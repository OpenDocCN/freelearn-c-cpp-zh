- en: 2\. Building Quality Object-Oriented Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.构建高质量的面向对象代码
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how to simplify complex logic using Object-Oriented
    Programming (OOP). You will start by creating classes and objects, before exploring
    the four pillars of OOP. You will then learn about some of the best practices
    in coding, known as the SOLID principles, and see how you can use C# 10 features
    to write effective code guided by these principles. By the end of this chapter,
    you will be able to write clean code using object-oriented design with C#.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用面向对象编程（OOP）简化复杂的逻辑。您将首先创建类和对象，然后探索面向对象编程的四大支柱。然后，您将了解一些最佳编码实践，即SOLID原则，并了解如何使用C#
    10功能编写受这些原则指导的有效代码。通过本章结束时，您将能够使用C#进行面向对象设计编写清晰的代码。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: How do people write software that is still maintainable even after many decades?
    What is the best way to model software around real-world concepts? The answer
    to both questions is Object Oriented Programming (OOP). OOP is a widely used paradigm
    in professional programming and is especially useful in enterprise settings.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 人们如何编写经过多年仍然易于维护的软件？围绕现实世界概念建模软件的最佳方法是什么？这两个问题的答案都是面向对象编程（OOP）。面向对象编程是专业编程中广泛使用的范式，尤其在企业环境中特别有用。
- en: OOP can be thought of as a bridge that connects real-world concepts and source
    code. A cat, for example, has certain defining properties, such as age, fur color,
    eye color, and name. The weather can be described using factors such as temperature
    and humidity. Both of these are real-world concepts that humans have identified
    and defined over time. In OOP, classes are what help in defining the logic of
    a program. When assigning concrete values to the properties of these classes,
    the result is an object. For example, using OOP, you can define a class for representing
    a room in a house, and then assign values to its properties (color and area) to
    create an object of that class.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程可以被认为是连接现实世界概念和源代码的桥梁。例如，猫具有一些定义属性，如年龄、毛色、眼睛颜色和名字。天气可以用温度和湿度等因素来描述。这些都是人类随着时间识别和定义的现实世界概念。在面向对象编程中，类是帮助定义程序逻辑的东西。当为这些类的属性分配具体值时，结果就是一个对象。例如，使用面向对象编程，您可以定义一个表示房子中的房间的类，然后为其属性（颜色和面积）分配值，以创建该类的对象。
- en: In *Chapter 1*, *Hello C#*, you learned how to use C# to write basic programs.
    In this chapter, you will see how you can design your code by implementing OOP
    concepts and using C# at its best.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*“你好C#”中，你学会了如何使用C#编写基本程序。在本章中，您将看到如何通过实现面向对象编程概念和充分利用C#来设计您的代码。
- en: Classes and Objects
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象
- en: A class is like a blueprint that describes a concept. An object, on the other
    hand, is the result you get after the application of this blueprint. For example,
    `weather` can be a class, and `25 degrees and` `cloudless` could refer to an object
    of this class. Similarly, you can have a class named `Dog`, while a four-year-old
    `Spaniel` can represent an object of the `Dog` class.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于描述概念的蓝图。另一方面，对象是应用此蓝图后获得的结果。例如，`weather`可以是一个类，`25度`和`无云`可以指代这个类的一个对象。同样，您可以有一个名为`Dog`的类，而四岁的`Spaniel`可以代表`Dog`类的一个对象。
- en: 'Declaring a class in C# is simple. It starts with the `class` keyword, followed
    by the class name and a pair of curly braces. To define a class named `Dog`, you
    can write the following code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中声明一个类很简单。它以`class`关键字开头，后跟类名和一对花括号。要定义一个名为`Dog`的类，您可以编写以下代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Right now, this class is just an empty skeleton. However, it can still be used
    to create objects by using the `new` keyword, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个类只是一个空的骨架。但是，仍然可以使用`new`关键字来创建对象，如下所示：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This creates an object named `dog`. Currently, the object is an empty shell,
    as it lacks properties. You will see in an upcoming section how to define properties
    for classes, but first, you will explore constructors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`dog`的对象。目前，该对象是一个空壳，因为它缺少属性。在接下来的部分中，您将看到如何为类定义属性，但首先，您将探索构造函数。
- en: Constructors
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: In C#, constructors are functions used to create new objects. You can also use
    them to set the initial values of an object. Like any function, a constructor
    has a name, takes arguments, and can be overloaded. A class must have at least
    one constructor, but if needed, it can have multiple constructors with different
    arguments. Even if you do not explicitly define a single constructor, a class
    will still have a default constructor–one that does not take any arguments or
    perform any actions but simply assigns memory to the newly created object and
    its fields.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，构造函数是用于创建新对象的函数。您还可以使用它们来设置对象的初始值。与任何函数一样，构造函数有一个名称，接受参数，并且可以重载。一个类必须至少有一个构造函数，但如果需要，它可以有多个具有不同参数的构造函数。即使您没有显式定义一个构造函数，类仍将具有默认构造函数-一个不接受任何参数或执行任何操作，而只是为新创建的对象及其字段分配内存的构造函数。
- en: 'Consider the following snippet, where a constructor for the `Dog` class is
    being declared:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，其中声明了`Dog`类的构造函数：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/H2lUF](https://packt.link/H2lUF).
    You can find the usage of the code at [https://packt.link/4WoSX](https://packt.link/4WoSX).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/H2lUF](https://packt.link/H2lUF)找到此示例中使用的代码。您可以在[https://packt.link/4WoSX](https://packt.link/4WoSX)找到代码的用法。
- en: 'If a method has the same name as the class and does not provide a `return`
    type, it is a constructor. Here, the snippet of the code is within a class named
    `Dog`. So, the constructor is within the specified line of code. Note that by
    defining this constructor explicitly, you hide the default constructor. If there
    is one or more such custom constructors, you will no longer be able to use a default
    constructor. Once the new constructor is called, you should see this message printed
    in the console: `"A Dog object has been created"`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法与类同名且没有提供 `return` 类型，则它是一个构造函数。在这里，代码片段在一个名为 `Dog` 的类中。因此，构造函数在指定的代码行内。请注意，通过显式定义此构造函数，您隐藏了默认构造函数。如果有一个或多个这样的自定义构造函数，您将不再能够使用默认构造函数。一旦调用新的构造函数，您应该在控制台中看到打印出此消息："已创建一个
    Dog 对象"。
- en: Fields and Class Members
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段和类成员
- en: 'You already know what a variable is: it has a type, a name, and a value, as
    you saw in *Chapter 1*, *Hello C#*. Variables can also exist in the class scope,
    and such a variable is called a field. Declaring a field is as simple as declaring
    a local variable. The only difference is the addition of a keyword at the start,
    which is the access modifier. For example, you can declare a field within the
    `Dog` class with the public access modifier, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道什么是变量：它有一个类型、一个名称和一个值，就像您在*第1章* *Hello C#*中看到的那样。变量也可以存在于类范围内，这样的变量称为字段。声明字段与声明局部变量一样简单。唯一的区别是在开头添加一个关键字，即访问修饰符。例如，您可以在
    `Dog` 类中声明一个具有公共访问修饰符的字段，如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This line of code states that the `Name` field, which is a string with the value
    `"unnamed"`, can be accessed publicly. Besides `public`, the other two main access
    modifiers in C# are `private` and `protected`, which you will look at them in
    detail later.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码说明了 `Name` 字段，它是一个值为 `"unnamed"` 的字符串，可以公开访问。除了 `public`，C# 中的另外两个主要访问修饰符是
    `private` 和 `protected`，您将在后面详细了解它们。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information regarding access modifiers at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers)找到有关访问修饰符的更多信息。
- en: Everything a class holds is called a class member. Class members can be accessed
    from outside of a class; however, such access needs to be granted explicitly using
    the `public` access modifier. By default, all members have a `private` access
    modifier.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 类所持有的一切都称为类成员。类成员可以从类的外部访问；但是，这种访问需要使用 `public` 访问修饰符明确授予。默认情况下，所有成员都具有 `private`
    访问修饰符。
- en: 'You can access class members by writing the object name followed by a dot (`.`)
    and the member name. For example, consider the following snippet in which two
    objects of the `Dog` class are being created:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过写对象名称后跟一个点(`.`)和成员名称来访问类成员。例如，考虑以下代码片段，其中创建了 `Dog` 类的两个对象：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, you can declare two independent variables, `sparky` and `ricky`. However,
    you haven''t explicitly assigned these names to the objects; note that these are
    only the variable names. To assign the names to the objects, you can write the
    following code using dot notation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以声明两个独立的变量，`sparky` 和 `ricky`。但是，您还没有明确地将这些名称分配给对象；请注意，这些只是变量名称。要将名称分配给对象，您可以使用点表示法编写以下代码：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can now have hands-on experience of creating classes and objects through
    an exercise.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过练习来亲身体验创建类和对象。
- en: 'Exercise 2.01: Creating Classes and Objects'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.01：创建类和对象
- en: Consider that there are two books, both by an author named `New Writer`. The
    first one, called `First Book`, was published by `Publisher 1`. There is no description
    available for this book. Similarly, the second one is named `Second Book` and
    was published by `Publisher 2`. It has a description that simply says, `"Interesting read"`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两本书，都是由名为 `New Writer` 的作者写的。第一本书名为 `First Book`，由 `Publisher 1` 出版。这本书没有可用的描述。类似地，第二本书名为
    `Second Book`，由 `Publisher 2` 出版。它有一个简单地说："有趣的阅读"的描述。
- en: In this exercise, you will model these books in code. The following steps will
    help you complete this exercise.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将在代码中对这些书进行建模。以下步骤将帮助您完成这个练习。
- en: 'Create a class called `Book`. Add fields for `Title`, `Author`, `Publisher`,
    `Description`, and the number of pages. You must print this information from outside
    the class, so make sure every field is `public`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Book` 的类。为 `Title`、`Author`、`Publisher`、`Description` 和页数添加字段。您必须从类的外部打印这些信息，因此请确保每个字段都是
    `public` 的：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a class named `Solution`, with the `Main` method. As you saw in *Chapter
    1*, *Hello C#*, this class with the `Main` method is the starting point of your application:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Solution` 的类，其中包含 `Main` 方法。正如您在*第1章* *Hello C#*中看到的那样，这个带有 `Main` 方法的类是您应用程序的起点：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the `Main` method, create an object for the first book and set the values
    for the fields, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内，为第一本书创建一个对象，并设置字段的值，如下所示：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, a new object named `book1` is created. Values are assigned to different
    fields by writing dot (`.`) followed by the field name. The first book does not
    have a description, so you can omit the field `book1.Description`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了一个名为 `book1` 的新对象。通过写点(`.`)后跟字段名称，为不同的字段分配值。第一本书没有描述，因此您可以省略字段 `book1.Description`。
- en: 'Repeat this step for the second book. For this book, you need to set a value
    for the `Description` field as well:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此步骤以创建第二本书。对于这本书，您还需要为 `Description` 字段设置一个值：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In practice, you will rarely see fields with public access modifiers. Data mutates
    easily, and you might not want to leave your program open to external changes
    after initialization.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，您很少会看到具有公共访问修饰符的字段。数据很容易变异，您可能不希望在初始化后让程序对外部更改开放。
- en: 'Inside the `Solution` class, create a method named `Print`, which takes a `Book`
    object as an argument and prints all fields and their values. Use string interpolation
    to concatenate book information and print it to the console using `Console.WriteLine()`,
    as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Solution`类中，创建一个名为`Print`的方法，该方法以`Book`对象作为参数，并打印所有字段及其值。使用字符串插值将书籍信息连接起来，并使用`Console.WriteLine()`将其打印到控制台，如下所示：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the `Main` method, call the `Print` method for `book1` and `book2`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中，调用`book1`和`book2`的`Print`方法：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Upon running this code, you will see the following output on the console:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，您将在控制台上看到以下输出：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/MGT9b](https://packt.link/MGT9b).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此练习中使用的代码[https://packt.link/MGT9b](https://packt.link/MGT9b)。
- en: In this exercise, you saw how to use fields and class members are used in simple
    programs. Now proceed to know about reference types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您看到了如何在简单程序中使用字段和类成员。现在继续了解引用类型。
- en: Reference Types
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型
- en: 'Suppose you have an object and the object is not created, just declared, as
    follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个对象，该对象尚未创建，只是声明如下：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What would happen if you tried accessing its `Name` value? Calling `speedy.Name`
    would throw a `NullReferenceException` exception because `speedy` is yet to be
    initialized. Objects are reference types, and their default value is null until
    initialized. You have already worked with value types, such as `int`, `float`,
    and `decimal`. Now you need to grasp that there are two major differences between
    value and reference types.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试访问其“Name”值会发生什么？调用`speedy.Name`将抛出`NullReferenceException`异常，因为`speedy`尚未初始化。对象是引用类型，它们的默认值是null，直到初始化。您已经使用过值类型，比如`int`、`float`和`decimal`。现在您需要了解值类型和引用类型之间的两个主要区别。
- en: Firstly, value types allocate memory on the stack, whereas reference types allocate
    memory on the heap. The stack is a temporary place in memory. As the name implies,
    in a stack, blocks of memory are stacked on top of each other. When you call a
    function, all local function variables will end up on a single block of the stack.
    If you call a nested function, the local variables of that function will be allocated
    on another block of the stack.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，值类型在堆栈上分配内存，而引用类型在堆上分配内存。堆栈是内存中的临时位置。顾名思义，在堆栈中，内存块被堆叠在彼此之上。当您调用一个函数时，所有局部函数变量都将最终位于堆栈的一个单一块上。如果您调用一个嵌套函数，该函数的局部变量将分配在堆栈的另一个块上。
- en: In the following figure, you can see which parts of code will allocate memory
    in the stack during execution, and which will do so in the heap. Method calls
    (1, 8, 10) and local variables (2, 4) will be stored in the stack. Objects (3,
    5) and their members (6) will be stored on the heap. Stacks use the Push method
    to allocate data, and Pop to deallocate it. When memory is allocated, it comes
    on top of the stack. When it is deallocated, it is removed from the top as well.
    You deallocate memory from the stack as soon as you leave the scope of a method
    (8, 10, 11). Heap is much more random, and Garbage Collector (GC) automatically
    (unlike some other languages, where you need to do it yourself), deallocates memory.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，您可以看到代码的哪些部分在执行过程中将在堆栈中分配内存，哪些部分将在堆中分配内存。方法调用（1、8、10）和局部变量（2、4）将存储在堆栈中。对象（3、5）及其成员（6）将存储在堆中。堆栈使用Push方法来分配数据，并使用Pop来释放它。当内存被分配时，它位于堆栈的顶部。当它被释放时，它也从顶部移除。一旦离开方法的范围（8、10、11），就会从堆栈中释放内存。堆要随机得多，垃圾收集器（GC）会自动（不像其他一些语言，需要自己做）释放内存。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: GC is a massive topic in itself. If you want to find out more, please refer
    to the official Microsoft documentation at [https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: GC本身就是一个庞大的主题。如果您想了解更多，请参阅微软官方文档[https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals)。
- en: '![Figure 2.1: Stack and heap comparison'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1：堆栈和堆比较'
- en: '](img/B16835_02_01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_02_01.jpg)'
- en: 'Figure 2.1: Stack and heap comparison'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：堆栈和堆比较
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you make too many nested calls, you will run into a `StackoverflowException`
    exception because the stack ran out of memory. Freeing up memory on the stack
    is just a matter of exiting from a function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您进行太多的嵌套调用，您将遇到`StackoverflowException`异常，因为堆栈内存不足。释放堆栈上的内存只是退出函数的问题。
- en: The second difference is that, when value types are passed to a method, their
    value is copied, while for reference types, only the reference is copied. This
    means that the reference type object's state is modifiable inside a method, unlike
    a value type, because a reference is simply the address of an object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是，当值类型传递给方法时，它们的值被复制，而对于引用类型，只有引用被复制。这意味着引用类型对象的状态在方法内是可修改的，不像值类型，因为引用只是对象的地址。
- en: 'Consider the following snippet. Here, a function named `SetTo5` sets the value
    of the number to `5`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段。这里，一个名为`SetTo5`的函数将数字的值设置为`5`：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, consider the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下代码：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should result in the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该导致以下输出：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you run this code, you find that the printed value of `a` is still `2` and
    not `5`. This is because `a` is a value type that passed the value `2`, and therefore
    its value is copied. Inside a function, you never work with the original; a copy
    is always made.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此代码，您会发现`a`的打印值仍然是`2`而不是`5`。这是因为`a`是一个传递值`2`的值类型，因此它的值被复制。在函数内部，您永远不会使用原始值；总是会进行复制。
- en: 'What about reference types? Suppose you add a field named `Owner` inside the
    `Dog` class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那引用类型呢？假设您在`Dog`类中添加一个名为`Owner`的字段：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a function, `ResetOwner`, that sets the value of the `Owner` field for
    an object to `None`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`ResetOwner`的函数，将对象的`Owner`字段的值设置为`None`：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, suppose the following code is executed:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设执行以下代码：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should result in the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该导致以下输出：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/gj164](https://packt.link/gj164).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/gj164](https://packt.link/gj164)找到本示例使用的代码。
- en: If you try running this snippet of code yourself, you will first see the name
    `speedy` on one line and then `None` printed on another. This would change the
    dog's name, and the changes would remain outside the function. This is because
    Dog is a class, and a class is a reference type. When passed to a function, a
    copy of a reference is made. However, a copy of a reference points to the whole
    object, and therefore the changes that are made remain outside as well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行这段代码片段，你会先看到一行上的名字`speedy`，然后在另一行上打印出`None`。这将改变狗的名字，并且这些改变将保留在函数外部。这是因为Dog是一个类，类是一个引用类型。当传递给一个函数时，会创建一个引用的副本。然而，引用的副本指向整个对象，因此所做的更改也会保留在外部。
- en: 'It might be confusing to hear that you pass a copy of a reference. How can
    you be sure you are working with a copy? To learn this, consider the following function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 听到你传递引用的副本可能会让人感到困惑。你怎么能确定你正在使用一个副本呢？为了了解这一点，考虑以下函数：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, creating a new object creates a new reference. If you change the value
    of a reference type, you are working with a completely different object. It may
    be one that looks the same but is stored in a completely different place in memory.
    Creating an object for a passed parameter will not affect anything outside the
    object. Though this may sound potentially useful, you should generally avoid doing
    this as it can make code difficult to comprehend.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建一个新对象会创建一个新的引用。如果你改变引用类型的值，你实际上是在使用一个完全不同的对象。它可能看起来一样，但存储在内存中的位置完全不同。为传递的参数创建一个对象不会影响对象外部的任何东西。虽然这可能听起来有用，但通常应该避免这样做，因为它会使代码难以理解。
- en: Properties
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: The `Dog` class has one flaw. Logically, you wouldn't want the name of a dog
    to be changed once it is assigned. However, as of now, there is nothing that prevents
    changing it. Think about the object from the perspective of what you can do with
    it. You can set the name of a dog (`sparky.Name = "Sparky"`) or you can get it
    by calling `sparky.Name`. However, what you want is a read-only name that can
    be set just once.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dog`类有一个缺陷。从逻辑上讲，你不希望一只狗的名字在分配后被改变。然而，目前还没有任何东西可以阻止它被改变。从你可以对对象做什么的角度来考虑这个对象。你可以设置一只狗的名字（`sparky.Name
    = "Sparky"`），或者通过调用`sparky.Name`来获取它。然而，你想要的是一个只读的名字，只能设置一次。'
- en: Most languages take care of this through setter and getter methods. If you add
    the `public` modifier to a field, this means that it can be both retrieved (read)
    and modified (written). It isn't possible to allow just one of these actions.
    However, with setters and getters, you can restrict both read and write access.
    In OOP, restricting what can be done with an object is key to ensuring data integrity.
    In C#, instead of setter and getter methods, you can use properties.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言通过setter和getter方法来处理这个问题。如果给一个字段添加`public`修饰符，这意味着它既可以被检索（读取）又可以被修改（写入）。不可能只允许其中一个操作。然而，通过setter和getter，你可以限制读和写访问。在面向对象编程中，限制对象的操作是确保数据完整性的关键。在C#中，你可以使用属性来代替setter和getter方法。
- en: 'In OOP languages (for example Java), to set or get the values of a name, you
    would write something like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程语言（例如Java）中，要设置或获取名字的值，你会写类似于这样的代码：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In C#, it is as simple as the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，它就是这么简单的：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is a property, which is nothing but a method that reads like a field.
    There are two types of properties: getters and setters. You can perform both read
    and write operations with them. From the preceding code, if you remove `get`,
    it will become write-only, and if you remove `set`, it will become read-only.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个属性，实际上就是一个读起来像字段的方法。属性有两种类型：获取器和设置器。你可以用它们执行读和写操作。从前面的代码中，如果你移除`get`，它将变成只写，如果你移除`set`，它将变成只读。
- en: 'Internally, the property includes a setter and a getter method with a backing
    field. A backing field is simply a private field that stores a value, and getter
    and setter methods work with that value. You can write custom getters and setters
    as well, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，属性包括一个带有后备字段的setter和getter方法。后备字段只是一个存储值的私有字段，getter和setter方法与该值一起工作。你也可以编写自定义的getter和setter，如下所示：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding snippet, the `Owner` property shows what the default getter
    and setter methods would look like for the `Dog` class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，`Owner`属性展示了`Dog`类的默认getter和setter方法的样子。
- en: 'Just like other members, individual parts of a property (either getter or setter)
    can have their own access modifier, like the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他成员一样，属性的各个部分（getter或setter）可以有自己的访问修饰符，如下所示：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this case, the getter is `public`, and the setter is `private`. All parts
    of the property (getter, setter, or both, as defined) take the access modifier
    from the property (`Name`, in this case) unless explicitly specified otherwise
    (as in the case of `private` set). If you do not need to set a name, you can get
    rid of the setter. If you need a default value, you can write the code for this
    as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，getter是`public`，setter是`private`。属性的所有部分（getter、setter或两者，如定义的那样）都从属性（在这种情况下是`Name`）中获取访问修饰符，除非另有明确规定（如`private`
    set的情况）。如果不需要设置名字，可以摆脱setter。如果需要默认值，可以编写以下代码：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This piece of code means that the `Name` field is read-only. You can set the
    name only through a constructor. Note that this is not the same as a `private`
    set because the latter means you can still change the name within the `Dog` class
    itself. If no setter is provided (as is the case here), you can set the value
    in only one place, the constructor.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码意味着`Name`字段是只读的。你只能通过构造函数设置名字。请注意，这与`private` set不同，因为后者意味着你仍然可以在`Dog`类内部更改名字。如果没有提供setter（就像这里的情况一样），你只能在一个地方设置值，那就是构造函数。
- en: 'What happens internally when you create a read-only property? The following
    code is generated by the compiler:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个只读属性时，内部会发生什么？编译器生成以下代码：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This shows that getter and setter properties are simply methods with a backing
    field. It is important to note that, if you have a property called `Name`, the
    `set_Name()` and `get_Name()` methods will be reserved because that's what the
    compiler generates internally.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明getter和setter属性只是带有后备字段的方法。重要的是要注意，如果您有一个名为`Name`的属性，那么`set_Name()`和`get_Name()`方法将被保留，因为这是编译器在内部生成的。
- en: You may have noticed a new keyword in the previous snippet, `readonly`. It signifies
    that the value of a field can only be initialized once—either during declaration
    or in a constructor.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个片段中，您可能已经注意到了一个新的关键字`readonly`。它表示字段的值只能在声明时或在构造函数中初始化一次。
- en: 'Returning a backing field with a property may seem redundant sometimes. For
    example, consider the next snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用属性返回后备字段可能看起来有些多余。例如，考虑下一个片段：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This code snippet is a custom property. When a getter or a setter is more than
    just a basic return, you can write the property in this way to add custom logic
    to it. This property, without affecting the original name of a dog, will prepend
    `Dog''s name is` before returning the name. You can make this more concise using
    expression-bodied property syntax, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段是一个自定义属性。当getter或setter不仅仅是基本返回时，您可以以这种方式编写属性，以向其添加自定义逻辑。这个属性，在不影响狗的原始名称的情况下，将在返回名称之前添加`Dog's
    name is`。您可以使用表达式主体属性语法使其更加简洁，如下所示：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code does the same thing as the previous code; the `=>` operator indicates
    that it is a read-only property, and you return a value that is specified on the
    right side of the `=>` operator.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与上一段代码做了同样的事情；`=>`运算符表示它是一个只读属性，并且您返回的值是`=>`运算符右侧指定的值。
- en: How do you set the initial value if there is no setter? The answer to that is
    a constructor. In OOP, a constructor serves one purpose—that is, setting the initial
    values of fields. Using a constructor is great for preventing the creation of
    objects in an invalid state.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有setter，您如何设置初始值？答案是构造函数。在面向对象编程中，构造函数有一个目的——那就是设置字段的初始值。使用构造函数非常适合防止以无效状态创建对象。
- en: 'To add some validation to the `Dog` class, you can write the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要向`Dog`类添加一些验证，您可以编写以下代码：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code you have just written will prevent an empty name from being passed
    when creating a `Dog` instance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚编写的代码将阻止在创建`Dog`实例时传递空名称。
- en: 'It is worth mentioning that within a class, you have access to the object itself
    that will be created. It might sound confusing, but it should make sense with
    this example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，在类内部，您可以访问将要创建的对象本身。这可能听起来有点混乱，但通过这个例子应该会有所启发：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `this` keyword is most often used to clear the distinction between class
    members and arguments. `this` refers to the object that has just been created,
    hence, `this.name` refers to the name of that object and `name` refers to the
    passed parameter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字通常用于清除类成员和参数之间的区别。`this`指的是刚刚创建的对象，因此，`this.name`指的是该对象的名称，而`name`指的是传递的参数。'
- en: 'Creating an object of the `Dog` class, and setting the initial value of a name,
    can now be simplified as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建`Dog`类的对象，并设置名称的初始值，可以简化如下：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You still have a private setter, meaning the property that you have is not entirely
    read-only. You can still change the value of a name within the class itself. However,
    fixing that is quite easy; you can simply remove the setter and it will become
    truly read-only.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然有一个私有的setter，这意味着您拥有的属性并非完全只读。您仍然可以在类本身内部更改名称的值。然而，修复这个问题非常容易；您只需删除setter，它就会变成真正的只读。
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [http://packt.link/hjHRV](http://packt.link/hjHRV).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://packt.link/hjHRV](http://packt.link/hjHRV)找到本示例使用的代码。
- en: Object Initialization
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象初始化
- en: 'Often, a class has read and write properties. Usually, instead of setting the
    property values via a constructor, they are assigned after the creation of an
    object. However, in C# there is a better way—object initialization. This is where
    you create a new object and set the mutable (read and write) field values right
    away. If you had to create a new object of the `Dog` class and set the value of
    `Owner` for this object to `Tobias`, you could add the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个类有读写属性。通常情况下，不是通过构造函数设置属性值，而是在创建对象后分配。然而，在C#中有一种更好的方法——对象初始化。这是您创建一个新对象并立即设置可变（读写）字段值的地方。如果您必须创建一个`Dog`类的新对象，并为该对象的`Owner`设置为`Tobias`，您可以添加以下代码：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This can be done using object initialization as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过对象初始化来完成这个操作，如下所示：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Setting initial properties like this when they are not a part of a constructor
    is generally more concise. The same applies to arrays and other collection types.
    Suppose you had two objects of the `Dog` class, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当它们不是构造函数的一部分时，设置初始属性通常更加简洁。对数组和其他集合类型也是如此。假设您有两个`Dog`类的对象，如下所示：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In such a case, one way of creating an array would be as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，创建数组的一种方式如下：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, instead of this, you can just add the following code, which is more
    concise:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以简单地添加以下代码，这更加简洁：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In C# 10, you can simplify object initialization without providing the type,
    if it can be inferred from the declaration, as in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 10中，您可以简化对象初始化，而无需提供类型，如果可以从声明中推断出类型，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Comparing Functions and Methods
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较函数和方法
- en: Up until now, you might have seen the terms—function and method—used quite often,
    almost interchangeably. Now proceed to gain further insight into functions and
    methods. A function is a block of code that you can call using its name and some
    input. A method is a function that exists within a class.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能经常看到术语——函数和方法——几乎可以互换使用。现在继续深入了解函数和方法。函数是一段可以使用其名称和一些输入调用的代码块。方法是存在于类中的函数。
- en: However, in C#, you cannot have functions outside of a class. Therefore, in
    C#, every function is a method. Many languages, especially non-OOP languages,
    have only some functions that can be called methods (for example, JavaScript).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在C#中，您不能在类外部有函数。因此，在C#中，每个函数都是一个方法。许多语言，特别是非面向对象的语言，只有一些可以称为方法的函数（例如JavaScript）。
- en: 'The behavior of a class is defined using methods. You have already defined
    some behavior for the `Dog` class, that is, getting its name. To finish implementing
    the behaviors for this class, you can implement some real-world parallels, such
    as sitting and barking. Both methods will be called from the outside:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类的行为是使用方法定义的。您已经为`Dog`类定义了一些行为，即获取其名称。要完成此类的行为实现，您可以实现一些现实世界的类比，例如坐下和吠叫。这两种方法都将从外部调用：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can call both methods like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以这样调用这两种方法：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In most cases, it is preferable to avoid exposing data publicly, so you should
    only ever expose functions publicly. Here, you might be wondering, What about
    properties? Properties are just getter and setter functions; they work with data
    but aren't data themselves. You should avoid **exposing** data publicly directly,
    for the same reason you lock your doors, or carry your phone in a case. If data
    were public, everyone could access it without any restrictions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，最好避免公开数据，因此您应该只公开函数。在这里，您可能会想知道，属性呢？属性只是获取器和设置器函数；它们处理数据，但并不是数据本身。您应该避免直接公开数据，原因与您锁门或将手机放在套子中的原因相同。如果数据是公开的，每个人都可以无限制地访问它。
- en: Also, data should not change when the program requires it to be constant. A
    method is a mechanism that ensures that an object is not used in invalid ways,
    and if it is, it's well handled.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当程序要求数据保持不变时，数据不应更改。方法是一种确保对象不以无效方式使用的机制，如果是，它会被很好地处理。
- en: What if you need to validate the fields consistently throughout the application?
    Again, properties, that is, getter and setter methods, can help with this. You
    can limit what you can do with data and add validation logic to it. Properties
    help you be in full control of how you can get and set data. Properties are handy,
    but it's important to use them with discretion. If you want to do something complex,
    something that needs extra computing, it is preferable to use a method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在整个应用程序中一致地验证字段，那么属性，即获取器和设置器方法，可以帮助实现这一点。您可以限制对数据的操作，并向其添加验证逻辑。属性帮助您完全控制如何获取和设置数据。属性很方便，但重要的是要谨慎使用它们。如果要做一些复杂的事情，需要额外的计算，最好使用方法。
- en: For example, imagine that you have a class for an inventory made up of items,
    each having some weight. Here, it might make sense to have a property to return
    the heaviest item. If you chose to do so through a property (call it `MaxWeight`),
    you might get unexpected results; getting the heaviest item would require iterating
    through a collection of all items and finding the maximum by weight. This process
    is not as fast as you would expect. In fact, in some cases, it might even throw
    an error. Properties should have simple logic, otherwise working with them might
    yield unexpected results. Therefore, when the need for compute-heavy properties
    arises, consider refactoring them to a method. In this case, you would refactor
    the `MaxWeight` property into the `GetMaxWeight` method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有一个库存类，由物品组成，每个物品都有一些重量。在这里，可能有一个属性返回最重的物品。如果您选择通过属性（称为`MaxWeight`）这样做，您可能会得到意想不到的结果；获取最重的物品将需要遍历所有物品的集合，并按重量找到最大值。这个过程不像你期望的那样快。事实上，在某些情况下，它甚至可能会抛出错误。属性应该有简单的逻辑，否则与它们一起工作可能会产生意想不到的结果。因此，当需要计算密集型属性时，考虑将它们重构为方法。在这种情况下，您将`MaxWeight`属性重构为`GetMaxWeight`方法。
- en: Properties should be avoided for returning results of complex calculations,
    as calling a property could be expensive. Getting or setting the value of a field
    should be straightforward. If it becomes expensive, it should no longer be treated
    as property.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 应避免使用属性返回复杂计算的结果，因为调用属性可能很昂贵。获取或设置字段的值应该是直接的。如果变得昂贵，它就不应该再被视为属性。
- en: An Effective Class
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个有效的类
- en: The `Dog` class models a `dog` object; therefore, it can be called a model.
    Some developers prefer to have a strict separation between data and logic. Others
    try to put as much logic in a model as possible, so long as it is self-contained.
    There is no right or wrong way here. It all depends on the context you are working
    with.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dog`类模拟了一个`dog`对象；因此，它可以被称为模型。一些开发人员更喜欢在数据和逻辑之间有严格的分离。其他人则尽可能多地将逻辑放入模型中，只要它是自包含的。这里没有对与错的方法。这一切都取决于您所处理的上下文。'
- en: Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This discussion is outside the scope of this chapter, but if you would like
    to know more, you can refer to the discussion on Domain-Driven Design (DDD) at
    [https://martinfowler.com/bliki/DomainDrivenDesign.html](https://martinfowler.com/bliki/DomainDrivenDesign.html).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个讨论超出了本章的范围，但如果您想了解更多，可以参考[https://martinfowler.com/bliki/DomainDrivenDesign.html](https://martinfowler.com/bliki/DomainDrivenDesign.html)上关于领域驱动设计（DDD）的讨论。
- en: 'It is hard to pinpoint what an effective class looks like. However, when deciding
    whether a method fits better in class A or class B, try asking yourself these
    questions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 很难准确描述一个有效的类是什么样的。但是，在决定方法更适合于A类还是B类时，尝试问自己以下问题：
- en: Would someone, who is not a programmer, know that you are talking about the
    class? Is it a logical representation of a real-world concept?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是程序员的人会知道您在谈论类吗？它是对现实世界概念的逻辑表示吗？
- en: How many reasons does the class have to change? Is it just one or are there
    more reasons?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类有多少个原因需要更改？只有一个还是有更多原因？
- en: Is private data tightly related to public behavior?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有数据是否与公共行为紧密相关？
- en: How often does the class change?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类有多经常更改？
- en: How easy is it to break the code?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码容易出错吗？
- en: Does the class do something by itself?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类自己是否做了什么？
- en: High cohesion is a term used to describe a class that has all its members strongly
    related, not only semantically, but logically as well. In contrast, a low cohesion
    class has loosely related methods and fields that probably could have a better
    place. Such a class is inefficient because it changes for multiple reasons and
    you cannot expect to look for anything inside it, as it simply has no strong logical
    meaning.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 高内聚性是一个用来描述一个类的术语，它的所有成员不仅在语义上，而且在逻辑上都是强相关的。相比之下，低内聚性的类具有松散相关的方法和字段，这些方法和字段可能有更好的位置。这样的类是低效的，因为它因多种原因而改变，你不能期望在其中查找任何东西，因为它根本没有强烈的逻辑意义。
- en: 'For example, a part of a `Computer` class could look like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Computer`类的一部分可能如下所示：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, `Computer` and `keys` are not related at the same level. There could
    be another class that better suits the `Key` class, that is `Keyboard`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Computer`和`keys`并不是在同一级别相关的。可能有另一个类更适合`Key`类，那就是`Keyboard`：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/FFcDa](https://packt.link/FFcDa).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/FFcDa](https://packt.link/FFcDa)找到此示例使用的代码。
- en: A keyboard is directly related to keys, just as it is directly related to a
    computer. Here, both `Keyboard` and the `Computer` class have high cohesion because
    the dependencies have a stable logical place. You can now learn more about it
    through an exercise.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘与键直接相关，就像它与计算机直接相关一样。在这里，`Keyboard`和`Computer`类都具有高内聚性，因为依赖关系有一个稳定的逻辑位置。现在，你可以通过练习更多地了解它。
- en: 'Exercise 2.02: Comparing the Area Occupied by Different Shapes'
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.02：比较不同形状占用的面积
- en: You have two sections of a backyard, one with circular tiles and the other with
    rectangular tiles. You would like to deconstruct one section of the backyard,
    but you are not sure which one it should be. Obviously, you want as little mess
    as possible and have decided to pick the section that occupies the least area.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两个后院的区域，一个有圆形瓷砖，另一个有矩形瓷砖。你想要拆除后院的一个区域，但你不确定应该拆除哪一个。显然，你希望尽可能少地弄脏，因此决定选择占用面积最小的区域。
- en: Given two arrays, one for different sized rectangular tiles and the other for
    different-sized circular tiles, you need to find which section to deconstruct.
    This exercise aims to output the name of the section occupying less area, that
    is, `rectangular` or  `circular`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个数组，一个是不同尺寸的矩形瓷砖，另一个是不同尺寸的圆形瓷砖，你需要找出哪个区域要拆除。这个练习旨在输出占用面积较小的区域的名称，即`rectangular`或`circular`。
- en: 'Perform the following steps to do so:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成这个过程：
- en: 'Create a `Rectangle` class as follows. It should have fields for `width`, `height`,
    and `area`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Rectangle`类如下。它应该有`width`、`height`和`area`字段：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, `_width` and `_height` have been made immutable, using the `readonly`
    keyword. The type chosen is `double` because you will be performing `math` operations.
    The only property that is exposed publicly is `Area`. It will return a simple
    calculation: the product of width and height. The `Rectangle` is immutable, so
    all it needs is to be passed once through a constructor and it remains constant thereafter.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用`readonly`关键字使`_width`和`_height`成为不可变的。所选的类型是`double`，因为你将执行`math`操作。唯一公开的属性是`Area`。它将返回一个简单的计算：宽度和高度的乘积。`Rectangle`是不可变的，因此它只需要通过构造函数传递一次，之后保持不变。
- en: 'Similarly, create a `Circle` class as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，创建一个`Circle`类如下：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `Circle` class is similar to `Rectangle` class, except that instead of width
    and height, it has `radius`, and the `Area` calculation uses a different formula.
    The constant `PI` has been used, which can be accessed from the `Math` namespace.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle`类与`Rectangle`类类似，只是它有`radius`而不是宽度和高度，并且`Area`的计算使用了不同的公式。使用了常量`PI`，可以从`Math`命名空间中访问。'
- en: 'Create a `Solution` class with a skeleton method named `Solve`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Solve`的骨架方法的`Solution`类：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, the `Solution` class demonstrates how the code works. For now, there are
    three constants based on the requirements (which section is bigger? rectangular
    or circular, or are they equal?). Also, the flow will be to calculate the total
    area of rectangles, then of circles and finally return the bigger.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Solution`类演示了代码的工作原理。目前，有三个基于要求的常量（哪个区域更大？矩形还是圆形，或者它们相等？）。此外，流程将是先计算矩形的总面积，然后是圆形的总面积，最后返回更大的那个。
- en: Before you can implement the solution, you must first create side methods for
    calculating the total area of the rectangular section, calculating the total area
    of the circular section, and comparing the two. You will do this over the next
    few steps.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现解决方案之前，你必须首先创建用于计算矩形部分的总面积、计算圆形部分的总面积和比较两者的辅助方法。你将在接下来的几个步骤中完成这些工作。
- en: 'Inside `Solution` class, add a method to calculate the total area of the rectangular
    section:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Solution`类中，添加一个方法来计算矩形部分的总面积：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This method goes through all the rectangles, gets the area of each, and adds
    it to the total sum.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法遍历所有矩形，获取每个矩形的面积，并将其添加到总和中。
- en: 'Similarly, add a method to calculate the total area of the circular section:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，添加一个方法来计算圆形部分的总面积：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, add a method to get the bigger area, as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个获取更大面积的方法，如下所示：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This snippet contains the most interesting part. In most languages, numbers
    with a decimal point are not accurate. In fact, in most cases, if a and b are
    floats or doubles, it is likely that they will never be equal. Therefore, when
    comparing such numbers, you must consider precision.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含了最有趣的部分。在大多数语言中，带有小数点的数字是不准确的。实际上，在大多数情况下，如果a和b是浮点数或双精度浮点数，它们可能永远不会相等。因此，在比较这样的数字时，你必须考虑精度。
- en: In this code, you have defined the margin, to have an acceptable range of accuracy
    of your comparison for when the numbers are considered equal (for example, 0.001
    and 0.0011 will be equal in this case since the margin is 0.01). After this, you
    can do a regular comparison and return the value for whichever section has the
    biggest area.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，你定义了边距，以便在数字被认为相等时有一个可接受的比较精度范围（例如，0.001和0.0011在这种情况下将是相等的，因为边距是0.01）。之后，你可以进行常规比较，并返回具有最大面积的部分的值。
- en: 'Now, create the `Main` method, as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建`Main`方法，如下所示：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, four sets of shapes are created for comparison. `compare1` has two empty
    sections, meaning they should be equal. `compare2` has a rectangle and no circles,
    so the rectangle is bigger. `compare3` has a circle and no rectangle, so the circles
    are bigger. Finally, `compare4` has both rectangles and circles, but the total
    area of the circles is bigger. You used string interpolation inside `Console.WriteLine`
    to print the results.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了四组形状进行比较。`compare1`有两个空的部分，意味着它们应该是相等的。`compare2`有一个矩形和没有圆，所以矩形更大。`compare3`有一个圆和没有矩形，所以圆更大。最后，`compare4`既有矩形又有圆，但圆的总面积更大。你在`Console.WriteLine`中使用了字符串插值来打印结果。
- en: 'Run the code. You should see the following being printed to the console:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。你应该看到以下内容被打印到控制台上：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/tfDCw](https://packt.link/tfDCw).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/tfDCw](https://packt.link/tfDCw)找到此练习中使用的代码。
- en: What if you did not have objects? What would the section be made of in that
    case? For a circle, it might be viable to just pass radii, but for rectangles,
    you would need to pass another collinear array with widths and heights.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有对象会怎样？在这种情况下，部分将由什么组成？对于一个圆来说，可能只需传递半径，但对于矩形，你需要传递另一个共线数组，其中包括宽度和高度。
- en: Object-oriented code is great for grouping similar data and logic under one
    shell, that is, a class, and passing those class objects around. In this way,
    you can simplify complex logic through simple interaction with a class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的代码非常适合将类似的数据和逻辑分组在一个外壳下，也就是一个类，并传递这些类对象。通过与类的简单交互，你可以简化复杂的逻辑。
- en: You will now know about the four pillars of OOP.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将了解面向对象编程的四大支柱。
- en: The Four Pillars of OOP
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程的四大支柱
- en: Efficient code should be easy to grasp and maintain, and OOP strives to achieve
    such simplicity. The entire concept of object-oriented design is based on four
    main tenets, also known as the four pillars of OOP.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 高效的代码应该易于理解和维护，而面向对象编程致力于实现这种简单性。面向对象设计的整个概念基于四个主要原则，也被称为面向对象编程的四大支柱。
- en: Encapsulation
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: 'The first pillar of OOP is encapsulation. It defines the relationship between
    data and behavior, placed in the same shell, that is, a class. It refers to the
    need to expose only what is necessary and hide everything else. When you think
    about encapsulation, think about the importance of security for your code: what
    if you leak a password, return confidential data, or make an API key public? Being
    reckless often leads to damage that can be hard to fix.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的第一个支柱是封装。它定义了数据和行为之间的关系，放置在同一个外壳中，也就是一个类。它指的是只公开必要的内容，隐藏其他所有内容。当你考虑封装时，考虑一下对于你的代码来说安全性的重要性：如果你泄露了密码、返回了机密数据或者公开了API密钥会怎么样？鲁莽行事往往会导致难以修复的损害。
- en: Security is not just limited to protection from malicious intent, but also extends
    to preventing manual errors. Humans tend to make mistakes. In fact, the more options
    there are to choose from, the more mistakes they are likely to make. Encapsulation
    helps in that regard because you can simply limit the number of options available
    to the person who will use the code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性不仅仅限于防止恶意意图，还包括防止手动错误。人们往往会犯错误。事实上，可供选择的选项越多，他们犯错的可能性就越大。封装有助于解决这个问题，因为你可以简单地限制将使用代码的人可用的选项数量。
- en: 'You should prevent all access by default, and only grant explicit access when
    necessary. For example, consider a simplified `LoginService` class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该默认阻止所有访问，只有在必要时才授予显式访问权限。例如，考虑一个简化的`LoginService`类：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This class has two `private` fields: `_usernames` and `_passwords`. The key
    point to note here is that neither passwords nor usernames are accessible to the
    public, but you can still achieve the required functionality by exposing just
    enough logic publicly, through the `Login` method.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个`private`字段：`_usernames`和`_passwords`。这里需要注意的关键点是，密码和用户名都不对外公开，但你仍然可以通过`Login`方法公开足够的逻辑来实现所需的功能。
- en: Note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find this code used for this example at [https://packt.link/6SO7a](https://packt.link/6SO7a).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/6SO7a](https://packt.link/6SO7a)找到此示例中使用的代码。
- en: Inheritance
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: A police officer can arrest someone, a mailman delivers mail, and a teacher
    teaches one or more subjects. Each of them performs widely different duties, but
    what do they all have in common? In the context of the real world, they are all
    human. They all have a name, age, height, and weight. If you were to model each,
    you would need to make three classes. Each of those classes would look the same,
    other than one unique method for each. How could you express in code that they
    are all human?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一个警察可以逮捕某人，邮递员递送邮件，老师教授一个或多个科目。他们每个人都执行着完全不同的职责，但他们有什么共同之处呢？在现实世界的背景下，他们都是人类。他们都有姓名、年龄、身高和体重。如果你要对每个人建模，你需要创建三个类。这些类中的每一个看起来都是一样的，除了每个类有一个独特的方法。你如何在代码中表达他们都是人类呢？
- en: The key to solving this problem is inheritance. It allows you to take all the
    properties from a parent class and transfer them to its child class. Inheritance
    also defines an is-a relationship. A police officer, a mailman, and a teacher
    are all humans, and so you can use inheritance. You will now write this down in
    code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的关键是继承。它允许你从父类中获取所有属性并将它们传递给子类。继承还定义了一种is-a关系。警察、邮递员和老师都是人类，所以你可以使用继承。现在你要把这些写成代码。
- en: 'Create a `Human` class that has fields for `name`, `age`, `weight`, and `height`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个“人”类，其中包含“姓名”、“年龄”、“体重”和“身高”字段：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A mailman is a human. Therefore, the `Mailman` class should have all that a
    `Human` class has, but on top of that, it should have the added functionality
    of being able to deliver mail. Write the code for this as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 邮递员是一个人。因此，“邮递员”类应该拥有“人”类拥有的一切，但除此之外，它还应该具有能够投递邮件的附加功能。编写代码如下：
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, look closely at the `Mailman` class. Writing `class Mailman : Human` means
    that `Mailman` inherits from `Human`. This means that `Mailman` takes all the
    properties and methods from `Human`. You can also see a new keyword, `base`. This
    keyword is used to tell which parent constructor is going to be used when creating
    `Mailman`; in this case, `Human`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，仔细看看“邮递员”类。编写“class Mailman : Human”意味着“邮递员”继承自“人”。这意味着“邮递员”继承了“人”的所有属性和方法。你还可以看到一个新关键字，“base”。这个关键字用于告诉在创建“邮递员”时将使用哪个父构造函数；在这种情况下是“人”。'
- en: 'Next, create a class named `Mail` to represent the mail, containing a field
    for a message being delivered to an address:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为“Mail”的类来表示邮件，其中包含一个字段，用于将消息传递到地址：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Creating a `Mailman` object is no different than creating an object of a class
    that does not use inheritance.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 创建“邮递员”对象与创建不使用继承的类的对象没有任何不同。
- en: 'Create `mailman` and `mail` variables and tell the `mailman` to deliver the
    mail as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建“邮递员”和“邮件”变量，并告诉“邮递员”投递邮件如下：
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/w1bbf](https://packt.link/w1bbf).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/w1bbf](https://packt.link/w1bbf)找到此示例使用的代码。
- en: In the preceding snippet, you created `mailman` and `mail` variables. Then,
    you told the `mailman` to deliver the `mail`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你创建了“邮递员”和“邮件”变量。然后，你告诉“邮递员”投递“邮件”。
- en: 'Generally, a base constructor must be provided when defining a child constructor.
    The only exception to this rule is when the parent has a parameter-less constructor.
    If a base constructor takes no arguments, then a child constructor using a base
    constructor would be redundant and therefore can be ignored. For example, consider
    the following snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在定义子构造函数时必须提供基础构造函数。唯一的例外是当父类有一个无参数的构造函数时。如果基础构造函数不带参数，则使用基础构造函数的子构造函数将是多余的，因此可以忽略。例如，考虑以下代码片段：
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`A` has no custom constructors, so implementing `B` would not require a custom
    constructor either.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: “A”没有自定义构造函数，因此实现“B”也不需要自定义构造函数。
- en: In C#, only a single class can be inherited; however, you can have a multi-level
    deep inheritance. For example, you could have a child class for `Mailman` named
    `RegionalMailman`, which would be responsible for a single region. In this way,
    you could go deeper and have another child class for `RegionalMailman`, called
    `RegionalBillingMailman`, then `EuropeanRegionalBillingMailman`, and so on.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，只能继承一个类；但是，可以进行多级深度继承。例如，你可以为“邮递员”命名为“区域邮递员”的子类，该子类将负责一个地区。通过这种方式，你可以更深入地进行继承，为“区域邮递员”创建另一个子类，称为“区域结算邮递员”，然后是“欧洲区域结算邮递员”，依此类推。
- en: When using inheritance, it is important to know that even if everything is inherited,
    not everything is visible. Just like before, `public` members only will be accessible
    from a parent class. However, in C#, there is a special modifier, named `protected`,
    that works like the `private` modifier. It allows child classes to access `protected`
    members (just like `public` members) but prevents them from being accessed from
    the outside of the class (just like `private`).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用继承时，重要的是要知道即使一切都被继承，也不是一切都可见。就像以前一样，“public”成员只能从父类中访问。但是，在C#中，有一个特殊的修饰符，名为“protected”，它的作用类似于“private”修饰符。它允许子类访问“protected”成员（就像“public”成员一样），但阻止它们从类的外部访问（就像“private”一样）。
- en: Decades ago, inheritance used to be the answer to many problems and the key
    to code reuse. However, over time, it became apparent that using inheritance comes
    at a price, which is coupling. When you apply inheritance, you couple a child
    class with a parent. Deep inheritance stacks class scope all the way from parent
    to child. The deeper the inheritance, the deeper the scope. Deep inheritance (two
    or more levels deep) should be avoided for the same reason you avoid global variables—it
    is hard to know what comes from where and hard to control the state changes. This,
    in turn, makes the code difficult to maintain.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年前，继承曾经是许多问题的答案和代码重用的关键。然而，随着时间的推移，人们发现使用继承是有代价的，即耦合。当应用继承时，你将子类与父类耦合在一起。深度继承将类的范围一直堆叠到子类。继承越深，范围就越深。应该避免深度继承（两个或更多级深度），原因与避免全局变量相同——很难知道来自何处，很难控制状态变化。这反过来使得代码难以维护。
- en: 'Nobody wants to write duplicate code, but what is the alternative? The answer
    to that is composition. Just as a computer is composed of different parts, code
    should be composed of different parts as well. For example, imagine you are developing
    a 2D game and it has a `Tile` object. Some tiles contain a trap, and some tiles
    move. Using inheritance, you could write the code like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人想要编写重复的代码，但是替代方案是什么？答案是组合。就像计算机由不同的部分组成一样，代码也应该由不同的部分组成。例如，想象一下你正在开发一个2D游戏，它有一个“Tile”对象。一些瓷砖包含陷阱，一些瓷砖会移动。使用继承，你可以这样编写代码：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This approach works fine until you face more complex requirements. What if there
    are tiles that could both be a trap and move? Should you inherit from a moving
    tile and rewrite the `TrapTile` functionality there? Could you inherit both? As
    you have seen, you cannot inherit more than one class at a time, therefore, if
    you were to implement this using inheritance, you would be forced to both complicate
    the situation, and rewrite some code. Instead, you could think about what different
    tiles contain. `TrapTile` has a trap. `MovingTile` has a motor.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在面对更复杂的要求时效果很好。如果有一种瓷砖既可以是陷阱又可以移动怎么办？您应该从移动瓷砖继承并在那里重写`TrapTile`的功能吗？您可以同时继承吗？正如您所见，您不能一次继承多个类，因此，如果您要使用继承来实现这一点，您将被迫复杂化情况，并重写一些代码。相反，您可以考虑不同瓷砖包含的内容。`TrapTile`有一个陷阱。`MovingTile`有一个电机。
- en: Both represent tiles, but the extra functionality they each have should come
    from different components, and not child classes. If you wanted to make this a
    composition-based approach, you would need to refactor quite a bit.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都代表瓷砖，但它们各自具有的额外功能应来自不同的组件，而不是子类。如果您想要将其作为基于组合的方法，您需要进行相当大的重构。
- en: 'To solve this, keep the `Tile` class as-is:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，保持`Tile`类不变：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, add two components—Motor and Trap classes. Such components serve as logic
    providers. For now, they do nothing:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加两个组件——`Motor`和`Trap`类。这些组件作为逻辑提供者。目前，它们什么也不做：
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/espfn](https://packt.link/espfn).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/espfn](https://packt.link/espfn)找到此示例使用的代码。
- en: 'Next, you define a `MovingTile` class that has a single component, `_motor`.
    In composition, components rarely change dynamically. You should not expose class
    internals, so apply `private readonly` modifiers. The component itself can have
    a child class or change, and so should not be created from the constructor. Instead,
    it should be passed as an argument (see the highlighted code):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您定义一个`MovingTile`类，它有一个名为`_motor`的单个组件。在组合中，组件很少动态变化。您不应该暴露类的内部，因此应用`private
    readonly`修饰符。组件本身可以有一个子类或更改，因此不应该从构造函数中创建。相反，它应该作为参数传递（请参阅突出显示的代码）：
- en: '[PRE60]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that the `Move` method now calls `_motor.Move()`. That is the essence of
    composition; the class that holds composition often does nothing by itself. It
    just delegates the calls of logic to its components. In fact, even though this
    is just an example class, a real class for a game would look quite similar to
    this.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Move`方法现在调用了`_motor.Move()`。这就是组合的本质；持有组合的类通常本身不做任何事情。它只是将逻辑的调用委托给它的组件。实际上，即使这只是一个示例类，一个真正的游戏类看起来也会非常类似。
- en: 'You will do the same for `TrapTile`, except that instead of `Motor`, it will
    contain a `Trap` component:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您将为`TrapTile`做同样的事情，只是它将包含一个`Trap`组件，而不是`Motor`：
- en: '[PRE61]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, it''s time to create the `MovingTrapTile` class. It has two components
    that provide logic to the `Move` and `Damage` methods. Again, the two methods
    are passed as arguments to a constructor:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候创建`MovingTrapTile`类了。它有两个组件，分别为`Move`和`Damage`方法提供逻辑。同样，这两个方法作为参数传递给构造函数：
- en: '[PRE62]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/SX4qG](https://packt.link/SX4qG).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/SX4qG](https://packt.link/SX4qG)找到此示例使用的代码。
- en: It might seem that this class repeats some code from the other class, but the
    duplication is negligible, and the benefits are well worth it. After all, the
    biggest chunk of logic comes from the components themselves, and a repeated field
    or a call is not significant.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类似乎重复了另一个类的一些代码，但重复是微不足道的，而好处是非常值得的。毕竟，最大的逻辑块来自组件本身，重复的字段或调用并不重要。
- en: 'You may have noticed that you inherited `Tile`, despite not extracting it as
    a component for other classes. This is because `Tile` is the essence of all the
    classes that inherit it. No matter what type a tile is, it is still a tile. Inheritance
    is the second pillar of OOP. It is powerful and useful. However, it can be hard
    to get inheritance right, because in order to be maintainable, it truly needs
    to be very clear and logical. When choosing whether you should use inheritance,
    consider these factors:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，尽管没有将`Tile`作为其他类的组件提取出来，但您仍然继承了它。这是因为`Tile`是所有继承它的类的本质。无论瓷砖是什么类型，它仍然是一种瓷砖。继承是面向对象编程的第二支柱。它是强大且有用的。然而，要正确地使用继承可能很困难，因为为了可维护性，它确实需要非常清晰和合乎逻辑。在选择是否应该使用继承时，请考虑以下因素：
- en: Not deep (ideally single level).
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不深（理想情况下是单层）。
- en: Logical (is-a relation, as you saw in your tiles example).
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑的（是一个关系，就像您在瓷砖示例中看到的）。
- en: Stable and extremely unlikely for the relationship between classes to change
    in the future; not going to be modified often.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定且极不可能在未来类之间的关系发生变化；不会经常修改。
- en: Purely additive (child class should not use parent class members, except for
    a constructor).
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯添加（子类不应使用父类成员，除了构造函数）。
- en: If any one of these rules is broken, it is recommended to use composition instead
    of inheritance.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些规则中的任何一个被打破，建议使用组合而不是继承。
- en: Polymorphism
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态性
- en: The third pillar of OOP is polymorphism. To grasp this pillar, it is useful
    to look at the meaning of the word. `Thomas`. `Thomas` is both a human and a mailman.
    `Mailman` is the specialized form and `Human` is the generalized form for Thomas.
    However, you can interact with `Thomas` through either of the two forms.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的第三支柱是多态性。要理解这一支柱，有必要看一下这个词的含义。`Thomas`。`Thomas`既是一个人，也是一个邮递员。`Mailman`是`Thomas`的专用形式，`Human`是`Thomas`的通用形式。然而，您可以通过这两种形式与`Thomas`进行交互。
- en: If you do not know the jobs for every human, you can use an `abstract` class.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道每个人的工作，可以使用一个`abstract`类。
- en: 'An `abstract` class is a synonym for an incomplete class. This means that it
    cannot be initialized. It also means that some of its methods may not have an
    implementation if you mark them with the `abstract` keyword. You can implement
    this for the `Human` class as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`abstract`类是不完整类的同义词。这意味着它不能被初始化。这也意味着如果您用`abstract`关键字标记它们，它的一些方法可能没有实现。您可以为`Human`类实现如下：'
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You have created an abstract (incomplete) `Human` class here. The only difference
    from earlier is that you have applied the `abstract` keyword to the class and
    added a new `abstract` method, `public abstract void Work()`. You have also changed
    the constructor to protected so that it is accessible only from a child class.
    This is because it no longer makes sense to have it `public` if you cannot create
    an `abstract` class; you cannot call a `public` constructor. Logically, this means
    that the `Human` class, by itself, has no meaning, and it only gets meaning after
    you have implemented the `Work` method elsewhere (that is, in a child class).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您创建了一个抽象（不完整的）`Human`类。与之前的唯一区别是，您将`abstract`关键字应用于类，并添加了一个新的`abstract`方法`public
    abstract void Work()`。您还将构造函数更改为受保护的，以便只能从子类访问。这是因为如果您不能创建一个`abstract`类，那么将它设为`public`就不再有意义；您不能调用`public`构造函数。逻辑上讲，这意味着`Human`类本身没有意义，只有在其他地方实现了`Work`方法后（也就是在子类中）才有意义。
- en: 'Now, you will update the `Mailman` class. It does not change much; it just
    gets an additional method, that is, `Work()`. To provide an implementation for
    abstract methods, you must use the `override` keyword. In general, this keyword
    is used to change the implementation of an existing method inside a child class.
    You will explore this in detail later:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将更新`Mailman`类。它并没有太多变化；只是增加了一个额外的方法，即`Work()`。要为抽象方法提供实现，必须使用`override`关键字。一般来说，这个关键字用于在子类中更改现有方法的实现。稍后您将详细探讨这一点：
- en: '[PRE64]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If you were to create a new object for this class and call the `Work` method,
    it would print `"A mailman is delivering mails."` to the console. To get a full
    picture of polymorphism, you will now create one more class, `Teacher`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为这个类创建一个新对象并调用`Work`方法，它将在控制台上打印`"A mailman is delivering mails."`。为了全面了解多态，现在您将创建另一个类`Teacher`：
- en: '[PRE65]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This class is almost identical to `Mailman`; however, a different implementation
    for the `Work` method is provided. Thus, you have two classes that do the same
    thing in two different ways. The act of calling a method of the same name, but
    getting different behavior, is called polymorphism.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类几乎与`Mailman`相同；但是提供了`Work`方法的不同实现。因此，您有两个类以两种不同的方式执行相同的操作。调用同名方法，但获得不同行为的行为称为多态。
- en: 'You already know about method overloading (not to be confused with overriding),
    which is when you have methods with the same names but different inputs. That
    is called static polymorphism and it happens during compile time. The following
    is an example of this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解了方法重载（不要与重写混淆），这是指具有相同名称但不同输入的方法。这称为静态多态，它发生在编译时。以下是一个例子：
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `Person` class has two methods with the same name, Say. One takes no arguments
    and the other takes a string as an argument. Depending on the arguments passed,
    different implementations of the method will be called. If nothing is passed,
    `"Hello"` will be printed. Otherwise, the words you pass will be printed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类有两个同名方法Say。一个不带参数，另一个带一个字符串作为参数。根据传递的参数，将调用方法的不同实现。如果什么都不传，将打印`"Hello"`。否则，将打印您传递的单词。'
- en: In the context of OOP, polymorphism is referred to as dynamic polymorphism,
    which happens during runtime. For the rest of this chapter, polymorphism should
    be interpreted as dynamic polymorphism.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程的上下文中，多态被称为动态多态，它发生在运行时。在本章的其余部分，多态应该被解释为动态多态。
- en: What is the Benefit of Polymorphism?
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多态的好处是什么？
- en: 'A teacher is a human, and the way a teacher works is by teaching. This is not
    the same as a mailman, but a teacher also has a name, age, weight, and height,
    like a mailman. Polymorphism allows you to interact with both in the same way,
    regardless of their specialized forms. The best way to illustrate this is to store
    both in an array of `humans` values and make them work:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 老师是一个人，老师的工作方式是教书。这与邮递员不同，但老师也有姓名、年龄、体重和身高，就像邮递员一样。多态允许您以相同的方式与两者交互，而不考虑它们的专业形式。最好的方法是将两者存储在`humans`值数组中并让它们工作：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This code results in the following being printed in the console:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将在控制台中打印以下内容：
- en: '[PRE68]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/ovqru](https://packt.link/ovqru).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/ovqru](https://packt.link/ovqru)找到此示例使用的代码。
- en: This code was polymorphism in action. You treated both `Mailman` and `Teacher`
    as `Human` and implemented the `Work` method for both. The result was different
    behaviors in each case. The important point to note here is that you did not have
    to care about the exact implementations of `Human` to implement `Work`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了多态。您将`Mailman`和`Teacher`都视为`Human`，并为两者都实现了`Work`方法。结果是每种情况下的不同行为。这里需要注意的重要一点是，您不必关心实现`Human`的具体细节来实现`Work`。
- en: 'How would you implement this without polymorphism? You would need to write
    `if` statements based on the exact type of an object to find the behavior it should
    use:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有多态，您将需要编写基于对象的确切类型的`if`语句来找到它应该使用的行为：
- en: '[PRE69]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As you see, this is a lot more complicated and harder to grasp. Keep this example
    in mind when you get into a situation with many `if` statements. Polymorphism
    can remove the burden of all that branching code by simply moving the code for
    each branch into a child class and simplifying the interactions.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这更加复杂且难以理解。当您遇到许多`if`语句的情况时，请记住这个例子。多态可以通过将每个分支的代码移动到子类中并简化交互来消除所有分支代码的负担。
- en: 'What if you wanted to print some information about a person? Consider the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要打印有关一个人的一些信息，可以考虑以下代码：
- en: '[PRE70]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Running this code would result in the object type names being printed to the
    console:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将导致对象类型名称被打印到控制台：
- en: '[PRE71]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In C#, everything derives from the `System.Object` class, so every single type
    in C# has a method called `ToString()`. Each type has its own implementation of
    this method, which is another example of polymorphism, widely used in C#.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，一切都源自`System.Object`类，因此C#中的每种类型都有一个名为`ToString()`的方法。每种类型都有其自己的此方法的实现，这是多态性的另一个例子，在C#中广泛使用。
- en: Note
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`ToString()` is different from `Work()` in that it provides a default implementation.
    You can achieve that using the `virtual` keyword, which will be covered in detail
    later in the chapter. From the point of view of a child class, working with the
    `virtual` or `abstract` keyword is the same. If you want to change or provide
    behavior, you will override the method.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString()`与`Work()`不同之处在于它提供了一个默认实现。您可以使用`virtual`关键字来实现这一点，这将在本章后面详细介绍。从子类的角度来看，使用`virtual`或`abstract`关键字是相同的。如果要更改或提供行为，您将覆盖该方法。'
- en: 'In the following snippet, a `Human` object is given a custom implementation
    of the `ToString()` method:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下片段中，`Human`对象被赋予了`ToString()`方法的自定义实现：
- en: '[PRE72]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Trying to print information about the humans in the same foreach loop would
    result in the following output:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在同一个foreach循环中打印有关人类的信息将导致以下输出：
- en: '[PRE73]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/EGDkC](https://packt.link/EGDkC).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/EGDkC](https://packt.link/EGDkC)找到此示例使用的代码。
- en: Polymorphism is one of the best ways to use different underlying behaviors when
    dealing with missing type information.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性是在处理缺少类型信息时使用不同底层行为的最佳方法之一。
- en: Abstraction
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象
- en: The last pillar of OOP is abstraction. Some say that there are only three pillars
    of OOP because abstraction does not really introduce much that is new. Abstraction
    encourages you to hide implementation details and simplify interactions between
    objects. Whenever you need the functionality of only a generalized form, you should
    not depend on its implementation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的最后一个支柱是抽象。有人说面向对象编程只有三个支柱，因为抽象并没有真正引入太多新内容。抽象鼓励您隐藏实现细节并简化对象之间的交互。每当您只需要通用形式的功能时，您不应该依赖于其实现。
- en: Abstraction could be illustrated with an example of how people interact with
    their computers. What occurs in the internal circuitry when you turn on the computer?
    Most people would have no clue, and that is fine. You do not need to know about
    the internal workings if you only need to use some functionality. All you have
    to know is what you can do, and not how it works. You know you can turn a computer
    on and off by pressing a button, and all the complex details are hidden away.
    Abstraction adds little new to the other three pillars because it reflects each
    of them. **Abstraction is similar to encapsulation**, as it hides unnecessary
    details to simplify interaction. It is also similar to polymorphism because it
    can interact with objects without knowing their exact types. Finally, inheritance
    is just one of the ways to create abstractions.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象可以通过人们如何与计算机交互的示例来说明。当您打开计算机时，内部电路会发生什么？大多数人可能不知道，这没关系。如果您只需要使用某些功能，您不需要了解内部工作原理。您只需要知道您可以通过按按钮打开和关闭计算机，所有复杂的细节都被隐藏起来。抽象对其他三个支柱几乎没有增加新内容，因为它反映了它们的每一个。**抽象类似于封装**，因为它隐藏了不必要的细节以简化交互。它也类似于多态性，因为它可以与对象交互而不知道它们的确切类型。最后，继承只是创建抽象的一种方式。
- en: 'You do not need to provide unnecessary details coming through implementation
    types when creating functions. The following example illustrates this problem.
    You need to make a progress bar. It should keep track of the current progress
    and should increment the progress up to a certain point. You could create a basic
    class with setters and getters, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建函数时，不需要提供实现类型传递的不必要细节。以下示例说明了这个问题。您需要创建一个进度条。它应该跟踪当前进度，并应该增加进度直到某个点。您可以创建一个带有设置器和获取器的基本类，如下所示：
- en: '[PRE74]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The following code demonstrates how to initialize a progress bar that starts
    at `0` progress and goes up to `100`. The rest of the code illustrates what happens
    when you want to set the new progress to 120\. Progress cannot be more than `Max`,
    hence, if it is more than `bar.Max`, it should just remain at `bar.Max`. Otherwise,
    you can update the new progress with the value you set. Finally, you need to check
    whether the progress is complete (at `Max` value). To do so, you will compare
    the delta with the allowed margin of error tolerance (`0.0001`). A progress bar
    is complete if it is close to tolerance. So, updating progress could look like
    the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何初始化一个从`0`进度开始并增加到`100`的进度条。代码的其余部分说明了当您想要将新进度设置为120时会发生什么。进度不能超过`Max`，因此，如果超过`bar.Max`，它应该保持在`bar.Max`。否则，您可以使用您设置的值更新新的进度。最后，您需要检查进度是否完成（达到`Max`值）。为此，您将比较增量与允许的误差容限（`0.0001`）。如果进度条接近容限，进度条就完成了。因此，更新进度可能如下所示：
- en: '[PRE75]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This code does what is asked for, but it needs a lot of detail for a function.
    Imagine if you had to use this in other code; you would need to perform the same
    checks once again. In other words, it was easy to implement but complex to consume.
    You have so little within the class itself. A strong indicator of that is that
    you keep on calling the object, instead of doing something inside the class itself.
    Publicly, it's possible to break the object state by forgetting to check the `Max`
    value of progress and setting it to some high or negative value. The code that
    you wrote has low cohesion because to change `ProgressBar`, you would do it not
    within the class but somewhere outside of it. You need to create a better abstraction.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做了被要求的事情，但对于一个函数来说需要很多细节。想象一下，如果你需要在其他代码中使用它，你需要再次执行相同的检查。换句话说，实现起来很容易，但消耗起来很复杂。类本身很少。一个很明显的指标是你一直在调用对象，而不是在类内部做一些事情。公开地说，通过忘记检查进度的`Max`值并将其设置为较高或负值，很容易破坏对象状态。你写的代码具有低内聚性，因为要改变`ProgressBar`，你需要在类的外部而不是类内部进行。你需要创建一个更好的抽象。
- en: 'Consider the following snippet:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下片段：
- en: '[PRE76]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: With this code, you have hidden the nitty-gritty details. When it comes to updating
    progress and defining what the tolerance is, that is up to the `ProgressBar` class
    to decide. In the refactored code, you have a property, `Current`, with a backing
    field, `_current`, to store the progress. The property setter checks whether progress
    is more than the maximum and, if it is, it will not allow the value of `_current`
    to be set to a higher value, `=`. It also cannot be negative, as in those cases,
    the value will be adjusted to `0`. Lastly, if it is not negative and not more
    than the maximum, then you can set `_current` to whatever value you pass.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，你隐藏了繁琐的细节。当涉及到更新进度和定义容差时，这取决于`ProgressBar`类来决定。在重构后的代码中，你有一个属性`Current`，有一个后备字段`_current`来存储进度。属性的setter检查进度是否超过最大值，如果是，它将不允许将`_current`的值设置为更高的值，`=`。它也不能是负数，因为在这种情况下，值将被调整为`0`。最后，如果它既不是负数也不超过最大值，那么你可以将`_current`设置为你传递的任何值。
- en: 'Clearly, this code makes it much simpler to interact with the `ProgressBar`
    class:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这段代码使与`ProgressBar`类的交互变得简单得多：
- en: '[PRE77]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You cannot break anything; you do not have any extra choices and all you can
    do is defined through minimalistic methods. When you are asked to implement a
    feature, it is not recommended to do more than what is asked. Try to be minimalistic
    and simplistic because that is key to an effective code.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能破坏任何东西；你没有任何额外的选择，你所能做的一切都是通过最小化的方法定义的。当你被要求实现一个功能时，不建议做比要求更多的事情。尽量做到最小化和简单化，因为这是有效代码的关键。
- en: Remember that well-abstracted code is full of empathy toward the reader. Just
    because today, it is easy to implement a class or a function, you should not forget
    about tomorrow. The requirements change, the implementation changes, but the structure
    should remain stable, otherwise, your code can break easily.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，良好抽象的代码对读者充满同理心。仅仅因为今天很容易实现一个类或一个函数，你不应该忘记明天。需求会改变，实现会改变，但结构应该保持稳定，否则你的代码很容易出错。
- en: Note
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example can be found at [https://packt.link/U126i](https://packt.link/U126i).
    The code given in GitHub is split into two contrasting examples—`ProgressBarGood`
    and `ProgressBarBad`. Both codes are simple `ProgressBar` but were named distinctly
    to avoid ambiguity.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/U126i](https://packt.link/U126i)找到此示例使用的代码。在GitHub上提供的代码分为两个对比示例——`ProgressBarGood`和`ProgressBarBad`。这两个代码都是简单的`ProgressBar`，但它们被命名为不同的名称以避免歧义。
- en: Interfaces
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: Earlier, it was mentioned that inheritance is not the proper way of designing
    code. However, you want to have an efficient abstraction as well as support for
    polymorphism, and little to no coupling. What if you wanted to have robot or ant
    workers? They do not have a name. Information such as height and weight are irrelevant.
    And inheriting from the `Human` class would make little sense. Using an interface
    solves this conundrum.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到过，继承不是设计代码的正确方式。然而，你希望有一个高效的抽象，同时支持多态性，以及尽可能少的耦合。如果你想要有机器人或蚂蚁工人怎么办？它们没有名字。身高和体重等信息是无关紧要的。从`Human`类继承就没有多大意义了。使用接口可以解决这个难题。
- en: In C#, by convention, interfaces are named starting with the letter `I`, followed
    by their actual name. An interface is a contract that states what a class can
    do. It does not have any implementation. It only defines behavior for every class
    that implements it. You will now refactor the human example using an interface.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，在C#中，接口的命名以字母`I`开头，后面跟着它们的实际名称。接口是一个合同，规定了一个类能做什么。它没有任何实现。它只为实现它的每个类定义行为。现在，你将使用接口重构人类的示例。
- en: 'What can an object of the `Human` class do? It can work. Who or what can do
    work? A worker. Now, consider the following snippet:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`Human`类的对象能做什么？它可以工作。谁或什么能工作？工作者。现在，考虑以下片段：'
- en: '[PRE78]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Interface `Work` method will have is the same as the interface access modifier,
    in this case, `public`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接口`Work`方法的访问修饰符与接口相同，即`public`。
- en: 'An ant is not a human, but it can work. With an interface, abstracting an ant
    as a worker is straightforward:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 蚂蚁不是人类，但它也可以工作。通过接口，将蚂蚁抽象为工作者是很简单的：
- en: '[PRE79]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Similarly, a robot is not a human, but it can work as well:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，机器人不是人类，但它也可以工作：
- en: '[PRE80]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If you refer to the `Human` class, you can change its definition to `public
    abstract class Human : IWorker`. This can be read as: `Human` class implements
    the `IWorker` interface.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你参考`Human`类，你可以将其定义为`public abstract class Human : IWorker`。这可以理解为：`Human`类实现了`IWorker`接口。'
- en: 'In the next snippet, `Mailman` inherits the `Human` class, which implements
    the `IWorker` interface:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个片段中，`Mailman`继承了`Human`类，该类实现了`IWorker`接口：
- en: '[PRE81]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If a child class inherits a parent class, which implements some interfaces,
    the child class will also be able to implement the same interfaces by default.
    However, `Human` was an abstract class and you had to provide implementation to
    the `abstract void Work` method.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个子类继承了一个实现了一些接口的父类，那么子类也将能够默认实现相同的接口。然而，`Human`是一个抽象类，你必须为`abstract void
    Work`方法提供实现。
- en: 'If anyone asked what a human, an ant, and a robot have in common, you could
    say that they can all work. You can simulate this situation as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人问人类、蚂蚁和机器人有什么共同之处，你可以说他们都能工作。你可以模拟这种情况，如下所示：
- en: '[PRE82]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This prints the following to the console:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台上打印如下内容：
- en: '[PRE83]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for the example at [https://packt.link/FE2ag](https://packt.link/FE2ag).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/FE2ag](https://packt.link/FE2ag)找到示例中使用的代码。
- en: 'C# does not support multiple inheritance. However, it is possible to implement
    multiple interfaces. Implementing multiple interfaces does not count as multiple
    inheritance. For example, to implement a `Drone` class, you could add an `IFlyer` interface:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: C#不支持多重继承。然而，可以实现多个接口。实现多个接口不算是多重继承。例如，要实现一个`Drone`类，你可以添加一个`IFlyer`接口：
- en: '[PRE84]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '`Drone` is a flying object that can do some work; therefore it can be expressed
    as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`无人机`是一种可以执行一些工作的飞行物体；因此，它可以表示如下：'
- en: '[PRE85]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Listing multiple interfaces with separating commas means the class implements
    each of them. You can combine any number of interfaces, but try not to overdo
    this. Sometimes, a combination of two interfaces makes up a logical abstraction.
    If every drone can fly and does some work, then you can write that in code, as
    follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 用逗号分隔列出多个接口意味着类实现了每一个接口。你可以组合任意数量的接口，但尽量不要过度。有时，两个接口的组合构成一个逻辑抽象。如果每个无人机都能飞行并且能做一些工作，那么你可以在代码中写出来，如下所示：
- en: '[PRE86]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'And the `Drone` class becomes simplified to `public class Drone : IDrone`.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`Drone`类变得简化为`public class Drone : IDrone`。'
- en: 'It is also possible to mix interfaces with a base class (but no more than one
    base class). If you want to represent an ant that flies, you can write the following
    code:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将接口与基类混合使用（但不超过一个基类）。如果你想表示一只会飞的蚂蚁，你可以编写以下代码：
- en: '[PRE87]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: An interface is undoubtedly the best abstraction because depending on it does
    not force you to depend on any implementation details. All that is required is
    the logical concepts that have been defined. Implementation is prone to change,
    but the logic behind relations between classes is not.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 接口无疑是最好的抽象，因为依赖于它不会强迫你依赖于任何实现细节。所需的只是已经定义的逻辑概念。实现容易改变，但类之间关系的逻辑不会改变。
- en: 'If an interface defines what a class can do, is it also possible to define
    a contract for common data? Absolutely. An interface holds behavior, hence it
    can hold properties as well because they define setter and getter behavior. For
    example, you should be able to track the drone, and for this, it should be identifiable,
    that is, it needs to have an ID. This can be coded as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个接口定义了一个类可以做什么，那么也可以定义一个用于共同数据的契约吗？当然可以。一个接口包含行为，因此它也可以包含属性，因为它们定义了setter和getter行为。例如，你应该能够追踪无人机，为此，它应该是可识别的，也就是说，它需要有一个ID。这可以编码如下：
- en: '[PRE88]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In modern software development, there are several complex low-level details
    that programmers use on a daily basis. However, they often do so without knowing.
    If you want to create a maintainable code base with lots of logic and easy-to-grasp
    code, you should follow these principles of abstraction:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代软件开发中，程序员每天都会使用一些复杂的低级细节。然而，他们经常在不知情的情况下这样做。如果你想创建一个易于理解的代码库，其中包含大量逻辑和易于理解的代码，你应该遵循这些抽象原则：
- en: Keep it simple and small.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持简单和小。
- en: Do not depend on details.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要依赖于细节。
- en: Hide complexity.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏复杂性。
- en: Expose only what is necessary.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只暴露必要的内容。
- en: With this exercise, you will grasp how OOP functions.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，你将了解面向对象编程的功能。
- en: 'Exercise 2.03: Covering Floor in the Backyard'
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.03：在后院铺地板
- en: A builder is building a mosaic with which he needs to cover an area of x square
    meters. You have some leftover tiles that are either rectangular or circular.
    In this exercise, you need to find out whether, if you shatter the tiles to perfectly
    fill the area they take up, can the tiles fill the mosaic completely.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一个建筑师正在用马赛克铺地，他需要覆盖x平方米的区域。你有一些剩下的瓷砖，要么是矩形的，要么是圆形的。在这个练习中，你需要找出，如果你打碎瓷砖来完全填满它们所占据的区域，瓷砖是否可以完全填满马赛克。
- en: 'You will write a program that prints `true`, if the mosaic can be covered with
    tiles, or `false`, if it cannot. Perform the following steps to do so:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你将编写一个程序，如果马赛克可以用瓷砖覆盖，则打印`true`，如果不能，则打印`false`。执行以下步骤来完成：
- en: 'Create an interface named `IShape`, with an `Area` property:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`IShape`的接口，带有一个`Area`属性：
- en: '[PRE89]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This is a get-only property. Note that a property is a method, so it is okay
    to have it in an interface.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个只读属性。请注意，属性是一个方法，所以在接口中拥有它是可以的。
- en: 'Create a class called `Rectangle`, with width and height and a method for calculating
    area, called `Area`. Implement an `IShape` interface for this, as shown in the
    following code:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Rectangle`的类，带有宽度和高度以及一个用于计算面积的方法，名为`Area`。为此实现一个`IShape`接口，如下所示的代码所示：
- en: '[PRE90]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The only thing required is to calculate the area. Hence, only the `Area` property
    is `public`. Your interface needs to implement a getter `Area` property, achieved
    by multiplying `width` and `height`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要做的就是计算面积。因此，只有`Area`属性是`public`。你的接口需要实现一个getter `Area`属性，通过将`width`和`height`相乘来实现。
- en: 'Create a `Circle` class with a `radius` and `Area` calculation, which also
    implements the `IShape` interface:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`半径`和`Area`计算的`Circle`类，它还实现了`IShape`接口：
- en: '[PRE92]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Create a skeleton `Solution` class with a method named `IsEnough`, as follows:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`IsEnough`的方法的骨架`Solution`类，如下所示：
- en: '[PRE93]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Both the class and the method are just placeholders for the implementation to
    come. The class is `static` because it will be used as a demo and it does not
    need to have a state. The `IsEnough` method takes the needed `mosaicArea`, an
    array of tiles objects, and returns whether the total area occupied by the tiles
    is enough to cover the mosaic.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 类和方法都只是实现的占位符。该类是`static`，因为它将用作演示，不需要具有状态。`IsEnough`方法接受所需的`mosaicArea`、一组瓷砖对象，并返回瓷砖占据的总面积是否足以覆盖马赛克。
- en: 'Inside the `IsEnough` method, use a `for` loop to calculate the `totalArea`.
    Then, return whether the total area covers the mosaic area:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`IsEnough`方法内部，使用`for`循环来计算`totalArea`。然后，返回总面积是否覆盖了马赛克区域：
- en: '[PRE94]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Inside the `Solution` class, create a demo. Add several sets of different shapes,
    as follows:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Solution`类内部创建一个演示。添加几组不同形状，如下所示：
- en: '[PRE95]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here, you use four examples. When the area to cover is `0`, then no matter what
    shapes you pass, it will be enough. When the area to cover is `1`, a rectangle
    of area `1x1` will be just enough. When it's `100`, a circle of radius `5` is
    not enough. Finally, for the fourth example, the area occupied by three shapes
    is added up, that is, a rectangle of area `1x1`, a circle of radius `1`, and the
    second rectangle of area `1.4x1`. The total area is `5`, which is less than the
    combined area of these three shapes.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用了四个例子。当要覆盖的面积为`0`时，无论您传递什么形状，都足够了。当要覆盖的面积为`1`时，面积为`1x1`的矩形刚好足够。当面积为`100`时，半径为`5`的圆不够。最后，对于第四个例子，三个形状占据的面积相加，即面积为`1x1`的矩形、半径为`1`的圆和面积为`1.4x1`的第二个矩形。总面积为`5`，小于这三个形状的组合面积。
- en: 'Run the demo. You should see the following output on your screen:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行演示。您应该在屏幕上看到以下输出：
- en: '[PRE96]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Note
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/EODE6](https://packt.link/EODE6).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/EODE6](https://packt.link/EODE6)找到用于此练习的代码。
- en: This exercise is very similar to *Exercise 2.02*. However, even though the assignment
    is more complex, there is less code than in the previous assignment. By using
    the OOP pillars, you were able to create a simple solution for a complex problem.
    You were able to create functions that depend on abstraction, rather than making
    overloads for different types. Thus, OOP is a powerful tool, and this only scratches
    the surface.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习与*练习2.02*非常相似。然而，尽管任务更复杂，但代码比上一个任务少。通过使用面向对象编程的支柱，您能够为复杂问题创建简单的解决方案。您能够创建依赖于抽象的函数，而不是为不同类型创建重载。因此，面向对象编程是一个强大的工具，这只是冰山一角。
- en: Everyone can write code that works but writing code that lives for decades and
    is easy to grasp is hard. So, it is imperative to know about the set of best practices
    in OOP.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都可以编写能够工作的代码，但编写能够持续数十年并且易于理解的代码是困难的。因此，了解面向对象编程中的最佳实践是至关重要的。
- en: SOLID Principles in OOP
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程中的SOLID原则
- en: SOLID principles are a set of best practices for OOP. SOLID is an acronym for
    five principles, namely, single responsibility, open-closed, Liskov substitution,
    interface segregation, and dependency inversion. You will not explore each of
    these in detail.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则是面向对象编程的最佳实践。SOLID是五个原则的首字母缩写，即单一职责、开闭原则、里氏替换、接口隔离和依赖反转。您将不会详细探讨每一个原则。
- en: Single Responsibility Principle
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Functions, classes, projects, and entire systems change over time. Every change
    is potentially a breaking one, so you should limit the risk of too many things
    changing at a time. In other words, a part of a code block should have only a
    single reason to change.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 函数、类、项目和整个系统随着时间的推移而发生变化。每一次变化都有可能是破坏性的，因此您应该限制同时发生太多变化的风险。换句话说，代码块的一部分应该只有一个改变的原因。
- en: For a function, this means that it should do just one thing and have no side
    effects. In practice, this means that a function should either change, or get
    something, but never do both. This also means that functions responsible for high-level
    things should not be mixed with functions that perform low-level things. Low-level
    is all about implementing interactions with hardware, and working with primitives.
    High-level is focused on compositions of software building blocks or services.
    When talking about high- and low-level functions, it is usually referred to as
    a chain of dependencies. If function A calls function B, A is considered higher-level
    than B. A function should not implement multiple things; it should instead call
    other functions that implement doing one thing. The general guideline for this
    is that if you think you can split your code into different functions, then in
    most cases, you should do that.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个函数来说，这意味着它应该只做一件事，并且没有副作用。实际上，这意味着一个函数应该要么改变，要么获取某些东西，但不能两者兼有。这也意味着负责高级事务的函数不应该与执行低级事务的函数混合在一起。低级是指实现与硬件的交互和使用原语。高级侧重于软件构建块或服务的组合。在谈论高级和低级函数时，通常称之为依赖链。如果函数A调用函数B，那么A被认为比B更高级。一个函数不应该实现多个事情；它应该调用实现单一事情的其他函数。对于这一点的一般指导原则是，如果您认为可以将代码拆分成不同的函数，那么在大多数情况下，您应该这样做。
- en: 'For classes, it means that you should keep them small and isolated from one
    another. An example of an efficient class is the `File` class, which can read
    and write. If it implemented both reading and writing, it would change for two
    reasons (reading and writing):'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类来说，这意味着您应该使它们小而相互隔离。一个高效的类的例子是`File`类，它可以读取和写入。如果它同时实现了读取和写入，它将因为两个原因（读取和写入）而发生变化。
- en: '[PRE97]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Therefore, to conform to this principle, you can split the reading code into
    a class called `Reader` and writing code into a class called `Writer`, as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了符合这一原则，您可以将读取代码拆分为一个名为`Reader`的类，将写入代码拆分为一个名为`Writer`的类，如下所示：
- en: '[PRE98]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now, instead of implementing reading and writing by itself, the `File` class
    will simply be composed of a reader and writer:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`File`类不再实现读取和写入，而是简单地由读取器和写入器组成：
- en: '[PRE99]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/PBppV](https://packt.link/PBppV).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/PBppV](https://packt.link/PBppV)找到此示例使用的代码。
- en: It might be confusing because what the class does essentially remains the same.
    However, now, it just consumes a component and is not responsible for implementing
    it. A high-level class (`File`) simply adds context to how lower-level classes
    (`Reader`, `Writer`) will be consumed.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会令人困惑，因为类的本质实质上保持不变。然而，现在它只是消耗一个组件，而不是负责实现它。一个高级别的类（`File`）只是为了解如何使用低级别的类（`Reader`、`Writer`）而添加了上下文。
- en: For a module (library), it means that you should strive to not introduce dependencies,
    which would be more than what the consumer would want. For example, if you are
    using a library for logging, it should not come with some third-party logging
    provider-specific implementation.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个模块（库），这意味着你应该努力不引入依赖关系，这些依赖关系可能超出消费者的需求。例如，如果你正在使用一个用于记录日志的库，它不应该带有某些特定于第三方记录提供者的实现。
- en: For a subsystem, it means that different systems should be as isolated as possible.
    If two (lower level) systems need to communicate, they could call one another
    directly. A consideration (not mandatory) would be to have a third system (higher-level)
    for coordination. Systems should also be separated through a boundary (such as
    a contract specifying communication parameters), which hides all the details.
    If a subsystem is a big library collection, it should have an interface to expose
    what it can do. If a subsystem is a web service, it should be a collection of
    endpoints. In any case, a contract of a subsystem should provide only the methods
    that the client may want.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个子系统来说，这意味着不同的系统应尽可能地隔离。如果两个（较低级别）系统需要通信，它们可以直接相互调用。一个考虑（不是强制性的）是有一个第三个系统（较高级别）用于协调。系统还应该通过边界（比如指定通信参数的合同）进行分离，隐藏所有细节。如果一个子系统是一个大型库集合，它应该有一个接口来暴露它可以做什么。如果一个子系统是一个网络服务，它应该是一个端点集合。在任何情况下，子系统的合同应该只提供客户可能需要的方法。
- en: 'Sometimes, the principle is overdone and classes are split so much that making
    a change requires changing multiple places. It does keep true to the principle,
    as a class will have a single reason to change, but in such a case, multiple classes
    will change for the same reason. For example, suppose you have two classes: `Merchandise`
    and `TaxCalculator`. The `Merchandise` class has fields for `Name`, `Price`, and
    `Vat`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，原则被过分强调，类被分割得太多，以至于进行更改需要改变多个地方。它确实符合原则，因为一个类只有一个改变的原因，但在这种情况下，多个类将因同样的原因而改变。例如，假设你有两个类：`Merchandise`和`TaxCalculator`。`Merchandise`类有`Name`、`Price`和`Vat`字段：
- en: '[PRE100]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Next, you will create the `TaxCalculator` class. `vat` is measured as a percentage,
    so the actual price to pay will be `vat` added to the original price:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将创建`TaxCalculator`类。`vat`是以百分比计量的，所以实际要支付的价格将是原始价格加上`vat`：
- en: '[PRE101]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'What would change if the functionality of calculating the price moved to the
    `Merchandise` class? You would still be able to perform the required operation.
    There are two key points here:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算价格的功能移动到`Merchandise`类，会发生什么变化？您仍然可以执行所需的操作。这里有两个关键点：
- en: The operation by itself is simple.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作本身很简单。
- en: Also, everything that the tax calculator needs come from the `Merchandise` class.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，税收计算器需要的一切都来自`Merchandise`类。
- en: 'If a class can implement the logic by itself, as long as it is self-contained
    (does not involve extra components), it usually should. Therefore, a proper version
    of the code would be as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类可以自己实现逻辑，只要它是自包含的（不涉及额外的组件），通常应该这样做。因此，代码的适当版本如下：
- en: '[PRE102]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This code moves the `NetPrice` calculation to the `Merchandise` class and the
    `TaxCalculator` class has been removed.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将`NetPrice`计算移到`Merchandise`类中，并删除了`TaxCalculator`类。
- en: Note
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Singe Responsibility Principle (SRP) can be summarized in a couple of words:
    **split it**. You can find the code used for this example at [https://packt.link/lWxNO](https://packt.link/lWxNO).'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 单一责任原则（SRP）可以用几个词来概括：**拆分它**。您可以在[https://packt.link/lWxNO](https://packt.link/lWxNO)找到此示例使用的代码。
- en: Open-Closed Principle
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开闭原则
- en: As mentioned previously, every change in code is potentially a breaking one.
    As a way around this, instead of changing existing code, it is often preferable
    to write new code. Every software entity should have an extension point, through
    which the changes should be introduced. However, after this change is done, a
    software entity should not be interfered with. The Open-Closed Principle (OCP)
    is hard to implement and takes a lot of practice, but the benefits (a minimum
    number of breaking changes) are well worth it.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，代码中的每一次更改都可能是破坏性的。为了避免这种情况，通常最好的方法不是更改现有的代码，而是编写新的代码。每个软件实体都应该有一个扩展点，通过这个扩展点应该引入更改。然而，在完成这些更改之后，不应该再干预软件实体。开闭原则（OCP）很难实现，需要大量的实践，但好处（最小数量的破坏性更改）是非常值得的。
- en: If a multiple-step algorithm does not change, but its individual steps can change,
    you should split it into several functions. A change for an individual step will
    no longer affect the entire algorithm, but rather just that step. Such minimization
    of reasons for a single class or a function to change is what OCP is all about.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个多步算法不改变，但它的各个步骤可以改变，你应该将它拆分成几个函数。对于一个单独的步骤的更改将不再影响整个算法，而只是影响到那一步。这种减少单个类或函数改变原因的做法正是OCP的全部内容。
- en: Note
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on OCP at [https://social.technet.microsoft.com/wiki/contents/articles/18062.open-closed-principle-ocp.aspx](https://social.technet.microsoft.com/wiki/contents/articles/18062.open-closed-principle-ocp.aspx).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://social.technet.microsoft.com/wiki/contents/articles/18062.open-closed-principle-ocp.aspx](https://social.technet.microsoft.com/wiki/contents/articles/18062.open-closed-principle-ocp.aspx)找到有关OCP的更多信息。
- en: Another example where you may want to implement this principle is a function
    working with combinations of specific values in code. This is called hardcoding
    and is generally deemed an inefficient practice. To make it work with new values,
    you might be tempted to create a new function, but by simply removing a hardcoded
    part and exposing it through function parameters, you can make it extensible.
    However, when you have variables that are known to be fixed and not changing,
    it is fine to hardcode them, but they should be flagged as constant.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你可能想要实现这个原则的例子是一个函数在代码中使用特定值的组合。这被称为硬编码，通常被认为是一种低效的做法。为了使它适用于新的值，你可能会想要创建一个新的函数，但是通过简单地移除硬编码部分并通过函数参数公开它，你可以使它变得可扩展。然而，当你有已知是固定且不会改变的变量时，硬编码是可以的，但它们应该被标记为常量。
- en: 'Previously, you created a file class with two dependencies—`Reader` and `Writer`.
    Those dependencies are hardcoded, and leave you with no extension points. Fixing
    that will involve two things. First, add the virtual modifier for both the `Reader`
    and `Writer` class methods:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，你创建了一个带有两个依赖项的文件类——“Reader”和“Writer”。这些依赖是硬编码的，并且没有扩展点。修复这个问题将涉及两件事。首先，为“Reader”和“Writer”类的方法添加虚拟修饰符：
- en: '[PRE103]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Then, change the constructor of the `File` class so that it accepts instances
    of `Reader` and `Writer`, instead of hardcoding the dependencies:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，改变“File”类的构造函数，使其接受“Reader”和“Writer”的实例，而不是硬编码依赖关系：
- en: '[PRE104]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This code enables you to override the existing reader and writer behavior and
    replace it with whatever behavior you want, that is, the `File` class extension
    point.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使你能够覆盖现有的读取器和写入器行为，并用你想要的任何行为替换它，也就是说，“File”类扩展点。
- en: OCP can be summarized in a few words as **don't change it, extend it**.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: OCP可以用几个词来概括：**不要改变它，扩展它**。
- en: Liskov Substitution
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 里斯科夫替换
- en: 'The Liskov Substitution Principle (LSP) is one of the most straightforward
    principles out there. It simply means that a child class should support all the
    public behavior of a parent class. If you have two classes, `Car` and `CarWreck`,
    where one inherits the other, then you have violated the principle:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 里斯科夫替换原则（LSP）是最直接的原则之一。它简单地意味着子类应该支持父类的所有公共行为。如果你有两个类，“Car”和“CarWreck”，其中一个继承另一个，那么你就违反了这个原则：
- en: '[PRE105]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Note
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/6nD76](https://packt.link/6nD76).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/6nD76](https://packt.link/6nD76)找到这个例子的代码。
- en: Both `Car` and `CarWreck` have a `Body` object. `Car` can move, but what about
    `CarWreck`? It can only stay in one place. The `Move` method is virtual because
    `CarWreck` intends to override it to mark it as not supported. If a child can
    no longer support what a parent can do, then it should no longer inherit that
    parent. In this case, a car wreck is not a car, it's simply a wreck.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: “Car”和“CarWreck”都有一个“Body”对象。“Car”可以移动，但“CarWreck”呢？它只能停在一个地方。“Move”方法是虚拟的，因为“CarWreck”打算覆盖它以标记它为不支持。如果一个子类不能再支持父类能做的事情，那么它就不应该再继承那个父类。在这种情况下，车祸不是一辆车，它只是一堆废墟。
- en: 'How do you conform to this principle? All you have to do is to remove the inheritance
    relationship and replicate the necessary behavior and structure. In this case,
    `CarWreck` still has a `Body` object, but the `Move` method is unnecessary:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何符合这个原则？你所要做的就是移除继承关系并复制必要的行为和结构。在这种情况下，“CarWreck”仍然有一个“Body”对象，但“Move”方法是不必要的。
- en: '[PRE106]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Code changes happen quite often, and you can sometimes inadvertently use the
    wrong method to achieve your goals. Sometimes, you couple code in such a way that
    what you thought was flexible code turns out to be a complex mess. Do not use
    inheritance as a way of doing code reuse. Keep things small and compose them (again)
    instead of trying to override the existing behavior. Before things can be reusable,
    they should be usable. Design for simplicity and you will get flexibility for free.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 代码变化经常发生，有时你可能会无意中使用错误的方法来实现你的目标。有时，你会以一种你认为是灵活的方式耦合代码，结果变成了一个复杂的混乱。不要使用继承作为代码重用的一种方式。保持事物的小而组合它们（再次）而不是试图覆盖现有的行为。在事物可以重用之前，它们应该是可用的。设计简单，你将会得到灵活性。
- en: 'LSP can be summarized in a few words: **don''t fake it**.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: LSP可以用几个词来概括：**不要假装**。
- en: Note
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on LSP at [https://www.microsoftpressstore.com/articles/article.aspx?p=2255313](https://www.microsoftpressstore.com/articles/article.aspx?p=2255313).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.microsoftpressstore.com/articles/article.aspx?p=2255313](https://www.microsoftpressstore.com/articles/article.aspx?p=2255313)找到有关LSP的更多信息。
- en: Interface Segregation
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口隔离
- en: The interface segregation principle is a special case of the OCP but is only
    applicable to contracts that will be exposed publicly. Remember, every change
    you make is potentially a breaking change, and this especially matters in making
    changes to a contract. Breaking changes are inefficient because they will often
    require effort to adapt to the change from multiple people.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离原则是OCP的一个特例，但只适用于将公开的合同。记住，你所做的每一个改变都有可能是一个破坏性的改变，这在对合同进行更改时尤其重要。破坏性的改变是低效的，因为它们通常需要多人努力来适应改变。
- en: 'For example, say you have an interface, `IMovableDamageable`:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个接口，“IMovableDamageable”：
- en: '[PRE107]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'A single interface should represent a single concept. However, in this case,
    it does two things: move and manage `Hp` (hit points). By itself, an interface
    with two methods is not problematic. However, in scenarios of the implementation
    needing only a part of an interface, you are forced to create a workaround.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单一的接口应该代表一个单一的概念。然而，在这种情况下，它做了两件事：移动和管理“Hp”（生命值）。一个接口本身有两个方法并不是有问题的。然而，在实现只需要接口的一部分的情况下，你被迫创建一个变通方法。
- en: 'For example, score text is indestructible, but you would like it to be animated
    and to move it across a scene:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，分数文本是不可摧毁的，但你希望它能够被动画化并在场景中移动：
- en: '[PRE108]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Note
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The point here isn't to print the location; just to give an example of where
    it is used. It's up to location's implementation whether it will be printed or
    not as such.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重点不是打印位置；只是为了举例说明它的使用。是否打印取决于位置的实现。
- en: 'Taking another example, you might have a house that does not move but can be destroyed:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个例子，您可能有一个不会移动但可以被摧毁的房子：
- en: '[PRE109]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In both scenarios, you worked around the issue by throwing `NotSupportedException`.
    However, another programmer should not be given an option to call code that never
    works in the first place. In order to fix the problem of representing too many
    concepts, you should split the `IMoveableDamageable` interface into `IMoveable`
    and `IDamageable`:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，您通过抛出`NotSupportedException`来解决了问题。但是，不应该给另一个程序员调用从一开始就不起作用的代码的选项。为了解决表示太多概念的问题，您应该将`IMoveableDamageable`接口拆分为`IMoveable`和`IDamageable`：
- en: '[PRE110]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'And the implementations can now get rid of the unnecessary parts:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，实现可以摆脱不必要的部分：
- en: '[PRE111]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `Console.WriteLine`, in the preceding code, would display the namespace
    name with the class name.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`Console.WriteLine`将显示命名空间名称和类名。
- en: Note
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Interface segregation can be summarized as **don't enforce it**. You can find
    the code used for this example at [https://packt.link/32mwP](https://packt.link/32mwP).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离可以总结为**不要强制执行**。您可以在[https://packt.link/32mwP](https://packt.link/32mwP)找到此示例的代码。
- en: Dependency Inversion
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖倒置
- en: Large software systems can consist of millions of classes. Each class is a small
    dependency, and if unmanaged, the complexity might stack into something impossible
    to maintain. If one low-level component breaks, it causes a ripple effect, breaking
    the whole chain of dependencies. The dependency inversion principle states that
    you should avoid hard dependence on underlying classes.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 大型软件系统可能由数百万个类组成。每个类都是一个小的依赖项，如果不加管理，复杂性可能堆积成无法维护的东西。如果一个低级组件出现故障，就会产生连锁反应，破坏整个依赖链。依赖倒置原则指出，您应该避免对底层类的硬依赖。
- en: Dependency injection is the industry-standard way of implementing dependency
    inversion. Do not mix the two; one is a principle and the other refers to the
    implementation of this principle.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是实现依赖倒置的行业标准方式。不要混淆这两者；一个是原则，另一个是指这个原则的实现。
- en: Note that you can also implement dependency inversion without dependency injection.
    For example, when declaring a field, instead of writing something like `private
    readonly List<int> _numbers = new List<int>();`, it is preferable to write `private
    readonly IList<int> = _numbers`, which shifts dependency to abstraction (`IList`)
    and not implementation (`List`).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您也可以实现依赖倒置而不使用依赖注入。例如，在声明字段时，不要写类似`private readonly List<int> _numbers =
    new List<int>();`这样的代码，而是更倾向于写`private readonly IList<int> = _numbers`，这样可以将依赖转移到抽象（`IList`）而不是具体实现（`List`）。
- en: 'What is dependency injection? It is the act of passing an implementation and
    setting it to an abstraction slot. There are three ways to implement this:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是依赖注入？这是将实现传递并将其设置为抽象槽的行为。有三种实现方式：
- en: Constructor injection is achieved by exposing an abstraction through the constructor
    argument and passing an implementation when creating an object and then assigning
    it to a field. Use it when you want to consistently use the same dependency in
    the same object (but not necessarily the same class).
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数注入是通过构造函数参数公开一个抽象，并在创建对象时传递一个实现，然后将其分配给一个字段来实现的。当您想要在同一个对象中一致使用相同的依赖项时（但不一定是同一个类）时，请使用它。
- en: Method injection is done by exposing an abstraction through a method argument,
    and then passing an implementation when calling that method. Use it when, for
    a single method, a dependency might vary, and you do not plan to store the dependency
    throughout that object's lifetime.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法注入是通过方法参数公开一个抽象，然后在调用该方法时传递一个实现来完成的。当一个方法的依赖可能变化，并且您不打算在该对象的整个生命周期内存储依赖时，请使用它。
- en: Property injection is implemented by exposing an abstraction through a public
    property, and then assigning (or not) that property to some exact implementation.
    Property injection is a rare way of injecting dependencies because it suggests
    that dependency might even be null or temporary and there are many ways in which
    it could break.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性注入是通过公共属性公开一个抽象，然后将该属性分配（或不分配）给某个确切的实现来实现的。属性注入是一种罕见的注入依赖的方式，因为它暗示依赖甚至可能是空的或临时的，并且有许多可能导致它破坏的方式。
- en: 'Given two types, `interface IBartender { }` and `class Bar : Bartender { }`,
    you can illustrate the three ways of dependency injection for a class called `Bar`.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '给定两种类型，`interface IBartender { }`和`class Bar : Bartender { }`，您可以为名为`Bar`的类说明依赖注入的三种方式。'
- en: 'First, prepare the `Bar` class for constructor injection:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为构造函数注入准备`Bar`类：
- en: '[PRE112]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The constructor injection is done as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数注入如下完成：
- en: '[PRE113]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This kind of dependency injection is a dominating kind of inheritance, as it
    enforces stability through immutability. For example, some bars have just one
    bartender.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这种依赖注入是一种主导的继承方式，因为它通过不可变性来强制稳定性。例如，有些酒吧只有一个调酒师。
- en: 'Method injection would look like this:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 方法注入看起来像这样：
- en: '[PRE114]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The injection itself is as follows:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 注入本身如下：
- en: '[PRE115]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Often, this kind of dependency injection is called interface injection because
    the method often goes under an interface. The interface itself is a great idea,
    but that does not change the idea behind this kind of dependency injection. Use
    method injection when you immediately consume a dependency that you set, or when
    you have a complex way of setting new dependencies dynamically. For example, it
    makes sense to use different bartenders for serving drinks.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这种依赖注入被称为接口注入，因为该方法通常在接口下进行。接口本身是一个很好的想法，但这并不改变这种依赖注入背后的思想。当您立即使用您设置的依赖项时，或者当您有一种动态设置新依赖项的复杂方式时，请使用方法注入。例如，为了为饮料服务使用不同的调酒师是有意义的。
- en: 'Finally, property injection can be done like this:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，属性注入可以这样完成：
- en: '[PRE116]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Bartender is now injected like this:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 调酒师现在是这样注入的：
- en: '[PRE117]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: For example, a bar might have bartenders changing shifts, but one bartender
    at a time.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，酒吧可能会有调酒师轮班，但一次只有一个调酒师。
- en: Note
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/JcmAT](https://packt.link/JcmAT).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/JcmAT](https://packt.link/JcmAT)找到此示例中使用的代码。
- en: 'Property injection in other languages might have a different name: setter injection.
    In practice, components do not change that often, so this kind of dependency injection
    is the rarest.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言中的属性注入可能有不同的名称：setter注入。在实践中，组件并不经常更改，因此这种依赖注入是最罕见的。
- en: 'For the `File` class, this should mean that instead of exposing classes (implementation),
    you should expose abstractions (interfaces). This means that your `Reader` and
    `Writer` classes should implement some contract:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`File`类，这意味着您应该暴露抽象（接口）而不是暴露类（实现）。这意味着您的`Reader`和`Writer`类应该实现某些契约：
- en: '[PRE118]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Your file class should expose reader and writer abstractions, instead of implementations,
    as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 您的文件类应该暴露阅读器和写入器抽象，而不是实现，如下所示：
- en: '[PRE119]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This allows for a choice of the kind of `IReader` and `IWriter` you would like
    to inject. A different reader may read a different file format, or a different
    writer may output in a different way. You have a choice.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您选择要注入的`IReader`和`IWriter`的类型。不同的阅读器可能读取不同的文件格式，或者不同的写入器可能以不同的方式输出。您有选择的余地。
- en: Dependency injection is a powerful tool that is used often, especially in an
    enterprise setting. It allows you to simplify complex systems by putting an interface
    in between and having 1:1 dependencies of implementation-abstraction-implementation.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一个强大的工具，经常被使用，特别是在企业环境中。它允许您通过在接口之间放置一个接口并具有实现-抽象-实现的1:1依赖关系来简化复杂系统。
- en: Writing effective code that does not break can be paradoxical. It is the same
    as buying a tool from a shop; you can't know for sure how long it will last, or
    how well it will work. Code, just like those tools, might work now but break in
    the near future, and you will only know that it does not work if and when it breaks.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 编写有效的不易破坏的代码可能是矛盾的。这就像从商店购买工具一样；您无法确定它会持续多长时间，或者它会工作得有多好。代码，就像那些工具一样，现在可能有效，但在不久的将来可能会出现问题，只有在它出现问题时才会知道它不起作用。
- en: Observing and waiting, seeing how the code evolves, is the only way to know
    for sure if you have written an effective code. In small, personal projects, you
    might not even notice any changes, unless you expose the project to the public
    or involve other people. To most people, SOLID principles often sound like old,
    outdated principles, like over-engineering. But they are actually a set of best
    practices that have withstood the test of time, formulated by top professionals
    seasoned in enterprise settings. It is impossible to write perfect, SOLID code
    right away. In fact, in some cases, it is not even necessary (if a project is
    small and meant to be short-lived, for example). As someone who wants to produce
    quality software and work as a professional, you should practice it as early on
    as possible.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 观察和等待，看代码如何演变，是确保您编写了有效代码的唯一方法。在小型个人项目中，您甚至可能察觉不到任何变化，除非将项目公开或者涉及其他人。对大多数人来说，SOLID原则通常听起来像是过时的原则，就像过度工程一样。但实际上，它们是经受住时间考验的一套最佳实践，由在企业环境中经验丰富的顶尖专业人士制定。一开始就写出完美的SOLID代码是不可能的。实际上，在某些情况下，这甚至不是必要的（例如，如果项目很小并且预计寿命很短）。作为一个想要生产高质量软件并且想要成为专业人士的人，您应该尽早练习它。
- en: How C# Helps with Object-Oriented Design
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#如何帮助面向对象设计
- en: So far, the principles you have learned are not language-specific. It is time
    to learn how to use C# for OOP. C# is a great language because it is full of some
    very useful features. It is not only one of the most productive languages to work
    with, but it also allows you to write beautiful, hard-to-break code. With a rich
    selection of keywords and languages features, you can model your classes completely
    the way you want, making the intentions crystal clear. This section will delve
    deep into C# features that help with object-oriented design.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您学到的原则并不是特定于语言的。现在是时候学习如何使用C#进行面向对象编程了。C#是一种很棒的语言，因为它充满了一些非常有用的功能。它不仅是最具生产力的语言之一，而且还允许您编写美观且不易破坏的代码。借助丰富的关键字和语言特性，您可以完全按照自己的意愿对类进行建模，使意图清晰明了。本节将深入探讨帮助面向对象设计的C#功能。
- en: Static
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态
- en: Up till now in this book, you have interacted mostly with `static` code. This
    refers to code that does not need new classes and objects, and that can be called
    right away. In C#, the static modifier can be applied in five different scenarios—methods,
    fields, classes, constructors, and the `using` statement.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，您主要与`static`代码进行交互。这指的是不需要新类和对象的代码，并且可以立即调用。在C#中，静态修饰符可以应用于五种不同的场景——方法、字段、类、构造函数和`using`语句。
- en: 'Static methods and fields are the simplest application of the `static` keyword:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法和字段是`static`关键字的最简单应用：
- en: '[PRE120]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Note
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/748m3](https://packt.link/748m3).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/748m3](https://packt.link/748m3)找到此示例中使用的代码。
- en: 'Here, you created a class called `DogsGenerator`. A `static class` cannot be
    initialized manually (using the `new` keyword). Internally, it is initialized,
    but only once. Calling the `GenerateDog` method returns a new `Dog` object with
    a counter next to its name, such as `Dog1`, `Dog2`, and `Dog3`. Writing a counter
    like this allows you to increment it from everywhere as it is `public static`
    and has a setter. This can be done by directly accessing the member from a class:
    `DogsGenerator.Counter++` will increment the counter by `1`.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您创建了一个名为`DogsGenerator`的类。`静态类`不能手动初始化（使用`new`关键字）。在内部，它被初始化，但只有一次。调用`GenerateDog`方法将返回一个带有名称旁边计数器的新`Dog`对象，例如`Dog1`，`Dog2`和`Dog3`。像这样写一个计数器允许您从任何地方递增它，因为它是`public
    static`并且有一个setter。这可以通过直接从类中访问成员来完成：`DogsGenerator.Counter++`将计数器递增`1`。
- en: Once again, note that this does not require a call through an object because
    a `static class` instance is the same for the entire application. However, `DogsGenerator`
    is not the best example of a `static class`. That's because you have just created
    a global state. Many people would say that `static` is inefficient and should
    be avoided because it might create unpredictable results due to being modified
    and accessed uncontrollably.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，这不需要通过对象调用，因为`static class`实例对整个应用程序是相同的。然而，`DogsGenerator`并不是`static class`的最佳示例。这是因为您刚刚创建了一个全局状态。许多人会说`static`是低效的，应该避免使用，因为它可能由于被无法控制地修改和访问而产生不可预测的结果。
- en: A public mutable state means that changes can happen from anywhere in the application.
    Other than being hard to grasp, such code is also prone to breaking in the context
    of applications with multiple threads (that is, it is not thread-safe).
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 公共可变状态意味着应用程序中的任何地方都可以发生更改。除了难以理解之外，这样的代码在具有多个线程的应用程序环境中也容易出现故障（即它不是线程安全的）。
- en: Note
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You will learn about threading in detail in *Chapter 5*, *Concurrency: Multithreading
    Parallel and Async Code*.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*第5章*“并发：多线程并行和异步代码”中详细了解线程。
- en: You can reduce the impact of a global state by making it publicly immutable.
    The benefit of doing so is that now you are in control. Instead of allowing a
    counter increment to happen from any place inside a program, you will change it
    within `DogsGenerator` only. For the `counter` property, achieving it is as simple
    as making the setter property `private`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使全局状态公开不可变来减少其影响。这样做的好处是现在您有了控制权。与允许计数器在程序的任何地方增加不同，您将仅在`DogsGenerator`内部更改它。对于`counter`属性，实现它就像将setter属性设为`private`那样简单。
- en: There is one valuable use case for the `static` keyword though, which is with
    helper functions. Such functions take an input and return the output without modifying
    any state internally. Moreover, a class that contains such functions is `static`
    and has no state. Another good application of the `static` keyword is creating
    immutable constants. They are defined with a different keyword (`const`). The
    `PI` and `E`, static helper methods such as `Sqrt` and `Abs`, and so on.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`static`关键字还有一个有价值的用例，那就是辅助函数。这样的函数接受输入并返回输出，而不在内部修改任何状态。此外，包含这些函数的类是`static`并且没有状态。`static`关键字的另一个良好应用是创建不可变常量。它们使用不同的关键字（`const`）进行定义。`PI`和`E`，静态辅助方法如`Sqrt`和`Abs`等。
- en: The `DogsGenerator` class has no members that would be applicable to an object.
    If all class members are `static`, then the class should be `static` as well.
    Therefore, you should change the class to `public static class DateGenerator`.
    Be aware, however, that depending on `static` is the same as depending on a concrete
    implementation. Although they are easy to use and straightforward, static dependencies
    are hard to escape and should only be used for simple code, or code that you are
    sure will not change and is critical in its implementation details. For that reason,
    the `Math` class is a `static class` as well; it has all the foundations for arithmetic
    calculations.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`DogsGenerator`类没有适用于对象的成员。如果所有类成员都是`static`，那么类也应该是`static`。因此，您应该将类更改为`public
    static class DateGenerator`。然而，请注意，依赖`static`与依赖具体实现是一样的。虽然它们易于使用和直接，但是静态依赖很难摆脱，应该仅用于简单的代码，或者您确定不会更改并且在其实现细节中至关重要的代码。因此，`Math`类也是一个`static
    class`；它具有所有算术计算的基础。'
- en: 'The last application of `static` is `using static`. Applying the `static` keyword
    before a `using` statement causes all methods and fields to be directly accessible
    without the need to call a `class`. For example, consider the following code:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`的最后一个应用是`using static`。在`using`语句之前应用`static`关键字会导致所有方法和字段可以直接访问，而无需调用`class`。例如，考虑以下代码：'
- en: '[PRE121]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This is a static import feature in C#. By using `static Math`, all static members
    can be accessed directly.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C#中的静态导入功能。通过使用`static Math`，所有静态成员都可以直接访问。
- en: Sealed
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sealed
- en: Previously, you mentioned that inheritance should be handled with great care
    because the complexity can quickly grow out of hand. You can carefully consider
    complexity when you read and write code, but can you prevent complexity by design?
    C# has a keyword for stopping inheritance called `sealed`. If it logically makes
    no sense to inherit a class, then you should mark it with the `sealed` keyword.
    Security-related classes should also be sealed because it is critical to keep
    them simple and non-overridable. Also, if performance is critical, then methods
    in inherited classes are slower, compared to being directly in a sealed class.
    This is due to how method lookup works.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，您提到继承应该谨慎处理，因为复杂性可能会迅速失控。在阅读和编写代码时，您可以仔细考虑复杂性，但是您能通过设计来预防复杂性吗？C#有一个用于阻止继承的关键字叫做`sealed`。如果逻辑上不合理继承一个类，那么您应该用`sealed`关键字标记它。与安全相关的类也应该是sealed，因为保持它们简单和不可重写是至关重要的。此外，如果性能很重要，那么继承类中的方法比直接在sealed类中慢。这是由于方法查找的工作方式。
- en: Partial
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分
- en: In .NET, it is quite popular to make desktop applications using `WinForms`.
    The way `WinForms` works is that you can design how your application looks, with
    the help of a designer. Internally, it generates UI code and all you have to do
    is double-click a component, which will generate event handler code. That is where
    the partial class comes in. All the boring, autogenerated code will be in one
    class and the code that you write will be in another. The key point to note is
    that both classes will have the same name but be in different files.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，使用`WinForms`制作桌面应用程序非常流行。`WinForms`的工作方式是您可以通过设计帮助设计应用程序的外观。在内部，它会生成UI代码，您只需双击一个组件，它就会生成事件处理程序代码。这就是部分类的用处。所有无聊的自动生成的代码将在一个类中，而您编写的代码将在另一个类中。需要注意的关键点是，这两个类将具有相同的名称，但位于不同的文件中。
- en: You can have as many partial classes as you want. However, the recommended number
    of partial classes is no more than two. The compiler will treat them as one big
    class, but to the user, they will seem like two separate ones. Generating code
    generates new class files, which will overwrite the code you write. Use `partial`
    when you are dealing with autogenerated code. The biggest mistake that beginners
    make is using `partial` to manage big complex classes. If your class is complex,
    it's best to split it into smaller classes, not just different files.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以拥有尽可能多的部分类。然而，推荐的部分类数量不超过两个。编译器会将它们视为一个大类，但对用户来说，它们会看起来像是两个独立的类。生成代码会生成新的类文件，这将覆盖你编写的代码。在处理自动生成的代码时使用`partial`。初学者最大的错误是使用`partial`来管理复杂的大类。如果你的类很复杂，最好将其拆分为较小的类，而不仅仅是不同的文件。
- en: There is one more use case for `partial`. Imagine you have a part of code in
    a class that is only needed in another assembly but is unnecessary in the assembly
    it is originally defined in. You can have the same class in different assemblies
    and mark it as `partial`. That way, a part of a class that is not needed will
    only be used where it is needed and be hidden where it should not be seen.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial`还有一个用例。想象一下，你在一个类中有一部分代码，这部分代码只在另一个程序集中需要，但在它最初定义的程序集中是不必要的。你可以在不同的程序集中拥有相同的类并标记为`partial`。这样，不需要的类的一部分将只在需要的地方使用，并在不应该看到的地方隐藏起来。'
- en: Virtual
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟
- en: 'Abstract methods can be overridden; however, they cannot be implemented. What
    if you wanted to have a method with a default behavior that could be overridden
    in the future? You can do this using the `virtual` keyword, as shown in the following example:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法可以被重写；然而，它们不能被实现。如果你想要一个具有默认行为并且将来可以被重写的方法，你可以使用`virtual`关键字，如下例所示：
- en: '[PRE122]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Here, the `Human` class has the `SayHi` method. This method is prefixed with
    the virtual keyword, which means that it can change behavior in a child class,
    for example:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Human`类有`SayHi`方法。这个方法前缀有虚拟关键字，这意味着它可以在子类中改变行为，例如：
- en: '[PRE123]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Note
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/ZpHhI](https://packt.link/ZpHhI).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/ZpHhI](https://packt.link/ZpHhI)找到本例中使用的代码。
- en: The `Frenchman` class inherits the `Human` class and overrides the `SayHi` method.
    Calling `SayHi` from a `Frenchman` object will print `Bonjour`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frenchman`类继承了`Human`类并重写了`SayHi`方法。从`Frenchman`对象调用`SayHi`将打印`Bonjour`。'
- en: One of the things about C# is that its behavior is hard to override. Upon declaring
    a method, you need to be explicit by telling the compiler that the method can
    be overridden. Only `virtual` methods can be overridden. Interface methods are
    virtual (because they get behavior later), however, you cannot override interface
    methods from child classes. You can only implement an interface in a parent class.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C#的一件事是它的行为很难被重写。在声明方法时，你需要明确告诉编译器该方法可以被重写。只有`virtual`方法可以被重写。接口方法是虚拟的（因为它们后来会得到行为），然而，你不能从子类中重写接口方法。你只能在父类中实现接口。
- en: An abstract method is the last type of virtual method and is the most similar
    to `virtual` in that it can be overridden as many times as you need (in child
    and grandchild classes).
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法是最后一种虚拟方法，与`virtual`最相似，因为它可以在子类和孙子类中被重写多次。
- en: To avoid having fragile, changing, overridable behavior, the best kind of virtual
    methods are the ones that come from an interface. The `abstract` and `virtual`
    keywords enable changing class behavior in child classes and overriding it, which
    can become a big issue if uncontrolled. Overriding behavior often causes both
    inconsistent and unexpected results, so you should be careful before using the
    `virtual` keyword.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免脆弱、易变、可重写的行为，最好的虚拟方法是来自接口的方法。`abstract`和`virtual`关键字使得可以在子类中改变类的行为并重写它，如果不加控制地使用，这可能会成为一个大问题。重写行为经常导致不一致和意外的结果，因此在使用`virtual`关键字之前应该小心。
- en: Internal
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部
- en: '`public`, `private`, and `protected` are the three access modifiers that have
    been mentioned. Many beginners think that the default class modifier is `private`.
    However, `private` means that it cannot be called from outside a class, and in
    the context of a namespace, this does not make much sense. The default access
    modifier for a class is `internal`. This means that the class will only be visible
    inside the namespace it is defined in. The `internal` modifier is great for reusing
    classes across the same assembly, while at the same time hiding them from the
    outside.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`、`private`和`protected`是三个已经提到的访问修饰符。许多初学者认为默认的类修饰符是`private`。然而，`private`意味着它不能从类外部调用，在命名空间的上下文中，这并没有太多意义。类的默认访问修饰符是`internal`。这意味着该类只在它所定义的命名空间内可见。`internal`修饰符非常适合在同一个程序集中重用类，同时将它们隐藏在外部。'
- en: Conditional Operators
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件运算符
- en: 'A null reference exception is probably the most common error in programming.
    For example, refer to the following code:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 空引用异常可能是编程中最常见的错误。例如，参考以下代码：
- en: '[PRE124]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: This code will throw `NullReferenceException` because you are interacting with
    a variable that has a null value. What is the length of a null array? There is
    no proper answer to this question, so an exception will be thrown here.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会抛出`NullReferenceException`，因为你正在与一个空值的变量交互。空数组的长度是多少？这个问题没有正确的答案，所以这里会抛出异常。
- en: The best way to protect against such an error is to avoid working with null
    values altogether. However, sometimes it is unavoidable. In those cases, there
    is another technique called defensive programming. Before using a value that might
    be `null`, make sure it is not `null`.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这种错误的最佳方法是完全避免使用空值。然而，有时是不可避免的。在这些情况下，有一种叫做防御性编程的技术。在使用可能为`null`的值之前，确保它不是`null`。
- en: 'Now recall the example of the `Dog` class. If you create a new object, the
    value of `Owner` could be null. If you were to determine whether the owner''s
    name starts with the letter `A`, you would need to check first whether the value
    of `Owner` is `null`, as follows:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回想一下 `Dog` 类的例子。如果你创建一个新对象，`Owner` 的值可能为 `null`。如果你要确定所有者的名字是否以字母 `A` 开头，你需要首先检查
    `Owner` 的值是否为 `null`，如下所示：
- en: '[PRE125]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'However, in C#, using null-conditional, this code becomes as simple as the
    following:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 C# 中，使用空值条件，这段代码变得和以下一样简单：
- en: '[PRE126]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Null-conditional (`?`) is an example of conditional operators in C#. It is an
    operator that implicitly runs an `if` statement (a specific `if` statement is
    based on the operator) and either returns something or continues work. The `Owner?.StartsWith('A')`
    part returns `true` if the condition is satisfied and `false` if it is either
    not satisfied or the object is `null`.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 空值条件运算符（`?`）是 C# 中条件运算符的一个例子。它是一个隐式运行 `if` 语句的运算符（特定的 `if` 语句是基于该运算符），并且要么返回某些东西，要么继续工作。`Owner?.StartsWith('A')`
    部分如果条件满足则返回 `true`，如果条件不满足或对象为 `null`，则返回 `false`。
- en: There are more conditional operators in C# that you will learn about.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中还有更多的条件运算符，你会在学习中了解到。
- en: Ternary Operators
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'There is hardly any language that does not have `if` statements. One of the
    most common kinds of `if` statement is `if-else`. For example, if the value of
    `Owner` is `null` for an instance of the `Dog` class, you can describe the instance
    simply as `{Name}`. Otherwise, you can better describe it as `{Name}, dog of {Owner}`,
    as shown in the following snippet:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有一种语言不包含 `if` 语句。最常见的 `if` 语句之一是 `if-else`。例如，如果 `Dog` 类的实例的 `Owner` 的值为
    `null`，你可以简单地描述实例为 `{Name}`。否则，你可以更好地描述它为 `{Name}, dog of {Owner}`，如下所示：
- en: '[PRE127]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'C#, like many other languages, simplifies this by using a ternary operator:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他语言一样，C# 通过使用三元运算符简化了这个过程。
- en: '[PRE128]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: On the left side, you have a condition (true or false), followed by a question
    mark (`?`), which returns the value on the right if the condition is true, followed
    by a colon (`:`), which returns the value to the left if the condition is false.
    `$` is a string interpolation literal, which allows you to write `$"{dog1.Name},
    dog of {dog1.Owner}"` over `dog1.Name + "dog of" + dog1.Owner`. You should use
    it when concatenating text.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，你有一个条件（true 或 false），后面跟着一个问号（`?`），如果条件为真，则返回右侧的值，后面跟着一个冒号（`:`），如果条件为假，则返回左侧的值。`$`
    是一个字符串插值文字，它允许你写 `$"{dog1.Name}, dog of {dog1.Owner}"` 而不是 `dog1.Name + "dog of"
    + dog1.Owner`。在连接文本时应该使用它。
- en: 'Imagine there are two dogs now. You want the first dog to join the second one
    (that is, be owned by the owner of the second dog), but this can only happen if
    the second one has an owner to begin with. Normally, you would use the following
    code:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设有两只狗。你希望第一只狗加入第二只狗（也就是说，被第二只狗的主人拥有），但这只有在第二只狗有主人的情况下才能发生。通常，你会使用以下代码：
- en: '[PRE129]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'But in C#, you can use the following code:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在 C# 中，你可以使用以下代码：
- en: '[PRE130]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Here, you have applied the null-coalescing operator (`??`), which returns the
    value to the right if it is `null` and the value on the left if it is not `null`.
    However, you can simplify this further:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你应用了空值合并运算符（`??`），如果它是 `null`，则返回右侧的值，如果不是 `null`，则返回左侧的值。但是，你可以进一步简化这个过程：
- en: '[PRE131]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This means that if the value that you are trying to assign (on the left) is
    `null`, then the output will be the value on the right.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你要分配的值（在左侧）是 `null`，那么输出将是右侧的值。
- en: 'The last use case for the null-coalescing operator is input validation. Suppose
    there are two classes, `ComponentA` and `ComponentB`, and `ComponentB` must contain
    an initialized instance of `ComponentA`. You could write the following code:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 空值合并运算符的最后一个用例是输入验证。假设有两个类，`ComponentA` 和 `ComponentB`，并且 `ComponentB` 必须包含
    `ComponentA` 的一个初始化实例。你可以写以下代码：
- en: '[PRE132]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'However, instead of the preceding code, you can simply write the following:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以简单地写成以下形式：
- en: '[PRE133]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This can be read as If there is no `componentA`, then an exception must be thrown.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以理解为如果没有 `componentA`，那么必须抛出异常。
- en: Note
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/yHYbh](https://packt.link/yHYbh).
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/yHYbh](https://packt.link/yHYbh) 找到此示例中使用的代码。
- en: In most cases, null operators should replace the standard `if null-else` statements.
    However, be careful with the way you use the ternary operator and limit it to
    simple `if-else` statements because the code can become unreadable very quickly.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，空值运算符应该替换标准的 `if null-else` 语句。但是，要小心使用三元运算符的方式，并将其限制在简单的 `if-else`
    语句中，因为代码可能会变得非常难读。
- en: Overloading Operators
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载运算符
- en: It is fascinating how much can be abstracted away in C#. Comparing primitive
    numbers, multiplying, or dividing them is easy, but when it comes to objects,
    it is not that simple. What is one person plus another person? What is a bag of
    apples multiplied by another bag of apples? It is hard to say, but it can make
    total sense in the context of some domains.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中有多少东西可以被抽象化，这是很迷人的。比较原始数字，相乘或相除都很容易，但是当涉及到对象时，情况就不那么简单了。一个人加上另一个人是什么？一个袋子的苹果乘以另一个袋子的苹果是什么？很难说，但在某些领域的情况下，这是完全有意义的。
- en: 'Consider a slightly better example. Suppose you are comparing bank accounts.
    Finding out who has more money in a bank account is a common use case. Normally,
    to compare two accounts, you would have to access their members, but C# allows
    you to overload comparison operators so that you can compare objects. For example,
    imagine you had a `BankAccount` class like so:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个稍微好一点的例子。假设你正在比较银行账户。找出哪个银行账户里的钱更多是一个常见的用例。通常，要比较两个账户，你需要访问它们的成员，但是 C# 允许你重载比较运算符，以便你可以比较对象。例如，假设你有一个像这样的
    `BankAccount` 类：
- en: '[PRE134]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Here, the balance amount is `private`. You do not care about the exact value
    of `balance`; all you want is to compare one with another. You could implement
    a `CompareTo` method, but instead, you will implement a comparison operator. In
    the `BankAccount` class, you will add the following code:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，余额金额是`private`。你不关心`balance`的确切值；你只想比较一个与另一个。你可以实现一个`CompareTo`方法，但相反，你将实现一个比较运算符。在`BankAccount`类中，你将添加以下代码：
- en: '[PRE135]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The preceding code is called an operator overload. With a custom operator overload
    like this, you can return true when a balance is bigger and false otherwise. In
    C#, operators are `public static`, followed by a return type. After that, you
    have the `operator` keyword followed by the actual operator that is being overloaded.
    The input depends on the operator being overloaded. In this case, you passed two
    bank accounts.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码称为运算符重载。通过自定义运算符重载，你可以在余额更大时返回true，否则返回false。在C#中，运算符是`public static`，后面跟着返回类型。之后，你有`operator`关键字，后面跟着被重载的实际运算符。输入取决于被重载的运算符。在这种情况下，你传递了两个银行账户。
- en: 'If you tried to compile the code as it is, you would get an error that something
    is missing. It makes sense that the comparison operators have a twin method that
    does the opposite. Now, add the less operator overload as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试按原样编译代码，你会得到一个错误，说有东西丢失了。比较运算符有一个相反的方法是有意义的。现在，添加小于运算符重载如下：
- en: '[PRE136]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The code compiles now. Finally, it would make sense to have an equality comparison.
    Remember, you will need to add a pair, equal and not equal:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码已经编译。最后，有一个相等比较是有意义的。记住，你需要添加一对，相等和不相等：
- en: '[PRE137]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Next, you will create bank accounts to compare. Note that all numbers have
    an `m` appended, as this suffix makes those numbers `decimal`. By default, numbers
    with a fraction are `double`, so you need to add `m` at the end to make them `decimal`:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建要比较的银行账户。请注意，所有数字都有一个附加的`m`，因为这个后缀使这些数字成为`decimal`。默认情况下，带有小数的数字是`double`，所以你需要在末尾添加`m`使它们成为`decimal`：
- en: '[PRE138]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Comparing two bank accounts becomes as simple as this now:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 现在比较两个银行账户变得如此简单：
- en: '[PRE139]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Running the code results in the following being printed to the console:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会导致以下内容被打印到控制台：
- en: '[PRE140]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Note
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/5DioJ](https://packt.link/5DioJ).
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/5DioJ](https://packt.link/5DioJ)找到此示例中使用的代码。
- en: Many (but not all) operators can be overloaded, but just because you can do
    so does not mean you should. Overloading operators can make sense in some cases,
    but in other cases, it might be counterintuitive. Again, remember to not abuse
    C# features and use them when it makes **logical** sense, and when it makes code
    easier to read, learn, and maintain.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 许多（但不是所有）运算符可以被重载，但仅仅因为你可以这样做并不意味着你应该这样做。在某些情况下，重载运算符是有意义的，但在其他情况下，可能是违反直觉的。再次强调，记住不要滥用C#的特性，只有在**逻辑**上有意义，使代码更易于阅读、学习和维护时才使用它们。
- en: Nullable Primitive Types
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可空原始类型
- en: Have you ever wondered what to do when a primitive value is unknown? For example,
    say a collection of products are announced. Their names, descriptions, and some
    other parameters are known, but the price is revealed only before the launch.
    What type should you use for storing the price values?
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想过当原始值是未知的时候该怎么办？例如，假设一组产品已经宣布。它们的名称、描述和一些其他参数是已知的，但价格只在发布前才公布。你应该使用什么类型来存储价格值？
- en: 'Nullable primitive types are primitive types that might have some value or
    no value. In C#, to declare such a type, you have to add `?` after a primitive,
    as shown in the following code:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 可空原始类型是可能具有一些值或没有值的原始类型。在C#中，要声明这样的类型，你必须在原始类型后添加`?`，如下面的代码所示：
- en: '[PRE141]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Here, you declared a field that may or may not have a value. Specifically, this
    means that a can be unknown. Do not confuse this with a default value because,
    by default, the value of `int` types is `0`.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你声明了一个可能有值也可能没有值的字段。具体来说，这意味着a可能是未知的。不要将其与默认值混淆，因为默认情况下，`int`类型的值是`0`。
- en: 'You can assign a value to a nullable field quite simply, as follows:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很简单地给可空字段赋值，如下所示：
- en: '[PRE142]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'And to retrieve its value afterward, you can write the code as follows:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以按照以下方式编写代码来检索其值：
- en: '[PRE143]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Generics
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型
- en: 'Sometimes, you will come across situations where you do the exact same thing
    with different types, where the only difference is because of the type. For example,
    if you had to create a method that prints an `int` value, you could write the
    following code:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会遇到这样的情况，你用不同的类型做完全相同的事情，唯一的区别是类型。例如，如果你需要创建一个打印`int`值的方法，你可以写以下代码：
- en: '[PRE144]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Similarly, if you need to print a string, you could add yet another overload:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你需要打印一个字符串，你可以添加另一个重载：
- en: '[PRE145]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'You did the same thing three times. Surely, there must be a way to reduce code
    duplication. Remember, in C#, all types derive from an `object` type, which has
    the `ToString()` method, so you can execute the following command:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 你做了三次相同的事情。当然，一定有办法减少代码重复。记住，在C#中，所有类型都派生自`object`类型，它有`ToString()`方法，所以你可以执行以下命令：
- en: '[PRE146]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Even though the last implementation contains the least code, it is actually
    the least efficient. An object is a reference type, whereas a primitive is a value
    type. When you take a primitive and assign it to an object, you also create a
    new reference to it. This is called boxing. It does not come for free, because
    you move objects from `stack to heap`. Programmers should be conscious of this
    fact and avoid it wherever possible.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最后的实现包含的代码最少，但实际上效率最低。对象是引用类型，而原始类型是值类型。当你将一个原始类型赋值给一个对象时，你也创建了一个新的引用。这就是所谓的装箱。它并不是免费的，因为你将对象从`堆栈`移动到`堆`。程序员应该意识到这一事实，并尽可能避免它。
- en: 'Earlier in the chapter, you encountered polymorphism—a way of doing different
    things using the same type. You can do the same things with different types as
    well and generics are what enable you to do that. In the case of the `Print` example,
    a generic method is what you need:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，你遇到了多态性——一种使用相同类型进行不同操作的方式。你也可以使用不同类型做同样的事情，泛型是让你能够做到这一点的关键。在`Print`示例中，你需要一个泛型方法：
- en: '[PRE147]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Using diamond brackets (`<>`), you can specify a type, `T`, with which this
    function works. `<T>` means that it can work with any type.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 使用菱形括号（`<>`），你可以指定一个类型`T`，这个函数可以使用`<T>`表示它可以与任何类型一起工作。
- en: 'Now, suppose you want to print all elements of an array. Simply passing a collection
    to a `WriteLine` statement would result in printing a reference, instead of all
    the elements. Normally, you would create a method that prints all the elements
    passed. With the power of generics, you can have one method that prints an array
    of any type:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想打印数组的所有元素。简单地将一个集合传递给`WriteLine`语句将导致打印一个引用，而不是所有的元素。通常情况下，你会创建一个打印所有传递元素的方法。有了泛型的强大功能，你可以有一个方法来打印任何类型的数组：
- en: '[PRE148]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Please note that the generic version is not as efficient as taking an `object`
    type, simply because you would still be using a `WriteLine` overload that takes
    an object as a parameter. When passing a generic, you cannot tell whether it needs
    to call an overload with an `int`, `float`, or `String`, or whether there is an
    exact overload in the first place. If there was no overload that takes an object
    for `WriteLine`, you would not be able to call the `Print` method. For that reason,
    the most performant code is actually the one with three overloads. It is not terribly
    important though because that is just one, very specific scenario where boxing
    happens anyway. There are so many other cases, however, where you can make it
    not only concise but performant as well.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，泛型版本不像使用`object`类型那样高效，因为你仍然会使用以`object`作为参数的`WriteLine`重载。当传递一个泛型时，你无法确定它是否需要调用一个带有`int`、`float`或`String`的重载，或者是否一开始就有一个确切的重载。如果没有一个接受对象参数的`WriteLine`重载，你将无法调用`Print`方法。因此，最有效的代码实际上是具有三个重载的代码。不过这并不是非常重要，因为这只是一个非常特定的场景，无论如何都会发生装箱。然而，在许多其他情况下，你不仅可以使代码简洁，而且还可以使其高效。
- en: 'Sometimes, the answer to choosing a generic or polymorphic function hides in
    tiny details. If you had to implement a method for comparing two elements and
    return `true` if the first one is bigger, you could do that in C# using an `IComparable` interface:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，选择泛型或多态函数的答案隐藏在微小的细节中。如果你需要实现一个比较两个元素并在第一个元素更大时返回`true`的方法，你可以在C#中使用`IComparable`接口来实现：
- en: '[PRE149]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'A generic version of this would look like this:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这个的泛型版本将如下所示：
- en: '[PRE150]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The new bit here is `where T : IComparable`. It is a generic constraint. By
    default, you can pass any type to a generic class or method. Constraints still
    allow different types to be passed, but they significantly reduce the possible
    options. A generic constraint allows only the types that conform to the constraint
    to be passed as a generic type. In this case, you will allow only the types that
    implement the `IComparable` interface. Constraints might seem like a limitation
    on types; however, they expose the behavior of the constrained types that you
    can use inside a generic method. Having constraints enables you to use the features
    of those types, so it is very useful. In this case, you do limit yourself to what
    types can be used, but at the same time, whatever you pass to the generic method
    will be comparable.'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '这里的新内容是`where T : IComparable`。这是一个泛型约束。默认情况下，你可以将任何类型传递给泛型类或方法。约束仍然允许传递不同的类型，但它们显著减少了可能的选项。泛型约束只允许符合约束的类型作为泛型类型传递。在这种情况下，你只允许实现`IComparable`接口的类型。约束可能看起来像是对类型的限制；然而，它们暴露了在泛型方法中可以使用的受约束类型的行为。有了约束，你可以使用这些类型的特性，因此它非常有用。在这种情况下，你确实限制了可以使用的类型，但同时，无论你传递什么类型到泛型方法中，它都是可比较的。'
- en: 'What if instead of returning whether the first element is bigger, you needed
    to return the first element itself? You could write a non-generic method as follows:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要返回第一个元素本身，而不是返回第一个元素是否更大，你可以编写一个非泛型方法如下：
- en: '[PRE151]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'And the generic version would look as follows:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型版本如下所示：
- en: '[PRE152]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Also, it is worth comparing how you will get a meaningful output using each
    version. With a non-generic method, this is what the code would look like:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，值得比较的是，你将如何使用每个版本获得有意义的输出。使用非泛型方法，代码将如下所示：
- en: '[PRE153]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'With a generic version, the code would be like this:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 有了泛型版本，代码会像这样：
- en: '[PRE154]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Note
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/sIdOp](https://packt.link/sIdOp).
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/sIdOp](https://packt.link/sIdOp)找到本示例中使用的代码。
- en: In this case, the winner is obvious. In the non-generic version, you have to
    do a cast. Casting in code is frowned upon because if you do get errors, you will
    get them during runtime and things might change and the cast will fail. Casting
    is also one extra action, whereas the generic version is far more fluent because
    it does not have a cast. Use generics when you want to work with types as-is and
    not through their abstractions. And returning an exact (non-polymorphic) type
    from a function is one of the best use cases for it.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，胜者是显而易见的。在非泛型版本中，你必须进行强制转换。在代码中进行强制转换是不受欢迎的，因为如果你出现错误，你将在运行时得到错误，事情可能会发生变化，强制转换将失败。强制转换也是额外的操作，而泛型版本更加流畅，因为它不需要强制转换。当你想要直接使用类型而不是通过它们的抽象时，请使用泛型。从函数中返回一个确切的（非多态）类型是它的最佳用例之一。
- en: C# generics will be covered in detail in *Chapter 4*, *Data Structures and LINQ*.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: C#泛型将在*第4章*，*数据结构和LINQ*中详细介绍。
- en: Enum
  id: totrans-619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: 'The `enum` type represents a set of known values. Since it is a type, you can
    pass it instead of passing a primitive value to methods. `enum` holds all the
    possible values, hence it isn''t possible to have a value that it would not contain.
    The following snippet shows a simple example of this:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`类型表示一组已知的值。由于它是一种类型，您可以将其传递给方法而不是传递原始值。`enum`包含所有可能的值，因此不可能有一个值它不包含。以下代码片段显示了一个简单的示例：'
- en: '[PRE155]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Note
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/gP9Li](https://packt.link/gP9Li).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/gP9Li](https://packt.link/gP9Li)找到此示例使用的代码。
- en: You can now get a possible gender value as if it were in a `static class` by
    writing `Gender.Other`. Enums can easily be converted to an integer using casting—`(int)Gender.Male`
    will return `0`, `(int)Gender.Female` will return `1`, and so on. This is because
    `enum`, by default, starts numbering at `0`.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过编写`Gender.Other`来获取可能的性别值，就好像它在一个`static class`中一样。枚举可以很容易地通过强制转换转换为整数—`(int)Gender.Male`将返回`0`，`(int)Gender.Female`将返回`1`，依此类推。这是因为`enum`默认从`0`开始编号。
- en: Enums do not have any behavior and they are known as constant containers. You
    should use them when you want to work with constants and prevent invalid values
    from being passed by design.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举没有任何行为，它们被称为常量容器。当您想要使用常量并防止通过设计传递无效值时，应该使用它们。
- en: Extension Methods
  id: totrans-626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展方法
- en: Almost always, you will be working with a part of code that does not belong
    to you. Sometimes, this might cause inconvenience because you have no access to
    change it. Is it possible to somehow extend the existing types with the functionality
    you want? Is it possible to do so without inheriting or creating new component
    classes?
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是，您将会处理不属于您的代码的一部分。有时，这可能会造成不便，因为您无法访问更改它。是否可能以某种方式扩展现有类型以获得所需的功能？是否可能在不继承或创建新组件类的情况下做到这一点？
- en: You can achieve this easily through extension methods. They allow you to add
    methods on complete types and call them as if those methods were natively there.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展方法，您可以轻松实现这一点。它们允许您在完整类型上添加方法，并且可以像本地方法一样调用它们。
- en: 'What if you wanted to print a `string` to a console using a `Print` method,
    but call it from a `string` itself? `String` has no such method, but you can add
    it using an extension method:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要使用`Print`方法将`string`打印到控制台，但是从`string`本身调用它呢？`String`没有这样的方法，但是您可以使用扩展方法添加它：
- en: '[PRE156]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'And this allows you to write the following code:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以编写以下代码：
- en: '[PRE157]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'This will print `Hey` to the console as follows:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台上打印`Hey`如下：
- en: '[PRE158]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Note
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/JC5cj](https://packt.link/JC5cj).
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/JC5cj](https://packt.link/JC5cj)找到此示例使用的代码。
- en: Extension methods are `static` and must be placed within a `static class`. If
    you look at the semantics of the method, you will notice the use of the `this`
    keyword. The `this` keyword should be the first argument in an extension method.
    After that, the function continues as normal and you can use the argument with
    the `this` keyword as if it was just another argument.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法是`static`的，必须放在一个`static class`中。如果您查看方法的语义，您会注意到使用了`this`关键字。`this`关键字应该是扩展方法中的第一个参数。之后，函数继续正常进行，您可以使用带有`this`关键字的参数，就好像它只是另一个参数一样。
- en: Use extension methods to add (extend, but not the same extensions as what happens
    with inheritance) new behavior to existing types, even if the type would not support
    having methods otherwise. With extension methods, you can even add methods to
    `enum` types, which is not possible otherwise.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展方法可以向现有类型添加（扩展，但不是与继承发生的相同扩展）新的行为，即使该类型在其他情况下不支持具有方法。通过扩展方法，甚至可以向`enum`类型添加方法，否则是不可能的。
- en: Struct
  id: totrans-639
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构
- en: A class is a reference type, but not all objects are reference types (saved
    on the heap). Some objects can be created on the stack, and such objects are made
    using structs.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 类是引用类型，但并非所有对象都是引用类型（保存在堆上）。有些对象可以在堆栈上创建，这样的对象是使用结构创建的。
- en: 'A struct is defined like a class, but it is used for slightly different things.
    Now, create a `struct` named `Point`:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 结构的定义类似于类，但用于稍有不同的事情。现在，创建一个名为`Point`的`struct`：
- en: '[PRE159]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The only real difference here is the `struct` keyword, which indicates that
    this object will be saved on the stack. Also, you might have noticed that there
    is no use of properties. There are many people who would, instead of `Point`,
    type `x` and `y`. It is not a big deal, but instead of one variable, you would
    be working with two. This way of working with primitives is called primitive obsession.
    You should follow the principles of OOP and work with abstractions, well-encapsulated
    data, as well as behavior to keep things close so that they have high cohesion.
    When choosing where to place variables, ask yourself this question: can `x` change
    independently of `y`? Do you ever modify a point? Is a point a complete value
    on its own? The answer to all of this is **yes** and therefore putting it in a
    data structure makes sense. But why choose a struct over a class?'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的真正区别是`struct`关键字，它表示这个对象将被保存在堆栈上。此外，您可能已经注意到没有使用属性。有很多人会用`x`和`y`代替`Point`。这并不是什么大不了的事，但是你会用两个变量来代替一个变量。这种使用原始类型的方式被称为原始类型偏执。您应该遵循面向对象编程的原则，使用抽象、封装良好的数据以及行为来保持高内聚。在选择变量放置的位置时，问问自己这个问题：`x`能独立于`y`改变吗？你会修改一个点吗？点本身是一个完整的值吗？所有这些问题的答案都是**是**，因此将其放入数据结构中是有意义的。但为什么选择结构而不是类呢？
- en: Structs are fast because they do not have any allocations on the heap. They
    are also fast because they are passed by value (therefore, access is direct, not
    through a reference). Passing them by value copies the values, so even if you
    could modify a struct, changes would not remain outside of a method. When something
    is just a simple, small composite value, you should use a struct. Finally, with
    structs, you get value equality.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体很快，因为它们在堆上没有任何分配。它们也很快，因为它们是按值传递的（因此，访问是直接的，而不是通过引用）。按值传递值，因此即使您可以修改结构体，更改也不会在方法外保留。当某物只是一个简单的、小的复合值时，您应该使用结构体。最后，使用结构体，您可以获得值相等。
- en: Another effective example of a `struct` is `DateTime`. `DateTime` is just a
    unit of time, containing some information. It also does not change individually
    and supports methods such as `AddDays`, `TryParse`, and `Now`. Even though it
    has several different pieces of data, they can be treated as one unit, as they
    are date- and time-related.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`的另一个有效示例是`DateTime`。`DateTime`只是一个时间单位，包含一些信息。它也不会单独改变，并支持`AddDays`、`TryParse`和`Now`等方法。即使它有几个不同的数据片段，它们可以被视为一个单位，因为它们与日期和时间相关。'
- en: 'Most `structs` should be immutable because they are passed by a copy of a value,
    so changing something inside a method will not keep those changes. You can add
    a `readonly` keyword to a `struct`, making all its fields `readonly`:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`structs`应该是不可变的，因为它们是通过值的副本传递的，所以在方法内部更改某些东西不会保留这些更改。您可以向`struct`添加一个`readonly`关键字，使其所有字段都是`readonly`：
- en: '[PRE160]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'A `readonly` `struct` can have either a `readonly` field or getter properties.
    This is useful for the future maintainers of your code base as it prevents them
    from doing things that you did not design for (no mutability). Structs are just
    tiny grouped bits of data, but they can have behavior as well. It makes sense
    to have a method to calculate the distance between two points:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`readonly` `struct`可以有一个`readonly`字段或getter属性。这对于您代码库的未来维护者非常有用，因为它可以防止他们做您没有设计的事情（不可变性）。结构体只是一小组数据位，但它们也可以有行为。有一个方法来计算两点之间的距离是有意义的：
- en: '[PRE161]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The preceding code has a little bit of math in it—that is, distance between
    two points is the square root of points x's and y's squared differences added
    together.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中有一点数学知识——即两点之间的距离是点x和y的平方差相加的平方根。
- en: 'It also makes sense to calculate the distance between this and other points.
    You do not need to change anything because you can just reuse the existing code,
    passing correct arguments:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 计算这个点和其他点之间的距离也是有意义的。您不需要改变任何东西，因为您可以重用现有的代码，传递正确的参数：
- en: '[PRE162]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'If you wanted to measure the distance between two points, you could create
    them like this:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要测量两点之间的距离，可以这样创建它们：
- en: '[PRE163]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'And use a member function to calculate distance:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用成员函数来计算距离：
- en: '[PRE164]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Or a static function:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 或一个静态函数：
- en: '[PRE165]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'The result for each version will be as follows:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 每个版本的结果将如下：
- en: '[PRE166]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Note
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/PtQzz](https://packt.link/PtQzz).
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/PtQzz](https://packt.link/PtQzz)找到此示例使用的代码。
- en: When you think about a struct, think about it as just a group of primitives.
    The key point to remember is that all the data members (properties or fields)
    in a struct must be assigned during object initialization. It needs to be done
    for the same reason local variables cannot be used without having a value set
    initially. Structs do not support inheritance; however, they do support implementing
    an interface.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 当您考虑一个结构体时，把它看作只是一组原始类型。需要记住的关键点是结构体中的所有数据成员（属性或字段）在对象初始化期间必须被赋值。出于同样的原因，局部变量在没有初始设置值的情况下不能使用。结构体不支持继承；然而，它们支持实现接口。
- en: Structs are actually a great way to have simple business logic. Structs should
    be kept simple and should not contain other object references within them; they
    should be primitive-only. However, a class can hold as many struct objects as
    it needs. Using structs is a great way of escaping the obsessive use of primitives
    and using simple logic naturally, within a tiny group of data where it belongs—that
    is, a `struct`.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体实际上是一个简单业务逻辑的好方法。结构体应该保持简单，不应该包含其他对象引用；它们应该只包含原始值。然而，一个类可以持有它需要的许多结构体对象。使用结构体是一种逃避过度使用原始类型并自然地使用简单逻辑的好方法，它们属于数据的一个小组——即`struct`。
- en: Record
  id: totrans-665
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录
- en: A record is a reference type (unlike a `struct`, more like a class). However,
    out of the box, it has methods for comparison by value (both using the `equals`
    method and the operator). Also, a record has a different default implementation
    of `ToString()`, which no longer prints a type, but instead all the properties.
    This is exactly what is needed in many cases, so it helps a lot. Finally, there
    is a lot of syntactic sugar around records, which you are about to witness.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是引用类型（不像`struct`，更像类）。然而，它具有按值比较的方法（使用`equals`方法和运算符）。此外，记录有一个不同的`ToString()`的默认实现，不再打印类型，而是打印所有属性。在许多情况下，这正是所需要的，因此它非常有帮助。最后，记录周围有很多语法糖，您即将见证。
- en: 'You already know how to create custom types in C#. The only difference between
    different custom types is the keyword used. For record types, such a keyword is
    `record`. For example, you will now create a movie record. It has a `Title`, `Director`,
    `Producer`, `Description`, and a `ReleaseDate`:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道如何在C#中创建自定义类型。不同自定义类型之间唯一的区别是使用的关键字。对于记录类型，这样一个关键字是`record`。例如，您现在将创建一个电影记录。它有一个`Title`、`Director`、`Producer`、`Description`和一个`ReleaseDate`：
- en: '[PRE167]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: So far, you should find this very familiar, because the only difference is the
    keyword. Regardless of such a minor detail, you already reap major benefits.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该会觉得这非常熟悉，因为唯一的区别是关键字。尽管有这样一个细微的差别，您已经获得了重大的好处。
- en: Note
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The intention of having `MovieRecordV1` class in chapter, as against `MovieClass`
    in GitHub code, was to have a type, similar to a class and then refactor highlighting
    how record helps.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中拥有`MovieRecordV1`类的意图，与GitHub代码中的`MovieClass`相对应，是为了拥有一个类似于类的类型，然后重构突出显示记录如何帮助。
- en: 'Create two identical movies:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两部相同的电影：
- en: '[PRE168]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'So far, everything is the same. Try to print a movie to the console:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都一样。尝试将电影打印到控制台：
- en: '[PRE169]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The output would be as follows:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE170]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Note
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/xylkW](https://packt.link/xylkW).
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/xylkW](https://packt.link/xylkW)找到此示例中使用的代码。
- en: If you tried doing the same to a class or a `struct` object, you would only
    get a type printed. However, for a record, a default behavior is to print all
    of its properties and their values.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试对类或`struct`对象执行相同操作，您将只获得一个类型打印。但是，对于记录，默认行为是打印其所有属性及其值。
- en: 'That is not the only benefit of a record. Again, a record has value-equality
    semantics. Comparing two movie records will compare them by their property values:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是记录的唯一好处。再次，记录具有值相等语义。比较两个电影记录将通过它们的属性值进行比较：
- en: '[PRE171]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: This will print `true true`.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印`true true`。
- en: 'With the same amount of code, you have managed to get the most functionality
    by simply changing a data structure to a record. Out of the box, a record provides
    `Equals()`, `GetHashCode() overrides`, `== and != overrides`, and even a `ToString`
    override, which prints the record itself (all the members and their values). The
    benefits of records do not end there because, using them, you have a way to reduce
    a lot of boilerplate code. Take full advantage of records and rewrite your movie
    record:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同数量的代码，您已经成功地通过简单地将数据结构更改为记录来获得最大的功能。记录提供了`Equals()`，`GetHashCode()`覆盖，`==和!=覆盖`，甚至`ToString`覆盖，它打印记录本身（所有成员及其值）。记录的好处并不止于此，因为使用它们，您可以减少大量样板代码。充分利用记录并重写您的电影记录：
- en: '[PRE172]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'This is a positional record, meaning all that you pass as parameters will end
    up in the right read-only data members as if it was a dedicated constructor. If
    you ran the demo again, you would notice that it no longer compiles. The major
    difference with this declaration is that, now, changing a description is no longer
    possible. Making a mutable property is not difficult, you just need to be explicit
    about it:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个位置记录，这意味着您传递的所有参数将最终出现在正确的只读数据成员中，就好像它是一个专用构造函数。如果您再次运行演示，您会注意到它不再编译。这个声明的主要区别是，现在不再可能更改描述。使可变属性并不困难，您只需要明确说明：
- en: '[PRE173]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'You started this paragraph with a discussion on immutability, but why is the
    primary focus on records? The benefits of records are actually immutability-focused.
    Using a `with` expression, you can create a copy of a record object with zero
    or more properties modified. So, suppose you add this to your demo:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 您从讨论不可变性开始了这一段，但为什么主要关注记录？记录的好处实际上是不可变性。使用`with`表达式，您可以创建一个记录对象的副本，其中有零个或更多个属性被修改。所以，假设您将这个添加到您的演示中：
- en: '[PRE174]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'The code would result in this:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将导致这种情况：
- en: '[PRE175]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: As you see, this code copies an object with just one property changed. Before
    records, you would need a lot of code to ensure all the members are copied, and
    only then would you set a value. Keep in mind that this creates a shallow copy.
    A shallow copy is an object with all the references copied. A deep copy is an
    object with all the reference-type objects recreated. Unfortunately, there is
    no way of overriding such behavior. Records cannot inherit classes, but they can
    inherit other records. They can also implement interfaces.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，此代码复制了一个仅更改了一个属性的对象。在记录之前，您需要大量的代码来确保所有成员都被复制，然后才能设置一个值。请记住，这会创建一个浅表复制。浅复制是一个所有引用都被复制的对象。深复制是一个所有引用类型对象都被重新创建的对象。不幸的是，没有办法覆盖这种行为。记录不能继承类，但可以继承其他记录。它们也可以实现接口。
- en: Other than being a reference type, records are more like structs in that they
    have value equality and syntactic sugar around immutability. They should not be
    used as a replacement for structs because structs are still preferable for small
    and simple objects, which have simple logic. Use records when you want immutable
    objects for data, which could hold other complex objects (if nested objects could
    have a state that changes, shallow copying might cause unexpected behavior).
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为引用类型之外，记录更像是结构，因为它们具有值相等性和围绕不可变性的语法糖。它们不应该用作结构的替代品，因为结构仍然更适合于具有简单逻辑的小型和简单对象。当您想要不可变对象用于数据时，请使用记录，这些数据可能包含其他复杂对象（如果嵌套对象可能具有更改状态的状态，浅复制可能会导致意外行为）。
- en: Init-Only Setters
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅初始化设置器
- en: 'With the introduction of records, the previous edition, C# 9, also introduced
    `init`-only setter properties. Writing `init` instead of `set` can enable object
    initialization for properties:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 随着记录的引入，之前的版本C# 9还引入了`init`-only setter属性。使用`init`而不是`set`可以为属性启用对象初始化：
- en: '[PRE176]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'This enables you to create a house with unknown properties:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您能够创建具有未知属性的房屋：
- en: '[PRE177]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Or assign them:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 或者分配它们：
- en: '[PRE178]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Using `init`-only setters is especially useful when you want read-only data,
    which can be known or not, but not in a consistent matter.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要只读数据时，使用`init`-only设置器特别有用，这些数据可以是已知的或未知的，但不是以一致的方式。
- en: Note
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/89J99](https://packt.link/89J99).
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/89J99](https://packt.link/89J99)找到此示例中使用的代码。
- en: ValueTuple and Deconstruction
  id: totrans-704
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ValueTuple和解构
- en: 'You already know that a function can only return one thing. In some cases,
    you can use the `out` keyword to return a second thing. For example, converting
    a string to a number is often done like this:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道函数只能返回一件事。在某些情况下，您可以使用`out`关键字返回第二件事。例如，将字符串转换为数字通常是这样做的：
- en: '[PRE179]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '`TryParse` returns both the parsed number and whether the text was a number.'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '`TryParse`返回解析的数字以及文本是否为数字。'
- en: 'However, C# has a better way of returning multiple values. You can achieve
    this using a data structure called `ValueTuple`. It is a generic `struct` that
    contains from one to six public mutable fields of any (specified) type. It is
    just a container for holding unrelated values. For example, if you had a `dog`,
    a `human`, and a `Bool`, you could store all three in a `ValueTuple` struct:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C#有一种更好的方法来返回多个值。您可以使用一个名为`ValueTuple`的数据结构来实现这一点。它是一个通用的`struct`，包含了一个到六个公共可变字段，字段的类型可以是任意指定的。它只是一个用来保存不相关值的容器。例如，如果你有一个`dog`，一个`human`和一个`Bool`，你可以把这三个值存储在一个`ValueTuple`结构中：
- en: '[PRE180]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'You can then access each—that is, `dog` through `values1.Item1`, `human` through
    `values1.Item2`, and i`sDogKnown` through `values.Item3`. Another way of creating
    a `ValueTuple` struct is to use brackets. This does exactly the same thing as
    before, but using the brackets syntax:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以通过`values1.Item1`访问每一个值，比如`dog`，通过`values1.Item2`访问`human`，通过`values.Item3`访问`isDogKnown`。创建`ValueTuple`结构的另一种方法是使用括号。这与之前的方法完全相同，只是使用了括号的语法：
- en: '[PRE181]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The following syntax proves extremely useful because, with it, you can declare
    a function that virtually returns multiple things:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语法非常有用，因为你可以声明一个几乎返回多个值的函数：
- en: '[PRE182]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Note
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/OTFpm](https://packt.link/OTFpm).
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/OTFpm](https://packt.link/OTFpm)找到本例中使用的代码。
- en: 'You can also do the opposite, using another C# feature called deconstruction.
    It takes object data members and allows you to split them apart, into separate
    variables. The problem with a tuple type is that it does not have a strong name.
    As mentioned before, every field will be called `ItemX`, where `X` is the order
    in which the item was returned. Working with all that, `GetDogHumanAndBool` would
    require the results to be assigned to three different variables:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用另一个C#特性，叫做解构，来做相反的操作。它可以获取对象的数据成员，并允许你将它们分开成单独的变量。元组类型的问题在于它没有一个强有力的名称。如前所述，每个字段都将被称为`ItemX`，其中`X`是返回的项目的顺序。在处理所有这些时，`GetDogHumanAndBool`需要将结果分配给三个不同的变量：
- en: '[PRE183]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'You can simplify this and instead make use of deconstruction—assigning object
    properties to different variables right away:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简化这个过程，而是使用解构——直接将对象属性分配给不同的变量：
- en: '[PRE184]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Using deconstruction, you are able to make this a lot more readable and concise.
    Use `ValueTuple` when you have multiple unrelated variables and you want to return
    them all from a function. You do not have to always work around using the `out`
    keyword, nor do you have to add overhead by creating a new class. You can solve
    this problem by simply returning and then deconstructing a `ValueTuple` struct.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解构，你可以使这个过程更加可读和简洁。当你有多个不相关的变量，并且想要从一个函数中返回它们时，可以使用`ValueTuple`。你不必总是使用`out`关键字来解决问题，也不必通过创建一个新的类来增加开销。你可以通过简单地返回然后解构`ValueTuple`结构来解决这个问题。
- en: You can now have hands-on experience of using SOLID principles for writing codes
    incrementally through the following exercise.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下练习，你可以亲身体验使用SOLID原则逐步编写代码。
- en: 'Exercise 2.04: Creating a Composable Temperature Unit Converter'
  id: totrans-722
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.04：创建一个可组合的温度单位转换器
- en: 'Temperature can be measured in different units: Celsius, Kelvin, and Fahrenheit.
    In the future, more units might be added. However, units do not have to be added
    dynamically by the user; the application either supports it or not. You need to
    make an application that converts temperature from any unit to another unit.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 温度可以用不同的单位来测量：摄氏度、开尔文和华氏度。将来可能会添加更多的单位。但是，单位不需要由用户动态添加；应用程序要么支持它，要么不支持。你需要制作一个应用程序，将温度从任何单位转换为另一个单位。
- en: It is important to note that converting to and from that unit will be a completely
    different thing. Therefore, you will need two methods for every converter. As
    a standard unit, you will use Celsius. Therefore, every converter should have
    a conversion method from and to Celsius, which makes it the simplest unit of a
    program. When you need to convert non-Celsius to Celsius, you will need to involve
    two converters—one to adapt the input to the standard unit (C), and then another
    one to convert from C to whatever unit you want. The exercise will aid you in
    developing an application using the SOLID principles and C# features you have
    learned in this chapter, such as `record` and `enum`.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，转换到和从这些单位的转换将是完全不同的事情。因此，你将需要为每个转换器编写两种方法。作为标准单位，你将使用摄氏度。因此，每个转换器都应该有一个从摄氏度到其他单位的转换方法，这使得它成为程序中最简单的单位。当你需要将非摄氏度转换为摄氏度时，你将需要涉及两个转换器——一个用来将输入适应标准单位（C），然后另一个用来将C转换为你想要的任何单位。这个练习将帮助你使用本章学到的SOLID原则和C#特性来开发一个应用程序，比如`record`和`enum`。
- en: 'Perform the following steps to do so:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤执行：
- en: 'Create a `TemperatureUnit` that uses an `enum` type to define constants—that
    is, a set of known values. You do not need to add it dynamically:'
  id: totrans-726
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`TemperatureUnit`，它使用`enum`类型来定义常量，即一组已知的值。你不需要动态添加它：
- en: '[PRE185]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: In this example, you will use three temperature units that are `C`, `K`, and
    `F`.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将使用三种温度单位，分别是`C`、`K`和`F`。
- en: 'Temperature should be thought of as a simple object made of two properties:
    `Unit` and `Degrees`. You could either use a `record` or a `struct` because it
    is a very simple object with data. The best choice would be picking a `struct`
    here (due to the size of the object), but for the sake of practicing, you will
    use a `record`:'
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 温度应该被看作一个由两个属性组成的简单对象：`Unit`和`Degrees`。你可以使用`record`或`struct`，因为它是一个非常简单的带有数据的对象。在这里，最好的选择是选择`struct`（因为对象的大小），但为了练习，你将使用一个`record`：
- en: '[PRE186]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Next, add a contract defining what you want from an individual specific temperature
    converter:'
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个合同，定义你从一个特定的温度转换器中想要得到什么：
- en: '[PRE187]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: You defined an interface with three methods—the `Unit` property to identify
    which temperature the converter is for, and `ToC` and `FromC` to convert from
    and to standard units.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了一个接口，其中包含三个方法——`Unit`属性用于标识转换器所针对的温度，`ToC`和`FromC`用于从标准单位转换到和从标准单位转换。
- en: 'Now that you have a converter, add the composable converter, which has an array
    of converters:'
  id: totrans-734
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您有了一个转换器，添加可组合的转换器，它具有一组转换器：
- en: '[PRE188]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'It makes no sense to have duplicate temperature unit converters. So, add an
    error that will be thrown when a duplicate converter is detected. Also, not having
    any converters makes no sense. Therefore, there should be some code for validating
    against `null` or empty converters:'
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拥有重复的温度单位转换器是没有意义的。因此，当检测到重复转换器时，添加一个将被抛出的错误。而且，没有任何转换器也是没有意义的。因此，应该有一些代码来验证`null`或空转换器：
- en: '[PRE189]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: When creating custom exceptions, you should provide as much information as possible
    about the context of an error. In this case, pass the `unit` for which the converter
    was not found.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义异常时，应尽可能提供有关错误上下文的尽可能多的信息。在这种情况下，传递未找到转换器的`unit`。
- en: 'Add a method that requires non-empty converters:'
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个需要非空转换器的方法：
- en: '[PRE190]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Passing an array of empty converters throws an `InvalidTemperatureConverterException`
    exception.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 传递一个空转换器数组会抛出`InvalidTemperatureConverterException`异常。
- en: 'Add a method that requires non-duplicate converters:'
  id: totrans-742
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个需要非重复转换器的方法：
- en: '[PRE191]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: This method goes through every converter and checks that, at other indexes,
    the same converter is not repeated (by duplicating `TemperatureUnit`). If it finds
    a duplicate unit, it will throw an exception. If it does not, it will just terminate successfully.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法遍历每个转换器，并检查在其他索引处是否重复转换器（通过重复`TemperatureUnit`）。如果找到重复的单位，它将抛出异常。如果没有，它将正常终止。
- en: 'Now combine it all in a constructor:'
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将所有内容组合在一个构造函数中：
- en: '[PRE192]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: When creating the converter, validate against converters that are not empty
    and not duplicates and only then set them.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建转换器时，验证不为空且不重复的转换器，然后设置它们。
- en: 'Next, create a `private` helper method to help you find the requisite converter,
    `FindConverter`, inside the composable converter:'
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在可组合的转换器内创建一个`private`辅助方法来帮助您找到所需的转换器`FindConverter`：
- en: '[PRE193]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: This method returns the converter of the requisite unit and, if no converter
    is found, throws an exception.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回所需单位的转换器，如果找不到转换器，则抛出异常。
- en: 'To simplify how you search and convert from any unit to Celsius, add a `ToCelsius`
    method for that:'
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化您搜索和从任何单位转换为摄氏度的过程，添加一个`ToCelsius`方法：
- en: '[PRE194]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Here, you find the requisite converter and convert the `Temperature` to Celsius.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您找到所需的转换器并将`Temperature`转换为Celsius。
- en: 'Do the same for converting from Celsius to any other unit:'
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于从摄氏度转换为任何其他单位的转换，也是同样的操作：
- en: '[PRE195]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Wrap it all up by implementing this algorithm, standardize the temperature
    (convert to Celsius), and then convert to any other temperature:'
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现这个算法，将温度标准化（转换为摄氏度），然后转换为任何其他温度，将所有内容包装起来：
- en: '[PRE196]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Add a few converters. Start with the Kelvin converter, `KelvinConverter`:'
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些转换器。从Kelvin转换器`KelvinConverter`开始：
- en: '[PRE197]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: The implementation of this and all the other converters is straightforward.
    All you had to do was implement the formula to convert to the correct unit from
    or to Celsius. Kelvin has a useful constant, absolute zero, so instead of having
    a magic number, `–273.15`, you used a named constant. Also, it is worth remembering
    that a temperature is not a primitive. It is both a degree value and a unit. So,
    when converting, you need to pass both. `ToC` will always take `TemperatureUnit.C`
    as a unit and `FromC` will take whatever unit the converter is identified as,
    in this case, `TemperatureUnit.K`.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的实现和所有其他转换器的实现都很简单。您只需要实现将正确单位转换为或从摄氏度的公式。Kelvin有一个有用的常数，绝对零度，所以您使用了一个命名常量而不是一个魔术数字`–273.15`。另外，值得记住的是温度不是一个原始类型。它既是一个度数值又是一个单位。因此，在转换时，您需要同时传递两者。`ToC`将始终以`TemperatureUnit.C`作为单位，而`FromC`将采用转换器被识别为的任何单位，即`TemperatureUnit.K`。
- en: 'Now add a Fahrenheit converter, `FahrenheitConverter`:'
  id: totrans-761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个Fahrenheit转换器`FahrenheitConverter`：
- en: '[PRE198]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Fahrenheit is identical structure-wise; the only differences are the formulas
    and unit value.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: Fahrenheit在结构上是相同的；唯一的区别是公式和单位值。
- en: 'Add a `CelsiusConverter`, which will accept a value for the temperature and
    return the same value, as follows:'
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`CelsiusConverter`，它将接受一个温度值并返回相同的值，如下所示：
- en: '[PRE199]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '`CelsiusConverter` is the simplest one. It does not do anything; it just returns
    the same temperature. The converters convert to standard temperature—Celsius to
    Celsius is always Celsius. Why do you need such a class at all? Without it, you
    would need to change the flow a bit, adding `if` statements to ignore the temperature
    if it was in Celsius. But with this implementation, you can incorporate it in
    the same flow and use it in the same way with the help of the same abstraction,
    `ITemperatureConverter`.'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '`CelsiusConverter`是最简单的。它什么也不做；它只是返回相同的温度。转换器将温度转换为标准温度——摄氏度转换为摄氏度始终是摄氏度。为什么你需要这样一个类呢？没有它，您需要稍微改变流程，添加`if`语句来忽略摄氏度的温度。但是通过这种实现，您可以将其合并到相同的流程中，并且可以在相同的抽象`ITemperatureConverter`的帮助下以相同的方式使用它。'
- en: 'Finally, create a demo:'
  id: totrans-767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个演示：
- en: '[PRE200]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: In this example, you have created all the converters and passed them to the
    converters container called `composableConverter`. Then you have created a temperature
    in Celsius and used it to perform conversions from and to all the other temperatures.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您已经创建了所有的转换器并将它们传递给名为`composableConverter`的转换器容器。然后，您创建了一个摄氏度温度，并用它来执行从其他温度到摄氏度的转换。
- en: 'Run the code and you will get the following results:'
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，您将得到以下结果：
- en: '[PRE202]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Note
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/dDRU6](https://packt.link/dDRU6).
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/dDRU6](https://packt.link/dDRU6)找到用于此练习的代码。
- en: A software developer, ideally, should design code in such a way that making
    a change now or in the future will take the same amount of time. Using SOLID principles,
    you can write code incrementally and minimize the risk of breaking changes, because
    you never change existing code; you just add new code. As systems grow, complexity
    increases, and it might be difficult to learn how things work. Through well-defined
    contracts, SOLID enables you to have easy-to-read, and maintainable code because
    each piece is straightforward by itself, and they are isolated from one another.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 一个软件开发人员理想情况下应该以这样的方式设计代码，使得现在或将来进行更改需要相同的时间。使用SOLID原则，你可以逐步编写代码并最小化破坏性更改的风险，因为你永远不会改变现有的代码；你只是添加新的代码。随着系统的增长，复杂性增加，学习事物如何工作可能会很困难。通过明确定义的契约，SOLID使你能够拥有易于阅读和易于维护的代码，因为每个部分都是简单明了的，并且它们彼此之间是隔离的。
- en: You will now test your knowledge of creating classes and overriding operators
    through an activity.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将通过一个活动来测试你创建类和重载运算符的知识。
- en: 'Activity 2.01: Merging Two Circles'
  id: totrans-777
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动2.01：合并两个圆
- en: 'In this activity, you will create classes and override operators to solve the
    following mathematics problem: A portion of pizza dough can be used to create
    two circular pizza bites each with a radius of three centimeters. What would be
    the radius of a single pizza bite made from the same amount of dough? You can
    assume that all the pizza bites are the same thickness. The following steps will
    help you complete this activity:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将创建类和重载运算符来解决以下数学问题：一部分比萨面团可以用来制作两个半径为三厘米的圆形比萨小块。使用相同量的面团制作一个单独的比萨小块的半径是多少？你可以假设所有的比萨小块厚度都是一样的。以下步骤将帮助你完成这个活动：
- en: Create a `Circle` struct with a radius. It should be a `struct` because it is
    a simple data object, which has a tiny bit of logic, calculating area.
  id: totrans-779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有半径的`Circle`结构。它应该是一个`struct`，因为它是一个简单的数据对象，具有一点点逻辑，计算面积。
- en: Add a property to get the area of a circle (try to use an expression-bodied
    member). Remember, the formula of a circle's area is `pi*r*r`. To use the `PI`
    constant, you will need to import the `Math` package.
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个属性来获取圆的面积（尝试使用表达式主体成员）。记住，圆的面积公式是`pi*r*r`。要使用`PI`常量，你需要导入`Math`包。
- en: Add two circles' areas together. The most natural way would be to use an overload
    for a plus (`+`) operator. Implement a `+` operator overload that takes two circles
    and returns a new one. The area of the new circle is the sum of the areas of the
    two old circles. However, do not create a new circle by passing the area. You
    need a Radius. You can calculate this by dividing the new area by `PI` and then
    taking the square root of the result.
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个圆的面积相加。最自然的方法是使用加号（`+`）运算符的重载。实现一个接受两个圆并返回一个新圆的`+`运算符重载。新圆的面积是两个旧圆的面积之和。然而，不要通过传递面积来创建一个新圆。你需要一个半径。你可以通过将新面积除以`PI`然后取结果的平方根来计算这个半径。
- en: Now create a `Solution` class that takes two circles and returns a result—the
    radius of the new circle.
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个`Solution`类，它接受两个圆并返回一个结果——新圆的半径。
- en: Within the `main` method, create two circles with a radius of `3` cm and define
    a new circle, which is equal to the areas of the two other circles added together.
    Print the results.
  id: totrans-783
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`方法中，创建两个半径为`3`厘米的圆，并定义一个新的圆，它等于两个其他圆的面积之和。打印结果。
- en: 'Run the `main` method and the result should be as follows:'
  id: totrans-784
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`main`方法，结果应该如下：
- en: '[PRE203]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: As you can see from this final output, the new circle will have a radius of
    `4.24` (rounded to the second decimal place).
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 从最终输出中可以看出，新的圆的半径将是`4.24`（四舍五入到小数点后两位）。
- en: Note
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在[https://packt.link/qclbF](https://packt.link/qclbF)找到。
- en: This activity was designed to test your knowledge of creating classes and overriding
    operators. Operators are not normally employed to solve this sort of problem,
    but in this case, it worked well.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动旨在测试你创建类和重载运算符的知识。通常不会使用运算符来解决这种问题，但在这种情况下，效果很好。
- en: Summary
  id: totrans-790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about OOP and how it helps take complex problems
    and abstract them into simple concepts. C# has several useful features and, roughly
    every one or two years, a new language version is released. The features mentioned
    in this chapter are just some of the ways in which C# aids in productivity. You
    have seen how, by design, it allows for better, clearer code, less prone to error.
    C# is one of the best languages when it comes to productivity. With C#, you can
    make effective code, and quickly, because a lot of the boilerplate code is done
    for you.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了面向对象编程以及它如何帮助将复杂问题抽象成简单概念。C#有几个有用的特性，大约每一到两年就会发布一个新的语言版本。本章提到的特性只是C#在提高生产力方面的一些方式。你已经看到了，通过设计，它允许更好、更清晰的代码，更不容易出错。C#在提高生产力方面是最好的语言之一。使用C#，你可以编写有效的代码，并且快速，因为很多样板代码都已经为你做好了。
- en: Finally, you learned the SOLID principles and used them in an application. SOLID
    is not something you can just read and learn immediately; it takes practice, discussions
    with your peers, and a lot of trial and error before you get it right and start
    applying it consistently. However, the benefits are worth it. In modern software
    development, producing fast, optimal code is no longer a number one priority.
    Nowadays, the focus is a balance of productivity (how fast you develop) and performance
    (how fast your program is). C# is one of the most efficient languages out there,
    both in terms of performance and productivity.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学会了SOLID原则并在一个应用中使用它们。SOLID不是你可以立即阅读和学习的东西；在你掌握并开始一致应用之前，需要练习、与同行讨论和大量的试错。然而，好处是值得的。在现代软件开发中，生产快速、最佳代码不再是头等大事。如今，重点是生产力（你开发的速度）和性能（你的程序运行的速度）的平衡。C#是最高效的语言之一，无论是性能还是生产力方面。
- en: In the next chapter, you will learn what functional programming is and how to
    work with lambdas and functional constructs such as delegates.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习什么是函数式编程，以及如何使用lambda和函数构造，比如委托。
