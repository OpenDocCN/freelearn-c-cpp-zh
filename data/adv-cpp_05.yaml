- en: 4\. Separation of Concerns - Software Architecture, Functions, and Variadic
    Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 关注点的分离 - 软件架构、函数和可变模板
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Develop classes using the PIMPL idiom to implement object-level encapsulation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PIMPL习惯用法来实现对象级封装
- en: Implement a callback system using functors, std::function, and lambda expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数对象、std::function和lambda表达式实现回调系统
- en: Implement lambdas using the right capture technique for the situation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正确的捕获技术来实现lambda表达式
- en: Develop variadic templates to implement C# style delegates for event handling.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发可变模板以实现C#风格的委托以进行事件处理。
- en: This chapter will show you how to implement the PIMPL idiom, and how to develop
    a callback mechanism for your own programs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何实现PIMPL习惯用法，以及如何为您自己的程序开发回调机制。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned how to implement classes to properly manage
    resources even when the exceptions occurred using RAII. We also learned about
    ADL (**Argument Dependent Lookup**) and how it determines the function to be called.
    Finally, we talked about how the explicit keyword can be used to prevent automatic
    conversion between types by the compiler, known as implicit conversion
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何实现类来正确管理资源，即使在发生异常时也是如此，使用RAII。我们还学习了ADL（**Argument Dependent Lookup**）以及它如何确定要调用的函数。最后，我们谈到了显式关键字如何可以防止编译器进行类型之间的自动转换，即隐式转换。
- en: In this chapter, we will look into dependencies, both physical and logical,
    and see how they can affect build times adversely. We'll also learn how to separate
    the visible interface class from the implementation details to increase the speed
    of the build times. We will then learn to capture functions and contexts so that
    we can call them later using `functors`, `std::function` and `lambda expressions`.
    Finally, we will implement a variadic template to deliver an event-based callback
    mechanism.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究依赖关系，包括物理依赖关系和逻辑依赖关系，以及它们如何对构建时间产生不利影响。我们还将学习如何将可见接口类与实现细节分离，以增加构建时间的速度。然后，我们将学习如何捕获函数和上下文，以便以后可以使用“函数对象”、“std::function”和“lambda表达式”来调用它们。最后，我们将实现可变模板以提供基于事件的回调机制。
- en: The Pointer to Implementation (PIMPL) Idiom
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指向实现的指针（PIMPL）习惯用法
- en: As projects implemented in C++ get larger and larger, there is the likelihood
    that the build times will grow at a faster rate than the number of files. This
    is because of the textual inclusion model used by the C++ build model. This is
    done so that the compiler can determine the size and layout of the class, causing
    a coupling between the `caller` and the `callee`, but allowing for optimization.
    Remember that everything must be defined before it can be used. A future feature
    called `Modules` promises to address this issue, but for now we need to understand
    the issue and the techniques used to address the problem.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着C++实现的项目变得越来越大，构建时间增长的速度可能会超过文件数量的增长速度。这是因为C++构建模型使用了文本包含模型。这样做是为了让编译器能够确定类的大小和布局，导致了“调用者”和“被调用者”之间的耦合，但也允许进行优化。请记住，一切都必须在使用之前定义。未来的一个特性叫做“模块”承诺解决这个问题，但现在我们需要了解这个问题以及用来解决问题的技术。
- en: Logical and Physical Dependencies
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑和物理依赖关系
- en: When we wish to access a class from another class, we have a logical dependency.
    One class is logically dependent upon another class. If we consider the `Graphics`
    classes, `Point3d` and `Matrix3d` that we developed in *Chapter 2A*, *No Ducks
    Allowed – Types and Deduction* and *Chapter 3*, *The Distance between Can and
    Should – Objects, Pointers and Inheritance*, we have two logically independent
    classes `Matrix3d` and `Point3d`. However, because of how we implemented the multiplication
    operator between the two, we created a compile-time or **physical dependency**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望从另一个类中访问一个类时，我们有一个逻辑依赖关系。一个类在逻辑上依赖于另一个类。如果我们考虑我们在*第2A章*“不允许鸭子 - 类型和推导”和*第3章*“能与应该之间的距离
    - 对象、指针和继承”中开发的`Graphics`类，`Point3d`和`Matrix3d`，我们有两个逻辑独立的类`Matrix3d`和`Point3d`。然而，由于我们如何在两者之间实现了乘法运算符，我们创建了一个编译时或**物理依赖关系**。
- en: '![Figure 4.1: Physical Dependencies of Matrix3d and Point3d'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1：Matrix3d和Point3d的物理依赖关系'
- en: '](img/C14583_04_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_01.jpg)'
- en: 'Figure 4.1: Physical Dependencies of Matrix3d and Point3d'
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.1：Matrix3d和Point3d的物理依赖关系
- en: As we can see with these relatively simple classes, the physical dependencies
    between the header files and the implementation files can quickly get complicated.
    It is this complexity that contributes to the build times of large projects because
    the number of physical (and logical) dependencies grows to thousands. We have
    shown only 13 dependencies in the preceding diagram as indicated by the arrows.
    But there are actually many more, as including a standard library header typically
    pulls in a hierarchy of include files. This means that if one header file is modified,
    then all files that are dependent upon it, either directly or indirectly, will
    need to be re-compiled to account for the change. This trigger for rebuilding
    also occurs if the change is to the private class members definition that users
    of the class cannot even access.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这些相对简单的类中所看到的，头文件和实现文件之间的物理依赖关系很快就会变得复杂起来。正是这种复杂性导致了大型项目的构建时间增加，因为物理（和逻辑）依赖关系的数量增长到了成千上万。在前面的图表中，我们只显示了13个依赖关系，如箭头所示。但实际上还有更多，因为包含标准库头文件通常会引入一系列包含文件的层次结构。这意味着如果修改了一个头文件，那么直接或间接依赖于它的所有文件都需要重新编译以适应变化。如果更改是对用户甚至无法访问的私有类成员定义的，也会触发重新构建。
- en: 'To help speed compile times, we have used the guard technique to prevent header
    files from being processed multiple times:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快编译时间，我们使用了保护技术来防止头文件被多次处理：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And lately, most compilers now support the `#pragma once` directive which achieves
    the same result.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，大多数编译器现在支持`#pragma once`指令，它可以实现相同的结果。
- en: These relationships between entities (files, classes, and so on) are known as
    **coupling**. A file/class is **highly coupled** to another file/class if changes
    to the file/class result in changes to the other file/class. A file/class is **loosely
    coupled** to another file/class if changes to the file/class do not result in
    changes to the other file/class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实体（文件、类等）之间的关系被称为**耦合**。如果对文件/类的更改导致对其他文件/类的更改，则文件/类与另一个文件/类**高度耦合**。如果对文件/类的更改不会导致对其他文件/类的更改，则文件/类与另一个文件/类**松散耦合**。
- en: Highly coupled code (files/classes) introduce problems into a project. Highly
    coupled code is hard to change (inflexible), hard to test and hard to understand.
    Loosely coupled code on the other hand is easier to change (only modify one class),
    highly testable (only need the class being tested) and easier to read and understand.
    Coupling reflects, and is related to, the logical and physical dependencies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 高度耦合的代码（文件/类）会给项目带来问题。高度耦合的代码难以更改（不灵活），难以测试和难以理解。另一方面，松散耦合的代码更容易更改（只需修改一个类），更易测试（只需测试正在测试的类）并且更易阅读和理解。耦合反映并与逻辑和物理依赖相关。
- en: The Pointer to Implementation (PIMPL) Idiom
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指向实现（PIMPL）惯用法
- en: One solution to this problem with coupling is to use the "**Pimpl Idiom**" (which
    stands for **Pointer to Implementation Idiom**). This is also referred to as an
    opaque pointer, the compiler firewall idiom or even **Cheshire Cat technique**.
    Consider the **Qt library**, in particular, the **Qt Platform Abstraction** (**QPA**).
    It is an abstraction layer that hides the details of the Operating Systems and/or
    platforms that the Qt application is hosted on. One method to implement such a
    layer is to use the PIMPL idiom where the common interface is exposed to the application
    developer, but the implementation of how the functionality is delivered is hidden.
    Qt actually uses a variant of PIMPL known as d-pointer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这种耦合问题的一种方法是使用“Pimpl惯用法”（即“指向实现的指针惯用法”）。这也被称为不透明指针、编译器防火墙惯用法，甚至是“切尔西猫技术”。考虑Qt库，特别是Qt平台抽象（QPA）。这是一个隐藏Qt应用程序所托管的操作系统和/或平台细节的抽象层。实现这样一层的方法之一是使用PIMPL惯用法，其中公共接口暴露给应用程序开发人员，但功能的实现方式是隐藏的。Qt实际上使用了PIMPL的变体，称为d-pointer。
- en: 'For example, one feature of a GUI is the use of a dialog that is a popup window
    that displays information or prompts for user input. It could be declared in **dialog.hpp**
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，GUI的一个特性是使用对话框，它是一个弹出窗口，用于显示信息或提示用户输入。可以在**dialog.hpp**中声明如下：
- en: Note
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注
- en: 'For more information about QT Platform Abstraction (QPA), visit the following
    link: [https://doc.qt.io/qt-5/qpa.html#](https://doc.qt.io/qt-5/qpa.html#).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有关QT平台抽象（QPA）的更多信息，请访问以下链接：[https://doc.qt.io/qt-5/qpa.html#](https://doc.qt.io/qt-5/qpa.html#)。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The user has access to all the functions required to use a `Dialog` but has
    no knowledge of how it is implemented. Note that we have a declared `DialogImpl`
    but not defined it. In general, there is not much we can do with such a class
    as `DialogImpl`. But there is one thing that is allowed and that is to declare
    a pointer to it. This feature of C++ allows us to hide the implementation details
    in the implementation file. This means that in this simple case we do not have
    any include files for this declaration.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以访问使用`Dialog`所需的所有函数，但不知道它是如何实现的。请注意，我们声明了`DialogImpl`但没有定义它。一般来说，我们对这样的`DialogImpl`类做不了太多事情。但有一件事是允许的，那就是声明一个指向它的指针。C++的这个特性允许我们在实现文件中隐藏实现细节。这意味着在这种简单情况下，我们不需要为这个声明包含任何包含文件。
- en: 'The implementation file **dialogImpl.cpp** may be implemented as:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实现文件**dialogImpl.cpp**可以实现为：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We note several things from this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从中注意到几件事：
- en: We define the implementation class `DialogImpl` before we define the methods
    required for Dialog. This is necessary because `Dialog` will need to exercise
    the methods through `m_pImpl` which means that they need to be defined first.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们定义对话框所需的方法之前，我们先定义实现类`DialogImpl`。这是必要的，因为`Dialog`将需要通过`m_pImpl`来调用这些方法，这意味着它们需要首先被定义。
- en: The `Dialog` constructor and destructor are responsible for the memory management.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dialog`的构造函数和析构函数负责内存管理。'
- en: We include all the necessary header files required for the implementation, in
    the implementation file only. This reduces the coupling by minimizing the number
    of headers included in the **Dialog.hpp** file.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只在实现文件中包含了实现所需的所有必要头文件。这通过最小化**Dialog.hpp**文件中包含的头文件数量来减少耦合。
- en: 'The program can be executed as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序可以按以下方式执行：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On execution, the above program produces the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，上述程序产生以下输出：
- en: '![Figure 4.2: Sample Pimpl implementation output'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2：示例Pimpl实现输出'
- en: '](img/C14583_04_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_02.jpg)'
- en: 'Figure 4.2: Sample Pimpl implementation output'
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.2：示例Pimpl实现输出
- en: Advantages and Disadvantages of PIMPL
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PIMPL的优缺点
- en: The biggest advantage in the use of PIMPL is that it breaks the compile-time
    dependencies between the clients of a class and its implementation. This allows
    for faster build times because PIMPL eliminates a large number of `#include` directives
    in the definition (header) file, instead pushing them to only be necessary in
    the implementation file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PIMPL的最大优势是它打破了类的客户端和其实现之间的编译时依赖关系。这样可以加快构建时间，因为PIMPL在定义（头）文件中消除了大量的`#include`指令，而只需要在实现文件中才是必要的。
- en: It also decouples the implementation from the clients. We are now free to change
    the implementation of the PIMPL class and only that file needs recompilation.
    This prevents compilation cascades where changes to hidden members trigger the
    rebuilding of clients. This is called a compilation-firewall.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将实现与客户端解耦。现在我们可以自由更改PIMPL类的实现，只需重新编译该文件。这可以防止编译级联，其中对隐藏成员的更改会触发客户端的重建。这被称为编译防火墙。
- en: 'Some other advantages of the PIMPL idiom are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: PIMPL惯用法的一些其他优点如下：
- en: '**Data Hiding** – the internal details of implementation are truly isolated
    in the implementation class. If this is part of a library, then it can be used
    to prevent the disclosure of information, such as Intellectual property.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据隐藏** - 实现的内部细节真正地被隔离在实现类中。如果这是库的一部分，那么它可以用来防止信息的泄露，比如知识产权。'
- en: '`DLL`, or `.so` file) and be free to change it without affecting the client
    code.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DLL`或`.so`文件），并且可以自由更改它而不影响客户端代码。'
- en: 'Such advantages come at a cost. The disadvantages are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优点是有代价的。缺点如下：
- en: '**Maintenance Effort** – there is additional code in the visible class that
    forwards the calls to the Implementation class. This adds a level of indirection
    with a minor increase in complexity.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护工作** - 可见类中有额外的代码将调用转发到实现类。这增加了一定复杂性的间接层。'
- en: '**Memory Management** – the addition of a pointer for the implementation now
    requires us to manage the memory. It also requires additional storage to hold
    the pointer and, in a memory constrained system (For example: Internet of Things
    device) this may be critical.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存管理** - 现在添加了一个指向实现的指针，我们需要管理内存。它还需要额外的存储空间来保存指针，在内存受限的系统中（例如：物联网设备）这可能是关键的。'
- en: Implementing PIMPL with unique_ptr<>
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用unique_ptr<>实现PIMPL
- en: Our current implementation of Dialog uses a raw pointer to hold the PIMPL implementation
    reference. In *Chapter 3*, *The Distance between Can and Should – Objects, Pointers
    and Inheritance*, we discussed ownership of objects and introduced smart pointers
    and RAII. The hidden object pointed to by the PIMPL pointer is a resource to be
    managed and should be executed using `RAII` and `std::unique_ptr`. As we shall
    see, there are some caveats for implementing `PIMPL` with `std::unique_ptr`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的Dialog实现使用原始指针来持有PIMPL实现引用。在*第3章*中，*能与应该之间的距离-对象、指针和继承*中，我们讨论了对象的所有权，并引入了智能指针和RAII。PIMPL指针指向的隐藏对象是一个需要管理的资源，应该使用`RAII`和`std::unique_ptr`来执行。正如我们将看到的，使用`std::unique_ptr`实现`PIMPL`有一些注意事项。
- en: Let's change our Dialog implementation to use smart pointers. Firstly, the header
    files changes to introduce the `#include <memory>` line and the destructor can
    be removed as the `unique_ptr` deletes the implementation class automatically.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将Dialog的实现改为使用智能指针。首先，头文件更改以引入`#include <memory>`行，并且可以删除析构函数，因为`unique_ptr`会自动删除实现类。
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Obviously, we remove the destructor from the implementation file, and we modify
    the constructor to use `std::make_unique`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们从实现文件中删除了析构函数，并修改构造函数以使用`std::make_unique`。
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When re-compiling our new version, there are no problems with the **Dialog.hpp**
    and **DialogImpl.cpp** files, but our client **main.cpp** reports the following
    errors (with the gcc compiler), as you can see below:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编译我们的新版本时，**Dialog.hpp**和**DialogImpl.cpp**文件没有问题，但我们的客户端**main.cpp**报告了以下错误（使用gcc编译器），如下所示：
- en: '![Figure 4.3: Failed compilation of Pimpl using unique_ptr'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3：使用unique_ptr失败的Pimpl编译'
- en: '](img/C14583_04_03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_03.jpg)'
- en: 'Figure 4.3: Failed compilation of Pimpl using unique_ptr'
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.3：使用unique_ptr失败的Pimpl编译
- en: 'The first error reports `Dialog` for us when `main()` function ends. As we
    discussed in *Chapter **2A*, *No Ducks Allowed – Types and Deduction* the compiler
    will generate a destructor for us (as we removed it). This generated destructor
    will call the destructor of `unique_ptr` which is the cause of the error. If we
    look at `line 76`, of `operator()` function for the default `deleter` used by
    `unique_ptr` (the `deleter` is the function called by `unique_ptr` when it destroys
    the object it points to):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当`main()`函数结束时，第一个错误报告了`Dialog`。正如我们在*第2A章*中讨论的那样，*不允许鸭子-类型和推断*编译器将为我们生成一个析构函数（因为我们删除了它）。这个生成的析构函数将调用`unique_ptr`的析构函数，这就是错误的原因。如果我们看一下`line
    76`，默认`unique_ptr`使用的`deleter`的`operator()`函数（`deleter`是`unique_ptr`在销毁其指向的对象时调用的函数）：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our code is failing on the second `static_assert()` statement that terminates
    the compilation with an error. The problem is that the compiler is trying to generate
    the destructor for `std::unique_ptr<DialogImpl>` and `DialogImpl` is an incomplete
    type. So, to fix the problem, we control the generation of the destructor to be
    at a point where `DialogImpl` is a complete type.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码在第二个`static_assert()`语句上失败，这会导致编译出错。问题在于编译器试图为`std::unique_ptr<DialogImpl>`和`DialogImpl`生成析构函数，而`DialogImpl`是一个不完整的类型。因此，为了解决问题，我们控制生成析构函数的时机，使`DialogImpl`成为一个完整的类型。
- en: To do this, we put the declaration of the destructor back into the class and
    add its implementation to the `DialogImpl.cpp` file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将析构函数的声明放回类中，并将其实现添加到`DialogImpl.cpp`文件中。
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we compile and run our program, it produces exactly the same output as
    before. In fact, if we only need an empty destructor, we can replace the above
    code with the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译并运行我们的程序时，它产生的输出与之前完全相同。实际上，如果我们只需要一个空的析构函数，我们可以用以下代码替换上面的代码：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we compile and run our program, then following output will be produced:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译并运行我们的程序，那么将产生以下输出：
- en: '![Figure 4.4: Sample unique_ptr Pimpl implementation output'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4：示例unique_ptr Pimpl实现输出'
- en: '](img/C14583_04_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_04.jpg)'
- en: 'Figure 4.4: Sample unique_ptr Pimpl implementation output'
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.4：示例unique_ptr Pimpl实现输出
- en: unique_ptr<> PIMPL Special Functions
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: unique_ptr<> PIMPL特殊函数
- en: 'As PIMPL usually implies that the visible interface class owns the implementation
    class, the move-semantics are a natural fit. However, in the same way the compiler
    generated destructor implementation is correct, the compiler generated move constructor
    and move assignment operator will give the desired behavior, that is, perform
    a move on the member `unique_ptr`. The move operations both potentially need to
    perform a delete before assigning the transferred value, and so, suffer from the
    same problem as the destructor with incomplete types. The solution is the same
    as for the destructor – declare the method in the header file and implement when
    the type is complete – in the implementation file. So, our header file looks like
    the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PIMPL通常意味着可见接口类拥有实现类，因此移动语义是一个自然的选择。然而，就像编译器生成的析构函数实现是正确的一样，编译器生成的移动构造函数和移动赋值运算符将产生期望的行为，即对成员`unique_ptr`执行移动。移动操作都可能需要在分配传输值之前执行删除，因此，与不完整类型的析构函数一样，它们也会遇到相同的问题。解决方案与析构函数相同-在头文件中声明该方法，并在类型完成时实现-在实现文件中。因此，我们的头文件看起来像下面这样：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While the implementation looks like:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实现看起来像：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Depending upon the data items that we are hiding in our implementation class,
    we may also desire copy functionality on our PIMPL classes. Using a `std::unique_ptr`
    inside the Dialog class prevents the automatic generation of a copy constructor
    and copy assignment operator, as the internal members do not support copy. Also,
    by defining the move member functions, as we saw in *Chapter 2A*, *No Ducks Allowed
    – Types and Deduction*, it also stops the compiler in generating the copy versions.
    In addition, if the compiler did generate copy semantics for us, it would only
    be a **shallow copy**. But due to the PIMPL implementation, we need a **deep copy**.
    So, we will need to write our own copy special member functions. Again, the definition
    goes in the header file and the implementation needs to be done where the type
    is complete, inside the **DialogImpl.cpp** file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在实现类中隐藏的数据项，我们可能还希望在我们的PIMPL类上具有复制功能。在Dialog类内部使用`std::unique_ptr`可以防止自动生成复制构造函数和复制赋值运算符，因为内部成员不支持复制。此外，通过定义移动成员函数，就像我们在*第2A章*中看到的那样，它也阻止编译器生成复制版本。此外，如果编译器为我们生成了复制语义，它只会是**浅复制**。但由于PIMPL实现，我们需要**深复制**。因此，我们需要编写自己的复制特殊成员函数。同样，定义放在头文件中，实现需要在类型完成的地方完成，即在**DialogImpl.cpp**文件中。
- en: 'In the header file, we add the following declarations:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中，我们添加以下声明：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And the implementation would look like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实现将如下所示：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note the `if(this == &rhs)` clauses. These are there to prevent the object from
    copying itself unnecessarily. Also, note that we need to check if either `unique_ptr`
    is empty and process the copy accordingly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`if(this == &rhs)`子句。这些是为了防止对象不必要地复制自身。还要注意，我们需要检查`unique_ptr`是否为空，并相应地处理复制。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Before solving any practical in this chapter, download the GitHub repository
    [https://github.com/TrainingByPackt/Advanced-CPlusPlus](https://github.com/TrainingByPackt/Advanced-CPlusPlus)
    and import the folder of Lesson 4 in Eclipse, so that you can view the codes for
    each exercises, and activities.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中解决任何实际问题之前，下载GitHub存储库[https://github.com/TrainingByPackt/Advanced-CPlusPlus](https://github.com/TrainingByPackt/Advanced-CPlusPlus)并在Eclipse中导入Lesson
    4文件夹，以便您可以查看每个练习和活动的代码。
- en: 'Exercise 1: Implementing a Kitchen with unique_ptr<>'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：使用unique_ptr<>实现厨房
- en: 'In this exercise, we will hide the details of how the kitchen processes orders
    by implementing the `Pimpl idiom` with the `unique_ptr<>`. Follow the below steps
    to implement this exercise:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过使用`unique_ptr<>`实现`Pimpl idiom`来隐藏厨房处理订单的细节。按照以下步骤来实现这个练习：
- en: Open the **Lesson4** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson4** then **Exercise01** and double click on **Exercise1.cpp** to
    open the file for this exercise into the editor.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson4**项目，然后在**Project Explorer**中展开**Lesson4**，然后展开**Exercise01**，双击**Exercise1.cpp**以将此练习的文件打开到编辑器中。
- en: As this is a CMake based project, change the current builder to be CMake Build
    (portable).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个基于CMake的项目，将当前构建器更改为CMake Build（便携式）。
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure **L4Exercise1** to run with the name **Exercise1**.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Launch Configuration**下拉菜单，然后选择**New Launch Configuration…**。配置**L4Exercise1**以使用名称**Exercise1**运行。
- en: 'Click on the **Run** button. Exercise 1 will run and produce the following
    output:![Figure 4.5: Exercise 1 Program output'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Run**按钮。练习1将运行并产生以下输出：![图4.5：练习1程序输出
- en: '](img/C14583_04_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_05.jpg)'
- en: 'Figure 4.5: Exercise 1 Program output'
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.5：练习1程序输出
- en: Open `Kitchen`. We are going to move all the private members into an implementation
    class and hide the details.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Kitchen`。我们将把所有私有成员移到一个实现类中并隐藏细节。
- en: 'In the `#include <memory>` directive to gain access to the `unique_ptr`. Add
    the declaration for the destructor `~Kitchen();` and then add the following two
    lines into the top of the private section:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`#include <memory>`指令中获得对`unique_ptr`的访问。添加析构函数`~Kitchen();`的声明，然后将以下两行添加到私有部分的顶部：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Open the `#include` directives:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`#include`指令：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Click on the **Run** button to re-build the program. You'll see that the output
    is still the same as before.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Run**按钮重新构建程序。您会看到输出仍然与以前相同。
- en: 'Remove all the private members except the two new ones from the `Kitchen` class
    in `Kitchen::Impl` declarations. The `#include <vector>`, `#include "recipe.hpp"`
    and `#include "dessert.hpp"`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Kitchen`类中的`Kitchen::Impl`声明中删除除两个新成员之外的所有私有成员。`#include <vector>`，`#include
    "recipe.hpp"`和`#include "dessert.hpp"`：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `Kitchen::Impl` constructor:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Kitchen::Impl`构造函数中：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For the remainder of the original methods, change them to be scoped to `Kitchen::Impl`
    instead of `Kitchen::`. For example, `std::string Kitchen::processOrder(std::string
    order)` becomes `std::string Kitchen::Impl::processOrder(std::string order)`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于原始方法的其余部分，将它们更改为作用域为`Kitchen::Impl`而不是`Kitchen::`。例如，`std::string Kitchen::processOrder(std::string
    order)`变为`std::string Kitchen::Impl::processOrder(std::string order)`。
- en: 'In `Kitchen::Impl`, add a constructor with a `std::string` argument and the
    `processOrder()` method. The `Kitchen::Impl` declaration should now look like
    the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Kitchen::Impl`中，添加一个带有`std::string`参数和`processOrder()`方法的构造函数。`Kitchen::Impl`声明现在应如下所示：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `#include <vector>`, `#include "recipe.hpp"` and `#include "dessert.hpp"`
    to the top of the file.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`#include <vector>`，`#include "recipe.hpp"`和`#include "dessert.hpp"`添加到文件顶部。
- en: Click on the `Kitchen::Kitchen` and `Kitchen::processOrder`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`Kitchen::Kitchen`和`Kitchen::processOrder`。
- en: 'In `Kitchen::Impl` method definitions, add the following two methods:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Kitchen::Impl`方法定义中，添加以下两个方法：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Click on the **Run** button to re-build the program. The program will run again
    to produce the original output.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Run**按钮重新构建程序。程序将再次运行以产生原始输出。
- en: '![Figure 4.6: The Kitchen program output using Pimpl'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6：使用Pimpl的厨房程序输出'
- en: '](img/C14583_04_06.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_06.jpg)'
- en: 'Figure 4.6: The Kitchen program output using Pimpl'
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.6：使用Pimpl的厨房程序输出
- en: In this exercise, we have taken a class that held many details in its private
    members and moved those details into a PIMPL class to hide the details and decouple
    the interface from the implementation using the techniques previously described.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们已经将一个类中的许多细节移到了PIMPL类中，以隐藏细节并使用先前描述的技术将接口与实现解耦。
- en: Function Objects and Lambda Expressions
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数对象和Lambda表达式
- en: 'One common pattern used in programming, particularly when implementing event-based
    processing, such as asynchronous input and output, is the use of the **callback**.
    A client registers that they want to be notified that an event has occurred (For
    example: data is available to read, or a data transmission is complete). This
    pattern is known as **Observer pattern** or **Subscriber Publisher pattern**.
    C++ supports a variety of techniques to provide the callback mechanism.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中常用的一种模式，特别是在实现基于事件的处理时，如异步输入和输出，是使用**回调**。客户端注册他们希望被通知事件发生的情况（例如：数据可供读取，或数据传输完成）。这种模式称为**观察者模式**或**订阅者发布者模式**。C
    ++支持各种技术来提供回调机制。
- en: Function Pointers
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数指针
- en: 'The first mechanism is the use of the **function pointers**. This is a legacy
    feature inherited from the C language. The following program shows an example
    of a function pointer:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种机制是使用**函数指针**。这是从C语言继承的传统功能。以下程序显示了函数指针的示例：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This program when compiled and executed, produces the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和执行此程序时，将产生以下输出：
- en: '![Figure 4.7: Function Pointer Program output'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7：函数指针程序输出'
- en: '](img/C14583_04_07.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_07.jpg)'
- en: 'Figure 4.7: Function Pointer Program output'
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.7：函数指针程序输出
- en: 'Strictly speaking the code should be modified as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，代码应修改如下：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, thing to note is that the address of (`&`) operator should be used to
    initialize the pointer. Secondly, we should check that the pointer is valid before
    calling it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是应使用地址（`&`）运算符来初始化指针。其次，在调用之前应检查指针是否有效。
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we attempt to compile this program, we get the following errors:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试编译此程序时，会得到以下错误：
- en: '![Figure 4.8: Errors compiling function pointer program'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8：编译函数指针程序时出现的错误'
- en: '](img/C14583_04_08.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_08.jpg)'
- en: 'Figure 4.8: Errors compiling function pointer program'
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.8：编译函数指针程序时出现的错误
- en: The text of the first error is `this` pointer.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个错误的文本是`this`指针。
- en: 'By changing the above program to the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将上述程序更改为以下内容：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It compiles and runs successfully:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它成功编译并运行：
- en: '![Figure 4.9: Function pointer program using static member function'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9：使用静态成员函数的函数指针程序'
- en: '](img/C14583_04_09.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_09.jpg)'
- en: 'Figure 4.9: Function pointer program using static member function'
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.9：使用静态成员函数的函数指针程序
- en: The function pointer technique is often used when interfacing with C libraries
    that use callbacks and operating system notifications which also support callbacks.
    In these two cases, it would be normal for the callback to take an argument which
    is a `void *` to a user registered data blob pointer. The data blob pointer could
    be the `this` pointer of a class which is then dereferenced and the callback forwarded
    into a member function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针技术通常用于与使用回调和支持回调的操作系统通知的C库进行接口的情况。在这两种情况下，回调通常会接受一个`void *`参数，该参数是用户注册的数据块指针。数据块指针可以是类的`this`指针，然后对其进行解引用，并将回调转发到成员函数。
- en: 'In other languages, such as Python and C#, it is a part of the language that
    capturing a function pointer will also capture the sufficient data to call that
    function (for example: `self` or `this`). C++ has the ability to make any object
    callable through the function call operator which we''ll cover next.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，如Python和C＃，捕获函数指针也会捕获调用该函数所需的足够数据（例如：`self`或`this`）是语言的一部分。 C ++具有通过函数调用运算符使任何对象可调用的能力，我们将在下面介绍。
- en: What is a Function Object?
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是函数对象？
- en: C++ allows for the function call operator `operator()` to be overloaded. This
    leads to the ability to make any object `callable`. An object that can be callable
    is known as a `Scaler` class in the following program implements a `functor`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: C ++允许重载函数调用运算符`operator()`。这导致可以使任何对象“可调用”。可调用的对象在以下程序中称为“Scaler”类实现了“functor”。
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are two objects of type `Scaler` created and they are used as functions
    inside the lines generating output. The above program produces the following output:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了两个类型为`Scaler`的对象，并且它们在生成输出的行内被用作函数。上述程序产生以下输出：
- en: '![Figure 4.10: Functors program output'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10：functors程序输出'
- en: '](img/C14583_04_10.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_10.jpg)'
- en: 'Figure 4.10: Functors program output'
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.10：函数对象程序输出
- en: One advantage of `functors` over function pointers is that they can contain
    state, either as an object or across all instances. Another advantage is that
    they can be passed to STL algorithms that expect a function (for example `std::for_each`)
    or an operator (for example `std::transform`).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`functors`相对于函数指针的一个优点是它们可以包含状态，可以是对象或跨所有实例。另一个优点是它们可以传递给期望函数（例如`std::for_each`）或操作符（例如`std::transform`）的STL算法。'
- en: 'An example of such a use might look like following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的用法示例可能如下所示：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we run this program, the output produced will look like the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，产生的输出将如下所示：
- en: '![Figure 4.11: Program output showing Scaler transformed vectors'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11：显示标量转换向量的程序输出'
- en: '](img/C14583_04_11.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_11.jpg)'
- en: 'Figure 4.11: Program output showing Scaler transformed vectors'
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.11：显示标量转换向量的程序输出
- en: 'Exercise 2: Implementing function objects'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：实现函数对象
- en: In this exercise, we will implement two different function objects that can
    work with the STL algorithm for_each.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现两个不同的函数对象，可以与STL算法`for_each`一起使用。
- en: Open the **Lesson4** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson4** then **Exercise02** and double click on **Exercise2.cpp** to
    open the file for this exercise into the editor.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson4**项目，然后在**项目资源管理器**中展开**Lesson4**，然后展开**Exercise02**，双击**Exercise2.cpp**以打开此练习的文件到编辑器中。
- en: As this is a CMake based project, change the current builder to be CMake Build
    (portable).
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个基于CMake的项目，将当前构建器更改为CMake Build（便携式）。
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure **L4Exercise2** to run with the name **Exercise2**.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**启动配置**下拉菜单，选择**新启动配置...**。配置**L4Exercise2**以名称**Exercise2**运行。
- en: 'Click on the **Run** button. Exercise 2 will run and produce the following
    output:![Figure 4.12: Exercise 2 Initial output'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮。练习2将运行并产生以下输出：![图4.12：练习2的初始输出
- en: '](img/C14583_04_12.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_12.jpg)'
- en: 'Figure 4.12: Exercise 2 Initial output'
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.12：练习2的初始输出
- en: The first thing we will do is fix the formatting of the output by introducing
    a function object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是通过引入函数对象来修复输出的格式。
- en: 'In the editor, before the definition of `main()` function add the following
    class definition:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，在`main()`函数定义之前添加以下类定义：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Inside the **main()** method replace the following code
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**main()**方法中替换以下代码
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**with**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**带有**'
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:![Figure 4.13: Exercise 2 Improved output format'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮。练习将运行并产生以下输出：![图4.13：改进的输出格式的练习2
- en: '](img/C14583_04_13.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_13.jpg)'
- en: 'Figure 4.13: Exercise 2 Improved output format'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.13：改进的输出格式的练习2
- en: 'The internal state of the `Printer` class allows us to fix the formatting.
    Now, introduce an `aggregator` class that will allow us to calculate the `average`.
    Add the following class definition to the top of the file:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Printer`类的内部状态允许我们修复格式。现在，引入一个`aggregator`类，它将允许我们计算`average`。在文件顶部添加以下类定义：'
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Modifiy `main()` method to use the `Averager` class as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`main()`方法以使用`Averager`类如下：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮。练习将运行并产生以下输出：
- en: '![Figure 4.14: Exercise 2 output with average'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.14：带有平均值的练习2输出'
- en: '](img/C14583_04_14.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_14.jpg)'
- en: 'Figure 4.14: Exercise 2 output with average'
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.14：带有平均值的练习2输出
- en: 'Note that `std::for_each()` returns the instance of `Averager` passed into
    it. This instance is copied into the variable `averager` that then contains the
    data required to calculate the average. In this exercise, we implemented two function
    objects or `functor` classes: `Averager` and `Printer` that we could use as functions
    when passed to the STL algorithm `for_each`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`std::for_each()`返回传递给它的`Averager`的实例。这个实例被复制到变量`averager`中，然后包含了计算平均值所需的数据。在这个练习中，我们实现了两个函数对象或`functor`类：`Averager`和`Printer`，当传递给STL算法`for_each`时，我们可以将它们用作函数。
- en: std::function<> template
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::function<>模板
- en: C++11 introduced a general polymorphic function wrapper template, `std::function<>`,
    that makes implementing callbacks and other function related capabilities easier.
    `std::function` holds a callable object known as the `std::function` will result
    in `std::bad_function_call` exception being thrown.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了一个通用的多态函数包装模板，`std::function<>`，使得实现回调和其他与函数相关的功能更容易。`std::function`保存一个可调用对象，称为`std::function`将导致抛出`std::bad_function_call`异常。
- en: 'The function object can store, copy or invoke a target that is any of the following
    callable objects: functions, function objects (defines the `operator()`), a pointer
    to member function or a lambda expression. We will cover more about it in the
    topic *What is a Lambda Expression?*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象可以存储、复制或调用目标，这些目标可以是以下任何可调用对象：函数、函数对象（定义了`operator()`）、成员函数指针或lambda表达式。我们将在主题*什么是Lambda表达式？*中更多地介绍它。
- en: 'When instantiating a `std::function` object, it is only necessary to provide
    the function signature and not the value to initialize it with, leading to an
    empty instance. The instantiation is done as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化`std::function`对象时，只需要提供函数签名，而不需要初始化它的值，导致一个空实例。实例化如下所示：
- en: '![Figure 4.15: Structure of a std::function declaration'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.15：std::function声明的结构'
- en: '](img/C14583_04_15.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_15.jpg)'
- en: 'Figure 4.15: Structure of a std::function declaration'
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.15：std::function声明的结构
- en: The arguments to the template, define the `function signature` of the target
    stored by `variable`. The signature starts with the return type (which may be
    void) and then places inside the parentheses the list of types that the function
    will be invoked with.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的参数定义了`variable`存储的目标的`function signature`。签名以返回类型开始（可以是void），然后在括号内放置函数将被调用的类型列表。
- en: The use of free functions and `functors` with `std::function` is straight forward.
    Provided that the signature matches the parameters passed to the `std::function`
    template, we can simply equate the free function or `functor` to the instance.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自由函数和`std::function`的`functor`非常简单。只要签名与传递给`std::function`模板的参数匹配，我们就可以简单地将自由函数或`functor`等同于实例。
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, if we want to use a method on an object instance then we need to use
    another STL helper template `std::bind()`. If we run the following program:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想要在对象实例上使用一个方法，那么我们需要使用另一个STL辅助模板`std::bind()`。如果我们运行以下程序：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then we get the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们得到以下输出：
- en: '![Figure 4.16: Program output using std::bind() and std::function'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.16：使用std::bind()和std::function的程序输出'
- en: '](img/C14583_04_16.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_16.jpg)'
- en: 'Figure 4.16: Program output using std::bind() and std::function'
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.16：使用std::bind()和std::function的程序输出
- en: 'Several points to note:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意几点：
- en: The function `method()` is referenced using the class as a scope specifier;
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数`method()`是使用类作为作用域限定符引用的；
- en: The address of the instance of `Binder` is passed as the second argument to
    `std::bind()` which makes it the first argument passed to `method()`. This is
    necessary as all non-static members have an implicit `this` pointer passed as
    the first argument.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Binder`实例的地址作为第二个参数传递给`std::bind()`，这使其成为传递给`method()`的第一个参数。这是必要的，因为所有非静态成员都有一个隐式的`this`指针作为第一个参数传递。'
- en: Using the `std::placeholders` definitions, we can bind arguments used when invoking
    the bound method and even change the order passed (as seen by `func3`).
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::placeholders`定义，我们可以绑定调用绑定方法时使用的参数，甚至改变传递的顺序（如`func3`所示）。
- en: C++11 introduced some syntactic sugar, known as lambda expressions, that make
    it easier to define anonymous functions that can also be used to bind methods
    and assign them to `std::function` instances expression. We'll cover more about
    it in the topic *What is a Lambda Expression?*
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了一些称为lambda表达式的语法糖，使得更容易定义匿名函数，还可以用于绑定方法并将它们分配给`std::function`实例表达式。我们将在*什么是Lambda表达式？*主题中更多地涵盖它。
- en: 'Exercise 3: Implementing callbacks with std::function'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：使用std::function实现回调
- en: 'In this exercise, we will implement function callbacks utilizing the `std::function<>`
    template. Follow the below steps to implement this exercise:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将利用`std::function<>`模板实现函数回调。按照以下步骤实现这个练习：
- en: Open the **Lesson4** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson4** then **Exercise03** and double click on **Exercise3.cpp** to
    open the file for this exercise into the editor.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson4**项目，然后在**Project Explorer**中展开**Lesson4**，然后展开**Exercise03**，双击**Exercise3.cpp**以将此练习的文件打开到编辑器中。
- en: As this is a CMake based project, change the current builder to be CMake Build
    (portable).
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个基于CMake的项目，请将当前构建器更改为CMake Build（便携式）。
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure **L4Exercise3** to run with the name **Exercise3**.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**启动配置**下拉菜单，然后选择**新启动配置…**。配置**L4Exercise3**以使用名称**Exercise3**运行。
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:![Figure 4.17: Exercise 3 output (Calling empty std::function)'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。练习将运行并产生以下输出：![图4.17：练习3输出（调用空的std::function）
- en: '](img/C14583_04_17.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_17.jpg)'
- en: 'Figure 4.17: Exercise 3 output (Calling empty std::function)'
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.17：练习3输出（调用空的std::function）
- en: 'The first thing we will do is prevent calling an empty `TestFunctionTemplate()`
    the line `func(42);` and replace it with the following code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是防止调用空的`TestFunctionTemplate()`行`func(42);`，并用以下代码替换它：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:![Figure 4.18: Exercise 3 output (preventing call to empty std::function)'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。练习将运行并产生以下输出：![图4.18：练习3输出（防止调用空的std::function）
- en: '](img/C14583_04_18.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_18.jpg)'
- en: 'Figure 4.18: Exercise 3 output (preventing call to empty std::function)'
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.18：练习3输出（防止调用空的std::function）
- en: 'Add the `FreeFunction()` method to the file before the function `TestFunctionTemplate()`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数`TestFunctionTemplate()`之前的文件中添加`FreeFunction()`方法：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In `TestFunctionTemplate()` function, immediately before `if (func)` add the
    following line:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TestFunctionTemplate()`函数中，在`if (func)`之前立即添加以下行：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:![Figure 4.19: Exercise 3 output (FreeMethod)'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。练习将运行并产生以下输出：![图4.19：练习3输出（FreeMethod）
- en: '](img/C14583_04_19.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_19.jpg)'
- en: 'Figure 4.19: Exercise 3 output (FreeMethod)'
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.19：练习3输出（FreeMethod）
- en: 'Add the new class definition before `TestFunctionTemplate()` function:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TestFunctionTemplate()`函数之前添加新的类定义：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Replace the line `func = FreeFunction;` with the following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换行`func = FreeFunction;`：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:![4.20: Exercise 3 output (Object function call override)'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。练习将运行并产生以下输出：![4.20：练习3输出（对象函数调用覆盖）
- en: '](img/C14583_04_20.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_20.jpg)'
- en: '4.20: Exercise 3 output (Object function call override)'
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 4.20：练习3输出（对象函数调用覆盖）
- en: 'Replace the line `func = funcClass;` with the following code:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换行`func = funcClass;`：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:![Figure 4.21: Exercise 3 output (Member function)'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。练习将运行并产生以下输出：![图4.21：练习3输出（成员函数）
- en: '](img/C14583_04_21.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_21.jpg)'
- en: 'Figure 4.21: Exercise 3 output (Member function)'
  id: totrans-235
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.21：练习3输出（成员函数）
- en: 'Replace the line `func = std::bind(…);` with the following code:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换行`func = std::bind(…);`：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。练习将运行并产生以下输出：
- en: '![Figure 4.22: Exercise 3 output (lambda function)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.22：练习3输出（lambda函数）'
- en: '](img/C14583_04_22.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_22.jpg)'
- en: 'Figure 4.22: Exercise 3 output (lambda function)'
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.22：练习3输出（lambda函数）
- en: In this exercise, we implemented four different types of function callback using
    the `std::function` template – free method, class member function, class function
    call method and a lambda function (which we look at next).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用`std::function`模板实现了四种不同类型的函数回调-自由方法，类成员函数，类函数调用方法和Lambda函数（我们将在下面讨论）。
- en: What is a Lambda Expression?
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是Lambda表达式？
- en: 'Since C++11, C++ has supported `anonymous functions`, also known as `lambda
    expressions`, or just `lambdas`. The two most common forms of lambda expression
    are:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++11以来，C++支持`匿名函数`，也称为`lambda表达式`或`lambda`。Lambda表达式的两种最常见形式是：
- en: '![Figure 4.23: Most common forms of lambda expressions'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.23：Lambda表达式的最常见形式'
- en: '](img/C14583_04_23.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_23.jpg)'
- en: 'Figure 4.23: Most common forms of lambda expressions'
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.23：Lambda表达式的最常见形式
- en: Under normal circumstances, the compiler is able to deduce the return type of
    the lambda based on the return statements within the **function_body** (as embodied
    by form (1) in the figure above). However, if the compiler cannot determine the
    return type, or if we wish to force a different type, then we can use form (2).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，编译器能够根据**function_body**中的返回语句推断Lambda的返回类型（如上图中的形式（1）所示）。然而，如果编译器无法确定返回类型，或者我们希望强制使用不同的类型，那么我们可以使用形式（2）。
- en: Everything after `[captures]` is the same as for a normal function definition,
    except that the name is missing. Lambdas are a convenient way of defining a short
    method (just a few lines) at the location it will be used. The lambda is often
    passed as an argument and will typically not be re-used. It should also be noted
    that a lambda can be assigned to a variable (usually declared with auto).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[captures]之后的所有内容与普通函数定义相同，只是缺少名称。Lambda是一种方便的方式，可以在将要使用的位置定义一个简短的方法（只有几行）。Lambda通常作为参数传递，并且通常不会被重复使用。还应该注意，Lambda可以分配给一个变量（通常使用auto声明）。'
- en: 'We can re-write the previous program where we used a `Scaler` class to use
    a lambda to achieve the same outcome:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新编写先前的程序，其中我们使用了`Scaler`类来使用Lambda来实现相同的结果：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When this program runs the output shows that the vector has been scaled by
    5:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当此程序运行时，输出显示向量已被缩放了5倍：
- en: '![Figure 4.24: Transform using lambda for scaling'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.24：使用lambda进行缩放的转换'
- en: '](img/C14583_04_24.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_24.jpg)'
- en: 'Figure 4.24: Transform using lambda for scaling'
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.24：使用lambda进行缩放的转换
- en: The lambda in this program is `[] (int n) {return 5*n;}` and has an empty capture
    clause `[]`. The empty capture clause means that the lambda function does not
    access any variables from the surrounding scope. If there are no parameters passed
    to the lambda, then the parameters clause `()` is optional.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序中的Lambda是`[]（int n）{return 5*n;}`，并且具有空的捕获子句`[]`。空的捕获子句意味着Lambda函数不访问周围范围内的任何变量。如果没有参数传递给Lambda，则参数子句`()`是可选的。
- en: Capturing data into Lambdas
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获数据到Lambda中
- en: The `operator()`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator()`。'
- en: 'A capture clause is a comma-separated list of zero or more captured variables.
    There is also the concept of default captures – either by reference or by value.
    So, the basic syntax for a capture is:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获子句是零个或多个被捕获变量的逗号分隔列表。还有默认捕获的概念-通过引用或通过值。因此，捕获的基本语法是：
- en: '`[&]` – captures all automatic storage duration variables in scope by reference'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[&]` - 通过引用捕获作用域内的所有自动存储期变量'
- en: '`[=]` – captures all automatic storage duration variables in scope by value
    (make a copy)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[=]` - 通过值捕获作用域内的所有自动存储期变量（制作副本）'
- en: '`[&x, y]` – captures x by reference and y by value'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[&x, y]` - 通过引用捕获x，通过值捕获y'
- en: This is translated by the compiler into member variables that are initialized
    by the constructor of the anonymous `functor` class. In case of the default captures
    (`&` and `=`), they must come first and only the variables referenced in the body
    are captured. The default capture can be overridden by placing the specific variable
    into the capture clause after the default capture. For example, `[&, x]` will
    by default capture by reference everything except `x` which it will capture by
    value.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将此转换为由匿名`functor`类的构造函数初始化的成员变量。在默认捕获（`&`和`=`）的情况下，它们必须首先出现，且仅捕获体中引用的变量。默认捕获可以通过在默认捕获后的捕获子句中放置特定变量来覆盖。例如，`[&，x]`将默认通过引用捕获除`x`之外的所有内容，它将通过值捕获`x`。
- en: However, while the default captures are convenient, they are not the preferred
    method of capture. This is because it can lead to dangling references (capture
    by reference and the referenced variable no longer exists when accessed by the
    lambda) or dangling pointers (capture by value, especially this pointers). It
    is clearer to capture your variables explicitly, which has the added benefit of
    the compiler being able to warn you about unexpected effects (such as trying to
    capture global or static variables).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，默认捕获虽然方便，但并不是首选的捕获方法。这是因为它可能导致悬空引用（通过引用捕获和引用的变量在Lambda访问时不再存在）或悬空指针（通过值捕获，特别是this指针）。明确捕获变量更清晰，而且编译器能够警告您意外效果（例如尝试捕获全局或静态变量）。
- en: 'C++14 introduced the **init capture** to the capture clause allowing for safer
    code and some optimizations. An init capture declares a variable in the capture
    clause and initializes it for use inside the lambda. An example of this is:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: C++14引入了**init capture**到捕获子句，允许更安全的代码和一些优化。初始化捕获在捕获子句中声明一个变量，并初始化它以在Lambda内部使用。例如：
- en: '[PRE40]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, `z` is declared and initialized in the capture clause so that it can
    be used in the lambda. If you want to use the x and y in the lambda, then they
    must be captured separately. As expected, when the lambda is called it produces
    the following output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`z`在捕获子句中声明并初始化，以便可以在Lambda中使用。如果要在Lambda中使用x和y，则它们必须分别捕获。如预期的那样，当调用Lambda时，它会产生以下输出：
- en: '[PRE41]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The init capture can also be used to capture movable objects into the lambda,
    or make copies of class members as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化捕获也可以用于将可移动对象捕获到Lambda中，或者如下所示复制类成员：
- en: '[PRE42]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This captures the value of the member variable and happens to give it the same
    name for use inside the lambda.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这捕获了成员变量的值，并恰好给它相同的名称以在lambda内部使用。
- en: By default, a lambda is a const function, meaning that it cannot change the
    value of a capture-by-value variable. Where it is desirable to modify the value,
    we need to use a third form of lambda expression shown below.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，lambda是一个const函数，这意味着它不能改变按值捕获的变量的值。在需要修改值的情况下，我们需要使用下面显示的lambda表达式的第三种形式。
- en: '![Figure 4.25: Another form of lambda expression'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.25：另一种lambda表达式形式'
- en: '](img/C14583_04_25.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_25.jpg)'
- en: 'Figure 4.25: Another form of lambda expression'
  id: totrans-275
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.25：另一种lambda表达式形式
- en: In this case, `specifiers` is replaced by `mutable`, telling the compiler that
    we want to modify the captured values. If we don't add mutable, and we attempt
    to modify a captured value, then the compiler will produce an error.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`specifiers`被`mutable`替换，告诉编译器我们想要修改捕获的值。如果我们不添加mutable，并尝试修改捕获的值，那么编译器将产生错误。
- en: 'Exercise 4: Implementing Lambdas'
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习4：实现Lambda
- en: 'In this exercise we will implement lambdas to perform a number of actions in
    the context of STL algorithms. Follow the below steps to implement this exercise:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现lambda以在STL算法的上下文中执行多个操作。按照以下步骤实现这个练习：
- en: Open the **Lesson4** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson4** then **Exercise04** and double click on **Exercise4.cpp** to
    open the file for this exercise into the editor.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson4**项目，然后在**Project Explorer**中展开**Lesson4**，然后双击**Exercise04**，再双击**Exercise4.cpp**以将此练习的文件打开到编辑器中。
- en: As this is a CMake based project, change the current builder to be CMake Build
    (portable).
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个基于CMake的项目，将当前构建器更改为CMake Build（便携式）。
- en: Click on the **Launch Configuration** drop down menu and select **New Launch
    Configuration…**. Configure **L4Exercise4** to run with the name **Exercise4**.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Launch Configuration**下拉菜单，选择**New Launch Configuration…**。配置**L4Exercise4**以使用名称**Exercise4**运行。
- en: 'Click on the **Run** button. The exercise will run and produce the following
    output:![Figure 4.26: Initial output from Exercise 4'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。练习将运行并产生以下输出：![图4.26：练习4的初始输出
- en: '](img/C14583_04_26.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_26.jpg)'
- en: 'Figure 4.26: Initial output from Exercise 4'
  id: totrans-284
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.26：练习4的初始输出
- en: 'The program `PrintVector()` and `main()`. `PrintVector()` is the same as the
    version we introduced in *What is a Function Object?*. Now modify it to use the
    `std::for_each()` library function and a lambda instead of the ranged-for loop.
    Update `PrintVector()` to be:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序`PrintVector()`和`main()`。`PrintVector()`与我们在*什么是函数对象？*中介绍的版本相同。现在修改它以使用`std::for_each()`库函数和lambda，而不是范围for循环。更新`PrintVector()`如下：
- en: '[PRE43]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Click on the **Run** button and we get the same output as before.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮，我们得到与之前相同的输出。
- en: 'Examine the lambda, we have captured the local variable `sep` by reference.
    Remove the `&` from `sep` and click on the **Run** button. This time the compilation
    fails with the following error:![Figure 4.27: Compilation failure due to modifying
    read-only variable'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查lambda，我们通过引用捕获了本地变量`sep`。从`sep`中删除`&`，然后单击**运行**按钮。这次编译失败，并显示以下错误：![图4.27：由于修改只读变量而导致的编译失败
- en: '](img/C14583_04_27.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_27.jpg)'
- en: 'Figure 4.27: Compilation failure due to modifying read-only variable'
  id: totrans-290
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.27：由于修改只读变量而导致的编译失败
- en: 'Change the lambda declaration to include the `mutable` specifier:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改lambda声明以包括`mutable`修饰符：
- en: '[PRE44]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Click on the **Run** button and we get the same output as before.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮，我们得到与之前相同的输出。
- en: 'But we can go one step further. Remove the declaration of `sep` from the function
    `PrintVector()` and change the lambda again to include an init capture. Write
    the following code to implement this:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但我们可以再进一步。从函数`PrintVector()`的声明中删除`sep`，并再次更改lambda以包括init捕获。编写以下代码来实现这一点：
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Click on the `PrintVector()` it now looks more compact as:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`PrintVector()`，现在看起来更紧凑：
- en: '[PRE46]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add the following lines after the call to `PrintVector()` in `main()` method:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`方法中调用`PrintVector()`之后，添加以下行：
- en: '[PRE47]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Click on the **Run** button and the output now adds the list of values sorted
    in descending order:![Figure 4.28: Program output for descending sort lambda'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮，现在的输出添加了按降序排序的值列表：![图4.28：按降序排序lambda的程序输出
- en: '](img/C14583_04_28.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_28.jpg)'
- en: 'Figure 4.28: Program output for descending sort lambda'
  id: totrans-302
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.28：降序排序lambda的程序输出
- en: 'Change the lambda function body to be `{return a<b;}`. Click on the **Run**
    button and the output now shows the values sorted in ascending order:![Figure
    4.29: Program output for ascending sort lambda'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将lambda函数体更改为`{return a<b;}`。单击**运行**按钮，现在的输出显示值按升序排序：![图4.29：按升序排序lambda的程序输出
- en: '](img/C14583_04_29.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_29.jpg)'
- en: 'Figure 4.29: Program output for ascending sort lambda'
  id: totrans-305
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.29：按升序排序lambda的程序输出
- en: 'After the call to `PrintVector()` function, add the following lines of code:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`PrintVector()`函数之后，添加以下代码行：
- en: '[PRE48]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Click on the `values > 25`:![Figure 4.30: Output for count_if lambda stored
    in variable'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`值> 25`：![图4.30：存储在变量中的count_if lambda的输出
- en: '](img/C14583_04_30.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_30.jpg)'
- en: 'Figure 4.30: Output for count_if lambda stored in variable'
  id: totrans-310
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.30：存储在变量中的count_if lambda的输出
- en: 'Add the following lines after the ones above and click the **Run** button:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述行之后添加以下行，并单击**运行**按钮：
- en: '[PRE49]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Following output will be generated:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将被生成：
- en: '![Figure 4.31: Erroneous output by re-using the pred lambda'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.31：通过重用pred lambda产生的错误输出'
- en: '](img/C14583_04_31.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_31.jpg)'
- en: 'Figure 4.31: Erroneous output by re-using the pred lambda'
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.31：通过重用pred lambda产生的错误输出
- en: 'The program wrongly reports that there are `seven (7) values > 40`; it should
    be `three (3)`. The problem is that when the lambda was created and stored in
    the variable `pred`, it captured the current value of threshold which was `25`.
    Change the line that defines `pred` to the following:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序错误地报告有`七（7）个值> 40`；应该是`三（3）`。问题在于当创建lambda并将其存储在变量`pred`中时，它捕获了阈值的当前值，即`25`。将定义`pred`的行更改为以下内容：
- en: '[PRE50]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Click on the **Run** button and the output now correctly reports the count:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮，现在输出正确报告计数：
- en: '![Figure 4.32: Correct output re-using the pred lambda'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.32：重用pred lambda的正确输出'
- en: '](img/C14583_04_32.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_32.jpg)'
- en: 'Figure 4.32: Correct output re-using the pred lambda'
  id: totrans-322
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.32：重用pred lambda的正确输出
- en: In this exercise, we implemented several lambdas, using various features of
    the lambda expression syntax including init capture and mutable.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用lambda表达式语法的各种特性实现了几个lambda，包括init捕获和mutable。
- en: Using lambdas
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用lambda
- en: While lambdas are a powerful feature of C++, they should be used appropriately.
    The goal is always to produce readable code. So, while a lambda might be short
    and to the point, sometimes it will be better for maintenance purposes to factor
    out the functionality into a well named method.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然lambda是C++的一个强大特性，但应该适当使用。目标始终是生成可读的代码。因此，虽然lambda可能很简短并且简洁，但有时将功能分解为一个命名良好的方法会更好以便于维护。
- en: Variadic Templates
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变模板
- en: In *Chapter 2B*, *No Ducks Allowed - Templates and Deduction*, we introduced
    generic programming and templates. Templates have been part of C++ before C++03\.
    Prior to C++11, templates were limited to a fixed number of arguments. In some
    cases, where a variable number of arguments was required, it was necessary to
    write a template for each variant of argument numbers required. Alternatively,
    there were variadic functions like `printf()` that could take a variable number
    of arguments. The problem with variadic functions is that they are not type safe
    as access to the arguments was through type casts via the `va_arg` macro. C++11
    changed all that with the introduction of variadic templates where a single template
    can take an arbitrary number of arguments. C++17 improved the writing of variadic
    templates by introducing the `constexpr` if construct that would allow the base
    case template to be merged with the "`recursive`" template.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2B章*，*不允许鸭子-模板和推导*中，我们介绍了泛型编程和模板。在C++03之前的C++中，模板一直是C++的一部分。在C++11之前，模板的参数数量是有限的。在某些情况下，需要变量数量的参数，需要为所需参数数量的每个变体编写模板。或者，有像`printf()`这样可以接受可变数量参数的可变函数。可变函数的问题在于它们不是类型安全的，因为对参数的访问是通过`va_arg`宏进行类型转换。C++11通过引入可变模板改变了这一切，其中一个模板可以接受任意数量的参数。C++17通过引入`constexpr`
    if结构改进了可变模板的编写，该结构允许基本情况模板与“递归”模板合并。
- en: The best approach is to implement a variadic template and explain how it works.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是实现一个可变模板并解释它是如何工作的。
- en: '[PRE51]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When we run this program, we get the following output:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，我们得到以下输出：
- en: '![Figure 4.33: Variadic Template Program Output'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.33：可变模板程序输出'
- en: '](img/C14583_04_33.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_33.jpg)'
- en: 'Figure 4.33: Variadic Template Program Output'
  id: totrans-333
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.33：可变模板程序输出
- en: 'So, what are the parts of a variadic template? And how do we read one? Consider
    the template from the above program:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，可变模板的部分是什么？我们如何阅读它？考虑上面程序中的模板：
- en: '[PRE52]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the above code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中：
- en: '`typename... Args` declares `Args` as a `template parameter pack`.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typename... Args` 声明 `Args` 为 `模板参数包`。'
- en: '`Args... args` is a `function parameter pack`, that is a bag of parameters
    whose types are given by `Args`.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Args... args`是一个`函数参数包`，其类型由`Args`给出。'
- en: '`sizeof...(args)` returns the number of pack elements in `args`. It is a special
    form of pack expansion.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sizeof...(args)`返回`args`中包的元素数量。这是一种特殊形式的包扩展。'
- en: '`args...` expands the pack in the recursive call to `summer()`.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args...`在对`summer()`的递归调用中展开了包。'
- en: 'Alternatively, you can think of the template as effectively the equivalent
    of:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将模板视为等效于：
- en: '[PRE53]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When the compiler processes `summer(1, 3, 5, 7, 9, 11)` in the sample program,
    it performs the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器处理样本程序中的`summer(1, 3, 5, 7, 9, 11)`时，它执行以下操作：
- en: It deduces that `T` is int and `Args...` is our parameter pack with <int, int,
    int, int, int>.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它推断`T`是int，`Args...`是我们的参数包，带有<int, int, int, int, int>。
- en: As there are more than zero args in the pack, the compiler generates `first
    + summer(args...)` with the ellipsis unpacking the template argument transforming
    `summer(args...)` into `summer(3,5,7,9,11)`.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于包中有多个参数，编译器生成了`first + summer(args...)`，省略号展开了模板参数，将`summer(args...)`转换为`summer(3,5,7,9,11)`。
- en: The compiler then generates the code for `summer(3,5,7,9,11)`. Again, resulting
    in `first + summer(args...)` being applied where `summer(5,7,9,11)`.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后编译器生成了`summer(3,5,7,9,11)`的代码。同样，应用了`first + summer(args...)`，其中`summer(5,7,9,11)`。
- en: This process is repeated until the compiler has to generate code for `summer(11)`.
    In this case, the else clause of the `constexpr` if statement is triggered which
    simply returns `first`.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个过程重复进行，直到编译器必须为`summer(11)`生成代码。在这种情况下，`constexpr` if语句的else子句被触发，它简单地返回`first`。
- en: As the types are determined by the arguments to the template, we are not restricted
    to the arguments having the same type. We have already met a couple of variadic
    templates in the STL – `std::function` and std::bind.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型由模板的参数确定，因此我们不限于参数具有相同的类型。我们已经在STL中遇到了一些可变模板-`std::function`和std::bind。
- en: 'There is another type of variadic template, one which forwards its arguments
    onto another function or template. This kind of template does little on its own
    but provides a standard approach to things. One example is the `make_unique` template
    which could be implemented as:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种类型的可变模板，它将其参数转发到另一个函数或模板。这种类型的模板本身并不做太多事情，但提供了一种标准的方法。一个例子是`make_unique`模板，可以实现为：
- en: '[PRE54]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`make_unique` has to call the new operator to allocate memory and then call
    the appropriate constructor for the type. The number of arguments required to
    call the constructor can vary greatly. This form of variadic template introduces
    some addition pack expansions:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_unique`必须调用new运算符来分配内存，然后调用类型的适当构造函数。调用构造函数所需的参数数量可能会有很大的变化。这种形式的可变模板引入了一些额外的包扩展：'
- en: '`Args&&...` means we have a list of forwarding references.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Args&&...`表示我们有一系列转发引用。'
- en: '`std::forward<Args>(args)...` which contains to parameter packs that are expanded
    together and must have the same number of elements – Args the template parameter
    pack and args the function parameter pack.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward<Args>(args)...`包含要一起展开的参数包，必须具有相同数量的元素-Args模板参数包和args函数参数包。'
- en: This pattern is used whenever we need to forward a function call to another
    function call in a variadic template.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要在可变参数模板中将一个函数调用转发到另一个函数调用时，就会使用这种模式。
- en: 'Activity 1: Implement a multicast event handler'
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：实现多播事件处理程序
- en: Microsoft first introduced the `Microsoft Foundation Class` (`MFC`) in 1992
    when C++ was in its infancy. This means that many of the design choices around
    the classes were restricted. For example, the handlers for events are typically
    routed through `OnEventXXX()` methods. These are usually configured using macros
    as part of a class derived from the MFC classes. Your team has been tasked with
    implementing multicast event handler more like delegates available in C# using
    templates that embody function objects and lead to variadic templates to achieve
    the variable argument lists.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 1992年，当C++处于萌芽阶段时，微软首次引入了`Microsoft Foundation Class`（`MFC`）。这意味着许多围绕这些类的设计选择受到了限制。例如，事件的处理程序通常通过`OnEventXXX()`方法路由。这些通常使用宏配置为从MFC类派生的类的一部分。您的团队被要求使用模板来实现更像C#中可用的委托的多播事件处理程序，这些模板体现了函数对象，并导致可变参数模板以实现可变参数列表。
- en: 'In C#, you declare a delegate as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，您可以声明委托如下：
- en: '[PRE55]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This makes Handler a type that can be assigned a value which can be called.
    This is essentially what `std::function<>` delivers us in C++ except for the ability
    to multi-cast. Your team is asked to develop a template class `Delegate` that
    can perform the same way as the C# delegate.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得Handler成为一个可以分配值并进行调用的类型。这基本上就是C++中`std::function<>`为我们提供的，除了能够进行多播。您的团队被要求开发一个模板类“Delegate”，可以像C#委托一样进行操作。
- en: The delegate will take a `variable list of arguments` but only return `void`
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Delegate将接受“可变参数列表”，但只返回“void”
- en: The `operator+=` will be used to add new callbacks to the delegate
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator+=`将用于向委托添加新的回调'
- en: It will be called either using either syntax `delegate.Notify(…)` or `delegate(…)`
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将使用以下语法之一进行调用：`delegate.Notify(…)`或`delegate(…)`
- en: 'Follow these steps to develop the Delegate template:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤开发Delegate模板：
- en: Load the prepared project from the **Lesson4/Activity01** folder and configure
    the Current Builder for the project to be CMake Build (Portable).
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Lesson4/Activity01**文件夹加载准备好的项目，并为项目配置当前构建器为CMake Build（Portable）。
- en: Build the project, configure the launcher and run the unit tests (which fail
    the one dummy test). Recommend that the name used for the tests runner is **L4delegateTests**.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目，配置启动器并运行单元测试（其中一个虚拟测试失败）。建议为测试运行器使用的名称是**L4delegateTests**。
- en: Implement a `Delegate` class that can wrap a single handler with all the required
    methods and supports a single int parameter for the callback.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个“Delegate”类，可以使用所有必需的方法包装单个处理程序，并支持回调的单个int参数。
- en: Update the template class to support multi-casting.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新模板类以支持多播。
- en: Convert the `Delegate` class to a template that can take a single template argument
    that defines the argument type used by the callbacks.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Delegate”类转换为模板，可以接受定义回调函数使用的参数类型的单个模板参数。
- en: Convert the `Delegate` template to a variadic template that can take zero or
    more arguments that define the types passed to the callbacks.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Delegate”模板转换为可变参数模板，可以接受零个或多个定义传递给回调函数的类型的参数。
- en: 'After following the above steps, the expected output looks like the following:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 按照上述步骤后，预期输出如下：
- en: '![Figure 4.34: Output from the successful implementation of Delegate'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.34：Delegate成功实现的输出'
- en: '](img/C14583_04_34.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_04_34.jpg)'
- en: 'Figure 4.34: Output from the successful implementation of Delegate'
  id: totrans-373
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.34：Delegate成功实现的输出
- en: Note
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 673.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第673页找到。
- en: Summary
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented a data and method hiding design approach, PIMPL,
    that has the added benefit of reducing dependencies and reducing build times.
    We then implemented function objects directly as custom classes and then as lambda
    functions. We then expanded our template programming skills by diving into variadic
    templates culminating in a template which can be used for event callback processing.
    In the next chapter, we will learn how to use the features of C++ to develop programs
    with multiple thread and manage their co-operation through concurrency constructs.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了一种数据和方法隐藏的设计方法PIMPL，它具有减少依赖关系和减少构建时间的附加好处。然后，我们直接将函数对象实现为自定义类，然后作为lambda函数。然后，我们通过深入研究可变参数模板来扩展我们的模板编程技能，最终实现了一个可用于事件回调处理的模板。在下一章中，我们将学习如何使用C++的特性来开发具有多个线程的程序，并通过并发构造来管理它们的协作。
