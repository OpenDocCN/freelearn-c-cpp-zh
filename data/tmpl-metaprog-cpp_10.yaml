- en: '*Chapter 7*: Patterns and Idioms'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第七章*：模式和惯用法'
- en: 'The previous parts of the book were designed to help you learn everything about
    templates, from the basics to the most advanced features, including the latest
    concepts and constraints from C++20\. Now, it is time for us to put this knowledge
    to work and learn about various metaprogramming techniques. In this chapter, we
    will discuss the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前几部分旨在帮助您了解有关模板的各个方面，从基础知识到最先进的功能，包括来自 C++20 的最新概念和约束。现在，是我们将这一知识付诸实践并学习各种元编程技术的时候了。在本章中，我们将讨论以下主题：
- en: Dynamic versus static polymorphism
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态多态与静态多态
- en: The **Curiously Recurring Template Pattern** (**CRTP**)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**奇特重复模板模式**（**CRTP**）'
- en: Mixins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合
- en: Type erasure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型擦除
- en: Tag dispatching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签分派
- en: Expression templates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式模板
- en: Typelists
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型列表
- en: By the end of the chapter, you will have a good understanding of various multiprogramming
    techniques that will help you solve a variety of problems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将很好地理解各种多编程技术，这将帮助您解决各种问题。
- en: 'Let’s start the chapter by discussing the two forms of polymorphism: dynamic
    and static.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以讨论两种多态形式：动态和静态，开始本章。
- en: Dynamic versus static polymorphism
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态多态与静态多态
- en: When you learn about object-oriented programming, you learn about its fundamental
    principles, which are **abstraction**, **encapsulation**, **inheritance**, and
    **polymorphism**. C++ is a multi-paradigm programming language that supports object-oriented
    programming too. Although a broader discussion on the principles of object-oriented
    programming is beyond the scope of this chapter and this book, it is worth discussing
    at least some aspects related to polymorphism.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当您学习面向对象编程时，您会了解其基本原理，即**抽象**、**封装**、**继承**和**多态**。C++ 是一种支持面向对象编程的多范式编程语言。尽管关于面向对象编程原理的更广泛讨论超出了本章和本书的范围，但至少讨论与多态相关的一些方面是值得的。
- en: 'So, what is polymorphism? The term is derived from the Greek words for “*many
    forms*”. In programming, it’s the ability of objects of different types to be
    treated as if they were of the same type. The C++ standard actually defines a
    polymorphic class as follows (see C++20 standard, paragraph *11.7.2*, *Virtual
    functions*):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是多态？这个术语来源于希腊语中的“*多种形式*”。在编程中，它是不同类型的对象被当作同一类型对象处理的能力。C++ 标准实际上将多态类定义为如下（见
    C++20 标准，段落 *11.7.2*，*虚函数*）：
- en: A class that declares or inherits a virtual function is called a polymorphic
    class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 声明或继承虚函数的类称为多态类。
- en: 'It also defines polymorphic objects based on this definition, as follows (see
    C++20 standard, paragraph *6.7.2*, *Object model*):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它还根据此定义定义了多态对象，如下所示（见 C++20 标准，段落 *6.7.2*，*对象模型*）：
- en: Some objects are polymorphic (11.7.2); the implementation generates information
    associated with each such object that makes it possible to determine that object’s
    type during program execution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一些对象是多态的（11.7.2）；其实施生成与每个此类对象关联的信息，使得在程序执行期间可以确定该对象类型。
- en: 'However, this actually refers to what is called **dynamic polymorphism** (or
    late binding), but there is yet another form of polymorphism, called **static
    polymorphism** (or early binding). Dynamic polymorphism occurs at runtime with
    the help of interfaces and virtual functions, while static polymorphism occurs
    at compile-time with the help of overloaded functions and templates. This is described
    in Bjarne Stroustrup’s glossary of terms for the C++ language (see [https://www.stroustrup.com/glossary.html](https://www.stroustrup.com/glossary.html)):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这实际上指的是所谓的**动态多态**（或后期绑定），但还有一种称为**静态多态**（或早期绑定）的多态形式。动态多态在运行时通过接口和虚函数发生，而静态多态在编译时通过重载函数和模板发生。这已在
    Bjarne Stroustrup 为 C++ 语言提供的术语表中描述（见 [https://www.stroustrup.com/glossary.html](https://www.stroustrup.com/glossary.html)）：
- en: polymorphism - providing a single interface to entities of different types.
    virtual functions provide dynamic (run-time) polymorphism through an interface
    provided by a base class. Overloaded functions and templates provide static (compile-time)
    polymorphism.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 多态 - 为不同类型的实体提供一个单一接口。虚函数通过基类提供的接口提供动态（运行时）多态。重载函数和模板提供静态（编译时）多态。
- en: 'Let’s look at an example of dynamic polymorphism. The following is a hierarchy
    of classes representing different units in a game. These units may attack others,
    so there is a base class with a pure virtual function called `attack`, and several
    derived classes implementing specific units that override this virtual function
    doing different things (of course, for simplicity, here we just print a message
    to the console). It looks as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看动态多态的一个例子。以下是一个表示游戏中不同单位的类的层次结构。这些单位可以攻击其他单位，因此有一个基类，它有一个名为`attack`的纯虚函数，并且有几个派生类实现了特定的单位，这些单位覆盖了这个虚函数并执行不同的操作（当然，为了简单起见，这里我们只是打印一条消息到控制台）。它看起来如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Based on this hierarchy of classes (which according to the standard are called
    `fight` shown as follows. This takes a sequence of pointers to objects of the
    base `game_unit` type and calls the `attack` member function. Here is its implementation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个类的层次结构（根据标准，这些类被称为`fight`，如下所示。它接受一个指向基类`game_unit`类型对象的指针序列，并调用`attack`成员函数。以下是它的实现：
- en: '[PRE14]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This function does not need to know the actual type of each object because
    due to dynamic polymorphism, it can handle them as if they were of the same (base)
    type. Here is an example of using it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不需要知道每个对象的实际类型，因为由于动态多态，它可以像它们具有相同的（基）类型一样处理它们。以下是一个使用它的例子：
- en: '[PRE21]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But now let’s say you could combine a mage and a knight and create a new unit,
    a knight mage with special abilities from both these units. C++ enables us to
    write code as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在假设你可以将一个法师和一个骑士组合起来，创建一个新的单位，一个具有这两个单位特殊能力的骑士法师。C++使我们能够编写如下代码：
- en: '[PRE24]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This does not come out of the box, but the language supports overloading operators,
    and we could do that for any user-defined types. To make the preceding line possible,
    we need the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是现成的，但语言支持运算符重载，我们可以为任何用户定义的类型做这件事。为了使前面的行成为可能，我们需要以下内容：
- en: '[PRE26]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Keep in mind these are just some simple snippets without any complex code. But
    the ability to add a `knight` and a `mage` together to create a `knight_mage`
    is nothing short of the ability to add two integers together, or a `double` and
    an `int`, or two `std::string` objects. This happens because there are many overloads
    of the `+` operator (both for built-in types and user-defined types) and based
    on the operands, the compiler is selecting the appropriate overload. Therefore,
    it can be said there are many forms of this operator. This is true for all the
    operators that can be overloaded; the `+` operator is just a typical example since
    it is ubiquitous. And this is the compile-time version of polymorphism, called
    **static polymorphism**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些只是一些简单的代码片段，没有任何复杂的代码。但是，将一个`knight`和一个`mage`相加以创建一个`knight_mage`的能力，与将两个整数相加的能力，或者一个`double`和一个`int`相加的能力，或者两个`std::string`对象相加的能力不相上下。这是因为有多个`+`运算符的重载（既适用于内置类型也适用于用户定义的类型），并且根据操作数，编译器会选择适当的重载。因此，可以说有这种运算符的许多形式。这对于所有可以重载的运算符都适用；`+`运算符只是一个典型的例子，因为它无处不在。这就是编译时多态，称为**静态多态**。
- en: 'Operators are not the only functions that can be overloaded. Any function can
    be overloaded. Although we have seen many examples in the book, let’s take another
    one:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符不是唯一可以重载的函数。任何函数都可以重载。尽管我们在书中看到了许多例子，但让我们再看一个：
- en: '[PRE35]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this snippet, the `increment` function is overloaded for both the `attack`
    and `defense` types, allowing us to write code as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，`increment`函数为`attack`和`defense`类型重载，允许我们编写如下代码：
- en: '[PRE39]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can replace the two overloads of `increment` with a function template. The
    changes are minimal, as shown in the next snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个函数模板替换`increment`的两个重载。变化很小，如下面的代码片段所示：
- en: '[PRE43]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The previous code continues to work, but there is a significant difference:
    in the former example, we had two overloads, one for `attack` and one for `defense`,
    so you could call the function with objects of these types but nothing else. In
    the latter, we have a template that defines a family of overloaded functions for
    any possible type `T` that has a data member called `value` whose type supports
    the post-increment operator. We can define constraints for such a function template,
    which is something we have seen in the previous two chapters of the book. However,
    the key takeaway is that overloaded functions and templates are the mechanisms
    to implement static polymorphism in the C++ language.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码仍然可以工作，但有一个显著的区别：在前面的例子中，我们有两个重载，一个用于`attack`，一个用于`defense`，因此你可以用这些类型的对象调用函数，但不能用其他类型的对象。在后面，我们有一个模板，为任何可能的类型`T`定义了一组重载函数，这些类型具有名为`value`的数据成员，其类型支持后增量运算符。我们可以为这样的函数模板定义约束，这在本书的前两章中我们已经看到。然而，关键要点是重载函数和模板是实现C++语言中静态多态的机制。
- en: Dynamic polymorphism incurs a performance cost because in order to know what
    functions to call, the compiler needs to build a table of pointers to virtual
    functions (and also a table of pointers to virtual base classes in case of virtual
    inheritance). So, there is some level of indirection when calling virtual functions
    polymorphically. Moreover, the details of virtual functions are not made available
    to the compiler who cannot optimize them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 动态多态会带来性能开销，因为为了知道要调用哪些函数，编译器需要构建一个指向虚函数的指针表（以及在虚继承的情况下，还需要一个指向虚基类的指针表）。因此，在以多态方式调用虚函数时，存在一定程度的间接性。此外，虚函数的细节并未提供给编译器，编译器无法对其进行优化。
- en: 'When these things can be validated as performance issues, we could raise the
    question: can we get the benefits of dynamic polymorphism at compile time? The
    answer is yes and there is one way to achieve this: the Curiously Recurring Template
    Pattern, which we will discuss next.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些事情可以验证为性能问题时，我们可以提出这样的问题：我们能否在编译时获得动态多态的好处？答案是肯定的，有一种方法可以实现这一点：奇特重复模板模式，我们将在下一节讨论。
- en: The Curiously Recurring Template Pattern
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奇特重复模板模式
- en: 'This pattern has a rather curious name: the **Curiously Recurring Template
    Pattern**, or **CRTP** for short. It’s called curious because it is rather odd
    and unintuitive. The pattern was first described (and its name coined) by James
    Coplien in a column in the *C++ Report* in 1995\. This pattern is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式有一个相当奇特的名字：**奇特重复模板模式**，简称**CRTP**。它被称为奇特，因为它相当奇怪且不直观。这个模式最初由James Coplien在1995年的《C++
    Report》杂志专栏中描述（并为其命名）。这个模式如下：
- en: There is a base class template that defines the (static) interface.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个定义（静态）接口的基类模板。
- en: Derived classes are themselves the template argument for the base class template.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生类本身是基类模板的模板参数。
- en: The member functions of the base class call member functions of its type template
    parameter (which are the derived classes).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类中的成员函数调用其类型模板参数（即派生类）的成员函数。
- en: 'Let’s see how the pattern implementation looks in practice. We will transform
    the previous example with game units into a version using the CRTP. The pattern
    implementation goes as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个模式在实际中的实现看起来是什么样子。我们将把之前的游戏单位示例转换为使用CRTP的版本。模式实现如下：
- en: '[PRE45]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `game_unit` class is now a template class but contains the same member function,
    `attack`. Internally, this performs an upcast of the `this` pointer to `T*` and
    then invokes a member function called `do_attack`. The `knight` and `mage` classes
    derive from the `game_unit` class and pass themselves as the argument for the
    type template parameter `T`. Both provide a member function called `do_attack`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`game_unit`类现在是一个模板类，但包含相同的成员函数`attack`。内部，这会将`this`指针向上转换为`T*`，然后调用名为`do_attack`的成员函数。`knight`和`mage`类从`game_unit`类派生，并将自身作为类型模板参数`T`的参数传递。两者都提供了一个名为`do_attack`的成员函数。'
- en: Notice that the member function in the base class template and the called member
    function in the derived classes have different names. Otherwise, if they had the
    same name, the derived class member functions would hide the member from the base
    since these are no longer virtual functions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到基类模板中的成员函数和派生类中调用的成员函数具有不同的名称。否则，如果它们具有相同的名称，派生类的成员函数将隐藏基类中的成员，因为这些不再是虚函数。
- en: 'The `fight` function that takes a collection of game units and calls the `attack`
    function needs to change too. It needs to be implemented as a function template,
    as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更改的 `fight` 函数是接受游戏单位集合并调用 `attack` 函数的函数。它需要实现为一个函数模板，如下所示：
- en: '[PRE63]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Using this function is a little different than before. It goes as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数与之前略有不同。它如下所示：
- en: '[PRE71]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We have moved the runtime polymorphism to compile-time. Therefore, the `fight`
    function cannot treat `knight` and `mage` objects polymorphically. Instead, we
    get two different overloads, one that can handle `knight` objects and one that
    can handle `mage` objects. This is static polymorphism.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将运行时多态移至编译时。因此，`fight` 函数不能以多态方式处理 `knight` 和 `mage` 对象。相反，我们得到两个不同的重载，一个可以处理
    `knight` 对象，另一个可以处理 `mage` 对象。这是静态多态。
- en: 'Although the pattern might not look complicated after all, the question you’re
    probably asking yourself at this point is: how is this pattern actually useful?
    There are different problems you can solve using CRT, including the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个模式最终可能看起来并不复杂，但你现在可能正在问自己一个问题：这个模式实际上有什么用？你可以使用CRT解决不同的问题，包括以下这些：
- en: Limiting the number of times a type can be instantiated
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制类型实例化的次数
- en: Adding common functionality and avoiding code duplication
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加通用功能并避免代码重复
- en: Implementing the composite design pattern
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现组合设计模式
- en: In the following subsections, we will look at each of these problems and see
    how to solve them with CRTP.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将查看这些问题中的每一个，并看看如何使用CRTP来解决它们。
- en: Limiting the object count with CRTP
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CRTP限制对象计数
- en: Let’s assume that for the game in which we created knights and mages we need
    some items to be available in a limited number of instances. For instance, there
    is a special sword type called *Excalibur* and there should be only one instance
    of it. On the other hand, there is a book of magic spells but there cannot be
    more than three instances of it at a time in the game. How do we solve this? Obviously,
    the sword problem could be solved with the singleton pattern. But what do we do
    when we need to limit the number to some higher value but still finite? The singleton
    pattern wouldn’t be of much help (unless we transform it into a “*multiton*”)
    but the CRTP would.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们为创建骑士和法师的游戏需要一些物品以有限的数量实例可用。例如，有一种特殊的剑类型叫做 *Excalibur*，应该只有一个实例。另一方面，有一个魔法咒语的书，但游戏一次不能有超过三个实例。我们如何解决这个问题？显然，剑的问题可以用单例模式解决。但当我们需要限制数量到一个更高的但仍然有限的值时，单例模式就帮不上什么忙（除非我们将其转换为“*multiton*”），但CRTP可以。
- en: 'First, we start with a base class template. The only thing this class template
    does is keep a count of how many times it has been instantiated. The counter,
    which is a static data member, is incremented in the constructor and decremented
    in the destructor. When that count exceeds a defined limit, an exception is thrown.
    Here is the implementation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从一个基类模板开始。这个类模板唯一做的事情是记录它被实例化的次数。计数器，这是一个静态数据成员，在构造函数中增加，在析构函数中减少。当这个计数超过一个定义的限制时，会抛出一个异常。以下是实现：
- en: '[PRE75]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The second part of the template consists of defining the derived classes. For
    the mentioned problem, they are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的第二部分是定义派生类。对于提到的问题，它们如下所示：
- en: '[PRE89]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can instantiate `excalibur` once. The second time we try to do the same
    (while the first instance is still alive) an exception will be thrown:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实例化 `excalibur` 一次。当我们第二次尝试这样做（而第一个实例仍然存活）时，将会抛出一个异常：
- en: '[PRE93]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Similarly, we can instantiate `book_of_magic` three times and an exception
    will be thrown the fourth time we attempt to do that:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以实例化 `book_of_magic` 三次，当我们第四次尝试这样做时，将会抛出一个异常：
- en: '[PRE102]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Next, we look at a more common scenario, adding common functionality to types.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看一个更常见的场景，向类型添加通用功能。
- en: Adding functionality with CRTP
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CRTP添加功能
- en: Another case when the curiously recurring template pattern can help us is providing
    common functionalities to derived classes through generic functions in a base
    class that relies solely on derived class members. Let’s take an example to understand
    this use case.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当好奇地重复模板模式可以帮助我们的时候，另一个案例是通过基类中的泛型函数提供通用功能给派生类，该基类仅依赖于派生类成员。让我们通过一个例子来理解这个用例。
- en: 'Let’s suppose that some of our game units have member functions such as `step_forth`
    and `step_back` that move them one position, forward or backward. These classes
    would look as follows (at a bare minimum):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的一些游戏单位具有`step_forth`和`step_back`这样的成员函数，这些函数可以将它们移动一个位置，向前或向后。这些类将如下所示（至少是基础形式）：
- en: '[PRE113]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'However, it could be a requirement that everything that can move back and forth
    one step should also be able to advance or retreat an arbitrary number of steps.
    However, this functionality could be implemented based on the `step_forth` and
    `step_back` functions, which would help avoid having duplicate code in each of
    these game unit classes. The CRTP implementation for this problem would, therefore,
    look as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能有一个要求，即所有可以前后移动一步的东西也应该能够前进或后退任意数量的步骤。然而，这个功能可以根据`step_forth`和`step_back`函数实现，这有助于避免在每个游戏单元类中都有重复的代码。因此，这个问题的CRTP实现将如下所示：
- en: '[PRE123]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'We can advance and retreat the units by calling the base class `advance` and
    `retreat` member functions as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用基类的`advance`和`retreat`成员函数来前进和后退单位，如下所示：
- en: '[PRE151]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'You could argue that the same result could be achieved using non-member function
    templates. For the sake of discussion, such a solution is presented as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会争辩说，使用非成员函数模板也可以达到相同的结果。为了讨论的目的，这样的解决方案如下所示：
- en: '[PRE157]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The client code would need to change but the changes are actually small:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码需要更改，但更改实际上很小：
- en: '[PRE181]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: The choice between these two may depend on the nature of the problem and your
    preferences. However, the CRTP has the advantage that it is describing well the
    interface of the derived classes (such as `knight` and `mage` in our example).
    With the non-member functions, you wouldn’t necessarily know about this functionality,
    which would probably come from a header that you need to include. However, with
    CRTP, the class interface is well visible to those using it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选择可能取决于问题的性质和你的偏好。然而，CRTP的优势在于它很好地描述了派生类的接口（例如，我们例子中的`knight`和`mage`）。使用非成员函数，你不必知道这种功能，这可能会来自你需要包含的头文件。然而，使用CRTP，类的接口对使用者来说非常清晰。
- en: For the last scenario we discuss here, let’s see how CRTP helps to implement
    the composite design pattern.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在这里讨论的最后一种场景，让我们看看CRTP如何帮助实现组合设计模式。
- en: Implementing the composite design pattern
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现组合设计模式
- en: 'In their famous book, *Design Patterns: Elements of Reusable Object-Oriented
    Software*, the Gang of Four (Erich Gamma, Richard Helm, Ralph Johnson, and John
    Vlissides) describe a structural pattern called composite that enables us to compose
    objects into larger structures and treat both individual objects and compositions
    uniformly. This pattern can be used when you want to represent part-whole hierarchies
    of objects and you want to ignore the differences between individual objects and
    compositions of individual objects.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们著名的书籍《设计模式：可复用面向对象软件元素》中，四人帮（Erich Gamma、Richard Helm、Ralph Johnson和John
    Vlissides）描述了一种结构模式，称为组合（composite），它使我们能够将对象组合成更大的结构，并统一处理单个对象和组合。当你想要表示对象的分-整体层次结构，并且你想要忽略单个对象和单个对象的组合之间的差异时，可以使用此模式。
- en: 'To put this pattern into practice, let’s consider the game scenario again.
    We have heroes that have special abilities and can do different actions, one of
    which is allying with another hero. That can be easily modeled as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这种模式付诸实践，让我们再次考虑游戏场景。我们有一些具有特殊能力并能执行不同动作的英雄，其中之一是与另一个英雄结盟。这可以很容易地建模如下：
- en: '[PRE187]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'These heroes are represented by the `hero` class that contains a name, a list
    of connections to other `hero` objects, as well as a member function, `ally_with`,
    that defines an alliance between two heroes. We can use it as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这些英雄由包含名称、指向其他`hero`对象的连接列表以及定义两个英雄之间联盟的成员函数`ally_with`的`hero`类表示。我们可以如下使用它：
- en: '[PRE208]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'The output of running this snippet is the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码片段的输出如下：
- en: '[PRE216]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Everything was simple so far. But the requirement is that heroes could be grouped
    together to form parties. It should be possible for a hero to ally with a group,
    and for a group to ally with either a hero or an entire group. Suddenly, there
    is an explosion of functions that we need to provide:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很简单。但要求是英雄可以被分组形成团体。应该允许一个英雄与一个团体结盟，以及一个团体可以与一个英雄或整个团体结盟。突然之间，我们需要提供的功能函数爆炸式增长：
- en: '[PRE217]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'This is where the composite design pattern helps us treat heroes and parties
    uniformly and avoid unnecessary duplications of the code. As usual, there are
    different ways to implement it, but one way is using the curiously recurring template
    pattern. The implementation requires a base class that defines the common interface.
    In our case, this will be a class template with a single member function called
    `ally_with`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是组合设计模式如何帮助我们统一处理英雄和党派，并避免不必要的代码重复。通常，有几种不同的实现方式，但其中一种方式是使用好奇重复模板模式。实现需要定义公共接口的基类。在我们的情况下，这将是一个只有一个名为
    `ally_with` 的成员函数的类模板：
- en: '[PRE228]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'We will define the `hero` class as a derived class from `base_unit<hero>`.
    This time, the `hero` class no longer implements `ally_with` itself. However,
    it features `begin` and `end` methods that are intended to simulate the behavior
    of a container:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义 `hero` 类为从 `base_unit<hero>` 派生的派生类。这次，`hero` 类不再自己实现 `ally_with`。然而，它具有
    `begin` 和 `end` 方法，旨在模拟容器的行为：
- en: '[PRE234]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'The class that models a group of heroes is called `hero_party` and derives
    from both `std::vector<hero>` (to define a container of `hero` objects) and from
    `base_unit<hero_party>`. This is why the `hero` class has `begin` and `end` functions
    to help us perform iterating operations on `hero` objects, just as we would do
    with `hero_party` objects:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟一组英雄的类称为 `hero_party`，它从 `std::vector<hero>`（用于定义 `hero` 对象的容器）和 `base_unit<hero_party>`
    中继承。这就是为什么 `hero` 类有 `begin` 和 `end` 函数，帮助我们执行对 `hero` 对象的迭代操作，就像我们对 `hero_party`
    对象所做的那样：
- en: '[PRE248]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'We need to implement the `ally_with` member function of the base class. The
    code is shown as follows. What it does is iterate through all the sub-objects
    of the current object and connect them with all the sub-objects of the supplied
    argument:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现基类的 `ally_with` 成员函数。代码如下所示。它的作用是遍历当前对象的所有子对象，并将它们与提供的参数的所有子对象连接起来：
- en: '[PRE251]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'The `hero` class declared the `base_unit` class template a friend so that it
    could access the `connections` member. It also declared the `operator<<` as a
    friend so that this function could access both the `connections` and `name` private
    members. For more information about templates and friends, see [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064),
    *Advanced Template Concepts*. The output stream operator implementation is shown
    here:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`hero` 类将 `base_unit` 类模板声明为友元，以便它可以访问 `connections` 成员。它还将 `operator<<` 声明为友元，以便这个函数可以访问
    `connections` 和 `name` 私有成员。有关模板和友元的更多信息，请参阅[*第4章*](B18367_04_ePub.xhtml#_idTextAnchor064)，*高级模板概念*。输出流操作符的实现如下所示：'
- en: '[PRE264]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'Having all this defined, we can write code as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了所有这些之后，我们可以编写如下代码：
- en: '[PRE276]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: 'We can see from this that we are able to ally a `hero` with both another `hero`
    and a `hero_party`, as well as a `hero_party` with either a `hero` or another
    `hero_party`. That was the proposed goal, and we were able to do it without duplicating
    the code between `hero` and `hero_party`. The output of executing the previous
    snippet is the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里我们可以看到，我们能够将 `hero` 与另一个 `hero` 或 `hero_party` 结盟，以及将 `hero_party` 与 `hero`
    或另一个 `hero_party` 结盟。这正是我们提出的目标，我们能够在 `hero` 和 `hero_party` 之间不重复代码的情况下实现它。执行前面的代码片段的输出如下：
- en: '[PRE291]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: After seeing how the CRTP helps achieve different goals, let’s look at the use
    of the CRTP in the C++ standard library.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到CRTP如何帮助实现不同的目标之后，让我们看看C++标准库中CRTP的使用。
- en: The CRTP in the standard library
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库中的CRTP
- en: The standard library contains a helper type called `std::enabled_shared_from_this`
    (in the `<memory>` header) that enables objects managed by a `std::shared_ptr`
    to generate more `std::shared_ptr` instances in a safe manner. The `std::enabled_shared_from_this`
    class is the base class in the CRTP pattern. However, the previous description
    may sound abstract, so let’s try to understand it with examples.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库包含一个名为 `std::enabled_shared_from_this` 的辅助类型（在 `<memory>` 头文件中），它允许由 `std::shared_ptr`
    管理的对象以安全的方式生成更多的 `std::shared_ptr` 实例。`std::enabled_shared_from_this` 类是CRTP模式中的基类。然而，前面的描述可能听起来很抽象，所以让我们通过示例来尝试理解它。
- en: 'Let’s suppose we have a class called `building` and we are creating `std::shared_ptr`
    objects in the following manner:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `building` 的类，并且我们正在以下方式创建 `std::shared_ptr` 对象：
- en: '[PRE292]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: We have a raw pointer and, on line `[1]`, we instantiate a `std::shared_ptr`
    object to manage its lifetime. However, on line `[2]`, we instantiate a second
    `std::shared_ptr` object for the same pointer. Unfortunately, the two smart pointers
    know nothing of each other, so upon getting out of scope, they will both delete
    the `building` object allocated on the heap. Deleting an object that was already
    deleted is undefined behavior and will likely result in a crash of the program.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个原始指针，在行`[1]`中，我们实例化了一个`std::shared_ptr`对象来管理其生命周期。然而，在行`[2]`中，我们为同一个指针实例化了一个第二个`std::shared_ptr`对象。不幸的是，这两个智能指针彼此之间一无所知，因此当它们超出作用域时，它们都会删除在堆上分配的`building`对象。删除已经删除的对象是未定义的行为，很可能会导致程序崩溃。
- en: 'The `std::enable_shared_from_this` class helps us create more `shared_ptr`
    objects from an existing one in a safe manner. First, we need to implement the
    CRTP pattern as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::enable_shared_from_this`类帮助我们以安全的方式从一个现有的对象创建更多的`shared_ptr`对象。首先，我们需要实现CRTP模式，如下所示：'
- en: '[PRE296]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'Having this new implementation, we can call the member function `shared_from_this`
    to create more `std::shared_ptr` instances from an object, which all refer to
    the same instance of the object:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个新的实现之后，我们可以调用成员函数`shared_from_this`从一个对象创建更多的`std::shared_ptr`实例，它们都指向同一个对象实例：
- en: '[PRE299]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'The interface of the `std::enable_shared_from_this` is as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::enable_shared_from_this`的接口如下：'
- en: '[PRE303]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: The previous example shows how `enable_shared_from_this` works but does not
    help understand when it is appropriate to use it. Therefore, let’s modify the
    example to show a realistic example.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子展示了`enable_shared_from_this`是如何工作的，但它并没有帮助理解何时应该使用它。因此，让我们修改例子以展示一个现实世界的例子。
- en: 'Let’s consider that the buildings we have can be upgraded. This is a process
    that takes some time and involves several steps. This task, as well as other tasks
    in the game, are executed by a designated entity, which we will call `executor`.
    In its simplest form, this `executor` class has a public member function called
    `execute` that takes a function object and executes it on a different thread.
    The following listing is a simple implementation:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我们拥有的建筑可以进行升级。这是一个需要一些时间并涉及多个步骤的过程。这个任务以及游戏中的其他任务都是由一个指定的实体执行的，我们将称之为`executor`。在其最简单的形式中，这个`executor`类有一个名为`execute`的公共成员函数，它接受一个函数对象并在不同的线程上执行它。以下是一个简单的实现：
- en: '[PRE314]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'The `building` class has a pointer to an `executor`, which is passed from the
    client. It also has a member function called `upgrade` that kicks off the execution
    process. However, the actual upgrade occurs in a different, private, function
    called `do_upgrade`. This is called from a lambda expression that is passed to
    the `execute` member function of the `executor`. All these are shown in the following
    listing:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`building`类有一个指向`executor`的指针，它由客户端传递。它还有一个名为`upgrade`的成员函数，它启动执行过程。然而，实际的升级发生在另一个不同的、私有的、名为`do_upgrade`的函数中。这是从传递给`executor`的`execute`成员函数的lambda表达式调用的。所有这些都在以下列表中展示：'
- en: '[PRE332]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: 'The client code is relatively simple: create an `executor`, create a building
    managed by a `shared_ptr`, set the `executor` reference, and run the upgrade process:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码相对简单：创建一个`executor`，创建一个由`shared_ptr`管理的建筑，设置`executor`引用，并运行升级过程：
- en: '[PRE359]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: 'If you run this program, you get the following output:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，你会得到以下输出：
- en: '[PRE368]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: What we can see here is that the building is destroyed before the upgrade process
    begins. This incurs undefined behavior and, although this program didn’t crash,
    a real-world program would certainly crash.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到的是，在升级过程开始之前，建筑就被销毁了。这会导致未定义的行为，尽管这个程序没有崩溃，但在现实世界的程序中肯定会崩溃。
- en: 'The culprit for this behavior is this particular line in the upgrading code:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的罪魁祸首是这个升级代码中的特定一行：
- en: '[PRE369]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: 'We are creating a lambda expression that captures the `this` pointer. The pointer
    is later used after the object it points to has been destroyed. To avoid this,
    we would need to create and capture a `shared_ptr` object. The safe way to do
    that is with the help of the `std::enable_shared_from_this` class. There are two
    changes that need to be done. The first is to actually derive the `building` class
    from the `std::enable_shared_from_this` class:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个捕获`this`指针的lambda表达式。该指针在它指向的对象被销毁后被使用。为了避免这种情况，我们需要创建并捕获一个`shared_ptr`对象。通过`std::enable_shared_from_this`类来做到这一点是安全的。需要进行两个更改。第一个是将`building`类实际派生自`std::enable_shared_from_this`类：
- en: '[PRE372]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: 'The second change requires us to call `shared_from_this` in the lambda capture:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变化要求我们在lambda捕获中调用`shared_from_this`：
- en: '[PRE376]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: 'These are two slight changes to our code but the effect is significant. The
    building object is no longer destroyed before the lambda expression gets executed
    on a separate thread (because there is now an extra shared pointer that refers
    to the same object as the shared pointer created in the main function). As a result,
    we get the output we expected (without any changes to the client code):'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们代码中微小的两个变化，但效果是显著的。构建对象不再在lambda表达式在单独的线程上执行之前被销毁（因为现在有一个额外的共享指针指向与主函数中创建的共享指针相同的对象）。因此，我们得到了预期的输出（无需对客户端代码进行任何更改）：
- en: '[PRE379]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: You could argue that after the main `function` finishes, we shouldn’t care what
    happens. Mind that this is just a demo program, and in practice, this happens
    in some other function and the program continues to run long after that function
    returns.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会争辩说，在主`function`完成后，我们不应该关心会发生什么。请注意，这只是一个演示程序，在实际应用中，这种情况发生在某个其他函数中，并且程序在函数返回后继续运行很长时间。
- en: With this, we conclude the discussion around the curiously recurring template
    pattern. Next, we will look at a technique called **mixins** that is often mixed
    with the CRTP pattern.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们结束了关于奇特重复模板模式（curiously recurring template pattern）的讨论。接下来，我们将探讨一种称为**混合（mixins**）的技术，它通常与CRTP模式结合使用。
- en: Mixins
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混入（Mixins）
- en: Mixins are small classes that are designed to add functionality to other classes.
    If you read about mixins, you will often find that the curiously recurring template
    pattern is used to implement mixins in C++. This is an incorrect statement. The
    CRTP helps achieve a similar goal to mixins, but they are different techniques.
    The point of mixins is that they are supposed to add functionality to classes
    without being a base class to them, which is the key to the CRTP pattern. Instead,
    mixins are supposed to inherit from the classes they add functionality to, which
    is the CRTP upside down.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 混入是设计用来向其他类添加功能的小类。如果你阅读有关混合的内容，你经常会发现奇特重复模板模式（CRTP）被用来在C++中实现混合。这是一个错误的说法。CRTP有助于实现与混合类似的目标，但它们是不同的技术。混合的关键点在于它们应该向类添加功能，而不成为它们的基类，这是CRTP模式的关键。相反，混合应该从它们添加功能的类中继承，这是CRTP模式颠倒过来的。
- en: 'Remember the earlier example with knights and mages that could move forth and
    back with the `step_forth` and `step_back` member functions? The `knight` and
    `mage` classes were derived from the `movable_unit` class template that added
    the functions `advance` and `retreat`, which enabled units to move several steps
    forth or back. The same example can be implemented using mixins in a reverse order.
    Here is how:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 记得之前关于骑士和法师的例子，它们可以用`step_forth`和`step_back`成员函数前后移动？`knight`和`mage`类是从添加了`advance`和`retreat`函数的`movable_unit`类模板派生出来的，这些函数使得单位可以向前或向后移动几步。同样的例子可以使用混合以相反的顺序实现。下面是如何做的：
- en: '[PRE380]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: 'You will notice that `knight` and `mage` are now classes that don’t have any
    base class. They both provide the `step_forth` and `step_back` member functions
    just as they did before, when we implemented the CRTP pattern. Now, the `movable_unit`
    class template is derived from one of these classes and defines the `advance`
    and `retreat` functions, which call `step_forth` and `step_back` in a loop. We
    can use them as follows:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，`knight`和`mage`现在是没有基类的类。它们都提供了`step_forth`和`step_back`成员函数，就像我们在实现CRTP模式时做的那样。现在，`movable_unit`类模板从这些类之一派生出来，并定义了`advance`和`retreat`函数，这些函数在循环中调用`step_forth`和`step_back`。我们可以这样使用它们：
- en: '[PRE416]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: 'This is very similar to what we had with the CRTP pattern, except that now
    we create instances of `movable_unit<knight>` and `movable_unit<mage>` instead
    of `knight` and `mage`. A comparison of the two patterns is shown in the following
    diagram (with CRTP on the left and mixins on the right):'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 这与CRTP模式非常相似，只是现在我们创建`movable_unit<knight>`和`movable_unit<mage>`的实例，而不是`knight`和`mage`。以下图表显示了两种模式的比较（CRTP位于左侧，混合位于右侧）：
- en: '![Figure 7.1: Comparison of the CRTP and the mixins patterns'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1：CRTP和混合模式的比较]'
- en: '](img/Figure_7.1_B18367.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1：CRTP和混合模式的比较](img/Figure_7.1_B18367.jpg)'
- en: 'Figure 7.1: Comparison of the CRTP and the mixins patterns'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：CRTP和混合模式的比较
- en: We can combine the static polymorphism achieved with mixins with dynamic polymorphism
    achieved with interfaces and virtual functions. We’ll demonstrate this with the
    help of an example concerning game units that fight. We had an earlier example
    when we discussed the CRTP, where the `knight` and `mage` classes had a member
    function called `attack`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将通过混入实现的静态多态与通过接口和虚函数实现的动态多态结合起来。我们将通过一个关于战斗游戏单位的例子来演示这一点，当我们讨论CRTP时，我们已经有一个早期的例子，其中“骑士”和“法师”类有一个名为`attack`的成员函数。
- en: 'Let’s say we want to define multiple attacking styles. For instance, each game
    unit can use either an aggressive or a moderate attacking style. So that means
    four combinations: aggressive and moderate knights, and aggressive and moderate
    mages. On the other hand, both knights and mages could be lone warriors that are
    comfortable to fight alone, or are team players that always fight in a group with
    other units.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要定义多种攻击风格。例如，每个游戏单位可以使用激进的或温和的攻击风格。这意味着有四种组合：激进的骑士和温和的骑士，以及激进的法师和温和的法师。另一方面，骑士和法师都可以是独自战斗的战士，他们习惯于单独作战，或者他们是团队玩家，总是与其他单位一起组成团队作战。
- en: That means we could have lone aggressive knights and lone moderate knights as
    well as team player aggressive knights and team player moderate knights. The same
    applies to mages. As you can see, the number of combinations grows a lot and mixins
    are a good way to provide this added functionality without expanding the `knight`
    and `mage` classes. Finally, we want to be able to treat all these polymorphically
    at runtime. Let’s see how we can do this.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以有单独的激进骑士和单独的温和骑士，以及团队玩家的激进骑士和团队玩家的温和骑士。对于法师也是如此。正如你所看到的，组合的数量增长了很多，混入是一个很好的方法，可以在不扩展“骑士”和“法师”类的情况下提供这种附加功能。最后，我们希望能够在运行时以多态的方式处理所有这些。让我们看看我们如何做到这一点。
- en: 'First, we can define aggressive and moderate fighting styles. These could be
    as simple as the following:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以定义激进的和温和的战斗风格。这些可能就像以下这样简单：
- en: '[PRE422]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: 'Next, we define mixins as the requirement of being able to fight alone or in
    a group. These classes are templates and are derived from their template argument:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义混入作为能够单独作战或团队作战的要求。这些类是模板，并从它们的模板参数派生：
- en: '[PRE436]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: 'Last, we need to define the `knight` and `mage` classes. These themselves will
    be mixins for the fighting styles. However, to be able to treat them polymorphically
    at runtime, we derive them from a base `game_unit` class that contains a pure
    virtual method called `attack` that these classes implement:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义“骑士”和“法师”类。这些类本身将是战斗风格的混入。然而，为了能够在运行时以多态的方式处理它们，我们从一个包含纯虚方法`attack`的基类`game_unit`派生它们，这些类实现了这个方法：
- en: '[PRE454]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: 'The `knight` and `mage` implementation of the `attack` member function makes
    use of the `T::fight` method. You have probably noticed that both the `aggresive_style`
    and `moderate_style` classes on one hand and the `lone_warrior` and `team_warrior`
    mixin classes on the other hand provide such a member function. This means we
    can do the following combinations:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: “骑士”和“法师”对`attack`成员函数的实现使用了`T::fight`方法。你可能已经注意到，一方面，`aggresive_style`和`moderate_style`类以及另一方面`lone_warrior`和`team_warrior`混入类都提供了这样的成员函数。这意味着我们可以做以下组合：
- en: '[PRE477]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: 'In total, there are 12 combinations that we defined here. And this was all
    possible with only six classes. This shows how mixins help us add functionality
    while keeping the complexity of the code at a reduced level. If we run the code,
    we get the following output:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有12种组合是我们在这里定义的。这所有的一切都只需要六个类。这显示了混入如何帮助我们添加功能，同时将代码的复杂性保持在较低水平。如果我们运行代码，我们会得到以下输出：
- en: '[PRE500]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: We have looked here at two patterns, CRTP and mixins, that are both intended
    to add additional (common) functionality to other classes. However, although they
    look similar, they have opposite structures and should not be confused with one
    another. An alternative technique to leverage common functionalities from unrelated
    types is called type erasure, which we will discuss next.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里探讨了两种模式，CRTP和混入，它们都旨在向其他类添加额外的（常见）功能。然而，尽管它们看起来相似，但它们的结构相反，不应该混淆。一种从无关类型中利用共同功能的技术称为类型擦除，我们将在下一节讨论。
- en: Type erasure
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型擦除
- en: The term `void` pointers (a legacy of the C language, which is to be avoided),
    but true type erasure is achieved with templates. Before we discuss this, let’s
    briefly look at the others.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“空指针”（这是C语言的遗留问题，应该避免），但真正的类型擦除是通过模板实现的。在我们讨论这个话题之前，让我们简要地看看其他的内容。
- en: The most rudimentary form of type erasure is the use of `void` pointers. This
    is typical of C and although possible in C++, it is in no way recommended. It
    is not type-safe and, therefore, error-prone. However, for the sake of the discussion,
    let’s have a look at such an approach.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的类型擦除形式是使用`void`指针。这在C语言中很典型，虽然在C++中也是可能的，但并不推荐使用。它不是类型安全的，因此容易出错。然而，为了讨论的目的，让我们看看这种方法的例子。
- en: 'Let’s say we again have `knight` and `mage` types and they both have an attack
    function (a behavior), and we want to treat them in a common way to exhibit this
    behavior. Let’s see the classes first:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们再次有`knight`和`mage`类型，它们两者都有一个攻击函数（一种行为），我们想要以相同的方式处理它们以展示这种行为。让我们先看看这些类：
- en: '[PRE501]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: 'In a C-like implementation, we could have a function for each of these types,
    taking a `void*` to an object of the type, casting it to the expected type of
    pointer, and then invoking the `attack` member function:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言风格的实现中，我们可以为这些类型中的每一个都定义一个函数，它接受一个指向该类型对象的`void*`，将其转换为期望的指针类型，然后调用`attack`成员函数：
- en: '[PRE509]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: 'These have a similar signature; the only thing that differs is the name. So,
    we can define a function pointer and then associate an object (or more precisely
    a pointer to an object) with a pointer to the right function handling it. Here
    is how:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有类似的签名；唯一不同的是名称。因此，我们可以定义一个函数指针，然后将一个对象（或者更精确地说，一个对象的指针）与处理它的函数的指针相关联。下面是如何做的：
- en: '[PRE517]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: 'There is no information about types in this last snippet. All that has been
    erased using `void` pointers. The `fight` function can be invoked as follows:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的片段中没有任何类型信息。所有这些信息都是通过`void`指针被擦除的。`fight`函数可以这样调用：
- en: '[PRE526]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '[PRE530]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: From a C++ perspective, this will probably look odd. It should. In this example,
    I have combined C techniques with C++ classes. Hopefully, we will not see snippets
    of code like this in production. Things will go wrong by a simple typing error
    if you pass a `mage` to the `fight_knight` function or the other way around. Nevertheless,
    it’s possible and is a form of type erasure.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 从C++的角度来看，这可能会看起来很奇怪。确实如此。在这个例子中，我将C技术结合到了C++类中。希望我们不会在生产代码中看到这样的代码片段。如果你将`mage`传递给`fight_knight`函数或相反，仅仅是一个简单的打字错误，事情就会出错。尽管如此，这是可能的，这也是一种类型擦除的形式。
- en: 'An obvious alternative solution in C++ is using polymorphism through inheritance.
    This is the very first solution we saw at the beginning of this chapter. For convenience,
    I’ll reproduce it here again:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，一个明显的替代方案是通过继承使用多态。这正是我们在本章开头看到的第一个解决方案。为了方便，我在这里再次呈现它：
- en: '[PRE533]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: '[PRE544]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: The `fight` function can handle `knight` and `mage` objects homogenously. It
    knows nothing of the actual objects whose addresses were passed to it (within
    a `vector`). However, it can be argued that types have not been completely erased.
    Both `knight` and `mage` are `game_unit` and the `fight` function handles anything
    that is a `game_unit`. For another type to be handled by this function, it needs
    to derive from the `game_unit` pure abstract class.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '`fight`函数可以统一处理`knight`和`mage`对象。它对传递给它的实际对象的地址一无所知（在`vector`中）。然而，可以争论说类型并没有被完全擦除。`knight`和`mage`都是`game_unit`，`fight`函数处理任何是`game_unit`的类型。要使另一个类型由这个函数处理，它需要从`game_unit`纯抽象类派生。'
- en: And sometimes that’s not possible. Perhaps we want to treat unrelated types
    in a similar matter (a process called **duck typing**) but we are not able to
    change those types. For instance, we do not own the source code. The solution
    to this problem is true type erasure with templates.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候这是不可能的。也许我们想要以类似的方式处理无关的类型（这个过程称为**鸭子类型**），但我们无法改变这些类型。例如，我们并不拥有源代码。这个问题的解决方案是使用模板进行真正的类型擦除。
- en: 'Before we get to see what this pattern looks like, let’s take it step by step
    to understand how the pattern developed, starting with the unrelated `knight`
    and `mage`, and the premise that we cannot modify them. However, we can write
    wrappers around them that would provide a uniform interface to the common functionality
    (behavior):'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到这个模式的样子之前，让我们一步一步地来理解这个模式是如何发展的，从无关的`knight`和`mage`开始，以及我们不能修改它们的假设。然而，我们可以围绕它们编写包装器，以提供对公共功能（行为）的统一接口：
- en: '[PRE552]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: '[PRE557]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '[PRE576]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: 'We do not need to call the `attack` member function in `game_unit` the same
    as it was in `knight` and `mage`. It can have any name. This choice was purely
    made on the grounds of mimicking the original behavior name. The `fight` function
    takes a collection of pointers to `game_unit`, therefore being able to handle
    both `knight` and `mage` objects homogenously, as shown next:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在`game_unit`中调用`attack`成员函数与`knight`和`mage`中的调用相同。它可以有任意名称。这种选择纯粹是基于模仿原始行为名称。`fight`函数接受指向`game_unit`的指针集合，因此能够统一处理`knight`和`mage`对象，如下所示：
- en: '[PRE584]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: '[PRE585]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: '[PRE589]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: 'The trouble with this solution is that there is a lot of duplicate code. The
    `knight_unit` and `mage_unit` classes are mostly the same. And when other classes
    need to be handled similarly, this duplication increases more. The solution to
    code duplication is using templates. We replace `knight_unit` and `mage_unit`
    with the following class template:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的问题是存在大量的重复代码。`knight_unit`和`mage_unit`类大部分相同。当其他类需要以类似方式处理时，这种重复会更多。解决代码重复的方法是使用模板。我们将`knight_unit`和`mage_unit`替换为以下类模板：
- en: '[PRE590]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: '[PRE594]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '[PRE597]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: 'There is only one copy of this class in our source code but the compiler will
    instantiate multiple specializations based on its usage. Any type information
    has been erased, with the exception of some type restrictions—the `T` type must
    have a member function called `attack` that takes no arguments. Notice that the
    `fight` function didn’t change at all. The client code needs to be slightly changed
    though:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的源代码中，这个类只有一个副本，但编译器会根据其使用情况实例化多个特殊化版本。任何类型信息都已删除，除了某些类型限制——`T`类型必须有一个不带参数的成员函数名为`attack`。请注意，`fight`函数没有任何变化。尽管如此，客户端代码需要稍作修改：
- en: '[PRE598]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '[PRE599]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: '[PRE600]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '[PRE601]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: '[PRE602]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: 'This leads us to the form of the type erasure pattern by putting the abstract
    base class and wrapper class template within another class:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致我们将抽象基类和包装类模板放入另一个类中，形成了类型擦除模式的形式：
- en: '[PRE604]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '[PRE605]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: '[PRE606]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '[PRE607]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '[PRE608]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: '[PRE609]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: '[PRE611]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '[PRE614]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '[PRE615]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: '[PRE616]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: '[PRE617]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '[PRE618]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '[PRE619]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: '[PRE620]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '[PRE622]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: '[PRE623]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: '[PRE624]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: '[PRE626]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '[PRE629]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: '[PRE630]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: '[PRE631]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: '[PRE632]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: 'The `game` class contains a collection of `game_unit` objects and has a method
    for adding new wrappers to any game unit (that has an `attack` member function).
    It also has a member function, `fight`, to invoke the common behavior. The client
    code is, this time, the following:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '`game`类包含一组`game_unit`对象，并有一个方法可以向任何具有`attack`成员函数的游戏单元添加新包装器。它还有一个成员函数`fight`，用于调用共同的行为。这次，客户端代码如下所示：'
- en: '[PRE633]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '[PRE635]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: '[PRE636]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: '[PRE637]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: '[PRE638]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: 'In the type erasure pattern, the abstract base class is called a **concept**
    and the wrapper that inherits from it is called a **model**. If we were to implement
    the type erasure pattern in the established formal manner it would look as follows:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型擦除模式中，抽象基类被称为**概念**，从它继承的包装器被称为**模型**。如果我们按照既定的正式方式实现类型擦除模式，它看起来如下所示：
- en: '[PRE639]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '[PRE640]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: '[PRE641]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: '[PRE642]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: '[PRE643]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '[PRE644]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: '[PRE645]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: '[PRE646]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: '[PRE647]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: '[PRE648]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: '[PRE649]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: '[PRE650]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: '[PRE651]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: '[PRE652]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '[PRE653]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: '[PRE654]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: '[PRE655]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: '[PRE656]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: '[PRE657]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: '[PRE658]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: '[PRE659]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: '[PRE660]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: '[PRE661]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: '[PRE662]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: '[PRE663]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: '[PRE664]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: '[PRE665]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: '[PRE666]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: '[PRE667]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: '[PRE668]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: '[PRE669]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: '[PRE670]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: In this snippet, `game_unit` was renamed as `unit_concept` and `game_unit_wrapper`
    was renamed as `unit_model`. There is no other change to them apart from the name.
    They are members of a new class called `unit` that stores a pointer to an object
    that implements `unit_concept`; that could be `unit_model<knight>` or `unit_model<mage>`.
    The `unit` class has a template constructor that enables us to create such model
    objects from `knight` and `mage` objects.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`game_unit`被重命名为`unit_concept`，`game_unit_wrapper`被重命名为`unit_model`。除了名称之外，它们没有其他变化。它们是新类`unit`的成员，该类存储指向实现`unit_concept`的对象的指针；这可以是`unit_model<knight>`或`unit_model<mage>`。`unit`类有一个模板构造函数，使我们能够从`knight`和`mage`对象创建这样的模型对象。
- en: 'It also has a public member function, `attack` (again, this can have any name).
    On the other hand, the `fight` function handles `unit` objects and invokes their
    `attack` member function. The client code may look as follows:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有一个公共成员函数，`attack`（再次，这可以有任何名称）。另一方面，`fight`函数处理`unit`对象并调用它们的`attack`成员函数。客户端代码可能如下所示：
- en: '[PRE671]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: '[PRE672]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: '[PRE673]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: '[PRE674]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: 'If you’re wondering where this pattern is used in real-world code, there are
    two examples in the standard library itself:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道这个模式在现实世界代码中的使用情况，标准库本身就有两个例子：
- en: '`std::function`: This is a general-purpose polymorphic function wrapper that
    enables us to store, copy, and invoke anything that is callable, such as functions,
    lambda expressions, bind expressions, function objects, pointers to member functions,
    and pointers to data members. Here is an example of using `std::function`:'
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::function`：这是一个通用多态函数包装器，使我们能够存储、复制和调用任何可调用的事物，例如函数、lambda表达式、绑定表达式、函数对象、成员函数指针和数据成员指针。以下是一个使用`std::function`的示例：'
- en: '[PRE675]'
  id: totrans-810
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE675]'
- en: '`std::any`: This is a class that represents a container to any value of a type
    that is copy-constructible. An example is used in the following snippet:'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::any`：这是一个表示可以存储任何可复制构造类型值的容器的类。以下代码片段中使用了示例：'
- en: '[PRE676]'
  id: totrans-812
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE676]'
- en: Type erasure is an idiom that combines inheritance from object-oriented programming
    with templates to create wrappers that can store any type. In this section, we
    have seen how the pattern looks and how it works, as well as some real-world implementations
    of the pattern.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除是一种结合面向对象编程中的继承和模板以创建可以存储任何类型的包装器的惯用语。在本节中，我们看到了这种模式的形状和它的工作方式，以及一些该模式的实际应用实例。
- en: Next in this chapter, we will discuss a technique called tag dispatching.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一部分，我们将讨论一种称为标签分派的技术。
- en: Tag dispatching
  id: totrans-815
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签分派
- en: '`std::enable_if` and **SFINAE** and is simple to understand and use. The term
    *tag* describes an empty class that has no members (data), or functions (behavior).
    Such a class is only used to define a parameter (usually the last) of a function
    to decide whether to select it at compile-time, depending on the supplied arguments.
    To better understand this, let’s consider an example.'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::enable_if`和**SFINAE**简单易懂且易于使用。术语*标签*描述的是一个没有成员（数据）或函数（行为）的空类。此类仅用于定义函数的参数（通常是最后一个），以决定在编译时是否选择它。为了更好地理解这一点，让我们考虑一个例子。'
- en: 'The standard library contains a utility function called `std::advance` that
    looks as follows:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中包含一个名为`std::advance`的实用函数，其形式如下：
- en: '[PRE677]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: '[PRE678]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: 'Notice that in C++17, this is also `constexpr` (more about this, shortly).
    This function increments the given iterator by `n` elements. However, there are
    several categories of iterators (input, output, forward, bidirectional, and random
    access). That means such an operation can be computed differently:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在C++17中，这也可以是`constexpr`（关于这一点，稍后会有更多介绍）。此函数通过`n`个元素增加给定的迭代器。然而，存在几种迭代器类别（输入、输出、前向、双向和随机访问）。这意味着此类操作可以以不同的方式计算：
- en: For input iterators, it could call `operator++` a number of `n` times.
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于输入迭代器，它可能需要调用`operator++`多次，次数为`n`。
- en: For bidirectional iterators, it could call either `operator++` a number of `n`
    times (if `n` is a positive number) or `operator--` a number of `n` times (if
    `n` is a negative number).
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于双向迭代器，它可能需要调用`operator++`多次（如果`n`是正数），或者调用`operator--`多次（如果`n`是负数）。
- en: For random-access iterators, it can use the `operator+=` to increment it directly
    with `n` elements.
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于随机访问迭代器，它可以使用`operator+=`直接通过`n`个元素来增加它。
- en: 'This implies there can be three different implementations, but it should be
    possible to select at compile-time which one is the best match for the category
    of the iterator it is called for. A solution for this is tag dispatching. And
    the first thing to do is define the tags. As mentioned earlier, tags are empty
    classes. Therefore, tags that correspond to the five iterator types can be defined
    as follows:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着可以有三种不同的实现，但应该可以在编译时选择最适合所调用迭代器类别的那个。解决这个问题的一个方法是标签分派。首先要做的事情是定义标签。如前所述，标签是空类。因此，对应于五种迭代器类型的标签可以定义为以下内容：
- en: '[PRE679]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: '[PRE680]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: '[PRE681]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: '[PRE682]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: '[PRE683]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: '[PRE684]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: '[PRE685]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: 'This is exactly how they are defined in the C++ standard library, in the `std`
    namespace. These tags will be used to define an additional parameter for each
    overload of `std::advance`, as shown next:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是C++标准库中在`std`命名空间中定义的方式。这些标签将被用来为`std::advance`的每个重载定义一个额外的参数，如下所示：
- en: '[PRE686]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: '[PRE687]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: '[PRE688]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: '[PRE689]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: '[PRE690]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: '[PRE691]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: '[PRE692]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: '[PRE693]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: '[PRE694]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: '[PRE695]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: '[PRE696]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: '[PRE697]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: '[PRE698]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: '[PRE699]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: '[PRE700]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: '[PRE701]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: '[PRE702]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: '[PRE703]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: '[PRE704]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: '[PRE705]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: '[PRE706]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: '[PRE707]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: '[PRE708]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: '[PRE709]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: '[PRE710]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: '[PRE711]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: '[PRE712]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: '[PRE713]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: '[PRE714]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: '[PRE715]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: '[PRE716]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: '[PRE717]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: '[PRE718]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: '[PRE719]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: 'These overloads are defined in a separate (inner) namespace of the `std` namespace
    so that the standard namespace is not polluted with unnecessary definitions. You
    can see here that each of these overloads has three parameters: a reference to
    an iterator, a number of elements to increment (or decrement), and a tag.'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 这些重载在`std`命名空间的一个单独的（内部）命名空间中定义，这样就不会污染标准命名空间中的不必要的定义。您可以看到，这些重载中的每一个都有三个参数：迭代器的引用、要增加（或减少）的元素数量，以及一个标签。
- en: 'The last thing to do is provide a definition of an `advance` function that
    is intended for direct use. This function does not have a third parameter but
    calls one of these overloads by determining the category of the iterator it is
    called with. Its implementation may look as follows:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是提供一个`advance`函数的定义，该函数旨在直接使用。此函数没有第三个参数，但它通过确定所调用迭代器的类别来调用这些重载之一。其实现可能如下所示：
- en: '[PRE720]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: '[PRE721]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: '[PRE722]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: '[PRE723]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: '[PRE724]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: '[PRE725]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: '[PRE726]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: '[PRE727]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: '[PRE728]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: '[PRE729]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: 'The `std::iterator_traits` class seen here defines a sort of interface for
    iterator types. For this purpose, it contains several member types, one of them
    being `iterator_category`. This resolves to one of the iterator tags defined earlier,
    such as `std::input_iterator_tag` for input iterators or `std::random_access_iterator_tag`
    for random access iterators. Therefore, based on the category of the supplied
    iterator, it instantiates one of these tag classes, determining the selection
    at compile-time of the appropriate overloaded implementation from the `details`
    namespace. We can invoke the `std::advance` function as follows:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 这里看到的 `std::iterator_traits` 类定义了一种迭代器类型的接口。为此，它包含几个成员类型，其中之一是 `iterator_category`。这解析为之前定义的迭代器标签之一，例如
    `std::input_iterator_tag` 用于输入迭代器或 `std::random_access_iterator_tag` 用于随机访问迭代器。因此，基于提供的迭代器类别，它实例化这些标签类之一，确定在编译时从
    `details` 命名空间中选择适当的重载实现。我们可以如下调用 `std::advance` 函数：
- en: '[PRE730]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: '[PRE731]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: '[PRE732]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: '[PRE733]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: '[PRE734]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: '[PRE735]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: The category type of the `std::vector`’s iterators is random access. On the
    other hand, the iterator category type for `std::list` is bidirectional. However,
    we can use a single function that relies on different optimized implementations
    by leveraging the technique of tag dispatching.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 迭代器的类别类型是随机访问。另一方面，`std::list` 的迭代器类别类型是双向的。然而，我们可以使用一个函数，该函数通过利用标签分发的技术，依赖于不同的优化实现。'
- en: Alternatives to tag dispatching
  id: totrans-887
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签分发的替代方案
- en: Prior to C++17, the only alternative to tag dispatching was SFINAE with `enable_if`.
    We have discussed this topic in [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080),
    *Type Traits and Conditional Compilation*. This is a rather legacy technique that
    has better alternatives in modern C++. These alternatives are **constexpr if**
    and **concepts**. Let’s discuss them one at a time.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 之前，标签分发的唯一替代方案是 SFINAE 与 `enable_if`。我们已经在 [*第 5 章*](B18367_05_ePub.xhtml#_idTextAnchor080)，*类型特性和条件编译*
    中讨论了此主题。这是一种相当过时的技术，在现代 C++ 中有更好的替代方案。这些替代方案是 **constexpr if** 和 **concepts**。让我们逐一讨论它们。
- en: Using constexpr if
  id: totrans-889
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `constexpr if`
- en: C++11 introduced the concept of `constexpr` values, which are values known at
    compile-time but also `constexpr` functions that are functions that could be evaluated
    at compile-time (if all inputs are compile-time values). In C++14, C++17, and
    C++20, many standard library functions or member functions of standard library
    classes have been changed to be `constexpr`. One of these is `std::advance`, whose
    implementation in C++17 is based on the constexpr if feature, also added in C++17
    (which was discussed in [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080),
    *Type Traits and Conditional Compilation*).
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 引入了 `constexpr` 值的概念，这些值在编译时已知，但还有 `constexpr` 函数，这些函数可以在编译时（如果所有输入都是编译时值）进行评估。在
    C++14、C++17 和 C++20 中，许多标准库函数或标准库类的成员函数已被更改为 `constexpr`。其中之一是 `std::advance`，其在
    C++17 中的实现基于 C++17 中也添加的 `constexpr if` 功能（在 [*第 5 章*](B18367_05_ePub.xhtml#_idTextAnchor080)，*类型特性和条件编译*
    中讨论过）。
- en: 'The following is a possible implementation in C++17:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 C++17 中的一个可能的实现：
- en: '[PRE736]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: '[PRE737]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: '[PRE738]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: '[PRE739]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: '[PRE740]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: '[PRE741]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: '[PRE742]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: '[PRE743]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: '[PRE744]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: '[PRE745]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: '[PRE746]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: '[PRE747]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: '[PRE748]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: '[PRE749]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: '[PRE750]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: '[PRE751]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: '[PRE752]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: '[PRE753]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: '[PRE754]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: '[PRE755]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: '[PRE756]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: '[PRE757]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: '[PRE758]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: '[PRE759]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: '[PRE760]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE760]'
- en: '[PRE761]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: '[PRE762]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE762]'
- en: '[PRE763]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: '[PRE764]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE764]'
- en: '[PRE765]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: '[PRE766]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE766]'
- en: '[PRE767]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: '[PRE768]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: '[PRE769]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE769]'
- en: Although this implementation still uses the iterator tags that we saw earlier,
    they are no longer used to invoke different overloaded functions but to determine
    the value of some compile-time expressions. The `std::is_base_of` type trait (through
    the `std::is_base_of_v` variable template) is used to determine the type of the
    iterator category at compile-time.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然此实现仍然使用我们之前看到的迭代器标签，但它们不再用于调用不同的重载函数，而是用于确定某些编译时表达式的值。`std::is_base_of` 类型特性（通过
    `std::is_base_of_v` 变量模板）用于在编译时确定迭代器类别。 '
- en: 'This implementation has several advantages:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现有几个优点：
- en: Has a single implementation of the algorithm (in the `std` namespace)
  id: totrans-928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法具有单个实现（在 `std` 命名空间中）
- en: Does not require multiple overloads with implementation details defined in a
    separate namespace
  id: totrans-929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要使用在单独命名空间中定义的实现细节进行多次重载
- en: The client code is unaffected. Therefore, library implementors were able to
    replace the previous version based on tag dispatching with the new version based
    on constexpr if, without affecting any line of code calling `std::advance`.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码不受影响。因此，库实现者能够用基于 `constexpr if` 的新版本替换基于标签分发的旧版本，而不影响调用 `std::advance`
    的任何代码行。
- en: However, in C++20 there is an even better alternative. Let’s explore it next.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 C++20 中有一个更好的替代方案。让我们接下来探索它。
- en: Using concepts
  id: totrans-932
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用概念
- en: 'The previous chapter was dedicated to constraints and concepts, introduced
    in C++20\. We have seen not only how these features work but also some of the
    concepts that the standard library defines in several headers such as `<concepts>`
    and `<iterator>`. Some of these concepts specify that a type is some iterator
    category. For instance, `std::input_iterator` specifies that a type is an input
    iterator. Similarly, the following concepts are also defined: `std::output_iterator`,
    `std::forward_iterator`, `std::bidirectional_iterator`, `std::random_access_iterator`,
    and `std::contiguous_iterator` (the last one indicating that an iterator is a
    random-access iterator, referring to elements that are stored contiguously in
    memory).'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章是关于约束和概念，这些概念是在C++20中引入的。我们不仅看到了这些功能是如何工作的，还看到了标准库在几个头文件中定义的一些概念，如`<concepts>`和`<iterator>`。其中一些概念指定了一个类型是某种迭代器类别。例如，`std::input_iterator`指定了一个类型是输入迭代器。同样，以下概念也被定义了：`std::output_iterator`、`std::forward_iterator`、`std::bidirectional_iterator`、`std::random_access_iterator`和`std::contiguous_iterator`（最后一个表示迭代器是一个随机访问迭代器，指的是存储在内存中连续的元素）。
- en: 'The `std::input_iterator` concept is defined as follows:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::input_iterator`概念定义如下：'
- en: '[PRE770]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE770]'
- en: '[PRE771]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE771]'
- en: '[PRE772]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE772]'
- en: '[PRE773]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE773]'
- en: '[PRE774]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE774]'
- en: '[PRE775]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE775]'
- en: '[PRE776]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE776]'
- en: 'Without getting into too many details, it is worth noting that this concept
    is a set of constraints that verify the following:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入太多细节，值得注意的是，这个概念是一组约束，用于验证以下内容：
- en: The iterator is dereferenceable (supports `*i`) and is incrementable (supports
    `++i` and `i++`).
  id: totrans-943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器是可解引用的（支持`*i`）并且是可递增的（支持`++i`和`i++`）。
- en: The iterator category is derived from `std::input_iterator_tag`.
  id: totrans-944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器类别是从`std::input_iterator_tag`派生出来的。
- en: 'This means that the category check is performed within the constraint. Therefore,
    these concepts are still based on the iterator tags, but the technique is significantly
    different than tag dispatching. As a result, in C++20, we could have yet another
    implementation for the `std::advance` algorithm, as follows:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着类别检查是在约束内进行的。因此，这些概念仍然基于迭代器标签，但与标签分发的技术相比，这种方法有显著的不同。因此，在C++20中，我们可能对`std::advance`算法有另一种实现，如下所示：
- en: '[PRE777]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE777]'
- en: '[PRE778]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE778]'
- en: '[PRE779]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE779]'
- en: '[PRE780]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE780]'
- en: '[PRE781]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE781]'
- en: '[PRE782]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE782]'
- en: '[PRE783]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE783]'
- en: '[PRE784]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE784]'
- en: '[PRE785]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE785]'
- en: '[PRE786]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE786]'
- en: '[PRE787]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE787]'
- en: '[PRE788]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE788]'
- en: '[PRE789]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE789]'
- en: '[PRE790]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE790]'
- en: '[PRE791]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE791]'
- en: '[PRE792]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE792]'
- en: '[PRE793]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE793]'
- en: '[PRE794]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE794]'
- en: '[PRE795]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE795]'
- en: '[PRE796]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE796]'
- en: '[PRE797]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE797]'
- en: '[PRE798]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE798]'
- en: '[PRE799]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE799]'
- en: '[PRE800]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE800]'
- en: '[PRE801]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE801]'
- en: 'There are a couple of things to notice here:'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个需要注意的地方：
- en: There are yet again three different overloads of the advanced function.
  id: totrans-972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级函数又有三个不同的重载。
- en: These overloads are defined in the `std` namespace and do not require a separate
    namespace to hide implementation details.
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些重载是在`std`命名空间中定义的，并且不需要单独的命名空间来隐藏实现细节。
- en: Although we explicitly wrote several overloads again, this solution is arguably
    easier to read and understand than the one based on constexpr if because the code
    is nicely separated into different units (functions), making it easier to follow.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们再次明确地写了几种重载，但与基于constexpr if的解决方案相比，这个解决方案更容易阅读和理解，因为代码被很好地分成了不同的单元（函数），这使得它更容易跟踪。
- en: Tag dispatching is an important technique for selecting between overloads at
    compile-time. It has its trade-offs but also better alternatives if you are using
    C++17 or C++20\. If your compiler supports concepts, you should prefer this alternative
    for the reasons mentioned earlier.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 标签分发是在编译时选择重载的重要技术。它有其权衡，但如果你在使用C++17或C++20，那么它也有更好的替代方案。如果你的编译器支持概念，你应该根据前面提到的原因选择这个替代方案。
- en: The next pattern we will look at in this chapter is expression templates.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨的下一个模式是表达式模板。
- en: Expression templates
  id: totrans-977
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式模板
- en: '**Expression templates** are a metaprogramming technique that enables lazy
    evaluation of a computation at compile-time. This helps to avoid inefficient operations
    that occur at runtime. However, this does not come for free, as expression templates
    require more code and can be cumbersome to read or understand. They are often
    used in the implementation of linear algebra libraries.'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式模板**是一种元编程技术，它允许在编译时延迟计算。这有助于避免在运行时发生的低效操作。然而，这并非没有代价，因为表达式模板需要更多的代码，并且可能难以阅读或理解。它们通常用于线性代数库的实现中。'
- en: 'Before seeing how expression templates are implemented, let’s understand what
    is the problem they solve. For this, let’s suppose we want to do some operations
    with matrices, for which we implemented the basic operations, addition, subtraction,
    and multiplication (either of two matrices or of a scalar and a matrix). We can
    have the following expressions:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解表达式模板是如何实现之前，让我们先了解它们解决的是什么问题。为此，让我们假设我们想要对矩阵进行一些操作，为此我们实现了基本操作，如加法、减法和乘法（两个矩阵之间的乘法或标量与矩阵之间的乘法）。我们可以有以下表达式：
- en: '[PRE802]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE802]'
- en: '[PRE803]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE803]'
- en: '[PRE804]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE804]'
- en: '[PRE805]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE805]'
- en: 'In this snippet, `m1`, `m2`, `m3`, and `m4` are matrices; similarly, `r1`,
    `r2`, `r3`, and `r4` are matrices that result from performing the operations on
    the right side. The first operation does not pose any problems: `m1` and `m2`
    are added and the result is assigned to `r1`. However, the second operation is
    different because there are three matrices that are added. That means `m1` and
    `m2` are added first and a temporary is created, which is then added to `m3` and
    the result assigned to `r2`.'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`m1`、`m2`、`m3` 和 `m4` 是矩阵；同样，`r1`、`r2`、`r3` 和 `r4` 是通过右侧操作得到的矩阵。第一个操作没有问题：`m1`
    和 `m2` 相加，结果赋值给 `r1`。然而，第二个操作不同，因为有三个矩阵相加。这意味着首先将 `m1` 和 `m2` 相加，然后创建一个临时变量，该临时变量随后与
    `m3` 相加，并将结果赋值给 `r2`。
- en: 'For the third operation, there are two temporaries: one for the result of multiplying
    `m1` and `m2` and one for the result of multiplying `m3` and `m4`; these two are
    then added and the result is assigned to `r3`. Finally, the last operation is
    similar to the second, meaning that a temporary object results from the multiplication
    between the scalar `5` and the matrix `m2`, and then this temporary is added to
    `m1` and the result assigned to `r4`.'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三次操作，有两个临时变量：一个用于计算 `m1` 和 `m2` 的乘积，另一个用于计算 `m3` 和 `m4` 的乘积；这两个乘积相加后，结果赋值给
    `r3`。最后，最后一个操作与第二个操作类似，意味着通过标量 `5` 和矩阵 `m2` 的乘积得到一个临时对象，然后将这个临时对象加到 `m1` 上，并将结果赋值给
    `r4`。
- en: The more complex the operation, the more temporaries are generated. This can
    affect performance when the objects are large. Expression templates help to avoid
    this by modeling the computation as a compile-time expression. The entire mathematical
    expression (such as `m1 + 5 * m2`) becomes a single expression template computed
    when the assignment is evaluated and without the need for any temporary object.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 操作越复杂，生成的临时变量就越多。当对象较大时，这可能会影响性能。表达式模板通过将计算建模为编译时表达式来帮助避免这种情况。整个数学表达式（如 `m1
    + 5 * m2`）在赋值评估时成为一个单独的表达式模板，而不需要任何临时对象。
- en: 'To demonstrate this, we will build some examples using vectors not matrices
    because these are simpler data structures, and the point of the exercise is not
    to focus on the representation of data but on the creation of expression templates.
    In the following listing, you can see a minimal implementation of a vector class
    that provides several operations:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将使用向量而不是矩阵来构建一些示例，因为这些数据结构更简单，练习的重点不是关注数据的表示，而是创建表达式模板。在下面的列表中，你可以看到一个向量的最小实现，它提供了几个操作：
- en: Constructing an instance from an initializer list or from a value representing
    a size (no initializing values)
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从初始化列表或表示大小的值（没有初始化值）构造实例
- en: Retrieving the number of elements in the vector
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取向量中的元素数量
- en: Element access with the subscript operator (`[]`)
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用下标运算符（`[]`）访问元素
- en: 'The code goes as follows:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE806]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE806]'
- en: '[PRE807]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE807]'
- en: '[PRE808]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE808]'
- en: '[PRE809]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE809]'
- en: '[PRE810]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE810]'
- en: '[PRE811]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE811]'
- en: '[PRE812]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE812]'
- en: '[PRE813]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE813]'
- en: '[PRE814]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE814]'
- en: '[PRE815]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE815]'
- en: '[PRE816]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE816]'
- en: '[PRE817]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE817]'
- en: '[PRE818]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE818]'
- en: '[PRE819]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE819]'
- en: '[PRE820]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE820]'
- en: '[PRE821]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE821]'
- en: '[PRE822]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE822]'
- en: '[PRE823]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE823]'
- en: '[PRE824]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE824]'
- en: '[PRE825]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE825]'
- en: 'This looks very similar to the `std::vector` standard container, and, in fact,
    it uses this container internally to hold the data. However, this aspect is irrelevant
    to the problem we want to solve. Remember we are using a vector and not a matrix
    because it’s easier to represent in a few lines of code. Having this class, we
    can define the necessary operations: addition and multiplication, both between
    two vectors and between a scalar and a vector:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常类似于 `std::vector` 标准容器，实际上，它使用这个容器内部来存储数据。然而，这个方面与我们想要解决的问题无关。记住，我们使用向量而不是矩阵，因为它更容易用几行代码表示。有了这个类，我们可以定义必要的操作：加法和乘法，这两个操作都是在两个向量之间以及标量和向量之间进行的：
- en: '[PRE826]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE826]'
- en: '[PRE827]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE827]'
- en: '[PRE828]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE828]'
- en: '[PRE829]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE829]'
- en: '[PRE830]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE830]'
- en: '[PRE831]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE831]'
- en: '[PRE832]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE832]'
- en: '[PRE833]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE833]'
- en: '[PRE834]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE834]'
- en: '[PRE835]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE835]'
- en: '[PRE836]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE836]'
- en: '[PRE837]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE837]'
- en: '[PRE838]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE838]'
- en: '[PRE839]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE839]'
- en: '[PRE840]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE840]'
- en: '[PRE841]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE841]'
- en: '[PRE842]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE842]'
- en: '[PRE843]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE843]'
- en: '[PRE844]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE844]'
- en: '[PRE845]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE845]'
- en: '[PRE846]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE846]'
- en: '[PRE847]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE847]'
- en: '[PRE848]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE848]'
- en: '[PRE849]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE849]'
- en: '[PRE850]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE850]'
- en: '[PRE851]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE851]'
- en: '[PRE852]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE852]'
- en: '[PRE853]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE853]'
- en: '[PRE854]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE854]'
- en: '[PRE855]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE855]'
- en: '[PRE856]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE856]'
- en: '[PRE857]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE857]'
- en: '[PRE858]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE858]'
- en: '[PRE859]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE859]'
- en: '[PRE860]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE860]'
- en: '[PRE861]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE861]'
- en: 'These implementations are relatively straightforward and should not pose a
    problem to understand at this point. Both the `+` and `*` operators take two vectors
    of potentially different types, such as `vector<int>` and `vector<double>`, and
    return a vector holding elements of a result type. This is determined by the result
    of adding two values of the template types `T` and `U`, using `std::declval`.
    This has been discussed in [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064),
    *Advanced Template Concepts*. A similar implementation is available for multiplying
    a scalar and a vector. Having these operators available, we can write the following
    code:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现相对简单，应该不会在这个阶段造成理解上的问题。`+`和`*`运算符接受两种可能不同类型的两个向量，例如`vector<int>`和`vector<double>`，并返回一个包含结果类型元素的向量。这是通过使用`std::declval`将模板类型`T`和`U`的两个值相加的结果来确定的。这已经在[*第4章*](B18367_04_ePub.xhtml#_idTextAnchor064)中讨论过，*高级模板概念*。类似的实现也适用于标量与向量的乘法。有了这些运算符，我们可以编写以下代码：
- en: '[PRE862]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE862]'
- en: '[PRE863]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE863]'
- en: '[PRE864]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE864]'
- en: '[PRE865]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE865]'
- en: '[PRE866]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE866]'
- en: 'As previously explained, this will create one temporary object while computing
    `v3` and two temporaries while computing `v4`. These are exemplified in the following
    diagrams. The first shows the first computation, `v3 = v1 + a * v2`:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这将创建一个临时对象来计算`v3`，并在计算`v4`时创建两个临时对象。以下图表展示了这些示例。第一个图表显示了第一个计算，`v3 = v1
    + a * v2`：
- en: '![Figure 7.2: A conceptual representation of the first expression'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.2: 第一个表达式的概念表示]'
- en: '](img/Figure_7.2_B18367.jpg)'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.2_B18367.jpg]'
- en: 'Figure 7.2: A conceptual representation of the first expression'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.2: 第一个表达式的概念表示]'
- en: 'The second diagram, shown next, presents a conceptual representation of the
    computation of the second expression, `v4 = v1 * v2 + v1 + v2`:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图表展示了第二个表达式`v4 = v1 * v2 + v1 + v2`的概念表示：
- en: '![Figure 7.3: A conceptual representation of the second expression'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.3: 第二个表达式的概念表示]'
- en: '](img/Figure_7.3_B18367.jpg)'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.3_B18367.jpg]'
- en: 'Figure 7.3: A conceptual representation of the second expression'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：第二个表达式的概念表示
- en: 'In order to avoid these temporaries, we can rewrite the implementation of the
    `vector` class using the expression templates pattern. This requires several changes:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些临时变量，我们可以使用表达式模板模式重写`vector`类的实现。这需要几个更改：
- en: Defining class templates to represent an expression between two objects (such
    as the expression of adding or multiplying two vectors).
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义类模板来表示两个对象之间的表达式（例如，两个向量的加法或乘法表达式）。
- en: Modifying the `vector` class and parameterize the container for its internal
    data, which by default would be a `std::vector` as previously but can also be
    an expression template.
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`vector`类并为其内部数据参数化容器，默认情况下将是一个`std::vector`，如之前所述，但也可以是一个表达式模板。
- en: Changing the implementation of the overloaded `+` and `*` operators.
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变重载的`+`和`*`运算符的实现。
- en: 'Let’s see how this is done, starting with the vector implementation. Here is
    the code:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何实现的，从向量实现开始。以下是代码：
- en: '[PRE867]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE867]'
- en: '[PRE868]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE868]'
- en: '[PRE869]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE869]'
- en: '[PRE870]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE870]'
- en: '[PRE871]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE871]'
- en: '[PRE872]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE872]'
- en: '[PRE873]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE873]'
- en: '[PRE874]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE874]'
- en: '[PRE875]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE875]'
- en: '[PRE876]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE876]'
- en: '[PRE877]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE877]'
- en: '[PRE878]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE878]'
- en: '[PRE879]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE879]'
- en: '[PRE880]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE880]'
- en: '[PRE881]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE881]'
- en: '[PRE882]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE882]'
- en: '[PRE883]'
  id: totrans-1084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE883]'
- en: '[PRE884]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE884]'
- en: '[PRE885]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE885]'
- en: '[PRE886]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE886]'
- en: '[PRE887]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE887]'
- en: '[PRE888]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE888]'
- en: '[PRE889]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE889]'
- en: '[PRE890]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE890]'
- en: '[PRE891]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE891]'
- en: '[PRE892]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE892]'
- en: '[PRE893]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE893]'
- en: '[PRE894]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE894]'
- en: '[PRE895]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE895]'
- en: '[PRE896]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE896]'
- en: '[PRE897]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE897]'
- en: '[PRE898]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE898]'
- en: '[PRE899]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE899]'
- en: '[PRE900]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE900]'
- en: '[PRE901]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE901]'
- en: '[PRE902]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE902]'
- en: '[PRE903]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE903]'
- en: '[PRE904]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE904]'
- en: 'In addition to the operations available in the initial implementation, this
    time we have also defined the following:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了初始实现中可用的操作外，这次我们还定义了以下内容：
- en: A default constructor
  id: totrans-1107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认构造函数
- en: A conversion constructor from a container
  id: totrans-1108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个容器到转换构造函数
- en: A copy constructor from a `vector` containing elements of a potentially different
    type
  id: totrans-1109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从包含可能不同类型元素的`vector`到复制构造函数
- en: A copy-assignment operator from a `vector` containing elements of a potentially
    different type
  id: totrans-1110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从包含可能不同类型元素的`vector`到复制赋值运算符
- en: Member function `data` that provides access to the underlaying container holding
    the data
  id: totrans-1111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员函数`data`，它提供了对底层容器中数据的访问
- en: 'An expression template is a simple class template that stores two operands
    and provides a way to perform the evaluation of the operation. In our case, we
    need to implement expressions for adding two vectors, multiplying two vectors,
    and multiplying a scalar and a vector. Let’s look at the implementation of the
    expression template for adding two vectors:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式模板是一个简单的类模板，它存储两个操作数并提供了一种执行操作评估的方法。在我们的情况下，我们需要实现两个向量的加法、两个向量的乘法以及标量与向量的乘法表达式。让我们看看两个向量加法表达式模板的实现：
- en: '[PRE905]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE905]'
- en: '[PRE906]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE906]'
- en: '[PRE907]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE907]'
- en: '[PRE908]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE908]'
- en: '[PRE909]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE909]'
- en: '[PRE910]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE910]'
- en: '[PRE911]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE911]'
- en: '[PRE912]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE912]'
- en: '[PRE913]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE913]'
- en: '[PRE914]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE914]'
- en: '[PRE915]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE915]'
- en: '[PRE916]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE916]'
- en: '[PRE917]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE917]'
- en: '[PRE918]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE918]'
- en: '[PRE919]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE919]'
- en: '[PRE920]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE920]'
- en: This class stores constant references to two vectors (or, in fact, any type
    that overloads the subscript operator and provides a `size` member function).
    The evaluation of the expression occurs in the overloaded subscript operator but
    not for the entire vector; only the elements at the indicated index are added.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 此类存储对两个向量（实际上，任何重载下标运算符并提供`size`成员函数的类型）的常量引用。表达式的评估发生在重载的下标运算符中，而不是整个向量中；只有指示索引处的元素被添加。
- en: Notice that this implementation does not handle vectors of different sizes (which
    you can take as an exercise to change). However, it should be easy to understand
    the lazy nature of this approach since the addition operation only occurs when
    invoking the subscript operator.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此实现不处理不同大小的向量（你可以将其作为练习来改变）。然而，由于加法操作仅在调用下标运算符时发生，因此应该很容易理解这种方法的懒加载性质。
- en: 'The multiplication expression templates for the two operations we need are
    implemented in a similar fashion. The code is shown in the next listing:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的两个操作的乘法表达式模板以类似的方式实现。代码将在下一列表中展示：
- en: '[PRE921]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE921]'
- en: '[PRE922]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE922]'
- en: '[PRE923]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE923]'
- en: '[PRE924]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE924]'
- en: '[PRE925]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE925]'
- en: '[PRE926]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE926]'
- en: '[PRE927]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE927]'
- en: '[PRE928]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE928]'
- en: '[PRE929]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE929]'
- en: '[PRE930]'
  id: totrans-1141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE930]'
- en: '[PRE931]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE931]'
- en: '[PRE932]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE932]'
- en: '[PRE933]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE933]'
- en: '[PRE934]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE934]'
- en: '[PRE935]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE935]'
- en: '[PRE936]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE936]'
- en: '[PRE937]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE937]'
- en: '[PRE938]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE938]'
- en: '[PRE939]'
  id: totrans-1150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE939]'
- en: '[PRE940]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE940]'
- en: '[PRE941]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE941]'
- en: '[PRE942]'
  id: totrans-1153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE942]'
- en: '[PRE943]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE943]'
- en: '[PRE944]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE944]'
- en: '[PRE945]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE945]'
- en: '[PRE946]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE946]'
- en: '[PRE947]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE947]'
- en: '[PRE948]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE948]'
- en: '[PRE949]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE949]'
- en: '[PRE950]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE950]'
- en: '[PRE951]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE951]'
- en: '[PRE952]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE952]'
- en: '[PRE953]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE953]'
- en: '[PRE954]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE954]'
- en: 'The last part of the change is to modify the definition of the overloaded `+`
    and `*` operators, which is as follows:'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 变更的最后一部分是修改重载的`+`和`*`运算符的定义，如下所示：
- en: '[PRE955]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE955]'
- en: '[PRE956]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE956]'
- en: '[PRE957]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE957]'
- en: '[PRE958]'
  id: totrans-1170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE958]'
- en: '[PRE959]'
  id: totrans-1171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE959]'
- en: '[PRE960]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE960]'
- en: '[PRE961]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE961]'
- en: '[PRE962]'
  id: totrans-1174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE962]'
- en: '[PRE963]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE963]'
- en: '[PRE964]'
  id: totrans-1176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE964]'
- en: '[PRE965]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE965]'
- en: '[PRE966]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE966]'
- en: '[PRE967]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE967]'
- en: '[PRE968]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE968]'
- en: '[PRE969]'
  id: totrans-1181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE969]'
- en: '[PRE970]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE970]'
- en: '[PRE971]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE971]'
- en: '[PRE972]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE972]'
- en: '[PRE973]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE973]'
- en: '[PRE974]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE974]'
- en: '[PRE975]'
  id: totrans-1187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE975]'
- en: '[PRE976]'
  id: totrans-1188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE976]'
- en: '[PRE977]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE977]'
- en: '[PRE978]'
  id: totrans-1190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE978]'
- en: '[PRE979]'
  id: totrans-1191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE979]'
- en: '[PRE980]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE980]'
- en: Although the code is more complex when implementing this pattern, the client
    code does not need to change. The snippet showed earlier works without any modifications
    but in a lazy manner. The evaluation of each element in the result is triggered
    by the invocation of the subscript operator that occurs in the copy-constructor
    and copy-assignment operator of the vector class.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管实现此模式时代码更为复杂，但客户端代码无需更改。前面展示的代码片段无需任何修改即可工作，但以懒加载的方式运行。结果集中每个元素的评估是由向量类中的复制构造函数和复制赋值运算符中出现的下标运算符的调用触发的。
- en: 'If this pattern looks cumbersome to you, there is the alternative of something
    better: the ranges library.'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个模式让你觉得繁琐，有一个更好的选择：范围库。
- en: Using ranges as an alternative to expression templates
  id: totrans-1195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用范围作为表达式模板的替代方案
- en: One of the major features of C++20 is the ranges library. A *range* is a generalization
    of a container - a class that allows you to iterate over its data (elements).
    A key element of the range library is the views. These are non-owning wrappers
    of other ranges that transform the underlying range through some operation.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: C++20的一个主要特性是范围库。*范围*是容器的一般化——一个允许你遍历其数据的类。范围库的一个关键元素是视图。这些是其他范围的非拥有包装器，通过某些操作转换底层范围。
- en: Moreover, they are lazy-evaluated and the time to construct, copy, or destroy
    them does not depend on the size of the underlying range. The lazy evaluation
    (the fact that transformations are applied to elements at the moment they are
    requested, not when the view is created) is a key feature of the library. However,
    that is exactly what the expression templates are also providing. As a result,
    many uses of the expression templates can be replaced with ranges. Ranges will
    be discussed in detail in the next chapter.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它们是懒加载的，构建、复制或销毁它们的时间不依赖于底层范围的大小。懒加载（即转换是在请求元素时而不是在创建视图时应用）是库的关键特性。然而，这正是表达式模板也提供的内容。因此，许多表达式模板的使用可以用范围来替代。范围将在下一章中详细讨论。
- en: 'The C++ ranges library is based on the `v1 + a * v2`:'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: C++范围库基于`v1 + a * v2`：
- en: '[PRE981]'
  id: totrans-1199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE981]'
- en: '[PRE982]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE982]'
- en: '[PRE983]'
  id: totrans-1201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE983]'
- en: '[PRE984]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE984]'
- en: '[PRE985]'
  id: totrans-1203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE985]'
- en: '[PRE986]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE986]'
- en: '[PRE987]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE987]'
- en: There is no need for a custom implementation of a vector class; it just works
    with the `std::vector` container. There is no need to overload any operator also.
    The code should be easy to follow, at least if you have some familiarity with
    the ranges library. First, we create a view that transforms the elements of the
    `v2` vector by multiplying each element with a scalar. Then, a second view is
    created that applies the plus operator on the elements of the `v1` range and the
    view resulting from the previous operation.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要为向量类实现自定义实现；它只需与`std::vector`容器一起工作。也不需要重载任何运算符。代码应该很容易理解，至少如果你对范围库有些熟悉的话。首先，我们创建一个视图，通过将每个元素乘以一个标量来转换`v2`向量中的元素。然后，创建第二个视图，它对`v1`范围和前一个操作的结果视图的元素应用加法运算符。
- en: 'Unfortunately, this code cannot be written in C++20 using the standard library,
    because the `zip_with` view has not been included in C++20\. However, this view
    will be available in C++23 under the name `zip_view`. Therefore, in C++23, we
    will be able to write this code as follows:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码不能使用 C++20 的标准库来编写，因为 `zip_with` 视图尚未包含在 C++20 中。然而，这个视图将在 C++23 中以
    `zip_view` 的名称提供。因此，在 C++23 中，我们将能够以下这种方式编写这段代码：
- en: '[PRE988]'
  id: totrans-1208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE988]'
- en: '[PRE989]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE989]'
- en: '[PRE990]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE990]'
- en: '[PRE991]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE991]'
- en: '[PRE992]'
  id: totrans-1212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE992]'
- en: '[PRE993]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE993]'
- en: '[PRE994]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE994]'
- en: 'To conclude the discussion of the expression templates pattern, you should
    keep in mind the following takeaways: the pattern is designed to provide lazy
    evaluation for costly operations, and it does so at the expense of having to write
    more code (that is also arguably more cumbersome) and increased compile-times
    (since heavy template code will have an impact on that). However, as of C++20,
    a good alternative to this pattern is represented by the ranges library. We will
    learn about this new library in [*Chapter 9*](B18367_09_ePub.xhtml#_idTextAnchor188),
    *The Ranges Library*.'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 要总结对表达式模板模式的讨论，你应该记住以下要点：该模式旨在为昂贵的操作提供惰性求值，但这是以编写更多代码（也可能更繁琐）和增加编译时间为代价的。然而，截至
    C++20，这种模式的良好替代品是范围库。我们将在 [*第 9 章*](B18367_09_ePub.xhtml#_idTextAnchor188)，*范围库*
    中了解这个新库。
- en: For the next and last section of this chapter, we will look at type lists.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的下一节和最后一节，我们将探讨类型列表。
- en: Typelists
  id: totrans-1217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型列表
- en: A **type list** (also spelled *typelist*) is a compile-time construct that enables
    us to manage a sequence of types. A typelist is somehow similar to a tuple but
    does not store any data. A typelist only carries type information and is used
    exclusively at compile-time for implementing different metaprogramming algorithms,
    type switches, or design patterns such as *Abstract Factory* or *Visitor*.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型列表**（也拼作 *typelist*）是一种编译时构造，它使我们能够管理一系列类型。类型列表在某种程度上类似于元组，但它不存储任何数据。类型列表仅携带类型信息，并在编译时专门用于实现不同的元编程算法、类型切换或设计模式，例如
    *抽象工厂* 或 *访问者*。'
- en: Important Note
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Although both the *type list* and *typelist* spellings are in use, most of the
    time you will find the term *typelist* in C++ books and articles. Therefore, this
    will be the form we will use in this book.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两种拼写 *type list* 和 *typelist* 都在使用，但大多数情况下，你会在 C++ 书籍和文章中找到术语 *typelist*。因此，我们将使用这种形式在这本书中。
- en: 'Typelists were popularized by Andrei Alexandrescu in his book, *Modern C++
    Design*, published a decade before the release of C++11 (and variadic templates).
    Alexandrescu defined a typelist as follows:'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 类型列表是由 Andrei Alexandrescu 在他十年前出版的书籍 *Modern C++ Design* 中推广的，这本书在 C++11 发布之前十年出版（以及变长模板）。Alexandrescu
    如下定义了类型列表：
- en: '[PRE995]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE995]'
- en: '[PRE996]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE996]'
- en: '[PRE997]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE997]'
- en: '[PRE998]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE998]'
- en: '[PRE999]'
  id: totrans-1226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE999]'
- en: '[PRE1000]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1000]'
- en: 'In his implementation, a typelist is composed of a head—which is a type, and
    a tail—which is another typelist. In order to perform various operations on the
    typelist (which will be discussed shortly) we also need a type to represent the
    end of the typelist. This can be a simple, empty type that Alexandrescu defined
    as follows:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的实现中，类型列表由一个头部组成——这是一个类型，以及一个尾部——这是另一个类型列表。为了在类型列表上执行各种操作（将在稍后讨论），我们还需要一个类型来表示类型列表的末尾。这可以是一个简单的、空类型，Alexandrescu
    如下定义：
- en: '[PRE1001]'
  id: totrans-1229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1001]'
- en: 'Having these two constructs, we can define typelists in the following way:'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 有这两个构造，我们可以以下这种方式定义类型列表：
- en: '[PRE1002]'
  id: totrans-1231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1002]'
- en: '[PRE1003]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1003]'
- en: 'Variadic templates make the implementation of typelists simpler, as shown in
    the next snippet:'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 变长模板使类型列表的实现更简单，如以下代码片段所示：
- en: '[PRE1004]'
  id: totrans-1234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1004]'
- en: '[PRE1005]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1005]'
- en: '[PRE1006]'
  id: totrans-1236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1006]'
- en: 'The implementation of operations of typelists (such as accessing a type at
    a given index, adding or removing types from the list, and so on) differs significantly
    depending on the selected approach. In this book, we will only consider the variadic
    template version. The advantage of this approach is simplicity at different levels:
    the definition of the typelist is shorter, there is no need for a type to represent
    the end of the list, and defining typelist aliases is also shorter and easier
    to read.'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 类型列表操作的实现（如访问给定索引处的类型、从列表中添加或删除类型等）根据所选方法的不同而有很大差异。在这本书中，我们只考虑变长模板版本。这种方法的优势在于不同层面的简单性：类型列表的定义更短，不需要一个类型来表示列表的末尾，定义类型列表别名也更短、更容易阅读。
- en: 'Today, perhaps many of the problems for which typelists represented the solution
    can be also solved using variadic templates. However, there are still scenarios
    where typelists are required. Here is an example: let’s consider a variadic metafunction
    (a type trait that performs a transformation of types) that does some transformation
    (such as adding the `const` qualifier) to the type template arguments. This metafunction
    defines a member type that represents the input types and one that represents
    the transformed types. If you try to define it as follows, it will not work:'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，也许许多原本由typelists提供解决方案的问题也可以使用可变参数模板来解决。然而，仍然有一些场景需要使用typelists。以下是一个例子：让我们考虑一个可变元函数（一个执行类型转换的类型特性），它对类型模板参数执行一些转换（例如添加`const`限定符）。这个元函数定义了一个成员类型来表示输入类型，另一个来表示转换后的类型。如果你尝试如下定义它，它将不会工作：
- en: '[PRE1007]'
  id: totrans-1239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1007]'
- en: '[PRE1008]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1008]'
- en: '[PRE1009]'
  id: totrans-1241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1009]'
- en: '[PRE1010]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1010]'
- en: '[PRE1011]'
  id: totrans-1243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1011]'
- en: '[PRE1012]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1012]'
- en: 'This code produces compiler errors, because the expansion of the parameter
    pack is not possible in this context. This is a topic we discussed in [*Chapter
    3*](B18367_03_ePub.xhtml#_idTextAnchor051), *Variadic Templates*. The solution
    to this is to use a typelist, as follows:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会产生编译错误，因为在这个上下文中无法展开参数包。这是我们讨论过的主题，见[*第3章*](B18367_03_ePub.xhtml#_idTextAnchor051)，*可变参数模板*。解决这个问题的方法是使用typelist，如下所示：
- en: '[PRE1013]'
  id: totrans-1246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1013]'
- en: '[PRE1014]'
  id: totrans-1247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1014]'
- en: '[PRE1015]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1015]'
- en: '[PRE1016]'
  id: totrans-1249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1016]'
- en: '[PRE1017]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1017]'
- en: '[PRE1018]'
  id: totrans-1251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1018]'
- en: '[PRE1019]'
  id: totrans-1252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1019]'
- en: '[PRE1020]'
  id: totrans-1253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1020]'
- en: '[PRE1021]'
  id: totrans-1254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1021]'
- en: '[PRE1022]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1022]'
- en: The change is minimal but produces the expected result. Although this is a good
    example of where typelists are needed, it’s not a typical example of where typelists
    are used. We will look at such an example next.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 变化很小，但产生了预期的结果。尽管这是一个需要typelists的很好的例子，但它并不是一个使用typelists的典型例子。我们将在下一个例子中查看这样的例子。
- en: Using typelists
  id: totrans-1257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用typelists
- en: It’s worth exploring a more complex example before we look at how to implement
    operations on typelists. This should give you an understanding of the possible
    usage of typelists, although you can always search for more online.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看如何在typelists上实现操作之前，探索一个更复杂的例子是值得的。这应该能让你理解typelists的可能用法，尽管你总是可以在线搜索更多内容。
- en: 'Let’s return to the example of the game units. For simplicity, we’ll only consider
    the following class:'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到游戏单位的例子。为了简单起见，我们只考虑以下类：
- en: '[PRE1023]'
  id: totrans-1260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1023]'
- en: '[PRE1024]'
  id: totrans-1261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1024]'
- en: '[PRE1025]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1025]'
- en: '[PRE1026]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1026]'
- en: '[PRE1027]'
  id: totrans-1264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1027]'
- en: 'A game unit has two data members representing indices (or levels) for attacking
    and defending. We want to operate changes on these members with the help of some
    functors. Two such functions are shown in the following listing:'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏单位有两个数据成员表示攻击和防御的索引（或等级）。我们希望通过一些函数对象的帮助对这些成员进行操作。以下列表显示了两个这样的函数：
- en: '[PRE1028]'
  id: totrans-1266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1028]'
- en: '[PRE1029]'
  id: totrans-1267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1029]'
- en: '[PRE1030]'
  id: totrans-1268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1030]'
- en: '[PRE1031]'
  id: totrans-1269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1031]'
- en: '[PRE1032]'
  id: totrans-1270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1032]'
- en: '[PRE1033]'
  id: totrans-1271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1033]'
- en: '[PRE1034]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1034]'
- en: '[PRE1035]'
  id: totrans-1273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1035]'
- en: '[PRE1036]'
  id: totrans-1274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1036]'
- en: '[PRE1037]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1037]'
- en: '[PRE1038]'
  id: totrans-1276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1038]'
- en: '[PRE1039]'
  id: totrans-1277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1039]'
- en: '[PRE1040]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1040]'
- en: '[PRE1041]'
  id: totrans-1279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1041]'
- en: 'The first increases the defense index by 20%, while the second increases the
    attack index by two units. Although this is a small example meant to demonstrate
    the use case, you can imagine a larger variety of functors like this that could
    be applied in some well-defined combinations. In our example, however, we want
    to apply these two functors on a `game_unit` object. We’d like to have a function
    as follows:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个增加了防御指数的20%，而第二个增加了攻击指数两个单位。尽管这是一个为了演示用例的小例子，但你可以想象出更多这样的函数，它们可以以一些定义良好的组合方式应用。然而，在我们的例子中，我们想在`game_unit`对象上应用这两个函数。我们希望有一个如下所示的函数：
- en: '[PRE1042]'
  id: totrans-1281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1042]'
- en: '[PRE1043]'
  id: totrans-1282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1043]'
- en: '[PRE1044]'
  id: totrans-1283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1044]'
- en: '[PRE1045]'
  id: totrans-1284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1045]'
- en: '[PRE1046]'
  id: totrans-1285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1046]'
- en: '[PRE1047]'
  id: totrans-1286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1047]'
- en: 'This `upgrade_unit` function takes a `game_unit` object and applies the `upgrade_defense`
    and `upgrade_attack` functors to it. For this, it uses another helper functor
    called `apply_functors`. This is a class template that has a single template argument.
    This template argument is a typelist. A possible implementation for the `apply_functors`
    functor is shown next:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`upgrade_unit`函数接受一个`game_unit`对象，并将`upgrade_defense`和`upgrade_attack`函数对象应用于它。为此，它使用另一个名为`apply_functors`的辅助函数对象。这是一个只有一个模板参数的类模板。这个模板参数是一个typelist。`apply_functors`函数对象的可能实现如下所示：
- en: '[PRE1048]'
  id: totrans-1288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1048]'
- en: '[PRE1049]'
  id: totrans-1289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1049]'
- en: '[PRE1050]'
  id: totrans-1290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1050]'
- en: '[PRE1051]'
  id: totrans-1291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1051]'
- en: '[PRE1052]'
  id: totrans-1292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1052]'
- en: '[PRE1053]'
  id: totrans-1293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1053]'
- en: '[PRE1054]'
  id: totrans-1294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1054]'
- en: '[PRE1055]'
  id: totrans-1295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1055]'
- en: '[PRE1056]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1056]'
- en: '[PRE1057]'
  id: totrans-1297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1057]'
- en: '[PRE1058]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1058]'
- en: '[PRE1059]'
  id: totrans-1299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1059]'
- en: '[PRE1060]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1060]'
- en: '[PRE1061]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1061]'
- en: '[PRE1062]'
  id: totrans-1302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1062]'
- en: '[PRE1063]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1063]'
- en: '[PRE1064]'
  id: totrans-1304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1064]'
- en: '[PRE1065]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1065]'
- en: '[PRE1066]'
  id: totrans-1306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1066]'
- en: '[PRE1067]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1067]'
- en: '[PRE1068]'
  id: totrans-1308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1068]'
- en: '[PRE1069]'
  id: totrans-1309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1069]'
- en: '[PRE1070]'
  id: totrans-1310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1070]'
- en: 'This class template has an overloaded call operator and two private helper
    functions:'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类模板有一个重载的调用操作符和两个私有辅助函数：
- en: '`apply`, which applies the functor from the `I` index of the typelist to a
    `game_unit` object.'
  id: totrans-1312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply`，它将typelist中的`I`索引处的函数对象应用于`game_unit`对象。'
- en: '`apply_all`, which applies all the functors in the typelist to a `game_unit`
    object by using the `apply` function in a pack expansion.'
  id: totrans-1313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply_all`，它通过使用包展开中的`apply`函数，将typelist中的所有函数对象应用于`game_unit`对象。'
- en: 'We can use the `upgrade_unit` function as follows:'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用`upgrade_unit`函数：
- en: '[PRE1071]'
  id: totrans-1315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1071]'
- en: '[PRE1072]'
  id: totrans-1316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1072]'
- en: '[PRE1073]'
  id: totrans-1317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1073]'
- en: '[PRE1074]'
  id: totrans-1318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1074]'
- en: '[PRE1075]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1075]'
- en: '[PRE1076]'
  id: totrans-1320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1076]'
- en: If you paid attention to the implementation of the `apply_functors` class template,
    you will have noticed the use of the `at_t` alias template and the `length_v`
    variable template, which we have not defined yet. We will look at these two and
    more in the next section.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了`apply_functors`类模板的实现，你会注意到使用了`at_t`别名模板和`length_v`变量模板，这些我们尚未定义。我们将在下一节中探讨这两个以及更多内容。
- en: Implementing operations on typelists
  id: totrans-1322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现类型列表的操作
- en: 'A typelist is a type that only carries valuable information at compile-time.
    A typelist acts as a container for other types. When you work with typelists,
    you need to perform various operations, such as counting the types in the list,
    accessing a type at a given index, adding a type at the beginning or the end of
    the list, or the reverse operation, removing a type from the beginning or the
    end of the list, and so on. If you think about it, these are typical operations
    you’d use with a container such as a vector. Therefore, in this section, we’ll
    discuss how to implement the following operations:'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 类型列表是一种仅在编译时携带有价值信息的类型。类型列表充当其他类型的容器。当你与类型列表一起工作时，你需要执行各种操作，例如计算列表中的类型数量、访问给定索引处的类型、在列表开头或末尾添加类型，或者反向操作，从列表开头或末尾移除类型等。如果你仔细想想，这些是在使用如向量这样的容器时通常会使用的典型操作。因此，在本节中，我们将讨论如何实现以下操作：
- en: '`size`: Determines the size of the list'
  id: totrans-1324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`：确定列表的大小'
- en: '`front`: Retrieves the first type in the list'
  id: totrans-1325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`front`：检索列表中的第一个类型'
- en: '`back`: Retrieves the last type in the list'
  id: totrans-1326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`back`：检索列表中的最后一个类型'
- en: '`at`: Retrieves the type at the specified index in the list'
  id: totrans-1327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`at`：检索列表中指定索引处的类型'
- en: '`push_back`: Adds a new type to the end of the list'
  id: totrans-1328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push_back`：将新类型添加到列表的末尾'
- en: '`push_front`: Adds a new type to the beginning of the list'
  id: totrans-1329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push_front`：将新类型添加到列表的开头'
- en: '`pop_back`: Removes the type at the end of the list'
  id: totrans-1330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop_back`：移除列表末尾的类型'
- en: '`pop_front`: Removes the type at the beginning of the list'
  id: totrans-1331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop_front`：移除列表开头的类型'
- en: A typelist is a compile-time construct. It is an immutable entity. Therefore,
    the operations that add or remove a type do not modify a typelist but create a
    new one. We’ll see that shortly. But first, let’s start with the simplest operation,
    which is retrieving the size of a typelist.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 类型列表是一个编译时构造。它是一个不可变实体。因此，添加或移除类型的操作不会修改类型列表，而是创建一个新的类型列表。我们很快就会看到这一点。但首先，让我们从最简单的操作开始，即检索类型列表的大小。
- en: 'To avoid naming confusion with the `size_t` type, we’ll call this operation
    `lenght_t`, and not `size_t`. We can define this as follows:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免与`size_t`类型命名混淆，我们将把这个操作称为`lenght_t`，而不是`size_t`。我们可以这样定义它：
- en: '[PRE1077]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1077]'
- en: '[PRE1078]'
  id: totrans-1335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1078]'
- en: '[PRE1079]'
  id: totrans-1336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1079]'
- en: '[PRE1080]'
  id: totrans-1337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1080]'
- en: '[PRE1081]'
  id: totrans-1338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1081]'
- en: '[PRE1082]'
  id: totrans-1339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1082]'
- en: '[PRE1083]'
  id: totrans-1340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1083]'
- en: '[PRE1084]'
  id: totrans-1341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1084]'
- en: '[PRE1085]'
  id: totrans-1342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1085]'
- en: '[PRE1086]'
  id: totrans-1343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1086]'
- en: '[PRE1087]'
  id: totrans-1344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1087]'
- en: '[PRE1088]'
  id: totrans-1345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1088]'
- en: '[PRE1089]'
  id: totrans-1346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1089]'
- en: '[PRE1090]'
  id: totrans-1347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1090]'
- en: '[PRE1091]'
  id: totrans-1348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1091]'
- en: '[PRE1092]'
  id: totrans-1349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1092]'
- en: In the `detail` namespace, we have a class template called `length`. There is
    a primary template (without a definition) and a specialization for a typelist.
    This specialization defines a member type called `type` that is a `std::integral_constant`,
    with a value of the type `std::size_t` representing the number of arguments in
    the parameter pack `Ts`. Furthermore, we have an alias template, `length_h`, that
    is an alias for the member called `type` of the `length` class template. Finally,
    we have a variable template called `length_v` that is initialized from the value
    of the `std::integral_constant` member, which is also called `value`.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 在`detail`命名空间中，我们有一个名为`length`的类模板。有一个主要模板（没有定义）和一个针对类型列表的特化。这个特化定义了一个名为`type`的成员类型，它是一个`std::integral_constant`，其值为表示参数包`Ts`中参数数量的`std::size_t`类型。此外，我们还有一个别名模板`length_h`，它是`length`类模板中名为`type`的成员的别名。最后，我们有一个变量模板`length_v`，它从名为`value`的`std::integral_constant`成员的值初始化，这个值也被称为`value`。
- en: 'We can verify the correctness of this implementation with the help of some
    `static_assert` statements, as follows:'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些`static_assert`语句来验证此实现的正确性，如下所示：
- en: '[PRE1093]'
  id: totrans-1352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1093]'
- en: '[PRE1094]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1094]'
- en: '[PRE1095]'
  id: totrans-1354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1095]'
- en: '[PRE1096]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1096]'
- en: '[PRE1097]'
  id: totrans-1356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1097]'
- en: 'The approach used here will be used for defining all the other operations.
    Let’s look next at accessing the front type in the list. This is shown in the
    next listing:'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的方法将被用于定义所有其他操作。接下来，让我们看看如何访问列表中的前一个类型。这将在下一个列表中展示：
- en: '[PRE1098]'
  id: totrans-1358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1098]'
- en: '[PRE1099]'
  id: totrans-1359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1099]'
- en: '[PRE1100]'
  id: totrans-1360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1100]'
- en: '[PRE1101]'
  id: totrans-1361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1101]'
- en: '[PRE1102]'
  id: totrans-1362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1102]'
- en: '[PRE1103]'
  id: totrans-1363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1103]'
- en: '[PRE1104]'
  id: totrans-1364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1104]'
- en: '[PRE1105]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1105]'
- en: '[PRE1106]'
  id: totrans-1366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1106]'
- en: '[PRE1107]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1107]'
- en: '[PRE1108]'
  id: totrans-1368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1108]'
- en: '[PRE1109]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1109]'
- en: '[PRE1110]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1110]'
- en: '[PRE1111]'
  id: totrans-1371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1111]'
- en: '[PRE1112]'
  id: totrans-1372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1112]'
- en: '[PRE1113]'
  id: totrans-1373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1113]'
- en: '[PRE1114]'
  id: totrans-1374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1114]'
- en: '[PRE1115]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1115]'
- en: '[PRE1116]'
  id: totrans-1376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1116]'
- en: 'In the `detail` namespace, we have a class template called `front_type`. Again,
    we declared a primary template but without a definition. However, we have two
    specializations: one for a typelist that contains at least one type and one for
    an empty typelist. In the former case, the `type` member is aliasing the first
    type in the typelist. In the latter case, there is no type so the `type` member
    is aliasing a type called `empty_type`. This is an empty class whose only role
    is to act as the return type for operations where no type is to be returned. We
    can verify the implementation as follows:'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 在`detail`命名空间中，我们有一个名为`front_type`的类模板。同样，我们声明了一个主模板但没有定义。然而，我们有两个特化：一个用于包含至少一个类型的类型列表，另一个用于空类型列表。在前者的情况下，`type`成员是对类型列表中第一个类型的别名。在后一种情况下，没有类型，因此`type`成员是对名为`empty_type`的类型的别名。这是一个空类，其唯一的作用是在不需要返回类型的情况下作为操作的返回类型。我们可以如下验证实现：
- en: '[PRE1117]'
  id: totrans-1378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1117]'
- en: '[PRE1118]'
  id: totrans-1379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1118]'
- en: '[PRE1119]'
  id: totrans-1380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1119]'
- en: '[PRE1120]'
  id: totrans-1381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1120]'
- en: '[PRE1121]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1121]'
- en: '[PRE1122]'
  id: totrans-1383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1122]'
- en: '[PRE1123]'
  id: totrans-1384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1123]'
- en: 'If you expect the implementation of the operation for accessing the back type
    to be similar, you will not be disappointed. Here is how it looks:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你期望访问后类型操作的实现与之前相似，你不会失望。以下是它的样子：
- en: '[PRE1124]'
  id: totrans-1386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1124]'
- en: '[PRE1125]'
  id: totrans-1387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1125]'
- en: '[PRE1126]'
  id: totrans-1388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1126]'
- en: '[PRE1127]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1127]'
- en: '[PRE1128]'
  id: totrans-1390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1128]'
- en: '[PRE1129]'
  id: totrans-1391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1129]'
- en: '[PRE1130]'
  id: totrans-1392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1130]'
- en: '[PRE1131]'
  id: totrans-1393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1131]'
- en: '[PRE1132]'
  id: totrans-1394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1132]'
- en: '[PRE1133]'
  id: totrans-1395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1133]'
- en: '[PRE1134]'
  id: totrans-1396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1134]'
- en: '[PRE1135]'
  id: totrans-1397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1135]'
- en: '[PRE1136]'
  id: totrans-1398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1136]'
- en: '[PRE1137]'
  id: totrans-1399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1137]'
- en: '[PRE1138]'
  id: totrans-1400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1138]'
- en: '[PRE1139]'
  id: totrans-1401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1139]'
- en: '[PRE1140]'
  id: totrans-1402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1140]'
- en: '[PRE1141]'
  id: totrans-1403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1141]'
- en: '[PRE1142]'
  id: totrans-1404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1142]'
- en: '[PRE1143]'
  id: totrans-1405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1143]'
- en: '[PRE1144]'
  id: totrans-1406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1144]'
- en: '[PRE1145]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1145]'
- en: '[PRE1146]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1146]'
- en: '[PRE1147]'
  id: totrans-1409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1147]'
- en: 'The only significant difference with this implementation is that there are
    three specializations of the `back_type` class template and there is recursion
    involved. The three specializations are for an empty typelist, a typelist with
    a single type, and a typelist with two or more types. The last one (which is actually
    the first in the previous listing) is using template recursion in the definition
    of its `type` member. We have seen how this works in [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064),
    *Advanced Template Concepts*. To ensure we implemented the operation the right
    way we can do some validation as follows:'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 与此实现相比，唯一的显著区别是`back_type`类模板有三个特化，并且涉及到递归。这三个特化分别用于空类型列表、只有一个类型的类型列表以及包含两个或更多类型的类型列表。最后一个（实际上是在前面的列表中的第一个）在其`type`成员的定义中使用了模板递归。我们已经在[*第4章*](B18367_04_ePub.xhtml#_idTextAnchor064)中看到了它是如何工作的，*高级模板概念*。为了确保我们正确实现了操作，我们可以进行以下验证：
- en: '[PRE1148]'
  id: totrans-1411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1148]'
- en: '[PRE1149]'
  id: totrans-1412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1149]'
- en: '[PRE1150]'
  id: totrans-1413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1150]'
- en: '[PRE1151]'
  id: totrans-1414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1151]'
- en: '[PRE1152]'
  id: totrans-1415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1152]'
- en: '[PRE1153]'
  id: totrans-1416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1153]'
- en: '[PRE1154]'
  id: totrans-1417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1154]'
- en: 'Apart from accessing the first and last type in a typelist, we are also interested
    in accessing a type at any given index. However, the implementation of this operation
    is less trivial. Let’s see it first:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 除了访问类型列表中的第一个和最后一个类型外，我们还对在任意给定索引处访问类型感兴趣。然而，这个操作的实现并不简单。让我们先看看它：
- en: '[PRE1155]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1155]'
- en: '[PRE1156]'
  id: totrans-1420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1156]'
- en: '[PRE1157]'
  id: totrans-1421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1157]'
- en: '[PRE1158]'
  id: totrans-1422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1158]'
- en: '[PRE1159]'
  id: totrans-1423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1159]'
- en: '[PRE1160]'
  id: totrans-1424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1160]'
- en: '[PRE1161]'
  id: totrans-1425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1161]'
- en: '[PRE1162]'
  id: totrans-1426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1162]'
- en: '[PRE1163]'
  id: totrans-1427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1163]'
- en: '[PRE1164]'
  id: totrans-1428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1164]'
- en: '[PRE1165]'
  id: totrans-1429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1165]'
- en: '[PRE1166]'
  id: totrans-1430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1166]'
- en: '[PRE1167]'
  id: totrans-1431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1167]'
- en: '[PRE1168]'
  id: totrans-1432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1168]'
- en: '[PRE1169]'
  id: totrans-1433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1169]'
- en: '[PRE1170]'
  id: totrans-1434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1170]'
- en: '[PRE1171]'
  id: totrans-1435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1171]'
- en: '[PRE1172]'
  id: totrans-1436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1172]'
- en: '[PRE1173]'
  id: totrans-1437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1173]'
- en: '[PRE1174]'
  id: totrans-1438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1174]'
- en: '[PRE1175]'
  id: totrans-1439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1175]'
- en: '[PRE1176]'
  id: totrans-1440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1176]'
- en: '[PRE1177]'
  id: totrans-1441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1177]'
- en: 'The `at_t` alias template has two template arguments: an index and a typelist.
    The `at_t` template is an alias for the member type of the `at_type` class template
    from the `detail` namespace. The primary template has three template parameters:
    an index representing the position of the type to retrieve (`I`), another index
    representing the current position in the iteration of the types in the list (`N`),
    and a typelist (`TL`).'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: '`at_t`别名模板有两个模板参数：一个索引和一个类型列表。`at_t`模板是`detail`命名空间中`at_type`类模板的成员类型的别名。主模板有三个模板参数：一个表示要检索的类型位置的索引（`I`），另一个表示在列表中类型迭代当前位置的索引（`N`），以及一个类型列表（`TL`）。'
- en: 'There are two specializations of this primary template: one for a typelist
    that contains at least one type and one for an empty typelist. In the latter case,
    the member `type` is aliasing the `empty_type` type. In the former case, the member
    `type` is defined with the help of the `std::conditional_t` metafunction. This
    defines its member `type` as the first type (`T`) when `I == N`, or as the second
    type (`typename at_type<I, N + 1, TL<Ts...>>::type`) when this condition is false.
    Here, again, we employ template recursion, incrementing the value of the second
    index with each iteration. The following `static_assert` statements validate the
    implementation:'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主模板有两个特化：一个用于包含至少一个类型的类型列表，另一个用于空类型列表。在后一种情况下，成员`type`是对`empty_type`类型的别名。在前一种情况下，成员`type`通过`std::conditional_t`元函数定义。这定义了它的成员`type`，当`I
    == N`时为第一个类型（`T`），当这个条件不成立时为`typename at_type<I, N + 1, TL<Ts...>>::type`。在这里，我们又使用了模板递归，每次迭代都会增加第二个索引的值。下面的`static_assert`语句验证了实现：
- en: '[PRE1178]'
  id: totrans-1444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1178]'
- en: '[PRE1179]'
  id: totrans-1445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1179]'
- en: '[PRE1180]'
  id: totrans-1446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1180]'
- en: '[PRE1181]'
  id: totrans-1447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1181]'
- en: '[PRE1182]'
  id: totrans-1448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1182]'
- en: '[PRE1183]'
  id: totrans-1449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1183]'
- en: '[PRE1184]'
  id: totrans-1450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1184]'
- en: '[PRE1185]'
  id: totrans-1451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1185]'
- en: '[PRE1186]'
  id: totrans-1452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1186]'
- en: '[PRE1187]'
  id: totrans-1453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1187]'
- en: '[PRE1188]'
  id: totrans-1454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1188]'
- en: '[PRE1189]'
  id: totrans-1455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1189]'
- en: '[PRE1190]'
  id: totrans-1456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1190]'
- en: '[PRE1191]'
  id: totrans-1457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1191]'
- en: '[PRE1192]'
  id: totrans-1458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1192]'
- en: '[PRE1193]'
  id: totrans-1459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1193]'
- en: '[PRE1194]'
  id: totrans-1460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1194]'
- en: '[PRE1195]'
  id: totrans-1461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1195]'
- en: '[PRE1196]'
  id: totrans-1462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1196]'
- en: 'The next category of operations to implement is adding a type to the beginning
    and the end of a typelist. We call these `push_back_t` and `push_front_t` and
    their definitions are as follows:'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 需要实现的下一个操作类别是在类型列表的开始和结束处添加一个类型。我们称这些为`push_back_t`和`push_front_t`，它们的定义如下：
- en: '[PRE1197]'
  id: totrans-1464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1197]'
- en: '[PRE1198]'
  id: totrans-1465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1198]'
- en: '[PRE1199]'
  id: totrans-1466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1199]'
- en: '[PRE1200]'
  id: totrans-1467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1200]'
- en: '[PRE1201]'
  id: totrans-1468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1201]'
- en: '[PRE1202]'
  id: totrans-1469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1202]'
- en: '[PRE1203]'
  id: totrans-1470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1203]'
- en: '[PRE1204]'
  id: totrans-1471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1204]'
- en: '[PRE1205]'
  id: totrans-1472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1205]'
- en: '[PRE1206]'
  id: totrans-1473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1206]'
- en: '[PRE1207]'
  id: totrans-1474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1207]'
- en: '[PRE1208]'
  id: totrans-1475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1208]'
- en: '[PRE1209]'
  id: totrans-1476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1209]'
- en: '[PRE1210]'
  id: totrans-1477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1210]'
- en: '[PRE1211]'
  id: totrans-1478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1211]'
- en: '[PRE1212]'
  id: totrans-1479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1212]'
- en: '[PRE1213]'
  id: totrans-1480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1213]'
- en: '[PRE1214]'
  id: totrans-1481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1214]'
- en: '[PRE1215]'
  id: totrans-1482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1215]'
- en: '[PRE1216]'
  id: totrans-1483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1216]'
- en: '[PRE1217]'
  id: totrans-1484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1217]'
- en: '[PRE1218]'
  id: totrans-1485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1218]'
- en: '[PRE1219]'
  id: totrans-1486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1219]'
- en: '[PRE1220]'
  id: totrans-1487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1220]'
- en: '[PRE1221]'
  id: totrans-1488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1221]'
- en: 'Based on what we have seen so far with the previous operations, these should
    be straightforward to understand. The opposite operations, when we remove the
    first or last type from a typelist, are more complex though. The first one, `pop_front_t`,
    looks as follows:'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前看到的操作，这些应该很容易理解。相反的操作，当我们从一个 typelist 中移除第一个或最后一个类型时，更为复杂。第一个，`pop_front_t`，看起来如下：
- en: '[PRE1222]'
  id: totrans-1490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1222]'
- en: '[PRE1223]'
  id: totrans-1491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1223]'
- en: '[PRE1224]'
  id: totrans-1492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1224]'
- en: '[PRE1225]'
  id: totrans-1493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1225]'
- en: '[PRE1226]'
  id: totrans-1494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1226]'
- en: '[PRE1227]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1227]'
- en: '[PRE1228]'
  id: totrans-1496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1228]'
- en: '[PRE1229]'
  id: totrans-1497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1229]'
- en: '[PRE1230]'
  id: totrans-1498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1230]'
- en: '[PRE1231]'
  id: totrans-1499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1231]'
- en: '[PRE1232]'
  id: totrans-1500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1232]'
- en: '[PRE1233]'
  id: totrans-1501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1233]'
- en: '[PRE1234]'
  id: totrans-1502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1234]'
- en: '[PRE1235]'
  id: totrans-1503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1235]'
- en: '[PRE1236]'
  id: totrans-1504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1236]'
- en: '[PRE1237]'
  id: totrans-1505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1237]'
- en: '[PRE1238]'
  id: totrans-1506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1238]'
- en: '[PRE1239]'
  id: totrans-1507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1239]'
- en: '[PRE1240]'
  id: totrans-1508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1240]'
- en: 'We have the primary template, `pop_front_type`, and two specializations: the
    first for a typelist with at least one type, and the second for an empty typelist.
    The latter defines the member `type` as an empty list; the former defines the
    member `type` as a typelist with the tail composed from the typelist argument.'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有主要的模板 `pop_front_type` 和两个特化：第一个是为至少包含一个类型的 typelist，第二个是为空 typelist。后者将成员
    `type` 定义为一个空列表；前者将成员 `type` 定义为一个由类型列表参数组成的尾部的 typelist。
- en: 'The last operation, removing the last type in a typelist, called `pop_back_t`,
    is implemented as follows:'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个操作，从 typelist 中移除最后一个类型，称为 `pop_back_t`，实现如下：
- en: '[PRE1241]'
  id: totrans-1511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1241]'
- en: '[PRE1242]'
  id: totrans-1512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1242]'
- en: '[PRE1243]'
  id: totrans-1513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1243]'
- en: '[PRE1244]'
  id: totrans-1514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1244]'
- en: '[PRE1245]'
  id: totrans-1515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1245]'
- en: '[PRE1246]'
  id: totrans-1516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1246]'
- en: '[PRE1247]'
  id: totrans-1517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1247]'
- en: '[PRE1248]'
  id: totrans-1518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1248]'
- en: '[PRE1249]'
  id: totrans-1519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1249]'
- en: '[PRE1250]'
  id: totrans-1520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1250]'
- en: '[PRE1251]'
  id: totrans-1521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1251]'
- en: '[PRE1252]'
  id: totrans-1522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1252]'
- en: '[PRE1253]'
  id: totrans-1523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1253]'
- en: '[PRE1254]'
  id: totrans-1524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1254]'
- en: '[PRE1255]'
  id: totrans-1525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1255]'
- en: '[PRE1256]'
  id: totrans-1526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1256]'
- en: '[PRE1257]'
  id: totrans-1527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1257]'
- en: '[PRE1258]'
  id: totrans-1528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1258]'
- en: '[PRE1259]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1259]'
- en: '[PRE1260]'
  id: totrans-1530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1260]'
- en: '[PRE1261]'
  id: totrans-1531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1261]'
- en: '[PRE1262]'
  id: totrans-1532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1262]'
- en: '[PRE1263]'
  id: totrans-1533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1263]'
- en: '[PRE1264]'
  id: totrans-1534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1264]'
- en: '[PRE1265]'
  id: totrans-1535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1265]'
- en: '[PRE1266]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1266]'
- en: '[PRE1267]'
  id: totrans-1537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1267]'
- en: '[PRE1268]'
  id: totrans-1538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1268]'
- en: '[PRE1269]'
  id: totrans-1539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1269]'
- en: '[PRE1270]'
  id: totrans-1540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1270]'
- en: '[PRE1271]'
  id: totrans-1541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1271]'
- en: '[PRE1272]'
  id: totrans-1542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1272]'
- en: '[PRE1273]'
  id: totrans-1543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1273]'
- en: '[PRE1274]'
  id: totrans-1544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1274]'
- en: '[PRE1275]'
  id: totrans-1545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1275]'
- en: '[PRE1276]'
  id: totrans-1546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1276]'
- en: For implementing this operation, we need to start with a typelist and recursively
    construct another typelist, element by element, until we get to the last type
    in the input typelist, which should be omitted. For this, we use a counter that
    tells us how many times we iterated the typelist.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个操作，我们需要从一个 typelist 开始，递归地逐个元素地构建另一个 typelist，直到我们到达输入 typelist 的最后一个类型，这个类型应该被省略。为此，我们使用一个计数器来告诉我们我们迭代
    typelist 的次数。
- en: 'This is initiated with the size of the typelist minus one and we need to stop
    when we reach zero. For this reason, the `pop_back_type` class template has four
    specializations, one for the general case when we are at some iteration in the
    typelist, two for the case when the counter reached zero, and one for the case
    when the counter reached the value minus one. This is the case when the initial
    typelist was empty (therefore, `length_t<TL> - 1` would evaluate to -1). Here
    are some asserts that show how to use `pop_back_t` and validate its correctness:'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 typelist 的大小减一开始的，我们需要在达到零时停止。因此，`pop_back_type` 类模板有四个特化，一个用于我们在 typelist
    中的某个迭代时的通用情况，两个用于计数器达到零的情况，一个用于计数器达到值减一的情况。这是初始 typelist 为空的情况（因此，`length_t<TL>
    - 1` 将评估为 -1）。以下是一些断言，展示了如何使用 `pop_back_t` 并验证其正确性：
- en: '[PRE1277]'
  id: totrans-1549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1277]'
- en: '[PRE1278]'
  id: totrans-1550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1278]'
- en: '[PRE1279]'
  id: totrans-1551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1279]'
- en: '[PRE1280]'
  id: totrans-1552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1280]'
- en: '[PRE1281]'
  id: totrans-1553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1281]'
- en: '[PRE1282]'
  id: totrans-1554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1282]'
- en: '[PRE1283]'
  id: totrans-1555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1283]'
- en: '[PRE1284]'
  id: totrans-1556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1284]'
- en: '[PRE1285]'
  id: totrans-1557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1285]'
- en: '[PRE1286]'
  id: totrans-1558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1286]'
- en: With these defined, we have provided a series of operations that are necessary
    for working with typelists. The `length_t` and `at_t` operations were used in
    the example shown earlier with the execution of functors on `game_unit` objects.
    Hopefully, this section provided a helpful introduction to typelists and enabled
    you to understand not only how they are implemented but also how they can be used.
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些定义的基础上，我们提供了一系列必要的操作，用于处理 typelists。`length_t` 和 `at_t` 操作在前面示例中用于在 `game_unit`
    对象上执行函数对象。希望这一节为 typelists 提供了一个有用的介绍，并使你不仅能够理解它们的实现方式，还能理解它们的使用方法。
- en: Summary
  id: totrans-1560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was dedicated to learning various metaprogramming techniques. We
    started by understanding the differences between dynamic and static polymorphism
    and then looked at the curiously recurring template pattern for implementing the
    latter.
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于学习各种元编程技术。我们首先理解了动态多态和静态多态之间的区别，然后探讨了实现静态多态的有趣重复出现的模板模式。
- en: Mixins was another pattern that has a similar purpose as CRTP—adding functionality
    to classes, but unlike CRTP, without modifying them. The third technique we learned
    about was type erasure, which allows similar types that are unrelated to be treated
    generically. In the second part, we learned about tag dispatching – which allow
    us to select between overloads at compile time, and expression templates – which
    enable lazy evaluation of a computation at compile-time to avoid inefficient operations
    that occur at runtime. Lastly, we explored typelists and learned how they are
    used and how we can implement operations with them.
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: Mixins 是另一种具有与 CRTP 相似目的的图案——向类添加功能，但与 CRTP 不同，它不会修改它们。我们学到的第三种技术是类型擦除，它允许处理与类型无关的类似类型。在第二部分，我们学习了标签分派——允许我们在编译时选择重载，以及表达式模板——允许在编译时进行延迟计算，以避免在运行时发生低效的操作。最后，我们探讨了
    typelists，并学习了它们的使用方法以及如何使用它们实现操作。
- en: In the next chapter, we will look at the core pillars of the standard template
    library, containers, iterators, and algorithms.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨标准模板库的核心支柱，容器、迭代器和算法。
- en: Questions
  id: totrans-1564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the typical problems that can be solved by CRTP?
  id: totrans-1565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CRTP 可以解决哪些典型问题？
- en: What are mixins and what is their purpose?
  id: totrans-1566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mixin 是什么？它们的目的何在？
- en: What is type erasure?
  id: totrans-1567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型擦除是什么？
- en: What is tag dispatching and what are its alternatives?
  id: totrans-1568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标签调度是什么？它的替代方案有哪些？
- en: What are expression templates and where are they used?
  id: totrans-1569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式模板是什么？它们在哪里被使用？
- en: Further reading
  id: totrans-1570
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* – Erich Gamma,
    Richard Helm, Ralph Johnson, John Vlissides, p. 163, Addison-Wesley'
  id: totrans-1571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设计模式：可重用面向对象软件的元素* – Erich Gamma，Richard Helm，Ralph Johnson，John Vlissides，p.
    163，Addison-Wesley'
- en: '*Modern C++ Design: Generic Programming and Design Patterns Applied* – Andrei
    Alexandrescu, Addison-Wesley Professional'
  id: totrans-1572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*现代 C++ 设计：泛型编程和设计模式的应用* – Andrei Alexandrescu，Addison-Wesley Professional'
- en: '*Mixin-Based Programming in C++* – Yannis Smaragdakis, Don Batory, [https://yanniss.github.io/practical-fmtd.pdf](https://yanniss.github.io/practical-fmtd.pdf%0D)'
  id: totrans-1573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于 Mixin 的 C++ 编程* – Yannis Smaragdakis，Don Batory，[https://yanniss.github.io/practical-fmtd.pdf](https://yanniss.github.io/practical-fmtd.pdf%0D)'
- en: '*Curiously Recurring Template Patterns* – James Coplien, [http://sites.google.com/a/gertrudandcope.com/info/Publications/InheritedTemplate.pdf](http://sites.google.com/a/gertrudandcope.com/info/Publications/InheritedTemplate.pdf%0D)'
  id: totrans-1574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*奇特重复的模板模式* – James Coplien，[http://sites.google.com/a/gertrudandcope.com/info/Publications/InheritedTemplate.pdf](http://sites.google.com/a/gertrudandcope.com/info/Publications/InheritedTemplate.pdf%0D)'
- en: '*Mixin Classes: The Yang of the CRTP* – Jonathan Boccara, [https://www.fluentcpp.com/2017/12/12/mixin-classes-yang-crtp/](https://www.fluentcpp.com/2017/12/12/mixin-classes-yang-crtp/%0D)'
  id: totrans-1575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Mixin 类：CRTP 的阳刚之力* – Jonathan Boccara，[https://www.fluentcpp.com/2017/12/12/mixin-classes-yang-crtp/](https://www.fluentcpp.com/2017/12/12/mixin-classes-yang-crtp/%0D)'
- en: '*What the Curiously Recurring Template Pattern can bring to your code* – Jonathan
    Boccara, [https://www.fluentcpp.com/2017/05/16/what-the-crtp-brings-to-code/](https://www.fluentcpp.com/2017/05/16/what-the-crtp-brings-to-code/%0D)'
  id: totrans-1576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*奇特重复的模板模式能给你的代码带来什么* – Jonathan Boccara，[https://www.fluentcpp.com/2017/05/16/what-the-crtp-brings-to-code/](https://www.fluentcpp.com/2017/05/16/what-the-crtp-brings-to-code/%0D)'
- en: '*Combining Static and Dynamic Polymorphism with C++ Mixin classes* – Michael
    Afanasiev, [https://michael-afanasiev.github.io/2016/08/03/Combining-Static-and-Dynamic-Polymorphism-with-C++-Template-Mixins.html](https://michael-afanasiev.github.io/2016/08/03/Combining-Static-and-Dynamic-Polymorphism-with-C++-Template-Mixins.html%0D)'
  id: totrans-1577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 C++ Mixin 类结合静态和动态多态* – Michael Afanasiev，[https://michael-afanasiev.github.io/2016/08/03/Combining-Static-and-Dynamic-Polymorphism-with-C++-Template-Mixins.html](https://michael-afanasiev.github.io/2016/08/03/Combining-Static-and-Dynamic-Polymorphism-with-C++-Template-Mixins.html%0D)'
- en: '*Why C++ is not just an Object-Oriented Programming Language* – Bjarne Stroustrup,
    [https://www.stroustrup.com/oopsla.pdf](https://www.stroustrup.com/oopsla.pdf%0D)'
  id: totrans-1578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为什么 C++ 不仅仅是一种面向对象编程语言* – Bjarne Stroustrup，[https://www.stroustrup.com/oopsla.pdf](https://www.stroustrup.com/oopsla.pdf%0D)'
- en: '`enable_shared_from_this` *- overview, examples, and internals* – Hitesh Kumar,
    [https://www.nextptr.com/tutorial/ta1414193955/enable_shared_from_this-overview-examples-and-internals](https://www.nextptr.com/tutorial/ta1414193955/enable_shared_from_this-overview-examples-and-internals%0D)'
  id: totrans-1579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enable_shared_from_this` *- 概述、示例和内部机制* – Hitesh Kumar，[https://www.nextptr.com/tutorial/ta1414193955/enable_shared_from_this-overview-examples-and-internals](https://www.nextptr.com/tutorial/ta1414193955/enable_shared_from_this-overview-examples-and-internals%0D)'
- en: '*Tag dispatch versus concept overloading* – Arthur O’Dwyer, [https://quuxplusone.github.io/blog/2021/06/07/tag-dispatch-and-concept-overloading/](https://quuxplusone.github.io/blog/2021/06/07/tag-dispatch-and-concept-overloading/%0D)'
  id: totrans-1580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标签调度与概念重载的比较* – Arthur O’Dwyer，[https://quuxplusone.github.io/blog/2021/06/07/tag-dispatch-and-concept-overloading/](https://quuxplusone.github.io/blog/2021/06/07/tag-dispatch-and-concept-overloading/%0D)'
- en: '*C++ Expression Templates: An Introduction to the Principles of Expression
    Templates* – Klaus Kreft and Angelika Langer, [http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm](http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm%0D)'
  id: totrans-1581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++ 表达式模板：表达式模板原理简介* – Klaus Kreft 和 Angelika Langer，[http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm](http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm%0D)'
- en: '*We don’t need no stinking expression templates*, [https://gieseanw.wordpress.com/2019/10/20/we-dont-need-no-stinking-expression-templates/](https://gieseanw.wordpress.com/2019/10/20/we-dont-need-no-stinking-expression-templates/)'
  id: totrans-1582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们不需要那些令人讨厌的表达式模板*，[https://gieseanw.wordpress.com/2019/10/20/we-dont-need-no-stinking-expression-templates/](https://gieseanw.wordpress.com/2019/10/20/we-dont-need-no-stinking-expression-templates/)'
- en: '*Generic Programming: Typelists and Applications* – Andrei Alexandrescu, [https://www.drdobbs.com/generic-programmingtypelists-and-applica/184403813](https://www.drdobbs.com/generic-programmingtypelists-and-applica/184403813%0D)'
  id: totrans-1583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*泛型编程：类型列表与应用* – 安德烈·亚历山德鲁斯库，[https://www.drdobbs.com/generic-programmingtypelists-and-applica/184403813](https://www.drdobbs.com/generic-programmingtypelists-and-applica/184403813%0D)'
- en: '*Of type lists and type switches* – Bastian Rieck, [https://bastian.rieck.me/blog/posts/2015/type_lists_and_switches/](https://bastian.rieck.me/blog/posts/2015/type_lists_and_switches/)'
  id: totrans-1584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类型列表和类型开关* – 巴斯蒂安·里克，[https://bastian.rieck.me/blog/posts/2015/type_lists_and_switches/](https://bastian.rieck.me/blog/posts/2015/type_lists_and_switches/)'
