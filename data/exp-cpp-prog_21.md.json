["```cpp\n        std::pair<int, int> divide_remainder(int dividend, int divisor);\n\n```", "```cpp\n        const auto result (divide_remainder(16, 3));\n        std::cout << \"16 / 3 is \" \n                  << result.first << \" with a remainder of \" \n                  << result.second << 'n';\n```", "```cpp\n auto [fraction, remainder] = divide_remainder(16, 3);\n        std::cout << \"16 / 3 is \" \n                  << fraction << \" with a remainder of \"       \n                  << remainder << 'n';\n```", "```cpp\n        std::tuple<std::string, \n                   std::chrono::system_clock::time_point, unsigned>\n        stock_info(const std::string &name);\n```", "```cpp\n const auto [name, valid_time, price] = stock_info(\"INTC\");\n```", "```cpp\n        struct employee {\n            unsigned id;\n            std::string name;\n            std::string role;\n            unsigned salary;\n        };\n```", "```cpp\n        int main()\n        {\n            std::vector<employee> employees {\n                /* Initialized from somewhere */};\n\n            for (const auto &[id, name, role, salary] : employees) {\n                std::cout << \"Name: \"   << name\n                          << \"Role: \"   << role\n                          << \"Salary: \" << salary << 'n';\n            }\n        }\n```", "```cpp\nauto [var1, var2, ...] = <pair, tuple, struct, or array expression>;\n```", "```cpp\nstd::tuple<int, float, long> tup {1, 2.0, 3};\nauto [a, b] = tup; // Does not work\n```", "```cpp\nerror: type 'std::tuple<int, float, long>' decomposes into 3 elements, but only 2 names were provided\nauto [a, b] = tup;\n```", "```cpp\nstd::map<std::string, size_t> animal_population {\n    {\"humans\",   7000000000},\n    {\"chickens\", 17863376000},\n    {\"camels\",   24246291},\n    {\"sheep\",    1086881528},\n    /* \u2026 */\n};\n\nfor (const auto &[species, count] : animal_population) {\n    std::cout << \"There are \" << count << \" \" << species \n              << \" on this planet.n\";\n}\n```", "```cpp\nint remainder;\nstd::tie(std::ignore, remainder) = divide_remainder(16, 5);\nstd::cout << \"16 % 5 is \" << remainder << 'n';\n```", "```cpp\nbool divide_remainder(int dividend, int divisor, \n                      int &fraction, int &remainder);\n\n```", "```cpp\nint fraction, remainder;\nconst bool success {divide_remainder(16, 3, fraction, remainder)};\nif (success) {\n    std::cout << \"16 / 3 is \" << fraction << \" with a remainder of \" \n              << remainder << 'n';\n}\n```", "```cpp\n       if (auto itr (character_map.find(c)); itr != character_map.end()) {\n           // *itr is valid. Do something with it.\n       } else {\n           // itr is the end-iterator. Don't dereference.\n       }\n       // itr is not available here at all\n\n```", "```cpp\n       switch (char c (getchar()); c) {\n           case 'a': move_left();  break;\n           case 's': move_back();  break;\n           case 'w': move_fwd();   break;\n           case 'd': move_right(); break;\n           case 'q': quit_game();  break;\n\n           case '0'...'9': select_tool('0' - c); break;\n\n           default:\n               std::cout << \"invalid input: \" << c << 'n';\n       }\n```", "```cpp\n{\n    auto var (init_value);\n    if (condition) {\n        // branch A. var is accessible\n    } else {\n        // branch B. var is accessible\n    }\n    // var is still accessible\n}\n```", "```cpp\nif (auto var (init_value); condition) {\n    // branch A. var is accessible\n} else {\n    // branch B. var is accessible\n}\n// var is not accessible any longer\n```", "```cpp\n{\n    auto var (init_value);\n    switch (var) {\n    case 1: ...\n    case 2: ...\n    ...\n    }\n    // var is still accessible\n}\n```", "```cpp\nswitch (auto var (init_value); var) {\ncase 1: ...\ncase 2: ...\n  ...\n}\n// var is not accessible any longer\n```", "```cpp\nif (std::lock_guard<std::mutex> lg {my_mutex}; some_condition) {\n    // Do something\n}\n```", "```cpp\nif (auto shared_pointer (weak_pointer.lock()); shared_pointer != nullptr) {\n    // Yes, the shared object does still exist\n} else {\n    // shared_pointer var is accessible, but a null pointer\n}\n// shared_pointer is not accessible any longer\n```", "```cpp\nif (DWORD exit_code; GetExitCodeProcess(process_handle, &exit_code)) {\n    std::cout << \"Exit code of process was: \" << exit_code << 'n';\n}\n// No useless exit_code variable outside the if-conditional\n```", "```cpp\n       // Three identical ways to initialize an int:\n       int x1 = 1;\n       int x2  {1};\n       int x3  (1);\n\n       std::vector<int> v1   {1, 2, 3}; // Vector with three ints: 1, 2, 3\n       std::vector<int> v2 = {1, 2, 3}; // same here\n       std::vector<int> v3   (10, 20);  // Vector with 10 ints, \n                                        // each have value 20\n```", "```cpp\n       auto v   {1};         // v is int\n       auto w   {1, 2};      // error: only single elements in direct \n                             // auto initialization allowed! (this is new)\n       auto x = {1};         // x is std::initializer_list<int>\n       auto y = {1, 2};      // y is std::initializer_list<int>\n       auto z = {1, 2, 3.0}; // error: Cannot deduce element type\n```", "```cpp\nstd::pair  my_pair  (123, \"abc\");       // std::pair<int, const char*>\nstd::tuple my_tuple (123, 12.3, \"abc\"); // std::tuple<int, double,\n                                        //            const char*>\n```", "```cpp\ntemplate <typename T1, typename T2, typename T3>\nclass my_wrapper {\n    T1 t1;\n    T2 t2;\n    T3 t3;\n\npublic:\n    explicit my_wrapper(T1 t1_, T2 t2_, T3 t3_) \n        : t1{t1_}, t2{t2_}, t3{t3_}\n    {}\n\n    /* \u2026 */\n};\n```", "```cpp\nmy_wrapper<int, double, const char *> wrapper {123, 1.23, \"abc\"};\n```", "```cpp\nmy_wrapper wrapper {123, 1.23, \"abc\"};\n```", "```cpp\nmy_wrapper<T1, T2, T3> make_wrapper(T1 t1, T2 t2, T3 t3)\n{\n    return {t1, t2, t3};\n}\n```", "```cpp\nauto wrapper (make_wrapper(123, 1.23, \"abc\"));\n```", "```cpp\ntemplate <typename T>\nstruct sum {\n    T value;\n\n    template <typename ... Ts>\n    sum(Ts&& ... values) : value{(values + ...)} {}\n};\n```", "```cpp\ntemplate <typename ... Ts>\nsum(Ts&& ... ts) -> sum<std::common_type_t<Ts...>>;\n```", "```cpp\nsum s          {1u, 2.0, 3, 4.0f};\nsum string_sum {std::string{\"abc\"}, \"def\"};\n\nstd::cout << s.value          << 'n'\n          << string_sum.value << 'n';\n```", "```cpp\n       template <typename T>\n       class addable\n       { \n           T val;\n\n       public:\n           addable(T v) : val{v} {}\n\n           template <typename U>\n           T add(U x) const {\n               return val + x;\n           }\n       };\n```", "```cpp\n       template <typename U>\n       T add(U x) \n       {\n           auto copy (val); // Get a copy of the vector member\n           for (auto &n : copy) { \n               n += x;\n           }\n           return copy;\n       }\n```", "```cpp\n       template <typename U>\n       T add(U x) const {\n           if constexpr (std::is_same_v<T, std::vector<U>>) {\n               auto copy (val);\n               for (auto &n : copy) { \n                   n += x;\n               }\n               return copy;\n           } else {\n               return val + x;\n           }\n       }\n\n```", "```cpp\n       addable<int>{1}.add(2);               // is 3\n       addable<float>{1.0}.add(2);           // is 3.0\n       addable<std::string>{\"aa\"}.add(\"bb\"); // is \"aabb\"\n\n       std::vector<int> v {1, 2, 3};\n       addable<std::vector<int>>{v}.add(10); \n           // is std::vector<int>{11, 12, 13}\n\n       std::vector<std::string> sv {\"a\", \"b\", \"c\"};\n       addable<std::vector<std::string>>{sv}.add(std::string{\"z\"}); \n           // is {\"az\", \"bz\", \"cz\"}\n```", "```cpp\nif constexpr (a) {\n    // do something\n} else if constexpr (b) {\n    // do something else \n} else {\n    // do something completely different\n}\n```", "```cpp\ntemplate <typename T>\nclass addable\n{\n    T val;\n\npublic:\n    addable(T v) : val{v} {}\n\n    template <typename U>\n std::enable_if_t<!std::is_same<T, std::vector<U>>::value, T>\n    add(U x) const { return val + x; }\n\n    template <typename U>\n std::enable_if_t<std::is_same<T, std::vector<U>>::value, \n                     std::vector<U>>\n    add(U x) const {\n        auto copy (val);\n        for (auto &n : copy) { \n            n += x;\n        }\n        return copy;\n    }\n};\n```", "```cpp\n       // foo_lib.hpp \n\n       class process_monitor { \n       public: \n           static const std::string standard_string \n               {\"some static globally available string\"}; \n       };\n\n       process_monitor global_process_monitor;\n```", "```cpp\n       // foo_lib.hpp \n\n       class process_monitor { \n       public: \n           static const inline std::string standard_string \n               {\"some static globally available string\"}; \n       };\n\n       inline process_monitor global_process_monitor;\n```", "```cpp\nclass foo {\npublic:\n    static std::string& standard_string() {\n        static std::string s {\"some standard string\"};\n        return s;\n    }\n};\n```", "```cpp\n      template <typename ... Ts>\n      auto sum(Ts ... ts);\n```", "```cpp\n      template <typename ... Ts>\n      auto sum(Ts ... ts)\n      {\n          return (ts + ...);\n      }\n```", "```cpp\n      int the_sum {sum(1, 2, 3, 4, 5)}; // Value: 15\n```", "```cpp\n      std::string a {\"Hello \"};\n      std::string b {\"World\"};\n\n      std::cout << sum(a, b) << 'n'; // Output: Hello World\n```", "```cpp\ntemplate <typename ... Ts>\nauto sum(Ts ... ts)\n{\n    return (ts + ... + 0);\n}\n```", "```cpp\ntemplate <typename ... Ts>\nauto product(Ts ... ts)\n{\n    return (ts * ... * 1);\n}\n```", "```cpp\ntemplate <typename R, typename ... Ts>\nauto matches(const R& range, Ts ... ts)\n{\n    return (std::count(std::begin(range), std::end(range), ts) + ...);\n}\n```", "```cpp\nstd::vector<int> v {1, 2, 3, 4, 5};\n\nmatches(v,         2, 5);          // returns 2\nmatches(v,         100, 200);      // returns 0\nmatches(\"abcdefg\", 'x', 'y', 'z'); // returns 0\nmatches(\"abcdefg\", 'a', 'd', 'f'); // returns 3\n```", "```cpp\ntemplate <typename T, typename ... Ts>\nbool insert_all(T &set, Ts ... ts)\n{\n    return (set.insert(ts).second && ...);\n}\n```", "```cpp\nstd::pair<iterator, bool> insert(const value_type& value);\n```", "```cpp\nstd::set<int> my_set {1, 2, 3};\n\ninsert_all(my_set, 4, 5, 6); // Returns true\ninsert_all(my_set, 7, 8, 2); // Returns false, because the 2 collides\n```", "```cpp\nstd::set<int> my_set {1, 2, 3};\n\ninsert_all(my_set, 4, 2, 5); // Returns false\n// set contains {1, 2, 3, 4} now, without the 5!\n\n```", "```cpp\ntemplate <typename T, typename ... Ts>\nbool within(T min, T max, Ts ...ts)\n{\n    return ((min <= ts && ts <= max) && ...);\n}\n```", "```cpp\nwithin( 10,  20,  1, 15, 30);    // --> false\nwithin( 10,  20,  11, 12, 13);   // --> true\nwithin(5.0, 5.5,  5.1, 5.2, 5.3) // --> true\n```", "```cpp\nstd::string aaa {\"aaa\"};\nstd::string bcd {\"bcd\"};\nstd::string def {\"def\"};\nstd::string zzz {\"zzz\"};\n\nwithin(aaa, zzz,  bcd, def); // --> true\nwithin(aaa, def,  bcd, zzz); // --> false\n```", "```cpp\ntemplate <typename T, typename ... Ts>\nvoid insert_all(std::vector<T> &vec, Ts ... ts)\n{\n    (vec.push_back(ts), ...);\n}\n\nint main()\n{\n    std::vector<int> v {1, 2, 3};\n    insert_all(v, 4, 5, 6);\n}\n```"]