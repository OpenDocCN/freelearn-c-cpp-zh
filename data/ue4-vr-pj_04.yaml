- en: Getting Around the Virtual World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在虚拟世界中移动
- en: In this chapter, we're going to take the pawn we built in the previous chapter
    and get it moving through the world. We'll begin with a commonly employed teleport
    movement scheme and cover a wide range of tasks that go into setting it up. We'll
    learn about navigation meshes in our environment, how to set up input events in
    our project and use them in Blueprints, and how to build a player pawn Blueprint
    and get it moving around the world. Finally, we'll also explore an immersive seamless
    locomotion scheme that you can use to allow your players to move through the world
    without teleporting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用前一章中构建的角色，使其在世界中移动。我们将从常用的传送移动方案开始，涵盖一系列设置任务。我们将了解环境中的导航网格，如何在项目中设置输入事件并在蓝图中使用它们，以及如何构建一个玩家角色蓝图并使其在世界中移动。最后，我们还将探讨一种沉浸式的无缝定位方案，您可以使用它让玩家在世界中移动而无需传送。
- en: 'Throughout the course of this chapter, we''ll be discussing the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的过程中，我们将讨论以下主题：
- en: Navigation meshes—what they are, how to set them up in your level, and how to
    refine them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航网格-它们是什么，如何在级别中设置它们，以及如何优化它们
- en: How to set up a Blueprint for your player pawn, and how to create input events
    that your pawn can use
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为玩家角色设置蓝图，以及如何创建角色可以使用的输入事件
- en: How to perform traces, using both straight lines and curves, to find legal target
    locations in your environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用直线和曲线进行追踪，以在环境中找到合法的目标位置
- en: How to create simple in-game indicators to show players what's going on
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建简单的游戏内指示器，向玩家展示正在发生的事情
- en: How to implement a seamless locomotion scheme to provide immersive movement
    for projects where teleportation wouldn't be appropriate
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现无缝的定位方案，为那些不适合传送的项目提供沉浸式移动
- en: This is going to be a lot of ground to cover, but it should be fun, and you're
    going to come away with a good grounding that's going to help you to figure out
    how to develop the things you want, and how to understand what other developers
    are doing when you see their Blueprints. We're going to take a slightly different
    approach in this chapter from the way most tutorials are done. To be an effective
    developer, it's far more important to learn how to think about a problem than
    simply to memorize a series of steps that may not apply to the next problem you
    face. In this chapter, we're going to walk through the processes of building elements
    and then, in some instances, *discover* bugs in them. Afterward, we'll need to
    change things to fix these bugs. This is where the real value in this approach
    lies—you'll begin to get a sense of how to develop software through iteration,
    which is the way it's really done. The goal here isn't to make you good at building
    these tutorials—it's to help you to become a developer who can make whatever you
    dream up on your own.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这将涉及很多内容，但应该很有趣，您将获得一个良好的基础，帮助您弄清楚如何开发您想要的东西，以及在看到其他开发人员的蓝图时如何理解他们在做什么。在本章中，我们将以与大多数教程不同的方式进行。作为一名有效的开发人员，学习如何思考问题比仅仅记住一系列可能不适用于您面临的下一个问题的步骤更重要得多。在本章中，我们将逐步介绍构建元素的过程，然后在某些情况下发现其中的错误。之后，我们需要更改这些内容以修复这些错误。这种方法的真正价值在于，您将开始逐渐了解如何通过迭代开发软件，这才是真正的开发方式。这里的目标不是让您擅长构建这些教程，而是帮助您成为一个可以独立实现自己想法的开发人员。
- en: With that being said, let's get building!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，让我们开始建设吧！
- en: Teleport locomotion
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传送定位
- en: As we discussed in [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml),
    *Thinking in VR*, one of the biggest challenges we face in VR is motion sickness
    that's triggered when the user tries to move around. One of the most commonly
    used solutions for this is to *teleport* the user from place to place rather than
    to allow them to move smoothly through the space. This breaks immersion, but avoids
    the problem of motion sickness entirely because it doesn't create a sense of motion
    at all. For applications where immersive movement isn't a priority, such as architectural
    visualization, this may be an ideal scheme to employ.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml)中讨论的那样，VR中面临的最大挑战之一是当用户尝试移动时引发的晕动病。其中最常用的解决方案之一是将用户从一个地方传送到另一个地方，而不是让他们在空间中平滑移动。这会破坏沉浸感，但完全避免了晕动病的问题，因为它根本不会产生运动感。对于沉浸式移动不是优先考虑的应用，比如建筑可视化，这可能是一种理想的方案。
- en: Creating a navigation mesh
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建导航网格
- en: The first thing we're going to need for a teleport-based locomotion scheme is
    a way to tell the engine where players are allowed to move and where they aren't.
    We can use a *navigation mesh* to do this job.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实现基于传送的定位方案所需的第一件事是告诉引擎玩家可以移动的位置和不允许移动的位置。我们可以使用导航网格来完成这个任务。
- en: A **navigation mesh**, often shortened to **navmesh**, is an automatically generated
    set of surfaces indicating walkable floors in an Unreal level. AI-controlled agents
    use the navigation mesh to find their way around the world, but it can also be
    used as a way to identify safe destinations for the player pawn to land, as we're
    doing here in our teleport system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 导航网格，通常缩写为navmesh，是在虚幻级别中自动生成的一组表明可行走地板的表面。AI控制的角色使用导航网格在世界中找到自己的路，但它也可以用作识别玩家角色安全着陆目的地的方式，就像我们在这里的传送系统中所做的那样。
- en: 'Creating a navmesh in Unreal is fairly simple. From your Modes panel, select
    the Volumes tab, and find the NavMesh Bounds Volume. Drag it into your scene,
    as shown in the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中创建导航网格相当简单。从模式面板中选择体积选项卡，找到导航网格边界体积。将其拖入场景中，如下图所示：
- en: '![](img/ff62bd89-e770-45fb-8353-9dfaac605ff5.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff62bd89-e770-45fb-8353-9dfaac605ff5.png)'
- en: Select the Nav Mesh Bounds Volume from Modes | Volumes
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从模式 | 体积中选择导航网格边界体积
- en: Moving and scaling the Navmesh Bounds volume
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动和缩放导航网格边界体积
- en: 'The NavMesh Bounds volume needs to surround any floor where you''d like the
    player to be able to teleport. Let''s make our navmesh visible so that we can
    see where the walkable floors are being set up:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: NavMesh边界体积需要围绕任何您希望玩家能够传送的地板。让我们使我们的导航网格可见，以便我们可以看到可行走的地板正在设置的位置：
- en: 'Hit the *P* key to toggle navigation visibility or, from the viewport menu,
    select Show | Navigation:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*P*键切换导航可见性，或者从视口菜单中选择显示|导航：
- en: '![](img/0fa82e83-9f5d-4ec3-93e0-219af714867f.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fa82e83-9f5d-4ec3-93e0-219af714867f.png)'
- en: Use the P key or Show | Navigation to display the generated navmesh in the environment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用P键或者选择显示|导航来在环境中显示生成的导航网格。
- en: If you don't see any navigable space after you've placed a NavMesh Bounds volume,
    make sure it's intersecting a walkable floor. The volume sets the boundaries for
    the navmesh generation, so if it's above the floor, it won't generate anything.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在放置NavMesh边界体积后看不到任何可导航空间，请确保它与可行走的地板相交。该体积设置了导航网格生成的边界，因此如果它在地板上方，它将不会生成任何东西。
- en: Of course, this NavMesh Bounds volume we just placed is far too small. Let's
    extend it to cover the space in which we'd like to move. We're going to do this
    by scaling the volume.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们刚刚放置的NavMesh边界体积太小了。让我们将其扩展以覆盖我们想要移动的空间。我们将通过缩放体积来实现这一点。
- en: Hit the *R* key to switch to scaling mode, or just tap the *spacebar* until
    the scaling gizmo appears.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*R*键切换到缩放模式，或者只需轻按*空格键*直到缩放工具出现。
- en: We could scale the volume from the perspective view, but for this kind of operation,
    it's often a good idea to go to an orthographic view so that we can really see
    what we're doing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从透视视图缩放体积，但对于这种操作，通常最好切换到正交视图，以便我们真正看到我们在做什么。
- en: 'Hit *Alt* + *J* or use the viewport''s view selector to switch to a top view:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Alt* + *J*键或使用视口的视图选择器切换到俯视图：
- en: '![](img/00012d43-9bf3-423a-97bf-09296f64b3d5.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00012d43-9bf3-423a-97bf-09296f64b3d5.png)'
- en: Switch to an orthographic top view using the menu or its associated shortcut
    key.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用菜单或相关的快捷键切换到正交俯视图。
- en: Scale the navmesh to surround the walkable area of the building.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将导航网格缩放以覆盖建筑物的可行走区域。
- en: 'With your navigation visible, you can see where it''s generating navmesh surfaces
    and whether it''s doing a sensible job of it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过可见的导航，您可以看到它正在生成导航网格表面以及它是否在合理的范围内工作：
- en: '![](img/a43840c2-2d94-4263-aac9-5f780232ff57.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a43840c2-2d94-4263-aac9-5f780232ff57.png)'
- en: A top view of our level showing the extents of the NavMesh bounds volume
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的关卡的俯视图显示了NavMesh边界体积的范围。
- en: In our case, parts of the building that we expect to be walkable aren't yet
    covered. This is because we haven't yet done anything with the height of our bounds
    volume, and these areas are too high or low to fit inside it. Let's jump to a
    side view to fix that.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们期望可行走的建筑物部分尚未覆盖。这是因为我们尚未对边界体积的高度进行任何处理，而这些区域的高度太高或太低，无法适应其中。让我们跳转到侧视图来修复这个问题。
- en: Hit *Alt* + *K* to jump to the left view, or select Left from your viewport
    view selection.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Alt* + *K*键跳转到左视图，或者从视口视图选择中选择左视图。
- en: 'Scale the bounds volume to a scale that reasonably covers the floor:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将边界体积缩放到合理覆盖地板的比例：
- en: '![](img/670062aa-f965-46ee-9c43-1492e0f2e2ec.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/670062aa-f965-46ee-9c43-1492e0f2e2ec.png)'
- en: Side view of the level. You can see here that we're scaling the navmesh bounds
    volume to encompass the floor
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关卡的侧视图。您可以在这里看到我们正在缩放NavMesh边界体积以包围地板
- en: Hit *Alt* + *G* to jump back to a perspective view and see how we're doing.
    Alternatively, you can select Perspective from your view selector.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Alt* + *G*键跳回透视视图并查看我们的进展。或者，您可以从视图选择器中选择透视视图。
- en: It's worth memorizing these keystrokes for changing views. You'll use them all
    of the time, and it's handy to be able to switch quickly. *Alt* + *J*, *K*, and
    *H* switch view angles. *Alt* + *2* switches to a wireframe view, and *Alt* +
    *4* switches back to a shaded view. There are plenty of other hotkeys, but you'll
    use these the most.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住这些改变视图的按键。您会经常使用它们，而且能够快速切换非常方便。*Alt* + *J*、*K*和*H*切换视角。*Alt* + *2*切换到线框视图，*Alt*
    + *4*切换回实体视图。还有很多其他快捷键，但您会经常使用这些。
- en: 'If we fly to the back of the temple, we can see that we have a problem here.
    Our navmesh didn''t generate as expected in the back corridor. Let''s figure out
    what''s going on here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们飞到寺庙的后面，我们会发现这里有一个问题。我们的导航网格在后面的走廊中没有按预期生成。让我们弄清楚这里发生了什么：
- en: '![](img/98ead175-7c85-4f0e-92e7-24b590a92b9a.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98ead175-7c85-4f0e-92e7-24b590a92b9a.png)'
- en: Here we can see that part of our level hasn't been properly covered by the navmesh.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到我们的关卡的一部分没有被导航网格正确覆盖。
- en: Fixing collision problems
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复碰撞问题
- en: 'There are almost always two reasons why a navmesh isn''t generating where you
    expect it. Either your volume isn''t surrounding the area where you''re trying
    to generate the mesh, or there''s something wrong with the collision in the area.
    Let''s take a look:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 导航网格没有生成在您期望的位置通常有两个原因。要么您的体积没有围绕您尝试生成网格的区域，要么该区域的碰撞有问题。让我们来看一下：
- en: Hit *Alt* + *C* to view the collision in the back hall, or hit Show | Collision.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Alt* + *C*键查看后厅的碰撞，或者按下显示|碰撞。
- en: It doesn't appear that there's any stray collision encroaching into the hall,
    so it's probably a missing collision on the floor.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来没有任何杂散的碰撞侵入到走廊中，所以可能是地板上缺少碰撞。
- en: Select the floor in the bad area.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择问题区域的地板。
- en: 'In its details, find its Static Mesh and double-click it to open it up:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其详细信息中，找到其静态网格并双击打开它：
- en: '![](img/de446944-4748-46f2-8b0e-a9430387c643.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de446944-4748-46f2-8b0e-a9430387c643.png)'
- en: Use the Details panel to find the static mesh for the bad floor region.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用详细面板找到问题地板区域的静态网格。
- en: 'In the Static Mesh Editor, select the Collision toolbar item and make sure
    that Simple Collision is checked:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在静态网格编辑器中，选择碰撞工具栏项，并确保勾选了“简单碰撞”：
- en: '![](img/2b4a5c4f-4080-4f17-af62-b903b1603ca6.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b4a5c4f-4080-4f17-af62-b903b1603ca6.png)'
- en: View simple collision for the static mesh
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 查看静态网格的简单碰撞
- en: Sure enough, our simple collision is missing. Let's fix this.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，我们的简单碰撞丢失了。让我们修复这个问题。
- en: Select Collision | Add Box Simplified Collision to add a simple collision plane
    to our floor.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择碰撞|添加简化碰撞盒，为我们的地板添加一个简单的碰撞平面。
- en: 'That''s much better. We should now see that the navmesh we expect has been
    generated back in our main level:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了。现在我们应该看到我们期望的navmesh已经在我们的主要层级中生成：
- en: '![](img/6841a774-5537-445a-853b-887083fada8e.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6841a774-5537-445a-853b-887083fada8e.png)'
- en: Simplified collision created for our floor mesh
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的地板网格创建简化碰撞
- en: Before we move on, let's take a second to talk about what's going on here. A
    very common thing we need to do in real-time software is figure out when an object
    has hit another object. Unreal uses *collision meshes* to do this. A collision
    mesh is simplified geometry that's used to check for intersections with other
    collision meshes in the world.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们花一点时间来谈谈这里发生的情况。在实时软件中，我们经常需要做的一件事是确定一个对象何时碰撞到另一个对象。Unreal使用*碰撞网格*来实现这一点。碰撞网格是简化的几何体，用于检查与世界中其他碰撞网格的相交。
- en: 'Actors have two of these:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 演员有两个：
- en: A **Complex Collision** mesh. This is simply the model's visible mesh.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**复杂碰撞**网格。这只是模型的可见网格。
- en: A **Simple Collision** mesh. This is a much less detailed convex mesh that surrounds
    the object. These are often generated when an object is imported, or can be created
    explicitly in the DCC where the model was created. If it's missing, you can create
    a simple collision in the editor, like we've done here. As a last resort, you
    can set Details | Collision | Collision Complexity to Use Complex Collision As
    Simple to use the object's visible mesh for all collision calculations. Don't
    do this for a mesh with a ton of polygons, though. It's expensive.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**简单碰撞**网格。这是一个较少详细的凸网格，围绕着物体。这些通常在导入对象时生成，或者可以在创建模型的DCC中显式创建。如果缺少它，您可以在编辑器中创建一个简单的碰撞，就像我们在这里所做的一样。作为最后的手段，您可以将详细信息|碰撞|碰撞复杂性设置为使用复杂碰撞作为简单碰撞，以将对象的可见网格用于所有碰撞计算。不过，对于具有大量多边形的网格，请不要这样做。这是昂贵的。
- en: Collision detection and handling is its own fairly deep topic and beyond the
    scope of this book, but for our purposes in VR development, we're going to care
    a lot about the simple collision meshes of our objects, because we'll use these
    as walkable surfaces to detect when another object hits them, to detect whether
    we can grab them, and for many other purposes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞检测和处理是一个相当深入的主题，超出了本书的范围，但对于我们在VR开发中的目的，我们将非常关心对象的简单碰撞网格，因为我们将使用它们作为可行走的表面来检测另一个对象何时碰撞到它们，以及是否可以抓取它们，以及其他许多用途。
- en: Excluding areas from the navmesh
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从navmesh中排除区域
- en: 'Looking around our map, we have a few more problems we need to fix. Our Navmesh
    Bounds Volume is generating a navmesh in a few areas where we don''t want our
    players to teleport. Let''s fix this, too:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看我们的地图时，我们还有一些问题需要解决。我们的Navmesh Bounds Volume在一些我们不希望玩家传送的区域生成了navmesh。让我们也修复这个问题：
- en: Hit *Alt* + *2* to switch to a wireframe view, or use the viewport's View Mode
    selector to switch to wireframe.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Alt* + *2*切换到线框视图，或使用视口的视图模式选择器切换到线框视图。
- en: We probably have a few problems we can fix just by adjusting the scale of the
    NavMesh Bounds volume. If we have navmesh generating on rooftops or window sills,
    let's reduce our Bounds volume's vertical scale to exclude these areas if we can.
    This is an area where hitting *Alt* + *K* to jump to a side view can help.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一些问题可以通过调整NavMesh Bounds体积的比例来解决。如果我们的navmesh在屋顶或窗台上生成，让我们将Bounds体积的垂直比例减小，以排除这些区域。这是一个可以通过按下*Alt*
    + *K*跳转到侧视图来帮助的地方。
- en: If our NavMesh Bounds volume is spreading further outside the building than
    it needs to, we can jump to a top view using *Alt* + *J* and adjust it to fit
    better.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的NavMesh Bounds体积扩展到建筑物外部的范围超出了需要的范围，我们可以使用*Alt* + *J*跳转到顶视图，并调整它以更好地适应。
- en: 'We''re still going to have a few leftover stray areas that we''ll want to exclude,
    and that can''t simply be fixed by scaling the volume. For these, we''ll use Nav
    Modifier Volumes. Refer to the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然会有一些剩余的杂散区域需要排除，而这些区域不能简单地通过调整体积来修复。对于这些区域，我们将使用Nav Modifier Volumes。请参考以下步骤：
- en: Grab a Nav Modifier Volume from your Modes palette and drag it into the scene.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Modes面板中获取一个Nav Modifier Volume，并将其拖入场景中。
- en: Move and scale it until it surrounds an area where the unwanted navmesh is being
    generated.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动和缩放它，直到它围绕着生成不需要的navmesh的区域。
- en: You'll see the navmesh in this region disappear when the nav modifier volume
    surrounds it. Take a look at the nav modifier volume properties in your Details
    panel. Do you see that Default | Area Class is set to NavArea_Null? This tells
    the navmesh generator to omit generating a navmesh in this region. You can see
    from the pulldown menu that it can also be used to mark obstacles and crawlspaces,
    but for what we're doing here, we don't care about these. We're just interested
    in using it to clear out unwanted navigation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当nav修改器体积围绕它时，您将看到该区域的navmesh消失。查看详细面板中的nav修改器体积属性。您是否看到默认|区域类别设置为NavArea_Null？这告诉navmesh生成器在此区域中不生成navmesh。您可以从下拉菜单中看到它还可以用于标记障碍物和爬行空间，但对于我们在这里要做的事情，我们不关心这些。我们只关心使用它来清除不需要的导航。
- en: 'Drag as many of these into your scene as you need to clean up the stray bits.
    You can hold down the *Alt* key while dragging a modifier volume to duplicate
    it, or hit *Ctrl* + *W* to make a copy:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些拖到场景中，根据需要清理杂散的部分。您可以在拖动修改器体积时按住*Alt*键进行复制，或按下*Ctrl* + *W*进行复制：
- en: '![](img/27229d49-ac56-4fe2-bdba-32a5ebdc9449.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27229d49-ac56-4fe2-bdba-32a5ebdc9449.png)'
- en: A perspective wireframe view can be useful for finding problems with your navigation
    coverage.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 透视线框视图对于查找导航覆盖问题非常有用。
- en: You'll find it helpful to memorize the transform hotkeys as you're moving objects
    around. *W* activates the Translate tool, which allows you to slide an object
    around. *E* activates the Rotate tool, and *R* activates the Scale tool. Tapping
    the *spacebar* also cycles through these tools. *Ctrl* + *W* duplicates an object,
    and holding *Alt* while dragging an object also copies it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动物体时，记住熟记变换热键会很有帮助。按下W键激活“平移”工具，可以让你滑动物体。按下E键激活“旋转”工具，按下R键激活“缩放”工具。按下空格键也可以循环使用这些工具。按住Ctrl键+W键可以复制一个物体，拖动物体时按住Alt键也可以复制它。
- en: When you're done, you should have a collection of Nav Modifier Volumes blocking
    off areas you don't want your player to stand on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该有一系列阻挡玩家站立的导航修改体积。
- en: Fly through your level and make sure you don't have any weird navmesh where
    you don't want it. Where you find problems, fix them by scaling your navmesh bounds
    volume, or adding nav modifier volumes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在你不希望出现奇怪的导航网格的地方飞行，确保没有问题。在发现问题时，通过缩放导航网格边界体积或添加导航修改体积来修复问题。
- en: Modifying your navmesh properties
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改导航网格属性
- en: There's one other thing you should know about before we move on, and that's
    where to adjust the properties for the navmesh you've just generated.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，还有一件事情你应该知道，那就是如何调整刚刚生成的导航网格的属性。
- en: If you need to change anything about its behavior, select the `RecastNavMesh`
    object, which will have been created in your level. In its Details panel, you
    can see properties governing its generation, querying, and runtime behavior.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要改变它的行为，选择“RecastNavMesh”对象，它将在你的关卡中创建。在其详细面板中，你可以看到控制其生成、查询和运行时行为的属性。
- en: 'We''re not going to go into these here except to call attention to one of these
    properties: if you wanted to adjust the size of an area into which your player
    could fit, you can adjust the Agent Radius to do so. Making this smaller will
    allow your player to fit into tighter spots. Similarly, you can adjust the Agent
    Height and Max Height to determine acceptable ceiling heights under which navigation
    should be generated. Generally, you''ll want to make changes to these values before
    you go crazy fine-tuning your nav modifier volumes since changes here will change
    where your navmesh is generated. For our purposes, we''re going to leave these
    values alone.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里详细介绍它们，只是提醒你其中一个属性：如果你想调整一个玩家可以适应的区域的大小，你可以调整代理半径来实现。将其缩小将使玩家适应更狭窄的空间。同样，你可以调整代理高度和最大高度来确定导航应该生成的可接受天花板高度。通常，在你疯狂微调导航修改体积之前，你会想要对这些值进行更改，因为这里的更改会改变导航网格的生成位置。对于我们的目的，我们将保持这些值不变。
- en: Setting up the pawn Blueprint
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置兵棋蓝图
- en: Now that we have our navigation built and tuned in our scene, we can turn off
    navigation visualization by hitting *P*, and start working on our locomotion behavior.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在场景中构建和调整了导航，我们可以通过按下P键关闭导航可视化，并开始处理我们的运动行为。
- en: 'To implement a teleport locomotion scheme, we need to do three jobs:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现传送运动方案，我们需要做三个工作：
- en: Figure out where the player wants to move
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弄清楚玩家想要移动到哪里
- en: Figure out where the player is actually allowed to move
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弄清楚玩家实际上被允许移动到哪里
- en: Move the player to the new location
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将玩家移动到新位置
- en: Let's get to work.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始工作吧。
- en: Iterative development
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代开发
- en: We're going to develop this method iteratively, the way you really would if
    you were developing it from scratch. Most tutorials simply walk you through the
    steps to build a finished method, but the problem with this approach is that it
    doesn't teach you *why* you're doing the things you're doing. As soon as you want
    to do something similar, but not exactly the same, you're back to square one.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以迭代的方式开发这种方法，就像你从头开始开发一样。大多数教程只是带你完成构建完成方法的步骤，但这种方法的问题在于它不教你为什么要做你正在做的事情。一旦你想做类似的事情，但又不完全相同，你就又回到了原点。
- en: Instead, we're going to work in stages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将分阶段进行工作。
- en: 'Kent Beck, a pioneering software developer, gives this advice to developers:
    *Make it work, make it right, make it fast.*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 杰出的软件开发者肯特·贝克给开发者提出了这样的建议：“让它工作，让它正确，让它快。”
- en: What's important here is the order in which you do things. It seems almost obvious
    at first, but few developers get it right when they're starting out. You'll save
    yourself a lot of heartache if you work in this order.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是你做事情的顺序。一开始似乎几乎是显而易见的，但很少有开发者在刚开始时就做对。如果按照这个顺序工作，你将节省很多痛苦。
- en: Make it work
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让它工作
- en: Build a rough assembly of what you're trying to do. Test it early and often.
    Build it to be easy to test and easy to change. Change things around until you're
    satisfied that it's doing the right work.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个大致的组装，测试早期和频繁。使其易于测试和易于更改。不断更改，直到你满意它正在做正确的工作。
- en: Make it right
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让它正确
- en: Now that you know what your code needs to do, figure out how you should really
    organize it. Are there better or cleaner ways to do what you're trying to do?
    Are there parts that can be reused? Will this code need to be used anywhere else?
    Could you debug it if you had to? Use the work you did in the *make it work* phase
    as a starting point, but now that you understand what you really need to do, write
    it correctly. It's okay to make a mess in the first stage (in fact, you're probably
    doing it wrong if you're not making a mess), but clean that mess up in this phase.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道你的代码需要做什么了，弄清楚你应该如何真正组织它。有没有更好或更清晰的方法来做你试图做的事情？有没有可以重复使用的部分？这段代码是否需要在其他地方使用？如果需要，你能调试它吗？以“让它工作”的阶段为起点，但现在你明白你真正需要做什么了，正确地编写它。在第一阶段制造混乱是可以的（事实上，如果你没有制造混乱，那么你可能做错了），但在这个阶段清理这个混乱。
- en: Make it fast
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让它快
- en: Once you have reasonably clean code that's doing the right job, look for ways
    you could get it running faster. Is there a result that you're generating more
    than once that you could cache to a variable and reuse? Are you checking conditions
    repeatedly, even though you know they can only change when certain things happen?
    Are you copying data that you could just read from its original location? Figure
    out what you could be doing more efficiently, and speed things up where you can.
    Be careful here, though. Some optimizations are so minor that they may not really
    make a noticeable difference to the running application. Go for the big ones,
    and use profiling tools to understand where your problems really are. You want
    to make sure you're optimizing things that are really going to make a difference.
    Also, be careful about making your code more difficult to read or debug as you
    optimize it. A change that shaves a tiny amount off of your frame time but makes
    a class difficult or impossible to update or maintain might not be worth it. Use
    judgment when optimizing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了合理干净的代码，能够正常工作，寻找可以使其运行更快的方法。是否有一个结果，您可以将其缓存到变量中并重复使用？您是否反复检查条件，即使您知道它们只会在某些事件发生时改变？您是否复制了可以直接从其原始位置读取的数据？找出您可以更高效地做什么，并在可以的地方加快速度。但要小心，在这里有些优化可能对运行应用程序没有明显的影响。选择大的优化，并使用性能分析工具了解您真正的问题所在。您要确保优化的是真正会产生差异的东西。此外，在优化代码时要小心不要使其更难以阅读或调试。将帧时间减少一点但使类难以更新或维护的更改可能不值得。在优化时要谨慎使用判断。
- en: Do things in order
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按顺序进行操作
- en: Many new developers mess this order up, and start trying to optimize their code
    before they've really made sure they're doing the right thing. This just wastes
    time, as there's a high likelihood that some of that code will be thrown out.
    Other developers skip the *make it right* phase, and consider their work done
    as soon as it seems to work. This is a mistake too, as 80% of the life cycle of
    a piece of code is spent maintaining and debugging it. If your code works but
    it's a mess, you're going to burn a lot of extra time trying to keep it running
    later on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 许多新开发者会在优化代码之前就开始尝试优化代码，而没有确保自己正在做正确的事情。这只会浪费时间，因为很可能会丢弃其中的一些代码。其他开发者跳过了“让它正确”的阶段，并在似乎工作正常时认为他们的工作已经完成。这也是一个错误，因为代码的80%的生命周期都用于维护和调试。如果您的代码能够工作但是一团糟，您将花费大量额外的时间来保持其运行。
- en: Problems that are created by rushed or sloppy work early in development are
    often referred to as *technical debt*. This is stuff you're going to have to fix
    later because, even though it runs, it may not be flexible or robust, or might
    just be an unreadable shambles. The time to clear your technical debt is right
    after you've finished your *make it work* phase, and before you've moved onto
    other things and started to build more code on top of something that needs to
    change.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发初期匆忙或粗心的工作所造成的问题通常被称为“技术债务”。这些是你以后需要修复的东西，因为即使它能运行，但可能不够灵活、健壮，或者只是一团难以理解的混乱。清理技术债务的时间是在完成“让它工作”阶段之后，而在继续其他工作并在需要更改的基础上构建更多代码之前。
- en: Working in this order and thinking of these as discrete stages will make you
    a more effective developer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个顺序并将其视为离散阶段来进行工作将使您成为一个更有效的开发者。
- en: Setting up a line trace from the right motion controller
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从右手控制器设置一条射线追踪
- en: 'Let''s begin with the first thing we need to do to get our teleport running—figuring
    out where the player wants to go:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从获取玩家想要去的位置开始设置我们的传送功能：
- en: Open up our BP_VRPawn Blueprint, and open My Blueprint | Graphs | EventGraph,
    if it isn't already open.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开BP_VRPawn蓝图，并打开我的蓝图|图表|事件图，如果尚未打开。
- en: We should still see the `BeginPlay` event in our Event Graph where we set our
    tracking origin. Now, we're going to add some code to our Event Tick.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在事件图中仍然看到“BeginPlay”事件，其中我们设置了跟踪原点。现在，我们将在事件Tick中添加一些代码。
- en: The Tick event is called every time the engine updates the frame. Be careful
    about putting too much work into your Tick events, as they can eat performance.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每次引擎更新帧时都会调用Tick事件。在Tick事件中不要放太多工作，因为它们会影响性能。
- en: If you don't already see an Event Tick node in your Event Graph, right-click
    anywhere in the graph, type `tick` in the search box, and select Add Event | Event
    Tick. If you already have a Tick event defined, this won't add a new one—it'll
    just take you to that node in the event graph. If you don't, this will create
    one now.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在事件图中还没有看到Event Tick节点，请在图中的任何位置右键单击，输入“tick”在搜索框中，然后选择添加事件|事件Tick。如果已经定义了一个Tick事件，这不会添加一个新的事件，而只会将您带到事件图中的该节点。如果没有，现在将创建一个。
- en: Right-click to the right of Event Tick, and add a Line Trace by Channel.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Event Tick的右侧单击，添加一个按通道进行线性追踪。
- en: When you perform a line trace, you supply a *start* point and an *end* point,
    and tell it what *collision channel* you're looking for. If an actor with a collision
    set to the supplied collision channel intersects the line between the start and
    end points, the trace will return `true`, and will return information about what
    it hit. We're going to use this behavior to find our teleport destination.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行线性追踪时，您提供一个“起点”和一个“终点”，并告诉它您要查找的“碰撞通道”。如果一个具有设置为提供的碰撞通道的碰撞的actor与起点和终点之间的线相交，追踪将返回“true”，并返回有关它所击中的信息。我们将利用这种行为来找到我们的传送目的地。
- en: 'Let''s start our trace at the location of the right motion controller:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从右手控制器的位置开始追踪：
- en: From your components list, grab `MotionController_R`, and drag it into your
    event graph.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从组件列表中获取MotionController_R，并将其拖动到事件图中。
- en: We want to start our trace at the motion controller's location, so let's drag
    a connector out from the `MotionController_R` return value and release.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望从运动控制器的位置开始追踪，所以让我们从MotionController_R的返回值中拖出一个连接器并释放。
- en: 'In the dialog that appears, type `getworld` into the search bar and select
    GetWorldLocation:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的对话框中，输入`getworld`并选择GetWorldLocation：
- en: '![](img/8c4a8a1c-1a1b-4ed3-9112-4bded8efdbb2.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/8c4a8a1c-1a1b-4ed3-9112-4bded8efdbb2.png)
- en: Blueprint node creation is context-sensitive by default. This means that if
    you're dragging a connection from another object, you'll only be shown actions
    that would be appropriate for that object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图节点的创建默认是上下文敏感的。这意味着如果你从另一个对象拖动连接，你只会看到适用于该对象的操作。
- en: Drag the result of `GetWorldLocation` into the Line Trace node's Start input
    pin.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GetWorldLocation`的结果拖入Line Trace节点的Start输入引脚。
- en: Now, let's set the trace end point. We're going to end our trace at a point
    10,000 units away from our start location, in the direction the controller is
    facing. Let's do a bit of simple math to figure out where that point is.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置追踪的终点。我们将在距离起始位置10,000个单位的点结束追踪，朝向控制器的方向。让我们进行一些简单的数学计算，找出那个点在哪里。
- en: From the `MotionController_R` output, create a `Get Forward Vector` node.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`MotionController_R`的输出中创建一个`Get Forward Vector`节点。
- en: This will return a vector with a length of 1 that aims in the direction the
    controller is facing. We said we wanted our end point to be 10,000 units from
    the start, so let's multiply our Forward vector by that value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个长度为1的向量，指向控制器所面向的方向。我们说过我们希望终点距离起点为10,000个单位，所以让我们将我们的Forward向量乘以该值。
- en: Drag the `Get Forward Vector` return value out and type `*` into the search
    bar. Select vector * float.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Get Forward Vector`的返回值拖出并在搜索栏中输入`*`。选择向量*浮点数。
- en: 'Now, drag a connector out from the float input to the multiply action, and
    select Promote to Variable:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从浮点输入拖出一个连接器到乘法操作，并选择Promote to Variable：
- en: '![](img/5dc6c864-8c13-42cd-8b29-f11331716833.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/5dc6c864-8c13-42cd-8b29-f11331716833.png)
- en: This is a fast way of creating variables in Blueprint. You can simply drag out
    from an input, select Promote to variable,
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在蓝图中快速创建变量的方法。你可以简单地从输入中拖出，选择Promote to variable，
- en: and a variable will be created with the correct type for the input
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 并且将创建一个具有正确类型的变量以供输入使用
- en: Name the new variable `TeleportTraceLength`, compile the Blueprint, and set
    the variable's value to `10000`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新变量命名为`TeleportTraceLength`，编译蓝图，并将变量的值设置为`10000`。
- en: You could have simply typed `10000` directly into the multiplication action's
    float input, but it's bad practice to do so. If you start hiding values all over
    the place in your Blueprints, you'll have a hard time finding them later on when
    you need to change them. Also, a number typed into an input doesn't do anything
    to explain what it is. A variable, on the other hand, can be given a name that
    describes what's actually going to change if its value is changed. Numbers buried
    without explanation in your code are called *magic numbers* by developers, and
    they're an example of *technical debt*. They're just going to turn into a hassle
    for you later on when you need to maintain or debug your code. Unless the use
    of a value is absolutely obvious in its context, use a variable instead, and give
    it a meaningful name.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在乘法操作的浮点输入中键入`10000`，但这样做是不好的实践。如果你在蓝图中随处隐藏数值，当你需要更改它们时，你将很难找到它们。此外，键入到输入中的数字并不能解释它是什么。相反，变量可以被赋予一个描述其值改变时实际发生的事情的名称。在你的代码中没有解释的数字被开发人员称为*魔法数字*，它们是*技术债务*的一个例子。当你需要维护或调试代码时，它们只会给你带来麻烦。除非一个值在其上下文中绝对明显，否则请使用一个变量，并给它一个有意义的名称。
- en: 'We now have a vector that''s 10,000 units long, aiming in the controller''s
    forward direction, but right now it would be running 10,000 units from the world''s
    center, rather than from the controller, as we intend. Let''s add the controller''s
    location to this vector to fix that:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个长度为10,000个单位的向量，指向控制器的前方，但现在它将从世界的中心运行10,000个单位，而不是从控制器开始，这不是我们的意图。让我们将控制器的位置添加到这个向量中以修正这个问题：
- en: Drag another connector from the controller's `GetWorldLocation` call, and type
    `+` in the search bar. Select vector + vector.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从控制器的`GetWorldLocation`调用中拖出另一个连接器，并在搜索栏中输入`+`。选择向量+向量。
- en: Drag the output from our forward vector multiplication into the other input.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的前向量乘法的输出拖入另一个输入。
- en: 'Connect the output of this addition to the End argument of `LineTraceByChannel`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此加法的输出连接到`LineTraceByChannel`的End参数：
- en: '![](img/eab371d1-f1f2-49ec-8133-60cc9422839a.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/eab371d1-f1f2-49ec-8133-60cc9422839a.png)
- en: Before we move on, let's set up some debug drawing to see whether everything
    is behaving as we expect so far.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们设置一些调试绘图，以查看到目前为止是否一切都按我们的预期运行。
- en: Hold down the *B* key and click on the open space to the right of the `Line
    Trace` node to create a `Branch` node. (You can also right-click and create a
    Branch node the way you usually do, but this is a useful shortcut.)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*B*键并点击`Line Trace`节点右侧的空白处，创建一个`Branch`节点。（你也可以右键单击并像通常那样创建一个Branch节点，但这是一个有用的快捷方式。）
- en: Drag a connector from the `Line Trace` node's Boolean Return Value to this branch's
    Condition.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Line Trace`节点的布尔返回值拖出一个连接器到这个分支的条件。
- en: The trace operation will return `True` if it hits something, and `False` if
    it doesn't. We're only interested in debug drawing the result if it hits something,
    so we're just going to use the `True` output from our branch.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果追踪操作命中了某个物体，它将返回`True`，如果没有命中，则返回`False`。我们只对命中物体进行调试绘图，所以我们只使用分支的`True`输出。
- en: If we did hit something, we need to know where the hit occurred.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确实命中了某个物体，我们需要知道命中发生的位置。
- en: Drag a connector from Out Hit and select Break Hit Result to see the members
    of the hit result struct.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Out Hit拖出一个连接器，并选择Break Hit Result以查看命中结果结构的成员。
- en: A **struct** is a bundled collection of variables that can be given a name and
    passed around as a single unit. The `Hit Result` struct is a commonly used struct
    that describes the properties of a detected collision, telling you where it occurred,
    what actor was hit, and many other details. Calling **break** on a struct allows
    us to see its contents.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构体**是一组捆绑在一起的变量，可以被赋予一个名称并作为一个单独的单元传递。`Hit Result`结构体是一个常用的结构体，描述了检测到的碰撞的属性，告诉你发生碰撞的位置、被击中的演员和许多其他细节。在结构体上调用**break**可以查看其内容。'
- en: 'Now, let''s draw a debug line representing our trace:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们画一条表示我们的跟踪的调试线：
- en: Drag an execution line from our `Branch` node's `True` output, and create a
    `Draw Debug Line` action.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的`Branch`节点的`True`输出拖动一个执行线，并创建一个`Draw Debug Line`动作。
- en: Drag the Location from the `Hit Result` struct into the Line End input on the
    `Debug Line` call.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Hit Result`结构体中的位置拖动到`Debug Line`调用的Line End输入中。
- en: Drag the hit result's Trace Start to the Line Start.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将击中结果的跟踪起点拖动到线的起点。
- en: Set the line's thickness to `2`, and set its color to anything you like.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将线的粗细设置为`2`，并将其颜色设置为你喜欢的任何颜色。
- en: 'While we''re at it, let''s draw a debug sphere at the hit location:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，让我们在击中位置处画一个调试球体：
- en: Create a `Draw Debug Sphere` node.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Draw Debug Sphere`节点。
- en: Connect its execution input to the debug line's output.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其执行输入连接到调试线的输出。
- en: 'Set its Center to the hit result''s Location:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其中心设置为击中结果的位置：
- en: '![](img/6142e634-b112-4a9c-a7f0-9f7ff46603cb.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6142e634-b112-4a9c-a7f0-9f7ff46603cb.png)'
- en: Be aware that `Draw Debug` calls only work in development builds. They're useful
    for understanding what's going on, but they're just debugging tools and need to
    be replaced with real visualizations for your actual software. We'll do that shortly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Draw Debug`调用仅在开发版本中起作用。它们对于理解正在发生的事情很有用，但它们只是调试工具，需要用实际软件的真实可视化替换。我们很快就会做到这一点。
- en: 'Let''s test it. Your result should look something like this:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来测试一下。你的结果应该看起来像这样：
- en: '![](img/0c4a2841-f8a2-4b08-8320-c23637ed28a3.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c4a2841-f8a2-4b08-8320-c23637ed28a3.png)'
- en: Good. So far, it's doing what we expect—casting a ray from the controller, and
    showing us where it hits a surface. The problem, though, is that it's just as
    happy to hit a wall as a floor. We need to restrict it to valid teleport destinations.
    Let's do that.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。到目前为止，它正在按我们的预期进行——从控制器发射一条射线，并显示它击中表面的位置。然而，问题是它同样可以击中墙壁和地板。我们需要将其限制在有效的传送目的地上。让我们来做这个。
- en: Improving our Trace Hit Result
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进我们的跟踪击中结果
- en: 'We''re going to do this first by setting up a simple test that only accepts
    surfaces facing upward. We''ll do this by using a vector operation called a *Dot
    Product* to compare a surface normal with the world''s up vector. Follow these
    steps to get started:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是设置一个简单的测试，只接受朝上的表面。我们将使用一个称为*点积*的向量运算来将表面法线与世界的上向量进行比较。按照以下步骤开始：
- en: Right-click somewhere to the right of our hit result breakout, and create a
    Dot Product node.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的击中结果拆分的右侧某处右键单击，创建一个点积节点。
- en: Drag the Normal from the hit result into the first input, and set the second
    input's *Z* value to 1.0.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将击中结果的法线拖动到第一个输入中，并将第二个输入的*Z*值设置为1.0。
- en: A *normal* is a vector that's perpendicular to the surface from which it extends.
    A *dot product* is a mathematical operator that returns the cosine of the angle
    between two vectors. If two vectors are exactly parallel, their dot product will
    be 1.0\. If they're facing exactly in opposite directions, their dot product will
    be -1.0\. If they're exactly perpendicular, the dot product is 0.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*法线*是垂直于其延伸表面的向量。*点积*是一种数学运算符，返回两个向量之间夹角的余弦值。如果两个向量完全平行，它们的点积将为1.0。如果它们完全相反，它们的点积将为-1.0。如果它们完全垂直，点积为0。'
- en: Since the vector (0,0,1) is the world's up vector, by testing the dot product
    of a surface normal against this vector, we can find out whether or not the normal
    is facing upward by checking whether the dot product is greater than 0.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向量(0,0,1)是世界的上向量，通过测试表面法线与该向量的点积，我们可以通过检查点积是否大于0来判断法线是否朝上。
- en: Drag a connector from the result of the dot product, and select the `>` operator.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从点积的结果中拖动一个连接器，并选择`>`运算符。
- en: Create another branch operator using this result as its Condition.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此结果作为条件创建另一个分支运算符。
- en: Press *Alt* + click the execution input to the Draw Debug Line node to disconnect
    it.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*Alt*并单击Draw Debug Line节点的执行输入以断开连接。
- en: Drag a new execution line from the return value's branch to this new branch.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从返回值的分支中拖动一个新的执行线到这个新的分支。
- en: 'Connect the True output from the dot product''s branch with our Draw Debug
    Line node:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将点积的分支的True输出与我们的Draw Debug Line节点连接起来：
- en: '![](img/ecccc094-918f-4fe3-b345-7473fb1a6cfb.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecccc094-918f-4fe3-b345-7473fb1a6cfb.png)'
- en: Let's test it. We'll see that we now see the debug sphere drawn when our ray
    hits a floor, but not when it hits a wall or a ceiling. As we mentioned a moment
    ago, this is because the dot product of a wall's normal versus the world's up
    vector will be 0, while the dot product of a ceiling against the world up is -1.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下。我们会发现当射线击中地板时，我们现在看到了调试球体的绘制，但当它击中墙壁或天花板时却没有。正如我们刚才提到的，这是因为墙壁的法线与世界的上向量的点积将为0，而天花板与世界上的点积为-1。
- en: This is better, but what about the places we decided we didn't want the player
    to go? We spent all of that time setting up our navmesh bounds and navmesh modifiers,
    and we're not using them yet. We should fix this.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做更好了，但是我们决定不让玩家去的地方怎么办？我们花了那么多时间设置我们的导航网格边界和导航网格修改器，但我们还没有使用它们。我们应该修复这个问题。
- en: Using navmesh data
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用导航网格数据
- en: 'Now, we''re going to take our test a step further, and look for the nearest
    point on the navmesh to wherever our pointer is pointing:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要进一步测试，寻找离我们指针指向的位置最近的导航网格点：
- en: Right-click in our graph, and create a Project Point to Navigation node
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中右键单击，创建一个Project Point to Navigation节点。
- en: Connect our hit result's Location output to this new node's Point input
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将击中结果的位置输出连接到这个新节点的点输入
- en: 'Connect the node''s Projected Location output with the debug line''s Line End and
    the Debug Sphere''s Center, replacing the location inputs that we''d previously
    been using there:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将节点的Projected Location输出与debug line的Line End和Debug Sphere的Center连接起来，替换之前在那里使用的位置输入：
- en: '![](img/38f742b8-1c43-4944-9ef9-e158f40cdcfd.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38f742b8-1c43-4944-9ef9-e158f40cdcfd.png)'
- en: What we're doing here is querying the navmesh we created to find the closest
    point on the mesh to the location we supplied. This will prevent a location from
    being selected that we'd excluded from our mesh.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是查询我们创建的导航网格，找到离我们提供的位置最近的网格上的点。这将防止选择我们从网格中排除的位置。
- en: As we look around the scene, though, we can start to see that we're going to
    have a problem. Casting a ray straight from the controller isn't going to allow
    us to teleport onto higher locations than where we're currently standing, because
    the ray won't be able to hit the higher floor. This is a flaw in our system, and
    we're going to need to rethink this.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们环顾四周时，我们会发现我们将会遇到一个问题。直接从控制器发射射线将无法让我们传送到比我们当前站立位置更高的位置，因为射线无法击中更高的地板。这是我们系统的一个缺陷，我们需要重新考虑这个问题。
- en: This is why it's so important to stick to our guns and do a *make it work* phase
    before we put a ton of work into cleaning up. It often happens that your first
    running prototype will reveal things you need to rethink, and it's better to discover
    these things early, before you've burned a ton of effort.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在我们投入大量工作之前坚持做一个“让它工作”的阶段非常重要的原因。通常情况下，你的第一个运行原型会揭示出你需要重新考虑的事情，最好在你付出大量努力之前尽早发现这些问题。
- en: Changing from line trace to parabolic trace
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从线追踪切换到抛物线追踪
- en: 'Thinking it through, it becomes clear that we''re going to need a curved path
    to reach points that are higher than our current viewpoint. Let''s modify our
    trace method to make this possible. This is the result we will get:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 经过思考，我们清楚地意识到，为了到达比我们当前视点更高的点，我们需要一个曲线路径。让我们修改我们的追踪方法以实现这一点。这是我们将得到的结果：
- en: '![](img/1fdd3794-85d5-4feb-946b-1ad0f19576bf.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fdd3794-85d5-4feb-946b-1ad0f19576bf.png)'
- en: 'The math used to calculate a parabola is actually fairly simple, but we have
    an even easier option available to us. The `Predict Projectile Path By TraceChannel` method
    already handles the math for us and can save us some time. Let''s use this now:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算抛物线的数学方法实际上相当简单，但我们还有一个更简单的选择。`Predict Projectile Path By TraceChannel`方法已经为我们处理了数学计算，并且可以节省我们一些时间。让我们现在使用它：
- en: Disconnect our Event Tick from the old Line Trace By Channel node.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断开我们的Event Tick与旧的Line Trace By Channel节点的连接。
- en: Right-click in our graph and create a Predict Projectile Path by TraceChannel node.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中右键单击，创建一个Predict Projectile Path by TraceChannel节点。
- en: Connect it to our Tick.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其连接到我们的Tick。
- en: Set its Trace Channel to Visibility.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其Trace Channel设置为Visibility。
- en: Next, connect the output from the GetWorldLocation of MotionController_R to
    the Start Pos input.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将MotionController_R的GetWorldLocation的输出连接到Start Pos输入。
- en: 'To get our Launch Velocity, we''re going to take the Forward Vector of MotionController_R,
    and multiply it by an arbitrary value:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得我们的发射速度，我们将使用MotionController_R的Forward Vector，并将其乘以一个任意值：
- en: Disconnect the old `TeleportTraceLength` variable from the Multiply node.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断开旧的`TeleportTraceLength`变量与Multiply节点的连接。
- en: Drag out a new connector from the Multiply node's float input and promote it
    to a variable. Let's name it `TeleportLaunchVelocity`.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Multiply节点的float输入处拖出一个新的连接器，并将其提升为一个变量。让我们将其命名为`TeleportLaunchVelocity`。
- en: Compile our Blueprint, and give it a value of 900.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译我们的蓝图，并给它一个值为900。
- en: 'Connect the result to the Launch Velocity input:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果连接到Launch Velocity输入：
- en: '![](img/ce8fc76f-f782-44d0-9420-f587a65d1c6d.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce8fc76f-f782-44d0-9420-f587a65d1c6d.png)'
- en: Now, let's draw the resulting path so that we can verify that it's doing what
    we expect.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们绘制结果路径，以便验证它是否按照我们的预期进行。
- en: Drawing the curved path
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制曲线路径
- en: 'The `Predict Projectile Path By TraceChannel` method is going to return an
    array of points describing the path of the parabola. We can use these points to
    draw our targeting indicator. Let''s get started:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predict Projectile Path By TraceChannel`方法将返回一个描述抛物线路径的点的数组。我们可以使用这些点来绘制我们的目标指示器。让我们开始吧：'
- en: Just as we did previously, connect a Branch to our Return Value. We're only
    interested in drawing anything if we got a good result.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，将一个Branch连接到我们的Return Value。我们只对得到一个好结果时才感兴趣。
- en: Now, to draw the curved path, we're actually going to have to draw a series
    of debug lines instead of just one.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了绘制曲线路径，我们实际上需要绘制一系列的debug line，而不仅仅是一个。
- en: 'Let''s drag a connector from Out Path Positions and create a ForEachLoop node:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从Out Path Positions拖出一个连接器并创建一个ForEachLoop节点：
- en: '![](img/e8df5cc7-1db3-44b9-b132-6ec6f6f8e7aa.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8df5cc7-1db3-44b9-b132-6ec6f6f8e7aa.png)'
- en: We should take a moment to talk about what we're doing here, since this is a
    concept you'll use quite a lot.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该花点时间来讨论我们在这里做什么，因为这是一个你将经常使用的概念。
- en: So far, all of the variables we've handled in our pawn Blueprint have contained
    single values—a number, a true or false value, and a vector. The connector for
    Out Path Positions, however, looks different. Instead of a circle, it's a 3 x
    3 grid. This icon indicates that this is an **array**. Rather than holding a single
    value, an array contains a list of values. In this case, those values are a list
    of points that make up the curved path we're going to draw.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的pawn蓝图中处理的所有变量都只包含单个值-一个数字，一个true或false值和一个向量。然而，Out Path Positions的连接器看起来不同。它不是一个圆圈，而是一个3
    x 3的网格。这个图标表示这是一个**数组**。数组不同于单个值，它包含一个值列表。在这种情况下，这些值是构成我们要绘制的曲线路径的点的列表。
- en: A *For Each Loop* is a programming structure called an **iterator**. Iterators
    loop through collections of values and allow you to perform operations on each
    element in the collection.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*For Each Loop*是一种称为**迭代器**的编程结构。迭代器循环遍历值的集合，并允许您对集合中的每个元素执行操作。'
- en: 'Let''s take a quick look at the ForEach Loop''s outputs:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看一下ForEach Loop的输出：
- en: The Loop Body will execute once for each item it finds in the array.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环体将为数组中的每个项目执行一次。
- en: The Array Element is the item it found.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组元素是它找到的项目。
- en: The Array Index is where it found it. Arrays are always numbered from zero,
    so the first item will have an index of 0, the second will have an index of 1,
    and so on.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组索引是它找到的位置。数组总是从零开始编号，所以第一个项目的索引为0，第二个项目的索引为1，依此类推。
- en: The Completed execution pin will be called when it reaches the end of the list.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它到达列表的末尾时，将调用Completed执行引脚。
- en: 'We''re going to use this loop to draw the line segments of our curve, but we''re
    going to need two points for each segment, which means we can''t draw anything
    until we reach the second point in the array:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个循环来绘制曲线的线段，但是每个线段需要两个点，这意味着在数组中达到第二个点之前我们不能绘制任何东西：
- en: Drag a connector from the Array Index output and connect it to an integer |
    integer node. Leave the second value as 0.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数组索引输出拖动连接器，并将其连接到一个整数|整数节点上。将第二个值保留为0。
- en: Connect its output to a Branch, and connect the Loop Body to the Branch input.
    This will allow us to skip the first value in the array.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其输出连接到一个分支，并将循环体连接到分支输入。这将允许我们跳过数组中的第一个值。
- en: 'Create a Draw Debug Line node, and connect the Array Element to the Line End
    input. Since we''re starting with the second value of the array, the point at
    that location is the end of our line. We''re going to get the line start by getting
    the point before it:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Draw Debug Line节点，并将数组元素连接到线段结束输入。由于我们从数组的第二个值开始，该位置上的点是我们线段的结束点。我们将通过获取它之前的点来获取线段的起点：
- en: '![](img/6ee3a718-2a43-4df8-b60f-083d68ed88d4.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ee3a718-2a43-4df8-b60f-083d68ed88d4.png)'
- en: To find our Line Start, drag another connector from the Array Index, and *subtract
    1* from it.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到我们的线段起点，从数组索引再拖动一个连接器，并从中减去1。
- en: 'Now, drag another connector from Out Path Positions, and type `Get` into the
    search box. Select Get (a copy):'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从Out Path Positions再拖动一个连接器，并在搜索框中输入`Get`。选择Get（复制）：
- en: '![](img/7fbff992-33c2-4e33-bdff-647a3e5ac552.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fbff992-33c2-4e33-bdff-647a3e5ac552.png)'
- en: This will get the element stored at the location in the array corresponding
    to the index we give it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取存储在数组中与给定索引对应位置的元素。
- en: Connect the result of our Array Index -1 subtraction to the Get node's integer
    input. This will retrieve the value before the one we're currently iterating on.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的数组索引减1的结果连接到Get节点的整数输入上。这将检索当前迭代的前一个值。
- en: 'Connect the output from this Get node to the Line Start of Draw Debug Line:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此Get节点的输出连接到Draw Debug Line的Line Start：
- en: '![](img/6abe0f30-f3cf-4a2a-bc6e-433261e589ad.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6abe0f30-f3cf-4a2a-bc6e-433261e589ad.png)'
- en: When you're finished, the drawing routine should look something like what's
    shown in the preceding screenshot.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，绘图例程应该看起来像前面截图中显示的样子。
- en: What we've just done here is looped through each of the path position vectors
    in Out Path Positions, and for each one after the first, we drew a line from the
    position before it to the current one, until we reached the end of the list.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚做的是遍历Out Path Positions中的每个路径位置向量，并且对于第一个之后的每个位置，我们从其前一个位置绘制一条线到当前位置，直到达到列表的末尾。
- en: Drawing the endpoint after all the line segments have been drawn
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在绘制完所有线段后绘制终点
- en: 'Finally, let''s draw a debug sphere at the trace endpoint. We can reuse the
    nodes we were previously using to draw the sphere at the end of our straight line
    trace:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在追踪终点处绘制一个调试球体。我们可以重复使用之前用于绘制直线追踪末端的节点：
- en: Just as we did before, **break** the **Hit Result** struct from Out Hit.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像之前一样，从Out Hit中**break**出**Hit Result**结构。
- en: Take its Location and feed it into a ProjectPointToNavigation node.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其位置输入到ProjectPointToNavigation节点中。
- en: Connect a Branch to its Return Value, and feed the **True** branch's execution
    into a Draw Debug Sphere node.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个分支连接到其返回值，并将True分支的执行连接到一个Draw Debug Sphere节点。
- en: Use the Projected Location as the debug sphere's Center.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将投影位置用作调试球体的中心。
- en: Rather than calling this right after the Draw Debug Line node, however, call
    it from the Completed output of ForEachLoop instead, since we only need to draw
    the sphere once after all of the line segments have been drawn.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不要在绘制调试线节点之后立即调用它，而是从ForEachLoop的Completed输出中调用它，因为我们只需要在绘制完所有线段后绘制一次球体。
- en: 'Your graph should now look like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您的图表现在应该如下所示：
- en: '![](img/e7bde58c-9e8b-41f4-b8af-0fbc6d824817.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7bde58c-9e8b-41f4-b8af-0fbc6d824817.png)'
- en: 'Let''s test it and see what happens when we run it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下，看看运行时会发生什么：
- en: '![](img/4cc4228f-796c-44ca-98ce-0bae0b3a67a1.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cc4228f-796c-44ca-98ce-0bae0b3a67a1.png)'
- en: Great! We're now projecting a curved path that will allow us to get around the
    map much more easily, and we've used debug drawing to verify that it's giving
    us good results.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在正在投射一条曲线路径，这将使我们更容易在地图上移动，并且我们使用调试绘制来验证它给我们带来了良好的结果。
- en: The Draw Debug methods we're using here will only work in debug and development
    builds. They aren't included in shipping builds. The correct way to draw this
    path would be to use the collection of points in Out Path Positions to change
    the shape of a spline mesh, but doing this is beyond the scope of this book. There's
    a good example, however, in the VR Template, and the work we've done here is a
    good starting point for understanding what they're doing in that project's Blueprints.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的Draw Debug方法只适用于调试和开发版本。它们不包含在发布版本中。绘制这条路径的正确方法是使用Out Path Positions中的点集合来改变样条网格的形状，但是这超出了本书的范围。然而，在VR模板中有一个很好的例子，我们在这里所做的工作是理解他们在该项目的蓝图中所做的工作的良好起点。
- en: Next, let's take care of the next job and allow our player to teleport to the
    destination they've chosen.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理下一个任务，允许玩家传送到他们选择的目的地。
- en: Teleporting the player
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传送玩家
- en: The first thing we need to do in this instance is give the player a way to tell
    the system when they intend to teleport.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们首先需要做的是给玩家一种告诉系统他们打算传送的方式。
- en: Creating Input Mappings
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建输入映射
- en: 'We''re going to use our Engine Input Mappings to set up a new named input.
    Let''s get started:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用引擎输入映射来设置一个新的命名输入。让我们开始吧：
- en: Open your Project Settings and navigate to Engine | Input.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目设置并导航到Engine | Input。
- en: 'Hit the + sign beside Bindings | Action Mappings to create a new action mapping:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Bindings | Action Mappings旁边的+号创建一个新的动作映射：
- en: '![](img/a39aa2d2-d39d-426c-a319-852ff1d2f7c3.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a39aa2d2-d39d-426c-a319-852ff1d2f7c3.png)'
- en: We're going to name it `TeleportRight`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把它命名为`TeleportRight`。
- en: What this is going to do is create an input event with this name that we can
    then respond to in our event graphs.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为TeleportRight的输入事件，我们可以在事件图中对其进行响应。
- en: You may have already discovered that you can set up events in your event graphs
    directly to listen to controller inputs and keystrokes. For most projects, though,
    it's a better idea to map your inputs here as it gives you a central location
    from which to manage them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经发现，您可以直接在事件图中设置事件来监听控制器输入和按键。然而，对于大多数项目来说，将输入映射到这里是一个更好的主意，因为它为您提供了一个集中管理它们的位置。
- en: 'Now, let''s indicate what inputs should trigger this teleport action. A drop-down
    menu has appeared beneath the new action mapping with a None indicator displayed.
    (Hit the expander arrow beside the action mappings if the drop-down menu isn''t
    visible.) Let''s carry on:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们指示哪些输入应触发此传送动作。在新的动作映射下方出现了一个下拉菜单，显示了None指示器。（如果下拉菜单不可见，请点击动作映射旁边的展开箭头。）让我们继续：
- en: Under TeleportRight, use the drop-down menu to select MotionController (R) Thumbstick.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TeleportRight下方，使用下拉菜单选择MotionController (R) Thumbstick。
- en: This will handle our Oculus Touch controller mappings, but doesn't help us on
    the HTC Vive, which doesn't use thumbsticks.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将处理我们的Oculus Touch控制器映射，但对于不使用拇指杆的HTC Vive来说并没有帮助。
- en: Hit the + sign beside the TeleportRight action to add another mapping to the
    group.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击TeleportRight动作旁边的+号，添加另一个映射到该组。
- en: 'Select MotionController (R) FaceButton1 for this one:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此选择MotionController (R) FaceButton1：
- en: '![](img/5b681e76-7e02-46bb-8b55-096201144bc9.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b681e76-7e02-46bb-8b55-096201144bc9.png)'
- en: Your bindings should now look like what's shown in the preceding screenshot.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您的绑定现在应该看起来像前面的截图所示。
- en: Now, we've told the input system to send a TeleportRight input event, regardless
    of whether the player is using a motion controller with a thumbstick or one with
    face buttons.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经告诉输入系统发送一个名为TeleportRight的输入事件，无论玩家是否使用带有拇指杆或带有面部按钮的动作控制器。
- en: These bindings are stored in `DefaultInput.ini` and can be edited there, but
    it's generally more convenient to set them up here in the Project Settings UI.
    If you need to copy a bunch of input bindings from one project to another, however,
    it can be convenient to copy the contents of `DefaultInput.ini` from one project
    to another. Not every project will have `DefaultInput.ini`. If yours doesn't,
    you can simply add it and the engine will use it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绑定存储在`DefaultInput.ini`中，并可以在那里进行编辑，但通常在项目设置UI中设置它们更方便。然而，如果您需要将一堆输入绑定从一个项目复制到另一个项目，将`DefaultInput.ini`的内容从一个项目复制到另一个项目可能更方便。并非每个项目都有`DefaultInput.ini`。如果您的项目没有，您可以简单地添加它，引擎将使用它。
- en: 'Let''s close Project Settings and return to our VRPawn''s event graph. You''ll
    find that you can now create a TeleportRight event here, since we defined it in
    our input settings. Let''s do this, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关闭项目设置并返回到我们的VRPawn的事件图。您会发现，您现在可以在这里创建一个TeleportRight事件，因为我们在输入设置中定义了它。让我们这样做，如下所示：
- en: '![](img/14f0af2a-817f-4ff6-b388-0d5950bbf8a3.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14f0af2a-817f-4ff6-b388-0d5950bbf8a3.png)'
- en: Caching our teleport destination
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存我们的传送目的地
- en: 'Now, before we do anything with this event, we need to store the location we
    found in our trace method previously so that we can use it here when the player
    tries to teleport:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们处理此事件之前，我们需要存储我们之前在跟踪方法中找到的位置，以便在玩家尝试传送时可以在此处使用它：
- en: Under My Blueprint | Variables, hit the + sign to create a new variable.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在My Blueprint | Variables下，点击+号创建一个新变量。
- en: Set its type to Boolean, and name it `bHasValidTeleportDest`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其类型设置为布尔型，并将其命名为`bHasValidTeleportDest`。
- en: Variable names are important. They tell the reader (who might be another developer
    maintaining your code or might be yourself in the future) what a variable represents.
    Your variable names should accurately reflect what they contain. In the case of
    True/False Boolean variables, make sure your name describes what question it's
    actually answering. So, for instance, in this case, *Teleport* would be a poor
    choice for a name, as it doesn't indicate whether the variable's value means that
    the player can teleport, is teleporting, has recently teleported, or just enjoys
    daydreaming about teleporting. Be clear about these things. `bHasValidTeleportDest`
    clearly indicates what it means.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名很重要。它们告诉读者（可能是另一个开发人员维护您的代码，也可能是将来的自己）变量代表什么。您的变量名应准确反映它们所包含的内容。对于True/False布尔变量，确保您的名称描述了它实际回答的问题。因此，在这种情况下，*Teleport*将是一个不好的选择，因为它并没有说明变量的值是否意味着玩家可以传送，正在传送，最近传送，还是只是喜欢幻想传送。对这些事情要清楚明确。`bHasValidTeleportDest`清楚地指示了它的含义。
- en: Prefixing Boolean variable names with *b* is a practice mandated by Epic's coding
    style guide for C++, but it's a good idea to follow it in Blueprint development
    as well. (If you plan on developing in C++, you should know and follow the Unreal
    style guide, which can be found at [https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard](https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard).)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，将布尔变量的名称前缀为*b*是Epic编码风格指南的规定，但在Blueprint开发中也是一个好主意。（如果您计划在C++中进行开发，您应该了解并遵循Unreal风格指南，可以在[https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard](https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard)找到。）
- en: Create another variable and name it `TeleportDest`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个变量并将其命名为`TeleportDest`。
- en: Set its type to Vector.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其类型设置为矢量。
- en: 'Let''s populate these variables. The location we care about is the Projected
    Location found by the Project Point to Navigation method we''re calling at our
    hit location. Let''s store whether we''ve found a valid location. You''ll probably
    want to drag the Draw Debug Sphere node a bit to the right to give yourself some
    room since we''re about to add a few nodes before we call it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们填充这些变量。我们关心的位置是我们在命中位置调用的Project Point to Navigation方法找到的Projected Location。让我们存储我们是否找到了有效的位置。由于我们即将在调用之前添加一些节点，您可能希望将Draw
    Debug Sphere节点向右移动一点以腾出一些空间：
- en: Drag your `bHasValidTeleportDest` variable onto the event graph, and select
    set when asked.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的`bHasValidTeleportDest`变量拖放到事件图上，并在询问时选择设置。
- en: Do you see where the Completed output from the ForEach loop runs into the Branch
    statement coming out of our Project Point to Navigation method?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否看到ForEach循环的Completed输出与我们的Project Point to Navigation方法输出的Branch语句相连？
- en: Press *Ctrl* + drag the execution input into that Branch node to move it onto
    the `CanTeleport` setter. (Notice that the *b* prefix on Boolean variables is
    automatically hidden when the variable is used in a graph.)
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl* +拖动执行输入到该Branch节点，将其移动到`CanTeleport`设置器上。（注意，当变量在图表中使用时，布尔变量上的*b*前缀会自动隐藏。）
- en: Feed the Return Value from the Project Point to Navigation method into this
    variable. You can press *Ctrl* + drag to move this too.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Project Point的返回值馈送到Navigation方法中的此变量中。您可以按下*Ctrl* +拖动以将其移动。
- en: Drag an execution line from Set bHasValidTeleportDest to the Branch input, and
    use the output of the setter to drive the branch.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Set bHasValidTeleportDest拖动一个执行线到Branch输入，并使用设置器的输出来驱动该分支。
- en: 'Let''s set our TeleportDest to the Project Point to Navigation method''s projected
    location if it returns true:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Project Point to Navigation方法返回true，则将TeleportDest设置为其投影位置：
- en: Drag our `TeleportDest` variable onto the event graph and choose to set it.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的`TeleportDest`变量拖放到事件图上并选择设置。
- en: Take the execution line running from our Branch node into our Draw Debug Sphere
    node, and press *Ctrl* + drag it to move it into the Set Teleport Dest input.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从Branch节点到Draw Debug Sphere节点的执行线拖动，并按下*Ctrl* +拖动它以将其移动到Set Teleport Dest输入中。
- en: Feed the Projected Location output into the `TeleportDest` variable.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Projected Location输出馈送到`TeleportDest`变量中。
- en: Now, just because it's cleaner, let's feed the output from the `TeleportDest`
    setter into the Center input on our DrawDebugSphere node.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只是因为它更干净，让我们将`TeleportDest`设置器的输出馈送到我们的DrawDebugSphere节点的Center输入上。
- en: It's worth learning about Blueprint shortcuts. Pressing *Alt* + clicking on
    a connection disconnects it. Pressing *Ctrl* + dragging a connection allows you
    to move it somewhere else.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 值得学习蓝图快捷键。按下*Alt* +点击连接可以断开连接。按下*Ctrl* +拖动连接可以将其移动到其他位置。
- en: From the False execution pin of Branch, let's set TeleportDest to (`0.0, 0.0,
    0.0`).
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Branch的False执行引脚中，让我们将TeleportDest设置为(`0.0, 0.0, 0.0`)。
- en: 'Your graph should now look like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您的图现在应该是这样的：
- en: '![](img/5bbdda98-cb03-419b-b6b8-ecf6fff953d6.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bbdda98-cb03-419b-b6b8-ecf6fff953d6.png)'
- en: Can you see the extra pin on the connection between Projected Location and Set
    Teleport Dest? That's a **Reroute Node**. You can create one by dragging a connection
    out and selecting Add Reroute Node from the creation dialog, or by *double-clicking*
    on an existing connector. These are useful for organizing your connections so
    that you can easily see what's going on in your graphs. In general, try to avoid
    allowing connectors to cross underneath nodes they're not connected to, as this
    can mislead someone reading your Blueprint. You can also feed multiple inputs
    into a reroute node or branch multiple outputs from it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否看到Projected Location和Set Teleport Dest之间连接上的额外引脚？那是一个**Reroute Node**。您可以通过拖动连接并选择从创建对话框中添加Reroute
    Node来创建一个，或者通过*双击*现有连接器来创建一个。这些对于组织连接非常有用，以便您可以轻松地看到图表中发生的情况。一般来说，尽量避免允许连接器在未连接到的节点下交叉，因为这可能会误导阅读您的蓝图的人。您还可以将多个输入馈送到reroute节点，或从reroute节点分支多个输出。
- en: Now, on every tick, we have either a true or a false value in `bHasValidTeleportDest`,
    and if it's true, we have the location to which we could teleport.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次tick，我们在`bHasValidTeleportDest`中都有一个true或false的值，如果为true，则有一个我们可以传送到的位置。
- en: Executing the teleport
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行传送
- en: 'Let''s use the value we''ve just stored in the `bHasValidTeleportDest` flag
    to see whether we have a valid destination, and teleport the player pawn to the
    `TeleportDest` if we do:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用刚刚存储在`bHasValidTeleportDest`标志中的值来查看我们是否有有效的目标，并在有时将玩家角色传送到`TeleportDest`：
- en: From the `TeleportRight` input action we created a moment ago, we'll connect
    an execution line from its Pressed output into a Branch node.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们刚刚创建的`TeleportRight`输入操作中，我们将从其Pressed输出连接一个执行线到一个Branch节点。
- en: Remember that you can hold down *B* and click to create a Branch node. Take
    a look at the other shortcuts found on Epic's Blueprint Editor Cheat Sheet here: [https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/CheatSheet](https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/CheatSheet).
    They'll save you a lot of time.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您可以按住*B*并单击以创建一个Branch节点。在这里查看Epic的蓝图编辑器Cheat Sheet中找到的其他快捷键：[https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/CheatSheet](https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/CheatSheet)。它们将为您节省很多时间。
- en: Grab your `bHasValidTeleportDest` variable and drag it onto the Branch node's
    Condition input.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动您的`bHasValidTeleportDest`变量并将其拖放到Branch节点的Condition输入上。
- en: 'From the True execution output, create a SetActorLocation action, and drag
    your `TeleportDest` variable onto its New Location input:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从True执行输出中创建一个SetActorLocation动作，并将您的`TeleportDest`变量拖放到其New Location输入上：
- en: '![](img/886789e5-a692-4944-b19c-7660d9b5930e.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/886789e5-a692-4944-b19c-7660d9b5930e.png)'
- en: Launch it into a VR preview and give it a shot. You should now be able to teleport
    around the map. It's nice to be able to explore, right?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 将其启动到VR预览中并试一试。现在您应该能够在地图上进行传送。能够探索是很好的，对吧？
- en: Now that we have everything working, let's do some work to improve things.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让一切正常工作，让我们做一些工作来改进事情。
- en: The first thing we'll notice when we start jumping around the map is that we
    don't have any way to change the player's orientation at their landing position.
    We can definitely improve this.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始在地图上跳来跳去时，我们会注意到一个问题，那就是我们没有任何方法来改变玩家在着陆位置的朝向。我们肯定可以改进这一点。
- en: Allowing the player to choose their landing orientation
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许玩家选择着陆方向
- en: If we want our player to be able to specify their facing direction when they
    land, the first thing we're going to need to do is give them a way to tell the
    system where they want to be looking.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望玩家能够在着陆时指定他们的面朝方向，我们首先需要做的是给他们一种告诉系统他们想要朝向何处的方法。
- en: Mapping axis inputs
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射轴输入
- en: 'Let''s add an input to give our player a way to do this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个输入，为玩家提供一种改变朝向的方式：
- en: Open up Project Settings | Engine | Input.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“项目设置”|“引擎”|“输入”。
- en: Do you see the section in Bindings | Action Mappings where we set up our TeleportRight
    input? Right below it is a list of **Axis Mappings**.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在“绑定”|“动作映射”中的部分中，您是否看到我们设置TeleportRight输入的部分？它的下方是一个**轴映射**列表。
- en: Hit the + button beside Axis Mappings to add a new mapping.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击轴映射旁边的+按钮添加一个新映射。
- en: Use the expansion arrow to open it up, and name it `MotionControllerThumbRight_Y`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用展开箭头打开它，并将其命名为`MotionControllerThumbRight_Y`。
- en: Map it to MotionController (R) Thumbstick Y.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其映射到MotionController（R）的拇指杆Y。
- en: Set its scale to -1.0.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其比例设置为-1.0。
- en: Create a second mapping, named `MotionControllerThumbRight_X`.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个映射，命名为`MotionControllerThumbRight_X`。
- en: Map it to `MotionController (R) Thumbstick X`, and leave its scale as 1.0.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其映射到`MotionController (R) Thumbstick X`，并将其比例保留为1.0。
- en: 'Unreal''s input system handles two kinds of mappings: **Action Mappings** and
    **Axis Mappings**. Action mappings are discrete events, such as button or key
    presses and releases. Axis mappings give you continuous information about an analog
    input, such as a joystick or a trackpad.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal的输入系统处理两种映射：**动作映射**和**轴映射**。动作映射是离散事件，例如按钮或键的按下和释放。轴映射为您提供有关模拟输入（例如操纵杆或触控板）的连续信息。
- en: 'You may have noticed that we scaled the Y input from our motion controller
    thumbstick by -1.0\. This is because the Y input from that device comes in reversed,
    so we need to flip it. Multiplying it by -1 simply inverts the input:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们通过-1.0缩放了来自运动控制器拇指杆的Y输入。这是因为该设备的Y输入是反向的，所以我们需要翻转它。将其乘以-1只是反转输入：
- en: '![](img/66967fe7-325a-4f12-b74d-a59c64f782fc.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66967fe7-325a-4f12-b74d-a59c64f782fc.png)'
- en: Your input mappings should now look like what's shown in the preceding screenshot.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输入映射现在应该看起来像前面的截图所示。
- en: Now that we've added our new input mappings, we can close our project settings.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了新的输入映射，我们可以关闭项目设置。
- en: Cleaning up our Tick event
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理我们的Tick事件
- en: Let's jump back to our pawn's event graph.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到角色的事件图。
- en: 'Since we want to check the player''s thumbstick position continuously while
    we''re setting up a teleport, we''re going to need to put this on the Event Tick.
    Our Tick event is getting a little crowded, though. Let''s clean it up before
    we start adding more:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在设置传送时持续检查玩家的拇指杆位置，因此我们需要将其放在事件Tick上。不过，我们的Tick事件有点拥挤。在开始添加更多内容之前，让我们先整理一下：
- en: 'Drag a marquee over the current contents of your Tick event:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前Tick事件的内容上拖动一个选框：
- en: '![](img/b0efc0af-adb4-485b-8f96-660516a68778.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0efc0af-adb4-485b-8f96-660516a68778.png)'
- en: Select all the nodes connected to your Event Tick.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 选择与事件Tick连接的所有节点。
- en: 'Right-click anywhere on the selected nodes and select Collapse to Function
    from the context menu:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击所选节点上的任意位置，并从上下文菜单中选择“折叠到函数”：
- en: '![](img/5faa06cf-bec0-47f9-bbc3-61a8b7a92911.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5faa06cf-bec0-47f9-bbc3-61a8b7a92911.png)'
- en: Right-click any of the selected nodes and select Collapse to Function.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击所选节点中的任意一个，并选择“折叠到函数”。
- en: Name the new function `SetTeleportDestination`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新函数命名为`SetTeleportDestination`。
- en: 'That''s much cleaner, isn''t it? Take a look at the following screenshot:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这样干净多了，不是吗？看一下下面的截图：
- en: '![](img/229b9c0c-9109-4b4c-8416-7cb8c4c3f7d9.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/229b9c0c-9109-4b4c-8416-7cb8c4c3f7d9.png)'
- en: In general, it's a good idea to use functions as a way of organizing and reusing
    your code, rather than leaving things strewn all over your event graph. Remember
    that 80% of the life cycle of any piece of code will be spent in debugging and
    maintaining it, so organizing your code early can save you quite a lot of work
    later on.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，使用函数作为组织和重用代码的一种方式是一个好主意，而不是将代码散布在整个事件图中。记住，任何代码的80%生命周期都将花在调试和维护上，因此早期组织代码可以节省很多工作量。
- en: The names you give your functions should be descriptive and they should be accurate.
    Think of them as a promise to the reader that the contents of the function really
    do whatever the name suggests they do. That reader might be you in the future,
    debugging or updating your code, or it might be another developer altogether.
    If you've named your functions clearly, everyone's going to have a much easier
    time understanding what your code is doing. If you modify a function in a way
    that changes what it does, change its name too. Don't let a legacy name mislead
    your reader.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您给函数起的名称应该是描述性的，准确的。将它们视为对读者的承诺，函数的内容确实做了名称所暗示的事情。这个读者可能是您将来调试或更新代码的人，也可能是完全不同的另一个开发人员。如果您清晰地命名了函数，每个人都将更容易理解您的代码在做什么。如果您以改变函数的方式修改函数，也要更改其名称。不要让传统名称误导读者。
- en: Using thumbstick input to orient the player
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用拇指杆输入来定位玩家
- en: 'Let''s create a new function to handle our teleport orientation:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新函数来处理我们的传送定位：
- en: Hit the + button in My Blueprint | Functions to create a new function.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“我的蓝图”|“函数”中的+按钮创建一个新函数。
- en: Name it `SetTeleportOrientation`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`SetTeleportOrientation`。
- en: A new tab will automatically open, showing you the contents of your function.
    Right now, it just contains an entry point with an execution pin.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的选项卡将自动打开，显示函数的内容。现在，它只包含一个带有执行引脚的入口点。
- en: Right-click anywhere inside the function's graph and type `thumbright` into
    the context menu's search box. You'll see that the two Axis Mappings you created
    in your input settings are now visible here as functions.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数的图表中的任何位置右键单击，然后在上下文菜单的搜索框中键入“thumbright”。您将看到您在输入设置中创建的两个轴映射现在在这里显示为函数。
- en: 'Add the Get MotionControllerThumbRight_Y and Get MotionControllerthumbRight_X nodes
    here:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里添加Get MotionControllerThumbRight_Y和Get MotionControllerthumbRight_X节点：
- en: '![](img/c18a43bd-4d09-4d9e-8c47-c982dc18ee98.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c18a43bd-4d09-4d9e-8c47-c982dc18ee98.png)'
- en: Create a Make Vector node.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Make Vector节点。
- en: Feed the return value from Get MotionControllerThumbRight_Y into the Make Vector node's
    X input. (This may seem backward, but it's correct—we need to transform this input
    to use it to drive our rotation.)
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Get MotionControllerThumbRight_Y的返回值输入到Make Vector节点的X输入中。（这可能看起来有些奇怪，但是是正确的——我们需要转换这个输入以用于驱动我们的旋转。）
- en: Feed Get MotionControllerThumbRight_X into the new vector's Y input.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Get MotionControllerThumbRight_X输入到新向量的Y输入中。
- en: 'Normalize the new vector by adding a Normalize node to the Make Vector''s Return
    Value:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Make Vector的返回值上添加一个Normalize节点来归一化新向量：
- en: '![](img/7c7eb290-ddc7-496b-9f79-50783dd11647.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c7eb290-ddc7-496b-9f79-50783dd11647.png)'
- en: '**Normalizing** a vector scales it to a length of 1\. A vector whose length
    is 1 is called a **unit vector**. Many mathematical operations on vectors will
    return incorrect results if they''re called on vectors with arbitrary lengths.
    A general rule of thumb is that, if you''re doing vector operations to figure
    out rotations or angles, make sure you''re using unit vectors.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**归一化**一个向量将其缩放为长度为1。长度为1的向量称为**单位向量**。如果对任意长度的向量进行数学运算，很多情况下会得到错误的结果。一个经验法则是，如果你正在进行向量运算以确定旋转或角度，请确保使用单位向量。'
- en: Now that we've normalized our input vector, we need to rotate it so it's aiming
    in the direction the player intends.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将输入向量归一化，我们需要将其旋转，使其指向玩家的意图方向。
- en: 'Here''s the thing about designing locomotion systems for VR: when you present
    the player with a rotation, you have to decide what its basis is going to be.
    When the player pushes a stick forward or touches forward on a trackpad, how do
    we translate that into a real-world rotation? If you''ve operated a remote control
    car or been playing games long enough to remember the old *tank-style* controls
    in *Resident Evil* and *Fear Effect*, you have some notion of what we''re describing
    here. *Forward* in those systems meant the direction the car or character was
    facing, and if the character was facing the camera at the moment, those controls
    were going to feel backward.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 关于为VR设计运动系统的问题是：当你向玩家展示一个旋转时，你必须决定它的基础是什么。当玩家向前推杆或触摸触控板向前时，我们如何将其转化为真实世界的旋转？如果你操作过遥控车或者玩游戏的时间足够长以记得*Resident
    Evil*和*Fear Effect*中的旧式*坦克式*控制，你对我们在这里描述的有一些概念。在这些系统中，“前进”意味着汽车或角色所面对的方向，如果角色此时面对摄像机，那么这些控制将会感觉反向。
- en: In traditional first-person designs over the past two decades, this isn't a
    problem we've had to address. There was no difference between the direction the
    character was facing and the direction the player was looking, so using the camera's
    look direction as a forward direction was an obvious choice.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的二十年里，传统的第一人称设计中，我们没有必须解决这个问题。角色面对的方向和玩家所看的方向没有区别，所以使用摄像机的观察方向作为前进方向是一个明显的选择。
- en: 'In VR, on the other hand, we have several options:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中，另一方面，我们有几个选择：
- en: We can base our rotation on the *pawn's rotation*, but that's not a great idea
    in room-scale VR, as the player can turn around in the tracking volume without
    necessarily rotating their pawn. You don't want to orient a control based on something
    the player may not be able to see.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以基于*角色的旋转*进行旋转，但在房间尺度的VR中，这不是一个好主意，因为玩家可以在跟踪范围内转身而不一定旋转角色。你不希望基于玩家可能看不到的东西来定位控制。
- en: 'We could base it on the player''s *look direction*, which is a better choice
    since it''s consistent from the player''s perspective, but creates funky behaviors
    as the player looks around:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以基于玩家的*观察方向*进行旋转，这是一个更好的选择，因为从玩家的角度来看，它是一致的，但在玩家四处观察时会产生奇怪的行为：
- en: '![](img/0be22159-18b2-4344-9e65-a967eac571d2.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0be22159-18b2-4344-9e65-a967eac571d2.png)'
- en: A character in VR can have several transforms at the same time - head, body,
    and hands.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中，一个角色可以同时具有多个变换——头部、身体和手部。
- en: In VR, a player's head, hands, and body can rotate independently of each other,
    so it's no longer always obvious where *forward* is.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中，玩家的头部、手部和身体可以独立于彼此旋转，所以前进方向不再总是明显的。
- en: The best choice, though (and as we'll discover later on when we handle seamless
    locomotion), is to base it on the *motion controller's orientation*, since the
    player's already using it to provide input, is aware of its orientation, and can
    change its orientation easily.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最好的选择（并且当我们处理无缝运动时，我们将在后面发现）是基于*运动控制器的方向*，因为玩家已经在使用它提供输入，意识到它的方向，并且可以轻松改变它的方向。
- en: 'Let''s set our system up this way:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式设置我们的系统：
- en: Add a RotateVector node to our Normalize node's return value.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Normalize节点的返回值中添加一个RotateVector节点。
- en: Drag a reference to MotionController_R onto the graph.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中拖动对MotionController_R的引用。
- en: 'Drag a GetWorldRotation node from MotionController_R:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从MotionController_R中拖动一个GetWorldRotation节点：
- en: '![](img/8d80a478-519e-4f05-a674-d42280c63066.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d80a478-519e-4f05-a674-d42280c63066.png)'
- en: This will get us the right controller's orientation in the world, but we're
    only interested in the side-to-side rotation (Yaw). We don't want any Pitch or
    Roll information.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到我们在世界中正确的控制器方向，但我们只对左右旋转（偏航）感兴趣。我们不需要任何俯仰或滚转信息。
- en: 'Right-click the Return Value from GetWorldRotation and select Split Struct
    Pin:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击GetWorldRotation的返回值，并选择Split Struct Pin：
- en: '![](img/49174351-383e-4ef5-b593-07b7c6a0b052.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49174351-383e-4ef5-b593-07b7c6a0b052.png)'
- en: Do the same for the RotateVector node's B input.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于RotateVector节点的B输入也做同样的操作。
- en: 'Connect the Yaw output from GetWorldRotation to the Yaw input to RotateVector.
    Leave Roll and Pitch unconnected:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将GetWorldRotation的Yaw输出连接到RotateVector的Yaw输入上。将Roll和Pitch保持未连接状态：
- en: '![](img/f04385ed-7840-4577-b0fc-eded2656a91d.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f04385ed-7840-4577-b0fc-eded2656a91d.png)'
- en: '**Splitting** struct pins in Blueprints is often cleaner than using **Break**
    and **Make** nodes to split them and reconstruct them. They do the same thing.
    It''s purely a question of what makes your Blueprint more readable.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图中，拆分结构引脚通常比使用Break和Make节点来拆分和重构它们更清晰。它们做的是同样的事情。这只是一个关于如何使你的蓝图更易读的问题。
- en: Now, we need to turn our rotated vector into a rotator we can use.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将旋转后的向量转换为可用的旋转器。
- en: Add a RotationFromXVector node to the RotateVector's return value.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个RotationFromXVector节点添加到RotateVector的返回值中。
- en: Finally, we need to store this vector so that we can use it later.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要存储这个向量，以便以后使用。
- en: Drag the RotationFromXVector node's return value out and select Promote to variable.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RotationFromXVector节点的返回值拖出来，并选择Promote to variable。
- en: Name the new variable `TeleportOrientation`.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新变量命名为`TeleportOrientation`。
- en: This will create a Set node for the new variable automatically. Drag an execution
    line from your function's entry point to this setter.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将自动为新变量创建一个Set节点。从函数的入口点拖动一个执行线到这个setter上。
- en: Drag an execution line from your setter and select Add Return Node to add an
    exit point to your function.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的setter拖动一个执行线，并选择添加Return Node来添加一个函数的退出点。
- en: '![](img/8ad87534-e51e-4ae6-adef-9dd78b577393.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ad87534-e51e-4ae6-adef-9dd78b577393.png)'
- en: We're now converting the return value from our RotateVector node to a rotator
    and using it to populate Teleport Orientation.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将RotateVector节点的返回值转换为一个旋转器，并用它来填充TeleportOrientation。
- en: Adding return nodes to functions that don't return values isn't required, but
    it's good practice to do it because it makes it clear to someone maintaining or
    debugging the code where the exit points are. Nothing will break if you don't
    do this, but your code will be easier to read if you do. We're not going to do
    this with every method in this book, just to avoid adding extra steps, but it's
    a good idea to make this a habit.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不返回值的函数添加返回节点并不是必需的，但这是一个好的实践，因为它清楚地告诉维护或调试代码的人代码的退出点在哪里。如果不这样做，不会出现任何问题，但如果这样做，你的代码将更容易阅读。我们不会在本书中的每个方法中都这样做，只是为了避免添加额外的步骤，但这是一个好习惯。
- en: 'Return to your event graph''s Event Tick, and drag the SetTeleportOrientation
    function onto the outgoing execution pin from SetTeleportDestination:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到事件图的Event Tick，将SetTeleportOrientation函数拖动到SetTeleportDestination的执行输出引脚上：
- en: '![](img/45b7bca7-f17e-4d89-a1b2-191c6cbc8ea8.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45b7bca7-f17e-4d89-a1b2-191c6cbc8ea8.png)'
- en: Set Teleport Orientation will now be called on every frame after Set Teleport
    Destination finishes.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在SetTeleportDestination完成后，SetTeleportOrientation现在将在每一帧上被调用。
- en: 'Let''s use this new information:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个新信息：
- en: In your event graph, find the InputAction TeleportRight event, where we're setting
    our actor location.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件图中，找到我们设置角色位置的InputAction TeleportRight事件。
- en: First, let's collapse this into a function as well. Leaving it out on the event
    graph is sloppy. Select the nodes to the right of our input action, right-click,
    and *collapse* them into a new function.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们也将把它折叠成一个函数。在事件图中留下它是不规范的。选择输入动作右侧的节点，右键单击，将它们*折叠*成一个新函数。
- en: 'Name the new function `ExecuteTeleport`:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新函数命名为`ExecuteTeleport`：
- en: '![](img/c8ba3b98-3eef-4f2a-ae12-cfbc785c2207.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8ba3b98-3eef-4f2a-ae12-cfbc785c2207.png)'
- en: Since we now have a teleport orientation value we need to accommodate, SetActorLocation
    is no longer enough for us, since it only sets location and not rotation. We could
    call a `Set Actor Rotation` method right after it, using the value stored in our
    TeleportOrientation variable, but there's a cleaner method available to us.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有了一个传送朝向值需要适应，SetActorLocation对我们来说已经不够了，因为它只设置位置而不设置旋转。我们可以在它之后立即调用一个`Set
    Actor Rotation`方法，使用存储在TeleportOrientation变量中的值，但我们有一个更简洁的方法可用。
- en: Select the Set Actor Location node here and **delete** it.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这里的Set Actor Location节点并**删除**它。
- en: Right-click in the graph and create a Teleport node.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中右键单击，创建一个Teleport节点。
- en: Connect the True branch from our Branch statement to its execution input.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分支语句的True分支连接到其执行输入上。
- en: Connect the TeleportDest variable to its Dest Location input.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将TeleportDest变量连接到其Dest Location输入。
- en: 'Grab the TeleportOrientation variable from our Variables list and drag it onto
    the Dest Rotation input pin:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从变量列表中获取TeleportOrientation变量，并将其拖动到Dest Rotation输入引脚上：
- en: '![](img/f99cd473-5018-4afe-9028-ea81c4a67c15.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f99cd473-5018-4afe-9028-ea81c4a67c15.png)'
- en: Let's try it out. Much better. Now, the position of our thumb on the trackpad
    or the orientation of the thumbstick affects our teleport orientation. We can
    look around much more easily.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看。好多了。现在，我们在轨迹板上的拇指位置或拇指杆的方向都会影响我们的传送方向。我们可以更容易地四处看看。
- en: There's still one more thing we need to fix though. Our teleport orientation
    works fine if the player is still looking in the same direction as the pawn's
    rotation, but becomes confusingly inaccurate if they aren't. Let's accommodate
    this.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一件事情我们需要修复。如果玩家的朝向与角色的旋转相同，我们的传送朝向就可以正常工作，但如果不同，它就会变得令人困惑和不准确。让我们适应一下。
- en: What we're going to want to do here is find out where the player is looking
    relative to the pawn's orientation, and then combine this difference in rotations
    with our selected teleport orientation so that when the player lands there, they're
    looking in the direction they selected.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是找出玩家相对于角色朝向的朝向，然后将这个旋转差与我们选择的传送朝向结合起来，这样当玩家降落时，他们会朝向他们选择的方向。
- en: Right-click and create a GetActorRotation node.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并创建一个GetActorRotation节点。
- en: We're only going to want the Yaw value from this rotation, so right-click the
    node's Return Value and select Split Struct Pin to break out the rotator's components.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要从这个旋转中获取Yaw值，所以右键单击节点的返回值，选择Split Struct Pin来分解旋转器的组件。
- en: From your Components list, drag a reference to the Camera component onto the
    graph.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从组件列表中，将对相机组件的引用拖动到图表中。
- en: Drag its output and call GetWorldRotation on it.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动其输出并对其调用GetWorldRotation。
- en: Right-click its Return Value and select Split Struct Pin.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击其返回值并选择拆分结构引脚。
- en: Right-click in the graph and create a Delta (Rotator) node. Split its A and
    B input struct pins.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击图表中并创建一个Delta（Rotator）节点。拆分其A和B输入结构引脚。
- en: Connect the GetActorRotation node's Return Value Z (Yaw) output to the Delta
    (Rotator) node's A Z (Yaw) input.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将GetActorRotation节点的返回值Z（偏航）输出连接到Delta（Rotator）节点的A Z（偏航）输入。
- en: Connect the Camera's GetWorldRotation node's Return Value Z (Yaw) output to
    the Delta (Rotator) node's B Z (Yaw) input.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相机的GetWorldRotation节点的返回值Z（偏航）输出连接到Delta（Rotator）节点的B Z（偏航）输入。
- en: Right-click in the graph and create a CombineRotators node.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中右键单击并创建一个CombineRotators节点。
- en: Feed the Teleport Orientation variable's value into the CombineRotators node's
    A input.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将传送方向变量的值输入到CombineRotators节点的A输入中。
- en: Feed the Return Value from the Delta (Rotator) node into the CombineRotator
    node's B input.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Delta（Rotator）节点的返回值输入到CombineRotator节点的B输入中。
- en: Feed the Return Value from the CombineRotators node into the Teleport node's
    Dest Rotation input.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将CombineRotators节点的返回值输入到Teleport节点的Dest Rotation输入中。
- en: '![](img/7aa921fb-c947-444c-bbdc-858b30300ebc.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7aa921fb-c947-444c-bbdc-858b30300ebc.png)'
- en: 'Now when the player lands at the selected teleport spot, they''ll be looking
    in the direction they expect. If you''re coming from traditional flat-screen game
    development, this is a thing you''re going to have to get used to accommodating
    as a VR developer: the pawn''s rotation is not synonymous with the look direction.
    Players in VR can look around without affecting the pawn''s orientation, so you''ll
    always need to keep both orientations in mind when handling rotation in VR.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当玩家降落在选定的传送点时，他们将朝着他们期望的方向看。如果您来自传统的平面游戏开发，这是您作为VR开发人员需要适应的一件事情：角色的旋转与视线方向不同。在VR中，玩家可以四处看，而不会影响角色的方向，因此在处理VR中的旋转时，您始终需要记住这两个方向。
- en: The problem now is that we can't see where it's going to aim us when we land.
    Let's improve our target indication.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们无法看到它将指向我们降落的位置。让我们改进一下目标指示。
- en: Creating a teleport destination indicator
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个传送目标指示器
- en: 'We''ll create a simple Blueprint actor to act as our teleport destination indicator:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的蓝图角色作为我们的传送目标指示器：
- en: In your project's Blueprints directory, right-click and create a new blueprint
    class with `Actor` as its parent class.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的蓝图目录中，右键单击并创建一个以`Actor`为父类的新蓝图类。
- en: Name it `BP_TeleportDestIndicator`.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`BP_TeleportDestIndicator`。
- en: Open it up.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它。
- en: In its Components tab, hit Add Component, and add a Cylinder component.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其组件选项卡中，点击添加组件，并添加一个圆柱体组件。
- en: Set the scale of the Cylinder to (`0.9, 0.9, 0.1`). (Remember to unlock the
    uniform scale lock to the right of the Scale input.)
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将圆柱体的比例设置为（`0.9, 0.9, 0.1`）。 （记得解锁比例输入右侧的统一比例锁定。）
- en: Under the Cylinder's Collision properties, set Can Character Step Up On to No,
    and set its Collision Preset to NoCollision. (This is important—this indicator
    will interfere with the pawn if it has a collision.)
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在圆柱体的碰撞属性下，将Can Character Step Up On设置为No，并将其碰撞预设设置为NoCollision。（这很重要-如果有碰撞，此指示器将干扰角色。）
- en: Add a Cube component.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个立方体组件。
- en: Set its Location to (`60.0, 0.0, 0.0`).
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其位置设置为（`60.0, 0.0, 0.0`）。
- en: 'Set its Scale to (0.3, 0.1, 0.1):'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其比例设置为（0.3, 0.1, 0.1）：
- en: '![](img/c0885e4f-a067-458d-b6ed-6693fdbb3381.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0885e4f-a067-458d-b6ed-6693fdbb3381.png)'
- en: Our indicator should look something like this.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的指示器应该看起来像这样。
- en: Compile it, save it, and close it.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译它，保存它，然后关闭它。
- en: Giving it a material
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给它一个材质
- en: 'If the blank white material isn''t doing it for you, we can create something
    a little nicer. We''re not going to go crazy on this one, but we can improve its
    look with some quick work:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果白色材质对您来说不够好，我们可以创建一些更好看的东西。我们不会在这个上面花太多时间，但是我们可以通过一些快速的工作来改善它的外观：
- en: From your project directory in your Content browser, create a new directory
    called `MaterialLibrary`.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从内容浏览器中的项目目录中，创建一个名为`MaterialLibrary`的新目录。
- en: Right-click inside it and select Create Basic Asset | Material.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中右键单击并选择创建基本资产|材质。
- en: Name your new material **M_TeleportIndicator**.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新材质命名为**M_TeleportIndicator**。
- en: Open it up.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它。
- en: In the Details | Material section, set its Blend Mode to Additive.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在详细信息|材质部分，将其混合模式设置为Additive。
- en: Set its Shading Model to Unlit.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其着色模型设置为未照明。
- en: Hold down the *3* key and click anywhere in the graph to create a Constant 3
    Vector node. This is how colors are represented in materials.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*3*键，然后在图表中的任意位置单击以创建一个Constant 3 Vector节点。这是材质中颜色的表示方式。
- en: 'Double-click the node and choose a primary green: R=0.0, G=1.0, B=0.0.'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击节点，选择主要的绿色：R=0.0，G=1.0，B=0.0。
- en: Drag the output of our color node into the Emissive Color input.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将颜色节点的输出拖动到发射颜色输入中。
- en: Right-click anywhere in the graph and create a Linear Gradient node.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中的任意位置右键单击并创建一个线性渐变节点。
- en: 'Drag the VGradient output into the material''s Opacity input:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将VGradient输出拖动到材质的不透明度输入中：
- en: '![](img/c2fd06f3-9fce-4b09-b90f-3b5a32df5d85.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2fd06f3-9fce-4b09-b90f-3b5a32df5d85.png)'
- en: Save and close the material.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭材质。
- en: Open your BP_TeleportDestIndicator Blueprint and select the Cylider component.
    Under its Details | Materials, set its Element 0 material to the material you
    just created.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开BP_TeleportDestIndicator蓝图并选择Cylider组件。在其详细信息|材料中，将其元素0材料设置为刚刚创建的材料。
- en: 'Do the same for the Cube component:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于立方体组件也是一样：
- en: '![](img/dd2a6360-d5d2-4fc1-8698-026e886610da.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd2a6360-d5d2-4fc1-8698-026e886610da.png)'
- en: Nice! This is a very simple material, and if we really wanted to, we could spend
    a lot of time designing something wonderful, but for what we're doing now, this
    is entirely fine.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！这是一个非常简单的材质，如果我们真的想要的话，我们可以花很多时间设计出一些精彩的东西，但是对于我们现在要做的事情来说，这完全可以。
- en: Adding the teleport indicator to the pawn
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将传送指示器添加到角色
- en: 'Now, let''s add this new indicator to our pawn:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个新的指示器添加到我们的角色中：
- en: In our VRPawn's Components tab, add a Child Actor component.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的VRPawn的Components选项卡中，添加一个Child Actor组件。
- en: In its Details | Child Actor Component | Child Actor Class, select the new BP_TeleportDestIndicator
    actor we just made.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其详细信息| Child Actor Component | Child Actor Class中，选择我们刚刚创建的新BP_TeleportDestIndicator
    actor。
- en: Rename the ChildActor to `TeleportDestIndicator`. (You can use the *F2* key
    to rename objects.)
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ChildActor重命名为“TeleportDestIndicator”。（您可以使用*F2*键重命名对象。）
- en: 'Let''s create a new function to set its position and orientation:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的函数来设置其位置和方向：
- en: Create a new function in the pawn's Functions collection, and name it `UpdateTeleportIndicator`.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在pawn的函数集合中创建一个新的函数，并将其命名为“UpdateTeleportIndicator”。
- en: Drag the TeleportDestIndicator into the function's graph.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将TeleportDestIndicator拖入函数的图表中。
- en: Drag the output from TeleportDestIndicator and create a SetWorldLocationAndRotation
    node, using it as its Target.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从TeleportDestIndicator拖动输出并创建一个SetWorldLocationAndRotation节点，将其用作目标。
- en: Drag your TeleportDest variable onto the New Location input.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将TeleportDest变量拖到New Location输入上。
- en: Drag your TeleportOrientation variable onto the New Rotation input.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将TeleportOrientation变量拖到New Rotation输入上。
- en: 'Give it a return node:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给它一个返回节点：
- en: '![](img/f310cd87-18b9-4a07-88a9-6a2de2a3e243.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f310cd87-18b9-4a07-88a9-6a2de2a3e243.png)'
- en: 'Return to your event graph, and drag an instance of the `UpdateTeleportIndicator`
    function onto your Event Tick after Set Teleport Orientation:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回事件图表，然后在Set Teleport Orientation之后，将UpdateTeleportIndicator函数的一个实例拖到Event
    Tick上：
- en: '![](img/008ef504-8c70-4c61-975c-345356a109db.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](img/008ef504-8c70-4c61-975c-345356a109db.png)'
- en: Let's try it out. That's better! Now, we can see where we're going to be facing
    when we land. While we're at it, let's get rid of that Debug Sphere we were using
    as a temporary solution earlier on.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看。好多了！现在，我们可以看到我们降落时将面对的方向。顺便说一句，让我们摆脱之前作为临时解决方案使用的Debug Sphere。
- en: In the Set Teleport Destination function, find the Draw Debug Sphere call and
    **delete** it.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Set Teleport Destination函数中，找到Draw Debug Sphere调用并**删除**它。
- en: Optimizing and refining our teleport
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化和完善我们的传送
- en: Let's finish things up with a bit of refinement, where we're still seeing some
    rough edges.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些细化来完成这些事情，因为我们仍然看到一些粗糙的边缘。
- en: Displaying UI only when teleport input is pressed
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只有在按下传送输入时显示UI
- en: 'First off, we''re running the teleport indicators all of the time, regardless
    of whether or not the user is actually trying to teleport. Let''s activate these
    interfaces only when the user is pressing the teleport input:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们一直在运行传送指示器，无论用户是否真正尝试传送。让我们只在用户按下传送输入时激活这些接口：
- en: Add a new variable to our player pawn. Set its type to Boolean, and name it
    `bTeleportPressed`.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们的玩家pawn添加一个新变量。将其类型设置为布尔型，并将其命名为“bTeleportPressed”。
- en: Press *Alt* + click on the execution line from InputAction TeleportRight to
    the `ExecuteTeleport` function call to disconnect it.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Alt* +单击从InputAction TeleportRight到ExecuteTeleport函数调用的执行线以断开连接。
- en: Drag the `bTeleportPressed` variable onto the Pressed execution pin from InputAction
    TeleportRight to create a setter. Set it to True here.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`bTeleportPressed`变量拖到InputAction TeleportRight的Pressed执行引脚上以创建一个setter。在这里将其设置为True。
- en: Drag another instance of `bTeleportPressed` onto the Released execution pin.
    Set it to False.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个`bTeleportPressed`的实例拖到Released执行引脚上。将其设置为False。
- en: 'Connect ExecuteTeleport to the setter that''s clearing TeleportPressed, so
    the teleport will happen when the user releases the input:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ExecuteTeleport连接到清除TeleportPressed的setter，以便在用户释放输入时进行传送：
- en: '![](img/f863cb00-a5ce-404e-81f8-a55b66b5756d.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f863cb00-a5ce-404e-81f8-a55b66b5756d.png)'
- en: Now that we have a variable that will be true when the teleport input is held,
    and false when it isn't, we can use this to manage what happens on our Tick event.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个变量，当传送输入被按住时为true，当没有按住时为false，我们可以使用它来管理Tick事件上发生的事情。
- en: Disconnect Event Tick from SetTeleportDestination.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断开Event Tick与SetTeleportDestination的连接。
- en: Add a Branch node here, and use `bTeleportPressed` as its condition.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里添加一个Branch节点，并使用`bTeleportPressed`作为其条件。
- en: 'Feed the execution line from Event Tick to the Branch input, and feed its True
    branch to `SetTeleportDestination.` This way, the teleport UI will only be updated
    or displayed when the user presses the teleport input:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Event Tick的执行线连接到Branch输入，并将其True分支连接到SetTeleportDestination。这样，只有在用户按下传送输入时，传送UI才会更新或显示：
- en: '![](img/3dfb86b0-ba5d-45d2-99fa-bd572fa2ac9b.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3dfb86b0-ba5d-45d2-99fa-bd572fa2ac9b.png)'
- en: 'Let''s try it out. This is better, but our destination indicator is still visible
    while the input isn''t pressed, and it''s not updating. We need to hide it when
    we''re not using it:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看。这样更好，但是我们的目标指示器在输入未按下时仍然可见，并且它没有更新。我们需要在不使用它时隐藏它：
- en: Select the TeleportDestIndicator component from your pawn's Components tab.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从pawn的Components选项卡中选择TeleportDestIndicator组件。
- en: In its Details, set Rendering | Hidden in Game to True.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其详细信息中，将Rendering | Hidden in Game设置为True。
- en: Drag your TeleportDestIndicator component onto the graph.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将TeleportDestIndicator组件拖到图表中。
- en: Drag a connector from it and call Set Hidden in Game on it.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从中拖出一个连接器，并在其上调用Set Hidden in Game。
- en: Drag an instance of **bTeleportPressed** onto your graph and **Get** its value.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**bTeleportPressed**的一个实例拖到图表上并**获取**其值。
- en: Drag a connector from it and type `not` into the search bar. Select NOT Boolean.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从中拖出一个连接器，并在搜索栏中键入“not”。选择NOT Boolean。
- en: Plug this value into the New Hidden input in your Set Hidden in Game action.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个值插入到“Set Hidden in Game”动作中的新隐藏输入中。
- en: 'This will cause the indicator to be hidden when Teleport is not pressed, and
    not hidden when it is:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致指示器在未按下传送时隐藏，在按下传送时不隐藏：
- en: '![](img/7b604c91-b28b-48a9-b0c2-ed813606366b.png)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b604c91-b28b-48a9-b0c2-ed813606366b.png)'
- en: Let's try it again. Much better. The UI is only displayed when we need it.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一次。好多了。只有在需要时才显示UI。
- en: We would still need to replace the teleport arc we're currently drawing with
    debug methods before we could ship. We're not going to run through that process
    here, though, because it's a bit too involved for the scope of this chapter. Basically,
    what you would do here is create a spline component on the pawn and attach a mesh
    to it. Instead of using a ForEach loop in `SetTeleportDestination` to draw a series
    of debug lines, we would save the path positions to a variable. In `UpdateTeleportIndicator`,
    we would then use these positions to set the points on the spline. If you'd like
    to give this a shot, there's a good example in the VR Template.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以发布之前，我们仍然需要用调试方法替换当前绘制的传送弧线。然而，我们不会在这里详细介绍这个过程，因为它对本章的范围来说有点太复杂了。基本上，你在这里要做的是在角色上创建一个样条线组件，并将一个网格附加到它上面。我们不再使用`SetTeleportDestination`中的ForEach循环来绘制一系列的调试线，而是将路径位置保存到一个变量中。在`UpdateTeleportIndicator`中，我们将使用这些位置来设置样条线上的点。如果你想尝试一下，VR模板中有一个很好的例子。
- en: Creating a deadzone for our input
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的输入创建一个死区
- en: As we jump around the map, it's also becoming clear that we haven't given the
    player an easy way to teleport without changing orientation. Our system works
    well when they want to look around, but doesn't give them a way to opt out.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在地图上跳跃时，也变得清楚，我们没有给玩家一个简单的方法来在不改变方向的情况下传送。当他们想要四处看看时，我们的系统运作良好，但是没有给他们一个选择退出的方式。
- en: 'Let''s open up `SetTeleportOrientation` and fix this:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`SetTeleportOrientation`并修复这个问题：
- en: Create a new variable in BP_VRPawn. Set its type to Float, and name it `TeleportDeadzone`.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在BP_VRPawn中创建一个新的变量。将其类型设置为Float，并将其命名为`TeleportDeadzone`。
- en: Compile the Blueprint and set its value to 0.7\. This will accept input at 70%
    of the trackpad or thumbstick's radius.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译蓝图并将其值设置为0.7。这将接受70%的触摸板或拇指杆半径的输入。
- en: Drag a second output from the Make Vector node that's combining the two Get
    MotionControllerThumbRight input values, and create a VectorLengthSquared node
    from it.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从将两个Get MotionControllerThumbRight输入值组合的Make Vector节点中拖动第二个输出，并从中创建一个VectorLengthSquared节点。
- en: Drag the `TeleportDeadzone` variable onto the graph and Get its value.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TeleportDeadzone`变量拖动到图表上并获取其值。
- en: Square the value of Teleport Deadzone.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对Teleport Deadzone的值进行平方。
- en: Drag the output from VectorLengthSquared and create a >= node.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动VectorLengthSquared的输出并创建一个>=节点。
- en: 'Drag the squared Teleport Deadzone value into its other input:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将平方的Teleport Deadzone值拖动到其另一个输入中：
- en: '![](img/c75ca880-5fb3-4002-a1c6-3a9c13a1f53e.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c75ca880-5fb3-4002-a1c6-3a9c13a1f53e.png)'
- en: What's going on here? We're interested in finding out whether the user's input
    is more than 70% of the way toward the edge of its range. We could find this by
    getting the vector length and comparing it with the Teleport Deadzone, and this
    would give us a correct answer, but finding the actual length of a vector involves
    a square root, which is expensive. Squaring a value, on the other hand, just involves
    multiplying it by itself, which is cheap. In our case, since we don't care what
    the real vector length is—just how it compares with the deadzone. We can skip
    the square root on our vector length and just compare it with the squared target
    length. This is a common way of optimizing vector length comparisons. You'll see
    it a lot.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？我们想知道用户的输入是否超过了其范围的70%。我们可以通过获取向量长度并将其与Teleport Deadzone进行比较来找到这个答案，这将给我们一个正确的答案，但是找到向量的实际长度涉及到一个平方根，这是昂贵的。另一方面，平方一个值只涉及将其乘以自身，这是廉价的。在我们的情况下，由于我们不关心实际的向量长度，只关心它与死区的比较。我们可以跳过向量长度的平方根，只将其与平方的目标长度进行比较。这是一种常见的优化向量长度比较的方法。你会经常看到它。
- en: Using squared vector lengths to test input deadzones will give you a properly
    round test region, so you'll get consistent results at any input angle.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 使用平方向量长度来测试输入死区将为您提供一个正确的圆形测试区域，因此您将在任何输入角度下获得一致的结果。
- en: 'Now, let''s use the result of this comparison to pick which rotation value
    we will use:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个比较的结果来选择我们将使用哪个旋转值：
- en: Place a Select node in the graph, and connect the output of the >= test to its
    Index input.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中放置一个选择节点，并将>=测试的输出连接到其Index输入。
- en: Disconnect the RotationFromXVector node's output from the Set Teleport Orientation
    node.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RotationFromXVector节点的输出从设置传送定向节点中断连接。
- en: Connect the RotationFromXVector node's output to the Select node's True input.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RotationFromXVector节点的输出连接到选择节点的True输入。
- en: Create a GetActorRotation node and connect its output to the Select node's False
    input.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个GetActorRotation节点，并将其输出连接到选择节点的False输入。
- en: 'Connect the Select node''s Return Value to the Set Teleport Orientation node''s
    input:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选择节点的返回值连接到设置传送定向节点的输入：
- en: '![](img/77990d2d-83c1-4b10-8e74-62f1a81527e2.png)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77990d2d-83c1-4b10-8e74-62f1a81527e2.png)'
- en: What we're doing here is using the result of our deadzone check to decide whether
    we should use the rotation value from the thumbstick inputs or just stick with
    the pawn's existing rotation. If the input is at 70% of the range or greater,
    we'll use the input. If not, we just use the pawn's rotation.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是使用死区检查的结果来决定我们是否应该使用拇指杆输入的旋转值，还是保持角色的现有旋转。如果输入在70%的范围或更大，我们将使用输入。如果不是，我们就使用角色的旋转。
- en: '![](img/449c69d1-3aa2-45c9-8c99-c45d34631011.png)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![](img/449c69d1-3aa2-45c9-8c99-c45d34631011.png)'
- en: Let's run it. Now, you'll change orientation if you're hitting the edge of the
    trackpad or pushing the thumbstick a fair distance, but if they're closer to the
    center, you'll just retain your current orientation when you teleport.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一下。现在，如果你触碰到触摸板的边缘或者推动拇指杆到相当远的距离，你的方向会改变，但如果它们离中心更近，你传送时将保持当前的方向。
- en: Fading out and in on teleport
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在传送时淡出和淡入
- en: 'Our system is starting to work pretty well, but our teleport can feel a little
    jarring. Let''s fade out and back in to make a more pleasant transition:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统开始运作得相当好了，但是传送可能会感觉有点突兀。让我们淡出并重新淡入，以实现更愉快的过渡：
- en: Open our pawn's event graph.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们角色的事件图。
- en: Near our InputAction Teleport Right event, create a `Get Player Camera Manager` node.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在InputAction Teleport Right事件附近，创建一个`Get Player Camera Manager`节点。
- en: From this node's Return Value, create a `Start Camera Fade` action.
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从该节点的返回值创建一个`Start Camera Fade`动作。
- en: Set its To Alpha value to 1.0.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其To Alpha值设置为1.0。
- en: Drag out its Duration input and promote it to a variable. Compile and set its
    value to **0.1**.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动其持续时间输入并提升为变量。编译并将其值设置为**0.1**。
- en: This will fade the scene camera to black over a duration of one tenth of a second.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使场景相机在十分之一秒的时间内变黑。
- en: Disconnect the input to the `Execute Teleport` function call.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断开与`Execute Teleport`函数调用的输入的连接。
- en: Connect the execution output from the Teleport Pressed = False node to the new
    Start Camera Fade action.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Teleport Pressed = False节点的执行输出连接到新的Start Camera Fade动作。
- en: You'll probably need to drag a few nodes off to the right to make some room.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能需要将一些节点拖到右侧以腾出空间。
- en: 'Now, we''re going to call Start Camera Fade after the user has released the
    teleport input, since we''ve cleared the `bTeleportPressed` flag:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户释放传送输入时，我们将调用Start Camera Fade，因为我们已经清除了`bTeleportPressed`标志：
- en: Drag an execution line from the Start Camera Fade node's execution output and
    put a Delay on it.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Start Camera Fade节点的执行输出拖出一个执行线，并放置一个延迟。
- en: Set the Delay duration to your Fade Duration variable.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将延迟持续时间设置为您的Fade Duration变量。
- en: Drag from the Delay's **Completed** output into your `Execute Teleport` function
    call so that the function will be called after the fade and delay have occurred.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从延迟的**完成**输出中拖出并放入您的`Execute Teleport`函数调用，以便在淡出和延迟发生后调用该函数。
- en: When the user releases the teleport input, we're fading out over a tenth of
    a second, waiting another tenth of a second, and then executing the teleport.
    Now, we need to fade back in once the teleport is done.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户释放传送输入时，我们会在十分之一秒内淡出，等待另外十分之一秒，然后执行传送。现在，传送完成后我们需要淡入。
- en: Create another Start Camera Fade node, and connect the Execute Teleport output
    to its execution input.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个Start Camera Fade节点，并将Execute Teleport的输出连接到其执行输入。
- en: Connect the output from Get Player Camera Manager to this node's Target input.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Get Player Camera Manager的输出连接到该节点的目标输入。
- en: Set its Duration to your `Fade Duration` variable.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其持续时间设置为您的`Fade Duration`变量。
- en: Set its From Alpha value to 1.0 and its To Alpha value to 0.0.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其From Alpha值设置为1.0，将其To Alpha值设置为0.0。
- en: 'Connect the output from this node to the input of your Set Hidden in Game node
    of Teleport Dest Indicator:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此节点的输出连接到Teleport Dest Indicator的Set Hidden in Game节点的输入：
- en: '![](img/1ef14375-1ba2-4283-bcdf-b6fc98e8b2f6.png)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ef14375-1ba2-4283-bcdf-b6fc98e8b2f6.png)'
- en: Your graph should now look like this.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 您的图表现在应该是这样的。
- en: Let's test it in-game. This is much nicer. We now have a fast fade out and in
    when the teleport action occurs. It's subtle, but adds a bit of polish to the
    application and makes the teleport less jarring.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在游戏中进行测试。这样做更好。当传送动作发生时，我们现在有一个快速的淡出和淡入。这虽然微妙，但为应用程序增添了一些亮点，使传送不那么令人震惊。
- en: 'Since this action takes time, however briefly, we should ensure that the player
    can''t trigger a second teleport while one is already underway:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于这个动作需要时间，我们应该确保玩家在一个传送正在进行时不能触发第二个传送：
- en: Create a new Boolean variable and name it `bIsTeleporting`.
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的布尔变量，并将其命名为`bIsTeleporting`。
- en: Drag an instance of it onto your graph and Get its value.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其拖到图表上并获取其值。
- en: Insert a new Branch node between InputAction TeleportRight and set Teleport
    Pressed to True.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在InputAction TeleportRight和set Teleport Pressed to True之间插入一个新的Branch节点。
- en: Use `bIsTeleporting` as the Branch node's Condition.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`bIsTeleporting`作为分支节点的条件。
- en: Connect its False output to the set Teleport Pressed to True node, and leave
    its True output unconnected.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其False输出连接到设置Teleport Pressed为True节点，并将其True输出保持未连接。
- en: 'Do the same for the input action''s Released execution:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于输入动作的Released执行，也做同样的操作：
- en: '![](img/24619ec8-7d02-4d4e-b390-81232642ca8a.png)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24619ec8-7d02-4d4e-b390-81232642ca8a.png)'
- en: This way, a Teleport Pressed or Released event will only be processed if `bIsTeleporting`
    is False.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，只有在`bIsTeleporting`为False时，才会处理传送按下或释放事件。
- en: 'Now, we need to set `bIsTeleporting` to True when we start a teleport action,
    and then set it to False again when the action finishes:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们开始传送动作时，我们需要将`bIsTeleporting`设置为True，然后在动作完成时再次将其设置为False：
- en: After the Set Teleport Pressed = False node coming from the input action's Released
    output, insert a setter to set `bIsTeleporting` to True.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从输入动作的Released输出出来的Set Teleport Pressed = False节点之后，插入一个setter将`bIsTeleporting`设置为True。
- en: Connect its output to the Start Camera Fade node.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其输出连接到Start Camera Fade节点。
- en: '![](img/efc934e6-a9a1-447a-9039-f83a82849f23.png)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efc934e6-a9a1-447a-9039-f83a82849f23.png)'
- en: After the second Start Camera Fade node, add another setter to set `bIsTeleporting`
    to False.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个Start Camera Fade节点之后，添加另一个setter将`bIsTeleporting`设置为False。
- en: 'Connect the output of that node to the Set Hidden in Game input for the Teleport
    Dest Indicator:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该节点的输出连接到Teleport Dest Indicator的Set Hidden in Game输入。
- en: '![](img/caba586b-b053-4fc6-87e7-e62c68fb5c99.png)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![](img/caba586b-b053-4fc6-87e7-e62c68fb5c99.png)'
- en: Now, when we execute a teleport by releasing the input, `bIsTeleporting` will
    be set to true until the teleport action has finished, and a new teleport action
    won't be accepted.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们释放输入执行传送时，`bIsTeleporting`将被设置为true，直到传送动作完成，新的传送动作将不会被接受。
- en: Teleport locomotion summary
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传送运动总结
- en: 'We''ve covered a lot of ground here and created a pretty comprehensive teleport
    locomotion scheme. Let''s go over the scheme:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里涵盖了很多内容，并创建了一个相当全面的传送运动方案。让我们回顾一下这个方案：
- en: It's bound to the navmesh, so it won't allow players to teleport into illegal
    locations
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它绑定到导航网格，因此不允许玩家传送到非法位置
- en: It's using a parabolic trace so that the player can teleport to destinations
    higher than their current position
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用抛物线追踪，以便玩家可以传送到比当前位置更高的目的地
- en: It allows the player to choose their target orientation when teleporting
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许玩家在传送时选择目标方向
- en: It does a decent job of indicating where the player is going to go and where
    they'll be facing
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在指示玩家将要去的地方和他们将面对的地方方面做得相当好
- en: It includes a few bits of polish, such as an input deadzone and a camera fade
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包括一些细节处理，如输入死区和相机淡入淡出
- en: There's more we could do with this, but it's a reasonably complete solution.
    If we were to improve it further, we would likely want to allow it to work with
    either hand, and we would certainly need to replace our debug-drawn teleport path
    with something that will work in a shipping build. If you choose to explore further
    from here, the VR Template included with the engine is a great next step. Many
    of the methods we just wrote here are similar to the methods used in that template,
    so you should find that you're standing on good ground to understand what you
    see when you start digging around in there.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以做更多的事情，但这已经是一个相当完整的解决方案了。如果我们进一步改进它，可能希望允许它与任何一只手一起使用，并且肯定需要用适用于发布版本的其他内容替换我们绘制的调试传送路径。如果您选择从这里进一步探索，引擎附带的VR模板是一个很好的下一步。我们刚刚在这里编写的许多方法与该模板中使用的方法类似，因此您应该会发现，当您开始深入研究时，您站在了一个很好的基础上，可以理解您看到的内容。
- en: Teleportation is an effective solution for getting around in VR because, as
    we mentioned earlier, it doesn't try to represent movement, so it doesn't generally
    trigger motion sickness in users. It works pretty well for applications that don't
    rely on a high degree of immersion in the ways players move through the world.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 传送是在虚拟现实中四处移动的有效解决方案，因为正如我们之前提到的，它不会尝试表示移动，所以通常不会引发用户晕动病。对于那些不依赖于玩家在世界中移动的高度沉浸式的应用程序来说，它效果非常好。
- en: 'For games and applications that want to maintain a higher level of immersion,
    teleportation may not be what you want, as it doesn''t behave the way movement
    in the real world does: it creates a discontinuous sense of space, and introduces
    interface elements that clearly don''t exist in the world. There''s no way around
    the reality that it''s an immersion-breaker.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 对于希望保持更高程度沉浸感的游戏和应用程序来说，传送可能不是您想要的，因为它的行为方式与现实世界中的移动不同：它会创建一种不连续的空间感，并引入明显不存在于世界中的界面元素。无论如何，它都会破坏沉浸感。
- en: Next, we're going to take a look at an immersive movement scheme that allows
    players to move smoothly through the world. Very sensitive players or those who
    are new to VR may not find immersive movement comfortable, so in some circumstances,
    it may be appropriate to offer teleport locomotion as an option on an application
    that also offers seamless movement.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一种沉浸式移动方案，允许玩家在世界中平稳移动。非常敏感的玩家或者对虚拟现实不熟悉的玩家可能不会觉得沉浸式移动舒适，因此在某些情况下，可以在应用程序中提供传送移动作为可选项。
- en: Let's take a look at how it works.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。
- en: Seamless locomotion
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无缝移动
- en: If you're making an immersive game or experience, that experience is going to
    be much more convincing to the player if their sense of the space around them
    isn't constantly being broken up by teleport actions. Let's take a look at a way
    to handle seamless locomotion in space.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在制作一款沉浸式游戏或体验，那么如果玩家周围的空间感不断被传送动作打断，那么这种体验对玩家来说会更加令人信服。让我们来看一下如何处理空间中的无缝移动。
- en: Setting up inputs for seamless locomotion
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置无缝移动的输入
- en: Ordinarily, we would probably allow users to select the sort of locomotion scheme
    they're comfortable with in an options menu, but since our current character doesn't
    do anything but move around, and we haven't done anything with the left controller
    yet, we can use it to drive our seamless locomotion scheme.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们可能会允许用户在选项菜单中选择他们熟悉的移动方案，但由于我们当前的角色除了移动以外什么都不做，而且我们还没有对左手控制器做任何处理，所以我们可以使用它来驱动我们的无缝移动方案。
- en: 'Let''s add a pair of input axis mappings for the left controller''s thumbstick:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为左手控制器的拇指杆添加一对输入轴映射：
- en: Open Project Settings | Engine | Input.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目设置 | 引擎 | 输入。
- en: Hit the + button beside Bindings | Axis Mappings twice to add two new axis mappings.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Bindings | Axis Mappings旁边的+按钮两次，添加两个新的轴映射。
- en: Name them `MoveForward`, and `MoveRight`.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们命名为`MoveForward`和`MoveRight`。
- en: Bind MoveForward to MotionController (L) Thumbstick Y.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MoveForward绑定到MotionController (L) Thumbstick Y。
- en: Set its Scale to -1.0.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其缩放设置为-1.0。
- en: 'Bind MoveRight to MotionController (L) Thumbstick X, and leave its Scale at
    1.0:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MoveRight绑定到MotionController (L) Thumbstick X，并将其缩放设置为1.0：
- en: '![](img/2054edc5-b7ed-45cf-b10e-b5eff2036e7d.png)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2054edc5-b7ed-45cf-b10e-b5eff2036e7d.png)'
- en: We're all set with our input bindings for the moment, so we can close our project
    settings.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时完成了输入绑定，所以可以关闭项目设置。
- en: Changing the pawn's parent class
  id: totrans-570
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改角色的父类
- en: For our pawn to move smoothly, we're going to need to give it a way to handle
    its movement input. There are two ways we could do this. We could write our own
    input handler on our Tick event, but this is a fairly involved process, and unnecessary
    if we're interested in implementing a straightforward movement scheme.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的角色平稳移动，我们需要为其提供处理移动输入的方法。我们有两种方法可以做到这一点。我们可以在Tick事件上编写自己的输入处理程序，但这是一个相当复杂的过程，如果我们只是想实现一个简单的移动方案，这是不必要的。
- en: 'An easier way is to add a Movement Component to our pawn. In Blueprint, however,
    there''s no way to add a movement component (in C++, there is), so instead, we''re
    going to have to change our pawn''s parent class to a class that contains the
    component we need, along with several others we''re also going to want. Let''s
    get started:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单的方法是为我们的角色添加一个Movement Component。然而，在蓝图中，没有办法添加一个移动组件（在C++中是可以的），所以我们需要将我们的角色的父类更改为一个包含我们需要的组件以及其他几个我们也想要的组件的类。让我们开始吧：
- en: 'Open your Blueprint of BP_VRPawn, and hit Class Settings on the toolbar:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开BP_VRPawn的蓝图，并在工具栏上点击Class Settings：
- en: '![](img/f4ac2f82-d94c-452f-8fe0-d1a6e71d0d11.png)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4ac2f82-d94c-452f-8fe0-d1a6e71d0d11.png)'
- en: We mentioned earlier that Unreal Engine is an **object oriented** system. An **object** is
    an instance of a **class**, and classes **inherit** from other classes, taking
    on their abilities and characteristics as they do. This is where that becomes
    important. We're going to change the capabilities of our BP_VRPawn by changing
    its parent class to a child of the Pawn class that contains the component we need.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过虚幻引擎是一个面向对象的系统。一个对象是一个类的实例，类从其他类继承，继承了它们的能力和特征。这就是为什么这一点很重要。我们将通过将 BP_VRPawn
    的父类更改为 Pawn 类的子类来改变它的功能，该子类包含我们需要的组件。
- en: 'Under Details | Class Options, change Parent Class from Pawn to Character:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在详细信息 | 类选项下，将父类从 Pawn 更改为 Character：
- en: '![](img/8a164f4b-9843-45c0-95bd-da158fde6cbe.png)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a164f4b-9843-45c0-95bd-da158fde6cbe.png)'
- en: 'If you look at your Components tab, you''ll see that a few new components have
    appeared:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看组件选项卡，你会发现出现了一些新的组件：
- en: '![](img/471bc9c7-6b98-415e-8248-b5306e4372d3.png)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![](img/471bc9c7-6b98-415e-8248-b5306e4372d3.png)'
- en: 'In addition to the components we created earlier on, we now have the following:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前创建的组件，我们现在还有以下组件：
- en: A Capsule component
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个胶囊组件
- en: An Arrow component
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个箭头组件
- en: A Mesh component
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网格组件
- en: A Character Movement component
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个角色移动组件
- en: These are all inherited from the `Character` class.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是从 `Character` 类继承的。
- en: This is useful. We need the Movement component to allow us to move around, and
    we need the Capsule component to keep us from walking through walls. We don't
    really need the Mesh component, since we're not rendering the player pawn's body,
    but it doesn't hurt us in this instance to have it here and just leave its Skeletal
    Mesh property empty for now.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有用。我们需要移动组件来让我们移动，我们需要胶囊组件来防止我们穿过墙壁。我们不真正需要网格组件，因为我们不渲染玩家角色的身体，但在这种情况下将其放在这里并且将其
    Skeletal Mesh 属性留空也不会对我们造成伤害。
- en: Be careful when changing an object's parent class. If the class you're changing
    to is a child of the previous parent class, that's generally going to be a safe
    change, because it will add new elements, but the parent's properties and functions
    will still be there. Going from a child class to a parent class can be riskier,
    since you may be relying on properties or functions that exist on the child, but
    don't exist on the parent. Changing to a class that's very different from your
    current class will probably create problems. It's fine if you know what you're
    doing, and the engine won't stop you, but you'll probably wind up cleaning up
    a lot of invalidated function calls or variable references.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 当更改对象的父类时要小心。如果你要更改的类是前一个父类的子类，那通常是安全的，因为它会添加新的元素，但父类的属性和函数仍然存在。从子类更改为父类可能更加危险，因为你可能依赖于子类上存在但父类上不存在的属性或函数。更改为与当前类非常不同的类可能会导致问题。如果你知道你在做什么，引擎不会阻止你，但你可能最终需要清理很多无效的函数调用或变量引用。
- en: Fixing the collision component
  id: totrans-588
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复碰撞组件
- en: 'If you run the game now, you''ll see that we''re floating a little higher above
    the floor than we were previously. This is because our Capsule component is colliding
    with the floor and pushing us upward. To fix this, open your Pawn''s Viewport
    tab. (If you''ve closed it, you can reopen it by double-clicking the BP_VRPawn(self)
    entry on your Components tab.) Let''s get started:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行游戏，你会发现我们离地面比之前高一点。这是因为我们的胶囊组件与地面碰撞并将我们推向上方。为了修复这个问题，打开你的角色蓝图的视口选项卡。（如果你关闭了它，可以通过双击组件选项卡上的
    BP_VRPawn(self) 条目来重新打开它。）让我们开始吧：
- en: Hit *Alt* + *K* to switch your viewport to a side view.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按 *Alt* + *K* 切换视口到侧视图。
- en: 'Grab your Camera Root and drag it downward until it''s sitting at the bottom
    of the Capsule Component. Its location should now be (0.0, 0.0, -90.0):'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抓住你的相机根组件，将其向下拖动，直到它位于胶囊组件的底部。它的位置现在应该是 (0.0, 0.0, -90.0)：
- en: '![](img/9d554b16-7b84-42c7-8771-950af5758fa4.png)'
  id: totrans-592
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d554b16-7b84-42c7-8771-950af5758fa4.png)'
- en: If you run the game again, you'll find that you're properly on the floor.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 如果再次运行游戏，你会发现你已经正确地站在地板上了。
- en: Handling movement input
  id: totrans-594
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理移动输入
- en: 'Now that we''ve given our pawn a movement component, let''s use the input bindings
    we mapped a moment ago to allow us to move around:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们给角色添加了一个移动组件，让我们使用之前映射的输入绑定来让我们移动：
- en: 'Right-click in your pawn''s event graph and create an Input | Axis Events |
    MoveForward event:'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的角色蓝图的事件图中右键单击，创建一个输入 | 轴事件 | 前进事件：
- en: '![](img/dc61e844-ba4b-4a61-98ff-052b8ec60503.png)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc61e844-ba4b-4a61-98ff-052b8ec60503.png)'
- en: Do the same for the MoveRight event we created in our axis bindings.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们在轴绑定中创建的 MoveRight 事件也做同样的操作。
- en: We now have two events that will run every frame, and allow us to feed movement
    input to our movement component.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个每帧运行的事件，可以向我们的移动组件提供移动输入。
- en: Create an Add Movement Input node, and connect its execution input to the output
    of InputAxis MoveForward.
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Add Movement Input 节点，并将其执行输入连接到 InputAxis MoveForward 的输出。
- en: Feed the Axis Value of MoveForward into the movement input's Scale Value.
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MoveForward 的轴值输入到移动输入的缩放值中。
- en: 'Repeat this for InputAxis MoveRight:'
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 InputAxis MoveRight 也重复这个步骤：
- en: '![](img/c6c2c89a-e340-41d8-a7b6-d59b6597cd29.png)'
  id: totrans-603
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6c2c89a-e340-41d8-a7b6-d59b6597cd29.png)'
- en: 'Now, we need to tell it the direction we''d like to move in:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉它我们想要移动的方向：
- en: Grab your Camera component from your components list, and drag it onto your
    event graph.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从组件列表中获取你的相机组件，并将其拖动到事件图中。
- en: From its output, create a GetWorldRotation node.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从它的输出中创建一个 GetWorldRotation 节点。
- en: Right-click on the GetWorldRotation output and split the struct pin.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 GetWorldRotation 的输出并拆分结构引脚。
- en: Right-click in the graph and create a Get Forward Vector node.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中右键单击，创建一个 Get Forward Vector 节点。
- en: Split its input pin.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拆分它的输入引脚。
- en: Connect the Yaw output from GetWorldRotation to the In Rot Z (Yaw) input in
    Get Forward Vector.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 GetWorldRotation 的 Yaw 输出连接到 Get Forward Vector 的 In Rot Z (Yaw) 输入。
- en: Right-click to create a Get Right Vector node.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击创建一个 Get Right Vector 节点。
- en: Split its input, and connect Yaw output of GetWorldRotation to its In Rot Z
    (Yaw) input.
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拆分其输入，并将GetWorldRotation的Yaw输出连接到其In Rot Z（Yaw）输入。
- en: Connect the output from Get Forward Vector to the World Direction input to Add
    Movement Input of InputAxis MoveForward node.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Get Forward Vector的输出连接到InputAxis MoveForward节点的World Direction输入的Add Movement
    Input。
- en: 'Connect the output from Get Right Vector to the MoveRight Add Movement Input:'
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Get Right Vector的输出连接到MoveRight Add Movement Input：
- en: '![](img/799912e0-21eb-4e11-b2dc-8a9d89b53da6.png)'
  id: totrans-615
  prefs: []
  type: TYPE_IMG
  zh: '![](img/799912e0-21eb-4e11-b2dc-8a9d89b53da6.png)'
- en: Let's give it a try in-game.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在游戏中试试看。
- en: We can still teleport using our right trackpad or thumbstick, but if we use
    the left input, it slides us smoothly through the world using our camera's look
    direction as the forward direction.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用右侧的触摸板或拇指杆进行传送，但如果我们使用左侧的输入，它会平滑地将我们滑过世界，使用我们相机的观察方向作为前进方向。
- en: Gamers that are used to first-person shooters are used to thinking of their
    camera direction as their forward direction. In VR, this doesn't have to be the
    case—it's perfectly reasonable for a character to be looking to the right while
    moving to the left. Our pawn has a concept of *Control Rotation*, which is its
    actual orientation in space, and is distinct from the direction the camera is
    facing. In practice, if you're going to drive movement from a pawn's control rotation
    rather than camera rotation, you need to provide visual cues to make it clear
    to the player exactly what their forward orientation is, or your movement scheme
    will just confuse them. To keep things clear in this instance, we've made our
    movement relative to the look direction.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯于第一人称射击游戏的玩家习惯于将相机方向视为前进方向。在VR中，这不一定是这样-角色可以向右看而向左移动是完全合理的。我们的角色有一个*控制旋转*的概念，它是其在空间中的实际方向，与相机面对的方向不同。实际上，如果您要从角色的控制旋转而不是相机旋转驱动移动，您需要提供视觉提示，以清楚地向玩家说明他们的前进方向是什么，否则您的移动方案将使他们困惑。为了保持清晰，在这种情况下，我们使我们的移动相对于观察方向。
- en: This works well enough, but it has some problems.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做效果还不错，但存在一些问题。
- en: Fixing movement speed
  id: totrans-620
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修正移动速度
- en: 'First, we''re moving too fast. Let''s fix this:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们移动得太快了。让我们修复一下：
- en: 'Select your pawn''s CharacterMovement Component, and in Details | Character
    Movement: Walking, set its Max Walk Speed to 240.0'
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您的角色的CharacterMovement组件，并在详细信息|角色移动中将其最大行走速度设置为240.0
- en: That's a much more reasonable speed for walking through the world.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更合理的步行速度。
- en: Letting the player look around without constantly steering
  id: totrans-624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让玩家在不断转向的情况下观察周围
- en: 'Let''s face it. Using the camera forward vector as the basis for our steering
    feels a little janky. Every time you turn your head to look at something, you
    have to steer to correct yourself. The world doesn''t work that way. Let''s use
    the orientation of the left controller as the basis for our movement instead:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们面对现实吧。使用相机前向矢量作为我们转向的基础感觉有点不稳定。每次你转动头部看东西时，你都必须转向纠正自己。世界不是这样运作的。让我们改为使用左侧控制器的方向作为我们移动的基础：
- en: Grab the `MotionController_L` component and drag it into the event graph near
    where we're currently getting the Camera's world rotation.
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抓住MotionController_L组件并将其拖动到事件图表中，靠近我们当前获取相机世界旋转的位置。
- en: 'Feed MotionController_L component''s output into the GetWorldRotation node,
    replacing the Camera''s connection:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MotionController_L组件的输出连接到GetWorldRotation节点，替换Camera的连接：
- en: '![](img/38ba6cf2-cf89-4b75-918c-67436a637a46.png)'
  id: totrans-628
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38ba6cf2-cf89-4b75-918c-67436a637a46.png)'
- en: Now, instead of using the Camera's Yaw as our basis for our forward and right
    world directions, we're using the controller, which makes intuitive sense. Forward
    is wherever you're pointing the controller, and meanwhile, the player can execute
    fine movements using the trackpad or joystick. They can steer by pointing in the
    direction they want to go and can look around without affecting their movement.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再使用Camera的偏航作为我们前进和右侧世界方向的基础，而是使用控制器，这是很直观的。前进方向是您指向控制器的方向，同时，玩家可以使用触摸板或摇杆进行精细移动。他们可以通过指向他们想要去的方向来转向，并且可以在不影响移动的情况下四处看看。
- en: Implementing snap-turning
  id: totrans-630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现快速转向
- en: The last thing we need to give the player is a way to change their orientation
    without having to spin their chair around in the real world.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要给玩家提供一种改变方向的方法，而不必在现实世界中转动椅子。
- en: 'While it works well to allow your players to move smoothly through the world
    like we just have, we don''t want them to turn smoothly. We discussed the reason
    for this in [Chapter 1](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml), *Thinking
    in VR*, but to recap here, visually induced motion sickness arises when players
    see movement that they don''t feel. We''re especially attuned to movements that
    appear to be spinning. This likely arises from a number of reasons:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然让玩家像我们刚才做的那样平滑地在世界中移动效果很好，但我们不希望他们平滑地转向。我们在[第1章](8ad5a719-9b05-467c-ba9b-4467ce678145.xhtml)中讨论了这个原因，即在VR中，当玩家看到他们没有感觉到的运动时，会引起视觉诱发的晕动病。我们对看起来像旋转的运动特别敏感。这可能是由于多种原因：
- en: A sense of spinning is a natural effect of disruptions to the vestibular system
    from poisoning. Ever had the bed-spins after a rough night out? What happened
    next? Right. Don't do that to your player.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从中毒引起的前庭系统干扰会产生旋转的感觉。在狂欢之夜后是否曾经有过床旋转的感觉？接下来会发生什么？对，不要让你的玩家经历这种感觉。
- en: Vestibular disconnect is strongest when there's a lot of optic flow in the image.
    When the player is rotating, nearly everything in the frame is moving to the side.
    That's a lot of movement.
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当图像中有大量视觉流动时，前庭系统的断开感最强烈。当玩家旋转时，几乎画面中的所有物体都向侧面移动。这是很多运动。
- en: In the real world, we naturally blink when rotating our head, or we aim our
    eyes first at the thing we want to look at (this movement is called a **saccade**),
    and then turn our head to follow. In the real world, we don't keep our eyes steady
    while we turn around.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实世界中，当我们转动头部时，我们自然会眨眼，或者我们首先将目光对准我们想要看的东西（这种运动称为**扫视**），然后转动头部跟随。在现实世界中，我们在转身时不会保持眼睛稳定。
- en: Snapping the player through a turn rather than allowing them to turn smoothly
    not only avoids creating a huge optic flow that's likely to make your user sick,
    but it actually does a better job of replicating the way we actually perceive
    turning in the real world than a smooth turn does.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 通过快速转向玩家而不是让他们平滑转向不仅可以避免创建一个可能让用户感到恶心的巨大视觉流动，而且实际上比平滑转向更好地复制了我们在现实世界中感知转向的方式。
- en: Let's set up a snap turn.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个快速转向。
- en: Setting up inputs for snap turning
  id: totrans-638
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置快速转向的输入
- en: 'Let''s add a pair of action bindings to snap right and left:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一对动作绑定来进行快速向右和向左转：
- en: Open your Project Settings | Engine | Input.
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目设置 | 引擎 | 输入。
- en: Add two new Action Mappings in Engine | Input | Bindings. Name them `SnapTurnRight` and
    `SnapTurnLeft`.
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在引擎 | 输入 | 绑定中添加两个新的动作映射。将它们命名为`SnapTurnRight`和`SnapTurnLeft`。
- en: Bind SnapTurnRight to MotionController (L) FaceButton2.
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将SnapTurnRight绑定到MotionController（L）FaceButton2。
- en: Bind SnapTurnLeft to MotionController (L) FaceButton4 and MotionController (L)
    FaceButton1.
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将SnapTurnLeft绑定到MotionController（L）FaceButton4和MotionController（L）FaceButton1。
- en: 'We''re binding two inputs to SnapTurnLeft to accommodate both Oculus and Vive
    inputs. On Oculus Touch controllers, FaceButton1 on the left controller is the
    X button, while FaceButton2 is the Y button. On the HTC Vive, FaceButton2 is the
    left-hand side of the trackpad, and FaceButton4 is the right-hand side of the
    pad:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个输入绑定到SnapTurnLeft以适应Oculus和Vive输入。在Oculus Touch控制器上，左控制器上的FaceButton1是X按钮，而FaceButton2是Y按钮。在HTC
    Vive上，FaceButton2是触摸板的左侧，而FaceButton4是触摸板的右侧：
- en: '![](img/d05f8efb-9a27-42f1-aadd-3b6bdc73ad42.png)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d05f8efb-9a27-42f1-aadd-3b6bdc73ad42.png)'
- en: Your input bindings should now look like this.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的输入绑定应该如下所示。
- en: We can close our project settings now.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以关闭项目设置了。
- en: Executing the snap turn
  id: totrans-648
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行快速转向
- en: 'Now, let''s execute a snap turn when these buttons are pressed:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在按下这些按钮时执行快速转向：
- en: 'In your pawn''s event graph, add input events for your SnapTurnLeft and SnapTurnRight
    actions:'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色的事件图中，为SnapTurnLeft和SnapTurnRight动作添加输入事件：
- en: '![](img/1f902968-f3a2-4811-b911-d60686b9663b.png)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f902968-f3a2-4811-b911-d60686b9663b.png)'
- en: Create a GetActorRotation node and split its output.
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个GetActorRotation节点并拆分其输出。
- en: Drag from the Return Value Z (Yaw) output and create a float - float node.
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从返回值Z（偏航）输出处拖动并创建一个float - float节点。
- en: Drag out from the subtraction node's second input and **promote** it to a variable.
    Name the variable `SnapTurnIncrement`.
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从减法节点的第二个输入处拖出并将其提升为变量。将变量命名为`SnapTurnIncrement`。
- en: Compile your Blueprint and set the SnapTurnIncrement value to 30.0.
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译蓝图并将SnapTurnIncrement值设置为30.0。
- en: Create a SetActorRotation node, and connect the **GetActorRotation** node's
    Roll and Pitch outputs directly to their corresponding inputs.
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个SetActorRotation节点，并将GetActorRotation节点的Roll和Pitch输出直接连接到相应的输入。
- en: Connect the result of your subtraction to the Yaw input.
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将减法的结果连接到偏航输入。
- en: Connect the Pressed execution output from InputAction SnapTurnLeft to the SetActorRotation
    node's input.
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将InputAction SnapTurnLeft的按下执行输出连接到SetActorRotation节点的输入。
- en: Select these nodes and press *Ctrl* + *W* to duplicate them.
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这些节点，按下Ctrl + W进行复制。
- en: Replace the subtraction in the duplicated set with an addition.
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将复制集中的减法替换为加法。
- en: 'Connect the duplicated nodes to execution of the InputAction SnapTurnRight
    output:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将复制的节点连接到InputAction SnapTurnRight的执行输出：
- en: '![](img/57e4c842-4bb3-48de-9eaf-6769f4330942.png)'
  id: totrans-662
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57e4c842-4bb3-48de-9eaf-6769f4330942.png)'
- en: Give it a shot in-game. It's not bad. We could improve it further for sure—right
    now, snap turning triggers movement as well, but it's a pretty usable solution.
    If it made sense for our game, we could potentially map down a press on the Vive
    trackpad or a joystick press on the left Oculus Touch to a 180° turn.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中试一试。效果还不错。我们肯定可以进一步改进它 - 目前，快速转向也会触发移动，但这是一个相当可用的解决方案。如果对我们的游戏有意义，我们还可以将Vive触摸板上的按下或左侧Oculus
    Touch上的摇杆按下映射为180°的转向。
- en: Going further
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步进行
- en: There are a few ways we could improve the work we've done here, but implementing
    them fully would fall outside the scope of this chapter. Let's take a brief moment
    to talk about ways you could improve on this class as you take things further.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式来改进我们在这里所做的工作，但是完全实施它们将超出本章的范围。让我们简要地谈谈在进一步进行时如何改进这个类。
- en: Snap turn using analog input
  id: totrans-666
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟输入进行快速转向
- en: Our current snap turn implementation works reasonably well on Vive wands, but
    doesn't feel great on Oculus Touch controls. It might feel better for our players
    to listen to the analog input from one of the thumbsticks and trigger a snap turn
    if it exceeds a certain threshold. This way, players could flip the thumbstick
    to the side to execute the snap, or just touch the edge of a Vive trackpad without
    having to press it.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前的快速转向实现在Vive手柄上效果还不错，但在Oculus Touch控制器上感觉不太好。对于我们的玩家来说，如果能听取其中一个摇杆的模拟输入并在超过一定阈值时触发快速转向可能会更好。这样，玩家可以将摇杆翻转到一侧来执行快速转向，或者只需触摸Vive触摸板的边缘而无需按下它。
- en: You could execute this by setting up an input axis binding on a motion controller
    thumbstick, and testing to see whether the input is greater than a threshold amount
    (for this test, we used 0.8) for a right turn or less than the negative threshold
    for a left turn.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在运动控制器的拇指杆上设置输入轴绑定，并测试输入是否大于阈值（对于此测试，我们使用了0.8）来执行此操作，以进行右转，或者小于负阈值进行左转。
- en: You'll need to remember to put a cooldown onto the snap so that it doesn't trigger
    repeatedly from a single press. In our case, we used a cooldown duration of 0.2.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要记住对快速转向进行冷却，以防止它在单次按下时重复触发。在我们的案例中，我们使用了0.2秒的冷却时间。
- en: 'If you''d like to build this into your pawn, here are the steps:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将其构建到您的角色中，请按照以下步骤进行：
- en: Create an input event handler for your MotionControllerThumbRight_X input axis.
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为MotionControllerThumbRight_X输入轴创建一个输入事件处理程序。
- en: Create a Branch, and only continue if `bTeleportPressed` is False. We don't
    want to process snap turns while we're teleporting.
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个分支，只有当`bTeleportPressed`为False时才继续。我们不希望在传送时处理快速转向。
- en: Create a new Boolean variable called `bSnapTurnCooldownActive`.
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`bSnapTurnCooldownActive`的新布尔变量。
- en: Create a Branch, and only continue if `bSnapTurnCooldownActive` is False.
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个分支，只有当`bSnapTurnCooldownActive`为False时才继续。
- en: Create a new float variable called `SnapTurnAnalogDeadzone`, compile, and set
    its value to 0.8.
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SnapTurnAnalogDeadzone`的新浮点变量，编译并将其值设置为0.8。
- en: Add a >= test to see whether the incoming Axis Value from your thumbstick input
    is greater than or equal to `SnapTurnAnalogDeadzone`.
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个>=测试，以查看来自拇指杆输入的输入轴值是否大于或等于`SnapTurnAnalogDeadzone`。
- en: Create a Branch from this, and on its False output, create another Branch.
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从此处创建一个分支，并在其False输出上创建另一个分支。
- en: For this second branch, test to see whether the incoming Axis Value is less
    than or equal to the negative SnapTurnAnalogDeadzone (multiply it by -1.0).
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个第二个分支，测试一下传入的轴值是否小于或等于负的SnapTurnAnalogDeadzone（将其乘以-1.0）。
- en: '![](img/bdb7c99f-4f74-419f-8777-6adc185455c7.png)'
  id: totrans-679
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdb7c99f-4f74-419f-8777-6adc185455c7.png)'
- en: Create a new Custom Event called ExecuteSnapTurnLeft, and feed it into the SetActorRotation
    call you're making from InputAction SnapTurnLeft.
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为ExecuteSnapTurnLeft的新自定义事件，并将其输入到从InputAction SnapTurnLeft调用的SetActorRotation中。
- en: 'Create another one called ExecuteSnapTurnRight, and feed it in where InputAction
    SnapTurnRight is being handled:'
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为ExecuteSnapTurnRight的自定义事件，并将其输入到处理InputAction SnapTurnRight的位置：
- en: '![](img/73b934fb-ddbd-4ba0-959f-84b9efa86ff0.png)'
  id: totrans-682
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73b934fb-ddbd-4ba0-959f-84b9efa86ff0.png)'
- en: Now, back on your ThumbstickRight handler, call ExecuteSnapTurnRight if the
    Input Axis was >= SnapTurnAnalogDeadzone.
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在ThumbstickRight处理程序中，如果输入轴大于等于SnapTurnAnalogDeadzone，请调用ExecuteSnapTurnRight。
- en: Call ExecuteSnapTurnLeft if the Input Axis was <= -SnapTurnAnalogDeadzone.
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入轴小于等于-SnapTurnAnalogDeadzone，请调用ExecuteSnapTurnLeft。
- en: '![](img/e8ea2743-287e-434e-9f87-a628e146719e.png)'
  id: totrans-685
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8ea2743-287e-434e-9f87-a628e146719e.png)'
- en: 'Now, we need to set a cooldown so that we don''t get a rapid-fire series of
    snap turns when the user moves the stick:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要设置一个冷却时间，以防止用户在移动摇杆时连续进行快速的快速转身：
- en: Add a setter to set bSnapTurnCooldownActive to true, and call it after both
    ExecuteSnapTurnRight and ExecuteSnapTurnLeft.
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个setter来将bSnapTurnCooldownActive设置为true，并在ExecuteSnapTurnRight和ExecuteSnapTurnLeft之后调用它。
- en: Add a delay. The default value of 0.2 is fine here, but if you wanted to tune
    your cooldown duration, promote this value to a variable.
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个延迟。默认值0.2在这里很好，但如果您想调整冷却时间，将此值提升为变量。
- en: After the delay, set bSnapTurnCooldownActive to False again.
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 延迟后，再次将bSnapTurnCooldownActive设置为False。
- en: '![](img/c55b1d36-b0cb-4178-8381-8d5e2750dd8c.png)'
  id: totrans-690
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c55b1d36-b0cb-4178-8381-8d5e2750dd8c.png)'
- en: With this Boolean flag and delay, we're simply setting up a gate whereby the
    snap turn input will be ignored for 0.2 seconds after the last time it was handled,
    which gives the user time to release the stick once they're oriented where they
    want to be.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个布尔标志和延迟，我们只是设置了一个门，使得在最后一次处理后的0.2秒内快速转身输入将被忽略，这给了用户释放摇杆的时间，一旦他们朝向他们想要的方向。
- en: This implementation gives your player a nice natural-feeling snap turn on the
    right stick while leaving the left stick for analogue seamless movement.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现使得玩家在右摇杆上有一个很好的自然感觉的快速转身，同时将左摇杆用于模拟无缝移动。
- en: Summary
  id: totrans-693
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We did quite a lot in this chapter.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们做了很多事情。
- en: 'We learned how to set up and refine a navigation mesh in our scene and how
    to find and fix collision problems with objects in our scene. We learned how to
    set up input actions and use them to move our player character around, and perhaps
    most importantly, we learned Kent Beck''s mantra for software development: *Make
    it work, make it right, make it fast*, and learned what it means to follow it
    as we pursue iterative development. We''re going to revisit this a lot. It''s
    a secret to effective software development.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何在场景中设置和优化导航网格，以及如何查找和修复场景中对象的碰撞问题。我们学习了如何设置输入动作并使用它们来移动我们的玩家角色，也许最重要的是，我们学习了肯特·贝克的软件开发口号：“让它工作，让它正确，让它快”，并学习了在迭代开发中遵循它的含义。我们将经常回顾这一点。这是有效软件开发的秘诀。
- en: That was a lot of work. The exercises in this chapter covered a lot of ground,
    but should have left you with a decent sense of how the parts fit together when
    setting up a player pawn and a locomotion system.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项很大的工作。本章的练习涵盖了很多内容，但应该让您对设置玩家角色和运动系统的各个部分如何配合有一个不错的理解。
- en: Now that we've given our pawn feet, in the next chapter, we're going to give
    it hands. We'll learn how to use motion controllers to point, grip, and interact
    with objects in the world. We'll also build on what we've learned about setting
    up navigation meshes and drop some AI into the world to use them as well. Now
    that we can get around the world, we're going to start bringing it to life.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们给了我们的角色脚，下一章，我们将给它手。我们将学习如何使用动作控制器来指向、抓取和与世界中的对象交互。我们还将在设置导航网格方面进一步学习，并将一些AI放入世界中以使用它们。现在我们可以在世界中四处走动了，我们将开始让它生动起来。
