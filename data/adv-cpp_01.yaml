- en: 1\. Anatomy of Portable C++ Software
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 可移植C++软件的解剖学
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Establish the code-build-test process
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立代码构建测试流程
- en: Describe the various stages of compilation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述编译的各个阶段
- en: Decipher complicated C++ type systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密复杂的C++类型系统
- en: Configure projects with unit tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置具有单元测试的项目
- en: Convert source code to object code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将源代码转换为目标代码
- en: Write readable code and debug it
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可读的代码并调试它
- en: In this chapter, we will learn to establish the code-build-test model that will
    be used throughout the book, write beautiful code, and perform unit tests.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习建立贯穿全书使用的代码构建测试模型，编写优美的代码并进行单元测试。
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: C++ is one of the oldest and most popular languages that you can use to write
    efficient code. It is both "close to the metal," like C, and has advanced object-oriented
    features, like Java. Being an efficient low-level language makes C++ the language
    of choice for domains in which efficiency is paramount, such as games, simulations,
    and embedded systems. At the same time, being an object-oriented language with
    advanced features such as generics, references, and countless others makes it
    suitable for large projects that are developed and maintained by multiple people.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: C++是最古老和最流行的语言之一，您可以使用它来编写高效的代码。它既像C一样“接近底层”，又具有高级的面向对象特性，就像Java一样。作为一种高效的低级语言，C++是效率至关重要的领域的首选语言，例如游戏、模拟和嵌入式系统。同时，作为一种具有高级特性的面向对象语言，例如泛型、引用和无数其他特性，使其适用于由多人开发和维护的大型项目。
- en: Almost any programming experience involves organizing your code base and using
    libraries written by others. C++ is no different. Unless your program is simple,
    you will distribute your code into multiple files that you need to organize, and
    you will use various libraries that fulfill tasks, usually in a much more efficient
    and robust way than your code would. C++ projects that do not use any third-party
    libraries are edge cases that do not represent the majority of projects, which
    use many libraries. These projects and their libraries are expected to work in
    different hardware architectures and operating systems. Therefore, it is important
    to spend time on project setup and understand the tools used to manage dependencies
    if you are going to develop anything meaningful with C++.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何编程经验都涉及组织您的代码库并使用他人编写的库。C++也不例外。除非您的程序很简单，否则您将把代码分发到多个文件中，并且需要组织这些文件，您将使用各种库来完成任务，通常比您的代码更有效和更可靠。不使用任何第三方库的C++项目是不代表大多数项目的边缘情况，大多数项目都使用许多库。这些项目及其库预期在不同的硬件架构和操作系统上工作。因此，如果您要使用C++开发任何有意义的东西，花时间进行项目设置并了解用于管理依赖关系的工具是很重要的。
- en: Most modern and popular high-level languages have standard tools to maintain
    projects, build them, and handle their library dependencies. Many of these have
    repositories that host libraries and tools that automatically download and use
    libraries from those repositories. For example, Python has `pip`, which takes
    care of downloading and using appropriate versions of libraries that the programmer
    wants to use. Similarly, JavaScript has `npm`, Java has `maven`, Dart has `pub`,
    and C# has `NuGet`. In most of these languages, you list the name of the library
    and the version that you would like to use, and the tool automatically downloads
    and uses the compatible version of the library. These languages benefit from the
    fact that the programs are built and run in a controlled environment in which
    a certain level of hardware and software requirements are satisfied. C++, on the
    other hand, is expected to work in a variety of contexts with different architectures,
    including very primitive hardware. Hence, C++ programmers are less pampered when
    it comes to building programs and performing dependency management.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代和流行的高级语言都有标准工具来维护项目、构建项目并处理其库依赖关系。其中许多都有托管库和工具的存储库，可以自动下载并使用这些库。例如，Python有`pip`，它负责下载和使用程序员想要使用的库的适当版本。同样，JavaScript有`npm`，Java有`maven`，Dart有`pub`，C#有`NuGet`。在这些语言中，您列出要使用的库的名称和版本，工具会自动下载并使用兼容版本的库。这些语言受益于程序在受控环境中构建和运行，其中满足一定级别的硬件和软件要求。另一方面，C++预期在各种上下文中使用，具有不同的架构，包括非常原始的硬件。因此，当涉及构建程序和执行依赖管理时，C++程序员受到的关注较少。
- en: Managing C++ Projects
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理C++项目
- en: In the world of C++, we have several tools that help in managing project sources
    and their dependencies. For example, `pkg-config`, `Autotools`, `make`, and `CMake`
    are the most notable ones in the community. Compared to the tools of the other
    high-level languages, these are much more complicated to use. `CMake` has arisen
    among these as the de facto standard for managing C++ projects and their dependencies.
    It is more opinionated compared to `make`, and it is accepted as the direct project
    format for most IDEs (Integrated Development Environments).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++世界中，我们有几种工具可帮助管理项目源代码及其依赖关系。例如，`pkg-config`、`Autotools`、`make`和`CMake`是社区中最值得注意的工具。与其他高级语言的工具相比，这些工具使用起来要复杂得多。`CMake`已成为管理C++项目及其依赖关系的事实标准。与`make`相比，它更具有主观性，并且被接受为大多数集成开发环境（IDE）的直接项目格式。
- en: While `CMake` helps with managing projects and their dependencies, the experience
    is still far from higher-level languages in which you list the libraries and their
    versions that you want to use and everything else is taken care of for you. With
    CMake, you still are responsible for installing libraries properly in your development
    environment, and you are expected to use compatible versions for each library.
    In popular Linux distributions with extensive package managers, you can easily
    install binary versions of most popular libraries. However, sometimes, you may
    have to compile and install the libraries yourself. This is a part of the whole
    C++ developer experience, which you will gather by learning more about the development
    platform of your choice. Here, we will focus more on how to properly set up our
    CMake projects, including understanding and resolving issues related to libraries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`CMake`有助于管理项目及其依赖关系，但体验仍远远不及高级语言，其中您列出要使用的库及其版本，其他一切都会为您处理。使用CMake，您仍需负责在开发环境中正确安装库，并且您需要使用每个库的兼容版本。在流行的Linux发行版中，有广泛的软件包管理器，您可以轻松安装大多数流行库的二进制版本。然而，有时您可能需要自行编译和安装库。这是C++开发者体验的一部分，您将通过学习更多关于您选择的开发平台的开发平台来了解。在这里，我们将更专注于如何正确设置我们的CMake项目，包括理解和解决与库相关的问题。
- en: The Code-Build-Test-Run Loop
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码构建测试运行循环
- en: In order to base our discussion on a solid foundation, we will immediately start
    with a practical example. We will start with a C++ code base template that you
    can use as a starting point for your own projects. We will see how we can build
    and compile it using CMake on the command line. We will also set up the Eclipse
    IDE for C/C++ developers and import our CMake project. The use of an IDE will
    provide us with facilities that ease the creation of source code and enable us
    to debug our programs line by line to view what exactly happens during the execution
    of our program and correct our mistakes in an informed fashion rather than trial
    and error and superstition.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以坚实的基础展开讨论，我们将立即从一个实际示例开始。我们将从一个C++代码基础模板开始，您可以将其用作自己项目的起点。我们将看到如何使用CMake在命令行上构建和编译它。我们还将为C/C++开发人员设置Eclipse
    IDE，并导入我们的CMake项目。使用IDE将为我们提供便利设施，以便轻松创建源代码，并使我们能够逐行调试我们的程序，查看程序执行过程中到底发生了什么，并以明智的方式纠正错误，而不是靠试错和迷信。
- en: Building a CMake Project
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一个CMake项目
- en: 'The de facto standard for C++ projects is to use CMake to organize and build
    the project. Here, we will use a basic template project as a starting point. The
    following is the folder structure of a sample template:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C++项目的事实标准是使用CMake来组织和构建项目。在这里，我们将使用一个基本的模板项目作为起点。以下是一个示例模板的文件夹结构：
- en: '![Figure 1.1: Folder structure of a sample template'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1：示例模板的文件夹结构'
- en: '](img/C14508_01_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_01.jpg)'
- en: 'Figure 1.1: Folder structure of a sample template'
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.1：示例模板的文件夹结构
- en: In the preceding figure, the `git` version control system. Such ignored files
    include the outputs of the build process, which are created locally and should
    not be shared among computers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，`git`版本控制系统。这些被忽略的文件包括构建过程的输出，这些文件是在本地创建的，不应在计算机之间共享。
- en: The files in the `make` files for different platforms.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不同平台的`make`文件中的文件。
- en: Building a project with CMake is a two-step process. First, we get CMake to
    generate platform-dependent configuration files for a native build system that
    will compile and build the project. Then, we will use the generated files to build
    the project. The platform-dependent build systems that CMake can generate configuration
    files for include `UNIX` `Makefiles`, `Ninja` `build files`, `NMake` `Makefiles`,
    and `MinGW` `Makefiles`. The choice here depends on the platform in use, the availability
    of these tools, and personal preference. `UNIX` `Makefiles` are a de facto standard
    for `Unix` and `Linux`, whereas `NMake` is its `Windows` and `Visual Studio` counterpart.
    `MinGW`, on the other hand, is a `Unix`-like environment in `Windows` in which
    `Makefiles` are also in use. `Ninja` is a modern build system that provides exceptional
    speed compared to other build systems coupled with multi-platform support, which
    we choose to use here. Furthermore, in addition to these command-line build systems,
    we can also generate IDE projects for `Visual Studio`, `XCode`, `Eclipse CDT`,
    and many others, and build our projects inside the IDE. Therefore, `CMake` is
    a meta tool that will create the configuration files for another system that will
    actually build the project. In the next section, we will solve an exercise, wherein
    we will generate `Ninja` `build files` using `CMake`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CMake构建项目是一个两步过程。首先，我们让CMake生成平台相关的配置文件，用于本地构建系统编译和构建项目。然后，我们将使用生成的文件来构建项目。CMake可以为平台生成配置文件的构建系统包括`UNIX`
    `Makefiles`、`Ninja` `build files`、`NMake` `Makefiles`和`MinGW` `Makefiles`。选择取决于所使用的平台、这些工具的可用性和个人偏好。`UNIX`
    `Makefiles`是`Unix`和`Linux`的事实标准，而`NMake`是其`Windows`和`Visual Studio`的对应物。另一方面，`MinGW`是`Windows`中的`Unix`-like环境，也在使用`Makefiles`。`Ninja`是一个现代的构建系统，与其他构建系统相比速度异常快，同时支持多平台，我们选择在这里使用。此外，除了这些命令行构建系统，我们还可以为`Visual
    Studio`、`XCode`、`Eclipse CDT`等生成IDE项目，并在IDE中构建我们的项目。因此，`CMake`是一个元工具，将为另一个实际构建项目的系统创建配置文件。在下一节中，我们将解决一个练习，其中我们将使用`CMake`生成`Ninja`
    `build files`。
- en: 'Exercise 1: Using CMake to Generate Ninja Build Files'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：使用CMake生成Ninja构建文件
- en: In this exercise, we will use `CMake` to generate `Ninja build files`, which
    are used to build C++ projects. We will first download our source code from a
    `git` repository and will use CMake and Ninja to build it. The aim of this exercise
    is to use CMake to generate Ninja build files, build the project, and then run
    them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`CMake`生成`Ninja build files`，用于构建C++项目。我们将首先从`git`存储库下载我们的源代码，然后使用CMake和Ninja来构建它。这个练习的目的是使用CMake生成Ninja构建文件，构建项目，然后运行它们。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The link to the GitHub repository can be found here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson1/Exercise01/project](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson1/Exercise01/project).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub仓库的链接可以在这里找到：[https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson1/Exercise01/project](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson1/Exercise01/project)。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'In a terminal window, type the following command to download the `CxxTemplate`
    repository from GitHub onto your local system:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，输入以下命令，将`CxxTemplate`仓库从GitHub下载到本地系统：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the previous command is similar to the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出类似于以下内容：
- en: '![Figure 1.2: Checking out the sample project from GitHub'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2：从GitHub检出示例项目'
- en: '](img/C14508_01_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_02.jpg)'
- en: 'Figure 1.2: Checking out the sample project from GitHub'
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.2：从GitHub检出示例项目
- en: Now you have the source code in the `CxxTemplate` folder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在`CxxTemplate`文件夹中有了源代码。
- en: 'Navigate into the `CxxTemplate` folder by typing the following command in the
    terminal:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中输入以下命令，进入`CxxTemplate`文件夹：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now you can list all the files in the project by typing the following command:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以通过在终端中输入以下命令来列出项目中的所有文件：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Generate our Ninja build file using the `cmake` command in the `CxxTemplate`
    folder. To do that, write the following command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CxxTemplate`文件夹中使用`cmake`命令生成我们的Ninja构建文件。为此，输入以下命令：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出如下：
- en: '![Figure 1.3: Generating the Ninja build file'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：生成Ninja构建文件'
- en: '](img/C14508_01_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_03.jpg)'
- en: 'Figure 1.3: Generating the Ninja build file'
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.3：生成Ninja构建文件
- en: Let's explain parts of the preceding command. With `-Bbuild`, we are telling
    CMake to use the `build` folder to generate build artifacts. Since this folder
    does not exist, CMake will create it. With `–H.`, we are telling CMake to use
    the current folder as the source. By using a separate `build` folder, we will
    keep our source files clean and all the build artifacts will live in the `build`
    folder, which is ignored by Git thanks to our `.gitignore` file. With `–GNinja`,
    we are telling CMake to use the Ninja build system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下上一个命令的部分。使用`-Bbuild`，我们告诉CMake使用`build`文件夹来生成构建产物。由于这个文件夹不存在，CMake会创建它。使用`-H.`，我们告诉CMake使用当前文件夹作为源。通过使用单独的`build`文件夹，我们将保持我们的源文件干净，所有的构建产物都将存放在`build`文件夹中，这得益于我们的`.gitignore`文件而被Git忽略。使用`-GNinja`，我们告诉CMake使用Ninja构建系统。
- en: 'Run the following commands to list the project files and to check the files
    that were created inside the `build` folder:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来列出项目文件并检查在`build`文件夹中创建的文件：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding command will show the following output in the terminal:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令将在终端中显示以下输出：
- en: '![Figure 1.4: Files in the build folder'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4：构建文件夹中的文件'
- en: '](img/C14508_01_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_04.jpg)'
- en: 'Figure 1.4: Files in the build folder'
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.4：构建文件夹中的文件
- en: It's clear that the preceding files will be present inside the build folder.
    **build.ninja** and **rules.ninja** in the preceding output are the Ninja build
    files that can actually build our project in this platform.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，上一个文件将存在于构建文件夹中。上一个输出中的**build.ninja**和**rules.ninja**是Ninja构建文件，实际上可以在这个平台上构建我们的项目。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: By using CMake, we did not have to write the Ninja build files and avoided committing
    to the Unix platform. Instead, we have a meta-build system that can generate low-level
    build files for other platforms such as UNIX/Linux, MinGW, and Nmake.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用CMake，我们不必编写Ninja构建文件，并避免了对Unix平台的提交。相反，我们有一个可以为其他平台生成低级构建文件的元构建系统，比如UNIX/Linux、MinGW和Nmake。
- en: 'Now, go into the `build` folder and build our project by typing the following
    commands in the terminal:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，进入`build`文件夹，并通过在终端中输入以下命令来构建我们的项目：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see a final output like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到最终输出如下：
- en: '![Figure 1.5: Building with ninja'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5：使用ninja构建'
- en: '](img/C14508_01_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_05.jpg)'
- en: 'Figure 1.5: Building with ninja'
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.5：使用ninja构建
- en: 'Type `ls` in the `CxxTemplate` executable or not:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CxxTemplate`可执行文件中键入`ls`或不键入：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The previous command yields the following output in the terminal:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令在终端中产生以下输出：
- en: '![Figure 1.6: Files in the build folder after running ninja'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6：运行ninja后构建文件夹中的文件'
- en: '](img/C14508_01_06.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_06.jpg)'
- en: 'Figure 1.6: Files in the build folder after running ninja'
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.6：运行ninja后构建文件夹中的文件
- en: In the preceding figure, you can see that the `CxxTemplate` executable is generated.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个图中，你可以看到`CxxTemplate`可执行文件已经生成。
- en: 'In the terminal, type the following command to run the `CxxTemplate` executable:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，输入以下命令来运行`CxxTemplate`可执行文件：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The previous command in the terminal will provide the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 终端中的上一个命令将提供以下输出：
- en: '![](img/C14508_01_07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14508_01_07.jpg)'
- en: 'Figure 1.7: Running the executable'
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.7：运行可执行文件
- en: 'The following line from the `src/CxxTemplate.cpp` file is responsible for writing
    the previous output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/CxxTemplate.cpp`文件中的以下行负责写入上一个输出：'
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now you have successfully built a CMake project in Linux. Ninja and CMake work
    quite well together. You have to run CMake only once and Ninja will detect whether
    CMake should be called again and will call it for you. For example, even if you
    add new source files to your `CMakeLists.txt` file, you only need to type the
    `ninja` command in the terminal, and it will run CMake automatically for you to
    update the Ninja build files. Now that you have learned about building a CMake
    project in Linux, in the next section, we will look at how to import a CMake project
    into Eclipse CDT.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功在Linux中构建了一个CMake项目。Ninja和CMake在一起工作得很好。你只需要运行一次CMake，Ninja就会检测是否需要再次调用CMake，并会自动为你调用。例如，即使你向`CMakeLists.txt`文件中添加新的源文件，你只需要在终端中输入`ninja`命令，它就会自动运行CMake来更新Ninja构建文件。现在你已经了解了如何在Linux中构建CMake项目，在下一节中，我们将看看如何将CMake项目导入Eclipse
    CDT。
- en: Importing a CMake Project into Eclipse CDT
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将CMake项目导入Eclipse CDT
- en: A Ninja build file is useful for building our project in Linux. However, a CMake
    project is portable and can be used with other build systems and IDEs as well.
    Many IDEs accept CMake as their configuration file and provide a seamless experience
    as you modify and build your project. In this section, we will discuss how to
    import a CMake project into Eclipse CDT, which is a popular cross-platform C/C++
    IDE.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Ninja构建文件对于在Linux中构建我们的项目非常有用。但是，CMake项目是可移植的，并且也可以与其他构建系统和IDE一起使用。许多IDE接受CMake作为其配置文件，并在您修改和构建项目时提供无缝体验。在本节中，我们将讨论如何将CMake项目导入Eclipse
    CDT，这是一款流行的跨平台C/C++ IDE。
- en: There are multiple ways of using Eclipse CDT with CMake. The default one that
    CMake provides is the one-way generation of the IDE project. Here, you create
    the IDE project once, and any modifications you make to your IDE project will
    not change back the original CMake project. This is useful if you manage your
    project as a CMake project and do one-time builds with Eclipse CDT. However, it's
    not ideal if you want to do your development in Eclipse CDT.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Eclipse CDT与CMake有多种方法。CMake提供的默认方法是单向生成IDE项目。在这里，您只需创建一次IDE项目，对IDE项目进行的任何修改都不会改变原始的CMake项目。如果您将项目作为CMake项目进行管理，并且只在Eclipse
    CDT中进行一次性构建，则这很有用。但是，如果您想在Eclipse CDT中进行开发，则不是理想的方法。
- en: Another way of using CMake with Eclipse CDT is to use the custom `cmake4eclipse`
    plugin. When using this plugin, you do not abandon your `CMakeLists.txt` file
    and make a one-way switch to Eclipse CDT's own project manager. Instead, you keep
    managing your project through the `CMakeLists.txt` file, which continues to be
    the main configuration file of your project. Eclipse CDT actively works with your
    `CMakeLists.txt` file to build your project. You can add or remove source files
    and make other changes in your `CMakeLists.txt`, and the `cmake4eclipse` plugin
    applies those changes to the Eclipse CDT project at every build. You will have
    a nice IDE experience while keeping your CMake project current. The benefit of
    this approach is that you can always quit using Eclipse CDT and use your `CMakeLists.txt`
    file to switch to another build system (such as Ninja) later. We will use this
    second approach in the following exercise.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Eclipse CDT与CMake的另一种方法是使用自定义的`cmake4eclipse`插件。使用此插件时，您不会放弃您的`CMakeLists.txt`文件并单向切换到Eclipse
    CDT的项目管理器。相反，您将继续通过`CMakeLists.txt`文件管理项目，该文件将继续是项目的主要配置文件。Eclipse CDT会积极与您的`CMakeLists.txt`文件合作构建项目。您可以在`CMakeLists.txt`中添加或删除源文件并进行其他更改，`cmake4eclipse`插件会在每次构建时将这些更改应用于Eclipse
    CDT项目。您将拥有良好的IDE体验，同时保持您的CMake项目处于最新状态。这种方法的好处是您始终可以停止使用Eclipse CDT，并使用您的`CMakeLists.txt`文件切换到另一个构建系统（如Ninja）。我们将在以下练习中使用这种第二种方法。
- en: 'Exercise 2: Importing the CMake File into Eclipse CDT'
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：将CMake文件导入Eclipse CDT
- en: 'In the last exercise, you developed a CMake project and you would like to start
    using Eclipse CDT IDE to edit and build that project. In this exercise, we will
    import our CMake project into the Eclipse CDT IDE using the `cmake4eclipse` plugin.
    Perform the following steps to complete the exercise:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，您开发了一个CMake项目，并希望开始使用Eclipse CDT IDE来编辑和构建该项目。在本练习中，我们将使用`cmake4eclipse`插件将我们的CMake项目导入Eclipse
    CDT IDE。执行以下步骤完成练习：
- en: Open Eclipse CDT.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Eclipse CDT。
- en: 'Create a new C++ project in the location of our current project (the folder
    that contains the `CMakeLists.txt` file and the **src** folder). Go to **File**
    | **New** | **Project**. A **New Project** dialog box appears like the one in
    the following screenshot:![Figure 1.8: New Project dialog box'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前项目的位置（包含`CMakeLists.txt`文件和**src**文件夹的文件夹）中创建一个新的C++项目。转到**文件** | **新建**
    | **项目**。将出现一个类似以下截图的**新建项目**对话框：![图1.8：新建项目对话框
- en: '](img/C14508_01_08.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_08.jpg)'
- en: 'Figure 1.8: New Project dialog box'
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.8：新建项目对话框
- en: 'Select the **C++ Project** option and click on the **Next** button. A **C++
    Project** dialog box appears like the one in the following screenshot:![Figure
    1.9: C++ Project dialog box'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**C++项目**选项，然后点击**下一步**按钮。将出现一个类似以下截图的**C++项目**对话框：![图1.9：C++项目对话框
- en: '](img/C14508_01_09.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_09.jpg)'
- en: 'Figure 1.9: C++ Project dialog box'
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.9：C++项目对话框
- en: Accept everything, including switching to the C/C++ perspective, and click **Finish**.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受一切，包括切换到C/C++视角，然后点击**完成**。
- en: 'Click on the **Restore** button at the top-left corner to view the newly created
    project:![Figure 1.10: The Restore button'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左上角的**还原**按钮查看新创建的项目：![图1.10：还原按钮
- en: '](img/C14508_01_10.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_10.jpg)'
- en: 'Figure 1.10: The Restore button'
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.10：还原按钮
- en: 'Click on the **CxxTemplate** project. Go to **Project** | **Properties**, then
    select **Tool Chain Editor** under **C/C++ Build** from the left pane and set
    **Current builder** to **CMake Builder (portable)**. Then, click on the **Apply
    and Close** button:![Figure 1.11: Project properties'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**CxxTemplate**项目。转到**项目** | **属性**，然后在左侧窗格下选择**C/C++构建**下的**工具链编辑器**，将**当前构建器**设置为**CMake
    Builder (portable)**。然后，点击**应用并关闭**按钮：![图1.11：项目属性
- en: '](img/C14508_01_11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_11.jpg)'
- en: 'Figure 1.11: Project properties'
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.11：项目属性
- en: 'Then, choose the **Project** | **Build All** menu item to build the project:![Figure
    1.12: Building the project'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择**项目** | **构建全部**菜单项来构建项目：![图1.12：构建项目
- en: '](img/C14508_01_12.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_12.jpg)'
- en: 'Figure 1.12: Building the project'
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.12：构建项目
- en: 'In the following `make all` that actually builds our project:![Figure 1.13:
    The build output'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的`make all`中实际构建我们的项目：![图1.13：构建输出
- en: '](img/C14508_01_13.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_13.jpg)'
- en: 'Figure 1.13: The build output'
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.13：构建输出
- en: 'If you did not get any errors in the previous steps, you can run the project
    using the menu item **Run** | **Run**. If you are given some options, choose **Local
    C/C++ Application** and **CxxTemplate** as the executable:![Figure 1.14: Running
    a project'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在之前的步骤中没有出现任何错误，您可以使用菜单项**运行** | **运行**来运行项目。如果给出了一些选项，请选择**本地C/C++应用程序**和**CxxTemplate**作为可执行文件：![图1.14：运行项目
- en: '](img/C14508_01_14.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_14.jpg)'
- en: 'Figure 1.14: Running a project'
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.14：运行项目
- en: 'When it runs, you will see the output of the program in the **Console** pane
    as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当运行时，你会在**控制台**窗格中看到程序的输出如下：
- en: '![Figure 1.15: Output of the project'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.15：项目的输出'
- en: '](img/C14508_01_15.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_15.jpg)'
- en: 'Figure 1.15: Output of the project'
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.15：项目的输出
- en: You have successfully built and run a CMake project using Eclipse CDT. In the
    next exercise, we will introduce a frequent change to our projects by adding new
    source files with new classes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功地使用Eclipse CDT构建和运行了一个CMake项目。在下一个练习中，我们将通过添加新的源文件和新类来频繁地更改我们的项目。
- en: 'Exercise 3: Adding New Source Files to CMake and Eclipse CDT'
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：向CMake和Eclipse CDT添加新的源文件
- en: 'As you develop significantly bigger C++ projects, you will tend to add new
    source files to it as the project grows to meet the set expectations. In this
    exercise, we will add a new `.cpp` and `.h` file pair to our project and see how
    CMake and Eclipse CDT work together with these changes. We will add these files
    inside the project using the new class wizard, but you can also create them with
    any other text editor. Perform the following steps to add new source files to
    CMake and Eclipse CDT:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 随着C++项目的不断扩大，你会倾向于向其中添加新的源文件，以满足预期的要求。在这个练习中，我们将向我们的项目中添加一个新的`.cpp`和`.h`文件对，并看看CMake和Eclipse
    CDT如何处理这些更改。我们将使用新类向项目中添加这些文件，但你也可以使用任何其他文本编辑器创建它们。执行以下步骤将新的源文件添加到CMake和Eclipse
    CDT中：
- en: 'First, open the project that we have been using until now. In the **Project
    Explorer** pane on the left, expand the root entry, **CxxTemplate**, and you will
    see the files and folders of our project. Right-click the **src** folder and select
    **New** | **Class** from the pop-up menu:![Figure 1.16: Creating a new class'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开我们一直在使用的项目。在左侧的**项目资源管理器**窗格中，展开根条目**CxxTemplate**，你会看到我们项目的文件和文件夹。右键单击**src**文件夹，从弹出菜单中选择**新建**
    | **类**：![图1.16：创建一个新类
- en: '](img/C14508_01_16.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_16.jpg)'
- en: 'Figure 1.16: Creating a new class'
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.16：创建一个新类
- en: In the dialog box that opened, type **ANewClass** for the class name. When you
    click on the **Finish** button, you will see the **ANewClass.cpp** and **ANewClass.h**
    files generated under the **src** folder.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的对话框中，为类名输入**ANewClass**。当你点击**完成**按钮时，你会看到**src**文件夹下生成了**ANewClass.cpp**和**ANewClass.h**文件。
- en: 'Now, let''s write some code into the `ANewClass` class and access it from the
    `ANewClass.cpp` and change the beginning of the file to match the following, and
    then save the file:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`ANewClass`类中写一些代码，并从`ANewClass.cpp`中访问它，并更改文件的开头以匹配以下内容，然后保存文件：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will see that Eclipse warns us with a `ANewClass.h` file as well. Such warnings
    are made possible by analyzers in IDEs and are quite useful as they help you fix
    your code as you are typing, without running the compiler.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到Eclipse用`ANewClass.h`文件警告我们。这些警告是由IDE中的分析器实现的，非常有用，因为它们可以在你输入代码时帮助你修复代码，而无需运行编译器。
- en: 'Open the `ANewClass.h` file, add the following code, and save the file:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ANewClass.h`文件，添加以下代码，并保存文件：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should see that the error in the `.cpp` file went away. If it did not go
    away, it may be because you may have forgotten to save one of the files. You should
    make it a habit to press *Ctrl + S* to save the current file, or *Shift + Ctrl
    + S* to save all the files that you edited.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到`.cpp`文件中的错误消失了。如果没有消失，可能是因为你可能忘记保存其中一个文件。你应该养成按*Ctrl + S*保存当前文件的习惯，或者按*Shift
    + Ctrl + S*保存你编辑过的所有文件。
- en: 'Now, let''s use this class from our other class, `CxxTemplate.cpp`. Open that
    file, perform the following modifications, and save the file. Here, we are first
    importing header files and in the constructor of `CxxApplication`, we are printing
    text to the console. Then, we are creating a new instance of `ANewClass` and calling
    its `run` method:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们从我们的另一个类`CxxTemplate.cpp`中使用这个类。打开该文件，进行以下修改，并保存文件。在这里，我们首先导入头文件，在`CxxApplication`的构造函数中，我们向控制台打印文本。然后，我们创建了`ANewClass`的一个新实例，并调用了它的`run`方法：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The complete code of this file can be found here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson1/Exercise03/src/CxxTemplate.cpp](https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson1/Exercise03/src/CxxTemplate.cpp).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的完整代码可以在这里找到：[https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson1/Exercise03/src/CxxTemplate.cpp](https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson1/Exercise03/src/CxxTemplate.cpp)。
- en: 'Try to build the project by clicking on the `CMakeLists.txt` file, make the
    following modification, and save the file:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试通过点击`CMakeLists.txt`文件来构建项目，进行以下修改，并保存文件：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Try to build the project again. This time you should not see any errors.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试再次构建项目。这次你不应该看到任何错误。
- en: 'Run the project using the **Run** | **Run** menu option. You should see the
    following output in the terminal:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**运行** | **运行**菜单选项运行项目。你应该在终端中看到以下输出：
- en: '![Figure 1.18: Program output'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.18：程序输出'
- en: '](img/C14508_01_18.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_18.jpg)'
- en: 'Figure 1.18: Program output'
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.18：程序输出
- en: You modified a CMake project, added new files to it, and ran it fine. Note that
    we created the files in the `src` folder and let the `CMakeLists.txt` file know
    about the CPP file. If you do not use Eclipse, you can simply continue with the
    usual CMake build commands and your program will run successfully. So far, we
    have checked out the sample code from GitHub and built it both with plain CMake
    and with the Eclipse IDE. We also added a new class to the CMake project and rebuilt
    it in Eclipse IDE. Now you know how to build and modify CMake projects. In the
    next section, we will perform an activity of adding a new source-header file pair
    to the project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你修改了一个CMake项目，向其中添加了新文件，并成功地运行了它。请注意，我们在`src`文件夹中创建了文件，并让`CMakeLists.txt`文件知道了CPP文件。如果你不使用Eclipse，你可以继续使用通常的CMake构建命令，你的程序将成功运行。到目前为止，我们已经从GitHub检出了示例代码，并且用纯CMake和Eclipse
    IDE构建了它。我们还向CMake项目中添加了一个新类，并在Eclipse IDE中重新构建了它。现在你知道如何构建和修改CMake项目了。在下一节中，我们将进行一个活动，向项目添加一个新的源文件-头文件对。
- en: 'Activity 1: Adding a New Source-Header File Pair to the Project'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：向项目添加新的源文件-头文件对
- en: 'As you develop C++ projects, you add new source files to it as the project
    grows. You may want to add new source files for various reasons. For example,
    let''s say you are developing an accounting application in which you calculate
    interest rates in many places of your project, and you want to create a function
    in a separate file so that you can reuse it throughout your project. To keep things
    simple, here we will create a simple summation function instead. In this activity,
    we will add a new source-header file pair to the project. Perform the following
    steps to complete the activity:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发C++项目时，随着项目的增长，您会向其中添加新的源文件。您可能出于各种原因想要添加新的源文件。例如，假设您正在开发一个会计应用程序，在其中需要在多个地方计算利率，并且您希望创建一个单独的文件中的函数，以便在整个项目中重用它。为了保持简单，在这里我们将创建一个简单的求和函数。在这个活动中，我们将向项目添加一个新的源文件和头文件对。执行以下步骤完成该活动：
- en: Open the project that we created in the earlier exercise in the Eclipse IDE.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse IDE中打开我们在之前练习中创建的项目。
- en: Add the `SumFunc.cpp` and `SumFunc.h` file pair to the project.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SumFunc.cpp`和`SumFunc.h`文件对添加到项目中。
- en: Create a simple function named `sum` that returns the sum of two integers.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sum`的简单函数，它返回两个整数的和。
- en: Call the function from the `CxxTemplate` class constructor.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`CxxTemplate`类构造函数中调用该函数。
- en: Build and run the project in Eclipse.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中构建并运行项目。
- en: 'The expected output should be similar to the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出应该类似于以下内容：
- en: '![Figure 1.19: Final output'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.19：最终输出'
- en: '](img/C14508_01_19.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_19.jpg)'
- en: 'Figure 1.19: Final output'
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.19：最终输出
- en: Note
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 620.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第620页找到。
- en: In the following section, we will talk about how to write unit tests for our
    projects. It is common to divide projects into many classes and functions that
    work together to achieve the desired goal. You must manage the behavior of these
    classes and functions with unit tests to ensure that they behave in expected ways.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将讨论如何为我们的项目编写单元测试。将项目分成许多类和函数，并让它们一起工作以实现期望的目标是很常见的。您必须使用单元测试来管理这些类和函数的行为，以确保它们以预期的方式运行。
- en: Unit Testing
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are an important part of programming in general. Basically, unit
    tests are little programs that use our classes in various scenarios with expected
    results, live in a parallel file hierarchy in our project, and do not end up in
    the actual executable but are executed separately by us during development to
    ensure that our code is behaving in expected ways. We should write unit tests
    for our C++ programs to ensure that they behave as they are supposed to after
    each change.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在编程中是一个重要的部分。基本上，单元测试是使用我们的类在各种场景下进行测试的小程序，预期结果是在我们的项目中的一个并行文件层次结构中，不会最终出现在实际的可执行文件中，而是在开发过程中由我们单独执行，以确保我们的代码以预期的方式运行。我们应该为我们的C++程序编写单元测试，以确保它们在每次更改后都能按照预期的方式运行。
- en: Preparing for the Unit Tests
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为单元测试做准备
- en: There are several C++ test frameworks that we can use with CMake. We will use
    **Google Test**, which has several benefits over other options. In the next exercise,
    we will prepare our project for unit testing with Google Test.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个C++测试框架可以与CMake一起使用。我们将使用**Google Test**，它比其他选项有几个优点。在下一个练习中，我们将准备我们的项目以便使用Google
    Test进行单元测试。
- en: 'Exercise 4: Preparing Our Project for Unit Testing'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习4：为单元测试准备我们的项目
- en: 'We have installed Google Test but our project is not set up to use Google Test
    for unit testing. In addition to the installation, there are settings that need
    to be carried out in our CMake project to have Google Test unit tests. Follow
    these steps to implement this exercise:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装了Google Test，但我们的项目还没有设置好以使用Google Test进行单元测试。除了安装之外，在我们的CMake项目中还需要进行一些设置才能进行Google
    Test单元测试。按照以下步骤执行此练习：
- en: Open Eclipse CDT and select the CxxTemplate project that we have been using.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Eclipse CDT，并选择我们一直在使用的CxxTemplate项目。
- en: Create a new folder named **tests** as we will perform all our tests there.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**tests**的新文件夹，因为我们将在那里执行所有的测试。
- en: 'Edit our base `CMakeLists.txt` file to allow tests in the `GTest` package that
    brings `GoogleTest` capability to CMake. We will add our new lines just after
    that:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑我们的基本`CMakeLists.txt`文件，以允许在`GTest`包中进行测试，该包为CMake带来了`GoogleTest`功能。我们将在此之后添加我们的新行：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is all we need to add to our main `CMakeLists.txt` file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要添加到我们主要的`CMakeLists.txt`文件中的所有内容。
- en: Create another `CMakeLists.txt` file inside our `add_subdirectory(tests)` line
    that we had in our main `CMakeLists.txt` file. This `tests/CMakeLists.txt` file
    will manage the test sources.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们主要的`CMakeLists.txt`文件中的`add_subdirectory(tests)`行内创建另一个`CMakeLists.txt`文件。这个`tests/CMakeLists.txt`文件将管理测试源代码。
- en: 'Add the following code in the `tests/CMakeLists.txt` file:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tests/CMakeLists.txt`文件中添加以下代码：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's dissect this code line by line. The first line brings in the Google Test
    capability. The second line creates the `tests` executable, which will include
    all our test source files. In this case, we only have one `CanTest.cpp` file,
    which will just verify that the testing works. After that, we link the `GTest`
    library to the `tests` executable. The last line identifies all individual tests
    in the `tests` executable and adds them to `CMake` as a test. This way, various
    test tools will be able to tell us which individual tests failed and which ones
    passed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析这段代码。第一行引入了Google Test功能。第二行创建了`tests`可执行文件，其中将包括所有我们的测试源文件。在这种情况下，我们只有一个`CanTest.cpp`文件，它将验证测试是否有效。之后，我们将`GTest`库链接到`tests`可执行文件。最后一行标识了`tests`可执行文件中的所有单独测试，并将它们添加到`CMake`作为一个测试。这样，各种测试工具将能够告诉我们哪些单独的测试失败了，哪些通过了。
- en: 'Create a `tests/CanTest.cpp` file. Add this code to simply verify that tests
    are running, without actually testing anything in our actual project:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`tests/CanTest.cpp`文件。添加这段代码来简单验证测试是否运行，而不实际测试我们实际项目中的任何内容：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `TEST_F` line is an individual test. Now, `EXPECT_EQ(0, 0)` is testing whether
    zero is equal to zero, which will always succeed if we can actually run the test.
    We will later add the results of our own classes here to be tested against various
    values. Now we have the necessary setup for Google Test in our project. Next,
    we will build and run these tests.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEST_F`行是一个单独的测试。现在，`EXPECT_EQ(0, 0)`正在测试零是否等于零，如果我们实际运行测试，它将始终成功。稍后，我们将在这里添加我们自己类的结果，以便对各种值进行测试。现在我们的项目中已经具备了Google
    Test的必要设置。接下来，我们将构建和运行这些测试。'
- en: Building, Running, and Writing Unit Tests
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建、运行和编写单元测试
- en: Now, we will discuss how to build, run, and write unit tests. The example that
    we have so far is a simple dummy test that is ready to be built and run. Later,
    we will add tests that make more sense and view the output of passing and failing
    tests. In the following exercise, we will build, run, and write unit tests for
    the project that we created in the previous exercise.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论如何构建、运行和编写单元测试。到目前为止，我们所拥有的示例是一个简单的虚拟测试，已准备好进行构建和运行。稍后，我们将添加更有意义的测试，并查看通过和失败测试的输出。在接下来的练习中，我们将为上一个练习中创建的项目构建、运行和编写单元测试。
- en: 'Exercise 5: Building and Running Tests'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5：构建和运行测试
- en: 'So far, you have created a project with `GoogleTest` set up, but you did not
    build or run the tests we created. In this exercise, we will build and run the
    tests that we created. Since we added our `tests` folder using `add_subdirectory`,
    building the project will automatically build the tests. Running the tests will
    require some more effort. Perform the following steps to complete the exercise:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经创建了一个设置好的`GoogleTest`的项目，但没有构建或运行我们创建的测试。在这个练习中，我们将构建和运行我们创建的测试。由于我们使用`add_subdirectory`添加了我们的`tests`文件夹，构建项目将自动构建测试。运行测试将需要更多的努力。执行以下步骤完成练习：
- en: Open our CMake project in Eclipse CDT.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse CDT中打开我们的CMake项目。
- en: 'To build the tests, simply build the project just like you did before. Here
    is the output of building the project one more time from Eclipse after a full
    build using **Project** | **Build All**:![Figure 1.20: Build operation and its
    output'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建测试，只需像以前一样构建项目即可。以下是在Eclipse中进行完整构建后再次构建项目的输出，使用**Project** | **Build All**：![图1.20：构建操作及其输出
- en: '](img/C14508_01_20.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_20.jpg)'
- en: 'Figure 1.20: Build operation and its output'
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.20：构建操作及其输出
- en: 'If you do not see this output, your console may be in the wrong view. You can
    correct it as shown in the following figures:![Figure 1.21: Viewing the correct
    console output'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您没有看到此输出，则可能是因为您的控制台处于错误的视图中。您可以按照以下图示进行更正：![图1.21：查看正确的控制台输出
- en: '](img/C14508_01_21.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_21.jpg)'
- en: 'Figure 1.21: Viewing the correct console output'
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.21：查看正确的控制台输出
- en: '![Figure 1.22: Viewing the correct console output'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.22：查看正确的控制台输出'
- en: '](img/C14508_01_22.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_22.jpg)'
- en: 'Figure 1.22: Viewing the correct console output'
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.22：查看正确的控制台输出
- en: As you can see, our project now has two executable targets. They both live in
    the `build` folder, as with any other build artifact. Their locations are `build/Debug/CxxTemplate`
    and `build/Debug/tests/tests`. Since they are executables, we can simply run them.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的项目现在有两个可执行目标。它们都位于`build`文件夹中，与任何其他构建产物一样。它们的位置分别是`build/Debug/CxxTemplate`和`build/Debug/tests/tests`。由于它们是可执行文件，我们可以直接运行它们。
- en: 'We ran `CxxTemplate` before and will not see any extra output now. Run the
    other executable by typing the following command in the terminal while we are
    in our project folder:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前运行了`CxxTemplate`，现在不会看到任何额外的输出。通过在项目文件夹中输入以下命令，我们可以运行其他可执行文件：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code generates the following output in the terminal:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在终端中生成了以下输出：
- en: '![Figure 1.23: Running the tests executable'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.23：运行测试可执行文件'
- en: '](img/C14508_01_23.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_23.jpg)'
- en: 'Figure 1.23: Running the tests executable'
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.23：运行测试可执行文件
- en: This is the simple output of our `tests` executable. If you want to see whether
    the tests have passed, you can simply run this. However, testing is so much more
    than that.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`tests`可执行文件的简单输出。如果您想查看测试是否通过，您可以简单地运行它。但是，测试远不止于此。
- en: 'One of the ways you can run your tests is by using the `ctest` command. Write
    the following commands in the terminal while you are in the project folder. We
    go to the folder where the `tests` executable resides, run `ctest` there, and
    come back:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过使用`ctest`命令之一来运行测试。在项目文件夹中的终端中输入以下命令。我们进入`tests`可执行文件所在的文件夹，运行`ctest`，然后返回：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And here is the output that you will see:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您将看到的输出：
- en: '![Figure 1.24: Running ctest'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.24：运行 ctest'
- en: '](img/C14508_01_24.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_24.jpg)'
- en: 'Figure 1.24: Running ctest'
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.24：运行 ctest
- en: Note
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The `ctest` command can run your `tests` executable with a number of options,
    including the ability to submit test results automatically to online dashboards.
    Here, we will simply run the `ctest` command; its further features are left as
    an exercise for the interested reader. You can type `ctest --help` or visit the
    online documentation to discover `ctest` further at [https://cmake.org/cmake/help/latest/manual/ctest.1.html#](https://cmake.org/cmake/help/latest/manual/ctest.1.html#).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctest`命令可以使用多种选项运行您的`tests`可执行文件，包括自动将测试结果提交到在线仪表板的功能。在这里，我们将简单地运行`ctest`命令；其更多功能留给感兴趣的读者作为练习。您可以输入`ctest
    --help`或访问在线文档以了解更多关于`ctest`的信息，网址为[https://cmake.org/cmake/help/latest/manual/ctest.1.html#](https://cmake.org/cmake/help/latest/manual/ctest.1.html#)。'
- en: Another way to run the tests is to run them inside Eclipse, in a nice graphical
    report format. For this, we will create a run configuration that is test-aware.
    In Eclipse, click on **Run** | **Run Configurations…**, right-click **C/C++ Unit**
    on the left, and select **New Configuration**.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种运行测试的方法是在Eclipse中以漂亮的图形报告格式运行它们。为此，我们将创建一个测试感知的运行配置。在Eclipse中，单击**Run** |
    **Run Configurations…**，在左侧右键单击**C/C++ Unit**，然后选择**New Configuration**。
- en: 'Change the name from **CxxTemplate Debug** to **CxxTemplate Tests** as follows:![Figure
    1.25: Changing the name of the run configuration'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名称从**CxxTemplate Debug**更改为**CxxTemplate Tests**如下所示：![图1.25：更改运行配置的名称
- en: '](img/C14508_01_25.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_25.jpg)'
- en: 'Figure 1.25: Changing the name of the run configuration'
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.25：更改运行配置的名称
- en: 'Under **C/C++ Application**, select the **Search Project** option:![Figure
    1.26: Run Configurations'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**C/C++ Application**下，选择**Search Project**选项：![图1.26：运行配置
- en: '](img/C14508_01_26.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_26.jpg)'
- en: 'Figure 1.26: Run Configurations'
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.26：运行配置
- en: 'Choose **tests** in the new dialog:![Figure 1.27: Creating the test run configuration
    and selecting the tests executable'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新对话框中选择**tests**：![图1.27：创建测试运行配置并选择测试可执行文件
- en: '](img/C14508_01_27.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_27.jpg)'
- en: 'Figure 1.27: Creating the test run configuration and selecting the tests executable'
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.27：创建测试运行配置并选择测试可执行文件
- en: 'Next, go to the **C/C++ Testing** tab and select **Google Tests Runner** in
    the dropdown. Click on **Apply** at the bottom of the dialog and click on the
    **Run** option for the test that we have to run for the first time:![Figure 1.28:
    Run Configurations'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到**C/C++ Testing**选项卡，并在下拉菜单中选择**Google Tests Runner**。点击对话框底部的**Apply**，然后点击第一次运行的测试的**Run**选项：![图1.28：运行配置
- en: '](img/C14508_01_28.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_28.jpg)'
- en: 'Figure 1.28: Run Configurations'
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.28：运行配置
- en: 'In the upcoming runs, you can either click the dropdown next to the play button
    in the toolbar, or choose **Run** | **Run History** to choose **CxxTemplate Tests**:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在即将进行的运行中，您可以单击工具栏中播放按钮旁边的下拉菜单，或选择**Run** | **Run History**来选择**CxxTemplate
    Tests**：
- en: '![Figure 1.29: Finalizing the run configuration settings and selecting a configuration
    to run'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.29：完成运行配置设置并选择要运行的配置'
- en: '](img/C14508_01_29.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_29.jpg)'
- en: 'Figure 1.29: Finalizing the run configuration settings and selecting a configuration
    to run'
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.29：完成运行配置设置并选择要运行的配置
- en: 'The result will be similar to the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将类似于以下截图：
- en: '![Figure 1.30: Run results of the unit test'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.30：单元测试的运行结果'
- en: '](img/C14508_01_30.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_30.jpg)'
- en: 'Figure 1.30: Run results of the unit test'
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.30：单元测试的运行结果
- en: This is a nice report that contains entries for all tests—only one for now.
    You may prefer this if you do not want to leave the IDE. Furthermore, when you
    have many tests, this interface can help you filter them effectively. Now you
    have built and run tests that were written using Google Test. You ran them in
    a couple of different ways, including directly executing the test, using `ctest`,
    and using Eclipse CDT. In the next section, we will solve an exercise wherein
    we will actually test the functionality of our code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的报告，包含了所有测试的条目，现在只有一个。如果您不想离开IDE，您可能会更喜欢这个。此外，当您有许多测试时，此界面可以帮助您有效地对其进行过滤。现在，您已经构建并运行了使用Google
    Test编写的测试。您以几种不同的方式运行了它们，包括直接执行测试，使用`ctest`和使用Eclipse CDT。在下一节中，我们将解决一个练习，其中我们将实际测试我们代码的功能。
- en: 'Exercise 6: Testing the Functionality of Code'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习6：测试代码功能
- en: 'You have run simple tests but now you want to write meaningful tests that are
    testing functionality. In the initial activity, we created `SumFunc.cpp`, which
    had the `sum` function. Now, in this exercise, we will write a test for that file.
    In this test, we will use the `sum` function to add two numbers and verify that
    the result is correct. Let''s recall the contents of the following files with
    the `sum` function from before:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经运行了简单的测试，但现在您想编写有意义的测试来测试功能。在初始活动中，我们创建了`SumFunc.cpp`，其中包含`sum`函数。现在，在这个练习中，我们将为该文件编写一个测试。在这个测试中，我们将使用`sum`函数来添加两个数字，并验证结果是否正确。让我们回顾一下之前包含`sum`函数的以下文件的内容：
- en: '`src/SumFunc.h`:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/SumFunc.h`：'
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`src/SumFunc.cpp`:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/SumFunc.cpp`：'
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Relevant lines of `CMakeLists.txt`:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`的相关行：'
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also, let''s recall our `CantTest.cpp` file, which has the `main()` function
    of our unit tests:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，让我们回顾一下我们的`CantTest.cpp`文件，它包含了我们单元测试的`main()`函数：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: Open our CMake project in Eclipse CDT.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse CDT中打开我们的CMake项目。
- en: 'Add a new test source file (`tests/SumFuncTest.cpp`) with the following content:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的测试源文件（`tests/SumFuncTest.cpp`），内容如下：
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that this does not have a `main()` function since `CanTest.cpp` has one
    and these will be linked together. Secondly, note that this includes `SumFunc.h`,
    which is in the `sum(3, 4)` inside the test. This is how we use our project code
    in tests.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里没有`main()`函数，因为`CanTest.cpp`有一个，它们将被链接在一起。其次，请注意，这包括`SumFunc.h`，它在测试中使用了`sum(3,
    4)`。这是我们在测试中使用项目代码的方式。
- en: 'Make the following change in the `tests/CMakeLists.txt` file to build the test:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tests/CMakeLists.txt`文件中进行以下更改以构建测试：
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that we added both the test (`SumFuncTest.cpp`) and the code that it tests
    (`../src/SumFunc.cpp`) to the executable, as our test code is using the code from
    the actual project.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将测试（`SumFuncTest.cpp`）和它测试的代码（`../src/SumFunc.cpp`）都添加到可执行文件中，因为我们的测试代码正在使用实际项目中的代码。
- en: 'Build the project and run the test as before. You should see the following
    report:![Figure 1.31: Output after running the test'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并像以前一样运行测试。您应该看到以下报告：![图1.31：运行测试后的输出
- en: '](img/C14508_01_31.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_31.jpg)'
- en: 'Figure 1.31: Output after running the test'
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.31：运行测试后的输出
- en: We can add such tests to our project and all of them will appear on the screen
    as shown in the preceeding screenshot.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这样的测试添加到我们的项目中，所有这些测试都将显示在屏幕上，就像前面的截图所示的那样。
- en: 'Now, let''s add one more test that will actually fail. In the `tests/SumFuncTest.cpp`
    file, make the following change:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个实际失败的测试。在`tests/SumFuncTest.cpp`文件中，进行以下更改：
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that this test assumes that the absolute values of the inputs are summed
    up, which is incorrect. The result of this call is `0` but is expected to be `6`
    in this example. This is the only change that we have to make in our project to
    add this test.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此测试假定输入的绝对值被求和，这是不正确的。这次调用的结果是`0`，但在这个例子中预期是`6`。这是我们在项目中必须做的唯一更改，以添加这个测试。
- en: 'Now, build the project and run the test. You should see this report:![Figure
    1.32: The build report'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建项目并运行测试。您应该会看到这个报告：![图1.32：构建报告
- en: '](img/C14508_01_32.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_32.jpg)'
- en: 'Figure 1.32: The build report'
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.32：构建报告
- en: 'As you can see in the preceding figure, the first two tests passed and the
    last test failed. When we see this output, there are two options: either our project
    code is wrong, or the test is wrong. In this case, our test is wrong. This is
    because our `6` is equal to `sum(3, -3)`. This is because we assumed that our
    function sums up the absolute values of the integers provided. However, this is
    not the case. Our function simply adds the given numbers, whether they are positive
    or negative. Therefore, this test had a faulty assumption and failed.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，前两个测试通过了，最后一个测试失败了。当我们看到这个输出时，有两种选择：要么我们的项目代码有问题，要么测试有问题。在这种情况下，我们的测试有问题。这是因为我们的`6`等于`sum(3,
    -3)`。这是因为我们假设我们的函数对提供的整数的绝对值求和。然而，事实并非如此。我们的函数只是简单地添加给定的数字，无论它们是正数还是负数。因此，这个测试有一个错误的假设，所以失败了。
- en: 'Let''s change the test and fix it. Change the test so that we expect the sum
    of `-3` and `3` to be `0`. Rename the test to reflect what this test actually
    does:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们改变测试并修复它。修改测试，使我们期望`-3`和`3`的和为`0`。重命名测试以反映这个测试实际上做了什么：
- en: '[PRE25]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run it now and observe in the report that all the tests pass:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行它，并观察报告中所有测试是否都通过了：
- en: '![Figure 1.33: Test execution is successful'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.33：测试执行成功'
- en: '](img/C14508_01_33.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_33.jpg)'
- en: 'Figure 1.33: Test execution is successful'
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.33：测试执行成功
- en: Finally, we have set up Google Test with CMake both in our system and project.
    We also wrote, built, and ran unit tests with Google Test, both in the terminal
    and in Eclipse. Ideally, you should write unit tests for every class and cover
    every possible usage. You should also run the tests after each major change and
    make sure you do not break existing code. In the next section, we will perform
    an activity of adding a new class and its test.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经在系统和项目中使用CMake设置了Google Test。我们还使用Google Test编写、构建和运行了单元测试，无论是在终端还是在Eclipse中。理想情况下，您应该为每个类编写单元测试，并覆盖每种可能的用法。您还应该在每次重大更改后运行测试，并确保不会破坏现有代码。在下一节中，我们将执行一个添加新类及其测试的活动。
- en: 'Activity 2: Adding a New Class and Its Test'
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动2：添加新类及其测试
- en: 'As you develop a C++ project, you add new source files to it as the project
    grows. You also write tests for them to ensure that they are working properly.
    In this activity, we will add a new class that simulates `1D` linear motion. The
    class will have double fields for `position` and `velocity`. It will also have
    a `advanceTimeBy()` method, which receives a double `dt` parameter, which modifies
    `position` based on the value of `velocity`. Use `EXPECT_DOUBLE_EQ` instead of
    `EXPECT_EQ` for double values. In this activity, we will add a new class and its
    test to the project. Follow these steps to perform this activity:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发C++项目时，随着项目的增长，我们会向其中添加新的源文件。我们还会为它们编写测试，以确保它们正常工作。在这个活动中，我们将添加一个模拟`1D`线性运动的新类。该类将具有`position`和`velocity`的double字段。它还将有一个`advanceTimeBy()`方法，接收一个double
    `dt`参数，根据`velocity`的值修改`position`。对于double值，请使用`EXPECT_DOUBLE_EQ`而不是`EXPECT_EQ`。在这个活动中，我们将向项目中添加一个新类及其测试。按照以下步骤执行此活动：
- en: Open the project that we have created in the Eclipse IDE.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse IDE中打开我们创建的项目。
- en: 'Add the `LinearMotion1D.cpp` and `LinearMotion1D.h` file pair to the project
    that contains the `LinearMotion1D` class. In this class, create two double fields:
    `position` and `velocity`. Also, create an `advanceTimeBy(double dt)` function
    that modifies `position`.'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`LinearMotion1D.cpp`和`LinearMotion1D.h`文件对添加到包含`LinearMotion1D`类的项目中。在这个类中，创建两个double字段：`position`和`velocity`。另外，创建一个`advanceTimeBy(double
    dt)`函数来修改`position`。
- en: Write tests for this in the `tests/LinearMotion1DTest.cpp` file. Write two tests
    that represent motion in two different directions.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tests/LinearMotion1DTest.cpp`文件中为此编写测试。编写两个代表两个不同方向运动的测试。
- en: Build and run it in the Eclipse IDE.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse IDE中构建并运行它。
- en: Verify that the tests have passed.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证测试是否通过。
- en: 'The final test results should look similar to the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的测试结果应该类似于以下内容：
- en: '![Figure 1.34: Final test results'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.34：最终测试结果'
- en: '](img/C14508_01_34.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_34.jpg)'
- en: 'Figure 1.34: Final test results'
  id: totrans-268
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.34：最终测试结果
- en: Note
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 622.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第622页找到。
- en: Adding new classes and their tests is a very common task in C++ development.
    We create classes for various reasons. Sometimes, we have a nice software design
    plan and we create the classes that it calls for. Other times, when a class becomes
    too large and monolithic, we separate some of its responsibility to another class
    in a meaningful way. Having this task be practical is important to prevent dragging
    your feet and ending up with huge monolithic classes. In the following section,
    we discuss what happens during the compilation and linking stages. This will give
    us a better perspective of what is happening under the hood of C++ programs.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++开发中，添加新类及其测试是一项非常常见的任务。我们出于各种原因创建类。有时，我们有一个很好的软件设计计划，我们创建它所需的类。其他时候，当一个类变得过大和单一时，我们以有意义的方式将一些责任分离到另一个类中。使这项任务变得实际是很重要的，以防止拖延和最终得到庞大的单一类。在接下来的部分中，我们将讨论编译和链接阶段发生了什么。这将让我们更好地了解C++程序底层发生了什么。
- en: Understanding Compilation, Linking, and Object File Contents
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解编译、链接和目标文件内容
- en: One of the main reasons for using C++ is efficiency. C++ gives us control over
    memory management, which is why understanding how objects are laid out in memory
    is important. Furthermore, C++ source files and libraries are compiled to object
    files for the target hardware and linked together. Often, C++ programmers have
    to deal with linker problems, which is why understanding the steps of the compilation
    and being able to investigate object files is important. On the other hand, large
    projects are developed and maintained by teams over a long period of time, which
    is why creating clean and understandable code is important. As with any other
    software, bugs arise in C++ projects and need to be identified, analyzed, and
    resolved carefully by observing the program behavior. Therefore, learning how
    to debug C++ code is also important. In the next section, we will learn how to
    create code that is efficient, plays well with other code, and is maintainable.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++的主要原因之一是效率。C++使我们能够控制内存管理，这就是为什么理解对象在内存中的布局很重要的原因。此外，C++源文件和库被编译为目标硬件的对象文件，并进行链接。通常，C++程序员必须处理链接器问题，这就是为什么理解编译步骤并能够调查对象文件很重要的原因。另一方面，大型项目是由团队在长时间内开发和维护的，这就是为什么创建清晰易懂的代码很重要的原因。与任何其他软件一样，C++项目中会出现错误，需要通过观察程序行为来仔细识别、分析和解决。因此，学习如何调试C++代码也很重要。在接下来的部分中，我们将学习如何创建高效、与其他代码协作良好且易于维护的代码。
- en: Compilation and Linking Steps
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译和链接步骤
- en: A C++ project is created as a set of source code files and project configuration
    files that organize the sources and library dependencies. In the compilation step,
    these sources are first converted to object files. In the linking step, these
    object files are linked together to form the executable that is the ultimate output
    of the project. The libraries that the project uses are also linked at this step.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: C++项目是一组源代码文件和项目配置文件，用于组织源文件和库依赖关系。在编译步骤中，这些源文件首先被转换为对象文件。在链接步骤中，这些对象文件被链接在一起，形成项目的最终输出可执行文件。项目使用的库也在这一步中被链接。
- en: In the upcoming exercises, we will use our existing project to observe the compilation
    and linking stages. Then, we will manually recreate them to view the process in
    more detail.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将进行的练习中，我们将使用现有项目来观察编译和链接阶段。然后，我们将手动重新创建它们以更详细地查看这个过程。
- en: 'Exercise 7: Identifying Build Steps'
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习7：识别构建步骤
- en: 'You have been building your projects without investigating the details of the
    build actions. In this exercise, we will investigate the details of our project''s
    build steps. Perform the following to complete the exercise:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您一直在构建项目而没有调查构建操作的详细信息。在这个练习中，我们将调查我们项目的构建步骤的详细信息。执行以下操作完成练习：
- en: Open the terminal.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。
- en: 'Navigate to the `build` folder wherein our `Makefile` file resides by typing
    the following command:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令导航到`build`文件夹，其中我们的`Makefile`文件位于其中：
- en: '[PRE26]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Clean the project and run the build in `VERBOSE` mode using the following command:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令清理项目并以`VERBOSE`模式运行构建：
- en: '[PRE27]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will get a detailed output of the build process in the terminal, which
    may look a bit crowded:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在终端中获得构建过程的详细输出，可能会显得有点拥挤：
- en: '![Figure 1.35: The build process part 1'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.35：构建过程第1部分'
- en: '](img/C14508_01_35.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_35.jpg)'
- en: 'Figure 1.35: The build process part 1'
  id: totrans-287
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.35：构建过程第1部分
- en: '![Figure 1.36: The build process part 2'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.36：构建过程第2部分'
- en: '](img/C14508_01_36.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_36.jpg)'
- en: 'Figure 1.36: The build process part 2'
  id: totrans-290
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.36：构建过程第2部分
- en: '![Figure 1.37: The full build output'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.37：完整的构建输出'
- en: '](img/C14508_01_37.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_37.jpg)'
- en: 'Figure 1.37: The full build output'
  id: totrans-293
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.37：完整的构建输出
- en: 'Here are some of the lines from this output. The following lines are the important
    ones related to the compilation and linkage of the main executable:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此输出中的一些行。以下行是与主可执行文件的编译和链接相关的重要行：
- en: '[PRE28]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `c++` command here is just a symbolic link to the `g++` compiler. To see
    that it''s actually a chain of symbolic links, type the following command:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的`c++`命令只是`g++`编译器的符号链接。要查看它实际上是一系列符号链接，输入以下命令：
- en: '[PRE29]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You will see the following output:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![Figure 1.38: The chain of symbolic links for /usr/bin/c++'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.38：/usr/bin/c++的符号链接链'
- en: '](img/C14508_01_38.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_38.jpg)'
- en: 'Figure 1.38: The chain of symbolic links for /usr/bin/c++'
  id: totrans-301
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.38：/usr/bin/c++的符号链接链
- en: 'Therefore, we will use `c++` and `g++` interchangeably throughout our discussion.
    In the build output that we quoted earlier, the first four lines are compiling
    each `.cpp` source file and creating the corresponding `.o` object file. The last
    line is linking together these object files to create the `CxxTemplate` executable.
    The following figure visually presents this process:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的讨论中，我们将交替使用`c++`和`g++`。在我们之前引用的构建输出中，前四行是编译每个`.cpp`源文件并创建相应的`.o`对象文件。最后一行是将这些对象文件链接在一起以创建`CxxTemplate`可执行文件。以下图形形象地展示了这个过程：
- en: '![Figure 1.39: Execution stages of a C++ project'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.39：C++项目的执行阶段'
- en: '](img/C14508_01_39.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_39.jpg)'
- en: 'Figure 1.39: Execution stages of a C++ project'
  id: totrans-305
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.39：C++项目的执行阶段
- en: As the previous figure shows, the CPP files that are added to CMake as a part
    of a target, along with the header files that they included, are compiled to object
    files, which are later linked together to create the target executable.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图所示，作为目标的一部分添加到CMake中的CPP文件以及它们包含的头文件被编译为对象文件，然后将它们链接在一起以创建目标可执行文件。
- en: 'To understand this process even further, let''s carry out the compilation steps
    ourselves. In the terminal, go to the project folder and create a new folder named
    `mybuild` using the following commands:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步了解这个过程，让我们自己执行编译步骤。在终端中，转到项目文件夹并使用以下命令创建一个名为`mybuild`的新文件夹：
- en: '[PRE30]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, run the following commands to compile the CPP source files to object
    files:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行以下命令将CPP源文件编译为对象文件：
- en: '[PRE31]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Go into the `mybuild` directory and see what''s there using the following command:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`mybuild`目录，并使用以下命令查看其中的内容：
- en: '[PRE32]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We see the following output as expected. These are our object files:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了预期的以下输出。这些是我们的目标文件：
- en: '![Figure 1.40: Compiled object files'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.40：已编译的目标文件'
- en: '](img/C14508_01_40.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_40.jpg)'
- en: 'Figure 1.40: Compiled object files'
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.40：已编译的目标文件
- en: 'In the next step, link the object files together to form our executable. Type
    the following command:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，将目标文件链接在一起形成我们的可执行文件。输入以下命令：
- en: '[PRE33]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s see our executable among the list of files here by typing the following
    command:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过输入以下命令，让我们在文件列表中看到我们的可执行文件：
- en: '[PRE34]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This shows the new `CxxTemplate` file in the following figure:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了以下图中的新`CxxTemplate`文件：
- en: '![Figure 1.41: Linked executable file'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.41：链接可执行文件'
- en: '](img/C14508_01_41.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_41.jpg)'
- en: 'Figure 1.41: Linked executable file'
  id: totrans-324
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.41：链接可执行文件
- en: 'Now, run our executable by typing the following command:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过输入以下命令运行我们的可执行文件：
- en: '[PRE35]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And see the output that we had before:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后看看我们之前的输出：
- en: '![Figure 1.42: Executable file output'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.42：可执行文件输出'
- en: '](img/C14508_01_42.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_42.jpg)'
- en: 'Figure 1.42: Executable file output'
  id: totrans-330
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.42：可执行文件输出
- en: Now that you have examined the details of the build process and have recreated
    them yourself, in the next section, let's explore the linking process.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经检查了构建过程的细节，并自己重新创建了它们，在下一节中，让我们探索链接过程。
- en: The Linking Step
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接步骤
- en: 'In this section, let''s look at a connection between two source files and how
    they end up in the same executable. Look at the **sum** function in the following
    figure:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们看一下两个源文件之间的联系以及它们如何最终出现在同一个可执行文件中。看看以下图中的**sum**函数：
- en: '![Figure 1.43: The linking process'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.43：链接过程'
- en: '](img/C14508_01_43.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_43.jpg)'
- en: 'Figure 1.43: The linking process'
  id: totrans-336
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.43：链接过程
- en: The **sum** function's body is defined in **SumFunc.cpp**. It has a forward
    declaration in **SumFunc.h**. This way, the source files that want to use the
    **sum** function can know about its signature. Once they know its signature, they
    can call it and trust that the actual function definition will be there during
    runtime, without actually having any interaction with **SumFunc.cpp** where the
    function is defined.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**sum**函数的主体在**SumFunc.cpp**中定义。它在**SumFunc.h**中有一个前向声明。这样，想要使用**sum**函数的源文件可以了解其签名。一旦它们知道了它的签名，它们就可以调用它，并相信在运行时将会有实际的函数定义，而实际上并没有与**SumFunc.cpp**交互。'
- en: After compilation, **CxxTemplate.cpp**, which calls the **sum** function, carries
    that call into its object file. Still, it does not know where the function definition
    is. The object file of **SumFunc.cpp** has that definition, but it has nothing
    to do with **CxxTemplate.o**, yet.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，调用**sum**函数的**CxxTemplate.cpp**将该调用传递到其目标文件中。但它不知道函数定义在哪里。**SumFunc.cpp**的目标文件具有该定义，但与**CxxTemplate.o**无关。
- en: During the linking step, the linker matches the call in **CxxTemplate.o** with
    the definition in **SumFunc.o**. The call works fine in the executable as a result.
    Had the linker not found the definition of the **sum** function, it would have
    given a linker error.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接步骤中，链接器将**CxxTemplate.o**中的调用与**SumFunc.o**中的定义进行匹配。结果，可执行文件中的调用正常工作。如果链接器找不到**sum**函数的定义，它将产生链接器错误。
- en: The linker finds the `symbol could not be resolved` error.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器找到了`无法解析符号`错误。
- en: 'This took us through the two stages of the build process: `compilation` and
    `linking`. Notice that we used rather simpler commands compared to that of CMake,
    when we compiled our sources manually. Feel free to type `man g++` to see all
    the options there. Later, we discussed linking and how symbols are resolved. We
    also talked about possible issues with the linking step. In the next section,
    we will learn about object files.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们经历了构建过程的两个阶段：`编译`和`链接`。请注意，与手动编译源文件时相比，我们使用了相当简单的命令。随时输入`man g++`以查看所有选项。稍后，我们将讨论链接以及符号是如何解析的。我们还讨论了链接步骤可能出现的问题。在下一节中，我们将学习有关目标文件的知识。
- en: 'Diving Deeper: Viewing Object Files'
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入挖掘：查看目标文件
- en: For the linking step to work without errors, we need to have all our symbol
    references match our symbol definitions. Most of the time, we can analyze how
    things will be resolved just by looking at the source files. Sometimes, in complex
    situations, we may have a difficult time understanding why a symbol is not being
    resolved. In such situations, looking at the contents of object files to investigate
    references and definitions can be useful to resolve the problem. Besides linker
    errors, understanding object file contents and how linking works in general is
    useful for a C++ programmer. Knowing what is happening under the hood may help
    programmers understand the whole process in a better way.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使链接步骤能够正常工作，我们需要使所有符号引用与符号定义匹配。大多数情况下，我们可以通过查看源文件来分析解决方案将如何解析。有时，在复杂情况下，我们可能难以理解为什么符号未能解析。在这种情况下，查看目标文件的内容以调查引用和定义可能有助于解决问题。除了链接器错误外，了解目标文件的内容以及链接工作的一般原理对于C++程序员来说是有用的。了解底层发生的事情可能有助于程序员更好地理解整个过程。
- en: When our source code is compiled to object files, our statements and expressions
    are converted to assembly code, which is the low-level language that the CPU understands.
    Each instruction in assembly contains an operation, followed by operators, which
    are registers of the CPU. There are instructions to load data to and from registers
    and operate on values in registers. The `objdump` command in Linux helps us view
    the contents of these object files.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的源代码编译为目标文件时，我们的语句和表达式将转换为汇编代码，这是CPU理解的低级语言。汇编中的每条指令都包含一个操作，后跟寄存器，这些寄存器是CPU的寄存器。有指令用于将数据加载到寄存器中并从寄存器中加载数据，并对寄存器中的值进行操作。Linux中的`objdump`命令可帮助我们查看这些目标文件的内容。
- en: Note
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'We will utilize Compiler Explorer, a nice online tool that is easier to use,
    where you can write code on the window to the left, and on the right, you can
    see the compiled assembly code. Here is the link to the Compiler Explorer: [https://godbolt.org](https://godbolt.org).'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用Compiler Explorer，这是一个很好用的在线工具，您可以在左侧窗口上编写代码，在右侧可以看到编译后的汇编代码。这是Compiler
    Explorer的链接：[https://godbolt.org](https://godbolt.org)。
- en: 'Exercise 8: Exploring Compiled Code'
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习8：探索编译代码
- en: 'In this exercise, we will use Compiler Explorer to compile some simple C++
    code in which we define and call a function. We will investigate the compiled
    assembly code to understand how exactly names are resolved and calls are made.
    This will give us a better understanding of what happens under the hood and how
    our code works in the executable format. Perform the following steps to complete
    the exercise:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Compiler Explorer编译一些简单的C++代码，其中我们定义并调用一个函数。我们将调查编译后的汇编代码，以了解名称是如何解析和调用是如何进行的。这将让我们更好地理解发生了什么以及我们的代码在可执行格式中是如何工作的。执行以下步骤完成练习：
- en: 'Add the following code in `call sum(int, int)` line does what you expect: it
    calls the preceding `sum` function and places the arguments in some registers.
    The important point here is that the functions are identified by their names and
    the types of their parameters in order. The linker looks for the appropriate function
    with this signature. Note that the return value is not a part of the signature.'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`call sum(int, int)`行中添加以下代码可以实现您的预期：它调用前面的`sum`函数并将参数放入一些寄存器中。这里的重要一点是，函数是通过它们的名称和参数类型按顺序标识的。链接器会寻找具有这个签名的适当函数。请注意，返回值不是签名的一部分。
- en: Disable the `_Z`, the number tells us how long the function name is, so that
    the following letters are correctly interpreted. After the function name, we have
    `v` for no parameters and `i` for an `int` parameter. You can change these function
    signatures to view other possible types.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用`_Z`，数字告诉我们函数名的长度，以便正确解释后面的字母。在函数名之后，我们有`v`表示没有参数，`i`表示一个`int`参数。您可以更改这些函数签名以查看其他可能的类型。
- en: 'Now, let''s look at how classes are compiled. Add the following code into **Compiler
    Explorer** under the existing code:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看类是如何编译的。将以下代码添加到**Compiler Explorer**的现有代码下：
- en: '[PRE36]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is the compiled version of these added lines:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这些添加行的编译版本：
- en: '![Figure 1.46: The compiled version'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.46：编译版本'
- en: '](img/C14508_01_46.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_46.jpg)'
- en: 'Figure 1.46: The compiled version'
  id: totrans-356
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.46：编译版本
- en: 'You may be surprised that there is no class definition in the compiled code.
    The methods are similar to global functions, but with a twist: their mangled names
    contain the class name and they receive the object instance as a parameter. Creating
    an instance simply allocates space for the fields of the class.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会惊讶地发现编译代码中没有类定义。这些方法类似于全局函数，但有一个变化：它们的混淆名称包含类名，并将对象实例作为参数接收。创建实例只是为类的字段分配空间。
- en: During the linker phase, these mangled function names are used to match callers
    with callees. For callers that cannot find a callee, we get linker errors. Most
    linker errors can be resolved by carefully checking sources. However, in some
    cases, viewing the object file contents with `objdump` can help get to the bottom
    of the problem.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接器阶段，这些混淆的函数名用于将调用者与被调用者匹配。对于找不到被调用者的调用者，我们会得到链接器错误。大多数链接器错误可以通过仔细检查源代码来解决。然而，在某些情况下，使用`objdump`查看目标文件内容可以帮助找到问题的根源。
- en: Debugging C++ Code
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试C++代码
- en: 'There are different levels of problems that you can come across while developing
    a C++ project:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发C++项目时，您可能会遇到不同级别的问题：
- en: First, you may receive compiler errors. These can happen because of a mistake
    you made in syntax, or a wrong choice for a type, and so on. The compiler is the
    first hoop you have to jump through, and it catches some mistakes you may have
    made.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，您可能会收到编译器错误。这可能是因为您在语法上犯了错误，或者选择了错误的类型等。编译器是您必须跨越的第一个障碍，它会捕捉到您可能犯的一些错误。
- en: The second hoop is the linker. There, a typical mistake is to use something
    that is declared, but not actually defined. This happens often when you use the
    wrong header file for a library—the header file advertises a certain signature
    that does not exist in any of the source files or libraries. Once you also jump
    through the linker hoop, your program is ready to execute.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个障碍是链接器。在那里，一个常见的错误是使用声明但实际上未定义的内容。当您使用错误的库头文件时，这种情况经常发生——头文件宣传了某个不存在于任何源文件或库中的签名。一旦您也通过了链接器的障碍，您的程序就准备好执行了。
- en: Now, the next hoop to jump through is to avoid any runtime errors. Your code
    may have compiled and linked properly, but it may be doing things that do not
    work, such as dereferencing a null pointer or dividing by zero.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，下一个要跨越的障碍是避免任何运行时错误。您的代码可能已经编译和链接成功，但可能会出现一些不起作用的情况，比如解引用空指针或除以零。
- en: To find and fix runtime errors, you have to interact with and monitor the running
    application in some way. An often-used technique is to add `print` statements
    to the code and monitor the logs that it generates, hoping to correlate the application
    behavior with the logs to pinpoint the region in code that has the problem. While
    this works for some cases, sometimes you need to take a closer look at the execution.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找和修复运行时错误，您必须以某种方式与正在运行的应用程序进行交互和监视。一个经常使用的技术是向代码中添加`print`语句，并监视它生成的日志，希望将应用程序行为与日志相关联，以确定代码中存在问题的区域。虽然这对某些情况有效，但有时您需要更仔细地查看执行情况。
- en: A debugger is a better tool to fight runtime errors. A debugger can let you
    run code line by line, continue running and pause on the lines that you want,
    investigate the values of memory, and pause on errors, among other things. This
    lets you watch what exactly is going on with memory as your program is running
    and identify the line of code that results in the unwanted behavior.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器是一个更好的工具来解决运行时错误。调试器可以让你逐行运行代码，继续运行并在你想要的行上暂停，调查内存的值，并在错误上暂停，等等。这让你可以在程序运行时观察内存的具体情况，并确定导致不良行为的代码行。
- en: '`gdb` is the canonical command-line debugger that can debug C++ programs. However,
    it may be difficult to use as debugging is inherently a visual task—you want to
    be able to look at lines of code, values of variables, and the output of the program
    at the same time. Luckily, Eclipse CDT includes a visual debugger that is easy
    to use.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`gdb`是一个经典的命令行调试器，可以调试C++程序。然而，它可能难以使用，因为调试本质上是一项视觉任务——你希望能够同时查看代码行、变量值和程序的输出。幸运的是，Eclipse
    CDT包含了一个易于使用的可视化调试器。'
- en: 'Exercise 9: Debugging with Eclipse CDT'
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习9：使用Eclipse CDT进行调试
- en: 'You have been simply running your projects and viewing the output. Now you
    want to learn how to debug your code in detail. In this exercise, we will explore
    Eclipse CDT''s debugging capabilities. Perform the following steps to complete
    the exercise:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前只是简单地运行项目并查看输出。现在你想要学习如何详细调试你的代码。在这个练习中，我们将探索Eclipse CDT的调试能力。按照以下步骤完成练习：
- en: Open the CMake project in Eclipse CDT.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse CDT中打开CMake项目。
- en: To ensure that we have an existing run configuration, click **Run** | **Run
    Configurations**. There, you should see a **CxxTemplate** entry under **C/C++
    Application**.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保我们有一个现有的运行配置，点击**运行** | **运行配置**。在那里，你应该在**C/C++应用程序**下看到一个**CxxTemplate**条目。
- en: Note
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Since we ran our project before, it should be there. If not, please go back
    and create it again.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前运行了项目，它应该在那里。如果没有，请返回并重新创建。
- en: Close the dialog box to continue.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭对话框以继续。
- en: To start the debugger, find the toolbar entry that looks like an insect (bug)
    and click on the dropdown next to it. Select `main()` function, which is shown
    with the green highlight and the arrow in the center code view. On the left, we
    see the running threads, of which there is only one. On the right, we see the
    variables that are accessible in this context. On the bottom, we see the **gdb**
    output that Eclipse uses behind the scenes to actually debug the executable. Now,
    there is not much to be debugged with our main function.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动调试器，找到看起来像昆虫（虫子）的工具栏条目，并点击旁边的下拉菜单。选择`main()`函数，它在代码视图中央显示为绿色高亮和箭头。在左侧，我们看到正在运行的线程，其中只有一个。在右侧，我们看到在这个上下文中可访问的变量。在底部，我们看到Eclipse在后台使用的**gdb**输出来实际调试可执行文件。现在，我们的主函数没有太多需要调试的地方。
- en: Click `libc-start.c` library, which is the caller of the `main` function. You
    can close it and switch to your source files when done. When you do not see the
    red stop button anymore, you know that the program execution is over.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`libc-start.c`库，它是`main`函数的调用者。当完成后，你可以关闭它并切换到你的源文件。当你不再看到红色停止按钮时，你就知道程序执行结束了。
- en: 'Edit our `main` function by adding the following code:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下代码编辑我们的`main`函数：
- en: '[PRE37]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The post-increment operator mixed with the occasional `do-while` loop can be
    a head-scratcher for some. This is because we try to execute the algorithm in
    our heads. However, our debugger is perfectly able to run it step by step and
    show us what exactly happens during execution.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 后增量运算符与偶尔的`do-while`循环对一些人来说可能是一个难题。这是因为我们试图在脑海中执行算法。然而，我们的调试器完全能够逐步运行它，并显示在执行过程中到底发生了什么。
- en: 'Start debugging after adding the preceding code. Click on the dropdown next
    to the **Debug** button in the toolbar and select **CxxTemplate**. Press *F6*
    a couple of times to step over in the code. It will show us how the variables
    change as well as the line of code that will be executed next:![Figure 1.48: Stepping
    over the code'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加了上述代码后开始调试。点击工具栏上**调试**按钮旁边的下拉菜单，选择**CxxTemplate**。按下*F6*几次来逐步执行代码。它会显示变量的变化以及将要执行的代码行：![图1.48：跳过代码
- en: '](img/C14508_01_48.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_48.jpg)'
- en: 'Figure 1.48: Stepping over the code'
  id: totrans-381
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.48：跳过代码
- en: 'Seeing the variables change after the execution of each line of code makes
    the algorithm much clearer to understand. As you press *F6*, note that the following
    are the values after each execution of the `t += i++;` line:![Figure 1.49: Variable
    states through time'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行每行代码后看到变量的变化，可以更清楚地理解算法。按下*F6*，注意在执行`t += i++;`这行代码后的值：![图1.49：变量状态随时间变化
- en: '](img/C14508_01_49.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_49.jpg)'
- en: 'Figure 1.49: Variable states through time'
  id: totrans-384
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.49：变量状态随时间变化
- en: The preceding output clearly explains how the values are changing and why `6`
    is printed at the end.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出清楚地解释了值是如何变化的，以及为什么最后打印出`6`。
- en: 'Explore other features of the debugger. While the variable view is useful,
    you can also hover over any variable and browse its value:![Figure 1.50: View
    option of the debugger'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索调试器的其他功能。虽然变量视图很有用，但你也可以悬停在任何变量上并浏览它的值：![图1.50：调试器的视图选项
- en: '](img/C14508_01_50.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_50.jpg)'
- en: 'Figure 1.50: View option of the debugger'
  id: totrans-388
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.50：调试器的视图选项
- en: Furthermore, the **Expression** view helps you calculate things that are otherwise
    not clear from the values that you browse.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**表达式**视图帮助你计算那些从浏览的值中不清楚的东西。
- en: 'Click on **Expression** on the right-hand side and click on the **Add** button:![Figure
    1.51: Adding an expression'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧点击**表达式**，然后点击**添加**按钮：![图1.51：添加表达式
- en: '](img/C14508_01_51.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_51.jpg)'
- en: 'Figure 1.51: Adding an expression'
  id: totrans-392
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.51：添加表达式
- en: 'Type **t+i** and hit *Enter*. Now you see the total in the list of expressions:![Figure
    1.52: Expression view with a new expression'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**t+i**并按*Enter*。现在你可以在表达式列表中看到总和：![图1.52：带有新表达式的表达式视图
- en: '](img/C14508_01_52.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_52.jpg)'
- en: 'Figure 1.52: Expression view with a new expression'
  id: totrans-395
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.52：带有新表达式的表达式视图
- en: You can press the red square in the toolbar or select **Run** | **Terminate**
    to stop debugging at any time. Another feature is breakpoints, which tell the
    debugger to pause whenever it goes to a line marked with a breakpoint. So far,
    we have been stepping through our code line by line, which may be very time-consuming
    in a large project. Instead, you usually want to continue the execution until
    it arrives at the code that you are interested in.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在工具栏中按下红色方块，或选择**运行** | **终止**随时停止调试。另一个功能是断点，它告诉调试器每当它到达带有断点的行时暂停。到目前为止，我们一直在逐行执行我们的代码，这在一个大型项目中可能非常耗时。相反，通常您希望继续执行，直到到达您感兴趣的代码。
- en: 'Now, instead of going line by line, add a breakpoint in the line that does
    the printing. For this, double-click on the area to the left of the line number
    of this line. In the following figure, the dot represents a breakpoint:![Figure
    1.53: Working with breakpoints'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，不是逐行进行，而是在进行打印的行中添加一个断点。为此，请双击此行行号左侧的区域。在下图中，点表示断点：![图1.53：使用断点
- en: '](img/C14508_01_53.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_53.jpg)'
- en: 'Figure 1.53: Workin with breakpoints'
  id: totrans-399
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.53：使用断点
- en: 'Now start the debugger. As usual, it will start paused. Now select **Run**
    | **Resume** or click on the toolbar button. It will run the three executions
    of the loop and pause at our breakpoint. This way, we saved time by stepping through
    code that we are not investigating:![Figure 1.54: Working with the debugger'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在启动调试器。通常情况下，它将开始暂停。现在选择**运行** | **恢复**或单击工具栏按钮。它将运行循环的三次执行，并在我们的断点处暂停。这样，我们通过跳过我们不调查的代码来节省时间：![图1.54：使用调试器
- en: '](img/C14508_01_54.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_54.jpg)'
- en: 'Figure 1.54: Working with the debugger'
  id: totrans-402
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.54：使用调试器
- en: While we have been dealing with the loop that we added, we ignored the line
    that creates an `app` object. The **Step Over** command was skipping this line.
    However, we also have the option to go into the constructor call that is in this
    line. For that, we will use **Run** | **Step Into** or the corresponding toolbar
    button.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们处理添加的循环时，我们忽略了创建`app`对象的行。**步过**命令跳过了这行。但是，我们也有选择进入这行中的构造函数调用的选项。为此，我们将使用**运行**
    | **步入**或相应的工具栏按钮。
- en: 'Stop the debugger and start it again. Click on **Step Over** to go to the line
    where the application is created:![Figure 1.55: Working with the debugger – the
    Step Over option'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止调试器，然后再次启动。单击**步过**以转到创建应用程序的行：![图1.55：使用调试器 - 步过选项
- en: '](img/C14508_01_55.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_55.jpg)'
- en: 'Figure 1.55: Working with the debugger – the Step Over option'
  id: totrans-406
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.55：使用调试器 - 步过选项
- en: 'The highlighted is the next line that would be executed if we step over again.
    Instead, press the Step Into button. This will take us into the constructor call:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们再次步过，高亮显示的是下一行将执行的行。相反，按下步入按钮。这将带我们进入构造函数调用：
- en: '![Figure 1.56: Working with the debugger – the Step Into option'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.56：使用调试器 - 步入选项'
- en: '](img/C14508_01_56.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14508_01_56.jpg)'
- en: 'Figure 1.56: Working with the debugger – the Step Into option'
  id: totrans-410
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.56：使用调试器 - 步入选项
- en: This is a handy feature for diving deeper into the function instead of simply
    stepping over it. Also, notice the call stack in the left debug view. You can
    always click on the lower entries to go and view the callers' contexts again.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个方便的功能，可以更深入地了解函数，而不仅仅是跳过它。还要注意左侧调试视图中的调用堆栈。您可以随时单击较低的条目以再次查看调用者的上下文。
- en: This was a brief introduction to the Eclipse CDT debugger, which uses GDB under
    the hood to give you a visual debugging experience. You may find debugging useful
    when trying to understand runtime errors better and correcting the mistakes that
    caused them.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Eclipse CDT调试器的简要介绍，它在内部使用GDB为您提供可视化调试体验。在尝试更好地理解运行时错误并纠正导致这些错误的错误时，您可能会发现调试非常有用。
- en: Writing Readable Code
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写可读的代码
- en: While visual debuggers are quite useful to identify and eliminate runtime errors
    or unintended program behavior, it is a better idea to write code that is less
    likely to have problems to begin with. One way to do that is to strive to write
    code that is easier to read and to understand. Then, finding problems in code
    becomes more like identifying contradictions between English sentences and less
    like solving cryptic puzzles. When you are writing code in a way that is understandable,
    your mistakes will often be apparent as you are making them and will be easier
    to spot when you come back to solve problems that slipped through.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可视化调试器非常有用，可以识别和消除运行时错误或意外的程序行为，但更好的做法是编写更不太可能出现问题的代码。其中一种方法是努力编写更易读和理解的代码。然后，在代码中找问题更像是识别英语句子之间的矛盾，而不是解决神秘的谜题。当您以一种易于理解的方式编写代码时，您的错误通常在制造时就会显现出来，并且在您回来解决滑过的问题时更容易发现。
- en: After some unenjoyable maintenance experiences, you realize that the primary
    purpose of the programs that you write is not to make the computer do what you
    want to, but to tell the reader what the computer will do when the program runs.
    This usually means that you need to do more typing, which IDEs can help with.
    This may also mean that you sometimes write code that is not the most optimal
    in terms of execution time or memory used. If this goes against what you have
    learned, consider that you may be trading a minuscule amount of efficiency for
    the risk of being incorrect. With the vast processing power and memory at our
    disposal, you may be making your code unnecessarily cryptic and possibly buggy
    in the vain quest for efficiency. In the next sections, we will list some rules
    of thumb that may help you write code that is more readable.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 经历了一些令人不愉快的维护经验后，你意识到你编写的程序的主要目的不是让计算机按照你的意愿去做，而是告诉读者程序运行时计算机将会做什么。这通常意味着你需要输入更多的内容，而集成开发环境可以帮助你。这也可能意味着你有时会编写在执行时间或内存使用方面不是最优的代码。如果这与你所学的知识相悖，考虑到你可能在以微不足道的效率换取错误的风险。在我们拥有的庞大处理能力和内存的情况下，你可能会使你的代码变得不必要地晦涩，可能会在追求效率的虚无之中产生错误。在接下来的章节中，我们将列出一些经验法则，这些法则可能会帮助你编写更易读的代码。
- en: Indentation and Formatting
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩进和格式化
- en: C++ code, as in many other programming languages, is composed of program blocks.
    A function has a set of statements that form its body as a block. A loop's block
    statements will execute in iterations. An `if` statement's block executes if the
    given condition is true and the corresponding `else` statement's block executes
    otherwise.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: C++代码，就像许多其他编程语言一样，由程序块组成。一个函数有一组语句组成它的主体作为一个块。循环的块语句将在迭代中执行。如果给定条件为真，则`if`语句的块将执行，相应的`else`语句的块将在条件为假时执行。
- en: 'Curly braces, or lack thereof for single-statement blocks, inform the computer,
    whereas indentation in the form of white space informs the human reader about
    the block structure. The lack of indentation, or misleading indentation, can make
    it very difficult for the reader to understand the structure of the code. Therefore,
    we should strive to keep our code well-indented. Consider the following two code
    blocks:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号，或者对于单语句块的缺失，通知计算机，而缩进形式的空白则通知人类读者关于块结构。缺乏缩进或者误导性的缩进会使读者非常难以理解代码的结构。因此，我们应该努力保持我们的代码缩进良好。考虑以下两个代码块：
- en: '[PRE38]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'While they are identical in terms of execution, it is much clearer in the second
    one that `firstFunction()` is executed only if `result` is `2`. Now consider the
    following code:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从执行的角度来看它们是相同的，但在第二个示例中更清楚地表明`firstFunction()`只有在`result`是`2`的情况下才会被执行。现在考虑以下代码：
- en: '[PRE39]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is simply misleading. If the reader is not careful, they might easily assume
    that `secondFunction()` is executed only if `result` is `2`. However, this code
    is identical to the two previous examples in terms of execution.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是误导。如果读者不小心，他们可能会很容易地假设`secondFunction()`只有在`result`是`2`的情况下才会被执行。然而，从执行的角度来看，这段代码与前两个示例是相同的。
- en: If you feel like correcting indentation is slowing you down, you can use your
    editor's formatting facilities to help you. In Eclipse, you can select a block
    of code and use **Source** | **Correct Indentation** to fix the indentation of
    that selection, or use **Source** | **Format** to also fix other formatting issues
    with code.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得纠正缩进在减慢你的速度，你可以使用编辑器的格式化工具来帮助你。在Eclipse中，你可以选择一段代码并使用**源码** | **纠正缩进**来修复该选择的缩进，或者使用**源码**
    | **格式化**来修复代码的其他格式问题。
- en: Beyond indentation, other formatting rules such as placing the curly brace at
    the correct line, inserting spaces around binary operators, and inserting a space
    after each comma are also very important formatting rules that you should abide
    by to keep your code well-formatted and easy to read.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 除了缩进之外，其他格式规则，比如将花括号放在正确的行上，在二元运算符周围插入空格，以及在每个逗号后插入一个空格，也是非常重要的格式规则，你应该遵守这些规则，以保持你的代码格式良好，易于阅读。
- en: In Eclipse, you can set formatting rules per-workspace in **Window** | **Preferences**
    | **C/C++** | **Code Style** | **Formatter** or per-project in **Project** | **Properties**
    | **C/C++ General** | **Formatter**. You can either select one of the industry-standard
    styles such as K&R or GNU, or you can modify them and create your own. This becomes
    especially important when you use **Source** | **Format** to format your code.
    For example, if you choose to use spaces for indentation but Eclipse's formatting
    rules are set to tabs, your code would become a mixture of tabs and spaces.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中，你可以在**窗口** | **首选项** | **C/C++** | **代码样式** | **格式化程序**中为每个工作空间设置格式化规则，或者在**项目**
    | **属性** | **C/C++常规** | **格式化程序**中为每个项目设置格式化规则。你可以选择行业标准样式，比如K&R或GNU，或者修改它们并创建自己的样式。当你使用**源码**
    | **格式化**来格式化你的代码时，这变得尤为重要。例如，如果你选择使用空格进行缩进，但Eclipse的格式化规则设置为制表符，你的代码将成为制表符和空格的混合体。
- en: Use Meaningful Names as Identifiers
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用有意义的标识符名称
- en: In our code, we use identifiers to name many items—variables, functions, class
    names, types, and so on. For the computer, these identifiers are merely a sequence
    of characters to distinguish them from one another. However, for the reader, they're
    much more. The identifier should completely and unambiguously describe the item
    that it represents. At the same time, it should not be overly long. Furthermore,
    it should abide by the style standards that are in use.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们使用标识符来命名许多项目——变量、函数、类名、类型等等。对于计算机来说，这些标识符只是一系列字符，用于区分它们。然而，对于读者来说，它们更重要。标识符应该完全且明确地描述它所代表的项目。同时，它不应该过长。此外，它应该遵守正在使用的样式标准。
- en: 'Consider the following code:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE40]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: While this is a perfectly valid piece of C++ code, it is quite difficult to
    read. Let's list the problems with it. First of all, let's look at the style problems
    of the identifiers. The `studentsFile` class name starts with a lowercase letter,
    which should have been uppercase instead. The `File` variable should have started
    with a lowercase letter. The `Count_Names` variable should have started with a
    lowercase letter and should not have had an underscore in it. The `CheckNextElement`
    method should have started with a lowercase letter. While these may seem arbitrary
    rules, being consistent in naming carries extra information about the name—when
    you see a word that starts with an uppercase letter, you immediately understand
    that it must be a class name. Furthermore, it is simply a distraction to have
    names that do not obey the standard in use.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一段完全有效的C++代码，但它很难阅读。让我们列出它的问题。首先，让我们看看标识符的风格问题。`studentsFile`类名以小写字母开头，而应该是大写字母。`File`变量应该以小写字母开头。`Count_Names`变量应该以小写字母开头，而且不应该有下划线。`CheckNextElement`方法应该以小写字母开头。虽然这些规则可能看起来是武断的，但在命名上保持一致会携带关于名称的额外信息——当你看到一个以大写字母开头的单词时，你立刻明白它必须是一个类名。此外，拥有不遵守使用标准的名称只会分散注意力。
- en: 'Now, let''s look beyond the style and inspect the names themselves. The first
    problematic name is the `runFileCheck` function. A method is an action that returns
    a value: its name should both clearly explain what it does as well as what it
    returns. "Check" is an overused word that is too vague for most situations. Yes,
    we checked it, it''s there—what should we do with it then? In this case, it seems
    we actually read the file and create a `File` object. In that case, `runFileCheck`
    should have been `readFile` instead. This clearly explains the action being taken,
    and the return value is what you would expect. If you wanted to be more specific
    about the return value, `readAsFile` could be another alternative. Similarly,
    the `check` method is vague and should be `exists` instead. The `CheckNextElement`
    method is also vague and should be `nextElementExists` instead.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们超越风格，检查名称本身。第一个有问题的名称是`runFileCheck`函数。方法是返回值的动作：它的名称应该清楚地解释它的作用以及它的返回值。
    “Check”是一个过度使用的词，在大多数情况下都太模糊了。是的，我们检查了，它在那里——那么我们接下来该怎么办呢？在这种情况下，似乎我们实际上读取了文件并创建了一个`File`对象。在这种情况下，`runFileCheck`应该改为`readFile`。这清楚地解释了正在进行的操作，返回值是你所期望的。如果你想对返回值更具体，`readAsFile`可能是另一种选择。同样，`check`方法太模糊了，应该改为`exists`。`CheckNextElement`方法也太模糊了，应该改为`nextElementExists`。
- en: Another overused vague word is `flag`, which is often used for Boolean variables.
    The name suggests an on/off situation but gives no clue as to what its value would
    mean. In this case, its `true` value means that the file exists, and the `false`
    value means that the file does not exist. The trick for naming Boolean variables
    is to devise a question or statement that is correct when the value of the variable
    is `true`. In this example, `fileExists` and `doesFileExist` are two good choices.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个过度使用的模糊词是“flag”，通常用于布尔变量。名称暗示了一个开/关的情况，但并没有提示其值的含义。在这种情况下，它的“true”值表示文件存在，“false”值表示文件不存在。命名布尔变量的技巧是设计一个问题或语句，当变量的值为“true”时是正确的。在这个例子中，“fileExists”和“doesFileExist”是两个不错的选择。
- en: Our next misnamed variable is `Count_Names`, or `countNames` with its correct
    capitalization. This is a bad name for an integer because the name does not suggest
    a number—it suggests an action that results in a number. Instead, an identifier
    such as `numNames` or `nameCount` would clearly communicate what the number inside
    means.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个命名不当的变量是“Count_Names”，或者正确的大写形式“countNames”。这对于整数来说是一个糟糕的名称，因为名称并没有暗示一个数字，而是暗示导致一个数字的动作。相反，诸如“numNames”或“nameCount”这样的标识符会清楚地传达内部数字的含义。
- en: Keeping Algorithms Clear and Simple
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持算法清晰简单
- en: 'When we read code, the steps that are taken and the flow should make sense.
    Things that are done indirectly—byproducts of functions, multiple actions being
    done together in the name of efficiency, and so on—are things that make it difficult
    to understand your code for the reader. For example, let''s look at the following
    code:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们阅读代码时，所采取的步骤和流程应该是有意义的。间接进行的事情——函数的副产品，为了效率而一起执行的多个操作等等——这些都会让读者难以理解你的代码。例如，让我们看看以下代码：
- en: '[PRE41]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we have an array that we are processing in a loop. At first glance, it
    is not very clear what exactly the loop is doing. The variable names are helping
    us understand what is going on, but we must run the algorithm in our heads to
    be sure that what's being advertised by those names is really happening here.
    There are three different operations that are taking place in this loop. Firstly,
    we are finding the sum of all the elements. Secondly, we are finding the minimum
    element in the array. Thirdly, we are taking the absolute value of each element
    after these operations.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个在循环中处理的数组。乍一看，很难确定循环到底在做什么。变量名帮助我们理解正在发生的事情，但我们必须在脑海中运行算法，以确保这些名称所宣传的确实发生在这里。在这个循环中进行了三种不同的操作。首先，我们找到所有元素的总和。其次，我们找到数组中的最小元素。第三，我们在这些操作之后取每个元素的绝对值。
- en: 'Now consider this alternative version:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑这个替代版本：
- en: '[PRE42]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now everything is much clearer. The first loop finds the sum of the inputs,
    the second loop finds the minimum element, and the third loop finds the absolute
    value of each element. Although it's much clearer and more understandable, you
    may feel like you are doing three loops, and therefore wasting CPU resources.
    The drive to create more efficient code may compel you to merge these loops. Note
    that the efficiency gains you have here would be minuscule; your program's time
    complexity would still be O(n).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都清晰多了。第一个循环找到输入的总和，第二个循环找到最小的元素，第三个循环找到每个元素的绝对值。虽然现在更清晰、更易理解，但你可能会觉得自己在做三个循环，因此浪费了CPU资源。创造更高效的代码的动力可能会促使你合并这些循环。请注意，这里的效率提升微乎其微；你的程序的时间复杂度仍然是O(n)。
- en: While creating code, readability and efficiency are two constraints that can
    often be in competition. If you want to develop readable and maintainable code,
    you should always prioritize readability. Then, you should strive to develop code
    that is also efficient. Otherwise, code that has low readability risks being difficult
    to maintain, or worse, risks having bugs that are difficult to identify and fix.
    Your program's high efficiency would be irrelevant when it is producing incorrect
    results or when the cost of adding new features to it becomes too high.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建代码时，可读性和效率是经常竞争的两个约束条件。如果你想开发可读性强、易于维护的代码，你应该始终优先考虑可读性。然后，你应该努力开发同样高效的代码。否则，可读性低的代码可能难以维护，甚至可能存在难以识别和修复的错误。当你的程序产生错误结果或者添加新功能的成本变得太高时，程序的高效性就变得无关紧要了。
- en: 'Exercise 10: Making Code Readable'
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习10：使代码更易读
- en: 'There are style and indentation problems in the following code. Spaces are
    used inconsistently, and the indentation is incorrect. Also, the decision on single-statement
    `if` blocks having curly braces or not is inconsistent. The following piece of
    code has problems in terms of indentation, formatting, naming, and clarity:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码存在样式和缩进问题。空格使用不一致，缩进不正确。此外，关于单语句`if`块是否使用大括号的决定也不一致。以下代码存在缩进、格式、命名和清晰度方面的问题：
- en: '[PRE43]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s fix these problems and make it compatible with a common C++ code style.
    Perform the following steps to complete this exercise:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决这些问题，使其符合常见的C++代码风格。执行以下步骤完成这个练习：
- en: Open Eclipse CDT.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Eclipse CDT。
- en: Create a new `a`, whose length is `Len`. Better names for these would be `input`
    and `inputLength`.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`a`，其长度为`Len`。对这些更好的命名应该是`input`和`inputLength`。
- en: Let's make that first change and rename `a` to `input`. If you are using Eclipse,
    you can select `Len` and rename it to `inputLength`.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先做出这个改变，将`a`重命名为`input`。如果你正在使用Eclipse，你可以选择`Len`并将其重命名为`inputLength`。
- en: 'The updated code will look like the following. Note that we do not need the
    comment anymore since parameter names are self-explanatory:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新后的代码将如下所示。请注意，由于参数名是不言自明的，我们不再需要注释：
- en: '[PRE44]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We have a couple of other variables defined before the loop. Let's try to understand
    them. It seems all it does with `S` is to add each element to it. Therefore, `S`
    must be `sum`. `M`, on the other hand, seems to be the minimum element—let's name
    it `smallest`.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环之前我们定义了一些其他变量。让我们试着理解它们。它似乎只是将每个元素添加到`S`中。因此，`S`必须是`sum`。另一方面，`M`似乎是最小的元素——让我们称它为`smallest`。
- en: '`Lim_value` seems to be a threshold, where we simply want to know whether it
    has been crossed. Let''s rename it `topThreshold`. The `flag` variable is set
    to true if this threshold is crossed. Let''s rename it to `isTopThresholdCrossed`.
    Here is the state of the code after these changes with **Refactor** | **Rename**:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Lim_value`似乎是一个阈值，我们只是想知道它是否被越过。让我们将其重命名为`topThreshold`。如果越过了这个阈值，`flag`变量被设置为true。让我们将其重命名为`isTopThresholdCrossed`。在这些更改后，代码的状态如下所示：**重构**
    | **重命名**：'
- en: '[PRE45]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s see how we can make this code simpler and easier to understand.
    The preceding code is doing these things: calculating the sum of the input elements,
    finding the smallest one, determining whether the top threshold was crossed, and
    multiplying each element by two.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使这段代码更简单、更易理解。前面的代码正在做这些事情：计算输入元素的总和，找到最小的元素，确定是否越过了顶部阈值，并将每个元素乘以2。
- en: 'Since all of these are done in the same loop, the algorithm is not very clear
    now. Fix that and have four separate loops:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于所有这些都是在同一个循环中完成的，现在算法不太清晰。修复这个问题，将其分为四个独立的循环：
- en: '[PRE46]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now the code is much clearer. While it's very easy to understand what each block
    is doing, we also added comments to make it even more clear. In this section,
    we gained a better understanding of how our code is converted to executables.
    Then, we discussed ways of identifying and resolving possible errors with our
    code. We finalized this with a discussion about how to write readable code that
    is less likely to have problems. In the next section, we will solve an activity
    wherein we will be making code more readable.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码清晰多了。虽然很容易理解每个块在做什么，但我们还添加了注释以使其更清晰。在这一部分，我们更好地理解了我们的代码是如何转换为可执行文件的。然后，我们讨论了识别和解决可能的代码错误的方法。我们最后讨论了如何编写可读性更强、更不容易出现问题的代码。在下一部分，我们将解决一个活动，我们将使代码更易读。
- en: 'Activity 3: Making Code More Readable'
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动3：使代码更易读
- en: 'You may have code that is unreadable and contains bugs, either because you
    wrote it in a hurry, or you received it from someone else. You want to change
    the code to eliminate its bugs and to make it more readable. We have a piece of
    code that needs to be improved. Improve it step by step and resolve the issues
    using a debugger. Perform the following steps to implement this activity:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有一些难以阅读并且包含错误的代码，要么是因为你匆忙写成的，要么是因为你从别人那里收到的。你想改变代码以消除其中的错误并使其更易读。我们有一段需要改进的代码。逐步改进它并使用调试器解决问题。执行以下步骤来实施这个活动：
- en: Below you will find the source for `SpeedCalculator` class. Add these two files
    to your project.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是`SpeedCalculator`类的源代码。将这两个文件添加到你的项目中。
- en: Create an instance of this class in your `main()` function and call its `run()`
    method.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`main()`函数中创建这个类的一个实例，并调用它的`run()`方法。
- en: Fix the style and naming problems in the code.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复代码中的风格和命名问题。
- en: Simplify the code to make it more understandable.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化代码以使其更易理解。
- en: Run the code and observe the problem at runtime.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察运行时的问题。
- en: Use the debugger to fix the problem.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用调试器来解决问题。
- en: 'Here''s the code for **SpeedCalculator.cpp** and **SpeedCalculator.h** that
    you will add to your project. You will modify them as a part of this activity:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**SpeedCalculator.cpp**和**SpeedCalculator.h**的代码，你将把它们添加到你的项目中。你将修改它们作为这个活动的一部分：
- en: '[PRE47]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-468
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 626.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第626页找到。
- en: Summary
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to create C++ projects that are portable and
    maintainable. We first learned how to create CMake projects and how to import
    them to Eclipse CDT, giving us the choice to use the command line or an IDE. The
    rest of the chapter focused on eliminating various problems in our projects. First,
    we learned how to add unit tests to a project and how to use them to ensure that
    our code works as intended. We continued this with a discussion about the compilation
    and linking steps that our code goes through and observed the contents of object
    files to gain a better understanding of executable files. Then, we learned how
    to debug our code visually in the IDE to eliminate runtime errors. We finished
    this discussion with a number of rules of thumb that help create readable, understandable,
    and maintainable code. These methods will come in handy on your C++ journey. In
    the next chapter, we will learn more about C++'s type system and templates.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建可移植和可维护的C++项目。我们首先学习了如何创建CMake项目以及如何将它们导入到Eclipse CDT，从而使我们可以选择使用命令行或者IDE。本章的其余部分侧重于消除项目中的各种问题。首先，我们学习了如何向项目添加单元测试，以及如何使用它们来确保我们的代码按预期工作。然后，我们讨论了代码经历的编译和链接步骤，并观察了目标文件的内容，以更好地理解可执行文件。接着，我们学习了如何在IDE中以可视化方式调试我们的代码，以消除运行时错误。我们用一些经验法则结束了这个讨论，这些法则有助于创建可读、易懂和可维护的代码。这些方法将在你的C++之旅中派上用场。在下一章中，我们将更多地了解C++的类型系统和模板。
