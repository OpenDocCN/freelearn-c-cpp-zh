- en: Getting Started with System Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始系统编程
- en: In this chapter, you will be introduced to the foundations on which the entire
    book is framed. You will learn (or refresh your knowledge of) how Linux is designed,
    and you will also learn about the shell, users and groups, process IDs, and thread
    IDs to be able to use a Linux system proficiently and get prepared for the next
    chapters. Furthermore, you will also learn how to develop a simple `hello world` program,
    and find out about its makefile, and also how to execute and debug it. Another
    important aspect of this chapter is to learn how Linux deals with errors, from
    both a shell and a source code point of view. This foundational knowledge is important
    to understand other advanced topics in the following chapters. You can safely
    skip this and the next chapters if this refresher is not needed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将被介绍整本书的基础知识。你将学习（或者复习）Linux的设计，还将学习关于shell、用户和用户组、进程ID和线程ID，以便能够熟练地使用Linux系统，并为接下来的章节做好准备。此外，你还将学习如何开发一个简单的“hello
    world”程序，了解它的makefile，以及如何执行和调试它。本章的另一个重要方面是学习Linux如何处理错误，无论是从shell还是源代码的角度。这些基础知识对于理解接下来章节中的其他高级主题非常重要。如果不需要这个复习，你可以安全地跳过本章和下一章。
- en: 'This chapter will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Learning the Linux fundamentals – architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Linux基础知识- 架构
- en: Learning the Linux fundamentals – shell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Linux基础知识- shell
- en: Learning the Linux fundamentals – users
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Linux基础知识- 用户
- en: Using a makefile to compile and link a program
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用makefile来编译和链接程序
- en: Using the **GNU Project Debugger **(**GDB**) to debug a program
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GNU Project Debugger（GDB）调试程序
- en: Learning the Linux fundamentals – processes and threads
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Linux基础知识- 进程和线程
- en: Handling a Linux bash error
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理Linux bash错误
- en: Handling Linux code error
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理Linux代码错误
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to let you try the programs immediately, we've set up a Docker image that
    has all the tools and libraries we'll need throughout the book. This is based
    on Ubuntu 19.04.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你立即尝试这些程序，我们设置了一个Docker镜像，其中包含了整本书中需要的所有工具和库。这是基于Ubuntu 19.04的。
- en: 'In order to set this up, follow these steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置这个，按照以下步骤进行：
- en: Download and install the Docker Engine from [www.docker.com](https://www.docker.com/).
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[www.docker.com](https://www.docker.com/)下载并安装Docker Engine。
- en: Pull the image from Docker Hub: `docker pull kasperondocker/system_programming_cookbook:latest`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Docker Hub拉取镜像：`docker pull kasperondocker/system_programming_cookbook:latest`。
- en: The image should now be available. Type in the following command to view the
    image: `docker images`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 镜像现在应该是可用的。输入以下命令查看镜像：`docker images`。
- en: 'You should have at least this image now: `kasperondocker/system_programming_cookbook`.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该至少有这个镜像：`kasperondocker/system_programming_cookbook`。
- en: Run the Docker image with an interactive shell, with the help of the following
    command: `docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在Docker镜像上运行交互式shell：`docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest
    /bin/bash`。
- en: The shell on the running container is now available. Run `root@39a5a8934370/#
    cd /BOOK/` to get all the programs developed, by chapters.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正在运行的容器上的shell现在可用。运行`root@39a5a8934370/# cd /BOOK/`来获取所有按章节开发的程序。
- en: The `--cap-add sys_ptrace` argument is needed to allow GDB in the Docker container
    to set breakpoints, which, by default, Docker does not allow.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 需要`--cap-add sys_ptrace`参数来允许Docker容器中的GDB设置断点，默认情况下Docker不允许这样做。
- en: Learning the Linux fundamentals - architecture
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Linux基础知识- 架构
- en: '**Linux** is a clone of the Unix operating system, developed by Linus Torvalds in
    the early ''90s. It is a multiuser, multitasking operating system that runs on
    a wide variety of platforms. The Linux kernel has a monolithic architecture for
    performance reasons. This means that it is self-contained in one binary, and all
    its **services** run in kernel space. This was one of the most controversial topics
    at the beginning. Andy Tanenbaum (professor at the Vrije Universiteit, Amsterdam)
    argued against its monolithic system, saying: *This is a giant step back into
    the 1970s.* He also argued against its portability, saying: *LINUX is tied fairly
    closely to the 80 x 86\. Not the way to go*. In the *minix* user group, there
    still is the thread of full chat involving Torvalds, Tanenbaum, and others.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Linux是Unix操作系统的一个克隆，由Linus Torvalds在90年代初开发。它是一个多用户、多任务操作系统，可以运行在各种平台上。Linux内核采用了单体结构的架构，出于性能原因。这意味着它是一个自包含的二进制文件，所有的服务都在内核空间运行。这在开始时是最具争议的话题之一。阿姆斯特丹自由大学的教授安迪·塔能鲍姆反对其单体系统，他说：“这是对70年代的巨大倒退。”他还反对其可移植性，说：“LINUX与80
    x 86紧密联系在一起。不是正确的方向。”在minix用户组中，仍然有涉及Torvalds、Tanenbaum和其他人的完整聊天记录。
- en: 'The following diagram shows the main Linux building blocks:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了主要的Linux构建模块：
- en: '![](img/9a7b4405-e9e4-431b-b068-0883d1189150.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a7b4405-e9e4-431b-b068-0883d1189150.png)'
- en: 'Let''s describe the layers we see in the diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下图表中看到的层次：
- en: On the top layer, there are user applications, processes, compilers, and tools.
    This layer (which runs in a user space) communicates with the Linux kernel (which
    runs in kernel space) through system calls.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶层，有用户应用程序、进程、编译器和工具。这一层（在用户空间运行）通过系统调用与Linux内核（在内核空间运行）进行通信。
- en: '**System libraries**: These are a set of functions through which an application
    can interact with the kernel.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统库：这是一组函数，通过它应用程序可以与内核进行交互。
- en: '**Kernel**: This component contains the core of the Linux system. Among other
    things, it has the scheduler, networking, memory management, and filesystems.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核：这个组件包含Linux系统的核心。除其他功能外，它还有调度程序、网络、内存管理和文件系统。
- en: '**Kernel modules**: These contain pieces of kernel code that still run in kernel
    space but are fully dynamic (in the sense that they can be loaded and unloaded
    with the running system). They typically contain device drivers, kernel code that
    is specific to a particular hardware module implementing a protocol, and so on.
    One huge advantage of the kernel modules is that users can load them without rebuilding
    the kernel.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核模块**：这些包含仍在内核空间中运行的内核代码片段，但是完全动态（可以在运行系统中加载和卸载）。它们通常包含设备驱动程序、特定于实现协议的特定硬件模块的内核代码等。内核模块的一个巨大优势是用户可以在不重新构建内核的情况下加载它们。'
- en: '**GNU** is a recursive acronym that stands for **GNU is Not Unix**. GNU is
    an operating system that is free software. Note the term *operating system* here.
    Indeed, GNU used alone is meant to represent a full set of tools, software, and
    kernel parts that an operating system needs. The GNU operating system kernel is
    called the** Hurd**. As the Hurdwas not production-ready, GNU typically uses the
    Linux kernel, and this combination is called the **GNU/Linux operating system**.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**GNU**是一个递归缩写，代表**GNU不是Unix**。GNU是一个自由软件的操作系统。请注意这里的术语*操作系统*。事实上，单独使用的GNU意味着代表操作系统所需的一整套工具、软件和内核部分。GNU操作系统内核称为**Hurd**。由于Hurd尚未达到生产就绪状态，GNU通常使用Linux内核，这种组合被称为**GNU/Linux操作系统**。'
- en: 'So, what are the GNU components on a GNU/Linux operating system? Packages* such
    as the **GNU Compiler Collection** (**GCC**), the **GNU C library**, GDB, the
    GNU Bash shell, and the **GNU Network Object Model Environment** (**GNOME**) desktop
    environment, to mention just a few. Richard Stallman and the **Free Software Foundation**
    (**FSF**)—of which Stallman is the founder—authored the **free software definition** to
    help respect users'' freedom. *Free software* is considered any package that grants
    users the following four types of freedoms (so-called **essential freedoms**: [https://isocpp.org/std/the-standard](https://isocpp.org/std/the-standard)):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在GNU/Linux操作系统上的GNU组件是什么？例如**GNU编译器集合**（**GCC**）、**GNU C库**、GDB、GNU Bash
    shell和**GNU网络对象模型环境**（**GNOME**）桌面环境等软件包。Richard Stallman和**自由软件基金会**（**FSF**）——Stallman是创始人——撰写了**自由软件定义**，以帮助尊重用户的自由。*自由软件*被认为是授予用户以下四种自由（所谓的**基本自由**：[https://isocpp.org/std/the-standard](https://isocpp.org/std/the-standard)）的任何软件包：
- en: The freedom to run the program as you wish, for any purpose (Freedom *0*).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自由按照您的意愿运行程序，无论任何目的（自由*0*）。
- en: The freedom to study how the program works and to change it, so it does your
    computing as you wish (Freedom *1*). Access to the source code is a precondition
    for this.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自由研究程序如何工作并对其进行更改，以便按照您的意愿进行计算（自由*1*）。访问源代码是这一自由的前提条件。
- en: The freedom to redistribute copies so that you can help others (Freedom *2*).
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自由重新分发副本，以便您可以帮助他人（自由*2*）。
- en: The freedom to distribute copies of your modified versions to others (Freedom
    *3*). By doing this, you can give the whole community a chance to benefit from
    your changes. Access to the source code is a precondition for this.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自由向他人分发您修改版本的副本（自由*3*）。通过这样做，您可以让整个社区有机会从您的更改中受益。访问源代码是这一自由的前提条件。
- en: The concrete instantiation of these principles is in the GNU/GPL license, which
    FSF authored. All of the GNU packages are released under the GNU/GPL license.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则的具体实现在FSF撰写的GNU/GPL许可证中。所有GNU软件包都是根据GNU/GPL许可证发布的。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Linux has a pretty standard folder structure across the distributions, so knowing
    this would allow you to easily find programs and install them in the correct place.
    Let''s have a look at it as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Linux在各种发行版中有一个相当标准的文件夹结构，因此了解这一点将使您能够轻松地找到程序并将其安装在正确的位置。让我们来看一下：
- en: Open a Terminal on the Docker image.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Docker镜像上打开终端。
- en: Type the command `ls -l /`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入命令`ls -l /`。
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The output of the command will contain the following folders:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出将包含以下文件夹：
- en: '![](img/4a845486-dd7f-40b4-a271-fc851692fe1e.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a845486-dd7f-40b4-a271-fc851692fe1e.png)'
- en: As you can see this folder structure is pretty organized and consistent across
    all the distributions. Under the hood, the Linux filesystem is quite modular and
    flexible. A user application can interact with the GNU C library(which provides
    interfaces such as open, read, write, and close) or the Linux system call directly.
    The system call interface, in this case, talks to the **Virtual** **Filesystem**
    *(*often referred to as the **VFS***)*. The VFS is the abstraction on top of the
    concrete filesystem implementations (for example, ext3, **Journaled File System**
    (**JFS**), and more). This architecture, as we can imagine, gives a high level
    of flexibility.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个文件夹结构非常有组织且在所有发行版中保持一致。在Linux文件系统底层，它相当模块化和灵活。用户应用程序可以与GNU C库（提供诸如open、read、write和close等接口）或Linux系统调用直接交互。在这种情况下，系统调用接口与**虚拟文件系统**（通常称为**VFS**）交谈。VFS是对具体文件系统实现（例如ext3、**日志文件系统**（**JFS**）等）的抽象。正如我们可以想象的那样，这种架构提供了高度的灵活性。
- en: Learning the Linux fundamentals - shell
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Linux基础知识-Shell
- en: A shell is a command interpreter that receives commands in an input, redirects
    them to GNU/Linux, and returns back the output. It is the most common interface
    between a user and GNU/Linux. There are different shell programs available. The
    most used ones are Bash shell (part of the GNU Project), tcsh shell, ksh shell,
    and zsh shell (this is basically an extended Bash shell).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Shell是一个命令解释器，它接收输入中的命令，将其重定向到GNU/Linux，并返回输出。这是用户和GNU/Linux之间最常见的接口。有不同的shell程序可用。最常用的是Bash
    shell（GNU项目的一部分）、tcsh shell、ksh shell和zsh shell（这基本上是一个扩展的Bash shell）。
- en: Why would you need a shell? A user needs a shell if they need to interact with
    the operating system through the **command line**. In this recipe, we'll show
    some of the most common shell commands. Quite often, the terms *shell* and *Terminal*
    are used interchangeably, even though, strictly speaking, they are not exactly
    the same thing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要shell？如果用户需要通过**命令行**与操作系统进行交互，则需要shell。在本食谱中，我们将展示一些最常见的shell命令。通常情况下，*shell*和*终端*这两个术语可以互换使用，尽管严格来说它们并不完全相同。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'In this section, we will learn the basic commands to run on the shell—for example,
    to find a file, `grep` a text into a file, copy, and delete:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习在shell上运行的基本命令，例如查找文件、在文件中查找`grep`、复制和删除：
- en: Opening a shell: Depending on the GNU/Linux distribution, opening a new shell
    command has different shortcuts. On Ubuntu, press *Ctrl *+ *Alt* + *T*, or press
    *Alt *+ *F2,* then type `gnome-terminal`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开shell：根据GNU/Linux发行版的不同，打开新shell命令有不同的快捷键。在Ubuntu上，按*Ctrl* + *Alt* + *T*，或按*Alt*
    + *F2*，然后输入`gnome-terminal`。
- en: 'Closing a shell: To close Terminal, just type `exit` and press *Enter*.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭shell：要关闭终端，只需键入`exit`并按*Enter*。
- en: 'The `find` command: This is used to search files in a directory hierarchy.
    In its simplest form, it appears like this:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`find`命令：用于在目录层次结构中搜索文件。在其最简单的形式中，它看起来像这样：'
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It supports wildcards, too:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它也支持通配符：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `grep` command prints the lines by matching a pattern:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`grep`命令通过匹配模式打印行：'
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`grep` also supports recursive search:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`还支持递归搜索：'
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Pipe commands: Commands running on the shell can be concatenated, to make the
    output of one command the input for another. The concatenation is done with the
    `|` (pipe) operator:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道命令：在shell上运行的命令可以连接起来，使一个命令的输出成为另一个命令的输入。连接是使用`|`（管道）运算符完成的：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Editing a file: The most two common tools to edit a file on Linux are `vi`
    and `emacs` (if you''re not interested in editing the file, `cat filename` will
    print the file to the standard output). While the first is inherited by the Unix
    operating system, the latter is part of the GNU Project. This book will extensively
    use `vi`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑文件：在Linux上编辑文件的最常用工具是`vi`和`emacs`（如果您对编辑文件不感兴趣，`cat filename`将文件打印到标准输出）。前者是Unix操作系统的一部分，后者是GNU项目的一部分。本书将广泛使用`vi`：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we will look at shell commands related to file manipulation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下与文件操作相关的shell命令。
- en: 'This is the command to remove files:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是删除文件的命令：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the command to remove directories:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是删除目录的命令：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is the command to clone a file:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是克隆文件的命令：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the command to clone a folder:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是克隆文件夹的命令：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the command to clone a folder using a relative and absolute path:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是使用相对路径和绝对路径克隆文件夹的命令：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The next section will describe these commands.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将描述这些命令。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Let''s have a look at the commands discussed in the *How to do it...* section,
    in detail:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解*如何做……*部分中讨论的命令：
- en: The first command searches (`.`) from the current folder and can contain absolute
    paths (for example, `/usr/local`) or relative paths (for example, `tmp/binaries`). For
    example, here, `-name` is the file to search.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个命令从当前文件夹搜索（`.`），可以包含绝对路径（例如`/usr/local`）或相对路径（例如`tmp/binaries`）。例如，在这里，`-name`是要搜索的文件。
- en: The second command searches from the `/usr/local` folder any file or folder
    that starts with `python`. The `find` command offers huge flexibility and a wide
    variety of options. For more information, refer to `man page` through the `man
    find` command.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个命令从`/usr/local`文件夹搜索以`python`开头的任何文件或文件夹。`find`命令提供了巨大的灵活性和各种选项。有关更多信息，请通过`man
    find`命令参考`man page`。
- en: The `grep` command searches and prints any line that contains the word `text` in
    the `filename` file.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`grep`命令搜索并打印包含`filename`文件中的`text`单词的任何行。'
- en: The `grep` recursive search command searches and prints any line that contains
    the word `text` in any file recursively from the `/usr/share` folder.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`grep`递归搜索命令搜索并打印任何包含`text`单词的行，从`/usr/share`文件夹递归搜索任何文件。'
- en: 'Pipe command (`|`): The output of the first command is shown in the following
    screenshot. A list of all the files and directories is passed as input to the
    second command (`grep`), which will be used to `grep` the filename:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道命令（`|`）：第一个命令的输出显示在以下截图中。所有文件和目录的列表作为输入传递给第二个命令（`grep`），将用于`grep`文件名：
- en: '![](img/11e480e2-e934-4db1-8d69-fe05a480546d.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11e480e2-e934-4db1-8d69-fe05a480546d.png)'
- en: Now, let's look at the commands that perform actions such as editing a file,
    and adding/removing files and directories.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下执行编辑文件、添加/删除文件和目录等操作的命令。
- en: '**Editing a file**:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑文件：
- en: The `vi` command will open the filename in edit mode, assuming the current user
    has writing permissions on it (we will discuss permissions in more detail later).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vi`命令将以编辑模式打开文件名，假设当前用户对其具有写入权限（我们将稍后更详细地讨论权限）。'
- en: 'The following is a short summary of the most used commands in `vi`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`vi`中最常用命令的简要总结：
- en: '*Shift **+ :* (that is, the *Shift* key + colon) to switch in edit mode.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shift + :*（即*Shift*键+冒号）切换到编辑模式。'
- en: '*Shift + :i* to insert.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shift + :i*插入。'
- en: '*Shift + :a* to append.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shift + :a*追加。'
- en: '*Shift + :q!* to quit the current session without saving.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shift + :q!*退出当前会话而不保存。'
- en: '*Shift + :wq* to save and quit the current session.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shift + :wq*保存并退出当前会话。'
- en: '*Shift + :set nu* to show the line numbers on the file.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shift + :set nu*显示文件的行号。'
- en: '*Shift + :23* (*Enter*) goes at line 23.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shift + :23*（*Enter*）转到第23行。'
- en: Press the (*Esc*)key to switch to command mode.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下（*Esc*）键切换到命令模式。
- en: '*.* to repeat the last command.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.*重复上一个命令。'
- en: '*cw* to change the word, or do this by pointing the cursor at the beginning
    of the word.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*cw*更改单词，或者通过将光标指向单词的开头来执行此操作。'
- en: '*dd to *remove the current line.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*dd*删除当前行。'
- en: '*yy* to copy the current line. If a number *N* is selected before the *yy*
    command, the *N* line will be copied.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*yy*复制当前行。如果在*yy*命令之前选择了数字*N*，则将复制*N*行。'
- en: '*p* to paste the copied line with the *yy *command.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p*粘贴使用*yy*命令复制的行。'
- en: '*u* to undo.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*u*取消。'
- en: '**Adding and removing files and directories**:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加和删除文件和目录**：'
- en: The first command removes the file named `filename`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个命令删除名为`filename`的文件。
- en: The second command removes `directoryName` and its content, recursively.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个命令递归地删除`directoryName`及其内容。
- en: The third command creates `file2`, which is an exact copy of `file1`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个命令创建了`file2`，它是`file1`的精确副本。
- en: 'The fourth command creates `folder2` as a clone of `folder1`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四个命令创建`folder2`作为`folder1`的克隆：
- en: '![](img/1d86e0fb-6dda-477a-b460-51fc4ae8f88a.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d86e0fb-6dda-477a-b460-51fc4ae8f88a.png)'
- en: 'There is a common pattern in the execution of the commands shown in this recipe.
    They are listed as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中所示的命令执行中存在一个常见模式。它们列举如下：
- en: The user types a command and hits *Enter*.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户输入命令并按*Enter*。
- en: The command is interpreted by Linux.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该命令由Linux解释。
- en: Linux interacts with its different parts (memory management, networking, filesystem,
    and more) to execute the command. This happens in kernel space**.**
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux与其不同的部分（内存管理、网络、文件系统等）进行交互以执行命令。这发生在内核空间**。**
- en: The results are returned to the user.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果返回给用户。
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe showed some of the most recurrent commands. Mastering all the options,
    even just for the most common shell commands, is tricky, and that is why `man
    pages` were created. They contain a solid and clear reference for the Linux user.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程展示了一些最常见的命令。掌握所有选项，即使只是对于最常见的shell命令，也是棘手的，这就是为什么创建了`man pages`。它们为Linux用户提供了坚实清晰的参考。
- en: See also
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 8](9fd0a0ac-d520-4227-866a-24583b98c69d.xhtml), *Dealing with Console
    I/O and Files*, will go deeper into console I/O and file management.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](9fd0a0ac-d520-4227-866a-24583b98c69d.xhtml)，*处理控制台I/O和文件*，将更深入地介绍控制台I/O和文件管理。'
- en: Learning the Linux fundamentals - users
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Linux基础知识-用户
- en: Linux is a multiuser and multitasking operating system, so basic user administration
    skills are a must. This recipe will show you how permissions for files and directories
    are structured, how to add and remove a user, how to change a user's password,
    and how to assign a user to a group.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Linux是一个多用户和多任务操作系统，因此基本的用户管理技能是必不可少的。本教程将向您展示文件和目录权限的结构，如何添加和删除用户，如何更改用户的密码以及如何将用户分配给组。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following series of steps shows useful commands for basic user administration
    activities:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一系列步骤显示了基本用户管理活动的有用命令：
- en: '**Creating a user**: Having one user configured for each individual using Linux
    is not just a best practice, it is also recommended. Creating a user is quite
    simple:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建用户**：为每个使用Linux的个人配置一个用户不仅是最佳实践，而且也是推荐的。创建用户非常简单：'
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `spacex` user has been created and assigned to the existing `developers`
    group. To switch to the newly created user, log in using the new user''s credentials:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`spacex`用户已创建并分配给现有的`developers`组。要切换到新创建的用户，请使用新用户的凭据登录：'
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Updating a user''s password**: Periodically, the password must be changed.
    Here is the command to do this:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新用户密码**：定期更改密码是必要的。以下是执行此操作的命令：'
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Assigning a user to a group**: As shown, a user can be assigned to a group
    when created. Alternatively, a user can be assigned to a group at any time, by
    running the following command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将用户分配给组**：如图所示，可以在创建用户时将用户分配给组。或者，可以随时通过运行以下命令将用户分配给组：'
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Removing a user**: Likewise, removing a user is pretty simple:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**删除用户**：同样，删除用户非常简单：'
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `-r` option indicates to remove the `spacex` home directory and `mail spool`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: -r选项表示删除spacex主目录和邮件邮箱。
- en: 'Now, let''s have a look at the final command, which shows a list of the groups
    to which the current user (`spacex`) belongs:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看最后一个命令，它显示当前用户（`spacex`）所属的组的列表：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the `spacex` user belongs to the `developers` and `testers`
    groups.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`spacex`用户属于`developers`和`testers`组。
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 1*, we used the `adduser` command to add the `spacex` user and, contextually,
    added the user to the `developers` group.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们使用`adduser`命令添加了`spacex`用户，并在上下文中将用户添加到`developers`组。
- en: S*tep 2* shows how to change the password of the current user. To change the
    password, the previous password must be provided. It is a good practice to change
    the password periodically.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*显示了如何更改当前用户的密码。要更改密码，必须提供先前的密码。定期更改密码是一个好习惯。'
- en: If we want to assign a user to a group, it can be done with the `usermod` command.
    In *step 3*, we have added the `spacex` user to the `testers` group. The `-a` and `-G` parameters
    just indicate that the new groups (`-G`) will be appended to the current groups (`-a`) of
    the user. That is, the `spacex` user will be assigned to the `testers` group,
    which will be contextually created. The `groups` command, in the same step, shows
    which groups the current user belongs to. If you only want to create a group,
    then `groupadd group-name` is the command you need.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将用户分配给组，可以使用`usermod`命令。在*步骤3*中，我们已将`spacex`用户添加到`testers`组。`-a`和`-G`参数只是指示新组（`-G`）将被附加到用户的当前组（`-a`）上。也就是说，`spacex`用户将被分配到`testers`组，该组将在上下文中创建。在同一步骤中，`groups`命令显示当前用户属于哪些组。如果您只想创建一个组，那么`groupadd
    group-name`就是您需要的命令。
- en: '*Step 4* shows how to remove a user with the `userdel` command, passing the
    `-r` parameter. This parameter ensures that all the files of the user we''re removing
    will be deleted.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤4*显示了如何使用`userdel`命令删除用户，传递`-r`参数。此参数确保将删除要删除的用户的所有文件。'
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'On a Linux filesystem, each file and directory has a set of information defining
    who can do what. The mechanism is simple, as well as powerful. The operations
    allowed on a file (or directory) are read, write, and execute (`r`, `w`, and `x`,
    respectively). These operations can be done by the owner of the file or directory,
    by a group of users, or by all users. Linux represents this information with Owner: `rwx`;
    Group: `rwx`; All Users: `rwx`; or, more simply: `rwx-rwx-rwx` (9 in total). Actually,
    Linux has one more flag on top of these ones that represents the type of file.
    It can be a folder (`d`), a symbolic link to another file (`l`), a regular file
    (`-`), a named pipe (`p`), a socket (`s`), a character device file (`c`), and
    a block device (`b`). Typical permissions for a file look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '在Linux文件系统中，每个文件和目录都有一组信息，定义了谁可以做什么。这个机制既简单又强大。文件（或目录）上允许的操作有读取、写入和执行（`r`、`w`和`x`）。这些操作可以由文件或目录的所有者、一组用户或所有用户执行。Linux用Owner:
    `rwx`；Group: `rwx`；All Users: `rwx`来表示这些信息；或者更简单地表示为`rwx-rwx-rwx`（总共9个）。实际上，Linux在这些标志之上还有一个表示文件类型的标志。它可以是一个文件夹（`d`）、一个符号链接到另一个文件（`l`）、一个常规文件（`-`）、一个命名管道（`p`）、一个套接字（`s`）、一个字符设备文件（`c`）和一个块设备（`b`）。文件的典型权限看起来像这样：'
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s see this in detail:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看一下：
- en: Reading from the left-hand side, the first character, `-`, informs us that `conf.json` is
    a regular file.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从左边开始阅读，第一个字符`-`告诉我们`conf.json`是一个常规文件。
- en: The next three characters are about the current user, `rwx`. The user has full **read** (**r**), **write** (**w**),
    and **execution** (**x**) permissions over the file.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的三个字符是关于当前用户的，`rwx`。用户对文件有完全的**读取**（**r**）、**写入**（**w**）和**执行**（**x**）权限。
- en: The next three chars are about the group to which the user belongs, `r-x`. All
    the users belonging to the group can read and execute the file, but cannot modify
    it (`w` is not selected, marked as `-`).
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的三个字符是关于用户所属的组，`r-x`。所有属于该组的用户都可以读取和执行文件，但不能修改它（`w`未被选择，标记为`-`）。
- en: The last three characters are about all the other users, `r-x`. All other users
    can just read and execute the file (`r` and `x` are marked, but `w` is not).
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的三个字符是关于所有其他用户，`r-x`。所有其他用户只能读取和执行文件（`r`和`x`被标记，但`w`没有）。
- en: 'The owner (or the root user) can change the permissions of the file. The easiest
    way to achieve this is through the `chmod` command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所有者（或root用户）可以更改文件的权限。实现这一点的最简单方法是通过`chmod`命令：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we''re asking the Linux kernel to add the write permission (`w`) to the
    group user type (`g`). The types of users are as follows: `u` (for user), `o`
    (for others), `a` (for all), and `g` (for group), and the permissions flag can
    be `x`, `w`, and `r`, as explained previously. `chmod` can also accept an integer:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求Linux内核向组用户类型（`g`）添加写权限（`w`）。用户类型有：`u`（用户）、`o`（其他人）、`a`（所有人）和`g`（组），权限标志可以是`x`、`w`和`r`，如前所述。`chmod`也可以接受一个整数：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There is a binary-to-decimal conversion on permission flags for each group
    type, for example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种组类型的权限标志，有一个二进制到十进制的转换，例如：
- en: '`wxr`: 111 = 7'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`wxr`：111 = 7'
- en: '`w-r`: 101 = 5'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`w-r`：101 = 5'
- en: '`--r`: 001 = 1'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`--r`：001 = 1'
- en: It could be a little cryptic at the beginning, but it is very practical and
    handy for everyday use.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始可能有点神秘，但对于日常使用来说非常实用和方便。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The `man pages` are an infinite resource of information and should be the first
    thing you look at. Commands such as `man groups`, `man userdel`, or `man adduser` will
    help with this.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`man`页面是一个无限的信息资源，应该是你查看的第一件事。像`man groups`、`man userdel`或`man adduser`这样的命令会对此有所帮助。'
- en: Using a makefile to compile and link a program
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`makefile`来编译和链接程序
- en: A makefile is a file that describes the relationship among the sources of a
    program used by the `make` utility to build (compile and link) the target goal
    (executable, shared object, and more). Makefiles are really important as they
    help to keep sources organized and easy to maintain. A program, to become executable,
    must be compiled and linked with other libraries. GCC is the most widely used
    collection of compilers. The two compilers used in the C and C++ world are GCC
    and g++ (for the C and C++ programs, respectively). This book will use g++.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`makefile`是描述程序源文件之间关系的文件，由`make`实用程序用于构建（编译和链接）目标目标（可执行文件、共享对象等）。`makefile`非常重要，因为它有助于保持源文件的组织和易于维护。要使程序可执行，必须将其编译并链接到其他库中。GCC是最广泛使用的编译器集合。C和C++世界中使用的两个编译器是GCC和g++（分别用于C和C++程序）。本书将使用g++。'
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This section will show how a makefile is written, to compile and run a simple
    C++ program. We''ll develop a simple program, and create its makefile to learn
    its rules:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分将展示如何编写一个`makefile`，来编译和运行一个简单的C++程序。我们将开发一个简单的程序，并创建它的`makefile`来学习它的规则：
- en: 'Let''s start by developing the program by opening the `hello.cpp` file:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从打开`hello.cpp`文件开始开发程序：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Type in the following code (refer to the *Learning the Linux fundamentals -
    shell* recipe to review the `vi` commands):'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码（参考*学习Linux基础知识- shell*中的`vi`命令）：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Save and exit: in `vi`, from the command mode, type `:wq`, which means write
    and quit. The `:x` command has the same effect.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并退出：在`vi`中，从命令模式下，输入`:wq`，表示写入并退出。`:x`命令具有相同的效果。
- en: 'From the shell, create a new file called `Makefile`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从shell中，创建一个名为`Makefile`的新文件：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Type in the following code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Although this is a typical `Hello World!`program, it is useful to show how a makefile
    is structured.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个典型的“Hello World!”程序，但它很有用，可以展示一个`makefile`的结构。
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Simply, a makefile consists of a set of rules. A rule consists of a target,
    a list of prerequisites, and a command.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，`makefile`由一组规则组成。规则由一个目标、一组先决条件和一个命令组成。
- en: 'In the first step, we opened the file (`hello.cpp`) and typed the program listed
    in *step 2*. Likewise, we opened another file, `Makefile`, in the same folder
    of the `hello.cpp` program, and typed the specific makefile commands. Let''s now
    dive into the makefile internals. A typical makefile has the following content:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们打开了文件（`hello.cpp`）并输入了*步骤2*中列出的程序。同样，我们打开了另一个文件`Makefile`，在`hello.cpp`程序的相同文件夹中，并输入了特定的makefile命令。现在让我们深入了解makefile的内部。典型的makefile具有以下内容：
- en: The first rule consists of a target called `all`, and a prerequisite called
    `hello`. There is no command for this rule.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个规则包括一个名为`all`的目标和一个名为`hello`的先决条件。这个规则没有命令。
- en: 'The second rule consists of a target called `hello`. It has a prerequisite
    on `hello.o` and a command to link: `g++`.'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个规则包括一个名为`hello`的目标。它有一个对`hello.o`的先决条件和一个链接命令：`g++`。
- en: 'The third rule has a target called `hello.o`, a prerequisite on `hello.cpp`,
    and a command to compile: `g++ -c hello.cpp`.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个规则有一个名为`hello.o`的目标，一个对`hello.cpp`的先决条件和一个编译命令：`g++ -c hello.cpp`。
- en: The last rule has a `clean` target with a command to remove all the `hello` and `hello.o` executables.
    This forces the recompilation of the files.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个规则有一个`clean`目标，带有一个命令来删除所有`hello`和`hello.o`可执行文件。这会强制重新编译文件。
- en: For any rule, if any of the source files change, then the command defined is
    executed.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于任何规则，如果任何源文件发生更改，则执行定义的命令。
- en: 'We''re now able to compile the program using the makefile we created:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们创建的makefile来编译程序：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''re also able to execute the program, whose output is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以执行程序，其输出如下：
- en: '![](img/2ffd955d-5371-4d04-a52b-13cf17e6eeaf.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ffd955d-5371-4d04-a52b-13cf17e6eeaf.png)'
- en: 'The process of generating a binary executable from a source file includes the
    phase of compilation and linking, which here is compressed inside a single command;
    it''ll be like this in most cases. In general, a large system code base relies
    on more sophisticated mechanisms but the steps are still the same: source file
    editing, compilation, and linking.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从源文件生成二进制可执行文件的过程包括编译和链接阶段，这里压缩在一个单独的命令中；在大多数情况下都是这样。一般来说，大型系统代码库依赖于更复杂的机制，但步骤仍然是相同的：源文件编辑、编译和链接。
- en: There's more...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This simple example just showed us the very basic concepts of a makefile and
    its `make` command. There is much more to it than that. Here are a few examples:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子只是向我们展示了makefile及其`make`命令的基本概念。它比这更多。以下是一些例子：
- en: 'Use of macros: A makefile allows the use of macros, which can be seen as **variables**.
    These can be used to organize the makefile to be more modular, for example:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 宏的使用：makefile允许使用宏，它们可以被视为**变量**。这些可以用于组织makefile以使其更加模块化，例如：
- en: A macro for all the dynamic libraries used in the program: `LIBS = -lxyz -labc`.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序中使用的所有动态库的宏：`LIBS = -lxyz -labc`。
- en: A macro for the compiler itself (in case you want to change to another compiler): `COMPILER
    = GCC`.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器本身的宏（如果要更改为其他编译器）：`COMPILER = GCC`。
- en: 'Reference these macros over all the makefile: `$(CC)`. This gives us the freedom
    to make changes in just one place.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个makefile中引用这些宏：`$(CC)`。这使我们可以在一个地方进行更改。
- en: By just typing `make` on a shell, the first rule defined in the makefile will
    run. In our case, the first rule is `all`. If we changed the makefile by putting
    **`clean` **as a first rule, running `make` without parameters would execute the
    `clean` rule. In general, you'll always pass some parameters—for example, `make
    clean`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需在shell上输入`make`，就会运行makefile中定义的第一个规则。在我们的情况下，第一个规则是`all`。如果我们通过将**`clean`**作为第一个规则来更改makefile，运行不带参数的`make`将执行`clean`规则。通常，您总是会传递一些参数，例如`make
    clean`。
- en: Using GDB to debug a program
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GDB调试程序
- en: Debugging is the process of identifying and removing errors from software systems.
    The GNU/Linux operating system has a **standard** *de facto* tool (that is, not
    part of any standard, but used by almost anybody in the Linux world) called GDB. The
    GDB version installed on this book's Docker is version 8.2.91\. Of course, there
    are graphical tools that can use GDB under the hood, but GDB on Linux is the way
    to go for its reliability, simplicity, and speed. In this recipe, we will debug
    the software we've written in the previous recipe.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是从软件系统中识别和消除错误的过程。GNU/Linux操作系统有一个**标准** *事实上*的工具（即不是任何标准的一部分，但几乎在Linux世界中被任何人使用）称为GDB。安装在本书的Docker上的GDB版本是8.2.91。当然，有一些可以在GDB下使用的图形工具，但在Linux上，GDB是可靠、简单和快速的选择。在这个示例中，我们将调试我们在上一个示例中编写的软件。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to use some of the GDB commands, we need to modify the previous program
    and add some variables in it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用一些GDB命令，我们需要修改之前的程序并在其中添加一些变量：
- en: 'Open a shell and modify the `hello.cpp` file by typing in the following code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个shell，并通过输入以下代码修改`hello.cpp`文件：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is a very simple program: take a variable, add `2` to it, and print the
    result.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的程序：取一个变量，加上`2`，然后打印结果。
- en: 'Let''s make sure that the program is compiled by typing the following command:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令，确保程序已编译：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have the executable, we will debug it. From the command line, type `gdb
    hello`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了可执行文件，我们将对其进行调试。从命令行输入`gdb hello`：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see, the last line says (`No debugging symbols found in hello`).
    GDB doesn''t have to debug symbols to debug the program, so we have to communicate
    to the compiler that the debug symbols are to be included during the compilation.
    We have to quit the current session; to do this, type `q` (*Enter*]. Then, edit
    the makefile, and add the `-g` option to the `g++` compiler section (the `hello.o`
    target):'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，最后一行说（`hello`中未找到调试符号）。GDB不需要调试符号来调试程序，因此我们必须告诉编译器在编译过程中包含调试符号。我们必须退出当前会话；要做到这一点，输入`q`（*Enter*）。然后，编辑makefile，并在`g++`编译器部分的`hello.o`目标中添加`-g`选项：
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s run it again, but, first, we have to rebuild the application with the
    `make` command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次运行它，但首先，我们必须用`make`命令重新构建应用程序：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We're ready to debug it. A debug session typically includes setting breakpoints,
    watching the content of variables, setting watchpoints, and many others. The next
    section will show the most common debug commands.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好调试了。调试会话通常包括设置断点，观察变量的内容，设置监视点等。下一节将展示最常见的调试命令。
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous section, we have seen the steps necessary to create a program
    and a makefile. In this section, we'll learn how to debug the `Hello World!` program
    we developed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们已经看到了创建程序和 makefile 所需的步骤。在本节中，我们将学习如何调试我们开发的`Hello World!`程序。
- en: 'Let''s start by visualizing the code we''re going to debug. We do this by running
    the `l` command (short for list):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从可视化我们要调试的代码开始。我们通过运行`l`命令（缩写）来做到这一点：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We have to set a breakpoint. To set a breakpoint, we run the `b 5` command.
    This sets a breakpoint to the code line number `5` in the current module:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须设置一个断点。要设置断点，我们运行`b 5`命令。这将在当前模块的代码行号`5`处设置一个断点：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It''s time to run the program now. To run a program, we type the `r` command.
    This runs the `hello` program we started with GDB:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是运行程序的时候了。要运行程序，我们输入`r`命令。这将运行我们用 GDB 启动的`hello`程序：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once started, GDB will automatically stop at any breakpoint hit by the process
    flow. In this case, the process runs, and then stops at line `5` of the `hello.cpp` file:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，GDB 将自动停在进程流程命中的任何断点处。在这种情况下，进程运行，然后停在`hello.cpp`文件的第`5`行：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To proceed step by step, we run the `n` command (that is, step over) on GDB.
    This executes the current visualized line of code. A similar command is `s` (step
    into). If the current command is a function, it steps into the function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了逐步进行，我们在 GDB 上运行`n`命令（即，跳过）。这会执行当前可视化的代码行。类似的命令是`s`（跳入）。如果当前命令是一个函数，它会跳入函数：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we need to know the content of a variable, we run the `p` command (short
    for print), which prints the content of a variable. In this case, as expected, `x
    = 12` gets printed:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要知道变量的内容，我们运行`p`命令（缩写），它会打印变量的内容。在这种情况下，预期地，`x = 12`被打印出来：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s run the program until the end (or until the next breakpoint, if
    set). This is done with the `c` command (short for continue):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行程序直到结束（或者直到下一个断点，如果设置了）。这是用`c`命令（继续的缩写）完成的：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: GDB really acts as an interpreter by letting the programmer step the program line
    by line. This helps the developer to troubleshoot problems, see the content of
    variables at runtime, change the status of variables, and more.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 实际上充当解释器，让程序员逐行步进程序。这有助于开发人员解决问题，查看运行时变量的内容，更改变量的状态等。
- en: There's more...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'GDB has a lot of very useful commands. In the following chapters, GDB will
    be explored more. There are four more commands to show here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 有很多非常有用的命令。在接下来的章节中，将更多地探索 GDB。这里有四个更多的命令要展示：
- en: '`s`: Short for step. If called on a method, it steps into it.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`s`：跳入的缩写。如果在一个方法上调用，它会跳入其中。'
- en: '`bt`: Short for backtrace. Prints the call stack.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bt`：回溯的缩写。打印调用堆栈。'
- en: '`q`: Short for quit. Use to exit GDB.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`q`：退出的缩写。用于退出 GDB。'
- en: '`d`: Short for delete. It removes a breakpoint. For example, `d 1` removes
    the first breakpoint set.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`d`：删除的缩写。它删除一个断点。例如，`d 1`删除第一个设置的断点。'
- en: 'The main page of the GNU GDB Project can be found here: [https://www.gnu.org/software/gdb](https://www.gnu.org/software/gdb). More
    detailed information can be found on the `man dbg` `man pages` and online. You
    can also refer to *Using GDB: A Guide to the GNU Source-Level Debugger,* by Richard
    M. Stallman and Roland H. Pesch*.*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'GNU GDB 项目的主页可以在这里找到：[https://www.gnu.org/software/gdb](https://www.gnu.org/software/gdb)。更详细的信息可以在`man
    dbg`的`man pages`和在线上找到。您也可以参考*Using GDB: A Guide to the GNU Source-Level Debugger,*
    by Richard M. Stallman and Roland H. Pesch*.*'
- en: Learning the Linux fundamentals - processes and threads
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 Linux 基础知识 - 进程和线程
- en: Processes and threads are the execution units of any operating system. In this
    recipe, you'll learn how to deal with processes and threads on GNU/Linux on the
    command line. A process is a running instance of a program with a well-defined
    set of resources such as files, processor state, and threads of execution allocated
    to it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 进程和线程是任何操作系统的执行单元。在这个教程中，您将学习如何在 GNU/Linux 命令行上处理进程和线程。
- en: A process in Linux is defined by the `task_struct` structure defined in the
    `sched.h` header file. On the other hand, a thread is defined by the `thread_info`
    structure in the `thread_info.h` header file. A thread is one possible flow of
    execution of the main process. A process has at least one thread (the main thread).
    All the threads of a process run concurrently on a system.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，进程由`sched.h`头文件中定义的`task_struct`结构定义。另一方面，线程由`thread_info.h`头文件中的`thread_info`结构定义。线程是主进程的一个可能的执行流。一个进程至少有一个线程（主线程）。进程的所有线程在系统上并发运行。
- en: One aspect to keep in mind on Linux is that it doesn't differentiate between
    processes and threads. A thread is just like a process that shares some resources
    with some other processes. For this reason, in Linux, threads are often referred
    to as a **lightweight process** (**LWP**).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上需要记住的一点是，它不区分进程和线程。线程就像一个与其他一些进程共享一些资源的进程。因此，在 Linux 中，线程经常被称为**轻量级进程**（**LWP**）。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll learn, step by step, all the most common commands to
    control processes and threads on a GNU/Linux distribution:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐步学习在 GNU/Linux 发行版上控制进程和线程的所有最常见命令：
- en: 'The `ps` command shows the processes, attributes, and other parameters in the
    current system:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ps`命令显示当前系统中的进程、属性和其他参数。'
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another way to get info on a process (and its threads) is to look in the `/process/PID`
    folder. This folder contains all the process info, threads of the process (in
    the form of subfolders with **process identifiers** (**PIDs**)), memory, and much
    more:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取有关进程（及其线程）的信息的另一种方法是查看`/process/PID`文件夹。该文件夹包含所有进程信息，进程的线程（以**进程标识符**（PID）的形式的子文件夹），内存等等：
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A process can be killed, too. Technically, killing a process means stopping
    its execution:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程也可以被终止。从技术上讲，终止一个进程意味着停止它的执行：
- en: '[PRE39]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This command sends the `kill` signal (`9`) to the process identified with the
    PID. Other signals can be sent to processes—for example, `HUP` (hangup) and `INT`
    (interrupt).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令向具有PID的进程发送`kill`信号（`9`）。其他信号也可以发送给进程，例如`HUP`（挂起）和`INT`（中断）。
- en: How it works...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In *s**tep 1* for each process, we can see the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，对于每个进程，我们可以看到以下内容：
- en: The user to whom the process belongs
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程所属的用户
- en: The PID
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PID
- en: The percentage of CPU and memory in a specific moment
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定时刻的CPU和内存百分比
- en: When the process started, and its running time
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当进程启动和运行时间
- en: The command used to run the process
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于运行进程的命令
- en: Through the `ps aux` command, we can grab the PID of the `hello` process, which
    is `172`. We can now look into the `/proc/172` folder.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ps aux`命令，我们可以获取`hello`进程的PID，即`172`。现在我们可以查看`/proc/172`文件夹。
- en: Processes and threads are building blocks of an operating system. In this recipe,
    we've seen how to interact with the kernel on the command line to get info on
    processes through a command (for example, `ps`), and by looking into a specific
    folder that Linux updates as the process runs. Again, every time we invoke a command
    (to get info on a process, in this case), the command must enter in kernel space
    to get valid and updated info on it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 进程和线程是操作系统的构建模块。在本教程中，我们已经看到如何通过命令行与内核交互，以获取有关进程的信息（例如`ps`），并通过查看Linux在进程运行时更新的特定文件夹来获取信息。同样，每次我们调用命令（在这种情况下是为了获取有关进程的信息），命令必须进入内核空间以获取有效和更新的信息。
- en: There's more...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `ps` command has many more parameters than the basic one seen in this recipe.
    A complete list is available on its Linux man page, `man ps`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`命令有比本教程中所见更多的参数。完整列表可在其Linux man页面`man ps`上找到。'
- en: A more advanced and interactive command to consider as an alternative to `ps` is
    the `top` command, `man top`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`ps`的替代方案，一个更高级和交互式的命令是`top`命令，`man top`。
- en: Handling a Linux bash error
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理Linux bash错误
- en: We've seen that one way to interact with the Linux kernel is through the shell,
    by invoking commands. A command can fail, as we can imagine, and a way to communicate
    a failure is to return a non-negative integer value. 0, in most cases, means success.
    This recipe will show you how to deal with error handling on the shell.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，通过shell是与Linux内核交互的一种方式，通过调用命令。命令可能会失败，正如我们可以想象的那样，而传达失败的一种方式是返回一个非负整数值。在大多数情况下，0表示成功。本教程将向您展示如何处理shell上的错误处理。
- en: How to do it...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This section will show you how to get errors directly from the shell and via
    a script, which is a fundamental aspect of script development:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示如何直接从shell和通过脚本获取错误，这是脚本开发的一个基本方面：
- en: 'First, run the following command:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，运行以下命令：
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a new file called `first_script.sh` and type in the following code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`first_script.sh`的新文件，并输入以下代码：
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Save the file, and exit (`:wq` or `:x`).
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并退出（`:wq`或`:x`）。
- en: 'Give execution permission (the `x` flag) to the current user for the `first_script.sh`
    file:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`first_script.sh`文件为当前用户授予执行权限（`x`标志）：
- en: '[PRE42]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These steps are detailed in the next section.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在下一节中详细介绍。
- en: How it works...
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1*, the `cp` command failed, as `file` and `file2` don't exist. By
    querying `echo $?`, we get the error code; in this case, it is `1`. This is particularly
    useful when writing bash scripts where we might need to check for a particular
    condition.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，`cp`命令失败了，因为`file`和`file2`不存在。通过查询`echo $?`，我们得到了错误代码；在这种情况下，它是`1`。这在编写bash脚本时特别有用，因为我们可能需要检查特定条件。
- en: In *step 2*, the script just lists the `does_not_exist.txt` file and reads the
    error code returned. If all goes fine, it prints an acknowledgment message and
    returns `0`. Otherwise, it returns the error code `11`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，脚本只是列出了`does_not_exist.txt`文件，并读取返回的错误代码。如果一切顺利，它会打印一个确认消息并返回`0`。否则，它会返回错误代码`11`。
- en: 'By running the script, we get the output as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行脚本，我们得到以下输出：
- en: '![](img/5d809462-bb33-4827-9f73-a2cbe6881bbc.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d809462-bb33-4827-9f73-a2cbe6881bbc.png)'
- en: 'Here, we notice a couple of things:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们注意到了一些事情：
- en: We logged our error string.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们记录了我们的错误字符串。
- en: The error code is the one we had set in the script.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误代码是我们在脚本中设置的。
- en: Under the hood, every time a command is invoked, it enters into kernel space.
    The command is executed, and a return status is sent back to the user in the form
    of an integer. It's really important to consider this return status, as we might
    have a command that apparently succeeded (no output) but eventually failed (returns
    code different from `0`).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，每次调用命令时，它都会进入内核空间。命令被执行，并以整数的形式将返回状态发送回用户。考虑这个返回状态非常重要，因为我们可能有一个命令，表面上成功了（没有输出），但最终失败了（返回的代码与`0`不同）。
- en: There's more...
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One important aspect of the return status of the commands is that it can be
    used to (conditionally) run the next command. Two important operators are used
    for this purpose: `&&` (AND) and `||` (OR).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的返回状态的一个重要方面是它可以用于（有条件地）运行下一个命令。为此目的使用了两个重要的运算符：`&&`（AND）和`||`（OR）。
- en: 'In the two commands here, the second is run if—and only if—the first succeeds
    (the `&&` operator). `file.txt` is removed if it is copied to the project folder:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个命令中，第二个命令只有在第一个成功时才会运行（`&&`运算符）。如果`file.txt`被复制到项目文件夹中，它将被删除：
- en: '[PRE43]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s have a look at a second example:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个第二个例子：
- en: '[PRE44]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding example, the second command is run only if the first fails
    (the `||` operator). `copy failed!` is printed if the copy fails.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，第二个命令仅在第一个失败时运行（`||`运算符）。如果复制失败，则打印`copy failed!`。
- en: In this recipe, we just showed that commands can be combined on a shell script
    to create a more complex command, and by controlling the error code, we can control
    the flow of execution. Man pages are a great resource as they contain all the
    commands and error codes (for example, `man cp` and `man cat`).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们只是展示了如何在shell脚本中组合命令以创建更复杂的命令，并通过控制错误代码，我们可以控制执行流程。man页面是一个很好的资源，因为它包含了所有的命令和错误代码（例如，`man
    cp`和`man cat`）。
- en: Handling Linux code error
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理Linux代码错误
- en: 'This recipe represents the second side of the coin in the topic of error handling:
    error handling at a source-code level. Linux *exposes* its kernel features through
    commands, as well as through a programming API. In this recipe, we''ll see how
    to deal with error codes and `errno` through a C program, to open a file.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代表了错误处理主题中的另一面：源代码级别的错误处理。Linux通过命令以及编程API公开其内核特性。在这个示例中，我们将看到如何通过C程序处理错误代码和`errno`，以打开一个文件。
- en: How to do it...
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll see how to get the error from a system call in a C
    program. To do this, we''ll create a program to open a non-existent file and show
    the details of the error returned by Linux:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何在C程序中从系统调用中获取错误。为此，我们将创建一个程序来打开一个不存在的文件，并显示Linux返回的错误的详细信息：
- en: Create a new file: `open_file.c`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件：`open_file.c`。
- en: 'Edit the following code in the newly created file:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑新创建的文件中的以下代码：
- en: '[PRE45]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Save the file and exit (`:x`).
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并退出（`:x`）。
- en: Compile the code: `gcc open_file.c`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码：`gcc open_file.c`。
- en: The preceding compilation (without parameters) will produce a binary file called `a.out`
    (which is the default name on the Linux and Unix operating systems).
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的编译（不带参数）将产生一个名为`a.out`的二进制文件（这是Linux和Unix操作系统上的默认名称）。
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The program listed tries to open a file in reading mode. Errors are printed
    on standard error, through the `fprintf` command. By running it, the output will
    be as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的程序尝试以读取模式打开文件。错误将通过`fprintf`命令打印在标准错误上。运行后，输出如下：
- en: '![](img/ec4464be-3ce9-4b95-b6fe-e888f82b52dd.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec4464be-3ce9-4b95-b6fe-e888f82b52dd.png)'
- en: 'There are a couple of considerations to highlight. The program is developed
    by strictly following the man page of the open system call (`man 2 open`):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些要点需要强调。该程序是通过严格遵循open系统调用的man页面（`man 2 open`）开发的：
- en: '[PRE46]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The developer (us, in this case) checked that the file descriptor was `-1` (confirmed
    by `fprintf`) to print `errno` too (with code `2`). What does `errno 2` mean? `strerror` is
    useful exactly for this scope, to translate from `errno` (which is cryptic) to
    something the programmer (or the user) would understand.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员（在这种情况下是我们）检查了文件描述符是否为`-1`（通过`fprintf`确认），以打印`errno`（代码为`2`）。`errno 2`是什么意思？`strerror`对于这个目的非常有用，它可以将`errno`（这是晦涩的）翻译成程序员（或用户）能理解的内容。
- en: There's more...
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In [Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml), *Revisiting C++*,
    we'll see how C++ helps programmers by providing higher-level mechanisms, and
    easy-to-write and more concise code. Even if we try to minimize the interaction
    with the kernel API directly, in favor of the use of the C++11-14-17 higher-level
    mechanism, there will be cases where we'll need to check the error status. In
    those cases, you are invited to pay attention to error management.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml)中，*重新审视C++*，我们将看到C++如何通过提供更高级的机制、易于编写和更简洁的代码来帮助程序员。即使我们试图最小化直接与内核API的交互，而更倾向于使用C++11-14-17更高级的机制，也会有需要检查错误状态的情况。在这些情况下，您被邀请注意错误管理。
