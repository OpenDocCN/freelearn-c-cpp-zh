- en: '*Chapter 2*: The CMake Language'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第*2章*：CMake语言
- en: Writing in the **CMake** **Language** is a bit tricky. When you read a CMake
    listfile for the first time, you may be under the impression that the language
    in it is so simple that it doesn't require any special training or preparation.
    What follows is very often a practical attempt to introduce changes and experiment
    with the code without a thorough understanding of how it works. We programmers
    are usually very busy and are overly keen to tackle any build-related issues with
    little investment. We tend to make gut-based changes hoping they just might do
    the trick. This approach to solving technical problems is called *voodoo programming*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在**CMake** **语言**中写作有点棘手。当你第一次阅读CMake列表文件时，你可能会觉得其中的语言如此简单，以至于不需要任何特殊培训或准备。接下来的内容经常是尝试引入变化和实验代码的实际尝试，而没有彻底理解它是如何工作的。我们程序员通常非常忙碌，并且过于热衷于用最小的投入解决任何与构建相关的问题。我们倾向于基于直觉进行更改，希望它们可能管用。解决技术问题的这种方法称为*巫术编程*。
- en: 'The CMake Language appears simple: after we have completed our small addition,
    fix, or hack, or added a one-liner, we realize that something isn''t working.
    The time spent on debugging is often longer than that spent on actually studying
    the subject. Luckily, this won''t be our fate – because this chapter covers the
    vast majority of the critical knowledge needed to use the CMake Language in practice.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: CMake语言看起来很简单：在我们完成小的添加、修复或黑客攻击，或者添加了一行代码之后，我们意识到有些事情不对劲。调试时间通常比实际研究主题的时间还要长。幸运的是，这不会是我们的命运——因为本章涵盖了实践中使用CMake语言所需的大部分关键知识。
- en: In this chapter, we'll not only learn about the building blocks of the CMake
    Language – **comments**, **commands**, **variables**, and **control structures**
    – but we'll also give the necessary background and try them out in a clean and
    modern CMake example. CMake puts you in a bit of a unique position. On one hand,
    you perform a role of a build engineer; you need to understand all the intricacies
    of the compilers, the platforms, and everything else in-between. On the other
    hand, you're a developer; you're writing code that generates a buildsystem. Writing
    good code is hard and requires thinking on many levels at the same time – it should
    work and be easy to read, but it should also be easy to analyze, extend, and maintain.
    This is exactly what we're going to talk about here.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不仅将学习CMake语言的构建块——**注释**、**命令**、**变量**和**控制结构**，还将提供必要的背景知识，并在一个干净现代的CMake示例中尝试它们。CMake让你处于一个独特的位置。一方面，你扮演着构建工程师的角色；你需要理解编译器、平台以及中间所有事物的复杂性。另一方面，你是一名开发者；你在编写生成构建系统的代码。编写好的代码是困难的，并要求同时思考多个层面——它应该能工作且容易阅读，但它也应该容易分析、扩展和维护。这正是我们将在这里讨论的内容。
- en: Lastly, we'll introduce some of the most useful and common commands in CMake.
    Commands that aren't used that often will be placed in the *Appendix* section
    (this will include a complete reference guide for the string, list, and file manipulation
    commands).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍CMake中一些最有用和常见的命令。不经常使用的命令将放在*附录*部分（这将包括字符串、列表和文件操作命令的完整参考指南）。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The basics of the CMake Language syntax
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake语言基础语法
- en: Working with variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量
- en: Using lists
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表
- en: Understanding control structures in CMake
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解CMake中的控制结构
- en: Useful commands
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用命令
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter02](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter02).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中存在的代码文件：[https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter02](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter02)。
- en: 'To build examples provided in this book always use recommended commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建本书中提供的示例，总是使用推荐的命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace placeholders `<build tree>` and `<source tree>` with appropriate
    paths. As a reminder: **build tree** is the path to target/output directory, **source
    tree** is the path at which your source code is located.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将占位符`<build tree>`和`<source tree>`替换为适当的路径。作为提醒：**构建树**是目标/输出目录的路径，**源树**是您的源代码所在的路径。
- en: The basics of the CMake Language syntax
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMake语言基础语法
- en: 'Composing CMake code is very much like writing in any other imperative language:
    lines are executed from top to bottom and from left to right, occasionally stepping
    into an included file or a called function. Depending on the mode (see the *Mastering
    the command line* section in [*Chapter 1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014),
    *First Steps with CMake*), the execution begins from the root file of the source
    tree (`CMakeLists.txt`) or a `.cmake` script file that was passed as an argument
    to `cmake`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编写CMake代码与编写其他命令式语言的代码非常相似：代码从上到下、从左到右执行，偶尔会进入一个被包含的文件或一个被调用的函数。根据模式（参见[第1章](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014)中的*掌握命令行*部分，*CMake的初学者指南*），执行从源树根文件（`CMakeLists.txt`）或作为一个参数传递给`cmake`的`.cmake`脚本文件开始。
- en: 'As we discussed in the previous chapter, scripts support the majority of the
    CMake Language (with the exclusion of any project-related functionality). As a
    result, they''re a great way to start practicing the CMake syntax itself, and
    that''s why we''ll be using them here. After becoming comfortable writing basic
    listfiles, we''ll start preparing actual project files in the next chapter. If
    you remember, scripts can be run with the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中讨论的，脚本支持CMake语言的大部分（排除任何与项目相关的功能）。因此，它们是开始练习CMake语法的好方法，这就是为什么我们会在这里使用它们。在熟练编写基本列表文件之后，我们将在下一章开始准备实际的项目文件。如果你还记得，脚本可以用以下命令运行：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: CMake supports `\n` or `\r\n` line endings. **UTF-8** with optional **Byte Order
    Markers** (**BOMs**) is supported in CMake versions above 3.0, and **UTF-16**
    is supported in CMake versions above 3.2.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CMake支持`\n`或`\r\n`行结束。**UTF-8**支持可选的**字节顺序标记**（**BOMs**）的CMake版本 above 3.0，并且**UTF-16**在CMake版本
    above 3.2中得到支持。
- en: Everything in a CMake listfile is either a *command invocation* or a *comment*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CMake列表文件中的所有内容要么是*命令调用*，要么是*注释*。
- en: Comments
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'Just like in **C++**, there are two kinds of comments – *single-line* comments
    and *bracket* (*multiline*) comments. But unlike in C++, bracket comments can
    be nested. Let me show you the syntax:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在**C++**中一样，有两种注释——*单行*注释和*方括号* (*多行*)注释。但与C++不同，方括号注释可以嵌套。让我给你展示一下语法：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Multiline comments get their name from their symbol – they start with an opening
    square bracket (`[`), any number of equal (`=`) signs, and another square bracket:
    `[=[`. To close a bracket comment, use the same number of equal signs and reverse
    the brackets like so: `]=]`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释因其符号而得名——它们以一个开口方括号（`[`）开始，后面跟着任意数量的等号（`=`）和一个另一个方括号：`[=[`。要关闭方括号注释，请使用相同数量的等号，并像这样反转方括号：`]=]`。
- en: 'Prepending opening bracket tokens with `#` is optional, and allows you to quickly
    disable a multiline comment by adding another `#` to the first line of the bracket
    comment like so:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在方括号标记前面加上`#`是可选的，允许你通过在方括号注释的第一行添加另一个`#`来快速禁用多行注释，像这样：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That's a nifty trick, but when and how should we use comments in our CMake file?
    Since writing listfiles is essentially programming, it is a good idea to bring
    our best coding practices to them as well. Code that follows such practices is
    often called *clean* – a term used over the years by software development gurus
    like Robert C. Martin, Martin Fowler, and many other authors. What's considered
    helpful and harmful is often heavily disputed and, as you might guess, comments
    have not been left out of these debates.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那是个巧妙的技巧，但我们在CMake文件中什么时候以及如何使用注释呢？由于编写列表文件本质上是一种编程，因此最好也将我们最好的编程实践应用到它们上。遵循此类实践的代码通常被称为*干净*——这个术语多年来被软件开发大师如Robert
    C. Martin, Martin Fowler，以及其他许多作者使用。认为有帮助和有害的东西常常激烈争论，正如你所猜的，注释也没有被排除在这些争论之外。
- en: 'Everything should be judged on a case-by-case basis, but generally agreed-upon
    guidelines say that good comments provide at least one of the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都应该根据具体情况来判断，但通常公认的指导原则说，好的注释至少提供以下之一：
- en: '**Information**: They can untangle complexities such as regex patterns or formatting
    strings.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息**：它们可以解释像正则表达式模式或格式化字符串这样的复杂性。'
- en: '**Intent**: They can explain the intent of the code when it is unobvious from
    the implementation or interface.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**意图**：它们可以在代码的实现或接口不明显时解释代码的意图。'
- en: '**Clarification**: They can explain concepts that can''t be easily refactored
    or changed.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阐明**：它们可以解释难以重构或更改的概念。'
- en: '**Warnings of consequences**: They can provide warnings, especially around
    code that can break other things.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警告后果**：它们可以提供警告，尤其是关于可能破坏其他内容的代码。'
- en: '**Amplification**: They can underline the importance of an idea that is hard
    to express in code.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**放大**：它们可以强调难以用代码表达的想法。'
- en: '**Legal clauses**: They can add this necessary evil, which is usually not the
    domain of a programmer.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法律条款**：它们可以添加这个必要的恶棍，这通常不是程序员的领域。'
- en: 'If you can, avoid adding comments and adopt better naming practices, or refactor
    or correct your code. If you can, avoid adding comments of the following types:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以，避免添加注释并采用更好的命名约定，或者重构或修正你的代码。如果你可以，避免添加以下类型的注释：
- en: '**Mandated**: These are added for completeness, but they are not really important.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制**：这些是为了完整性而添加的，但它们并不是非常重要。'
- en: '**Redundant**: These repeat what is already clearly written in the code.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冗余**：这些重复了代码中已经清晰写明的内容。'
- en: '**Misleading**: These could be outdated or incorrect if they don''t follow
    code changes.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**误导**：如果它们没有跟随代码更改，它们可能是过时的或不正确的。'
- en: '**Journal**: These note what has been changed and when (use **VCS** for this
    instead).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：这些记录了更改的内容和时间（使用**版本控制系统**代替）。'
- en: '**Dividers**: These mark sections.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分隔符**：这些用于标记章节。'
- en: Writing elegant code without comments is hard, but it improves the experience
    of the reader. Since we spend more time reading code than writing it, we should
    always try to *write readable code*, instead of just trying to write it quickly.
    I recommend checking out the *Further reading* section at the end of this chapter
    for some good references on *clean code*. If you're interested in comments in
    particular, you'll find a link to one of my many YouTube videos touching on this
    subject in depth.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不带注释编写优雅的代码很难，但它可以提高读者的体验。由于我们花在阅读代码上的时间比编写代码的时间多，我们总是应该努力*编写可读的代码*，而不仅仅是尝试快速编写它。我建议在本章末尾查看*进一步阅读*部分，那里有一些关于*整洁代码*的好参考资料。如果你对注释特别感兴趣，你会在其中一个
    YouTube 视频中找到一个深入讨论这个主题的链接，这个视频是我关于这个主题的众多视频之一。
- en: Command invocations
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令调用
- en: Time for some action! Invoking commands is the bread and butter of CMake listfiles.
    To execute a command, you must provide its name, followed by parentheses, in which
    you may enclose a whitespace-separated list of **command arguments**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候动手了！调用命令是 CMake 列表文件的核心。要执行一个命令，你必须提供其名称，后面跟着括号，其中你可以包含一个空格分隔的**命令参数**列表。
- en: '![Figure 2.1 – An example of a command'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – 命令示例'
- en: '](img/Figure_2.1_B17205.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.1_B17205.jpg)'
- en: Figure 2.1 – An example of a command
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 命令示例
- en: Command names aren't case-sensitive, but there is a convention in the CMake
    community to use snake_case in command names (that is, lower-case words joined
    with underscores). You can also define your own commands, which we'll cover in
    the *Understanding control structures in CMake* section of this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 命令名称不区分大小写，但 CMake 社区有一个约定，在命令名称中使用蛇形大小写（即，使用下划线连接的小写字母单词）。你也可以定义自己的命令，这部分将在本章的*理解
    CMake 中的控制结构*部分进行介绍。
- en: What's especially striking in comparison to C++ is the fact that command invocations
    in CMake are not expressions. You can't provide another command as an argument
    to a called command, as *everything* between the parentheses is interpreted as
    an argument for that command.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C++ 相比，特别引人注目的是 CMake 中的命令调用不是表达式。你不能将另一个命令作为参数传递给被调用的命令，因为*所有*括号内的内容都被解释为该命令的参数。
- en: 'Even more enraging is the fact that CMake commands don''t require semicolons
    at the end of an invocation. This may be because each line of source can contain
    up to one command invocation, followed by an optional single-line comment. Alternatively,
    an entire line has to be part of a bracket comment. So, these are the only allowed
    formats:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更加令人沮丧的是，CMake 命令在调用结束时不需要分号。这可能是因为源代码的每一行可以包含多达一个命令调用，后面可以跟一个可选的单行注释。或者，整个行必须是括号注释的一部分。所以，这些是唯一允许的格式：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Putting a command after a bracket comment is not allowed:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号注释后放置命令是不允许的：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After removing any comments, whitespace, and empty lines, we get a list of command
    invocations. This creates an interesting perspective – CMake syntax is really
    simple, but is that a good thing? How do we even work with variables? Or, how
    do we direct the flow of the execution?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除任何注释、空格和空行之后，我们得到一个命令调用的列表。这创造了一个有趣的视角——CMake 语法真的很简单，但这是一件好事吗？我们是如何处理变量的？或者，我们是如何指导执行流程的？
- en: 'CMake provides commands for these actions and much more. To make things easier,
    we''ll be introducing the relevant commands as we move through different examples,
    and they can be grouped into three categories:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了这些操作以及更多命令。为了简化事情，我们将随着不同示例的推进介绍相关命令，并将它们分为三个类别：
- en: '**Scripting commands**: These are always available, and they change the state
    of the command processor, access variables, and affect other commands and the
    environment.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本命令**：这些命令始终可用，用于改变命令处理器的状态、访问变量，并影响其他命令和环境。'
- en: '**Project commands**: These are available in projects, and they manipulate
    the project state and build targets.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目命令**：这些命令在项目中可用，用于操作项目状态和构建目标。'
- en: '**CTest commands**: These are available in CTest scripts. They manage testing.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CTest命令**：这些命令在CTest脚本中可用，用于管理测试。'
- en: We'll cover the most useful scripting commands in this chapter (as they are
    also useful in projects). Project and CTest commands will be discussed in the
    following chapters as we introduce the concepts relating to build targets ([*Chapter
    3*](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078), *Setting Up Your First CMake
    Project*) and testing frameworks ([*Chapter 8*](B17205_08_Final_JC_ePub.xhtml#_idTextAnchor179),
    *Testing Frameworks*).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍最有用的脚本命令（因为它们在项目中也非常有用）。项目和CTest命令将在我们引入与构建目标相关的概念（[第3章](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078)，*设置你的第一个CMake项目*)和测试框架（[第8章](B17205_08_Final_JC_ePub.xhtml#_idTextAnchor179)，*测试框架*）时讨论。
- en: 'Virtually every command relies on other elements of the language in order to
    function: variables, conditional statements, and first and foremost, command-line
    arguments. Let''s see how we should use these.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个命令都依赖于语言的其他元素才能正常工作：变量、条件语句，以及最重要的，命令行参数。让我们看看应该如何使用这些元素。
- en: Command arguments
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令参数
- en: Many commands require whitespace-separated arguments to parametrize how they
    behave. As you saw in *Figure 2.1*, there's something weird happening with the
    quotes around the arguments. Some arguments have quotes and others don't – what's
    up with that?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 许多命令需要用空格分隔的参数来指定它们的行为方式。正如你在*图2.1*中看到的，引号周围的参数有些奇怪。一些参数有引号，而其他参数没有——这是怎么回事？
- en: Under the hood, the only data type recognized by CMake is a *string*. This is
    why every command expects zero or more strings for its arguments. But plain, static
    strings aren't very useful, especially when we can't nest command invocations.
    Here's where arguments come into play – CMake will evaluate every argument to
    a static string and then pass them into the command. *Evaluating* means *string
    interpolation*, or substituting parts of a string with another value. This can
    mean replacing the *escape sequences*, expanding the *variable references* (also
    called *variable interpolation*), and unpacking *lists*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，CMake唯一能识别的数据类型是一个*字符串*。这就是为什么每个命令都期望其参数为零个或多个字符串。但是，普通的、静态的字符串并不非常有用，尤其是当我们不能嵌套命令调用时。参数就派上用场了——CMake将评估每个参数为静态字符串，然后将它们传递给命令。*评估*意味着*字符串插值*，或将字符串的一部分替换为另一个值。这可以意味着替换*转义序列*，展开*变量引用*（也称为*变量插值*），以及解包*列表*。
- en: 'Depending on the context, we might want to enable such evaluation as needed.
    And for that reason, CMake offers three types of arguments:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上下文，我们可能需要启用这种评估。为此，CMake提供了三种参数类型：
- en: '**Bracket arguments**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方括号参数**'
- en: '**Quoted arguments**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引号参数**'
- en: '**Unquoted arguments**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未引用的参数**'
- en: Each argument type offers a different level of evaluation and has a few small
    quirks to it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每种参数类型提供不同级别的评估，并且有一些小怪癖。
- en: Bracket arguments
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方括号参数
- en: Bracket arguments aren't evaluated because they are used to pass multiline strings,
    verbatim, as a single argument to commands. This means it will include whitespace
    in the form of tabs and newlines.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号参数不进行评估，因为它们用于将多行字符串作为单个参数传递给命令，而不做任何更改。这意味着它会包括制表符和换行符形式的空白。
- en: These arguments are structured exactly like comments – that is, they are opened
    with `[=[` and closed with `]=]`, where the number of the equal signs in the opening
    and closing tokens has to match (skipping the equal signs is fine too, but they
    still have to match). The only difference from comments is that you can't nest
    bracket arguments.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数的结构与注释完全一样——也就是说，它们以`[=[`开头，以`]=]`结尾，其中开头和结尾标记中的等号数量必须匹配（省略等号也是可以的，但它们仍然必须匹配）。与注释的区别在于，你不能嵌套方括号参数。
- en: 'Here''s an example of the use of such an argument with the `message()` command,
    which prints all passed arguments to the screen:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用此类参数与`message()`命令的一个例子，该命令将所有传递的参数打印到屏幕上：
- en: chapter02/01-arguments/bracket.cmake
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02/01-arguments/bracket.cmake
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the above example, we can see different forms of bracket arguments. The
    first one skips the equal sign. Note how putting closing tags on a separate line
    is visible as an empty line in the output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们可以看到不同形式的括号参数。第一个省略了等号。注意把闭合标签放在单独一行上，在输出中会显示为一个空行：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The second form is useful when we're passing text that contains double brackets
    (`]]`) (highlighted in the code snippet), as they won't be interpreted as marking
    the end of the argument.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式在传递包含双括号（`]]`）的文本时很有用（在代码片段中突出显示），因为它们不会被解释为参数的结束标记。
- en: These kinds of bracket arguments have limited use – typically, to contain longer
    blocks of text. In most cases, we'll need something more dynamic, such as quoted
    arguments.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这类括号参数的用途有限——通常，用来包含较长的文本块。在大多数情况下，我们需要一些更动态的内容，比如引号参数。
- en: Quoted arguments
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引号参数
- en: 'Quoted arguments resemble a regular C++ string – these arguments group together
    multiple characters, including whitespace, and they will expand *escape sequences*.
    Like C++ strings, they are opened and closed with a double quote character (`"`),
    so to include a quote character within the output string, you have to escape it
    with a backslash (`\"`). Other well-known escape sequences are supported as well:
    `\\` denotes a literal backslash, `\t` is a tab character, `\n` is a newline,
    and `\r` is a carriage return.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 引号参数类似于普通的C++字符串——这些参数将多个字符（包括空格）组合在一起，并将展开*转义序列*。和C++字符串一样，它们用双引号字符（`"`）打开和关闭，所以为了在输出字符串中包含一个引号字符，你必须用反斜杠（`\"`）进行转义。也支持其他一些著名的转义序列：`\\`表示一个字面反斜杠，`\t`是一个制表符，`\n`是一个换行符，`\r`是一个回车符。
- en: This is where the similarities with C++ strings end. Quoted arguments can span
    multiple lines, and they will interpolate variable references. Think of them as
    having a built-in `sprintf` function from `std::format` function from `${name}`.
    We'll talk more about variable references in the *Working with variables* section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是C++字符串相似之处的结束。引号参数可以跨越多行，并且它们将插值变量引用。可以认为它们内置了`sprintf`函数从`std::format`中`${name}`。我们将在*使用变量*部分更多地讨论变量引用。
- en: 'Let''s try these arguments in action:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试这些参数的实际应用：
- en: chapter02/01-arguments/quoted.cmake
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02/01-arguments/quoted.cmake
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Can you guess how many lines will be in the output of the preceding script?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到前面脚本的输出将有多少行吗？
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That's right – we have one escaped quote character, one escaped newline, and
    a literal newline. All of them will be printed in the output. We also accessed
    a built-in `CMAKE_VERSION` variable, which we can see correctly interpolated on
    the last line.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 没错——我们有一个转义的引号字符，一个转义的换行符，和一个字面的换行符。它们都将被打印在输出中。我们还访问了内置的`CMAKE_VERSION`变量，我们可以在最后一行正确地看到它被插值。
- en: Unquoted arguments
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未引用的参数
- en: The last type of argument is definitely a bit rare in the programming world.
    We got used to the fact that strings have to be delimited in one way or another,
    for example, by using single quotes, double quotes, or a backslash. CMake deviates
    from this convention and introduces unquoted arguments. We might argue that dropping
    delimiters makes the code easier to read, just like skipping semicolons. Is that
    true? I'll let you form your own opinion.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中，最后一种参数确实比较少见。我们习惯了字符串要以某种方式进行分隔，例如，使用单引号、双引号或反斜杠。CMake与这个约定不符，并引入了未引用的参数。我们可能会认为省略分隔符可以使代码更容易阅读，就像省略分号一样。这是真的吗？我会让你自己形成自己的看法。
- en: Unquoted arguments evaluate both *escape sequences* and *variable references*.
    However, be careful with semicolons (`;`), as in CMake, this is treated as a delimiter.
    CMake will split the argument containing it into multiple arguments. If you need
    to use it, escape it with a backslash (`\;`). This is how CMake manages lists.
    I'll explain that in detail in the *Using lists* section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 未引用的参数评估*转义序列*和*变量引用*。然而，要小心分号（`;`），因为在CMake中，这被视为分隔符。CMake会将包含它的参数拆分为多个参数。如果你需要使用它，用反斜杠（`\;`）转义它。这就是CMake如何管理列表的方式。我将在*使用列表*部分详细解释。
- en: 'You may find that these arguments are the most perplexing to work with, so
    here''s an illustration to help clarify how these arguments are partitioned:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现这些参数是最让人困惑的，所以这里有一个说明来帮助澄清这些参数是如何划分的：
- en: '![Figure 2.2 – Escape sequences cause separate tokens to be interpreted as
    a single argument'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 – 转义序列导致分离的标记被解释为一个参数](img/Figure_2.2_B17205.jpg)'
- en: '](img/Figure_2.2_B17205.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.2_B17205.jpg)'
- en: Figure 2.2 – Escape sequences cause separate tokens to be interpreted as a single
    argument
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 转义序列导致分离的标记被解释为一个参数
- en: Question
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 问题
- en: Why does it matter if a value is passed as a single argument or many arguments?
    Some CMake commands require a specific number of arguments and ignore any overhead.
    If your arguments accidentally become separated, you'll get hard-to-debug errors.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么一个值作为单个参数传递或多个参数传递会有区别？一些 CMake 命令需要特定数量的参数，并忽略任何开销。如果你的参数不小心被分开了，你会得到难以调试的错误。
- en: Unquoted arguments cannot contain unescaped quotes (`"`), hashes (`#`), and
    backslashes (`\`). And if that's not enough rules to remember, parentheses (`()`)
    are allowed only if they form correct, matching pairs. That is, you'll start with
    an opening parenthesis and close it before closing the command argument list.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 未引用的参数不能包含未转义的引号（`"`）、散列（`#`）和反斜杠（`\`）。如果这些规则还不够难以记忆，圆括号（`()`）只能在它们形成正确、匹配的对时使用。也就是说，你将以一个开放圆括号开始，并在关闭命令参数列表之前关闭它。
- en: 'Let''s look at some examples of all of the above rules:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看上面所有规则的一些例子：
- en: chapter02/01-arguments/unquoted.cmake
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02/01-arguments/unquoted.cmake
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What will be the output of the above? Let''s have a look:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出会是什么？让我们来看看：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Even a simple command such as `message()` is very particular about separated
    unquoted arguments:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是像 `message()` 这样的简单命令也非常在意分离的未引用参数：
- en: The space in `a single argument` was correctly printed when it was explicitly
    escaped.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `a single argument` 中的空格在显式转义时被正确打印。
- en: However, `twoarguments` and `threeseparatearguments` were *glued* together,
    since `message()` doesn't add any spaces on its own.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，`twoarguments` 和 `threeseparatearguments` 被*粘*在一起，因为 `message()` 本身不会添加任何空格。
- en: Now that we understand how to deal with the complexities and quirks of CMake
    arguments, we are ready to tackle the next interesting subject – working with
    all kinds of *variables* in CMake.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了如何处理 CMake 参数的复杂性和怪癖，我们准备迎接下一个有趣的话题——在 CMake 中处理各种*变量*。
- en: Working with variables
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CMake 中处理变量
- en: '**Variables** in CMake are a surprisingly complex subject. Not only are there
    three categories of variables – normal, cache, and environment – but they also
    reside in different scopes, with specific rules on how one scope affects the other.
    Very often, a poor understanding of all these rules becomes a source of bugs and
    headaches. I recommend you study this section with care and make sure you understand
    all of concepts before moving on.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 中的变量是一个相当复杂的话题。不仅变量分为三种类别——普通、缓存和环境变量，而且它们还存在于不同的作用域中，有着特定的一套规则，一个作用域如何影响另一个作用域。在大多数情况下，对这些规则的误解成为错误和头痛的来源。我建议你仔细学习这一部分，并确保在继续之前理解了所有概念。
- en: 'Let''s start with some key facts about variables in CMake:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解一些关于 CMake 变量的关键事实：
- en: Variable names are case-sensitive and can include almost any character.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名是区分大小写的，并且几乎可以包含任何字符。
- en: All variables are stored internally as strings, even if some commands can interpret
    them as values of other data types (even lists!).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的变量内部都是以字符串的形式存储的，即使有些命令可以将它们解释为其他数据类型（甚至是列表！）。
- en: The basic variable manipulation commands are `set()` and `unset()`, but there
    are other commands that can affect variables, such as `string()` and `list()`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 的基本变量操作命令是 `set()` 和 `unset()`，但还有其他可以影响变量的命令，如 `string()` 和 `list()`。
- en: 'To set a variable, we simply call `set()`, providing its name and the value:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个变量，我们只需调用 `set()`，提供其名称和值：
- en: chapter02/02-variables/set.cmake
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02/02-variables/set.cmake
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the use of brackets and quoted arguments allows for spaces to
    be included in the variable name. However, when referencing it later, we have
    to escape the whitespace with a backslash (`\`). For that reason, it is recommended
    to use only alphanumeric characters, dashes (`-`), and underscores (`_`) in variable
    names.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，括号和引号参数的使用允许在变量名中包含空格。然而，在稍后引用时，我们必须用反斜杠（`\`）转义空格。因此，建议变量名只使用字母数字字符、连字符（`-`）和下划线（`_`）。
- en: 'Also avoid reserved names (in upper, lower, or mixed case) that begin with
    any of the following: `CMAKE_`, `_CMAKE_`, or underscore (`_`), followed by the
    name of any CMake command.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 还应避免以以下任何内容开头的保留名称（全部大写、全部小写或混合大小写）：`CMAKE_`、`_CMAKE_` 或下划线（`_`），后跟任何 CMake
    命令的名称。
- en: Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `set()` command accepts a plain text variable name as its first argument,
    but the `message()` command uses a variable reference wrapped in the `${}` syntax.
    What would happen if we were to provide a variable wrapped in the `${}` syntax
    to the `set()` command? To answer that, we'll need to understand variable references
    better.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`set()`命令接受一个普通文本变量名作为其第一个参数，但`message()`命令使用的是用`${}`语法包裹的变量引用。如果我们向`set()`命令提供一个用`${}`语法包裹的变量，会发生什么？为了回答这个问题，我们需要更好地理解变量引用。'
- en: 'To unset a variable, we can use `unset()` in the following way: `unset(MyString1)`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消设置变量，我们可以使用以下方式：`unset(MyString1)`。
- en: Variable references
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量引用
- en: 'I already mentioned references briefly in the *Command arguments* section,
    as they''re evaluated for quoted and unquoted arguments. And we learned that to
    create a reference to a defined variable, we need to use the `${}` syntax, like
    so: `message(${MyString1})`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在*命令参数*部分简要提到了引用，因为它们对带引号和不带引号的参数进行评估。我们还了解到，要创建一个对已定义变量的引用，我们需要使用`${}`语法，如下所示：`message(${MyString1})`。
- en: On evaluation, CMake will traverse the scope stack (I'll explain that in a second)
    and replace `${MyString1}` with a value, or an empty string if no variable is
    found (CMake won't generate any error messages). This process is called *variable
    evaluation*, *expansion*, or *interpolation*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估时，CMake将遍历作用域堆栈（我稍后会解释）并将`${MyString1}`替换为一个值，如果没有找到变量，则替换为一个空字符串（CMake不会生成任何错误消息）。这个过程被称为*变量评估*、*展开*或*插值*。
- en: 'Such interpolation is performed in an inside-out fashion. This means two things:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的插值是逆向进行的。这意味着两件事：
- en: If the following reference is encountered – `${MyOuter${MyInner}}` – CMake will
    try to evaluate `MyInner` first, rather than searching for a variable named `MyOuter${MyInner}`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到以下引用——`${MyOuter${MyInner}}`——CMake将首先尝试评估`MyInner`，而不是搜索名为`MyOuter${MyInner}`的变量。
- en: If the `MyInner` variable is successfully expanded, CMake will repeat the expansion
    process until no further expansion is possible.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`MyInner`变量成功展开，CMake将重复展开过程，直到无法进一步展开为止。
- en: 'Let''s consider an example with the following variables:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下变量的示例：
- en: '`MyInner` with a `Hello` value'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyInner`带有`Hello`值'
- en: '`MyOuter` with a `${My` value'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyOuter`带有`${My`值'
- en: If we call the `message("${MyOuter}Inner} World")` command, the output we'll
    receive will be `Hello World`, and that is because `${MyOuter}` was replaced with
    a literal value, `${My`, which, when combined with the top-level value, `Inner}`,
    creates another variable reference – `${MyInner}`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`message("${MyOuter}Inner} World")`命令，我们将收到`Hello World`的输出，这是因为`${MyOuter}`被替换为字面值`${My`，与顶级值`Inner}`结合，创建了另一个变量引用——`${MyInner}`。
- en: CMake will perform this expansion to the full extent, and only then will it
    pass the resulting values as arguments to the command. This is why when we call
    `set(${MyInner} "Hi")`, we won't actually be changing the `MyInner` variable,
    but instead, we'll change the `Hello` variable. CMake expands `${MyInner}` to
    `Hello` and passes that string as the first argument to the `set()` command, along
    with a new value, `Hi`. Very often, this is not what we want.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: CMake将进行这种展开到最大限度，然后才将结果值作为参数传递给命令。这就是为什么我们调用`set(${MyInner} "Hi")`时，我们实际上并没有改变`MyInner`变量，而是改变了`Hello`变量。CMake展开`${MyInner}`为`Hello`，并将该字符串作为`set()`命令的第一个参数，并传递一个新的值，`Hi`。通常，这并不是我们想要的结果。
- en: 'Variable references are a bit peculiar in how they work when it comes to variable
    categories, but in general, the following applies:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 变量引用在变量类别方面的工作方式有些奇特，但总的来说，以下内容适用：
- en: The `${}` syntax is used to reference *normal* or *cache* variables.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${}`语法用于引用*普通*或*缓存*变量。'
- en: The `$ENV{}` syntax is used to reference *environment* variables.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ENV{}`语法用于引用*环境*变量。'
- en: The `$CACHE{}` syntax is used to reference *cache* variables.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$CACHE{}`语法用于引用*缓存*变量。'
- en: That's right, with `${}`, you might get a value from one category or the other.
    I'll explain that in the *How to correctly use the variable scope in CMake* section,
    but first, let's introduce some other categories of variables so that we understand
    clearly what they are.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，使用`${}`，你可能会从一个类别或另一个类别中获取一个值。我将在*如何在CMake中正确使用变量作用域*部分解释这一点，但首先，让我们介绍一下其他类别的变量，以便我们清楚地了解它们是什么。
- en: Note
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that you can pass arguments to scripts through the command line after
    a `--` token. Values will be stored in the `CMAKE_ARGV<n>` variable and the count
    of the passed arguments will be in the `CMAKE_ARGC` variable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您可以在`--`标记之后通过命令行向脚本传递参数。值将存储在`CMAKE_ARGV<n>`变量中，传递的参数数量将在`CMAKE_ARGC`变量中。
- en: Using the environment variables
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: This is the least complicated kind of variable. CMake makes a copy of the variables
    that were in the environment used to start the `cmake` process and makes them
    available in a single, global scope. To reference these variables, use the `$ENV{<name>}`
    syntax.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的变量类型。CMake会复制启动`cmake`过程时使用的环境中的变量，并使它们在一个单独的全局作用域中可用。要引用这些变量，请使用`$ENV{<name>}`语法。
- en: CMake also allows you to set (`set()`) and unset (`unset()`) these variables,
    but changes will only be made to a local copy in the running `cmake` process and
    not the actual system environment; moreover, these changes won't be visible to
    subsequent runs of builds or tests.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: CMake还允许您设置（`set()`）和取消设置（`unset()`）这些变量，但更改只会对运行中的`cmake`过程中的本地副本进行修改，而不会对实际系统环境进行修改；此外，这些更改不会对后续的构建或测试运行可见。
- en: 'To modify or create a variable, use the `set(ENV{<variable>} <value>)` command,
    like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改或创建一个变量，请使用`set(ENV{<variable>} <value>)`命令，如下所示：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To clear an environment variable, use `unset(ENV{<variable>})`, like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要清除一个环境变量，请使用`unset(ENV{<variable>})`，如下所示：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Be aware that there are a few environment variables that affect different aspects
    of CMake behavior. The `CXX` variable is one of them – it specifies what executable
    will be used for compiling C++ files. We''ll cover other environmental variables,
    as they will become relevant for this book. A full list is available in the documentation:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有几个环境变量会影响CMake行为的不同方面。`CXX`变量是其中的一个——它指定了用于编译C++文件的执行文件。我们将在本书中覆盖其他环境变量，因为它们将变得相关。完整的列表可以在文档中找到：
- en: '[https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html)'
- en: If you use `ENV` variables as arguments to your commands, the values will be
    interpolated during the generation of the buildsystem. This means that they will
    get baked into the build tree, and changing the environment for the build stage
    won't have any effect.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将`ENV`变量作为命令的参数，它们的值将在构建系统的生成过程中进行插值。这意味着它们将被编织进构建树中，更改构建阶段的环境将没有任何效果。
- en: 'For example, take the following project file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下项目文件：
- en: chapter02/03-environment/CMakeLists.txt
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02/03-environment/CMakeLists.txt
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding example has two steps: it will print the `myenv` environment
    variable during the configuration, and it will add a build stage through `add_custom_target()`,
    which echoes the same variable as part of the build process. We can test what
    happens with a bash script that uses one value for the configuration stage and
    another for the build stage:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例有两个步骤：在配置阶段打印`myenv`环境变量，并通过`add_custom_target()`添加一个构建阶段，在构建过程中输出相同的变量。我们可以用一个bash脚本测试会发生什么，该脚本在配置阶段使用一个值，在构建阶段使用另一个值：
- en: chapter02/03-environment/build.sh
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02/03-environment/build.sh
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Running the preceding code clearly shows that the value set during the configuration
    is persisted to the generated buildsystem:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码清楚地显示，在配置阶段设置的值被持久到了生成的构建系统中：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using the cache variables
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓存变量
- en: We first mentioned cache variables when discussing command-line options for
    `cmake` in [*Chapter 1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014), *First
    Steps with CMake*. Essentially, they're persistent variables stored in a `CMakeCache.txt`
    file in your build tree. They contain information gathered during the project
    configuration stage, both from the system (path to compilers, linkers, tools,
    and others) and from the user through the `CMakeCache.txt` file) – they only exist
    in *projects*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在[第1章](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014) *CMake的初步步骤*中提到了缓存变量，当时是在讨论`cmake`的命令行选项。本质上，它们是存储在构建树中的`CMakeCache.txt`文件中的持久变量。它们包含在项目配置阶段收集的信息，既有来自系统的（编译器、链接器、工具等的路径），也有通过`CMakeCache.txt`文件来自用户的——它们只存在于*项目中*。
- en: Cache variables can be referenced with the `$CACHE{<name>}` syntax.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存变量可以用`$CACHE{<name>}`语法引用。
- en: 'To set a cache variable, use `set()` with the following syntax:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个缓存变量，请使用以下语法使用`set()`：
- en: '`set(<variable> <value> CACHE <type> <docstring> [FORCE])`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`set(<variable> <value> CACHE <type> <docstring> [FORCE])`'
- en: 'As you can see, there are some new required arguments (in comparison to the
    `set()` command for normal variables), and it also introduces first keywords:
    `CACHE` and `FORCE`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，有一些新的必需参数（与正常变量的 `set()` 命令相比），它还引入了第一个关键字：`CACHE` 和 `FORCE`。
- en: 'Specifying `CACHE` as a `set()` argument means that we intend to change what
    was provided during the configuration stage, and it imposes a requirement to provide
    the variable `<type>` and `<docstring>` values. This is because these variables
    are configurable by the user and the GUI needs to know how to display it. The
    following types are accepted:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `CACHE` 指定为 `set()` 参数意味着我们打算改变在配置阶段提供的内容，并强制提供变量 `<type>` 和 `<docstring>`
    值。这是因为这些变量可以由用户配置，GUI 需要知道如何显示它。以下类型被接受：
- en: '`BOOL`: A Boolean on/off value. The GUI will show a checkbox.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOL`: 是/否的布尔值。GUI 将显示一个复选框。'
- en: '`FILEPATH`: A path to a file on a disk. The GUI will open a file dialog.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILEPATH`: 磁盘上一个文件的路径。GUI 将打开一个文件对话框。'
- en: '`PATH`: A path to a directory on a disk. The GUI will open a directory dialog.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATH`: 磁盘上一个目录的路径。GUI 将打开一个目录对话框。'
- en: '`STRING`: A line of text. The GUI offers a text field to be filled. It can
    be replaced by a drop-down control by calling `set_property(CACHE <variable> STRINGS
    <values>)`.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STRING`: 一行文本。GUI 提供一个文本字段来填写。它可以被调用 `set_property(CACHE <variable> STRINGS
    <values>)` 的下拉控件替换。'
- en: '`INTERNAL`: A line of text. The GUI skips internal entries. The internal entries
    may be used to store variables persistently across runs. Use of this type implicitly
    adds the `FORCE` keyword.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERNAL`: 一行文本。GUI 跳过内部条目。内部条目可用于在多次运行之间持久化存储变量。使用此类型隐式添加 `FORCE` 关键字。'
- en: The `<doctring>` value is simply a label that will be displayed by the GUI next
    to the field to provide more detail about this setting to the user. It is required
    even for an `INTERNAL` type.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`<docstring>` 值只是一个标签，它将由 GUI 在字段旁边显示，为用户提供关于此设置的更多详细信息。即使是 `INTERNAL` 类型也需要它。'
- en: 'Setting cache variables follows the same rules as environmental variables to
    some extent – values are overwritten only for the current execution of CMake.
    Take a look at this example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 设置缓存变量遵循与环境变量相同的规则，在某种程度上——值只在 CMake 的当前执行中覆盖。看这个例子：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The above call has no permanent effect if the variable exists in the cache.
    However, if the value doesn''t exist in cache or an optional `FORCE` argument
    is specified, the value will be persisted:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量在缓存中存在，上述调用将没有永久效果。然而，如果值不在缓存中或者指定了可选的 `FORCE` 参数，该值将被持久化：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Setting the cache variables has some unobvious implications. That is, any normal
    variable with the same name will be removed. We'll find out why in the next section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 设置缓存变量有一些不明显的含义。也就是说，任何同名的正常变量都会被移除。我们在下一节中找出原因。
- en: As a reminder, cache variables can be managed from the command line as well
    (check the appropriate section in [*Chapter 1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014),
    *First Steps with CMake*).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，缓存变量也可以从命令行管理（查看 [*第 1 章*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014)，*CMake
    的第一步* 中的适当部分）。
- en: How to correctly use the variable scope in CMake
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在 CMake 中正确使用变量作用域
- en: '**Variable scope** is probably the hardest part of the whole concept of the
    CMake Language. This is maybe because we''re so accustomed to how things are done
    in more advanced languages that support namespaces and scope operators. CMake
    doesn''t have those mechanisms, so it deals with this issue in its own, somewhat
    unusual way.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量作用域** 可能是整个 CMake 语言概念中最难的部分。这可能是因为我们习惯于在支持命名空间和作用域操作符的更高级语言中是如何处理事情的。CMake
    没有这些机制，所以它以自己 somewhat unusual 的方式处理这个问题。'
- en: Just to clarify, variable scopes as a general concept are meant to separate
    different layers of abstraction so that when a user-defined function is called,
    variables set in that function are local to it. These *local* variables aren't
    affecting the *global* scope, even if the names of the local variables are exactly
    the same as the global ones. If explicitly needed, functions should have read/write
    access to global variables as well. This separation of variables (or scopes) has
    to work on many levels – when one function calls another, the same separation
    rules apply.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，作用域作为一个一般概念是为了将不同层次的抽象分离，以便当调用一个用户定义的函数时，函数中设置的变量是局部的。这些*局部*变量即使与*全局*变量的名称完全相同，也不会影响全局作用域。如果明确需要，函数应该对全局变量也有读/写权限。这种变量的分离（或作用域）必须在多个层面上工作——当一个函数调用另一个函数时，相同的分离规则适用。
- en: 'CMake has two scopes:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: CMake有两个作用域：
- en: '`function()` are executed'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`function()`
- en: '`CMakeLists.txt` listfile in a nested directory is executed from the `add_subdirectory()`
    command'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在嵌套目录中执行的`CMakeLists.txt`清单文件从`add_subdirectory()`命令开始
- en: We'll cover the preceding commands later in this book, but first, we need to
    know how the concept of variable scope is implemented. When a nested scope is
    created, CMake simply fills it with copies of all the variables from the current
    scope. Subsequent commands will affect these copies. But as soon as the execution
    of the nested scope is completed, all copies are deleted and the original, parent
    scope is restored.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书稍后介绍前面的命令，但首先，我们需要了解作用域概念是如何实现的。当创建一个嵌套作用域时，CMake简单地用当前作用域的所有变量的副本填充它。随后的命令将影响这些副本。但一旦嵌套作用域的执行完成，所有的副本都被删除，并恢复原始的父作用域。
- en: 'Let''s consider the following scenario:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下场景：
- en: The parent scope sets the `VAR` variable to `ONE`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父作用域将`VAR`变量设置为`ONE`。
- en: The nested scope starts and `VAR` is printed to console.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嵌套作用域开始，并将`VAR`打印到控制台。
- en: The `VAR` variable is set to `TWO`, and `VAR` is printed to the console.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VAR`变量被设置为`TWO`，并将`VAR`打印到控制台。'
- en: The nested scope ends, and `VAR` is printed to the console.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嵌套作用域结束，并将`VAR`打印到控制台。
- en: 'The console''s output will look like this: `ONE`, `TWO`, `ONE`. This is because
    the copied `VAR` variable is discarded after the nested scope ends.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台的输出将如下所示：`ONE`，`TWO`，`ONE`。这是因为嵌套作用域结束后，复制的`VAR`变量被丢弃。
- en: How the concept of scope works in CMake has interesting implications that aren't
    that common in other languages. If you unset (`unset()`) a variable created in
    the parent scope while executing in a nested scope, it will disappear, but only
    in the nested scope. When the nested scope is completed, the variable is restored
    to its previous value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在CMake中作用域的概念如何工作有着有趣的暗示，这在其他语言中并不常见。如果你在一个嵌套作用域中执行时取消设置（`unset()`）了在父作用域中创建的变量，它将消失，但仅在嵌套作用域中。当嵌套作用域完成后，变量会恢复到其原来的值。
- en: This brings us to the behavior of variable referencing and the `${}` syntax.
    Whenever we try to access the normal variable, CMake will search for the variables
    from the current scope, and if the variable with such a name is defined, it will
    return its value. So far, so good. However, when CMake can't find a variable with
    that name (for example, if it didn't exist or was unset (`unset()`)), it will
    search through the cache variables and return a value from there if a match is
    found.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们想到了变量引用和`${}`语法的的行为。无论何时我们尝试访问普通变量，CMake都会从当前作用域搜索变量，如果定义了这样一个名字的变量，它会返回它的值。到目前为止，一切都好。然而，当CMake找不到这个名字的变量（例如，如果它不存在或被取消设置（`unset()`）），它将搜索缓存变量，并在找到匹配项时返回那里的值。
- en: That's a possible gotcha if we have a nested scope calling `unset()`. Depending
    on where we reference that variable – in the inner or the outer scope – we'll
    be accessing the cache or the original value.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在嵌套作用域中调用`unset()`，这可能是一个潜在的陷阱。取决于我们引用那个变量的位置——在内部还是外部作用域——我们将访问缓存或原始值。
- en: 'But what can we do if we really need to change the variable in the calling
    (parent) scope? CMake has a `PARENT_SCOPE` flag you can add at the end of the
    `set()` and `unset()` commands:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们真的需要在调用（父）作用域中更改变量，该怎么办呢？CMake有一个`PARENT_SCOPE`标志，你可以在`set()`和`unset()`命令的末尾添加：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That workaround is a bit limited, as it doesn't allow accessing variables more
    than one level up. Another thing worth noting is the fact that using `PARENT_SCOPE`
    doesn't change variables in the current scope.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变通方法有点局限，因为它不允许访问超过一级的变量。值得注意的是，使用`PARENT_SCOPE`并不会改变当前作用域中的变量。
- en: 'Let''s see how variable scope works in practice and consider the following
    example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际中变量作用域是如何工作的，并考虑以下示例：
- en: chapter02/04-scope/CMakeLists.txt
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02/04-scope/CMakeLists.txt
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We set the global variable, `V`, to `1`, and then we call the `Outer` function;
    then set `V` to `2` and call the `Inner` function, and then set `V` to `3`. After
    every step, we print the variable to the console:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将全局变量`V`设置为`1`，然后调用`Outer`函数；然后将`V`设置为`2`并调用`Inner`函数，然后将`V`设置为`3`。在每一步之后，我们都将变量打印到控制台：
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we explained previously, as we go deeper into the functions, the variable
    values are copied to the nested scope, but as we exit the scope, their original
    value is restored.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前解释的，当我们深入函数时，变量值会被复制到嵌套作用域中，但当我们退出作用域时，它们的原始值会被恢复。
- en: 'What would the output be if we changed the `set()` command of the `Inner` function
    to operate in the parent scope: `set(V 3 PARENT_SCOPE)`?'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更改`Inner`函数的`set()`命令以在父级作用域中操作：`set(V 3 PARENT_SCOPE)`，输出会是什么？
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We affected the scope of the `Outer` function, but not the scope of the `Inner`
    function or the global scope!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们影响了`Outer`函数的作用域，但没有影响`Inner`函数或全局作用域！
- en: The CMake documentation also mentions that CMake scripts bind variables in one
    directory scope (which is a bit redundant, as the only command that effectively
    creates a directory scope, `add_subdirectory()`, isn't allowed in scripts).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如CMake文档中提到的，CMake脚本在单个目录作用域中绑定变量（这有点冗余，因为唯一有效地创建目录作用域的命令，`add_subdirectory()`，在脚本中不允许）。
- en: Since all variables are stored as strings, CMake has to take a more creative
    approach to more complex data structures such as *lists*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有变量都存储为字符串，CMake不得不采取更具创意的方法来处理更复杂的数据结构，如*列表*。
- en: Using lists
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用列表
- en: 'To store a `;`) as a delimiter: `a;list;of;5;elements`. You can escape a semicolon
    in an element with a backslash, like so: `a\;single\;element`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储`;`)作为分隔符：`a;list;of;5;elements`。您可以在元素中用反斜杠转义分号：`a\;single\;element`。
- en: 'To create a list, we can use the `set()` command: `set(myList a list of five
    elements)`. Because of how lists are stored, the following commands will have
    exactly the same effect:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个列表，我们可以使用`set()`命令：`set(myList a list of five elements)`。由于列表的存储方式，以下命令将具有完全相同的效果：
- en: '`set(myList "a;list;of;five;elements")`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set(myList "a;list;of;five;elements")`'
- en: '`set(myList a list "of;five;elements")`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set(myList a list "of;five;elements")`'
- en: 'CMake automatically unpacks lists in unquoted arguments. By passing an unquoted
    `myList` reference, we effectively send more arguments to the command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: CMake会自动在未引用的参数中解包列表。通过传递一个未引用的`myList`引用，我们实际上向命令发送了更多参数：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `message()` command will receive here six arguments: "`the list is:`",
    "`a`", "`list`", "`of`", "`five`", "`elements`". This may have unintended consequences,
    as the output will be printed without any additional spaces between the arguments:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`message()`命令将接收六个参数："`the list is:`"，"`a`"，"`list`"，"`of`"，"`five`"，"`elements`"。这将导致意想不到的后果，因为输出将不带任何额外空格打印参数之间：'
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, this is a very simple mechanism, and it should be used carefully.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是一个非常简单的机制，应该谨慎使用。
- en: 'CMake offers a `list()` command that provides a multitude of subcommands to
    read, search, modify, and order lists. Here''s a short summary:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了一个`list()`命令，该命令提供了许多子命令来读取、搜索、修改和排序列表。以下是一个简要总结：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Most of the time, we don't really need to use lists in our projects. However,
    if you find yourself in that rare case where this concept would be convenient,
    you'll find a more in-depth reference of the `list()` command in the *Appendix*
    section.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们实际上并不需要在项目中使用列表。然而，如果你发现自己处于这种方便的概念的罕见情况，你会在*附录*部分找到`list()`命令的更深入的参考。
- en: Now that we know how to work with lists and variables of all kinds, let's shift
    our focus to controlling the execution flow and learn about control structures
    available in CMake.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何处理各种变量和列表，让我们将重点转移到控制执行流程上，并了解CMake中可用的控制结构。
- en: Understanding control structures in CMake
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解CMake中的控制结构
- en: 'The CMake Language wouldn''t be complete without **control structures**! Like
    everything else, they are provided in the form of a command, and they come in
    three categories: **conditional blocks**, **loops**, and **command definitions**.
    Control structures are executed in scripts and during buildsystem generation for
    projects.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在CMake语言中，**控制结构**是不可或缺的！与 everything else 一样，它们以命令的形式提供，并分为三个类别：**条件块**、**循环**和**命令定义**。控制结构在脚本中执行，在项目构建系统生成期间也执行。
- en: Conditional blocks
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件块
- en: 'The only conditional block supported in CMake is the humble `if()` command.
    All conditional blocks have to be closed with an `endif()` command, and they may
    have any number of `elseif()` commands and one optional `else()` command in this
    order:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: CMake支持的唯一条件块是谦逊的`if()`命令。所有条件块都必须用`endif()`命令关闭，它们可能有任意数量的`elseif()`命令和一个可选的`else()`命令，顺序如下：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As in many other imperative languages, the `if()`-`endif()` block controls
    which sets of commands will be executed:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多其他命令式语言一样，`if()`-`endif()`块控制哪些命令集将被执行：
- en: If the `<condition>` expression specified in the `if()` command is met, the
    first section will be executed.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`if()`命令中指定的`<条件>`表达式满足，将执行第一个部分。
- en: Otherwise, CMake will execute commands in the section belonging to the first
    `elseif()` command in this block that has met its condition.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，CMake将执行本块中第一个满足其条件的`elseif()`命令所属的部分中的命令。
- en: If there are no such commands, CMake will check if the `else()` command is provided
    and execute any commands in that section of the code.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有这样的命令，CMake将检查是否提供了`else()`命令并执行该代码部分的任何命令。
- en: If none of the above conditions are met, the execution continues after the `endif()`
    command.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果上述条件都不满足，执行将继续`endif()`命令之后进行。
- en: The provided `<condition>` expression is evaluated according to a very simple
    syntax.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的`<条件>`表达式根据一个非常简单的语法进行评估。
- en: The syntax for conditional commands
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件命令的语法
- en: The same syntax is valid for `if()`, `elseif()`, and `while()` commands.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`if()`、`elseif()`和`while()`命令，相同的语法是有效的。
- en: Logical operators
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'The `if()` conditions support the `NOT`, `AND`, and `OR` logical operators:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`if()`条件支持`NOT`、`AND`和`OR`逻辑运算符：'
- en: '`NOT <condition>`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOT <条件>`'
- en: '`<condition> AND <condition>`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<条件> AND <条件>`'
- en: '`<condition> OR <condition>`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<条件> OR <条件>`'
- en: 'Also, the nesting of conditions is possible with matching pairs of parentheses
    (`()`). As in all decent languages, the CMake Language respects the order of evaluation
    and starts from the innermost parenthesis:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，条件的嵌套是可能的，匹配的括号对（`()`）。像所有体面的语言一样，CMake语言尊重评估的顺序，并从最内层的括号开始：
- en: '`(<condition>) AND (<condition> OR (<condition>))`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(<条件>) AND (<条件> OR (<条件>))`'
- en: The evaluation of a string and a variable
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串和变量的评估
- en: 'For legacy reasons (because the variable reference (`${}`) syntax wasn''t always
    around), CMake will try to evaluate *unquoted arguments* as if they are *variable
    references*. In other words, using a plain variable name (for example, `VAR`)
    inside a condition is equal to writing `${VAR}`. Here''s an example for you to
    consider, and a *gotcha*:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因（因为变量引用（`${}`）语法并非一直存在），CMake会尝试将*未引用的参数*评估为变量引用。换句话说，在条件中使用普通的变量名（例如，`VAR`）等同于写`${VAR}`。下面是一个供你考虑的示例和一个*陷阱*：
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `if()` condition works in a bit of a convoluted way here – first, it will
    evaluate `${VAR2}` to `VAR1`, which is a recognized variable, and this in turn
    is evaluated to the `FALSE` string. Strings are considered Boolean true only if
    they equal any of the following constants (these comparisons are case insensitive):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`if()`条件在这里有点复杂——首先，它会评估`${VAR2}`为`VAR1`，这是一个已知的变量，进而将其评估为`FALSE`字符串。字符串只有等于以下常量之一时才被认为是布尔真（这些比较不区分大小写）：'
- en: '`ON`, `Y`, `YES`, or `TRUE`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ON`、`Y`、`YES`或`TRUE`'
- en: A non-zero number
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非零数字
- en: This brings us to the conclusion that the condition in the preceding example
    will evaluate to false.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们得出结论，前一个示例中的条件将评估为假。
- en: 'However, here''s another catch – what would be the evaluation of a condition
    with an unquoted argument with a name of a variable containing a value such as
    `BAR`? Consider the following code example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里还有一个陷阱——一个未引用的参数的条件评估会怎样，这个参数的名称包含一个值为`BAR`的变量呢？考虑以下代码示例：
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'According to what we have said so far, it would be `false`, as the `BAR` string
    doesn''t meet the criteria to evaluate to a Boolean `true` value. That''s unfortunately
    not the case, because CMake makes an exception when it comes to unquoted variable
    references. Unlike with quoted arguments, `FOO` won''t be evaluated to `BAR` to
    produce an `if("BAR")` statement (which would be `false`). Instead, CMake will
    only evaluate `if(FOO)` to `false` if it is any of the following constants (these
    comparisons are case insensitive):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们迄今为止的说法，这将是`false`，因为`BAR`字符串不符合评估为布尔`true`值的准则。不幸的是，这不是事实，因为CMake在未引用的变量引用方面做出了例外。与引号引用的参数不同，`FOO`不会被评估为`BAR`以产生`if("BAR")`语句（这将是`false`）。相反，CMake只会评估`if(FOO)`为`false`，如果它是以下常量之一（这些比较不区分大小写）：
- en: '`OFF`, `NO`, `FALSE`, `N`, `IGNORE`, `NOTFOUND`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OFF`，`NO`，`FALSE`，`N`，`IGNORE`，`NOTFOUND`'
- en: A string ending with `-NOTFOUND`
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`-NOTFOUND`结尾的字符串
- en: An empty string
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符串
- en: Zero
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零
- en: 'So, simply asking for an undefined variable will be evaluated to `false`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，简单地询问一个未定义的变量将被评估为`false`：
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, defining a variable beforehand changes the situation, and the condition
    is evaluated to `true`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事先定义一个变量会改变情况，条件被评估为`true`：
- en: '[PRE31]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you think that the behavior of unquoted arguments is confusing, wrap variable
    references in quoted arguments: `if ("${FOO}")`. This will result in argument
    evaluation before the provided argument is passed into the `if()` command, and
    the behavior will be consistent with the evaluation of strings.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为未引用的参数的行为令人困惑，请将变量引用用引号引起来：`if ("${FOO}")`。这将导致在提供的参数传递到`if()`命令之前先评估参数，行为将与字符串的评估一致。
- en: 'In other words, CMake assumes that the user is asking if the variable is defined
    (and is not explicitly `false`). Luckily, we can explicitly check that fact (and
    not worry about the value inside):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，CMake假设用户询问变量是否定义（并且不是显式`false`）。幸运的是，我们可以明确地检查这一点（而不必担心内部值）：
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Comparing values
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 比较值
- en: 'Comparison operations are supported with the following operators:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 比较操作支持以下操作符：
- en: '`EQUAL`, `LESS`, `LESS_EQUAL`, `GREATER`, and `GREATER_EQUAL`'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`EQUAL`，`LESS`，`LESS_EQUAL`，`GREATER`，和`GREATER_EQUAL`'
- en: 'They can be used to compare numeric values, like so:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以用来比较数字值，如下所示：
- en: '[PRE33]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The CMake documentation states that if one of the operands is not a number,
    the value will be `false`. But practical experiments show that the comparison
    of strings starting with a number works correctly: `if (20 EQUALS "20 GB")`.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 根据CMake文档，如果操作数之一不是数字，值将是`false`。但实际实验表明，以数字开头的字符串比较工作正确：`if (20 EQUALS "20
    GB")`。
- en: 'You can compare software versions following the `major[.minor[.patch[.tweak]]]`
    format by adding a `VERSION_` prefix to any of the operators:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过给任何操作符添加`VERSION_`前缀，按照`major[.minor[.patch[.tweak]]]`格式比较软件版本：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Omitted components are treated as zero, and non-integer version components truncate
    the compared string at that point.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 省略的组件被视为零，非整数版本组件在比较字符串时截断。
- en: 'For *lexicographic* string comparisons, we need to prepend an operator with
    the `STR` prefix (note the lack of an underscore):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*字典顺序*的字符串比较，我们需要在操作符前加上`STR`前缀（注意没有下划线）：
- en: '[PRE35]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We often need more advanced mechanisms than simple equality comparisons. Fortunately,
    CMake also supports `MATCHES` operator as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要比简单相等比较更高级的机制。幸运的是，CMake也支持`MATCHES`操作符，如下所示：
- en: '`<VARIABLE|STRING> MATCHES <regex>`'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`<变量名|字符串> MATCHES <正则表达式>`'
- en: Any matched groups are captured in `CMAKE_MATCH_<n>` variables.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 任何匹配的组都捕获在`CMAKE_MATCH_<n>`变量中。
- en: Simple checks
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简单检查
- en: We already mentioned one simple check, `DEFINED`, but there are others that
    simply return `true` if a condition is met.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了一个简单的检查，`DEFINED`，但还有其他简单的返回`true`如果条件满足的检查。
- en: 'We can check the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查以下内容：
- en: 'If a value is in a list: `<VARIABLE|STRING> IN_LIST <VARIABLE>`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值在列表中：`<变量名|字符串> IN_LIST <变量名>`
- en: 'If a command is available for invocation: `COMMAND <command-name>`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个命令可以被调用：`COMMAND <命令名>`
- en: 'If a CMake policy exists: `POLICY <policy-id>` (this is covered in [*Chapter
    3*](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078), *Setting Up Your First CMake
    Project*)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在CMake策略：`POLICY <策略ID>`（这在[第3章](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078)中有介绍，*设置你的第一个CMake项目*)
- en: 'If a CTest test was added with `add_test()`: `TEST <test-name>`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个CTest测试是用`add_test()`添加的：`TEST <测试名称>`
- en: 'If a build target is defined: `TARGET <target-name>`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果定义了一个构建目标：`TARGET <目标名称>`
- en: We'll explore build targets in [*Chapter 4*](B17205_04_Final_JC_ePub.xhtml#_idTextAnchor106),
    *Working with Targets*, but for now, let's just say that targets are logical units
    of a build process in a project created with a `add_executable()`, `add_library()`,
    or `add_custom_target()` command that has already been invoked.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](B17205_04_Final_JC_ePub.xhtml#_idTextAnchor106)，《使用目标》中探索构建目标，但现在，让我们说目标是为项目创建的逻辑构建过程中的单位，该项目已经调用了`add_executable()`、`add_library()`或`add_custom_target()`命令。
- en: Examining the filesystem
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查文件系统
- en: 'CMake provides many ways of working with files. We rarely need to manipulate
    them directly, and normally we''d rather use a high-level approach. For reference,
    this book will provide a short list of the file-related commands in the *Appendix*
    section. But most often, only the following operators will be needed (behavior
    is well defined only for absolute paths):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了许多处理文件的方法。我们很少需要直接操作它们，通常我们更愿意使用高层次的方法。为了参考，本书将在附录部分提供一个简短的与文件相关的命令列表。但大多数时候，只需要以下操作符（对于绝对路径的行为定义得很清楚）：
- en: '`EXISTS <path-to-file-or-directory>`: Checks if a file or directory exists'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXISTS <path-to-file-or-directory>`：检查文件或目录是否存在'
- en: This resolves symbolic links (it returns `true` if the target of the symbolic
    link exists).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了符号链接（如果符号链接的目标存在，则返回`true`）。
- en: '`<file1> IS_NEWER_THAN <file2>`: Checks which file is newer'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<file1> IS_NEWER_THAN <file2>`：检查哪个文件更新'
- en: This returns `true` if `file1` is newer than (or equal to) `file2` or if one
    of the two files doesn't exist.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`file1`比（或等于）`file2`新，或者这两个文件中的一个不存在，则返回`true`。
- en: '`IS_DIRECTORY path-to-directory`: Checks if a path is a directory'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IS_DIRECTORY path-to-directory`：检查一个路径是否是目录'
- en: '`IS_SYMLINK file-name`: Checks if a path is a symbolic link'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IS_SYMLINK file-name`：检查一个路径是否是符号链接'
- en: '`IS_ABSOLUTE path`: Checks if a path is absolute'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IS_ABSOLUTE path`：检查一个路径是否是绝对的'
- en: Loops
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'Loops in CMake are fairly straightforward – we can use either `while()` or
    `foreach()` to repeatedly execute the same set of commands. Both of these commands
    support loop control mechanisms:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: CMake中的循环相当直接——我们可以使用`while()`或`foreach()`来反复执行相同的命令集。这两个命令都支持循环控制机制：
- en: The `break()` loop stops the execution of the remaining block and breaks from
    the enclosing loop.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break()`循环停止剩余块的执行，并从外层循环中断。'
- en: The `continue()` loop stops the execution of the current iteration and starts
    at the top of the next one.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`continue()`循环停止当前迭代的执行，并从下一个开始。'
- en: While
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当
- en: 'The loop block is opened with a `while()` command and closed with an `endwhile()`
    command. Any enclosed commands will be executed as long as the `<condition>` expression
    provided in `while()` is `true`. The syntax for phrasing the condition is the
    same as for the `if()` command:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 循环块用`while()`命令打开，用`endwhile()`命令关闭。只要`while()`中提供的`<condition>`表达式为`true`，任何包含的命令都将执行。表述条件的语法与`if()`命令相同：
- en: '[PRE36]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You probably guessed that – with some additional variables – the `while` loop
    can replace a `for` loop. Actually, it's way easier to use a `foreach()` loop
    for that – let's take a look.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能猜到了——通过一些额外的变量——`while`循环可以替代`for`循环。实际上，使用`foreach()`循环要容易得多——让我们来看看。
- en: Foreach loops
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: foreach循环
- en: 'A foreach block comes in a few variants that execute enclosed commands for
    each value. Like other blocks, it has opening and closing commands: `foreach()`
    and `endforeach()`.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: foreach块有几个变体，为每个值执行包含的命令。与其他块一样，它有`foreach()`和`endforeach()`命令。
- en: 'The simplest form of `foreach()` is meant to provide a C++-style `for` loop:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach()`的最简单形式旨在提供C++风格的`for`循环：'
- en: '[PRE37]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'CMake will iterate from `0` to `<max>` (inclusive). If we need more control,
    we can use the second variant, providing `<min>`, `<max>`, and, optionally, `<step>`.
    All arguments must be nonnegative integers. Also, `<min>` has to be smaller than
    `<max>`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: CMake将从`0`迭代到`<max>`（包括）。如果我们需要更多的控制，可以使用第二种变体，提供`<min>`、`<max>`，可选地提供`<step>`。所有参数必须是非负整数。此外，`<min>`必须小于`<max>`：
- en: '[PRE38]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, `foreach()` shows its true colors when it is working with lists:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当它处理列表时，`foreach()`显示了它的真正颜色：
- en: '[PRE39]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'CMake will take elements from all of the provided `<lists>` list variables,
    followed by all of the explicitly stated `<items>` values, and store them in `<loop
    variable>`, executing `<commands>` for every item, one by one. You can choose
    to provide only lists, only values, or both:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: CMake将取所有提供的`<lists>`列表变量的元素，然后是所有明确声明的`<items>`值，并将它们存储在`<loop variable>`中，一次执行`<commands>`中的每一个项目。你可以选择只提供列表、只提供值，或者两者都提供：
- en: chapter02/06-loops/foreach.cmake
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02/06-loops/foreach.cmake
- en: '[PRE40]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding code will print the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将输出以下内容：
- en: '[PRE41]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or, we can use a short version (skipping the `IN` keyword) for the same result:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用简短版本（省略 `IN` 关键字）得到相同的结果：
- en: '[PRE42]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since version 3.17, `foreach()` has learned how to zip lists (`ZIP_LISTS`):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本3.17开始，`foreach()` 学会了如何压缩列表（`ZIP_LISTS`）：
- en: '[PRE43]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Zipping lists means simply iterating through multiple lists and working on
    respective items with the same index. Let''s look at an example:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩列表意味着简单地遍历多个列表，并对具有相同索引的相应项目进行操作。让我们看一个例子：
- en: chapter02/06-loops/foreach.cmake
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02/06-loops/foreach.cmake
- en: '[PRE44]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'CMake will create a `num_<N>` variable for each list provided, which it will
    fill with items from each list. You can pass multiple `<loop_var>` variable names
    (one for every list) and each list will use a separate variable to store its items:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: CMake将为每个提供的列表创建一个 `num_<N>` 变量，并填充每个列表的项目。您可以传递多个 `<loop_var>` 变量名（每个列表一个），每个列表将使用单独的变量存储其项目：
- en: '[PRE45]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If the count of items differs between lists, CMake won't define variables for
    shorter ones.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表之间的项数不同，CMake不会为较短的列表定义变量。
- en: So, that's everything covered with regard to *loops*.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，关于*循环*的内容就讲到这里。
- en: Command definitions
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令定义
- en: 'There are two ways to define your own command: you can use the `macro()` command
    or the `function()` command. The easiest way to explain the differences between
    these commands is by comparing them to C-style preprocessor macros and actual
    C++ functions:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自己的命令有两种方法：可以使用 `macro()` 命令或 `function()` 命令。解释这些命令之间的区别最简单的方式是通过将它们与C语言风格的预处理器宏和实际的C++函数进行比较：
- en: A `macro()` command works more like a find-and-replace instruction than an actual
    subroutine call such as `function()`. Contrary to functions, macros don't create
    a separate entry on a call stack. This means that calling `return()` in a macro
    will return to the calling statement one level higher than it would for a function
    (possibly terminating the execution if we're already in the top scope).
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`macro()` 命令更像是一个查找和替换指令，而不是实际的子程序调用，如 `function()`。与函数相反，宏不会在调用栈上创建一个单独的条目。这意味着在宏中调用
    `return()` 将会返回到比函数中的 `return()` 高一个级别的调用语句（如果我们在最外层作用域中，可能会导致执行终止）。'
- en: The `function()` command creates a separate scope for local variables, unlike
    the `macro()` command, which works in the variable scope of a caller. This may
    lead to confusing results. Let's talk about these details in the next section.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function()` 命令为局部变量创建了一个单独的作用域，与 `macro()` 命令在工作域中的调用者不同。这可能会导致混淆的结果。我们在下一节讨论这些细节。'
- en: 'Both methods accept arguments that you can name and reference inside of a command
    block. Additionally, CMake allows you to access arguments passed in command calls
    with the following references:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都接受可以在命令块内部命名和引用的参数。此外，CMake允许您使用以下引用访问在命令调用中传递的参数：
- en: '`${ARGC}`: The count of arguments'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ARGC}`：参数的数量'
- en: '`${ARGV}`: A list of all arguments'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ARGV}`：所有参数的列表'
- en: '`${ARG0}`, `${ARG1}`, `${ARG2}`: The value of an argument at a specific index'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ARG0}`、`${ARG1}`、`${ARG2}`：特定索引处的参数值'
- en: '`${ARGN}`: A list of anonymous arguments that were passed by a caller after
    the last expected argument'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ARGN}`: 传递给调用者的一些匿名参数，在最后一个预期参数之后'
- en: Accessing a numeric argument with an index outside of the `ARGC` bounds is undefined
    behavior.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引访问超出 `ARGC` 范围的数字参数是未定义行为。
- en: If you decide to define a command with named arguments, every call has to pass
    all of them or it will be invalid.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定定义一个带有命名参数的命令，每个调用都必须传递它们全部，否则它将是无效的。
- en: Macros
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宏
- en: 'Defining a macro is similar to any other block:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 定义宏与其他块类似：
- en: '[PRE46]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: After this declaration, we may execute our macro by calling its name (function
    calls are case-insensitive).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在此声明之后，我们可以通过调用其名称来执行我们的宏（函数调用不区分大小写）。
- en: 'The following example highlights all of the problems relating to variable scopes
    in macros:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例突出了宏中变量作用域的所有问题：
- en: chapter02/08-definitions/macro.cmake
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02/08-definitions/macro.cmake
- en: '[PRE47]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here''s the output from this script:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此脚本的输出：
- en: '[PRE48]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'What happened? Despite explicitly setting `myVar` to `new value`, it didn''t
    affect the output for `message("argument: ${myVar}")`! This is because arguments
    passed to macros aren''t treated as real variables but rather as constant find-and-replace
    instructions.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '发生了什么事？尽管明确将 `myVar` 设置为 `new value`，但它并没有影响 `message("argument: ${myVar}")`
    的输出！这是因为传递给宏的参数不是作为真正的变量处理，而是作为常数的查找和替换指令。'
- en: On the other hand, the `myVar` variable in the global scope got changed from
    `first value` to `new value`. This behavior is called a *side effect* and is considered
    a bad practice, as it's hard to tell which variables might be affected by such
    a macro without reading it.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，全局作用域中的 `myVar` 变量从 `first value` 变为了 `new value`。这种行为被称为 *副作用*，并且被认为是坏实践，因为不阅读宏就很难知道哪个变量可能会受到此类宏的影响。
- en: I recommend using functions whenever you can, as it will probably save you a
    lot of headaches.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议尽可能多地使用函数，因为这可能会节省你很多头疼的问题。
- en: Functions
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: 'To declare a command as a function, follow this syntax:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个命令作为一个函数，请使用以下语法：
- en: '[PRE49]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: A function requires a name and optionally accepts a list of names of expected
    arguments. If a function call passes more arguments than were declared, the excess
    arguments will be interpreted as anonymous arguments and stored in the `ARGN`
    variable.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数需要一个名称，可选地接受一个预期参数的名称列表。如果函数调用传递的参数比声明的参数多，多余的参数将被解释为匿名参数并存储在 `ARGN` 变量中。
- en: As mentioned before, functions open their own scope. You can call `set()`, providing
    one of the named arguments of the function, and any change will be local to the
    function (unless `PARENT_SCOPE` is specified, as we discussed in the *How to correctly
    use the variable scope in CMake* section).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，函数打开它们自己的作用域。你可以调用 `set()`，提供函数的一个命名参数，任何更改都仅限于函数内部（除非指定了 `PARENT_SCOPE`，正如我们在
    *如何在 CMake 中正确使用变量作用域* 部分讨论的那样）。
- en: Functions follow the rules of the call stack, enabling returning to the calling
    scope with the `return()` command.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 函数遵循调用栈的规则，通过 `return()` 命令返回调用作用域。
- en: 'CMake sets the following variables for each function (these have been available
    since version 3.17):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 为每个函数设置了以下变量（这些变量自 3.17 版本以来一直可用）：
- en: '`CMAKE_CURRENT_FUNCTION`'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_FUNCTION`'
- en: '`CMAKE_CURRENT_FUNCTION_LIST_DIR`'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_FUNCTION_LIST_DIR`'
- en: '`CMAKE_CURRENT_FUNCTION_LIST_FILE`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_FUNCTION_LIST_FILE`'
- en: '`CMAKE_CURRENT_FUNCTION_LIST_LINE`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_FUNCTION_LIST_LINE`'
- en: 'Let''s take a look at these function variables in practice:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在实际中看看这些函数变量：
- en: chapter02/08-definitions/function.cmake
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02/08-definitions/function.cmake
- en: '[PRE50]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This prints the following output:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出以下输出：
- en: '[PRE51]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, the general syntax and concept of the functions is very similar
    to macros, but this time – it actually works.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，函数的一般语法和概念与宏非常相似，但这次——它实际上起作用了。
- en: The procedural paradigm in CMake
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CMake 中的过程式范例
- en: 'Let''s imagine for a second that we want to write some CMake code in the same
    way we would write a program in C++. We''ll make a `CMakeLists.txt` listfile that
    will call three defined commands that may call defined commands of their own:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设一下，我们想要以与在 C++ 中编写程序相同的方式编写一些 CMake 代码。我们将创建一个 `CMakeLists.txt` 列表文件，它将调用三个定义的命令，这些命令可能还会调用它们自己的定义命令：
- en: '![Figure 2.3 – A procedural call graph'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – 过程式调用图](img/Figure_2.3_B17205.jpg)'
- en: '](img/Figure_2.3_B17205.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.3_B17205.jpg)'
- en: Figure 2.3 – A procedural call graph
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 过程式调用图
- en: 'Writing in this procedural style is a bit of a problem in CMake – you are required
    to provide command definitions you''re planning to use ahead of time. The CMake
    parser will not have it any other way. Your code would look something like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CMake 中以这种过程式风格编写代码有点问题——你被迫提供你计划使用的命令定义。CMake 解析器别无选择。你的代码可能看起来像这样：
- en: '[PRE52]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What a nightmare! Everything is reversed! This code is very difficult to read
    as the most minuscule details are at the top of the file. A correctly structured
    piece of code lists the most general steps in the first subroutine, after which
    it provides the slightly more detailed subroutines, and pushes the most detailed
    steps to the very end of the file.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 多么噩梦般的场景！一切都被颠覆了！这段代码非常难以阅读，因为最微小的细节都放在了文件的最顶部。一段正确结构的代码首先在第一个子程序中列出最一般的步骤，然后提供稍微详细一些的子程序，并将最详细的步骤推到最后一个文件。
- en: 'There are solutions to this problem: moving command definitions to other files
    and partitioning scopes across directories (scoped directories will be explained
    in detail in [*Chapter 3*](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078), *Setting
    Up Your First CMake Project*). But there is also a solution that is simple and
    elegant: declaring an entry-point macro at the top of the file and calling it
    at the very end of the file:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有解决方案：将命令定义移动到其他文件并将作用域分区到目录之间（将在 [第 3 章](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078)
    中详细解释，*设置你的第一个 CMake 项目*）。但还有一个简单而优雅的解决方案：在文件顶部声明一个入口点宏，并在文件的最后调用它：
- en: '[PRE53]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: With this approach, our code is written with gradually narrowing scope, and
    because we're not actually calling the `main()` macro until the very end, CMake
    won't complain about the execution of undefined commands!
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们的代码是以逐渐缩小的范围编写的，并且因为我们实际上直到最后才调用`main()`宏，所以CMake不会抱怨未定义命令的执行！
- en: One last question remains – why use a macro over a recommended function? In
    this case, it's good to have unrestricted access to global variables, and since
    we're not passing any arguments to `main()`, we don't need to worry about the
    usual caveats.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题依然存在——为什么要在宏上而不是推荐函数上使用？在这种情况下，无限制访问全局变量是好的，由于我们没有向`main()`传递任何参数，所以我们不需要担心常见的警告。
- en: You'll find a simple example of this concept in the `chapter-02/09-procedural/CMakeLists.txt`
    listfile in the GitHub repository for this book.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书GitHub仓库中的`chapter-02/09-procedural/CMakeLists.txt`清单文件中找到这个概念的一个简单示例。
- en: A word on naming conventions
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于命名约定的一点说明
- en: 'Naming is famously hard in software development, but nevertheless, it''s very
    important to maintain a solution that is easy to read and understand. When it
    comes to CMake scripts and projects, we should follow the rules of the *clean
    code* approach, as we would with any software development solution:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，命名是以著称困难的，尽管如此，维持一个易于阅读和理解解决方案仍然非常重要。在CMake脚本和项目方面，我们应该遵循*干净代码*方法的规则，就像在任何一个软件开发解决方案方面一样：
- en: Follow a consistent naming style (`snake_case` is an accepted standard in the
    CMake community).
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循一致的命名风格（在CMake社区中，`snake_case`是被接受的标准化风格）。
- en: Use short but meaningful names (for example, avoid `func()`, `f()`, and suchlike).
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简短而有意义的名称（例如，避免`func()`、`f()`等）。
- en: Avoid puns and cleverness in your naming.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在你的命名中使用双关语和机智。
- en: Use pronounceable, searchable names that don't require mental mapping.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可以发音、可搜索的名称，不需要进行心智映射。
- en: Now that we know how to properly invoke the commands with the correct syntax,
    let's explore which commands will be the most beneficial to us to begin with.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何正确地使用正确的语法调用命令，那么让我们来探讨哪些命令最初对我们最有益。
- en: Useful commands
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用命令
- en: CMake offers many, many scripting commands that allow you to work with variables
    and the environment. Some of them are covered extensively in the *Appendix* section,
    for example, `list()`, `string()`, and `file()` (we'll leave these explanations
    there and concentrate on projects in the main chapters). Others, such as `find_...()`,
    fit better in chapters that talk about managing dependencies. In this section,
    we'll briefly cover the most useful commands for scripts.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了许多脚本命令，允许你与变量和环境交互。其中一些在*附录*部分有广泛的覆盖，例如`list()`、`string()`和`file()`（我们在这里解释这些命令，并在主章节集中精力于项目）。其他的，如`find_...()`，更适合在讨论管理依赖的章节中。在本节中，我们将简要介绍对脚本最有用的命令。
- en: The message() command
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`message()`命令'
- en: 'We already know and love our trusty `message()` command, which prints text
    to standard output. However, there''s a lot more to it than meets the eye. By
    providing a `MODE` argument, you can customize the style of the output, and in
    the case of an error, you can stop the execution of the code: `message(<MODE>
    "text")`.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道并喜欢我们可靠的`message()`命令，它将文本打印到标准输出。然而，它的内涵远不止所见。通过提供一个`MODE`参数，你可以自定义输出的样式，在出错的情况下，你可以停止代码的执行：`message(<MODE>
    "text")`。
- en: 'The recognized modes are as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 已识别的模式如下：
- en: '`FATAL_ERROR`: This stops processing and generation.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FATAL_ERROR`：这会停止处理和生成。'
- en: '`SEND_ERROR`: This continues processing, but skips generation.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEND_ERROR`：这会继续处理，但跳过生成。'
- en: '`WARNING`: This continues processing.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WARNING`：这会继续处理。'
- en: '`AUTHOR_WARNING`: A CMake warning. This continues processing.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTHOR_WARNING`：CMake警告。这会继续处理。'
- en: '`DEPRECATION`: This works accordingly if either of the `CMAKE_ERROR_DEPRECATED`
    or `CMAKE_WARN_DEPRECATED` variables are enabled.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEPRECATION`：如果启用了`CMAKE_ERROR_DEPRECATED`或`CMAKE_WARN_DEPRECATED`变量，这将相应地工作。'
- en: '`NOTICE` or omitted mode (default): This prints a message to `stderr` to attract
    the user''s attention.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOTICE`或省略模式（默认）：这会在`stderr`上打印一条消息，以吸引用户的注意。'
- en: '`STATUS`: This continues processing and is recommended for main messages for
    users.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATUS`：这会继续处理，并且建议用于主要用户信息。'
- en: '`VERBOSE`: This continues processing and should be used for more detailed information
    that usually isn''t very necessary.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VERBOSE`：这会继续处理，通常用于不必要太详细的更多信息。'
- en: '`DEBUG`: This continues processing and should contain any fine details that
    might be helpful when there''s an issue with a project.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG`：这会继续处理，并且应该包含在项目出现问题时可能有助于解决问题的任何详细信息。'
- en: '`TRACE`: This continues processing and is recommended to print messages during
    the project development. Usually, these sorts of messages would be removed before
    publishing the project.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRACE`：这会继续处理，并且在项目开发期间推荐打印消息。通常，这类消息在发布项目之前会被删除。'
- en: 'The following example stops execution after the first message:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在第一条消息后停止执行：
- en: chapter02/10-useful/message_error.cmake
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02/10-useful/message_error.cmake
- en: '[PRE54]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This means messages will be printed depending on the current log level (which
    is `STATUS` by default). We discussed how to change this in the previous chapter
    in the *Options for debugging and tracing* section. At that point, I promised
    to talk about debugging with `CMAKE_MESSAGE_CONTEXT`, so let''s get to it. Since
    then, we have acquired an understanding of three important pieces to this puzzle:
    lists, scopes, and functions.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着将根据当前日志级别（默认是`STATUS`）打印消息。我们在上一章的*调试和跟踪选项*部分讨论了如何更改此设置。在那部分，我承诺要谈论使用`CMAKE_MESSAGE_CONTEXT`进行调试，所以让我们开始吧。从那时起，我们已经了解了这个谜题的三个重要部分：列表、作用域和函数。
- en: 'When we enable a command-line flag, `cmake --log-context`, our messages will
    be decorated with dot-separated context and stored in the `CMAKE_MESSAGE_CONTEXT`
    list. Consider the following example:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启用一个命令行标志，`cmake --log-context`，我们的消息将被点分隔的上下文装饰，并存储在`CMAKE_MESSAGE_CONTEXT`列表中。考虑以下示例：
- en: chapter02/10-useful/message_context.cmake
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02/10-useful/message_context.cmake
- en: '[PRE55]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output of the preceding script will look like this:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 前面脚本的输出将如下所示：
- en: '[PRE56]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The initial scope of the function is copied from the parent scope (which already
    has one item in the list: `top`). The first command in `foo` adds a new item with
    the `foo` function name to `CMAKE_MESSAGE_CONTEXT`. The message is printed, and
    the function scope ends, discarding the local, copied variables, and the previous
    scope (without `foo`) is restored.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的初始作用域是从父作用域中复制的（父作用域中已经有一个列表项：`top`）。`foo`中的第一条命令向`CMAKE_MESSAGE_CONTEXT`中添加了一个新项，该项带有`foo`函数名称。打印消息，函数作用域结束，丢弃本地复制的变量，并恢复之前的范围（不包含`foo`）。
- en: This approach is useful with many nested functions in very complex projects.
    Hopefully, you won't ever need it, but I thought it is a really good example of
    how a function scope works in practice.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在非常复杂的项目中有很多嵌套函数时非常有用。希望您永远不需要它，但我觉得这是一个非常好的例子，展示了函数作用域在实际中是如何工作的。
- en: 'Another cool trick with `message()` is to add indentation to the `CMAKE_MESSAGE_INDENT`
    list (in exactly the same way as with `CMAKE_MESSAGE_CONTEXT`):'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`message()`的另一个酷炫技巧是向`CMAKE_MESSAGE_INDENT`列表中添加缩进（与`CMAKE_MESSAGE_CONTEXT`完全相同的方式）：'
- en: '[PRE57]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output from our scripts can then look a bit cleaner:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本的输出可以变得更加整洁：
- en: '[PRE58]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Since CMake doesn't offer any real debugger with breakpoints or other tools,
    the ability to produce clean log messages comes in very handy when things don't
    go exactly as planned.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CMake没有提供任何真正的带有断点或其他工具的调试器，因此在事情并不完全按计划进行时，生成干净的日志消息功能非常方便。
- en: The include() command
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`include()`命令'
- en: 'We can partition our CMake code into separate files to keep things ordered
    and, well, *separate*. Then, we can reference them from our parent listfile by
    calling `include()`, as shown in the following example:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将CMake代码分割到单独的文件中，以保持事物有序，嗯，*分离*。然后，我们可以通过调用`include()`从父列表文件中引用它们，如下例所示：
- en: '[PRE59]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If we provide a filename (a path with a `.cmake` extension), CMake will try
    to open and execute it. Note that no nested, separate scope will be created, so
    any changes to variables done in that file will affect the calling scope.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供一个文件名（带有`.cmake`扩展名的路径），CMake将尝试打开并执行它。请注意，不会创建嵌套的独立作用域，因此在该文件中对变量的任何更改都将影响调用作用域。
- en: CMake will raise an error if a file doesn't exist unless we specify that it
    is optional with the `OPTIONAL` keyword. If we need to know if `include()` was
    successful, we can provide a `RESULT_VARIABLE` keyword with the name of the variable.
    It will be filled with a full path to the included file on success or not found
    (`NOTFOUND`) on failure.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: CMake如果文件不存在将抛出一个错误，除非我们使用`OPTIONAL`关键字指定它是可选的。如果我们需要知道`include()`是否成功，我们可以提供带有变量名称的`RESULT_VARIABLE`关键字。在成功时，它将填充包含成功包含的文件的完整路径，或在失败时（`NOTFOUND`）不包含。
- en: 'When running in script mode, any relative paths will be resolved from the current
    working directory. To force searching in relation to the script itself, provide
    an absolute path:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 当以脚本模式运行时，任何相对路径都将从当前工作目录解析。要强制在脚本本身的关系中搜索，请提供一个绝对路径：
- en: '[PRE60]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If we don't provide a path but do provide the name of a module (without `.cmake`
    or otherwise), CMake will try to find a module and include it. CMake will search
    for a file with the name of `<module>.cmake` in `CMAKE_MODULE_PATH` and then in
    the CMake module directory.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有提供路径，但是提供了模块的名称（不带`.cmake`或其他），CMake将尝试查找模块并将其包含进来。CMake将在`CMAKE_MODULE_PATH`中搜索名为`<模块>.cmake`的文件，然后在其模块目录中搜索。
- en: The include_guard() command
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`include_guard()`命令'
- en: When we include files that have side effects, we might want to restrict them
    so that they're only included once. This is where `include_guard([DIRECTORY|GLOBAL])`
    comes in.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们包含具有副作用的文件时，我们可能希望限制它们，使它们只被包含一次。这就是`include_guard([DIRECTORY|GLOBAL])`发挥作用的地方。
- en: Put `include_guard()` at the top of the included file. When CMake encounters
    it for the first time, it will make a note of this fact in the current scope.
    If the file gets included again (maybe because we don't control all of the files
    in our project), it won't be processed any further.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 将`include_guard()`放在被包含文件的顶部。当CMake首次遇到它时，它将在当前作用域中记录这一事实。如果文件再次被包含（也许是因为我们无法控制我们项目中的所有文件），它将不再被进一步处理。
- en: If we want to protect against inclusion in unrelated function scopes that won't
    share variables with each other, we should provide `DIRECTORY` or `GLOBAL` arguments.
    As the names suggest, the `DIRECTORY` keyword will apply the protection within
    the current directory and below, and the `GLOBAL` keyword applies the protection
    to the whole build.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要防止在不相关的函数作用域中包含，这些作用域不会共享变量，我们应该提供`DIRECTORY`或`GLOBAL`参数。正如这些名称所暗示的，`DIRECTORY`关键字将在当前目录及其子目录内应用保护，而`GLOBAL`关键字将对整个构建过程应用保护。
- en: The file() command
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`file()`命令'
- en: 'To give you an idea of what you can do with CMake scripts, let''s take a quick
    glance at the most useful variants of the file manipulation command:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解您可以用CMake脚本做什么，让我们快速浏览一下文件操作命令的最有用变体：
- en: '[PRE61]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In short, the `file()` command will let you read, write, and transfer files,
    and work with the filesystem, file locks, paths, and archives, all in a system-independent
    manner. Please see the *Appendix* section for more details.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`file()`命令将让您以系统无关的方式读取、写入和传输文件，以及与文件系统、文件锁、路径和存档进行交互。请参阅*附录*部分以获取更多详细信息。
- en: The execute_process() command
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`execute_process()`命令'
- en: 'Every now and then, you''ll need to resort to using tools available in the
    system (after all, CMake is primarily a buildsystem generator). CMake offers a
    command for this purpose: you can use `execute_process()` to run other processes
    and collect their output. This command is a great fit for scripts, and it can
    also be used in projects during the configuration stage. Here''s the general form
    of the command:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 时不时地，您需要使用系统可用的工具（毕竟，CMake主要是构建系统生成器）。CMake为此提供了一个命令：您可以使用`execute_process()`来运行其他进程并收集它们的输出。这个命令非常适合脚本，也可以在配置阶段项目中使用。以下是该命令的一般形式：
- en: '[PRE62]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: CMake will use the API of the operating system to create a child process (so,
    shell operators such as `&&`, `||`, and `>` won't work). However, you can still
    chain commands and pass the output of one to another simply by providing the `COMMAND
    <cmd> <arguments>` arguments more than once.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: CMake将使用操作系统的API来创建子进程（因此，像`&&`，`||`和`>`这样的shell操作符将不起作用）。然而，您仍然可以通过多次提供`COMMAND
    <命令> <参数>`参数来链接命令，并将一个的输出传递给另一个。
- en: Optionally, you may use a `TIMEOUT <seconds>` argument to terminate the process
    if it hasn't finished the task within the required limit, and you can set the
    `WORKING_DIRECTORY <directory>` as you need.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，您可以使用`TIMEOUT <秒>`参数来终止进程，如果它没有在规定的时间内完成任务，并且您可以根据需要设置`WORKING_DIRECTORY
    <目录>`。
- en: 'The exit codes of all tasks can be collected in a list by providing `RESULTS_VARIABLE
    <variable>` arguments. If you''re only interested in the result of the last executed
    command, use the singular form: `RESULT_VARIABLE <variable>`.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 所有任务的退出代码可以通过提供`RESULTS_VARIABLE <变量>`参数来收集在列表中。如果您只对最后执行的命令的结果感兴趣，请使用单数形式：`RESULT_VARIABLE
    <变量>`。
- en: 'To collect the output, CMake provides two arguments: `OUTPUT_VARIABLE` and
    `ERROR_VARIABLE` (which are used in a similar fashion). If you would like to merge
    both `stdout` and `stderr`, use the same variable for both arguments.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 为了收集输出，CMake提供了两个参数：`OUTPUT_VARIABLE`和`ERROR_VARIABLE`（这两个参数用法相似）。如果您想合并`stdout`和`stderr`，请为这两个参数使用同一个变量。
- en: Remember that when writing projects for other users, you should make sure that
    the command you're planning to use is available on the platforms you claim to
    support.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当为其他用户编写项目时，您应该确保您打算使用的命令在您声称支持的平台上是可用的。
- en: Summary
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter opened the door to actual programming with CMake – you're now able
    to write great, informative comments and invoke built-in commands, and you understand
    how to correctly provide all kinds of arguments to them. This knowledge alone
    will help you understand the unusual syntax of CMake listfiles that you may have
    seen in other projects.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 本章打开了使用CMake进行实际编程的大门——你现在能够编写伟大的、富有信息性的注释和调用内置命令，并理解如何正确地为它们提供各种参数。这个知识本身将帮助您理解CMake列表文件中您可能在其他项目中看到的异常语法。
- en: Next, we covered variables in CMake – specifically, how to reference, set, and
    unset normal, cache, and environment variables. We took a deep dive into how directory
    and function scopes work, and we discussed the issues (and their workarounds)
    relating to nested scopes.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讲解了CMake中的变量——具体来说，是如何引用、设置和取消设置普通、缓存和环境变量。我们深入探讨了目录和函数作用域是如何工作的，并讨论了与嵌套作用域相关的问题（及其解决方法）。
- en: We also covered lists and control structures. We discussed the syntax of conditions,
    their logical operations, the evaluation of unquoted arguments, and strings and
    variables. We learned how to compare values, do simple checks, and examine the
    state of the files in the system. This allows us to write conditional blocks and
    while loops. And while we were talking about loops, we also grasped the syntax
    of foreach loops.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讲解了列表和控制结构。我们讨论了条件的语法、它们的逻辑操作、未引用参数的评估以及字符串和变量。我们学习了如何比较值、进行简单检查以及查看系统文件的状态。这使我们能够编写条件块和while循环。在谈论循环的时候，我们也掌握了foreach循环的语法。
- en: I'm sure that knowing how to define your own commands with macro and function
    statements will help you write cleaner code in a more procedural style. We also
    shared a few ideas about how to structure our code better and come up with more
    readable names.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信了解如何使用宏和函数语句定义自己的命令将帮助您以更程序化的风格编写更干净的代码。我们还分享了一些关于如何更好地组织代码和提出更易读名称的想法。
- en: Finally, we were formally introduced to the `message()` command and its multiple
    log levels. We also studied how to partition and include listfiles, and we discovered
    a few other useful commands. I feel confident that with this material, we are
    ready to tackle the next chapter and write our first project in CMake.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们正式介绍了`message()`命令及其多个日志级别。我们还学习了如何分割和包含列表文件，发现了几种其他有用的命令。我相信有了这些材料，我们准备好迎接下一章，并在CMake中编写我们的第一个项目。
- en: Further reading
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章涵盖的主题，您可以参考以下内容：
- en: '*Clean Code: A Handbook of Agile Software Craftsmanship* (Robert C. Martin):
    [https://amzn.to/3cm69DD](https://amzn.to/3cm69DD)'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整洁的代码：敏捷软件工艺手册**（Robert C. Martin）：[https://amzn.to/3cm69DD](https://amzn.to/3cm69DD)'
- en: '*Refactoring: Improving the Design of Existing Code* (Martin Fowler): [https://amzn.to/3cmWk8o](https://amzn.to/3cmWk8o)'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构：改善现有代码的设计**（Martin Fowler）：[https://amzn.to/3cmWk8o](https://amzn.to/3cmWk8o)'
- en: '*Which comments in your code ARE GOOD?* (Rafał Świdzinski): [https://youtu.be/4t9bpo0THb8](https://youtu.be/4t9bpo0THb8)'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你的代码中哪些注释是好的？**（Rafał Świdzinski）：[https://youtu.be/4t9bpo0THb8](https://youtu.be/4t9bpo0THb8)'
- en: '*What''s the CMake syntax to set and use variables?* (StackOverflow): [https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables](https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables)'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMake中设置和使用变量的语法是什么？**（StackOverflow）：[https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables](https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables)'
