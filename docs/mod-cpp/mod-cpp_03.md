# 第三章：使用函数

函数是 C++的基础设施；代码包含在函数中，要执行该代码，您必须调用函数。C++在定义和调用函数的方式上非常灵活：您可以定义具有固定数量参数或可变数量参数的函数；您可以编写通用代码，以便相同的代码可以用于不同的类型；甚至可以编写具有可变数量类型的通用代码。

# 定义 C++函数

在最基本的层面上，函数具有参数，具有操作参数的代码，并返回一个值。C++为您提供了几种确定这三个方面的方法。在接下来的部分中，我们将从声明的左侧到右侧涵盖 C++函数的这些部分。函数也可以是**模板化**的，但这将留到以后的部分。

# 声明和定义函数

函数必须被定义一次，但通过重载，您可以有许多具有相同名称但参数不同的函数。使用函数的代码必须能够访问函数的名称，因此它需要访问函数的定义（例如，函数在源文件中较早地定义）或函数的声明（也称为函数原型）。编译器使用原型来对调用代码进行类型检查，以确保*调用代码*调用函数时使用了正确的类型。

通常，库被实现为单独的编译库文件，并且库函数的原型在头文件中提供，以便许多源文件可以通过包含头文件来使用这些函数。但是，如果您知道函数名称、参数和返回类型，您可以在自己的文件中输入原型。

无论您做什么，您只是为编译器提供调用函数的表达式进行类型检查的信息。链接器负责在库中定位函数，并将代码复制到可执行文件中，或者设置基础设施以从共享库中使用函数。包含库的头文件并不意味着您将能够使用该库中的函数，因为在标准 C++中，头文件没有包含函数的库的信息。

Visual C++提供了一个名为`pragma`的`comment`，它可以与`lib`选项一起使用，作为向链接器发送消息以链接特定库的指令。因此，在头文件中使用`#pragma comment(lib, "mylib")`将告诉链接器链接`mylib.lib`。通常，最好使用项目管理工具，如**nmake**或**MSBuild**，以确保正确的库被链接到项目中。

C 运行时库的大部分是这样实现的：函数被编译为静态库或动态链接库，函数原型在头文件中提供。您在链接器命令行中提供库，并且通常会包含库的头文件，以便函数原型对编译器可用。只要链接器知道库的存在，您就可以在代码中输入原型（并将其描述为*外部链接*，以便编译器知道函数在其他地方定义）。这可以避免将一些大文件包含到源文件中，这些文件大多会包含您不会使用的函数原型。

然而，C++标准库的大部分是在头文件中实现的，这意味着这些文件可能会非常大。您可以通过将这些头文件包含在预编译头文件中来节省编译时间。

到目前为止，在本书中，我们使用了一个源文件，因此所有函数都在与它们使用的相同文件中定义，并且我们在调用函数之前定义了函数，也就是说，函数在调用它的代码*上方*定义。只要函数原型在函数调用之前定义，您就不必在使用函数之前定义函数：

```cpp
    int mult(int, int); 

    int main() 
    { 
        cout << mult(6, 7) << endl; 
        return 0; 
    } 

    int mult(int lhs, int rhs) 
    { 
        return lhs * rhs; 
    }
```

`mult`函数在`main`函数之后定义，但这段代码将编译，因为在`main`函数之前给出了原型。这被称为**前向声明**。原型不必具有参数名称。这是因为编译器只需要知道参数的类型，而不需要它们的名称。然而，由于参数名称应该是自说明的，通常最好给出参数名称，以便可以看到函数的目的。

# 指定链接

在上一个例子中，函数是在同一个源文件中定义的，因此具有*内部链接*。如果函数是在另一个文件中定义的，原型将具有*外部链接*，因此原型必须这样定义：

```cpp
    extern int mult(int, int);        // defined in another file
```

`extern`关键字是你可以添加到函数声明中的许多指定符之一。例如，`static`指定符可以用于原型，表示函数具有内部链接，名称只能在当前源文件中使用。在前面的例子中，在原型中将函数标记为`static`是合适的。

```cpp
    static int mult(int, int);        // defined in this file
```

你还可以将函数声明为`extern "C"`，这会影响函数名在目标文件中的存储方式。这对库很重要，不久将会涉及到。

# 内联

如果函数计算的值可以在编译时计算，可以在声明的左侧使用`constexpr`标记它，以指示编译器可以通过在编译时计算值来优化代码。如果函数值可以在编译时计算，这意味着函数调用中的参数必须在编译时已知，因此它们必须是文字。函数还必须是单行。如果不满足这些限制，那么编译器可以自由地忽略该指定符。

相关的是`inline`指定符。这可以放在函数声明的左侧，作为对编译器的建议，当其他代码调用函数时，编译器不应该在内存中插入一个跳转到函数的指令（以及创建一个堆栈帧），而是应该将实际代码的副本放在调用函数中。同样，编译器可以自由地忽略这个指定符。

# 确定返回类型

函数可以被编写为运行一个例程而不返回值。如果是这种情况，必须指定函数返回`void`。在大多数情况下，函数将返回一个值，即使只是表示函数已正确完成。没有要求调用函数获取返回值或对其进行任何操作。调用函数可以简单地忽略返回值。

有两种方法可以指定返回类型。第一种方法是在函数名之前给出类型。这是迄今为止大多数示例中使用的方法。第二种方法称为**尾返回类型**，要求在函数名之前将`auto`作为返回类型，并使用`->`语法在参数列表后给出实际的返回类型：

```cpp
    inline auto mult(int lhs, int rhs) -> int 
    { 
        return lhs * rhs; 
    }
```

这个函数非常简单，可以作为内联的一个很好的候选。左侧的返回类型是`auto`，这意味着实际的返回类型在参数列表后指定。`-> int`表示返回类型是`int`。这种语法与在左侧使用`int`具有相同的效果。当函数是模板化的，返回类型可能不明显时，这种语法是有用的。

在这个简单的例子中，你可以完全省略返回类型，只需在函数名的左侧使用`auto`。这种语法意味着编译器将从实际返回的值推断返回类型。显然，编译器只能从函数体知道返回类型，因此你不能为这样的函数提供原型。

最后，如果函数根本不返回（例如，如果它进入一个永无止境的循环来轮询某个值），您可以使用 C++11 属性`[[noreturn]]`标记它。编译器可以使用此属性编写更有效的代码，因为它知道不需要提供返回值的代码。

# 命名函数

一般来说，函数名称对变量有相同的规则：它们必须以字母或下划线开头，不能包含空格或其他标点符号。遵循自我描述代码的一般原则，您应该根据函数的功能命名函数。有一个例外，这些是用于为运算符提供重载的特殊函数（这些函数大多是标点符号）。这些函数的名称采用`operatorx`的形式，其中`x`是您在代码中将使用的运算符。后面的部分将解释如何使用全局函数实现运算符。

运算符是重载的一个例子。您可以重载任何函数，也就是说，使用相同的名称但提供具有不同参数类型或不同数量参数的实现。

# 函数参数

函数可能没有参数，在这种情况下，函数定义为一对空括号。函数定义必须在括号之间给出参数的类型和名称。在许多情况下，函数将具有固定数量的参数，但您可以编写具有可变数量参数的函数。您还可以为一些参数定义默认值，从而提供一个根据传递给函数的参数数量进行重载的函数。可变参数列表和默认参数将在后面介绍。

# 指定异常

函数也可以标记是否会抛出异常。有关异常的更多细节将在第七章 *诊断和调试* 中给出，但您需要了解两种语法。

早期版本的 C++允许您以三种方式在函数上使用`throw`说明符：首先，您可以提供一个逗号分隔的异常类型列表，这些异常可能由函数中的代码抛出；其次，您可以提供一个省略号（`...`），这意味着函数可能抛出任何异常；第三，您可以提供一对空括号，这意味着函数不会抛出异常。语法如下：

```cpp
    int calculate(int param) throw(overflow_error) 
    { 
        // do something which potentially may overflow 
    }
```

C++11 已经弃用了`throw`说明符，主要是因为指示异常类型的能力并不实用。然而，发现指示不会抛出异常的`throw`版本是有用的，因为它使编译器能够通过提供不处理异常的代码基础设施来优化代码。C++11 保留了这种行为，使用`noexcept`说明符：

```cpp
    // C++11 style: 
    int increment(int param) noexcept 
    { 
        // check the parameter and handle overflow appropriately 
    }
```

# 函数体

确定返回类型、函数名称和参数后，您需要定义函数的主体。函数的代码必须出现在一对大括号（`{}`）之间。如果函数返回一个值，那么函数必须至少有一行（函数中的最后一行）带有`return`语句。这必须返回适当的类型或可以隐式转换为函数返回类型的类型。如前所述，如果函数声明为返回`auto`，那么编译器将推断返回类型。在这种情况下，所有的`return`语句*必须*返回相同的类型。

# 使用函数参数

当调用函数时，编译器会检查函数的所有重载，以找到与调用代码中的参数匹配的函数。如果没有完全匹配，则会执行标准和用户定义的类型转换，因此调用代码提供的值可能与参数的类型不同。

默认情况下，参数是按值传递的，并且会进行复制，这意味着参数在函数中被视为局部变量。函数的编写者可以决定通过指针或 C++引用将参数传递给引用。**按引用传递**意味着调用代码中的变量可以被函数修改，但这可以通过使参数`const`来控制，这样按引用传递的原因是为了防止进行（可能昂贵的）复制。内置数组始终作为指向数组第一项的指针传递。编译器将在需要时创建临时对象。例如，当参数是`const`引用时，调用代码传递文字时，将创建临时对象，并且仅可用于函数中的代码：

```cpp
    void f(const float&); 
    f(1.0);              // OK, temporary float created 
    double d = 2.0; 
    f(d);                // OK, temporary float created
```

# 传递初始化程序列表

如果可以将初始化程序列表转换为参数的类型，则可以将初始化程序列表作为参数传递。例如：

```cpp
    struct point { int x; int y; }; 

    void set_point(point pt); 

    int main() 
    { 
        point p; 
        p.x = 1; p.y = 1; 
        set_point(p); 
        set_point({ 1, 1 });  
        return 0; 
    }
```

此代码定义了一个具有两个成员的结构。在`main`函数中，在堆栈上创建了`point`的新实例，并通过直接访问成员对其进行初始化。然后将该实例传递给具有`point`参数的函数。由于`set_point`的参数是按值传递的，编译器会在函数的堆栈上创建结构的副本。`set_point`的第二次调用也是如此：编译器将在函数的堆栈上创建一个临时的`point`对象，并使用初始化程序列表中的值对其进行初始化。

# 使用默认参数

有时您可能有一个或多个参数的值是如此频繁使用，以至于您希望它们被视为参数的默认值，同时仍然可以允许调用者在必要时提供不同的值。为此，您可以在定义的参数列表中提供默认值：

```cpp
    void log_message(const string& msg, bool clear_screen = false) 
    { 
        if (clear_screen) clear_the_screen(); 
        cout << msg << endl; 
    }
```

在大多数情况下，预计该函数用于打印单个消息，但偶尔用户可能希望首先清除屏幕（例如，对于第一条消息或在预定的行数之后）。为了适应该函数的使用，`clear_screen`参数被赋予了默认值`false`，但调用者仍然可以选择传递一个值：

```cpp
    log_message("first message", true); 
    log_message("second message"); 
    bool user_decision = ask_user(); 
    log_message("third message", user_decision);
```

请注意，默认值出现在函数定义中，而不是在函数原型中，因此如果`log_message`函数在头文件中声明，则原型应为：

```cpp
    extern void log_message(const string& msg, bool clear_screen);
```

可以具有默认值的参数是最右边的参数。

您可以将具有默认值的每个参数视为函数的单独重载，因此在概念上，`log_message`函数应该被视为两个函数：

```cpp
    extern void log_message(const string& msg, bool clear_screen); 
    extern void log_message(const string& msg); // conceptually
```

如果定义了一个只有`const string&`参数的`log_message`函数，那么编译器将不知道是调用该函数还是给`clear_screen`赋予默认值`false`的版本。

# 可变数量的参数

具有默认参数值的函数可以被视为具有可变数量的用户提供的参数，其中您在编译时知道参数的最大数量和它们的值，如果调用者选择不提供值。C++还允许您编写函数，其中对参数的数量和传递给函数的值的确定性较少。

有三种方法可以具有可变数量的参数：初始化程序列表，C 风格的可变参数列表和可变模板函数。这三种方法中的后者将在本章后面讨论，一旦涵盖了模板函数。

# 初始化程序列表

到目前为止，在本书中，初始化列表一直被视为一种 C++11 构造，有点像内置数组。实际上，当您使用大括号的初始化列表语法时，编译器实际上会创建一个模板化的`initialize_list`类的实例。如果使用初始化列表来初始化另一种类型（例如，初始化`vector`），编译器将使用大括号之间给定的值创建一个`initialize_list`对象，并使用`initialize_list`迭代器初始化容器对象。可以利用从大括号初始化列表创建`initialize_list`对象的能力，为函数提供可变数量的参数，尽管所有参数必须是相同类型的。

```cpp
    #include <initializer_list> 

    int sum(initializer_list<int> values) 
    { 
        int sum = 0; 
        for (int i : values) sum += i; 
        return sum; 
    } 

    int main() 
    { 
        cout << sum({}) << endl;                       // 0 
        cout << sum({-6, -5, -4, -3, -2, -1}) << endl; // -21 
        cout << sum({10, 20, 30}) << endl;             // 60 
        return 0; 
    }
```

`sum`函数有一个`initializer_list<int>`的单一参数，它只能用整数列表进行初始化。`initializer_list`类的函数非常少，因为它只存在于给予大括号列表中的值。值得注意的是，它实现了一个`size`函数，返回列表中的项目数，以及`begin`和`end`函数，返回列表中第一个项目的指针和最后一个项目后面的位置。这两个函数需要为列表提供迭代器访问，并且使您能够使用范围-`for`语法与对象一起使用。

这在 C++标准库中很典型。如果一个容器在内存中以连续的内存块保存数据，那么指针算术可以使用指向第一项的指针和指向最后一项后面的指针来确定容器中有多少项。递增第一个指针可以顺序访问每一项，指针算术允许随机访问。所有容器都实现了`begin`和`end`函数，以便访问容器的*迭代器*。

在这个例子中，`main`函数三次调用这个函数，每次都使用大括号初始化列表，函数将返回列表中项目的总和。

显然，这种技术意味着*变量*参数列表中的每个项目必须是相同类型（或者可以转换为指定类型的类型）。如果参数是`vector`，则会得到相同的结果；不同之处在于`initializer_list`参数需要较少的初始化。

# 参数列表

C++继承了 C 的参数列表的概念。为此，您可以使用省略号语法（`...`）作为最后一个参数，以指示调用者可以提供零个或多个参数。编译器将检查函数的调用方式，并为这些额外的参数在堆栈上分配空间。要访问额外的参数，您的代码必须包含`<cstdarg>`头文件，其中包含您可以使用的宏来从堆栈中提取额外的参数。

这是固有的不安全类型，因为编译器无法检查函数在运行时从堆栈中获取的参数是否与调用代码放在堆栈上的参数类型相同。例如，以下是一个将整数相加的函数的实现：

```cpp
    int sum(int first, ...) 
    { 
        int sum = 0;    
        va_list args; 
        va_start(args, first); 
        int i = first; 
        while (i != -1) 
        { 
            sum += i; 
            i = va_arg(args, int); 
        } 
        va_end(args); 
        return sum; 
    }
```

函数的定义必须至少有一个参数，以便宏起作用；在这种情况下，参数称为`first`。重要的是，您的代码要保持堆栈处于一致的状态，这是通过使用`va_list`类型的变量来实现的。这个变量在函数开始时通过调用`va_start`宏进行初始化，并且在函数结束时通过调用`va_end`宏将堆栈恢复到其先前的状态。

这个函数中的代码只是简单地遍历参数列表，并维护一个总和，当参数的值为-1 时，循环结束。没有宏可以提供关于栈上有多少参数的信息，也没有宏可以提供栈上参数的类型的指示。您的代码必须假定变量的类型，并在`va_arg`宏中提供所需的类型。在这个例子中，`va_arg`被调用，假设栈上的每个参数都是`int`。

一旦所有参数都从栈上读取完毕，代码在返回总和之前调用`va_end`。函数可以这样调用：

```cpp
    cout << sum(-1) << endl;                       // 0 
    cout << sum(-6, -5, -4, -3, -2, -1) << endl;   // -20 !!! 
    cout << sum(10, 20, 30, -1) << endl;           // 60
```

由于`-1`用于指示列表的结束，这意味着要对零个参数求和，您必须至少传递一个参数，即`-1`。此外，第二行显示，如果您传递了一系列负数（在这种情况下，`-1`不能是参数），则会出现问题。通过选择另一个*标记值*，可以解决这个问题。

另一种实现可以避免使用列表末尾的标记，而是使用第一个必需的参数来给出后续参数的计数：

```cpp
    int sum(int count, ...) 
    { 
        int sum = 0; 
        va_list args; 
        va_start(args, count); 
        while(count--) 
        { 
            int i = va_arg(args, int); 
            sum += i; 
        } 
        va_end(args); 
        return sum; 
    }
```

这一次，第一个值是*后面的参数的数量*，因此该例程将从栈上提取这个确切数量的整数并对它们求和。代码的调用方式如下：

```cpp
    cout << sum(0) << endl;                         // 0 
    cout << sum(6, -6, -5, -4, -3, -2, -1) << endl; // -21 
    cout << sum(3, 10, 20, 30) << endl;             // 60
```

没有约定确定传递了多少参数的问题。

该例程假定栈上的每个项都是`int`，但在函数的原型中没有关于这一点的信息，因此编译器无法对实际用于调用函数的参数进行类型检查。如果调用者提供了不同类型的参数，则可能会从栈上读取错误数量的字节，使得对`va_arg`的所有其他调用的结果无效。考虑这个：

```cpp
    cout << sum(3, 10., 20, 30) << endl;
```

同时按下逗号和句号键是很容易的，这在输入`10`参数后发生了。句号意味着`10`是一个`double`，因此编译器将一个`double`值放在栈上。当函数使用`va_arg`宏从栈上读取值时，它将把 8 字节的`double`读取为两个 4 字节的`int`值，对于 Visual C++生成的代码，这将导致总和为`1076101140`。这说明了参数列表的类型不安全方面：您无法让编译器对传递给函数的参数进行类型检查。

如果您的函数传递了不同类型的参数，那么您必须实现一些机制来确定这些参数是什么。C `printf`函数是参数列表的一个很好的例子：

```cpp
    int printf(const char *format, ...);
```

这个函数的必需参数是一个格式字符串，而且这个字符串包含一个有序的变量参数列表和它们的类型。格式字符串提供了通过`<cstdarg>`宏不可用的信息：可变参数的数量和每个参数的类型。`printf`函数的实现将遍历格式字符串，当它遇到参数的格式说明符（以`%`开头的字符序列）时，它将使用`va_arg`从栈上读取预期的类型。应该清楚的是，C 风格的参数列表并不像乍一看那么灵活；而且，它们可能非常危险。

# 函数特性

函数是应用程序或库中定义的模块化代码片段。如果函数是由另一个供应商编写的，重要的是您的代码以供应商预期的方式调用函数。这意味着要了解使用的调用约定以及它如何影响栈。

# 调用栈

当您调用一个函数时，编译器会为新的函数调用创建一个堆栈帧，并将项目推送到堆栈上。放在堆栈上的数据取决于您的编译器以及代码是为调试还是发布构建而编译的；然而，一般来说，将会有关于传递给函数的参数、返回地址（函数调用后的地址）以及函数中分配的自动变量的信息。

这意味着，当您在运行时进行函数调用时，将会有一个内存开销和性能开销，因为在函数运行之前会创建堆栈帧，并且在函数完成后进行清理时会有性能开销。如果函数是内联的，这种开销就不会发生，因为函数调用将使用当前的堆栈帧而不是新的堆栈帧。显然，内联函数应该是小的，无论是代码还是在堆栈上使用的内存。编译器可以忽略`inline`说明符，并使用单独的堆栈帧调用函数。

# 指定调用约定

当您的代码使用自己的函数时，您不需要关注*调用约定*，因为编译器会确保使用适当的约定。然而，如果您正在编写可以被其他 C++编译器甚至其他语言使用的库代码，那么调用约定就变得重要起来。由于本书不涉及可互操作的代码，我们不会深入讨论，而是会看两个方面：函数命名和堆栈维护。

# 使用 C 链接

当您给一个 C++函数起一个名字时，这就是您在 C++代码中调用函数时将使用的名字。然而，在底层，C++编译器会*修饰*该名字，添加额外的符号以表示返回类型和参数，以便重载函数都有不同的名字。对于 C++开发人员来说，这也被称为**名称修饰**。

如果您需要通过共享库（在 Windows 中是**动态链接库**）导出一个函数，您必须使用其他语言可以使用的类型和名称。为此，您可以使用`extern "C"`标记一个函数。这意味着该函数具有 C 链接，编译器不会使用 C++名称修饰。显然，您应该只在将被外部代码使用的函数上使用这个标记，并且不应该在具有返回值和使用 C++自定义类型的参数的函数上使用它。

然而，如果这样的函数确实返回一个 C++类型，编译器只会发出警告。原因是 C 是一种灵活的语言，C 程序员将能够弄清楚如何将 C++类型转换为可用的东西，但滥用它们是不好的做法！

`extern "C"`链接也可以用于全局变量，并且可以用于单个项目或（使用大括号）多个项目。

# 指定堆栈的维护方式

Visual C++支持六种可以用于函数的调用约定。`__clrcall`说明该函数应该作为.NET 函数调用，并允许您编写具有混合本机代码和托管代码的代码。C++/CLR（微软的 C++语言扩展，用于编写.NET 代码）超出了本书的范围。其他五种用于指示参数如何传递给函数（在堆栈上或使用 CPU 寄存器）以及谁负责维护堆栈。我们只会涵盖三种：`__cdecl`、`__stdcall`和`__thiscall`。

您很少会显式使用`__thiscall`；它是用于自定义类型的成员函数的调用约定，并且表示该函数具有一个隐藏参数，该参数是指向可以通过函数中的`this`关键字访问的对象的指针。更多细节将在下一章中给出，但重要的是要意识到这样的成员函数具有不同的调用约定，特别是当您需要初始化函数指针时。

默认情况下，C++全局函数将使用`__cdecl`调用约定。堆栈由调用代码维护，因此在调用代码中，对`__cdecl`函数的每次调用都会跟随清理堆栈的代码。这使得每个函数调用都会变得稍微大一些，但这对于使用可变参数列表是必要的。大多数 Windows SDK 函数使用`__stdcall`调用约定，它表示被调用的函数清理堆栈，因此在调用代码中不需要生成这样的代码。显然，编译器知道函数使用`__stdcall`是很重要的，否则它将生成代码来清理已经被函数清理的堆栈帧。通常会看到带有`WINAPI`标记的 Windows 函数，这是`__stdcall`的`typedef`。

# 使用递归

在大多数情况下，调用堆栈的内存开销并不重要。然而，当您使用递归时，可能会建立一个很长的堆栈帧链。顾名思义，递归是指一个函数调用自身。一个简单的例子是计算阶乘的函数：

```cpp
    int factorial(int n) 
    { 
        if (n > 1) return n ∗ factorial(n − 1); 
        return 1; 
    }
```

如果您为 4 调用此函数，则会进行以下调用：

```cpp
    factorial(4) returns 4 * factorial(3) 
        factorial(3) returns 3 * factorial(2) 
            factorial(2) returns 2 * factorial(1) 
                factorial(1) returns 1
```

重要的一点是，在递归函数中必须至少有一种方法可以在没有递归的情况下离开函数。在这种情况下，当使用参数 1 调用`factorial`时，函数将结束。实际上，这样的函数应该标记为`inline`，以避免创建任何堆栈帧。

# 函数重载

您可以有几个具有相同名称的函数，但参数列表不同（参数的数量和/或参数的类型）。这就是*函数重载*的函数名称。当调用这样的函数时，编译器将尝试找到最适合提供的参数的函数。如果没有合适的函数，编译器将尝试转换参数，以查看是否存在具有这些类型的函数。编译器将从简单的转换开始（例如，数组名称到指针，类型到`const`类型），如果失败，编译器将尝试提升类型（例如，`bool`到`int`）。如果失败，编译器将尝试标准转换（例如，引用到类型）。如果这样的转换导致有多个可能的候选项，那么编译器将发出函数调用模糊的错误。

# 函数和作用域

编译器在寻找合适的函数时也会考虑函数的作用域。您不能在一个函数内定义另一个函数，但是您可以在函数的作用域内提供一个函数原型，编译器将尝试（如果需要通过转换）首先调用具有这种原型的函数。考虑以下代码：

```cpp
    void f(int i)    { /*does something*/ } 
    void f(double d) { /*does something*/ } 

    int main() 
    { 
        void f(double d); 
        f(1); 
        return 0; 
    }
```

在这段代码中，函数`f`被重载为一个接受`int`的版本和一个接受`double`的版本。通常，如果您调用`f(1)`，编译器将调用函数的第一个版本。然而，在`main`中有一个接受`double`的版本的原型，并且`int`可以转换为`double`而不会丢失信息。原型与函数调用处于相同的作用域，因此在这段代码中，编译器将调用接受`double`的版本。这种技术本质上*隐藏*了带有`int`参数的版本。

# 删除的函数

隐藏函数的更正式方法是使用作用域。C++将尝试显式转换内置类型。例如：

```cpp
    void f(int i);
```

您可以使用`int`或任何可以转换为`int`的内容来调用此函数：

```cpp
    f(1); 
    f('c'); 
    f(1.0); // warning of conversion
```

在第二种情况下，`char`是一个整数，因此它被提升为`int`并调用函数。在第三种情况下，编译器将发出警告，指出转换可能会导致数据丢失，但这只是一个警告，所以代码会编译。如果要阻止这种隐式转换，可以*删除*您不希望调用者使用的函数。要做到这一点，提供一个原型并使用语法`= delete`：

```cpp
    void f(double) = delete; 

    void g() 
    { 
        f(1);   // compiles 
        f(1.0); // C2280: attempting to reference a deleted function 
    }
```

现在，当代码尝试使用`char`或`double`（或`float`，它将被隐式转换为`double`）调用函数时，编译器将发出错误。

# 按值传递和按引用传递

默认情况下，编译器将按值传递参数，也就是说，会创建一个副本。如果传递自定义类型，则会调用其*复制构造函数*来创建一个新对象。如果传递一个指向内置类型或自定义类型对象的指针，则*指针*将按值传递，也就是说，函数堆栈上为参数创建一个新指针，并用传递给函数的内存地址进行初始化。这意味着在函数中，您可以更改指针指向的其他内存（如果您想对该指针进行指针算术，则这很有用）。指针指向的数据将通过引用传递，也就是说，数据保持在函数外部，但函数可以使用指针来更改数据。同样，如果在参数上使用引用，则表示通过引用传递对象。显然，如果在指针或引用参数上使用`const`，则这将影响函数是否可以更改指向的数据。

在某些情况下，您可能希望从函数中返回多个值，并且您可能选择使用函数的返回值来指示函数是否执行正确。做法之一是将其中一个参数作为*out*参数，也就是说，它是一个指针或引用，指向函数将要改变的对象或容器：

```cpp
    // don't allow any more than 100 items 
    bool get_items(int count, vector<int>& values) 
    { 
        if (count > 100) return false; 
        for (int i = 0; i < count; ++i) 
        { 
            values.push_back(i); 
        } 
        return true; 
    }
```

要调用此函数，必须创建一个`vector`对象并将其传递给函数：

```cpp
    vector<int> items {}; 
    get_items(10, items); 
    for(int i : items) cout << i << ' '; 
    cout << endl
```

因为`values`参数是一个引用，这意味着当`get_values`调用`push_back`向`values`容器中插入一个值时，实际上是将该值插入到`items`容器中。

如果通过指针传递输出参数，则重要的是查看指针声明。一个`*`表示变量是一个指针，两个表示它是一个指向指针的指针。以下函数通过输出参数返回一个`int`：

```cpp
    bool get_datum(/*out*/ int *pi);
```

代码的调用方式如下：

```cpp
    int value = 0; 
    if (get_datum(&value)) { cout << "value is " << value << endl; } 
    else                   { cout << "cannot get the value" << endl;}
```

这种返回一个表示成功的值的模式经常被使用，特别是在访问跨进程或机器边界的数据的代码中。函数返回值可以用来提供关于调用失败的详细信息（没有网络访问？无效的安全凭证？等等），并且表示输出参数中的数据应该被丢弃。

如果输出参数有一个双`*`，那么这意味着返回值本身是一个指针，要么指向单个值，要么指向一个数组：

```cpp
    bool get_data(/*in/out*/ int *psize, /*out*/ int **pi);
```

在这种情况下，您使用第一个参数传入要使用的缓冲区的大小，并在返回时通过该参数接收缓冲区的实际大小（它是输入/输出），以及第二个参数中的缓冲区的指针：

```cpp
    int size = 10; 
    int *buffer = nullptr; 
    if (get_data(size, &buffer)) 
    { 
        for (int i = 0; i < size; ++i) 
        { 
            cout << buffer[i] << endl; 
        } 
        //delete [] buffer; 
    }
```

任何返回内存缓冲区的函数都必须记录谁有责任释放内存。在大多数情况下，通常是调用者，就像这个例子代码中假设的那样。

# 设计函数

通常函数会对全局数据或调用者传入的数据进行操作。重要的是，当函数完成时，它会使这些数据处于一致的状态。同样重要的是，函数在访问数据之前可以对数据做出假设。

# 前置条件和后置条件

一个函数通常会改变一些数据：传递给函数的值，函数返回的数据，或一些全局数据。在设计函数时，确定将访问和更改哪些数据，并记录这些规则非常重要。

函数将具有前置条件，即它将使用的数据的假设。例如，如果一个函数传递一个文件名，并打算从文件中提取一些数据，那么谁负责检查文件是否存在？您可以将其作为函数的责任，并且前几行将检查该名称是否是文件的有效路径，并调用操作系统函数来检查文件是否存在。但是，如果您有多个函数将对文件执行操作，您将在每个函数中复制此检查代码，最好将该责任放在调用代码上。显然，这样的操作可能很昂贵，因此重要的是避免调用代码和函数执行检查。

第七章，*诊断和调试*，将描述如何添加调试代码，称为**断言**，您可以将其放置在函数中以检查参数的值，以确保调用代码遵循您设置的前置条件规则。断言是使用条件编译定义的，因此只会出现在**调试构建**中（即使用调试信息编译的 C++代码）。**发布构建**（将交付给最终用户的完成代码）将有条件地编译断言；这使得代码更快，如果您的测试足够彻底，可以确保前置条件得到满足。

您还应该记录函数的后置条件。也就是说，有关函数返回的数据的假设（通过函数返回值、输出参数或引用传递的参数）。后置条件是调用代码将做出的假设。例如，您可能返回一个有符号整数，而函数应返回一个正值，但使用负值表示错误。通常，返回指针的函数将在函数失败时返回`nullptr`。在这两种情况下，调用代码知道它需要检查返回值，并且只有在它是正值或不是`nullptr`时才使用它。

# 使用不变量

您应该小心记录函数如何使用函数外部的数据。如果函数的意图是改变外部数据，您应该记录函数将做什么。如果您没有明确记录函数对外部数据的影响，那么您必须确保函数完成时不会影响这些数据。原因是调用代码只会假设您在文档中所说的内容，更改全局数据的副作用可能会引起问题。有时需要存储全局数据的状态，并在函数返回之前将项目返回到该状态。

一个例子是`cout`对象。`cout`对象是全局的，它可以通过操作符更改，以使其以某种方式解释数值。如果您在函数中更改它（比如，通过插入`hex`操作符），那么当在函数外部使用`cout`对象时，这种更改将保留下来。

创建一个名为`read16`的函数，该函数从文件中读取 16 个字节，并以十六进制形式和 ASCII 字符形式将值打印到控制台上：

```cpp
    int read16(ifstream& stm) 
    { 
        if (stm.eof()) return -1;  

        int flags = cout.flags(); 
        cout << hex; 
        string line; 

        // code that changes the line variable 

        cout.setf(flags); 
        return line.length(); 
    }
```

这段代码将`cout`对象的状态存储在临时变量`flags`中。`read16`函数可以以任何必要的方式更改`cout`对象，但因为我们有存储的状态，这意味着在返回之前可以将对象恢复到其原始状态。

# 函数指针

当应用程序运行时，它将调用的函数将存在于内存中的某个位置。这意味着您可以获取函数的地址。C++允许您使用函数调用运算符（一对括号括住参数`()`）通过函数指针调用函数。

# 记住括号！

首先，一个简单的例子，说明函数指针如何在代码中引起难以注意的错误。一个名为`get_status`的全局函数执行各种验证操作，以确定系统状态是否有效。该函数返回值为零表示系统状态有效，大于零的值表示错误代码：

```cpp
    // values over zero are error codes 
    int get_status() 
    { 
        int status = 0;  
        // code that checks the state of data is valid 
        return status; 
    }
```

代码可以这样调用：

```cpp
    if (get_status > 0) 
    { 
        cout << "system state is invalid" << endl; 
    }
```

这是一个错误，因为开发人员遗漏了`()`，所以编译器不将其视为函数调用。相反，它将其视为对函数的内存地址的测试，由于函数永远不会位于内存地址为零的位置，因此比较将始终为`true`，即使系统状态有效，也会打印出消息。

# 声明函数指针

最后一节突出了获取函数地址有多么容易：只需使用函数的名称，不带括号：

```cpp
    void *pv = get_status;
```

指针`pv`只是轻微感兴趣；现在你知道函数存储在内存中的位置，但要打印这个地址，你仍然需要将其转换为整数。为了使指针有用，您需要能够声明一个通过该函数可以被调用的指针。为了看看如何做到这一点，让我们回到函数原型：

```cpp
    int get_status()
```

函数指针必须能够调用不带参数并期望返回整数值的函数。函数指针声明如下：

```cpp
    int (*fn)() = get_status;
```

`*`表示变量`fn`是一个指针；然而，这会绑定到左边，因此如果没有括号围绕`*fn`，编译器会解释这意味着声明是一个`int*`指针。声明的其余部分指示如何调用此函数指针：不带参数并返回一个`int`。

通过函数指针调用很简单：在通常给出函数名称的地方给出指针的名称：

```cpp
    int error_value = fn();
```

再次注意括号的重要性；它们表示在函数指针`fn`中保存的地址处调用函数。

函数指针可能会使代码看起来相当凌乱，特别是当您使用它们指向模板化函数时，因此通常代码会定义一个别名：

```cpp
    using pf1 = int(*)();
    typedef int(*pf2)();
```

这两行声明了调用`get_status`函数所需的函数指针类型的别名。两者都是有效的，但`using`版本更易读，因为清楚地表明了`pf1`是正在定义的别名。要了解原因，请考虑这个别名：

```cpp
    typedef bool(*MyPtr)(MyType*, MyType*);
```

类型别名称为`MyPtr`，它是一个返回`bool`并接受两个`MyType`指针的函数。使用`using`更清晰：

```cpp
    using MyPtr = bool(*)(MyType*, MyType*);
```

这里的显著标志是`(*)`，它表示类型是函数指针，因为您使用括号来打破`*`的关联性。然后，您可以向外读取函数的原型：向左查看返回类型，向右获取参数列表。

一旦声明了别名，就可以创建一个指向函数的指针并调用它：

```cpp
    using two_ints = void (*)(int, int); 

    void do_something(int l, int r){/* some code */} 

    void caller() 
    { 
        two_ints fn = do_something; 
        fn(42, 99); 
    }
```

请注意，由于`two_ints`别名声明为指针，因此在声明此类型的变量时不使用`*`。

# 使用函数指针

函数指针只是一个指针。这意味着您可以将其用作变量；您可以从函数中返回它，或将其作为参数传递。例如，您可能有一些执行一些冗长例程的代码，并且您希望在例程期间提供一些反馈。为了使其灵活，您可以定义函数以接受**回调指针**，并在例程中定期调用该函数以指示进度：

```cpp
    using callback = void(*)(const string&); 

    void big_routine(int loop_count, const callback progress) 
    { 
        for (int i = 0; i < loop_count; ++i) 
        { 
            if (i % 100 == 0) 
            { 
                string msg("loop "); 
                 msg += to_string(i); 
                 progress(msg); 
            } 
            // routine 
        } 
    }
```

这里`big_routine`有一个名为`progress`的函数指针参数。该函数有一个循环，将被调用多次，每一百次循环它都会调用回调函数，传递一个提供有关进度信息的`string`。

请注意，`string`类定义了一个`+=`运算符，可用于将字符串附加到变量中字符串的末尾，而`<string>`头文件定义了一个名为`to_string`的函数，该函数针对每种内置类型进行了重载，以返回使用函数参数的值格式化的`string`。

此函数将函数指针声明为`const`，只是为了让编译器知道该函数指针在此函数中不应更改为指向另一个函数的指针。可以这样调用代码：

```cpp
    void monitor(const string& msg) 
    { 
        cout << msg << endl; 
    } 

    int main() 
    { 
        big_routine(1000, monitor); 
        return 0; 
    }
```

`monitor`函数具有与`callback`函数指针描述的相同原型（例如，如果函数参数是`string&`而不是`const string&`，则代码将无法编译）。然后调用`big_routine`函数，将`monitor`函数的指针作为第二个参数传递。

如果将回调函数传递给库代码，则必须注意函数指针的调用约定。例如，如果将函数指针传递给 Windows 函数，例如`EnumWindows`，它必须指向使用`__stdcall`调用约定声明的函数。

C++标准使用另一种技术来调用在运行时定义的函数，即函数对象。这将很快介绍。

# 模板化函数

当您编写库代码时，通常必须编写几个仅在传递给函数的类型之间不同的函数；常规操作是相同的，只是类型发生了变化。C++提供了*模板*，允许您编写更通用的代码；您使用*通用类型*编写常规操作，并且在编译时编译器将生成具有适当类型的函数。使用`template`关键字和尖括号（`<>`）中的参数列表标记模板化函数，这些参数为将要使用的类型提供了占位符。重要的是要理解这些模板参数是类型，并且是指将被实际类型替换的函数调用时使用的参数（和函数返回值）的类型。它们不是函数的参数，当您调用函数时，您通常不提供它们。

最好用一个例子来解释模板函数。一个简单的`maximum`函数可以这样写：

```cpp
    int maximum(int lhs, int rhs) 
    { 
        return (lhs > rhs) ? lhs : rhs; 
    }
```

您可以使用其他整数类型调用此函数，并且较小的类型（`short`，`char`，`bool`等）将被提升为`int`，较大类型（`long long`）的值将被截断。同样，`unsigned`类型的变量将被转换为`signed int`，这可能会引起问题。考虑一下对函数的调用：

```cpp
    unsigned int s1 = 0xffffffff, s2 = 0x7fffffff; 
    unsigned int result = maximum(s1, s2);
```

`result`变量的值是什么：`s1`还是`s2`？是`s2`。原因是两个值都转换为`signed int`，当转换为有符号类型时，`s1`将是值`-1`，`s2`将是值`2147483647`。

要处理无符号类型，您需要*重载*函数并为有符号和无符号整数编写版本：

```cpp
    int maximum(int lhs, int rhs) 
    { 
        return (lhs > rhs) ? lhs : rhs; 
    } 

    unsigned maximum(unsigned lhs, unsigned rhs) 
    { 
        return (lhs > rhs) ? lhs : rhs; 
    }
```

常规操作相同，但类型已更改。还有另一个问题--如果调用者混合类型会怎样？以下表达式有意义吗：

```cpp
    int i = maximum(true, 100.99);
```

这段代码将编译，因为`bool`和`double`可以转换为`int`，并且将调用第一个重载。由于这样的调用是无意义的，如果编译器捕获到此错误，那将更好。

# 定义模板

回到`maximum`函数的两个版本，两者的常规操作都是相同的；改变的只是类型。如果有一个通用类型，我们称之为`T`，其中`T`可以是实现`operator>`的任何类型，那么常规操作可以用伪代码描述如下：

```cpp
    T maximum(T lhs, T rhs) 
    { 
        return (lhs > rhs) ? lhs : rhs; 
    }
```

这将不会编译，因为我们没有定义类型`T`。模板允许你告诉编译器代码使用了一个类型，并且将从传递给函数的参数中确定。以下代码将编译：

```cpp
    template<typename T> 
    T maximum(T lhs, T rhs) 
    { 
        return (lhs > rhs) ? lhs : rhs; 
    }
```

模板声明使用`typename`标识符指定将要使用的类型。类型`T`是一个占位符；你可以使用任何你喜欢的名称，只要它不是在同一作用域中的其他名称，当然，它必须在函数的参数列表中使用。你可以使用`class`代替`typename`，但意思是一样的。

你可以调用这个函数，传递任何类型的值，编译器将为该类型创建代码，调用该类型的`operator>`。

重要的是要意识到，当编译器第一次遇到模板函数时，它将为指定的类型创建函数的版本。如果你为几种不同类型调用模板函数，编译器将为每种类型创建一个*专门化*函数。

这个模板的定义表明只会使用一个类型，所以你只能用相同类型的两个参数来调用它：

```cpp
    int i = maximum(1, 100);
    double d = maximum(1.0, 100.0);
    bool b = maximum(true, false);
```

所有这些都将编译，前两个将给出预期的结果。最后一行将把`b`赋值为`true`，因为`bool`是一个整数，`true`的值为`1+`，`false`的值为`0`。这可能不是你想要的，所以我们稍后会回到这个问题。请注意，由于模板规定了两个参数必须是相同类型，所以下面的代码将不会编译：

```cpp
    int i = maximum(true, 100.99);
```

原因是`template`参数列表只给出了一个类型。如果你想要定义一个带有不同类型参数的函数，那么你将不得不为模板提供额外的参数：

```cpp
    template<typename T, typename U> 
    T maximum(T lhs, U rhs) 
    { 
        return (lhs > rhs) ? lhs : rhs; 
    }
```

这样做是为了说明模板的工作原理；定义一个接受两种不同类型的最大函数实际上是没有意义的。

这个版本是为两种不同类型编写的，模板声明提到了两种类型，并且这些类型用于两个参数。但请注意，函数返回`T`，即第一个参数的类型。函数可以这样调用：

```cpp
    cout << maximum(false, 100.99) << endl; // 1 
    cout << maximum(100.99, false) << endl; // 100.99
```

第一个输出是`1`（或者如果你使用`bool alpha`操纵器，是`true`），第二行的结果是`100.99`。原因并不是立即显而易见。在两种情况下，比较都将从函数返回`100.99`，但是因为返回值的类型是`T`，返回值的类型将是第一个参数的类型。在第一种情况下，`100.99`首先被转换为`bool`，由于`100.99`不是零，返回的值是`true`（或者`1`）。在第二种情况下，第一个参数是`double`，所以函数返回一个`double`，这意味着返回`100.99`。如果模板版本的`maximum`被更改为返回`U`（第二个参数的类型），那么上面代码返回的值将被颠倒：第一行返回`100.99`，第二行返回`1`。

请注意，当你*调用*模板函数时，你不必给出模板参数的类型，因为编译器会推断它们。重要的是要指出，这仅适用于参数。返回类型不是由调用者分配给函数值的变量的类型决定的，因为函数可以在不使用返回值的情况下被调用。

尽管编译器将根据你调用函数的方式推断模板参数，你可以在调用函数时显式提供类型，以调用函数的特定版本，并且（如果必要）让编译器执行隐式转换：

```cpp
    // call template<typename T> maximum(T,T); 
    int i = maximum<int>(false, 100.99);
```

这段代码将调用具有两个`int`参数并返回`int`的`maximum`版本，因此返回值是`100`，即`100.99`转换为`int`。

# 使用模板参数值

到目前为止定义的模板已经将类型作为模板的参数，但您也可以提供整数值。以下是一个相当牵强的例子来说明这一点：

```cpp
    template<int size, typename T> 
    T* init(T t) 
    { 
        T* arr = new T[size]; 
        for (int i = 0; i < size; ++i) arr[i] = t; 
        return arr; 
    }
```

有两个模板参数。第二个参数提供了一个类型的名称，其中`T`是用于函数参数类型的占位符。第一个参数看起来像一个函数参数，因为它以类似的方式使用。参数`size`可以在函数中作为本地（只读）变量使用。函数参数是`T`，因此编译器可以从函数调用中推断出第二个模板参数，但无法推断出第一个参数，因此您*必须*在调用中提供一个值。以下是调用此模板函数的示例，`T`为`int`，`size`为`10`的值：

```cpp
    int *i10 = init<10>(42); 
    for (int i = 0; i < 10; ++i) cout << i10[i] << ' '; 
    cout << endl; 
    delete [] i10;
```

第一行使用`10`作为模板参数，`42`作为函数参数调用函数。由于`42`是一个`int`，`init`函数将创建一个具有十个成员的`int`数组，并且每个成员都初始化为`42`的值。编译器推断出`int`是第二个参数，但是此代码也可以使用`init<10,int>(42)`调用函数，以明确指示您需要一个`int`数组。

非类型参数必须在编译时是常量：值可以是整数（包括枚举），但不能是浮点数。您可以使用整数数组，但是这些将通过模板参数作为指针可用。

尽管在大多数情况下编译器无法推断值参数，但如果该值被定义为数组的大小，则可以。这可以用来使函数看起来可以确定内置数组的大小，但当然不行，因为编译器将为所需的每个大小创建函数的版本。例如：

```cpp
    template<typename T, int N> void print_array(T (&arr)[N]) 
    { 
        for (int i = 0; i < N; ++i) 
        { 
            cout << arr[i] << endl; 
        } 
    }
```

在这里，有两个模板参数：一个是数组的类型，另一个是数组的大小。函数的参数看起来有点奇怪，但它只是通过引用传递的内置数组。如果不使用括号，则参数是`T& arr[N]`，即大小为 N 的对`T`类型的对象的引用的内置数组，这不是我们想要的。我们想要一个大小为 N 的`T`类型的内置数组对象。这个函数的调用方式如下：

```cpp
    int squares[] = { 1, 4, 9, 16, 25 }; 
    print_array(squares);
```

关于前面的代码的有趣之处在于编译器看到初始化列表中有五个项目。内置数组有五个项目，因此调用函数如下：

```cpp
    print_array<int,5>(squares);
```

如前所述，编译器将为代码调用的每个`T`和`N`组合实例化此函数。如果模板函数有大量代码，那么这可能是一个问题。解决这个问题的一种方法是使用辅助函数：

```cpp
    template<typename T> void print_array(T* arr, int size) 
    { 
        for (int i = 0; i < size; ++i) 
        { 
            cout << arr[i] << endl; 
        } 
    } 

    template<typename T, int N> inline void print_array(T (&arr)[N]) 
    { 
        print_array(arr, N); 
    }
```

这做了两件事。首先，有一个接受指针和指针指向的项目数的`print_array`版本。这意味着`size`参数在运行时确定，因此此函数的版本仅在编译时为所使用的数组类型实例化，而不是类型和数组大小。第二件事要注意的是，使用数组大小模板化的函数声明为`inline`，并调用函数的第一个版本。尽管对于每种类型和数组大小的组合都会有一个版本，但实例化将是内联的，而不是完整的函数。

# 专门化模板

在某些情况下，您可能有一个适用于大多数类型的例程（并且适合于模板函数），但您可能会发现某些类型需要不同的例程。为了处理这种情况，您可以编写一个专门的模板函数，即一个将用于特定类型的函数，当调用者使用适合此专门化的类型时，编译器将使用此代码。例如，这是一个相当无意义的函数；它返回类型的大小：

```cpp
    template <typename T> int number_of_bytes(T t) 
    { 
        return sizeof(T); 
    }
```

这对大多数内置类型都适用，但如果你用指针调用它，你将得到指针的大小，而不是指针指向的内容。因此，`number_of_bytes("x")` 将返回 4（在 32 位系统上），而不是 `char` 数组的大小为 2。你可能决定为 `char*` 指针编写一个专门的版本，使用 C 函数 `strlen` 来计算字符串中的字符数，直到 `NUL` 字符。为此，你需要一个类似于模板函数的原型，用实际类型替换模板参数，由于不需要模板参数，你可以省略它。由于这个函数是为特定类型而设计的，你需要将专门的类型添加到函数名中：

```cpp
    template<> int number_of_bytes<const char *>(const char *str) 
    { 
        return strlen(str) + 1; 
    }
```

现在当你调用 `number_of_bytes("x")` 时，将调用专门的版本，它将返回值 2。

早些时候，我们定义了一个模板函数，返回相同类型的两个参数的最大值：

```cpp
    template<typename T> 
    T maximum(T lhs, T rhs) 
    { 
        return (lhs > rhs) ? lhs : rhs; 
    }
```

使用专门化，你可以为不使用 `>` 运算符进行比较的类型编写版本。由于找到两个布尔值的最大值没有意义，你可以删除 `bool` 的专门化：

```cpp
    template<> bool maximum<bool>(bool lhs, bool rhs) = delete;
```

这意味着，如果代码使用 `bool` 参数调用 `maximum`，编译器将生成错误。

# 可变模板

可变模板是指模板参数的数量是可变的。语法类似于函数的可变参数；你使用省略号，但是你将它们放在参数列表中参数的左边，这将声明它为 *参数包*：

```cpp
    template<typename T, typename... Arguments>  
    void func(T t, Arguments... args);
```

`Arguments` 模板参数是零个或多个类型，这些类型是函数的相应数量的参数 `args` 的类型。在这个例子中，函数至少有一个类型为 `T` 的参数，但你可以有任意数量的固定参数，包括一个也没有。

在函数内部，你需要展开参数包以访问调用者传递的参数。你可以使用特殊运算符 `sizeof...` 来确定参数包中有多少项（注意省略号是名称的一部分）；与 `sizeof` 运算符不同，这是项数而不是字节大小。要展开参数包，你需要在参数包的名称右侧使用省略号（例如 `args...`）。编译器将在这一点展开参数包，用参数包的内容替换符号。

然而，你在设计时不知道有多少参数或它们是什么类型，因此有一些策略可以解决这个问题。第一种使用递归：

```cpp
    template<typename T> void print(T t) 
    { 
        cout << t << endl; 
    } 

    template<typename T, typename... Arguments>  
    void print(T first, Arguments ... next) 
    { 
        print(first); 
        print(next...); 
    }
```

可变模板的 `print` 函数可以用任何可以由 `ostream` 类处理的一个或多个参数调用：

```cpp
    print(1, 2.0, "hello", bool);
```

当这个函数被调用时，参数列表被分成两部分：第一个参数（`1`）在第一个参数 `first` 中，其他三个参数放在参数包 `next` 中。然后函数体调用 `print` 的第一个版本，将 `first` 参数打印到控制台。可变函数的下一行然后展开参数包，调用 `print`，也就是说，这是递归调用。在这个调用中，`first` 参数将是 `2.0`，其余的参数将放在参数包中。这将一直持续下去，直到参数包被展开到没有更多参数为止。

另一种展开参数包的方法是使用初始化列表。在这种情况下，编译器将为每个参数创建一个数组：

```cpp
    template<typename... Arguments>  
    void print(Arguments ... args) 
    { 
        int arr [sizeof...(args)] = { args... }; 
        for (auto i : arr) cout << i << endl; 
    }
```

数组 `arr` 是用参数包的大小创建的，初始化大括号中使用的展开语法将数组填充为参数。虽然这对任意数量的参数都适用，但所有参数都必须是数组 `arr` 的相同类型。

一个技巧是使用逗号运算符：

```cpp
    template<typename... Arguments>  
    void print(Arguments ... args) 
    { 
        int dummy[sizeof...(args)] = { (print(args), 0)... }; 
    }
```

这将创建一个名为`dummy`的虚拟数组。除了在参数包的扩展中使用外，不使用此数组。该数组的大小与`args`参数包的大小相同，省略号使用括号之间的*表达式*扩展参数包。该表达式使用逗号运算符，它将返回逗号的右侧。由于这是一个整数，这意味着`dummy`的每个条目都具有零值。有趣的部分是逗号运算符的左侧。在这里，使用具有单个模板化参数的`print`版本来调用`args`参数包中的每个项目。

# 重载运算符

我们之前说过函数名称不应包含标点符号。这并不完全正确，因为如果您正在编写运算符，*只有*在函数名称中使用标点符号。运算符用于作用于一个或多个操作数的表达式。一元运算符有一个操作数，二元运算符有两个操作数，并且运算符返回操作的结果。显然，这描述了一个函数：返回类型、名称和一个或多个参数。

C++提供了关键字`operator`，以指示该函数不使用函数调用语法，而是使用与运算符相关的语法调用（通常，一元运算符的第一个参数在运算符的右侧，而二元运算符的第一个参数在左侧，第二个参数在右侧，但也有例外）。

通常，您将提供运算符作为自定义类型的一部分（因此运算符作用于该类型的变量），但在某些情况下，您可以在全局范围内声明运算符。两者都是有效的。如果您正在编写自定义类型（如下一章中所述的类），那么将运算符的代码封装为自定义类型的一部分是有意义的。在本节中，我们将集中讨论另一种定义运算符的方法：作为全局函数。

您可以提供以下一元运算符的自定义版本：

```cpp
    ! & + - * ++ -- ~
```

您还可以提供以下二元运算符的自定义版本：

```cpp
    != == < <= > >= && ||
    % %= + += - -= * *= / /= & &= | |= ^ ^= << <<= = >> =>>
    -> ->* ,
```

您还可以编写函数调用运算符`()`、数组下标`[]`、转换运算符、强制转换运算符`()`以及`new`和`delete`的版本。您不能重新定义`.`、`.*`、`::`、`?:`、`#`或`##`运算符，也不能重新定义“命名”运算符`sizeof`、`alignof`或`typeid`。

在定义运算符时，您编写一个函数，其中函数名称为`operator*x*`，而`*x*`是运算符符号（请注意，没有空格）。例如，如果您定义了一个具有两个成员的`struct`，用于定义笛卡尔点，您可能希望比较两个点是否相等。`struct`可以这样定义：

```cpp
    struct point 
    { 
        int x; 
        int y; 
    };
```

比较两个`point`对象很容易。如果一个对象的`x`和`y`等于另一个对象中对应的值，则它们相同。如果定义了`==`运算符，则还应该使用相同的逻辑定义`!=`运算符，因为`!=`应该给出`==`运算符的完全相反的结果。这是如何定义这些运算符的：

```cpp
    bool operator==(const point& lhs, const point& rhs) 
    { 
        return (lhs.x == rhs.x) && (lhs.y == rhs.y); 
    } 

    bool operator!=(const point& lhs, const point& rhs) 
    { 
        return !(lhs == rhs); 
    }
```

这两个参数是运算符的两个操作数。第一个是左侧的操作数，第二个参数是右侧的操作数。它们以引用的方式传递，以便不进行复制，并且它们被标记为`const`，因为运算符不会改变对象。一旦定义，您可以像这样使用`point`类型：

```cpp
    point p1{ 1,1 }; 
    point p2{ 1,1 }; 
    cout << boolalpha; 
    cout << (p1 == p2) << endl; // true 
    cout << (p1 != p2) << endl; // false
```

您可以定义一对名为`equals`和`not_equals`的函数，并使用这些函数：

```cpp
    cout << equals(p1,p2) << endl;     // true 
    cout << not_equals(p1,p2) << endl; // false
```

然而，定义运算符使代码更易读，因为您可以像使用内置类型一样使用该类型。运算符重载通常被称为*语法糖*，使代码更易于阅读-但这淡化了一个重要的技术。例如，智能指针是一种涉及类**析构函数**以管理资源生命周期的技术，仅因为您可以调用此类对象，就好像它们是指针一样。您可以这样做，因为智能指针类实现了`->`和`*`运算符。另一个例子是**函数对象**，其中类实现了`()`运算符，以便可以访问对象，就好像它们是函数一样。

当您编写自定义类型时，应该问自己是否重载类型的运算符是有意义的。例如，如果类型是数值类型，例如复数或矩阵-那么实现算术运算符是有意义的，但是实现逻辑运算符是否有意义，因为该类型没有逻辑方面？有一种诱惑，即重新定义运算符的*含义*以涵盖您的特定操作，但这将使您的代码不太可读。

一般来说，一元运算符被实现为接受单个参数的全局函数。后缀递增和递减运算符是一个例外，允许与前缀运算符不同的实现。前缀运算符将具有对对象的引用作为参数（该运算符将递增或递减），并返回对此更改后的对象的引用。然而，后缀运算符必须返回递增或递减之前的对象的值。因此，运算符函数有两个参数：将被更改的对象的引用和一个整数（始终是 1 的值）；它将返回原始对象的副本。

二元运算符将有两个参数并返回一个对象或对象的引用。例如，对于我们之前定义的`struct`，我们可以为`ostream`对象定义插入运算符：

```cpp
    struct point 
    { 
        int x; 
        int y; 
    }; 

    ostream& operator<<(ostream& os, const point& pt) 
    { 
        os << "(" << pt.x << "," << pt.y << ")"; 
        return os; 
    }
```

这意味着您现在可以将`point`对象插入到`cout`对象中，以在控制台上打印它：

```cpp
    point pt{1, 1}; 
    cout << "point object is " << pt << endl;
```

# 函数对象

函数对象，或**函数对象**，是实现函数调用运算符（`operator()`）的自定义类型。这意味着可以以看起来像是函数的方式调用函数运算符。由于我们尚未涵盖类，因此在本节中，我们将仅探讨标准库提供的函数对象类型以及如何使用它们。

`<functional>`头文件包含各种可用作函数对象的类型。以下表列出了这些类型：

| **目的** | **类型** |
| --- | --- |
| 算术 | `divides`，`minus`，`modulus`，`multiplies`，`negate`，`plus` |
| 位运算 | `bit_and`，`bit_not`，`bit_or`，`bit_xor` |
| 比较 | `equal_to`，`greater`，`greater_equal`，`less`，`less_equals`，`not_equal_to` |
| 逻辑 | `logical_and`，`logical_not`，`logical_or` |

这些都是二元函数类，除了`bit_not`，`logical_not`和`negate`之外，它们都是一元的。二元函数对象作用于两个值并返回一个结果，一元函数对象作用于单个值并返回一个结果。例如，您可以使用以下代码计算两个数字的模数：

```cpp
    modulus<int> fn; 
    cout << fn(10, 2) << endl;
```

这声明了一个名为`fn`的函数对象，它将执行模数。该对象在第二行中使用，该行调用对象上的`operator()`函数，并带有两个参数，因此以下行等同于前一行：

```cpp
    cout << fn.operator()(10, 2) << endl;
```

结果是在控制台上打印了值`0`。`operator()`函数仅对两个参数执行模数，在本例中为`10 % 2`。这看起来并不太令人兴奋。`<algorithm>`头文件包含可以使用函数对象的函数。大多数采用谓词，即逻辑函数对象，但是一个`transform`采用执行操作的函数对象：

```cpp
    // #include <algorithm> 
    // #include <functional> 

    vector<int> v1 { 1, 2, 3, 4, 5 }; 
    vector<int> v2(v1.size()); 
    fill(v2.begin(), v2.end(), 2); 
    vector<int> result(v1.size()); 

    transform(v1.begin(), v1.end(), v2.begin(), 
        result.begin(), modulus<int>()); 

    for (int i : result) 
    { 
        cout << i << ' '; 
    } 
    cout << endl;
```

这段代码将对两个向量中的值执行五次模数计算。在概念上，它是这样做的：

```cpp
    result = v1 % v2;
```

也就是说，`result`中的每个项目都是`v1`和`v2`中相应项目的模数。在代码中，第一行创建了一个具有五个值的`vector`。我们将计算这些值与`2`的模数，因此第二行声明了一个空的`vector`，但与第一个`vector`具有相同的容量。通过调用`fill`函数填充了这个第二个`vector`。第一个参数是`vector`中第一个项目的地址，`end`函数返回`vector`中最后一个项目之后的地址。函数调用的最后一个项目是将在从第一个参数指向的项目开始到但不包括第二个参数指向的项目的每个项目中放置在`vector`中的值。

此时，第二个`vector`将包含五个项目，每个项目都将是`2`。接下来，为结果创建一个`vector`；再次，它与第一个数组的大小相同。最后，通过`transform`函数执行计算，再次显示如下：

```cpp
    transform(v1.begin(), v1.end(),  
       v2.begin(), result.begin(), modulus<int>());
```

前两个参数给出了第一个`vector`的迭代器，从中可以计算出项目的数量。由于所有三个`vector`的大小相同，因此只需要`v2`和`result`的`begin`迭代器。

最后一个参数是函数对象。这是一个临时对象，仅在此语句期间存在；它没有名称。此处使用的语法是对类的构造函数的显式调用；它是模板化的，因此您需要提供模板参数。`transform`函数将对`v1`中的每个项目调用此函数对象的`operator(int,int)`函数作为第一个参数，并将`v2`中的相应项目作为第二个参数，并将结果存储在`result`中的相应位置。

由于`transform`接受任何二元函数对象作为第二个参数，您可以传递`plus<int>`的实例以将值 2 添加到`v1`中的每个项目，或者传递`multiplies<int>`的实例以将`v1`中的每个项目乘以 2。

函数对象非常有用的一种情况是使用谓词进行多个比较时。谓词是一个比较值并返回布尔值的函数对象。`<functional>`头文件包含几个类，允许您比较项目。让我们看看`result`容器中有多少个项目为零。为此，我们使用`count_if`函数。这将遍历容器，将谓词应用于每个项目，并计算谓词返回`true`值的次数。有几种方法可以做到这一点。第一种定义了一个谓词函数：

```cpp
    bool equals_zero(int a) 
    { 
        return (a == 0); 
    }
```

然后可以将指针传递给`count_if`函数：

```cpp
    int zeros = count_if( 
       result.begin(), result.end(), equals_zero);
```

前两个参数指示要检查的值的范围。最后一个参数是指向用作谓词的函数的指针。当然，如果要检查不同的值，可以使其更通用：

```cpp
    template<typename T, T value> 
    inline bool equals(T a) 
    { 
        return a == value; 
    }
```

像这样调用它：

```cpp
    int zeros = count_if( 
       result.begin(), result.end(), equals<int, 0>);
```

这段代码的问题在于我们在使用操作的地方定义了操作。`equals`函数可以在另一个文件中定义；但是，对于谓词，将检查代码定义在需要谓词的代码附近更易读。

`<functional>`头文件还定义了可以用作函数对象的类。例如，`equal_to<int>`，它比较两个值。但是，`count_if`函数期望一个一元函数对象，它将传递一个单个值（参见前面描述的`equals_zero`函数）。`equal_to<int>`是一个二元函数对象，比较两个值。我们需要提供第二个操作数，为此我们使用名为`bind2nd`的辅助函数：

```cpp
    int zeros = count_if( 
       result.begin(), result.end(), bind2nd(equal_to<int>(), 0));
```

`bind2nd`将参数`0`*绑定*到从`equal_to<int>`创建的函数对象。像这样使用函数对象将谓词的定义更接近将使用它的函数调用，但语法看起来相当混乱。C++11 提供了一种机制，可以让编译器确定所需的函数对象并将参数绑定到它们。这些被称为 lambda 表达式。

# 介绍 lambda 表达式

lambda 表达式用于在将使用函数对象的位置创建一个匿名函数对象。这使得您的代码更易读，因为您可以看到将要执行的内容。乍一看，lambda 表达式看起来像是在函数参数的地方定义一个函数：

```cpp
    auto less_than_10 = [](int a) {return a < 10; }; 
    bool b = less_than_10(4);
```

为了避免使用谓词的复杂性，在这段代码中，我们将一个变量分配给了 lambda 表达式。这通常不是您使用它的方式，但这样做可以使描述更清晰。lambda 表达式开头的方括号称为**捕获列表**。这个表达式不捕获变量，所以方括号是空的。您可以使用在 lambda 表达式外声明的变量，这些变量必须被*捕获*。捕获列表指示所有这些变量是通过引用（使用`[&]`）还是通过值（使用`[=]`）捕获。您还可以命名将被捕获的变量（如果有多个，使用逗号分隔的列表），如果它们被值捕获，只需使用它们的名称。如果它们被引用捕获，使用它们的名称上加`&`。

您可以通过引入在表达式外声明的名为`limit`的变量，使前面的 lambda 表达式更通用：

```cpp
    int limit = 99; 
    auto less_than = limit {return a < limit; };
```

如果将 lambda 表达式与全局函数进行比较，捕获列表有点像标识全局函数可以访问的全局变量。

在捕获列表之后，您在括号中给出参数列表。同样，如果将 lambda 与函数进行比较，lambda 参数列表等同于函数参数列表。如果 lambda 表达式没有任何参数，那么可以完全省略括号。

lambda 的主体用一对大括号给出。这可以包含任何可以在函数中找到的内容。lambda 主体可以声明局部变量，甚至可以声明`static`变量，这看起来很奇怪，但是合法的：

```cpp
    auto incr = [] { static int i; return ++i; }; 
    incr(); 
    incr(); 
    cout << incr() << endl; // 3
```

lambda 的返回值是从返回的项推断出来的。lambda 表达式不一定要返回一个值，如果是这种情况，表达式将返回`void`：

```cpp
    auto swap = [](int& a, int& b) { int x = a; a = b; b = x; }; 
    int i = 10, j = 20; 
    cout << i << " " << j << endl; 
    swap(i, j); 
    cout << i << " " << j << endl;
```

lambda 表达式的强大之处在于，您可以在需要函数对象或谓词的情况下使用它们：

```cpp
    vector<int> v { 1, 2, 3, 4, 5 }; 
    int less_than_3 = count_if( 
       v.begin(), v.end(),  
       [](int a) { return a < 3; }); 
    cout << "There are " << less_than_3 << " items less than 3" << endl;
```

在这里，我们声明了一个`vector`并用一些值初始化它。`count_if`函数用于计算容器中有多少项小于 3。因此，前两个参数用于给出要检查的项的范围，第三个参数是执行比较的 lambda 表达式。`count_if`函数将为传递给 lambda 的`a`参数的范围中的每个项调用此表达式。`count_if`函数会持续计算 lambda 返回`true`的次数。

# 在 C++中使用函数

本章的示例使用了本章学到的技术，以按文件大小顺序列出文件夹和子文件夹中的所有文件，给出文件名和它们的大小。该示例相当于在命令行中输入以下内容：

```cpp
dir /b /s /os /a-d folder
```

在这里，`folder`是您要列出的文件夹。`/s`选项进行递归，`/a-d`从列表中移除文件夹，`/os`按大小排序。问题在于，如果没有`/b`选项，我们会得到有关每个文件夹的信息，但使用它会移除列表中的文件大小。我们希望得到按最小文件大小排序的文件名（及其路径）列表和它们的大小。

首先，在`Beginning_C++`文件夹下创建一个新的文件夹，名为`Chapter_05`。在 Visual C++中创建一个新的 C++源文件，并将其保存为`files.cpp`，保存在这个新文件夹下。示例将使用基本的输出和字符串。它将接受一个命令行参数；如果传递了更多的命令行参数，我们将只使用第一个。将以下内容添加到`files.cpp`中：

```cpp
    #include <iostream> 
    #include <string> 
    using namespace std; 

    int main(int argc, char* argv[]) 
    { 
        if (argc < 2) return 1; 
        return 0; 
    }
```

示例将使用 Windows 函数`FindFirstFile`和`FindNextFile`来获取符合文件规范的文件的信息。这些函数返回一个`WIN32_FIND_DATAA`结构中的数据，其中包含有关文件名、文件大小和文件属性的信息。这些函数还返回有关文件夹的信息，这意味着我们可以测试子文件夹并进行递归。`WIN32_FIND_DATAA`结构以两部分的 64 位数字形式给出文件大小：高 32 位和低 32 位。我们将创建我们自己的结构来保存这些信息。在 C++包含文件之后的文件顶部添加以下内容：

```cpp
    using namespace std; 

    #include <windows.h> struct file_size { unsigned int high; unsigned int low; };
```

第一行是 Windows SDK 头文件，这样您就可以访问 Windows 函数，结构用于保存有关文件大小的信息。我们想要通过它们的大小来比较文件。`WIN32_FIND_DATAA`结构提供了两个`unsigned long`成员的大小（一个带有高 4 个字节，另一个带有低 4 个字节）。我们可以将其存储为 64 位数字，但是为了有借口编写一些运算符，我们将大小存储在我们的`file_size`结构中。示例将打印文件大小，并将比较文件大小，因此我们将编写一个运算符将`file_size`对象插入输出流；由于我们想按大小对文件进行排序，我们需要一个运算符来确定一个`file_size`对象是否大于另一个。

该代码将使用 Windows 函数获取有关文件的信息，特别是它们的名称和大小。这些信息将存储在一个`vector`中，因此在文件顶部添加这两行：

```cpp
    #include <string> 
    #include <vector>
 #include <tuple>
```

`tuple`类是必需的，这样我们就可以将`string`（文件名）和`file_size`对象作为`vector`中的每个项目进行存储。为了使代码更易读，在结构定义之后添加以下别名：

```cpp
    using file_info = tuple<string, file_size>;
```

然后在`main`函数的上面添加获取文件夹中文件的函数的框架代码：

```cpp
    void files_in_folder( 
       const char *folderPath, vector<file_info>& files) 
    { 
    }
```

这个函数接受一个`vector`的引用和一个文件夹路径。代码将遍历指定文件夹中的每个项目。如果它是一个文件，它将把详细信息存储在`vector`中；否则，如果项目是一个文件夹，它将调用自身来获取该子文件夹中的文件。在`main`函数的底部添加对这个函数的调用：

```cpp
    vector<file_info> files; 
    files_in_folder(argv[1], files);
```

代码已经检查了至少有一个命令行参数，并且我们将其用作要检查的文件夹。`main`函数应该打印文件信息，因此我们在堆栈上声明一个`vector`，并将其通过引用传递给`files_in_folder`函数。到目前为止，这段代码什么也没做，但您可以编译代码以确保没有拼写错误（记得使用`/EHsc`参数）。

大部分工作是在`files_in_folder`函数中完成的。首先，在这个函数中添加以下代码：

```cpp
    string folder(folderPath); 
    folder += "*"; 
    WIN32_FIND_DATAA findfiledata {}; 
    void* hFind = FindFirstFileA(folder.c_str(), &findfiledata); 

    if (hFind != INVALID_HANDLE_VALUE) 
    { 
       do 
       { 
       } while (FindNextFileA(hFind, &findfiledata)); 
       FindClose(hFind); 
    }
```

我们将使用函数的 ASCII 版本（因此在结构和函数名称后面加上`A`）。`FindFirstFileA`函数接受一个搜索路径，在这种情况下，我们使用一个带有`*`后缀的文件夹名称，表示*这个文件夹中的所有内容*。请注意，Windows 函数需要一个`const char*`参数，因此我们在`string`对象上使用`c_str`函数。

如果函数调用成功并找到符合条件的项目，那么函数会填充传递的`WIN32_FIND_DATAA`结构，并返回一个不透明指针，该指针将用于对此搜索进行后续调用（您不需要知道它指向什么）。代码检查调用是否成功，如果成功，它会重复调用`FindNextFileA`以获取下一个项目，直到此函数返回 0，表示没有更多项目。不透明指针被传递给`FindNextFileA`，以便它知道正在检查哪个搜索。搜索完成后，代码调用`FindClose`来释放 Windows 为搜索分配的任何资源。

搜索将返回文件和文件夹项目；为了分别处理每个项目，我们可以测试`WIN32_FIND_DATAA`结构的`dwFileAttributes`成员。在`do`循环中添加以下代码：

```cpp
    string findItem(folderPath); 
    findItem += ""; 
    findItem += findfiledata.cFileName; 
    if ((findfiledata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) 
    { 
        // this is a folder so recurse 
    } 
    else 
    { 
        // this is a file so store information 
    }
```

`WIN32_FIND_DATAA`结构只包含文件夹中项目的相对名称，因此前几行创建了绝对路径。接下来的几行测试项目是文件夹（目录）还是文件。如果项目是文件，那么我们只需将其添加到传递给函数的向量中。将以下内容添加到`else`子句中：

```cpp
    file_size fs{}; 
    fs.high = findfiledata.nFileSizeHigh; 
    fs.low = findfiledata.nFileSizeLow; 
    files.push_back(make_tuple(findItem, fs));
```

第一、二、三行初始化了一个`file_size`结构，其中包含了大小数据，最后一行将文件名和大小的`tuple`添加到了`vector`中。这样你就可以看到对这个函数的简单调用的结果了，将以下内容添加到`main`函数的底部：

```cpp
    for (auto file : files) 
    { 
        cout << setw(16) << get<1>(file) << " "  
            << get<0>(file) << endl; 
    }
```

这遍历了`files`向量中的项目。每个项目都是一个`tuple<string, file_size>`对象，要获取`string`项目，可以使用标准库函数`get`，使用 0 作为函数模板参数，要获取`file_size`对象，可以使用 1 作为函数模板参数调用`get`。代码调用`setw`操纵器，以确保文件大小始终以 16 个字符宽的列打印出来。要使用这个，您需要在文件顶部添加一个`<iomanip>`包含。注意，`get<1>`将返回一个`file_size`对象，并将其插入`cout`。目前，这段代码无法编译，因为没有操作符来执行这个操作。我们需要编写一个。

在结构的定义之后，添加以下代码：

```cpp
    ostream& operator<<(ostream& os, const file_size fs) 
    { 
        int flags = os.flags(); 
        unsigned long long ll = fs.low + 
            ((unsigned long long)fs.high << 32); 
        os << hex << ll; 
        os.setf(flags); 
        return os; 
    }
```

这个操作符将改变`ostream`对象，所以我们在函数开始时存储初始状态，并在结束时将对象恢复到这个状态。由于文件大小是一个 64 位数字，我们将`file_size`对象的组成部分转换为十六进制数并打印出来。

现在您可以编译并运行此应用程序。例如：

```cpp
files C: \windows
```

这将列出`windows`文件夹中文件的名称和大小。

还有两件事情需要做--递归子文件夹和对数据进行排序。这两个都很容易实现。在`files_in_folder`函数中，将以下代码添加到`if`语句的代码块中：

```cpp
    // this is a folder so recurse 
    string folder(findfiledata.cFileName); 
    // ignore . and .. directories 
    if (folder != "." && folder != "..") 
    { 
        files_in_folder(findItem.c_str(), files); 
    }
```

搜索将返回`.`（当前）文件夹和`..`（父级）文件夹，因此我们需要检查并忽略它们。下一步是递归调用`files_in_folder`函数以获取子文件夹中的文件。如果您愿意，您可以编译和测试应用程序，但这次最好使用`Beginning_C++`文件夹来测试代码，因为递归列出 Windows 文件夹将产生大量文件。

代码返回了文件列表，但我们希望按文件大小的顺序查看它们。为此，我们可以使用`<algorithm>`头文件中的排序函数，所以在`<tuple>`的包含之后添加一个包含。在`main`函数中，在对`files_in_folder`的调用之后，添加以下代码：

```cpp
    files_in_folder(argv[1], files); 

    sort(files.begin(), files.end(), 
        [](const file_info& lhs, const file_info& rhs) { 
            return get<1>(rhs) > get<1>(lhs);    
    } );
```

`sort`函数的前两个参数表示要检查的项目范围。第三个项目是一个谓词，函数将把`vector`中的两个项目传递给谓词。如果两个参数顺序正确（第一个小于第二个），则必须返回`true`值。

谓词由 lambda 表达式提供。没有捕获的变量，所以表达式以`[]`开头，然后是由`sort`算法比较的项目的参数列表（通过`const`引用传递，因为它们不会被更改）。实际比较是在大括号之间进行的。由于我们想按升序列出文件，我们必须确保两者中的第二个大于第一个。在这段代码中，我们在两个`file_size`对象上使用`>`运算符。为了使这段代码编译，我们需要定义这个运算符。在插入运算符之后添加以下内容：

```cpp
    bool operator>(const file_size& lhs, const file_size& rhs) 
    { 
        if (lhs.high > rhs.high) return true; 
        if (lhs.high == rhs.high) { 
            if (lhs.low > rhs.low) return true; 
        } 
        return false; 
    }
```

现在可以编译示例并运行它。您应该发现指定文件夹和子文件夹中的文件按文件大小顺序列出。

# 摘要

函数允许您将代码分割为逻辑程序，这使得您的代码更易读，并且具有能够重用代码的灵活性。C++提供了丰富的选项来定义函数，包括可变参数列表、模板、函数指针和 lambda 表达式。然而，全局函数存在一个主要问题：数据与函数分离。这意味着函数必须通过全局数据项访问数据，或者数据必须在每次调用函数时通过参数传递给函数。在这两种情况下，数据存在于函数之外，并且可能被与数据无关的其他函数使用。下一章将提供解决方案：类。`class`允许您将数据封装在自定义类型中，并且您可以在该类型上定义函数，以便只有这些函数才能访问数据。
