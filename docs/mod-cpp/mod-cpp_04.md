# 第四章：类

C++允许您创建自己的类型。这些自定义类型可以具有运算符，并且可以转换为其他类型；实际上，它们可以像内置类型一样使用，具有您定义的行为。这个功能使用了一个称为类的语言特性。能够定义自己的类型的优势在于，您可以将数据封装在您选择的类型的对象中，并使用该类型来管理该数据的生命周期。您还可以定义可以对该数据执行的操作。换句话说，您可以定义具有状态和行为的自定义类型，这是面向对象编程的基础。

# 编写类

当您使用内置类型时，数据直接可供访问该数据的任何代码。C++提供了一种机制（`const`）来防止写访问，但任何代码都可以使用`const_cast`来去除`const`。您的数据可能很复杂，例如指向映射到内存中的文件的指针，意图是您的代码将更改一些字节，然后将文件写回磁盘。这样的原始指针是危险的，因为其他代码可以访问指针并更改不应更改的缓冲区的一部分。需要的是一种将数据封装到了解要更改哪些字节的类型中，并且只允许该类型访问数据的机制。这是类的基本思想。

# 回顾结构

我们已经看到了 C++中封装数据的一种机制：`struct`。结构允许您声明内置类型、指针或引用的数据成员。当您从该`struct`创建变量时，您正在创建该结构的**实例**，也称为**对象**。您可以创建引用该对象的变量或指向该对象的指针。甚至可以将对象按值传递给函数，编译器将对对象进行复制（它将调用`struct`的*复制构造函数*）。

我们已经看到，对于`struct`，任何可以访问实例的代码（甚至通过指针或引用）都可以访问对象的成员（尽管这可能会改变）。这样使用，`struct`可以被视为包含状态的**聚合**类型。

`struct`的实例的成员可以通过直接使用点运算符初始化，也可以通过指向对象的指针使用`->`运算符进行初始化。我们还看到，您可以使用初始化器列表（在大括号中）初始化`struct`的实例。这是相当受限制的，因为初始化器列表必须与`struct`中的数据成员匹配。在第二章中，*使用内存、数组和指针*，您看到可以将指针作为`struct`的成员，但必须明确采取适当的操作来释放指针指向的内存；如果不这样做，可能会导致内存泄漏。

`struct`是您可以在 C++中使用的类类型之一；另外两个是`union`和`class`。定义为`struct`或`class`的自定义类型也可以具有行为和状态，C++允许您定义一些特殊函数来控制实例的创建和销毁、复制和转换。此外，您可以在`struct`或`class`类型上定义运算符，以便您可以在实例上使用运算符，类似于在内置类型上使用运算符。`struct`和`class`之间存在差异，我们将在后面讨论，但总的来说，本章的其余部分将涉及类，当提到`class`时，通常可以假定相同的内容也适用于`struct`。

# 定义类

在一个语句中定义了一个类，并且将在由大括号`{}`括起来的多个语句块中定义其成员。由于这是一个语句，所以必须在最后一个大括号后面加上分号。一个类可以在头文件中定义（就像许多**C++标准库**类一样），但是你必须采取措施确保这样的文件只在源文件中包含一次。然而，关于类中必须在源文件中定义的特定项目有一些规则，这将在后面介绍。

如果你浏览 C++标准库，你会发现类包含成员函数，并且试图将类的所有代码放入单个头文件中，这使得代码难以阅读和理解。这可能是有道理的，对于由大量专业 C++程序员维护的库文件，但对于你自己的项目来说，可读性应该是一个关键的设计目标。因此，C++类可以在 C++头文件中声明，包括其成员函数，并且函数的实际实现可以放在源文件中。这使得头文件更容易维护和更可重用。

# 定义类的行为

一个类可以定义只能通过类的实例调用的函数；这样的函数通常被称为**方法**。一个对象将有状态；这是由类定义的数据成员提供的，并且在创建对象时初始化。对象上的方法定义了对象的行为，通常作用于对象的状态。当你设计一个类时，你应该这样考虑方法：它们描述了对象在做某事。

```cpp
    class cartesian_vector 
    { 
    public: 
        double x; 
        double y; 
        // other methods 
        double get_magnitude() { return std::sqrt((x * x) + (y * y)); } 
    };
```

这个类有两个数据成员，`x`和`y`，它们表示笛卡尔 x 和 y 方向上的二维向量的方向。`public`关键字意味着在此指定符号之后定义的任何成员都可以被类外定义的代码访问。默认情况下，类的所有成员都是`private`的，除非你另有说明。`private`意味着该成员只能被类的其他成员访问。

这是`struct`和`class`之间的区别：默认情况下，`struct`的成员是`public`的，而默认情况下，`class`的成员是`private`的。

这个类有一个名为`get_magnituide`的方法，它将返回笛卡尔向量的长度。这个函数作用于类的两个数据成员并返回一个值。这是一种**访问器**方法；它允许访问对象的状态。这样的方法在`class`上很典型，但没有要求方法返回值。像函数一样，方法也可以接受参数。`get_magnituide`方法可以这样调用：

```cpp
    cartesian_vector vec { 3.0, 4.0 }; 
    double len = vec.get_magnitude(); // returns 5.0
```

在堆栈上创建了一个`cartesian_vector`对象，并使用列表初始化语法将其初始化为表示向量`(3,4)`的值。这个向量的长度是 5，这是通过调用对象的`get_magnitude`返回的值。

# 使用这个指针

类中的方法有一种特殊的调用约定，在 Visual C++中称为`__thiscall`。原因是类中的每个方法都有一个名为`this`的隐藏参数，它是指向当前实例的类类型的指针：

```cpp
    class cartesian_vector 
    { 
    public: 
        double x; 
        double y; 
        // other methods 
        double get_magnitude() 
        { 
             return std::sqrt((this->x * this->x) + (this->y * this->y)); 
        } 
    };
```

在这里，`get_magnitude`方法返回`cartesian_vector`对象的长度。通过`->`运算符访问对象的成员。如前所示，可以在不使用`this`指针的情况下访问类的成员，但这确实明确了这些项是类的成员。

你可以在`cartesian_vector`类型上定义一个方法，允许你改变它的状态：

```cpp
    class cartesian_vector 
    { 
    public: 
        double x; 
        double y; 
        reset(double x, double y) { this->x = x; this->y = y; } 
        // other methods 
    };
```

`reset`方法的参数与类的数据成员具有相同的名称；然而，由于我们使用了`this`指针，编译器知道这不会产生歧义。

您可以使用`*`运算符对`this`指针进行解引用，以访问对象。当成员函数必须返回对当前对象的引用时（正如我们稍后将看到的一些运算符），这是很有用的，您可以通过返回`*this`来实现。类中的方法还可以将`this`指针传递给外部函数，这意味着它通过类型化指针通过引用传递当前对象。

# 使用作用域解析运算符

在`class`语句中可以内联定义一个方法，但也可以分开声明和实现，因此方法在`class`语句中声明，但在其他地方定义。在`class`语句之外定义方法时，需要使用作用域解析运算符为该类型的方法提供名称。例如，使用之前的`cartesian_vector`示例：

```cpp
    class cartesian_vector 
    { 
    public: 
        double x; 
        double y; 
        // other methods 
        double magnitude(); 
    }; 

    double cartesian_vector::magnitude() 
    { 
        return sqrt((this->x * this->x) + (this->y * this->y)); 
    }
```

该方法在类定义之外定义；但是，它仍然是类方法，因此具有`this`指针，可用于访问对象的成员。通常，类将在头文件中声明方法的原型，并且实际方法将在单独的源文件中实现。在这种情况下，使用`this`指针访问类成员（方法和数据成员）使得当您粗略查看源文件时，函数是类的方法是显而易见的。

# 定义类状态

您的类可以具有内置类型作为数据成员，也可以具有自定义类型。这些数据成员可以在类中声明（并在构造类的实例时创建），也可以是指向在自由存储中创建的对象或引用在其他地方创建的对象的指针。请记住，如果您有一个指向在自由存储中创建的项目的指针，您需要知道谁负责释放指针指向的内存。如果您有一个引用（或指针）指向在某个堆栈帧上创建的对象，则需要确保您的类的对象的生存时间不会超过该堆栈帧。

当您将数据成员声明为`public`时，这意味着外部代码可以读取和写入数据成员。

您可以决定只提供只读访问权限，这种情况下，可以将成员设为`private`，并通过访问器提供读取访问权限：

```cpp
    class cartesian_vector 
    { 
        double x; 
        double y; 
    public: 
        double get_x() { return this->x; } 
        double get_y() { return this->y; } 
        // other methods 
    };
```

当您将数据成员`private`时，这意味着您不能使用初始化程序列表语法来初始化对象，但我们稍后会解决这个问题。您可以决定使用访问器来给数据成员提供写入访问权限，并使用此来检查值。

```cpp
    void cartesian_vector::set_x(double d) 
    { 
        if (d > -100 && d < 100) this->x = d; 
    }
```

这是一种范围必须在（但不包括）-100 和 100 之间的类型。

# 创建对象

您可以在堆栈或自由存储中创建对象。使用前面的示例，如下所示：

```cpp
    cartesian_vector vec { 10, 10 }; 
    cartesian_vector *pvec = new cartesian_vector { 5, 5 }; 
    // use pvec 
    delete pvec
```

这是对象的**直接初始化**，假设`cartesian_vector`的数据成员是`public`。`vec`对象在堆栈上创建并使用初始化列表进行初始化。在第二行，对象在自由存储中创建并使用初始化列表进行初始化。自由存储中的对象必须在某个时候被释放，这是通过删除指针来完成的。`new`运算符将为类的数据成员和类所需的任何基础设施在自由存储中分配足够的内存。

C++11 的一个新特性是允许直接初始化以在类中提供默认值：

```cpp
    class point 
    { 
    public: 
        int x = 0; 
        int y = 0; 
    };
```

这意味着如果您创建一个`point`实例而没有任何其他初始化值，它将被初始化，以便`x`和`y`都为零。如果数据成员是内置数组，则可以在类中使用初始化列表进行直接初始化：

```cpp
    class car 
    { 
    public: 
        double tire_pressures[4] { 25.0, 25.0, 25.0, 25.0 }; 
    };
```

C++标准库容器可以使用初始化列表进行初始化，因此，在这个`tire_pressures`类中，我们可以使用`vector<double>`或`array<double,4>`，并以相同的方式进行初始化，而不是声明类型为`double[4]`。

# 对象的构造

C++允许你定义特殊的方法来执行对象的初始化。这些被称为**构造函数**。在 C++11 中，你将默认获得三个这样的函数，但如果你愿意，你可以提供自己的版本。这三个构造函数以及另外三个相关函数如下：

+   默认构造函数：这是用来创建一个具有*默认*值的对象。

+   复制构造函数：这用于基于现有对象的值创建一个新对象。

+   移动构造函数：这用于使用从现有对象移动的数据创建新对象。

+   析构函数：这是用来清理对象使用的资源。

+   复制赋值：这将数据从一个现有对象复制到另一个现有对象。

+   移动赋值：这将数据从一个现有对象移动到另一个现有对象。

这些函数的编译器创建的版本将被隐式地设为`public`；然而，你可以决定通过定义自己的版本并将它们设为`private`，或者你可以使用`=delete`语法删除它们，从而阻止复制或赋值。

你也可以提供自己的构造函数，以便使用你决定需要初始化新对象的任何参数。

构造函数是一个与类型同名的成员函数，但它不返回值，所以如果构造失败，你不能返回值，这可能意味着调用者将收到一个部分构造的对象。处理这种情况的唯一方法是抛出异常（在第七章中解释，*诊断和调试*）。

# 定义构造函数

当对象创建时没有值时，将使用默认构造函数，因此对象将必须用默认值初始化。之前声明的`point`可以这样实现：

```cpp
    class point 
    { 
        double x; double y; 
    public: 
        point() { x = 0; y = 0; } 
    };
```

这将明确地将项目初始化为零值。如果你想创建一个具有默认值的实例，你不需要包括括号。

```cpp
    point p;   // default constructor called
```

重要的是要注意这个语法，因为很容易出错地写成以下形式：

```cpp
    point p();  // compiles, but is a function prototype!
```

这将编译，因为编译器会认为你提供了一个函数原型作为前向声明。然而，当你尝试使用符号`p`作为变量时，你会得到一个错误。你也可以使用空括号的初始化列表语法调用默认构造函数：

```cpp
    point p {};  // calls default constructor
```

虽然在这种情况下并不重要，数据成员是内置类型，但在构造函数体中像这样初始化数据成员涉及到调用成员类型的赋值运算符。更有效的方法是使用**成员列表**进行直接初始化。

以下是一个带有两个参数的构造函数，用来说明成员列表：

```cpp
    point(double x, double y) : x(x), y(y) {}
```

括号外的标识符是类成员的名称，括号内的项目是用来初始化该成员的表达式（在这种情况下是构造函数参数）。这个例子使用`x`和`y`作为参数名。你不必这样做；这里只是给出一个例子，说明编译器将区分参数和数据成员。你也可以在构造函数的成员列表中使用大括号初始化语法：

```cpp
    point(double x, double y) : x{x}, y{y} {}
```

当你像这样创建一个对象时，你调用这个构造函数：

```cpp
    point p(10.0, 10.0);
```

你也可以创建一个对象数组：

```cpp
    point arr[4];
```

这将创建四个`point`对象，可以通过对`arr`数组进行索引访问。请注意，当你创建一个对象数组时，会调用*默认*构造函数；没有办法调用任何其他构造函数，所以你必须分别初始化每一个。

您还可以为构造函数参数提供默认值。在下面的代码中，`car`类为四个轮胎（前两个是前轮胎）和备用轮胎设置了值。有一个构造函数具有用于前后轮胎的必需值，并为备用轮胎提供了一个可选值。如果没有为备用轮胎压力提供值，则将使用默认值：

```cpp
    class car 
    { 
        array<double, 4> tire_pressures;; 
        double spare; 
    public: 
        car(double front, double back, double s = 25.0)  
          : tire_pressures{front, front, back, back}, spare{s} {} 
    };
```

这个构造函数可以用两个值或三个值来调用：

```cpp
    car commuter_car(25, 27); 
    car sports_car(26, 28, 28);
```

# 委托构造函数

构造函数可以使用相同的成员列表语法调用另一个构造函数：

```cpp
    class car 
    { 
        // data members 
    public: 
        car(double front, double back, double s = 25.0)  
           : tire_pressures{front, front, back, back}, spare{s} {} 
        car(double all) : car(all, all) {} 
    };
```

在这里，接受一个值的构造函数委托给接受三个参数的构造函数（在这种情况下使用备用值）。

# 复制构造函数

当您按值传递对象（或按值返回）或者基于另一个对象显式构造对象时，将使用复制构造函数。以下两行都从另一个`point`对象创建了一个`point`对象，而且在这两种情况下都调用了复制构造函数：

```cpp
    point p1(10, 10); 
    point p2(p1); 
    point p3 = p1;
```

最后一行看起来涉及赋值运算符，但实际上调用了复制构造函数。复制构造函数可以这样实现：

```cpp
    class point 
    { 
        int x = 0;int y = 0; 
    public: 
        point(const point& rhs) : x(rhs.x), y(rhs.y) {} 
    };
```

初始化访问另一个对象（`rhs`）的`private`数据成员。这是可以接受的，因为构造函数参数与正在创建的对象的类型相同。复制操作可能并不像这样简单。例如，如果类包含一个指针数据成员，您很可能希望复制指针指向的数据，并且这将涉及在新对象中创建一个新的内存缓冲区。

# 类型转换

您还可以执行转换。在数学中，您可以定义一个表示方向的向量，以便两点之间的连线是一个向量。在我们的代码中，我们已经定义了一个`point`类和一个`cartesian_vector`类。您可以决定创建一个构造函数，该构造函数创建原点和一个点之间的向量，这样您就将一个`point`对象转换为一个`cartesian_vector`对象：

```cpp
    class cartesian_vector 
    { 
        double x; double y;  
    public: 
        cartesian_vector(const point& p) : x(p.x), y(p.y) {} 
    };
```

这里有一个问题，我们马上就会解决。可以这样调用转换：

```cpp
    point p(10, 10); 
    cartesian_vector v1(p); 
    cartesian_vector v2 { p }; 
    cartesian_vector v3 = p;
```

# 交朋友

上面代码的问题在于`cartesian_vector`类访问了`point`类的`private`成员。由于我们已经编写了这两个类，我们很乐意打破规则，因此我们将`cartesian_vector`类声明为`point`类的`friend`：

```cpp
    class cartesian_vector; // forward decalartion 

    class point 
    { 
        double x; double y; 
    public: 
        point(double x, double y) : x(x), y(y){} 
        friend class cartesian_point; 
    };
```

由于`cartesian_vector`类在`point`类之后声明，我们必须提供一个前向声明，告诉编译器名称`cartesian_vector`即将被使用，并且将在其他地方声明。重要的一行以`friend`开头。这表明整个`cartesian_vector`类的代码可以访问`point`类的私有成员（数据和方法）。

您还可以声明`friend`函数。例如，您可以声明一个运算符，使得`point`对象可以插入到`cout`对象中，以便可以打印到控制台。您不能更改`ostream`类，但可以定义一个全局方法：

```cpp
    ostream& operator<<(ostream& stm, const point& pt) 
    { 
        stm << "(" << pt.x << "," << pt.y << ")"; 
        return stm; 
    }
```

此函数访问`point`的`private`成员，因此您必须将该函数声明为`point`类的`friend`：

```cpp
    friend ostream& operator<<(ostream&, const point&);
```

这样的`friend`声明必须在`point`类中声明，但放在`public`或`private`部分都无关紧要。

# 将构造函数标记为显式

在某些情况下，您不希望允许将一个类型隐式转换为另一个类型的构造函数的参数。为此，您需要使用`explicit`说明符标记构造函数。这意味着现在唯一调用构造函数的方式是使用括号语法：*显式*调用构造函数。在下面的代码中，您不能将`double`隐式转换为`mytype`的对象：

```cpp
    class mytype  
    { 
    public: 
        explicit mytype(double x); 
    };
```

现在你必须*显式*调用构造函数，如果你想要用`double`参数创建一个对象：

```cpp
    mytype t1 = 10.0; // will not compile, cannot convert 
    mytype t2(10.0);  // OK
```

# 对象的销毁

当对象被销毁时，会调用一个特殊的方法，称为析构函数。这个方法的名称是类的名称前缀加上一个`~`符号，它不返回值。

如果对象是一个自动变量，位于堆栈上，那么当变量超出作用域时它将被销毁。当对象按值传递时，在被调用的函数的堆栈上会进行一次复制，当被调用的函数完成时对象将被销毁。此外，函数的完成方式并不重要，无论是显式调用`return`还是达到最终的大括号，或者抛出异常；在所有这些情况下，都会调用析构函数。如果在一个函数中有多个对象，析构函数的调用顺序与在相同作用域中对象的构造顺序相反。如果你创建一个对象数组，那么在声明数组时将为数组中的每个对象调用默认构造函数，并且当数组超出作用域时所有的对象都将被销毁--并且每个对象的析构函数都会被调用。

以下是一些示例，对于一个类`mytype`：

```cpp
    void f(mytype t) // copy created 
    { 
        // use t 
    }   // t destroyed 

    void g() 
    { 
        mytype t1; 
        f(t1); 
        if (true) 
        { 
            mytype t2; 
        }   // t2 destroyed 

        mytype arr[4]; 
    }  // 4 objects in arr destroyed in reverse order to creation 
       // t1 destroyed
```

当你返回一个对象时，会发生一个有趣的动作。以下注释是你所期望的：

```cpp
    mytype get_object() 
    { 
        mytype t;               // default constructor creates t 
        return t;               // copy constructor creates a temporary 
    }                           // t destroyed 

    void h() 
    { 
        test tt = get_object(); // copy constructor creates tt 
    }                           // temporary destroyed, tt destroyed
```

实际上，这个过程更加简化。在调试构建中，编译器会看到在`get_object`函数返回时创建的临时对象将作为变量`tt`使用的对象，因此在`get_object`函数的返回值上不会有额外的复制。函数实际上看起来是这样的：

```cpp
    void h() 
    { 
        mytype tt = get_object();  
    }   // tt destroyed
```

然而，编译器能够进一步优化代码。在发布构建中（启用了优化），临时对象将不会被创建，调用函数中的对象`tt`将是在`get_object`中创建的实际对象`t`。

当你显式删除在自由存储上分配的对象的指针时，对象将被销毁。在这种情况下，对析构函数的调用是确定的：当你的代码调用`delete`时会被调用。同样，对于相同的类`mytype`，这是如下的：

```cpp
    mytype *get_object() 
    { 
        return new mytype; // default constructor called 
    } 

    void f() 
    { 
        mytype *p = get_object(); 
        // use p 
        delete p;        // object destroyed 
    }
```

有时你会希望使用删除对象的确定性方面（可能会忘记调用`delete`的危险），有时你会更喜欢在适当的时间销毁对象的保证（可能会在以后的时间）。

如果一个类的数据成员是一个带有析构函数的自定义类型，那么当包含对象被销毁时，也会调用包含对象上的析构函数。尽管如此，请注意这仅适用于*对象*是类成员的情况。如果一个类成员是指向自由存储中的对象的指针，那么你必须在包含对象的析构函数中显式删除指针。然而，你需要知道指针指向的对象在哪里，因为如果它不在自由存储中，或者对象被其他对象使用，调用`delete`会引起问题。

# 分配对象

赋值运算符在将一个*已经创建*的对象分配给另一个值时被调用。默认情况下，你会得到一个复制赋值运算符，它将复制所有的数据成员。这不一定是你想要的，特别是如果对象有一个数据成员是指针的情况下，此时你更有可能想要进行深拷贝，复制指向的数据而不是指针的值（在后一种情况下，*两个*对象将指向相同的数据）。

如果你定义了一个复制构造函数，你仍然会得到默认的复制赋值运算符；然而，如果你认为编写自己的复制构造函数很重要，那么你也应该提供一个自定义的复制赋值运算符。 （同样，如果你定义了一个复制赋值运算符，你将得到默认的复制构造函数，除非你定义它。）

复制赋值运算符通常是类的`public`成员，并且它接受一个用于提供赋值值的对象的`const`引用。赋值运算符的语义是可以链式调用的，所以，例如，这段代码调用了两个对象上的赋值运算符：

```cpp
    buffer a, b, c;              // default constructors called 
    // do something with them 
    a = b = c;                   // make them all the same value 
    a.operator=(b.operator=(c)); // make them all the same value
```

最后两行做了同样的事情，但显然第一行更易读。为了启用这些语义，赋值运算符必须返回一个被赋值的对象的引用。因此，类`buffer`将有以下方法：

```cpp
    class buffer 
    { 
        // data members 
    public: 
        buffer(const buffer&);            // copy constructor 
        buffer& operator=(const buffer&); // copy assignment 
    };
```

尽管复制构造函数和复制赋值方法看起来做了类似的事情，但有一个关键的区别。复制构造函数创建了一个之前不存在的新对象。调用代码知道如果构造失败，那么将会引发异常。而赋值操作中，两个对象已经存在，所以你是将一个对象的值复制到另一个对象。这应该被视为一个原子操作，并且所有的复制都应该被执行；赋值在中途失败，导致一个对象是两个对象的一部分，是不可接受的。

此外，在构造中，对象只有在构造成功后才存在，所以复制构造不能发生在对象本身上，但是对于代码将对象分配给自身是完全合法的（尽管毫无意义）。复制赋值需要检查这种情况并采取适当的行动。

有各种策略可以做到这一点，一个常见的策略被称为复制和交换惯用法，因为它使用了标记为`noexcept`的标准库`swap`函数，并且不会抛出异常。这种惯用法涉及在赋值右侧的对象上创建一个临时副本，然后交换它的数据成员与左侧对象的数据成员。

# 移动语义

C++11 通过移动构造函数和移动赋值运算符提供了移动语义，当临时对象被用来创建另一个对象或被赋值给现有对象时，这些函数将被调用。在这两种情况下，因为临时对象不会在语句之后存在，临时对象的内容可以被移动到另一个对象，使得临时对象处于无效状态。编译器将通过默认操作从临时对象中移动数据到新创建的（或被赋值的）对象中创建这些函数。

你可以编写自己的版本，并且为了指示移动语义，这些版本有一个 rvalue 引用（`&&`）作为参数。

如果你希望编译器为你提供这些方法的默认版本，你可以在类声明中提供带有`=default`后缀的原型。在大多数情况下，这是自说明的，而不是一个要求，但如果你正在编写一个 POD 类，你必须使用这些函数的默认版本，否则`is_pod`将不会返回`true`。

如果你只想使用移动而不使用复制（例如，文件句柄类），那么你可以*删除*复制函数：

```cpp
    class mytype 
    { 
        int *p; 
    public: 
        mytype(const mytype&) = delete;             // copy constructor 
        mytype& operator= (const mytype&) = delete; // copy assignment 
        mytype&(mytype&&);                          // move constructor 
        mytype& operator=(mytype&&);                // move assignment 
    };
```

这个类有一个指针数据成员，并允许移动语义，这种情况下移动构造函数将被调用，参数是一个临时对象的引用。由于对象是临时的，它在移动构造函数调用之后不会存在。这意味着新对象可以*移动*临时对象的状态到自身：

```cpp
    mytype::mytype(mytype&& tmp) 
    { 
        this->p = tmp.p; 
        tmp.p = nullptr; 
    }
```

移动构造函数将临时对象的指针赋值为`nullptr`，这样，为类定义的任何析构函数都不会尝试删除指针。

# 声明静态成员

你可以声明一个类的成员——数据成员或方法——为`static`。这在某些方面类似于在自动变量和文件作用域声明的函数上使用`static`关键字，但是当在类成员上使用这个关键字时，有一些重要的不同之处。

# 定义静态成员

当在类成员上使用`static`时，表示该项与类相关联，而不是与特定实例相关联。对于数据成员，这意味着所有类的实例共享一个数据项。同样，静态方法不附加到对象，它不是`__thiscall`，也没有`this`指针。

静态方法是类的命名空间的一部分，因此它可以为类创建对象并访问它们的`private`成员。静态方法默认具有`__cdecl`调用约定，但如果需要，可以声明为`__stdcall`。这意味着，可以编写一个在类中用于初始化许多库使用的 C 样式指针的方法。请注意，静态函数不能调用类的非静态方法，因为非静态方法需要`this`指针，但非静态方法可以调用静态方法。

非静态方法通过对象调用，可以使用点运算符（对于类实例）或`->`运算符（对于对象指针）。静态方法不需要关联对象，但可以通过对象调用。

这提供了两种调用静态方法的方式，通过对象或通过`class`名称：

```cpp
    class mytype 
    { 
    public: 
        static void f(){} 
        void g(){ f(); } 
    };
```

在这里，类定义了一个名为`f`的静态方法和一个名为`g`的非静态方法。非静态方法`g`可以调用静态方法，但静态方法`f`不能调用非静态方法。由于静态方法`f`是`public`的，类外部的代码可以调用它。

```cpp
    mytype c; 
    c.g();       // call the nonstatic method 
    c.f();       // can also call the static method thru an object 
    mytype::f(); // call static method without an object
```

虽然可以通过对象调用静态函数，但您不必创建任何对象来调用它。

静态数据成员需要更多的工作，因为当使用`static`时，表示数据成员不是对象的一部分，通常在创建对象时分配数据成员。必须在类外定义`static`数据成员：

```cpp
    class mytype 
    { 
    public: 
        static int i; 
        static void incr() { i++; } 
    }; 

    // in a source file 
    int mytype::i = 42;
```

数据成员在类外部的文件作用域中定义。它使用`class`名称命名，但请注意，它也必须使用类型进行定义。在这种情况下，数据成员使用一个值进行初始化；如果不这样做，那么在首次使用变量时，它将具有类型的默认值（在这种情况下为零）。如果选择在头文件中声明类（这是常见的做法），则`static`数据成员的定义必须在源文件中。

还可以在方法中声明一个`static`变量。在这种情况下，该值在所有对象的方法调用之间保持不变，因此它具有与`static class`成员相同的效果，但不需要在类外部定义变量的问题。

# 使用静态和全局对象

全局函数中的静态变量将在该函数首次调用之前的某个时刻创建。同样，作为类成员的静态对象将在首次访问之前的某个时刻初始化。

静态和全局对象在调用`main`函数之前构造，并在`main`函数结束后销毁。这种初始化的顺序存在一些问题。C++标准规定，源文件中定义的静态和全局对象的初始化将在使用该源文件中的任何函数或对象之前发生，如果一个源文件中有多个全局对象，则它们将按照它们被*定义*的顺序进行初始化。问题在于如果有几个源文件中都有静态对象。在这种情况下，无法保证这些对象的初始化顺序。如果一个静态对象依赖于另一个静态对象，那么就会出现问题，因为无法保证依赖对象在所依赖的对象之后创建。

# 命名构造函数

这是`public static`方法的一个应用。其思想是，由于`static`方法是`class`的成员，这意味着它可以访问`class`实例的`private`成员，因此这样的方法可以创建一个对象，执行一些额外的初始化，然后将对象返回给调用者。这是一个**工厂方法**。到目前为止使用的`point`类是使用笛卡尔坐标构建的，但我们也可以基于极坐标创建一个点，其中`(x, y)`的笛卡尔坐标可以计算为：

```cpp
    x = r * cos(theta) 
    y = r * sin(theta)
```

这里`r`是到点的向量长度，`theta`是该向量逆时针到 x 轴的角度。`point`类已经有一个接受两个`double`值的构造函数，因此我们不能使用它来传递极坐标；相反，我们可以使用一个`static`方法作为*命名构造函数*：

```cpp
    class point 
    { 
        double x; double y; 
    public: 
        point(double x, double y) : x(x), y(y){} 
        static point polar(double r, double th) 
        { 
            return point(r * cos(th), r * sin(th)); 
        } 
    };
```

可以这样调用该方法：

```cpp
    const double pi = 3.141529; 
    const double root2 = sqrt(2); 
    point p11 = point::polar(root2, pi/4);
```

对象`p11`是具有笛卡尔坐标(1,1)的`point`。在这个例子中，`polar`方法调用了一个`public`构造函数，但它可以访问私有成员，所以同样的方法也可以写成（效率较低）：

```cpp
    point point::polar(double r, double th) 
    { 
        point pt; 
        pt.x = r * cos(th); 
        pt.y = r * sin(th); 
        return pt; 
    }
```

# 嵌套类

您可以在类内定义一个类。如果嵌套类声明为`public`，那么您可以在容器类中创建对象并将它们返回给外部代码。然而，通常情况下，您会希望声明一个被类使用并且应该是`private`的类。以下声明了一个`public`的嵌套类：

```cpp
    class outer 
    { 
    public: 
        class inner  
        { 
        public: 
            void f(); 
        }; 

        inner g() { return inner(); } 
    }; 

    void outer::inner::f() 
    { 
         // do something 
    }
```

注意嵌套类的名称是以包含类的名称作为前缀的。

# 访问 const 对象

到目前为止，您已经看到了许多使用`const`的例子，也许最常见的是将其应用于引用作为函数参数，以指示编译器函数只对对象具有只读访问权限。这样的`const`引用用于通过引用传递对象，以避免通过值传递对象时会发生的复制开销。`class`上的方法可以访问对象数据成员，并且可能会改变它们，因此如果通过`const`引用传递对象，编译器将只允许引用调用不改变对象的方法。之前定义的`point`类有两个访问器来访问类中的数据：

```cpp
    class point 
    { 
        double x; double y; 
    public: 
        double get_x() { return x; } 
        double get_y() { return y: } 
    };
```

如果您定义一个函数，该函数接受对此的`const`引用，并尝试调用这些访问器，您将会收到来自编译器的错误：

```cpp
    void print_point(const point& p) 
    { 
        cout << "(" << p.get_x() << "," << p.get_y() << ")" << endl; 
    }
```

编译器的错误有点晦涩：

```cpp
cannot convert 'this' pointer from 'const point' to 'point &'
```

这个消息是编译器抱怨对象是`const`，它是不可变的，并且它不知道这些方法是否会保持对象的状态。解决方法很简单--对不改变对象状态的方法添加`const`关键字，就像这样：

```cpp
    double get_x() const { return x; } 
    double get_y() const { return y: }
```

这实际上意味着`this`指针是`const`。`const`关键字是函数原型的一部分，因此该方法可以在此上进行重载。您可以有一个方法，当它在`const`对象上调用时被调用，另一个方法在非`const`对象上被调用。这使您能够实现写时复制模式，例如，`const`方法将返回对数据的只读访问，而非`const`方法将返回可写的数据的*副本*。

当然，标记为`const`的方法不能改变数据成员，甚至是暂时的。因此，这样的方法只能调用`const`方法。也许有一些罕见的情况，数据成员被设计为可以通过`const`对象进行更改；在这种情况下，成员的声明会标记为`mutable`关键字。

# 使用指针与对象

对象可以在自由存储器上创建，并通过类型化指针进行访问。这样做更加灵活，因为将指针传递给函数是高效的，并且您可以明确确定对象的生命周期，因为对象是通过`new`调用创建的，并且通过`delete`调用销毁的。

# 获取对象成员的指针

如果你需要通过实例访问类数据成员的地址（假设数据成员是`public`），你只需使用`&`运算符：

```cpp
    struct point { double x; double y; }; 
    point p { 10.0, 10.0 }; 
    int *pp = &p.x;
```

在这种情况下，`struct`用于声明`point`，以便成员默认为`public`。第二行使用初始化列表构造了一个具有两个值的`point`对象，然后最后一行获取了一个数据成员的指针。当然，在对象被销毁后，指针不能再使用。数据成员被分配在内存中（在这种情况下是在堆栈上），因此地址运算符只是获取指向该内存的指针。

函数指针是一个不同的情况。无论创建了多少个`class`的实例，内存中只会有一个方法的副本，但是因为方法使用`__thiscall`调用约定（带有隐藏的`this`参数），所以你必须有一个函数指针，它可以用对象的指针初始化，以提供`this`指针。考虑这个`class`：

```cpp
    class cartesian_vector 
    { 
    public: 
        // other items 
        double get_magnitude() const 
        { 
            return std::sqrt((this->x * this->x) + (this->y * this->y)); 
        }  
    };
```

我们可以这样定义一个指向`get_magnitude`方法的函数指针：

```cpp
    double (cartesian_vector::*fn)() const = nullptr; 
    fn = &cartesian_vector::get_magnitude;
```

第一行声明了一个函数指针。这类似于 C 函数指针声明，只是在指针类型中包含了`class`名称。这是必要的，这样编译器就知道在通过这个指针调用时必须提供一个`this`指针。第二行获取了一个指向该方法的指针。注意没有涉及到任何对象。你不是获取一个对象上的方法的函数指针；你是获取一个必须通过对象调用的`class`上的方法的指针。要通过这个指针调用方法，你需要在对象上使用成员指针运算符`.*`：

```cpp
    cartesian_vector vec(1.0, 1.0); 
    double mag = (vec.*fn)();
```

第一行创建了一个对象，第二行调用了该方法。成员指针运算符表示右侧的函数指针将与左侧的对象一起调用。在调用方法时，左侧的对象的地址将用作`this`指针。由于这是一个方法，我们需要提供一个参数列表，在这种情况下是空的（如果你有参数，它们将在该语句右侧的括号中）。如果你有一个对象指针，那么语法是类似的，但是你使用`->*`成员指针运算符：

```cpp
    cartesian_vector *pvec = new cartesian_vector(1.0, 1.0); 
    double mag = (pvec->*fn)(); 
    delete pvec;
```

# 运算符重载

类型的行为之一是可以应用于它的操作。C++允许你在类的一部分中重载 C++运算符，以便清楚地表明运算符是作用于该类型的。这意味着对于一元运算符，成员方法不应该有参数，而对于二元运算符，你只需要一个参数，因为当前对象将位于运算符的左侧，因此方法参数是右侧的项目。以下表总结了如何实现一元和二元运算符，以及四个例外情况：

| **表达式** | **名称** | **成员方法** | **非成员函数** |
| --- | --- | --- | --- |
| +a/-a | 前缀一元 | operator() | operator(a) |
| a, b | 二元 | operator(b) | operator(a,b) |
| a+/a- | 后缀一元 | operator(0) | operator(a,0) |
| a=b | 赋值 | operator=(b) |  |
| a(b) | 函数调用 | operator()(b) |  |
| a[b] | 索引 | operator[](b) |  |
| a-> | 指针访问 | operator->() |  |

这里的■符号用于表示除表中提到的四个运算符之外的任何可接受的一元或二元运算符。

对于运算符应该返回什么并没有严格的规定，但是如果自定义类型的运算符的行为类似于内置类型的运算符，那么会有所帮助。还必须有一些一致性。如果你实现了`+`运算符来将两个对象相加，那么`+=`运算符应该使用相同的加法操作。同样，你可以说加法操作也将决定减法操作应该是什么样的，因此`-`和`-=`运算符。同样，如果你想定义`<`运算符，那么你应该也定义`<=`、`>`、`>=`、`==`和`!=`。

标准库的算法（例如`sort`）只会期望在自定义类型上定义`<`操作符。

表格显示，你可以将几乎所有的操作符实现为自定义类型类的成员或全局函数（除了那四个必须是成员方法的）。一般来说，最好将操作符作为类的一部分来实现，因为它保持了封装性：成员函数可以访问类的非公共成员。

一元操作符的一个例子是一元负号操作符。这通常不会改变一个对象，而是返回一个新的对象，这个对象是原对象的*负值*。对于我们的`point class`来说，这意味着将两个坐标都变成负数，这相当于在直线*y=-x*上对笛卡尔点进行镜像：

```cpp
    // inline in point 
    point operator-() const 
    { 
        return point(-this->x, -this->y); 
    }
```

操作符声明为`const`，因为明显这个操作符不会改变对象，因此在`const`对象上调用是安全的。操作符可以这样调用：

```cpp
    point p1(-1,1); 
    point p2 = -p1; // p2 is (1,-1)
```

要理解为什么我们要像这样实现操作符，回顾一下当应用于内置类型时一元操作符会做什么。这里的第二个语句，`int i, j=0; i = -j;`，只会改变`i`，不会改变`j`，所以成员`operator-`不应该影响对象的值。

二元负号操作符有不同的含义。首先，它有两个操作数，其次，在这个例子中，结果是一个不同类型的操作数，因为结果是一个向量，通过将一个点从另一个点中取出来来表示一个方向。假设`cartesian_vector`已经定义了一个有两个参数的构造函数，那么我们可以这样写：

```cpp
    cartesian_vector point::operator-(point& rhs) const 
    { 
        return cartesian_vector(this->x - rhs.x, this->y - rhs.y); 
    }
```

增量和减量操作符有特殊的语法，因为它们是可以前置或后置的一元操作符，并且它们会改变被应用的对象。两个操作符之间的主要区别在于后置操作符返回增量/减量操作之前的对象的值，因此需要创建一个临时对象。因此，前置操作符几乎总是比后置操作符性能更好。在类定义中，为了区分这两者，前置操作符没有参数，后置操作符有一个虚拟参数（在前面的表中，给出了 0）。对于一个类`mytype`，这是这样的：

```cpp
    class mytype  
    { 
    public: 
        mytype& operator++() 
        {  
            // do actual increment 
            return *this; 
        } 
        mytype operator++(int) 
        { 
            mytype tmp(*this); 
            operator++(); // call the prefix code 
            return tmp; 
        } 
    };
```

实际的增量代码是由前置操作符实现的，并且后置操作符通过显式调用该方法来使用这个逻辑。

# 定义函数类

函数对象是一个实现了`()`操作符的类。这意味着你可以使用与调用函数相同的语法来调用一个对象。考虑这个：

```cpp
    class factor 
    { 
        double f = 1.0; 
    public: 
        factor(double d) : f(d) {} 
        double operator()(double x) const { return f * x; }  
    };
```

这段代码可以这样调用：

```cpp
    factor threeTimes(3);        // create the functor object 
    double ten = 10.0; 
    double d1 = threeTimes(ten); // calls operator(double) 
    double d2 = threeTimes(d1);  // calls operator(double)
```

这段代码表明，函数对象不仅提供了一些行为（在这种情况下，在参数上执行一个动作），而且它也可以有一个状态。前面两行是通过对象上的`operator()`方法调用的。

```cpp
    double d2 = threeTimes.operator()(d1);
```

看语法。函数对象被调用就好像它是这样声明的一个函数：

```cpp
    double multiply_by_3(double d) 
    { 
        return 3 * d;  
    }
```

想象一下，你想要传递一个指向函数的指针--也许你希望函数的行为可以被外部代码改变。为了能够使用函数对象或者方法指针，你需要重载你的函数：

```cpp
    void print_value(double d, factor& fn); 
    void print_value(double d, double(*fn)(double));
```

第一个接受一个函数对象的引用。第二个有一个 C 类型的函数指针（你可以传递一个指向`multiply_by_3`的指针），并且相当难以阅读。在这两种情况下，`fn`参数在实现代码中以相同的方式被调用，但你需要声明两个函数，因为它们是不同的类型。现在，考虑函数模板的魔力：

```cpp
    template<typename Fn> 
    void print_value(double d, Fn& fn) 
    { 
        double ret = fn(d); 
        cout << ret << endl; 
    }
```

这是通用代码；`Fn`类型可以是 C 函数指针或者函数对象`class`，编译器会生成适当的代码。

这段代码可以通过传递一个函数指针到一个全局函数，该函数将具有`__cdecl`调用约定，或者一个函数对象，其中将调用`operator()`运算符，该运算符具有`__thiscall`调用约定。

这只是一个实现细节，但这意味着你可以编写一个通用函数，可以接受 C 风格的函数指针或函数对象作为参数。C++标准库使用了这个魔法，这意味着它提供的算法可以被调用，要么使用*全局函数*，要么使用*函数对象*，要么使用*lambda 表达式*。

标准库算法使用三种类型的函数类、生成器和一元和二元函数；也就是说，具有零、一个或两个参数的函数。此外，标准库调用一个返回`bool`的函数对象（一元或二元）**谓词**。文档将告诉你是否需要谓词、一元或二元函数。旧版本的标准库需要知道函数对象的返回值和参数（如果有的话）的类型，因此，函数对象类必须基于标准类`unary_function`和`binary_function`。在 C++11 中，这个要求已经被移除，因此没有必要使用这些类。

在某些情况下，当需要一个一元函数时，你可能会想要使用一个二元函数。例如，标准库定义了`greater`类，当作为函数对象使用时，它接受两个参数和一个`bool`来确定第一个参数是否大于第二个参数，使用两个参数的类型定义的`operator>`。这将用于需要二元函数的函数，因此函数将比较两个值；例如：

```cpp
    template<typename Fn>  
    int compare_vals(vector<double> d1, vector<double> d2, Fn compare) 
    { 
        if (d1.size() > d2.size()) return -1; // error 
        int c = 0; 
        for (size_t i = 0; i < d1.size(); ++i) 
        { 
            if (compare(d1[i], d2[i])) c++; 
        } 
        return c; 
    }
```

这个函数接受两个集合，并使用作为最后一个参数传递的函数对象比较相应的项目。可以这样调用它：

```cpp
    vector<double> d1{ 1.0, 2.0, 3.0, 4.0 }; 
    vector<double> d2{ 1.0, 1.0, 2.0, 5.0 }; 
    int c = compare_vals(d1, d2, greater<double>());
```

`greater`函数对象类在`<functional>`头文件中定义，使用定义为该类型的`operator>`比较两个数字。如果你想要比较容器中的项目和一个固定值；也就是说，当函数对象的`operator()(double, double)`方法被调用时，一个参数总是有一个固定的值？一种选择是定义一个有状态的函数对象类（如前面所示），使得固定值成为函数对象的成员。另一种方法是用固定值填充另一个`vector`，并继续比较两个`vector`（对于大的`vector`来说，这可能会变得非常昂贵）。

另一种方法是重用函数对象类，但将一个值*绑定*到它的一个参数上。可以像这样编写`compare_vals`函数的一个版本，只接受一个`vector`：

```cpp
    template<typename Fn>  
    int compare_vals(vector<double> d, Fn compare) 
    { 
        int c = 0; 
        for (size_t i = 0; i < d.size(); ++i) 
        { 
            if (compare(d[i]) c++; 
        } 
        return c; 
    }
```

代码被编写为在一个值上调用函数对象参数，因为假设函数对象包含另一个要比较的值。这是通过将函数对象类绑定到参数来实现的：

```cpp
    using namespace::std::placeholders; 
    int c = compare_vals(d1, bind(greater<double>(), _1, 2.0));
```

`bind`函数是可变参数的。第一个参数是函数对象，后面是将传递给函数对象的`operator()`方法的参数。`compare_vals`函数接收一个**binder**对象，将函数对象绑定到值上。在`compare_vals`函数中，对函数对象的调用`compare(d[i])`实际上是对绑定对象的`operator()`方法的调用，这个方法将参数`d[i]`和绑定的值转发给函数对象的`operator()`方法。

在调用`bind`时，如果提供了实际值（这里是`2.0`），那么该值将传递给函数对象在调用函数对象时的位置（这里是`2,0`传递给第二个参数）。如果使用下划线前缀的符号，则它是一个**占位符**。在`std::placeholders`命名空间中定义了 20 个这样的符号（`_1`到`_20`）。占位符的意思是“使用在这个位置传递给绑定器对象`operator()`方法调用的值来传递给函数对象调用`operator()`方法中由占位符指示的位置”。因此，在这个调用中，占位符的意思是“将从调用绑定器中传递的第一个参数传递给`greater`函数对象`operator()`的第一个参数”。

之前的代码比较`vector`中的每个项目与`2.0`，并将大于`2.0`的项目计数。你可以这样调用它：

```cpp
    int c = compare(d1, bind(greater<double>(), 2.0, _1));
```

参数列表被交换，这意味着`2.0`与`vector`中的每个项目进行比较，并且函数将计数`2.0`大于项目的次数。

`bind`函数和占位符是 C++11 中的新功能。在之前的版本中，你可以使用`bind1st`和`bind2nd`函数来将一个值绑定到函数对象的第一个或第二个参数上。

# 定义转换运算符

我们已经看到，如果你的自定义类型有一个接受你要转换的类型的构造函数，那么构造函数可以用来将另一种类型转换为你的自定义类型。你也可以进行另一种方向的转换：将对象转换为另一种类型。为此，你提供一个没有返回类型的操作符，其名称为要转换为的类型。在这种情况下，你需要在`operator`关键字和名称之间加一个空格。

```cpp
    class mytype 
    { 
        int i; 
    public: 
        mytype(int i) : i(i) {} 
        explicit mytype(string s) : i(s.size()) {} 
        operator int () const { return i; } 
    };
```

这段代码可以将`int`或`string`转换为`mytype`；在后一种情况下，只能通过显式提及构造函数来实现。

最后一行允许你将对象转换回`int`：

```cpp
    string s = "hello"; 
    mytype t = mytype(s); // explicit conversion 
    int i = t;            // implicit conversion
```

你可以将这样的转换运算符声明为`explicit`，这样它们只会在使用显式转换时被调用。在许多情况下，你会希望省略这个关键字，因为当你想要将资源封装在类中并使用析构函数来自动管理资源时，隐式转换是有用的。

使用转换运算符的另一个例子是从有状态的函数对象中返回值。这里的想法是`operator()`将执行某些操作，并且结果由函数对象维护。问题是，如何获取函数对象的状态，特别是当它们经常作为临时对象创建时？转换运算符可以提供这种功能。

例如，当你计算平均值时，你需要分两个阶段：第一阶段是累积值，第二阶段是通过将其除以项目数来计算平均值。以下的函数对象类通过在转换为`double`的过程中执行除法来实现这一点：

```cpp
    class averager 
    { 
        double total; 
        int count; 
    public: 
        averager() : total(0), count(0) {} 
        void operator()(double d) { total += d; count += 1; } 
        operator double() const 
        {        
            return (count != 0) ? (total / count) : 
                numeric_limits<double>::signaling_NaN(); 
        } 
    };
```

这样调用它：

```cpp
    vector<double> vals { 100.0, 20.0, 30.0 }; 
    double avg = for_each(vals.begin(), vals.end(), averager());
```

`for_each`函数对`vector`中的每个项目调用函数对象，`operator()`简单地对传递给它的项目求和并保持计数。有趣的是，在`for_each`函数迭代完`vector`中的所有项目后，它会返回函数对象，因此会有一个隐式转换为`double`，调用转换运算符来计算平均值。

# 管理资源

我们已经看到一种需要仔细管理的资源：内存。您使用`new`分配内存，当您使用完内存后，必须使用`delete`释放内存。未能释放内存将导致内存泄漏。内存可能是最基本的系统资源，但大多数操作系统还有许多其他资源：文件句柄、图形对象句柄、同步对象、线程和进程。有时，对这种资源的拥有是独占的，并且会阻止其他代码访问通过该资源访问的资源。因此，重要的是在某个时刻释放这些资源，并且通常及时释放这些资源。

类在这里有所帮助，使用了 Bjarne Stroustrup 发明的一种称为**资源获取即初始化**（RAII）的机制，他是 C++的作者。简单地说，资源在对象的构造函数中分配，并在析构函数中释放，这意味着资源的生命周期与对象的生命周期相同。通常，这种包装对象是在堆栈上分配的，这意味着无论发生什么情况，当对象超出范围时，资源都将被释放。

因此，如果对象在循环语句（`while`、`for`）的代码块中声明，那么在每次循环结束时，将调用每个对象的析构函数（按创建顺序的相反顺序），并且当循环重复时，对象将再次创建。无论循环是因为已经到达代码块的末尾而重复，还是通过调用`continue`而重复。离开代码块的另一种方法是通过调用`break`、`goto`，或者如果代码调用`return`来离开函数。如果代码引发异常（参见第七章，*诊断和调试*），则在对象超出范围时将调用析构函数，因此如果代码受`try`块保护，则将在调用`catch`子句之前调用块中声明的对象的析构函数。如果没有保护块，则在函数堆栈被销毁并传播异常之前将调用析构函数。

# 编写包装类

在编写包装资源的类时，您必须解决几个问题。构造函数将被用于获取资源，要么使用某种库函数（通常通过某种不透明句柄访问）获取资源，要么将资源作为参数传递。这个资源将作为数据成员存储，以便类上的其他方法可以使用它。析构函数将使用库提供的函数释放资源。这是最低限度。此外，您还需要考虑对象将如何使用。

通常，如果您可以将实例用作资源句柄，这样的包装类会更加方便。这意味着您可以保持相同的编程风格来访问资源，但您不必太担心释放资源。

您应该考虑是否希望能够在包装类和资源句柄之间进行转换。如果允许这样做，这意味着您可能需要考虑克隆资源，以便您不会有两个句柄的副本--一个由类管理，另一个副本可能会被外部代码释放。您还需要考虑是否允许对象被复制或分配，如果允许，那么您将需要适当地实现复制构造函数、移动构造函数以及复制和移动赋值运算符。

# 使用智能指针

C++标准库提供了几个类来包装通过指针访问的资源。为了防止内存泄漏，您必须确保在某个时候释放在自由存储器上分配的内存。智能指针的想法是您将实例视为指针，因此您使用`*`运算符进行解引用以访问它指向的对象，或者使用`->`运算符访问包装对象的成员。智能指针类将管理其包装的指针的生命周期，并将适当释放资源。

标准库有三个智能指针类：`unique_ptr`，`shared_ptr`和`weak_ptr`。每个类以不同的方式处理资源的释放，以及如何或是否可以复制指针。

# 管理独占所有权

`unique_ptr`类是使用指向将要维护的对象的指针构造的。该类提供了`*`运算符来访问对象，对包装指针进行解引用。它还提供了`->`运算符，因此如果指针是用于类的，您可以通过包装指针访问成员。

以下在自由存储器上分配一个对象并手动维护其生命周期：

```cpp
    void f1() 
    { 
       int* p = new int; 
       *p = 42; 
       cout << *p << endl; 
       delete p; 
    }
```

在这种情况下，您获得了一个指向为`int`分配的自由存储器上的内存的指针。要访问内存--无论是写入还是读取--您都必须使用`*`运算符对指针进行解引用。当您完成指针时，必须调用`delete`来释放内存并将其返回给自由存储器。现在考虑相同的代码，但使用智能指针：

```cpp
    void f2() 
    { 
       unique_ptr<int> p(new int); 
       *p = 42; 
       cout << *p << endl; 
       delete p.release(); 
    }
```

两个主要区别是智能指针对象是通过调用以模板参数使用的类型的指针的构造函数显式构造的。这种模式强化了资源应该只由智能指针管理的想法。

第二个变化是通过在智能指针对象上调用`release`方法来释放内存，以获取包装指针的所有权，这样我们就可以显式删除指针。

将`release`方法释放指针从智能指针的所有权中释放。在此调用之后，智能指针不再包装资源。`unique_ptr`类还有一个`get`方法，将允许访问包装的指针，但智能指针对象仍将保留所有权；*不要通过这种方式删除获得的指针*！

请注意，`unique_ptr`对象包装一个指针，只是指针。这意味着对象在内存中的大小与它包装的指针相同。到目前为止，智能指针增加了很少，所以让我们看看另一种释放资源的方法：

```cpp
    void f3() 
    { 
       unique_ptr<int> p(new int); 
       *p = 42; 
       cout << *p << endl; 
       p.reset(); 
    }
```

这是*确定性*释放资源，这意味着资源在您希望发生时释放，这与指针的情况类似。这里的代码并不释放资源本身；它允许智能指针使用**删除器**来释放资源。`unique_ptr`的默认删除器是一个名为`default_delete`的函数类，它在包装指针上调用`delete`运算符。

如果您打算使用确定性销毁，`reset`是首选方法。您可以通过将自定义函数类的类型作为`unique_ptr`模板的第二个参数来提供自己的删除器：

```cpp
    template<typename T> struct my_deleter 
    { 
        void operator()(T* ptr)  
        { 
            cout << "deleted the object!" << endl; 
            delete ptr; 
        } 
    };
```

在您的代码中，您将指定您想要自定义删除器，就像这样：

```cpp
    unique_ptr<int, my_deleter<int> > p(new int);
```

在删除指针之前，您可能需要执行额外的清理，或者指针可能是通过除`new`之外的机制获得的，因此您可以使用自定义删除器来确保调用适当的释放函数。请注意，删除器是智能指针类的一部分，因此如果您有两个使用两种不同删除器的不同智能指针，智能指针类型是不同的，即使它们包装相同类型的资源。

当您使用自定义删除器时，`unique_ptr`对象的大小可能大于包装的指针。如果删除器是一个函数对象，每个智能指针对象将需要为此分配内存，但如果使用 lambda 表达式，则不需要更多的额外空间。

当然，您最有可能允许智能指针为您管理资源的生命周期，为此，您只需允许智能指针对象超出范围：

```cpp
    void f4() 
    { 
       unique_ptr<int> p(new int); 
       *p = 42; 
       cout << *p << endl; 
    } // memory is deleted
```

由于创建的指针是单个对象，这意味着您可以调用适当构造函数上的`new`运算符来传递初始化参数。`unique_ptr`的构造函数传递指向已构造对象的指针，然后类管理对象的生命周期。虽然可以直接通过调用其构造函数创建`unique_ptr`对象，但不能调用复制构造函数，因此在构造期间不能使用初始化语法。相反，标准库提供了一个名为`make_unique`的函数。

它有几个重载，因此这是基于这个类创建智能指针的首选方式：

```cpp
    void f5() 
    { 
       unique_ptr<int> p = make_unique<int>(); 
       *p = 42; 
       cout << *p << endl; 
    } // memory is deleted
```

此代码将在包装类型（`int`）上调用默认构造函数，但您可以提供要传递给类型的适当构造函数的参数。例如，对于具有两个参数的构造函数的`struct`，可以使用以下方法：

```cpp
    void f6() 
    { 
       unique_ptr<point> p = make_unique<point>(1.0, 1.0); 
       p->x = 42; 
       cout << p->x << "," << p->y << endl; 
    } // memory is deleted
```

`make_unique`函数调用分配具有非默认值的成员的构造函数。`->`运算符返回一个指针，编译器将通过这个指针访问对象成员。

还有一个专门用于数组的`unique_ptr`和`make_unique`的特化。此版本的`unique_ptr`的默认删除器将在指针上调用`delete[]`，因此它将删除数组中的每个对象（并调用每个对象的析构函数）。该类实现了一个索引器运算符（`[]`），因此您可以访问数组中的每个项目。但是，请注意，没有范围检查，因此，就像内置数组变量一样，您可以访问数组的末尾之外。没有解引用运算符（`*`或`->`），因此基于数组的`unique_ptr`对象只能使用数组语法访问。

`make_unique`函数有一个重载，允许您传递要创建的数组的大小，但您必须逐个初始化每个对象：

```cpp
    unique_ptr<point[]> points = make_unique<point[]>(4);     
    points[1].x = 10.0; 
    points[1].y = -10.0;
```

这将创建一个包含四个`point`对象的数组，最初设置为默认值，接下来的行将第二个点初始化为`(10.0，-10.0)`的值。几乎总是比使用`unique_ptr`来管理对象数组更好使用`vector`或`array`。

早期版本的 C++标准库有一个名为`auto_ptr`的智能指针类。这是第一次尝试，在大多数情况下都有效，但也有一些限制；例如，`auto_ptr`对象不能存储在标准库容器中。C++11 引入了右值引用和其他语言特性，如移动语义，通过这些特性，`unique_ptr`对象可以存储在容器中。`auto_ptr`类仍然通过`<new>`头文件可用，但只是为了让旧代码仍然可以编译。

关于`unique_ptr`类的重要一点是它确保指针只有一个副本。这很重要，因为类析构函数将释放资源，所以如果您*可以*复制`unique_ptr`对象，这意味着将有多个析构函数尝试释放资源。`unique_ptr`对象具有*独占所有权*；实例始终拥有其指向的内容。

您不能复制分配`unique_ptr`智能指针（复制分配运算符和复制构造函数已删除），但可以通过转移所有权从源指针到目标指针来*移动*它们。因此，函数可以返回`unique_ptr`，因为通过移动语义将所有权转移到分配给函数值的变量。如果智能指针放入容器中，则会进行另一个移动。

# 共享所有权

有时您需要共享指针：您可能创建多个对象并将指针传递给每个对象的单个对象，以便它们可以调用此对象。通常，当一个对象持有指向另一个对象的指针时，该指针表示应在包含对象的销毁期间销毁的资源。如果指针是共享的，这意味着当其中一个对象删除指针时，所有其他对象中的指针将无效（这称为**悬空指针**，因为它不再指向对象）。您需要一种机制，其中多个对象可以持有指针，直到*所有*使用该指针的对象都表示它们将不再需要使用它为止，该指针将保持有效。

C++11 通过`shared_ptr`类提供了这种功能。该类在资源上维护**引用计数**，并且对于该资源的每个`shared_ptr`副本都会增加引用计数。当销毁该资源的一个`shared_ptr`实例时，它将减少引用计数。引用计数是共享的，因此它意味着非零值表示至少存在一个访问该资源的`shared_ptr`。当最后一个`shared_ptr`对象将引用计数减少到零时，可以安全释放资源。

这意味着必须以原子方式管理引用计数以处理多线程代码。

由于引用计数是共享的，这意味着每个`shared_ptr`对象都持有指向称为**控制块**的共享缓冲区的指针，这意味着它持有原始指针和指向控制块的指针，因此每个`shared_ptr`对象将持有比`unique_ptr`更多的数据。控制块用于不仅仅是引用计数。

`shared_ptr`对象可以创建以使用自定义删除器（作为构造函数参数传递），并且删除器存储在控制块中。这很重要，因为这意味着自定义删除器不是智能指针类型的一部分，因此封装相同资源类型但使用不同删除器的多个`shared_ptr`对象仍然是相同类型，并且可以放入该类型的容器中。

您可以从另一个`shared_ptr`对象创建一个`shared_ptr`对象，并且这将使用原始指针和指向控制块的指针初始化新对象，并且增加引用计数。

```cpp
    point* p = new point(1.0, 1.0); 
    shared_ptr<point> sp1(p); // Important, do not use p after this! 
    shared_ptr<point> sp2(sp1); 
    p = nullptr; 
    sp2->x = 2.0; 
    sp1->y = 2.0; 
    sp1.reset(); // get rid of one shared pointer
```

在这里，第一个共享指针是使用原始指针创建的。这不是使用`shared_ptr`的推荐方式。第二个共享指针是使用第一个智能指针创建的，因此现在有两个共享指针指向相同的资源（`p`被分配为`nullptr`以防止其进一步使用）。在此之后，`sp1`或`sp2`可以用于访问*相同*资源。在此代码结束时，一个共享指针被重置为`nullptr`；这意味着`sp1`不再具有对资源的引用计数，并且您无法使用它来访问资源。但是，您仍然可以使用`sp2`来访问资源，直到它超出范围，或者您调用`reset`。

在此代码中，智能指针是从单独的原始指针创建的。由于共享指针现在接管了资源的生命周期管理，因此重要的是不再使用原始指针，在这种情况下将其分配为`nullptr`。最好避免使用原始指针，标准库通过一个名为`make_shared`的函数实现了这一点，可以像这样使用：

```cpp
    shared_ptr<point> sp1 = make_shared<point>(1.0,1.0);
```

该函数将使用对`new`的调用创建指定的对象，并且由于它接受可变数量的参数，您可以使用它来调用包装类上的任何构造函数。

您可以从`unique_ptr`对象创建一个`shared_ptr`对象，这意味着指针被*移动*到新对象，并且创建了引用计数控制块。由于资源现在将被共享，这意味着不再对资源拥有独占权，因此`unique_ptr`对象中的指针将被设置为`nullptr`。这意味着您可以有一个工厂函数，返回一个包装在`unique_ptr`对象中的对象指针，并且调用代码可以确定是否使用`unique_ptr`对象来独占访问资源，还是使用`shared_ptr`对象来共享资源。

对于对象数组使用`shared_ptr`没有太大意义；有更好的方法来存储对象的集合（`vector`或`array`）。无论如何，有一个索引运算符（`[]`），默认删除器调用`delete`，而不是`delete[]`。

# 处理悬空指针

在本书的前面，我们指出，当您删除资源时，应将指针设置为`nullptr`，并且在使用指针之前应检查指针是否为`nullptr`。这样可以避免调用已被删除的对象的内存指针：悬空指针。

有时悬空指针可能是有意设计的。例如，*父*对象可能创建具有**反向指针**到父对象的*子*对象，以便子对象可以访问父对象。（一个例子是窗口创建子控件；子控件通常可以访问父窗口是很有用的。）在这种情况下使用共享指针的问题在于父对象将对每个子控件有一个引用计数，而每个子控件对父对象也有一个引用计数，这会创建一个循环依赖。

另一个例子是，如果您有一个观察者对象的容器，并且希望能够在事件发生时通过调用每个观察者对象的方法来通知每个观察者对象。维护此列表可能会很复杂，特别是如果观察者对象可以被删除，因此您必须提供一种从容器中删除对象的方法（其中将存在`shared_ptr`引用计数），然后才能完全删除对象。如果您的代码可以简单地以一种不维护引用计数但允许您在使用指针时检查指针是否悬空或指向现有对象的方式将对象指针添加到容器中，那将变得更容易。

这样的指针被称为**弱指针**，C++11 标准库提供了一个名为`weak_ptr`的类。您不能直接使用`weak_ptr`对象，也没有解引用运算符。

相反，您可以从`shared_ptr`对象创建一个`weak_ptr`对象，当您想要访问资源时，您可以从`weak_ptr`对象创建一个`shared_ptr`对象。这意味着`weak_ptr`对象具有相同的原始指针，并且访问相同的控制块作为`shared_ptr`对象，但它不参与引用计数。

创建后，`weak_ptr`对象将使您能够测试包装指针是指向现有资源还是已被销毁的资源。有两种方法可以做到这一点：要么调用成员函数`expired`，要么尝试从`weak_ptr`创建一个`shared_ptr`。如果您正在维护一组`weak_ptr`对象，您可能决定定期遍历该集合，对每个对象调用`expired`，如果该方法返回`true`，则从集合中删除该对象。由于`weak_ptr`对象可以访问原始`shared_ptr`对象创建的控制块，它可以测试引用计数是否为零。

测试`weak_ptr`对象是否悬空的第二种方法是从中创建一个`shared_ptr`对象。有两种选择。您可以通过将弱指针传递给其构造函数来创建`shared_ptr`对象，如果指针已过期，则构造函数将抛出`bad_weak_ptr`异常。另一种方法是在弱指针上调用`lock`方法，如果弱指针已过期，则`shared_ptr`对象将被分配为`nullptr`，您可以对此进行测试。这三种方法在这里显示：

```cpp
    shared_ptr<point> sp1 = make_shared<point>(1.0,1.0); 
    weak_ptr<point> wp(sp1); 

    // code that may call sp1.reset() or may not 

    if (!wp.expired())  { /* can use the resource */} 

    shared_ptr<point> sp2 = wp.lock(); 
    if (sp2 != nullptr) { /* can use the resource */} 

    try 
    { 
        shared_ptr<point> sp3(wp); 
        // use the pointer 
    } 
    catch(bad_weak_ptr& e) 
    { 
        // dangling weak pointer 
    }
```

由于弱指针不会改变资源的引用计数，这意味着您可以使用它作为回指针来打破循环依赖（尽管通常更合理的做法是使用原始指针，因为子对象不能没有父对象而存在）。

# 模板

类可以被模板化，这意味着您可以编写通用代码，编译器将生成一个使用您的代码类型的类。参数可以是类型、常量整数值，或者可变版本（零个或多个参数，由使用类的代码提供）。例如：

```cpp
    template <int N, typename T> class simple_array 
    { 
        T data[N]; 
    public: 
        const T* begin() const { return data; } 
        const T* end() const { return data + N; } 
        int size() const { return N; } 

        T& operator[](int idx)  
        { 
            if (idx < 0 || idx >= N) 
                throw range_error("Range 0 to " + to_string(N)); 
            return data[idx]; 
        }  
    };
```

这是一个非常简单的数组类，它定义了基本的迭代器函数和索引运算符，这样您就可以这样调用它：

```cpp
    simple_array<4, int> four; 
    four[0] = 10; four[1] = 20; four[2] = 30; four[3] = 40; 
    for(int i : four) cout << i << " "; // 10 20 30 40 
    cout << endl; 
    four[4] = -99;            // throws a range_error exception
```

如果您选择在`class`声明之外定义一个函数，则需要将模板及其参数作为`class`名称的一部分给出：

```cpp
    template<int N, typename T> 
    T& simple_array<N,T>::operator[](int idx) 
    { 
        if (idx < 0 || idx >= N) 
            throw range_error("Range 0 to " + to_string(N)); 
        return data[idx]; 
    }
```

您还可以为模板参数设置默认值：

```cpp
    template<int N, typename T=int> class simple_array 
    { 
        // same as before 
    };
```

如果您认为应该为模板参数提供特定的实现，那么您可以将该版本的代码作为模板的特化提供：

```cpp
    template<int N> class simple_array<N, char> 
    { 
        char data[N]; 
    public: 
        simple_array<N, char>(const char* str)  
        {  
            strncpy(data, str, N);  
        } 
        int size() const { return N; } 
        char& operator[](int idx) 
        { 
            if (idx < 0 || idx >= N) 
                throw range_error("Range 0 to " + to_string(N)); 
            return data[idx]; 
        } 
        operator const char*() const { return data; } 
    };
```

请注意，通过特化，您不会从完全模板化的类中获得任何代码；您必须实现您想要提供的所有方法，并且，如本例所示，还要实现与特化相关但在完全模板化类上不可用的方法。这个例子是**部分特化**，意味着它只是针对一个参数（`T`，数据类型）进行了特化。这个类将用于声明为类型`simple_array<n, char>`的变量，其中`n`是一个整数。您可以自由地拥有一个完全特化的模板，在这种情况下，它将是一个特定大小和指定类型的特化：

```cpp
    template<> class simple_array<256, char> 
    { 
        char data[256]; 
    public: 
        // etc 
    };
```

在这种情况下可能没有用，但是想法是对需要 256 个字符的变量进行特殊代码处理。

# 使用类

**资源获取即初始化**技术对于管理由其他库提供的资源非常有用，例如 C 运行时库或 Windows SDK。它简化了您的代码，因为您不必考虑资源句柄何时超出范围，并在每个点提供清理代码。如果清理代码很复杂，在 C 代码中通常会看到它放在函数的末尾，并且函数中的每个退出点都会有一个`goto`跳转到该代码。这会导致混乱的代码。在这个例子中，我们将用一个类来包装 C 文件函数，以便文件句柄的生命周期可以自动维护。

C 运行时的`_findfirst`和`_findnext`函数允许您搜索与模式匹配的文件或目录（包括通配符符号）。`_findfirst`函数返回一个`intptr_t`，这与该搜索相关，并且将其传递给`_findnext`函数以获取后续值。这个`intptr_t`是 C 运行时为搜索维护的资源的不透明指针，因此当您完成搜索时，必须调用`_findclose`来清理与之关联的任何资源。为了防止内存泄漏，调用`_findclose`非常重要。

在`Beginning_C++`文件夹下，创建一个名为`Chapter_06`的文件夹。在 Visual C++中，创建一个新的 C++源文件，保存到`Chapter_06`文件夹中，并将其命名为`search.cpp`。该应用程序将使用标准库控制台和字符串，并将使用 C 运行时文件函数，因此在文件顶部添加以下行：

```cpp
    #include <iostream> 
    #include <string> 
    #include <io.h> 
    using namespace std;
```

应用程序将使用 C 函数搜索文件，并且将使用带有参数的`main`函数。将以下内容添加到文件底部：

```cpp
    void usage() 
    { 
        cout << "usage: search pattern" << endl; 
        cout << "pattern is the file or folder to search for " 
             << "with or without wildcards * and ?" << endl; 
    } 

    int main(int argc, char* argv[]) 
    { 
        if (argc < 2) 
        { 
            usage(); 
            return 1; 
        } 
    }
```

首先要创建一个搜索句柄的包装类，以管理此资源。在使用函数上方，添加一个名为`search_handle`的类：

```cpp
    class search_handle 
    { 
        intptr_t handle; 
    public: 
        search_handle() : handle(-1) {} 
        search_handle(intptr_t p) : handle(p) {} 
        void operator=(intptr_t p) { handle = p; } 
        void close()  
        { if (handle != -1) _findclose(handle); handle = 0; } 
        ~search_handle() { close(); } 
    };
```

这个类有一个单独的函数来释放句柄。这样，这个类的用户可以尽快释放包装资源。如果对象用于可能引发异常的代码中，`close`方法不会直接被调用，而是会调用析构函数。包装对象可以使用`intptr_t`值创建。如果这个值是-1，那么句柄是无效的，所以`close`方法只会在句柄没有这个值时调用`_findclose`。

我们希望这个类的对象拥有句柄的独占权，因此通过将以下内容放入类的公共部分来删除复制构造函数和复制赋值：

```cpp
    void operator=(intptr_t p) { handle = p; } 
 search_handle(search_handle& h) = delete; void operator=(search_handle& h) = delete;
```

如果对象被移动，那么现有对象中的任何句柄都必须被释放，因此在刚刚添加的行之后添加以下内容：

```cpp
    search_handle(search_handle&& h)  { close(); handle = h.handle; } 
    void operator=(search_handle&& h) { close(); handle = h.handle; }
```

包装类将通过调用`_findfirst`分配，并将传递给调用`_findnext`，因此包装类需要两个运算符：一个用于转换为`intptr_t`，以便可以在需要`intptr_t`的任何地方使用此类的对象，另一个用于在需要`bool`时使用对象。将这些添加到类的`public`部分：

```cpp
    operator bool() const { return (handle != -1); } 
    operator intptr_t() const { return handle; }
```

转换为`bool`允许您编写如下代码：

```cpp
    search_handle handle = /* initialize it */; 
    if (!handle) { /* handle is invalid */ }
```

如果有一个返回指针的转换运算符，那么编译器将优先调用这个而不是转换为`bool`。

您应该能够编译此代码（记得使用`/EHsc`开关）以确认没有拼写错误。

接下来，编写一个包装类来执行搜索。在`search_handle`类下面，添加一个`file_search`类：

```cpp
    class file_search 
    { 
        search_handle handle; 
        string search; 
    public: 
        file_search(const char* str) : search(str) {} 
        file_search(const string& str) : search(str) {} 
    };
```

这个类是根据搜索条件创建的，我们可以选择传递 C 或 C++字符串。该类有一个`search_handle`数据成员，并且，由于默认析构函数将调用成员对象的析构函数，因此我们不需要自己提供析构函数。但是，我们将添加一个`close`方法，以便用户可以显式释放资源。此外，为了让类的用户确定搜索路径，我们需要一个访问器。在类的底部，添加以下内容：

```cpp
    const char* path() const { return search.c_str(); } 
    void close() { handle.close(); }
```

我们不希望复制`file_search`对象的实例，因为那意味着搜索句柄的两个副本。您可以删除复制构造函数和赋值运算符，但没有必要。尝试这样做：在`main`函数中，添加此测试代码（位置无关紧要）：

```cpp
    file_search f1(""); 
    file_search f2 = f1;
```

编译代码。您将收到一个错误和一个解释：

```cpp
 error C2280: 'file_search::file_search(file_search &)': attempting to reference a deleted function
 note: compiler has generated 'file_search::file_search' here
```

没有复制构造函数，编译器会生成一个（这是第二行）。第一行有点奇怪，因为它说你正在尝试调用编译器生成的已删除的方法！实际上，错误是说生成的复制构造函数正在尝试复制`handle`数据成员和已删除的`search_handle`复制构造函数。因此，您受到保护，防止复制`file_search`对象而无需添加任何其他代码。删除您刚添加的测试行。

接下来，在`main`函数的底部添加以下行。这将创建一个`file_search`对象并将信息打印到控制台。

```cpp
    file_search files(argv[1]); 
    cout << "searching for " << files.path() << endl;
```

然后，您需要添加代码来执行搜索。这里使用的模式将是一个具有输出参数并返回`bool`的方法。如果方法调用成功，则找到的文件将在输出参数中返回，并且该方法将返回`true`。如果调用失败，则输出参数保持不变，并且该方法返回`false`。在`file_search`类的`public`部分中，添加此函数：

```cpp
    bool next(string& ret) 
    { 
        _finddata_t find{}; 
        if (!handle) 
        { 
            handle = _findfirst(search.c_str(), &find); 
            if (!handle) return false; 
        } 
        else 
        { 
            if (-1 == _findnext(handle, &find)) return false; 
        } 

        ret = find.name; 
        return true; 
    }
```

如果这是对该方法的第一次调用，则`handle`将无效，因此将调用`_findfirst`。这将使用搜索结果填充`_finddata_t`结构并返回一个`intptr_t`值。`search_handle`对象的数据成员被赋予从此函数返回的值，如果`_findfirst`返回`-1`，则该方法返回`false`。如果调用成功，则输出参数（指向`string`的引用）将使用`_finddata_t`结构中的 C 字符串指针进行初始化。

如果有更多与模式匹配的文件，那么可以重复调用`next`函数，在这些后续调用中，将调用`_findnext`函数以获取下一个文件。在这种情况下，`search_handle`对象被传递给函数，并通过类的转换运算符隐式转换为`intptr_t`。如果`_findnext`函数返回`-1`，则意味着搜索中没有更多文件。

在`main`函数的底部，添加以下行来执行搜索：

```cpp
    string file; 
    while (files.next(file)) 
    { 
        cout << file << endl; 
    }
```

现在您可以编译代码并使用搜索条件运行它。请记住，这受到`_findfirst`/`_findnext`函数的限制，因此您可以进行的搜索将非常简单。尝试在命令行中运行此命令，并使用参数搜索`Beginning_C++`文件夹中的子文件夹。

```cpp
 search Beginning_C++Ch*
```

这将给出以`Ch`开头的子文件夹列表。由于没有理由让`search_handle`成为一个单独的类，将整个类移到`search_handle`的`private`部分，在`handle`数据成员的声明之上。编译并运行代码。

# 总结

使用类，C++提供了一个强大而灵活的机制来封装数据和方法，以提供对数据进行操作的行为。您可以将此代码模板化，以便编写通用代码并让编译器为您需要的类型生成代码。在本例中，您已经看到类是面向对象的基础。类封装数据，使得调用者只需要了解预期的行为（在本例中是获取搜索中的下一个结果），而无需了解类如何实现这一点的细节。
