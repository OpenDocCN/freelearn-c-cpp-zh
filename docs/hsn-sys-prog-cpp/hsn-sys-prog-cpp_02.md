# 第二章：学习 C、C++17 和 POSIX 标准

如第一章所述，*开始系统编程*，系统编程是通过进行系统调用与底层操作系统协调来执行各种操作的行为。每个操作系统都有自己的一套系统调用，以及这些系统调用的执行方式也各不相同。

为了防止系统程序员不得不为每个不同的操作系统重新编写他们的程序，已经制定了几个标准，这些标准用一个明确定义的 API 包装了操作系统的 ABI。

在本章中，我们将讨论三个标准——C 标准、C++标准和 POSIX 标准。C 和 POSIX 标准提供了包装操作系统 ABI 的基本语言语法和 API。具体来说，C 标准定义了程序链接和执行，标准 C 语法（许多高级语言，如 C++，都是基于此），以及提供 ABI 到 API 包装的 C 库。

C 库可以被视为更大的 POSIX 标准的子集，后者定义了更大的 API 子集，包括但不限于文件系统、网络和线程库。

最后，C++标准定义了 C++语法、程序链接和执行，以及提供 C 和 POSIX 标准更高级抽象的 C++库。本书的大部分内容将围绕这些标准 API 以及如何在 C++17 中使用它们。

本章有以下目标：

+   学习 C、C++和 POSIX 标准

+   理解程序链接和执行，以及 C 和 C++之间的区别

+   简要概述这些标准提供的功能，每个功能将在本书的后面更详细地讨论

# 技术要求

为了跟随本章的示例，读者必须具备：

+   一个能够编译和执行 C++17 的基于 Linux 的系统（例如，Ubuntu 17.10+）

+   GCC 7+

+   CMake 3.6+

+   互联网连接

要下载本章中的所有代码，包括示例和代码片段，请转到以下链接：[`github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter02`](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter02)。

# 从 C 标准语言开始

C 编程语言是最古老的语言之一。与其他高级语言不同，C 足够类似汇编语言编程，同时又提供了一些高级编程抽象，因此成为系统、嵌入式和内核级程序员的首选。

几乎每个主要的操作系统都源自 C。此外，大多数高级语言，包括 C++，都是基于 C 构建其高级构造，因此仍然需要 C 标准的一些组件。

C 标准是由**国际标准化组织**（**ISO**）管理的一个庞大标准。我们假设读者对 C 标准和如何编写 C 代码有一些基本知识：[`www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf`](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf)。

因此，本节的目标是讨论一些在其他书中讨论得较少的主题，以及本书和系统编程相关的 C 标准的部分，但在其他章节中缺失。

有关 C 编程语言和如何编写 C 程序的更多信息，请参阅本章的*进一步阅读*部分。

# 标准的组织方式

该规范分为三个部分：

+   环境

+   语言

+   库

让我们简要讨论每个部分的目的。之后，我们将讨论 C 标准的特定部分，这些部分与系统编程相关，但在本书的其他地方没有讨论。

# 环境

标准的环境部分提供了主要由编译器编写者需要的信息，以更好地理解如何为 C 创建编译器。

它描述了编译器必须遵守的最低限制（例如必须支持的最小嵌套`if()`语句数量），以及程序是如何链接和启动的。

在本章中，我们将讨论程序链接和执行，以更好地理解创建 C 程序所需的内容。

# 语言

标准的语言部分提供了与 C 语法相关的所有细节，包括变量是什么，如何编写函数，`for()`循环和`while()`循环之间的区别，以及支持的所有运算符以及它们的工作原理。

这本书假设读者对标准的这一部分有一般的了解，并且只涉及标准 C 语法的系统编程特定细微差别，读者可能会遇到的问题（比如与指针相关的问题）。

# 库

标准的库部分描述了标准 C 语言提供的所有库设施。这包括向`stdout`输出字符串、分配内存和处理时间等设施。

系统编程主要围绕这些库设施展开，本书的大部分内容将集中在这些库设施上，它们提供了什么以及如何使用它们。

# C 程序的启动方式

标准中与系统编程相关但在文献中没有被广泛讨论的一部分是 C 程序如何启动。一个常见的误解是 C 程序从以下两个入口点开始：

```cpp
int main(void) {}
int main(int argc, char *argv[]) {}
```

虽然这实际上是 C 程序员提供的第一个函数调用，但它并不是 C 程序启动时调用的第一个函数。它也不是执行的第一段代码，也不是用户提供的第一段执行的代码。

在`main()`函数执行之前，操作系统和标准 C 环境以及用户都进行了大量的工作。

让我们看看编译器如何创建一个简单的`Hello World\n`示例：

```cpp
#include <stdio.h>

int main(void) 
{
    printf("Hello World\n");
}
```

为了更好地理解 C 程序的启动过程，让我们看看这个简单程序是如何编译的：

```cpp
> gcc -v scratchpad.c; ./a.out

Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
Configured with: ...
...
```

通过向 GCC 添加`-v`选项，我们可以看到编译器编译我们的简单的`Hello World\n`程序所采取的每一步。

首先，编译器将程序转换为可以由`gnu-as`处理的格式：

```cpp
/usr/lib/gcc/x86_64-linux-gnu/7/cc1 -quiet -v -imultiarch x86_64-linux-gnu scratchpad.c -quiet -dumpbase scratchpad.c -mtune=generic -march=x86-64 -auxbase scratchpad -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/ccMSWHgC.s
```

你不仅可以看到初始编译是如何执行的，还可以看到操作系统提供的默认标志。

接下来，编译器将输出转换为一个目标文件，如下所示：

```cpp
/usr/bin/x86_64-linux-gnu-as -v --64 -o /tmp/cc9oaJWV.o /tmp/ccMSWHgC.s
```

最后，最后一步使用`collect2`实用程序将生成的目标文件链接成一个单独的可执行文件，这是一个围绕链接器的包装器：

```cpp
/usr/lib/gcc/x86_64-linux-gnu/7/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper -plugin-opt=-fresolution=/tmp/ccWQB2Gf.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/7 -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/7/../../.. /tmp/cc9oaJWV.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o
```

在这里有几个重要的事情需要注意关于程序是如何链接的：

+   `-lc`：使用此标志告诉链接器链接`libc`。像这里讨论的其他库一样，我们没有告诉编译器链接`libc`。默认情况下，GCC 会为我们链接`libc`。

+   `-lgcc_s`：这是一个静态库，由 GCC 自动链接，用于支持特定于编译器的操作，包括在 32 位 CPU 上进行 64 位操作，以及诸如异常展开（这是一个将在第十三章中讨论的主题，*异常处理*）。

+   `Scrt1.o`、`crti.o`、`crtbeginS.o`、`crtendS.o`和`crtn.o`：这些库提供了启动和停止应用程序所需的代码。

具体来说，**C 运行时** **库**（**CRT**）库是这里感兴趣的库。这些库提供了引导应用程序所需的代码，包括：

+   执行全局构造函数和析构函数（尽管这不是标准 C 的功能，GCC 支持 C 中的构造函数和析构函数）。

+   设置展开以支持异常支持。虽然这主要是为了 C++异常，对于仅需要标准 C 的应用程序来说是不需要的，但它们仍然需要链接到 set jump 异常逻辑中，这个话题将在第十三章中进行解释，*异常处理*。

+   提供`_start`函数，这是使用默认 GCC 编译器的任何基于 C 的应用程序的实际入口点。

最后，所有这些库都负责为`main()`函数提供传递给它的参数，并拦截`main()`函数的返回值，并在需要时代表您执行`exit()`函数。

这里最重要的一点是，在您的程序中执行的第一段代码不是`main()`函数，如果您注册了全局构造函数，它也不是您提供的第一段代码。在系统编程中，如果您遇到程序初始化的问题，这是首先要查看的地方。

# 关于链接的一切

链接是一个非常复杂的主题，因操作系统而异。例如，Windows 和 Linux 链接程序的方式完全不同。因此，我们将把讨论限制在 Linux 上。

当 C 源文件被编译时，它被编译成所谓的**目标文件**，其中包含以二进制格式定义程序中每个函数的编译源代码，如下所示：

```cpp
> gcc -c scratchpad.c; objdump -d scratchpad.o

...

0000000000000000 <main>:
   0: 55 push %rbp
   1: 48 89 e5 mov %rsp,%rbp
   4: 48 8d 3d 00 00 00 00 lea 0x0(%rip),%rdi # b <main+0xb>
   b: e8 00 00 00 00 callq 10 <main+0x10>
  10: b8 00 00 00 00 mov $0x0,%eax
  15: 5d pop %rbp
  16: c3 retq
```

如此所示，编译器创建了一个目标文件，其中包含源代码的编译（即二进制）版本。这里的一个重要说明是，`main()`函数被标记为*main*，以纯文本形式。

让我们扩展这个例子来包括另一个函数：

```cpp
int test(void)
{
    return 0;
}

int main(void)
{
    return test();
}
```

编译这个源文件，我们得到以下结果：

```cpp
> gcc -c scratchpad.c; objdump -d scratchpad.o

...

0000000000000000 <test>:
   0: 55 push %rbp
   1: 48 89 e5 mov %rsp,%rbp
   4: b8 00 00 00 00 mov $0x0,%eax
   9: 5d pop %rbp
   a: c3 retq

000000000000000b <main>:
   b: 55 push %rbp
   c: 48 89 e5 mov %rsp,%rbp
   f: e8 00 00 00 00 callq 14 <main+0x9>
  14: 5d pop %rbp
  15: c3 retq
```

如此所示，每个编译的函数都使用与函数相同的名称标记。也就是说，每个函数的名称都不是*混编*的（不像 C++）。名称混编将在下一节中进一步详细解释，以及为什么这在链接方面很重要。

超越简单的源文件，C 程序被分成编译和链接在一起的源文件组。具体来说，可执行文件是目标文件和库的组合。库是额外目标文件的组合，分为两种不同的类型：

+   **静态库**：在编译时链接的库

+   **动态库**：在加载时链接的库

# 静态库

静态库是一组在编译时链接的目标文件。在 Linux（和大多数基于 UNIX 的系统中），静态库只是一组目标文件的存档。您可以轻松地获取现有的静态库并使用`AR`工具来提取原始的目标文件。

与作为程序一部分链接的目标文件不同，作为静态库一部分链接的目标文件只包括静态库所需的源代码，提供了优化，从程序中删除未使用的代码，最终减少了程序的总大小。

这种方法的缺点是，使用静态库链接程序的顺序很重要。如果在提供需要该库的代码之前（即在命令行上）链接库，将会发生链接错误，因为静态库中的代码将被优化掉。

操作系统提供的库通常也不支持静态链接，并且通常不需要静态链接操作系统库，因为这些库可能已经被操作系统加载到内存中。

# 动态库

动态库是在加载时链接的库。动态库更像是没有入口点的可执行文件。它们包含程序所需的代码，加载时链接器负责为程序提供每个所需函数的位置。

程序也可以在运行时链接自身作为优化，只链接需要的函数（这个过程称为**延迟加载**）。

操作系统提供的大多数库都是动态库。要查看程序需要哪些动态库，可以使用 LDD 工具，如下所示：

```cpp
> ldd a.out
  linux-vdso.so.1 (0x00007ffdc5bfd000)
  libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f92878a0000)
  /lib64/ld-linux-x86-64.so.2 (0x00007f9287e93000)
```

在这个例子中，我们使用 LDD 工具列出了我们简单的`Hello World\n`示例所需的动态库。如下所示，需要以下库：

+   `vdso`：操作系统提供的库，用于加速系统调用的过程

+   `libc`：标准 C 库

+   `ld-linux-x86-64`：动态链接器本身，负责延迟加载

# 作用域

C 语言的一个特点是它使用*作用域*，这使它与汇编语言编程有了明显的区别。在汇编中，函数的前缀和后缀必须手动编码，而这个过程完全取决于 CPU 提供的**指令集架构**（ISA）和程序员决定使用的 ABI。

在 C 中，函数的作用域会自动使用`{}`语法为您定义。例如：

```cpp
#include <stdio.h>

int main(void) 
{
    printf("Hello World\n");
}
```

在我们简单的`Hello World\n`示例中，作用域用于定义`main()`函数的开始和结束。其他基本类型的作用域也可以使用`{}`语法来定义。例如：

```cpp
#include <stdio.h>

int main(void)
{
    int i;

    for (i = 0; i < 10; i++) {
        printf("Hello World: %d\n", i);
    }
}
```

在上一个例子中，我们定义了`main()`函数和`for()`循环的作用域。

`{}`语法也可以用于为任何内容创建*作用域*。例如：

```cpp
#include <stdio.h>

int main(void)
{
    {
        int i;
        ...
    }

    {
        int i;
        ...
    }
}
```

在上一个例子中，我们能够在不小心重新定义它的情况下两次使用`i`变量，因为我们将`i`的定义包裹在`{}`中。这不仅告诉编译器`i`的作用域，还告诉编译器如果需要的话自动为我们创建前缀和后缀（因为优化可能消除了前缀和后缀的需要）。

作用域还用于定义编译器在链接方面公开的内容。在标准 C 中，`static`关键字告诉编译器变量只对正在编译的目标文件可见（即具有作用域），这不仅为链接器提供了优化，还防止两个全局变量或函数相互冲突。

因此，如果一个函数不打算被另一个源文件（或库）调用，它应该被标记为静态。

在系统编程的上下文中，作用域很重要，因为系统编程通常需要获取系统级资源。正如将在第四章中看到的那样，*C++，RAII 和 GSL 刷新器*，C++提供了使用标准 C`{}`语法创建生命周期可作用域对象的能力，为资源获取和释放提供了安全机制。

# 指针和数组

在学校里，我有一位老师曾经告诉过我：

“无论你有多有经验，没有人完全理解指针。”

没有比这更真实的陈述了。在标准 C 中，指针是一个值指向内存中的位置的变量。标准 C 的问题在于，这个内存位置与特定类型无关。相反，指针类型本身定义了指针指向的内存类型，如下例所示：

```cpp
int main(void)
{
    int i;
    int *p = &i;
}

// > gcc scratchpad.c; ./a.out
```

在上一个例子中，我们创建了一个整数，然后创建了一个指针，并将其指向先前定义的整数。但是，我们可以这样做：

```cpp
int main(void)
{
    int i;
    void *p = &i;

    int *int_p = p;
    float *float_p = p;
}

// > gcc scratchpad.c; ./a.out
```

在这个程序中，我们创建了一个指向整数的指针，但我们将指针类型定义为`void *`，这告诉编译器我们正在创建一个没有类型的指针。然后我们创建了另外两个指针——一个指向整数，一个指向浮点数。这两个额外的指针都是使用我们之前创建的`void *`指针进行初始化的。

这个例子的问题在于标准 C 编译器执行自动类型转换，将`void *`转换为整数指针和浮点数指针。如果同时使用这两个指针，将会发生一些损坏：

+   根据架构的不同，缓冲区溢出可能会发生，因为整数可能比浮点数大，反之亦然。这取决于所使用的 CPU；这是一个将在第三章中更详细讨论的话题，*C 和 C++的系统类型*。

+   在内部，整数和浮点数在同一内存中以不同的方式存储，这意味着任何尝试设置一个值都会破坏另一个值。

值得庆幸的是，现代 C 编译器具有能够检测这种类型转换错误的标志，但是这些警告必须启用，因为它们默认情况下是关闭的，如前所示。

指针的明显问题不仅在于它们可以指向内存中的任何内容并重新定义该内存的含义，而且它们还可以取空值。换句话说，指针被认为是可选的。它们可以选择包含有效值并指向内存，或者它们可以是空的。

因此，在确定其值有效之前，不应使用指针，如下所示：

```cpp
#include <stdio.h>

int main(void)
{
    int i = 42;
    int *p = &i;

    if (p) {
        printf("The answer is: %d\n", *p);
    }
}

// > gcc scratchpad.c; ./a.out
// The answer is: 42
```

在前面的例子中，我们创建了一个指向整数的指针，它被初始化为先前定义的一个初始值为`42`的整数的位置。我们检查确保`p`不是一个空指针，然后将其值输出到`stdout`。

`if()`语句的添加不仅麻烦，而且性能不佳。因此，大多数程序员会省略`if()`语句，因为在这个例子中，`p`永远不会是一个空指针。

这个问题在于，程序员可能会在这个简单的例子中添加与这个假设相矛盾的代码，同时忘记添加`if()`语句，导致潜在生成难以发现的分段错误的代码。

正如将在下一节中所示，C++标准通过引入*引用*的概念来解决这个问题，它是一个非可选指针，这意味着它必须始终指向一个有效的、有类型的内存位置。为了解决这个问题，在标准 C 中，通常（虽然不总是）通过公共 API 来检查空指针。私有 API 通常不会检查空指针以提高性能，这样做的假设是，只要公共 API 不能接受空指针，私有 API 很可能永远不会看到无效的指针。

标准 C 数组类似于指针。唯一的区别在于 C 数组利用了一种能够对指针指向的内存进行索引的语法，就像下面的例子中所示：

```cpp
#include <stdio.h>

int main(void)
{
    int i[2] = {42, 43};
    int *p = i;

    if (p) {
        // method #1
        printf("The answer is: %d and %d\n", i[0], p[0]);
        printf("The answer is: %d and %d\n", i[1], p[1]);

        // method #2
        printf("The answer is: %d and %d\n", *(i + 0), *(p + 0));
        printf("The answer is: %d and %d\n", *(i + 1), *(p + 1));
    }
}

// > gcc scratchpad.c; ./a.out
// The answer is: 42 and 42
// The answer is: 43 and 43
// The answer is: 42 and 42
// The answer is: 43 and 43
```

在前面的例子中，我们创建了一个包含 2 个元素的整数数组，初始化为值`42`和`43`。然后我们创建一个指向该数组的指针。请注意，不再需要`&`。这是因为数组本身就是一个指针，因此我们只是将一个指针设置为另一个指针的值（而不是必须从现有内存位置提取指针）。

最后，我们使用指针算术来打印数组中每个元素的值，既使用数组本身，又使用指向数组的指针。

正如将在第四章中讨论的那样，数组和指针之间几乎没有区别。当尝试访问数组中的元素时，两者都执行所谓的**指针算术**。

在系统编程方面，指针被广泛使用。例如：

+   由于标准 C 不像 C++那样包含*引用*的概念，必须通过引用传递的系统 API（因为它们太大而无法通过值传递，或者必须由 API 修改）必须通过指针传递，因此在进行系统调用时会大量使用指针。

+   系统编程通常涉及与内存中的位置指针交互，旨在定义该内存的布局。指针提供了一种方便的方法来实现这一点。

# 库

标准 C 不仅定义了语法、环境和程序链接方式，还提供了一组库，程序员可以利用这些库来进行系统编程。其中一些库如下：

+   `errno.h`：提供处理错误所需的代码。这个库将在第十三章中进一步讨论，*异常处理*。

+   `inttypes.h`：提供类型信息，将在第三章中讨论，*C 和 C++的系统类型*。

+   `limits.h`：提供每种类型的限制信息，将在第三章中讨论，*C 和 C++的系统类型*。

+   `setjump.h`：提供 C 风格的异常处理的 API，将在第十三章中讨论，*异常处理*。

+   `signal.h`：提供处理系统发送到程序的信号的 API，将在第五章中讨论，*Linux/Unix 系统编程*。

+   `stdbool.h`：提供类型信息，将在第三章中讨论，*C 和 C++的系统类型*。

+   `stddef.h`：提供类型信息，将在第三章中讨论，*C 和 C++的系统类型*。

+   `stdint.h`：提供类型信息，将在第三章中讨论，*C 和 C++的系统类型*。

+   `stdio.h`：提供在系统编程中处理输入和输出的函数，将在第六章和第八章中讨论，*学习控制台输入/输出*和*学习文件输入/输出*。

+   `stdlib.h`：提供各种实用程序，包括动态内存分配 API，将在第七章中讨论，*全面了解内存管理*。

+   `time.h`：提供处理时钟的功能，将在第十一章中讨论，*Unix 中的时间接口*。

正如前面所述，本书的大部分内容将集中在这些功能上，以及它们如何支持系统编程。

# 学习 C++标准

C++编程语言（最初称为带类的 C）专门设计为提供比 C 更高级的功能，包括更好的类型安全性和面向对象编程，同时考虑了系统编程。具体来说，C++旨在提供 C 程序的性能和效率，同时仍提供更高级语言的特性。

如今，C++是世界上最流行的编程语言之一，应用于从航空电子学到银行业的各个领域。

与 C 标准一样，C++标准也很庞大，并由 ISO 管理。我们假设读者对 C++标准和如何编写 C 代码有一些基本的了解：[`www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4713.pdf`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4713.pdf)。

因此，本节的目标是讨论一些在其他书中没有详细讨论的主题，以及与本书和系统编程相关的 C++标准的部分，但在其他章节中缺失。有关 C++编程语言以及如何编写 C++程序的更多信息，请参阅本章的*进一步阅读*部分。

# 标准的组织方式

与 C 标准规范一样，C++规范分为三大组部分：

+   一般约定和概念

+   语言语法

+   库

应该注意到，C++标准比 C 标准要大得多。

# 一般约定和概念

标准中的前四个部分专门讨论约定和概念。它们定义了类型、程序的启动和关闭、内存和链接。它们还概述了理解规范其余部分所需的所有定义和关键字。

与标准 C 规范一样，在这些部分中定义了许多对系统程序员很重要的东西，因为它们定义了编译器在编译程序时将输出什么，以及程序将如何执行。

# 语言语法

规范中的接下来 12 个部分定义了 C++语言的语法本身。这包括 C++的特性，如类、重载、模板和异常处理。有整本书只是针对规范的这些部分写的。

我们假设读者对 C++有一般的了解，我们在书中不再讨论这部分规范，除了第四章中关于 C++17 的修改，*C++，RAII 和 GSL 刷新*。

# 库

规范中剩下的 14 个部分定义了 C++作为规范一部分提供的库。应该注意到，本书的大部分内容都围绕着规范的这一部分。

具体来说，我们详细讨论了 C++为系统程序员提供的设施，以及如何在实践中使用这些设施。

# 链接 C++应用程序

与 C 一样，C++应用程序通常从一个具有与 C 相同签名的`main()`函数开始。同样，与 C 程序一样，代码的实际入口点实际上是`_start`函数。

然而，与 C 不同，C++要复杂得多，包括了更多的代码来演示一个简单的例子。为了证明这一点，让我们看一个简单的`Hello World\n`示例：

```cpp
#include <iostream>

int main(void)
{
    std::cout << "Hello World\n";
}

// > g++ scratchpad.cpp; ./a.out
// Hello World
```

首先，C++应用程序示例比上一节中等价的 C 示例略长：

```cpp
> gcc scratchpad.c -o c_example
> g++ scratchpad.cpp -o cpp_example
> stat -c "%s %n" *
8352 c_example
8768 cpp_example
```

如果我们看一下我们的示例中的符号，我们得到以下内容：

```cpp
> nm -gC cpp_example
                 U __cxa_atexit@@GLIBC_2.2.5
                 w __cxa_finalize@@GLIBC_2.2.5
00000000000008f4 T _fini
0000000000000688 T _init
00000000000007fa T main
00000000000006f0 T _start
                 U std::ios_base::Init::Init()@@GLIBCXX_3.4
                 U std::ios_base::Init::~Init()@@GLIBCXX_3.4
0000000000201020 B std::cout@@GLIBCXX_3.4
                 U std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)@@GLIBCXX_3.4

...
```

如前所述，我们的程序包含一个`main()`函数和一个`_start()`函数。`_start()`函数是应用程序的实际入口点，而`main()`函数在初始化完成后由`_start()`函数调用。

`_init()`和`_fini()`函数负责全局构造和销毁。在我们的示例中，`_init()`函数创建了 C++库支持`std::cout`所需的代码，而`_fini()`函数负责销毁这些全局对象。为此，全局对象使用`__cxa_atexit()`函数注册，并最终使用`__cxa_finalize()`函数销毁。

其余的符号构成了`std::cout`的代码，包括对`ios_base{}`和`basic_ostream{}`的引用。

这里需要注意的重要事情是，与 C 语言一样，有很多代码在`main()`函数之前和之后执行，并且在 C++中使用全局对象只会增加启动和停止应用程序的复杂性。

在前面的例子中，我们使用`_C`选项来解开我们的函数名。让我们看看使用这个选项的相同输出：

```cpp
> nm -gC cpp_example
                 U __cxa_atexit@@GLIBC_2.2.5
                 w __cxa_finalize@@GLIBC_2.2.5
00000000000008f4 T _fini
0000000000000688 T _init
00000000000007fa T main
00000000000006f0 T _start
                 U _ZNSt8ios_base4InitC1Ev@@GLIBCXX_3.4
                 U _ZNSt8ios_base4InitD1Ev@@GLIBCXX_3.4
0000000000201020 B _ZSt4cout@@GLIBCXX_3.4
                 U _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@@GLIBCXX_3.4

...
```

如上所示，一些函数仍然可读，而另一些则不可读。具体来说，C++规范规定某些支持函数使用 C 链接进行链接，防止名称编码。在我们的例子中，这包括`__cxa_xxx()`函数、`_init()`、`_fini()`、`main()`和`_start()`。

然而，支持`std::cout`的 C++库函数的语法几乎无法阅读。在大多数符合 POSIX 标准的系统上，可以使用`C++filt`命令来解开这些编码的名称，如下所示：

```cpp
> c++filt _ZSt4cout
std::cout
```

这些名称被编码是因为它们的名称中包含了整个函数签名，包括参数和特化（例如，`noexcept`关键字）。为了证明这一点，让我们创建两个函数重载：

```cpp
void test(void) {}
void test(bool b) {}

int main(void)
{
    test();
    test(false);
}

// > g++ scratchpad.cpp; ./a.out
```

在前面的例子中，我们创建了两个具有相同名称但不同函数签名的函数，这个过程称为**函数重载**，这是 C++特有的。

现在让我们看看我们测试应用程序中的符号：

```cpp
> nm -g a.out
...

0000000000000601 T _Z4testb
00000000000005fa T _Z4testv
```

函数名在 C++中被编码的原因有几个：

+   在函数名中编码函数参数意味着函数可以重载，并且编译器和链接器将知道哪个函数做什么。没有名称编码，具有相同名称但不同参数的两个函数对于链接器来说看起来是相同的，会导致错误。

+   通过在函数名中编码这种类型的信息，链接器能够识别库函数是否使用了不同的签名进行编译。没有这些信息，链接器可能会将使用不同签名（因此不同实现）编译的库链接到相同的函数名，这将导致难以发现的错误，很可能会导致损坏。

C++名称编码的最大问题是对公共 API 进行微小更改会导致库无法再与已经存在的代码链接。

有许多方法可以克服这个问题，但总的来说，重要的是要理解 C++在函数名中编码了关于你如何编写代码的大量信息，这使得公共 API 不改变除非期望进行版本更改至关重要。

# 作用域

C 和 C++之间的一个主要区别是对象的构造和销毁是如何处理的。让我们看下面的例子：

```cpp
#include <iostream>

struct mystruct {
    int data1{42};
    int data2{42};
};

int main(void)
{
    mystruct s;
    std::cout << s.data1 << '\n';
}

// > g++ scratchpad.cpp; ./a.out
// 42
```

与 C 语言不同，在 C++中，我们可以使用`{}`运算符来定义结构的数据值应该如何初始化。这是可能的，因为在 C++中，对象（包括结构和类）包含构造函数和析构函数，定义了对象在构造时如何初始化和在销毁时如何销毁。

在系统编程时，这种方案将被广泛使用，并且在处理系统资源时，构造和销毁对象的概念将贯穿本书。具体来说，将利用作用域来定义对象的生命周期，从而定义对象拥有的系统资源，使用一种称为**资源获取即初始化**（**RAII**）的概念。

# 指针与引用

在前一节中，我们详细讨论了指针，包括指针可以取两个值——有效或空（假设损坏不是方程式的一部分）。

问题在于用户必须检查指针是否有效。当使用指针来定义内存的内容（例如，使用数据结构布局内存）时，通常不会出现问题，但在 C 中，指针经常必须简单地用于减少将大型对象传递给函数的开销，就像以下示例中一样：

```cpp
struct mystruct {
    int data1{};
    int data2{};
    int data3{};
    int data4{};
    int data5{};
    int data6{};
    int data7{};
    int data8{};
};

void test(mystruct *s)
{
}

int main(void)
{
    mystruct s;
    test(&s);
}

// > g++ scratchpad.cpp; ./a.out
```

在前面的例子中，我们创建了一个包含八个变量的结构。以值传递这种类型的结构将导致使用堆栈（即，多次内存访问）。在 C 中，通过指针传递这种结构以减少将结构传递给单个寄存器的成本更加高效，很可能完全消除所有内存访问。

问题在于，现在，test 函数必须在使用指针之前检查指针是否有效。因此，该函数将一组内存访问交换为分支语句和可能导致 CPU 流水线刷新的操作，而我们所要做的只是减少将大型对象传递给函数的成本。

如前一节所述，解决方案就是简单地不验证指针的有效性。然而，在 C++中，我们还有另一个选择，那就是通过引用传递结构，如下所示：

```cpp
struct mystruct {
    int data1{};
    int data2{};
    int data3{};
    int data4{};
    int data5{};
    int data6{};
    int data7{};
    int data8{};
};

void test(mystruct &s)
{
}

int main(void)
{
    mystruct s;
    test(s);
}

// > g++ scratchpad.cpp; ./a.out
```

在前面的例子中，我们的`test()`函数接受了`mystruct{}`的引用，而不是指针。当我们调用`test()`函数时，无需获取结构的地址，因为我们没有使用指针。

C++引用将在本书中大量使用，因为它们极大地提高了程序的性能和稳定性，特别是在系统编程中，资源、性能和稳定性至关重要。

# 库

C++不仅定义了基本的环境和语言语法，还提供了一组库，程序员可以利用这些库进行系统编程。这些包括以下内容：

+   **控制台输入/输出库**：这些包括`iostream`，`iomanip`和`string`库，它们提供了处理字符串、格式化字符串和输出字符串（或从用户那里获取输入）的能力。我们将在第六章中讨论大多数这些库，*学习编程控制台输入/输出*。

+   **内存管理库**：这些包括内存库，其中包含有助于防止悬空指针的内存管理实用程序。它们将在第七章中讨论*全面了解内存管理*。

+   **文件输入/输出库**：这些包括`fstream`和`filesystem`（C++17 中新增）库，在第八章中将讨论*学习文件输入/输出*。

+   **时间库**：这些包括`chrono`库，在第十一章中将讨论*Unix 中的时间接口*。

+   **线程库**：这些包括`thread`，`mutex`和`conditional_variable`库，在第十二章中将讨论*学习编程 POSIX 和 C++线程*。

+   **错误处理库**：这些包括异常支持库，在第十三章中将讨论*使用异常进行错误处理*

# 从 POSIX 标准开始

POSIX 标准定义了符合 POSIX 的操作系统必须实现的所有功能。在系统编程方面，POSIX 标准定义了操作系统必须支持的系统调用接口（即 API，而不是 ABI）。

在底层，C 和 C ++提供的大多数系统级 API 实际上执行 POSIX 函数，或者它们本身就是 POSIX 函数（就像很多 C 库 API 一样）。事实上，`libc`通常被认为是更大的 POSIX 标准的子集，而 C ++利用`libc`和 POSIX 来实现其更高级的 API，如线程，内存管理，错误处理，文件操作和输入/输出。有关更多信息，请参阅[`ieeexplore.ieee.org/document/8277153/`](https://ieeexplore.ieee.org/document/8277153/)。

在本节中，我们将讨论与系统编程相关的 POSIX 标准的一些组件。所有这些主题将在后面的章节中进一步详细讨论。

# 内存管理

`libc`提供的所有内存管理函数也被视为 POSIX API。此外，还有一些`libc`不提供的 POSIX 特定内存管理函数，如对齐内存。

例如，以下演示了如何使用 POSIX 分配对齐的动态（堆）内存：

```cpp
#include <iostream>

int main()
{
    void *ptr;

    if (posix_memalign(&ptr, 0x1000, 42 * sizeof(int))) {
        std::clog << "ERROR: unable to allocate aligned memory\n";
        ::exit(EXIT_FAILURE);
    }

    std::cout << ptr << '\n';
    free(ptr);
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x55c5d31d1000
```

在这个例子中，我们使用`posix_memalign()`函数来分配一个对齐到页面的`42`个整数的数组。这是一个 POSIX 特定的函数。

此外，我们还利用`std::clog()`函数将错误输出到`stderr`，在底层利用了 POSIX 特定函数将字符串输出到`stderr`。我们还使用了`::exit()`，这是一个用于退出应用程序的`libc`和 POSIX 函数。

最后，我们利用了`std::cout()`和`free()`函数。`std::cout()`使用 POSIX 函数将字符串输出到`stdout`，而`free()`是用于释放内存的`libc`和 POSIX 特定函数。

在这个简单的例子中，我们利用了几个 C、C++和 POSIX 特定的功能来执行系统编程。在本书中，我们将讨论如何大量利用 POSIX 来编程系统以完成特定任务。

# 文件系统

POSIX 不仅定义了如何从符合 POSIX 的操作系统中读取和写入文件，还定义了文件应该位于文件系统上的位置。在第八章中，《学习使用 C、C++和 POSIX 进行文件输入/输出编程》，我们将详细介绍如何使用 C、C++和 POSIX 读取和写入文件系统。

关于文件系统的布局，POSIX 定义了文件应该位于的位置，包括以下常见文件夹：

+   `/bin`：所有用户使用的二进制文件

+   `/boot`：启动操作系统所需的文件

+   `/dev`：物理和虚拟设备

+   `/etc`：操作系统需要的配置文件

+   `/home`：用户特定的文件

+   `/lib`：可执行文件需要的库

+   `/mnt 和/media`：用作临时挂载点

+   `/sbin`：系统特定的二进制文件

+   `/tmp`：在重启时删除的文件

+   `/usr`：前述文件夹的用户特定版本

# 套接字

要在符合 POSIX 的操作系统上进行网络编程，您需要利用 POSIX 套接字 API。POSIX 提供的套接字编程接口是一个很好的例子，它既不是由 C 也不是由 C++提供的一组 API，但在符合 POSIX 的操作系统上进行网络编程时是必需的。

在第十章中，《使用 C++编程 POSIX 套接字》，我们将讨论如何使用 POSIX 套接字 API 执行网络编程，同时利用 C ++。具体来说，我们将展示如何利用 C ++简化基于套接字的网络编程的实现，并提供如何执行网络编程的几个示例。

# 线程

线程为系统程序员提供了执行并行执行的手段。具体来说，线程是操作系统在适当时安排的执行单元。C++和 POSIX 都提供了用于处理线程的 API，其中 C++的 API 可能更容易使用。

应该注意，在幕后，C++利用了 POSIX 线程库（pthreads）-因此，即使 C++提供了一组用于处理线程的 API，最终，POSIX 线程负责所有情况下的线程。

这是因为原因很简单。 POSIX 定义了程序与操作系统交流的接口。在这种情况下，如果您希望告诉操作系统创建一个线程，您必须通过利用操作系统定义的 API 来实现。如果操作系统符合 POSIX 标准，那么这些接口就是 POSIX，而不管可能会被放置在那里以使 API 更容易使用的任何抽象。

# 总结

在本章中，我们了解了三种不同的标准：C、C++和 POSIX。 C 标准定义了流行的 C 语法，C 风格的程序链接和执行，以及提供跨平台 API 的标准 C 库，以包装操作系统的 ABI。

我们还了解了 C++标准，以及它如何定义 C++语法，程序链接和执行，以及高级 C++ API，以包装底层的 C 和 POSIX API 到 C++。

最后，我们看到 POSIX 标准提供了超出 C 的额外 API。这些 API 包括（但不限于）内存管理、网络和线程。一般来说，POSIX 标准定义了应用程序在任何符合 POSIX 标准的操作系统上以跨平台方式执行其功能所需的所有标准。

本书的其余部分将重点关注这些标准中定义的 API，以及它们如何用于在 C++17 中进行系统编程。在下一章中，我们将专门介绍由 C、C++和 POSIX 提供的系统类型，以及它们如何影响系统编程。

# 问题

1.  C 标准是否是 POSIX 标准的一部分？如果是，列举一个在两个标准中都常见的 API。

1.  `_start()`和`main()`函数之间有什么区别？

1.  列举 C 运行时的一个职责。

1.  全局构造函数是在`main()`函数之前还是之后执行的？

1.  C++名称修饰是什么，为什么需要？

1.  列举 C 和 C++程序链接之间的一个区别。

1.  指针和引用之间有什么区别？

# 进一步阅读

+   [`www.packtpub.com/application-development/c17-example`](https://www.packtpub.com/application-development/c17-example)

+   [`www.packtpub.com/application-development/getting-started-c17-programming-video`](https://www.packtpub.com/application-development/getting-started-c17-programming-video)
