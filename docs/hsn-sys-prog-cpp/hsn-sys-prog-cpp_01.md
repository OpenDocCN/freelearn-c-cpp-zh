# 第一章：开始系统编程

在本章中，我们将讨论系统编程是什么（即，向操作系统发出系统调用以代表您执行操作），并深入探讨系统编程和使用 C++进行系统编程的利弊。

在本章中，我们将回顾以下内容：

+   系统调用，包括它们是什么，如何执行它们以及与它们相关的潜在安全风险

+   在系统编程时使用 C++的好处

# 技术要求

为了遵循本章的示例，读者必须具备：

+   能够编译和执行 C++17 的基于 Linux 的系统（例如，Ubuntu 17.10+）

+   GCC 7+

+   CMake 3.6+

+   互联网连接

# 理解系统调用

操作系统是一种旨在同时执行一个或多个应用程序的软件，同时还提供这些应用程序执行所需的资源。为了实现这一点，操作系统必须能够在同一时间将硬件资源分配给系统上执行的所有应用程序。

例如，大多数个人电脑（PC）都有一个存储所有文件的硬盘，这些文件是 PC 所有者正在使用的。在现代 PC 上，用户可能希望同时执行几个应用程序，例如网络浏览器和办公套件。

这两个应用程序都需要在执行时不同的时间独占访问硬盘。对于网络浏览器，这可能是将网站缓存到磁盘中，而对于办公套件，这可能是存储文档。

操作系统有责任管理应用程序及其对硬盘的访问，以确保网络浏览器和办公套件都能正常执行。

为了实现这一点，操作系统提供了应用程序编程接口（API），应用程序可以利用这些接口来完成其任务。访问硬盘就是其中一个任务的例子。`read()`和`write()`函数是 POSIX 兼容操作系统提供的 API 的例子，用于从文件描述符读取和写入数据。

在底层，这些 API 使用称为系统调用的应用程序二进制接口（ABI）向操作系统发出调用。执行系统调用以完成操作系统提供的任务的行为称为系统编程，这是本书的主要重点。

# 系统调用的解剖学

在本节中，我们将重点关注英特尔 x86 架构的示例，尽管这些示例适用于大多数其他 CPU 架构。

原始的 x86 架构利用中断提供系统调用 ABI。操作系统提供的 API 将在 CPU 上编程特定寄存器，并使用中断调用操作系统。

例如，使用 BIOS，应用程序可以使用`int 0x13`从硬盘中读取数据，其寄存器布局如下：

+   `AH = 2`

+   `AL`：要读取的扇区

+   `CH`：柱面

+   `CL`：扇区

+   `DH`：磁头

+   `DL`：驱动器

+   `ES:BX`：缓冲区地址

应用程序作者将使用`read()`API 命令来读取这些数据，而在底层，`read()`将使用前面的 ABI 执行系统调用。当`int 0x13`执行时，应用程序将被硬件暂停，操作系统（在本例中为 BIOS）将代表应用程序执行从磁盘中读取数据，并将结果返回到应用程序提供的缓冲区中。

完成后，BIOS 将执行`iret`（中断返回）以返回到应用程序，然后应用程序将从磁盘中读取的数据等待在其缓冲区中以供使用。

采用这种方法，应用程序不需要知道如何在特定计算机上与硬盘进行物理接口，以便读取数据；这是操作系统及其设备驱动程序应该处理的任务。

应用程序也不必担心可能正在执行的其他应用程序。它只需利用提供的 API（或 ABI，取决于操作系统），其余繁琐的细节由操作系统处理。

换句话说，系统调用提供了应用程序之间的清晰界限，以帮助用户完成特定任务，并帮助操作系统管理这些应用程序和它们所需的硬件资源。

然而，中断是缓慢的。硬件不会对操作系统的编写方式或操作系统正在执行的应用程序的编写或组织方式做任何假设。因此，中断必须在执行中断处理程序之前保存 CPU 状态，并在执行`iret`命令时恢复此状态，导致性能不佳。

正如将要展示的那样，应用程序在尝试执行其任务时会进行大量的系统调用，这种性能不佳成为 x86 架构（以及其他 CPU 架构）的瓶颈。

为了解决这个问题，现代版本的 Intel x86 CPU 提供了*快速系统调用*指令。这些指令专门设计用于解决基于中断的系统调用的性能瓶颈。然而，它们需要 CPU、操作系统和在该操作系统上执行的应用程序之间的协调，以减少开销。

具体来说，操作系统必须以 CPU 指定的特定方式构造自身和正在运行的应用程序的内存布局。通过预定义操作系统及其相关应用程序的内存布局，CPU 在执行系统调用时不再需要保存和恢复太多 CPU 状态，从而减少开销。如何实现这一点取决于您是在 Intel 还是 AMD x86 CPU 上执行。

关于系统调用的执行方式最重要的一点是，系统调用并不廉价。即使有快速系统调用支持，系统调用也必须执行大量的工作。在通过`read()`API 从硬盘读取数据的情况下，必须设置 CPU 寄存器状态并执行系统调用指令。CPU 控制权被移交给操作系统，以从硬盘中读取数据。

由于可能有多个应用程序正在执行，并且尝试同时从硬盘中读取数据，因此操作系统可能必须暂停应用程序，以便为另一个应用程序提供服务。

一旦操作系统准备好为应用程序提供服务，它必须首先弄清楚应用程序试图读取的数据，这最终决定了它需要与哪个物理设备进行交互。在我们的例子中，这是一个硬盘，但在符合 POSIX 标准的系统中，它可以是任何类型的块设备。

接下来，操作系统必须利用其设备驱动程序之一从这个硬盘中读取数据。这需要时间，因为操作系统必须在硬盘上物理编程，要求从特定位置请求数据，通过一个几乎肯定不以与 CPU 本身相同的速度执行的硬件总线。

一旦硬盘最终向操作系统提供所请求的数据，操作系统可以将这些信息提供给应用程序，并返回控制权，将 CPU 状态恢复给应用程序。所有这些繁琐的工作都被一个`read()`调用所隐藏。

因此，系统调用应该谨慎执行，只在绝对需要时执行，以防止导致应用程序性能不佳。

值得注意的是，这种优化类型需要对应用程序利用的 API 有深入的了解，因为更高级的 API 会代表 API 自己进行系统调用。例如，分配内存，稍后将讨论，也是另一种系统调用。

例如，看看使用`std::array{}`或`std::vector{}`命令之间的区别。`std::vector{}`支持在底层管理的数组大小调整，这需要内存分配。这不仅可能导致内存碎片化（这本书后面将讨论的一个主题），还可能导致性能不佳，因为内存分配可能需要向操作系统请求更多的系统 RAM。

# 了解不同类型的系统调用

几乎在符合 POSIX 标准的操作系统上执行的每个应用程序都必须进行一些系统调用。在这里，我们概述了本书中将探讨的一些系统调用类型。

# 控制台输入/输出

如果您曾经执行过命令行应用程序，您将会熟悉基于控制台的输入/输出的概念。这在符合 POSIX 标准的操作系统中尤其如此。在向控制台输出时，您可以将输出发送到`stdout`（通常用于正常输出）或`stderr`（通常用于输出错误消息）。

通过应用程序执行系统调用来输出到`stdout`和`stderr`。 （值得注意的是，在本书中，我们通常说我们*输出到*`stdout`，而不是*打印到控制台*。）

这是因为，在符合 POSIX 标准的系统上，您的应用程序实际上并不知道将文本发送到哪里。应用程序利用 API 输出到`stdout`。这可以通过以下方式实现：

+   写入专用文件句柄（即`stdout`）

+   使用 C API，如`printf`

+   使用 C++ API，如`std::cout`

+   为您输出到`stdout`的应用程序分叉（例如，使用`echo`）

大多数情况下，这些示例在说到底都会向操作系统发出系统调用，将字符缓冲区传输到管理`stdout`或`stderr`的设备。在某些情况下，这会导致操作系统将生成的字符缓冲区传递给父进程（可能是您的 shell），最终父进程会再次进行系统调用，将字符缓冲区显示在屏幕上。

无论您的操作系统如何处理，操作系统中存在一个设备驱动程序，用于管理用于显示文本的物理监视器，应用程序调用的简单 API（例如`printf`和`std::cout`）最终会向该设备驱动程序提供所请求的字符缓冲区。

尽管在大多数系统上，输出到`stdout`的文本通常会提供给您的 shell，并最终显示在屏幕上，但这并非一定如此。由于应用程序正在进行系统调用以输出字符缓冲区，因此操作系统可以自由地将这些数据转发到串行设备、日志文件、作为另一个应用程序的输入等。

这种灵活性是符合 POSIX 标准的操作系统如此强大的原因之一，也是学习如何正确进行系统调用如此重要的原因。

# 内存分配

内存是应用程序必须使用系统调用请求的另一种资源。当应用程序首次执行时，大多数应用程序会获得全局和堆栈内存资源，以及应用程序在调用诸如`malloc()`和`free()`等函数时可以使用的一小块堆内存。

如果应用程序只使用最初在堆中给定的内存，那么应用程序不需要请求额外的内存。然而，如果堆内存用尽，应用程序的`malloc()`或`free()`引擎将不得不向操作系统（通过系统调用）请求更多内存。

为了做到这一点，操作系统将通过向应用程序添加更多的物理内存来扩展应用程序的末端。然后，`malloc()`或`free()`引擎能够利用这些额外的内存，直到需要更多内存。

在内存有限的系统上，当请求额外的内存时，操作系统必须从当前未执行的其他应用程序中获取内存。它通过将这些应用程序交换到磁盘上来实现这一点，这是一种昂贵的操作。

因此，在资源受限的系统上，不应该在时间关键的代码中调用`malloc()`或`free()`，因为执行这些函数所需的时间可能会有很大的变化。

我们将在第七章中更详细地介绍内存管理，*全面了解内存管理*。

# 文件输入/输出

读写文件是大多数应用程序的另一个常见用例，需要进行系统调用。

值得注意的是，在符合 POSIX 的系统上，读取和写入文件描述符并不总是意味着读取和写入存储设备上的文件。相反，您所做的系统调用会写入*字符*或*块*设备。这可能是一个存储设备，但也可能是一个控制台设备，甚至是一个虚拟设备，比如`/dev/random`，在读取时提供随机数据。

在第八章中，*学习文件输入/输出编程*，我们将提供有关文件输入/输出系统编程的更多信息。

# 网络

网络是另一个常见的用例，需要进行系统调用。在符合 POSIX 的系统上，我们通过使用 POSIX 套接字进行基于网络的系统编程。套接字提供了与操作系统中的**网络接口控制器**（**NIC**）和支持逻辑（例如 TCP/IP 协议栈）进行编程的 API。

网络本身是一个非常复杂的主题，值得有一本专门的书来讨论，但幸运的是，执行这种类型的编程所需的系统调用是简单的，大部分繁琐的细节由操作系统处理。

在第十章中，*使用 C++编程 POSIX 套接字*，我们将更详细地介绍如何使用套接字 API 进行这些类型的系统调用。

# 时间

一些读者可能会感到惊讶，甚至执行简单的任务，如获取当前日期和时间，都需要系统调用来向操作系统请求这些信息。直到今天，系统上都提供了一个专用芯片（带有电池，以防断电）来维护当前的日期和时间。

如果需要这些信息，必须进行系统调用来请求。当这种情况发生时，操作系统将询问负责管理芯片的设备驱动程序当前存储的日期和时间，然后将此信息返回给应用程序。

值得注意的是，并非所有时间接口都需要系统调用。例如，大多数高分辨率定时器，它们旨在在操作发生前后比较高分辨率数字，不需要操作系统执行此操作。这是因为这些高分辨率定时器通常直接存在于 CPU 中，并且它们的值可以使用简单的指令提取。

这些类型的定时器的缺点是它们的值本身通常是没有意义的（也就是说，返回的值之间的差异才提供了意义，而不是值本身）。基本上，这些定时器通常只是一个计数器，每次 CPU 滴答（也就是执行一条指令）时递增。

由于现代 CPU 可以动态改变其频率，这些计数器存储的值取决于 CPU 自上次上电以来执行的时间长短，以及 CPU 在执行时设置的频率。

甚至不能保证一个计数器中的值与另一个物理核上的另一个计数器中读取的值相同，因为每个物理核都能够独立于多核 CPU 上的其他核改变自己的频率。

高分辨率定时器的好处是它们可以非常快地执行（因为您只是执行一个读取 CPU 中计数器的指令）。两个测量值之间的差异可以用来执行诸如测量执行小函数所需时间的任务，这通常无法使用标准定时器完成，因为它们没有足够的粒度。

在第十一章中，《Unix 中的时间接口》，我们将详细介绍这些细节，甚至提供如何自己实现的示例。

# 线程和进程创建

同时执行多个任务可以通过请求操作系统创建额外的线程（甚至新进程）来实现。这是系统编程中的常见任务，有许多系统调用可以完成这项工作。

进程是一个执行单元，为其分配了一组资源（例如内存、文件描述符等）。每个应用程序至少由一个进程组成，但它们可以包含多个进程（例如，shell 是一个专门设计用于运行多个子进程的应用程序）。

每个进程由操作系统安排执行一定的时间，然后下一个进程获得 CPU 的访问权限，这个循环根据需要继续进行。

线程类似于进程，但它们与同一进程的其他线程共享相同的资源。线程为应用程序提供了一个机会，可以创建能够并行执行的任务，而无需使用进程间通信方法。在第十二章中，《学习使用 POSIX 和 C++线程编程》，我们将学习如何使用 POSIX 和 C++ API 编程线程。

# 系统调用安全风险

系统调用并非没有安全风险。即使在现代硬件上，使用英特尔以外的 CPU 架构，在操作系统中执行多个进程并实现进程之间的完全隔离几乎是不可能的。

尽管现代硬件和现代操作系统都在努力提供最佳的隔离和安全性，但应始终假定与您同时执行的其他恶意进程可能能够窥探您的操作，包括解密用户数据等敏感任务。

这是另一个值得一本专门书籍的主题，但在这里，我们将简要讨论影响系统编程的两种不同的最近的安全漏洞。

# SYSRET

英特尔和 AMD 提供的*快速系统调用*接口并非没有问题。如前所述，为了使快速系统调用正常工作，硬件、操作系统和应用程序必须协调。这是为了确保 ABI 信息得到正确处理，以允许操作系统在执行系统调用之前无需硬件保存整个 CPU 状态。

当系统调用完成并且必须将控制权交还给应用程序时也是如此。为了实现这一点，操作系统必须加载应用程序的堆栈，然后执行`SYSRET`指令，将控制权返回给应用程序。

这种方法的问题在于**不可屏蔽中断**（NMI）可能会在操作系统加载应用程序的堆栈和执行`SYSRET`之间触发。这种竞争条件的结果是，NMI（以根权限执行的代码）将使用应用程序的堆栈而不是内核的堆栈执行，从而可能导致安全漏洞或损坏。

值得庆幸的是，现代操作系统有办法防止这种类型的攻击，大多数操作系统，如 Linux，都可以并且确实利用这些方法。

# Meltdown 和 Spectre

熔断和幽灵攻击是系统调用实现的复杂性的现代例子。为了支持系统调用的快速执行，内核的内存被映射到每个应用程序中，使用一种称为 3:1 分割的内存布局技术，指的是应用程序内存与内核内存的三比一的比例。

为了防止应用程序读取/写入内核内存，这些内核内存可能包含高度敏感的信息，如加密密钥和密码，现代 CPU 架构提供了一种机制来锁定内核内存的部分，以便只有内核能够看到所有内容。应用程序只能看到其部分特权内存。

为了提高这些现代 CPU 的性能，包括英特尔、AMD 和 ARM 在内的大多数架构都采用了一种称为**推测执行**的技术。例如，看下面的代码：

```cpp
if (x) {
    do_y();
}

do_z();
```

CPU 在执行这条指令之前不知道`x`是真还是假。如果 CPU 假设`x`是真，它可以通过节省一些 CPU 周期来提高性能。如果`x`实际上是真的，CPU 就能节省周期，而如果`x`实际上是假的，惩罚通常是值得冒的风险，特别是如果 CPU 能够对`x`是真还是假进行合理猜测（例如，如果 CPU 在过去执行过这个语句并且`x`是真的）。

这种优化称为*推测执行*。CPU 正在执行代码，即使可能以后代码可能被证明是无效的并需要撤销。

像熔断和幽灵这样的推测执行攻击利用这一过程，绕过保护系统调用接口的内存保护，这个接口位于应用程序和其内核之间。这是通过说服 CPU 进行推测执行一个通常会导致安全违规的指令（例如，尝试从内核内存中读取密码）来完成的。

如果 CPU 推测执行这种类型的指令，CPU 将在 CPU 加载密码到 CPU 缓存和 CPU 发现发生安全违规之间存在一个间隙。如果 CPU 在这个间隙期间被中断（使用所谓的瞬态指令），密码将留在 CPU 缓存中，即使指令实际上并没有完成执行。

为了从缓存中恢复密码，攻击者利用了对 CPU 的额外攻击，称为**侧信道攻击**，这些攻击专门设计用来读取 CPU 缓存的内容，而不执行直接的内存操作。

最终结果是，攻击者能够设置一系列复杂的条件，最终允许他们使用一个非特权应用程序（可能是你在寻找猫视频时点击的网站）恢复存储在内核中的敏感信息。

如果这看起来很复杂，那是因为它确实很复杂。这些类型的攻击非常复杂。这些例子的目标是提供关于系统调用并非没有问题的简要概述。根据你所执行的 CPU 和操作系统，你在处理敏感信息时可能需要特别小心。

# 在系统编程时使用 C++的好处

尽管本书的重点是系统编程而不是 C++，我们确实提供了很多 C++的例子，但与标准 C 相比，C++在系统编程中有几个好处。

请注意，本节假定读者对 C++有一些基本知识。有关 C++标准的更完整解释将在第二章中提供，*学习 C、C++17 和 POSIX 标准*。

# C++中的类型安全

标准 C 不是一种类型安全的语言。类型安全是指为防止一种类型与另一种类型混淆而采取的保护措施。一些语言，如 ADA，非常类型安全，提供了许多保护措施，以至于有时使用该语言可能会令人沮丧。

相反，像 C 这样的语言是如此不安全，以至于很难找到类型错误，而且经常导致不稳定性。

C++在这两种方法之间提供了一个折衷方案，鼓励默认情况下合理的类型安全性，同时在需要时提供规避这一点的机制。

例如，考虑以下代码：

```cpp
/* Example: C */
int *p = malloc(sizeof(int));

// Example: C++
auto p = new int;
```

在 C 中在堆上分配整数需要使用`malloc()`，它返回`void *`。这段代码存在几个问题，在 C++中得到了解决：

+   C 自动将`void *`类型转换为`int *`，这意味着即使用户声明的类型与返回的类型之间没有连接，隐式类型转换仍然发生了。用户可以轻松地分配`short`（这与`int`不同，这是我们将在第三章中讨论的一个主题，*C 和 C++的系统类型*）。类型转换仍然会被应用，这意味着编译器无法正确地检测到分配的空间对于用户尝试分配的类型来说不够大。

+   程序员必须声明分配的大小。与 C++不同，C 不了解正在分配的类型。因此，它不知道类型的大小，因此程序员必须明确声明这一点。这种方法的问题在于可能引入难以发现的分配错误。通常，提供给`sizeof()`的类型是不正确的（例如，程序员可能提供指针而不是类型本身，或者程序员可能稍后更改代码，但忘记更改提供给`sizeof()`的值）。如前所述，`malloc()`分配和返回的内容与用户尝试分配的类型之间没有关联，这提供了引入难以发现的逻辑错误的机会。

+   类型必须明确声明两次。`malloc()`返回`void *`，但 C 隐式转换为用户声明的任何指针类型，这意味着类型已经声明了两次（在这种情况下，`void *`和`int *`）。在 C++中，使用`auto`意味着类型只声明一次（在这种情况下，`int`表示类型是`int *`），并且`auto`将采用返回的任何类型。使用`auto`和去除隐式类型转换意味着分配中声明的任何类型都是`p`变量将采用的类型。如果在此分配后的代码期望`p`采用不同的类型，编译器将在 C++中在编译时知道这一点，而在 C 中，这样的错误可能直到运行时才会被捕获，当程序崩溃时（我们希望这段代码不控制飞机！）。

除了隐式类型转换的危险示例之外，C++还提供了**运行时类型信息**（**RTTI**）。这些信息有许多用途，但最重要的用例涉及`dynamic_cast<>`运算符，它执行运行时类型检查。

具体来说，可以在运行时检查从一种类型转换为另一种类型，以确保不会发生类型错误。这在执行以下操作时经常看到：

+   **多态类型转换**：在 C 中，多态是可能的，但必须手动完成，这是内核编程中经常见到的模式。然而，C 无法确定指针是否为基本类型分配，从而导致可能出现类型错误的可能性。相反，C++能够在运行时确定提供的指针是否被转换为正确的类型，包括在使用多态性时。

+   **异常支持**：在捕获异常时，C++ 使用 RTTI（本质上是 `dynamic_cast<>`）来确保被抛出的异常被适当的处理程序捕获。

# C++ 对象

尽管 C++ 支持使用内置构造进行面向对象编程，但面向对象编程也经常在 C 中以及 POSIX 中使用。看下面的例子：

```cpp
/* Example: C */

struct point 
{
    int x;
    int y;
};

void translate(point *p; int val)
{
    if (p == NULL) {
        return;
    }

    p->x += val;
    p->y += val;
}
```

在前面的例子中，我们有一个存储 `point{}` 的结构体，其中包含 `x` 和 `y` 位置。然后我们提供一个函数，能够使用给定的值（即对角线平移）来翻译这个 `point{}` 的 `x` 和 `y` 位置。

关于这个例子，有几点需要注意：

+   人们经常声称不喜欢面向对象的编程，但是在他们的代码中却会看到这种情况，实际上这是一种面向对象的设计。使用类并不是创建面向对象设计的唯一方式。C++ 的不同之处在于语言提供了额外的构造来清晰、安全地处理对象，而在 C 中，这个功能必须手动完成，这个过程容易出错。

+   `translate()` 函数只与 `point{}` 对象相关，因为它将 `point{}` 作为参数。因此，编译器没有上下文信息来理解如何操作 `point{}` 结构，没有给 `translate()` 提供指针作为参数。这意味着每个公共函数都必须以指针作为第一个参数来操作 `point{}` 结构，并验证指针是否有效。这不仅是一个笨拙的接口，而且速度慢。

在 C++ 中，前面的例子可以写成如下形式：

```cpp
// Example: C++

struct point 
{
    int x;
    int y;

    void translate(int val)
    {
        p->x += val;
        p->y += val;
    }
};
```

在这个例子中，仍然使用了一个 `struct`。C++ 中类和结构体的唯一区别是，结构体中的所有变量和函数默认都是公共的，而类中默认是私有的。

不同之处在于 `translate()` 函数是 `point{}` 的成员，这意味着它可以访问其结构的内容，因此不需要指针来执行翻译。因此，这段代码更安全、更确定，并且更容易理解，因为永远不会出现空指针解引用的情况。

最后，C++ 中的对象提供了构造和销毁例程，有助于防止对象未被正确初始化或正确销毁。看下面的例子：

```cpp
// Example: C++

struct myfile 
{
    int fd{0};

    ~myfile() {
        close(fd);
    }
};
```

在前面的例子中，我们创建了一个自定义文件对象，它保存了一个文件描述符，在使用 POSIX API 进行系统编程时经常看到和使用。

在 C 中，程序员需要记住在初始化时手动将文件描述符设置为 `0`，并在不再使用时关闭文件描述符。在 C++ 中，使用前面的例子，每次使用 `myfile` 时都会为您执行这两个操作。

这是一个使用**资源获取即初始化**（**RAII**）的例子，这个主题将在 第四章 中详细讨论，*C++，RAII 和 GSL 刷新*，因为这种模式在 C++ 中经常被使用。在系统编程时，我们将利用这种技术来避免许多常见的 POSIX 风格陷阱。

# C++ 中使用的模板

模板编程经常被低估和误解，它是 C++ 中一个没有得到足够赞扬的补充。大多数程序员只需要尝试创建一个通用链表就能理解为什么。

C++ 模板使您能够在不提前定义类型信息的情况下定义代码。

在 C 中创建链表的一种方式是使用指针和动态内存分配，就像在这个简单的例子中看到的那样：

```cpp
struct node 
{
    void *data;
    node next;
};

void add_data(node *n, void *val);
```

在前面的例子中，我们使用 `void *` 存储链表中的数据。使用方法如下：

```cpp
node head;
add_data(&head, malloc(sizeof(int)));
*(int*)head.data = 42;
```

这种方法存在一些问题：

+   这种类型的链表显然不是类型安全的。数据的使用和数据的分配完全无关，需要使用这个链表的程序员在没有错误的情况下管理所有这些。

+   节点和数据都需要动态内存分配。正如前面讨论的，内存分配很慢，因为它们需要系统调用。

+   总的来说，这段代码很难阅读，而且笨拙。

创建通用链表的另一种方法是使用宏。在互联网上有几种这些类型的链表（和其他数据结构）的实现，它们提供了一个通用的链表实现，无需动态分配数据。这些宏为用户提供了一种在编译时定义链表将管理的数据类型的方法。

除了可靠性之外，这些实现使用宏来实现模板编程的方式远不如优雅。换句话说，向 C 添加通用数据结构的解决方案是使用 C 的宏语言手动实现模板编程。程序员最好只使用 C++模板。

在 C++中，可以创建像链表这样的数据结构，而无需在声明之前声明链表管理的类型，如下所示：

```cpp
template<typename T>
class mylinked_list
{
    struct node 
    {
        T data;
        node *next;
    };

public:

    ...

private:

    node m_head;
};
```

在上面的例子中，我们不仅能够创建一个不需要宏或动态分配（以及使用`void *`指针带来的所有问题）的链表，而且还能够封装功能，提供更清晰的实现和用户 API。

关于模板编程经常提出的一个抱怨是它生成的代码量。模板的大部分代码膨胀通常源于编程错误。例如，程序员可能没有意识到整数和无符号整数不是相同的类型，导致在使用模板时出现代码膨胀（因为为每种类型创建了一个定义）。

即使不考虑这个问题，使用宏也会产生相同的代码膨胀。没有免费的午餐。如果你想避免使用动态分配和类型转换，同时仍然提供通用算法，你必须为你计划使用的每种类型创建你的算法的实例。如果可靠性是你的目标，允许编译器生成确保程序正确执行所需的代码，将会超过这些缺点。

# 与 C++相关的函数式编程

函数式编程是 C++的另一个补充，它以 lambda 函数的形式为用户提供编译器的帮助。目前，这在 C 中必须手动完成。

在 C 中，可以使用回调来实现函数式编程构造。例如，考虑以下代码：

```cpp
void
guard(void (*ptr)(int *val), int *val)
{
    lock();
    ptr(val);
    unlock();
}

void 
inc(int *val)
{
    *val++;
}

void 
dec(int *val)
{
    *val--;
}

void
foo() 
{
    int count = 0;
    guard(inc, &count);
    guard(dec, &count);
}
```

在上面的代码示例中，我们创建了一个`guard`函数，它锁定互斥锁，调用一个操作值的函数，然后在退出时解锁互斥锁。然后，我们创建了两个函数，一个增加给定的值，一个减少给定的值。最后，我们创建一个函数，实例化一个计数，然后使用`guard`函数递增计数和递减计数。

这段代码存在一些问题：

+   第一个问题是需要指针逻辑来确保我们可以操作所需操作的变量。我们还需要手动传递这个指针来跟踪它。这使得 API 笨拙，因为我们必须为这样一个简单的例子手动编写大量额外的代码。

+   辅助函数的函数签名是静态的。`guard`函数是一个简单的函数。它锁定互斥锁，调用一个函数，然后解锁它。问题在于，由于在编写代码时必须知道函数的参数，而不是在编译时，我们无法将此函数重用于其他任务。我们需要手动为计划支持的每种函数签名类型编写相同的函数。

可以使用以下 C++编写相同的示例：

```cpp
template<typename FUNC>
guard(FUNC f)
{
    lock();
    f();
    unlock();
}

void
foo() 
{
    int count = 0;
    guard(inc, [&]{ count++ });
    guard(inc, [&]{ count-- });
}
```

在前面的例子中，提供了相同的功能，但不需要指针。此外，守卫函数是通用的，可以用于多种情况。这是通过利用模板编程和函数式编程实现的。

Lambda 提供了回调，但是回调的参数被编码到 lambda 的函数签名中，这由模板函数的使用吸收。编译器能够生成一个用于接受参数（在本例中是对`count`变量的引用）并将其存储在代码本身中以供使用的守卫函数的版本，从而消除了用户手动执行此操作的需要。

在本书中，前面的例子将被大量使用，特别是在创建基准测试示例时，因为这种模式使您能够将功能包装在旨在计时回调执行的代码中。

# C++中的错误处理机制

错误处理是 C 的另一个问题。问题是，至少在添加了 set jump 异常之前，从函数获取错误代码的唯一方法是：

+   限制函数的输出，以便将函数的某些输出值视为错误

+   获取函数返回一个结构，然后手动解析该结构

例如，考虑以下代码：

```cpp
struct myoutput 
{
    int val;
    int error_code;
}

struct myoutput myfunc(int val)
{
    struct myoutput = {0};

    if (val == 42) {
        myoutput.error_code = -1;
    }

    myoutput.val = val;
    return myoutput;
}

void 
foo(void)
{
    struct myoutput = myfunc(42);

    if (myoutput.error_code == -1) {
        printf("yikes\n");
        return;
    }
}
```

前面的例子提供了一个简单的机制，用于从函数输出错误，而无需限制函数的输出（例如，假设`-1`始终是一个错误）。

在 C++中，可以使用以下 C++17 逻辑来实现：

```cpp
std::pair<int, int>
myfunc(int val)
{
    if (val == 42) {
        return {0, -1};
    }

    return {val, 0};
}

void 
foo(void)
{
    if (auto [val, error_code] = myfunc(42); error_code == -1) {
        printf("yikes\n");
        return;
    }
}
```

在前面的例子中，我们能够通过利用`std::pair{}`来消除对专用结构的需求，并且通过利用`initializer_list{}`和 C++17 结构化绑定来消除对`std::pair{}`的需求。

然而，还有一种更简单的处理错误的方法，而无需检查您执行的每个函数的输出，那就是使用异常。C 通过 set jump API 提供异常，而 C++提供 C++异常支持。这两者将在第十三章中详细讨论，即*使用异常处理错误*。

# API 和 C++容器在 C++中

除了 C++提供的语言原语外，它还带有**标准模板库**（STL）及相关 API，这些 API 极大地帮助系统编程。本书的很大一部分将专注于这些 API 以及它们如何支持系统编程。

应该注意，本书的重点是系统编程而不是 C++，因此我们不会详细介绍 C++容器，而是假设读者对它们是什么以及它们如何工作有一些基本知识。话虽如此，C++容器通过防止用户手动重写它们来支持系统编程。

我们教导学生如何编写自己的数据结构，不是为了当他们需要数据结构时知道如何编写一个，而是为了当他们需要一个时，知道使用哪种数据结构以及为什么。C++已经提供了大部分，如果不是全部，您在系统编程时可能需要的数据结构。

# 总结

在本章中，我们了解了什么是系统编程。我们涵盖了系统调用的一般解剖，不同类型的系统调用以及一些最近与系统调用相关的安全问题。

此外，我们讨论了使用 C++进行系统编程的优势，而不仅仅是严格使用标准 C。在下一章中，我们将详细介绍 C、C++和 POSIX 标准以及它们与系统编程的关系。

# 问题

1.  什么是系统编程？

1.  在*快速系统调用*之前，系统调用是如何执行的？

1.  支持*快速系统调用*所做的关键更改是什么？

1.  分配内存是否总是导致系统调用？

1.  Meltdown 和 Spectre 攻击利用了什么类型的执行？

1.  什么是类型安全？

1.  在 C++中模板编程至少提供一个好处是什么？

# 进一步阅读

+   [`www.packtpub.com/application-development/c17-example`](https://www.packtpub.com/application-development/c17-example)

+   [`www.packtpub.com/application-development/getting-started-c17-programming-video`](https://www.packtpub.com/application-development/getting-started-c17-programming-video)
