# 第十四章：评估

# 第一章

1.  通过系统调用来完成操作系统提供的任务的行为称为**系统编程**。

1.  通过调用操作系统的中断处理程序。

1.  特殊指令已添加到 CPU 以支持系统调用，无需调用中断处理程序，这在执行之前保存了更多的 CPU 状态。

1.  不。`malloc()`/`free()`的大多数实现会从操作系统请求大量内存，然后在程序执行期间划分该内存。只有在内存用尽并且`malloc()`/`free()`必须请求更多内存时才需要系统调用。

1.  推测执行。

1.  类型安全是编程语言帮助防止由于类型之间差异而导致错误的程度。强类型语言比弱类型语言更能防止这些类型的错误。

1.  C++模板为用户提供了在不提前定义类型信息的情况下定义代码的能力。

# 第二章

1.  是的。C 标准的大部分内容也是 POSIX 标准的一部分。 POSIX 通常会提供特定于 POSIX 操作系统的附加设施。 C 和 POSIX 函数的示例包括`read()`和`write()`。

1.  `_start()`是应用程序的入口点，通常由 C 运行时设施提供。`main()`是用户提供的函数，通常是用户代码中要执行的第一个函数，最终由 C 运行时设施在应用程序完全初始化后调用。

1.  执行全局构造函数和析构函数，并初始化 C++异常。

1.  之前。

1.  C++名称修饰将函数的整个签名嵌入到函数的符号中。这不仅需要为 C++中的函数重载提供支持，还确保链接器不会意外地动态链接两个具有相同名称但具有不同签名的函数（这在 C 中可能会发生）。

1.  C 符号不会被修饰。C++会。

1.  指针可以指向任何内存，包括`nullptr`。引用则不行。

# 第三章

1.  这取决于 CPU 架构。在某些 CPU 上，短`int`为 16 位宽，而`int`为 32 位宽。但并非所有 CPU 都是这样。

1.  这取决于 CPU 架构。在大多数 CPU 上，`int`是 32 位宽，但并非总是如此。

1.  不。

1.  `int32_t`始终为 32 位宽。在某些 CPU 上，`int`可以是 16、32 或 64 位宽。

1.  是的。这些称为**精确宽度**类型，将始终是所需的宽度。

1.  确保结构不会被编译器自动填充以进行优化。

1.  不。

# 第四章

1.  结构化绑定提供了通过手动提供单独变量来检索结构结果的能力，例如，`auto [first, second] = std::pair{1, 2}`

1.  现在可以在同一行上列出嵌套的命名空间

1.  您不再需要提供错误消息

1.  使您能够在`if`语句中定义变量

1.  资源获取即初始化

1.  在构造时获取和初始化资源，并在销毁时释放资源

1.  指出谁拥有指针（即负责删除指针的实体）

1.  `Expects()`定义了函数的输入期望，`Ensures()`定义了函数的输出

# 第五章

1.  `rax`。

1.  `rdi`。

1.  减法。

1.  段是一组部分。

1.  处理异常所需的信息。

1.  `Fork()`创建一个新进程，而`exec()`用新程序覆盖现有进程。这两者都需要启动新程序。

1.  第二。

1.  完成的进程的进程 ID。

# 第六章

1.  `std::cin`是类型感知的。

1.  能够处理用户定义的类型，提供更清晰、类型安全的 IO。

1.  格式说明符通常比`#include <iomanip>`更灵活。

1.  如果必须发生刷新，请使用`std::endl`。

1.  `std::cerr`在每次写入后会刷新，而`std::clog`不会。在处理错误时，请使用`std::cerr`确保在灾难性问题发生之前成功刷新所有调试信息。

1.  `std::internal`。

1.  通过同时使用`std::oct`和`std::uppercase`。

1.  通过利用`gsl::span`。

1.  通过利用`rdbuf()`成员函数。

# 第七章

1.  `new()`分配单个对象，而`new()`分配对象数组。

1.  不。

1.  全局内存对整个程序可见，而静态内存（在全局定义）仅对定义它的源文件可见。

1.  通过使用`alignas()`函数的别名，比如`using aligned_int alignas(0x1000) = int;`。

1.  不适用于 C++17 及以下版本

1.  只有在多个对象必须拥有内存时才应该使用`std::shared_ptr`（也就是说，内存需要能够以任何顺序和任何时间被多个对象释放）。

1.  是的（取决于操作系统和权限）。

1.  如果分配了 4 个字节并使用了 3 个，那么就会产生内部碎片（浪费内存）。如果以这样的方式分配内存，使得分配器不再具有连续的内存块可供分配（即使它有大量空闲内存），那么就会产生外部碎片。

# 第八章

1.  `is_open()`

1.  `std::ios_base::in` | `std::ios_base::out`

1.  读取`0`并设置标志

1.  缓冲区溢出错误

1.  是的

1.  测试

1.  `/home/user`

# 第九章

1.  这意味着相同分配器的两个实例始终相等，这反过来意味着两个分配器都可以分配和释放彼此的内存。

1.  如果相同分配器的两个实例可以分配和释放彼此的内存。

1.  是的。

1.  是的。

1.  当容器被复制时，它的分配器也被复制。

1.  它为容器提供了使用为不同类型创建分配器的副本的能力。

1.  对于`std::list`，`n ==1`；对于`std::vector`，`n`可以是任何数字。

# 第十章

1.  UDP 是无连接的。

1.  `SOCK_DGRAM`

1.  `SOCK_STREAM`

1.  IPV4。

1.  `Bind()`分配一个端口，而`connect()`连接到先前分配的端口。

1.  `sendto()`以地址作为参数，通常由 UDP 使用，而`send()`通常由 TCP 使用。

1.  它不会。

1.  类型安全。

# 第十一章

1.  1970 年 1 月 1 日星期四

1.  自 UNIX 纪元开始以来的秒数。

1.  `clock()`相对于程序的执行。

1.  非 POSIX 操作系统可能支持分数时间。

1.  `difftime()`的包装器。

1.  稳定时钟提供实际时间，而高分辨率计时器提供的数字只有在与`duration{}`一起使用时才提供值。

# 第十二章

1.  `pthread_self()`

1.  它们不是类型安全的。

1.  当两个线程竞争读/写相同的资源时。

1.  当线程等待永远不会被释放的同步原语（例如互斥锁）时。

1.  C++ future 提供了一种类型安全的机制，用于返回线程的结果。

1.  确保函数只执行一次，而不管调用它的线程数是多少。

1.  `std::shared_mutex`提供了支持多个读取器的能力。

1.  允许单个线程多次锁定同一互斥锁而不会陷入死锁。

# 第十三章

1.  C++异常不需要检查每个函数调用的返回结果。

1.  POSIX 风格的函数必须保留函数输出的一部分以传达错误。例如，如果函数必须返回文件句柄，在发生错误时返回`0`，这意味着文件句柄不能具有值`0`。

1.  跳转设置不会解开堆栈，这意味着析构函数被跳过。

1.  `catch(...)`

1.  必须为每个函数存储如何解开堆栈的指令。这是为了提高性能而进行的权衡。

1.  它们很慢。
