# 第四章：数据结构

在上一章中，我们讨论了如何分析时间和内存复杂性以及如何衡量性能。在本章中，我们将讨论如何从标准库中选择和使用数据结构。要理解为什么某些数据结构在今天的计算机上运行得非常好，我们首先需要了解一些关于计算机内存的基础知识。在本章中，您将了解以下内容：

+   计算机内存的属性

+   标准库容器：序列容器和关联容器

+   标准库容器适配器

+   并行数组

在我们开始遍历标准库提供的容器和一些其他有用的数据结构之前，我们将简要讨论一些计算机内存的属性。

# 计算机内存的属性

C++将内存视为一系列单元。每个单元的大小为 1 字节，并且每个单元都有一个地址。通过其地址访问内存中的一个字节是一个常量时间操作，*O(1)*，换句话说，它与内存单元的总数无关。在 32 位机器上，您可以理论上寻址 2³²字节，即大约 4GB，这限制了进程一次允许使用的内存量。在 64 位机器上，您可以理论上寻址 2⁶⁴字节，这是如此之大，以至于几乎没有任何地址用完的风险。

以下图显示了内存中排列的一系列内存单元。每个单元包含 8 位。十六进制数字是内存单元的地址：

![](img/B15619_04_01.png)

图 4.1：一系列内存单元

由于通过地址访问一个字节是一个*O(1)*操作，从程序员的角度来看，很容易相信每个内存单元都可以快速访问。这种对内存的处理方式在许多情况下都是简单且有用的，但是在选择数据结构以实现高效使用时，您需要考虑现代计算机中存在的内存层次结构。随着从主存储器读取和写入所需的时间与今天处理器的速度相比变得更加昂贵，内存层次结构的重要性已经增加。以下图显示了具有一个 CPU 和四个核心的机器的架构：

![](img/B15619_04_02.png)

图 4.2：具有四个核心的处理器的示例；标有 L1i、L1d、L2 和 L3 的框是内存缓存

我目前正在使用 2018 年的 MacBook Pro 进行撰写本章，它配备了 Intel Quad-Core i7 CPU。在这个处理器上，每个核心都有自己的 L1 和 L2 缓存，而 L3 缓存是所有四个核心共享的。从终端运行以下命令：

```cpp
sysctl -a hw 
```

给我提供了以下信息，除其他外：

```cpp
hw.memsize: 17179869184
hw.cachelinesize: 64
hw.l1icachesize: 32768
hw.l1dcachesize: 32768
hw.l2cachesize: 262144
hw.l3cachesize: 8388608 
```

报告的`hw.memsize`是主存储器的总量，本例中为 16GB。

`hw.cachelinesize`报告的是 64 字节，这是缓存行的大小，也称为块。当访问内存中的一个字节时，机器不仅会获取所请求的字节；相反，机器总是获取一个缓存行，在这种情况下是 64 字节。 CPU 和主存储器之间的各种高速缓存跟踪 64 字节的块，而不是单个字节。

`hw.l1icachesize`是 L1 指令缓存的大小。这是一个 32KB 的缓存，专门用于存储 CPU 最近使用的指令。 `hw.l1dcachesize`也是 32KB，专门用于数据，而不是指令。

最后，我们可以读取 L2 缓存和 L3 缓存的大小，分别为 256KB 和 8MB。一个重要的观察是，与可用的主存储器量相比，缓存非常小。

没有提供关于从缓存层中的每一层访问数据所需的实际周期数的详细事实，一个非常粗略的指导原则是，相邻层之间的延迟存在数量级的差异（例如，L1 和 L2）。下表显示了 Peter Norvig 在一篇名为《在十年内自学编程》（2001）的文章中提出的延迟数字的摘录（[`norvig.com/21-days.html`](http://norvig.com/21-days.html)）。完整的表通常被称为《每个程序员都应该知道的延迟数字》，并且由 Jeff Dean 创作：

| L1 缓存引用 | 0.5 ns |
| --- | --- |
| L2 缓存引用 | 7 ns |
| 主存储器引用 | 100 ns |

以这样的方式结构化数据，使得缓存可以被充分利用，对性能有着显著的影响。访问最近使用过的数据，因此可能已经存在于缓存中，将使你的程序更快。这被称为**时间局部性**。

此外，访问位于你正在使用的其他数据附近的数据，将增加你需要的数据已经在先前从主存储器中获取的缓存行中的可能性。这被称为**空间局部性**。

在内部循环中不断清除缓存行可能导致非常糟糕的性能。这有时被称为**缓存抖动**。让我们看一个例子：

```cpp
constexpr auto kL1CacheCapacity = 32768; // The L1 Data cache size 
constexpr auto kSize = kL1CacheCapacity / sizeof(int); 
using MatrixType = std::array<std::array<int, kSize>, kSize>; 
auto cache_thrashing(MatrixType& matrix) { 
  auto counter = 0;
  for (auto i = 0; i < kSize; ++i) {
    for (auto j = 0; j < kSize; ++j) {
      matrix[i][j] = counter++;
    }
  }
} 
```

这个版本在我的电脑上运行大约需要 40 毫秒。然而，只需将内部循环中的一行更改为以下内容，完成函数所需的时间就会从 40 毫秒增加到 800 毫秒以上：

```cpp
matrix[j][i] = counter++; 
```

在第一个例子中，使用`matrix[i][j]`时，大多数情况下我们将访问已经在 L1 缓存中的内存，而在使用`matrix[j][i]`的修改版本中，每次访问都会生成一个 L1 缓存未命中。一些图像可能会帮助你理解发生了什么。与其绘制完整的 32768 x 32768 矩阵，不如用这里显示的一个小 3 x 3 矩阵作为例子：

![](img/B15619_04_03.png)

图 4.3：一个 3x3 矩阵

即使这可能是我们对矩阵在内存中的想象，实际上并不存在二维内存。相反，当这个矩阵在一维内存空间中排列时，它看起来是这样的：

![](img/B15619_04_04.png)

图 4.4：一个二维矩阵在一维内存空间中

也就是说，它是一个按行排列的连续元素数组。在我们算法的快速版本中，数字按照它们在内存中连续排列的顺序顺序访问，就像这样：

![](img/B15619_04_05.png)

图 4.5：快速顺序步幅-1 访问

而在算法的慢速版本中，元素以完全不同的模式访问。使用慢速版本访问前四个元素现在看起来是这样的：

![](img/B15619_04_06.png)

图 4.6：使用较大步幅的慢速访问

以这种方式访问数据由于空间局部性差而明显较慢。现代处理器通常也配备有**预取器**，它可以自动识别内存访问模式，并尝试从内存中预取可能在不久的将来被访问的缓存。预取器对于较小的步幅表现最佳。你可以在 Randal E. Bryant 和 David R. O'Hallaron 的优秀著作《计算机系统，程序员的视角》中阅读更多相关内容。

总结本节，即使内存访问是恒定时间操作，缓存对实际访问内存所需时间的影响可能会很大。在使用或实现新数据结构时，这是一件需要时刻牢记的事情。

接下来，我将介绍 C++标准库中的一组数据结构，称为容器。

# 标准库容器

C++标准库提供了一组非常有用的容器类型。容器是包含一系列元素的数据结构。容器管理它所持有的元素的内存。这意味着我们不必显式地创建和删除放入容器中的对象。我们可以将在堆栈上创建的对象传递给容器，容器将会复制并存储它们在自由存储器上。

迭代器用于访问容器中的元素，因此对于理解标准库中的算法和数据结构来说，它们是一个基本概念。迭代器概念在*第五章*，*算法*中有介绍。对于本章来说，知道迭代器可以被视为指向元素的指针，并且迭代器根据它们所属的容器定义了不同的操作符就足够了。例如，类似数组的数据结构提供对其元素的随机访问迭代器。这些迭代器支持使用`+`和`-`的算术表达式，而例如链表的迭代器只支持`++`和`--`操作符。

容器分为三类：序列容器、关联容器和容器适配器。本节将简要介绍这三类容器中的容器，并讨论在性能成为问题时需要考虑的最重要的事情。

## 序列容器

序列容器会按照我们添加元素到容器时指定的顺序来保留元素。标准库中的序列容器包括`std::array`、`std::vector`、`std::deque`、`std::list`和`std::forward_list`。我也会在本节中介绍`std::basic_string`，尽管它不是正式的通用序列容器，因为它只处理字符类型的元素。

在选择序列容器之前，我们应该知道以下问题的答案：

1.  元素数量是多少（数量级）？

1.  使用模式是什么？您将多频繁地添加数据？读取/遍历数据？删除数据？重新排列数据？

1.  您最常在序列中添加数据的位置是哪里？在末尾、开头还是中间？

1.  您需要对元素进行排序吗？或者您是否甚至关心顺序？

根据这些问题的答案，我们可以确定哪种序列容器更适合我们的需求。但是，为了做到这一点，我们需要对每种类型的序列容器的接口和性能特征有基本的了解。

接下来的部分将简要介绍不同的序列容器，首先介绍最常用的容器之一。

### 向量和数组

`std::vector`可能是最常用的容器类型，原因很充分。向量是一个在需要时动态增长的数组。添加到向量中的元素保证在内存中是连续排列的，这意味着您可以通过索引以常数时间访问数组中的任何元素。这也意味着在按照它们排列的顺序遍历元素时，由于前面提到的空间局部性，它提供了出色的性能。

向量有一个**大小**和一个**容量**。大小是当前容器中保存的元素数量，容量是向量需要分配更多空间之前可以容纳的元素数量：

![](img/B15619_04_07.png)

图 4.7：std::vector 的大小和容量

使用`push_back()`函数向向量末尾添加元素是快速的，只要大小小于容量。当添加一个元素并且没有更多空间时，向量将会分配一个新的内部缓冲区，然后将所有元素移动到新空间。容量会以一种很少发生调整缓冲区大小的方式增长，因此使`push_back()`成为摊销的常数时间操作，正如我们在*第三章*，*分析和测量性能*中讨论的那样。

类型为`std::vector<Person>`的向量模板实例将按值存储`Person`对象。当向量需要重新排列`Person`对象（例如，作为插入的结果），值将被复制构造或移动。如果对象具有`nothrow`移动构造函数，则对象将被移动。否则，为了保证强异常安全性，对象将被复制构造：

```cpp
Person(Person&& other) {         // Will be copied 
   // ...
} 
Person(Person&& other) noexcept { // Will be moved 
   // ...
} 
```

在内部，`std::vector`使用`std::move_if_noexcept`来确定对象是应该被复制还是移动。`<type_traits>`头文件可以帮助您在编译时验证您的类在移动时是否保证不会抛出异常：

```cpp
static_assert(std::is_nothrow_move_constructible<Person>::value); 
```

如果您要将新创建的对象添加到向量中，您可以利用`emplace_back()`函数，它将为您创建对象，而不是使用`push_back()`函数创建对象，然后将其复制/移动到向量中：

```cpp
persons.emplace_back("John", 65); 
```

向量的容量可以通过以下方式改变：

+   通过在`capacity == size`时向向量添加元素

+   通过调用`reserve()`

+   通过调用`shrink_to_fit()`

除此之外，向量不会改变容量，因此也不会分配或释放动态内存。例如，成员函数`clear()`会清空向量，但不会改变其容量。这些内存保证使得向量即使在实时环境中也可以使用。

自 C++20 以来，还有两个免费函数可以从`std::vector`中删除元素。在 C++20 之前，我们必须使用*擦除-移除惯用法*，我们将在*第五章* *算法*中讨论。然而，现在从`std::vector`中删除元素的推荐方法是使用`std::erase()`和`std::erase_if()`。以下是如何使用这些函数的简短示例：

```cpp
auto v = std::vector{-1, 5, 2, -3, 4, -5, 5};
std::erase(v, 5);                               // v: [-1,2,-3,4,-5]
std::erase_if(v, [](auto x) { return x < 0; }); // v: [2, 4] 
```

作为动态大小向量的替代，标准库还提供了一个名为`std::array`的固定大小版本，它通过使用堆栈而不是自由存储来管理其元素。数组的大小是在编译时指定的模板参数，这意味着大小和类型元素成为具体类型的一部分：

```cpp
auto a = std::array<int, 16>{};
auto b = std::array<int, 1024>{}; 
```

在这个例子中，`a`和`b`不是相同的类型，这意味着在使用类型作为函数参数时，你必须指定大小：

```cpp
auto f(const std::array<int, 1024>& input) { 
  // ... 
} 

f(a);  // Does not compile, f requires an int array of size 1024 
```

这一开始可能看起来有点麻烦，但事实上，这是与内置数组类型（C 数组）相比的一个很大的优势，因为当传递给函数时，它会自动将指针转换为数组的第一个元素，从而丢失大小信息：

```cpp
// input looks like an array, but is in fact a pointer 
auto f(const int input[]) {  
  // ... 
} 

int a[16]; 
int b[1024]; 
f(a); // Compiles, but unsafe 
```

数组失去其大小信息通常被称为**数组衰变**。在本章后面，您将看到如何通过在将连续数据传递给函数时使用`std::span`来避免数组衰变。

### 双端队列

有时，您会发现自己处于需要频繁向序列的开头和结尾添加元素的情况。如果您使用的是`std::vector`并且需要加快在前面插入的速度，您可以使用`std::deque`，它是**双端队列**的缩写。`std::deque`通常实现为一组固定大小的数组，这使得可以在常数时间内通过它们的索引访问元素。然而，正如您在下图中所看到的，所有元素并不是存储在内存中的连续位置，这与`std::vector`和`std::array`的情况不同。

![](img/B15619_04_08.png)

图 4.8：std::deque 的可能布局

### 列表和前向列表

`std::list`是一个**双向链表**，意味着每个元素都有一个指向下一个元素和一个指向前一个元素的链接。这使得可以向前和向后遍历列表。还有一个名为`std::forward_list`的**单向链表**。之所以不总是选择双向链表而不是`std::forward_list`，是因为双向链表中的后向指针占用了过多的内存。因此，如果不需要向后遍历列表，就使用`std::forward_list`。单向链表的另一个有趣特性是它针对非常短的列表进行了优化。当列表为空时，它只占用一个字，这使得它成为稀疏数据的一种可行数据结构。

请注意，即使元素在一个序列中是有序的，它们在内存中*并不*像向量和数组那样连续布局，这意味着迭代链表很可能会产生比向量更多的缓存未命中。

总之，`std::list`是一个具有指向下一个和上一个元素的双向链表：

![](img/B15619_04_09.png)

图 4.9：std::list 是一个双向链表

`std::forward_list`是一个具有指向下一个元素的单向链表：

![](img/B15619_04_10.png)

图 4.10：std::forward_list 是一个单向链表

`std::forward_list`更加内存高效，因为它只有一个指向下一个元素的指针。

列表也是唯一支持**splicing**的容器，这是一种在不复制或移动元素的情况下在列表之间传输元素的方法。这意味着，例如，可以在常数时间*O(1)*内将两个列表连接成一个。其他容器对于这样的操作至少需要线性时间。

### 基本字符串

我们将在本节中介绍的最后一个模板类是`std::basic_string`。`std::string`是`std::basic_string<char>`的一个`typedef`。从历史上看，`std::basic_string`并不保证在内存中连续布局。这在 C++17 中发生了改变，这使得可以将字符串传递给需要字符数组的 API。例如，以下代码将整个文件读入字符串中：

```cpp
auto in = std::ifstream{"file.txt", std::ios::binary | std::ios::ate}; 
if (in.is_open()) { 
  auto size = in.tellg(); 
  auto content = std::string(size, '\0'); 
  in.seekg(0); 
  in.read(&content[0], size); 
  // "content" now contains the entire file 
} 
```

通过使用`std::ios::ate`打开文件，位置指示器被设置到流的末尾，这样我们就可以使用`tellg()`来检索文件的大小。之后，我们将输入位置设置为流的开头并开始读取。

大多数`std::basic_string`的实现都利用了称为**小对象优化**的东西，这意味着如果字符串的大小很小，它们不会分配任何动态内存。我们将在本书的后面讨论小对象优化。现在，让我们继续讨论关联容器。

## 关联容器

关联容器根据元素本身的特性放置它们的元素。例如，在关联容器中不可能像使用`std::vector::push_back()`或`std::list::push_front()`那样在后面或前面添加元素。相反，元素是以一种使得可以在不需要扫描整个容器的情况下找到元素的方式添加的。因此，关联容器对我们想要存储在容器中的对象有一些要求。我们将在后面讨论这些要求。

关联容器有两个主要类别：

+   **有序关联容器**：这些容器基于树；容器使用树来存储它们的元素。它们要求元素按照小于运算符(`<`)进行排序。基于树的容器中添加、删除和查找元素的函数都是 O(log n)。这些容器被命名为`std::set`、`std::map`、`std::multiset`和`std::multimap`。

+   **无序关联容器**：这些容器基于哈希表；容器使用哈希表来存储它们的元素。它们要求元素使用相等运算符（`==`）进行比较，并且有一种方法可以根据元素计算哈希值。稍后会详细介绍。基于哈希表的容器中添加、删除和查找元素的函数都是*O(1)*。这些容器的名称是`std::unordered_set`、`std::unordered_map`、`std::unordered_multiset`和`std::unordered_multimap`。

自 C++20 以来，所有关联容器都配备了一个名为`contains()`的函数，当您想知道容器是否包含某些特定元素时应该使用它。在较早版本的 C++中，需要使用`count()`或`find()`来确定容器是否包含元素。

始终使用专门的函数，如`contains()`和`empty()`，而不是使用`count() > 0`或`size() == 0`。专门的函数保证是最有效的。

### 有序集合和映射

有序关联容器保证插入、删除和搜索可以在对数时间*O(log n)*内完成。如何实现这一点取决于标准库的实现。然而，我们所知道的实现确实使用了某种自平衡二叉搜索树。树保持大致平衡是控制树的高度以及访问元素的最坏情况运行时间的必要条件。树不需要预先分配内存，因此通常情况下，每次插入元素时树都会在自由存储器上分配内存，并在擦除元素时释放内存。请看下面的图表，显示平衡树的高度为*O(log n)*：

![](img/B15619_04_11.png)

图 4.11：如果树是平衡的，则树的高度为 O(log n)

### 无序集合和映射

无序集合和映射的版本提供了基于哈希的替代方案，而不是基于树的版本。这种数据结构通常被称为哈希表。理论上，哈希表提供了摊销的常数时间插入、添加和删除操作，可以与操作在*O(log n)*的基于树的版本进行比较。然而，在实践中，差异可能并不那么明显，特别是如果您的容器中没有存储非常大数量的元素。

让我们看看哈希表如何提供*O(1)*的操作。哈希表将其元素保存在一些桶的数组中。当向哈希表添加元素时，使用哈希函数计算元素的整数。这个整数通常被称为元素的**哈希**。然后，哈希值被限制在数组的大小范围内（例如通过使用取模运算），以便新的限制值可以用作数组中的索引。一旦计算出索引，哈希表就可以将元素存储在数组的该索引处。查找元素的操作方式类似，首先计算要查找的元素的哈希值，然后访问数组。

除了计算哈希值，这种技术似乎很简单。然而，这只是故事的一半。如果两个不同的元素生成相同的索引，要么是因为它们产生了相同的哈希值，要么是因为两个不同的哈希值被限制到相同的索引，会发生什么？当两个不相等的元素最终位于同一个索引时，我们称之为**哈希冲突**。这不仅仅是一个边缘情况：即使我们使用一个很好的哈希函数，尤其是当数组的大小与我们添加的元素数量相比较小时，这种情况会经常发生。有各种方法来处理哈希冲突。在这里，我们将专注于标准库中使用的一种方法，称为**分离链接**。

分离链接解决了两个不相等的元素最终在相同索引处的问题。数组不仅仅是直接存储元素，而是一个序列的**桶**。每个桶可以包含多个元素，也就是所有散列到相同索引的元素。因此，每个桶也是某种类型的容器。用于桶的确切数据结构未定义，对于不同的实现可能会有所不同。但是，我们可以将其视为链表，并假设在特定桶中查找元素是缓慢的，因为它需要线性扫描桶中的元素。

下图显示了一个具有八个桶的哈希表。元素分布在三个单独的桶中。索引为**2**的桶包含四个元素，索引为**4**的桶包含两个元素，索引为**5**的桶只包含一个元素。其他桶为空：

![](img/B15619_04_12.png)

图 4.12：每个桶包含 0 个或多个元素

#### 哈希和相等

哈希值可以在与容器大小相关的常量时间内计算，它决定了元素将被放置在哪个桶中。由于可能会有多个对象生成相同的哈希值，因此最终进入同一个桶，每个键还需要提供一个相等函数，用于将要查找的键与桶中的所有键进行比较。

如果两个键相等，则它们需要生成相同的哈希值。但是，两个对象返回相同的哈希值而彼此不相等是完全合法的。

一个好的哈希函数计算快速，并且还会在桶之间均匀分布键，以最小化每个桶中的元素数量。

以下是一个*非常糟糕*但有效的哈希函数的示例：

```cpp
auto my_hash = [](const Person& person) {
  return 47; // Bad, don't do this!
}; 
```

它是有效的，因为它将为两个相等的对象返回相同的哈希值。哈希函数也非常快。然而，由于所有元素将产生相同的哈希值，所有键最终将进入同一个桶，这意味着查找一个元素将是*O(n)*而不是我们所追求的*O(1)*。

另一方面，一个好的哈希函数可以确保元素在桶之间均匀分布，以最小化哈希冲突。C++标准实际上对此有一个注释，指出哈希函数很少会为两个不同的对象产生相同的哈希值。幸运的是，标准库已经为基本类型提供了良好的哈希函数。在许多情况下，我们可以在为用户定义的类型编写自己的哈希函数时重用这些函数。

假设我们想要将`Person`类作为`unorordered_set`中的键。`Person`类有两个数据成员：`age`是一个`int`，`name`是一个`std::string`。我们首先编写相等谓词：

```cpp
auto person_eq = [](const Person& lhs, const Person& rhs) {
  return lhs.name() == rhs.name() && lhs.age() == rhs.age();
}; 
```

为了使两个`Person`对象相等，它们需要有相同的名称和相同的年龄。现在我们可以通过组合包含在相等谓词中的所有数据成员的哈希值来定义哈希谓词。不幸的是，C++标准中还没有函数来组合哈希值，但 Boost 中有一个很好的函数可用，我们将在这里使用：

```cpp
#include <boost/functional/hash.hpp>
auto person_hash = [](const Person& person) { 
  auto seed = size_t{0};
  boost::hash_combine(seed, person.name()); 
  boost::hash_combine(seed, person.age()); 
  return seed;
}; 
```

如果由于某种原因，您无法使用 Boost，`boost::hash_combine()`实际上只是一个可以从[`www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine`](https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine)的文档中复制的一行代码。

有了相等和哈希函数的定义，我们最终可以创建我们的`unordered_set`：

```cpp
using Set = std::unordered_set<Person, decltype(person_hash),                                decltype(person_eq)>; 
auto persons = Set{100, person_hash, person_eq}; 
```

一个很好的经验法则是在生成哈希值时始终使用等函数中使用的所有数据成员。这样，我们遵守了等号和哈希之间的约定，同时这使我们能够提供一个有效的哈希值。例如，仅在计算哈希值时使用名称是正确但低效的，因为这意味着所有具有相同名称的`Person`对象最终都会进入同一个桶中。更糟糕的是，在哈希函数中包括未在等函数中使用的数据成员。这很可能会导致灾难，使您无法在`unordered_set`中找到相等的对象。

#### 哈希策略

除了创建均匀分布在桶中的键的哈希值之外，我们还可以通过拥有许多桶来减少碰撞的数量。每个桶的平均元素数称为**负载因子**。在前面的示例中，我们创建了一个具有 100 个桶的`unordered_set`。如果我们向集合中添加 50 个`Person`对象，`load_factor()`将返回 0.5。`max_load_factor`是负载因子的上限，当达到该值时，集合将需要增加桶的数量，并且因此还需要重新散列当前集合中的所有元素。还可以使用`rehash()`和`reserve()`成员函数手动触发重新散列。

让我们继续看看第三类：容器适配器。

## 容器适配器

标准库中有三种容器适配器：`std::stack`、`std::queue`和`std::priority_queue`。容器适配器与序列容器和关联容器非常不同，因为它们代表可以由底层序列容器实现的**抽象数据类型**。例如，堆栈是一个**后进先出**（**LIFO**）数据结构，支持在堆栈顶部进行推送和弹出，可以使用`vector`、`list`、`deque`或任何其他支持`back()`、`push_back()`和`pop_back()`的自定义序列容器来实现。队列也是如此，它是一个**先进先出**（**FIFO**）数据结构，以及`priority_queue`。

在本节中，我们将重点关注`std::priority_queue`，这是一个非常有用的数据结构，很容易被忘记。

### 优先队列

**优先队列**提供了具有最高优先级的元素的常数时间查找。使用元素的小于运算符定义优先级。插入和删除都在对数时间内运行。优先队列是一个部分有序的数据结构，可能不明显何时使用它而不是完全排序的数据结构，例如树或排序向量。但是，在某些情况下，优先队列可以为您提供所需的功能，并且成本比完全排序的容器低。

标准库已经提供了一个部分排序算法，所以我们不需要自己写。但让我们看看如何使用优先队列来实现一个部分排序算法。假设我们正在编写一个程序，用于根据查询搜索文档。匹配的文档（搜索命中）应按排名排序，我们只对找到的前 10 个排名最高的搜索命中感兴趣。

文档由以下类表示：

```cpp
class Document { 
public:  
  Document(std::string title) : title_{std::move(title)} {}
private:  
  std::string title_; 
  // ... 
}; 
```

在搜索时，算法选择与查询匹配的文档并计算搜索命中的排名。每个匹配的文档由`Hit`表示：

```cpp
struct Hit { 
  float rank_{}; 
  std::shared_ptr<Document> document_; 
}; 
```

最后，我们需要对命中进行排序并返回前*m*个文档。对于排序命中有哪些选项？如果命中包含在提供随机访问迭代器的容器中，我们可以使用`std::sort()`并且只返回前*m*个元素。或者，如果命中的总数远远大于我们要返回的*m*个文档，我们可以使用`std::partial_sort()`，这比`std::sort()`更有效。

但是如果我们没有随机访问迭代器怎么办？也许匹配算法只提供了对命中的前向迭代器。在这种情况下，我们可以使用优先队列，仍然得到一个高效的解决方案。我们的排序接口将如下所示：

```cpp
template<typename It>
auto sort_hits(It begin, It end, size_t m) -> std::vector<Hit> { 
```

我们可以使用定义了递增运算符的任何迭代器调用此函数。接下来，我们创建一个由`std::vector`支持的`std::priority_queue`，使用自定义比较函数来保持队列顶部的*最低*排名命中：

```cpp
 auto cmp = [](const Hit& a, const Hit& b) { 
    return a.rank_ > b.rank_; // Note, we are using greater than 
  };
  auto queue = std::priority_queue<Hit, std::vector<Hit>,                                    decltype(cmp)>{cmp}; 
```

我们将在优先队列中最多插入 m 个元素。优先队列将包含到目前为止看到的排名最高的命中。在当前在优先队列中的元素中，排名最低的命中将成为最顶部的元素：

```cpp
 for (auto it = begin; it != end; ++it) { 
    if (queue.size() < m) { 
      queue.push(*it); 
    } 
    else if (it->rank_ > queue.top().rank_) { 
      queue.pop(); 
      queue.push(*it); 
    } 
  } 
```

现在，我们已经在优先队列中收集了排名最高的命中，所以唯一剩下的事情就是将它们以相反的顺序放入向量中，并返回排序后的命中：

```cpp
 auto result = std::vector<Hit>{}; 
  while (!queue.empty()) { 
    result.push_back(queue.top()); 
    queue.pop(); 
  } 
  std::reverse(result.begin(), result.end()); 
  return result; 
} // end of sort_hits() 
```

这个算法的复杂度是多少？如果我们用 n 表示命中次数，用 m 表示返回的命中次数，我们可以看到内存消耗是 O(m)，而时间复杂度是 O(n * log m)，因为我们正在迭代 n 个元素。此外，在每次迭代中，我们可能需要进行推送和/或弹出，这两者都在 O(log m)时间内运行。

现在我们将离开标准库容器，专注于一些与标准容器密切相关的新的有用的类模板。

# 使用视图

在本节中，我们将讨论 C++标准库中一些相对较新的类模板：C++17 中的`std::string_view`和 C++20 中引入的`std::span`。

这些类模板不是容器，而是一系列连续元素的轻量级视图（或切片）。视图是小对象，可以按值复制。它们不分配内存，也不提供有关它们指向的内存的生存期的任何保证。换句话说，它们是非拥有引用类型，与本章前面描述的容器有很大不同。与此同时，它们与`std::string`、`std::array`和`std::vector`密切相关，我们将很快看到。我将从描述`std::string_view`开始。

### 使用 string_view 避免复制

`std::string_view`包含一个指向不可变字符串缓冲区开头的指针和一个大小。由于字符串是一系列连续的字符，指针和大小完全定义了一个有效的子字符串范围。通常，`std::string_view`指向由`std::string`拥有的一些内存。但它也可以指向具有静态存储期的字符串字面量或类似内存映射文件的东西。以下图表显示了`std::string_view`指向由`std::string`拥有的内存：

![](img/B15619_04_13.png)

图 4.13：一个指向由 std::string 实例拥有的内存的 std::string_view 对象。

由`std::string_view`定义的字符序列不需要以空字符结尾，但包含空字符的字符序列是完全有效的。另一方面，`std::string`需要能够从`c_str()`返回以空字符结尾的字符串，这意味着它总是在序列的末尾存储额外的空字符。

`string_view`不需要空终止符的事实意味着它可以比 C 风格字符串或`std::string`更有效地处理子字符串，因为它不必创建新的字符串来添加空终止符。使用`std::string_view`的`substr()`的复杂度是常数，这应该与`std::string`的`substr()`版本进行比较，后者的复杂度是线性时间。

将字符串传递给函数时也会有性能提升。考虑以下代码：

```cpp
auto some_func(const std::string& s) {
  // process s ...
}
some_func("A string literal"); // Creates a std::string 
```

当将字符串字面量传递给`some_func()`时，编译器需要构造一个新的`std::string`对象以匹配参数的类型。然而，如果我们让`some_func()`接受一个`std::string_view`，就不再需要构造一个`std::string`了：

```cpp
auto some_func(std::string_view s) { // Pass by value
  // process s ... 
}
some_func("A string literal"); 
```

`std::string_view`实例可以有效地从`std::string`和字符串字面量构造，并且因此是函数参数的合适类型。

### 使用 std::span 消除数组衰减

在本章前面讨论`std::vector`和`std::array`时，我提到了数组衰减（失去数组的大小信息）在将内置数组传递给函数时会发生：

```cpp
// buffer looks like an array, but is in fact a pointer 
auto f1(float buffer[]) {
  const auto n = std::size(buffer);   // Does not compile!
  for (auto i = 0u; i < n; ++i) {     // Size is lost!
    // ...
  }
} 
```

我们可以通过添加大小参数来解决这个问题：

```cpp
auto f2(float buffer[], size_t n) {
  for (auto i = 0u; i < n; ++i) {
    // ...
  }
} 
```

尽管这在技术上是有效的，但向该函数传递正确的数据既容易出错又繁琐，如果`f2()`将缓冲区传递给其他函数，它需要记住传递正确大小的变量`n`。这是`f2()`的调用点可能会看起来像的：

```cpp
float a[256]; 
f2(a, 256);     
f2(a, sizeof(a)/sizeof(a[0])); // A common tedious pattern
f2(a, std::size(a)); 
```

数组衰减是许多与边界相关的错误的根源，在使用内置数组的情况下（出于某种原因），`std::span`提供了一种更安全的方法将数组传递给函数。由于 span 在一个对象中同时保存了指向内存的指针和大小，因此我们可以将其用作将元素序列传递给函数时的单一类型：

```cpp
auto f3(std::span<float> buffer) {  // Pass by value
  for (auto&& b : buffer) {         // Range-based for-loop
    // ...
  }
}
float a[256]; 
f3(a);          // OK! Array is passed as a span with size
auto v = std::vector{1.f, 2.f, 3.f, 4.f};
f3(v);          // OK! 
```

与内置数组相比，span 更方便使用，因为它更像一个具有迭代器支持的常规容器。

在数据成员（指针和大小）和成员函数方面，`std::string_view`和`std::span`之间有许多相似之处。但也有一些显着的区别：`std::span`指向的内存是可变的，而`std::string_view`总是指向常量内存。`std::string_view`还包含特定于字符串的函数，如`hash()`和`substr()`，这自然不是`std::span`的一部分。最后，在`std::span`中没有`compare()`函数，因此不可能直接在`std::span`对象上使用比较运算符。

现在是时候强调一些与使用标准库数据结构相关的一般性能要点了。

# 一些性能考虑

我们现在已经涵盖了三个主要的容器类别：序列容器、关联容器和容器适配器。本节将为您提供一些在使用容器时考虑的一般性能建议。

## 在复杂性保证和开销之间取得平衡。

在选择容器时，了解数据结构的时间和内存复杂性是重要的。但同样重要的是要记住，每个容器都带有开销成本，这对于较小的数据集的性能影响更大。复杂性保证只有在足够大的数据集时才变得有趣。在您的用例中，您需要决定足够大的含义。在这里，您需要再次在执行程序时测量以获得见解。

此外，计算机配备了内存缓存的事实使得对缓存友好的数据结构更有可能表现更好。这通常有利于`std::vector`，它的内存开销低，并且将其元素连续存储在内存中，使得访问和遍历更快。

下图显示了两种算法的实际运行时间。一个以线性时间*O(n)*运行，另一个以对数时间*O(log n)*运行，但开销更大。当输入大小低于标记的阈值时，对数算法比线性时间算法慢：

![](img/B15619_04_14.png)

图 4.14：对于较小的 n，线性算法 O(n)比运行在 O(log n)的算法更快

我们要记住的下一个要点更加具体，突出了使用最合适的 API 函数的重要性。

## 了解并使用适当的 API 函数

在 C++中，通常有多种方法可以做某事。语言和库继续发展，但很少有功能被弃用。当新函数添加到标准库中时，我们应该学会何时使用它们，并反思我们可能已经使用的模式，以弥补以前缺失的功能。

在这里，我们将专注于标准库中的两个小但重要的函数：`contains()`和`empty()`。在检查关联容器中的元素是否存在时使用`contains()`。如果要知道容器是否有任何元素或为空，请使用`empty()`。除了更清晰地表达意图外，它还具有性能优势。检查链表的大小是一个*O(n)*操作，而在列表上调用`empty()`则在常数时间*O(1)*内运行。

在 C++20 之前和`contains()`函数的引入之前，每当我们想要检查关联容器中某个值的存在时，我们都不得不绕个弯。您很可能会遇到使用各种方法来查找元素存在性的代码。假设我们使用`std::multiset`实现了一个单词袋：

```cpp
auto bag = std::multiset<std::string>{}; // Our bag-of-words
// Fill bag with words ... 
```

如果我们想知道我们的单词袋中是否有某个特定单词，有许多方法可以继续。一个选择是使用`count()`，就像这样：

```cpp
auto word = std::string{"bayes"}; // Our word we want to find
if (bag.count(word) > 0) {
   // ...
} 
```

这似乎是合理的，但它可能有一些额外开销，因为它计算与我们的单词匹配的*所有*元素。另一种选择是使用`find()`，但它有相同的开销，因为它返回所有匹配的单词，而不仅仅是第一次出现的：

```cpp
if (bag.find(word) != bag.end()) {
  // ...
} 
```

在 C++20 之前，推荐的方法是使用`lower_bound()`，因为它只返回第一个匹配的元素，就像这样：

```cpp
if (bag.lower_bound(word) != bag.end()) { 
  // ...
} 
```

现在，随着 C++20 和`contains()`的引入，我们可以更清楚地表达我们的意图，并确保当我们只想检查元素是否存在时，库会为我们提供最有效的实现：

```cpp
if (bag.contains(word)) { // Efficient and with clear intent 
  // ...
} 
```

一般规则是，如果有一个特定的成员函数或为特定容器设计的自由函数，那么如果符合您的需求，请使用它。它将是高效的，并且会更清晰地表达意图。不要像之前展示的那样绕道而行，只是因为您还没有学会完整的 API，或者因为您有以某种方式做事的旧习惯。

还应该说的是，零开销原则特别适用于这样的函数，因此不要浪费时间试图通过手工制作自己的函数来智胜库实现者。

我们现在将继续看一个更长的示例，展示我们如何以不同的方式重新排列数据，以优化特定用例的运行时性能。

# 并行数组

我们将通过讨论迭代元素和探索在迭代类似数组的数据结构时改善性能的方法来结束本章。我已经提到了访问数据时性能的两个重要因素：空间局部性和时间局部性。当在内存中连续存储的元素上进行迭代时，如果我们设法保持对象小，那么我们将增加所需数据已经被缓存的概率，这要归功于空间局部性。显然，这将对性能产生巨大影响。

回想一下在本章开头展示的缓存抖动示例，我们在矩阵上进行了迭代。它表明有时我们需要考虑访问数据的方式，即使我们对数据有一个相当紧凑的表示。

接下来，我们将比较迭代不同大小对象需要多长时间。我们将首先定义两个结构体，`SmallObject`和`BigObject`：

```cpp
struct SmallObject { 
  std::array<char, 4> data_{}; 
  int score_{std::rand()}; 
};

struct BigObject { 
 std::array<char, 256> data_{}; 
 int score_{std::rand()}; 
}; 
```

`SmallObject`和`BigObject`是相同的，只是初始数据数组的大小不同。这两个结构都包含一个名为`score_`的`int`，我们为测试目的初始化为一个随机值。我们可以使用`sizeof`运算符让编译器告诉我们对象的大小：

```cpp
std::cout << sizeof(SmallObject); // Possible output is 8 
std::cout << sizeof(BigObject);   // Possible output is 260 
```

我们需要大量对象来评估性能。创建每种对象一百万个：

```cpp
auto small_objects = std::vector<SmallObject>(1'000'000); 
auto big_objects = std::vector<BigObject>(1'000'000); 
```

现在进行迭代。假设我们想要对所有对象的分数进行求和。我们更倾向于使用`std::accumulate()`，这是我们稍后会在书中介绍的，但是，现在，一个简单的`for`循环就可以了。我们将这个函数写成一个模板，这样我们就不必为每种类型的对象手动编写一个版本。该函数迭代对象并对所有分数求和：

```cpp
template <class T> 
auto sum_scores(const std::vector<T>& objects) {  
  ScopedTimer t{"sum_scores"};    // See chapter 3 

  auto sum = 0; 
  for (const auto& obj : objects) { 
    sum += obj.score_; 
  } 
  return sum; 
} 
```

现在，我们准备看看在小对象中求和分数需要多长时间，与大对象相比：

```cpp
auto sum = 0; 
sum += sum_scores(small_objects); 
sum += sum_scores(big_objects); 
```

为了获得可靠的结果，我们需要多次重复测试。在我的电脑上，计算小对象的总和大约需要 1 毫秒，计算大对象的总和需要 10 毫秒。这个例子类似于本章开头的缓存抖动示例，而造成巨大差异的一个原因是，再次是因为计算机使用缓存层次结构从主内存中获取数据的方式。

在处理比前面的例子更现实的场景时，我们如何利用迭代小对象集合比大对象集合更快的事实？

显然，我们可以尽力保持类的大小较小，但这通常说起来容易做起来难。此外，如果我们正在处理一个已经增长了一段时间的旧代码库，很有可能会遇到一些非常大的类，其中包含太多的数据成员和太多的职责。

现在，我们将看一个代表在线游戏系统中用户的类，并看看我们如何将其分成更小的部分。该类具有以下数据成员：

```cpp
struct User { 
  std::string name_; 
  std::string username_; 
  std::string password_; 
  std::string security_question_; 
  std::string security_answer_; 
  short level_{}; 
  bool is_playing_{}; 
}; 
```

用户有一个经常使用的名称和一些很少使用的身份验证信息。该类还跟踪玩家当前所玩的级别。最后，`User`结构还通过存储`is_playing_`布尔值来知道用户当前是否在玩。

`sizeof`运算符在 64 位架构编译时报告`User`类为 128 字节。数据成员的近似布局如下图所示：

![](img/B15619_04_15.png)

图 4.15：User 类的内存布局

所有用户都保存在`std::vector`中，并且有两个经常调用并且需要快速运行的全局函数：`num_users_at_level()`和`num_playing_users()`。这两个函数都迭代所有用户，因此我们需要快速迭代用户向量。

第一个函数返回达到特定级别的用户数量：

```cpp
auto num_users_at_level(const std::vector<User>& users, short level) { 
  ScopedTimer t{"num_users_at_level (using 128 bytes User)"}; 

  auto num_users = 0; 
  for (const auto& user : users)
    if (user.level_ == level)
      ++num_users; 
  return num_users; 
} 
```

第二个函数计算当前有多少用户在玩：

```cpp
auto num_playing_users(const std::vector<User>& users) { 
  ScopedTimer t{"num_playing_users (using 128 bytes User)"}; 

  return std::count_if(users.begin(), users.end(), 
    [](const auto& user) { 
      return user.is_playing_; 
    }); 
} 
```

在这里，我们使用算法`std::count_if()`而不是手写循环，就像我们在`num_users_at_level()`中所做的那样。`std::count_if()`将为用户向量中的每个用户调用我们提供的谓词，并返回谓词返回`true`的次数。这基本上也是我们在第一个函数中所做的，所以我们也可以在第一个情况下使用`std::count_if()`。这两个函数都在线性时间内运行。

使用一个包含一百万个用户的向量调用这两个函数会得到以下输出：

```cpp
11 ms num_users_at_level (using 128 bytes User)
10 ms num_playing_users (using 128 bytes User) 
```

我们假设通过使`User`类更小，迭代向量将更快。如前所述，密码和安全数据字段很少使用，可以分组在一个单独的结构中。这将给我们以下类：

```cpp
struct AuthInfo { 
  std::string username_; 
  std::string password_; 
  std::string security_question_; 
  std::string security_answer_; 
}; 

struct User { 
  std::string name_; 
  std::unique_ptr<AuthInfo> auth_info_; 
  short level_{}; 
  bool is_playing_{}; 
}; 
```

这个改变将`User`类的大小从 128 字节减小到 40 字节。在`User`类中不再存储四个字符串，而是使用指针来引用新的`AuthInfo`对象。下图显示了我们如何将`User`类分成两个较小的类：

![](img/B15619_04_16.png)

图 4.16：当认证信息保存在单独的类中时的内存布局

从设计的角度来看，这个改变也是有意义的。将认证数据保存在单独的类中增加了`User`类的内聚性。`User`类包含一个指向认证信息的指针。当然，用户数据占用的总内存量并没有减少，但现在重要的是缩小`User`类以加快迭代所有用户的函数。

从优化的角度来看，我们必须再次测量以验证我们关于较小数据的假设是否有效。结果表明，使用较小的`User`类时，两个函数的运行速度都提高了两倍以上。修改版本运行时的输出如下：

```cpp
4 ms num_users_at_level with User
3 ms num_playing_users with User 
```

接下来，我们将尝试一种更激进的方式来缩小我们需要迭代的数据量，即使用**并行数组**。首先，警告：在许多情况下，这是一种优化，具有太多的缺点，无法成为可行的替代方案。不要将其视为一般技术，并且不加思考地应用它。在看完几个例子之后，我们将回顾并行数组的优缺点。

通过使用并行数组，我们简单地将大型结构拆分为较小的类型，类似于我们为`User`类的认证信息所做的操作。但是，我们不是使用指针来关联对象，而是将较小的结构存储在相等大小的单独数组中。不同数组中的较小对象，它们共享相同的索引，形成完整的原始对象。

一个例子将阐明这种技术。我们所使用的`User`类由 40 个字节组成。现在它只包含一个用户名字符串，一个指向认证信息的指针，一个表示当前级别的整数，以及`is_playing_`布尔值。通过缩小用户对象，我们发现在迭代对象时性能有所提高。用户对象数组的内存布局看起来像下图所示。我们暂时忽略内存对齐和填充，但在*第七章* *内存管理*中会回到这些主题：

![](img/B15619_04_17.png)

图 4.17：用户对象在向量中连续存储

我们可以将所有`short`级别和`is_playing_`标志存储在单独的向量中，而不是一个包含用户对象的向量。用户数组中索引为 0 的用户的当前级别也存储在级别数组的索引 0 处。这样，我们可以避免使用级别的指针，而是只使用索引来连接数据字段。我们也可以对布尔`is_playing_`字段做同样的操作，最终得到三个并行数组，而不是一个。这三个向量的内存布局看起来像这样：

![](img/B15619_04_18.png)

图 4.18：使用三个并行数组时的内存布局

我们使用三个并行数组来快速迭代一个特定字段。`num_users_at_level()`函数现在可以通过仅使用级别数组来计算特定级别的用户数量。现在的实现只是`std::count()`的一个包装器：

```cpp
auto num_users_at_level(const std::vector<int>& users, short level) { 
  ScopedTimer t{"num_users_at_level using int vector"}; 
  return std::count(users.begin(), users.end(), level); 
} 
```

同样，`num_playing_users()`函数只需要迭代布尔向量来确定正在玩游戏的用户数量。同样，我们使用`std::count()`：

```cpp
auto num_playing_users(const std::vector<bool>& users) { 
  ScopedTimer t{"num_playing_users using vector<bool>"}; 
  return std::count(users.begin(), users.end(), true); 
} 
```

使用并行数组，我们根本不需要使用用户数组。提取数组所占用的内存量远远小于用户数组，因此让我们再次检查在一百万用户上运行这些函数时是否提高了性能：

```cpp
auto users = std::vector<User>(1'000'000); 
auto levels = std::vector<short>(1'000'000); 
auto playing_users = std::vector<bool>(1'000'000); 

// Initialize data 
// ... 

auto num_at_level_5 = num_users_at_level(levels, 5);
auto num_playing = num_playing_users(playing_users); 
```

使用整数数组计算特定级别的用户数量只需要大约 0.7 毫秒。回顾一下，初始版本使用 128 字节大小的`User`类大约需要 11 毫秒。较小的`User`类执行时间为 4 毫秒，现在，只使用`levels`数组，我们的执行时间降至 0.7 毫秒。这是一个相当大的变化。

对于第二个函数`num_playing_users()`来说，改变更大——只需要大约 0.03 毫秒就能计算出当前正在玩游戏的用户数量。之所以能够如此快速，是因为有一种叫做**位数组**的数据结构。原来`std::vector<bool>`并不是标准的 C++ `bool`对象的向量。在内部，它实际上是一个位数组。在位数组中，诸如`count()`和`find()`等操作可以被高效地优化，因为它可以一次处理 64 位（在 64 位机器上），甚至可能通过使用 SIMD 寄存器处理更多位。`std::vector<bool>`的未来尚不明朗，很可能会很快被固定大小的`std::bitset`和新的动态大小的 bitset 所取代。Boost 中已经有了一个名为`boost::dynamic_bitset`的版本。

这一切都很棒，但我警告过您会有一些缺点。首先，从类中提取字段实际上会对代码结构产生重大影响。在某些情况下，将大类拆分为较小的部分是完全合理的，但在其他情况下，它完全破坏了封装性，并暴露了本应该隐藏在更高抽象接口后面的数据。

确保数组同步也很麻烦，因此我们总是需要确保组成一个对象的字段在所有数组中的相同索引处存储。这样的隐式关系很难维护，也容易出错。

最后一个缺点实际上与性能有关。在前面的例子中，您看到对于逐个字段迭代的算法，性能有了很大的提升。然而，如果我们有一个需要访问已提取到不同数组中的多个字段的算法，它将比在一个包含更大对象的数组上迭代要慢得多。

因此，就像在处理性能时一样，没有什么是不需要付出代价的，暴露数据并将一个简单的数组拆分为多个数组的代价可能太高，也可能不太高。这一切取决于您所面临的情况，以及在测量后您所遇到的性能收益。在真正面临性能问题之前，不要考虑并行数组。始终优先考虑良好的设计原则，并倾向于显式地表达对象之间的关系，而不是隐式的。

# 总结

在本章中，介绍了标准库中的容器类型。您了解到我们如何组织数据对于我们能够高效执行集合对象上的某些操作有着重大影响。标准库容器的渐近复杂度规范是在选择不同数据结构时需要考虑的关键因素。

此外，您了解到现代处理器中的缓存层次结构如何影响我们需要如何组织数据以实现对内存的高效访问。高效利用缓存层次结构的重要性不言而喻。这也是为什么保持元素在内存中连续的容器，如`std::vector`和`std::string`，已经成为最常用的容器之一的原因。

在下一章中，我们将看看如何使用迭代器和算法来高效地操作容器。
