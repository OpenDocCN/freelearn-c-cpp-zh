# 1

# C++简介

这本书旨在为您提供编写高效应用程序的坚实基础，以及实现现代 C++库的策略。我试图以实用的方式来解释 C++如何运作，现代 C++11 到 C++20 的现代特性是语言的自然部分，而不是从历史上看 C++。

在本章中，我们将：

+   介绍一些对编写健壮、高性能应用程序很重要的 C++特性

+   讨论 C++相对于竞争语言的优势和劣势

+   查看本书中使用的库和编译器

# 为什么选择 C++？

让我们开始探讨一些今天使用 C++的原因。简而言之，C++是一种高度可移植的语言，提供了零成本的抽象。此外，C++为程序员提供了编写和管理大型、富有表现力和健壮的代码库的能力。在本节中，我们将探讨*零成本抽象*的含义，将 C++的抽象与其他语言中的抽象进行比较，并讨论可移植性和健壮性，以及为什么这些特性很重要。

让我们开始进入零成本抽象。

## 零成本抽象

活跃的代码库会不断增长。有更多的开发人员在一个代码库上工作，代码库就会变得更大。为了管理代码库不断增长的复杂性，我们需要语言特性，比如变量、函数和类，能够使用自定义名称和接口创建我们自己的抽象，以抑制实现的细节。

C++允许我们定义自己的抽象，但它也带有内置的抽象。例如，C++函数的概念本身就是控制程序流的抽象。基于范围的`for`循环是另一个内置抽象的例子，它使得直接迭代一系列值成为可能。作为程序员，我们在开发程序时不断添加新的抽象。同样，C++的新版本引入了语言和标准库的新抽象。但是不断添加抽象和新的间接层是有代价的——效率。这就是零成本抽象发挥作用的地方。C++提供的许多抽象在空间和时间方面的运行成本非常低。

使用 C++，当需要时可以自由地谈论内存地址和其他与计算机相关的低级术语。然而，在大型软件项目中，希望用处理应用程序正在执行的任务的术语来表达代码，并让库处理与计算机相关的术语。图形应用程序的源代码可能涉及铅笔、颜色和滤镜，而游戏可能涉及吉祥物、城堡和蘑菇。低级的与计算机相关的术语，比如内存地址，可以留在 C++库代码中，其中性能至关重要。

### 编程语言和机器码抽象

为了让程序员摆脱处理与计算机相关的术语的需要，现代编程语言使用抽象，这样一个字符串列表，例如，可以被处理和看作是一个字符串列表，而不是一个我们可能会因为轻微的拼写错误而失去追踪的地址列表。这些抽象不仅让程序员摆脱了错误，还通过使用应用程序领域的概念使代码更具表现力。换句话说，代码用更接近口语的术语表达，而不是用抽象的编程关键字表达。

C++和 C 现在是两种完全不同的语言。不过，C++与 C 高度兼容，并且从 C 继承了很多语法和习惯用法。为了给你一些 C++抽象的例子，我将展示如何在 C 和 C++中解决一个问题。

看一下以下 C/C++代码片段，它们对应于问题：“这个书籍列表中有多少本《哈姆雷特》？”

我们将从 C 版本开始：

```cpp
// C version
struct string_elem_t { const char* str_; string_elem_t* next_; };
int num_hamlet(string_elem_t* books) {
  const char* hamlet = "Hamlet";
  int n = 0;
  string_elem_t* b; 
  for (b = books; b != 0; b = b->next_)
    if (strcmp(b->str_, hamlet) == 0)
      ++n;
  return n;
} 
```

使用 C++的等效版本看起来会是这样的：

```cpp
// C++ version
int num_hamlet(const std::forward_list<std::string>& books) {
  return std::count(books.begin(), books.end(), "Hamlet");
} 
```

尽管 C++版本仍然更像机器语言而不是人类语言，但由于更高级别的抽象，许多编程术语已经消失。以下是前两个代码片段之间的一些显著差异：

+   原始内存地址的指针根本不可见

+   `std::forward_list<std::string>`容器替换了手工制作的使用`string_elem_t`的链表

+   `std::count()`函数替换了`for`循环和`if`语句

+   `std::string`类提供了对`char*`和`strcmp()`的更高级别抽象

基本上，`num_hamlet()`的两个版本都会转换为大致相同的机器代码，但 C++的语言特性使得库可以隐藏计算机相关的术语，比如指针。许多现代 C++语言特性可以被视为对基本 C 功能的抽象。

### 其他语言中的抽象

大多数编程语言都是基于抽象构建的，这些抽象被转换为机器代码，由 CPU 执行。C++已经发展成为一种高度表达性的语言，就像今天许多其他流行的编程语言一样。C++与大多数其他语言的区别在于，其他语言实现这些抽象是以运行时性能为代价的，而 C++始终致力于以零成本实现其抽象。这并不意味着用 C++编写的应用程序默认比用其他语言（比如 C#）编写的应用程序更快。相反，这意味着通过使用 C++，您可以对生成的机器代码指令和内存占用进行精细控制（如果需要）。

公平地说，如今很少需要最佳性能，而为了更低的编译时间、垃圾回收或安全性而牺牲性能，就像其他语言所做的那样，在许多情况下更为合理。

### 零开销原则

“零成本抽象”是一个常用的术语，但它存在一个问题 - 大多数抽象通常都是有成本的。即使在程序运行时没有成本，也几乎总是在某个地方产生成本，比如长时间的编译时间，难以解释的编译错误消息等等。通常更有趣的是讨论零开销原则。C++的发明者 Bjarne Stroustrup 这样定义零开销原则：

+   你不使用的东西，你就不需要付费

+   你使用的东西，你无法手工编码得更好

这是 C++的一个核心原则，也是语言演变的一个非常重要的方面。为什么，你可能会问？基于这一原则构建的抽象将被性能意识强烈的程序员广泛接受和使用，并且在性能非常关键的环境中使用。找到许多人都同意并广泛使用的抽象，使我们的代码库更易于阅读和维护。

相反，C++语言中不完全遵循零开销原则的特性往往会被程序员、项目和公司所放弃。在这一类中最显著的两个特性是异常（不幸的是）和运行时类型信息（RTTI）。即使没有使用这些特性，它们都可能对性能产生影响。我强烈建议使用异常，除非你有非常充分的理由不这样做。与使用其他机制处理错误相比，性能开销在大多数情况下都是可以忽略的。

## 可移植性

C++长期以来一直是一种受欢迎且全面的语言。它与 C 高度兼容，语言中很少有被弃用的部分，无论是好是坏。C++的历史和设计使其成为一种高度可移植的语言，而现代 C++的发展确保了它将长期保持这种状态。C++是一种活跃的语言，编译器供应商目前正在非常出色地迅速实现新的语言特性。

## 健壮性

除了性能、表现力和可移植性之外，C++还提供了一系列语言特性，使程序员能够编写健壮的代码。

在作者的经验中，健壮性并不是指编程语言本身的强大性 - 在任何语言中都可以编写健壮的代码。相反，资源的严格所有权，const 正确性，值语义，类型安全以及对象的确定性销毁是 C++提供的一些功能，使得编写健壮的代码更容易。也就是说，能够编写易于使用且难以误用的函数、类和库。

## 今天的 C++

总之，今天的 C++为程序员提供了编写富有表现力和健壮的代码基础的能力，同时还可以选择针对几乎任何硬件平台或实时需求。在今天最常用的语言中，只有 C++具有所有这些特性。

我已经简要介绍了为什么 C++仍然是一种相关且广泛使用的编程语言。在接下来的部分，我们将看看 C++与其他现代编程语言的比较。

# 与其他语言相比的 C++

自 C++首次发布以来，出现了大量的应用类型、平台和编程语言。然而，C++仍然是一种广泛使用的语言，其编译器适用于大多数平台。截至今天，唯一的例外是 Web 平台，JavaScript 及其相关技术是其基础。然而，Web 平台正在发展，能够执行以前只在桌面应用程序中可能的功能，在这种情况下，C++已经通过使用诸如 Emscripten、asm.js 和 WebAssembly 等技术进入了 Web 应用程序。

在这一部分，我们将首先从性能的角度比较竞争性语言。接下来，我们将看看 C++如何处理对象所有权和垃圾回收，以及如何避免在 C++中出现空对象。最后，我们将介绍一些 C++的缺点，用户在考虑语言是否适合其需求时应该牢记。

## 竞争性语言和性能

为了了解 C++如何实现与其他编程语言相比的性能，让我们讨论一些 C++与大多数其他现代编程语言之间的基本区别。

为简单起见，本节将重点比较 C++和 Java，尽管大部分比较也适用于基于垃圾收集器的其他编程语言，如 C#和 JavaScript。

首先，Java 编译为字节码，然后在应用程序执行时将其编译为机器代码，而大多数 C++实现直接将源代码编译为机器代码。尽管字节码和即时编译器在理论上可能能够实现与预编译的机器代码相同（或者在理论上甚至更好）的性能，但截至今天，它们通常做不到。不过，公平地说，它们对大多数情况来说表现得足够好。

其次，Java 以完全不同的方式处理动态内存，与 C++不同。在 Java 中，内存由垃圾收集器自动释放，而 C++程序通过手动或引用计数机制处理内存释放。垃圾收集器确实可以防止内存泄漏，但以性能和可预测性为代价。

第三，Java 将所有对象放在单独的堆分配中，而 C++允许程序员将对象放在堆和栈上。在 C++中，还可以在一个单一的堆分配中创建多个对象。这可以有两个原因带来巨大的性能提升：对象可以在不总是分配动态内存的情况下创建，并且多个相关对象可以相邻地放置在内存中。

看看下面的例子中内存是如何分配的。C++函数在栈上同时使用对象和整数；Java 将对象放在堆上：

| C++ | Java |
| --- | --- |

|

```cpp
class Car {
public:
  Car(int doors)
      : doors_(doors) {}
private:
  int doors_{}; 
};
auto some_func() {
  auto num_doors = 2;
  auto car1 = Car{num_doors};
  auto car2 = Car{num_doors};
  // ...
} 
```

|

```cpp
class Car {
  public Car(int doors) { 
    doors_ = doors;
  }
  private int doors_;
  static void some_func() {
    int numDoors = 2;
    Car car1 = new Car(numDoors);
    Car car2 = new Car(numDoors);
    // ...
  }
} 
```

|

| C++将所有内容都放在堆栈上:![](img/B15619_01_01.png) | Java 将`Car`对象放在堆上:![](img/B15619_01_02.png) |
| --- | --- |

现在让我们看看下一个例子，看看在使用 C++和 Java 时，`Car`对象的数组是如何放置在内存中的：

| C++ | Java |
| --- | --- |

|

```cpp
auto n = 4;
auto cars = std::vector<Car>{};
cars.reserve(n);
for (auto i=0; i<n;++i) {
   cars.push_back(Car{2});
} 
```

|

```cpp
int n = 4;
ArrayList<Car> cars = 
  new ArrayList<Car>();
for (int i=0; i<n; i++) {
  cars.addElement(new Car(2));
} 
```

|

| 以下图表显示了在 C++中`Car`对象在内存中的布局:![](img/B15619_01_03.png) | 以下图表显示了在 Java 中`Car`对象在内存中的布局:![](img/B15619_01_04.png) |
| --- | --- |

C++向量包含放置在一个连续内存块中的实际`Car`对象，而 Java 中的等价物是对`Car`对象的*引用*的连续内存块。在 Java 中，对象已经分别分配，这意味着它们可以位于堆的任何位置。

这会影响性能，因为在这个例子中，Java 实际上需要在 Java 堆空间中执行五次分配。这也意味着每当应用程序迭代列表时，C++都会获得性能优势，因为访问附近的内存位置比访问内存中的几个随机位置更快。

## C++语言的非性能相关特性

很容易认为只有在性能是主要关注点时才应该使用 C++。难道不是这样吗？C++只是因为手动内存处理而增加了代码库的复杂性，这可能导致内存泄漏和难以跟踪的错误吗？

这可能在几个 C++版本前是真的，但现代 C++程序员依赖于标准库中提供的容器和智能指针类型。在过去的 10 年中，C++增加的大部分特性使得这门语言更加强大和更容易使用。

我想在这里强调一些 C++的旧但强大的特性，这些特性与健壮性有关，而不是性能，很容易被忽视：值语义、`const`正确性、所有权、确定性销毁和引用。

### 值语义

C++支持值语义和引用语义。值语义允许我们按值传递对象，而不仅仅是传递对象的引用。在 C++中，值语义是默认的，这意味着当你传递一个类或结构的实例时，它的行为与传递`int`、`float`或任何其他基本类型的行为相同。要使用引用语义，我们需要明确使用引用或指针。

C++类型系统使我们能够明确陈述对象的所有权。比较 C++和 Java 中一个简单类的以下实现。我们将从 C++版本开始：

```cpp
// C++
class Bagel {
public:
  Bagel(std::set<std::string> ts) : toppings_(std::move(ts)) {}
private:
  std::set<std::string> toppings_;
}; 
```

在 Java 中对应的实现可能如下所示：

```cpp
// Java
class Bagel {
  public Bagel(ArrayList<String> ts) { toppings_ = ts; }
  private ArrayList<String> toppings_;
} 
```

在 C++版本中，程序员声明`toppings`完全被`Bagel`类封装。如果程序员打算让夹料列表在几个百吉饼之间共享，它将被声明为某种指针：如果所有权在几个百吉饼之间共享，则为`std::shared_ptr`，如果其他人拥有夹料列表并且应该在程序执行时修改它，则为`std::weak_ptr`。

在 Java 中，对象之间共享所有权。因此，无法区分夹心面包的夹料列表是打算在几个百吉饼之间共享还是不共享，或者它是否在其他地方处理，或者如果是在大多数情况下，是否完全由`Bagel`类拥有。

比较以下函数；由于在 Java（和大多数其他语言）中默认情况下每个对象都是共享的，程序员必须对诸如此类的微妙错误采取预防措施：

| C++ | Java |
| --- | --- |

|

```cpp
// Note how the bagels do
// not share toppings:
auto t = std::set<std::string>{};
t.insert("salt");
auto a = Bagel{t};
// 'a' is not affected
// when adding pepper
t.insert("pepper");
// 'a' will have salt
// 'b' will have salt & pepper 
auto b = Bagel{t};
// No bagel is affected
t.insert("oregano"); 
```

|

```cpp
// Note how both the bagels
// share toppings:
TreeSet<String> t = 
  new TreeSet<String>();
t.add("salt");
Bagel a = new Bagel(t);
// Now 'a' will subtly 
// also have pepper
t.add("pepper");
// 'a' and 'b' share the
// toppings in 't'
Bagel b = new Bagel(t);
// Both bagels are affected
toppings.add("oregano"); 
```

|

### const 正确性

C++的另一个强大特性是能够编写完全`const`正确的代码，而 Java 和许多其他语言则缺乏这一能力。Const 正确性意味着类的每个成员函数签名都明确告诉调用者对象是否会被修改；如果调用者尝试修改声明为`const`的对象，则不会编译。在 Java 中，可以使用`final`关键字声明常量，但这缺乏将成员函数声明为`const`的能力。

以下是一个示例，说明如何使用`const`成员函数防止意外修改对象。在下面的`Person`类中，成员函数`age()`声明为`const`，因此不允许改变`Person`对象，而`set_age()`改变对象，*不能*声明为`const`：

```cpp
class Person {
public:
  auto age() const { return age_; }
  auto set_age(int age) { age_ = age; }
private:
  int age_{};
}; 
```

还可以区分返回可变和不可变引用的成员。在下面的`Team`类中，成员函数“leader() const”返回一个不可变的`Person`，而`leader()`返回一个可能被改变的`Person`对象：

```cpp
class Team {
public:
  auto& leader() const { return leader_; }
  auto& leader() { return leader_; }
private:
  Person leader_{};
}; 
```

现在让我们看看编译器如何帮助我们找到在尝试改变不可变对象时的错误。在下面的示例中，函数参数`teams`声明为`const`，明确显示此函数不允许修改它们：

```cpp
void nonmutating_func(const std::vector<Team>& teams) {
  auto tot_age = 0;

  // Compiles, both leader() and age() are declared const
  for (const auto& team : teams) 
    tot_age += team.leader().age();
  // Will not compile, set_age() requires a mutable object
  for (auto& team : teams) 
    team.leader().set_age(20);
} 
```

如果我们想编写一个*可以*改变`teams`对象的函数，我们只需删除`const`。这向调用者发出信号，表明此函数可能会改变`teams`：

```cpp
void mutating_func(std::vector<Team>& teams) {
  auto tot_age = 0;

  // Compiles, const functions can be called on mutable objects
  for (const auto& team : teams) 
    tot_age += team.leader().age();
  // Compiles, teams is a mutable variable
  for (auto& team : teams) 
    team.leader().set_age(20);
} 
```

### 对象所有权

除非在非常罕见的情况下，C++程序员应该将内存处理留给容器和智能指针，而不必依赖手动内存处理。

明确地说，通过使用`std::shared_ptr`可以在 C++中几乎模拟 Java 中的垃圾收集模型。请注意，垃圾收集语言不使用与`std::shared_ptr`相同的分配跟踪算法。`std::shared_ptr`是基于引用计数算法的智能指针，如果对象具有循环依赖关系，它将泄漏内存。垃圾收集语言具有更复杂的方法，可以处理和释放循环依赖对象。

然而，与依赖垃圾收集器不同，通过精心避免共享对象默认情况下的严格所有权，可以避免由此产生的微妙错误，就像 Java 中的情况一样。

如果程序员在 C++中最小化了共享所有权，生成的代码将更易于使用，更难被滥用，因为它可以强制类的用户按照预期使用它。

### C++中的确定性销毁

在 C++中，对象的销毁是确定性的。这意味着我们（可以）确切地知道对象何时被销毁。而在 Java 等垃圾收集语言中，垃圾收集器决定未引用对象何时被终结，这种情况并非如此。

在 C++中，我们可以可靠地撤销对象生命周期中所做的操作。起初，这可能看起来微不足道。但事实证明，这对我们如何提供异常安全保证以及在 C++中处理资源（如内存、文件句柄、互斥锁等）有很大影响。

确定性销毁也是使 C++可预测的特性之一。这是程序员非常重视的东西，也是对性能关键应用的要求。

我们将在本书的后面花更多时间讨论对象所有权、生命周期和资源管理。因此，如果目前这些内容还不太清楚，不要太担心。

### 使用 C++引用避免空对象

除了严格的所有权外，C++还有引用的概念，这与 Java 中的引用不同。在内部，引用是一个不允许为空或重新指向的指针；因此，当将其传递给函数时不涉及复制。

因此，C++中的函数签名可以明确限制程序员传递 null 对象作为参数。在 Java 中，程序员必须使用文档或注释来指示非 null 参数。

看一下这两个用于计算球体体积的 Java 函数。第一个如果传递了 null 对象就会抛出运行时异常，而第二个则会悄悄地忽略 null 对象。

在 Java 中，第一个实现如果传递了 null 对象就会抛出运行时异常：

```cpp
// Java
float getVolume1(Sphere s) {
  float cube = Math.pow(s.radius(), 3);
  return (Math.PI * 4 / 3) * cube; 
} 
```

在 Java 中，第二个实现会悄悄地处理 null 对象：

```cpp
// Java
float getVolume2(Sphere s) { 
  float rad = s == null ? 0.0f : s.radius();
  float cube = Math.pow(rad, 3);
  return (Math.PI * 4 / 3) * cube;
} 
```

在 Java 中实现的这两个函数中，调用函数的人必须检查函数的实现，以确定是否允许 null 对象。

在 C++中，第一个函数签名明确只接受通过引用初始化的对象，引用不能为 null。使用指针作为参数的第二个版本明确显示了处理 null 对象。

C++中作为引用传递的参数表示不允许 null 值：

```cpp
auto get_volume1(const Sphere& s) {   
  auto cube = std::pow(s.radius(), 3.f);
  auto pi = 3.14f;
  return (pi * 4.f / 3.f) * cube;
} 
```

C++中作为指针传递的参数表示正在处理 null 值：

```cpp
auto get_volume2(const Sphere* s) {
  auto rad = s ? s->radius() : 0.f;
  auto cube = std::pow(rad, 3);
  auto pi = 3.14f;
  return (pi * 4.f / 3.f) * cube;
} 
```

能够在 C++中使用引用或值作为参数立即告知 C++程序员函数的预期使用方式。相反，在 Java 中，用户必须检查函数的实现，因为对象总是作为指针传递，并且存在它们可能为 null 的可能性。

## C++的缺点

如果不提及一些缺点，将 C++与其他编程语言进行比较是不公平的。正如前面提到的，C++有更多的概念需要学习，因此更难正确使用和发挥其全部潜力。然而，如果程序员能够掌握 C++，更高的复杂性就会变成优势，代码库变得更加健壮并且性能更好。

然而，C++也有一些缺点，这些缺点只是缺点。其中最严重的是长时间的编译时间和导入库的复杂性。直到 C++20，C++一直依赖于一个过时的导入系统，其中导入的头文件只是简单地粘贴到需要它们的地方。C++20 中引入的模块将解决系统的一些问题，该系统基于包含头文件，并且还将对大型项目的编译时间产生积极影响。

C++的另一个明显缺点是缺乏提供的库。而其他语言通常提供大多数应用程序所需的所有库，例如图形、用户界面、网络、线程、资源处理等，C++提供的几乎只是最基本的算法、线程，以及从 C++17 开始的文件系统处理。对于其他一切，程序员必须依赖外部库。

总之，尽管 C++的学习曲线比大多数其他语言要陡峭，但如果使用正确，C++的健壮性与许多其他语言相比是一个优势。因此，尽管编译时间长且缺乏提供的库，我认为 C++是一个非常适合大型项目的语言，即使对于性能不是最高优先级的项目也是如此。

# 本书中使用的库和编译器

正如前面提到的，C++在库方面并没有提供更多的东西。因此，在本书中，我们必须在必要时依赖外部库。在 C++世界中最常用的库可能是 Boost 库（[`www.boost.org`](http://www.boost.org)）。

本书的一些部分使用了 Boost 库，因为标准 C++库不够。我们只会使用 Boost 库的头文件部分，这意味着使用它们自己不需要任何特定的构建设置；而只需要包含指定的头文件即可。

此外，我们将使用 Google Benchmark，一个微基准支持库，来评估小代码片段的性能。Google Benchmark 将在*第三章* *分析和测量性能*中介绍。

可在[`github.com/PacktPublishing/Cpp-High-Performance-Second-Edition`](https://github.com/PacktPublishing/Cpp-High-Performance-Second-Edition)找到本书的存储库，其中包含了书中的源代码，使用了 Google Test 框架，使您更容易构建、运行和测试代码。

还应该提到，本书使用了很多来自 C++20 的新功能。在撰写本文时，我们使用的编译器（Clang、GCC 和 Microsoft Visual C++）尚未完全实现其中一些功能。其中一些功能完全缺失或仅支持实验性功能。关于主要 C++编译器当前状态的最新摘要可以在[`en.cppreference.com/w/cpp/compiler_support`](https://en.cppreference.com/w/cpp/compiler_support)找到。

# 总结

在本章中，我已经强调了 C++的一些特点和缺点，以及它是如何发展到今天的状态的。此外，我们讨论了 C++与其他语言相比的优缺点，从性能和健壮性的角度来看。

在下一章中，我们将探讨一些对 C++语言发展产生重大影响的现代和基本功能。
