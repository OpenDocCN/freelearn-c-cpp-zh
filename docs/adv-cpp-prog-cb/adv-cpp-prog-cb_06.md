# 为性能优化您的代码

优化代码以提高性能可以确保您的代码充分利用了 C++所能提供的功能。与其他高级语言不同，C++能够提供高级的语法自由，而不会牺牲性能，尽管诚然会增加学习曲线的成本。

本章很重要，因为它将演示更高级的优化代码方法，包括如何在单元级别对软件进行基准测试，如何检查编译器为潜在优化而生成的结果汇编代码，如何减少应用程序使用的内存资源数量，以及为什么编译器提示（如`noexcept`）很重要。阅读完本章后，您将具备编写更高效 C++代码的技能。

在本章中，我们将涵盖以下配方：

+   对代码进行基准测试

+   查看汇编代码

+   减少内存分配的数量

+   声明 noexcept

# 技术要求

要编译和运行本章中的示例，您必须具有管理访问权限，可以访问运行 Ubuntu 18.04 的计算机，并具有功能正常的互联网连接。在运行这些示例之前，您必须安装以下内容：

```cpp
> sudo apt-get install build-essential git cmake valgrind
```

如果这是安装在 Ubuntu 18.04 以外的任何操作系统上，则需要 GCC 7.4 或更高版本和 CMake 3.6 或更高版本。

# 对代码进行基准测试

在本配方中，您将学习如何对源代码进行基准测试和优化。优化源代码将导致更高效的 C++，从而增加电池寿命，提高性能等。这个配方很重要，因为优化源代码的过程始于确定您计划优化的资源，这可能包括速度、内存甚至功耗。没有基准测试工具，要比较解决同一个问题的不同方法是非常困难的。

对于 C++程序员来说，有无数的基准测试工具（任何测量程序的单个属性的工具），包括 Boost、Folly 和 Abseil 等 C++ API，以及诸如 Intel 的 vTune 之类的特定于 CPU 的工具。还有一些性能分析工具（任何帮助您了解程序行为的工具），如 valgrind 和 gprof。在本配方中，我们将重点关注其中的两个：Hayai 和 Valgrind。Hayai 提供了一个微基准测试的简单示例，而 Valgrind 提供了一个更完整、但更复杂的动态分析/性能分析工具的示例。

# 准备工作

在开始之前，请确保已满足所有技术要求，包括安装 Ubuntu 18.04 或更高版本，并在终端窗口中运行以下命令：

```cpp
> sudo apt-get install build-essential git valgrind cmake
```

这将确保您的操作系统具有适当的工具来编译和执行本配方中的示例。完成此操作后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。

# 操作步骤

执行以下步骤完成这个配方：

1.  从新的终端中运行以下命令以下载源代码：

```cpp
> cd ~/
> git clone https://github.com/PacktPublishing/Advanced-CPP-CookBook.git
> cd Advanced-CPP-CookBook/chapter06
```

1.  要编译源代码，请运行以下命令：

```cpp
> cmake -DCMAKE_BUILD_TYPE=Debug .
> make recipe01_examples
```

1.  一旦源代码被编译，您可以通过运行以下命令来执行本配方中的每个示例：

```cpp
> ./recipe01_example01
[==========] Running 2 benchmarks.
[ RUN ] vector.push_back (10 runs, 100 iterations per run)
[ DONE ] vector.push_back (0.200741 ms)
...
[ RUN ] vector.emplace_back (10 runs, 100 iterations per run)
[ DONE ] vector.emplace_back (0.166699 ms)
...

> ./recipe01_example02
```

在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本配方中所教授的课程的关系。

# 工作原理

应用于 C++的最常见优化是执行速度。为了优化 C++的速度，我们必须首先开发不同的方法来解决同一个问题，然后对每个解决方案进行基准测试，以确定哪个解决方案执行速度最快。基准测试工具，如 GitHub 上的基于 C++的基准测试库 Hayai，有助于做出这一决定。为了解释这一点，让我们看一个简单的例子：

```cpp
#include <string>
#include <vector>
#include <hayai.hpp>

std::vector<std::string> data;

BENCHMARK(vector, push_back, 10, 100)
{
    data.push_back("The answer is: 42");
}

BENCHMARK(vector, emplace_back, 10, 100)
{
    data.emplace_back("The answer is: 42");
}
```

当我们执行上述代码时，我们会得到以下输出：

![](img/4b7883ec-9592-4fde-bb6f-bcc9465077c4.jpg)

在前面的示例中，我们使用 Hayai 库来基准测试使用`push_back()`和`emplace_back()`向向量添加字符串之间的性能差异。`push_back()`和`emplace_back()`之间的区别在于，`push_back()`创建对象，然后将其复制或移动到向量中，而`emplace_back()`在向量中创建对象本身，而无需临时对象和随后的复制/移动。也就是说，如果使用`push_back()`，必须构造对象，然后将其复制或移动到向量中。如果使用`emplace_back()`，则只需构造对象。如预期的那样，`emplace_back()`优于`push_back()`，这就是为什么诸如 Clang-Tidy 之类的工具建议尽可能使用`emplace_back()`而不是`push_back()`。

基准库，如 Hayai，使用简单，对帮助程序员优化源代码非常有效，并且不仅能够对速度进行基准测试，还能够对资源使用进行基准测试。这些库的问题在于它们更适合在*单元*级别而不是*集成*和*系统*级别进行利用；也就是说，要测试整个可执行文件，这些库不适合帮助程序员，因为随着测试规模的增加，它们的扩展性不佳。为了分析整个可执行文件而不是单个函数，存在诸如 Valgrind 之类的工具，它可以帮助您分析哪些函数在优化方面需要最多的关注。然后，可以使用基准测试工具来分析需要最多关注的函数。

Valgrind 是一种动态分析工具，能够检测内存泄漏并跟踪程序的执行。为了看到这一点，让我们看下面的示例：

```cpp
volatile int data = 0;

void foo()
{
 data++;
}

int main(void)
{
 for (auto i = 0; i < 100000; i++) {
 foo();
 }
}
```

在前面的示例中，我们从名为`foo()`的函数中递增一个全局变量（标记为 volatile 以确保编译器不会优化掉该变量），然后执行这个函数`100,000`次。要分析这个示例，请运行以下命令（使用`callgrind`输出程序中每个函数被调用的次数）：

```cpp
> valgrind --tool=callgrind ./recipe01_example02
> callgrind_annotate callgrind.out.*
```

这导致以下输出：

![](img/f6aac4e5-2af5-426e-a176-9da59a0a379b.png)

正如我们所看到的，`foo()`函数在前面的输出中位于最前面（动态链接器的`_dl_lookup_symbol_x()`函数被调用最多，用于在执行之前链接程序）。值得注意的是，程序列表（在左侧）中`foo()`函数的指令总数为`800,000`。这是因为`foo()`函数有`8`条汇编指令，并且被执行了`100,000`次。例如，让我们使用`objdump`（一种能够输出可执行文件编译汇编的工具）来查看`foo()`函数的汇编，如下所示：

![](img/f3a341c8-cf01-4265-9e74-e2496c465733.png)

使用 Valgrind，可以对可执行文件进行分析，以确定哪些函数执行时间最长。例如，让我们看看`ls`：

```cpp
> valgrind --tool=callgrind ls
> callgrind_annotate callgrind.out.*
```

这导致以下输出：

![](img/050bd8f5-9adc-4825-b4db-fc8970010080.png)

正如我们所看到的，`strcmp`函数被频繁调用。这些信息可以与*单元*级别的基准测试 API 相结合，以确定是否可以编写更快的`strcmp`版本（例如，使用手写汇编和特殊的 CPU 指令）。使用诸如 Hayai 和 Valgrind 之类的工具，可以分离出程序中消耗最多 CPU、内存甚至电源的函数，并重写它们以提供更好的性能，同时将精力集中在将提供最佳投资回报的优化上。

# 查看汇编代码

在本教程中，我们将从两种不同的优化中查看生成的汇编：循环展开和传引用参数。这个教程很重要，因为它将教会你如何深入了解编译器是如何将 C++转换为可执行代码的。这些信息将揭示为什么 C++规范（如 C++核心指南）对于优化和性能做出了推荐。当你试图编写更好的 C++代码时，尤其是当你想要优化它时，这通常是至关重要的。

# 准备工作

在开始之前，请确保已满足所有技术要求，包括安装 Ubuntu 18.04 或更高版本，并在终端窗口中运行以下命令：

```cpp
> sudo apt-get install build-essential git cmake
```

这将确保您的操作系统具有正确的工具来编译和执行本教程中的示例。完成这些操作后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。

# 如何做到这一点...

执行以下步骤来完成本教程：

1.  从新的终端中，运行以下命令来下载源代码：

```cpp
> cd ~/
> git clone https://github.com/PacktPublishing/Advanced-CPP-CookBook.git
> cd Advanced-CPP-CookBook/chapter06
```

1.  要编译源代码，请运行以下命令：

```cpp
> cmake -DCMAKE_BUILD_TYPE=Debug .
> make recipe02_examples
```

1.  一旦源代码被编译，您可以通过运行以下命令来执行本教程中的每个示例：

```cpp
> ./recipe02_example01

> ./recipe02_example02

> ./recipe02_example03

> ./recipe02_example04

> ./recipe02_example05
```

在下一节中，我们将逐个介绍这些例子，并解释每个例子程序的作用以及它与本教程中所教授的课程的关系。

# 它是如何工作的...

学习如何优化 C++代码的最佳方法之一是学习如何分析编译器在编译后生成的汇编代码。在本教程中，我们将学习如何通过查看两个不同的例子来进行这种分析：循环展开和传引用参数。

在我们查看这些例子之前，让我们先看一个简单的例子：

```cpp
int main(void)
{ }
```

在上面的例子中，我们只有一个`main()`函数。我们没有包含任何 C 或 C++库，`main()`函数本身是空的。如果我们编译这个例子，我们会发现生成的二进制文件仍然非常大：

![](img/99ace8d4-1e3a-45be-a24f-c318040b45eb.png)

在这种情况下，这个例子的大小是`22kb`。为了显示编译器为这段代码生成的汇编代码，我们可以这样做：

```cpp
> objdump -d recipe02_example01
```

前面命令的输出结果应该令人惊讶，因为对于一个完全没有任何功能的应用程序来说，代码量很大。

为了更好地了解有多少代码，我们可以通过使用`grep`来细化输出，这是一个让我们从任何命令中过滤文本的工具。让我们看看代码中的所有函数：

![](img/d17573c5-b2e5-4905-a7a5-29b065898a0d.png)

正如我们所看到的，编译器会自动为您添加几个函数。这包括`_init()`、`_fini()`和`_start()`函数。我们还可以查看特定的函数，比如我们的主函数，如下所示：

![](img/1b25fad2-bea6-4f4c-a87b-adb0e85f399d.png)

在上面的例子中，我们搜索`objdump`的输出，查找`main>:`和`RETQ`。所有函数名都以`>:`结尾，而每个函数的最后一条指令（通常）是在 Intel 64 位系统上的`RETQ`。

以下是生成的汇编：

```cpp
  401106: push %rbp
  401107: mov %rsp,%rbp
```

首先，它将当前的堆栈帧指针（`rbp`）存储到堆栈中，并将堆栈帧指针加载到`main()`函数的堆栈的当前地址（`rsp`）。

这可以在每个函数中看到，并称为函数的前言。`main()`执行的唯一代码是`return 0`，这是编译器自动添加的代码：

```cpp
  40110a: mov $0x0,%eax
```

最后，这个函数中的最后一个汇编包含了函数的结尾，它恢复了堆栈帧指针并返回：

```cpp

  40110f: pop %rbp
  401110: retq
```

现在我们对如何获取和阅读编译后的 C++程序的汇编结果有了更好的理解，让我们来看一个循环展开的例子，循环展开是用其等效的指令版本替换循环指令的过程。为了做到这一点，确保示例是在发布模式下编译的（也就是启用了编译器优化），通过以下命令进行配置：

```cpp
> cmake -DCMAKE_BUILD_TYPE=Release .
> make
```

为了理解循环展开，让我们看一下以下代码：

```cpp
volatile int data[1000];

int main(void)
{
    for (auto i = 0U; i < 1000; i++) {
        data[i] = 42;
    }
}
```

当编译器遇到循环时，生成的汇编代码包含以下代码：

![](img/4414aa74-9275-444b-bf7a-a8a150a4a426.png)

让我们来分解一下：

```cpp
  401020: xor %eax,%eax
  401022: nopw 0x0(%rax,%rax,1)
```

前两条指令属于代码的`for (auto i = 0U;`部分。在这种情况下，`i`变量存储在`EAX`寄存器中，并使用`XOR`指令将其设置为`0`（在 Intel 上，`XOR`指令比`MOV`指令更快地将寄存器设置为 0）。`NOPW`指令可以安全地忽略。

接下来的几条指令是交错的，如下所示：

```cpp
  401028: mov %eax,%edx
  40102a: add $0x1,%eax
  40102d: movl $0x2a,0x404040(,%rdx,4)
```

这些指令代表了`i++;`和`data[i] = 42;`的代码。第一条指令存储了`i`变量的当前值，然后将其加一，然后再将`42`存储到由`i`索引的内存地址中。方便的是，这个汇编结果展示了一个优化的可能机会，因为编译器可以使用以下方式实现相同的功能：

```cpp
 movl $0x2a,0x404040(,%rax,4)
 add $0x1,%eax
```

前面的代码在执行`i++`之前存储了值`42`，因此不再需要以下内容：

```cpp
  mov %eax,%edx
```

存在多种方法来实现这种潜在的优化，包括使用不同的编译器或手写汇编。下一组指令执行我们`for`循环的`i < 1000;`部分：

```cpp
  401038: cmp $0x3e8,%eax
  40103d: jne 401028 <main+0x8>
```

`CMP`指令检查`i`变量是否为`1000`，如果不是，则使用`JNE`指令跳转到函数顶部继续循环。否则，剩下的代码执行：

```cpp
  40103f: xor %eax,%eax
  401041: retq 
```

为了了解循环展开的工作原理，让我们将循环的迭代次数从`1000`改为`4`，如下所示：

```cpp
volatile int data[4];

int main(void)
{
    for (auto i = 0U; i < 4; i++) {
        data[i] = 42;
    }
}
```

我们可以看到，除了循环迭代次数之外，代码是相同的。汇编结果如下：

![](img/4414aa74-9275-444b-bf7a-a8a150a4a426.png)

我们可以看到，`CMP`和`JNE`指令都不见了。现在，以下代码被编译了（但还有更多！）：

```cpp
    for (auto i = 0U; i < 4; i++) {
        data[i] = 42;
    }
```

编译后的代码转换为以下代码：

```cpp
        data[0] = 42;
        data[1] = 42;
        data[2] = 42;
        data[3] = 42;
```

`return 0;`出现在赋值之间的汇编中。这是允许的，因为函数的返回值与赋值无关（因为赋值指令从不触及`RAX`），这为 CPU 提供了额外的优化（因为它可以并行执行`return 0;`，尽管这是本书范围之外的话题）。值得注意的是，循环展开并不要求使用少量的循环迭代。一些编译器会部分展开循环以实现优化（例如，以`4`个为一组而不是一次执行`1`次循环）。

我们的最后一个例子将研究按引用传递而不是按值传递。首先，在调试模式下重新编译代码：

```cpp
> cmake -DCMAKE_BUILD_TYPE=Debug .
> make
```

让我们看一下以下例子：

```cpp
struct mydata {
    int data[100];
};

void foo(mydata d)
{
    (void) d;
}

int main(void)
{
    mydata d;
    foo(d);
}
```

在这个例子中，我们创建了一个大型结构体，并按值传递给了我们主函数中名为`foo()`的函数。主函数的汇编结果如下：

![](img/45b46604-3410-4880-b1de-7ed7b6ecbd4b.png)

前面示例中的重要指令如下：

```cpp
  401137: rep movsq %ds:(%rsi),%es:(%rdi)
  40113a: callq 401106 <_Z3foo6mydata>
```

前面的指令将大型结构体复制到堆栈上，然后调用我们的`foo()`函数。复制是因为结构体是按值传递的，这意味着编译器必须执行复制。顺便说一句，如果您想以可读的格式而不是混淆的格式看到输出，可以在选项中添加`C`，如下所示：

![](img/1e602d6c-13f7-4a30-9494-09b95deb705c.png)

最后，让我们按引用传递来看看结果的改善：

```cpp
struct mydata {
    int data[100];
};

void foo(mydata &d)
{
    (void) d;
}

int main(void)
{
    mydata d;
    foo(d);
}
```

如我们所见，我们通过引用传递结构而不是按值传递。生成的汇编代码如下：

![](img/60ea97a9-3744-48ce-bc91-000a09a842b0.png)

在这里，代码要少得多，导致可执行文件更快。正如我们所学到的，如果我们希望了解编译器生成了什么，检查编译器生成的内容是有效的，因为这提供了有关您可以进行的潜在更改的更多信息，以编写更有效的 C++代码。

# 减少内存分配的数量

C++在应用程序运行时会一直产生隐藏的内存分配。本教程将教你如何确定 C++何时分配内存以及如何在可能的情况下删除这些分配。了解如何删除内存分配很重要，因为`new()`、`delete()`、`malloc()`和`free()`等函数不仅速度慢，而且它们提供的内存也是有限的。删除不需要的分配不仅可以提高应用程序的整体性能，还有助于减少其整体内存需求。

# 准备工作

开始之前，请确保已满足所有技术要求，包括安装 Ubuntu 18.04 或更高版本，并在终端窗口中运行以下命令：

```cpp
> sudo apt-get install build-essential git valgrind cmake
```

这将确保您的操作系统具有适当的工具来编译和执行本教程中的示例。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行示例。

# 如何做...

执行以下步骤以完成本教程：

1.  从新的终端运行以下命令以下载源代码：

```cpp
> cd ~/
> git clone https://github.com/PacktPublishing/Advanced-CPP-CookBook.git
> cd Advanced-CPP-CookBook/chapter06
```

1.  要编译源代码，请运行以下命令：

```cpp
> cmake .
> make recipe03_examples
```

1.  源代码编译完成后，您可以通过运行以下命令来执行本教程中的每个示例：

```cpp
> ./recipe03_example01

> ./recipe03_example02

> ./recipe03_example03

> ./recipe03_example04

> ./recipe03_example05

> ./recipe03_example06

> ./recipe03_example07
```

在下一节中，我们将逐个步骤地介绍每个示例，并解释每个示例程序的作用以及它与本教程中所教授的课程的关系。

# 它是如何工作的...

在本教程中，我们将学习如何监视应用程序消耗的内存量，以及 C++在幕后分配内存的不同方式。首先，让我们看一个什么都不做的简单应用程序：

```cpp
int main(void)
{
}
```

如我们所见，这个应用程序什么也没做。要查看应用程序使用了多少内存，我们将使用动态分析工具 Valgrind，如下所示：

![](img/4b394af7-4501-4c48-bfd4-20e1f216d0de.png)

如前面的示例所示，我们的应用程序已经分配了堆内存（即使用`new()`/`delete()`或`malloc()`/`free()`分配的内存）。要确定此分配发生的位置，让我们再次使用 Valgrind，但这次我们将启用一个名为**Massif**的工具，它将跟踪内存分配的来源：

![](img/def07c68-3679-40b0-ae34-b2b5ebb1757c.png)

要查看上述示例的输出，我们必须输出一个为我们自动创建的文件：

```cpp
> cat massif.out.*
```

这导致我们检索到以下输出：

![](img/2434cd14-83e9-4761-b2d4-a3f3616eb879.png)

如我们所见，动态链接器的`init()`函数正在执行分配，大小为`72,704`字节。为了进一步演示如何使用 Valgrind，让我们看一个简单的例子，其中我们执行自己的分配：

```cpp
int main(void)
{
    auto ptr = new int;
    delete ptr;
}
```

要查看上述源代码的内存分配，我们需要再次运行 Valgrind：

![](img/5ca77107-fafd-479a-8c84-a660ea785dd3.png)

如我们所见，我们已经分配了`72,708`字节。由于我们知道应用程序将自动为我们分配`72,704`字节，我们可以看到 Valgrind 成功检测到我们分配的`4`字节（在运行 Linux 的 Intel 64 位系统上是整数的大小）。要查看此分配发生的位置，让我们再次使用 Massif：

![](img/d1b7826e-721d-44ad-8c3a-dbc55d4cc5e1.png)

正如我们所看到的，我们在命令行选项中添加了`--threshold=0.1`，这告诉 Valgrind 任何占`.1%`分配的分配都应该被记录。让我们`cat`一下结果（`cat`程序只是将文件的内容回显到控制台）：

```cpp
> cat massif.out.*
```

通过这样做，我们得到以下输出：

![](img/8e0189c6-c5a1-44bb-a848-4d752d4bee3a.png)

正如我们所看到的，Valgrind 检测到了`init()`函数和我们的`main()`函数的内存分配。

现在我们知道如何分析应用程序所做的内存分配，让我们看一些不同的 C++ API，看看它们在幕后做了什么类型的内存分配。首先，让我们看一个`std::vector`，如下所示：

```cpp
#include <vector>
std::vector<int> data;

int main(void)
{
    for (auto i = 0; i < 10000; i++) {
        data.push_back(i);
    }
}
```

在这里，我们创建了一个整数的全局向量，然后向向量添加了`10,000`个整数。使用 Valgrind，我们得到以下输出：

![](img/01e29595-e5db-4190-8321-93c0973e49cb.png)

在这里，我们可以看到有`16`次分配，总共`203,772`字节。我们知道应用程序将为我们分配`72,704`字节，所以我们必须从总数中去掉这部分，留下`131,068`字节的内存。我们还知道我们分配了`10,000`个整数，总共`40,000`字节。所以，问题是，其他`91,068`字节来自哪里？

答案在于`std::vector`在幕后的工作方式。`std::vector`必须始终确保内存的连续视图，这意味着当插入发生并且`std::vector`空间不足时，它必须分配一个新的更大的缓冲区，然后将旧缓冲区的内容复制到新缓冲区。问题在于`std::vector`不知道在所有插入完成时缓冲区的总大小，因此当执行第一次插入时，它创建一个小缓冲区以确保不浪费内存，然后以小增量增加`std::vector`的大小，导致多次内存分配和内存复制。

为了防止发生这种分配，C++提供了`reserve()`函数，该函数允许`std::vector`的用户估计他们认为他们将需要多少内存。例如，考虑以下代码：

```cpp
#include <vector>
std::vector<int> data;

int main(void)
{
    data.reserve(10000);  // <--- added optimization 

    for (auto i = 0; i < 10000; i++) {
        data.push_back(i);
    }
}
```

在前面的例子中，代码与之前的例子相同，唯一的区别是我们添加了对`reserve()`函数的调用，该函数告诉`std::vector`我们认为向量将有多大。Valgrind 的输出如下：

![](img/726ac6f0-8701-40ea-b53e-310902914389.png)

正如我们所看到的，应用程序分配了`112,704`字节。如果我们去掉应用程序默认创建的`72,704`字节，我们剩下`40,000`字节，这正是我们预期的大小（因为我们向向量添加了`10,000`个整数，每个整数的大小为`4`字节）。

数据结构不是 C++标准库 API 的唯一一种执行隐藏分配的类型。让我们看一个`std::any`，如下所示：

```cpp
#include <any>
#include <string>

std::any data;

int main(void)
{
    data = 42;
    data = std::string{"The answer is: 42"};
}
```

在这个例子中，我们创建了一个`std::any`，并将其分配给一个整数和一个`std::string`。让我们看一下 Valgrind 的输出：

![](img/56140dbb-bf2e-4670-82e2-15eb7134ce6d.png)

正如我们所看到的，发生了`3`次分配。第一次分配是默认发生的，而第二次分配是由`std::string`产生的。最后一次分配是由`std::any`产生的。这是因为`std::any`必须调整其内部存储以适应它看到的任何新的随机数据类型。换句话说，为了处理*通用*数据类型，C++必须执行分配。如果我们不断改变数据类型，情况会变得更糟。例如，考虑以下代码：

```cpp
#include <any>
#include <string>

std::any data;

int main(void)
{
    data = 42;
    data = std::string{"The answer is: 42"};
    data = 42;                                 // <--- keep swapping
    data = std::string{"The answer is: 42"};   // <--- keep swapping
    data = 42;                                 // <--- keep swapping
    data = std::string{"The answer is: 42"};   // ...
    data = 42;
    data = std::string{"The answer is: 42"};
}
```

前面的代码与之前的例子相同，唯一的区别是我们在不同的数据类型之间进行了交换。Valgrind 产生了以下输出：

![](img/1df2f995-397d-4929-adfd-d6847ce57abf.png)

正如我们所看到的，发生了`9`次分配，而不是`3`次。为了解决这个问题，我们需要使用`std::variant`而不是`std::any`，如下所示：

```cpp
#include <variant>
#include <string>

std::variant<int, std::string> data;

int main(void)
{
    data = 42;
    data = std::string{"The answer is: 42"};
}
```

`std::any`和`std::variant`之间的区别在于，`std::variant`要求用户声明变体必须支持的类型，从而在赋值时消除了动态内存分配的需要。Valgrind 的输出如下：

![](img/2a8432c6-3aa6-4f3e-9f2d-d83c733ea3d2.png)

现在，我们只有`2`个分配，正如预期的那样（默认分配和从`std::string`分配）。正如本教程所示，包括 C++标准库在内的库可以隐藏内存分配，可能会减慢代码速度并使用比预期更多的内存资源。诸如 Valgrind 之类的工具可以用于识别这些类型的问题，从而使您能够创建更高效的 C++代码。

# 声明 noexcept

C++11 引入了`noexcept`关键字，除了简化异常的一般使用方式外，还包括了更好的 C++异常实现，去除了一些性能损耗。但是，这并不意味着异常不包括*开销*（即性能惩罚）。在本教程中，我们将探讨异常如何给应用程序增加开销，以及`noexcept`关键字如何帮助减少这些惩罚（取决于编译器）。

本教程很重要，因为它将演示如果一个函数不会抛出异常，那么应该标记为`noexcept`，以防止额外的开销影响应用程序的总大小，从而导致应用程序加载更快。

# 准备工作

在开始之前，请确保已满足所有技术要求，包括安装 Ubuntu 18.04 或更高版本，并在终端窗口中运行以下命令：

```cpp
> sudo apt-get install build-essential git cmake
```

这将确保您的操作系统具有适当的工具来编译和执行本教程中的示例。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行我们的示例。

# 操作步骤...

执行以下步骤完成本教程：

1.  在新的终端中，运行以下命令以下载源代码：

```cpp
> cd ~/
> git clone https://github.com/PacktPublishing/Advanced-CPP-CookBook.git
> cd Advanced-CPP-CookBook/chapter06
```

1.  要编译源代码，请运行以下命令：

```cpp
> cmake .
> make recipe04_examples
```

1.  源代码编译完成后，可以通过运行以下命令来执行本教程中的每个示例：

```cpp
> ./recipe04_example01 

> ./recipe04_example02
```

在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本教程所教授的课程的关系。

# 工作原理

在本教程中，我们将学习为什么将函数标记为`noexcept`非常重要，如果它不应该抛出异常。这是因为它去除了对异常支持的额外开销，可以改善执行时间、应用程序大小，甚至加载时间（这取决于编译器、使用的标准库等）。为了证明这一点，让我们创建一个简单的示例：

```cpp
class myclass
{
    int answer;

public:
    ~myclass()
    {
        answer = 42;
    }
};
```

我们需要做的第一件事是创建一个类，在销毁时设置一个`private`成员变量，如下所示：

```cpp
void foo()
{
    throw 42;
}

int main(void) 
{
    myclass c;

    try {
        foo();
    }
    catch (...) {
    }
}
```

现在，我们可以创建两个函数。第一个函数抛出一个异常，而第二个函数是我们的主函数。这个函数创建了我们类的一个实例，并在`try`/`catch`块中调用`foo()`函数。换句话说，`main()`函数在任何时候都不会抛出异常。如果我们查看主函数的汇编代码，我们会看到以下内容：

![](img/e8b37484-b6b5-4a42-a49c-ace342254030.png)

正如我们所看到的，我们的主函数调用了`_Unwind_Resume`，这是异常解开器使用的。这额外的逻辑是因为 C++必须在函数末尾添加额外的异常逻辑。为了去除这额外的逻辑，告诉编译器`main()`函数不会抛出异常：

```cpp
int main(void) noexcept
{
    myclass c;

    try {
        foo();
    }
    catch (...) {
    }
}
```

添加`noexcept`告诉编译器不能抛出异常。结果，该函数不再包含处理异常的额外逻辑，如下所示：

![](img/b17102a6-7e31-4c82-8751-308a935b23f2.png)

正如我们所看到的，取消函数不再存在。值得注意的是，存在对 catch 函数的调用，这是由于`try`/`catch`块而不是异常的开销。
