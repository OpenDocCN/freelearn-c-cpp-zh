# 前言

欢迎来到 C++中的函数式编程实践之旅！这本书讲述了一个古老的概念，即函数式编程，以及一个经典的编程语言，即 C++，最终联合起来。

函数式编程自上世纪 50 年代以来就存在；然而，由于其数学基础，多年来一直对主流软件开发的兴趣有限。随着多核 CPU 和大数据的出现导致需要并行化，以及编程语言设计者对不可变性和 lambda 表达式的兴趣增加，函数式编程概念逐渐被引入到包括 C＃、Java、PHP、JavaScript、Python 和 Ruby 在内的所有主要编程语言中。C++一直与函数式编程息息相关，例如函数指针、函数对象和 STL 中的算法等功能使许多程序员能够利用某些构造。然而，从 C++ 11 开始，我们看到了 lambda 的引入，以及`all_of`、`any_of`和`none_of`等高阶函数的引入。在 C++ 17 中，我们看到了更多的进展，包括`map`（实现为`transform`）。此外，C++ 20 中的功能也非常令人兴奋；例如，允许可组合、轻量级和惰性评估转换的 ranges 库是标准库的一个重要补充。

这就引出了你将从本书中学到的内容。无论您是经验丰富的程序员还是 C++初学者，您都将学习有关函数式编程概念的知识，以及如何在 C++中使用它们，以及它们对管理和改进现有代码库的有用性。每个想法都将通过清晰的代码示例展示，并通过单元测试进行验证；我们强烈建议您拿这些代码示例来自己尝试一下。

我们特别努力确保每个想法都以清晰的方式呈现，并且遵循理解的流程；换句话说，我们一直在优化您的学习体验。为了做到这一点，我们决定夸大使用某些构造。例如，示例代码大量使用 lambda，因为我们想展示它们的用法。我们认为学习函数式编程的最佳方式是充分了解 lambda 和对 lambda 的操作。我们期望读者能够将这种方法与生产方法区分开；事实上，我建议您自己尝试这些概念，然后在生产代码的小部分上进行实验，然后再充分利用那些有前途的概念。为了支持这一目标，我们记录了多种使用函数操作的方法，这样您将拥有足够的工具来在各种情境下使用。

需要注意的是，我们经过深思熟虑决定在大部分书中使用 C++ 17 标准。我们不使用外部库（除了单元测试库），并且坚持使用语言和 STL 的标准功能。重点是函数式编程概念以及如何使用最简化的方法来实现它们。唯一的例外是书的最后一部分，它涉及 C++和 STL 的未来。我们这样做是因为我们认为让您理解这些概念并准备好以最少的工具应用它们比提供多种实现选项更重要。这在大部分书中省略了 ranges 库、Boost 库对函数式编程的支持，以及其他可能的有用库，可以扩展或简化代码。我将把尝试它们的机会留给读者，并让我们知道它们的效果如何。

# 这本书适合谁

这本书适用于已经了解 C++（包括语言语法、STL 容器和模板元素）并希望为自己的工具箱增添更多工具的程序员。您不需要了解任何有关函数式编程的知识来阅读本书；我们已经以清晰实用的方式解释了每个想法。

然而，您需要对来自函数式编程世界的工具集感到好奇。大量的实验将帮助您充分利用本书，因此我鼓励您尝试运行代码，并告诉我们您的发现。

# 本书涵盖的内容

第一章《函数式编程简介》向您介绍了函数式编程的基本思想。

第二章《理解纯函数》教会您函数式编程的基本构建块，即侧重于不变性的函数，以及如何在 C++中编写它们。

第三章《深入了解 Lambda 表达式》侧重于 Lambda 表达式以及如何在 C++中编写它们。

第四章《函数组合的概念》探讨了如何使用高阶操作组合函数。

第五章《部分应用和柯里化》教会您如何在 C++中使用函数的两个基本操作——部分应用和柯里化。

第六章《函数式思维-从数据到数据输出》向您介绍了另一种组织代码的方式，实现以函数为中心的设计。

第七章《使用功能操作消除重复》是对“不要重复自己”（DRY）原则、代码重复和相似性类型以及如何使用功能操作（如组合、部分应用和柯里化）编写更加 DRY 代码的概述。

第八章《使用类改善内聚性》演示了函数如何演变为类，以及如何将类转换为函数。

第九章《函数式编程的测试驱动开发》探讨了如何在函数式编程中使用测试驱动开发（TDD），以及不变性和纯函数如何简化测试。

第十章《性能优化》深入探讨了如何优化以函数为中心设计的性能的具体方法，包括记忆化、尾递归优化和并行执行。

第十一章《基于属性的测试》探讨了函数式编程如何实现编写自动化测试的新范式，通过数据生成增强了基于示例的测试。

第十二章《重构到和通过纯函数》解释了任何现有代码如何被重构为纯函数，然后再次转换为类，而风险最小。它还涉及经典设计模式和一些函数式设计模式。

第十三章《不变性和架构-事件溯源》解释了不变性可以在数据存储级别上移动，介绍了如何使用事件溯源，并讨论了它的优缺点。

第十四章《使用 Ranges 库进行惰性求值》深入研究了强大的 Ranges 库，并演示了如何在 C++ 17 和 C++ 20 中使用它。

第十五章《STL 支持和提案》介绍了 C++ 17 标准中的 STL 功能特性，以及 C++ 20 的一些有趣的补充。

第十六章，*标准语言支持和提案*，总结了函数式编程的基本构建块以及在 C++ 17 标准中使用它们的各种选项。

# 充分利用本书

本书假定您对 C++语法和基本 STL 容器有很好的了解。但是，它并不假定您对函数式编程、函数式构造、范畴论或数学有任何了解。我们已经非常努力地确保每个概念都以清晰的方式从实际的、以程序员为中心的角度进行解释。

我们强烈建议您在阅读章节后玩弄代码，或者在完成章节后尝试复制样本中的代码。更好的是，选择一个编码卡塔（例如，来自[`codingdojo.org/kata/`](http://codingdojo.org/kata/)）问题，并尝试使用本书中的技术来解决它。通过阅读和玩弄代码的结合，您将学到更多，而不仅仅是阅读理论。

本书中的大部分内容需要您以不同的方式思考代码结构，有时这与您习惯的方式相悖。然而，我们认为函数式编程是您工具箱中的另一个工具；它并不与您已经知道的知识相矛盾，而是为您提供了额外的工具来用于生产代码。何时以及如何使用它们是您的决定。

要运行本书中的代码示例，您将需要`g++`和`make`命令。或者，您可以使用支持 C++ 17 的任何编译器运行示例，但您需要手动运行每个文件。所有代码示例都可以使用`make`或`make [specific example]`进行编译和自动运行，并在控制台上提供输出，但有一些注意事项需要遵循。

来自第十章的内存优化示例，*性能优化*，需要使用`make allMemoryLogs`或特定目标运行，需要在每个目标运行后按键盘，将在`out/`文件夹中创建日志文件，显示进程分配内存的演变。这仅适用于 Linux 系统。

来自第十章的反应式编程示例，*性能优化*，需要用户输入。只需输入数字，程序将以反应式方式计算它们是否为质数。即使在计算过程中，程序也应该接收输入。来自第十六章的代码示例，*标准语言支持和提案*，需要支持 C++20 的编译器；目前使用`g++-8`。您需要单独安装`g++-8`。

# 下载示例代码文件

您可以从[www.packt.com](http://www.packt.com)的帐户中下载本书的示例代码文件。如果您在其他地方购买了本书，您可以访问[www.packt.com/support](http://www.packt.com/support)并注册，以便直接通过电子邮件接收文件。

您可以按照以下步骤下载代码文件：

1.  在[www.packt.com](http://www.packt.com)上登录或注册。

1.  选择“支持”选项卡。

1.  单击“代码下载和勘误”。

1.  在搜索框中输入书名，然后按照屏幕上的说明操作。

下载文件后，请确保使用最新版本的以下工具解压或提取文件夹：

+   Windows 的 WinRAR/7-Zip

+   Mac 的 Zipeg/iZip/UnRarX

+   Linux 的 7-Zip/PeaZip

该书的代码包也托管在 GitHub 上，网址为[`github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp`](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)。如果代码有更新，将在现有的 GitHub 存储库上进行更新。

我们还有其他代码包，来自我们丰富的图书和视频目录，可在**[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)**上找到。去看看吧！

# 代码实例

访问以下链接以查看代码的执行情况：

[`bit.ly/2ZPw0KH`](http://bit.ly/2ZPw0KH)

# 使用的约定

本书中使用了许多文本约定。

`CodeInText`：表示文本中的代码词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 句柄。以下是一个例子：“在 STL 中，它是用`find_if`函数实现的。让我们看看它的运行情况。”

一块代码设置如下：

```cpp
class Number{
    public:
        static int zero(){ return 0; }
        static int increment(const int value){ return value + 1; }
}
```

当我们希望引起您对代码块的特定部分的注意时，相关的行或项目将以粗体设置：

```cpp
First call: 1,367 ns < 16,281 ns
Second call: 58,045 ns < 890,056 ns Third call: 16,167 ns > 939 ns Fourth call: 1,334 ns > 798 ns
```

警告或重要说明看起来像这样。

提示和技巧看起来像这样。
