# 第一章

# Essential Features

《*极致 C*》是一本将为你提供开发和维护真实 C 应用程序所需的基本和高级知识的书籍。通常，仅了解一种编程语言的语法是不够的，用它来编写成功的程序——在 C 语言中，这一点比大多数其他语言更为重要。因此，我们将涵盖你编写 C 语言优秀软件所需的所有概念，从简单的单进程程序到更复杂的多进程系统。

这第一章主要关注你在编写 C 程序时会发现极其有用的 C 语言特定特性。这些特性涉及你在 C 语言编程中会经常遇到的情况。尽管有许多关于 C 编程的优秀书籍和教程，它们详细解释了所有内容，并涵盖了 C 语法的几乎所有方面，但在我们深入 C 语言之前，考虑一些关键特性将是有用的。

这些特性包括预处理指令、变量指针、函数指针和结构体。当然，在今天的更现代的编程语言中，这些特性很常见，也很容易在 Java、C#、Python 等语言中找到它们的对应物。例如，Java 中的*引用*可以被认为是与 C 语言中的变量指针相似元素。这些特性和它们相关的概念是如此基础，以至于没有它们，任何软件都无法继续工作，即使它能够被执行！甚至一个简单的“hello world”程序也无法在没有加载需要使用*函数指针*的多个共享库的情况下运行！

所以，无论何时你看到像交通信号灯、你汽车的中央电脑、厨房里的微波炉、你智能手机的操作系统，或者可能任何其他你通常不会去想的其他设备，它们都有用 C 语言编写的软件组件。

我们的生活今天受到了 C 编程语言的发明巨大影响，没有 C 语言，我们的世界将会非常不同。

本章主要关注编写专家级 C 代码所需的必要特性和机制，并包含了一组精选的特性，供我们深入研究。我们将探讨以下主题：

+   **预处理指令、宏和条件编译**：预处理是 C 语言中那些你在其他编程语言中难以找到的特性之一。预处理带来了许多优势，我们将深入探讨其中一些有趣的应用，包括*宏*和*条件指令*。

+   **变量指针**：本节将深入探讨*变量指针*及其用途。我们还将通过观察一些可能因滥用变量指针而引入的缺陷来获得一些有价值的见解。

+   **函数**：本章的这一部分深入探讨了关于函数的各个方面，而不仅仅是它们的语法。实际上，语法是最容易的部分！在本节中，我们将探讨函数作为编写*过程式*代码的构建块。本节还讨论了*函数调用机制*以及函数如何从调用函数接收其参数。

+   **函数指针**：毫无疑问，*函数指针*是 C 语言最重要的特性之一。函数指针是指向现有函数的指针，而不是指向变量。在算法设计中，能够存储指向现有逻辑的指针至关重要，这就是为什么我们专门有一个章节来介绍这个话题。函数指针在从加载动态库到*多态性*的广泛应用中都有出现，在接下来的几章中，我们还将看到更多关于函数指针的内容。

+   **结构体**：C 语言的结构体可能有简单的语法和传达简单的概念，但它们是编写*组织良好*和更*面向对象*的代码的主要构建块。它们的重要性，连同函数指针一起，绝对不能被高估！在本章的最后部分，我们将回顾关于 C 语言中结构体及其技巧的所有需要了解的内容。

C 语言的基本特性和它们周围的概念在 Unix 生态系统中扮演着关键角色，它们使得尽管 C 语言历史悠久且语法严格，C 语言仍然成为一个重要且具有影响力的技术。在接下来的章节中，我们将更多地讨论 C 语言和 Unix 之间的相互影响。现在，让我们从讨论预处理指令开始，开始这一章的学习。

在阅读本章之前，请记住你应该已经熟悉 C 语言。本章中的大多数例子都很简单，但强烈建议你在继续阅读其他章节之前了解 C 语言的语法。为了方便起见，以下是在继续阅读本书之前你应该熟悉的主题列表：

计算机体系结构的一般知识——你应该了解内存、CPU、外围设备及其特性，以及程序如何在计算机系统中与这些元素交互。

编程的一般知识——你应该了解算法是什么，其执行如何追踪，源代码是什么，二进制数是什么，以及它们相关的算术如何工作。

熟悉在类似 Linux 或 macOS 的 Unix 操作系统中使用终端和基本 shell 命令。

至少一种编程语言中关于编程主题的中级知识，如条件语句、不同类型的循环、结构或类，C 语言或 C++中的指针、函数等。

关于面向对象编程的基本知识——这不是强制性的，因为我们将在书中详细解释面向对象编程，但这样的知识将有助于你在阅读书的第三部分“面向对象”章节时更好地理解；*面向对象*。

# 预处理器指令

*预处理*是 C 中的一个强大特性。我们将在 *第二章*，*编译和链接* 中全面介绍它，但现在是时候定义预处理为一种允许你在提交给编译器之前对源代码进行工程化和修改的东西。这意味着与其他语言相比，C 的编译管道至少多了一步。在其他编程语言中，源代码会直接发送到编译器，但在 C 和 C++ 中，它应该先进行预处理。

这一步额外的操作使得 C（以及 C++）成为一门独特的编程语言，因为 C 程序员可以在提交给编译器之前有效地更改他们的源代码。这种特性在大多数高级编程语言中并不存在。

预处理的目的在于移除预处理指令，并用等效生成的 C 代码替换它们，准备一个最终可以提交给编译器的源代码。

可以使用一组 *指令* 来控制并影响 C 预处理器的行为。C 指令是以 `#` 字符开头的代码行，在头文件和源文件中都是如此。这些行只对 C 预处理器有意义，而对 C 编译器没有意义。C 中有各种指令，但其中一些非常重要，特别是用于宏定义的指令和用于条件编译的指令。

在下一节中，我们将解释宏并给出各种示例，以展示它们的多种用途。我们还将进一步分析它们，以找到它们的优缺点。

## 宏

关于 C 宏有很多传言。一种说法是它们会使你的源代码变得过于复杂且难以阅读。另一种说法是，如果你在代码中使用了宏，在调试应用程序时可能会遇到问题。你可能自己听到过一些这样的说法。但它们在多大程度上是有效的？宏是应该避免的邪恶吗？还是它们对你的项目有一些可以带来的好处？

事实上，你会在任何知名的 C 项目中找到宏。作为证明，下载一个知名的 C 项目，例如 Apache HTTP 服务器，并使用 `grep` 命令搜索 `#define`。你将看到一系列定义宏的文件。对于你作为一个 C 开发者来说，你无法避免宏。即使你自己不使用它们，你也可能会在其他人的代码中看到它们。因此，你需要了解它们是什么以及如何处理它们。

`grep` 命令指的是 Unix 类操作系统中的一个标准壳工具程序，它会在字符流中搜索一个模式。它可以用来在给定路径下找到的所有文件的 内容中搜索文本或模式。

宏有多个应用，以下是一些示例：

+   定义一个常量

+   使用函数而不是编写 C 函数

+   循环展开

+   头文件保护

+   代码生成

+   条件编译

尽管宏有更多可能的用途，我们将在接下来的几节中关注上述内容。

### 定义一个宏

宏使用 `#define` 指令定义。每个宏都有一个名称和一个可能的参数列表。它还有一个 *值*，在预处理阶段通过称为 *宏展开* 的步骤用其 *名称* 替换。也可以使用 `#undef` 指令 *取消定义* 宏。让我们从一个简单的例子开始，*示例 1.1*：

```cpp
#define ABC 5
int main(int argc, char** argv) {
  int x = 2;
  int y = ABC;
  int z = x + y;
  return 0;
}
```

代码框 1-1 [ExtremeC_examples_chapter1_1.c]：定义一个宏

在先前的代码框中，`ABC` 不是一个持有整数值的变量，也不是一个整型常量。实际上，它是一个名为 `ABC` 的宏，其对应的值是 `5`。在宏展开阶段之后，可以提交给 C 编译器的结果代码看起来如下：

```cpp
int main(int argc, char** argv) {
  int x = 2;
  int y = 5;
  int z = x + y;
  return 0;
}
```

代码框 1-2：示例 1.1 在宏展开阶段生成的代码

*代码框 1-2* 中的代码具有有效的 C 语法，现在编译器可以继续并编译它。在先前的例子中，预处理器执行了宏展开，作为其中的一部分，预处理器简单地用宏的值替换了宏的名称。预处理器还删除了开头几行的注释。

现在我们来看另一个示例，*示例 1.2*：

```cpp
#define ADD(a, b) a + b
int main(int argc, char** argv) {
  int x = 2;
  int y = 3;
  int z = ADD(x, y);
  return 0;
}
```

代码框 1-3 [ExtremeC_examples_chapter1_2.c]：定义一个函数式宏

在先前的代码框中，类似于 *示例 1.1*，`ADD` 不是一个函数。它只是一个接受参数的 *函数式宏*。预处理之后，生成的代码将如下所示：

```cpp
int main(int argc, char** argv) {
  int x = 2;
  int y = 3
  int z = x + y;
  return 0;
}
```

代码框 1-4：预处理和宏展开后的示例 1.2

如您在先前的代码框中看到的，所发生的展开如下。用作参数 `a` 的参数 `x` 被替换为宏值中所有 `a` 的实例。对于参数 `b` 和其对应的参数 `y` 也是如此。然后，进行最终替换，我们在预处理的代码中得到 `x + y` 而不是 `ADD(a, b)`。

由于函数式宏可以接受输入参数，它们可以模仿 C 函数。换句话说，您可以将频繁使用的逻辑命名为函数式宏，并使用该宏代替 C 函数。

这样，宏的出现将被频繁使用的逻辑替换，作为预处理阶段的一部分，无需引入新的 C 函数。我们将在后面进一步讨论这一点，并比较两种方法。

宏只存在于编译阶段之前。这意味着理论上，编译器对宏一无所知。如果你打算使用宏而不是函数，这是一个非常重要的要点。编译器对函数了如指掌，因为它是 C 语法的一部分，并且被解析并保存在 *解析树* 中。但宏只是 C 预处理器指令，只有预处理器本身知道。

宏允许你在编译之前 *生成* 代码。在其他编程语言，如 Java 中，你需要使用 *代码生成器* 来完成这个目的。我们将给出关于宏这一应用的例子。

现代 C 编译器了解 C 预处理器指令。尽管普遍认为它们对预处理阶段一无所知，但实际上并非如此。现代 C 编译器在进入预处理阶段之前就了解源代码。看看以下代码：

```cpp
#include <stdio.h>
#define CODE \
printf("%d\n", i);
int main(int argc, char** argv) {
 CODE
 return 0;
}
```

代码框 1-5 [example.c]：导致未声明的标识符错误的宏定义

如果你使用 macOS 中的`clang`编译上述代码，输出将会是：

```cpp
$ clang example.c
code.c:7:3: error: use of undeclared identifier 'i'
CODE
^
code.c:4:16: note: expanded from macro 'CODE'
printf("%d\n", i);
               ^
1 error generated.
$
```

命令行框 1-1：编译输出的结果引用了宏定义

正如你所见，编译器生成了一条错误信息，它精确地指向了宏定义所在的行。

作为旁注，在大多数现代编译器中，你可以在编译前查看预处理结果。例如，当使用`gcc`或`clang`时，你可以使用`-E`选项来输出预处理后的代码。以下命令行框演示了如何使用`-E`选项。请注意，输出并未完全显示：

```cpp
$ clang -E example.c
# 1 "sample.c"# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 361 "<built-in>" 3
...
# 412 "/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h" 2 3 4
# 2 "sample.c" 2
...
int main(int argc, char** argv) {
 printf("%d\n", i);
 return 0;
}
$
```

命令行框 1-2：预处理阶段后的 example.c 代码

现在我们来定义一个重要的概念。一个 *翻译单元*（或一个 *编译单元*）是经过预处理的 C 代码，它已经准备好传递给编译器。

在翻译单元中，所有指令都被替换为包含或宏展开，生成了一段平坦的长 C 代码。

既然你对宏有了更多的了解，让我们来处理一些更复杂的例子。它们将展示宏的强大和危险之处。在我看来，极端的开发方式以熟练的方式处理危险和微妙的事物，这正是 C 语言的核心所在。

下一个例子很有趣。请注意宏是如何按顺序使用来生成循环的：

```cpp
#include <stdio.h>
#define PRINT(a) printf("%d\n", a);
#define LOOP(v, s, e) for (int v = s; v <= e; v++) {
#define ENDLOOP }
int main(int argc, char** argv) {
 LOOP(counter, 1, 10)
 PRINT(counter)
 ENDLOOP
  return 0;
}
```

代码框 1-6 [ExtremeC_examples_chapter1_3.c]：使用宏生成循环

正如你在前面的代码框中看到的，`main`函数内部的代码在任何方面都不是有效的 C 代码！但在预处理之后，我们得到了一个正确的 C 源代码，它可以无问题地编译。以下是预处理的结果：

```cpp
...
... content of stdio.h …
...
int main(int argc, char** argv) {
  for (int counter = 1; counter <= 10; counter++) {
    printf("%d\n", counter);
  }
  return 0;
}
```

代码框 1-7：预处理阶段后的示例 1.3

在 *代码框 1-6* 的 `main` 函数中，我们只是使用了一组不同且看起来不像 C 的指令来编写我们的算法。然后预处理后，在 *代码框 1-7* 中，我们得到了一个完全功能且正确的 C 程序。这是宏的一个重要应用；定义一个新的 **领域特定语言** (**DSL**) 并使用它来编写代码。

DSLs 在项目的不同部分非常有用；例如，它们在测试框架（如 Google Test 框架（gtest））中被大量使用，其中 DSL 用于编写断言、期望和测试场景。

我们应该注意，在最终的预处理器代码中我们没有任何 C 指令。这意味着 *代码框 1-6* 中的 `#include` 指令已被它所引用的文件的内容所替换。这就是为什么你在 *代码框 1-7* 中的 `main` 函数之前看到了 `stdio.h` 头文件的内容（我们用省略号替换了它）。

让我们现在看看下一个示例，*示例 1.4*，它介绍了关于宏参数的两个新运算符；`#` 和 `##` 运算符：

```cpp
#include <stdio.h>
#include <string.h>
#define CMD(NAME) \
 char NAME ## _cmd[256]  = ""; \
 strcpy(NAME ## _cmd, #NAME);
int main(int argc, char** argv) {
 CMD(copy)
 CMD(paste)
 CMD(cut)
  char cmd[256];
  scanf("%s", cmd);
  if (strcmp(cmd, copy_cmd) == 0) {
    // ...
  }
  if (strcmp(cmd, paste_cmd) == 0) {
    // ...
  }
  if (strcmp(cmd, cut_cmd) == 0) {
    // ...
  }
  return 0;
}
```

代码框 1-8 [ExtremeC_examples_chapter1_4.c]：在宏中使用 # 和 ## 运算符

在扩展宏时，`#` 运算符将参数转换为带有引号的字符串形式。例如，在上面的代码中，`#` 运算符在 `NAME` 参数之前使用，将其转换为预处理器代码中的 `"copy"`。

`##` 运算符有不同的含义。它只是将参数连接到宏定义中的其他元素，并通常形成变量名。以下是 *示例 1.4* 的最终预处理器源代码：

```cpp
...
... content of stdio.h ...
...
... content of string.h ...
...
int main(int argc, char** argv) {
  char copy_cmd[256] = ""; strcpy(copy_cmd, "copy");
  char paste_cmd[256] = ""; strcpy(paste_cmd, "paste");
  char cut_cmd[256] = ""; strcpy(cut_cmd, "cut");
  char cmd[256];
  scanf("%s", cmd);
  if (strcmp(cmd, copy_cmd) == 0) {
  }
  if (strcmp(cmd, paste_cmd) == 0) {
  }
  if (strcmp(cmd, cut_cmd) == 0) {
  }
  return 0;
}
```

代码框 1-9：预处理阶段后的示例 1.4

比较预处理前后的源代码有助于你理解 `#` 和 `##` 运算符是如何应用于宏参数的。请注意，在最终的预处理器代码中，从同一宏定义扩展的所有行都在同一行上。

将长宏拆分成多行是一个好的实践，但不要忘记使用 \ (一个反斜杠) 来让预处理器知道定义的其余部分将在下一行。请注意，\ 不会替换为 *换行符*。相反，它是一个指示符，表示下一行是同一宏定义的延续。

现在让我们讨论不同类型的宏。下一节将讨论可以接受可变数量参数的 *可变参数宏*。

### 可变参数宏

下一个示例，*示例 1.5*，是关于可变参数宏的，它可以接受可变数量的输入参数。有时同一个可变参数宏接受 2 个参数，有时接受 4 个参数，有时接受 7 个。当不确定同一个宏的不同用法中参数的数量时，可变参数宏非常方便。以下是一个简单的示例：

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define VERSION "2.3.4"
#define LOG_ERROR(format, ...) \
 fprintf(stderr, format, __VA_ARGS__)
int main(int argc, char** argv) {
  if (argc < 3) {
 LOG_ERROR("Invalid number of arguments for version %s\n.", VERSION);
    exit(1);
  }
  if (strcmp(argv[1], "-n") != 0) {
 LOG_ERROR("%s is a wrong param at index %d for version %s.", argv[1], 1, VERSION);
    exit(1);
  }
  // ...
  return 0;
}
```

代码框 1-10 [ExtremeC_examples_chapter1_5.c]：可变宏的定义和用法

在前面的代码框中，你看到了一个新的标识符：`__VA_ARGS__`。这是一个指示符，告诉预处理器用所有尚未分配给任何参数的剩余输入参数来替换它。

在前面的示例中，在第二次使用 `LOG_ERROR` 时，根据宏定义，参数 `argv[1]`、`1` 和 `VERSION` 是那些尚未分配给任何参数的输入参数。因此，它们将在宏展开时用来代替 `__VA_ARGS__`。

作为旁注，函数 `fprintf` 将内容写入 *文件描述符*。在 *示例 1.5* 中，文件描述符是 `stderr`，它是进程的 *错误流*。注意每个 `LOG_ERROR` 使用后的分号结束。这是强制性的，因为宏在其定义中不提供这些分号，程序员 *必须* 添加这个分号以使最终预处理的代码在语法上正确。

以下代码是通过 C 预处理器处理后的最终输出：

```cpp
...
... content of stdio.h ...
...
... content of stdlib.h ...
...
... content of string.h ...
...
int main(int argc, char** argv) {
  if (argc < 3) {
    fprintf(stderr, "Invalid number of arguments for version %s\n.", "2.3.4");
    exit(1);
  }
  if (strcmp(argv[1], "-n") != 0) {
    fprintf(stderr, "%s is a wrong param at index %d for version %s.", argv[1], 1, "2.3.4");
    exit(1);
  }
  // ...
  return 0;
}
```

代码框 1-11：预处理阶段后的示例 1.5

下一个示例，*示例 1.6*，是变长宏的渐进式使用，试图模拟循环。关于这一点有一个著名的例子。在 C++ 有 `foreach` 之前，*boost* 框架（现在仍然如此）通过一系列宏提供 `foreach` 行为。

在以下链接中，你可以看到 `BOOST_FOREACH` 宏是如何在头文件中定义的：[`www.boost.org/doc/libs/1_35_0/boost/foreach.hpp`](https://www.boost.org/doc/libs/1_35_0/boost/foreach.hpp)。它用于遍历 boost 集合，实际上是一个函数式宏。

我们接下来的示例，*示例 1.6*，是关于一个简单的循环，它与 boost 的 `foreach` 完全不可比，但仍然，它给你提供了一个如何使用变长宏重复一系列指令的思路：

```cpp
#include <stdio.h>
#define LOOP_3(X, ...) \
 printf("%s\n", #X);
#define LOOP_2(X, ...) \
 printf("%s\n", #X); \
 LOOP_3(__VA_ARGS__)
#define LOOP_1(X, ...) \
 printf("%s\n", #X); \
 LOOP_2(__VA_ARGS__)
#define LOOP(...) \
 LOOP_1(__VA_ARGS__)
int main(int argc, char** argv) {
 LOOP(copy paste cut)
 LOOP(copy, paste, cut)
 LOOP(copy, paste, cut, select)
  return 0;
}
```

代码框 1-12 [ExtremeC_examples_chapter1_6.c]：使用变长宏模拟循环

在开始解释示例之前，让我们看看预处理后的最终代码。然后，对发生了什么进行解释将会更容易：

```cpp
...
... content of stdio.h ...
...
int main(int argc, char** argv) {
  printf("%s\n", "copy paste cut"); printf("%s\n", ""); printf("%s\n", "");
  printf("%s\n", "copy"); printf("%s\n", "paste"); printf("%s\n", "cut");
  printf("%s\n", "copy"); printf("%s\n", "paste"); printf("%s\n", "cut");
  return 0;
}
```

代码框 1-13：预处理阶段后的示例 1.6

如果你仔细查看预处理后的代码，你会看到 `LOOP` 宏已经被展开为多个 `printf` 指令，而不是 `for` 或 `while` 这样的循环指令。很明显为什么是这样，这是因为预处理器不会为我们编写智能的 C 代码。它的作用是将宏替换为我们提供的指令。

使用宏创建循环的唯一方法是将迭代指令一个接一个地放置，作为一些独立的指令。这意味着一个简单的宏循环，有 1000 次迭代，将在 C 中被替换为 1000 条指令，我们最终代码中不会有任何实际的 C 循环。

前面的技术会导致二进制文件大小增大，这可以被视为一个缺点。但将指令一个接一个地放置，而不是将它们放入循环中，这被称为*循环展开*，有其自身的应用，这些应用需要在受限和性能要求高的环境中达到可接受的性能水平。根据我们到目前为止所解释的，似乎使用宏进行循环展开是在二进制大小和性能之间的一种权衡。我们将在下一节中更多地讨论这个问题。

关于前面示例的另一个注意事项。正如你所见，`main`函数中`LOOP`宏的不同用法产生了不同的结果。在第一次使用中，我们传递了`copy paste cut`，单词之间没有逗号。预处理程序将其接受为单个输入，因此模拟循环只有一个迭代。

在第二次使用中，输入`copy, paste, cut`通过逗号分隔单词传递。现在，预处理程序将它们视为三个不同的参数；因此，模拟循环有三个迭代。这可以从下面的*Shell Box 1-3*中清楚地看出。

在第三次使用中，我们传递了四个值，`copy, paste, cut, select,`但只有三个被处理。正如你所见，预处理代码与第二次使用完全相同。这是因为我们的循环宏只能处理最多三个元素的列表。超过第三个的额外元素将被忽略。

注意，这不会产生编译错误，因为没有生成任何错误的最终 C 代码，但我们的宏在处理元素的数量上有限制：

```cpp
$ gcc ExtremeC_examples_chapter1_6.c
$ ./a.out
copy paste cut
copy
paste
cut
$
```

Shell Box 1-3：示例 1.6 的编译和输出

### 宏的优缺点

让我们从讨论软件设计开始，稍微谈谈宏的定义和组合。这既是一门艺术，有时也是一种上瘾的行为！你甚至在没有定义任何宏之前，就在脑海中开始构建预期的预处理代码，并基于此来定义你的宏。由于这是一种复制代码并与之玩耍的简单方法，因此可能会过度使用。过度使用宏可能对你来说不是大问题，但可能对你的队友来说却是。但为什么是这样呢？

宏有一个重要的特性。如果你在宏中编写某些内容，它们将在编译阶段之前被其他代码行替换，最终你将得到一段没有模块性的平坦长代码。当然，你在心中和可能在你的宏中拥有模块性，但在你的最终二进制文件中并不存在。这正是使用宏可能开始引起设计问题的原因。

软件设计试图将类似的算法和概念打包成几个可管理的和可重用的*模块*，但宏试图使一切线性化和扁平化。因此，当你将宏作为软件设计中的某些逻辑构建块使用时，它们的信息可能会在预处理阶段丢失，成为最终翻译单元的一部分。这就是为什么架构师和设计师会使用关于宏的经验法则：

> 如果可以将宏写成 C 函数，那么你应该写一个 C 函数而不是宏！

从调试的角度来看，再次强调，宏被认为是有害的。开发者使用编译错误来查找日常开发任务中存在的*语法错误*的位置。他们还使用*日志*和可能*编译警告*来检测错误并修复它。编译错误和警告都对错误分析流程有益，并且都是由编译器生成的。

关于宏，尤其是对于旧的 C 编译器，编译器对宏一无所知，它将编译源代码（翻译单元）视为一段长、线性、扁平的代码。因此，对于查看带有宏的实际 C 代码的开发者和查看没有宏的预处理代码的 C 编译器来说，存在两个不同的世界。所以，开发者很难理解编译器报告的内容。

希望借助我们现代的 C 编译器，这个问题已经不再那么严重了。如今，著名的 C 编译器如`gcc`和`clang`对预处理阶段有了更深入的了解，并且它们会尽量保持、使用并报告开发者所看到的源代码。否则，宏的问题可能会通过`#include`指令重复出现，简单来说，因为翻译单元的主要内容只有在所有包含发生之后才会被知晓。因此，我们可以得出结论，调试问题没有我们之前段落中提到的软件设计问题那么严重。

如果你还记得，我们在解释*示例 1.6*时提出过一次讨论。这是关于程序的二进制大小和性能之间的权衡。这种权衡的更一般形式是在单个大二进制和多个小二进制之间。它们都提供相同的功能，但前者可能会有更好的性能。

在一个项目中使用的二进制文件数量，尤其是在项目很大时，或多或少与*模块化*的程度和投入的设计努力成正比。例如，一个拥有 60 个库（共享或静态）和一个可执行文件的项目似乎是根据一个软件计划开发的，该计划将依赖关系拆分成多个库，并在单个主可执行文件中使用它们。

换句话说，当一个项目根据软件设计原则和最佳实践进行开发时，二进制文件的数量和大小会经过精心设计，通常将由多个轻量级二进制文件组成，这些二进制文件具有适用的最小大小，而不是只有一个庞大的二进制文件。

软件设计试图将每个软件组件放置在一个巨大的层次结构中的合适位置，而不是将它们按线性顺序排列。尽管在大多数情况下其对性能的影响很小，但这种做法本质上与性能相悖。

因此，我们可以得出结论，关于*示例 1.6*的讨论是关于设计和性能之间的权衡。当你需要性能时，有时你需要牺牲设计，将事物置于线性构造中。例如，你可以避免循环，并使用*循环展开*。

从另一个角度来看，性能始于在设计阶段定义的问题中选择合适的算法。接下来的步骤通常被称为*优化*或*性能调整*。在这个阶段，获得性能等同于让 CPU 以线性且顺序的方式计算，而不是强迫它在不同部分的代码之间跳跃。这可以通过修改已经使用的算法或用一些性能更好且通常更复杂的算法来替换它们来实现。这个阶段可能会与设计哲学发生冲突。正如我们之前所说的，设计试图将事物置于层次结构中并使其非线性，但 CPU 期望事物是线性的，已经取出的并且准备好被处理。因此，这种权衡应该针对每个问题单独处理和平衡。

让我们更详细地解释一下循环展开。这项技术主要在嵌入式开发中使用，尤其是在处理能力有限的环境中。其技术是通过移除循环，使它们线性化，以提高性能并避免在迭代过程中产生循环开销。

这正是我们在*示例 1.6*中所做的；我们使用宏模拟了一个循环，这导致了一系列线性指令。从这个意义上说，我们可以说宏可以用于嵌入式开发中的性能调整，以及在指令执行方式的一点点改变就能带来显著性能提升的环境中。更重要的是，宏可以使代码更具可读性，我们可以提取重复的指令。

关于之前提到的那个说宏应该被等效的 C 函数替换的引用，我们知道这个引用是为了设计而存在的，在某些情况下可以忽略。在一个性能提升是关键要求的上下文中，有一系列线性指令可以带来更好的性能，这可能是必要的。

代码生成是宏的另一个常见应用。它们可以用于将 DSL 引入项目中。*Microsoft MFC*、*Qt*、*Linux Kernel* 和 *wxWidgets* 是成千上万个使用宏来定义他们自己的 DSL 的项目中的几个。大多数是 C++ 项目，但它们使用这个 C 特性来简化他们的 API。

作为结论，如果调查并了解其预处理形式的影响，C 宏可以具有优势。如果你在一个团队项目中工作，总是要分享你在团队中关于宏使用的决策，并确保自己与团队做出的决策保持一致。

## 条件编译

条件编译是 C 的另一个独特特性。它允许你根据不同的条件拥有不同的预处理源代码。尽管它暗示的意义，编译器并没有进行任何条件操作，但传递给编译器的预处理代码可以根据一些指定的条件而不同。这些条件是在准备预处理代码时由预处理器评估的。有不同指令有助于条件编译。你可以看到以下列表：

+   `#ifdef`

+   `#ifndef`

+   `#else`

+   `#elif`

+   `#endif`

以下示例，*示例 1.7*，展示了这些指令的基本用法：

```cpp
#define CONDITION
int main(int argc, char** argv) {
#ifdef CONDITION
  int i = 0;
  i++;
#endif
  int j= 0;
  return 0;
}
```

代码框 1-14 [ExtremeC_examples_chapter1_7.c]：条件编译的示例

在预处理前面的代码时，预处理器看到 `CONDITION` 宏的定义并将其标记为已定义。请注意，没有为 `CONDITION` 宏提出任何值，这是完全有效的。然后，预处理器继续向下直到它到达 `#ifdef` 语句。由于 `CONDITION` 宏已经定义，`#ifdef` 和 `#endif` 之间的所有行都将复制到最终源代码中。

你可以在下面的代码框中看到预处理后的代码：

```cpp
int main(int argc, char** argv) {
  int i = 0;
  i++;
  int j= 0;
  return 0;
}
```

代码框 1-15：预处理阶段后的示例 1.7

如果宏未定义，我们就不会看到任何 `#if-#endif` 指令的替换。因此，预处理后的代码可能如下所示：

```cpp
int main(int argc, char** argv) {
  int j= 0;
  return 0;
}
```

代码框 1-16：预处理阶段后的示例 1.7，假设 `CONDITION` 宏未定义

注意到在代码框 *1-15* 和 *1-16* 中保留的空行，这些空行是在预处理阶段，将 `#ifdef-#endif` 部分替换为其评估值后留下的。

可以使用传递给编译命令的 `-D` 选项来定义宏。关于前面的例子，我们可以如下定义 `CONDITION` 宏：

```cpp
$ gcc -DCONDITION -E main.c
```

这是一个很棒的特性，因为它允许你在源代码之外定义宏。这在只有一个源代码但需要为不同的架构编译它时特别有用，例如 Linux 或 macOS，它们有不同的默认宏定义和库。

`#ifndef`的一个非常常见的用法是作为*头文件保护*语句。这个语句保护头文件在预处理阶段不被重复包含，我们可以说几乎每个项目中几乎所有 C 和 C++的头文件都将这个语句作为它们的第一个指令。

以下代码，*示例 1.8*，展示了如何使用头文件保护语句。假设这是头文件的内容，并且意外地在一个编译单元中被包含两次。请注意，*示例 1.8*只是一个头文件，它不应该被编译：

```cpp
#ifndef EXAMPLE_1_8_H
#define EXAMPLE_1_8_H
void say_hello();
int read_age();
#endif
```

代码框 1-17 [ExtremeC_examples_chapter1_8.h]：头文件保护器的示例

正如你所见，所有变量和函数声明都放在`#ifndef`和`#endif`对之间，并且通过宏来防止多次包含。在下一段中，我们将解释如何做到这一点。

当第一次包含发生时，`EXAMPLE_1_8_H`宏尚未定义，因此预处理器继续进入`#ifndef-#endif`块。下一个语句定义了`EXAMPLE_1_8_H`宏，预处理器将所有内容复制到预处理的代码中，直到它达到`#endif`指令。当第二次包含发生时，`EXAMPLE_1_8_H`宏已经定义，因此预处理器跳过`#ifndef-#endif`部分内的所有内容，并移动到`#endif`之后的下一个语句（如果有的话）。

将整个头文件内容放在`#ifndef-#endif`对之间是一种常见的做法，除了注释外，外部不留下任何内容。

在本节的最后一点，为了避免`#ifndef-#endif`指令对，可以使用`#pragma once`来保护头文件免受双重包含问题的影响。条件指令与`#pragma once`指令的区别在于，尽管它被几乎所有 C 预处理器支持，但它并不是 C 标准的一部分。然而，如果你的代码需要*可移植性*，最好不要使用它。

以下代码框包含了一个如何在使用`#pragma once`指令而不是`#ifndef-#endif`指令的*示例 1.8*中的演示：

```cpp
#pragma once
void say_hello();
int read_age();
```

代码框 1-18：在示例 1.8 中使用 #pragma once 指令

现在，我们已经展示了预处理指令的一些有趣特性和各种应用，我们将关闭预处理指令这一主题。下一节将介绍变量指针，这是 C 语言的另一个重要特性。

# 变量指针

变量指针的概念，或简称为指针，是 C 语言中最基本的概念之一。在大多数高级编程语言中，你几乎找不到它们的直接迹象。实际上，它们已经被一些双胞胎概念所取代，例如 Java 中的*引用*。值得注意的是，指针的独特之处在于它们所指向的地址可以直接由硬件使用，而高级的双胞胎概念如引用则不是这样。

深入理解指针及其工作方式对于成为一名熟练的 C 程序员至关重要。它们是内存管理中最基本的概念之一，尽管它们的语法很简单，但使用不当可能会导致灾难。我们将在*第四章*，*进程内存结构*和*第五章*，*栈和堆*中涵盖与内存管理相关的主题，但在这里本章中，我们想要回顾关于指针的所有内容。如果你对指针的基本术语和概念感到自信，你可以跳过这一节。

## 语法

任何类型的指针背后的思想非常简单；它只是一个简单的变量，用于保存一个*内存地址*。你可能会首先想起它们中的星号字符，`*`，在 C 语言中用于声明指针。你可以在*示例 1.9*中看到它。下面的代码框演示了如何声明和使用变量指针：

```cpp
int main(int argc, char** argv) {
  int var = 100;
  int* ptr = 0;
  ptr = &var;
  *ptr = 200;
  return 0;
}
```

代码框 1-19 [ExtremeC_examples_chapter1_9.c]: C 语言中声明和使用指针的示例

上述示例包含了你需要了解的所有关于指针语法的知识。第一行在*栈段*上声明了`var`变量。我们将在*第四章*，*进程内存结构*中讨论栈段。第二行声明了初始值为零的指针`ptr`。具有零值的指针称为*空指针*。只要`ptr`指针保持其零值，它就被认为是空指针。如果你在声明时不打算存储有效的地址，那么*置空*指针非常重要。

正如你在*代码框 1-19*中看到的，没有包含任何头文件。指针是 C 语言的一部分，你不需要包含任何内容就能使用它们。实际上，我们可以有完全不包含任何头文件的 C 程序。

以下所有声明在 C 语言中都是有效的：

`int* ptr = 0;`

`int * ptr = 0;`

`int *ptr = 0;`

`main`函数中的第三行引入了`&`操作符，称为*引用操作符*。它返回其旁边变量的地址。我们需要这个操作符来获取变量的地址。否则，我们无法用有效的地址初始化指针。

同样地，返回的地址被存储到`ptr`指针中。现在，`ptr`指针不再是空指针了。在第四行，我们看到指针之前还有一个操作符，称为*解引用操作符*，表示为`*`。这个操作符允许你间接访问`ptr`指针所指向的内存单元。换句话说，它允许你通过指向它的指针来读取和修改`var`变量。第四行等价于`var = 200;`语句。

空指针不指向有效的内存地址。因此，解引用空指针*必须*避免，因为这被认为是*未定义行为*，通常会导致崩溃。

关于前面的示例的最后一句话，我们通常将默认宏 `NULL` 定义为值 `0`，并且可以在声明时用来使指针无效。使用这个宏而不是直接使用 `0` 是一个好习惯，因为它 使得区分变量和指针更容易：

```cpp
char* ptr = NULL;
```

代码框 1-20：使用 NULL 宏来使指针无效

C++ 中的指针与 C 中的完全相同。它们需要通过在其中存储 `0` 或 `NULL` 来使它们无效，但 C++11 有一个用于初始化指针的新关键字。它既不是像 `NULL` 这样的宏，也不是像 `0` 这样的整数。这个关键字是 `nullptr`，可以用来使指针无效或检查它们是否为空。以下示例演示了它在 C++11 中的用法：

```cpp
char* ptr = nullptr;
```

代码框 1-21：在 C++11 中使用 nullptr 使指针无效

记住这一点至关重要，指针 *必须* 在声明时初始化。如果你在声明时不希望存储任何有效的内存地址，不要让它们保持未初始化状态。通过分配 `0` 或 `NULL!` 来使其为空。否则，你可能会遇到致命的错误！

在大多数现代编译器中，未初始化的指针总是被置为空。这意味着所有未初始化的指针的初始值都是 `0`。但这不应被视为不正确初始化指针的借口。记住，你正在为不同的架构编写代码，新旧架构，这可能在旧系统上引起问题。此外，你将在大多数 *内存分析器* 中为这些类型的未初始化指针获得错误和警告列表。内存分析器将在 *第四章*，*进程内存结构* 和 *第五章*，*栈和堆* 中详细解释。

## 变量指针的算术运算

内存最简单的图景是一个非常长的单维字节数组。带着这个图景，如果你站在一个字节上，你只能在数组中前后移动；没有其他可能的移动。所以，这也会适用于指向内存中不同字节的指针。增加指针会使指针向前移动，而减少它会使指针向后移动。指针不可能进行其他算术运算。

正如我们之前所说的，指针上的算术运算与字节数组中的移动类似。我们可以用这个图来介绍一个新概念：*算术步长*。我们需要这个新概念，因为当你将指针增加 1 时，它可能在内存中向前移动超过 1 个字节。每个指针都有一个算术步长，这意味着如果指针增加或减少 1，它将移动的字节数。这个算术步长由指针的 C *数据类型* 决定。

在每个平台上，我们只有一个单一的内存单元，所有指针都存储在该内存中的地址。因此，从字节大小来看，所有指针应该具有相同的大小。但这并不意味着它们的算术步长都相同。正如我们之前提到的，指针的算术步长由其 C 数据类型决定。

例如，`int` 指针的大小与 `char` 指针相同，但它们的算术步长不同。`int*` 通常具有 4 字节的算术步长，而 `char*` 具有字节的算术步长。因此，增加整数指针会使它在内存中向前移动 4 字节（将 4 字节添加到当前地址），而增加字符指针只会使它在内存中向前移动 1 字节。以下示例，*示例 1.10*，演示了两种不同数据类型的两个指针的算术步长：

```cpp
#include <stdio.h>
int main(int argc, char** argv) {
  int var = 1;
  int* int_ptr = NULL; // nullify the pointer
  int_ptr = &var;
  char* char_ptr = NULL;
  char_ptr = (char*)&var;
  printf("Before arithmetic: int_ptr: %u, char_ptr: %u\n",
          (unsigned int)int_ptr, (unsigned int)char_ptr);
  int_ptr++;    // Arithmetic step is usually 4 bytes
  char_ptr++;   // Arithmetic step in 1 byte
  printf("After arithmetic: int_ptr: %u, char_ptr: %u\n",
          (unsigned int)int_ptr, (unsigned int)char_ptr);
  return 0;
}
```

代码框 1-22 [ExtremeC_examples_chapter1_10.c]: 两个指针的算术步长

以下 shell 框显示 *示例 1.10* 的输出。请注意，在同一台机器上连续两次运行可能打印不同的地址，甚至从平台到平台，因此你可能在输出中观察到不同的地址：

```cpp
$ gcc ExtremeC_examples_chapter1_10.c
$ ./a.out
Before arithmetic: int_ptr: 3932338348, char_ptr: 3932338348
After arithmetic:  int_ptr: 3932338352, char_ptr: 3932338349
$
```

Shell Box 1-4：第一次运行示例 1.10 的输出

从算术操作前后的地址比较中可以清楚地看出，整数指针的步长是 4 字节，而字符指针的步长是 1 字节。如果你再次运行示例，指针可能指向其他地址，但它们的算术步长保持不变：

```cpp
$ ./a.out
Before arithmetic: int_ptr: 4009638060, char_ptr: 4009638060
After arithmetic:  int_ptr: 4009638064, char_ptr: 4009638061
$
```

Shell Box 1-5：第二次运行示例 1.10 的输出

现在你已经了解了算术步长，我们可以讨论使用指针算术来 *迭代* 内存区域的经典示例。示例 1.11 和 1.12 是关于打印整数数组所有元素的。没有使用指针的简单方法在 *示例 1.11* 中提出，而基于指针算术的解决方案作为 *示例 1.12* 的一部分给出。

以下代码框显示了 *示例 1.11* 的代码：

```cpp
#include <stdio.h>
#define SIZE 5
int main(int argc, char** argv) {
 int arr[SIZE];
 arr[0] = 9;
 arr[1] = 22;
 arr[2] = 30;
 arr[3] = 23;
 arr[4] = 18;
 for (int i = 0; i < SIZE; i++) {
   printf("%d\n", arr[i]);
 }
 return 0;
}
```

代码框 1-23 [ExtremeC_examples_chapter1_11.c]: 不使用指针算术遍历数组

*代码框 1-23* 中的代码你应该很熟悉。它只是使用 *循环计数器* 来引用数组的特定索引并读取其内容。但如果你想使用指针而不是通过 *索引器* 语法（`[` 和 `]` 之间的整数）来访问元素，应该以不同的方式完成。以下代码框演示了如何使用指针遍历数组边界：

```cpp
#include <stdio.h>
#define SIZE 5
int main(int argc, char** argv) {
 int arr[SIZE];
 arr[0] = 9;
 arr[1] = 22;
 arr[2] = 30;
 arr[3] = 23;
 arr[4] = 18;
 int* ptr = &arr[0];
 for (;;) {
   printf("%d\n", *ptr);
   if (ptr == &arr[SIZE - 1]) {
     break;
   }
   ptr++;
 }
 return 0;
}
```

代码框 1-24 [ExtremeC_examples_chapter1_12.c]: 使用指针算术遍历数组

第二种方法，在 *代码框 1-24* 中演示，使用无限循环，当 `ptr` 指针的地址与数组的最后一个元素相同时会中断。

我们知道数组是内存中的相邻变量，所以增加和减少一个指向元素的指针实际上使其在数组内部来回移动，最终指向不同的元素。

从前面的代码中可以看出，`ptr`指针的数据类型是`int*`。这是因为它必须能够指向数组的任何单个元素，该元素是类型为`int`的整数。请注意，数组的所有元素都是同一类型，因此它们具有相同的大小。因此，增加`ptr`指针使其指向数组内部的下一个元素。正如你所见，在`for`循环之前，`ptr`指向数组的第一个元素，通过进一步的增加，它沿着数组的内存区域向前移动。这是指针算术的一个非常经典的用法。

注意，在 C 语言中，数组实际上是一个指向其第一个元素的指针。因此，在示例中，`arr`的实际数据类型是`int*`。因此，我们可以将这一行写成如下：

```cpp
int* ptr = arr;
```

代替以下行：

```cpp
int* ptr = &arr[0];
```

## 泛型指针

类型为`void*`的指针被称为泛型指针。它可以指向任何地址，就像所有其他指针一样，但我们不知道它的实际数据类型，因此我们不知道它的算术步长。泛型指针通常用于存储其他指针的内容，但它们忘记了那些指针的实际数据类型。因此，泛型指针不能被解引用，并且不能对其进行算术运算，因为其底层数据类型是未知的。以下示例，*示例 1.13*，展示了解引用泛型指针是不可能的：

```cpp
#include <stdio.h>
int main(int argc, char** argv) {
 int var = 9;
 int* ptr = &var;
 void* gptr = ptr;
 printf("%d\n", *gptr);
 return 0;
}
```

Code Box 1-25 [ExtremeC_examples_chapter1_13.c]：解引用泛型指针会生成编译错误！

如果你使用 Linux 中的`gcc`编译前面的代码，你会得到以下错误：

```cpp
$ gcc ExtremeC_examples_chapter1_13.c
In function 'main':warning: dereferencing 'void *' pointer
  printf("%d\n", *gptr);
                 ^~~~~
error: invalid use of void expression
  printf("%d\n", *gptr);
$
```

Shell Box 1-6：在 Linux 中编译示例 1.13

如果你使用 macOS 中的`clang`编译它，错误信息不同，但它指的是相同的问题：

```cpp
$ clang ExtremeC_examples_chapter1_13.c
error: argument type 'void' is incomplete
  printf("%d\n", *gptr);
                 ^
1 error generated.
$
```

Shell Box 1-7：在 macOS 中编译示例 1.13

正如你所见，这两个编译器都不接受对泛型指针进行解引用。实际上，对泛型指针进行解引用是没有意义的！那么，它们有什么用呢？实际上，泛型指针非常适合定义*泛型函数*，这些函数可以接受广泛范围的不同指针作为它们的输入参数。以下示例，*示例 1.14*，试图揭示有关泛型函数的细节：

```cpp
#include <stdio.h>
void print_bytes(void* data, size_t length) {
  char delim = ' ';
  unsigned char* ptr = data;
  for (size_t i = 0; i < length; i++) {
    printf("%c 0x%x", delim, *ptr);
    delim = ',';
    ptr++;
  }
  printf("\n");
}
int main(int argc, char** argv) {
 int a = 9;
 double b = 18.9;
 print_bytes(&a, sizeof(int));
 print_bytes(&b, sizeof(double));
 return 0;
}
```

Code Box 1-26 [ExtremeC_examples_chapter1_14.c]：泛型函数的示例

在前面的代码框中，`print_bytes`函数接收一个地址作为`void*`指针和一个表示长度的整数。使用这些参数，函数从指定的地址开始打印所有字节，直到指定的长度。正如你所看到的，该函数接受一个通用指针，允许用户传递他们想要的任何指针。请注意，对*void 指针*（通用指针）的赋值*不需要*显式转换。这就是为什么我们没有对`a`和`b`的地址进行显式转换。

在`print_bytes`函数内部，我们必须使用一个`unsigned char`指针来在内存中移动。否则，我们无法直接对 void 指针参数`data`进行任何算术运算。正如你可能知道的，`char*`或`unsigned char*`的步长为 1 字节。因此，它是逐字节遍历内存地址范围并逐个处理所有这些字节的最佳指针类型。

关于这个示例的最后一句话，`size_t`是一个标准的无符号数据类型，通常用于在 C 语言中存储大小。

`size_t`在 ISO/ICE 9899:TC3 标准的第 6.5.3.4 节中定义。这个 ISO 标准是著名的 2007 年修订的 C99 规范。这个标准一直是所有 C 语言实现的基础。ISO/ICE 9899:TC3 (2007)的链接是[`www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf`](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf)。

## 指针大小

如果你使用谷歌搜索“C 中指针的大小”，你可能会意识到你无法找到对该问题的明确答案。网上有很多答案，确实，你无法在不同的架构上为指针定义一个固定的大小。指针的大小取决于架构，而不是一个特定的 C 语言概念。C 语言并不太关心这样的与硬件相关的细节，它试图提供一种通用的方式来处理指针和其他编程概念。这就是为什么我们称 C 语言为标准。对 C 语言来说，只有指针及其上的算术运算才是重要的。

架构指的是计算机系统中使用的硬件。你将在即将到来的章节“编译和链接”中找到更多细节。

你始终可以使用`sizeof`函数来获取指针的大小。查看你的目标架构上`sizeof(char*)`的结果就足够了。一般来说，32 位架构上的指针是 4 字节，64 位架构上的指针是 8 字节，但在其他架构上你可能找到不同的大小。请记住，你编写的代码*不应该*依赖于指针大小的特定值，也不应该对其做出任何假设。否则，当你将代码移植到其他架构时，你可能会遇到麻烦。

## 悬挂指针

由于指针误用导致的问题有很多，悬垂指针的问题尤为著名。指针通常指向一个已分配变量的地址。读取或修改没有注册变量的地址是一个大错误，可能会导致崩溃或*段错误*情况。段错误是一个令人恐惧的错误，每个 C/C++开发者至少应该在编写代码时遇到过一次。这种情况通常发生在你误用指针时。你正在访问你无权访问的内存位置。之前那里有一个变量，但现在已经被释放了。

让我们尝试在以下示例中产生这种情况，*示例 1.15*：

```cpp
#include <stdio.h>
int* create_an_integer(int default_value) {
  int var = default_value;
  return &var;
}
int main() {
  int* ptr = NULL;
  ptr = create_an_integer(10);
  printf("%d\n", *ptr);
  return 0;
}
```

代码框 1-27 [ExtremeC_examples_chapter1_15.c]：产生段错误情况

在前面的例子中，`create_an_integer`函数用于创建一个整数。它声明了一个具有默认值的整数并返回其地址给调用者。在`main`函数中，接收创建的整数`var`的地址并将其存储在`ptr`指针中。然后，解引用`ptr`指针，并打印出`var`变量中的值。

但事情并不那么简单。当你想在 Linux 机器上使用`gcc`编译器编译这段代码时，它会生成以下警告，但仍然成功完成编译，并得到最终的可执行文件：

```cpp
$ gcc ExtremeC_examples_chapter1_15.c
In function 'f':
warning: function returns address of local variable [-Wreturn-local-addr]
   return &var;
          ^~~~
$
```

Shell 框 1-8：在 Linux 中编译 example 1.15

这确实是一条重要的警告信息，程序员很容易忽略并忘记。我们将在*第五章*，*栈和堆*中更详细地讨论这个问题。让我们看看如果我们继续执行生成的可执行文件会发生什么。

当你运行*示例 1.15*时，你会得到一个段错误错误，程序会立即崩溃：

```cpp
$ ./a.out
Segmentation fault (core dumped)
$
```

Shell 框 1-9：运行 example 1.15 时发生段错误

那么，出了什么问题呢？`ptr`指针是悬垂的，它指向一个已释放的内存部分，这部分内存曾经是变量`var`的内存位置。

`var`变量是`create_an_integer`函数的局部变量，在离开函数后将被释放，但其地址可以从函数中返回。因此，在将返回的地址复制到`main`函数中的`ptr`作为部分内容后，`ptr`变成了一个悬垂指针，指向内存中的无效地址。现在，解引用指针会导致严重问题，程序会崩溃。

如果你回顾编译器生成的警告，它清楚地指出了问题。

它说你在*返回局部变量的地址*，这个地址在函数返回后将被释放。聪明的编译器！如果你认真对待这些警告，你就不会遇到这些令人恐惧的 bug。

但是，重写示例的正确方法是什么？是的，使用 *堆内存*。我们将在 *第四章* *进程内存结构* 和 *第五章* *栈和堆* 中全面介绍堆内存，但现在，我们将使用 *堆分配* 来重写示例，你将看到如何从使用 *堆* 而不是 *栈* 中受益。

*示例 1.16* 以下展示了如何使用堆内存分配变量，并允许函数之间传递地址而不遇到任何问题：

```cpp
#include <stdio.h>
#include <stdlib.h>
int* create_an_integer(int default_value) {
  int* var_ptr = (int*)malloc(sizeof(int));
  *var_ptr = default_value;
  return var_ptr;
}
int main() {
  int* ptr = NULL;
  ptr = create_an_integer(10);
  printf("%d\n", *ptr);
  free(ptr);
  return 0;
}
```

代码框 1-28 [ExtremeC_examples_chapter1_16.c]: 使用堆内存重写示例 1.15

正如你在前面的代码框中看到的，我们包含了一个新的头文件 `stdlib.h`，并且使用了两个新的函数，`malloc` 和 `free`。简单的解释是这样的：在 `create_an_integer` 函数内部创建的整型变量不再是局部变量了。相反，它是一个从堆内存分配的变量，其生命周期不再局限于声明它的函数。因此，它可以在调用者（外部）函数中被访问。指向这个变量的指针也不再是悬垂指针了，只要变量存在且没有被释放，它们就可以被解引用。最终，通过调用 `free` 函数来释放变量，结束其生命周期。请注意，当不再需要堆变量时，释放堆变量是强制性的。

在本节中，我们讨论了有关变量指针的所有基本问题。在下一节中，我们将讨论 C 中的函数及其解剖结构。

# 关于函数的一些细节

C 是一种 *过程式* 编程语言。在 C 中，函数充当过程，它们是 C 程序的构建块。因此，了解它们是什么，它们如何表现，以及当你进入或离开函数时会发生什么，是很重要的。一般来说，函数（或过程）类似于普通变量，它们存储算法而不是值。通过将变量和函数组合成新的类型，我们可以在相同的概念下存储相关的值和算法。这就是我们在 *面向对象编程* 中所做的事情，它将在本书的第三部分 *面向对象* 中介绍。在本节中，我们想要探索函数，并讨论它们在 C 中的属性。

## 函数的解剖结构

在本节中，我们希望在单个地方回顾有关 C 函数的所有内容。如果你觉得这对你来说很熟悉，你可以简单地跳过这一节。

函数是一个具有名称、输入参数列表和输出结果列表的逻辑盒子。在 C 语言以及受 C 语言影响的许多其他编程语言中，函数只返回一个值。在 C++和 Java 这样的面向对象语言中，函数（通常称为*方法*）也可以抛出*异常*，而 C 语言则不行。函数通过函数调用来调用，即简单地使用函数名称来执行其逻辑。正确的函数调用应该传递所有必需的参数给函数，并等待其执行。请注意，在 C 语言中，函数总是*阻塞*的。这意味着调用者必须等待被调用函数完成，然后才能收集返回的结果。

与阻塞函数相反，我们可以有一个*非阻塞*函数。在调用非阻塞函数时，调用者不需要等待函数完成，它可以继续执行。在这种方案中，通常有一个*回调*机制，当被调用（或被调用者）函数完成时触发。非阻塞函数也可以称为*异步函数*或简单地称为*async 函数*。由于 C 语言中没有异步函数，我们需要使用多线程解决方案来实现它们。我们将在本书的第五部分*并发*中更详细地解释这些概念。

有趣的是，现在对使用非阻塞函数而非阻塞函数的兴趣日益增长。这通常被称为*事件驱动编程*。在这种编程方法中，非阻塞函数是核心，大多数编写的函数都是非阻塞的。

在事件驱动编程中，实际的功能调用发生在*事件循环*内部，并且当事件发生时，会触发适当的回调。例如，`libuv`和`libev`这样的框架推广了这种编程方式，并允许你围绕一个或多个事件循环来设计你的软件。

## 设计中的重要性

函数是过程式编程的基本构建块。自从编程语言中正式支持它们以来，它们对我们编写代码的方式产生了巨大影响。使用函数，我们可以将逻辑存储在半变量实体中，并在需要时随时随地进行调用。使用它们，我们只需编写一次特定逻辑，就可以在多个地方多次使用。

此外，函数允许我们隐藏一段逻辑，使其不被其他现有逻辑看到。换句话说，它们在各个逻辑组件之间引入了一个抽象层次。例如，假设你有一个名为`avg`的函数，它计算输入数组的平均值。你还有一个名为`main`的函数，它调用`avg`函数。我们说`avg`函数内部的逻辑对`main`函数内部的逻辑是隐藏的。

因此，如果你想更改`avg`函数内部的逻辑，你不需要更改`main`函数内部的逻辑。这是因为`main`函数只依赖于`avg`函数的名称和可用性。这是一个巨大的成就，至少在我们不得不使用穿孔卡片来编写和执行程序的那些年里是这样！

我们仍然在使用这个特性来设计用 C 编写的库，甚至是 C++和 Java 这样的高级编程语言。

## 栈管理

如果你查看在类 Unix 操作系统中运行的过程的内存布局，你会注意到所有进程都共享一个类似的布局。我们将在 *第四章*，*进程内存结构* 中更详细地讨论这个布局，但现在，我们想要介绍其 *段* 之一；栈段。栈段是所有局部变量、数组和结构默认分配的内存位置。所以，当你在一个函数中声明一个局部变量时，它就是从栈段分配的。这种分配总是在栈段顶部发生。

注意到段名称中的术语 *栈*。这意味着这个段的行为就像一个栈。变量和数组总是分配在其顶部，而顶部的变量是首先被移除的。记住这个与栈概念的类比。我们将在下一段中回到这个话题。

栈段也用于函数调用。当你调用一个函数时，一个包含返回地址和所有传递参数的 *栈帧* 被放置在栈段顶部，然后才执行函数逻辑。当从函数返回时，栈帧被弹出，由返回地址指定的指令被执行，这通常应该继续调用函数。

函数体内声明的所有局部变量都被放置在栈段顶部。所以，当离开函数时，所有栈变量都会被释放。这就是为什么我们称它们为 *局部变量*，也是为什么一个函数不能访问另一个函数中的变量。这种机制也解释了为什么在进入函数之前和离开函数之后不会定义局部变量。

理解栈段及其工作方式对于编写正确和有意义的代码至关重要。它还能防止常见的内存错误发生。它也是一个提醒，你不能在栈上创建任何你想要的尺寸的变量。栈是内存的一个有限部分，你可能会填满它并可能收到 *栈溢出* 错误。这通常发生在我们有很多函数调用消耗了所有的栈段，它们的栈帧时。这在处理递归函数时非常常见，当函数在没有任何中断条件或限制的情况下调用自己时。

## 值传递与引用传递

在大多数计算机编程书籍中，都有一个关于函数参数按值传递和按引用传递的章节。幸运的是，或者不幸的是，在 C 中我们只有按值传递。

在 C 中没有引用，因此也没有按引用传递。所有内容都复制到函数的局部变量中，函数退出后无法读取或修改它们。

尽管有许多示例似乎证明了按引用传递函数调用，但我应该说的是，在 C 中按引用传递是一种错觉。在本节的其余部分，我们想要揭露这个错觉，并说服你那些示例也是按值传递。以下示例将演示这一点：

```cpp
#include <stdio.h>
void func(int a) {
  a = 5;
}
int main(int argc, char** argv) {
  int x = 3;
  printf("Before function call: %d\n", x);
  func(x);
  printf("After function call: %d\n", x);
  return 0;
}
```

Code Box 1-29 [ExtremeC_examples_chapter1_17.c]：一个按值传递函数调用的示例

预测输出很容易。`x` 变量没有变化，因为它是以值传递的。以下 shell box 展示了 *示例 1.17* 的输出并证实了我们的预测：

```cpp
$ gcc ExtremeC_examples_chapter1_17.c
$ ./a.out
Before function call: 3
After function call: 3
$
```

Shell Box 1-10：示例 1.17 的输出

以下示例，*示例 1.18*，演示了在 C 中不存在按引用传递：

```cpp
#include <stdio.h>
void func(int* a) {
  int b = 9;
  *a = 5;
  a = &b;
}
int main(int argc, char** argv) {
  int x = 3;
  int* xptr = &x;
  printf("Value before call: %d\n", x);
  printf("Pointer before function call: %p\n", (void*)xptr);
  func(xptr);
  printf("Value after call: %d\n", x);
  printf("Pointer after function call: %p\n", (void*)xptr);
  return 0;
}
```

Code Box 1-30 [ExtremeC_examples_chapter1_18.c]：一个按指针传递函数调用的示例，与按引用传递不同

这就是输出结果：

```cpp
$ gcc ExtremeC_examples_chapter1_18.c
$ ./a.out
The value before the call: 3
Pointer before function call: 0x7ffee99a88ec
The value after the call: 5
Pointer after function call: 0x7ffee99a88ec
$
```

Shell Box 1-11：示例 1.18 的输出

如你所见，函数调用后指针的值没有改变。这意味着指针是以按值传递的参数传递的。在 `func` 函数内部解引用指针允许访问指针指向的变量。但你看到，在函数内部改变指针参数的值并不会改变调用函数中的对应参数。在 C 的函数调用过程中，所有参数都是按值传递的，解引用指针允许修改调用函数的变量。

值得注意的是，上述示例演示了一个按指针传递的示例，其中我们传递变量的指针而不是直接传递它们。通常建议使用指针作为参数而不是将大对象传递给函数，但为什么？这很容易猜测。复制指针参数的 8 个字节比复制大对象的数百个字节要高效得多。

意外地，在上面的示例中传递指针并不高效！这是因为 `int` 类型是 4 个字节，复制它比复制其指针的 8 个字节更高效。但结构体和数组的情况并非如此。由于结构体和数组的复制是按字节进行的，并且它们中的所有字节都应该一个接一个地复制，因此通常最好传递指针。

现在我们已经讨论了有关 C 中函数的一些细节，让我们来谈谈函数指针。

# 函数指针

函数指针是 C 编程语言的另一个超级特性。前两个部分是关于变量指针和函数的，本节将结合它们，讨论一个更有趣的话题：函数指针。

它们有众多应用，但将大型二进制文件拆分为较小的二进制文件，并在另一个小的可执行文件中重新加载，是其中最重要的应用之一。这导致了*模块化*和软件设计。函数指针是 C++中实现多态性的构建块，并允许我们扩展现有的逻辑。在本节中，我们将介绍它们，并为我们在接下来的章节中将要覆盖的更高级主题做好准备。

就像变量指针指向变量一样，函数指针指向函数，并允许你间接调用该函数。下面的例子，*例子 1.19*，可以作为这个主题的良好起点：

```cpp
#include <stdio.h>
int sum(int a, int b) {
  return a + b;
}
int subtract(int a, int b) {
  return a - b;
}
int main() {
  int (*func_ptr)(int, int);
  func_ptr = NULL;
  func_ptr = &sum;
  int result = func_ptr(5, 4);
  printf("Sum: %d\n", result);
  func_ptr = &subtract;
  result = func_ptr(5, 4);
  printf("Subtract: %d\n", result);
  return 0;
}
```

Code Box 1-31 [ExtremeC_examples_chapter1_19.c]：使用单个函数指针调用不同的函数

在先前的代码框中，`func_ptr`是一个函数指针。它只能指向与它的签名相匹配的特定类别的函数。签名限制了指针只能指向接受两个整数参数并返回整数结果的函数。

正如你所见，我们定义了两个名为`sum`和`subtract`的函数，它们与`func_ptr`指针的签名相匹配。先前的例子使用`func_ptr`函数指针分别指向`sum`和`subtract`函数，然后使用相同的参数调用它们并比较结果。这是例子的输出：

```cpp
$ gcc ExtremeC_examples_chapter1_19.c
$ ./a.out
Sum: 9
Subtract: 1
$
```

Shell Box 1-12：例子 1.19 的输出

正如你在*例子 1.19*中看到的，我们可以使用单个函数指针调用具有相同参数列表的不同函数，这是一个重要的特性。如果你熟悉面向对象编程，首先想到的可能是*多态*和*虚函数*。实际上，这是在 C 语言中支持多态并模仿 C++虚函数的唯一方法。我们将作为本书第三部分*对象* *导向*的一部分介绍面向对象编程。

就像变量指针一样，正确初始化函数指针非常重要。对于那些在声明时不会立即初始化的函数指针，必须将它们设置为 null。函数指针的 null 化在先前的例子中得到了演示，并且它与变量指针非常相似。

通常建议为函数指针定义一个新的*类型别名*。下面的例子，*例子 1.20*，演示了应该如何做：

```cpp
#include <stdio.h>
typedef int bool_t;
typedef bool_t (*less_than_func_t)(int, int);
bool_t less_than(int a, int b) {
  return a < b ? 1 : 0;
}
bool_t less_than_modular(int a, int b) {
  return (a % 5) < (b % 5) ? 1 : 0;
}
int main(int argc, char** argv) {
  less_than_func_t func_ptr = NULL;
  func_ptr = &less_than;
  bool_t result = func_ptr(3, 7);
  printf("%d\n", result);
  func_ptr = &less_than_modular;
  result = func_ptr(3, 7);
  printf("%d\n", result);
  return 0;
}
```

Code Box 1-32 [ExtremeC_examples_chapter1_20.c]：使用单个函数指针调用不同的函数

`typedef` 关键字允许你为已定义的类型定义一个别名。在先前的例子中有两个新的类型别名：`bool_t`，它是 `int` 类型的别名，以及 `less_than_func_t` 类型，它是函数指针类型 `bool_t (*)(int, int)` 的别名类型。这些别名增加了代码的可读性，并允许你为长而复杂的类型选择一个更短的名字。在 C 语言中，新类型的名字通常以 `_t` 结尾，你可以在许多其他标准类型别名中找到这个约定，例如 `size_t` 和 `time_t`。

# 结构体

从设计角度来看，结构体是 C 语言中最基本的概念之一。如今，它们不再仅限于 C 语言，你几乎可以在每种现代编程语言中找到它们对应的理念。

但我们应该在计算历史的背景下讨论它们，当时没有其他编程语言提供这样的概念。在许多努力摆脱机器级编程语言的尝试中，引入结构体是朝着在编程语言中实现**封装**迈出的重要一步。数千年来，我们的思维方式并没有发生太大的变化，封装一直是我们的逻辑推理的核心手段。

但在 C 语言之后，我们终于有了某种工具，在这种情况下，是一种编程语言，它能够理解我们的思维方式，并能存储和处理我们推理的构建块。最终，我们得到了一种类似于我们思维和想法的语言，所有这一切都发生在我们得到结构体的时候。与现代语言中发现的封装机制相比，C 语言的结构体并不完美，但它们足以让我们构建一个平台，在这个平台上创建我们最好的工具。

## 为什么需要结构体？

你知道每种编程语言都有一些**基本数据类型**（**PDTs**）。使用这些基本数据类型，你可以设计你的数据结构，并围绕它们编写算法。这些基本数据类型是编程语言的一部分，它们不能被更改或删除。例如，没有 `int` 和 `double` 这两种基本类型，你将无法使用 C 语言。

当你需要自定义数据类型，而语言中的数据类型又不足以满足需求时，结构体就派上用场了。**用户定义类型**（**UDTs**）是由用户创建的类型，它们不是语言的一部分。

注意，用户定义类型（UDTs）与使用 `typedef` 定义的类型不同。关键字 `typedef` 并没有真正创建一个新类型，而是为已定义的类型定义了一个别名或同义词。但结构体允许你将全新的用户定义类型（UDTs）引入到你的程序中。

结构体在其他编程语言中具有对应的概念，例如 C++ 和 Java 中的类或 Perl 中的包。在这些语言中，它们被认为是**类型创建者**。

## 为什么需要用户定义类型？

那么，为什么我们需要在程序中创建新的类型呢？这个问题的答案揭示了软件设计背后的原则以及我们用于日常软件开发的 方法。我们创建新的类型，因为我们每天都在用大脑进行常规分析时这样做。

我们不会把周围的环境看作整数、双精度浮点数或字符。我们已经学会了将相关的属性分组到同一个对象下。我们将在*第六章*，*面向对象编程和封装*中更详细地讨论我们分析周围环境的方式。但作为对起始问题的回答，我们需要新的类型，因为我们使用它们在更高层次的逻辑上分析我们的问题，接近于人类的逻辑。

在这里，你需要熟悉**商业逻辑**这个术语。商业逻辑是在商业中找到的所有实体和规则的总和。例如，在银行系统的商业逻辑中，你会遇到客户、账户、余额、货币、现金、支付等概念，这些都是为了使货币提取等操作成为可能和有意义的。

假设你必须用纯整数、浮点数或字符来解释一些银行逻辑。这几乎是不可能的。如果对程序员来说可能，那么对**商业分析师**来说几乎毫无意义。在一个具有明确商业逻辑的真实软件开发环境中，程序员和商业分析师需要紧密合作。因此，他们需要拥有一套共享的术语、词汇表、类型、操作、规则、逻辑等等。

今天，不支持在其*类型系统*中创建新类型的编程语言可以被认为是一种死语言。也许这就是为什么大多数人认为 C 是一种死编程语言，主要是因为他们无法在 C 中轻松定义新的类型，他们更愿意转向 C++或 Java 等高级语言。是的，在 C 中创建一个良好的类型系统并不容易，但你需要的一切都在那里。

即使今天，选择 C 作为项目的主要语言，并接受在 C 项目中创建和维护一个良好的类型系统的努力，背后可能有多种原因。甚至今天，许多公司都在这样做。

尽管我们每天在软件分析中需要新的类型，但 CPU 并不理解这些新的类型。CPU 试图坚持 PDTs（程序数据类型）和快速计算，因为它们被设计成这样做。所以，如果你用高级语言编写了一个程序，它应该被翻译成 CPU 级别的指令，这可能会花费你更多的时间和资源。

在这种意义上，幸运的是，C 与 CPU 级别的逻辑并不遥远，它有一个可以轻松转换的类型系统。你可能听说过 C 是一种低级或硬件级别的编程语言。这是为什么一些公司和组织试图用 C 编写和维护他们的核心框架，即使今天也是如此。

## 结构有什么作用？

结构体将相关的值封装在单个统一类型下。作为一个早期示例，我们可以将`red`、`green`和`blue`变量组合在一个新的单一数据类型`color_t`下。新的类型`color_t`可以在各种程序中表示 RGB 颜色，例如图像编辑应用程序。我们可以定义相应的 C 结构体如下：

```cpp
struct color_t {
  int red;
  int green;
  int blue;
};
```

代码框 1-33：C 语言中表示 RGB 颜色的结构体

如我们之前所述，结构体具有封装性。封装是软件设计中最基本的概念之一。它涉及到将相关的字段分组并封装在一个新的类型下。然后，我们可以使用这个新类型来定义所需的变量。我们将在*第六章*，*面向对象编程与封装*中详细描述封装，同时讨论面向对象设计。

注意，我们使用`_t`后缀来命名新的数据类型。

## 内存布局

对于 C 程序员来说，了解结构变量的确切内存布局通常很重要。在内存中有一个糟糕的布局可能会在某些架构中导致性能下降。不要忘记，我们编写代码是为了生成 CPU 的指令。值存储在内存中，CPU 应该能够足够快地读写它们。了解内存布局有助于开发者理解 CPU 的工作方式，并调整他们的代码以获得更好的结果。

以下示例，*示例 1.21*，定义了一个新的结构类型`sample_t`，并声明了一个结构变量`var`。然后，它用一些值填充其字段，并打印变量在内存中的大小和实际字节数。这样，我们可以观察变量的内存布局：

```cpp
#include <stdio.h>
struct sample_t {
  char first;
  char second;
  char third;
  short fourth;
};
void print_size(struct sample_t* var) {
  printf("Size: %lu bytes\n", sizeof(*var));
}
void print_bytes(struct sample_t* var) {
  unsigned char* ptr = (unsigned char*)var;
  for (int i = 0; i < sizeof(*var); i++, ptr++) {
    printf("%d ", (unsigned int)*ptr);
  }
  printf("\n");
}
int main(int argc, char** argv) {
  struct sample_t var;
  var.first = 'A';
  var.second = 'B';
  var.third = 'C';
  var.fourth = 765;
  print_size(&var);
  print_bytes(&var);
  return 0;
}
```

代码框 1-34 [ExtremeC_examples_chapter1_21.c]：打印分配给结构变量的字节数

对了解一切的确切内存布局的渴望是 C/C++特有的，随着编程语言变得高级，这种渴望会消失。例如，在 Java 和 Python 中，程序员对非常低级的内存管理细节了解较少，另一方面，这些语言不提供很多关于内存的细节。

正如你在*代码框 1-34*中看到的，在 C 语言中，在声明结构变量之前必须使用`struct`关键字。因此，在前面的例子中我们有`struct sample_t var`，这展示了你应该如何在声明语句中使用关键字在结构类型之前。提到这一点是显而易见的，你需要使用一个`.`（点）来访问结构变量的字段。如果它是一个结构指针，你需要使用`->`（箭头）来访问其字段。

为了防止在代码中大量使用`struct`，在定义一个新的结构类型和声明一个新的结构变量时，我们可以使用`typedef`来为结构定义一个新的别名类型。以下是一个示例：

```cpp
typedef struct {
  char first;
  char second;
  char third;
  short fourth;
} sample_t;
```

现在，你可以声明变量而不使用`struct`关键字：

```cpp
sample_t var;
```

以下是在 macOS 机器上编译并执行前一个示例后的输出。请注意，生成的数字可能因主机系统而异：

```cpp
$ clang ExtremeC_examples_chapter1_21.c
$ ./a.out
Size: 6 bytes
65 66 67 0 253 2
$
```

Shell Box 1-13: 示例 1.21 的输出

正如您在前一个 Shell Box 中看到的，`sizeof(sample_t)` 返回了 6 个字节。结构变量的内存布局与数组非常相似。在数组中，所有元素在内存中相邻，这对于结构变量及其字段也是如此。区别在于，在数组中，所有元素具有相同的类型和大小，但在结构变量中并非如此。每个字段可以具有不同的类型，因此它也可以具有不同的大小。与内存大小容易计算的数组不同，结构变量在内存中的大小取决于几个因素，并且不容易确定。

起初，猜测结构变量的大小似乎很简单。对于前一个示例中的结构，它有四个字段，三个 `char` 字段和一个 `short` 字段。通过简单的计算，如果我们假设 `sizeof(char)` 是 1 个字节，`sizeof(short)` 是 2 个字节，那么 `sample_t` 类型的每个变量在其内存布局中应该有 5 个字节。但当我们查看输出时，我们看到 `sizeof(sample_t)` 是 6 个字节。多出 1 个字节！为什么会有这个额外的字节？再次，当我们查看结构变量 `var` 的内存布局中的字节时，我们可以看到它与我们的预期 `65 66 67 253 2` 略有不同。

为了使这一点更清晰并解释为什么结构变量的大小不是 5 个字节，我们需要引入 *内存对齐* 的概念。CPU 总是执行所有计算。除此之外，它需要在计算任何内容之前从内存中加载值，并在计算后需要将结果存储回内存。计算在 CPU 内部非常快，但与内存访问相比非常慢。了解 CPU 如何与内存交互非常重要，因为这样我们可以利用这些知识来提升程序或调试问题。

CPU 通常在每次内存访问中读取特定数量的字节。这个字节数通常被称为 *字*。因此，内存被分成字，字是 CPU 用来从内存读取和写入的原子单元。一个字中实际的字节数是一个架构相关的因素。例如，在大多数 64 位机器上，字大小是 32 位或 4 个字节。关于内存对齐，我们说如果变量的起始字节位于字的开始处，则该变量在内存中是对齐的。这样，CPU 可以以优化的内存访问次数加载其值。

关于前面的例子，*例子 1.21*，前三个字段，`first`、`second` 和 `third`，每个字段都是 1 字节，它们位于结构布局的第一个单词中，并且它们都可以通过一次内存访问来读取。关于第四个字段，`fourth` 占用 2 字节。如果我们不考虑内存对齐，它的第一个字节将是第一个单词的最后一个字节，这使得它未对齐。

如果是这样的话，CPU 就需要一起进行两次内存访问和一些位移动，才能检索字段的值。这就是为什么我们在字节 `67` 后看到一个额外的零。这个零字节被添加是为了完成当前单词，并让第四个字段从下一个单词开始。在这里，我们说第一个单词被一个零字节填充。编译器使用 *填充* 技术在内存中对齐值。填充是为了匹配对齐而添加的额外字节。

可以关闭对齐。在 C 术语中，我们使用一个更具体的术语来表示对齐的结构。我们说结构不是打包的。*打包结构*没有对齐，使用它们可能会导致二进制不兼容和性能下降。你可以轻松地定义一个打包的结构。我们将在下一个例子，*例子 1.22*，中这样做，它与前面的例子，*例子 1.21*，非常相似。在这个例子中，`sample_t` 结构是打包的。下面的代码框显示了 *例子 1.22*。请注意，类似的代码被省略号替换了：

```cpp
#include <stdio.h>
struct __attribute__((__packed__)) sample_t {
  char first;
  char second;
  char third;
  short fourth;
} ;
void print_size(struct sample_t* var) {
  // ...
}
void print_bytes(struct sample_t* var) {
  // ...
}
int main(int argc, char** argv) {
  // ...
}
```

代码框 1-35 [ExtremeC_examples_chapter1_22.c]：声明一个打包的结构

在下面的 shell 框中，前面的代码使用 `clang` 在 macOS 上编译并运行：

```cpp
$ clang ExtremeC_examples_chapter1_22.c
$ ./a.out
Size: 5 bytes
65 66 67 253 2
$
```

Shell Box 1-14：*例子 1.22* 的输出

正如你在 *Shell Box 1-14* 中看到的那样，打印的大小正好是我们预期的 *例子 1.21* 的一部分。最终的布局也与我们的预期相匹配。打包结构通常用于内存受限的环境，但它们可能会对大多数架构的性能产生巨大的负面影响。只有新的 CPU 可以在不强制额外成本的情况下从多个单词中读取未对齐的值。请注意，默认情况下启用了内存对齐。

## 嵌套结构

正如我们在前面的章节中解释的那样，在 C 语言中，我们通常有两种数据类型。有一种是语言的基本类型，还有一种是由程序员使用 `struct` 关键字定义的类型。前者是 PDTs，后者是 UDTs。

到目前为止，我们的结构示例都是关于仅由 PDTs（结构）组成的 UDTs（结构）。但在这个部分，我们将给出一个由其他 UDTs（结构）组成的 UDTs（结构）的例子。这些被称为 *复杂数据类型*，它们是嵌套几个结构的结果。

让我们从例子，*例子 1.23*，开始：

```cpp
typedef struct {
  int x;
  int y;
} point_t;
typedef struct {
  point_t center;
  int radius;
} circle_t;
typedef struct {
  point_t start;
  point_t end;
} line_t;
```

代码框 1-36 [ExtremeC_examples_chapter1_23.c]：声明一些嵌套的结构

在前面的代码框中，我们有三个结构；`point_t`、`circle_t` 和 `line_t`。`point_t` 结构是一个简单的 UDT，因为它仅由 PDT 组成，但其他结构包含 `point_t` 类型的变量，这使得它们成为复杂的 UDT。

复杂结构的大小计算方式与简单结构完全相同，即通过将所有字段的大小相加。当然，我们仍然应该注意对齐，因为它可能会影响复杂结构的大小。因此，如果 `sizeof(int)` 是 4 字节，则 `sizeof(point_t)` 将是 8 字节。然后，`sizeof(circle_t)` 是 12 字节，`sizeof(line_t)` 是 16 字节。

通常将结构变量称为对象。它们与面向对象编程中的对象完全类似，我们将看到它们可以封装值和函数。因此，称它们为 C 对象并没错。

## 结构指针

与指向 PDT 指针类似，我们也可以有指向 UDT 的指针。它们的工作方式与 PDT 指针完全相同。它们指向内存中的一个地址，你可以像对 PDT 指针那样对它们进行算术运算。UDT 指针也有与 UDT 大小相等的算术步长。如果你对指针或允许在它们上进行的算术运算一无所知，请前往 *指针* 部分，并阅读它。

重要的是要知道，结构变量指向结构变量第一个字段的位置。在前面的例子 *示例 1.23* 中，类型为 `point_t` 的指针将指向其第一个字段 `x` 的地址。这同样适用于类型 `circle_t`。类型为 `circle_t` 的指针将指向其第一个字段 `center`，因为它实际上是一个 `point_t` 对象，所以它将指向 `point_t` 类型中第一个字段 `x` 的地址。因此，我们可以有 3 个不同的指针指向内存中的同一单元格。以下代码将演示这一点：

```cpp
#include <stdio.h>
typedef struct {
  int x;
  int y;
} point_t;
typedef struct {
  point_t center;
  int radius;
} circle_t;
int main(int argc, char** argv) {
  circle_t c;
  circle_t* p1 = &c;
  point_t*  p2 = (point_t*)&c;
  int*      p3 = (int*)&c;
  printf("p1: %p\n", (void*)p1);
  printf("p2: %p\n", (void*)p2);
  printf("p3: %p\n", (void*)p3);
  return 0;
}
```

代码框 1-37 [ExtremeC_examples_chapter1_24.c]：三个不同类型的指针指向内存中的同一字节

这是输出：

```cpp
$ clang ExtremeC_examples_chapter1_24.c
$ ./a.out
p1: 0x7ffee846c8e0
p2: 0x7ffee846c8e0
p3: 0x7ffee846c8e0
$
```

Shell Box 1-15: 示例 1.24 的输出

正如你所见，所有指针都指向同一字节，但它们的类型不同。这通常用于通过添加更多字段来扩展来自其他库的结构。这也是我们在 C 中实现 *继承* 的方式。我们将在 *第八章*，*继承和多态* 中讨论这一点。

这章的最后部分。在下一章中，我们将深入了解 C 编译器管道以及如何正确编译和链接 C 项目。

# 摘要

在本章中，我们回顾了 C 编程语言的一些重要特性。我们试图更进一步，展示这些特性的设计方面以及背后的概念。当然，正确使用一个特性需要对该特性的不同方面有更深入的了解。作为本章的一部分，我们讨论了以下内容：

+   我们讨论了 C 语言的预处理阶段以及各种指令如何影响预处理器以不同的方式行动或为我们生成特定的 C 代码。

+   宏和宏展开机制允许我们在将翻译单元传递到编译阶段之前生成 C 代码。

+   条件指令允许我们根据某些条件修改预处理的代码，并允许我们针对不同情况有不同的代码。

+   我们还研究了变量指针以及它们在 C 语言中的应用。

+   我们介绍了泛型指针以及如何有一个可以接受任何类型指针的函数。

+   我们讨论了一些问题，例如段错误和悬挂指针，以展示由于误用指针可能出现的几种灾难性情况。

+   接下来讨论了函数，并回顾了它们的语法。

+   我们探讨了函数的设计方面以及它们如何有助于构建一个结构良好的 C 程序过程。

+   我们还解释了函数调用机制以及如何使用栈帧将参数传递给函数。

+   本章探讨了函数指针。函数指针强大的语法允许我们将逻辑存储在类似变量的实体中，并在以后使用它们。实际上，这是当今每个程序使用的根本机制，用于加载和操作。

+   结构与函数指针的结合在 C 语言中产生了封装。我们将在本书的第三部分*面向对象*中更多地讨论这一点。

+   我们试图解释结构的设计方面以及它们对我们以 C 语言设计程序的影响。

+   我们还讨论了结构变量的内存布局以及它们如何在内存中放置以最大化 CPU 利用率。

+   还讨论了嵌套结构。我们也查看了一下复杂结构变量的内部，并讨论了它们的内存布局应该如何。

+   作为本章的最后一部分，我们讨论了结构指针。

下一章将是构建 C 项目的第一步。下一章将讨论 C 编译管道和链接机制。彻底阅读它对于继续阅读本书并进入后续章节至关重要。
