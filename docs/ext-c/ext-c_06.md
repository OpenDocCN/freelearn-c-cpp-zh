# 第六章

# 面向对象编程与封装

关于面向对象编程或 OOP 有很多优秀的书籍和文章。但我认为其中许多并没有使用非 OOP 语言如 C 来讨论相同的话题！这是怎么可能的？我们甚至能够使用不支持面向对象的编程语言来编写面向对象的程序吗？更精确地说，使用 C 语言编写面向对象的程序是可能的吗？

对于上述问题的简短回答是肯定的，但在解释如何之前，我们需要先解释为什么。我们需要将问题分解，看看面向对象编程（OOP）究竟是什么意思。为什么可以使用没有面向对象支持声明的语言来编写面向对象的程序？这似乎是一个悖论，但事实并非如此，我们本章的努力就是要解释这是为什么，以及应该如何去做。

可能还会让你感到困惑的另一个问题是，当你打算将 C 语言作为你的主要编程语言时，讨论这些话题和了解面向对象编程（OOP）有什么意义？几乎所有现有的成熟的 C 代码库，如开源内核、HTTPD、Postfix、nfsd、ftpd 等服务实现，以及许多其他 C 库如 OpenSSL 和 OpenCV，都是用面向对象的方式编写的。这并不意味着 C 是面向对象的；相反，这些项目组织其内部结构的方法源于面向对象的思想。

我强烈推荐您与下一章一起阅读本章，并更多地了解面向对象编程，因为首先，这将使您能够像设计前面提到的库的工程师一样思考和设计，其次，在阅读这些库的源代码时将非常有帮助。

C 语言在其语法中不支持诸如类、继承和虚函数等面向对象的概念。然而，它确实以间接的方式支持面向对象的概念。实际上，几乎历史上所有的通用编程语言都内在地支持面向对象编程——在 Smalltalk、C++和 Java 出现之前。这是因为每个通用编程语言都必须有一种方法来扩展其数据类型，而这正是面向对象的第一步。

C 语言不能，也不应该在其语法中支持面向对象的特性；这并非因为它的年代，而是因为我们将在本章中讨论的非常好的理由。简单来说，你仍然可以使用 C 语言编写面向对象的程序，但需要付出一些额外的努力来克服复杂性。

关于 C 语言中的 OOP 有一些书籍和文章，它们通常试图为编写类、实现继承、多态等创建一个*类型系统*，使用 C 语言来实现。这些书籍将添加 OOP 支持视为一系列函数、宏和预处理器，所有这些都可以一起使用来用 C 语言编写面向对象的程序。我们本章不会采取这种方法。我们不会从 C 中创建一个新的 C++；相反，我们想要推测 C 如何有可能被用于 OOP。

通常人们会说，面向对象编程（OOP）是与过程式和函数式编程范式并列的另一种编程范式。但 OOP 远不止于此。OOP 更像是一种思考和分析问题的方法。它是对宇宙及其内部对象层次的一种态度。它是我们古老、内在和继承下来的方法，用于理解和分析我们周围的物理和抽象实体。它对我们理解自然的基本性不言而喻。

我们总是从面向对象的角度思考每一个问题。OOP 只是将人类一直采用的观点应用到编程语言中，以解决计算问题。所有这些都解释了为什么 OOP 是编写软件时最常用的编程范式。

本章以及接下来的三章将展示，OOP 中的任何概念都可以在 C 语言中实现——即使实现起来可能很复杂。我们知道我们可以用 C 实现 OOP，因为有些人已经做到了，尤其是在他们基于 C 创建了 C++之后，并且他们已经在 C 中以面向对象的方式构建了许多复杂且成功的程序。

这些章节不会建议你使用特定的库或宏集来声明类、建立继承关系或处理其他 OOP 概念。此外，我们也不会强制任何方法或纪律，例如特定的命名约定。我们将简单地使用原始的 C 语言来实现 OOP 概念。

我们之所以将**整整四章**都用于 C 语言中的 OOP，是因为面向对象背后的理论很重，以及为了展示所有这些内容而必须探索的各种示例。OOP 背后的大部分基本理论将在本章中解释，而更实际的话题将在接下来的章节中处理。话虽如此，我们需要讨论理论，因为 OOP 概念通常对大多数熟练的 C 程序员来说都是新的，即使是那些有多年经验的人。

接下来的四章几乎涵盖了你在 OOP 中可能会遇到的所有内容。在本章中，我们将讨论以下内容：

+   首先，我们将为面向对象文献中最基本的术语给出定义。我们将定义类、对象、属性、行为、方法、域等。这些术语将在接下来的四章中大量使用。它们对于你理解其他面向对象相关资源也是至关重要的，因为它们是面向对象接受的语言的基础部分。

+   本章的第一部分并不完全关于术语；我们还将深入讨论面向对象的根源及其背后的哲学，探讨面向对象思维的本质。

+   本章的第二部分致力于探讨 C 语言及其为什么不是，以及为什么不能成为面向对象的语言。这是一个应该被提出并得到恰当回答的重要问题。这个话题将在第十章“Unix – 历史 和架构”中进一步讨论，我们将探讨 Unix 及其与 C 语言的紧密关系。

+   本章的第三部分讨论了*封装*，这是面向对象最基本的概念之一。简单来说，它允许你创建对象并使用它们。你可以在对象内部放置变量和方法的事实直接来自封装。这一点在第三部分中进行了详细讨论，并给出了几个示例。

+   然后这一章转向*信息隐藏*，这是封装的一个副作用（尽管非常重要）。没有信息隐藏，我们就无法隔离和解除软件模块的耦合，并且我们实际上无法向客户提供实现无关的 API。这是本章最后讨论的内容。

正如之前提到的，整个主题将涵盖四章，接下来的章节将基于*组合*关系展开。从那里开始，接下来的章节将涵盖*聚合*、*继承*、*多态*、*抽象*。

在本章中，尽管如此，我们将从面向对象（OOP）的理论开始，探讨如何从我们对软件组件的思考过程中提取对象模型。

# 面向对象思维

正如我们在章节介绍中所说，面向对象思维是我们分解和分析周围事物的方式。当你看着桌子上的一只花瓶时，你能够理解花瓶和桌子是独立的对象，而不需要进行任何深入的分析。

无意识地，你意识到它们之间存在一个边界，将它们分开。你知道你可以改变花瓶的颜色，而桌子的颜色将保持不变。

这些观察结果表明，我们从面向对象的视角看待我们的环境。换句话说，我们只是在脑海中创建周围面向对象现实的反映。我们也在计算机游戏、3D 建模软件和工程软件中看到很多这种情况，所有这些都可以涉及许多对象之间的相互交互。

面向对象编程（OOP）是将面向对象思维应用于软件设计和开发。面向对象思维是我们处理周围环境的方式，这就是为什么面向对象编程成为了编写软件最常用的范式。

当然，如果你采用面向对象的方法，有些问题可能会很难解决，如果你选择了另一种范式，这些问题可能会更容易被分析和解决，但这些问题的出现相对较少。

在接下来的章节中，我们将了解更多关于将面向对象思维转化为面向对象代码的翻译。

## 心理概念

你很难找到一个完全不包含至少一些面向对象思维痕迹的程序，即使它是用 C 或某些其他非面向对象语言编写的。如果人类编写程序，它将自然地是面向对象的。这甚至可以从变量名中看出。看看以下例子。它声明了保存 10 名学生信息的所需变量：

```cpp
  char*  student_first_names[10];
  char*  student_surnames[10];
   int   student_ages[10];
double   student_marks[10];
```

代码框 6-1：四个通过具有学生 _ 前缀相关联的数组，根据命名约定，旨在保存 10 名学生的信息

在*代码框 6-1*中找到的声明显示了我们是怎样使用变量名将一些变量归入同一概念下的，在这个例子中是*学生*。我们必须这样做；否则，我们会因为那些对我们面向对象思维来说没有意义的临时命名而感到困惑。假设我们有如下这样的东西：

```cpp
  char*  aaa[10];
  char*  bbb[10];
   int   ccc[10];
double   ddd[10];
```

代码框 6-2：四个具有特定名称的数组，旨在保存 10 名学生的信息！

使用如*代码框 6-2*中所示的那种变量名，无论你有多少编程经验，你必须承认在编写算法时你会遇到很多麻烦。变量命名一直很重要，因为名字提醒我们心中的概念以及数据与这些概念之间的关系。通过使用这种临时命名，我们在代码中失去了这些概念及其关系。这可能对计算机来说不是问题，但它会复杂化我们程序员的分析和故障排除，并增加我们犯错的几率。

让我们更详细地了解一下在我们当前语境中我们所说的“概念”是什么。概念是一种存在于心中的心理或抽象图像，它以思想或想法的形式存在。一个*概念*可能是由对现实世界实体的感知形成的，也可能完全是虚构和抽象的。当你看一棵树或思考一辆车时，它们相应的图像作为两个不同的概念出现在你的脑海中。

注意，有时我们在不同的语境中使用“概念”这个术语，例如在“面向对象的概念”中，显然这个“概念”一词的使用方式与我们刚才给出的定义并不相同。在与技术相关的话题中使用的“概念”一词，简单来说是指理解某个主题所需的原则。目前，我们将使用这个与技术相关的定义。

概念对于面向对象思维非常重要，因为如果你不能在心中形成并维持对对象的了解，你就不能提取关于它们所代表和关联的细节，也不能理解它们之间的关系。

因此，面向对象思维是关于以概念及其关系为前提的思考。由此可以推断，如果你想编写一个合适的面向对象程序，你需要在你心中对所有的相关对象、它们对应的概念以及它们之间的关系有一个恰当的理解。

在你心中形成的面向对象地图，由许多概念及其相互关系组成，不能轻易地传达给他人，例如在作为一个团队处理任务时。更重要的是，这种心理概念是易变的、难以捉摸的，并且很容易被遗忘。这也额外强调了这样一个事实，即你需要模型和其他工具来进行表示，以便将你的思维导图转化为可传达的想法。

## 思维导图和对象模型

在本节中，我们通过一个例子来进一步理解我们之前讨论的内容。假设我们有一个场景的书面描述。描述某物的目的是向观众传达相关的具体概念。可以这样想：描述者心中有一张地图，上面描绘了各种概念以及它们如何相互联系；他们的目标是向观众传达这张思维导图。你可以说，这基本上是所有艺术表达的目标；实际上，当你看一幅画、听一首音乐或读一本小说时，这正是发生的事情。

现在我们将来看一个书面描述。它描述了一个教室。放松你的心情，尽量想象你所读到的内容。你心中所看到的一切都是以下描述传达的概念：

*我们的教室是一个老旧的房间，有两扇大窗户。当你进入房间时，你可以看到对面墙上的窗户。房间中间有一些棕色的木椅。有五个学生坐在椅子上，其中两个是男孩。你右边墙上有一块绿色的木制黑板，老师正在和学生交谈。他是一位穿着蓝色衬衫的老人。*

现在，让我们看看在我们心中形成了哪些概念。不过，在我们这样做之前，请记住，你的想象力可能会在你没有注意到的情况下失控。所以，让我们尽力限制自己在这个描述的范围内。例如，我可以想象更多，比如说女孩们是金发的。但是描述中没有提到这一点，所以我们不会考虑这一点。在下一段中，我将解释在我心中形成了什么，在继续之前，你也应该尝试为自己做同样的事情。

在我心中，有五个概念（或心理图像，或对象），每个学生一个。还有五个概念用于椅子。还有一个概念用于木头，另一个概念用于玻璃。我知道每把椅子都是由木头制成的。这是一个关系，在木头概念和椅子概念之间。此外，我知道每个学生都坐在椅子上。因此，有五个关系——在椅子和学生之间。我们可以继续识别更多概念并将它们联系起来。很快，我们就会有一个描述数百个概念之间关系的巨大且复杂的图。

现在，暂停一下，看看你如何不同地提取概念及其关系。这是一个每个人都可以以不同方式完成的教训。当你想要解决特定问题时，这个过程也会发生。你需要在对问题发起攻击之前创建一个思维导图。这是我们称之为*理解阶段*的阶段。

你使用基于问题概念及其之间关系的途径来解决问题。你用这些概念来解释你的解决方案，如果有人想理解你的解决方案，他们首先应该理解这些概念及其关系。

如果我告诉你，当你尝试使用计算机解决问题时，这正是所发生的事情，你可能会感到惊讶，但这正是实际情况。你将问题分解为对象（与心理环境中的概念相同）以及它们之间的关系，然后尝试编写一个基于这些对象的程序，最终解决问题。

你所编写的程序模拟了你心中所拥有的概念及其关系。计算机运行解决方案，你可以验证它是否有效。你仍然是解决问题的那个人，但现在一台计算机是你的同事，因为它可以执行你的解决方案，这个解决方案现在被描述为一系列从你的思维导图中翻译出来的机器级指令，执行得更快、更准确。

面向对象的程序通过对象来模拟概念，当我们在大脑中为问题创建思维导图时，程序在其内存中创建一个对象模型。换句话说，如果我们把人类与面向对象的程序进行比较，那么术语*概念*、*思维*和*思维导图*分别等同于*对象*、*内存*和*对象模型*。这是我们在这个部分提供的重要关联，它将我们的思维方式与面向对象程序联系起来。

但我们为什么使用计算机来模拟我们的思维导图呢？因为计算机在速度和精度方面很擅长。这是一个非常经典的回答，但对我们的问题来说仍然是一个相关的回答。创建和维护一个大的思维导图及其相应的对象模型是一项复杂的任务，而计算机可以非常出色地完成这项任务。作为另一个优点，程序创建的对象模型可以存储在磁盘上并在以后使用。

思维导图可能会因为情绪而遗忘或改变，但计算机没有情绪，对象模型比人类思维更加健壮。这就是我们为什么要编写面向对象的程序：能够将我们思维中的概念转移到有效的程序和软件中。

**注意**：

到目前为止，还没有发明出可以从某人的思维中下载和存储思维导图的东西——但也许在将来会！

## 对象不在代码中

如果你查看一个运行中的面向对象程序的内存，你会发现它充满了对象，它们都是相互关联的。对人类来说也是如此。如果你把人类看作是一部机器，你可以说他们总是处于运行状态，直到他们去世。这是一个重要的类比。对象只能存在于运行程序中，就像概念只能存在于活着的思维中。这意味着只有当你有一个运行程序时，你才有对象。

这可能看起来像是一个悖论，因为当你编写一个程序（面向对象的程序）时，程序还不存在，所以不能运行！那么，在没有运行程序和没有对象的情况下，我们如何编写面向对象的代码呢？

**注意**：

当你编写面向对象的代码时，没有任何对象存在。只有当你将代码构建成可执行的程序并运行它时，对象才会被创建。

面向对象编程（OOP）实际上并不是关于创建对象。它是在程序运行时，创建一系列指令，这些指令将导致一个完全动态的对象模型。因此，面向对象的代码应该能够在编译和运行后创建、修改、关联甚至删除对象。

因此，编写面向对象代码是一项棘手的任务。在对象存在之前，你需要想象对象及其关系。这正是面向对象可能变得复杂，以及我们需要支持面向对象的编程语言的原因。想象尚未创造的事物并描述或设计其各种细节的艺术通常被称为*设计*。这就是为什么这个过程通常被称为**面向对象设计**（**OOD**）的原因。

在面向对象代码中，我们只计划创建对象。面向对象编程导致了一系列关于何时以及如何创建对象的指令。当然，这不仅仅关于创建。所有关于对象的操作都可以使用编程语言详细说明。面向对象编程语言是一种具有一系列指令（和语法规则）的语言，允许你编写和计划不同的与对象相关的操作。

到目前为止，我们已经看到人类心智中的概念与程序内存中的对象之间存在明显的对应关系。因此，对概念和对象可以执行的操作之间也应该存在对应关系。

每个对象都有一个专属的生命周期。这一点也适用于心中的概念。在某个时刻，一个想法出现在脑海中，并作为一个概念形成心理图像，而在另一个时刻，它逐渐消失。对于对象来说也是如此。对象在某个时刻被构建，在另一个时刻被销毁。

最后一点需要注意的是，一些心理概念非常坚定和稳定（与波动和短暂的概念相对，这些概念来去不定）。似乎这些概念与任何心智无关，即使在没有心智去理解它们的时候就已经存在。它们大多是数学概念。数字 2 就是一个例子。整个宇宙中只有一个数字 2！这真是太神奇了。这意味着你和我心中对数字 2 的概念是完全相同的；如果我们试图改变它，它就不再是数字 2 了。这正是我们离开面向对象领域的时刻，我们进入另一个领域，充满了不可变对象，这被描述在*函数式编程*范式标题下。

## 对象属性

任何心智中的每个概念都与一些属性相关联。如果你记得，在我们的教室描述中，我们有一个名为*chair1*的椅子，它是棕色的。换句话说，每个椅子对象都有一个名为颜色的属性，对于*chair1*对象来说它是棕色。我们知道教室里还有四把其他的椅子，它们有自己的颜色属性，可能具有不同的值。在我们的描述中，它们都是棕色的，但可能在另一个描述中，其中一把或两把是黄色的。

一个对象可以有一个或多个属性或一组属性。我们将分配给这些属性值的总和称为对象的**状态**。状态可以简单地被视为一个值列表，每个值属于某个特定的属性，并附加到对象上。对象在其生命周期内可以被修改。这样的对象被称为**可变的**。这仅仅意味着状态可以在其生命周期内被改变。对象也可以是**无状态的**，这意味着它们不携带任何状态（或任何属性）。

一个对象也可以是**不可变的**，就像对应于数字 2 的概念（或对象）一样，不能被改变——不可变意味着状态在构造时确定，之后不能被修改。

**注意**：

可以将无状态对象视为不可变对象，因为它的状态在其整个生命周期内不能被改变。实际上，它没有任何状态可以改变。

最后一点，不可变对象特别重要。它们的状态不能被改变的事实是一个优势，尤其是在它们在多线程环境中共享时。

## 领域

每个编写来解决特定问题（即使是极其微小的问题）的程序都有一个定义明确的领域。领域是另一个在软件工程文献中广泛使用的术语。领域定义了软件展示其功能边界的范围。它还定义了软件应该解决的问题的要求。

一个领域使用特定的和预定的术语（词汇表）来传达其使命并使工程师保持在它的边界内。参与任何软件项目的每个人都应该意识到他们的项目定义的领域。

例如，银行软件通常是为一个非常明确的领域构建的。它有一组作为其词汇表的已知术语，包括账户、信用、余额、转账、贷款、利息等等。

领域的定义通过其词汇表中的术语变得清晰；例如，在银行领域，你不会找到患者、药品和剂量的术语。

如果一种编程语言不提供处理特定领域（如医疗保健领域的患者和药品概念）的特定概念的功能（设施），那么使用该编程语言编写该领域的软件将会很困难——并非不可能，但肯定很复杂。此外，软件越大，开发和维护就越困难。

## 对象之间的关系

对象可以相互关联；它们可以相互引用以表示关系。例如，作为我们课堂描述的一部分，对象 *student4*（第四个学生）可能与对象 *chair3*（第三个椅子）在名为 *sitting on* 的关系上相关联。换句话说，*student4* 坐在 *chair3* 上。这样，系统中的所有对象都相互引用，形成一个称为对象模型的网络。正如我们之前所说的，对象模型是我们心中形成的思维导图的对应物。

当两个对象相关联时，一个对象状态的变化可能会影响另一个对象的状态。让我们通过一个例子来解释这一点。假设我们有两个无关的对象 `p1` 和 `p2`，代表像素。

对象 `p1` 的属性如下所示：`{x: 53, y: 345, red: 120, green: 45, blue: 178}`。对象 `p2` 的属性为 `{x: 53, y: 346, red: 79, green: 162, blue: 23}`。

**注意：**

我们使用的符号几乎与 **JavaScript 对象表示法** 或 **JSON** 完全相同，但略有不同。在这个符号中，单个对象的属性被两个大括号包围，并且属性之间用逗号分隔。每个属性都有一个与它分开的值，由冒号分隔。

现在，为了使它们相关联，它们需要有一个额外的属性来表示它们之间的关系。对象 `p1` 的状态将变为 `{x: 53, y: 345, red: 120, green: 45, blue: 178, adjacent_down_pixel: p2}`，而 `p2` 的状态将变为 `{x: 53, y: 346, red: 79, green: 162, blue: 23, adjacent_up_pixel: p1}`。

`adjacent_down_pixel` 和 `adjacent_up_pixel` 属性表示这些像素对象是相邻的；它们的 `y` 属性仅相差 1 个单位。使用这些额外的属性，对象意识到它们与其他对象之间存在关系。例如，`p1` 知道它的 `adjacent_down_pixel` 是 `p2`，而 `p2` 知道它的 `adjacent_up_pixel` 是 `p1`。

因此，正如我们所看到的，如果两个对象之间形成关系，这些对象的状态（或对应于它们属性的值列表）将发生变化。因此，通过向它们添加新属性来创建对象之间的关系，这使得关系成为对象状态的一部分。这当然对这些对象的可变性和不可变性有影响。

注意，定义对象状态和不可变性的属性子集可以从一个域更改为另一个域，并且不一定包含所有属性。在一个域中，我们可能只使用非引用属性（如前例中的 `x`、`y`、`red`、`green` 和 `blue`）作为状态，而在另一个域中，我们可能将它们与引用属性（如前例中的 `adjacent_up_pixel` 和 `adjacent_down_pixel`）一起组合。

## 面向对象操作

面向对象编程语言允许我们在即将运行的程序中计划对象的构建、对象的销毁以及改变对象的状态。因此，让我们首先看看对象的构建。

**注意：**

术语“构建”是经过精心选择的。我们本可以使用“创建”或“构建”，但这些术语在面向对象编程文献的标准术语中并不被接受。创建指的是为对象分配内存，而构建则意味着初始化其属性。

计划对象的构建有两种方式：

+   第一种方法涉及构建一个空对象——一个在其状态中没有任何属性的*无属性*对象——或者更常见的是，具有一组最小属性的对象。

+   随着代码的运行，将确定并添加更多属性。使用这种方法，同一个对象在不同的程序执行中可能会有不同的属性，这取决于周围环境的变化。

+   每个对象都被视为一个独立的实体，任何两个对象，即使它们看起来属于同一个组（或类），由于它们具有共同属性列表，在程序继续执行时，它们的状态可能会有不同的属性。

+   例如，已经提到的像素对象`p1`和`p2`都是像素（或者它们都属于名为`pixel`的同一类），因为它们具有相同的属性——`x`、`y`、`red`、`green`和`blue`。在建立关系后，它们会有不同的状态，因为它们那时具有新的和不同的属性：`p1`有`adjacent_down_pixel`属性，而`p2`有`adjacent_up_pixel`属性。

+   这种方法用于 JavaScript、Ruby、Python、Perl 和 PHP 等编程语言。其中大部分是**解释型编程语言**，它们的属性被保留为内部数据结构中的**映射**（或**散列**），可以轻松地在运行时更改。这种技术通常被称为**基于原型的面向对象编程**。

+   第二种方法涉及构建一个其属性预先确定且在执行过程中不会改变的实体。不允许在运行时向此类对象添加更多属性，并且对象将保持其结构。仅允许属性的值发生变化，而这种变化仅在对象可变时才可能发生。

+   要应用这种方法，程序员应该创建一个预设计的**对象模板**或**类**，该模板跟踪在运行时需要存在于对象中的所有属性。然后，这个模板应该被编译并在运行时输入到面向对象的语言中。

+   在许多编程语言中，这种对象模板被称为类。例如，Java、C++和 Python 等编程语言使用这个术语来表示它们的对象模板。这种技术通常被称为**基于类的面向对象编程**。请注意，Python 支持基于原型和基于类的面向对象编程。

**注意：**

类仅确定对象中存在的属性列表，但并不确定在运行时分配给它们的实际值。

注意，对象和*实例*是同一件事，它们可以互换使用。然而，在某些文本中，它们之间可能存在一些细微的差异。还有一个术语，*引用*，值得提及并解释。术语对象或实例用于指代该对象值的实际内存分配位置，而引用就像一个指向该对象的指针。因此，我们可以有许多引用指向同一个对象。一般来说，对象通常没有名称，但引用确实有名称。

**注意：**

在 C 中，我们有指针作为引用的对应语法。我们还有栈对象和堆对象。堆对象没有名称，我们使用指针来引用它。相比之下，栈对象实际上是一个变量，因此有一个名称。

虽然可以使用这两种方法，但 C 和特别是 C++官方设计的方式是为了支持基于类的构造方法。因此，当程序员想在 C 或 C++中创建一个对象时，他们首先需要有一个类。我们将在未来的章节中更多地讨论类及其在面向对象编程中的作用。

以下讨论可能看起来有些不相关，但实际上并非如此。关于人类如何通过生活成长，有两种不同的观点，它们与我们讨论过的对象构造方法非常吻合。其中一种哲学认为，人类出生时是空无一物的，没有本质（或状态）。

通过在生活中经历不同的好事和坏事，他们的本质开始成长并发展成为一个具有独立和成熟性格的东西。*存在主义*是一种哲学传统，它推广了这个观点。

它著名的格言是“存在先于本质”。这简单意味着人类首先来到存在，然后通过生活经验获得他们的本质。这个想法与我们的基于原型的对象构造方法非常接近，在这种方法中，对象是空无一物地构造的，然后在运行时发展。

另一种哲学更古老，主要是由宗教推广的。在这种观点中，人类是根据一个形象（或本质）创造的，而这个形象在人类存在之前就已经确定。这与我们计划根据模板或类来构造对象的方式非常相似。作为对象创造者，我们准备一个类，然后程序开始根据该类创建对象。

**注意：**

小说或故事中的人物，包括文学和历史资料中的人物，在克服某种困难时所采取的方法与我们在计算机科学中为解决类似问题而设计的算法之间存在很大的对应关系。我深信人类的生活方式和他们所经历的现实与我们对计算机科学中算法和数据结构的理解之间存在着极大的和谐。前面的讨论就是这种 OOP 与哲学之间和谐的一个很好的例子。

与对象构造类似，对象销毁发生在运行时；我们只能在代码中规划它。对象在其整个生命周期中分配的所有资源都应该在销毁时释放。当一个对象正在被销毁时，所有其他相关对象都应该被更改，以便它们不再引用被销毁的对象。一个对象不应该有引用一个不存在对象的属性，否则我们就会在我们的对象模型中失去*引用完整性*。这可能导致运行时错误，如内存损坏或段错误，以及逻辑错误，如计算错误。

修改对象（或改变对象的状态）可以通过两种不同的方式发生。它可能是现有属性值的改变，也可能是向该对象的属性集中添加或从集中移除属性。后者只有在选择了基于原型的对象构造方法时才能发生。记住，改变不可变对象的状态是被禁止的，通常面向对象的语言也不允许这样做。

## 对象具有行为

每个对象，连同其属性，都有它能够执行的一定列表的功能。例如，汽车对象能够加速、减速、转弯等。在面向对象编程（OOP）中，这些功能总是符合领域需求。例如，在银行对象模型中，客户可以订购新账户，但不能吃饭。当然，客户是人，可以吃饭，但只要吃饭功能与银行领域无关，我们就不会将其视为客户对象的一个必要功能。

每个功能都能通过改变其属性的值来改变对象的状态。作为一个简单的例子，一辆汽车对象可以加速。加速是汽车对象的一个功能，通过加速，汽车的速度，即其属性之一，发生了变化。

总结来说，对象仅仅是一组属性和功能。在后面的章节中，我们将更多地讨论如何将这些事物组合成一个对象。

到目前为止，我们已经解释了研究和理解面向对象编程（OOP）所需的基本术语。下一步是解释封装的基本概念。但是，作为一个休息，让我们了解一下为什么 C 语言不能成为面向对象的语言。

# C 语言不是面向对象的，但为什么？

C 不是面向对象的，但这并不是因为它的年龄。如果年龄是原因，我们到现在应该已经找到了一种方法使其成为面向对象的语言。但是，正如你将在第十二章“最新的 C”中看到的那样，C 编程语言的最新标准 C18 并不试图将 C 变成面向对象的语言。

另一方面，我们有 C++，它是基于 C 的所有努力以实现面向对象语言的结果。如果 C 的命运是它被面向对象的语言所取代，那么今天就不会有任何对 C 的需求了，这主要是因为 C++——但当前对 C 工程师的需求表明情况并非如此。

人类以面向对象的方式思考，但 CPU 执行的是机器级指令，这些指令是过程式的。CPU 只是依次执行一系列指令，并且时不时地需要跳转、从内存中的不同地址获取并执行其他指令；这与使用像 C 这样的过程式编程语言编写的程序中的函数调用非常相似。

C 不能成为面向对象的语言，因为它位于面向对象和过程式编程之间的障碍上。面向对象是人类对问题的理解，而过程式执行是 CPU 能够执行的操作。因此，我们需要某种东西处于这个位置并形成这个障碍。否则，通常以面向对象方式编写的程序无法直接转换为过程式指令以供 CPU 执行。

如果你看看像 Java、JavaScript、Python、Ruby 等高级编程语言，它们在其架构中都有一个组件或层，它介于它们的运行环境与操作系统内部实际找到的 C 库（Unix-like 系统中的标准 C 库和 Windows 系统中的 Win32 API）之间。例如，**Java 虚拟机**（**JVM**）在 Java 平台上就是这样做的。虽然并非所有这些环境都是必然面向对象的（例如 JavaScript 或 Python 可以是过程式和面向对象的），但它们需要这个层来将它们的高级逻辑转换为低级过程式指令。

# 封装

在前面的章节中，我们看到了每个对象都有一组属性和一组与之相关的功能。在这里，我们将讨论将这些属性和功能放入一个称为对象的实体中。我们通过一个称为“封装”的过程来完成这件事。

封装简单地说就是将相关的事物放在一起，形成一个代表对象的“胶囊”。这首先发生在你的脑海中，然后应该转移到代码中。当你觉得一个对象需要有一些属性和功能时，你就在脑海中进行了封装；然后这个封装需要转移到代码层面。

能够在编程语言中封装事物至关重要，否则将相关变量放在一起将变得难以承受（我们提到了使用命名约定来完成这一点）。

对象是由一组属性和一组功能组成的。这两者都应该封装到对象胶囊中。让我们首先谈谈*属性封装*。

## 属性封装

正如我们之前看到的，我们总是可以使用变量名来进行封装，将不同的变量绑定在一起并将它们分组在同一个对象下。以下是一个例子：

```cpp
int pixel_p1_x     = 56;
int pixel_p1_y     = 34;
int pixel_p1_red   = 123;
int pixel_p1_green = 37;
int pixel_p1_blue  = 127;
int pixel_p2_x     = 212;
int pixel_p2_y     = 994;
int pixel_p2_red   = 127;
int pixel_p2_green = 127;
int pixel_p2_blue  = 0;
```

代码框 6-3：一些按名称分组的代表两个像素的变量

这个例子清楚地说明了变量名是如何用来将变量分组在`p1`和`p2`下的，它们在某种程度上是*隐式*对象。通过隐式，我们是指程序员是唯一一个意识到这些对象存在的人；编程语言对它们一无所知。

编程语言只看到 10 个似乎彼此独立的变量。这将是一个非常低级的封装，低到它甚至不会被正式认为是封装。通过变量名进行封装存在于所有编程语言中（因为你可以命名变量），即使在汇编语言中也是如此。

我们需要的是提供*显式*封装的方法。通过显式，我们是指程序员和编程语言都意识到封装以及存在的胶囊（或对象）。不提供显式*属性封装*的编程语言很难使用。

幸运的是，C 确实提供了显式封装，这也是我们能够相对容易地用 C 编写许多固有的面向对象程序的原因之一。另一方面，正如我们在下一节中将要看到的，C 没有提供显式行为封装，我们必须提出一种隐式纪律来支持这一点。

注意，在编程语言中拥有像封装这样的显式特性总是受欢迎的。在这里，我们只讨论了封装，但这可以扩展到许多其他面向对象特性，例如继承和多态。这样的显式特性允许编程语言在编译时而不是运行时捕获相关错误。

在运行时解决错误是一场噩梦，因此我们应始终尝试在编译时捕获错误。这是面向对象语言的主要优势，它完全了解我们的面向对象思维方式。面向对象语言可以在编译时找到并报告我们设计中的错误和违规，从而避免我们在运行时解决许多严重错误。事实上，这正是我们每天看到更多复杂编程语言的原因——让一切对语言来说都是明确的。

不幸的是，C 中并非所有面向对象特性都是显式的。这基本上是为什么用 C 编写面向对象程序很难的原因。但 C++中有更多显式特性，确实，这也是它被称为面向对象编程语言的原因。

在 C 语言中，结构提供了封装。让我们改变 *代码框 6-3* 中的代码，并使用结构来重写它：

```cpp
typedef struct {
  int x, y;
  int red, green, blue;
} pixel_t;
pixel_t p1, p2;
p1.x = 56;
p1.y = 34;
p1.red = 123;
p1.green = 37;
p1.blue = 127;
p2.x = 212;
p2.y = 994;
p2.red = 127;
p2.green = 127;
p2.blue = 0;
```

代码框 6-4：`pixel_t` 结构和声明两个 `pixel_t` 变量

关于 *代码框 6-4* 有几点需要注意：

+   属性封装发生在我们将 `x`、`y`、`red`、`green` 和 `blue` 属性放入一个新的类型 `pixel_t` 中时。

+   封装总是创建一个新的类型；在 C 语言中，属性封装尤其如此。这一点非常重要，实际上，这是我们使封装显式化的方式。请注意 `pixel_t` 末尾的 `_t` 后缀。在 C 语言中，通常会在新类型的名称末尾添加 `_t` 后缀，但这不是强制的。我们在这本书中一直使用这个约定。

+   当这段代码执行时，`p1` 和 `p2` 将是我们的显式对象。它们都是 `pixel_t` 类型，并且只有结构中指定的属性。在 C 语言中，尤其是 C++ 中，类型决定了它们的对象的属性。

+   新类型 `pixel_t` 只是一个类的属性（或对象模板）。记住，“类”这个词指的是包含属性和功能的对象模板。由于 C 结构只保留属性，它不能作为类的对应物。不幸的是，在 C 语言中我们没有类的对应概念；属性和功能是分开存在的，我们在代码中隐式地将它们关联起来。每个类在 C 语言中都是隐式的，它指的是一个结构以及一系列 C 函数。你将在接下来的例子中看到更多关于这一点的内容，这是本章以及未来章节的一部分。

+   正如你所见，我们正在基于一个模板（这里是指 `pixel_t` 的结构）构建对象，并且模板具有对象在出生时应该拥有的预定义属性。就像我们之前说的那样，结构只存储属性而不存储功能。

+   对象构造与声明新变量的声明非常相似。首先是类型，然后是变量名（在这里是对象名）。在声明对象时，几乎同时发生两件事：首先为对象分配内存（创建），然后使用默认值初始化属性（构造）。在上面的例子中，由于所有属性都是整数，C 语言中的默认整数值将是 0。

+   在 C 语言和许多其他编程语言中，我们使用点 (`.`) 来访问对象内的属性，或者使用箭头 (`->`) 来通过存储在指针中的地址间接访问结构的属性。语句 `p1.x`（如果 `p1` 是指针，则为 `p1->x`）应读作 *p1 对象中的 x 属性*。

如你所知，属性当然不是唯一可以封装到对象中的东西。现在我们来看看功能是如何封装的。

## 行为封装

对象只是一个属性和方法胶囊。方法是我们通常用来表示保存在对象中的逻辑或功能的标准术语。它可以被认为是一个具有名字、参数列表和返回类型的 C 函数。属性传达*值*，方法传达*行为*。因此，一个对象有一系列值，可以在系统中执行某些行为。

在基于类的面向对象语言，如 C++中，将多个属性和方法组合到一个类中非常容易。在基于原型的语言，如 JavaScript 中，我们通常从一个空对象（*ex nihilo*，或“无中生有”）或从现有对象克隆开始。为了在对象中拥有行为，我们需要添加方法。看看以下例子，它有助于你了解原型编程语言是如何工作的。它是用 JavaScript 编写的：

```cpp
// Construct an empty object
var clientObj = {};
// Set the attributes
clientObj.name = "John";
clientObj.surname = "Doe";
// Add a method for ordering a bank account
clientObj.orderBankAccount = function () {
  ...
}
...
// Call the method
clientObj.orderBankAccount();
```

代码框 6-5：在 JavaScript 中构造客户端对象

正如这个例子所示，在第 2 行，我们创建了一个空对象。在接下来的两行中，我们向我们的对象添加了两个新属性，`name`和`surname`。然后在下一行，我们添加了一个新的方法，`orderBankAccount`，它指向一个函数定义。这一行实际上是一个赋值操作。在右侧是一个*匿名函数*，它没有名字，被分配给了左侧对象的`orderBankAccount`属性。换句话说，我们将一个函数存储到了`orderBankAccount`属性中。在最后一行，调用了对象的`orderBankAccount`方法。这个例子是原型编程语言的优秀演示，这些语言最初只依赖于一个空对象，没有更多。

在基于类的编程语言中，前面的例子会有所不同。在这些语言中，我们首先编写一个类，因为没有类，我们就不能有任何对象。下面的代码框包含了之前的例子，但用 C++编写：

```cpp
class Client {
public:
  void orderBankAccount() {
    ...
  }
  std::string name;
  std::string surname:
};
...
Client clientObj;
clientObj.name = "John";
clientObj.surname = "Doe";
...
clientObj.orderBankAccount ();
```

代码框 6-6：在 C++中构造客户端对象

正如你所见，我们首先声明了一个新的类，`Client`。在第 1 行，我们声明了一个类，它立即成为了一个新的 C++类型。它类似于一个胶囊，被大括号包围。在声明类之后，我们从`Client`类型构造了`clientObj`对象。

在接下来的几行中，我们设置了属性，最后，我们在`clientObj`对象上调用了`orderBankAccount`方法。

**注意：**

在 C++这样的基于类的面向对象语言中，方法通常被称为*成员函数*，属性被称为*数据成员*。

如果你观察开源和知名的 C 项目所采用的封装某些项目的技术，你会发现它们之间有一个共同的主题。在本节的剩余部分，我们将提出一种基于此类项目中观察到的类似技术的行为封装技术。

由于我们经常会回溯到这个技术，我将给它起一个名字。我们称这个技术为**隐式封装**。它是隐式的，因为它不提供 C 语言所知的明确的行为封装。基于 ANSI C 标准中我们目前所拥有的内容，我们无法让 C 语言知道类。因此，所有试图在 C 语言中实现面向对象技术的技术都必须是隐式的。

隐式封装技术建议以下内容：

+   使用 C 结构来保存对象的属性（显式属性封装）。这些结构被称为**属性结构**。

+   对于行为封装，使用 C 函数。这些函数被称为**行为函数**。正如你可能知道的，在 C 语言的结构中我们不能有函数。因此，这些函数必须存在于属性结构之外（隐式行为封装）。

+   行为函数必须接受一个结构指针作为它们的参数之一（通常是第一个或最后一个参数）。这个指针指向对象的属性结构。这是因为行为函数可能需要读取或修改对象的属性，这是非常常见的。

+   行为函数应该有合适的名字来表明它们与同一类对象相关。这就是为什么在使用这个技术时坚持一致的命名约定非常重要。这是我们在这几章中试图坚持的两个命名约定之一，以便实现清晰的封装。另一个是在属性结构的名称中使用`_t`后缀。然而，当然，我们并不强迫这样做，你可以使用你自己的自定义命名约定。

+   对应于行为函数的声明语句通常放在用于保持属性结构声明的同一个头文件中。这个头文件被称为**声明头文件**。

+   行为函数的定义通常放在一个或多个单独的源文件中，这些源文件包括声明头文件。

注意，在隐式封装中，类确实存在，但它们是隐式的，只有程序员知道。以下示例*示例 6.1*展示了如何在真实的 C 程序中使用这种技术。它是一个关于汽车对象，直到耗尽燃料并停止加速的例子。

以下头文件作为*示例 6.1*的一部分，包含了新类型`car_t`的声明，它是`Car`类的属性结构。该头文件还包含了`Car`类行为函数所需的声明。我们使用“`Car`类”这个短语来指代 C 代码中缺失的隐式类，它集体包括了属性结构和行为函数：

```cpp
#ifndef EXTREME_C_EXAMPLES_CHAPTER_6_1_H
#define EXTREME_C_EXAMPLES_CHAPTER_6_1_H
// This structure keeps all the attributes
// related to a car object
typedef struct {
  char name[32];
  double speed;
  double fuel;
} car_t;
// These function declarations are 
// the behaviors of a car object
void car_construct(car_t*, const char*);
void car_destruct(car_t*);
void car_accelerate(car_t*);
void car_brake(car_t*);
void car_refuel(car_t*, double);
#endif
```

代码框 6-7 [ExtremeC_examples_chapter6_1.h]：Car 类的属性结构和行为函数的声明

正如你所见，属性结构`car_t`有三个字段——`name`、`speed`和`fuel`——它们是汽车对象的属性。请注意，`car_t`现在是一个新的 C 语言类型，我们现在可以声明此类类型的变量。行为函数通常也声明在同一个头文件中，正如你可以在前面的代码框中看到的那样。它们以`car_`前缀开头，以强调它们都属于同一个类。

关于隐式封装技术的一个重要事项：每个对象都有自己的唯一属性结构变量，但所有对象共享相同的行为函数。换句话说，我们必须为每个对象从属性结构类型创建一个专用变量，但我们只编写一次行为函数，并为不同的对象调用它们。

注意，`car_t`属性结构本身不是一个类。它只包含`Car`类的属性。所有声明共同构成了隐式的`Car`类。随着我们的深入，你会看到更多这样的例子。

有许多著名的开源项目使用前面的技术来编写半面向对象的代码。一个例子是`libcurl`。如果你查看它的源代码，你会看到很多以`curl_`开头的结构和函数。你可以在这里找到此类函数的列表：[`curl.haxx.se/libcurl/c/allfuncs.html`](https://curl.haxx.se/libcurl/c/allfuncs.html)。

以下源文件包含了作为示例 6.1 一部分的行为函数的定义：

```cpp
#include <string.h>
#include "ExtremeC_examples_chapter6_1.h"
// Definitions of the above functions
void car_construct(car_t* car, const char* name) {
  strcpy(car->name, name);
  car->speed = 0.0;
  car->fuel = 0.0;
}
void car_destruct(car_t* car) {
  // Nothing to do here!
}
void car_accelerate(car_t* car) {
  car->speed += 0.05;
  car->fuel -= 1.0;
  if (car->fuel < 0.0) {
    car->fuel = 0.0;
  }
}
void car_brake(car_t* car) {
  car->speed -= 0.07;
  if (car->speed < 0.0) {
    car->speed = 0.0;
  }
  car->fuel -= 2.0;
  if (car->fuel < 0.0) {
    car->fuel = 0.0;
  }
}
void car_refuel(car_t* car, double amount) {
  car->fuel = amount;
}
```

代码框 6-8 [ExtremeC_examples_chapter6_1.c]：作为`Car`类一部分的行为函数的定义

`Car`的行为函数在*代码框 6-8*中定义。正如你所见，所有这些函数都接受一个`car_t`指针作为它们的第一个参数。这允许函数读取和修改对象的属性。如果一个函数没有接收属性结构的指针，那么它可以被认为是一个普通的 C 函数，它不表示对象的任何行为。

注意，行为函数的声明通常位于它们对应的属性结构声明旁边。这是因为程序员是负责维护属性结构和行为函数之间对应关系的唯一人员，维护应该是足够简单的。这就是为什么将这两组保持在一起，通常在同一个头文件中，有助于维护类的整体结构，并减轻未来工作的痛苦。

在下面的代码框中，你会找到包含`main`函数和执行主要逻辑的源文件。所有行为函数都将在这里使用：

```cpp
#include <stdio.h>
#include "ExtremeC_examples_chapter6_1.h"
// Main function
int main(int argc, char** argv) {
  // Create the object variable
  car_t car;
  // Construct the object
  car_construct(&car, "Renault");
  // Main algorithm
  car_refuel(&car, 100.0);
  printf("Car is refueled, the correct fuel level is %f\n",
    car.fuel);
  while (car.fuel > 0) {
    printf("Car fuel level: %f\n", car.fuel);
    if (car.speed < 80) {
      car_accelerate(&car);
      printf("Car has been accelerated to the speed: %f\n", 
  car.speed);
    } else {
      car_brake(&car);
      printf("Car has been slowed down to the speed: %f\n",
  car.speed);
    }
  }
  printf("Car ran out of the fuel! Slowing down ...\n");
  while (car.speed > 0) {
    car_brake(&car);
    printf("Car has been slowed down to the speed: %f\n", 
      car.speed);
  }
  // Destruct the object
  car_destruct(&car);
  return 0;
} 
```

代码框 6-9 [ExtremeC_examples_chapter6_1_main.c]：示例 6.1 的主函数

作为`main`函数中的第一条指令，我们已从`car_t`类型声明了`car`变量。变量`car`是我们第一个`car`对象。在这一行，我们为对象的属性分配了内存。在下一行，我们构建了对象。现在在这一行，我们初始化了属性。你只能在为对象的属性分配了内存的情况下初始化对象。在代码中，构造函数接受第二个参数作为汽车的名字。你可能已经注意到，我们将`car`对象的地址传递给了所有的`car_*`行为函数。

在`while`循环之后，`main`函数读取`fuel`属性并检查其值是否大于零。事实上，`main`函数，作为一个非行为函数，能够访问（读取和写入）`car`的属性，这是一个重要的事情。例如，`fuel`和`speed`属性是*公共*属性的例子，除了行为函数之外的其他函数（外部代码）也可以访问。我们将在下一节回到这个点。

在离开`main`函数并结束程序之前，我们已经销毁了`car`对象。这仅仅意味着对象分配的资源在这一阶段被释放了。关于这个例子中的`car`对象，没有需要执行销毁操作，但并不总是这样，销毁可能需要遵循一些步骤。我们将在接下来的例子中看到更多关于这一点的内容。销毁阶段是强制性的，可以防止堆分配时的内存泄漏。

看看我们如何将前面的例子写成 C++代码会很好。这有助于你了解面向对象的语言是如何理解类和对象的，以及它是如何减少编写正确面向对象代码的开销的。

以下代码框，作为*示例 6.2*的一部分，显示了包含 C++中`Car`类的头文件：

```cpp
#ifndef EXTREME_C_EXAMPLES_CHAPTER_6_2_H
#define EXTREME_C_EXAMPLES_CHAPTER_6_2_H
class Car {
public:
  // Constructor
  Car(const char*);
  // Destructor
  ~Car();
  void Accelerate();
  void Brake();
  void Refuel(double);
  // Data Members (Attributes in C)
  char name[32];
  double speed;
  double fuel;
};
#endif
```

代码框 6-10 [ExtremeC_examples_chapter6_2.h]: C++中 Car 类的声明

前面代码的主要特点是 C++知道类。因此，前面的代码演示了显式封装；属性和行为封装。不仅如此，C++还支持更多的面向对象的概念，如构造函数和析构函数。

在 C++代码中，所有的声明，无论是属性还是行为，都被封装在类定义中。这是显式封装。看看我们声明的第一个和第二个函数，我们将它们声明为类的构造函数和析构函数。C 不知道构造函数和析构函数；但 C++有它们自己的特定符号。例如，析构函数以~开头，并且与类的名字相同。

此外，正如你所看到的，行为函数缺少第一个指针参数。这是因为它们都可以访问类内部的属性。下一个代码框显示了包含已声明行为函数定义的源文件内容：

```cpp
#include <string.h>
#include "ExtremeC_examples_chapter6_2.h"
Car::Car(const char* name) {
  strcpy(this->name, name);
  this->speed = 0.0;
  this->fuel = 0.0;
}
Car::~Car() {
  // Nothing to do
}
void Car::Accelerate() {
  this->speed += 0.05;
  this->fuel -= 1.0;
  if (this->fuel < 0.0) {
    this->fuel = 0.0;
  }
}
void Car::Brake() {
  this->speed -= 0.07;
  if (this->speed < 0.0) {
    this->speed = 0.0;
  }
  this->fuel -= 2.0;
  if (this->fuel < 0.0) {
    this->fuel = 0.0;
  }
}
void Car::Refuel(double amount) {
  this->fuel = amount;
}
```

代码框 6-11 [ExtremeC_examples_chapter6_2.cpp]：C++中 Car 类的定义

如果你仔细观察，你会发现 C 代码中的`car`指针已经被 C++中的`this`指针所取代，`this`是 C++中的一个关键字。关键字`this`简单地说就是当前对象。这里我就不再进一步解释了，但这是一个聪明的解决方案，用来消除 C 语言中的指针参数，并使行为函数更简单。

最后，以下代码框包含了使用前面类定义的`main`函数：

```cpp
// File name: ExtremeC_examples_chapter6_2_main.cpp
// Description: Main function
#include <iostream>
#include "ExtremeC_examples_chapter6_2.h"
// Main function
int main(int argc, char** argv) {
  // Create the object variable and call the constructor
  Car car("Renault");
  // Main algorithm
  car.Refuel(100.0);
  std::cout << "Car is refueled, the correct fuel level is "
    << car.fuel << std::endl;
  while (car.fuel > 0) {
    std::cout << "Car fuel level: " << car.fuel << std::endl;
    if (car.speed < 80) {
      car.Accelerate();
      std::cout << "Car has been accelerated to the speed: "
        << car.speed << std::endl;
    } else {
      car.Brake();
      std::cout << "Car has been slowed down to the speed: "
        << car.speed << std::endl;
    }
  }
  std::cout << "Car ran out of the fuel! Slowing down ..."
    << std::endl;
  while (car.speed > 0) {
    car.Brake();
    std::cout << "Car has been slowed down to the speed: "
      << car.speed << std::endl;
  }
  std::cout << "Car is stopped!" << std::endl;
  // When leaving the function, the object 'car' gets
  // destructed automatically.
  return 0;
}
```

代码框 6-12 [ExtremeC_examples_chapter6_2_main.cpp]：示例 6.2 的主函数

为 C++编写的`main`函数与我们为 C 编写的非常相似，只是它为类变量分配内存而不是结构变量。

在 C 中，我们不能将属性和行为函数组合在一起，因为 C 语言知道这个组合。相反，我们必须使用文件来分组它们。但在 C++中，我们有这种组合的语法，即*类定义*。它允许我们将数据成员（或属性）和成员函数（或行为函数）放在同一个地方。

由于 C++知道封装，因此向行为函数传递指针参数是多余的，正如你所看到的，在 C++中，我们在成员函数声明中没有任何像 C 版本的`Car`类中那样的第一个指针参数。

那么，发生了什么？我们在 C 语言，这是一种过程式编程语言，和 C++语言，这是一种面向对象的语言，都编写了一个面向对象的程序。最大的变化是使用`car.Accelerate()`代替`car_accelerate(&car)`，或者使用`car.Refuel(1000.0)`代替`car_refuel(&car, 1000.0)`。

换句话说，如果我们在一个过程式编程语言中执行`func(obj, a, b, c, ...)`这样的调用，我们可以在面向对象的语言中这样做`obj.func(a, b, c, ...)`。它们是等效的，但来自不同的编程范式。就像我们之前说的那样，有无数使用这种技术的 C 项目例子。

**注意：**

在*第九章*，*C++中的抽象和面向对象*，你会看到 C++使用完全相同的先导技术，将高级 C++函数调用转换为低级 C 函数调用。

作为最后的注意事项，C 和 C++在对象销毁方面有一个重要的区别。在 C++中，每当在栈上分配一个对象并且它即将超出作用域时，析构函数会自动调用，就像任何其他栈变量一样。这是 C++内存管理的一个重大成就，因为在 C 中，你可能会忘记调用析构函数，最终导致内存泄漏。

现在是时候讨论封装的其他方面了。在下一节中，我们将讨论封装的一个后果：信息隐藏。

## 信息隐藏

到目前为止，我们已经解释了封装如何将属性（代表值）和功能（代表行为）捆绑在一起形成对象。但这并没有结束。

封装还有一个重要的目的或后果，那就是*信息隐藏*。信息隐藏是指保护（或隐藏）一些不应对外界可见的属性和行为。这里的“外界”指的是不属于对象行为的代码的所有部分。根据这个定义，如果没有是类公共接口的一部分，那么没有任何其他代码，或者简单地说，没有任何其他 C 函数可以访问对象的私有属性或私有行为。

注意，同一类型的两个对象的行为，例如`Car`类中的`car1`和`car2`，可以访问同一类型的任何对象的属性。这是因为我们为类中的所有对象编写一次行为函数。

在*示例 6.1*中，我们看到`main`函数很容易访问`car_t`属性结构中的`speed`和`fuel`属性。这意味着`car_t`类型中的所有属性都是公共的。拥有公共属性或行为可能是一件坏事，因为它可能有一些长期和危险的影响。

作为结果，实现细节可能会泄露出来。假设你打算使用一个汽车对象。通常，对你来说，重要的是它有一个加速汽车的行为；而你并不好奇它是如何实现的。对象中可能有更多的内部属性有助于加速过程，但没有合理的理由让它们对消费者逻辑可见。

例如，提供给发动机启动器的电流量可能是一个属性，但它应该仅对对象本身是私有的。这也适用于对象内部的一些行为。例如，将燃料注入燃烧室是一种内部行为，不应该对你可见和可访问，否则你可能会干扰它并中断发动机的正常工作过程。

从另一个角度来看，实现细节（汽车是如何工作的）因汽车制造商而异，但能够加速汽车是一种所有汽车制造商都提供的行为。我们通常说，能够加速汽车是`Car`类的*公共 API*或*公共接口*的一部分。

通常情况下，使用对象的代码会依赖于该对象的公共属性和行为。这是一个严重的问题。最初将内部属性声明为公共的，然后将其设置为私有，可能会导致依赖于该属性的代码构建失败。预期使用该属性作为公共事物的代码的其他部分在更改后不会编译。

这意味着你破坏了向后兼容性。这就是为什么我们选择保守的方法，默认将每个属性都设置为私有，直到我们找到将其公开的合理理由。

简而言之，从类中公开私有代码实际上意味着我们不是依赖于轻量级的公共接口，而是依赖于厚重的实现。这些后果是严重的，有可能导致项目中的大量返工。因此，保持属性和行为尽可能私有是很重要的。

下面的代码框，作为*示例 6.3*的一部分，将展示如何在 C 语言中拥有私有属性和行为。这个例子是关于一个`List`类，它应该存储一些整数值：

```cpp
#ifndef EXTREME_C_EXAMPLES_CHAPTER_6_3_H
#define EXTREME_C_EXAMPLES_CHAPTER_6_3_H
#include <unistd.h>
// The attribute structure with no disclosed attribute
struct list_t;
// Allocation function
struct list_t* list_malloc();
// Constructor and destructor functions
void list_init(struct list_t*);
void list_destroy(struct list_t*);
// Public behavior functions
int list_add(struct list_t*, int);
int list_get(struct list_t*, int, int*);
void list_clear(struct list_t*);
size_t list_size(struct list_t*);
void list_print(struct list_t*);
#endif
```

代码框 6-13 [ExtremeC_examples_chapter6_3.h]: List 类的公共接口

在前面的代码框中看到的是我们使属性私有的方式。如果另一个源文件，例如包含`main`函数的文件，包含了前面的头文件，它将无法访问`list_t`类型内部的属性。原因很简单。`list_t`只是一个声明而没有定义，仅通过结构声明，你无法访问结构体的字段。你甚至无法从它中声明一个变量。这样，我们保证了信息隐藏。这实际上是一项伟大的成就。

再次强调，在创建和发布头文件之前，必须仔细检查是否需要公开某些内容。通过公开公共行为或公共属性，你会创建依赖关系，其破坏将耗费你时间、开发努力，并最终导致金钱损失。

下面的代码框展示了`list_t`属性结构的实际定义。请注意，它是在源文件中定义的，而不是在头文件中：

```cpp
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 10
// Define the alias type bool_t
typedef int bool_t;
// Define the type list_t
typedef struct {
 size_t size;
 int* items;
} list_t;
// A private behavior which checks if the list is full
bool_t __list_is_full(list_t* list) {
  return (list->size == MAX_SIZE);
}
// Another private behavior which checks the index
bool_t __check_index(list_t* list, const int index) {
  return (index >= 0 && index <= list->size);
}
// Allocates memory for a list object
list_t* list_malloc() {
  return (list_t*)malloc(sizeof(list_t));
}
// Constructor of a list object
void list_init(list_t* list) {
  list->size = 0;
  // Allocates from the heap memory
  list->items = (int*)malloc(MAX_SIZE * sizeof(int));
}
// Destructor of a list object
void list_destroy(list_t* list) {
  // Deallocates the allocated memory
  free(list->items);
}
int list_add(list_t* list, const int item) {
  // The usage of the private behavior
  if (__list_is_full(list)) {
    return -1;
  }
  list->items[list->size++] = item;
  return 0;
}
int list_get(list_t* list, const int index, int* result) {
  if (__check_index(list, index)) {
    *result = list->items[index];
    return 0;
  }
  return -1;
}
void list_clear(list_t* list) {
  list->size = 0;
}
size_t list_size(list_t* list) {
  return list->size;
}
void list_print(list_t* list) {
  printf("[");
  for (size_t i = 0; i < list->size; i++) {
    printf("%d ", list->items[i]);
  }
  printf("]\n");
}
```

代码框 6-14 [ExtremeC_examples_chapter6_3.c]: List 类的定义

在前面的代码框中看到的所有定义都是私有的。将要使用`list_t`对象的外部逻辑对前面的实现一无所知，头文件是外部代码唯一依赖的代码片段。

注意，前面的文件甚至没有包含头文件！只要定义和函数签名与头文件中的声明相匹配，这就足够了。然而，建议这样做，因为这保证了声明与其对应定义之间的兼容性。正如您在*第二章*，*编译和链接*中看到的，源文件是分别编译的，最后链接在一起。

实际上，链接器将私有定义带到公共声明中，并从中制作出一个可工作的程序。

**注意：**

我们可以为私有行为函数使用不同的表示法。我们在它们的名称中使用前缀`__`。例如，`__check_index`函数是一个私有函数。请注意，私有函数在头文件中没有相应的声明。

下面的代码框包含*示例 6.3*的`main`函数，该函数创建两个列表对象，填充第一个，并使用第二个列表存储第一个列表的逆序。最后，它将它们打印出来：

```cpp
#include <stdlib.h>
#include "ExtremeC_examples_chapter6_3.h"
int reverse(struct list_t* source, struct list_t* dest) {
  list_clear(dest);
  for (size_t i = list_size(source) - 1; i >= 0; i--) {
    int item;
    if(list_get(source, i, &item)) {
      return -1;
    }
    list_add(dest, item);
  }
  return 0;
}
int main(int argc, char** argv) {
  struct list_t* list1 = list_malloc();
  struct list_t* list2 = list_malloc();
  // Construction
  list_init(list1);
  list_init(list2);
  list_add(list1, 4);
  list_add(list1, 6);
  list_add(list1, 1);
  list_add(list1, 5);
  list_add(list2, 9);
  reverse(list1, list2);
  list_print(list1);
  list_print(list2);
  // Destruction
  list_destroy(list1);
  list_destroy(list2);
  free(list1);
  free(list2);
  return 0;
}
```

代码框 6-15 [ExtremeC_examples_chapter6_3_main.c]：示例 6.3 的`main`函数

如您在前面的代码框中所见，我们只根据头文件中声明的功能编写了`main`和`reverse`函数。换句话说，这些函数仅使用了`List`类的公共 API（或公共接口）；属性结构`list_t`及其行为函数的声明。这个例子很好地展示了如何打破依赖关系，并从代码的其他部分隐藏实现细节。

**注意：**

使用公共 API，您可以编写一个可以编译的程序，但除非您提供私有部分的相应对象文件并将它们链接在一起，否则它不能成为一个真正的可工作程序。

在前面的代码中，有一些相关点我们在下面进行了更详细的探讨。我们需要有一个`list_malloc`函数来为`list_t`对象分配内存。然后，当我们完成对象时，我们可以使用`free`函数释放分配的内存。

在前面的例子中，您不能直接使用`malloc`。这是因为如果您打算在`main`函数中使用`malloc`，您必须传递`sizeof(list_t)`作为应该分配的字节数。然而，您不能对不完整类型使用`sizeof`。

从头文件中包含的`list_t`类型是一个*不完整类型*，因为它只是一个声明，没有提供有关其内部字段的信息，并且在编译时我们不知道它的大小。实际的大小只有在链接时间确定实现细节时才会确定。作为解决方案，我们必须定义`list_malloc`函数，并在`sizeof(list_t)`确定的地方使用`malloc`。

为了构建*示例 6.3*，我们首先需要编译源文件。以下命令在链接阶段之前生成必要的对象文件：

```cpp
$ gcc -c ExtremeC_examples_chapter6_3.c -o private.o
$ gcc -c ExtremeC_examples_chapter6_3_main.c -o main.o
```

Shell Box 6-1: 编译示例 6.3

如你所见，我们将私有部分编译成 `private.o`，将主要部分编译成 `main.o`。记住，我们不编译头文件。头文件中的公共声明包含在 `main.o` 对象文件中。

现在我们需要将前面的对象文件链接在一起，否则 `main.o` 单独不能变成可执行程序。如果你尝试仅使用 `main.o` 创建可执行文件，你会看到以下错误：

```cpp
$ gcc main.o -o ex6_3.out
main.o: In function 'reverse':
ExtremeC_examples_chapter6_3_main.c:(.text+0x27): undefined reference to 'list_clear'
...
main.o: In function 'main':
ExtremeC_examples_chapter6_3_main.c:(.text+0xa5): undefined reference to 'list_malloc'
...                                                                                                                               collect2: error: ld returned 1 exit status
$
```

Shell Box 6-2: 仅通过提供 main.o 尝试链接示例 6.3

你会看到链接器找不到在头文件中声明的函数的定义。链接示例的正确方法是：

```cpp
$ gcc main.o private.o -o ex6_3.out
$ ./ex6_3.out
[4 6 1 5 ]
[5 1 6 4 ]
$
```

Shell Box 6-3: 将示例 6.3 链接并运行

如果你更改 `List` 类背后的实现会发生什么？

假设，而不是使用数组，你使用链表。看起来我们不需要再次生成 `main.o`，因为它很好地独立于它使用的列表的实现细节。因此，我们只需要为新实现编译并生成一个新的对象文件；例如，`private2.o`。然后，我们只需要重新链接对象文件并获取新的可执行文件：

```cpp
$ gcc main.o private2.o -o ex6_3.out
$ ./ex6_3.out
[4 6 1 5 ]
[5 1 6 4 ]
$
```

Shell Box 6-4: 将示例 6.3 与 List 类的不同实现链接并运行

如你所见，从用户的角度来看，没有任何变化，但底层实现已被替换。这是一项巨大的成就，这种方法在 C 项目中被广泛使用。

如果我们想在新的列表实现的情况下不重复链接阶段，该怎么办？在这种情况下，我们可以使用共享库（或 `.so` 文件）来包含私有对象文件。然后，我们可以在运行时动态加载它，从而无需再次重新链接可执行文件。我们已在 *第三章*，*对象文件* 中讨论了共享库。

在这里，我们将结束本章，并在下一章继续我们的讨论。接下来的两章将讨论两个类之间可能存在的可能关系。

# 摘要

在本章中，以下主题已被讨论：

+   我们对面向对象哲学进行了详尽的解释，以及如何从你的思维导图中提取对象模型。

+   我们还介绍了领域概念及其如何用于过滤思维导图，仅保留相关概念和想法。

+   我们还介绍了单个对象的属性和行为，以及它们应该如何从领域描述中的思维导图或需求中提取。

+   我们解释了为什么 C 不能成为面向对象编程（OOP）语言，并探讨了它在将 OOP 程序翻译成最终将在 CPU 上运行的底层汇编指令中的作用。

+   封装作为面向对象编程（OOP）的第一原则已被讨论。我们使用封装来创建胶囊（或对象），它们包含一组属性（值的占位符）和一组行为（逻辑的占位符）。

+   信息隐藏也被讨论了，包括它如何导致可以不依赖底层实现而使用的接口（或 API）。

+   在讨论信息隐藏时，我们展示了如何在 C 代码中使属性或方法私有化。

下一章将开启关于类之间可能存在关系的讨论。我们开始**第七章**，**组合与聚合**，先讨论组合关系，然后，在**第八章**，**继承与多态**中，我们继续讨论继承和多态。
