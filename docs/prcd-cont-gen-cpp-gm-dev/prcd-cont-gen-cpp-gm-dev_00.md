# 前言

电脑游戏是一个庞大的媒介，已经发展了三到四十年。游戏比以往任何时候都更大、更沉浸，玩家的期望也从未如此之高。虽然线性游戏，即具有固定故事和固定进度的游戏，仍然很常见，但越来越多的动态和开放式的游戏正在被开发。

计算机硬件和视频游戏技术的进步正在给“游戏世界”这个词带来更加直接的意义。游戏地图不断增加，变得更加灵活，这要归功于过程生成等技术的发展。由于内容是动态生成的，所以购买同一款游戏的两名玩家可能会有非常不同的体验。

在本书中，我们将介绍过程生成，学习生成内容以创建动态和不可预测的游戏系统和机制所需的技能。

本书提供了一个流氓式 C++游戏的游戏模板。当我们在第二章“项目设置和拆分”中编译和设置项目时，您会发现它目前只是一个空壳。然而，随着我们在书中的学习，您将通过真实的例子了解到程序生成内容背后的概念。然后我们将在空项目中实现这些例子。

# 本书涵盖的内容

第一章，“过程生成简介”，向我们介绍了过程生成的广阔主题。我一直觉得真正学会某事的关键部分是理解为什么要以这种方式完成。了解如何完成某事固然很重要，但了解其起源以及为什么会以这种方式完成则会创造出更完整的画面和更深刻的理解。在本章中，我们将回到过程生成的诞生以及它进入现代电脑游戏的历程。

第二章，“项目设置和拆分”，解释了如何在您选择的 IDE 中设置提供的流氓式游戏项目，并为 Visual Studio 和 Code::Blocks 提供了详细的说明。它是用 C++/SFML 编写的，我们将在整本书中进行扩展。我们还将介绍您可能遇到的常见问题，并首次运行该项目。

第三章，“使用 C++数据类型进行 RNG”，探讨了随机数生成（RNG），包括围绕它的问题以及我们如何在运行时使用它与 C++数据类型来实现随机结果。RNG 是过程生成的核心，是我们模拟计算机随机行为并通过算法实现动态结果的方式。

第四章，“过程填充游戏环境”，帮助我们通过在地图周围的随机位置生成物品和敌人来进一步开发我们的关卡。在过程生成的游戏中，生成环境是一个基本的部分，而在随机位置生成游戏对象是实现这一目标的重要一步。

第五章，“创建独特和随机的游戏对象”，探讨了我们如何创建独特和随机的游戏对象。在运行时，某些物品将被过程生成，这意味着可能会有大量的可能组合。我们将介绍在前几章中用于实现这一点的技能和技术。我们将把所有这些内容整合在一起，构建一个过程系统！

第六章，“程序生成艺术”，通过摆脱简单地随机设置成员变量，转而创建程序生成的艺术和图形，进一步提升了我们的程序生成工作。我们将为我们的敌人程序生成纹理，并修改关卡精灵，使我们的地牢每一层都具有独特的感觉。

第七章，“程序修改音频”，研究了艺术的近亲音频，使用类似的技术来为我们的声音创建差异。我们还将使用 SFML 的音频功能来创建专门的 3D 声音，为我们的关卡带来更多深度。

第八章，“程序行为和机制”，利用我们迄今为止学到的一切知识，创建复杂的程序行为和机制，如寻路和独特的关卡目标。我们将赋予我们的敌人智能，让他们穿越关卡并追逐玩家。我们还将创建独特的关卡目标，并为玩家执行带来独特的奖励。

第九章，“程序地牢生成”，完成了我们对游戏项目的工作。我们将实现也许是 roguelike 游戏最具代表性的特征：程序生成的关卡。在整本书中，我们一直在使用相同的固定关卡。所以，是时候开始程序生成它们了！我们还将在关卡之间创建一些差异，并实现我们在上一章中创建的目标生成器。

第十章，“基于组件的架构”，介绍了基于组件的设计，因为我们的模板项目的工作现在已经完成。程序生成的关键在于灵活性。因此，我们希望使用最灵活的架构进行工作。基于组件的架构可以实现这一点，对这种设计方法有很好的理解将有助于您未来的进步和构建更大的系统。

第十一章，“结语”，回顾了项目和我们在完成程序生成之旅时涉及的主题。对于我们使用的程序生成的每个领域，我们还将确定一些跳板，以便您希望深入探讨该主题。

# 您需要什么

在撰写本书的过程中，我使用了适用于 Windows 桌面的 Visual Studio Community 2015。这是一个很棒的 IDE，具有我们创建 Windows 的 C++游戏所需的所有工具。它可以免费从微软获得，因此我强烈建议您下载并在整本书的过程中使用它。

如果您以前从未使用过它，不要担心；我们将详细介绍项目设置，以便您熟悉我们将使用的 IDE 的各个部分。我还将提供 Code::Blocks 的设置说明。如果您选择不使用 IDE，您将需要访问 C++编译器，以便您可以运行我们在书中将要使用的项目。

# 这本书适合谁

这本书面向那些具有 C++游戏开发知识并希望将程序生成融入其游戏中的人。它将假定对编程基础有相当扎实的理解，如数据类型、返回类型、方法调用等。还假定对游戏开发背后的概念有一定了解，因为我们不会深入研究底层引擎。

提供了一个游戏模板，并且我们将在整本书的过程中使用 SFML 来扩展它。不需要有关 SFML 的先前经验。完成本书后，您将对程序生成的内容是什么，它在游戏中如何使用以及将应用于真实游戏的一系列实用技能有扎实的理解。

# 惯例

在本书中，您会发现一些文本样式，用于区分不同类型的信息。以下是一些这些样式的示例及其含义的解释。

文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 句柄显示如下："我们调用了`std::srand()`并设置了一个新的种子，但每次运行程序时，我们都再次设置相同的种子"

代码块设置如下：

```cpp
Stirng myStringLiteral = "hello";
string myString = { 'h', 'e', 'l', 'l', 'o', '\0' };
```

当我们希望引起您对代码块的特定部分的注意时，相关行或项目会以粗体显示：

```cpp
// If the enemy is dead remove it.
if (enemy.IsDead())
{
    enemyIterator = m_enemies.erase(enemyIterator);

    // If we have an active goal decrement killGoal.
 if (m_activeGoal)
 {
 --m_killGoal;
 }
}
```

**新术语**和**重要单词**以粗体显示。例如，屏幕上看到的单词，比如菜单或对话框中的单词，会以这样的方式出现在文本中："在 Code::Blocks 中，将以下内容添加到项目的**构建选项**和**搜索目录**选项卡中"。

### 注意

警告或重要提示会以这样的方式出现在框中。

### 提示

提示和技巧会以这种方式出现。

## 额外练习

每章结束时，都有一些复习问题和进一步的练习可以完成。虽然这对书籍并不是至关重要，但建议您完成它们，以便您可以衡量对所涵盖主题的理解，并获得更多经验。
