# C++游戏开发

从我小时候起，我就被告知，无论是追求体育运动的完美，学习乐器，甚至是新的技术技能，对基本原理的深刻理解和实践是决定成败的关键。用 C++进行游戏开发也是如此。在你掌握这个过程之前，你必须完善基础知识。这就是本书第一章的内容，涵盖了将在整本书中使用的基础概念。本章分为以下几个部分：

+   高级 C++概念概述

+   使用类型和容器

+   游戏编程模式

# 本书中使用的约定

在整本书中，你将遇到代码片段和示例。为了保持代码的可读性和统一性，我将遵循一些基本的编码约定。虽然编码标准的话题是一个复杂而冗长的讨论，但我认为为任何高级项目制定一些指导方针是很重要的。至少应该考虑在任何工作开始之前，制定一个可访问的指南，说明预期的符号和命名约定。如果你想了解更多关于 C++中常用的编码标准，一个很好的起点是 ISO C++网站上关于编码标准常见问题解答部分的链接[`isocpp.org/wiki/faq/coding-standards`](https://isocpp.org/wiki/faq/coding-standards)。在那里，你将找到各种情况下常用的标准以及一堆建议阅读的链接，以进一步扩展你的知识。

本书中使用的标准和约定基于一些核心 C++指南、行业最佳实践和我的个人经验。我们将在整本书中使用最新的 ISO C++标准，即 C++14。然而，有时我们可能会使用最新提议的修订版 C++17 的一些功能，也被称为 C++1y。当发生这种情况时，将会做出说明。

类和函数名称将遵循*MixedCase*风格，而变量将遵循*camelCase*风格。一些示例看起来会像下面这样：

```cpp
int m_numberOfPlayers; 

void RunScripts(){} 

class GameObject {}; 
```

本书中使用的另一个重要约定是你应该了解的作用域前缀的使用。作用域前缀是提高其他开发人员和你自己在不可避免地忘记变量所属作用域时的可读性的一种快速方法。以下是使用的前缀列表：

+   `m_`：这用于类成员变量。这些是`private`，通过使用前缀，告诉任何使用变量的人，它在类中是明显可用的，或者通过外部的 getter 或 setter，例如`m_numberOfPlayers`。

+   `s_`：这用于静态类成员。这告诉任何使用这个变量的人，在类的所有实例中只存在一个副本，并且它是静态的，例如`s_objDesc`。

+   `g_`：这用于全局变量。这告诉任何使用这个变量的人，它在任何地方都是可用的。我们在书中不会看到很多这样的变量，例如`g_playerInfo`。

# 高级 C++概念概述

在我们开始构建工具、库和其他游戏组件之前，最好先复习一下在整本书中会经常出现的一些更常见的概念。在本节中，我们将快速浏览一些高级主题。这并不意味着要列出一个完整的清单，目标也不是对每个主题进行全面的概述，而是在游戏开发时对概念进行回顾和解释。

我们将看一些简单的例子，并强调在处理这些概念时可能出现的一些问题。一些经验丰富的 C++ 开发人员可能能够跳过这一部分，但由于这些主题将在本书的其余部分中发挥重要作用，因此重要的是对它们每一个都有牢固的理解。如果您正在寻找更广泛的回顾或更深入的解释，请查看本章末尾*总结*部分中的一些建议阅读。

# 使用命名空间

与智能指针等相比，命名空间可能看起来不是一个非常高级的主题，但随着您在 C++ 游戏开发中的进展，命名空间将成为开发工具包的重要组成部分。简单回顾一下，命名空间是一个声明，为其封装内部的所有变量、类型和函数提供范围。这很重要，因为它为我们提供了一种将代码组织成逻辑组的方式。通过将代码分成这些组，我们不仅使其更易于阅读，还可以防止所谓的**名称冲突**。当您开始使用多个库时，名称冲突就会成为一个大问题。使用命名空间通过其作用域来防止这种情况。例如，假设我们为某个平台的专用字符串类实现了一个实现。为了防止这个专用版本干扰并与标准库实现发生冲突，我们可以像这样将我们的类型包装在一个命名空间中：

```cpp
namespace ConsoleHelper 
{ 
  class string 
  { 
    friend bool operator == (const string &string1,
    const string &string2); 
    friend bool operator < (const string &string1,
    const string &string2); 
    //other operators ... 
    public: 
    string (); 
    string(const char* input); 
    ~string() ; 
    //more functions ... 
  } 
} 
```

然后我们可以这样调用我们特定的字符串实现：

```cpp
ConsoleHelper::string name = new ConsoleHelper::string("Player Name");
```

当然，如果我们不想一遍又一遍地输入`ConsoleHelper`部分，我们可以添加一个`using`语句，告诉编译器使用特定的命名空间来查找我们正在使用的函数、类型和变量。您可以使用以下代码行为我们的命名空间做到这一点：

```cpp
using namespace ConsoleHelper; 
```

唯一的问题是它将包括所有`ConsoleHelper`库。如果我们只想包括命名空间的特定成员，我们可以使用以下语法：

```cpp
using namespace ConsoleHelper::string; 
```

这将只包括字符串成员，而不是整个命名空间。

# 继承和多态

继承和多态是可以轻松填满自己的章节的主题。它们是 C++ 非常复杂和强大的组成部分。我在这一部分的目标不是覆盖继承和多态的所有细节。相反，我想快速看一下这些概念如何帮助您构建代码结构。我们将涵盖重点，但我假设您对面向对象开发概念有基本的理解，并熟悉访问修饰符和友元等主题。

首先，我们将专注于继承。继承的概念是现代面向对象设计和开发的重要部分。虽然继承的能力可以节省击键，但当允许程序员开发派生类的复杂层次结构时，继承真正显示其力量。让我们通过一个简单的例子来看一下继承的使用。在这个例子中，我们创建了一个简单的`Enemy`类。这个类将处理实体的健康、武器、要造成的伤害、AI 脚本等等：

```cpp
class Enemy 
{ 
  public: 
    void RunAIScripts(); 
    void Update(double deltaTime); 
  private: 
    int m_health; 
    int m_damage; 
};
```

当我们开始向游戏中添加更多的敌人时，我们可能会开始添加一些不同的条件语句，以允许敌人有更多的变化。添加越来越多的`if`语句，甚至在这里和那里插入一些 switch 语句。这很快就变成了一团纠缠、难以阅读的代码混乱。如果我们决定添加一个略有不同的敌人-一个有自己可能的条件语句的敌人，比如一个 boss 敌人类型。这个新的 boss 敌人类型与原始的`Enemy`类有相似的结构，并且共享许多相同的类型和函数。我们可以将重叠的代码复制到我们的新`Boss`类中。这样可以运行，但这并不是理想的解决方案。我们会有很多代码重复，而这种不必要的重复会增加出错的机会。然后，如果你不得不修复一个 bug，现在你必须在多个地方进行修复。这是一个不必要的维护头痛。相反，我们可以使用继承。如果我们的新 boss 敌人类型继承自原始敌人类型，这意味着我们可以使用原始类提供给我们的类型和函数。继承的更强大之处在于，我们不仅可以采用继承类的函数，还可以用我们自己的实现来覆盖它们。新的`Boss`类可以这样写：

```cpp
class Boss : public Enemy 
{ 
  public: 
    void Update(double deltaTime); 
    //more functions... 
}; 
```

这种结构通常被称为**父**和**子**层次结构，其中`Boss`类是`Enemy`类的子类。这意味着`Boss`现在将拥有从`Enemy`类中继承的所有必需的结构。我应该指出，我们只继承了被声明为`public`的函数和变量。这是因为在使用继承时，类的`public`方法和变量对所有使用该类的人都是可见的。`protected`方法和变量只对类本身和任何派生类可用。`private`方法和变量只对该类可用，其他人无法访问，即使是派生类。

我们已经覆盖了`Update()`函数的实现，为新的`Boss`类提供了一个特殊版本。现在，在我们的代码中，我们可以写出以下内容：

```cpp
//Somewhere in game or level manager 
void UpdateObjects (double deltaTime) 
{ 
  enemy.Update(deltaTime); 
  boss.Update(deltaTime); 
} 
```

当这段代码运行时，它将调用对象的`Update()`函数的各个独立实现。另一方面，考虑到我们有以下代码：

```cpp
//Somewhere in game or level manager 
void UpdateAI () 
{ 
  enemy.RunAIScripts(); 
  boss.RunAIScripts (); 
} 
```

在这里，我们没有覆盖`RunAIScripts()`函数，因为它不继承原始类的函数实现。虽然这是一个非常基本的例子，但它确实展示了单一继承的能力，这让我想到了我的下一个主题-多重继承。

假设我们继续前面的例子，我们决定要添加一个新的敌人类型，一个可以飞行的 boss。我们有一个`Boss`类，一个`Enemy`类，甚至一个从`Enemy`类继承的`FlyingEnemy`类，看起来像这样：

```cpp
class FlyingEnemy : public Enemy 
{ 
  public: 
    void Update(double deltaTime); 
    void FlightAI(); 
    //many more functions...  
} 
```

问题是我们想要`FlyingEnemy`的功能，但我们也想要`Boss`的一些功能。同样，我们可以将我们想要的代码块复制到一个新的类中，但 C++为我们提供了一个更好的解决方案，**多重继承**。顾名思义，多重继承允许我们从多个来源派生我们的类。然后我们可以构建具有两个或更多父类的类，导致复杂的层次结构，但正如我们将看到的，这也可能导致一些问题。

继续我们的例子，我们的新`FlyingBoss`类会看起来像下面这样：

```cpp
class FlyingBoss : public Boss, public FlyingEnemy 
{ 
  public: 
    void Update(double deltaTime); 
    //other functions... 
} 
```

乍一看，这看起来像是完美的类，我们从两个父类中继承了我们需要的函数和变量。然而，在使用多重继承时，会出现一些问题。首先是歧义的问题。当被继承的两个或更多个类具有相同名称的函数或变量时，就会出现歧义。例如，在我们的例子中，如果我们没有覆盖`Update()`函数，并且在对象上调用`Update()`，编译器会查看我们从中继承的类的实现。由于它们都有相同名称的实现，编译器会抛出编译时错误，抱怨调用中的歧义。为了解决这个问题，我们必须在函数调用上使用前缀来标识我们想要使用的实现类。为此，我们在代码中使用作用域运算符(`::`)来从`FlyingEnemy`类中调用实现，代码看起来像这样：

```cpp
FlyingEnemy::Update(deltaTime); 
```

第二个问题可能不太明显；它与类继承树在我们的例子中的结构有关。表面上看，一切都很好；`FlyingBoss`类从`Boss`类和`FlyingEnemy`类继承。问题出现在继承树的上一层，`Boss`和`FlyingEnemy`类都从`Enemy`类继承。这在类层次结构中创建了可怕的死亡之钻模式。这可能看起来不是什么大问题，但是这种模式会导致一些不幸的问题。首先是再次出现歧义的问题。每当您尝试从`FlyingBoss`类访问`Enemy`类的任何成员变量或函数时，都会出现歧义。这是因为每个变量和函数都有多条路径。为了解决这个问题，我们可以通过再次使用作用域运算符(`::`)来指定我们想要遵循的路径。死亡之钻模式引起的另一个问题是重复的问题。当我们创建一个`FlyingBoss`对象时，它将拥有从`Boss`类继承的一切的两个副本。这是因为`FlyingEnemy`和`Boss`类都有从`Enemy`类继承的副本。正如您所看到的，这很混乱，可能会导致各种头痛。幸运的是，C++为我们提供了一个解决方案，即**虚拟继承**的概念。通过虚拟继承，我们可以确保父类只在任何子类中出现一次。要实现虚拟继承，我们只需在声明要继承的类时使用`virtual`关键字。在我们的例子中，类声明看起来会像这样：

```cpp
class Boss : public virtual Enemy 
{ 
  public: 
    //functions... 
}; 

class FlyingEnemy : public virtual Enemy 
{ 
  public: 
    //functions...  
} 

class FlyingBoss : public Boss, public FlyingEnemy 
{ 
  public: 
    //other functions... 
} 
```

现在`FlyingBoss`类只有一个通过继承获得的实例。

虽然这确实解决了死亡之钻和其他可能的层次问题，但这些问题通常是潜在设计问题的迹象。我建议在自动转向虚拟继承作为解决方案之前，研究所有其他选项。

最后，我想快速提到两个重要的主题，它们共同使继承成为了不可思议的工具，多态和虚函数。归结为基础知识，多态是将一个类的对象用作另一个类的一部分的能力。为了简单起见，让我们来看一下：

```cpp
FlyingBoss* FlyBoss = new FlyingBoss();  
```

这行代码创建了一个指向新的`FlyingBoss`对象的指针，这里没有什么新鲜的。然而，我们也可以这样创建一个新的指针：

```cpp
Boss* FlyBoss = new FlyingBoss(); 
```

这得益于继承和多态。我们能够将`FlyBoss`对象称为`Boss`类对象。现在可能看起来很简单，但随着你对 C++的理解不断深入，你会开始意识到这个概念有多么强大。它还引出了我想要在继承中谈到的最后一个话题，虚函数。由于我们可以创建这样的对象指针，如果我们在`FlyingBoss`对象的`Boss*`上调用`Update()`函数会发生什么？这就是虚函数发挥作用的地方。如果一个函数被标记为`virtual`关键字，就像这样：

```cpp
virtual void Update(double deltaTime); 
```

这告诉编译器使用调用函数的对象类型来确定在该情况下应该使用哪个实现。因此，在我们的例子中，如果我们在`FlyingBoss`实现中使用虚函数，那么当从`FlyingBoss`对象的`Boss*`调用时，它将使用该实现。

# 指针和引用

C++中最被误解和害怕的概念之一就是指针和引用的概念。这往往是新开发人员放弃继续学习 C++的原因。已经有许多书籍和教程试图揭开这个话题的神秘面纱，坦率地说，我很容易就能写一章甚至一本专门讨论指针和引用的内部和外部知识。我希望你现在已经对经典意义上的指针和引用这个话题感到满意，并对它们的力量和灵活性有了健康的欣赏。因此，在这一部分，我们不打算涵盖核心原则，而是看看更重要的用途，即经典指针和引用的用途，并简要介绍旨在帮助消除一些神秘感和内存管理问题的新指针。

我们将从经典指针和引用开始。虽然你很快就会看到使用新指针的好处，但我仍然相信，像许多 C++游戏开发人员一样，旧版本仍然有其存在的价值。其中一个地方就是在处理向函数传递数据时。在调用函数时，往往很容易写出以下代码：

```cpp
void MyFunction(GameObject myObj) 
{ 
  //do some object stuff 
} 
```

虽然这段代码完全合法，但如果对象的大小不容忽视，它可能会带来严重的性能问题。当传递这样的对象时，编译器会自动在内存中创建对象的副本。在大多数情况下，这不是我们想要的。为了防止编译器在内存中创建副本，我们可以使用经典指针或引用传递对象。前面的代码看起来会像这样：

```cpp
void MyFunction (GameObject& myObj) 
{ 
  //do some object stuff 
} 
```

或者，它看起来会像这样：

```cpp
void MyFunction (GameObject* myObj) 
{ 
  //do some object stuff 
} 
```

现在对象不会被复制到内存中，并允许我们通过解引用对实际对象进行操作。这是经典指针和引用的更常见和持续的用途之一。经典指针和引用的另一个常见用途是在处理字符串文字和移动对象时。这种类型的应用在许多游戏开发库中仍然很常见。因此，你应该习惯看到类似以下的代码：

```cpp
const char* pixelShader; 
```

随着现代 C++和 C++11 标准的推出，出现了一组新的托管指针，以帮助简化指针的理解和使用。这些新指针与经典指针非常相似，除了一个关键的区别；它们是托管的。这实际上意味着这些新指针将处理它们自己的内存分配和释放。由于经典指针的一个主要问题是必须手动管理内存和所有权的问题，这使得指针的使用更加受欢迎和更加灵活。这些托管指针（`unique_ptr`和`shared_ptr`）通常在更现代的游戏开发库中使用。

# unique_ptr 和 shared_ptr

`unique_ptr`或唯一指针被认为是智能指针。之所以称其为唯一，是因为这种类型的对象拥有其指针的唯一所有权。这意味着没有两个`unique_ptr`指针可以管理相同的对象，它是唯一的。`unique_ptr`的最大优势之一是它管理自己的生命周期。这意味着当指针超出范围时，它会自动销毁自身并释放其内存。这解决了可怕的悬空指针问题，并避免了内存泄漏。这也消除了所有权的问题，因为现在明确了谁删除了指针。

自 C++14 标准以来，我们现在可以使用一个方便的小函数来创建唯一指针，`make_unique`。`make_unique`函数创建了一个`T`类型的对象，然后将其包装在唯一指针中。使用`make_unique`创建`unique_ptr`指针的语法如下：

```cpp
    std::unique_ptr<T> p = new std::make_unique<T>();
```

创建后，您可以像使用经典指针一样使用指针。解引用运算符`*`和`->`的工作方式与通常情况下一样。这里的最大区别再次在于，当指针超出范围时，它会自动销毁，使我们不必手动跟踪每个退出点以避免任何内存泄漏问题。

`shared_ptr`或共享指针与唯一指针非常相似。它被认为是智能指针，可以自动处理内存的删除和释放。不同之处在于共享指针*共享*对象的所有权。这意味着，与唯一指针不同，共享指针可以是指向单个对象的多个共享指针之一。这意味着如果共享指针超出范围或指向另一个对象，通过`reset()`或`=`运算符，对象仍然存在。只有当拥有对象的所有`shared_ptr`对象被销毁、超出范围或重新分配给另一个指针时，对象才会被销毁并释放其内存。

与唯一指针一样，共享指针也有一个用于创建的方便函数。`make_shared`函数创建了一个`T`类型的对象，然后将其包装在共享指针中。使用`make_shared`函数创建`shared_ptr`函数的语法如下：

```cpp
std::shared_ptr<T> p = new std::make_shared<T>(); 
```

与唯一指针一样，共享指针也有典型的解引用运算符`*`和`->`。

# const 正确性

在 C++社区中，`const`正确性可能是一个有争议的话题。我第一门 C++课程的讲师甚至说`const`关键字是语言中最重要的关键字之一。当然，我也听到了另一种说法，开发人员告诉我他们从不使用`const`，这完全是在浪费击键。我认为我在`const`方面处于中间位置；我相信它有重要的用途，但它可能像任何其他特性一样被过度使用。在这一部分，我想展示一些更好的`const`使用方法。

简而言之，`const`关键字用作类型限定符，让编译器知道这个值或对象是不可变的。在开始学习 C++游戏开发时，你对`const`的第一次接触可能会很早。最常见的情况是，在定义我们想要轻松访问的重要值时，我们引入了*const-ness*的使用，比如这样：

```cpp
const int MAX_BULLETS = 100;
```

然后我们可以在代码的其他部分轻松多次使用这个命名值。这样做的最大优势是，如果我们决定更改值，比如子弹的最大数量，在这种情况下，我们只需更改这个常量值，而不必更改代码库中散布的大量硬编码值。

随着您深入 C++开发，`const`关键字将变得更加熟悉。它在库和引擎代码中以各种方式大量使用。它还用于函数参数的定义或用作函数定义的修饰符。让我们简要地看一下这些。

首先，在参数的定义中使用它，可以确保我们给定值的函数不会以任何方式修改它。例如，看下面的代码：

```cpp
void ObjFunction(GameObject &myObject) 
{ 
  //do stuff 
  If(*myObject.value == 0) 
  { 
    //run some logic 
    Game.changeState(newState); 
    //possible unknown modifier function 
    *myObject.value = 1; 
  } 
} 
```

好吧，这是一个非常简单的例子，但如果您调用这样的函数，却不知道它可能会修改对象，您最终会得到您可能没有预期的结果。`const`关键字有两种方式可以帮助解决这个可能的问题。一种是在传递值时使用`const`关键字：

```cpp
void ObjFunction(const GameObject &myObject) 
{ 
  //do stuff 
  If(*myObject.value == 0) 
  { 
    //run some logic 
    Game.ChangeState(newState); 
    //possible unknown modifier function 
    *myObject.value = 1; //now will throw a compile error 
  } 
}
```

这样就不可能在函数中的任何地方修改传递的值，使其保持不变。

另一种方法是创建`const`安全的函数。当您将函数定义为`const`函数时，它允许`const`对象调用它。默认情况下，`const`对象不能调用非`const`函数。但是，非`const`对象仍然可以调用`const`函数。要将函数定义为`const`函数，我们可以添加`const`关键字来修改函数定义本身。您只需在函数签名的末尾添加`const`，如下所示：

```cpp
void ObjFunction(const GameObject &myObject) const 
{ 
  //do stuff 
  If(*myObject.value == 0) 
  { 
    //run some logic 
    Game.ChangeState(newState); 
    //possible unknown modifier function 
    *myObject.value = 1; //now will throw a compile error 
  } 
} 
```

这是我编写任何不会修改任何对象或值的函数的首选方法。它允许在将来可以从`const`对象调用它，并且还允许在其代码中使用该函数的其他开发人员轻松识别该函数不会修改与其组合使用的任何对象或值。

# 内存管理

在 C++中，**内存管理**的概念经常是初学者的噩梦话题。我经常听到开发人员说*我不使用 C++是因为它的手动内存管理*。事实上，在绝大多数项目中手动内存管理是非常罕见的。如今，随着现代概念如托管智能指针，手动构建的内存管理系统在日常开发中变得不那么重要。只有当涉及高性能计算，如游戏开发时，控制内存分配和释放才成为一个问题。在游戏开发中，控制内存分配和释放的概念仍然是开发人员关注的焦点，这也适用于大多数移动设备，尽管价格实惠的高内存设备不断增长。在接下来的部分，我们将重新审视堆栈和堆，以及处理内存分配的方法的差异。这将为下一章奠定基础，我们将看到一个自定义内存管理系统的示例。

让我们从堆栈开始，这个名字很贴切的**内存结构**，你可以把它想象成一堆盘子或碟子。当您在堆栈上创建一个对象或变量时，它被放在堆的顶部。当对象或变量超出范围时，这类似于从堆栈中移除盘子或碟子。在代码中，堆栈上的分配看起来像这样：

```cpp
int number = 10; 
Player plr = Player(); 
```

第一行创建一个整数值，并将其赋值为`10`。存储整数所需的内存在堆栈上分配。第二行具有完全相同的想法，只是针对`Player`对象而已。

使用堆栈的一个好处是，当对象或变量超出范围时，我们分配的任何内存都将被清理。然而，这可能是一把双刃剑；许多新开发人员遇到的问题是，他们在对象超出范围后仍然查找或调用对象，因为他们使用堆栈来存储它们。堆栈的另一个问题是其大小受限，这取决于平台和编译器设置。如果创建了大量对象并长时间保存，这可能会成为一个问题。尝试分配超出堆栈可用内存的内存将引发运行时错误。

另一种选择是堆，你可以将其视为一大块或一大容器的内存。与堆栈不同，这个内存堆是无序的，很容易变得碎片化。好消息是，现代内存和操作系统实现提供了一种低级机制来处理这种碎片化，通常称为**内存虚拟化**。这种虚拟化的另一个好处是，它提供了对比物理内存更多的堆存储的访问权限，通过在需要时将内存交换到硬盘。要在堆上分配和销毁内存，你可以使用关键字`new`和`delete`，以及`new[]`和`delete[]`用于对象的容器。代码看起来会像这样：

```cpp
Player* plr = new Player(); 
char* name = new char[10]; 
delete plr; 
delete[] name; 
```

前两行创建了一个`Player`对象和一个堆上的字符数组。接下来的两行分别删除了这些对象。重要的是要记住，对于在堆上创建的每个内存块，你必须调用 delete 来销毁或释放该内存块。如果不这样做，可能会导致内存泄漏，使你的应用程序继续消耗更多内存，直到设备耗尽并崩溃。这是一个常见的问题，很难追踪和调试。内存泄漏是新开发人员认为 C++内存管理困难的原因之一。

那么，你应该使用堆栈还是堆？嗯，这实际上取决于实现和要存储的对象或值。我建议的一个经验法则是，如果可以使用堆栈进行分配，那应该是你的默认选择。如果确实需要使用堆，尝试使用管理系统来处理创建和删除。这将减少内存泄漏和其他与处理自己的内存管理相关的问题的几率。我们将在下一章中讨论如何构建自己的内存管理器作为核心库的一部分。

# 处理错误

我希望我能说我写的每一行代码都能一次性无缺地运行。现实是我是人，容易犯错误。处理这些错误并追踪错误可能是大部分开发时间所花费的地方。有一个良好的方法来捕捉和处理在游戏运行时发生的错误和其他问题是至关重要的。本节介绍了一些用于查找和处理错误的 C++技术。

当你遇到问题时，可以使用一种技术优雅地让程序崩溃。这意味着，我们告诉计算机停止执行我们的代码并立即退出，而不是让计算机自行崩溃。在 C++中，我们可以使用`assert()`方法来做到这一点。一个例子看起来会像下面的代码：

```cpp
#include <assert.h> 
... 
void MyFunction(int number) 
{ 
  ... 
  assert(number != NULL); 
  ... 
} 
```

当计算机遇到代码行`assert(number != NULL);`时，它会检查整数 number 是否为`NULL`，如果是，这将导致断言失败，立即停止执行并退出程序。这至少让我们有些控制。我们可以利用`assert()`函数提供的机会来捕获更多信息，以创建崩溃报告。我们可以打印出文件、行，甚至错误的描述作为自定义消息。虽然这样做有效，但还有很多需要改进的地方。

另一种处理错误的技术是异常，它可以提供更多的灵活性。异常的工作原理是这样的：当程序遇到问题时，它可以抛出一个异常来停止执行。然后程序会寻找最近的异常处理块。如果在抛出异常的函数中找不到该块，那么程序会在父函数中寻找处理块。这个过程会展开堆栈，意味着堆栈上创建的所有对象都会按照它们被传入的顺序被销毁。这个过程会一直持续，直到程序找到一个处理块或者到达堆栈的顶部，此时会调用默认的异常处理程序，程序将退出。总的来说，在 C++中处理异常的语法非常简单。要抛出异常，你可以使用关键字`throw`。这将触发程序寻找一个处理块，用关键字`Catch`表示。`Catch`块必须位于`Try`块的后面，`Try`块封装了可能抛出异常的代码。一个简单的例子是：

```cpp
Void ErroringFunction() 
{ 
  ...// do something that causes error 
  throw; 
} 
Void MyFunction() 
{ 
  ... 
  Try //the try block 
  { 
    ... 
    ErroringFunction(); 
    ... 
  } 
  Catch(...)//catch *all exceptions block 
  { 
    ... //handle the exception 
  } 
} 
```

您还可以通过将异常类型作为参数传递给 Catch 块来捕获和处理特定错误，如下面的代码所示：

```cpp
... 
Throw MyExeception("Error! Occurred in Myfunction()"); 
... 
Catch(MyException e) 
{ 
  ...//handle exception 
}  
```

使用异常的优势在于我们可以灵活地处理错误。如果情况允许，我们可以纠正导致错误的问题并继续进行，或者我们可以简单地将一些信息转储到日志文件中并退出程序。选择权在我们手中。

您实现的处理错误的解决方案完全取决于您所在的项目。事实上，一些开发人员选择完全忽略处理错误。然而，我强烈建议使用某种错误处理系统。在本书的演示示例代码中，我实现了一个异常处理系统。我建议将其作为起始参考。本章末尾的建议阅读部分还包含一些关于处理错误的优秀参考资料。

# 处理类型和容器

C++是一种强类型的不安全语言。它提供了令人难以置信的控制能力，但最终期望程序员知道自己在做什么。在高级水平上理解如何处理类型对于掌握游戏库和核心系统编程至关重要。游戏开发在很大程度上依赖于 C++中类型的灵活性，它还依赖于可用的高级库，比如**标准模板库**（**STL**）。在接下来的几节中，我们将看一些在游戏开发中常用的容器及其 STL 实现。我们还将介绍如何通过使用模板创建通用代码。最后，我们将通过查看类型推断及其更常见的用例来结束类型和容器的主题。

# STL 通用容器

C++ STL 是一组容器类的集合，允许以不同的结构存储数据，具有提供对容器元素访问的迭代器，以及可以对容器和它们持有的元素执行操作的算法。这些结构、迭代器和算法都经过了极其优化，在大多数情况下使用了 C++语言标准的最新实现。STL 广泛使用 C++中的模板特性，以便轻松地适应我们自己的类型。我们将在下一节中看一下模板化。STL 是一个庞大的主题，有许多关于概念和实现的书籍。如果你对 STL 的经验很少，我强烈建议阅读一些关于这个主题的精彩书籍。我在本章末尾的*总结*部分列出了一些书籍。本节将集中介绍在游戏开发中更常用的一些 STL 容器。我假设你对容器有基本的了解，并且有一些使用迭代器遍历容器中的元素的经验。

让我们从两个序列容器 vector 和 list 开始。它们被称为**序列容器**是因为它们按特定顺序存储它们的元素。这允许在该顺序或序列的任何位置添加或删除元素。Vector 和 list 是你将遇到的最受欢迎的 STL 序列容器之一。了解一些关键事实将有助于您决定哪一个最适合特定任务。我已经包括了一些建议来帮助指导您。

# 向量

**Vector**是 STL 中提供的最基本的容器之一。虽然它相对简单，但它非常灵活，是游戏开发中最广泛使用的容器之一。你最有可能看到它的地方是替代 C 数组。使用数组带来的一个更大的缺点是你必须在声明时定义数组的大小。这意味着在大多数情况下，你需要知道所需元素的最大数量，或者你需要分配比你所需的更多。幸运的是，对于我们来说，向量没有这个预定义大小的缺点；向量将增长以容纳添加的新元素。要创建一个整数向量，我们可以使用以下语法：

```cpp
std::vector<int> playerID ; 
```

你可能注意到在`vector`之前有`std::`，这是因为`vector`类是`std`命名空间的一部分，所以我们需要确定我们希望使用该实现。请参阅本章前面的*使用命名空间*部分进行复习。我们可以通过在代码文件开头添加`using namespace std;`语句来避免输入这个。我更喜欢在我的标准库调用或任何其他特定命名空间调用中添加`std::`。由于游戏开发使用了很多库，使用很多`using`语句可能会变得混乱且容易出错。虽然需要多按几下键盘，但可以避免很多麻烦。

我个人在大多数情况下使用向量代替数组，并建议您也这样做。不过，在将所有数组更改为向量之前，有一点很重要，那就是向量可能会导致问题的一个方面。当你创建一个向量时，会为它分配一个连续的内存块。内存的大小取决于向量中的元素数量。始终会有足够的空间来容纳向量中当前的所有元素，再加上一点额外的空间以便添加新元素。这就是向量的诀窍，随着添加更多的元素，最终开始耗尽空间，向量将获取更多的内存，以便始终有空间容纳新元素。它首先创建一个新的内存块，复制第一个内存块的所有内容，然后删除它。这就是问题可能出现的地方。为了防止不断的分配、复制和删除，当向量分配新内存时，通常会将前一个大小加倍。由于向量永远不会缩小，如果我们以一种方式使用向量，导致大量添加和删除元素，这很容易成为一个内存问题，特别是对于内存较低的设备。了解这一点不应该阻止您使用向量，在正确的情况下实现时，这应该很少成为问题，并且如果出现问题，可以通过重构来轻松解决。

一些使用向量的完美例子包括；玩家列表，角色动画列表，玩家武器，任何你可能不经常添加或删除的列表。这将避免可能的内存问题，同时让你可以使用向量的迭代器、算法和其他优点。

# 列表

**列表**是在使用 C++开发游戏时可能会看到的另一种序列容器类型。要创建一个整数值的列表容器，语法看起来会像这样：

```cpp
std::list<int> objValues; 
```

列表容器在其实现和开发中的一般用法上与向量有很大的不同。关键的区别在于，与向量不同，列表容器不会将所有元素存储在一个大的连续内存块中。相反，它将其元素存储为双向链表中的节点。每个节点都保存着指向下一个和上一个节点的指针。当然，这使得向量的额外内存分配问题消失了，因为列表中只有每个元素的内存是预先分配的。当添加新元素时，只会创建新节点的内存，节省了在向量实现中可能看到的浪费内存。这也允许在列表中的任何位置添加元素，与向量容器相比，性能要好得多。然而，也有一些缺点。由于内存中的单独节点设置，列表上的每个操作很可能最终会导致内存分配。由于每个节点可能散布在内存中，没有保证的顺序，这种不断的内存分配可能是在动态内存较慢的系统上的潜在问题。这也意味着列表遍历其元素比向量要慢。但这并不是要阻止您在项目中使用列表。我建议在您经常添加或删除的对象或元素组中使用列表。一个很好的例子是在每一帧中渲染的游戏对象或网格的列表。列表不应被视为向量的替代品。每种都有其优点和缺点，找到最佳解决方案通常是最困难的部分。

最后，我们将要看的最后一个容器是一个常用的**关联容器**。与序列容器不同，关联容器不保留其中元素的相对位置。相反，关联容器是为了速度而构建的，更具体地说是元素查找速度。不用进入**大 O 符号**，这些关联容器及其对应的算法在查找特定元素时远远优于向量和列表。它们被称为关联容器的原因是它们通常提供一个键/数据对，以便实现更快的查找。值得注意的是，有时容器中的键就是数据本身。我们将在这里关注的是地图容器。

# 地图

地图在游戏开发中有多种用途。与向量或列表相比，地图的独特之处在于每个地图由两部分数据组成。第一部分数据是一个键，第二部分是实际存储的元素。这就是使地图在查找元素时如此高效的原因。一个简单的思考方式是，地图就像数组，但是它不是使用整数值来索引元素，而是使用可以是任何类型的键来索引其元素。地图甚至有一个专门的`[]`运算符，允许您使用熟悉的数组语法访问元素。

要创建一个以整数作为键和字符串作为元素类型或值的地图，我们的代码看起来会像下面这样：

```cpp
std::map<int,string> gameObjects; 
```

在内存使用方面，地图与列表和向量容器都不同。地图不像向量那样将数据存储在连续的块中，而是将元素保存在节点中，就像列表一样。列表和地图处理它们的分配方式的不同之处在于节点的结构方式。地图中的节点具有指向下一个节点和上一个节点的指针，就像列表一样，但这些节点是以树状模式排列的。这种树状模式会随着节点的添加和删除而自动平衡。好消息是，这种平衡行为不会增加任何新的分配。地图的性能与列表非常相似，因为内存管理是相似的，唯一可能看到差异的时候是节点树的自动平衡所带来的非常轻微的开销。

地图经常被用作字典的形式。它们通过键提供非常快速的唯一值查找；因此，在游戏开发中一些很好的地图示例包括：具有唯一 ID 的游戏元素列表，具有唯一 ID 的多人游戏客户端列表，以及几乎任何你想要以某种键值对存储的元素组。

# 模板

模板是 C++语言中的一个较新概念。模板有助于解决当使用不同的数据类型或类时不得不重写相同代码的普遍问题。这使我们能够编写所谓的通用代码。然后我们可以在项目的其他部分使用这个通用代码。截至 C++14 标准，现在有三种可以使用的模板类型：**类模板**，**函数模板**和**变量模板**。让我们在接下来的部分更仔细地看看它们。

# 类模板

使用类模板，我们可以创建抽象类，可以在不指定类的函数将处理什么数据类型的情况下进行定义。在构建库和容器时，这变得非常有用。事实上，C++标准库广泛使用类模板，包括我们在本章中早些时候看到的`vector`类。让我们来看一个`Rectangle`类的简单实现。这可能是一个有用的类，用于查找屏幕坐标、按钮和其他 GUI 元素，甚至简单的 2D 碰撞检测。

不使用类模板的基本实现将看起来像这样：

```cpp
class Rectangle 
{ 
  public: 
    Rectangle(int topLeft, int topRight, int bottomLeft,
    int bottomRight) : 
    m_topLeft (topLeft), m_topRight(topRight), 
    m_bottomLeft(bottomLeft), m_bottomRight(bottomRight){} 

    int GetWidth() { return m_topRight - m_topLeft; } 
  private: 
    int m_topLeft; 
    int m_topRight; 
    int m_bottomLeft; 
    int m_bottomRight; 
}; 
```

在大多数情况下这是有效的，但是如果我们想在使用 0.0 到 1.0 的值的不同坐标系中使用这个矩形，我们将不得不做一些改变。我们可以只是复制代码并将整数数据类型更改为浮点数，这样也可以正常工作，但是使用类模板我们可以避免这种代码重复。

使用模板，新的`Rectangle`类将看起来像这样：

```cpp
template <class T> 
class Rectangle 
{ 
  public: 
    Rectangle(T topLeft, T topRight, T bottomLeft,
    T bottomRight) : 
    m_topLeft(topLeft), m_topRight (topRight), 
    m_bottomLeft(bottomLeft), m_bottomRight(bottomRight){} 

    T GetWidth() { return m_topRight - m_topLeft; } 
    T GetHeight() { return m_bottomLeft - m_topLeft;} 
  private: 
    T m_topLeft; 
    T m_topRight; 
    T m_bottomLeft; 
    T m_bottomRight; 
}; 
```

你会注意到的第一个变化是在我们的类定义之前包含了`template<class T>`。这告诉编译器这个类是一个模板。`T`是一个数据类型的占位符。第二个变化是所有的整数数据类型都被替换为这个占位符。所以现在我们可以像这样使用`int`数据类型创建一个矩形：

```cpp
Rectangle(10,20,1,2); 
```

当编译器遇到这行代码时，它会通过模板类并用`int`替换所有占位符的实例，然后即时编译新的类。使用浮点值创建一个矩形，我们可以使用以下代码：

```cpp
Rectangle (1,1,0.5,0.5); 
```

我们可以对任何我们喜欢的数据类型这样做；唯一的限制是这些类型必须在类的操作中得到支持。如果不支持，就会抛出运行时错误。一个例子是一个具有乘法函数的类模板，试图使用该模板与一个字符串。

# 函数模板

函数模板的概念与类模板非常相似；最大的区别是函数模板不需要显式实例化。它们是根据传入的数据类型自动创建的。以下将交换两个值，但它不特定于任何类类型：

```cpp
template<class T> 
void Swap (T &a, T &b) 
{ 
    T temp = a; 
    a = b; 
    b = temp; 
} 
```

然后你可以传递整数值：

```cpp
Swap(23,42); 
or float values; 
Swap(12.5, 5.2); 
```

实际上，你可以将这个函数用于任何支持赋值运算符和复制构造函数的类型。这里的限制是两个数据类型必须是相同的类型。即使数据类型具有隐式转换，这也是正确的。

```cpp
Swap(1.8, 22); // Results in a compile time error 
```

# 变量模板

我想快速提到的最后一种模板类型是变量模板，不要与**可变参数模板**混淆。在 C++14 中引入的变量模板允许将一个变量包装在一个模板化的结构或类中。经常使用的例子是数学构造中的 pi：

```cpp
template<class T> 
constexpr T pi = T(3.1415926535897932385); 
```

这意味着你可以将`pi`作为`float`、`int`或`double`变量，并在通用函数中使用它，例如，计算给定半径的圆的面积：

```cpp
template<typename T> 
T area_of_circle_with_radius(T r)  
{ 
  return pi<T> * r * r; 
} 
```

这个模板函数可以用于各种数据类型，因此你可以返回一个整数、一个浮点数，或者任何其他支持的数据类型作为面积。你可能不经常看到变量模板的使用。它们在 C++中仍然被认为是一个新的概念，但是了解它们的存在是很重要的。它们确实有一些独特的情况，也许有一天会帮助你解决一个困难的问题。

正如你所看到的，模板确实有它们的好处，我鼓励你在合适的地方使用它们。然而，重要的是要注意在实现模板时可能出现的一些潜在缺点。第一个潜在的缺点是所有的模板必须在同一个文件中有它们的整个实现，通常是头文件。`export`关键字可以纠正这一点，但并非所有商业编译器都支持它。模板的另一个缺点是它们以难以调试而臭名昭著。当问题存在于模板代码内部时，编译器往往会给出晦涩的错误。我的最大建议是谨慎使用它们，就像其他功能一样。仅仅因为一个功能是先进的，并不意味着它就是一个好选择。最后，查看你的编译器以获取实现的确切细节。

# 类型推断及其使用时机

C++11 标准带来了一些非常有用的**类型推断**能力。这些新的能力给程序员提供了更多的工具来创建通用、灵活的代码。在这一部分，我们将更深入地研究这些新的能力。

我们将从一个新的强大关键字开始。`auto`关键字允许您在声明时让编译器推断变量类型，如果可能的话。这意味着，与其像这样定义一个变量：

```cpp
int value = 10; 
```

现在你可以只使用`auto`：

```cpp
auto value = 10; 
```

然而，这并不是`auto`关键字的最佳用法，事实上，这是一个完美的例子，说明你不应该这样做。尽管在声明任何变量时使用`auto`可能很诱人，但这不仅会给编译增加完全不必要的开销，还会使您的代码更难阅读和理解。这就是你不应该用`auto`做的事情，那么你应该怎么用`auto`呢？嗯，`auto`真正显示其帮助之处的地方是与模板一起使用。与`auto`关键字配合使用时，模板可以变得非常灵活和强大。让我们来看一个快速的例子。

在这个例子中，我们有一个简单的模板函数，为我们创建一些游戏对象，类似于以下内容：

```cpp
template <typename ObjectType, typename ObjectFactory> 
void CreateObject (const ObjectFactory &objFactory) 
{ 
  ObjectType obj = objFactory.makeObject(); 
  // do stuff with obj 
} 
```

要调用这段代码，我们将使用以下代码：

```cpp
MyObjFactory objFactory; 
CreateObject<PreDefinedObj>(objFactory); 
```

这段代码运行良好，但使用`auto`关键字可以使其更加灵活和易于阅读。我们的代码现在看起来像这样：

```cpp
template <typename ObjectFactory > 
void CreateObject (const ObjectFactory &objFactory) 
{ 
  auto obj = objFactory.MakeObject(); 
  // do stuff with obj 
} 
```

然后我们调用这个函数的代码将是：

```cpp
MyObjFactory objFactory; 
CreateObject (objFactory); 
```

虽然这是一个过度简化，但它应该让您看到`auto`可以提供的可能性。通过不定义对象工厂将返回的类型，我们允许工厂在其实现中更加自由，从而允许在我们的代码库中更广泛地使用工厂。

在模板之外，您将经常看到`auto`关键字的应用之一是在 for 循环中迭代器的声明中。这已经成为许多更现代的库中的常见做法。您经常会看到 for 循环写成这样：

```cpp
for (auto it = v.begin(); it != v.end(); ++it)  
{ 
  //do stuff 
}
```

`auto`关键字有一个辅助关键字`decltype`，它从变量中提取类型。因此，`auto`用于让编译器推断变量类型是什么，而`decltype`用于确定变量的类型是什么。当您加入`auto`关键字功能的最后一部分作为`return`值时，这变得非常有用。在 C++11 之前和`auto`关键字之前，`return`值必须在函数名之前声明，如下所示：

```cpp
TreeObject CreateObject (const ObjectFactory &objFactory) 
{ 
  auto obj = objFactory.MakeObject(); 
  return obj; 
} 
```

这意味着`CreateObject`函数必须返回一个`TreeObject`类型，但正如前面提到的，让编译器推断`objFactory.MakeObject();`返回的对象类型可以提供更大的灵活性。为了推断函数返回的对象类型，我们可以使用`auto`、`decltype`和新的`return`语法的概念。我们的新函数现在看起来像这样：

```cpp
template <typename ObjectFactory > 
auto CreateObject(const ObjectFactory &objFactory) -> decltype (objFactory.makeObject()) 
{ 
  auto obj = objFactory.MakeObject(); 
  return obj; 
} 
```

还要注意的是，`auto`和`decltype`会增加我们的编译时间开销。在大多数情况下，这将是微不足道的，但在某些情况下可能会成为一个问题，因此在将这些新关键字纳入您的代码库时要意识到这一点。

随着您继续构建更多的库和工具集，构建更通用、灵活的代码的能力将变得至关重要。像使用`auto`、`decltype`和新的`return`语法这样的技巧只是实现这一目标的一些方法。在接下来的章节中，我们将看到更多有用的概念。

# 游戏编程模式

编程模式或开发模式，简单来说，是常见或经常遇到的问题的解决方案。它是一个描述或模板，提供了可以在许多不同情况下使用的解决方案。这些模式是正式的最佳实践，通常是通过多年的迭代开发而形成的。通过在项目中使用模式，你可以使你的代码更具性能、更强大和更具适应性。它们允许你构建结构化的代码，天生就是解耦的。这种解耦是使你的代码更通用且更易于使用的原因。你不再需要将整个程序塞进脑海中，以理解特定代码段试图实现什么。相反，你可以专注于独立运行的小块。这就是面向对象设计的真正力量。这种解耦也将使得在测试过程中更容易追踪错误，通过将问题隔离到某个代码段。

至少对最基本的模式有扎实的理解，将对你开始构建自己的库和引擎结构至关重要。在接下来的几节中，我们将看一些这些基本模式。

# 使用循环进行工作

可以说，游戏开发中最重要的概念之一是循环的概念。如果你以前曾经制作过游戏，我几乎可以保证你曾经使用过某种形式的循环。尽管循环很常见，但循环的特定实现通常并非如此。模式为开发人员提供了构建高性能、灵活循环的指导方针和结构。

最常见的循环模式之一是**游戏循环模式**。游戏循环模式的目的是提供一种机制，将游戏时间的流逝与用户输入和其他事件分离，而不受处理器时钟速度的影响。简单来说，游戏循环在游戏运行期间或特定状态下持续运行，参见后面章节的状态机。在这个持续循环中，每个循环的时刻或轮次，我们都有机会更新游戏的各个部分。这通常包括更新当前游戏状态，检查和更新任何用户输入，而不会阻塞，并调用绘制或渲染任何游戏对象。许多平台和几乎所有引擎都有自己的实现。重要的是要注意你正在使用的平台或引擎是否有自己的游戏循环。如果有，你将需要将你的代码和循环结构连接到提供的机制中。

举个例子，Unity 游戏引擎抽象了循环过程，它通过所有游戏对象继承的`Update()`函数暴露了与内部游戏循环的连接。这种 Unity 结构是游戏循环模式如何与其他模式（如更新模式）结合，构建一个级联循环系统的绝佳示例，允许主游戏循环驱动每个对象的内部循环机制。我们现在不会构建一个完整的示例，但随着我们继续阅读本书，我们将看到更多这样的结构是如何构建的。接下来的几节将继续探讨如何结合模式来构建完整的游戏系统流程。

为了帮助理解游戏循环是如何构建的，让我们看一个典型的、稍微简单的例子：

```cpp
double lastTime = getSystemTime(); 
while (!gameOver) 
{ 
  double currentTime = getSystemTime (); 
  double deltaTime = currentTime - lastTime; 
  CheckInput(); 
  Update(deltaTime); 
  Draw(); 
  lastTime = currentTime; 
} 
```

代码的第一行，`double lastTime = getSystemTime();`，在循环的第一次运行之前存储了时间。接下来是一个简单的`while`循环，在这种情况下，只要变量`gameOver`不为真，循环就会继续运行。在`while`循环内，首先我们获取当前时间。接下来我们创建一个`deltaTime`变量，它是自上次循环步骤以来经过的时间。然后我们调用游戏的其他组件：`Input`，`Update`和`Draw`。这是游戏循环模式的关键；我们使用这个标准的运行循环来推动游戏向前发展。你可能会注意到我们将`deltaTime`传递给`Update`方法。这是循环的另一个重要组成部分，不深入研究更新模式，通过传递循环之间经过的时间，我们能够修改诸如游戏对象物理等东西，使用适当的时间片，这对保持一切同步和流畅非常重要。这种游戏循环模式实现的风格被称为**可变时间步**模式，因为循环步骤是基于更新所需的时间量。更新代码所需的时间越长，循环步骤之间的时间就越长。这意味着循环的每一步将决定经过了多少真实时间。使用这种方法意味着游戏将在不同硬件上以一致的速率运行，这也意味着拥有强大机器的用户将获得更流畅的游戏体验。然而，这种实现还远非完美。它没有优化渲染或处理步骤之间可能发生的延迟，但这是一个很好的开始。了解发生在幕后的事情是一个重要的步骤。在下一节中，我们将看一种允许我们基于事件创建代码路径的模式，这与循环的结合是游戏系统流的自然演变。

# 状态机

我们将要检查的下一个模式是**状态模式**；更具体地说，我们将看有限状态机。状态机是一个非常强大的工程概念。虽然在大多数编程学科中并不常见，除了可能是 AI 开发，有限状态机在构建分支代码中扮演着重要的角色。也许令人惊讶的是，我们日常生活中发现的许多机械逻辑电路都是由有限状态机的形式构建而成的。

一个现实世界的例子是一组交通信号灯，它根据等待的车辆改变状态（有时可能不够快）。有限状态机可以归结为一个抽象系统，其中机器只能处于有限数量的状态之一。机器将保持在这个状态，称为当前状态，直到事件或触发条件导致转换。让我们看一个演示这个概念的例子：

```cpp
//simple enum to define our states 
Enum GameState 
{ 
  Waiting, 
  Playing, 
  GameOver 
} 

GameState currentGameState = GameState.Waiting; 

//Other game class functions... 

void Update(double deltaTime) 
{ 
  //switch case that acts as our machine 
  switch(currentGameState) 
  { 
    case Waiting: 
      //do things while in waiting state 
      //Transition to the next state 
      currentGameState = Playing; 
    break; 
    case Playing: 
      //do things while in playing state 
      CheckInput(); 
      UpdateObjects(deltaTime); 
      Draw(); 
      //Transition to the next state 
      currentGameState = Gameover; 
    break; 
    case Gameover: 
      //do things while in waiting state 
      UploadHighScore(); 
      ResetGame(); 
      //Transition to the next state 
      currentGameState = Waiting; 
    break; 
  } 
```

首先，我们有一个包含游戏状态的`enum`结构。接下来，我们创建一个`GameState`变量类型来保存机器当前所处的游戏状态。然后在一个`Update`循环中，我们实现了一个控制从状态到状态转换流的`switch case`结构。这种实现的关键在于机器的每个状态都有一个到下一个状态的转换状态。这保持了机器的运行，并允许我们根据机器当前的状态执行不同的操作。虽然这可能是游戏状态机的最基本形式之一，但它确实展示了有限状态模式的用处。当你开始创建库和其他组件时，你会开始看到这些令人难以置信的工具的更多用途。还有许多其他更复杂的实现和更多的模式来帮助描述它们。这些将在本书的后面章节中看到。

# 事件监听器

在游戏开发过程中经常会遇到这样的情况，即根据用户输入或来自其他代码块触发的条件执行某些代码。也许你只是需要一种可靠的方式让游戏对象进行通信。这就是使用事件或消息传递系统的想法产生的地方。已经创建了许多模式来帮助解决这个问题，包括**Overseer**，**Model View Controller**等。这些模式中的每一个都实现了处理事件的不同机制；许多实际上是基于彼此构建的。然而，在我们开始使用这些模式之前，我认为了解在幕后支持所有这些解决方案的基础是很重要的。通过构建我们自己的解决方案，我们将更好地理解问题，并更加欣赏解决它的模式。在我们的示例中，我们将使用本章学到的概念来构建一个简单但可重用的事件系统，可以在您自己的项目中使用。

我们可以采取的第一种方法是使用我们刚刚看到的状态机的简单版本。在这种方法中，我们使用`switch case`结构来根据传入的事件类型分支代码。为了节省空间和时间，一些基本结构代码已被省略：

```cpp
//Event could be an enum or struct that houses the different event types 
void GameObject::HandleEvent(Event* event) 
{ 
  switch(event) 
  { 
    case Collision: 
      HandleCollision(); 
      //Do other things... 
    break; 
    Case Explosion: 
      HandleExplosion() 
      //More things... 
    break; 
  } 
} 
```

这是一个快速而粗糙的实现，在一些非常基本的情况下可以工作。如果我们为我们的事件类型使用结构体或联合体，我们可以添加一些简单的消息功能，这将使其更加有用。不幸的是，这种方法最终存在太多重大问题。首先是我们需要有一个事件类型的单一来源。然后我们必须每次想要添加新的事件类型时编辑这个来源。其次是`switch case`结构，同样，每次我们希望添加新的事件类型时，我们都必须追加和修改这个部分。所有这些都非常繁琐，容易出错，并且在面向对象的语言中是不好的设计。

我们可以采取的第二种方法依赖于**运行时类型信息**（**RTTI**）的能力，这是在运行时确定变量类型的概念。使用 RTTI 使我们能够在解决方案中使用`dynamic_cast`来确定事件类型。我应该指出，并非所有的 RTTI 实现都是相同的，并且可能并非在所有编译器中默认打开。查看您的编译器的文档以获取确切信息。

首先，我们为我们将创建的所有特定事件创建一个简单的基类：

```cpp
class Event 
{ 
  protected: 
    virtual ~event() {}; 
}; 
```

现在只需要使用`dynamic_cast`来确定事件的类型，并将消息信息传递给对象自己的处理函数：

```cpp
void onEvent(Event* event) 
{ 
  if (Collision* collision = dynamic_cast<Collision*>(event)) 
  { 
    onCollision(collision); 
  } 
  else if (Explosion* explosion = dynamic_cast< Explosion *>(event)) 
  { 
    onExplosion(explosion); 
  } 
  //etc... 
}
```

这是一个比我们看到的第一个更优雅的解决方案。它提供了更多的灵活性，并且更容易维护。然而，我们可以重构这段代码，使其更加简单。使用我们之前学到的模板的概念，以及老式的重载，我们的新代码可以被构造如下：

```cpp
Template <class T> 
bool TryHandleEvent(const Event* event) 
{ 
  If(cosnt T* event = dynamic_cast<const T*> (event)) 
  { 
    Return HandleEvent(event); 
  } 
  Return false; 
} 

void OnEvent( const Event* event) 
{ 
  If(TryHandleEvent<Collision>(event)) return; 
  Else if(TryHandleEvent<Explosion>(event)) return; 
} 
```

与本章中的其他示例一样，这个示例是基本的。虽然这种新方法比第一种更清晰、更具适应性，但它也有一些缺点。这包括`dynamic_cast`的开销，这完全取决于类层次结构。维护和容易出错的代码问题仍然存在于`if...else`链中。此外，我们还有更重要的不正确类型检测的问题。例如，使用这种方法，如果我们有一个从另一个类继承的类型，比如从`Explosion`类继承的`LargeExplosion`类。如果对对象类型的查询顺序不正确，事件指针首先被转换为`Explosion`类，而实际上它指向`LargeExplosion`类，编译器将不正确地检测类型并调用函数的错误版本。一个更理想的解决方案是有一个`EventHandler`类，它将处理所有事件的注册、存储和多态函数。然后你可以有成员函数处理程序来实现特定的事件类型，这些成员函数处理程序可以从处理程序函数基类继承。这将解决我们在其他两种方法中看到的许多问题，同时给我们一个更通用、可重复使用的实现。

我们将在这里停止我们的实现。由于事件处理系统在游戏系统的许多不同部分中起着如此重要的作用，从工具链到用户输入和网络，我们将在本书的其余部分中看到更多这些模式和技术的应用。

# 总结

在本章中，我们涵盖了很多内容。我们讨论了一些现代游戏开发中使用的更高级的 C++主题。我们看了继承和多态性，指针，引用和常见的 STL 通用容器。模板化的概念以及使用类、函数和变量模板构建通用代码。类型推断和新语言关键字`auto`和`decltype`以及它们与新的`return`值语法的组合使用。最后，我们在本章结束时看了一些当今使用的核心游戏模式。

在下一章中，我们将看看如何使用这些关键概念来创建可以在我们的游戏开发项目中使用和重复使用的核心库。
