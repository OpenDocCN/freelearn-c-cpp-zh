# 第十章：*第九章*

# 需求工程

在过去几十年中，关于如何构建正确软件的思考可能与如何更好地构建软件的思考大致相当。20 世纪 60 年代至 80 年代的软件工程技术解释了如何构建需求规格说明，如何验证交付的软件满足规格，以及如何让在构建和测试软件过程中做出的发现反馈到规格中。

在 20 世纪 90 年代，出现了倾向于用户与软件构建者之间更紧密互动的方法。**快速应用开发**放弃了“前期大量”规划，转而采用快速迭代的原型，客户可以探索并给出反馈。**极限编程**将这一想法进一步发展，不仅让客户或客户的代表在开发过程中评估产品，而且在项目进行中还参与优先级排序和规划项目。（将这些 20 世纪 90 年代的想法称为简化。RAD 和其他方法背后的许多概念至少从 20 世纪 70 年代以来就已经存在，系统性的文献综述可以将这些想法更精确地定位到日历上。

然而，将这些想法综合成构建软件的提议系统是在 20 世纪 90 年代，也是在 20 世纪 90 年代，开发团队开始使用这些系统，供应商创造了产品来满足他们的需求。

与此同时，软件应用向用户展示的历史也在不断发展。这种展示的成功体现在 successive generations of practitioners（ successive generations of practitioners 指的是连续几代从业者）逐渐远离了前一代使用的术语。如果使软件易于使用的尝试被证明是有效的，那么人们会乐意将自己与该领域联系起来。相反，**人机交互**已经不再受欢迎，同样不再受欢迎的还有**人机界面设计**、**计算机支持的协作工作**、**交互设计**、**用户界面设计**等等。很快，**用户体验**将成为历史简历中的关键词之一。

如果构建软件的全部目的是为了让人们更容易地做事，那么我们应该调查人们试图做什么以及如何支持他们。在这个过程中，我们可以了解我们自己的工作方式，这可以帮助我们改进自己的工作（也许甚至可以通过编写软件来实现）。

## 研究人们

软件应用并非存在于真空之中。它们是由人使用的；一个由具有现有目标、想法、价值观以及彼此之间互动（是的，程序员，现有技术）的人群系统。将新的软件产品引入这个系统无疑会改变这个系统。它是否会支持现有的目标和价值观，或者用新的来取代它们？它是否会简化现有的互动，或者引入摩擦？

为了回答这些问题，我们必须有一种方法来衡量这个人群系统。为了做到这一点，我们必须了解我们应该就这个系统提出哪些问题，以便支持我们想要学习和发现我们应该衡量什么。

### 决定模型

在*第六章，测试*中，我必须首先决定软件系统的需求并非源于宇宙的基本真理，而是基于使用该系统的人与世界以及彼此互动的方式。现在想象一下，你正在尝试理解像 Excel 这样的应用程序的需求。你会考虑每个百万级用户的个别需求吗？虽然这可能导致产品质量更高（或者如果你通过提供不同的解决方案来解决冲突需求，则可能是多个产品），但很少有，如果有的话，公司能够承担起涉及的研究，即使他们能够承担，从结果软件中获得利润也可能很困难。

选择少数具有代表性的用户来设计和开发软件要便宜得多。有些团队选择真实的客户，而有些团队则基于假设的客户或市场研究创建“用户画像”。无论采用哪种方式，产品都将代表那些真实或想象中的人的实际或想象需求。

用户画像给人一种为用户设计的印象，但实际上产品团队只是将他们对软件应该是什么的印象外化了。当鲍勃只是一个贴在白板上的股票照片时，很容易从“我想这个功能”变成“鲍勃会想要这个功能”。鲍勃不会参与讨论，所以不会告诉你相反的情况。关键是要进入虚构的鲍勃的头脑，问他“为什么”他会想要这个功能。有时，我所在的团队在使用用户画像时，会指定某人在讨论中担任他们的倡导者。这给了那个人挑战试图将话语放入用户画像嘴里的权利；虽然这并不完全等同于有真实客户参与，但仍然很有用。

初看起来，内部或“企业”软件的构建者似乎情况要好得多；找到将要使用软件的人，为他们构建。关于这种软件环境模型，还有一些重要的问题。一个明显的问题是你要在哪里停止。你正在为的团队是否代表公司中的一个孤立单位，有明确的输入和输出，还是你将这个团队和其他团队之间的互动视为系统的一部分？那么与客户、合作伙伴和其他外部实体的互动呢？文章**关于企业架构的三种思想学派**——[`ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6109219`](http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6109219)探讨了这些边界对考虑涉及的系统的影响。

在确定了系统的范围之后，你是为目前构成该系统的特定人员设计，还是为更抽象的概念，例如那些人员所担任的角色设计？在两种情况下，都要意识到政治偏见可能进入你的模型。根据经理与其下属之间互动的协作模型设计的软件将与基于受压迫工人与剥削资产阶级之间斗争的模型不同。因为软件最终会改变其部署的系统，这样的决策将影响人们相互工作的方式。

## 你不一定需要构建客户要求的东西

发现任何软件应用的需求都很困难，即使构建它的人将是使用它的人。在*第六章，测试*中，我探讨了每个人都有自己关于软件应该做什么的想法，而在*第七章，架构*中，有些需求并没有明确表达。所以，如果你只是要求每个人列出软件应该做的事情，并据此构建，那么它将充满冲突，可能不会满足任何一个人对它的所有期望。

虽然询问人们是找出软件应该做什么的不准确方法，但询问人们是其中最容易和最可访问的方法之一。你可以通过定向问卷或开放式讨论来采访人们，了解他们对感兴趣系统的看法，并希望揭示一些那些隐含的需求。你还可以召集一群人，作为一个圆桌讨论或焦点小组，共同讨论他们的需求和问题。即使人们在尽力回答你的问题时很有帮助，也可能会出现解释他们答案的问题。他们所做的是一项专业活动，制作软件也是如此。每个学科都将有自己的术语和公认的“常识”知识；在这些术语之间进行翻译将是困难的。每个人都有自己版本的对“每个人”做他们工作所知道的事情，可能不会想到告诉你那些事情。

所以，有一种艺术（或者也许是一种科学；我认为该行业还没有下定决心）在于超越直接回答你的直接问题，找出你*应该*提出的问题以及你*永远不会*得到答案的问题。这就是定制软件（尤其是所谓的“企业”软件）有机会提供比现成软件更好的体验的地方；你有机会观察你的用户*真正*在做什么，并提供支持这些行为的软件，而不是提供支持他们声明的需求的东西。

你还需要记住，*你*是软件专家，而你的客户是解决他们所解决问题的专家。当他们在谈论他们遇到的*问题*时，关于如何解决这个问题的信息比他们告诉你他们预想的*解决方案*时更多。这并不是说你不应该接受他们的建议；但你应该记住，他们的专业知识在其他地方，而你的团队可能在设计软件方面有更多的经验。显然，如果你是一个在开发工具上工作的初创公司，你的团队可能比你的客户有*更少*的经验。

## 避免询问你想要听到的

如果你有一个宠爱的功能，在采访和焦点小组讨论中，很容易将其融入到对潜在用户的讨论中。你面临的问题是你很容易让人们同意这个功能是个好主意，即使它实际上并不是。

首先，你必须区分人们认为他们会使用的东西和人们*确实*使用的东西。考虑一下你使用的任何文字处理软件，想想它有多少你从未使用过的功能。当你购买该软件时，你是否被营销材料中对这些功能的讨论所影响？（关于文字处理器具有比人们使用更多的功能这一观点，已经被人机交互研究人员调查过——[`www.cs.ubc.ca/~joanna/papers/GI2000_McGrenere_Bloat.pdf`](https://www.cs.ubc.ca/~joanna/papers/GI2000_McGrenere_Bloat.pdf)，尽管他们发现一些功能被某些用户未使用，但用户仍然知道这些功能存在，并对它们的功能有所了解。因此，说这些额外功能完全没有价值显然是夸大其词；然而，由于这里描述的特征矩阵营销，我们通常将是否将功能纳入产品中的默认选择定为“是”。你认为大多数其他用户是否真的使用了这些功能？如果软件没有这些功能，它是否仍然具有同样的价值？在具有功能的应用程序和没有功能的应用程序之间进行选择时，人们通常会选择具有功能的应用程序，即使他们现在看不到需要它的理由。尤其是在收集需求时，没有其他信息可供参考；如果不能看到这两个（目前假设的）应用程序，潜在用户就无法比较它们的可用性、速度、质量或其他功能，所以选项实际上真的归结为“有”或“没有”。

还要记住，那些对某个声明没有强烈观点的人倾向于同意它。这在心理学领域被称为*顺从反应偏差*，在评估问卷结果时需要考虑。以下是一个例子。想象一下，你想要构建一个“清洁编码者”IDE，但首先你想知道是否有人会使用它。你创建了一份问卷，要求受访者对这些陈述进行评分，以表示他们同意或不同意这些陈述的程度：

+   专业程序员编写单元测试。

+   一个好的方法应该尽量减少循环和分支。

+   长且描述性的变量名更好。

另有人想写一个“简化版”IDE，回顾那些“真正的程序员不吃千层面”的时代，他们只是完成工作。（这是一个对文章**真正的程序员不用 Pascal**——[`www.ee.ryerson.ca/~elf/hack/realmen.html`](http://www.ee.ryerson.ca/~elf/hack/realmen.html)的戏谑引用，该文章本身是对书籍**真正的男人不吃千层面**——[`bit.ly/2XjLjxw`](https://bit.ly/2XjLjxw)的戏谑引用。那本书本身是讽刺的，但我已经没有地方可以插入我的舌头了。）他们创建了一份问卷，让受访者对这些陈述表示同意的程度：

+   花在编写测试上的时间是用来不增加价值的时间。

+   一个好的方法需要有足够的循环和分支来提供一个简单的界面，进入复杂的工作。

+   打字不是编程的重点；简洁是一种美德。

这些问卷将产生不同的结果；不一定完全相互对立，但确实每个都揭示了各自尺度高端的偏见。这是默认响应偏差；每个人都问了他们想听的问题，并且每个案例的受访者都倾向于同意它。两位研究人员应该各自从两个列表中选择问题组合，以获得更具代表性的调查。

最后，记住告诉你的客户“我认为我们应该这样做”会由于一个称为**锚定**的认知偏差而使他们倾向于这种方法——[`www.sciencedaily.com/terms/anchoring.htm`](https://www.sciencedaily.com/terms/anchoring.htm))。一旦在他们的脑海中“锚定”了某个特定功能或工作流程，他们就会更喜欢包含该功能或工作流程的选项，即使从理性上看它比无关的替代方案更差。你可能会因为它是你首先想到并脱口而出的而偏袒一个次优或昂贵的方案。最好是尽早留出选项，这样你就不会让你的客户与你在后来创建的更好设计相对抗。

## 理解问题领域

如前所述，你和你的团队是软件制作的专家，而客户是软件将要完成的事情的专家。我曾警告过不要用这种区别来构建你想要的软件而不是客户需要的软件；这难道意味着软件人员坚持软件，而客户坚持他们的问题领域吗？

不。

你需要知道你正在为谁构建，所以你需要对问题领域有一些了解。是的，这是不对称的。这是因为情况是不对称的——你正在构建软件来解决一个问题；问题并不是为了你可以编写一些软件而创造的。就是这样，并且妥协必须更多地来自软件制作人，而不是我们为之工作的人。你越了解你试图解决的问题，你就越能从该领域和软件领域综合想法来创造有趣的解决方案。换句话说，如果你了解软件将要做什么，你就能编写更好的软件。这希望不是一个有争议的想法。

这种理解可以在不同的层面上实现，与与客户的不同程度的互动相关。*第五章，编码实践*描述了**领域驱动设计**和无处不在的语言：定义问题域概念的术语表，也应用于命名软件域中的部分。不用说，所有参与软件开发的人都应该熟悉无处不在的语言，并以相同的方式使用它——否则就不是无处不在了！无处不在的语言的目的是确保当人们使用技术术语或行话时，每个人——客户和软件制造商——都意味着相同的事情。因此，它更倾向于使用来自问题域的术语，这样非软件人员就不必学习软件术语，并且预期这些术语渗透到软件设计和实现中，而不仅仅是用于客户会议。

应该将无处不在的语言视为一个起点。包括极限编程在内的一些方法要求开发团队有客户代表在场，以确保开发工作始终在增加价值。这些讨论需要在业务层面进行，也就是说，在问题域的层面。（这也是程序员经常感到沮丧的原因之一，因为业务没有安排时间进行重构、开发基础设施或“偿还”技术债务。问题在于，在业务讨论的背景下提出这些事情是一个错误；这些是我们所做事情和我们如何相互合作的内部细节，与我们如何与客户合作以及业务价值无关。如果某些重构工作可以使软件更容易工作，那么就去做，让业务看到成本降低的结果。）这反过来意味着至少需要一个人能够与客户代表就手头的问题进行同行讨论。

## 揭示隐性需求

本章已经涵盖了这样一个观点：你需要找出客户从他们的软件中需要的东西，而这些东西他们并没有提到。但再次提出这一点是值得的，因为无处不在的语言可能存在无处不在的漏洞。

想想那些你对外部软件领域的人询问你正在编写的应用程序时感到惊讶的时刻。好吧，当然，我们为七英寸平板电脑制作的那个应用程序不会在三英寸的手机上工作。这是一件如此基本的事情，甚至不值得提，那么为什么有人会问这个问题呢？

现在考虑一下这种情况的反面。在你的问题域中，人们认为哪些事情是如此基本，以至于他们永远不会提到？那些教授在第一年讲座中告诉他们是“明显”的事情，他们从未质疑过？你将如何让任何人告诉你这些事情？

就像配对辅导一样，这是一个表现得像任性的幼儿可能对你有利的情境。领域专家可能有自己的做事方式；找出*为什么*将会揭示他们没有想到要告诉你的东西。这会让人感到沮丧。有些事情我们没有真正的理由去做；它们只是“最佳实践”或完成工作的方式。对这些事情进行探究会引发认知失调，这可能导致人们变得防御性；重要的是让他们知道你之所以提问是因为你意识到他们在这些事情上多么专业，而你只是需要了解基础知识以便为他们做好工作。

为什么会有认知失调？好吧，有时候我们只是因为“这就是他们做事的方式”而做事，而不是因为这种技术有任何已知的价值。我们可以在软件制作的领域中找到这样的例子。许多开发者（尽管并非所有）使用版本控制。这样做有什么好处？令人惊讶的是，*没有找到任何研究*——[`www.neverworkintheory.org/?p=451`](http://www.neverworkintheory.org/?p=451)——来调查这一点。然而，包括我在内的许多开发者会告诉你，版本控制很重要，你应该这样做，并且可以提出好处。如果你告诉我们“但是没有证据支持这些好处，为什么不停止呢？”我们可能会感到困惑和愤怒，更加激烈地试图捍卫我们的立场，尽管论点存在问题。

## 你不应该建造客户想要的东西

至少，你可能根本不应该这样做。大多数时候，他们不会代表大多数用户，甚至*任何*用户。这种情况几乎在软件的每个领域都会发生：

+   内部软件通常由 IT 部门委托，但会被销售、工程师、财务和其他部门使用。

+   商业软件通常由产品经理推动，但会卖给成千上万（或更多）的人。即使你有专门的客户代表，他们也只代表众多用户中的一个。而且，就像内部软件一样，这个“代表”可能也不是应用程序的最终用户。

+   即使是为参与决策的小团队定制软件的情况，过多的建议也会来自资历较深或更健谈的用户；最糟糕的情况是，具体请求会在被总结并呈交给开发团队之前，先通过高级经理的理解进行筛选。

这意味着，在几乎所有情况下，客户想要的东西最多只是对产品最佳利益（因此是其用户群，以及可能还有你的底线）的一个粗略近似。管理这个问题的技巧当然是政治性的，而不是技术性的；你可能不想得罪那些正在向软件需求提供反馈的人，尤其是如果他们正在支付账单的话。这意味着要翻过**波佐比特**——[`c2.com/cgi/wiki?SetTheBozoBit`](http://c2.com/cgi/wiki?SetTheBozoBit)是不可能的。但如果某个想法是糟糕的，你可能不希望它在你的应用程序中出现。

但是什么让你确信这是一个糟糕的想法？即使你是你正在编写的软件的用户，这也只是不太具有代表性的一个用户与另一个用户之间的比较。是的，你可能对平台规范和预期行为有更多的了解，但这也可能意味着你对全新的想法持保守态度，因为没有其他应用程序是这样工作的。

通过数据可以解决这个冲突。我在*第六章，测试*中讨论了 A/B 测试和用户验收测试；这些工具可以在这里用来发现任何给定的建议是否改善了软件。这不必很昂贵；在这方面，你不必在发现是否有人想要它之前构建整个功能。你可以在白板上尝试一个原型来查看人们如何使用它，或者构建该功能的非常基本的版本来查看它的受欢迎程度。尽管如此，在尝试通过调查用户来了解一个功能可能会多么受欢迎时要谨慎：回答“是”或“否”需要同样的努力，但在一种情况下，他们有更高的机会得到一个新玩意儿，无论他们是否会使用它。对特征调查的响应中的风险/回报计算倾向于肯定请求，而我们已经看到默认同意偏差意味着人们倾向于同意他们面前提出的任何陈述。

当你拥有数据时，对话可以开始“那是个不错的主意，但看起来客户还没有准备好接受它”，而不是“我不会构建你的糟糕功能。”这是一种与客户保持持续关系的更容易的方式。不幸的是，这并不总是可行的；许多软件仍然在秘密中构建，直到 1.0 版本几乎准备好（甚至更晚）才与用户互动。在这些情况下，你只有不完美的客户代理，而且不管你喜不喜欢，你只能根据他们的建议和你的意见来工作。你仍然可以围绕假设的其他用户（通常称为角色）来框架讨论，以减轻对具有挑战性的“个人”功能请求的情感反应，但这只是一种不完美的修辞工具，而不是不完美的需求工具。1.0 版本中的应用遥测可以告诉你人们如何真正使用功能，并帮助你优先考虑未来的开发，但对于关于初始发布的讨论来说已经太晚了；记住，是初始发布在花钱，而它没有自我支付。

## 软件系统的人类因素

关于软件需求的问题在于，它们不存在。或者至少，它们不是孤立存在的。粒子物理学的标准模型基于这样的想法，即存在被称为夸克的基本粒子，它们结合成称为*强子*（包括质子和中子的重粒子）和*介子*（在高温相互作用中重要的中等质量粒子）的系统。夸克通过携带强力的胶子绑定到这些系统中。这个模型被普遍接受，尽管没有人曾单独看到过夸克或胶子；它们总是强子或介子的组成部分。

正如夸克和胶子本身没有存在一样，没有用户的软件本身也是没有意义的，没有软件的用户也没有事情可做。整体代表一个*社会技术系统*，而我们正是通过我们的软件开发努力构建和修改这个系统。因此，没有对软件需求的观点是不完整的，没有对软件将对与之互动的人的政治、经济、社会结构和心理学产生的影响的看法，以及这些人将如何影响软件的看法。

*我已经对这个观点有了理论上的理解好几年了。最终，在**罗伯特·安内特**（[`twitter.com/robert_annett`](https://twitter.com/robert_annett)）关于遗产软件系统的演讲中，这个观点对我产生了情感上的共鸣。他讲述的一个轶事是，他走过他在部署新系统的公司办公室，与将要一起工作的人交谈。当他们离开大约有 20 个数据录入员工作的房间时，他的新同事低声说，“这真的很遗憾——当你的新系统上线时，我们不得不解雇他们。”*

*有时，你提供给编译器的符号和文字的模式会对真实的人产生真正的影响，无论是好是坏*。

### 经济学

这场互动的经济方面在 Barry Boehm 1981 年的著作《软件工程经济学》[`books.google.co.uk/books/about/Software_engineering_economics.html?id=VphQAAAAMAAJ&redir_esc=y`](http://books.google.co.uk/books/about/Software_engineering_economics.html?id=VphQAAAAMAAJ&redir_esc=y)中得到了很好的阐述。他对于估计软件项目成本的模型在业界并没有被普遍采用，但它确实包括了被他称为“人际关系因素”的内容，这些因素可以影响软件系统的成本和收益。它包括了与别人合作的“修改后的黄金法则”：

*己所不欲，勿施于人——如果你和他们一样*。

条件句的目的在于提醒程序员，并不是每个人都希望被当作喜欢解决软件问题并能理解计算机科学概念的人来对待。Boehm 认为，在软件项目中，可用性、满足人类需求以及允许用户实现其潜能的需求，在经济术语上需要被考虑。

虽然这肯定比完全不考虑这些因素要好（或者至少更完整），但试图为它们找到美元价值只是考虑它们的一个早期阶段。我从其中，以及从信息安全和其他领域的类似论点（记得在*第六章，测试*中关于无障碍经济价值的讨论）中推断出，我们要么看不到，要么无法证明这些属性固有的好处，但我们仍然希望将它们纳入我们的决策中。我们不愿意忽视它们的事实，使我倾向于第二个解释：我们知道这些事物是有价值的，但我们没有论据来支持这一点。

这并不是说这些关于人的因素的保护措施没有用；只是它们并不是辩论的顶峰。你可以看到，从成本的角度来看，可用性在经济上可能是合理的；在设计可用的软件上投入更多努力，可以使用户更有效率，更满意。满意（与另一个因素——实现人类潜能——相关）可以导致对工作的更大参与和更高的员工留存率，从而降低组织的 HR 成本。满足人类需求是**赫茨伯格**[`www.businessballs.com/herzberg.htm`](http://www.businessballs.com/herzberg.htm)认为的*卫生因素*：人们必须满足他们的基本需求，才能被激励去追求其他目标。

有时在目标之间的权衡无法合理地用经济术语来表示。一个很好的例子是游戏：如果它有很好的可用性，那么它将非常简单，人们会快速完成它然后回到工作中去——这是一个经济上的胜利。但人们不会玩简单的游戏；他们玩那些给他们提供挑战的游戏，无论这个挑战是心理上的、灵巧上的还是其他什么。因此，玩家想要挑战或沉浸于游戏世界的愿望优先于其他，尽管很难为这种愿望赋予货币价值。

### 政治

软件开发的政治面可能会影响人们认为自己在使用软件的系统以及更广泛的交互系统中所受到的认可、支持、赋权和价值。让我们从这个案例研究开始本节：一个在企业中使用的共享日历应用程序。在一个团队中，每个人都可以在自己的日历上安排事件，而经理可以看到所有人的日历。此外，经理还有一位个人助理，可以在经理的日历中为经理安排事件。

经理感到自己处于权力地位，因为他们可以看到每个人的位置，可以在报告应该在那里的时候，策略性地走过他们的办公桌，看看他们在忙什么，因为他们没有记录任何会议。此外，经理感到赋权，因为更新日历软件的机械工作已经委托给了别人，而委托是管理者的一项关键活动。

另一方面，团队的其他成员感到赋权，因为他们可以通过日历软件控制经理。如果他们不想被打扰，他们可以为自己创建一个“会议”并找到一个安静的地方工作。他们可以与个人助理合作，安排经理在他们想要进行团队讨论而不希望经理参与的时间参加会议。

关于日历软件的讨论依赖于使用日历的团队中的潜在政治模型：我写它是基于一个*马克思主义*模型，揭示了经理（扮演资本家角色）和工人之间的斗争。每个团队都代表着自己的目标，根据模型，这些目标不可避免地存在冲突。通过确保冲突的目标不会在单一问题上直接对立，从而实现稳定。

参与这个系统的人们是否真的参与了这个系统模型所呈现的冲突——以及个人参与者是否认识到这种冲突或对这个系统有不同的看法，这个模型并没有捕捉到。这是一个内部一致的叙述，它没有告诉我们关于其准确性或适用性的任何信息。

在设计供多个人使用的软件时，人和我们对其政治的模型的真实政治都会塑造软件促进的互动。软件会支持现有的权力分配，还是会以牺牲其他人为代价赋予某一群体权力？政治结构是在粗略的层面上建模的（如上例中的经理/工人案例）还是捕捉了系统中每个个体的不同需求和期望？软件会促进任何新的关系还是会破坏一些现有的关系？它会消除不平等，加强现有的不平等，还是会引入新的不平等？

这些问题是复杂的，但为了全面理解协作软件对其用户的影响，回答这些问题是必要的。正如本节前面提到的轶事所示，软件系统可以对真实的人产生实际影响：一家大企业的管理层在部署新软件后可能会很高兴减少员工人数，以收回开发成本，并认为那些被裁员的员工有责任找到替代工作。一个有责任通过提供工作来支持当地人民的慈善机构可能更愿意保留工人并拒绝软件。只有通过理解政治环境，你才能确保你的软件对你的潜在用户和客户来说是良好的社会适应。

## 优先考虑需求

这一节实际上重申了之前的内容：你应该优先构建用户*需要*的软件，而不是他们*想要*的软件。这是意识形态，无论如何。现实总是有这种讨厌的习惯，在这个时候插上一句“实际上”。

向买家推销他们真正需要的东西比推销他们想要的东西要容易得多。推销东西是一个很好的机会，因为它允许你资助其他活动：也许包括开发客户仍然需要的其他东西。但是，实际上...

...良好的营销努力可以说服客户，他们真正需要的东西是他们确实想要的。然后，你可以通过让人们*应该*购买的东西并说服他们购买它来跳过所有上述讨论。这是一种高风险、高回报的情况：是的，*向人们推销一匹更快的马*——[`blogs.hbr.org/cs/2011/08/henry_ford_never_said_the_fast.html`](http://blogs.hbr.org/cs/2011/08/henry_ford_never_said_the_fast.html)更容易，但利润不会那么高，成功也不会那么持久，就像你发明汽车行业一样。正如他们所说，利润是承担风险的一种奖励。

那么，你如何优先考虑构建软件，这实际上取决于你能够承受的风险水平。你可以通过找到人们肯定愿意购买的东西并构建它们来获得渐进的低利润收益。这是**精益创业**方法，你从无到有，快速迭代，直到数据告诉你人们想要购买什么。或者你可以承担风险：构建你知道人们需要的东西，然后说服他们这值得花钱。这种方法与史蒂夫·乔布斯著名的立场最为相似：*顾客不需要知道他们想要什么*。

## 这真的是“工程”吗？

有一句古老的格言说，任何需要包含“科学”这个词的东西都不是科学。是的，原文作者是在谈论计算机科学。但也许我们应该对将“工程”一词归因于需求工程持谨慎态度。毕竟，工程是将科学应用于制造实体的应用，而需求工程是将社会科学（社会学的警告又响了！）应用于改善社会系统的业务。实际上，它将某些社会科学领域（政治学、经济学、人类学、民族志和地理学）转变为其他社会科学领域（社会学和商业研究），并创建了一些软件来实现这种转变。（在我完成这一节不久之后，保罗·拉尔夫向 ArXiv 提交了一篇论文，描述了软件设计的**理性和替代范式**——[`arxiv.org/abs/1303.5938v1`](http://arxiv.org/abs/1303.5938v1)。理性范式基本上是基于直觉的需求工程版本：软件需求作为宇宙中的基本真理存在，可以通过仔细思考推导出来。替代范式是经验主义：需求是人们之间互动的结果，只能通过观察来理解。拉尔夫的论文很好地解释了这两种范式，并将它们置于软件设计历史背景中。）

这并不是说“需求工程”这个短语需要被淘汰，因为人们知道它的意思，并将其用作该学科真实含义的占位符。但也许我们需要将其视为一种代际现象；对我们来说，它被称为“需求工程”，我们记得在教别人的时候给它一个不同的术语；比如“社会软件”。
