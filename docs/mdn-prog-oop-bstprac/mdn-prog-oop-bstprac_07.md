# 第六章：*第五章*

# 编码实践

## 引言

如果你通过阅读书籍或在线课程来学习编程，你可能坐在电脑前，使用文本编辑器或 IDE，完全解决每个问题。大多数软件团队都有两个额外的问题需要应对——他们正在编写的应用程序更大，并且有不止一个人同时在工作产品上。在本章中，我将探讨一些在更大项目上进行编程的常见方法（尽管，团队合作在这个问题中扮演了如此重要的角色，以至于在本书后面的章节中有一个专门的章节来讨论它）。

本章的大部分内容将作为快速参考，包括一个内联阅读列表和一些额外的观点。原因是这些概念太大，无法在这本小说长度的一章中详细说明。

## 测试驱动开发

**TDD**（**测试驱动开发**）是一个很大的话题，关于它的书籍已经有很多了。确实，其中一本书是我写的：**《测试驱动 iOS 开发**》([`www.pearsoned.co.uk/bookshop/detail.asp?item=100000000444373`](http://www.pearsoned.co.uk/bookshop/detail.asp?item=100000000444373))。所以，这里不会过多地深入细节。如果你之前从未遇到过测试驱动开发，或者“红-绿-重构”这个短语，我推荐阅读**《通过测试引导面向对象软件开发**》([`www.growing-object-oriented-software.com/`](http://www.growing-object-oriented-software.com/))（当然，除非你专注于 iOS）。

### TDD 的目的

人们谈论测试驱动开发作为一种确保高测试覆盖率的方法。当然，它确实做到了这一点。但它的主要用途是一个 *设计工具*。你可以根据你在产品中需要如何使用该类来构建模块或类的可执行规范。通常，我会在设计类的时候创建一些测试，但随着代码的变化，它们变得过时，我会移除它们。

我之前通过编写一系列测试并将实现工作委托给其他开发者来分配课程。我在周五晚上留下了一个失败的测试，这样我知道周一早上应该做什么（`#error` C 预处理器命令，它通过插入带有自定义消息的编译器错误来使用，对此也很有用）。TDD 在生成自动化回归测试之外还有很多实用工具。

注意，TDD 只在你将自己限制在可以通过 TDD（轻松地）实现的设计时，才能帮助你进行设计。这并不是坏事，因为它意味着所有内容都将以相似、可理解的方式进行设计。就像一本杂志有一个语气和风格指南，这样读者对任何文章都有一个基本的期望水平。

从允许 TDD 引发设计选择中得出的特定约束，或者至少是*建议*，包括你的设计可能会是松散耦合的（也就是说，每个模块不会在很大程度上依赖于系统中的其他模块）以及从外部注入的可互换依赖项。如果你的反应是“太好了——这正是我想要的”，那么你不会有任何问题。

### 我正在编写的软件无法进行测试

实际上，可能可以。除了前面提到的书中提供的示例代码外，我在写的每个项目中都有未测试的代码。在大多数情况下，它可能*确实*可以测试。让我们看看一些没有编写测试的真正原因。

*我已经编写了没有测试的代码，无法想出如何进行回溯测试*

这是一个常见的抱怨。不要让 TDD 的支持者自鸣得意地说“好吧，你一开始就应该编写测试”，这是教条且无用的。此外，已经太晚了。相反，你应该决定你是否愿意（并且能够）花时间更改代码，使其易于测试。

当然，不仅仅是时间；任何软件的任何更改都存在风险。 – 正如本书其他地方提到的，你编写的任何代码都是一种负债，而不是资产。关于是否将代码适应以支持测试的适应性的决定，应考虑的不仅仅是工作的成本，还有执行工作的潜在风险。（我故意将这项工作称为“适应”而不是“重构”。重构意味着在不影响行为的情况下更改模块的结构。在你设置测试之前，你不能保证行为没有改变。）这些需要与代码在测试下的潜在好处以及错过将代码整理好的机会成本相平衡。

如果你决定*确实*想要继续进行这些更改，你应该规划你的方法，以确保为测试所做的支持工作不会过于侵入性。在你看到这些更改是否反映了你的期望之前，你不想改变软件的行为。在这方面，迈克尔·费瑟斯的《**与遗留代码有效工作**》([`c2.com/cgi/wiki?WorkingEffectivelyWithLegacyCode`](https://c2.com/cgi/wiki?WorkingEffectivelyWithLegacyCode))是一本很好的资源。

*我不知道如何测试那个 API/设计/等等*

通常，“这个无法测试”归结为“我不知道如何测试它。”有时，确实存在某些特定的 API 不适合独立使用的情况。一个很好的例子是低级图形代码，它通常期望存在一个你正在绘制的上下文。在一种方式下重现这个上下文，以便测试框架捕获和检查绘图命令，这可能非常困难（如果确实可能的话）。

你可以通过将问题 API 包装在你自己设计的接口中来提供这种检查能力。然后，你可以用可测试的实现来替换它——或者如果需要，用替代 API。好吧，你写的适配器类可能仍然无法进行测试，但它应该足够薄，以至于风险很低。

在其他情况下，通过一点思考，可以找到测试代码的方法。我经常被告知，带有大量 GUI 代码的应用程序无法进行测试。为什么不能呢？

GUI 应用程序中有什么？首先，有大量的数据模型和“业务”逻辑，这些在其他任何上下文中都是相同的，并且可以轻松地进行测试。然后，是与 UI 的交互：MVC 世界中的“控制器”层。这是通过触发模型中的变化来响应来自 UI 的事件，并通过更新视图来响应来自模型的事件的代码。这也很容易测试，通过模拟事件并确保控制器正确地响应它们；模拟交互的“另一端”。

这就只剩下视图层中的任何自定义绘图代码了。这确实可能既困难（见上文）又无关紧要——有时，图形的重要性不在于它们的“正确性”，而在于它们的美学品质。你无法真正为这一点推导出自动测试。

如果你的应用程序确实主要是自定义绘图代码，那么：（i）我可能愿意承认其中大部分无法进行测试；（ii）你可能需要重新思考你的架构。

*我现在没有时间*

好吧！这就是“为什么没有对这个进行测试？”的真正答案。实际上，编写没有测试的代码可能比创建测试更快、更便宜，尤其是如果需要考虑如何测试该功能的话。然而，正如我之前所说的，对测试努力的全面成本分析应该包括没有测试可能带来的潜在成本。而且，正如我们所知，预测未测试代码中可能存在的错误数量是困难的。

### 那么，测试驱动开发是不是一个银弹？

正如你将在本章后面看到的那样，人们并不相信存在一个制作软件的银弹。很多人对 TDD 得到的结果感到满意。其他人则对其他实践得到的结果感到满意。我的观点是，如果你正在制作解决问题的东西，并且可以非常有信心地证明你所做的是在解决问题，那么你就在做出有价值的贡献。就我个人而言，我目前对 TDD 作为一种展示我如何用软件解决问题各个部分的方法感到满意。

## 领域驱动设计

**领域驱动设计**（**DDD**）这个术语是在 2004 年出版的同名书中提出的——[`domaindrivendesign.org/books/evans_2003`](http://domaindrivendesign.org/books/evans_2003)，尽管其大部分原则在面向对象分析和设计实践者中已经存在了相当长的时间。实际上，DDD 的核心可以被认为是源自 Simula 67 中使用的模拟技术——这是一种影响了 C++设计的语言。

简而言之，许多软件（尤其是“企业”软件）都是作为特定问题的解决方案而创建的。因此，软件应由软件专家与领域专家共同设计。他们应该使用一个共享的问题域模型，这样整个团队都在努力解决同一个问题。

为了减少沟通问题，定义了一个“通用语言”——一个在文档和软件中使用的通用术语表。这包括源代码——类和方法使用通用语言命名，以反映它们解决的问题部分。

我认为是学习领域驱动设计的一些原则最终让我对**面向对象编程**（**OOP**）有了“点击”的感觉（本章后面还有更多关于 OOP 的内容）。当我开始接触 C++和 Java 等语言时，我已经做了很长时间的 C 和 Pascal 编程。虽然我能看到方法属于类，就像模块一样工作，但决定**什么**应该是一个对象，它的边界在哪里，以及它如何与其他对象交互，这让我花了很长时间才掌握。

在某个时候，我参加了一个关于领域建模的培训课程——它使这个过程变得非常简单。其核心内容大致如下：倾听领域专家描述一个问题。每当他们用名词描述问题域中的概念时，那就是一个候选类，或者可能是类的属性。每当某事被描述为动词时，那就是一个方法候选。

将问题规范转换为对象和动作的简短描述对我来说是一个巨大的启发；我无法用其他方式思考面向对象编程。

## 行为驱动开发

我发现很难决定是把 BDD（行为驱动开发）放在这一章，还是与团队合作一起讨论，因为它实际上是一种伪装成编码实践的沟通练习。但无论如何，它就在这里。确实，本章中的许多部分都会在编码和沟通之间徘徊，因为编程是一种协作活动。

BDD 实际上是一种其他技术的融合。它严重依赖于 DDD（领域驱动设计）的理念，如通用语言，并将它们与测试驱动开发相结合。主要创新是在功能级别应用测试优先原则。使用通用语言作为**领域特定语言**（[`martinfowler.com/books/dsl.html`](http://martinfowler.com/books/dsl.html)），团队与客户合作，以可执行的形式表达功能规格，作为自动验收测试。然后，开发者努力满足验收测试中表达的条件。

我自己的经验是，BDD 往往停留在对话层面，而不是实施层面。敏捷团队（包括其客户）很容易就故事的可接受标准进行合作，然后技术团队成员根据这些标准实施评估系统的测试。对于团队来说，合作编写自动化测试，其结果让客户确信用户故事已被正确构建，这是很难的——我从未见过这种情况发生。

## xDD

似乎每次开发者大会都会出现一个新的**（某种）驱动开发**的流行词汇。TDD；BDD；**验收测试驱动开发**（[`www.methodsandtools.com/archive/archive.php?id=72`](http://www.methodsandtools.com/archive/archive.php?id=72)）；**模型驱动开发**（[`social.msdn.microsoft.com/Forums/azure/en-US/d9fa0158-d9c7-4a88-8ba6-a36a242e2542/model-driven-development-net?forum=dslvsarchx`](https://social.msdn.microsoft.com/Forums/azure/en-US/d9fa0158-d9c7-4a88-8ba6-a36a242e2542/model-driven-development-net?forum=dslvsarchx)）。有些人认为*这太多了*——[`scottberkun.com/2007/asshole-driven-development/`](http://scottberkun.com/2007/asshole-driven-development/)。

许多新术语都是由那些希望在他们刚刚定义的领域内开辟自己的一片天地的人引入的。许多只是吸引人的名字，涵盖了现有的实践。——的确，TDD 实际上是**极限编程**中流行的测试优先实践的编码化。但这并不意味着它们没有价值；有时，真正原创的部分确实是新颖的，值得了解。而且，围绕这些技术聚集的社区有自己的习俗和工作方式，值得探索。

## 设计由合同

关于我最近的一个软件项目，我有点儿坦白：里面有很多单元测试。但是，对于每一个测试断言，代码本身中都有超过三个断言。

这些对于记录我对代码如何组合的假设非常有价值。虽然单元测试表明每个方法或类在独立工作时都按预期工作，但这些断言是确保边界尊重方法内部所做的假设——也就是说，它们充当了一种集成测试的形式。

我所写的断言主要分为三类——测试当方法进入时期望是否得到满足，其结果是否如我在返回之前所期望，以及方法执行期间进行的某些转换是否产生符合特定条件的结果。在开发者构建中，每当这些假设中有一个未得到满足时，应用程序会在失败的断言处崩溃。然后我可以决定是否需要更改该方法，或者它被使用的这种方式是否错误。

在 1988 年设计**Eiffel 语言**([`docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition`](http://docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition))时，Bertrand Meyer 将一个包含三种不同类型测试的“合同”形式化，这些测试与上述断言类似：

+   *前置条件*应在函数进入时为真

+   *后置条件*应在函数退出时为真

+   *不变性*在所有“稳定”时刻都保持为真——在构造函数退出后，以及在任何对象的方法没有被执行的时刻。 

与将条件编码为断言不同，在 Eiffel 中，它们实际上是方法定义的一部分。合同形式化了方法调用者与其实现者之间的关系：调用者需要在调用方法之前确保满足前置条件。作为回报，`被调用者`承诺满足后置条件。这些条件可以通过编译器插入到代码中作为断言，以验证类在运行时是否表现正确。你也可以想象将一个自动检查器，如**Klee**([`klee.github.io/getting-started/`](http://klee.github.io/getting-started/))，指向一个类；它可以检查方法的所有代码路径，并报告那些即使它们从满足前置条件和不变性开始，但最终没有满足后置条件或不变性的路径。

Meyer 创造了*设计合同*这个术语来指代在 Eiffel 方法定义中包含前置条件、后置条件和不变性的做法。实际上，这个术语是他的公司拥有的商标；其他语言的实现被称为合同编程或合同编码（幸运的是，不是合同驱动开发…）。

正如我们所看到的，即使没有语言支持这种功能，我也倾向于使用合同编程的糟糕替代品。我发现这些合同式断言在开发中失败得比单元测试失败得多；对我来说，合同编程是比 TDD 更好的早期警告系统。

## 按规格开发

据我所知，这目前不是一种常见的开发实践。但作为测试驱动开发的自然发展，我认为它值得提及和考虑。

单元测试，即使作为 TDD 的一部分使用，也是以定制的方式使用的——作为我们独特类别的定制规范。我们可以从更多地使用这些测试中受益，用动态规范测试来替代许多 API 中使用的静态、易出错的类型测试。

例如，表视图不需要仅仅响应数据源选择器的某些东西；它需要的是像数据源一样*行为*的东西。所以，让我们创建一些任何数据源都应该满足的测试，并将它们捆绑成一个可以在运行时测试的规范。请注意，这些并不是真正的单元测试，因为我们不是在测试我们的数据源——我们在测试*任何*数据源。

表视图需要知道有多少行，以及每行的内容。因此，你可以看到，对表视图数据源的动态测试并不仅仅是单独测试这些方法；它还会测试数据源能否提供它所说的行数那么多值。你可以想象，在支持设计-by-contract 的语言中，例如 Eiffel，合作者的规范可以是类合同的一部分。

这些规范将在协作者提供时由对象进行测试，而不是等待在执行过程中出现失败。是的，这比通常在方法的前置条件中发生的易出错的类型层次或一致性测试要慢。不，这不是问题：我们希望在让它变得快速之前先让它变得正确。

将测试用例视为对象之间协作的规范，而不是（或除了）为特定类进行的单一测试，为开发者之间的协作开辟了新的途径。框架供应商可以提供作为增强文档的规范。框架消费者可以提供他们如何使用框架的规范作为错误报告或支持问题；供应商可以将这些规范添加到回归测试工具中。应用程序作者可以创建规范发送给承包商或供应商作为验收测试。供应商可以通过证明他们的代码是某些其他代码的“即插即用”替代品来展示他们的代码。

## 结对编程

在我的职业生涯中，我进行了很多结对编程，尽管它只占我时间的少数部分。我也观察过其他人进行结对编程；合作伙伴之间的互动可以是非常有趣的观看。

在深入探讨我认为的*良好*结对编程之前，我将描述一下*不良*结对编程的特点。

### 后排驾驶并非结对编程

因为我已经做了很长时间的 TDD，我习惯于故意让我的代码在足够好以集成之前经历一段无价值的阶段。也许我会等到看到它失败后再处理失败条件，或者最后再添加它。也许我想不出一个方法名，所以会先命名为`DoTheThing()`，直到我有一个更清晰的图像。

我必须记住的是，*我的搭档可能不会以同样的方式工作*。是的，看到未处理的条件或未按照我偏好的约定命名的变量很烦人，但那是不是现在最紧迫的问题？可能不是；司机目前正在处理的问题吸引了他们的注意力，谈论其他事情只是分心。我应该帮助他们工作，并在适当的时候提出其他问题。

这种问题的更极端形式：偷走键盘并不是结对编程。

### 作为一名沉默的搭档并不是结对编程

我最常看到这种情况发生的情况是，领航员（由于没有更好的、更通用的词来描述那个不驾驶的人——尽管不是“乘客”，很明显的原因）感到自己不如司机，或者被司机吓到了。他们害怕贡献，或者觉得自己不够资格贡献，因为他们不想显得愚蠢或害怕对他们的贡献的反应。

这个部分不是为在这种情况下开车的司机准备的——我稍后会提到；这是为领航员准备的。如果你看不出代码是如何做到它应该做到的，也许它根本就没有做到。如果你向你的搭档询问，可能会发生以下两种情况：

+   你会发现一个错误，它将被修复

+   那个错误根本不存在，但你将了解到代码是如何处理那个问题的

（技术上，还有第三种选择，即司机可能会告诉你闭嘴。到那时，你想要一本关于人力资源的书，而不是成为一名开发者。）

如果你没有询问，可能会发生以下两种情况：

+   那个错误将存在，并且不会被修复

+   那个错误根本不存在，你也不会了解到代码是如何工作的

简而言之，如果你不询问，错误更有可能留在代码中，所以你应该考虑这是你的职业责任去询问。

### 那么，结对编程仅仅是那些事物之间的平衡吗？

那是对事情的一种过于简化的看法，但是的。结对编程在两个人都参与时效果最好；否则，其中一个人可能是多余的，即使他们碰巧在充当打字员。如何*良好地*进行结对编程取决于你试图用它来做什么。

### 结对编程作为编程

我很少使用结对编程作为将代码放入应用程序的手段，我发现确保两个人都参与的简单规则是：直到两个人都同意，任何事情都不会发生。这允许司机调节副驾驶的行为：“那是个好点子，但让我们把它放在一边，直到我们完成这部分。”这也*要求*司机让沉默的搭档参与。

在进行配对编程时，我常常会犯的错误是掌舵：“让我给你展示一下我的意思。”**双方**的规则对我来说和其他人一样重要，因为它要求我找到比破坏合作关系更好的方式来描述我的想法。有一个白板真的很有帮助。

如果目标是编写生产代码，配对在两个技能水平大致相同的人之间进行时效果最好，他们可以轮流驾驶。当他们的能力之间存在不平衡时，它就会变成……

### 配对作为一种辅导实践

配对作为教学练习非常出色。关于在两人都同意之前不写代码的规则仍然适用，这确保了学生能够与导师讨论任何问题，导师有机会引导这个过程。

我认为当教练坐在导航员的位置上时，配对辅导效果最好。他们的角色是鼓励学生提问，然后成为那个用另一个问题回答每个问题的任性的幼儿。

严肃地说。我发现帮助某人通过问题的最好方法是识别并提出他们应该问自己的问题。这揭示了隐藏的假设，让人们提出口头论据来支持（有时引导他们改变）他们的立场，最终他们会尝试猜测接下来会问哪些问题，这意味着他们在被问之前就有了答案。这种技巧在你对辅导的主题一无所知时也非常有用——但到目前为止，我们假设教练程序员是更有经验的程序员。

当学生盯着 IDE 中的空白文件时，问题可以非常高级。我们即将编写的代码将接口于何处，它又强加什么约束？我们是否有选择我们使用的 API，如果有，我们应该选择哪一个？偶尔的“为什么？”有助于揭示学生的思维过程。

行动在学习过程中有它的位置，因此有时适当的回应不是一个问题，而是“好吧，让我们试试看。”即使你的学生还没有找到你认为最好的解决方案，开始尝试也是快速找出哪一方对将要发生的事情判断错误的好方法。

### 但它有效吗？

配对编程实际上有益吗？它在编程课程的环境中显然是有益的（[`dl.acm.org/citation.cfm?id=563353`](http://dl.acm.org/citation.cfm?id=563353))，其中配对程序员生产的软件比单独程序员更好，并且更有可能获得更高的分数（[`portal.acm.org/citation.cfm?doid=611892.612006`](http://portal.acm.org/citation.cfm?doid=611892.612006))。这些结果是否可以推广到所有程序员是有疑问的；了解为什么这些主题在配对时表现更好，以及这些条件是否适用于更熟练的程序员将很有趣。

## 代码审查

另一件可以肯定的是，结对编程**不是**代码审查练习；它们有不同的目标。代码审查应该进行以讨论和改进现有代码。结对编程是关于两个人从头开始构建一些代码。如果你的结对编程是关于一个人编写代码，另一个人说他们做错了，那么你需要重新思考你的实践（或者你的合作关系）。

请注意，当代码审查进行得不顺利时，这也是真的。代码审查的一个问题是，发现满足“我不会那样写”的代码比发现满足“应该考虑到这些因素”的代码要容易得多。这往往阻碍了从代码审查中获得有用信息，因为审查者会对代码的制表符/空格/变量名/其他退化特性感到沮丧。

正是这类问题让我更倾向于异步、分布式的代码审查而不是面对面审查。我们经常看到，**人们**([`programmers.stackexchange.com/questions/80469/how-to-stand-ground-when-colleagues-are-neglecting-the-process`](http://programmers.stackexchange.com/questions/80469/how-to-stand-ground-when-colleagues-are-neglecting-the-process))**不理解**他们同事的**动机**([`thedailywtf.com`](http://thedailywtf.com))。让审查者自己解决最初的挫折和愤怒——最好是，**没有作者在场作为出气筒**。审查者有机会冷静下来，熟悉要求，并详细研究代码……这在面对面的审查中并不成立，因为房间里还有其他人，等着得到第一块智慧之石。

关于面对面审查的话题，要警惕那些在这个领域引用“经典”的人。鼓吹代码审查好处的人经常会引用**Fagan 关于代码检查的论文**([`ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5388086`](http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5388086))，声称它表明在引入代码审查后，软件开发成本有所降低。好吧，确实如此。但并不是以任何你从现代软件开发中认识到的任何方式。

Fagan 小组进行的代码检查在很大程度上会揭露今天在编译代码之前现代 IDE 就会报告的问题。确实，Fagan 特别描述了在产品编写后、提交给编译器之前进行代码检查。回想一下你上一次在尝试构建之前**完全**编写应用程序的时候。对于今天的大多数开发者来说，这种情况从未发生过。

Fagan 的审查会在将一叠穿孔卡片提交到批量编译器之前发现诸如缺少分号或拼写错误等问题。这确实是在失去计算机时间和返工方面的一项宝贵节省。然而，对于现代代码审查来说，要具有价值，它必须在其他地方节省时间。应该鼓励审阅者关注更高层次的实际问题。代码是否代表了一个良好的抽象？是否有在其他地方重用其组件的机会？它是否准确地解决了当前的问题？

我发现对实现这一目标最有用的工具是清单。一组简短的、审阅者应关注的事项可以将审阅引导远离关于风格和命名实践的琐细问题。此外，它还指导*作者*在编写代码时思考这些问题，这应该会使实际的审阅过程本身相当简短。使用相同的清单几次之后，其有效性会降低，因为团队中的每个人都会对清单上出现的问题有一个共享的处理方法。因此，当旧项目变得不相关而其他问题的重要性增加时，清单上的项目应该进行交换。

通常，我正在工作的团队在将某个工作集成到发布版本时会进行代码审查。这比计划中的审查（代码很少经过充分准备，导致审阅者专注于已知的粗糙边缘）或请求审查（开发者根本不会请求）要好。GitHub 等工具通过“拉取请求”支持这一点——当作者想要将一些代码合并到上游分支或存储库时，他们会发送一个请求，这是一个进行审查的机会。其他工具，如**gerrit** ([`code.google.com/p/gerrit/`](http://code.google.com/p/gerrit/))，也提供了类似的功能。

理想情况下，代码审查应被视为学习活动。作者应该学习*为什么*审阅者建议特定的更改，存在什么问题，以及为什么提出的更改以代码提交到审查的方式解决了这些问题。审阅者也应该在学习：从提交的代码中学习的机会，通过提出令人信服的论据来支持为什么你的更改应该被接受，这些论据不是“因为我最懂”。为了使这起作用，代码审查的结果必须是一个讨论，即使它是一个审查工具中的评论线程。做一些额外的修复并接受没有讨论的修复更改会失去审查的大部分好处。

## 编程范式及其适用性

在一个（理论上正确，但实际并不令人愉快）层面上，所有软件都是由加载、存储、数学和跳转组成的，所以任何应用程序都可以使用任何允许正确排序这些基本操作的工具来编写。然而，贯穿这本书的一个关键主题是软件的人际性质，在这里，我们有一个具体的例子：应用程序源代码是程序员之间相互理解的来源。

在探索这个话题之前，我们先稍微回顾一下历史，以便明确这个想法，这样我们就可以将其放下。这是关于连续层抽象的想法，它允许人们在前人的基础上构建。是的，所有软件都是由上述基本操作构建的，但用计算机操作来思考你的问题是困难的。在存储程序计算机被发明后的几年里，EDSAC 程序员创建了一个*汇编器*，它将助记操作名称（如*加*表示为*A*）转换成计算机使用的操作`代码`。然后程序员只需关注他们正在添加事物的事实，而不必关注处理器在这个特定的寻址模式中用哪个数字来表示加法（在有多于一种寻址模式的计算机上）。

其他工作，包括对宏汇编器的研究以及格蕾丝·霍珀在 A-1 和其他编译器上的工作，使得程序员能够从计算机操作（即使是“友好”的名称）中提升一个层次，并以一种可以被翻译成低级指令的方式表达*他们想要发生的事情*。例如，一个循环遍历某些代码，使用索引变量从 2 到 20 取偶数值，可以表示为`FOR I=2 TO 20 STEP 2:…:NEXT I`，而不是计算机实际需要执行的初始化、测试、分支和更新步骤。

因此，当某人第一次在软件中解决问题时，其他人（在合法性、兼容性和可用性允许的情况下）可以在该解决方案之上构建其他软件。这适用于以下讨论：对象可以由其他对象构建，函数可以由其他函数构建。函数也可以由对象构建，对象也可以由函数构建。这不是那个故事。这是关于*故事*由函数和对象构建的故事；关于将编程范式作为思考软件和向其他程序员描述关于软件思考的方式。

### 面向对象编程

当它在 20 世纪 80 年代中期成为一种流行的技术时，有些人试图将 OOP 定位为解决软件行业所有问题的方案（这些问题是否以描述的形式存在可能是一个需要另一次讨论的话题）。IBM 臭名昭著的 System/360 项目的管理者弗雷德·布鲁克斯曾告诉程序员，没有*银弹*——[`www.cs.nott.ac.uk/~cah/G51ISS/Documents/NoSilverBullet.html`](http://www.cs.nott.ac.uk/~cah/G51ISS/Documents/NoSilverBullet.html)；软件行业面临的问题是困难的，没有任何技术解决方案会使它变得更容易。布拉德·考克斯反问，*如果真的有银弹*——[`dl.acm.org/citation.cfm?id=132388`](http://dl.acm.org/citation.cfm?id=132388)（即面向对象技术），而你的竞争对手已经在使用它？

就考克斯所看到的（或者至少在推广他的公司时定位它），面向对象编程是文化转变，它将软件构建从分离的独立手工艺品行业转变为真正的工程学科，通过引入*对象*作为具有标准接口的可互换组件，就像 pozidrive 螺丝或四乘二的板条。（软件-集成电路：考克斯使用的另一个隐喻，尤其是在他的书《面向对象编程：一种进化方法》——[`books.google.co.uk/books/about/Object_Oriented_Programming.html?id=deZQAAAAMAAJ&redir_esc=y`](http://books.google.co.uk/books/about/Object_Oriented_Programming.html?id=deZQAAAAMAAJ&redir_esc=y)中，是*软件集成电路*。正如计算机硬件的发展通过从组装离散组件的计算机到连接标准集成电路而加速一样，他设想了一种软件摩尔定律，这种定律源于从标准对象或软件集成电路组装的应用程序的连续发展。）

软件制造公司可以构建这些标准组件，并将它们提供给对象市场。这将相当于软件行业的贸易商店，蓝领工匠和 DIY 计算机用户可以从货架上购买对象，并将它们组装成他们需要的应用程序。

事实上，布鲁克斯已经指出，与软件开发相关的问题分为两类：一类是源于其作为复杂活动的*本质*问题，另一类是与当前流程或技术及其缺陷相关的*偶然*问题。面向对象编程没有解决本质问题，而是用其他偶然问题取代了一些问题。

总之，所有这些历史可能有些兴趣，但什么是面向对象编程呢？我们需要关注的问题不是操纵数据或指导计算机，而是如何*组织*这些数据和指令以帮助（人类）理解。

面向对象软件区别于其他技术的特性是其代码及其作用的数据以相互关联的组织形式构成自主单元（即所谓的*对象*），通过发送消息相互交互。支持这种方法的论点是，一个在这样一个单元上工作的程序员只需要理解其协作单元的*接口*——他们理解的消息以及这些消息的前提条件和结果；而不需要理解*实现*——这些单元是如何工作的。因此，一个由许多指令组成的大型程序被分割成多个独立的实体，这些实体可以独立开发。

许多在面向对象编程之前就已经存在的编程语言已经允许将代码组织成模块，每个模块都有自己的功能和数据。这些模块可以限制只通过特定的接口函数相互通信。面向对象编程在此基础上引入了自动机的概念，即代码和数据自包含的包，它既独立于软件系统中的无关部分，也独立于其他类似实例。因此，虽然用 Modula-2 编写的多人游戏可能有一个控制玩家角色并隐藏其细节的模块，但如果用像 Oberon-2 这样的面向对象语言编写，它可能有一个代表每个玩家角色的对象，该对象隐藏其内部细节，既隐藏于游戏的其他部分，也隐藏于其他玩家对象。

考虑到这种希望构建一个通过消息（cpp-messages）进行通信的自主代理系统，一些读者可能会对“面向对象编程涉及消息发送”的说法表示异议，他们认为使用 C++等语言（其成员函数作为反例）并不涉及消息发送。但可以简单地说，对象之间发送消息的*心智模型*仍然是有用的，尽管实际的语言实现可能不同。现在，一些其他读者可能会引用艾伦·凯的言论来断言，只有具有消息发送功能的语言才能被认为是面向对象的。（如果你挖掘得足够深，你会发现，在 Smalltalk 中，“面向对象”有时被用来指代*内存管理*范式；换句话说，就是垃圾回收器。编程模型被称为“消息传递”。因此，也许带有 Boehm-Demers-Weiser 垃圾回收器的 C++在纯粹主义者看来确实*是*面向对象的。不管怎样。如果你对此有异议，请找其他人发邮件。）最大的问题（如果不是*唯一*的问题；采用面向对象编程引入的唯一问题是选择哪些对象负责哪些动作。这是一个难以解决的问题；我记得我在创建第一个面向对象系统时犯了很多错误，直到近十年后才想要改进。所有领域的程序员都写过关于将系统分解为组件对象的经验法则，有些人还开发了评估软件与这些经验法则相关性的工具，以及自动改变组成的工具。

这些启发式方法从模糊的概念（如开闭原则、单一职责原则等）到精确定义的数学规则（如 Liskov 替换原则、迪米特法则等）不等。大多数（或许全部）这些方法都有一个高级目标，那就是提高系统中对象的*自主性*，减少它们对系统其他部分的依赖程度。这样做的好处是：提高了对象在不同系统中的可重用性，以及减少了某个特定对象因系统其他部分的变动而需要修改的可能性。

研究人员还发现，**面向对象软件**比结构化软件更难进行审查——[`dl.acm.org/citation.cfm?id=337343`](http://dl.acm.org/citation.cfm?id=337343)。导致紧密耦合对象连接系统的理想设计属性也产生了一个难以发现执行流程的系统；你不能轻易地看到任何特定消息的结果控制流向何方。确实存在一些工具旨在通过提供面向对象系统的多个相关视图来解决这个问题，例如 Code Bubbles 和 Eclipse Mylyn。这些工具目前还不是主流。当然，还有那些以 UML 等符号图示化方式描述面向对象软件的文档，这些文档的价值在*第八章，文档*中有所描述。

我发现，关于面向对象编程最有趣的阅读材料是它在新兴时期所写的；至少对于商业程序员来说是新的。这些材料试图说服你面向对象编程的好处，并解释这种范式的推理。在接下来的几十年中，具体的实践发生了显著变化，但现代书籍假设你知道*为什么*想要做面向对象编程，甚至常常假设你知道它是什么。

我建议即使是自认为经验丰富的面向对象程序员也应该阅读《面向对象编程：一种进化方法》（[`books.google.co.uk/books/about/Object_oriented_programming.html?id=U8AgAQAAIAAJ&redir_esc=y`](http://books.google.co.uk/books/about/Object_oriented_programming.html?id=U8AgAQAAIAAJ&redir_esc=y)）和《面向对象软件构造》（[`books.google.co.uk/books?id=v1YZAQAAIAAJ&source=gbs_similarbooks`](http://books.google.co.uk/books?id=v1YZAQAAIAAJ&source=gbs_similarbooks)）。这些书籍不仅告诉你关于特定语言（分别是 Objective-C 和 Eiffel）的信息，还介绍了这些语言旨在解决的问题。

从这些以及其他领域的基石性文本中，你可能学到的就是，面向对象编程（OOP）没有成功的原因并不是它失败了，而是它从未被尝试过。为了使 OOP 易于理解，**面向对象技术**公司明确指出，你已经在做的事情其实已经是面向对象编程了。如果你知道如何在 C 语言中编写顺序语句，你会*喜欢*在 Java 中编写顺序语句，然后你就在做面向对象编程了。

### 面向方面编程

面向对象编程的一个扩展，到目前为止还没有达到相同的应用和货币水平，即面向方面编程，旨在解决面向对象系统构建中的特定问题。更具体地说，这个问题存在于具有单一继承的单继承类面向对象系统中。

上一节描述了许多启发式方法的存在，这些方法是为了指导基于对象系统的代码组织。其中一种启发式方法是*单一职责原则*，它表示一个类中的代码应该只负责一件事。想象一下，然后是一个人力资源部门的数据库应用程序（如果忽略食谱管理器，几乎是面向对象示例的典范）。一个类可能代表一个员工，具有姓名、薪水、经理等属性。不应让每个人都能够更改员工的薪水，因此需要一些访问控制。为了审计和调试目的，能够记录员工薪水的任何更改也可能很有用。

因此有三个职责：更新数据库、访问控制和审计。单一职责原则意味着我们应该避免将所有职责放入`Employee`类中。实际上，这会导致大量重复，因为访问控制和审计功能也需要在应用程序的其他地方使用。它们是*横切关注点*，许多不同类必须提供相同的设施。

虽然有其他方法可以将这些横切关注点构建到应用程序中，但面向方面编程在面向对象系统中打开了可配置的*连接点*。这些连接点包括方法进入或退出、执行转移到异常处理器以及字段被读取或更改。方面定义了连接点必须满足的谓词，以便此方面相关（称为切入点）以及在该连接点运行的代码（有时称为建议）。

面向方面编程扩展适用于流行的面向对象环境（**AspectJ** ([`www.eclipse.org/aspectj/`](http://www.eclipse.org/aspectj/)) 用于 Java 和 **Aspect#** ([`sourceforge.net/projects/aspectsharp/`](http://sourceforge.net/projects/aspectsharp/)) 用于.NET)），但如前所述，这种风格并不广泛使用。它进一步加剧了面向对象已经存在的问题，即很难确定在给定事件响应中确切执行了哪些代码。其他系统，如 Ruby 和 Self（以及 C++），有“特性”或“混入”，它们占据着方面的位置，但不是名称。

### 函数式编程

比面向对象编程还要不那么新颖——尽管需要一点重新发现——的是函数式编程。正如其名所示，函数式编程完全是关于函数的；在这种情况下，是在数学意义上可以应用于某个输入域并产生相应范围输出的操作。而面向对象系统描述了计算机必须执行的命令式命令，函数式程序描述了应用于给定输入的函数。

这种区别导致了一些从命令式系统（尽管这些偏离可以在面向对象代码中建模，但在函数式编程中很普遍）中出现的有趣差异。函数式系统的一部分可以*惰性评估*；换句话说，计算机看到需要 x 的平方结果，可以推迟计算该结果，直到它实际上被使用，或者 CPU 处于空闲状态。这在对计算平方来说并不那么有趣，但可以导致像处理所有整数的列表这样的技巧。在命令式代码中，所有整数的列表在创建时就需要计算，这是不可能做到的。函数式软件可以定义一个评估为所有整数列表的东西，然后只对实际访问的条目进行惰性评估。

类似地，结果可以被*记忆化*：当 x 等于 2 时，x 乘以 x 的结果总是 4；我们知道它不依赖于任何其他东西，例如数据库的状态或用户在键盘上按下的键，所以一旦计算出 2 乘以 2 等于 4，我们就可以始终记住它并再次使用答案 4。

*递归*是函数程序中经常使用的武器。我们如何构建所有整数的列表？让我们限制自己为正整数的列表。定义 `f(x)` 函数，使得：

+   如果 `x` 是列表 `l` 的头部，`f(x)=1`

+   否则，`f(x)=1+f(previous entry)`

那么，对于一个只有一个条目的列表，应用 `f` 的结果是 1。对于两个条目的列表，它变成 `1+f(single-entry)=2`，依此类推。

递归和惰性评估都是有用的特性，但它们都不是函数式编程风格的固有特性；它们只是经常被用于这些领域。程序作为函数模型的一个更本质的部分是副作用的缺失。

因为数学函数没有副作用，函数的输出只取决于其输入。函数式编程的倡导者说，这使得软件更容易理解（不会发生任何“魔法”），并且它为构建多线程软件提供了一个良好的方法，因为不可能出现竞态条件；如果函数的输入可以准备，函数就可以产生其输出。如果一个函数与一个数字作为输入工作得很好，它将以相同的方式与另一个函数的（数值）输出作为输入工作；它的执行只取决于它接收到的。

当然，许多软件系统都有产生副作用的要求，例如在显示屏上绘制图像或修改数据库的保存状态。不同的函数式编程语言随后提供了不同的技术来*封装*——而不是完全删除——可变状态。例如，用 Haskell 编写的软件系统的有状态组件将被表示为函数的结果，并且可以自身执行以产生所需副作用；这样，有状态的部分可以充当函数程序的汇或源。

函数式编程在过去的几年里在商业领域获得了极大的流行，这主要得益于功能语言与现有（面向对象）代码的接口；例如，**Clojure** ([`clojure.org`](http://clojure.org)) 是在 **Java 虚拟机** (**JVM**) 上运行的，而 **F#** ([`fsharp.org/learn.html`](https://fsharp.org/learn.html)) 是在 .Net 虚拟机上的。尽管如此，其原则却要古老得多——LISP 是在 1958 年首次被描述的——[`www-formal.stanford.edu/jmc/recursive.html`](http://www-formal.stanford.edu/jmc/recursive.html)，但这些原则是基于早于可编程计算机的数学概念——[`www.jstor.org/stable/1968337`](http://www.jstor.org/stable/1968337)。关于函数式编程的如何和为什么，一本很好的参考书是 **《计算机程序的构造和解释》** ([`web.mit.edu/alexmv/6.037/sicp.pdf`](https://web.mit.edu/alexmv/6.037/sicp.pdf))，尽管这本书的最近版本使用了乍一看不是功能语言的 Python。
