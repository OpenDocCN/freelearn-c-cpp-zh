

# 第八章：什么是一个好的测试？

使用 TDD 开发的项目将有很多测试。但不要假设更多的或更长的测试总是更好的。你需要有好的测试。但什么是好的测试？

我们在这个章节中不会编写更多的代码。这个章节更多的是回顾我们已经遇到的一些情况，以及参考即将到来的章节中的某些测试。这是一个反思你到目前为止所学内容并展望即将到来的主题的机会。

一个好的测试应该包含以下元素：

+   容易理解——良好的理解将导致更多测试的更好想法，并使测试更容易维护。

+   专注于特定的场景——不要试图在一个巨大的测试中测试一切。在测试中做太多事情会破坏可理解性的第一条指导原则。

+   可重复——使用随机行为来有时捕捉问题的测试可能在最糟糕的时候错过问题。

+   保持与项目紧密相关——确保测试属于它们正在测试的项目。

+   应该测试应该发生的事情而不是如何发生的事情——如果一个测试过于依赖内部工作原理，那么它将是脆弱的，当代码重构时将造成更多的工作。

本章将用示例解释这些主题。

# 技术要求

本章中的所有代码都来自本书的其他章节，并在此用作示例代码，以加强好的测试的想法。

# 使测试易于理解

使用描述性的测试名称可能是你可以做的单件最好的事情来改进你的测试。我尽可能喜欢使用简单的句子来命名我的测试。例如，我们最早创建的测试之一叫做 `"Test will pass without any confirms"`，看起来像这样：

```cpp
TEST("Test will pass without any confirms")
{
}
```

一个好的模式是这样的：

```cpp
<object><does something><qualification>
```

每个部分都应该替换为你正在做的事情的具体内容。对于刚刚给出的例子，`<object>` 是 `Test`，`<does something>` 是 `will pass`，而 `<qualification>` 是 `without` `any confirms`。

我并不总是遵循这个模式，尤其是在测试一个对象或类型以获得几个不同且相关结果时。例如，紧随上一个测试之后的简单测试看起来像这样：

```cpp
TEST("Test bool confirms")
{
    bool result = isNegative(0);
    CONFIRM_FALSE(result);
    result = isNegative(-1);
    CONFIRM_TRUE(result);
}
```

对于这个简单的测试，只有两种可能性。布尔值要么是假的，要么是真的。测试专注于布尔类型，名称完全描述了测试做了什么。我的建议是，当有道理的时候，遵循命名模式。

以下是一些描述性名称如何帮助改进你的测试的方法：

+   名称是你将在摘要描述中看到的，它将帮助任何人仅通过一眼就能理解正在测试的内容。

+   一个描述性的名称将帮助你发现测试中的漏洞，因为当你能清楚地看到已经测试了什么时，更容易看到缺少了什么。

+   一个遵循给定模式的描述性名称将帮助你专注于编写测试。很容易失去对测试应该做什么的跟踪，并开始包括其他事情。描述性名称将帮助你将相关的检查放在它们自己的测试中，这样它们就不会再使被测试的内容变得杂乱，并将有自己的描述性名称，这有助于它们脱颖而出。

将这三个好处结合起来，你将得到一个增强良好命名需求的反馈循环。你将自然地创建更多测试，因为每个测试都是专注的。这有助于你更好地理解正在测试的内容，从而帮助你找到缺失的测试。然后，在编写新测试时，你将保持方向，并在新想法出现时继续创建更多测试。

想象一下，如果我们采取了不同的方法，创建了一个名为“确认”的测试。它会做什么？这能激发你想到更多测试吗？你会在测试中编写什么代码？这是一个阻止更好测试循环的名称。没有人会知道测试做什么，除非阅读代码。没有人会想到新的场景，因为焦点被拖入了代码。而且测试代码本身可能散落在各处，但仍未能覆盖所有应该测试的内容。

我们不要忘记，使用 TDD 的目的是为了帮助我们驱动设计，提高软件质量，并让我们有信心重构和增强代码。描述性名称有助于所有这些。

你可能会发现，在重大重构之后，某些测试可能不再适用。这是正常的，它们可以被删除。描述性名称将帮助我们识别这些过时的测试。有时，与其删除测试，不如更新它们，专注于的测试将更容易更新。

创建良好测试的下一步是保持它们的简单性。复杂的测试通常是一个糟糕设计的症状。TDD 有助于改进设计。所以当你发现一个复杂的测试时，那就是你简化被测试项目设计的信号。

如果你能够进行简化测试的更改，那么这通常是一个双赢的局面。你得到的是更容易理解的测试，这导致软件质量更高，更容易使用。记住，测试是软件的消费者，就像任何其他组件一样。所以当你能够简化测试时，你也在简化使用相同代码的其他代码。

简化测试的一个重要部分是利用设置和清理代码。这使测试能够专注于它需要做的事情，并让我们能够阅读和理解测试的主要点，而不会被其他准备工作的代码分散注意力。

例如，在*第十四章*，“如何测试服务”，我向你展示了最初创建来测试服务的测试。该测试创建了一个服务本地实例并调用`start`。我意识到其他测试可能需要启动服务，因此它们可以共享已经启动的服务和一些设置代码。新的测试使用一个允许多个测试共享相同设置和拆卸代码的测试套件。测试看起来像这样：

```cpp
TEST_SUITE("Request can be sent and response received", "Service 1")
{
    std::string user = "123";
    std::string path = "";
    std::string request = "Hello";
    std::string expectedResponse = "Hi, " + user;
    std::string response = gService1.service().handleRequest(
        user, path, request);
    CONFIRM_THAT(response, Equals(expectedResponse));
}
```

这个测试有一个描述性的名称，并专注于需要测试的内容，而不是创建和启动服务所需的内容。该测试使用全局`gService1`实例，通过`service`方法公开已运行的服务。

通过提供描述性名称并尽可能简化你的测试，你将发现使用 TDD（测试驱动开发）可以获得更好的结果，这将导致更好的软件设计。下一节将更详细地介绍如何专注于特定场景。

# 将测试集中在特定场景

上一节解释了描述性名称的一个好处是它们有助于保持测试的集中。在本节中，我们将探讨各种场景，这将为你提供关于要集中注意力的想法。

说一个测试应该集中是很不错的。但如果不知道如何确定要集中什么，那么这不会对你有帮助。建议变得空洞且令人沮丧。

这五个案例将使建议更有意义。并非所有这些案例都适用于所有情况。但拥有这些案例将对你有所帮助，有点像清单。你只需要思考每一个案例，并编写覆盖该案例的具体测试。案例如下：

1.  **正常或愉快**：这是一个常见的用例。

1.  **边缘**：这是正常和错误情况之间过渡的案例。

1.  **错误**：这是一个需要处理的常见问题。

1.  **非正常**：这是一个有效但不太常见的用例。

1.  **故意误用**：这是一个故意设计来造成问题的错误案例。

让我们先从正常或愉快的情况开始。这个应该很简单，但通常会被包括其他一些案例而变得过于复杂。或者，另一种可能使其过于复杂的方式是创建一个过于模糊或不清晰表明它是正常或愉快情况的测试。

这个实际的名称可能应该是正常情况，因为这与其他情况的风格相匹配。但我经常把这个想成愉快的情况，所以我包括了两个名称。你也可以把它想成典型情况。无论你怎么想，你只需要选择一个最能描述你的代码通常使用方式的场景。我认为它是愉快的情况，因为不应该有任何错误。这应该代表预期的和典型的情况，并且应该成功。例如，在*第十三章*，*如何测试浮点数和自定义值*中，有一个测试浮点值的测试，它涵盖了从 0.1 到 100 的 1000 个典型值，增量是 0.1。测试看起来像这样：

```cpp
TEST("Test many float comparisons")
{
    int totalCount {1'000};
    int passCount = performComparisons<float>(totalCount);
    CONFIRM_THAT(passCount, Equals(totalCount));
}
```

边界情况位于一个愉快的情况和问题或错误情况之间的边界。你可能经常需要两个边界情况，其中一个代表最极端的使用方式，但仍然在正常范围内，另一个则是错误条件的开始。边界情况是良好和不良结果之间的过渡。通常会有多个边界情况。

边界情况在测试中非常重要，因为它们往往能发现很多错误，也许更重要的是，它们能让你思考你的设计。当你考虑边界情况时，你通常会接受边界情况或者改变你的设计，使得边界情况不再适用。

前一个浮点比较的边界情况是为了测试一个非常小的浮点值和一个非常大的浮点值。这两个测试是分开的，看起来像这样：

```cpp
TEST("Test small float values")
{
    // Based on float epsilon = 1.1920928955078125e-07
    CONFIRM_THAT(0.000001f, NotEquals(0.000002f));
}
TEST("Test large float values")
{
    // Based on float epsilon = 1.1920928955078125e-07
    CONFIRM_THAT(9'999.0f, Equals(9'999.001f));
}
```

边界情况有时可能更技术性，因为通常有一个原因使得测试成为边界情况。对于浮点值，边界情况基于*epsilon*值。Epsilon 值在*第十三章*，*如何测试浮点值*中有解释。为小和大浮点值添加测试将导致我们改变*第十三章*中比较浮点值的方式。这就是为什么边界情况在测试中如此有价值。

错误情况就像愉快的情况变得悲伤。想想你的代码可能需要处理的典型问题，并为该特定问题编写一个测试。就像愉快的情况有时可能过于复杂一样，这个测试也可能过于复杂。你不需要为了变化本身而包括错误情况的微小变化。只需选择你认为最能代表最常见或中间情况，并导致错误的情况，并为该单一情况创建一个测试。当然，你希望用描述性的名称命名测试，以解释情况。

例如，在*第十一章* *管理依赖*中，有一个正常测试来确保标签*可以*用于过滤消息。一个错误情况几乎正好相反，确保覆盖的默认标签*不*用于过滤消息。如果没有先阅读*第十一章*，这个测试可能没有意义。我将其包括在这里，作为一个错误情况的例子。注意测试末尾的`CONFIRM_FALSE`，这是确保日志消息不会出现在日志文件中的部分。测试看起来是这样的：

```cpp
TEST("Overridden default tag not used to filter messages")
{
    MereTDD::SetupAndTeardown<TempFilterClause> filter;
    MereMemo::addFilterLiteral(filter.id(), info);
    std::string message = "message ";
    message += Util::randomString();
    MereMemo::log(debug) << message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
}
```

如果你认为有多个错误情况都足够重要，应该包含在内，请将它们放入单独的测试中，并询问每个情况的不同之处。这可能会让你产生洞察力，从而改变你的设计或导致更多的测试。

我喜欢包含一些测试，这些测试超出了正常情况，但不是边界或边缘情况。这些测试仍然在有效使用范围内，应该成功，但可能会让你的代码做一点额外的工作。这种情况在帮助捕捉回归中可能很有价值。回归是一个新的错误，它代表了一个以前曾经工作过的问题。回归在做出重大设计变更后最为常见。有一些非正常但仍然预期会成功的测试将提高你在做出重大变更后对代码继续工作的信心。

最后一个情况是有意误用，出于安全原因很重要。这不仅仅是一个错误情况；这是一个精心设计的错误情况，旨在以攻击者可以用于自己目的的预测方式导致你的代码失败。对于这种情况，与其创建你知道会失败的测试，不如考虑什么会导致你的代码以惊人的方式失败。也许你的代码将负数视为错误。那么，对于有意误用，也许可以考虑使用非常大的负数。

在*第十四章* *如何测试服务*中，提到了一个关于有意误用的可能测试。我们实际上并没有创建这个测试，但我确实描述了这个测试可能的样子。在服务中，有一个表示正在进行的请求的字符串值。代码处理未识别的请求字符串，我提到一个好的测试会尝试使用一些不存在的请求调用服务，以确保服务正确处理格式不正确的请求。

关于专注于特定场景的最后一条建议，我想推荐你避免重复测试。这不是前面提到的五种情况之一，因为它适用于所有这些情况。

重复测试是指你在许多测试中反复检查相同的事情或做出相同的确认。你不需要这样做，这只会让你分心，无法专注于每个测试应该关注的内容。

如果你需要确认某个属性或结果是否正常工作，那么就为它创建一个测试。然后你可以相信它将会被测试。你不需要每次使用时都再次确认属性是否按预期工作。一旦你为某事创建了测试，那么你就不需要在其他测试中验证它是否工作。

# 只以这种方式使用随机行为

上一章提到了在测试中使用随机行为，了解这一点对于你的测试可预测和可重复非常重要。

可预测性和随机性几乎是你能想象到的最相反的两个属性。我们应该如何调和这两个属性呢？首先，你需要理解的是，你编写的测试应该是可预测的。如果一个测试通过了，那么除非你无法控制的外部因素失败，例如在测试过程中硬盘崩溃，否则它应该总是通过。没有办法可预测地处理这样的意外，这也不是我在谈论的。我的意思是，如果一个测试通过了，那么它应该继续通过，直到某些代码更改导致它失败。

当测试失败时，它应该继续失败，直到问题得到解决。你最不希望的是向测试中添加随机行为，以便有时做一件事，有时做另一件事。这是因为第一种行为可能会通过，而第二种行为可能会走不同的代码路径而失败。

如果你遇到失败，进行你认为可以解决问题的更改，然后通过测试，你可能会认为你的更改解决了问题。但如果是第二次测试运行恰好使用了总是通过的那个随机行为呢？这会使验证代码更改实际上是否解决问题变得困难。

更糟糕的是，当某些随机失败条件从未被执行时会发生什么？你认为所有可能的代码路径组合都在运行，但偶然之间，一个或多个条件被跳过了。这可能导致你错过应该被捕获的 bug。

我希望我已经说服你远离随机测试行为。如果你想测试不同的场景，那么编写多个测试，以便每个场景都由其自己的测试来可靠地运行。

那么，为什么我在上一章提到了使用随机性呢？我实际上确实建议你使用随机性，但不是用来决定测试做什么的方式；而是用来帮助防止不同测试运行之间的冲突。这种随机行为在创建临时表的辅助函数中提到：

```cpp
std::string createTestTable ()
{
    // If this was real code, it might open a
    // connection to a database, create a temp
    // table with a random name, and return the
    // table name.
    return "test_data_01";
}
```

假设你有一个需要一些数据的测试。你在设置中创建数据，在测试完成后在清理中删除它。如果测试程序在测试期间崩溃，并且清理没有机会删除数据会发生什么？下次你运行测试时，很可能设置会失败，因为数据仍然存在。这就是我所说的冲突。

也许你认为，如果你增强设置以成功找到已存在的数据，那么你可以。你也可以通过其他方式得到冲突，例如在团队中编写代码时，两个团队成员几乎同时运行测试。两个设置步骤都会运行，其中一个发现数据已存在并继续。但在测试开始使用数据之前，另一个团队成员已经完成，并且清理代码删除了数据。仍在运行测试的团队成员现在会失败，因为数据不再存在。

你可以通过生成随机数据几乎完全消除这个问题。但不要随机到影响测试行为。只需随机到足以避免冲突。也许数据是通过一个名称来标识的。只要名称不是测试的一部分，名称可以稍微改变，以便每次运行测试时，数据都有一个不同的名称。`createTestTable`函数返回一个硬编码的名称，但注释提到随机名称可能更好。

在测试中使用完全随机行为的地方，例如在执行随机渗透测试时，你需要模糊或更改数据来模拟你否则无法为特定场景编写测试用例的情况。可能的组合数量可能太多，无法用特定的命名测试用例处理。因此，在这些情况下，编写使用随机数据来改变测试行为和结果的测试是个好主意。但这类测试不会帮助你通过 TDD 来改进你的设计。它们有补充 TDD 的位置。

当编写使用随机行为的测试时，例如处理不可计数的组合时，你需要捕获失败，因为每个失败都需要分析以找出问题。这是一个耗时过程。虽然很有价值，但当你编写测试来帮助你确定要使用的设计或评估重大设计变更的结果以查看是否有什么东西被破坏时，这不是你需要的。

对于对 TDD 最有益的测试类型，应避免任何可能改变测试结果的随机行为。这将确保你的测试可重复和可预测。

# 只测试你的项目

其他组件和库将被使用，可能会失败。你应该如何处理测试中的这些失败？我的建议是假设只有你的代码需要被测试。你应该假设你使用的组件和库已经过测试并且正在正常工作。

首先，记住我们使用 TDD 来改进我们自己的代码。如果你为一些你购买或在网上找到的代码编写测试，这会如何影响你自己的代码？

总是有这样的可能性，你正在使用一个开源库，并且你有一个很好的改进想法。那太好了！但是这个改进应该属于那个其他项目。它不应该出现在你自己的项目测试中。即使你在商业软件包中找到一个错误，你所能做的就是报告问题并希望它得到修复。

你最不想做的事情就是在自己的测试项目中添加一个确认，确认其他代码按预期工作。这不仅不会影响你自己的设计，实际上会使你的测试变得不那么专注。它通过添加一些对你的项目没有直接好处的干扰，削弱了你应该追求的清晰度。

本书下一章开始是**第二部分**，我们将构建一个日志库。日志库将是一个独立的项目，有自己的测试集。日志库还将使用我们一直在构建的测试库。想象一下，如果我们向测试库添加一个新功能，然后从日志库测试这个新功能，那会多么令人困惑。

# 测试应该发生的事情，而不是如何发生

我常见的一个问题是，当测试试图通过检查过程中的内部步骤来验证预期结果时。测试正在检查如何做某事。这种类型的测试很脆弱，通常需要频繁的更新和更改。

更好的方法是测试最终结果会发生什么。因为这样，内部步骤可以根据需要改变和适应。测试在整个过程中保持有效，无需进一步维护。

如果你发现自己正在频繁地更新测试，以便它们再次通过，那么你的测试可能是在测试如何做某事，而不是做了什么。

例如，在*第十章*“深入理解 TDD 过程”中，有一个名为*何时测试过多？*的部分，详细解释了应该测试什么的概念。

一般的想法是这样的。假设你有一个向集合添加过滤器的函数。如果你写一个专注于代码如何工作的测试，那么你可能会遍历集合中的项目，以确保刚刚添加的过滤器确实出现在集合中。这种方法的缺点是集合是一个内部步骤，可能会改变，这会导致测试失败。更好的方法是首先添加过滤器，然后尝试执行一个会受到过滤器影响的操作。确保过滤器按你预期的方式影响代码，并将它如何工作的内部细节留给被测试的代码。这是测试应该发生的事情，是一个更好的方法。

# 摘要

这更像是一个反思性的章节，你学到了一些有助于你编写更好测试的技巧。早期和后期章节的例子被用来帮助加强这些想法和指导。如果你确保考虑以下事项，你会写出更好的测试：

+   测试应该易于理解，具有描述性的名称。

+   宁愿使用小型且专注的测试，而不是试图做所有事情的庞大测试。

+   确保测试是可重复的。如果一个测试失败了一次，那么它应该继续失败，直到代码被修复。

+   一旦你测试了某个东西，你就不需要继续测试相同的东西。如果你有一些其他测试可以共享的有用代码，那么考虑将这些代码放入自己的项目，并为其设置自己的测试集。只测试你项目中的代码。

+   测试应该发生的事情，而不是它应该如何发生。换句话说，减少对内部步骤的关注，而是验证你最感兴趣的结果。

有许多方法可以编写更好的测试。本章不应被视为包含你需要考虑的唯一事项。相反，本章确定了导致测试问题的常见问题，并为你提供了改进测试的技巧和建议。在下一章中，我们将使用 TDD 来创建一个将使用单元测试库的项目，就像你将在自己的项目中做的那样。

# 第二部分：使用 TDD 创建日志库

本书分为三部分。在本第二部分中，我们将使用单元测试库来设计和构建一个日志库。在这个过程中，你将看到如何在不同项目中使用 TDD，就像你将在自己的项目中做的那样。

本部分涵盖了以下章节：

+   *第九章*, *使用测试*

+   *第十章*, *深入理解 TDD 过程*

+   *第十一章*, *管理依赖*
