# 前言

长期以来，嵌入式系统的开发要求要么使用纯 C，要么使用汇编语言。这其中有很多充分的理由。硬件资源不足以运行用高级编程语言（如 C++、Java 或 Python）编写的应用程序，但更重要的是，没有真正的需要用这些语言编写软件。有限的硬件资源限制了软件的复杂性，嵌入式应用程序的功能保持相对简单，C 的功能足以实现它。

由于硬件发展的进步，如今越来越多的嵌入式系统由价格低廉但功能强大的 SoC 提供支持，能够运行诸如 Linux 之类的通用多任务操作系统。

不断增长的硬件能力需要更复杂的软件，越来越多的情况下 C++成为新嵌入式系统的首选语言。通过其“你不使用的部分不需要付费”的方法，它允许开发人员创建使用计算和内存资源的应用程序，就像用 C 编写的应用程序一样，但提供了更多处理复杂性和更安全的资源管理工具，如面向对象编程和 RAII 习惯用法。

经验丰富的嵌入式开发人员通常倾向于以一种类似习惯的方式用 C++编写代码，认为这种语言只是 C 的面向对象扩展，一个带有类的 C。然而，现代 C++有自己的最佳实践和概念，正确使用这些概念可以帮助开发人员避免常见陷阱，并允许他们在几行代码中完成很多工作。

另一方面，具有 C++经验的开发人员进入嵌入式系统的世界时，应该了解特定硬件平台和应用领域的要求、限制和能力，并相应地设计他们的 C++代码。

这本书的目标是弥合这一差距，并演示现代 C++的特性和最佳实践如何在嵌入式系统的背景下应用。

# 这本书是为谁写的

这本书是为那些想要在 C++中构建有效嵌入式程序的开发人员和电子硬件、软件和系统芯片工程师而写的。

嵌入式系统的世界是广阔的。这本书试图涵盖其中一种类型，即运行 Linux 操作系统的 SoC，如树莓派或 BeagleBoard，并简要涉及低级微控制器，如 Arduino。

预期读者熟悉 C++，但不需要深入了解 C++或有嵌入式系统经验。

# 这本书涵盖了什么

第一章《嵌入式系统基础》，定义了嵌入式系统是什么，它们与其他系统有何不同，为什么需要特定的编程技术，以及为什么 C++在嵌入式开发中是好的，在许多情况下是最佳选择。它概述了嵌入式开发人员在日常工作中遇到的约束和挑战：有限的系统资源和 CPU 性能，处理硬件错误和远程调试。

第二章《设置环境》，解释了嵌入式系统开发环境与 Web 或桌面应用程序开发的差异，并介绍了构建和目标系统、交叉编译和交叉工具包、串行控制台和远程 shell 的概念。它提供了为运行 Windows、macOS 或 Linux 的最常见桌面配置设置虚拟化构建和目标主机的实际步骤。

第三章《使用不同架构》，解释了如何在 C++代码中考虑目标系统的 CPU 架构和内存配置的重要差异。

第四章《处理中断》涵盖了中断和中断服务例程的低级概念。在现代操作系统中，即使是开发人员或设备驱动程序也必须使用操作系统提供的更高级别的 API。这就是为什么我们使用 8051 微控制器来探讨中断技术。

第五章《调试、日志记录和性能分析》涵盖了特定于基于 Linux 的嵌入式系统的调试技术，比如直接在目标板上运行 gdb、设置 gdbserver 进行远程调试，以及日志记录对于调试和故障根本原因分析的重要性。

第六章《内存管理》提供了几种内存分配的实用方法和最佳实践，对于嵌入式系统的开发人员将会很有帮助。我们讨论了为什么在嵌入式应用程序中要避免动态内存分配，以及可以考虑用于快速、确定性内存分配的替代方案。

第七章《多线程和同步》解释了如何使用 C++标准库提供的函数和类来实现高效的多线程应用程序，以充分利用现代多核 CPU 的所有性能。

第八章《通信和序列化》涵盖了进程间和系统间通信的概念、挑战和最佳实践，比如套接字、管道、共享内存以及使用 FlatBuffers 库进行内存高效序列化。将应用程序解耦为使用明确定义的异步协议相互通信的独立组件，是扩展软件系统的标准方式，同时保持其快速和容错性。

第九章《外围设备》解释了如何在 C++程序中使用各种外围设备。尽管大多数设备通信 API 不依赖于特定的编程语言，但我们将学习如何利用 C++的强大功能编写对开发人员方便并有助于防止常见资源泄漏错误的包装器。

第十章《降低功耗》探讨了编写节能应用程序和利用操作系统的功耗管理功能的最佳实践。它提供了几种适用于基于 Linux 的嵌入式系统的实用方法，但相同的概念也可以扩展到任何操作系统和任何平台。

第十一章《时间点和间隔》涵盖了与时间操作相关的各种主题，从测量间隔到添加延迟。我们将了解标准 C++ Chrono 库提供的 API，以及如何有效地使用它来构建可移植的嵌入式应用程序。

第十二章《错误处理和容错》探讨了用 C++编写的嵌入式应用程序的错误处理的可能实现和最佳实践。它解释了如何有效地使用 C++异常，并将其与传统错误代码和复杂返回类型等替代方案进行了比较。它涉及了基本的容错机制，如看门狗定时器和心跳。

第十三章《实时系统指南》涵盖了实时系统的具体内容。它简要描述了实时系统的定义以及存在哪些类型的实时系统。它包含了如何使应用程序的行为更加确定性的实用方法，这是实时系统的关键要求。

第十四章，*安全关键系统的指南*，解释了什么是安全关键系统，以及它们与其他嵌入式系统的不同之处。它涵盖了在开发安全关键系统时所需的开发方法和工具，从遵循形式化编码指南，如 MISRA、AUTOSAR 或 JSF，到使用静态代码分析或形式软件验证工具。

第十五章，*微控制器编程*，概述了为微控制器编写、编译和调试 C++代码的基本概念。我们将学习如何使用广泛使用的 Arduino 板来设置开发环境。

# 为了充分利用本书

嵌入式系统的开发意味着您的应用程序将与某种专用硬件进行交互——特定的 SoC 平台、特定的微控制器或特定的外围设备。有各种各样的可能硬件配置，以及需要与这些硬件设置一起工作的专用操作系统或集成开发环境。

本书的目标是让每个人都能开始学习嵌入式系统编程，而不需要在硬件上投入太多。这就是为什么大多数的示例都是针对在虚拟化的 Linux 环境或模拟器中工作。然而，有些示例可能需要物理硬件。这些示例被设计为在树莓派或 Arduino 上运行，这两种是最常用和价格相对便宜的平台。

| **本书涵盖的软件/硬件** | **操作系统要求** |
| --- | --- |
| Docker ([`www.docker.com/products/docker-desktop`](https://www.docker.com/products/docker-desktop)) |

+   Microsoft Windows 10 专业版或企业版 64 位

+   macOS 10.13 或更新版本

+   Ubuntu Linux 16.04 或更新版本

+   Debian Linux Stretch（9）或 Buster（10）

+   Fedora Linux 30 或更新版本

|

| QEMU ([`www.qemu.org/download/`](https://www.qemu.org/download/)) |
| --- |

+   Windows 8 或更新版本（32 位或 64 位）

+   macOS 10.7 或更新版本

+   Linux（各种发行版）

|

| 树莓派 3 型 B+ |  |
| --- | --- |
| Arduino UNO R3 或 ELEGOO UNO R3 |  |

**如果您使用的是本书的数字版本，我们建议您自己输入代码或通过 GitHub 存储库访问代码（链接在下一节中提供）。这样做将有助于避免与复制和粘贴代码相关的任何潜在错误。**

# 下载示例代码文件

您可以从[www.packt.com](http://www.packt.com/)的帐户中下载本书的示例代码文件。如果您在其他地方购买了本书，可以访问[www.packtpub.com/support](https://www.packtpub.com/support)注册，直接将文件发送到您的邮箱。

您可以按照以下步骤下载代码文件：

1.  在[www.packt.com](http://www.packt.com/)上登录或注册。

1.  选择“支持”选项卡。

1.  单击“代码下载”。

1.  在搜索框中输入书名，然后按照屏幕上的说明操作。

文件下载后，请确保使用最新版本的以下软件解压缩文件夹：

+   Windows 上的 WinRAR/7-Zip

+   Mac 上的 Zipeg/iZip/UnRarX

+   Linux 上的 7-Zip/PeaZip

该书的代码包也托管在 GitHub 上，网址为[`github.com/PacktPublishing/Embedded-Programming-with-Modern-CPP-Cookbook`](https://github.com/PacktPublishing/Embedded-Programming-with-Modern-CPP-Cookbook)。如果代码有更新，将在现有的 GitHub 存储库上进行更新。

我们还提供来自丰富图书和视频目录的其他代码包，可在**[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)**上找到。请查看！

# 下载彩色图片

我们还提供了一个 PDF 文件，其中包含本书中使用的屏幕截图/图表的彩色图片。您可以在这里下载：[`static.packt-cdn.com/downloads/9781838821043_ColorImages.pdf`](https://static.packt-cdn.com/downloads/9781838821043_ColorImages.pdf)。

# 使用的约定

本书中使用了许多文本约定。

`CodeInText`：表示文本中的代码词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 用户名。例如："在`gdbserver`下运行`hello`应用程序。"

代码块设置如下：

```cpp
#include <iostream>

int main() {
 std::cout << "Hello, world!" << std::endl;
 return 0;
}
```

当我们希望引起您对代码块的特定部分的注意时，相关行或项目将以粗体显示：

```cpp
#include <iostream>

int main() {
 std::cout << "Hello, world!" << std::endl;
 return 0;
}
```

任何命令行输入或输出都是这样写的：

```cpp
$ docker run -ti -v $HOME/test:/mnt ubuntu:bionic
```

**粗体**：表示一个新术语、一个重要单词或屏幕上看到的单词。例如，菜单或对话框中的单词会以这种方式出现在文本中。例如："为了配置 CMake 的交叉编译，最好使用所谓的**toolchain**文件"

警告或重要说明看起来像这样。

提示和技巧看起来像这样。

# 章节

在本书中，您会经常看到几个标题（*准备就绪*、*如何做...*、*它是如何工作的...*、*还有更多...*和*另请参阅*）。

为了清晰地说明如何完成一个食谱，请按照以下各节使用：

# 准备就绪

本节告诉您在食谱中可以期待什么，并描述如何设置任何软件或食谱所需的任何初步设置。

# 如何做...

本节包含了遵循食谱所需的步骤。

# 它是如何工作的...

本节通常包括对前一节中发生的事情的详细解释。

# 还有更多...

本节包含了有关食谱的额外信息，以使您对食谱更加了解。

# 另请参阅

本节为食谱提供了其他有用信息的链接。