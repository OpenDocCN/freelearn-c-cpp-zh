# 第一章：嵌入式系统基础

嵌入式系统是将硬件和软件组件结合起来解决更大系统或设备中的特定任务的计算机系统。与通用计算机不同，它们非常专业化和优化，只执行一个任务，但执行得非常出色。

它们无处不在，但我们很少注意到它们。您可以在几乎每个家用电器或小工具中找到它们，例如微波炉、电视机、网络附加存储或智能恒温器。您的汽车包含了几个相互连接的嵌入式系统，用于处理制动、燃油喷射和信息娱乐。

在本章中，我们将处理嵌入式系统的以下主题：

+   探索嵌入式系统

+   利用有限资源

+   性能影响

+   使用不同的架构

+   处理硬件错误

+   使用 C++进行嵌入式开发

+   远程部署软件

+   远程运行软件

+   日志记录和诊断

# 探索嵌入式系统

每个计算机系统都是为了解决更大系统或设备的特定问题而创建的嵌入式系统。即使您的通用 PC 或笔记本电脑也包含许多嵌入式系统。键盘、硬盘驱动器、网络卡或 Wi-Fi 模块——每个都是具有处理器（通常称为**微控制器**）和自己的软件（通常称为**固件**）的嵌入式系统。

现在让我们深入了解嵌入式系统的不同特性。

# 它们与桌面或 Web 应用程序有何不同？

与桌面或服务器相比，嵌入式系统最显著的特点是其紧密耦合的硬件和软件，专门用于完成特定任务。

嵌入式设备在各种物理和环境条件下工作。大多数嵌入式系统不是设计为仅在专用条件数据中心或办公室中工作。它们必须在无法控制的环境中正常工作，通常没有任何监督和维护。

由于它们是专业化的，硬件要求被精确计算，以尽可能地节约成本。因此，软件旨在利用可用资源的 100%，并且最小化或没有储备。

与常规桌面和服务器相比，嵌入式系统的硬件差异更大。每个系统的设计都是独特的。它们可能需要非常特定的 CPU 和将它们连接到存储器和外围硬件的电路图。

嵌入式系统旨在与外围硬件通信。嵌入式程序的主要部分是检查状态、读取输入、发送数据或控制外部设备。嵌入式系统通常没有用户界面。与在传统桌面或 Web 应用程序上进行相同操作相比，这使得开发、调试和诊断更加困难。

# 嵌入式系统类型

嵌入式系统涵盖了广泛的用例和技术，从用于自动驾驶或大规模存储系统的强大系统到用于控制灯泡或 LED 显示器的微型微控制器。

根据硬件的集成和专业化程度，嵌入式系统大致可以分为以下几类：

+   **微控制器**（**MCUs**）

+   **片上系统**（**SoC**）

+   **特定应用集成电路**（**ASICs**）

+   **现场可编程门阵列**（**FPGAs**）

# 微控制器

MCUs 是为嵌入式应用设计的通用集成电路。单个 MCU 芯片通常包含一个或多个 CPU、存储器和可编程输入/输出外设。它们的设计允许它们直接与传感器或执行器接口，而无需添加任何其他组件。

MCUs 广泛应用于汽车发动机控制系统、医疗设备、遥控器、办公设备、家用电器、电动工具和玩具。

它们的 CPU 从简单的 8 位处理器到更复杂的 32 位甚至 64 位处理器都有。

存在许多 MCUs；如今最常见的是以下几种：

+   英特尔 MCS-51 或 8051 MCU。

+   Atmel 的 AVR

+   来自 Microchip Technology 的可编程接口控制器（PIC）

+   各种基于 ARM 的 MCU

# 片上系统

SoC 是一种集成电路，它将解决特定类别问题所需的所有电子电路和部件集成在一个芯片上。

它可能包含数字、模拟或混合信号功能，取决于应用。在单个芯片中集成大多数电子部件的两个主要好处是：小型化和低功耗。与较少集成的硬件设计相比，SoC 需要明显更少的功耗。在硬件和软件层面对功耗的优化使其能够在没有外部电源的情况下工作数天、数月甚至数年。通常，它还集成了射频信号处理，加上其紧凑的物理尺寸，使其成为移动应用的理想解决方案。此外，SoC 通常用于汽车行业、可穿戴电子产品和物联网（IoT）。

![](img/5075c1bd-7414-4cbc-bfd7-19097332a3de.png)

图 1.1：树莓派 B+型号

树莓派系列单板计算机是基于 SoC 设计的系统的一个例子。B+型号建立在 Broadcom BCM2837B0 SoC 之上，具有集成的四核 1.4 GHz 基于 ARM 的 CPU，1 GB 内存，网络接口控制器和四个以太网接口。

该板具有四个 USB 接口，MicroSD 卡插槽用于引导操作系统和存储数据，以太网和 Wi-Fi 网络接口，HDMI 视频输出，以及一个 40 针 GPIO 头，用于连接自定义外围硬件。

它配备了 Linux 操作系统，是教育和 DIY 项目的绝佳选择。

# 特定应用集成电路

特定应用集成电路（ASICs）是由制造商定制用于特定用途的集成电路。定制是一个昂贵的过程，但允许它们满足通常对通用硬件解决方案不可行的要求。例如，现代高效的比特币矿工通常建立在专用 ASIC 芯片之上。

为了定义 ASIC 的功能，硬件设计师使用硬件描述语言之一，如 Verilog 或 VHDL。

# 现场可编程门阵列

与 SoCs、ASICs 和 MCUs 不同，现场可编程门阵列（FPGAs）是半导体器件，可以在制造后在硬件级别上重新编程。它们基于一组可配置逻辑块（CLBs），通过可编程互连连接。开发人员可以根据自己的需求编程互连以执行特定功能。FPGA 使用硬件定义语言（HDL）进行编程。它允许实现任何数字功能的组合，以便快速高效地处理大量数据。

# 使用有限资源

人们普遍错误地认为嵌入式系统是基于比常规台式机或服务器硬件慢得多的硬件。尽管这通常是情况，但并非总是如此。

一些特定的应用可能需要大量的计算能力或大量的内存。例如，自动驾驶需要处理来自各种传感器的大量数据，使用实时 AI 算法需要内存和 CPU 资源。另一个例子是利用大量内存和资源进行数据缓存、复制和加密的高端存储系统。

在任何情况下，嵌入式系统硬件都设计成最小化整个系统的成本。对嵌入式系统的软件工程师来说，资源是稀缺的。他们被期望利用所有可用资源，并严肃对待性能和内存优化。

# 考虑性能影响

大多数嵌入式应用都针对性能进行了优化。如前所述，目标 CPU 被选择为成本效益高，开发人员会提取其所有的计算能力。另一个因素是与外围硬件的通信。这通常需要精确和快速的反应时间。因此，对于像 Python 或 Java 这样的脚本、可解释、字节码语言，只有有限的空间。大多数嵌入式程序都是用编译成本机代码的语言编写的，主要是 C 和 C++。

为了实现最大性能，嵌入式程序利用编译器的所有性能优化能力。现代编译器在代码优化方面非常出色，以至于它们可以胜过由熟练开发人员用汇编语言编写的代码。

然而，工程师不能仅仅依赖编译器提供的性能优化。为了实现最大效率，他们必须考虑目标平台的具体情况。通常用于在 x86 平台上运行的桌面或服务器应用程序的编码实践，对于 ARM 或 MIPS 等不同架构可能是低效的。利用目标架构的特定特性通常会显著提高程序的性能。

# 与不同架构一起工作

桌面应用程序的开发人员通常很少关注硬件架构。首先，他们经常使用高级编程语言，隐藏了这些复杂性，但牺牲了一些性能。其次，在大多数情况下，他们的代码在 x86 架构上运行，并且他们经常认为其特性是理所当然的。例如，他们可能假设`int`的大小是`32`位，这在许多情况下是不正确的。

嵌入式开发人员处理更广泛的架构。即使他们不是用目标平台本地的汇编语言编写代码，他们也应该意识到所有 C 和 C++基本类型都依赖于架构；标准只保证`int`至少是`16`位。他们还应该了解特定架构的特性，如**字节序**和**对齐**，并考虑到浮点数或 64 位数字的操作，在 x86 架构上相对便宜，但在其他架构上可能更昂贵。

# 字节序

字节序定义了表示大数值的字节在内存中存储的顺序。

有两种字节序：

+   **大端**：最重要的字节被首先存储。`0x01020304` 32 位值存储在`ptr`地址如下：

| **内存中的偏移** | **值** |
| --- | --- |
| `ptr` | 0x01 |
| `ptr + 1` | 0x02 |
| `ptr + 2` | 0x03 |
| `ptr + 3` | 0x04 |

大端架构的例子包括 AVR32 和 Motorola 68000。

+   **小端**：最不重要的字节被首先存储。`0x01020304` 32 位值存储在`ptr`地址如下：

| **内存中的偏移** | **值** |
| --- | --- |
| `ptr` | 0x04 |
| `ptr + 1` | 0x03 |
| `ptr + 2` | 0x02 |
| `ptr + 3` | 0x01 |

x86 架构是小端的。

+   **双端**：硬件支持可切换的字节序。一些例子是 PowerPC、ARMv3 和前面的例子。

字节序在与其他系统交换数据时特别重要。如果开发人员按原样发送`0x01020304` 32 位整数，如果接收者的字节序与发送者的字节序不匹配，它可能被读取为`0x04030201`。这就是为什么数据应该进行**序列化**。

这段 C++代码可以用来确定系统的字节序：

```cpp
#include <iostream>
int main() {
  union {
    uint32_t i;
    uint8_t c[4];
  } data;
  data.i = 0x01020304;
  if (data.c[0] == 0x01) {
    std::cout << "Big-endian" << std::endl;
  } else {
    std::cout << "Little-endian" << std::endl;
  }
}
```

# 对齐

处理器不是按字节而是按**内存字**来读写数据——与其数据地址大小匹配的块。32 位处理器使用 32 位字，64 位处理器使用 64 位字，依此类推。

当字对齐时，读写是最有效的——数据地址是字大小的倍数。例如，对于 32 位架构，`0x00000004`地址是对齐的，而`0x00000005`是不对齐的。

编译器会自动对齐数据以实现最有效的数据访问。当涉及到结构时，对于不了解对齐的开发人员来说，结果可能会令人惊讶：

```cpp
 struct {

    uint8_t c;

    uint32_t i;

  } a = {1, 1};

  std::cout << sizeof(a) << std::endl;
```

前面的代码片段的输出是什么？`uint8_t`的大小是`1`，而`uint32_t`的大小是`4`。开发人员可能期望结构的大小是各个部分大小的总和。然而，结果高度取决于目标架构。

对于 x86，结果是`8`。让我们在`i`之前再添加一个`uint8_t`字段：

```cpp
struct {

    uint8_t c;

    uint8_t cc;

    uint32_t i;

  } a = {1, 1};

  std::cout << sizeof(a) << std::endl;
```

结果仍然是`8`！编译器通过添加填充字节根据对齐规则优化结构内数据字段的放置。这些规则是与架构相关的，对于其他架构，结果可能会有所不同。因此，结构不能在两个不同系统之间直接交换，而需要进行序列化，这将在第八章中更详细地解释，即通信和序列化。

除了 CPU，访问数据对齐对于通过硬件地址转换机制进行有效的内存映射也是至关重要的。现代操作系统使用 4 KB 内存块或页面来将进程虚拟地址空间映射到物理内存。将数据结构对齐到 4 KB 边界可以提高性能。

# 固定宽度整数类型

C 和 C++开发人员经常忘记基本数据类型（如`char`、`short`或`int`）的大小是与架构相关的。为了使代码具有可移植性，嵌入式开发人员经常使用明确指定数据字段大小的固定大小整数类型。

最常用的数据类型如下：

| **宽度** | **有符号** | **无符号** |
| --- | --- | --- |
| 8 位 | `int8_t` | `uint8_t` |
| 16 位 | `int16_t` | `uint16_t` |
| 32 位 | `int32_t` | `uint32_t` |

指针大小也取决于架构。开发人员经常需要访问数组的元素，由于数组在内部表示为指针，偏移量表示取决于指针大小。`size_t`是一种特殊的数据类型，以一种与架构无关的方式表示偏移量和数据大小。

# 处理硬件错误

嵌入式开发人员工作的重要部分是处理硬件。与大多数应用程序开发人员不同，嵌入式开发人员不能依赖硬件。硬件因不同原因而失败，嵌入式开发人员必须区分纯粹的软件故障和由硬件故障或故障引起的软件故障。

# 早期版本的硬件

嵌入式系统基于专门设计和制造用于特定用例的专用硬件。这意味着在为嵌入式系统开发软件时，其硬件尚未稳定且经过充分测试。当软件开发人员在其代码行为中遇到错误时，这并不一定意味着存在软件错误，而可能是由于不正确工作的硬件引起的。

很难对这些问题进行分类。它们需要知识、直觉，有时需要使用示波器来将问题的根本原因缩小到硬件层面。

# 硬件是不可靠的

硬件本质上是不可靠的。每个硬件组件都有失败的可能性，开发人员应该意识到硬件随时可能出现故障。由于内存故障，存储在内存中的数据可能会损坏。由于外部噪音，通过通信渠道传输的消息可能会被更改。

嵌入式开发人员已经为这些情况做好了准备。他们使用校验和或**循环冗余检查**（**CRC**）码来检测并在可能的情况下纠正损坏的数据。

# 环境条件的影响

高温、低温、高湿度、振动、灰尘和其他环境因素都会显著影响硬件的性能和可靠性。虽然开发人员设计他们的软件来处理所有潜在的硬件错误，但在不同的环境中测试系统是常见的做法。此外，了解环境条件可以在解决问题的根本原因分析时提供重要线索。

# 在嵌入式开发中使用 C++

多年来，绝大多数嵌入式项目都是使用 C 编程语言开发的。这种语言非常适合嵌入式软件开发人员的需求。它提供了功能丰富和方便的语法，但与此同时，它相对低级，并且不会向开发人员隐藏平台特定的细节。

由于其多功能性、紧凑性和编译代码的高性能，它成为了嵌入式世界中的事实标准开发语言。C 语言的编译器存在于大多数，如果不是所有的架构中；它们被优化为生成比手动编写的机器代码更有效的代码。

随着嵌入式系统的复杂性不断增加，开发人员面临 C 语言的限制，其中最显著的是容易出错的资源管理和缺乏高级抽象。在 C 中开发复杂的应用程序需要大量的工作和时间。

与此同时，C++在不断发展，获得新的功能，并采用使其成为现代嵌入式系统开发人员的最佳选择的编程技术。这些新功能和技术如下：

+   你不用为你不使用的东西付费。

+   面向对象编程来处理代码复杂性。

+   **资源获取即初始化**（**RAII**）。

+   异常。

+   强大的标准库。

+   线程和内存模型作为语言规范的一部分。

# 你不用为你不使用的东西付费

C++的座右铭之一是*你不用为你不使用的东西付费*。这种语言比 C 语言还要多很多功能，但对于那些不被使用的功能，它承诺零开销。

例如，虚函数：

```cpp
#include <iostream>

class A {

public:

  void print() {

    std::cout << "A" << std::endl;

  }

};

class B: public A {

public:

  void print() {

    std::cout << "B" << std::endl;

  }

};

int main() {

  A* obj = new B;

  obj->print();

}
```

尽管`obj`指向`B`类的对象，上面的代码将输出`A`。为了使其按预期工作，开发人员添加了一个关键字——`virtual`：

```cpp
#include <iostream>

class A {

public:

  virtual void print() {

    std::cout << "A" << std::endl;

  }

};

class B: public A {

public:

  void print() {

    std::cout << "B" << std::endl;

  }

};

int main() {

  A* obj = new B;

  obj->print();

}
```

在这个改变之后，代码输出`B`，这是大多数开发人员期望得到的结果。你可能会问为什么 C++不默认强制每个方法都是`virtual`。这种方法是 Java 采用的，似乎没有任何不利之处。

原因是`virtual`函数并不是免费的。函数解析是通过虚拟表在运行时执行的——这是一个函数指针数组。它会给函数调用时间增加一点开销。如果你不需要动态多态性，你就不用为它付费。这就是为什么 C++开发人员添加`virtual`关键字，以明确同意会增加性能开销的功能。

# 面向对象编程来处理代码复杂性

随着嵌入式程序的复杂性随着时间的推移而增长，使用 C 语言提供的传统过程化方法来管理它们变得越来越困难。如果你看一下一个大型的 C 项目，比如 Linux 内核，你会发现它采用了许多面向对象编程的方面。

Linux 内核广泛使用封装，隐藏实现细节，并使用 C 结构提供对象接口。

虽然在 C 中编写面向对象的代码是可能的，但在 C++中进行这样的操作要容易得多，也更方便，因为编译器为开发人员做了所有繁重的工作。

# 资源获取即初始化

嵌入式开发人员经常使用操作系统提供的资源：内存、文件和网络套接字。C 开发人员使用 API 函数对资源进行获取和释放；例如，使用`malloc`来申请一块内存，使用`free`将其返回给系统。如果开发人员因某种原因忘记调用`free`，这块内存就会泄漏。内存泄漏或资源泄漏通常是 C 编写的应用程序中的常见问题：

```cpp
#include <stdio.h>

#include <unistd.h>

#include <fcntl.h>

#include <string.h>

int AppendString(const char* str) {

  int fd = open("test.txt", O_CREAT|O_RDWR|O_APPEND);

 if (fd < 0) {

    printf("Can't open file\n");

    return -1;

  }

  size_t len = strlen(str);

  if (write(fd, str, len) < len) {

    printf("Can't append a string to a file\n");

    return -1;

  }

  close(fd);

  return 0;

}
```

上述代码看起来是正确的，但它包含了几个严重的问题。如果`write`函数返回错误或写入的数据少于请求的数据（这是正确的行为），`AppendString`函数会记录错误并返回。然而，如果它忘记关闭文件描述符，就会发生内存泄漏。随着时间的推移，越来越多的文件描述符泄漏，最终程序达到打开文件描述符的限制，导致*所有*对`open`函数的调用失败。

C++提供了一个强大的编程习惯，可以防止资源泄漏：**RAII**。资源在对象构造函数中分配，在对象析构函数中释放。这意味着只有在对象存活时才持有资源。当对象被销毁时，资源会自动释放：

```cpp
#include <fstream>

void AppendString(const std::string& str) {

  std::ofstream output("test.txt", std::ofstream::app);

  if (!output.is_open()){

    throw std::runtime_error("Can't open file");

  }

  output << str;

}
```

请注意，此函数不会显式调用`close`。文件在输出对象的析构函数中关闭，当`AppendString`函数返回时会自动调用该析构函数。

# 异常

传统上，C 开发人员使用错误代码来处理错误。这种方法需要程序员的大量注意力，并且是 C 程序中难以找到的错误的不断来源。很容易忽略或忽视缺少检查返回代码的情况，掩盖了错误：

```cpp
#include <stdio.h>

 #include <unistd.h>

 #include <fcntl.h>

 #include <iostream>

 #include <fstream>

 char read_last_byte(const char* filename) {

         char result = 0;

         int fd = open(filename, O_RDONLY);

         if (fd < 0) {

                printf("Can't open file\n");

                return -1;

       } 

         lseek(fd, -1, SEEK_END);

         size_t s = read(fd, &result, sizeof(result));

         if (s != sizeof(result)) {

                 printf("Can't read from file: %lu\n", s);

                 close(fd);

                 return -1;

        } 

         close(fd);

         return result;

 }
```

上述代码至少有两个与错误处理相关的问题。首先，未检查`lseek`函数调用的结果。如果`lseek`返回错误，函数将无法正确工作。第二个问题更微妙，但更重要且更难修复。`read_last_byte`函数返回`-1`表示错误，但它也是一个字节的有效值。无法区分文件的最后一个字节是`0xFF`还是函数遇到了错误。为了正确处理这种情况，函数接口应重新定义如下：

```cpp
int read_last_byte(const char* filename, char* result);
```

在发生错误的情况下，函数返回`-1`，否则返回`0`。结果存储在通过引用传递的`char`变量中。虽然这个接口是正确的，但对开发人员来说并不像原来的接口那样方便。

一个最终会随机崩溃的程序可能被认为是这类错误的最佳结果。如果它继续工作，悄悄地损坏数据或生成不正确的结果将更糟。

除此之外，实现逻辑的代码和负责错误检查的代码交织在一起。代码变得难以阅读和理解，结果更容易出错。

尽管开发人员仍然可以继续使用返回代码，但现代 C++中错误处理的推荐方式是异常。正确设计和正确使用异常显著减少了错误处理的复杂性，使代码更易读和更健壮。

使用异常编写的相同函数在 C++中看起来更加清晰：

```cpp
char read_last_byte2(const char* filename) {

         char result = 0;

         std::fstream file;

         file.exceptions (

                 std::ifstream::failbit | std::ifstream::badbit );

         file.open(filename);

         file.seekg(-1, file.end);

         file.read(&result, sizeof(result));

         return result;

 }
```

# 强大的标准库

C++带有功能丰富且强大的标准库。许多以前需要 C 开发人员使用第三方库的函数现在已经成为标准 C++库的一部分。这意味着更少的外部依赖，更稳定和可预测的行为，以及在硬件架构之间的更好可移植性。

C++标准库提供了建立在最常用的数据结构（如数组、二叉树和哈希表）之上的容器。这些容器是通用的，有效地满足了开发人员日常需求的大部分。开发人员不需要花费时间和精力创建自己的基本数据结构的实现，这通常容易出错。

容器被精心设计，以最小化对显式资源、分配或释放的需求，从而大大降低了内存或其他系统资源泄漏的可能性。

标准库还提供许多标准算法，如`find`、`sort`、`replace`、二进制搜索、集合操作和排列。这些算法可以应用于任何公开的集成器接口的容器。结合标准容器，它们帮助开发人员专注于高级抽象，并在经过充分测试的功能之上构建它们，而只需最少量的额外代码。

# 线程和内存模型作为语言规范的一部分

C++11 标准引入了一个内存模型，清楚地定义了 C++程序在多线程环境中的行为。

对于 C 语言规范，内存模型不在范围内。语言本身不知道线程或并行执行语义。这取决于第三方库，例如 pthread，提供多线程应用程序所需的所有支持。

早期版本的 C++遵循了相同的原则。多线程不在语言规范的范围内。然而，支持指令重排序的多管线现代 CPU 需要编译器更确定的行为。

因此，C++的现代规范明确定义了线程类、各种类型的锁和互斥锁、条件变量和原子变量。这为嵌入式开发人员提供了一个强大的工具包，用于设计和实现能够利用现代多核 CPU 所有功能的应用程序。由于工具包是语言规范的一部分，这些应用程序具有确定的行为，并且可移植到所有支持的架构。

# 远程部署软件

嵌入式系统的软件部署通常是一个复杂的过程，应该经过精心设计、实施和测试。有两个主要挑战：

+   嵌入式系统通常部署在人类操作员难以或不切实际访问的地方。

+   如果软件部署失败，系统可能无法运行。这将需要技术熟练的技术人员和额外的工具来进行恢复。这是昂贵的，而且通常是不可能的。

连接到互联网的嵌入式系统的第一个挑战的解决方案是**OTA**（Over-the-Air）更新。系统定期连接到专用服务器，检查是否有可用的更新。如果找到软件的更新版本，它将被下载到设备并安装到持久内存中。

这种方法被智能手机、机顶盒、智能电视和连接到互联网的游戏机制造商广泛采用。

在设计 OTA 更新时，系统架构师应考虑影响整体解决方案的许多因素。例如，如果所有设备几乎同时检查更新，会在更新服务器上创建高峰负载，同时让它们在其他时间处于空闲状态。随机化检查时间可以使负载均匀分布。目标系统应设计为保留足够的持久内存以下载完整的更新映像，然后应用它。实现更新软件映像下载的代码应处理网络连接中断，并在连接恢复后恢复下载，而不是重新开始。OTA 更新的另一个重要因素是安全性。更新过程应仅接受真实的更新映像。更新由制造商进行加密签名，只有在设备上运行的安装程序接受签名匹配的映像。

嵌入式系统的开发人员知道更新可能因不同原因而失败；例如，在更新过程中断电。即使更新成功完成，新版本的软件可能不稳定，并在启动时崩溃。预期即使在这种情况下，系统也能够恢复。

这是通过分离主要软件组件和引导加载程序来实现的。引导加载程序验证主要组件的一致性，例如包含所有可执行文件、数据和脚本的操作系统内核和根文件系统。然后，它尝试运行操作系统。在失败的情况下，它切换到先前的版本，该版本应与新版本一起保存在持久内存中。硬件看门狗定时器用于检测和防止软件更新导致系统挂起的情况。

在软件开发和测试过程中使用 OTA 或完整的镜像重新刷写是不切实际的。它会显著减慢开发过程。工程师使用其他方式将他们的软件构建部署到开发系统，例如远程外壳或允许开发人员工作站和目标板之间共享文件的网络文件系统。

# 远程运行软件

嵌入式系统旨在使用特定的硬件和软件组件组合解决特定问题。这就是为什么系统中的所有软件组件都经过定制以实现这个目标。所有非必要的东西都被禁用，所有定制软件都集成到引导序列中。

用户不启动嵌入式程序；它们在系统启动时启动。然而，在开发过程中，工程师需要在不重新启动系统的情况下运行他们的应用程序。

这取决于目标平台的类型而有所不同。对于基于 SoC 并运行像 Linux 这样的抢占式多任务操作系统的足够强大的系统，可以使用远程 shell 来实现。

现代系统通常使用**安全外壳**（**SSH**）作为远程外壳。目标系统运行一个等待传入连接的 SSH 守护程序。开发人员使用客户端 SSH 程序，如 Linux 中的 SSH 或 Windows 中的 PuTTY，连接到目标系统以访问目标系统。一旦连接，他们可以像在本地计算机上一样使用嵌入式板上的 Linux shell 进行工作。

远程运行程序的常见工作流程如下：

1.  使用交叉编译工具包在本地系统中构建可执行程序。

1.  使用`scp`工具将其复制到远程系统。

1.  使用 SSH 连接到远程系统，并从命令行运行可执行文件。

1.  使用相同的 SSH 连接，分析程序输出。

1.  当程序终止或被开发人员中断时，将其日志取回开发人员的工作站进行深入分析。

MCU 没有足够的资源来运行远程 shell。开发人员通常直接将编译后的代码上传到平台内存，并从特定的内存地址启动代码执行。

# 日志记录和诊断

日志记录和诊断是任何嵌入式项目的重要方面。

在许多情况下，使用交互式调试器是不可能或不切实际的。硬件状态可能在几毫秒内发生变化。程序在断点上停止后，开发人员没有足够的时间来分析它。收集详细的日志数据并使用工具进行分析和可视化是高性能、多线程、时间敏感的嵌入式系统的更好方法。

由于在大多数情况下资源是有限的，开发人员经常不得不做出权衡。一方面，他们需要收集尽可能多的数据来确定故障的根本原因——无论是软件还是硬件，故障发生时硬件组件的状态，以及系统处理的硬件和软件事件的准确时间。另一方面，日志可用空间有限，每次写日志都会影响整体性能。

解决方案是在设备上本地缓冲日志数据，并将其发送到远程系统进行详细分析。

这种方法对于嵌入式软件的开发效果很好。然而，部署系统的诊断需要更复杂的技术。

许多嵌入式系统脱机工作，不提供方便的内部日志访问。开发人员需要仔细设计和实施其他诊断和报告方式。如果系统没有显示器，LED 指示灯或蜂鸣器通常用于编码各种错误条件。它们足以提供有关故障类别的信息，但在大多数情况下无法提供必要的细节以确定根本原因。

嵌入式设备具有专用的诊断模式，用于测试硬件组件。在上电后，几乎任何设备或电器都会执行**上电自检**（**POST**），对硬件进行快速测试。这些测试应该快速进行，不涵盖所有测试场景。这就是为什么许多设备都有隐藏的**服务模式**，可以由开发人员或现场工程师激活，以执行更彻底的测试。

# 总结

在本章中，我们讨论了嵌入式软件的高级概述，以及它的不同之处，还了解了为什么以及如何在这个领域高效地使用 C++。
