# 前言

亲爱的读者，您好！您已经置身于朋友之中。欢迎您踏上高级技能、意外惊喜、巧妙知识和新颖编程工具的旅程。假设您是一位经验丰富的软件工程师，知道如何编写高质量的代码，并对一些构建和操作系统有所了解。您也遇到过几种计算机架构，并修复了一个或两个错误。那么以下情况如何：您是一位刚开始学习如何成为一名软件工程师的学生。您希望有一天成为一名优秀的专业人士。您希望成为别人在软件行为不可预测时寻求的专家。或者您只是出于最初的好奇心拿起这本书，还不知道能期待什么。那就太完美了！

我们挑战您回忆一下在您的实践中，至今仍无法解释发生了什么的情况。不，我们不是指超自然现象——尽管这个话题相当晦涩。我们谈论的是系统及其行为，以及我们作为专业工程师如何进行其行为。我们的代码只是告诉机器做什么的工具。所以，假设您已经记起了一个困扰您一段时间的问题——您将如何处理？如果它阻碍了您晋升的道路呢？或者当它让一个对您来说重要的客户失望时呢？或者您只是想给您的老师留下深刻印象。我们理解您！我们也在那里。

尽管如此，不要被误导。我们通过一些基本要点为您提供机会，丰富您作为工程师的方式，但我们并非拥有所有答案。我们坚信，改变您看待代码工作方式的方法将使您成为一个更加稳健的专家，无论您的专业领域是什么。您应该关心这一点，因为技术世界正在快速发展。跟上每一个创新、算法、语言、操作系统和架构是不可能的。但您可以在正确的时间提出正确的问题。您有机会了解如何进一步优化、更好地设计、验证您的环境，并激励自己彻底理解您的工作。

我们再次向您发起挑战。这次，通过我们的经验和专业知识，让我们帮助您更加自我意识和高效。有一些复杂的现实世界挑战，我们急切地想要与您分享。请记住，这需要您花费一些时间。作为朋友，我们希望您喜欢这本书，并将其中激动人心的部分与他人分享。快快……让我们出发吧！

# 本书面向的对象

本书面向希望提升在基于 Linux 和 Unix 操作系统中 C++编程知识的程序员和开发者。无论您是希望学习如何在这样的环境中使用 C++的初学者，还是希望探索适用于系统编程的最新 C++20 特性的经验丰富的程序员，您都会发现这本书很有帮助。

# 本书涵盖的内容

*第一章*, *开始使用 Linux 系统和 POSIX 标准*，向读者介绍了不同操作系统存在的理由。讨论了 Linux 的特定内容，读者接着学习基于 Unix 的操作系统编程的基础。提到了内核空间和用户空间，因为系统调用接口被彻底解释。之后，我们利用这个机会介绍 POSIX 和一些标准函数调用，以便让读者了解系统编程的好处。

*第二章*, *关于进程管理的更多学习*，扩展了前一章的学习内容，并指出如果操作系统是主要资源管理器，那么进程就是主要资源使用者。这是通过一个可能变得复杂且需要良好分析的过程来实现的。因此，本章介绍了主要进程的生命周期——其启动、运行和最终状态。还介绍了线程的本质。我们探讨了操作系统的调度算法。引入了一个示例 C++应用程序，并讨论了其`main()`函数作为入口点。此外，还介绍了启动进程的不同方法：`fork()`、`vfork()`和`exec()`。还讨论了其他基本函数，如`wait()`、`exit()`、`pthread_create()`和`pthread_join()`。

*第三章*, *文件系统导航*，展示了文件在 Linux 中作为基本资源表示的作用——无论是数据还是对 I/O 设备的访问。这种抽象允许用户以相同的方式通过相同的系统接口操作流或存储数据。我们讨论了文件系统结构——元数据和 inode。向读者展示了 C++文件系统操作的示例。我们利用这个机会介绍了管道作为进程间通信的初始工具。还提供了 C++20 的`string_view`对象。最后，我们提到了信号处理，因为它将在后续章节中需要。

*第四章*, *深入 C++对象*，引导读者了解一些核心的 C++特性，如对象的创建过程及其初始化。我们讨论了生命周期对象问题、临时对象、RVO、RAII 模式以及 C++20。我们还一起介绍了函数对象和 lambda 表达式，以及如何使用它们的详细说明。接下来，我们将更深入地探讨 lambda 表达式。最后，我们将关注一些如何在 STL 和多线程中使用 lambda 表达式的具体示例。

*第五章*，*使用 C++处理错误*，探讨了基于 Unix 操作系统的 C++编程中不同类型的错误报告，如错误代码、异常和断言。我们将讨论异常处理和异常操作的最佳实践以及未捕获异常在系统中的情况。我们将讨论异常规范以及为什么我们更喜欢`noexcept`关键字。我们将探讨使用异常时的性能影响及其背后的机制。接下来，我们将讨论如何使用`std::optional`来处理错误。最后，我们将讨论`std::uncaught_exceptions`功能提供了什么。

*第六章*，*使用 C++进行并发系统编程*，讨论了基于 Unix 的操作系统中的进程和线程的基本原理和理论。我们将探讨 C++内存模型的变化，以便原生地支持并发。我们将熟悉 C++原语，这些原语使多线程支持成为可能——线程、jthread 和任务。接下来，我们将学习如何使用 C++同步原语来同步并行代码的执行。我们还将研究 STL 在并行算法方向上提供了什么。最后，我们将学习如何编写无锁代码。

*第七章*，*进程间通信的进行*，引导读者了解 Linux 环境中的基本 IPC 机制（因为他们已经对多线程的挑战有所了解）。进程之间能够轻松地相互通信是很重要的，因此，我们快速地浏览了消息队列。它们允许在不阻塞进程的情况下交换数据。我们将花一些时间讨论同步机制——信号量和互斥量——然后继续讨论共享内存。它提供了对某些数据的快速访问，同时允许异构系统有一个数据交换的共同点。最后，套接字经常被使用，但主要是为了它们允许网络上的计算机系统之间进行通信的可能性。

*第八章*，*在 Linux 中使用时钟、定时器和信号*，介绍了基于 Unix 的操作系统中的信号和定时器。我们最初将介绍信号系统是如何工作的，以及用户如何有效地管理操作时间。我们将介绍 C++语言提供的功能来处理时钟和定时器。我们将介绍标准时间 API，`std::chrono`，预定义的时钟和时间。接下来，我们将介绍如何正确使用它们以及可以期待什么。然后，我们将关注标准提供的持续时间功能以及用户定义的时钟。最终，我们将介绍 C++20 中引入的日历和时间库。

*第九章*，*理解 C++内存模型*，探讨了 C++20 的一些新特性。它指导读者了解如何以及为什么管理动态资源的一些关键评论。接着讨论了条件变量和互斥锁的使用，以及懒初始化和缓存友好性。在讨论如何从不同的同步机制中选择方法时，介绍了 C++内存顺序。还展示了自旋锁/票选锁技术。

*第十章*，*在系统编程中使用 C++协程*，讨论了协程，这是一个在有些编程语言中已有实现但现在是 C++20 中引入的概念。它们被描述为在执行期间挂起并在稍后恢复的栈函数。本章讨论了系统编程领域中的这些确切的有价值特性。还讨论了它们的缺点，例如，在堆上保持挂起的协程状态。还展示了某些实际用法。

# 为了充分利用本书

在开始本书之前，需要熟悉 C++语言的基础和 C 语言中的 POSIX 编程。对 Linux 和 Unix 的基本知识将有所帮助，但不是必需的。

| **本书涵盖的软件** | **操作系统要求** |
| --- | --- |
| C++20 | Linux Mint 21 |
| GCC12.2 |  |
| godbolt.org |  |

如果您使用的是本书的数字版，我们建议您亲自输入代码或从本书的 GitHub 仓库（下一节中提供链接）获取代码。这样做将帮助您避免复制粘贴代码时可能出现的任何潜在错误。

每一章都有其各自的技术要求。所有示例都经过这些要求运行。代码依赖于系统，因此可能无法直接在您的环境中运行。

# 下载示例代码文件

您可以从 GitHub（[`github.com/PacktPublishing/C-Programming-for-Linux-Systems`](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems)）下载本书的示例代码文件。如果代码有更新，它将在 GitHub 仓库中更新。

我们还有其他来自我们丰富的图书和视频目录的代码包可供选择，这些代码包可在[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)找到。查看它们吧！

# 使用的约定

本书使用了多种文本约定。

`文本中的代码`：表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 账号。以下是一个示例：“该示例使用`open()`和`close()` POSIX 函数，这些函数尝试从我们的 Linux 测试环境的文件系统中打开和关闭文件。”

代码块设置如下：

```cpp
if (ecode.value() == EEXIST)
```

当我们希望您注意代码块中的特定部分时，相关的行或项目将以粗体显示：

```cpp
std::for_each(v1.begin(), v1.end(),
                  &mean, sum{0.0}, count{0}, text mutable
```

任何命令行输入或输出都按以下方式编写：

```cpp
$ ./test
```

小贴士或重要注意事项

看起来像这样。

# 联系我们

我们始终欢迎读者的反馈。

**一般反馈**：如果你对本书的任何方面有疑问，请通过电子邮件发送至 customercare@packtpub.com，并在邮件主题中提及书名。

**勘误表**：尽管我们已经尽最大努力确保内容的准确性，但错误仍然可能发生。如果你在这本书中发现了错误，我们非常感谢你向我们报告。请访问[www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)并填写表格。

**盗版**：如果你在互联网上遇到我们作品的任何形式的非法副本，我们非常感谢你提供位置地址或网站名称。请通过 copyright@packt.com 与我们联系，并提供材料的链接。

**如果你有兴趣成为作者**：如果你在某个领域有专业知识，并且你感兴趣的是撰写或为本书做出贡献，请访问[authors.packtpub.com](http://authors.packtpub.com)。

# 分享你的想法

一旦你阅读了《Linux 系统编程的 C++编程》，我们很乐意听到你的想法！请[点击此处直接转到该书的亚马逊评论页面](https://packt.link/r/1805129007)并分享你的反馈。

你的评论对我们和科技社区非常重要，并将帮助我们确保我们提供高质量的内容。

# 下载本书的免费 PDF 副本

感谢你购买本书！

你喜欢在旅途中阅读，但无法携带你的印刷书籍到处走吗？

你的电子书购买是否与你的选择设备不兼容？

别担心，现在，随着每本 Packt 书籍，你都可以免费获得该书的 DRM 免费 PDF 版本。

在任何地方、任何时间、任何设备上阅读。直接从你最喜欢的技术书籍中搜索、复制和粘贴代码到你的应用程序中。

优惠远不止这些，你还可以获得独家折扣、时事通讯和每日免费内容的每日电子邮件。

按照以下简单步骤获取优惠：

1.  扫描下面的二维码或访问以下链接

![](img/B20833_QR_Free_PDF.jpg)

[`packt.link/free-ebook/9781805129004`](https://packt.link/free-ebook/9781805129004)

1.  提交你的购买证明

1.  就这些！我们将直接将你的免费 PDF 和其他优惠发送到你的电子邮件中

# 第一部分：巩固基础

本书的这一部分将为你提供进入系统编程高级主题所需的基本工具。经验丰富的读者也会发现这部分内容很有帮助，因为 C++20 的一些特性在系统编程领域得到了实际的应用。本部分确保读者与所讨论的主题保持一致，并提供从技术示例中提取最佳内容的机会。同时，它还注意到了 Linux 系统开发的重要方面。

本部分包含以下章节：

+   *第一章**，从 Linux 系统和 POSIX 标准开始学习*

+   *第二章**，学习更多关于进程管理*

+   *第三章**，在文件系统中导航*

+   *第四章**，深入探索 C++对象*

+   *第五章**，使用 C++处理错误*
