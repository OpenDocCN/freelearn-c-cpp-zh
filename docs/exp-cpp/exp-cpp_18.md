# 第十八章：在机器学习任务中使用 C++

人工智能（AI）和机器学习（ML）最近变得越来越受欢迎。从简单的食品送货网站到复杂的工业机器人，AI 已被宣称为支持软件和硬件的主要特性之一。虽然大多数时候这些术语被用来使产品看起来更严肃，但一些公司正在密集地研究并将 AI 纳入其系统中。

在我们继续之前，请考虑到这一章是从 C++程序员的角度对机器学习进行温和介绍。对于更全面的文献，请参考本章末尾的书籍列表。在本章中，我们将介绍人工智能和机器学习的概念。虽然最好有数学背景，但在本章中我们几乎不使用任何数学。如果你打算扩展你的技能并深入机器学习，你必须先考虑学习数学。

除了介绍概念，本章还提供了机器学习任务的示例。我们将实施它们，并给你一个如何研究和解决更复杂任务的基本思路。

我们将在本章中涵盖以下主题：

+   人工智能和机器学习的介绍

+   机器学习的类别和应用

+   为计算设计一个 C++类

+   神经网络结构和实现

+   回归分析和聚类

# 技术要求

在本章中，使用 g++编译器和`-std=c++2a`选项来编译示例。你可以在[`github.com/PacktPublishing/Expert-CPP`](https://github.com/PacktPublishing/Expert-CPP)找到本章中使用的源文件。

# 人工智能的介绍

人工智能的最简单定义是机器表现得像人类一样。这是机器所展示的智能。接下来讨论智能的定义。我们如何为机器定义智能，以及在什么程度上我们应该大声宣布我们正在处理一个智能机器？

如果你不熟悉用不同的测试来验证机器智能的方法，其中一种流行的方法是图灵测试。其思想是让一个询问者向两个人提问，其中一个是机器，另一个是人类。如果询问者无法清楚区分这两者，那么这台机器就应该被认为是智能的。

图灵测试是以艾伦·图灵命名的。这项测试是在他 1950 年的论文《计算机器和智能》中提出的。他建议使用模拟游戏来确定机器是否像人类一样思考。

被询问的人在墙后，以便询问者看不见他们。然后询问者向两个参与者提出几个问题。以下图表演示了询问者如何与人类和机器进行交流，但无法亲自看到他们：

![](img/34dd7f9a-7753-4539-9a3a-526fa0f79ee3.png)

当你开始深入研究人工智能领域时，智能的定义变得越来越模糊。可以以任何形式向机器提问：文字、音频、视觉等等。有许多东西可能永远不会出现在机器中，比如他们的表情。有时人们通过对方的表情来理解彼此的情绪。你无法确定机器是否会理解，甚至能够模仿他们脸上的情绪。没有人教我们在生气时看起来生气。没有人教我们有情感。它们就在那里。很难说有一天，类似的事情是否会被机器实现。

谈到人工智能时，我们大多数时候认为它是关于一个与人类类似的说话和行为的机器人。但当你试图将其作为程序员进行分解时，你会遇到许多子领域，每个子领域都需要花费大量时间来理解。许多领域有许多正在进行的任务或处于早期研究阶段。以下是一些你可能有兴趣在职业生涯中专注的人工智能子领域：

+   **计算机视觉**：设计用于视觉对象识别和通过分析它们的视觉表示来理解对象的算法。人类很容易在人群中发现熟悉的面孔，但为机器实现类似的功能可能需要很长时间才能达到与人类相同的准确性。

+   **自然语言处理**（**NLP**）：机器对文本进行语言分析。它在各个领域都有应用，比如机器翻译。想象一下，计算机完全理解人类书面文本，这样我们就可以告诉它该做什么，而不是花几个月学习编程语言。

+   **知识推理**：这似乎是机器表现智能的明显目标。知识推理涉及让机器根据它们所拥有的信息进行推理并提供解决方案；例如，通过检查医疗状况来提供诊断。

+   **机器学习**：机器用于执行任务的算法和统计模型的研究领域。机器学习算法不依赖于直接指令，而是依赖于模式和推理。也就是说，机器学习允许机器自行完成工作，无需人类参与。

让我们分别讨论前面的子领域，然后集中讨论机器学习。

# 计算机视觉

计算机视觉是一个广泛的研究领域，有许多正在进行的研究项目。它涉及几乎与视觉数据处理相关的一切。它在各个领域都有广泛的应用；例如，人脸识别软件处理来自城市各处摄像头的数据，以查找和确定犯罪嫌疑人，或者光学字符识别软件从包含文本的图像中生成文本。结合一些**增强现实**（**AR**）技术，软件能够将图像中的文本翻译成用户熟悉的语言。

这一领域的研究正在日益取得进展。结合人工智能系统，计算机视觉是使机器感知世界的领域。对我们来说是简单的任务，但在计算机视觉方面实现起来是具有挑战性的。例如，当我们在图像中看到一个物体时，我们很容易看出它的尺寸。例如，以下图像代表了一辆自行车的前视图：

![](img/1e417264-3431-4087-a127-a74603e541bf.png)

即使我们不提到它是一辆自行车，人类也不难确定它。对我们来说，图像底部中央的黑色粗线是自行车的前轮是显而易见的。很难告诉计算机理解它是一个车轮。计算机所看到的只是一堆像素，其中一些颜色相同：

![](img/1f146977-eca9-4201-8f08-c4874284568e.png)

除了理解自行车的车轮，它还应该推断这辆自行车必须有另一辆在图像中看不见的车轮。而且，我们可能对自行车的大致尺寸有一个猜测，而对于计算机来说，从图像中确定它是一个全面的任务。也就是说，我们视角中的简单事物可能在计算机视觉中成为一个真正的挑战。

我们建议在计算机视觉任务中使用 OpenCV 库。这是一个用 C 和 C++编写的跨平台库。OpenCV 代表了一组旨在实时计算机视觉的功能，包括但不限于人脸识别、手势识别、动作理解、运动跟踪和其他功能。

计算机视觉中的典型任务包括对象识别、识别和检测。对象识别是理解对象是前一图像中的车辆。识别是识别对象的个别实例，例如前一图像中自行车的车轮。对象检测任务可能包括在自行车图像中找到损坏的区域。所有这些任务结合机器学习算法可能构成一个全面的软件，它能够以接近人类方式理解周围环境。

# NLP

另一个有趣的研究领域是自然语言处理。自然语言处理致力于使计算机理解人类语言。更一般化的方法是自动语音识别和自然语言理解；这是虚拟助手的关键特性。今天，和手机交谈并要求它在网络上搜索某些内容已经不再是魔术。整个过程都由语音和文本分析中的复杂算法驱动。以下图表显示了发生在对话代理背后的高层视图：

![](img/2afbe1d3-4236-437b-8728-a7a864c33172.png)

许多语言处理任务与网络相关。搜索引擎处理用户输入以在网络上数百万文档中搜索是自然语言处理的顶级应用之一。在下一章中，我们将深入探讨搜索引擎的设计和实现。搜索引擎设计的主要关注点之一是处理文本数据。搜索引擎不能只存储所有网站并对用户的查询返回第一个匹配项。自然语言处理中有许多复杂的任务。假设我们正在设计一个程序，该程序接收文本文档并应输出文档中的句子。识别句子的开始和结束是其中的一个复杂任务。以下句子是一个简单的例子：

```cpp
I love studying C++. It's hard, but interesting. 
```

程序将输出两个句子：

```cpp
I love studying C++.
It's hard, but interesting.
```

在编码任务方面，我们只需搜索句子末尾的 .（句号）字符，并确保第一个单词以大写字母开头。如果其中一句话的形式如下，程序会如何行为？

```cpp
I love studying C++!
```

由于句子末尾有感叹号，我们应该重新审视我们的程序，添加另一个规则来识别句子的结束。如果一句话是这样结束的呢？

```cpp
It's hard, but interesting...
```

逐一引入更多规则和定义，以实现一个完全功能的句子提取器。在解决自然语言处理任务时，利用机器学习将我们引向更智能的方向。

另一个与语言相关的任务是机器翻译，它可以自动将一种语言的文档翻译成另一种语言。此外，需要注意的是，构建一个全面的自然语言处理系统将有益于其他研究领域，比如知识推理。

# 知识推理

知识推理是使计算机以类似于人类的方式思考和推理。想象一下和机器进行对话，开始如下：

```cpp
[Human] Hello
[Machine] Hello
```

我们可以编程让机器回答特定问题或理解用户输入的复杂文本，但要让机器基于以前的经验进行推理就要困难得多。例如，以下推理是研究的目标之一：

```cpp
[Human] I was walking yesterday and it was raining.
[Machine] Nice.
[Human] I should dress warmer next time.
[Machine] OK.
[Human] I think I have a temperature.
[Machine] Did you caught a cold yesterday?
[Human] I guess so.
```

虽然似乎很容易发现感冒和雨之间的联系，但让程序推断这一点需要付出很大的努力。它必须将雨与感冒联系起来，并将有温度与感冒联系起来。它还应该记住先前的输入，以便在智能地保持对话中使用它。

前面提到的所有研究领域对于程序员来说都是令人兴奋的深入领域。最后，机器学习通常是设计算法和模型的基础，用于每个特定应用领域。

# 机器学习

机器学习使我们达到了一个全新的水平，让机器执行任务的方式与人类一样，甚至可能更好。与我们之前介绍的领域相比，机器学习的目标是构建能够在没有具体指令的情况下执行任务的系统。在发明人工智能机器的过程中，我们应该更加关注人类智慧。当一个孩子出生时，并不表现出智能行为，而是开始慢慢熟悉周围的世界。没有记录表明一个月大的婴儿解决微分方程或创作音乐。就像孩子学习和发现世界一样，机器学习关注的是构建直接执行任务的基础模型，而不是直接执行任务，而是学会如何执行任务。这是设置系统执行预定义指令和让系统自行解决问题之间的根本区别。

当一个孩子开始行走、拿东西、说话和提问时，他们正在逐步获取关于世界的知识。他或她拿起一本书，尝试它的味道，不久之后就不再把书当作食物来咀嚼。几年过去了，孩子现在打开书的页面，寻找其中的图像和构成文本的小图形。再过几年，孩子开始阅读它们。多年过去了，大脑变得越来越复杂，它的神经元之间建立了越来越多的连接。孩子变成了一个聪明的人类。

想象一下一个系统，其中有一些神奇的算法和模型。在输入了大量数据之后，它将能够越来越理解，就像孩子通过处理视觉数据（通过他们的眼睛观察）、气味或味道的输入数据来了解世界一样。后来，通过提出问题的方式，孩子开始理解单词，并将这些单词与现实世界中的对象，甚至是无形的概念联系起来。机器学习系统几乎以相同的方式行事。它们处理输入数据并产生一些输出，符合我们期望的结果。下图说明了这个想法：

![](img/e1574aeb-59e5-4890-a1cb-0c31e04315f3.png)

现在让我们深入了解机器学习。和往常一样，理解新事物的最好方法是先尝试实现它。

# 理解机器学习

机器学习是一个庞大的研究领域，正在快速扩展。要理解机器学习，我们首先应该了解学习的本质。思考和推理是使我们——人类——特殊的关键概念。机器学习的核心是使系统学习并利用知识来执行任务。你可能还记得学习编程的第一步。我们相信那并不容易。你必须学习新概念，构建抽象，并让你的大脑理解程序执行的底层原理。之后，你需要使用那些在入门指南中描述的关键字、指令、条件语句、函数、类等小构件来构建复杂系统。

然而，机器学习程序与我们通常创建的程序不同。看一下下面的代码：

```cpp
int calculate()
{
  int a{14};
  int b{27};
  int c{a + b};
  return c;
}
```

简单的前述程序按照我们的指示执行。它包含了几个简单的指令，导致变量`c`表示`a`和`b`的和。我们可以修改函数以接受用户输入，如下所示：

```cpp
int calculate(int a, int b)
{
  int c{a + b};
  return c;
}
```

前述函数永远不会获得任何智能。无论我们调用`calculate()`函数多少次都无所谓。无论我们提供什么数字作为输入都无所谓。该函数代表了一系列指令。我们甚至可以说是一系列硬编码的指令。也就是说，该函数永远不会修改自己的指令以根据输入的不同行为。然而，我们可以引入一些逻辑；比如说，我们让它在收到负数时每次返回 0：

```cpp
int calculate(int a, int b)
{
  if (a < 0 && b < 0) {
    return 0;
  }
  int c{a + b};
  return c;
}
```

条件语句引入了函数基于其输入所做决定的最简单形式。我们可以添加更多的条件语句，使函数增长并具有复杂的实现。然而，无论添加多少条件语句，它都不会变得更聪明，因为它不是代码自己想出来的。这就是我们在处理程序时所面临的限制。它们不会思考；它们会按照我们编程的方式行事。我们决定它们必须如何行事。它们总是服从。嗯，只要我们没有引入错误。

现在，想象一下 ML 算法在行动。假设`calculate()`函数中有一些魔法，以便它根据输入返回一个值。假设它具有以下形式：

```cpp
int calculate(int a, int b)
{
  // some magic
  // return value 
}
```

现在，假设我们正在调用`calculate()`并将`2`和`4`作为参数传递，希望它将计算它们的总和并返回`6`。此外，想象一下，我们可以以某种方式告诉它结果是否符合我们的预期。过了一会儿，函数以一种方式行事，以便它了解如何使用这些输入值并返回它们的总和。我们正在构建的以下类代表了我们对理解 ML 的第一步。

# 设计一个学习的算法

以下类代表一个计算机。它包括四种算术运算，并期望我们提供如何计算输入值的示例：

```cpp
struct Example
{
  int input1;
  int input 2;
  int output;
};

class CalculationMachine
{
public:
  using Examples = std::vector<Example>;
  // pass calculation examples through the setExamples()
 void setExamples(const Examples& examples);

  // the main function of interest
  // returns the result of the calculation
 int calculate(int a, int b);

private:
  // this function pointer will point to 
  // one of the arithmetic functions below
 int (*fptr_)(int, int) = nullptr;

private:
  // set of arithmetic functions
  static int sum(int, int);
  static int subtract(int, int);
  static int multiply(int, int);
  static int divide(int, int);
};
```

在使用`calculate()`函数之前，我们应该为`setExamples()`函数提供一个示例列表。以下是我们提供给`CalculationMachine`的示例的示例：

```cpp
3 4 7
2 2 4
5 5 10
4 5 9
```

每行中的前两个数字代表输入参数；第三个数字是操作的结果。`setExamples()`函数是`CalculationMachine`学习如何使用正确的算术函数。我们可以从前面的例子中猜出正在发生的事情，同样`CalculationMachine`试图找到最适合其操作的方法。它通过示例并定义在调用`calculate()`时应该使用哪个函数。实现方式类似于以下内容：

```cpp
void CalculationMachine::setExamples(const Examples& examples)
{
  int sum_count{0};
  int sub_count{0};
  int mul_count{0};
  int div_count{0};
  for (const auto& example : Examples) {
 if (CalculationMachine.sum(example.input1, example.input2) == example.output) {
 ++sum_count;
 }
 if (CalculationMachine.subtract(example.input1, example.input2) == example.output) {
 ++sub_count;
 }
    // the same for multiply() and divide()
  }

  // the function that has the maximum number of correct output results
  // becomes the main function for called by calculate()
  // fptr_ is assigned the winner arithmetic function
}
```

从前面的例子中可以看出，该函数调用所有算术函数并将它们的返回值与示例输出进行比较。每次结果正确时，它会增加特定函数的正确答案计数。最后，具有最多正确答案的函数被分配给`fptr_`，该函数由`calculate()`函数使用如下：

```cpp
int CalculationMachine::calculate(int a, int b)
{
  // fptr_ points to the sum() function
 return fptr_(a, b);
}
```

我们设计了一个简单的学习算法。`setExamples()`函数可以被重命名为`setDataSet()`或`trainWithExamples()`或类似的名称。`CalculationMachine`的例子的重点在于我们定义了一个模型和算法来处理它，并且我们可以称之为 ML。它从数据中学习。或者，更好的是，它从经验中学习。我们提供给`CalculationMachine`的示例向量中的每个记录都可以被视为一种经验。我们说计算的性能随着经验的增加而提高。也就是说，我们提供的示例越多，它在选择正确的函数执行任务时就越有信心。而任务就是根据两个输入参数计算值。学习过程本身不是任务。学习是导致执行任务的原因。任务通常被描述为系统应该如何处理一个示例，其中一个示例是一组特征。尽管在 ML 术语中，一个示例被表示为一个向量（数学），其中每个条目都是另一个特征，但向量数据结构的选择只是一个巧合。作为系统训练的基本原则之一，ML 算法可以被分类为监督或无监督。让我们检查它们的区别，然后建立 ML 系统的各种应用。

# ML 的分类

以下图表说明了 ML 的分类：

![](img/57c4aa6a-343d-43e9-8060-f24d62dee7b3.png)

ML 算法的分类取决于它们在学习过程中的经验类型。我们通常称示例的集合为*数据集*。有些书籍也使用术语*数据点*。数据集基本上是代表对目标系统有用的任何数据的集合。它可能包括一段时间内的天气测量，某家公司或多家公司的股票价格列表，或任何其他数据集。虽然数据集可能是未经处理的或所谓的原始数据，但也有数据集包含每个经验的附加信息。在`CalculationMachine`的示例中，我们使用了一个原始数据集，尽管我们已经编程系统识别前两个值是操作的操作数，第三个值是其结果。如前所述，我们将 ML 算法分类为监督和无监督。

监督学习算法从带标签的数据集中学习；也就是说，每条记录都包含描述数据的附加信息。`CalulcationMachine`是监督学习算法的一个例子。监督学习也被称为**带教练训练**。教练使用数据集来教授系统。 

监督学习算法将能够在从提供的经验中学习后标记新的未知数据。下图最好描述了它：

![](img/3c11cb39-8e0b-48ed-af2b-e498f0345c35.png)

监督学习算法的一个应用示例是电子邮件应用中的垃圾邮件过滤器。用户将电子邮件标记为垃圾邮件或非垃圾邮件，然后系统试图在新收到的电子邮件中找到模式以检测潜在的垃圾邮件。

`CalculationMachine`的示例是监督学习的另一个案例。我们用以下数据集来喂它：

```cpp
3 4 7
2 2 4
5 5 10
4 5 9
```

我们编程`CalculationMachine`以读取前两个数字作为输入参数，第三个数字作为应用于输入的函数产生的输出。这样，我们提供了关于系统应该得到什么结果的必要信息。

无监督学习算法更加复杂——它们处理包含大量特征的数据集，然后试图找到特征的有用属性。无监督学习算法大多是独立定义数据集中的内容。就智能而言，无监督学习方法更符合智能生物的描述，而不是监督学习算法。相比之下，监督学习算法试图预测哪些输入值映射到输出值，而无监督算法执行多个操作来发现数据集中的模式。根据前面图表中的关联，下图描述了一个无监督学习算法：

![](img/3957f1b0-47f6-4f5f-9fd7-d789c436e981.png)

无监督学习算法的应用示例包括推荐系统。我们将在下一章中讨论一个例子，设计一个网络搜索引擎。推荐系统分析用户活动以推荐类似的数据，例如电影推荐。

从前面的插图中可以看出，还有*强化学习*。这是一类从错误中学习的算法。学习系统和其经验之间存在反馈循环，因此强化学习算法与环境进行交互。它可能在开始时犯很多错误，经过处理反馈后，纠正自身以改进算法。学习过程成为任务执行的一部分。想象一下，`CalculationMachine`只接收输入数字而不是计算结果。对于每个经验，它将通过应用算术运算之一产生结果，然后接收反馈。假设它减去数字，然后根据反馈修改自身以计算总和。

# ML 的应用

了解机器学习的分类有助于更好地将其应用于各种任务。有许多任务可以通过机器学习来解决。我们已经提到*分类*是机器学习算法解决的任务之一。基本上，分类是过滤和排序输入以指定输入所属的类别的过程。用机器学习解决分类通常意味着它产生一个将输入映射到特定输出的函数。输出类别的概率分布也是一种分类任务。分类任务的最佳示例之一是对象识别。输入是一组像素值（换句话说，是一幅图像），输出是标识图像中物体的值。想象一下一个能够识别不同种类的工具并在命令下将它们交给工人的机器人；也就是说，一个在车库里工作的机械师有一个能够识别螺丝刀并在命令下将其带来的助手机器人。

更具挑战性的是具有缺失输入的分类。在前面的例子中，这类似于要求机器人带来螺丝钉的东西。当一些输入缺失时，学习算法必须使用多个函数来实现成功的结果。例如，助手机器人可能首先带来钳子，然后找到螺丝刀作为正确的解决方案。

与分类类似的是*回归*，在这种情况下，系统被要求根据提供的一些输入来预测一个数值。不同之处在于输出的格式。回归任务的一个例子是预测股票未来价格。这些以及其他机器学习的应用使其迅速成为一个研究领域。学习算法不仅仅是一系列条件语句，尽管一开始可能感觉是这样。它们是基于更全面的构造，模仿人脑神经元及其连接而建模的。这将我们带到下一节，即**人工神经网络**（**ANNs**）的研究。

# 神经网络

神经网络被设计用于识别模式。它们是模仿人脑的；更具体地说，我们谈论的是大脑神经元及其人工对应物——人工神经元。人类大脑中的神经元在下图中有所说明：

![](img/2ae9ed94-046b-41d3-b973-d49240e60d96.png)

神经元通过*突触*与其他神经元进行通信。神经元的基本功能是处理部分数据并根据该数据产生信号。在编程术语中，神经元接受一组输入并产生输出。

这就是为什么下面的图表清楚地说明了为什么人工神经元类似于人脑神经元结构：

![](img/c5ab77e8-d399-4ea8-8266-87af81434f8b.png)

ANN 是自然神经网络的一个简化模型。它代表了一组相互连接的节点，每个节点代表一个神经元模型。每个节点连接可以传输类似于生物大脑神经元中突触的信号。神经网络是一组帮助进行聚类和分类的算法。正如您从前面的图表中看到的，神经网络由三层组成：

+   输入层

+   隐藏层

+   输出层

输入层和输出层不言自明；初始输入是外部数据，例如图像、音频或文本文件。输出是任务的完成，例如对文本内容的分类或图像中识别的对象。隐藏层是使网络产生合理结果的关键。输入到输出的转换经过隐藏层，隐藏层进行了必要的分析、处理和修改以产生输出。

考虑前面的图表；它显示一个神经元可以有多个输入和输出连接。通常，每个连接都有一个权重，指定连接的重要性。前面图表中的分层告诉我们，每一层的神经元都连接到紧邻的前一层和后一层的神经元。您应该注意，输入和输出层之间可能有几个隐藏层。虽然输入和输出层的主要目的是读取外部数据并返回计算（或推断）的输出，但隐藏层的目的是通过学习来适应。学习还涉及调整连接和权重，以提高输出的准确性。这就是机器学习发挥作用的地方。因此，如果我们创建一个复杂的神经网络，其中包含几个隐藏层，准备学习和改进，我们就得到了一个人工智能系统。例如，让我们先来研究聚类问题，然后再进行回归分析。

# 聚类

聚类涉及将一组对象分组以将它们分布在相似对象的组中。也称为**聚类分析**，它是一组旨在将相似对象分组在一起的技术和算法。最简单的说明是将一组有颜色的对象分成不同的组，每组由相同颜色的对象组成，如下所示：

![](img/3ef57b1e-05f2-4d19-a942-b7d6b85c8d95.png)

虽然我们在本章讨论 AI 任务，但我们建议您首先尝试用到目前为止所掌握的知识库来解决问题。也就是说，让我们想一想如何通过相似性对对象进行分类。首先，我们应该对对象的外观有一个基本的概念。在前面的例子中，一个对象的表示可能是这样的：`形状`，`颜色`，尺寸（2D 对象的`宽度`和`高度`），等等。不深入探讨，基本对象表示可能是这样的：

```cpp
struct Object
{
  int color;
  int shape;
  int width;
  int height;
};
```

让我们考虑颜色和形状的值在一定范围内的事实。我们可以使用枚举来提高可读性。聚类分析涉及分析对象以某种方式对其进行分类。首先想到的是有一个接受对象列表的函数。让我们试着定义一个：

```cpp
using objects_list = std::vector<Object>;
using categorized_table = std::unordered_map<int, objects_list>;
categorized_table clusterize(const objects_list& objects)
{
  // categorization logic 
}
```

想一想实现细节。我们需要定义聚类点。它可能是颜色，也可能是形状的类型。具有挑战性的是，它可能是未知的。也就是说，为了以防万一，我们对每个属性的对象进行分类如下：

```cpp
categorized_table clusterize(const objects_list& objects)
{
  categorized_table result;
  for (const auto& obj : objects) {
    result[obj.color].push_back(obj);
    result[obj.shape].push_back(obj);
  }
  return result;
}
```

具有相似颜色或形状的对象被分组在一个哈希表中。虽然前面的代码相当简单，但它包含了按某种相似性标准对对象进行分组的基本思想。在前面的例子中，我们更可能将其描述为硬聚类。一个对象要么属于一个簇，要么不属于。相反，软聚类（也称为模糊聚类）描述了对象对某个簇的归属程度。

例如，形状属性的对象相似性可以由应用于对象的函数的结果来定义。也就是说，如果对象 A 的形状是正方形，对象 B 的形状是菱形，那么函数定义了对象 A 和对象 B 是否具有相似的形状。这意味着我们应该更新前面例子中的逻辑，以便根据几个值来比较对象并定义它们的形状为一组。通过进一步发展这个想法，我们迟早会到达不同的聚类策略和算法，比如 K 均值聚类。

# 回归分析

回归分析涉及找出一个值对另一个值的偏差。理解回归分析的最简单方法是通过数学函数的图表。您可能还记得函数 f(x) = y 的图表：

![](img/378390fd-c0b2-4a73-86ea-cc2108a8afa0.png)

对于每个`x`的值，函数都会得出一个固定的`y`值。回归分析与前面的图表有些相似，因为它涉及查找变量之间的关系。更具体地说，它估计因变量和几个自变量之间的关系。因变量也被称为**结果**，而自变量也被称为**特征**。特征的数量可能是一个。

最常见的回归分析形式是线性回归。它看起来与前面的图表相似。以下是一个例子，表示测试程序所花费的时间与发布版本中发现的错误数量之间的关系：

![](img/85954804-fb7b-4621-8295-dd72845621b6.png)

有两种类型的回归：负回归是前面图表中显示的一种，因为自变量的值减少而因变量增加。相反，正回归具有自变量增加的值。

机器学习中的回归分析被用作一种预测的方式。你可能会开发一个程序，根据自变量的数值来预测结果。正如你到目前为止已经猜到的那样，机器学习是一个涵盖广泛主题的大领域。尽管程序员倾向于尽可能少地使用数学，但在机器学习中却是不可能的。你仍然需要掌握一些数学知识，以充分利用机器学习。回归分析在很大程度上依赖于数学统计。

# C++和机器学习

现在已经不再是秘密，机器学习更多地涉及数学而不是编程。计算机科学的根源在数学中，在早期，计算机科学家首先是数学家。你可能熟悉一些杰出的科学家，包括艾伦·图灵、约翰·冯·诺伊曼、克劳德·香农、诺伯特·维纳、尼古劳斯·维尔特、唐纳德·克努斯等。他们都是数学家，对技术有着特殊的热爱。在其发展过程中，计算机编程成为了一个更加友好的领域，对新手更加友好。在过去的二三十年里，计算机程序员不再被迫在开发有用的程序之前学习数学。编程语言演变成了越来越高级的工具，几乎每个人都可以编写代码。

有很多框架可以让程序员的工作更轻松。现在只需要几周的时间就可以掌握一些框架或高级编程语言，并创建一个新的程序。然而，程序往往会重复自己。现在构建一些东西并不那么困难，因为有很多模式和最佳实践可以帮助我们。数学的作用已经被推到了后台，越来越多的人成为程序员，甚至根本不需要使用数学。这实际上并不是一个问题；这更像是技术发展的自然流动。最终，技术的目标是让人类生活更加舒适。工程师也是如此。然而，在 20 世纪 60 年代，NASA 的工程师使用计算机进行计算，但那时的计算机并非我们今天所知的计算机。那些都是真正的人类，拥有一种特殊的专业称为“计算机”，尽管成为计算机意味着在数学上非常出色，比其他人更快地解决方程。

现在我们是计算机科学的新时代的一部分，数学再次回归。机器学习工程师现在使用数学的方式，就像数学家在 20 世纪 70 年代或 80 年代使用编程语言一样。现在仅仅知道一种编程语言或一个框架已经不够了，要设计一个新的算法或将机器学习应用到你的应用程序中，你还应该至少在一些数学子领域表现出色，比如线性代数、统计学和概率论。

几乎相同的逻辑也适用于 C++。现代语言提供了广泛的功能，而 C++开发人员仍在努力设计具有手动内存管理的无缺陷程序。如果您对 ML 领域进行一些快速研究，您会发现大多数库或示例都在使用 Python。起初，这可能被视为在 ML 任务中使用的默认语言。然而，ML 工程师开始触及一个新的进化阈值——性能。这个阈值并不新鲜；许多工具仍在需要性能的部分使用 C++。游戏开发、操作系统、关键任务系统以及许多其他基本领域都在使用 C++（和 C）作为*事实*标准。现在是 C++征服新领域的时候了。我们对读者的最好建议是学习 ML 和 C++，因为将 C++纳入其中对于 ML 工程师来说慢慢变得至关重要，以获得最佳性能。

# 总结

我们介绍了 ML 及其类别和应用。这是一个快速增长的研究领域，在构建智能系统方面有着众多应用。我们将 ML 分类为监督、无监督和强化学习算法。每个类别都在解决分类、聚类、回归和机器翻译等任务中有应用。

我们实现了一个简单的学习算法，它根据提供的经验定义了一个计算函数。我们称之为我们用来训练系统的数据集。使用数据集（称为**经验**）进行训练是 ML 系统中的关键属性之一。

最后，我们介绍并讨论了应用于识别模式的人工神经网络。ML 和神经网络在解决任务时息息相关。本章为您提供了领域的必要介绍以及几个任务的示例，以便您花一些时间深入了解该主题。这将帮助您对 AI 和 ML 有一个大致的了解，因为在实际应用开发中，对工程师来说这变得越来越必要。在下一章中，我们将学习如何实现基于对话的搜索引擎。

# 问题

1.  什么是 ML？

1.  监督学习和无监督学习算法之间有什么区别？

1.  给出一些 ML 应用的例子。

1.  你会如何修改`CalculationMachine`类以在用不同的经验集训练后改变其行为？

1.  神经网络的目的是什么？

# 进一步阅读

+   *人工智能和机器学习基础*，网址为[`www.packtpub.com/big-data-and-business-intelligence/artificial-intelligence-and-machine-learning-fundamentals`](https://www.packtpub.com/big-data-and-business-intelligence/artificial-intelligence-and-machine-learning-fundamentals)

+   *机器学习基础*，网址为[`www.packtpub.com/big-data-and-business-intelligence/machine-learning-fundamentals`](https://www.packtpub.com/big-data-and-business-intelligence/machine-learning-fundamentals)

+   *算法交易的实践机器学习*，网址为[`www.packtpub.com/big-data-and-business-intelligence/hands-machine-learning-algorithmic-trading`](https://www.packtpub.com/big-data-and-business-intelligence/hands-machine-learning-algorithmic-trading)
