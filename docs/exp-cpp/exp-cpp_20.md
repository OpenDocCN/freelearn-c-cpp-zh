# 评估

# 第一章

1.  从源代码生成可执行文件的过程称为编译。编译 C++程序是一系列复杂的任务，最终产生机器代码。通常，C++编译器解析和分析源代码，生成中间代码，对其进行优化，最后生成一个名为对象文件的机器代码文件。另一方面，解释器不会产生机器代码。相反，它逐行执行源代码中的指令。

1.  首先是预处理，然后编译器通过解析代码、执行语法和语义分析来编译代码，然后生成中间代码。在优化生成的中间代码之后，编译器生成最终的对象文件（包含机器代码），然后可以与其他对象文件链接。

1.  预处理器旨在处理源文件，使其准备好进行编译。预处理器使用预处理指令，如`#define`和`#include`。指令不代表程序语句，而是预处理器的命令，告诉它如何处理源文件的文本。编译器无法识别这些指令，因此每当您在代码中使用预处理指令时，预处理器会在实际编译代码之前相应地解析它们。 

1.  编译器为每个编译单元输出一个对象文件。链接器的任务是将这些对象文件合并成一个单一的对象文件。

1.  库可以链接到可执行文件中，可以是静态库也可以是动态库。当将它们作为静态库链接时，它们将成为最终可执行文件的一部分。动态链接库也应该被操作系统加载到内存中，以便为您的程序提供调用其函数的能力。

# 第二章

1.  通常，`main()`函数有两个参数，`argc`和`argv`，其中`argc`是程序的输入参数数量，`argv`包含这些输入参数。很少见的是，您可能会看到一个广泛支持但未标准化的第三个参数，最常见的名称是`envp`。`envp`的类型是 char 指针数组，它保存系统的环境变量。

1.  `constexpr`说明符声明函数的值可以在编译时求值。相同的定义也适用于变量。名称由`const`和表达式组成。

1.  递归导致为函数调用分配额外的空间。与迭代解决方案相比，为函数分配空间和调用的成本很高。

1.  栈保存具有自动存储期的对象；也就是说，程序员不需要关心内存中这些对象的构造和销毁。通常，栈用于函数参数和局部变量。另一方面，堆允许在程序执行期间分配新的内存。然而，正确的内存空间释放现在是程序员的责任。

1.  指针的大小不取决于指针的类型，因为指针是表示内存中地址的值。地址的大小取决于系统。通常是 32 位或 64 位。因此，我们说指针的大小是 4 或 8 字节。

1.  数组在项目位置方面具有独特的结构。它们在内存中是连续放置的；第二个项目紧跟在第一个项目后面，第三个项目紧跟在第二个项目后面，依此类推。考虑到这一特性，以及数组由相同类型的元素组成的事实，访问任何位置的项目都需要恒定的时间。

1.  如果我们在`case`语句中忘记了`break`关键字，执行将会转移到下一个`case`语句，而不检查其条件。

1.  例如，`operations['+'] = [](int a, int b) { return a + b; }`

# 第三章

1.  身份、状态和行为。

1.  在移动对象而不是复制时，我们省略了创建临时变量。

1.  在 C++中，结构体和类之间没有任何区别，除了默认访问修饰符。结构体的默认访问修饰符是 public，而类的默认访问修饰符是 private。

1.  在聚合的情况下，包含其他类的实例或实例的类可以在没有聚合的情况下实例化。而组合则表示强的包含关系。

1.  私有继承将继承的成员隐藏在派生类的客户端代码中。保护继承也是如此，但允许链中的派生类访问这些成员。

1.  通常，引入虚函数会导致向类添加指向虚函数表的附加数据成员。通常，这会增加类对象的 4 或 8 个字节的空间（根据指针的大小）。

1.  单例设计模式允许构造类的单个实例。这在许多项目中非常有用，其中我们需要确保类的实例数量限制为一个。例如，如果实现为单例的数据库连接类效果最佳。

# 第四章

1.  宏是强大的工具，如果以正确的方式使用。然而，以下方面限制了宏的使用。(1) 你无法调试宏；(2) 宏扩展可能导致奇怪的副作用；(3) 宏没有命名空间，因此如果你的宏与其他地方使用的名称冲突，你会在不想要的地方得到宏替换，这通常会导致奇怪的错误消息；和(4) 宏可能影响你不知道的事情。有关更多详细信息，请访问[`stackoverflow.com/questions/14041453`](https://stackoverflow.com/questions/14041453)。

1.  类/函数模板是一种用于生成模板类/函数的模板。它只是一个模板，而不是一个类/函数，因此编译器不会为其生成任何对象代码。模板类/函数是类/函数模板的一个实例。由于它是一个类/函数，编译器会生成相应的对象代码。

1.  当我们定义一个类/函数模板时，在`template`关键字后面有一个<>符号，其中必须给出一个或多个类型参数。<>中的类型参数被称为模板参数列表。当我们实例化一个类/函数模板时，所有模板参数必须用相应的模板参数替换，这被称为模板参数列表。

隐式实例化是按需发生的。然而，当提供库文件（.lib）时，你不知道用户将来会使用什么类型的参数列表，因此，你需要显式实例化所有潜在的类型。

1.  *多态*意味着某物以不同的形式存在。具体来说，在编程语言中，多态意味着一些函数、操作或对象在不同的上下文中有几种不同的行为。在 C++中，有两种多态性：动态多态和静态多态。动态多态允许用户在运行时确定要执行的实际函数方法，而静态多态意味着在编译时知道要调用的实际函数（或者一般来说，要运行的实际代码）。

函数重载意味着使用相同的名称但不同的参数集（不同的签名）定义函数。

函数重写是子类重写父类中定义的虚方法的能力。

1.  类型特征是一种用于收集有关类型信息的技术。借助它，我们可以做出更明智的决策

在通用编程中开发高质量优化的算法。类型特征可以通过部分或完全模板特化来实现。

1.  我们可以在`g()`中编写一个错误语句，并构建代码。如果实例化了未使用的函数，则编译器将报告错误，否则将成功构建。您可以在以下文件中找到示例代码，`ch4_5_class_template_implicit_inst_v2.h`和`ch4_5_class_template_implicit_inst_B_v2.cpp`，位于[`github.com/PacktPublishing/Mastering-Cpp-Programming./tree/master/Chapter-4.`](https://github.com/PacktPublishing/Expert-CPP/tree/master/Chapter-4)

1.  请参考[`github.com/PacktPublishing/Mastering-Cpp-Programming./tree/master/Chapter-4`](https://github.com/PacktPublishing/Mastering-Cpp-Programming./tree/master/Chapter-4)中的`ch4_q7.cpp`。

1.  这是一个实验练习；不需要答案。

# 第五章

1.  计算机内存可以描述为一个概念 - **动态 RAM**（**DRAM**），或者是计算机包含的所有内存单元的组合，从寄存器和缓存内存开始，到硬盘结束。从程序员的角度来看，DRAM 是最感兴趣的，因为它保存了计算机中运行的程序的指令和数据。

1.  虚拟内存是一种有效管理计算机物理内存的方法。通常，操作系统会整合虚拟内存来处理程序的内存访问，并有效地为特定程序分配内存块。

1.  在 C++中，我们使用`new`和`delete`运算符来分配和释放内存空间。

1.  `delete`用于释放为单个对象分配的空间，而`delete[]`用于动态数组，并在堆上释放数组的所有元素。

1.  垃圾收集器是一种工具或一组工具和机制，用于在堆上提供自动资源释放。对于垃圾收集器，需要一个支持环境，比如虚拟机。C++直接编译成可以在没有支持环境的情况下运行的机器代码。

# 第六章

1.  在向向量中插入新元素时，它被放置在向量的已分配的空闲槽中。如果向量的大小和容量相等，则意味着向量没有空闲槽可供新元素使用。在这些（罕见）情况下，向量会自动调整大小，这涉及分配新的内存空间，并将现有元素复制到新的更大空间。

1.  在链表的前面插入元素时，我们只创建新元素并更新列表指针，以有效地将新元素放入列表中。在向向量的前面插入新元素时，需要将所有向量元素向右移动，以释放一个槽位给该元素。

1.  请参考 GitHub 中的章节源代码。

1.  它看起来像一个链表。

1.  选择排序搜索最大（或最小）元素，并用该最大（或最小）元素替换当前元素。插入排序将集合分为两部分，并遍历未排序部分，并将其每个元素放入已排序部分的适当槽中。

1.  请参考 GitHub 中的章节源代码。

# 第七章

1.  C++中的 ranges 库允许处理元素的范围，并使用视图适配器对其进行操作，这样更有效，因为它们不会将整个集合作为适配器结果存储。

1.  如果函数不修改状态，并且对于相同的输入产生相同的结果，则该函数是纯的。

1.  纯虚函数是没有实现的函数的特征。纯虚函数用于描述派生类的接口函数。函数式编程中的纯函数是那些不修改状态的函数。

1.  折叠（或缩减）是将一组值组合在一起以生成减少数量的结果的过程。

1.  尾递归允许编译器通过省略为每个递归调用分配新内存空间来优化递归调用。

# 第八章

1.  如果两个操作的开始和结束时间在任何时刻交错，则它们会同时运行。

1.  并行意味着任务同时运行，而并发不强制任务同时运行。

1.  进程是程序的映像。它是程序指令和数据加载到计算机内存中的组合。

1.  线程是进程范围内可以由操作系统调度程序调度的代码部分，而进程是正在运行的程序的映像。

1.  请参考章节中的任何示例。

1.  通过使用双重检查锁定。

1.  请参考 GitHub 上该章节的源代码。

1.  C++20 引入了协程作为经典异步函数的补充。协程将代码的后台执行提升到了下一个级别。它们允许在必要时暂停和恢复函数。`co_await`是一个构造，告诉代码等待异步执行的代码。这意味着函数可以在那一点被暂停，并在结果准备好时恢复执行。

# 第九章

1.  双重检查锁定是使单例模式在多线程环境中无缺陷地工作的一种方法。

1.  这是一种确保在复制其他堆栈的基础数据时，其底层数据不会被修改的方法。

1.  原子操作是不可分割的操作，原子类型利用底层机制来确保指令的独立和原子执行。

1.  `load()`和`store()`利用低级机制来确保写入和读取操作是原子的。

1.  除了`load()`和`store()`之外，还有诸如`exchange()`、`wait()`和`notify_one()`等操作。

# 第十章

1.  TDD 代表测试驱动开发，其目的是在项目的实际实现之前编写测试。这有助于更清晰地定义项目需求，并在代码中避免大部分错误。

1.  交互图表现了对象之间通信的确切过程。这使开发人员能够高层次地查看任何给定时刻的实际程序执行。

1.  在聚合的情况下，包含其他类的实例或实例的类可以在没有聚合的情况下实例化。另一方面，组合表达了强包含关系。

1.  简而言之，里氏替换原则确保接受某种类型 T 对象作为参数的任何函数也将接受类型 K 对象，如果 K 扩展了 T。

1.  开闭原则规定类应该对扩展开放，对修改关闭。在所述示例中，`Animal`对扩展开放，因此从`Animal`继承`monkey`类并不违反该原则。

1.  请参考 GitHub 上该章节的源代码。

# 第十一章

1.  覆盖私有虚函数允许通过保持其公共接口不变来修改类的行为。

1.  这是一种行为设计模式，其中对象封装了一个动作和执行该动作所需的所有信息。

1.  尽可能与其他对象共享数据。当我们有许多具有相似结构的对象时，跨对象共享重复数据可以最小化内存使用。

1.  观察者通知订阅对象有关事件，而中介者则扮演着相互通信对象之间连接的角色。

1.  将游戏循环设计为无限循环是合理的，因为从理论上讲，游戏可能永远不会结束，只有在玩家命令结束时才会结束。

# 第十二章

1.  物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。

1.  端口号提供了一种区分在同一环境中运行的多个网络应用程序的方法。

1.  套接字是提供程序员发送和接收网络数据的抽象。

1.  首先，我们需要创建并绑定带有 IP 地址的套接字。接下来，我们应该监听传入的连接，如果有一个连接，我们应该接受连接以进一步处理数据通信。

1.  TCP 是一种可靠的协议。它处理端点之间的稳固连接，并通过重新发送接收方未收到的数据包来处理数据包丢失。另一方面，UDP 不可靠。几乎所有处理方面都由程序员来处理。UDP 的优势在于它的速度，因为它省略了握手、检查和数据包丢失处理。

1.  宏定义会导致代码中的逻辑错误，很难发现。最好始终使用`const`表达式而不是宏。

1.  客户端应用程序必须具有唯一的标识符，以及用于授权和/或验证它们的令牌（或密码）。

# 第十三章

1.  这是一个实验室练习；不需要答案。

1.  以下输出来自 NVIDIA Jetson Nano 上的 Ubuntu 18.04：

```cpp
swu@swu-desktop:~/ch13$ g++ -c -Wall -Weffc++ -Wextra ch13_rca_compound.cpp
 ch13_rca_compound.cpp: In function ‘int main()’:
 ch13_rca_compound.cpp:11:17: warning: operation on ‘x’ may be undefined [-Wsequence-point]
 std::cout << f(++x, x) << std::endl; //bad,f(4,4) or f(4,3)?
 ^~~

```

```cpp
swu@swu-desktop:~/ch13$ g++ -c -Wall -Weffc++ -Wextra ch13_rca_mix_sign_unsigned.cpp
nothing is detected 
```

```cpp
swu@swu-desktop:~/ch13$ g++ -c -Wall -Weffc++ -Wextra ch13_rca_order_of_evaluation.cpp
 ch13_rca_order_of_evaluation.cpp: In constructor ‘A::A(int)’:
 ch13_rca_order_of_evaluation.cpp:14:14: warning: ‘A::v3’ will be initialized after [-Wreorder]
 int v1, v2, v3;
 ^~
 ch13_rca_order_of_evaluation.cpp:14:6: warning: ‘int A::v1’ [-Wreorder]
 int v1, v2, v3;
 ^~
 ch13_rca_order_of_evaluation.cpp:7:2: warning: when initialized here [-Wreorder]
 A(int x) : v2(v1), v3(v2), v1(x) {
 ^
 ch13_rca_order_of_evaluation.cpp: In constructor ‘B::B(float)’:
 ch13_rca_order_of_evaluation.cpp:32:6: warning: ‘B::v2’ will be initialized after [-Wreorder]
 int v2;
 ^~
 ch13_rca_order_of_evaluation.cpp:31:6: warning: ‘int B::v1’ [-Wreorder]
 int v1; //good, here the declaration order is clear
 ^~
 ch13_rca_order_of_evaluation.cpp:25:2: warning: when initialized here [-Wreorder]
 B(float x) : v2(x), v1(v2) {};
 ^
 swu@swu-desktop:~/ch13$ g++ -c -Wall -Weffc++ -Wextra ch13_rca_uninit_variable.cpp
 ch13_rca_uninit_variable.cpp: In function ‘int main()’:
 ch13_rca_uninit_variable.cpp:7:2: warning: ‘x’ is used uninitialized in this function [-Wuninitialized]
 if (x) {
 ^~
```

1.  因为静态分析工具从其模型中预测错误，动态分析工具通过程序的执行来检测错误。

1.  请参考样本代码，`ch13_tdd_v3.h`，`ch13_tdd_v3.cpp`和`ch13_tdd_Boost_UTF3.cpp`，

[`github.com/PacktPublishing/Mastering-Cpp-Programming./tree/master/Chapter-13`](https://github.com/PacktPublishing/Mastering-Cpp-Programming./tree/master/Chapter-13)。

# 第十四章

1.  Qt 的编译模型允许省略虚拟机。它使用**元对象编译器**（**MOC**）将其转换为 C++，然后编译为特定平台的机器代码。

1.  `QApplication::exec()`是应用程序的起点。它启动 Qt 的事件循环。

1.  通过调用`setWindowTitle()`。

1.  `m->index (2, 3)`。

1.  `wgt->resize (400, 450)`。

1.  当从`QLayout`继承时，应为`addItem()`、`sizeHint()`、`setGeometry()`、`itemAt()`、`takeAt()`和`minimumSize()`函数提供实现。

1.  通过使用`connect()`函数，该函数以源对象和目标对象以及信号和插槽的名称作为参数。

# 第十五章

1.  **ML**代表**机器学习**，是计算机系统用于执行特定任务的算法和统计模型的研究领域，而不使用显式指令，而是依赖模式和推理。

1.  监督学习算法（也称为带教练的训练）从带标签的数据集中学习；也就是说，每个记录都包含描述数据的附加信息。无监督学习算法更加复杂——它们处理包含大量特征的数据集，然后试图找到特征的有用属性。

1.  机器学习应用包括机器翻译、自然语言处理、计算机视觉和电子邮件垃圾邮件检测。

1.  其中一种方法是为每个结果添加权重，如果减法操作的权重超过其他操作，它将成为主导操作。

1.  神经网络的目的是识别模式。

# 第十六章

1.  网络爬虫下载网页并存储其内容，以便搜索引擎对其进行索引。

1.  我们称之为倒排索引，因为它将单词映射回它们在文档中的位置。

1.  在索引之前，标记化会规范化单词。

1.  推荐引擎验证并推荐适合特定请求的最佳结果。

1.  知识图是一个图，其中节点是主题（知识），边是主题之间的连接。
