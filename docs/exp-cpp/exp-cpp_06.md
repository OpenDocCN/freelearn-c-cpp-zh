# 您可以在此章节中找到使用的源文件[`github.com/PacktPublishing/Expert-CPP`](https://github.com/PacktPublishing/Expert-CPP)。

技术要求

内存分配和释放始于对函数的简单调用。调用函数通常意味着向其传递参数。函数需要空间来存储这些参数。为了简化生活，这些都是自动处理的。当我们在代码中声明对象时，同样会发生自动分配。它们的生命周期取决于它们声明的范围。无论何时它们超出范围，它们都将被自动释放。大多数编程语言为动态内存提供类似的自动释放功能。动态分配的内存 - 与自动分配相对 - 是程序员用来识别根据需求请求新内存的代码部分的术语。例如，在存储客户请求列表的程序中，当客户数量增加时会使用这种功能来请求新的内存空间。

大多数语言提供了简化的方法来访问动态内存，而不必担心其释放策略，将繁重的工作留给运行时支持环境。C++程序员必须处理内存管理的低级细节。无论是由于语言的哲学、结构还是年龄，C++都没有提供高级内存管理功能。因此，对内存结构及其管理的深入理解对于每个 C++程序员来说都是必不可少的。让我们在本章中揭示内存和适当的内存管理技术背后的奥秘。

我们将使用电路、继电器和逻辑门来设计一个能够存储位的简单设备。本节的目的是了解内存在其最低级别的结构。在本章中，我们将涵盖以下主题：

+   什么是内存，我们如何在 C++中访问它？

+   很难描述设备如何存储这些变量。为了在那个神奇的过程中投下一些光芒，让我们试着设计一个存储一点信息的设备。

+   内存管理技术和习惯用法

+   详细的内存分配

# 垃圾收集基础知识

使用`g++`编译器和选项`-std=c++2a`编译本章中的示例。

在最低级别的表示中，内存是一个存储位状态的设备。假设我们正在发明一个可以存储单个位信息的设备。现在，这似乎既毫无意义又神奇。毫无意义是因为发明已经在很久以前就已经发明了。神奇是因为程序员现在有幸福的稳定多功能环境，提供了大量的库、框架和工具来创建程序，甚至不需要了解它们的内部工作。声明变量或分配动态内存已经变得非常容易，就像下面的代码片段所示：

# 在 C++中，内存管理是有代价的。关心的程序员经常抱怨 C++因为它需要手动内存管理。而像 C#和 Java 这样的语言使用自动内存管理，使得程序运行速度比它们的 C++对应程序慢。手动内存管理经常容易出错和不安全。正如我们在前几章中已经看到的，程序代表数据和指令。几乎每个程序都在某种程度上使用计算机内存。很难想象一个有用的程序不需要内存分配。

理解计算机内存

```cpp
int var;
double* pd = new double(4.2);
```

为了在内存管理的*类型*之间进行某种区分，无论是自动还是手动，程序员都使用内存分段。程序操作多个内存段，堆栈、堆、只读段等等，尽管它们都具有相同的结构并且是同一虚拟内存的一部分。

# 设计一个内存存储设备

内存管理和智能指针

这是一个简单的电路示例，您可能在物理课上熟悉：

![](img/e049c87e-55a0-431d-96bf-28b605e4c07e.png)

它由一根连接电池和灯泡的**导线**组成。**导线**上有一个控制灯泡状态的**开关**。当开关关闭时，灯泡亮起，否则灯泡熄灭。我们将在这个电路中添加两个 NOR 逻辑元件。NOR 是非或的缩写。通常用以下方式表示：

![](img/4072ad42-c9a2-495f-aee5-06d736ddb9c9.png)

它有两个输入（导线引入元件），每个代表一个电信号。如果两个输入都为 0，我们说输出（从元件出来的导线）为 1。这就是为什么我们称它为*非或*，因为如果任何一个输入为 1，OR 元件就会输出 1。前述 NOR 元件只是使用两个继电器构建的。继电器是使用电磁铁来闭合和打开触点的开关。看看下面的图表：

![](img/99bb5ce8-b8cc-4b27-b767-ec65c76b7ddc.png)

当**继电器**的两个**开关**关闭（意味着**继电器**正在工作并拉下电路的**开关**）时，灯泡是*关闭*的。当我们将**继电器**的两个**开关**移动到开放位置时，灯泡就会*亮起*。上图是描述 NOR 门的一种方式。此时，我们可以使用电线、灯泡、电池和继电器创建逻辑元件。现在让我们看看两个 NOR 元件的奇怪组合，引发了一个有趣的发现：

![](img/767e57ea-e066-4eef-b2eb-afc2868604c2.png)

上图是典型的**R-S 触发器**的表示。**R**代表*复位*，**S**代表*设置*。前述方案构建的设备可以存储一个位。输出**Q**是我们可以读取设备内容的导线。如果我们设置触发器来存储位，输出将为 1。您应该仔细检查图表，并想象逐个或同时向其输入传递信号，并查看**Q**的输出。当输入**S**为 1 时，**Q**变为 1。当**R**为 1 时，**Q**变为 0。这样我们就可以*设置*或*复位*位。只要我们向设备提供电流，它就会存储位。

现在想象一下，将之前设计的许多设备相互连接，以便存储多于一个位的信息。这样，我们可以构建复杂的内存设备，存储字节甚至**千字节**（**KB**）的数据。

前述设备类似于在晶体管发明之前计算机中使用的设备。晶体管是一种更小的设备，能够存储位。晶体管有不同的类型。现代设备不使用继电器；相反，它们集成了数百万个晶体管来存储和操作数据。**中央处理单元**（**CPU**）寄存器就是利用晶体管存储指定数量位的设备的一个例子。通常，通用寄存器最多可以存储 64 位数据。但是，您不能仅使用寄存器来存储所有程序和数据。计算机内存的组织要复杂得多。现在让我们从更高层次的角度来研究计算机内存的层次结构。

# 从更高层次的角度理解计算机内存

了解计算机内存和数据存储的细节对于编写专业程序至关重要。当程序员提到“内存”一词时，大多数情况下他们指的是虚拟内存。虚拟内存是由操作系统（OS）支持的抽象，用于控制和为进程提供内存空间。每个进程都有其地址空间，表示为几个段的集合。我们在《使用 C++进行低级编程》的第二章中讨论了有哪些内存段，以及给定程序如何使用每个内存段。从程序员的角度来看，访问内存空间主要限于对象声明和使用。无论我们在堆栈、堆还是静态内存中声明对象，我们都访问相同的内存抽象——虚拟内存。虽然复杂，但虚拟内存使生活变得更加轻松。直接使用物理内存更加困难，尽管这是程序员技能的重大进步。你至少应该知道有哪些内存存储单元，以及如何利用这些知识来编写更好的代码。

在本节中，我们已经讨论了物理内存层次结构。我们称之为“层次结构”，因为较低级别的每个内存单元提供更快的访问速度，但空间较小。每个连续更高级别的内存提供更多的空间，但访问速度较慢。

我们讨论物理内存层次结构是因为它将帮助我们设计更好的代码。了解每个级别的内存如何工作可以提高我们作为程序员的水平，并使我们能够更好地组织数据操作。以下图表说明了内存层次结构：

（图片）

寄存器是放置在 CPU 中的最快可访问的内存单元。寄存器的数量是有限的，因此我们无法将所有程序数据都保存在其中。另一方面，动态 RAM 能够存储程序的各种数据。由于其物理结构和与 CPU 的距离，从 DRAM 中访问数据需要更长的时间。CPU 通过数据总线访问 DRAM，数据总线是一组在 CPU 和 DRAM 之间传输数据的导线。为了向 DRAM 控制器发出读取或写入数据的信号，CPU 使用控制总线。我们将 DRAM 称为“主内存”。让我们详细看看内存层次结构。

# 寄存器

寄存器保存固定数量的数据。CPU 字长通常由寄存器的最大长度定义，例如八字节或四字节。我们无法直接从 C++程序中访问寄存器。

C++支持使用`asm`声明嵌入汇编代码，例如`asm("mov edx, 4")`。这是一种特定于平台的人为代码增强，因此我们不建议使用它。

在较早版本的语言中，我们可以在声明变量时使用`register`关键字：

```cpp
register int num = 14;
```

修饰符指定编译器将变量存储在寄存器中。这样，它给程序员一种虚假的代码优化感觉。

编译器是将高级 C++代码转换为机器代码的复杂工具。在翻译过程中，代码经历了多次转换，包括代码优化。当程序员对代码的一部分应用“技巧”来强制编译器优化时，编译器将其视为建议而不是命令。

例如，在循环中访问变量，如果将该变量放在寄存器中而不是 DRAM 中，访问速度将更快。例如，以下循环一百万次访问对象：

```cpp
auto number{42};
for (int ix = 0; ix < 10000000; ++ix) {
 int res{number + ix};
  // do something with res
}
```

正如我们所知，`number`具有自动存储期限（与`auto`关键字无关），并放置在堆栈上。堆栈是虚拟内存中的一个段，虚拟内存是对物理 DRAM 的抽象。从寄存器中访问对象比从 DRAM 中访问对象要快得多。假设从 DRAM 中读取`number`的值比从`寄存器`中读取的值慢五倍。显然，通过使用`寄存器`关键字来优化前面的循环似乎是显而易见的，如下所示：

```cpp
register auto number{42};
// the loop omitted for code brevity
```

然而，现在编译器进行了更好的优化，因此对修改器的需求随着时间的推移而减弱，现在已经是一个不推荐使用的语言特性。更好的优化是完全摆脱`number`对象。

例如，以下代码表示使用实际值而不是通过驻留在 DRAM 中的变量访问该值的编译优化版本：

```cpp
for (int ix = 0; ix < 1000000; ++ix) {
 int res{42 + ix};
  // do something with res
}
```

尽管前面的示例可以说是简单的，但我们应该考虑在编译过程中进行的编译器优化。

发现寄存器可以提高我们对程序执行细节的理解。关键是 CPU 执行的所有操作都是通过寄存器进行的，包括 CPU 应该解码和执行的指令都是使用特定的寄存器访问的，通常称为**指令指针**。当我们运行程序时，CPU 访问其指令并解码和执行它们。从主存中读取数据和向内存写入数据是通过从寄存器复制数据来执行的。通常，通用寄存器用于在 CPU 对其执行操作时临时保存数据。以下图表描述了**CPU**及其通过总线与主存的交互的抽象视图：

![](img/b98cbe03-4c6c-4b6c-acb8-5079eee59237.png)

正如您所看到的，CPU 和 DRAM 之间的通信是通过各种总线进行的。在第二章中，我们讨论了 C++程序的低级表示 - 您应该快速查看以更好地理解以下示例。

现在，让我们看看寄存器的运行情况。以下 C++代码声明了两个变量，并将它们的和存储在第三个变量中：

```cpp
int a{40}, b{2};
int c{a + b};
```

要执行求和指令，CPU 将变量`a`和`b`的值移入其寄存器。在计算总和后，它将结果移入另一个寄存器。程序的汇编伪代码表示类似于以下内容：

```cpp
mov eax, a
mov ebx, b
add eax, ebx
```

编译器不一定要生成将每个变量映射到一个寄存器的代码 - 寄存器的数量是有限的。您只需要记住，应该将经常访问的变量保持足够小，以适应其中一个寄存器。对于较大的对象，高速缓存内存会发挥作用。让我们看看。

# 高速缓存内存

缓存的概念在编程和计算机系统中很常见。在浏览器中加载的图像会被缓存，以避免在用户再次访问网站时向 Web 服务器发出进一步的请求以下载它。缓存使程序运行更快。这个概念可以以许多形式利用，包括在单个函数中。例如，以下递归函数计算一个数字的阶乘：

```cpp
long factorial(long n) {
  if (n <= 1) { return 1; }
  return n * factorial(n - 1);
}
```

该函数不记得其先前计算的值，因此以下调用分别导致五次和六次递归调用：

```cpp
factorial(5); // calls factorial(4), which calls factorial(3), and so on
factorial(6); // calls factorial(5), which calls factorial(4), and so on
```

我们可以通过将它们存储在全局可访问的变量中来缓存每一步已计算的值。

```cpp
std::unordered_map<long, long> cache;

long factorial(long n) {
  if (n <= 1) return 1;
 if (cache.contains(n)) return cache[n];
 cache[n] = n * factorial(n - 1);
 return cache[n];
}
```

修改进一步调用函数的优化：

```cpp
factorial(4);
// the next line calls factorial(4), stores the result in cache[5], which then calls factorial(3)
// and stores the result in cache[4] and so on
factorial(5);
factorial(6); // calls the factorial(5) which returns already calculated value in cache[5]
```

与缓存概念使阶乘函数运行更快的方式相同，CPU 内部实际存储设备名为**缓存**。该设备存储最近访问的数据，以便使对该数据的进一步访问更快。以下图表描述了 CPU 内部的**寄存器**和**缓存内存**：

![](img/3ab977f8-8e12-4e36-b903-b72c9da9b7ff.png)

缓存的大小通常范围从 2KB 到 64KB（很少为 128KB）。虽然对于诸如 Photoshop 之类的应用程序来说，缓存的大小可能远远不够，因为图像数据的大小可能远远大于缓存本身，但在许多情况下，它确实会有所帮助。例如，假设我们在一个向量中存储了超过 1000 个数字：

```cpp
std::vector<int> vec;
vec.push_back(1);
...
vec.push_back(9999);
```

以下代码打印向量项：

```cpp
for (auto it: vec) {
  std::cout << it;
}
// 1
// 2
// 3
// ...
// 9999
```

假设要打印该项，**CPU**将其从内存复制到 rax 寄存器，然后调用运算符`<<`，将 rax 的值打印到屏幕上。在循环的每次迭代中，**CPU**将向 rax 寄存器复制向量的下一项，并调用函数打印其值。每次复制操作都需要**CPU**将该项的地址放在**地址总线**上，并将**控制总线**设置为读模式。**DRAM**微控制器通过地址总线接收到的地址访问数据，并将其值复制到数据总线，从而将数据发送给**CPU**。**CPU**将值传递给 rax 寄存器，然后执行指令打印其值。下图显示了**CPU**和**DRAM**之间的交互：

![](img/38e99ee6-c6b8-4007-8a8b-3705975066fd.png)

为了优化循环，CPU 保持了**数据局部性**的概念，即将整个向量复制到缓存中，并从缓存中访问向量项，省略了对 DRAM 的不必要请求。在下图中，您可以看到通过数据总线从 DRAM 接收的数据然后存储在**缓存内存**中：

![](img/a638de34-c3d8-4c57-9edc-078fb8563b94.png)

存储在 CPU 中的缓存被称为**一级**（**L1**）**缓存**。这是容量最小的缓存，位于 CPU 内部。许多体系结构都有**二级**（**L2**）**缓存**，它位于 CPU 外部（尽管比主存储器更接近），并且与 DRAM 的访问方式相同。L2 缓存和 DRAM 之间的区别在于物理结构和数据访问模式。L2 缓存代表**静态 RAM**（**SRAM**），比 DRAM 更快，但也更昂贵。

一些运行时环境在实现垃圾回收时利用了缓存的概念。它们根据对象的生命周期将对象分成不同的类别，生命周期最短的对象，比如在代码的局部范围内分配的对象，被放入缓存中以便更快地访问和释放。

新的缓存级别用作较低级别的缓存。例如，L2 缓存用作 L1 缓存的缓存内存。当 CPU 遇到缓存未命中时，它会请求 L2 缓存，依此类推。

# 主存储器

DRAM 的物理结构迫使它刷新其电荷以保持数据稳定，而 SRAM 不需要像 DRAM 那样刷新。我们之所以称 DRAM 为主存储器，主要是因为程序加载到其中；操作系统维护虚拟内存并将其映射到 DRAM。所有实际的工作都是通过主存储器进行的。

正如我们之前讨论的，主存储器代表了一系列可寻址的数据字节。每个字节都有自己独特的地址，并且可以使用该地址进行访问。我们之前提到过，CPU 将数据的地址放在地址总线上，从而让 DRAM 微控制器获取请求的数据并通过数据总线发送出去。

正如我们所知，操作系统引入了虚拟内存作为对物理内存的抽象。它将虚拟内存的内容映射到物理内存，这涉及到 CPU 的**转换旁路缓存**（**TLB**）。TLB 是另一种缓存内存的形式：它存储了**虚拟内存**到**物理内存**的最近转换，从而为将来的请求进行缓存。如下图所示，**CPU**与**TLB**协调以正确地将虚拟地址转换为物理地址：

![](img/38b916ec-a8a1-40f4-aa32-f99bc44eaebf.png)

尽管内存管理很复杂，但操作系统为我们提供了一个足够简单的抽象来管理程序所需的内存。我们有能力使用堆栈自动分配内存，也可以在堆上动态分配内存。自动内存分配实际上并不涉及太多问题和困难；我们只需声明对象，它们就会放在堆栈上，然后在执行离开作用域时自动删除。在动态内存的情况下（不要与前面提到的硬件 DRAM 混淆），分配和释放都应该手动完成，这会导致可能导致内存泄漏的错误。

# 永久存储

当我们关闭计算机时，主内存的内容会被擦除（因为电荷不再刷新）。为了在断电时永久存储数据，计算机配备了硬盘驱动器（HDD）或固态硬盘驱动器（SSD）。从程序员的角度来看，永久存储用于存储程序及其必要的数据。我们已经知道，为了运行程序，它应该被加载到主内存中，也就是从硬盘驱动器复制到 DRAM 中。操作系统使用加载器处理这个过程，并在内存中创建一个程序映像，通常称为进程。当程序完成或用户关闭它时，操作系统将进程的地址范围标记为可用。

假设我们使用文本编辑器在学习 C++时写笔记。在编辑器中键入的文本将驻留在主内存中，除非我们将其保存在硬盘驱动器上。这一点很重要，因为大多数程序会跟踪最近的用户活动，并允许用户修改程序设置。为了保持用户修改后的设置，即使程序重新启动，程序会将它们存储为硬盘上的单独的*设置*文件。下次程序运行时，它首先从硬盘驱动器中读取相应的设置文件，然后更新自身以应用最近的设置修改。

通常，永久存储的容量比主内存大得多，这使得可以将硬盘驱动器用作虚拟内存的备份。操作系统可以维护虚拟内存并伪装其大小，使其比物理 DRAM 更大。例如，启动几个重量级应用程序可能会迅速耗尽 DRAM 的最大容量。然而，操作系统仍然可以通过将其额外的空间备份到硬盘驱动器来维护更大的虚拟内存。当用户在应用程序之间切换时，操作系统将虚拟内存的超出字节复制到硬盘驱动器，并将当前运行的应用程序映射到物理内存。

这使得程序和操作系统运行得更慢，但允许我们保持它们打开，而不必担心主内存的有限大小。现在让我们深入了解 C++中的内存管理。

# 内存管理的基础

大多数情况下，内存管理中出现的问题是程序员忘记释放内存空间。这导致内存泄漏。内存泄漏是几乎每个程序中普遍存在的问题。当程序请求新的内存空间来存储其数据时，操作系统会将提供的空间标记为“忙碌”。也就是说，程序的任何其他指令或任何其他程序都无法请求该忙碌的内存空间。当程序部分完成内存空间时，理想情况下，它必须通知操作系统去除忙碌标签，以便为其他程序释放空间。一些语言提供对动态分配内存的自动控制，使程序员只需担心应用程序的逻辑，而不必不断担心释放内存资源。然而，C++假设程序员是负责和聪明的（这并不总是事实）。动态分配的内存管理是程序员的责任。这就是为什么语言提供了“new”和“delete”运算符来处理内存空间，其中 new 运算符分配内存空间，而 delete 运算符释放内存空间。换句话说，处理动态分配内存的理想代码如下所示：

```cpp
T* p = new T(); // allocate memory space
p->do_something(); // use the space to do something useful
delete p; // deallocate memory space
```

忘记调用 delete 运算符会使分配的内存空间“永远忙碌”。所谓的“永远”，是指程序运行的时间。现在想象一下一个总是在用户计算机上打开的网络浏览器。这里发生的内存泄漏可能会导致内存饥饿，最终用户不得不重新启动程序，甚至更糟糕的是重新启动操作系统。

这个问题适用于我们使用的任何资源，无论是我们忘记关闭的文件还是套接字（关于套接字的更多信息请参见第十二章，*网络和安全*）。为了解决这个问题，C++程序员使用**资源获取即初始化**（**RAII**）习惯用法，该习惯用法规定资源应该在初始化时获取，这样可以在以后正确释放它。让我们看看它的实际应用。

# 内存管理的一个例子

考虑以下函数，该函数动态分配了一个包含 420 个`shorts`的数组，从用户输入中读取它们的值，按升序打印它们，并释放数组：

```cpp
void print_sorted() {
  short* arr{new short[420]};
  for (int ix = 0; ix < 420; ++ix) {
    std::cin >> arr[ix];
  }
  std::sort(arr, arr + 420);
  for (int ix = 0; ix < 420; ++ix) {
    std::cout << arr[ix];
  }
  delete arr; // very bad!
}
```

在前面的代码中，我们已经犯了一个错误，即使用错误的`delete`运算符来释放内存。要释放数组，我们必须使用`delete[]`运算符，否则代码会导致内存泄漏。以下是我们如何说明数组的分配：

![](img/073fb3c2-f36b-4002-bfc3-fecbeb34ecdf.png)

假设我们使用`delete`而不是`delete[]`来释放空间。它将把`arr`视为一个 short 指针，因此将删除从`arr`指针中包含的地址开始的前两个字节，如下图所示：

![](img/50d84dee-769a-47cc-b579-5967570ec8ed.png)

现在我们从 420 个项目中移除了第一个项目，剩下的 419 个`shorts`保持在堆上不变。每当我们需要堆上的新空间时，包含 419 个“untouchables”的小部分将永远不会被再次重用。虽然 new 和 delete 运算符的家族是实现定义的，但我们不应该真的指望最好的实现来避免内存泄漏。

让我们修改前面的代码，正确释放数组的分配内存，并确保消除输入负数的可能性：

```cpp
void print_sorted() {
 short* arr{new short[420]};
  for (int ix = 0; ix < 420; ++ix) {
    std::cin >> arr[ix];
 if (arr[ix] < 0) return;
  }
  std::sort(arr, arr + 420);
  // print the sorted array, code omitted for brevity
 delete[] arr;
}
```

前面的修改是可能的内存泄漏的另一个例子，尽管我们显然为了简单起见写了丑陋的代码。关键是，每当用户输入一个负数时，函数就会返回。这让我们有 420 个应该被释放的`shorts`孤立。然而，分配的内存的唯一访问是`arr`指针，它在堆栈上声明，因此当函数返回时它将被自动删除（指针变量，而不是指向它的内存空间）。为了消除内存泄漏的可能性，我们应该在函数退出之前简单地调用`delete[]`运算符：

```cpp
void print_sorted() {
 short* arr{new short[420]};
  for(int ix = 0; ix < 420; ++ix) {
    std::cin >> arr[ix];
 if (arr[ix] < 0) {
 delete[] arr;
 return;
 }
  }
  // sort and print the sorted array, code omitted for brevity
 delete[] arr;
}
```

代码变得有些丑陋，但它修复了内存泄漏。如果我们进一步修改函数并使用第三方库函数来对数组进行排序：

```cpp
import <strange_sort.h>;

void print_sorted() {
  short* arr{new short[420]};
  for (...) { /* code omitted for brevity */ }
 strange_sort::sort(arr, arr + 420);
  // print the sorted array, code omitted for brevity
  delete[] arr;
}  
```

事实证明，`strange_sort::sort`在数组项的值超过 420 时会抛出异常（毕竟这就是一个奇怪的排序）。如果异常没有被捕获，它将冒泡到调用者函数，除非它在某处被捕获，或者程序崩溃。未捕获的异常导致堆栈展开，这导致`arr`变量（指针）的自动销毁，因此我们面临另一个内存泄漏的可能性。为了解决这个问题，我们可以将`strange_sort::sort`包装在 try-catch 块中：

```cpp
try {
  strange_sort::sort(arr, arr + 420);
} catch (ex) { delete[] arr; }
```

C++程序员不断寻求处理内存泄漏的方法，例如 RAII 习惯用法和智能指针，我们将在接下来的章节中讨论。

# 使用智能指针

有许多支持自动垃圾收集的语言。例如，为对象获取的内存由运行时环境跟踪。当具有对它的引用的对象超出范围时，它将释放内存空间。例如，考虑以下情况：

```cpp
// a code sample of the language (not-C++) supporting automated garbage collection
void foo(int age) {
  Person p = new Person("John", 35);
  if (age <= 0) { return; }
  if (age > 18) {
   p.setAge(18);
  }
  // do something useful with the "p"
}
// no need to deallocate memory manually
```

在前面的代码块中，`p`引用（通常，垃圾收集语言中的引用类似于 C++中的指针）指的是`new`运算符返回的内存位置。自动垃圾收集器管理`new`运算符创建的对象的生命周期。它还跟踪对该对象的引用。每当对象没有引用时，垃圾收集器就会释放其空间。通过在 C++中使用 RAII 习惯用法，可以实现类似的功能。让我们看看它的实际应用。

# 利用 RAII 习惯用法

如前所述，RAII 习惯用法建议在初始化时获取资源。看看下面的类：

```cpp
template <typename T>
class ArrayManager {
public:
  ArrayManager(T* arr) : arr_{arr} {}
  ~ArrayManager() { delete[] arr_; }

  T& operator[](int ix) { return arr_[ix]; }

  T* raw() { return arr_; }
};
```

`print_sorted`函数现在可以使用`ArrayManager`来正确释放分配的数组：

```cpp
void print_sorted() {
 ArrayManager<short> arr{new short[420]};
  for (int ix = 0; ix < 420; ++ix) {
    std::cin >> arr[ix];
  }
  strange_sort::sort(arr.raw(), arr.raw() + 420);
  for (int ix = 0; ix < 420; ++ix) {
    std::cout << arr[ix];
  }
}
```

我们建议使用标准容器，如`std::vector`，而不是`ArrayManager`，尽管它是 RAII 应用的一个很好的例子：在初始化时获取资源。我们创建了一个`ArrayManager`的实例，并用内存资源对其进行了初始化。从那时起，我们可以忘记它的释放，因为实际的释放发生在`ArrayManager`的析构函数中。由于我们在堆栈上声明了`ArrayManager`实例，当函数返回或发生未捕获的异常时，它将被自动销毁，并且析构函数将被调用。

在这种情况下，使用标准容器是首选，因此让我们为单个指针实现 RAII 习惯用法。以下代码动态为`Product`实例分配内存：

```cpp
Product* apple{new Product};
apple->set_name("Red apple");
apple->set_price(0.42);
apple->set_available(true);
// use the apple
// don't forget to release the resource
delete apple;
```

如果我们将 RAII 习惯用法应用于前面的代码，它将在代码执行的适当点释放资源：

```cpp
ResourceManager<Product> res{new Product};
res->set_name("Red apple");
res->set_price(0.42);
res->set_available(true);
// use the res the way we use a Product
// no need to delete the res, it will automatically delete when gets out of the scope
```

`ResourceManager`类还应该重载运算符`*`和`->`，因为它必须像指针一样行为，以便正确获取和管理指针：

```cpp
template <typename T>
class ResourceManager {
public:
  ResourceManager(T* ptr) : ptr_{ptr} {}
  ~ResourceManager() { delete ptr_; }

 T& operator*() { return *ptr_; }
 T* operator->() { return ptr_; }
};
```

`ResourceManager`类关心 C++中的智能指针的概念。C++11 引入了几种类型的智能指针。我们将它们称为*智能*，是因为它们包装资源并管理其自动释放。这仅仅是因为当对象被设置为销毁时，对象的析构函数将被调用。也就是说，我们通过具有自动存储期的对象操作动态分配的空间。当处理程序对象超出范围时，其析构函数执行必要的操作以释放底层资源。

然而，智能指针可能带来额外的问题。在前面段落讨论的简单智能指针中，最终会出现几个问题。例如，我们没有处理`ResourceManager`的复制：

```cpp
void print_name(ResourceManager<Product> apple) {
  std::cout << apple->name();
}

ResourceManager<Product> res{new Product};
res->set_name("Red apple");
print_name(res);
res->set_price(0.42);
// ...
```

前面的代码会导致未定义的行为。以下图表显示了伪装的问题：

![](img/8a9ce9cc-43a7-4a58-a6f1-53b386cae052.png)

**res**和**apple**都获取了相同的资源。每当它们中的一个超出范围（**apple**），底层资源就会被释放，这会导致另一个`ResourceManager`实例拥有悬空指针。当另一个`ResourceManager`实例超出范围时，它将尝试两次删除指针。通常，程序员会意识到在特定情况下需要哪种智能指针。这就是为什么 C++提供了几种类型的智能指针，我们将进一步讨论。要在程序中使用它们，您应该导入`<memory>`头文件。

# std::unique_ptr

与我们之前实现的`ResourceManager`实例类似，`std::unique_ptr`代表了一个基本的智能指针。例如，要使用这个智能指针来管理`Product`对象，我们这样做：

```cpp
std::unique_ptr<Product> res{new Product};
res->set_name("Red apple");
// res will delete its acquired resource when goes out of scope
```

请注意我们如何访问`Product`成员函数`set_name`。我们将`res`对象视为具有类型`Pointer*`的东西。

`unique_ptr`之所以被称为 unique，是因为它提供了严格所有权的语义-它有责任销毁所获得的对象。更有趣的是，`unique_ptr`不能被复制。它没有复制构造函数或赋值运算符。这就是为什么它的**所有权**是*严格*的。当然，这并不意味着我们不能移动`unique_ptr`类。在这种情况下，我们完全将所有权转移到唯一指针的另一个实例。

智能指针的主要要求之一是保持它们的轻量级。我们肯定会同意这一点。虽然`unique_ptr`是一个完整的类，有几个成员函数，但它不会通过附加数据成员来“污染”。它只是一个围绕分配对象的原始指针的包装器。我们可以通过调用`unique_ptr`的`release()`成员函数来访问该原始指针，如下所示：

```cpp
Product* p = res.release();
// now we should delete p manually to deallocate memory
```

请注意，`release()`函数不会调用删除运算符。它只是归还所有权。调用`release()`函数后，`unique_ptr`不再拥有资源。要重用已拥有资源的`unique_ptr`，您应该使用`reset()`成员函数。它调用底层指针的删除运算符并“重置”唯一指针以供进一步使用。另一方面，如果要获取底层对象而不释放所有权，应该调用`get()`成员函数：

```cpp
std::unique_ptr<Product> up{new Product()};
Product* p = res.get();
// now p also points to the object managed by up
```

我们无法在以下情况中使用`unique_ptr`类，因为它无法被复制：

```cpp
// Don't do this
void print_name(std::unique_ptr<Product> apple) {
  std::cout << apple->name();
}
std::unique_ptr<Product> res{new Product};
res->set_name("Red apple");
print_name(res); // bad code
res->set_price(0.42);
// ...
```

然而，这并不是我们在前面的代码中寻找的。您可以将前面的代码视为糟糕的设计，因为它混淆了所有权细节。让我们继续讨论 C++中的下一个智能指针，它解决了将`unique_ptr`传递给函数的问题。

# std::shared_ptr 和 std::weak_ptr

我们需要一个提供*共享所有权*的智能指针。我们需要的东西在 C++11 中被引入，称为`std::shared_ptr`。实现具有共享所有权的智能指针更难，因为您应该注意正确释放资源。例如，当前面代码块中的`print_name()`函数完成其工作时，它的参数和局部对象将被销毁。销毁智能指针会导致所拥有的资源得到适当的释放。智能指针如何知道该资源是否仍然被另一个智能指针所拥有呢？其中一个流行的解决方案是保持对资源的引用计数。`shared_ptr`类也是如此：它保持指向底层对象的指针的数量，并在使用计数变为 0 时删除它。因此，几个共享指针可以拥有相同的对象。

现在，我们刚才讨论的示例应该重写如下：

```cpp
void print_name(std::shared_ptr<Product> apple) {
  std::cout << apple->name();
}
std::shared_ptr<Product> res{new Product};
res->set_name("Red apple");
print_name(res);
res->set_price(0.42);
// ...
```

调用`print_name()`函数后，共享指针的使用计数增加了 1。当函数完成其工作时，使用计数将减少 1，但托管对象不会被释放。这是因为`res`对象尚未超出范围。让我们稍微修改示例以打印对共享对象的引用计数：

```cpp
void print_name(std::shared_ptr<Product> apple) {
  std::cout << apple.use_count() << " eyes on the " << apple->name();
}

std::shared_ptr<Product> res{new Product};
res->set_name("Red apple");
std::cout << res.use_count() << std::endl;
print_name(res);
std::cout << res.use_count() << std::endl;
res->set_price(0.42);
// ...
```

前面的代码将在屏幕上打印如下内容：

```cpp
1
2 eyes on the Red apple
1
```

当最后一个`shared_ptr`超出范围时，它也会销毁底层对象。然而，在共享指针之间共享对象时，您应该小心。以下代码显示了共享所有权的一个明显问题：

```cpp
std::shared_ptr<Product> ptr1{new Product()};
Product* temp = ptr1.get();
if (true) {
  std::shared_ptr<Product> ptr2{temp};
  ptr2->set_name("Apple of truth");
}
ptr1->set_name("Peach"); // danger!
```

`ptr1`和`ptr2`都指向同一个对象，但它们彼此不知道。因此，当我们通过`ptr2`修改`Product`对象时，它会影响`ptr1`。当`ptr2`超出范围（在`if`语句之后）时，它将销毁底层对象，而该对象仍然被`ptr1`拥有。这是因为我们通过将原始的`temp`指针传递给它，使`ptr2`拥有了该对象。`ptr1`无法跟踪到这一点。

只能使用`std::shared_ptr`的复制构造函数或赋值运算符来共享所有权。这样，我们避免了如果它正在被另一个`shared_ptr`实例使用时删除对象。共享指针使用控制块实现共享所有权。每个共享指针持有两个指针，一个指向它管理的对象，一个指向控制块。控制块表示动态分配的空间，包含资源的使用计数。它还包含对于`shared_ptr`至关重要的其他几个东西，例如资源的`allocator`和`deleter`。我们将在下一节介绍分配器。`deleter`通常是常规的`delete`运算符。

控制块还包含弱引用的数量。这是因为所拥有的资源也可能被弱指针指向。`std::weak_ptr`是`std::shared_ptr`的小兄弟。它指的是由`shared_ptr`实例管理的对象，但并不拥有它。`weak_ptr`是一种访问和使用由`shared_ptr`拥有的资源而不拥有它的方法。然而，有一种方法可以使用`lock()`成员函数将`weak_ptr`实例转换为`shared_ptr`。

`unique_ptr`和`shared_ptr`都可以用于管理动态分配的数组。必须正确指定模板参数：

```cpp
std::shared_ptr<int[]> sh_arr{new int[42]};
sh_arr[11] = 44;
```

为了访问底层数组的元素，我们使用共享指针的`[]`运算符。还要注意，当在动态多态性中使用智能指针时，不会有缺点。例如，假设我们有以下类层次结构：

```cpp
struct Base
{
  virtual void test() { std::cout << "Base::test()" << std::endl; }
}; 

struct Derived : Base
{
  void test() override { std::cout << "Derived::test()" << std::endl; }
};
```

以下代码按预期工作，并将`Derived::test()`输出到屏幕上。

```cpp
std::unique_ptr<Base> ptr = std::make_unique_default_init<Derived>();
ptr->test();
```

尽管使用智能指针可能会破坏指针的美感，但建议大量使用智能指针以避免内存泄漏。然而，值得注意的是，用`unique_ptr`或`shared_ptr`指针替换所有指针，也无法解决所有内存泄漏问题。它们也有缺点。在应用它们解决问题之前，考虑一种平衡的方法，或者更好地彻底了解问题和智能指针本身的细节。

在 C++程序中管理内存是有代价的。我们讨论的最重要的事情是正确释放内存空间。该语言不支持自动内存释放，但值得一提的是垃圾收集器。然而，要有一个完整的垃圾收集器，我们需要语言级别的支持。C++没有提供任何支持。让我们尝试在 C++中模拟垃圾收集器。

# 垃圾收集

垃圾收集器通常是可解释语言的运行时环境中的一个单独模块。例如，C#和 Java 都有垃圾收集器，这使得程序员的生活变得更加轻松。垃圾收集器跟踪代码中的所有对象分配，并在它们不再使用时释放。它被称为**垃圾收集器**，因为它在使用后删除内存资源：它收集程序员留下的垃圾。

据说 C++程序员不会留下垃圾，这就是为什么该语言不支持垃圾收集器的原因。尽管程序员倾向于辩护该语言，称其之所以没有垃圾收集器是因为它是一种快速的语言，但事实是它可以在没有垃圾收集器的情况下生存。

像 C#这样的语言将程序编译成中间字节码表示，然后由运行时环境解释和执行。垃圾收集器是环境的一部分，并且积极跟踪所有对象分配。它是一个复杂的机制，尽最大努力在合理的时间内管理内存。以下图表描述了典型的运行时环境，该环境分配由垃圾收集器监督的内存：

![](img/2421ee02-8ebd-4784-8109-1c53318b8124.png)

即使使用智能指针，我们仍然需要手动调用`delete`运算符来释放 C++中的内存空间。智能指针只是在获取对象时获取对象，并在对象超出范围时删除对象。关键点是，即使智能指针引入了一些半自动行为，它们仍然表现得好像程序员没有忘记在代码的指定点释放资源。垃圾收集器会自动执行这些操作，并通常使用单独的执行线程。它尽力不要减慢实际程序执行速度。

一些垃圾收集实现技术包括根据对象的生命周期持续时间对对象进行分类。分类使垃圾收集器访问对象并在对象不再使用时释放内存空间。为了加快这个过程，应该更频繁地访问生命周期短的对象，而不是生命周期长的对象。例如，考虑以下代码：

```cpp
struct Garbage {
  char ch;
  int i;
};

void foo() {
  Garbage* g1 = new Garbage();
  if (true) {
    Garbage* g2 = new Garbage();
  }
}

int main() {
  static Garbage* g3 = new Garbage();
}
```

如果 C++有垃圾收集器，那么对象`g1`、`g2`和`g3`将在程序执行的不同时间段被删除。如果垃圾收集器根据它们的生命周期持续时间对它们进行分类，那么`g2`的生命周期将是最短的，并且应该首先被访问以释放它。

要真正在 C++中实现垃圾收集器，我们应该将其作为程序的一部分。垃圾收集器应该首先负责分配内存来跟踪并删除它：

```cpp
class GarbageCollector {
public:
 template <typename T>
 static T* allocate() { 
   T* ptr{new T()};
 objects_[ptr] = true;
   return ptr;
 }

 static void deallocate(T* p) {
   if (objects_[p]) {
     objects_[p] = false;
     delete p;
   }
 } private:
 std::unordered_map<T*, bool> objects_;
};
```

前面的类通过静态的`allocate()`函数跟踪通过分配的对象。如果对象正在使用，则通过`deallocate()`函数删除它。以下是`GarbageCollector`的使用方法：

```cpp
int* ptr = GarbageCollector::allocate<int>();
*ptr = 42;
GarbageCollector::deallocate(ptr);
```

实际上，这个类使得内存管理比智能指针稍微困难一些。基本上，在 C++中没有必要实现垃圾收集器，因为智能指针几乎可以处理关于*自动*内存释放的任何情况。

然而，让我们看看一种技巧，它将允许垃圾收集器正确释放某个指针指向的空间。在我们最简单的前面的实现中，我们跟踪了我们提供给用户的所有指针。每个指针指向堆上的一些空间，应该在程序执行的某个时刻被释放。在`GarbageCollector`中，我们将使用标准的`delete`运算符。问题是，它如何知道应该释放多少字节？看看下面的例子：

```cpp
Student* ptr = new Student;
int* ip = new int{42};
// do something with ptr and ip
delete ptr;
delete ip;
```

假设一个`Student`实例占用 40 个字节的内存，一个整数占用 4 个字节。我们应该以某种方式将这些信息传递给删除运算符。在前面的代码中，我们删除了`ptr`和`ip`，它们分别指向不同大小的内存空间。那么它如何知道在`ptr`的情况下应该将 40 个字节标记为自由，而在`ip`的情况下应该将 4 个字节标记为自由？对于这个问题有不止一种解决方案，让我们看看其中一种。

每当我们分配内存时，`new`运算符将分配空间的大小放在实际内存空间之前，如下图所示：

![](img/10cfb979-45e6-41f9-9d2f-7fcb0fff9408.png)

这些信息然后被`delete`运算符使用，它通过读取内存空间之前放置的相应字节来读取内存空间的大小。C++的一个主要关注点是管理数据集合的内存。STL 容器，如`std::vector`和`std::list`，在第六章中描述的《深入 STL 中的数据结构和算法》中，对处理内存有不同的模型。默认情况下，容器有一个指定的内存分配器，用于处理容器元素的内存分配和释放。让我们更详细地了解一下分配器。

# 使用分配器

分配器的理念是为容器内存管理提供控制。简单来说，分配器是 C++容器的高级垃圾收集器。虽然我们在容器内存管理范围内讨论分配器，但您肯定可以将这个想法扩展到通用的垃圾收集器。在本节的开头，我们实现了一个设计不良的垃圾收集器。当研究分配器时，您会发现`GarbageCollector`类和 C++中的默认分配器之间有很多相似之处。默认分配器在`<memory>`中定义，它有两个基本函数-`allocate()`和`deallocate()`。`allocate()`函数定义如下：

```cpp
[[nodiscard]] constexpr T* allocate(std::size_t num);
```

`allocate()`函数获取类型为`T`的`num`个对象的空间。注意`[[nodiscard]]`属性-这意味着调用者不应该丢弃返回值。否则，编译器将打印警告消息。

让我们使用分配器为五个整数获取空间：

```cpp
import <memory>;

int main()
{
  std::allocator<int> IntAlloc;
  int* ptr = IntAlloc.allocate(5);
  // construct an integer at the second position
 std::allocator_traits<IntAlloc>::construct(IntAlloc, ptr + 1, 42);
  IntAlloc.deallocate(ptr, 5); // deallocate all
}
```

注意我们如何使用`std::allocator_traits`在分配的空间中构造对象。下图显示了

`deallocate()`函数定义如下：

```cpp
constexpr void deallocate(T* p, std::size_t n)
```

在上一个代码片段中，我们使用`allocate()`函数返回的指针来调用`deallocate()`函数。

您可能不会直接在项目中使用分配器，但是每当您需要自定义内存管理行为时，使用现有的或引入新的分配器可能会有所帮助。STL 容器主要使用分配器，因为它们在结构和行为上有所不同，这导致需要为内存分配和释放具有专门的行为。我们将在下一章更详细地讨论 STL 容器。

# 总结

像 C#这样的语言中的垃圾收集器是由环境提供的。它们与用户程序并行工作，并在程序看起来有效时尝试清理。我们无法在 C++中做同样的事情；我们能做的只是在程序中直接实现垃圾收集器，提供一种半自动的方式来释放已使用的内存资源。自 C++11 以来，这种机制已经得到了语言中智能指针的适当覆盖。

内存管理是每个计算机程序的关键组成部分之一。程序应该能够在执行过程中动态请求内存。优秀的程序员了解内存管理的内部细节。这有助于他们设计和实现性能更好的应用程序。虽然手动内存管理被认为是一种优势，但在较大的应用程序中往往变得痛苦。在本章中，我们已经学会了如何通过智能指针避免错误并处理内存释放。有了这种基本的理解，您应该对设计避免内存泄漏的程序更有信心。

在下一章中，我们将学习 STL，重点关注数据结构和算法，并深入研究它们的 STL 实现。除了比较数据结构和算法，我们还将介绍 C++20 中一个显著的新特性：概念。

# 问题

1.  解释计算机内存。

1.  什么是虚拟内存？

1.  用于内存分配和释放的运算符是哪些？

1.  `delete`和`delete[]`之间有什么区别？

1.  什么是垃圾收集器，为什么 C++不支持垃圾收集器？

# 进一步阅读

有关更多信息，请参阅以下链接：

+   每个程序员都应该了解的关于内存的知识，作者乌尔里希·德雷珀，网址为[`people.freebsd.org/~lstewart/articles/cpumemory.pdf`](https://people.freebsd.org/~lstewart/articles/cpumemory.pdf)

+   《代码：计算机硬件和软件的隐藏语言》，作者查尔斯·佩兹德，网址为[`www.amazon.com/Code-Language-Computer-Hardware-Software/dp/0735611319/`](https://www.amazon.com/Code-Language-Computer-Hardware-Software/dp/0735611319/)
