["```cpp\nclass C_Position : public C_Base{ \npublic: \n  C_Position(): C_Base(Component::Position), m_elevation(0){} \n\n  void ReadIn(std::stringstream& l_stream){ \n    l_stream >> m_position.x >> m_position.y >> m_elevation; \n  } \n\n  sf::Vector2f GetPosition() const { ... } \n  sf::Vector2f GetOldPosition() const { ... } \n  unsigned int GetElevation() const { ... } \n  void SetPosition(float l_x, float l_y){ ... } \n  void SetPosition(const sf::Vector2f& l_vec){ ... } \n  void SetElevation(unsigned int l_elevation){ ... } \n  void MoveBy(float l_x, float l_y){ ... } \n  void MoveBy(const sf::Vector2f& l_vec){ ... } \nprivate: \n  sf::Vector2f m_position; \n  sf::Vector2f m_positionOld; \n  unsigned int m_elevation; \n}; \n\n```", "```cpp\nclass C_Drawable : public C_Base{ \npublic: \n  C_Drawable(const Component& l_type) : C_Base(l_type){} \n  virtual ~C_Drawable(){} \n\n  virtual void UpdatePosition(const sf::Vector2f& l_vec) = 0; \n  virtual sf::Vector2u GetSize() const = 0; \n  virtual void Draw(sf::RenderWindow* l_wind) = 0; \n}; \n\n```", "```cpp\nclass C_SpriteSheet : public C_Drawable{ \npublic: \n  C_SpriteSheet(): C_Drawable(Component::SpriteSheet), \n    m_spriteSheet(nullptr){} \n\n  void ReadIn(std::stringstream& l_stream){l_stream>>m_sheetName;} \n  void Create(TextureManager* l_textureMgr, \n    const std::string& l_name = \"\") \n  { \n    if (m_spriteSheet) { m_spriteSheet.release(); } \n    m_spriteSheet = std::make_unique<SpriteSheet>(l_textureMgr); \n    m_spriteSheet->LoadSheet(\"media/Spritesheets/\" + \n      (!l_name.empty() ? l_name : m_sheetName) + \".sheet\"); \n  } \n\n  SpriteSheet* GetSpriteSheet(){ ... } \n  void UpdatePosition(const sf::Vector2f& l_vec){ ... } \n  sf::Vector2u GetSize() const { ... } \n  void Draw(sf::RenderWindow* l_wind){ ... } \nprivate: \n  std::unique_ptr<SpriteSheet> m_spriteSheet; \n  std::string m_sheetName; \n}; \n\n```", "```cpp\nS_Renderer::S_Renderer(SystemManager* l_systemMgr) \n  :S_Base(System::Renderer, l_systemMgr) \n{ \n  Bitmask req; \n  req.TurnOnBit((unsigned int)Component::Position); \n  req.TurnOnBit((unsigned int)Component::SpriteSheet); \n  m_requiredComponents.push_back(req); \n  req.Clear(); \n\n  m_drawableTypes.TurnOnBit((unsigned int)Component::SpriteSheet); \n  // Other types... \n\n  m_systemManager->GetMessageHandler()-> \n    Subscribe(EntityMessage::Direction_Changed,this); \n} \n\n```", "```cpp\nvoid S_Renderer::Update(float l_dT){ \n  EntityManager* entities = m_systemManager->GetEntityManager(); \n  for(auto &entity : m_entities) \n  { \n    auto position = entities-> \n      GetComponent<C_Position>(entity, Component::Position); \n    C_Drawable* drawable = GetDrawableFromType(entity); \n    if (!drawable) { continue; } \n    drawable->UpdatePosition(position->GetPosition()); \n  } \n} \n\n```", "```cpp\nvoid S_Renderer::HandleEvent(const EntityId& l_entity, \n  const EntityEvent& l_event) \n{ \n  if (l_event == EntityEvent::Moving_Left || \n    l_event == EntityEvent::Moving_Right || \n    l_event == EntityEvent::Moving_Up || \n    l_event == EntityEvent::Moving_Down || \n    l_event == EntityEvent::Elevation_Change || \n    l_event == EntityEvent::Spawned) \n  { \n    SortDrawables(); \n  } \n} \n\n```", "```cpp\nvoid S_Renderer::Notify(const Message& l_message){ \n  if(HasEntity(l_message.m_receiver)){ \n    EntityMessage m=static_cast<EntityMessage>(l_message.m_type); \n    switch(m){ \n    case EntityMessage::Direction_Changed:  \n      SetSheetDirection(l_message.m_receiver, \n        (Direction)l_message.m_int); \n      break; \n    } \n  } \n} \n\n```", "```cpp\nvoid S_Renderer::Render(Window* l_wind, unsigned int l_layer) \n{ \n  EntityManager* entities = m_systemManager->GetEntityManager(); \n  for(auto &entity : m_entities){ \n    auto position = entities-> \n      GetComponent<C_Position>(entity, Component::Position); \n    if(position->GetElevation() < l_layer){ continue; } \n    if(position->GetElevation() > l_layer){ break; } \n    C_Drawable* drawable = GetDrawableFromType(entity); \n    if (!drawable) { continue; } \n    sf::FloatRect drawableBounds; \n    drawableBounds.left = position->GetPosition().x - \n      (drawable->GetSize().x / 2); \n    drawableBounds.top = position->GetPosition().y - \n      drawable->GetSize().y; \n    drawableBounds.width = \n      static_cast<float>(drawable->GetSize().x); \n    drawableBounds.height = \n      static_cast<float>(drawable->GetSize().y); \n    if (!l_wind->GetViewSpace().intersects(drawableBounds)){ \n      continue; \n    } \n    drawable->Draw(l_wind->GetRenderWindow()); \n  } \n} \n\n```", "```cpp\nvoid S_Renderer::SetSheetDirection(const EntityId& l_entity, \n  const Direction& l_dir) \n{ \n  EntityManager* entities = m_systemManager->GetEntityManager(); \n  if (!entities->HasComponent(l_entity, Component::SpriteSheet)) \n  { return; } \n  auto sheet = entities-> \n    GetComponent<C_SpriteSheet>(l_entity,Component::SpriteSheet); \n  sheet->GetSpriteSheet()->SetDirection(l_dir); \n} \n\n```", "```cpp\nvoid S_Renderer::SortDrawables(){ \n  EntityManager* e_mgr = m_systemManager->GetEntityManager(); \n  std::sort(m_entities.begin(), m_entities.end(), \n    [e_mgr](unsigned int l_1, unsigned int l_2) \n  { \n    auto pos1 = e_mgr-> \n      GetComponent<C_Position>(l_1, Component::Position); \n    auto pos2 = e_mgr-> \n      GetComponent<C_Position>(l_2, Component::Position); \n    if (pos1->GetElevation() == pos2->GetElevation()){ \n      return pos1->GetPosition().y < pos2->GetPosition().y; \n    } \n    return pos1->GetElevation() < pos2->GetElevation(); \n  }); \n} \n\n```", "```cpp\nC_Drawable* S_Renderer::GetDrawableFromType( \n  const EntityId& l_entity) \n{ \n  auto entities = m_systemManager->GetEntityManager(); \n  for (size_t i = 0; i < static_cast<size_t>(Component::COUNT); \n    ++i) \n  { \n    if (!m_drawableTypes.GetBit(i)) { continue; } \n    auto component = static_cast<Component>(i); \n    if (!entities->HasComponent(l_entity, component)){ continue; } \n    return entities->GetComponent<C_Drawable>(l_entity,component); \n  } \n  return nullptr; \n} \n\n```", "```cpp\nclass C_Movable : public C_Base{ \npublic: \n  C_Movable() : C_Base(Component::Movable), \n    m_velocityMax(0.f), m_direction((Direction)0){} \n\n  void ReadIn(std::stringstream& l_stream){ \n    l_stream >> m_velocityMax >> m_speed.x >> m_speed.y; \n    unsigned int dir = 0; \n    l_stream >> dir; \n    m_direction = static_cast<Direction>(dir); \n  } \n  ... \n  void SetVelocity(const sf::Vector2f& l_vec){ ... } \n  void SetMaxVelocity(float l_vel){ ... } \n  void SetSpeed(const sf::Vector2f& l_vec){ ... } \n  void SetAcceleration(const sf::Vector2f& l_vec){ ... } \n  void SetDirection(const Direction& l_dir){ ... } \n  void AddVelocity(const sf::Vector2f& l_vec){ ... } \n  void ApplyFriction(const sf::Vector2f& l_vec){ ... } \n  void Accelerate(const sf::Vector2f& l_vec){ ... } \n  void Accelerate(float l_x, float l_y){ ... } \n  void Move(const Direction& l_dir){ ... } \nprivate: \n  sf::Vector2f m_velocity; \n  sf::Vector2f m_speed; \n  sf::Vector2f m_acceleration; \n  float m_velocityMax; \n  Direction m_direction; \n}; \n\n```", "```cpp\nS_Movement::S_Movement(SystemManager* l_systemMgr)  \n  : S_Base(System::Movement,l_systemMgr) \n{ \n  Bitmask req; \n  req.TurnOnBit((unsigned int)Component::Position); \n  req.TurnOnBit((unsigned int)Component::Movable); \n  m_requiredComponents.push_back(req); \n  req.Clear(); \n\n  m_systemManager->GetMessageHandler()-> \n    Subscribe(EntityMessage::Is_Moving,this); \n\n  m_gameMap = nullptr; \n} \n\n```", "```cpp\nvoid S_Movement::Update(float l_dT){ \n  if (!m_gameMap){ return; } \n  EntityManager* entities = m_systemManager->GetEntityManager(); \n  for(auto &entity : m_entities){ \n    auto position = entities-> \n      GetComponent<C_Position>(entity, Component::Position); \n    auto movable = entities-> \n      GetComponent<C_Movable>(entity, Component::Movable); \n    MovementStep(l_dT, movable, position); \n    position->MoveBy(movable->GetVelocity() * l_dT); \n  } \n} \n\n```", "```cpp\nvoid S_Movement::HandleEvent(const EntityId& l_entity,  \n  const EntityEvent& l_event) \n{ \n  switch(l_event){ \n  case EntityEvent::Colliding_X: \n    StopEntity(l_entity, Axis::x); break; \n  case EntityEvent::Colliding_Y: \n    StopEntity(l_entity, Axis::y); break; \n  case EntityEvent::Moving_Left: \n    SetDirection(l_entity, Direction::Left); break; \n  case EntityEvent::Moving_Right: \n    SetDirection(l_entity, Direction::Right); break; \n  case EntityEvent::Moving_Up: \n    { \n      auto mov = m_systemManager->GetEntityManager()-> \n        GetComponent<C_Movable>(l_entity,Component::Movable); \n      if(mov->GetVelocity().x == 0){ \n        SetDirection(l_entity, Direction::Up); \n      } \n    } \n    break; \n  case EntityEvent::Moving_Down: \n    { \n      auto mov = m_systemManager->GetEntityManager()-> \n        GetComponent<C_Movable>(l_entity,Component::Movable); \n      if(mov->GetVelocity().x == 0){ \n        SetDirection(l_entity, Direction::Down); \n      } \n    } \n    break; \n  } \n} \n\n```", "```cpp\nvoid S_Movement::Notify(const Message& l_message){ \n  EntityManager* eMgr = m_systemManager->GetEntityManager(); \n  EntityMessage m = static_cast<EntityMessage>(l_message.m_type); \n  switch(m){ \n  case EntityMessage::Is_Moving: \n    { \n    if (!HasEntity(l_message.m_receiver)){ return; } \n    auto movable = eMgr-> \n     GetComponent<C_Movable>(l_message.m_receiver, \n     Component::Movable); \n    if (movable->GetVelocity() != sf::Vector2f(0.f, 0.f)){return;} \n    m_systemManager->AddEvent(l_message.m_receiver, \n      (EventID)EntityEvent::Became_Idle); \n    } \n    break; \n  } \n} \n\n```", "```cpp\nsf::Vector2f S_Movement::GetTileFriction(unsigned int l_elevation, \n  unsigned int l_x, unsigned int l_y) \n{ \n  Tile* t = nullptr; \n  while (!t && l_elevation >= 0){ \n    t = m_gameMap->GetTile(l_x, l_y, l_elevation); \n    --l_elevation; \n  } \n\n  return(t ? t->m_properties->m_friction : \n    m_gameMap->GetDefaultTile()->m_friction); \n} \n\n```", "```cpp\nvoid S_Movement::MovementStep(float l_dT, C_Movable* l_movable, \n  const C_Position* l_position) \n{ \n  sf::Vector2f f_coefficient = GetTileFriction( \n    l_position->GetElevation(), \n    static_cast<unsigned int>(floor(l_position->GetPosition().x / \n      Sheet::Tile_Size)), \n    static_cast<unsigned int>(floor(l_position->GetPosition().y / \n      Sheet::Tile_Size))); \n\n  sf::Vector2f friction(l_movable->GetSpeed().x * f_coefficient.x, \n    l_movable->GetSpeed().y * f_coefficient.y); \n\n  l_movable->AddVelocity(l_movable->GetAcceleration() * l_dT); \n  l_movable->SetAcceleration(sf::Vector2f(0.0f, 0.0f)); \n  l_movable->ApplyFriction(friction * l_dT); \n\n  float magnitude = sqrt( \n    (l_movable->GetVelocity().x * l_movable->GetVelocity().x) + \n    (l_movable->GetVelocity().y * l_movable->GetVelocity().y)); \n\n  if (magnitude <= l_movable->GetMaxVelocity()){ return; } \n  float max_V = l_movable->GetMaxVelocity(); \n  l_movable->SetVelocity(sf::Vector2f( \n    (l_movable->GetVelocity().x / magnitude) * max_V, \n    (l_movable->GetVelocity().y / magnitude) * max_V)); \n} \n\n```", "```cpp\nvoid S_Movement::StopEntity(const EntityId& l_entity,  \n  const Axis& l_axis) \n{ \n  auto movable = m_systemManager->GetEntityManager()-> \n    GetComponent<C_Movable>(l_entity,Component::Movable); \n  if(l_axis == Axis::x){ \n    movable->SetVelocity(sf::Vector2f( \n      0.f, movable->GetVelocity().y)); \n  } else if(l_axis == Axis::y){ \n    movable->SetVelocity(sf::Vector2f( \n      movable->GetVelocity().x, 0.f)); \n  } \n} \n\n```", "```cpp\nvoid S_Movement::SetDirection(const EntityId& l_entity,  \n  const Direction& l_dir) \n{ \n  auto movable = m_systemManager->GetEntityManager()-> \n    GetComponent<C_Movable>(l_entity,Component::Movable); \n  movable->SetDirection(l_dir); \n\n  Message msg((MessageType)EntityMessage::Direction_Changed); \n  msg.m_receiver = l_entity; \n  msg.m_int = static_cast<int>(l_dir); \n  m_systemManager->GetMessageHandler()->Dispatch(msg); \n} \n\n```", "```cpp\nenum class Origin{ Top_Left, Abs_Centre, Mid_Bottom }; \n\n```", "```cpp\nclass C_Collidable : public C_Base{ \npublic: \n  C_Collidable(): C_Base(Component::Collidable),  \n    m_origin(Origin::Mid_Bottom), m_collidingOnX(false), \n    m_collidingOnY(false){} \n\n  void ReadIn(std::stringstream& l_stream){ \n    unsigned int origin = 0; \n    l_stream >> m_AABB.width >> m_AABB.height >> m_offset.x \n      >> m_offset.y >> origin; \n    m_origin = static_cast<Origin>(origin); \n  } \n\n  const sf::FloatRect& GetCollidable() const { ... } \n  bool IsCollidingOnX() const { ... } \n  bool IsCollidingOnY() const { ... } \n  void CollideOnX(){ m_collidingOnX = true; } \n  void CollideOnY(){ m_collidingOnY = true; } \n  void ResetCollisionFlags(){ ... } \n  void SetCollidable(const sf::FloatRect& l_rect){ ... } \n  void SetOrigin(const Origin& l_origin){ ... } \n  void SetSize(const sf::Vector2f& l_vec){ ... } \n\n  void SetPosition(const sf::Vector2f& l_vec){ \n    switch(m_origin){ \n    case(Origin::Top_Left) : \n      m_AABB.left    = l_vec.x + m_offset.x; \n      m_AABB.top     = l_vec.y + m_offset.y; \n      break; \n    case(Origin::Abs_Centre): \n      m_AABB.left    = l_vec.x - (m_AABB.width / 2) + m_offset.x; \n      m_AABB.top     = l_vec.y - (m_AABB.height / 2) + m_offset.y; \n      break; \n    case(Origin::Mid_Bottom): \n      m_AABB.left    = l_vec.x - (m_AABB.width / 2) + m_offset.x; \n      m_AABB.top     = l_vec.y - m_AABB.height + m_offset.y; \n      break; \n    } \n  } \nprivate: \n  sf::FloatRect m_AABB; \n  sf::Vector2f m_offset; \n  Origin m_origin; \n\n  bool m_collidingOnX; \n  bool m_collidingOnY; \n}; \n\n```", "```cpp\nS_Collision::S_Collision(SystemManager* l_systemMgr)  \n  : S_Base(System::Collision,l_systemMgr) \n{ \n  Bitmask req; \n  req.TurnOnBit((unsigned int)Component::Position); \n  req.TurnOnBit((unsigned int)Component::Collidable); \n  m_requiredComponents.push_back(req); \n  req.Clear(); \n\n  m_gameMap = nullptr; \n} \n\n```", "```cpp\nvoid S_Collision::Update(float l_dT){ \n  if (!m_gameMap){ return; } \n  EntityManager* entities = m_systemManager->GetEntityManager(); \n  for(auto &entity : m_entities){ \n    auto position = entities-> \n      GetComponent<C_Position>(entity, Component::Position); \n    auto collidable = entities-> \n      GetComponent<C_Collidable>(entity, Component::Collidable); \n\n    CheckOutOfBounds(position); \n    collidable->SetPosition(position->GetPosition()); \n    collidable->ResetCollisionFlags(); \n    MapCollisions(entity, position, collidable); \n  } \n  EntityCollisions(); \n} \n\n```", "```cpp\nvoid S_Collision::EntityCollisions(){ \n  EntityManager* entities = m_systemManager->GetEntityManager(); \n  for(auto itr = m_entities.begin(); itr!=m_entities.end(); ++itr) \n  { \n    for(auto itr2=std::next(itr); itr2!=m_entities.end(); ++itr2){ \n      auto collidable1 = entities-> \n        GetComponent<C_Collidable>(*itr, Component::Collidable); \n      auto collidable2 = entities-> \n        GetComponent<C_Collidable>(*itr2, Component::Collidable); \n      if(collidable1->GetCollidable().intersects( \n        collidable2->GetCollidable())) \n      { \n        // Entity-on-entity collision! \n      } \n    } \n  } \n} \n\n```", "```cpp\nvoid S_Collision::CheckOutOfBounds(C_Position* l_pos){ \n  unsigned int TileSize = m_gameMap->GetTileSize(); \n\n  if (l_pos->GetPosition().x < 0){ \n    l_pos->SetPosition(0.0f, l_pos->GetPosition().y); \n  } else if (l_pos->GetPosition().x > \n    m_gameMap->GetMapSize().x * TileSize) \n  { \n    l_pos->SetPosition( \n      static_cast<float>(m_gameMap->GetMapSize().x * TileSize), \n      l_pos->GetPosition().y); \n  } \n\n  if (l_pos->GetPosition().y < 0){ \n    l_pos->SetPosition(l_pos->GetPosition().x, 0.0f); \n  } else if (l_pos->GetPosition().y > \n    m_gameMap->GetMapSize().y * TileSize) \n  { \n    l_pos->SetPosition( \n      l_pos->GetPosition().x, \n      static_cast<float>(m_gameMap->GetMapSize().y * TileSize)); \n  } \n} \n\n```", "```cpp\nvoid S_Collision::MapCollisions(const EntityId& l_entity, \n  C_Position* l_pos, C_Collidable* l_col) \n{ \n  Collisions c; \n  CheckCollisions(l_pos, l_col, c); \n  HandleCollisions(l_entity, l_pos, l_col, c); \n} \n\n```", "```cpp\nstruct CollisionElement{ \n  CollisionElement(float l_area, TileInfo* l_info, \n    const sf::FloatRect& l_bounds):m_area(l_area), m_tile(l_info), \n    m_tileBounds(l_bounds){} \n  float m_area; \n  TileInfo* m_tile; \n  sf::FloatRect m_tileBounds; \n}; \n\nusing Collisions = std::vector<CollisionElement>; \n\n```", "```cpp\nvoid S_Collision::CheckCollisions(C_Position* l_pos, \n  C_Collidable* l_col, Collisions& l_collisions) \n{ \n  unsigned int TileSize = m_gameMap->GetTileSize(); \n  sf::FloatRect EntityAABB = l_col->GetCollidable(); \n  int FromX = static_cast<int>(floor(EntityAABB.left / TileSize)); \n  int ToX = static_cast<int>(floor((EntityAABB.left + \n    EntityAABB.width) / TileSize)); \n  int FromY = static_cast<int>(floor(EntityAABB.top / TileSize)); \n  int ToY = static_cast<int>(floor((EntityAABB.top + \n    EntityAABB.height) / TileSize)); \n\n  for (int x = FromX; x <= ToX; ++x) { \n    for (int y = FromY; y <= ToY; ++y) { \n      for (size_t l = l_pos->GetElevation(); l < \n        l_pos->GetElevation() + 1; ++l) \n      { \n        auto t = m_gameMap->GetTile(x, y, l); \n        if (!t) { continue; } \n        if (!t->m_solid) { continue; } \n        sf::FloatRect TileAABB = static_cast<sf::FloatRect>( \n          sf::IntRect(x*TileSize, y*TileSize,TileSize,TileSize)); \n        sf::FloatRect Intersection; \n        EntityAABB.intersects(TileAABB, Intersection); \n        float S = Intersection.width * Intersection.height; \n        l_collisions.emplace_back(S, t->m_properties, TileAABB); \n        break; \n      } \n    } \n  } \n} \n\n```", "```cpp\nvoid S_Collision::HandleCollisions(const EntityId& l_entity, \n  C_Position* l_pos, C_Collidable* l_col,Collisions& l_collisions) \n{ \n  sf::FloatRect EntityAABB = l_col->GetCollidable(); \n  unsigned int TileSize = m_gameMap->GetTileSize(); \n\n  if (l_collisions.empty()) { return; } \n  std::sort(l_collisions.begin(), l_collisions.end(), \n    [](CollisionElement& l_1, CollisionElement& l_2) { \n      return l_1.m_area > l_2.m_area; \n    } \n  ); \n\n  for (auto &col : l_collisions) { \n    EntityAABB = l_col->GetCollidable(); \n    if (!EntityAABB.intersects(col.m_tileBounds)) { continue; } \n    float xDiff = (EntityAABB.left + (EntityAABB.width / 2)) - \n      (col.m_tileBounds.left + (col.m_tileBounds.width / 2)); \n    float yDiff = (EntityAABB.top + (EntityAABB.height / 2)) - \n      (col.m_tileBounds.top + (col.m_tileBounds.height / 2)); \n    float resolve = 0; \n    if (std::abs(xDiff) > std::abs(yDiff)) { \n      if (xDiff > 0) { \n        resolve=(col.m_tileBounds.left+TileSize)-EntityAABB.left; \n      } else { \n        resolve = -((EntityAABB.left + EntityAABB.width) - \n          col.m_tileBounds.left); \n      } \n      l_pos->MoveBy(resolve, 0); \n      l_col->SetPosition(l_pos->GetPosition()); \n      m_systemManager->AddEvent( \n        l_entity, (EventID)EntityEvent::Colliding_X); \n      l_col->CollideOnX(); \n    } else { \n      if (yDiff > 0) { \n        resolve=(col.m_tileBounds.top + TileSize)-EntityAABB.top; \n      } else { \n        resolve = -((EntityAABB.top + EntityAABB.height) - \n          col.m_tileBounds.top); \n      } \n      l_pos->MoveBy(0, resolve); \n      l_col->SetPosition(l_pos->GetPosition()); \n      m_systemManager->AddEvent( \n        l_entity, (EventID)EntityEvent::Colliding_Y); \n      l_col->CollideOnY(); \n    } \n  } \n} \n\n```", "```cpp\nclass C_Controller : public C_Base{ \npublic: \n  C_Controller() : C_Base(Component::Controller){} \n  void ReadIn(std::stringstream& l_stream){} \n}; \n\n```", "```cpp\nS_Control::S_Control(SystemManager* l_systemMgr) \n  : S_Base(System::Control,l_systemMgr) \n{ \n  Bitmask req; \n  req.TurnOnBit((unsigned int)Component::Position); \n  req.TurnOnBit((unsigned int)Component::Movable); \n  req.TurnOnBit((unsigned int)Component::Controller); \n  m_requiredComponents.push_back(req); \n  req.Clear(); \n} \n\n```", "```cpp\nvoid S_Control::HandleEvent(const EntityId& l_entity,  \n  const EntityEvent& l_event) \n{ \n  switch(l_event){ \n  case EntityEvent::Moving_Left: \n    MoveEntity(l_entity, Direction::Left); break; \n  case EntityEvent::Moving_Right: \n    MoveEntity(l_entity, Direction::Right); break; \n  case EntityEvent::Moving_Up: \n    MoveEntity(l_entity, Direction::Up); break; \n  case EntityEvent::Moving_Down: \n    MoveEntity(l_entity, Direction::Down); break; \n  } \n} \n\n```", "```cpp\nvoid S_Control::MoveEntity(const EntityId& l_entity,  \n  const Direction& l_dir) \n{ \n  auto mov = m_systemManager->GetEntityManager()-> \n    GetComponent<C_Movable>(l_entity, Component::Movable); \n  mov->Move(l_dir); \n} \n\n```", "```cpp\nenum class EntityState{ Idle, Walking, Attacking, Hurt, Dying }; \n\nclass C_State : public C_Base{ \npublic: \n  C_State(): C_Base(Component::State){} \n  void ReadIn(std::stringstream& l_stream){ \n    unsigned int state = 0; \n    l_stream >> state; \n    m_state = static_cast<EntityState>(state); \n  } \n\n  EntityState GetState() const { ... } \n  void SetState(const EntityState& l_state){ ... } \nprivate: \n  EntityState m_state; \n}; \n\n```", "```cpp\nS_State::S_State(SystemManager* l_systemMgr) \n  : S_Base(System::State,l_systemMgr) \n{ \n  Bitmask req; \n  req.TurnOnBit((unsigned int)Component::State); \n  m_requiredComponents.push_back(req); \n\n  m_systemManager->GetMessageHandler()-> \n    Subscribe(EntityMessage::Move,this); \n  m_systemManager->GetMessageHandler()-> \n    Subscribe(EntityMessage::Switch_State,this); \n} \n\n```", "```cpp\nvoid S_State::Update(float l_dT){ \n  EntityManager* entities = m_systemManager->GetEntityManager(); \n  for(auto &entity : m_entities){ \n    auto state = entities-> \n      GetComponent<C_State>(entity, Component::State); \n    if(state->GetState() == EntityState::Walking){ \n      Message msg((MessageType)EntityMessage::Is_Moving); \n      msg.m_receiver = entity; \n      m_systemManager->GetMessageHandler()->Dispatch(msg); \n    } \n  } \n} \n\n```", "```cpp\nvoid S_State::HandleEvent(const EntityId& l_entity, \n  const EntityEvent& l_event) \n{ \n  switch(l_event){ \n  case EntityEvent::Became_Idle: \n    ChangeState(l_entity,EntityState::Idle,false); \n    break; \n  } \n} \n\n```", "```cpp\nvoid S_State::Notify(const Message& l_message){ \n  if (!HasEntity(l_message.m_receiver)){ return; } \n  EntityMessage m = static_cast<EntityMessage>(l_message.m_type); \n  switch(m){ \n  case EntityMessage::Move: \n    { \n      auto state = m_systemManager->GetEntityManager()-> \n        GetComponent<C_State>(l_message.m_receiver, \n        Component::State); \n\n      if (state->GetState() == EntityState::Dying){ return; } \n      EntityEvent e; \n      Direction dir = static_cast<Direction>(l_message.m_int); \n      if (dir==Direction::Up){e=EntityEvent::Moving_Up;} \n      else if (dir==Direction::Down){e=EntityEvent::Moving_Down;} \n      else if(dir==Direction::Left){e=EntityEvent::Moving_Left;} \n      else if(dir==Direction::Right){e=EntityEvent::Moving_Right;} \n\n      m_systemManager->AddEvent(l_message.m_receiver, \n        static_cast<EventID>(e)); \n      ChangeState(l_message.m_receiver, \n        EntityState::Walking,false); \n    } \n    break; \n  case EntityMessage::Switch_State:  \n    ChangeState(l_message.m_receiver, \n      (EntityState)l_message.m_int,false); \n    break; \n  } \n} \n\n```", "```cpp\nvoid S_State::ChangeState(const EntityId& l_entity,  \n  const EntityState& l_state, bool l_force) \n{ \n  EntityManager* entities = m_systemManager->GetEntityManager(); \n  auto state = entities-> \n    GetComponent<C_State>(l_entity, Component::State); \n  if (!l_force && state->GetState()==EntityState::Dying){return;} \n  state->SetState(l_state); \n  Message msg((MessageType)EntityMessage::State_Changed); \n  msg.m_receiver = l_entity; \n  msg.m_int = static_cast<int>(l_state); \n  m_systemManager->GetMessageHandler()->Dispatch(msg); \n} \n\n```", "```cpp\nS_SheetAnimation::S_SheetAnimation(SystemManager* l_systemMgr) \n  : S_Base(System::SheetAnimation,l_systemMgr) \n{ \n  Bitmask req; \n  req.TurnOnBit((unsigned int)Component::SpriteSheet); \n  req.TurnOnBit((unsigned int)Component::State); \n  m_requiredComponents.push_back(req); \n\n  m_systemManager->GetMessageHandler()-> \n    Subscribe(EntityMessage::State_Changed,this); \n} \n\n```", "```cpp\nvoid S_SheetAnimation::Update(float l_dT){ \n  EntityManager* entities = m_systemManager->GetEntityManager(); \n  for(auto &entity : m_entities){ \n    auto sheet = entities-> \n      GetComponent<C_SpriteSheet>(entity, Component::SpriteSheet); \n    auto state = entities-> \n      GetComponent<C_State>(entity, Component::State); \n\n    sheet->GetSpriteSheet()->Update(l_dT); \n\n    const std::string& animName = sheet-> \n      GetSpriteSheet()->GetCurrentAnim()->GetName(); \n    if(animName == \"Attack\"){ \n      if(!sheet->GetSpriteSheet()->GetCurrentAnim()->IsPlaying()) \n      { \n        Message msg((MessageType)EntityMessage::Switch_State); \n        msg.m_receiver = entity; \n        msg.m_int = static_cast<int>(EntityState::Idle); \n        m_systemManager->GetMessageHandler()->Dispatch(msg); \n      } else if(sheet->GetSpriteSheet()-> \n        GetCurrentAnim()->IsInAction()) \n      { \n        Message msg((MessageType)EntityMessage::Attack_Action); \n        msg.m_sender = entity; \n        m_systemManager->GetMessageHandler()->Dispatch(msg); \n      } \n    } else if(animName == \"Death\" && \n      !sheet->GetSpriteSheet()->GetCurrentAnim()->IsPlaying()) \n    { \n      Message msg((MessageType)EntityMessage::Dead); \n      msg.m_receiver = entity; \n      m_systemManager->GetMessageHandler()->Dispatch(msg); \n    } \n    if (sheet->GetSpriteSheet()->GetCurrentAnim()->CheckMoved()){ \n      int frame = sheet->GetSpriteSheet()-> \n        GetCurrentAnim()->GetFrame(); \n      Message msg((MessageType)EntityMessage::Frame_Change); \n      msg.m_receiver = entity; \n      msg.m_int = frame; \n      m_systemManager->GetMessageHandler()->Dispatch(msg); \n    } \n  } \n} \n\n```", "```cpp\nvoid S_SheetAnimation::Notify(const Message& l_message){ \n  if (!HasEntity(l_message.m_receiver)) { return; } \n  EntityMessage m = static_cast<EntityMessage>(l_message.m_type); \n  switch(m){ \n  case EntityMessage::State_Changed: \n    { \n      EntityState s = static_cast<EntityState>(l_message.m_int); \n      switch(s){ \n      case EntityState::Idle: \n        ChangeAnimation(l_message.m_receiver,\"Idle\",true,true); \n        break; \n      case EntityState::Walking: \n        ChangeAnimation(l_message.m_receiver,\"Walk\",true,true); \n        break; \n      case EntityState::Attacking: \n        ChangeAnimation(l_message.m_receiver,\"Attack\",true,false); \n        break; \n      case EntityState::Hurt: break; \n      case EntityState::Dying: \n        ChangeAnimation(l_message.m_receiver,\"Death\",true,false); \n        break; \n      } \n    } \n    break; \n  } \n} \n\n```", "```cpp\nvoid S_SheetAnimation::ChangeAnimation(const EntityId& l_entity,  \n  const std::string& l_anim, bool l_play, bool l_loop) \n{ \n  auto sheet = m_systemManager->GetEntityManager()-> \n    GetComponent<C_SpriteSheet>(l_entity,Component::SpriteSheet); \n  sheet->GetSpriteSheet()->SetAnimation(l_anim,l_play,l_loop); \n} \n\n```", "```cpp\nenum class EntitySound{ None = -1, Footstep, Attack, \n  Hurt, Death, COUNT }; \n\nstruct SoundParameters{ \n  static const int Max_SoundFrames = 5; \n  SoundParameters(){ \n    for (int i = 0; i < Max_SoundFrames; ++i){ m_frames[i] = -1; } \n  } \n  std::string m_sound; \n  std::array<int, Max_SoundFrames> m_frames; \n}; \n\n```", "```cpp\nclass C_SoundEmitter : public C_Base{ \npublic: \n  C_SoundEmitter():C_Base(Component::SoundEmitter),m_soundID(-1){} \n  void ReadIn(std::stringstream& l_stream){ \n    std::string main_delimiter = \":\"; \n    std::string frame_delimiter = \",\"; \n    for (size_t i=0;i<static_cast<size_t>(EntitySound::COUNT);++i) \n    { \n      std::string chunk; \n      l_stream >> chunk; \n      if (chunk.empty()){ break; } \n\n      std::string sound = chunk.substr(0, \n        chunk.find(main_delimiter)); \n      std::string frames = chunk.substr(chunk.find(main_delimiter) \n        +main_delimiter.length()); \n      m_params[i].m_sound = sound; \n      size_t pos = 0; \n      unsigned int frameNum = 0; \n      while (frameNum < SoundParameters::Max_SoundFrames){ \n        pos = frames.find(frame_delimiter); \n        int frame = -1; \n        if (pos != std::string::npos){ \n          frame = stoi(frames.substr(0, pos)); \n          frames.erase(0, pos + frame_delimiter.length()); \n        } else { \n          frame = stoi(frames); \n          m_params[i].m_frames[frameNum] = frame; \n          break; \n        } \n        m_params[i].m_frames[frameNum] = frame; \n        ++frameNum; \n      } \n    } \n  } \n\n  SoundID GetSoundID() const { ... } \n  void SetSoundID(const SoundID& l_id){ ... } \n  const std::string& GetSound(const EntitySound& l_snd) const{...} \n  bool IsSoundFrame(const EntitySound& l_snd, int l_frame) const \n  { ... } \n  SoundParameters* GetParameters() { ... } \nprivate: \n  std::array<SoundParameters, \n    static_cast<size_t>(EntitySound::COUNT)> m_params; \n  SoundID m_soundID; \n}; \n\n```", "```cpp\nclass C_SoundListener : public C_Base{ \npublic: \n  C_SoundListener() : C_Base(Component::SoundListener){} \n  void ReadIn(std::stringstream& l_stream){} \n}; \n\n```", "```cpp\nS_Sound::S_Sound(SystemManager* l_systemMgr) \n  : S_Base(System::Sound, l_systemMgr), \n  m_audioManager(nullptr), m_soundManager(nullptr) \n{ \n  Bitmask req; \n  req.TurnOnBit((unsigned int)Component::Position); \n  req.TurnOnBit((unsigned int)Component::SoundEmitter); \n  m_requiredComponents.push_back(req); \n  req.ClearBit((unsigned int)Component::SoundEmitter); \n  req.TurnOnBit((unsigned int)Component::SoundListener); \n  m_requiredComponents.push_back(req); \n\n  m_systemManager->GetMessageHandler()-> \n    Subscribe(EntityMessage::Direction_Changed, this); \n  m_systemManager->GetMessageHandler()-> \n    Subscribe(EntityMessage::Frame_Change, this); \n} \n\n```", "```cpp\nvoid S_Sound::Update(float l_dT){ \n  EntityManager* entities = m_systemManager->GetEntityManager(); \n  for (auto &entity : m_entities){ \n    auto c_pos = entities-> \n      GetComponent<C_Position>(entity, Component::Position); \n    auto position = c_pos->GetPosition(); \n    auto elevation = c_pos->GetElevation(); \n\n    auto IsListener = entities-> \n      HasComponent(entity, Component::SoundListener); \n    if (IsListener){ \n      sf::Listener::setPosition( \n        MakeSoundPosition(position, elevation)); \n    } \n\n    if (!entities->HasComponent(entity, Component::SoundEmitter)) \n    { continue; } \n    auto c_snd = entities-> \n     GetComponent<C_SoundEmitter>(entity,Component::SoundEmitter); \n    if (c_snd->GetSoundID() == -1){ continue; } \n    if (!IsListener){ \n      if (!m_soundManager->SetPosition(c_snd->GetSoundID(), \n        MakeSoundPosition(position, elevation))) \n      { c_snd->SetSoundID(-1); } \n    } else { \n      if (!m_soundManager->IsPlaying(c_snd->GetSoundID())){ \n        c_snd->SetSoundID(-1); \n      } \n    } \n  } \n} \n\n```", "```cpp\nvoid S_Sound::Notify(const Message& l_message){ \n  if (!HasEntity(l_message.m_receiver)){ return; } \n  EntityManager* entities = m_systemManager->GetEntityManager(); \n  auto IsListener = entities-> \n    HasComponent(l_message.m_receiver, Component::SoundListener); \n  EntityMessage m = static_cast<EntityMessage>(l_message.m_type); \n  switch (m){ \n  case EntityMessage::Direction_Changed: \n  { \n    if (!IsListener){ return; } \n    Direction dir = static_cast<Direction>(l_message.m_int); \n    switch (dir){ \n    case Direction::Up: \n      sf::Listener::setDirection(0, 0, -1); break; \n    case Direction::Down: \n      sf::Listener::setDirection(0, 0, 1); break; \n    case Direction::Left: \n      sf::Listener::setDirection(-1, 0, 0); break; \n    case Direction::Right: \n      sf::Listener::setDirection(1, 0, 0); break; \n    } \n  } \n    break; \n  case EntityMessage::Frame_Change: \n    if (!entities-> \n      HasComponent(l_message.m_receiver,Component::SoundEmitter)) \n    { return; } \n    auto state = entities-> \n      GetComponent<C_State>(l_message.m_receiver,Component::State) \n      ->GetState(); \n    auto sound = EntitySound::None; \n    if(state ==EntityState::Walking){sound=EntitySound::Footstep;} \n    else if (state == EntityState::Attacking){ \n      sound = EntitySound::Attack; \n    } else if (state == EntityState::Hurt){ \n      sound = EntitySound::Hurt; \n    } else if (state == EntityState::Dying){ \n      sound = EntitySound::Death; \n    } \n    if (sound == EntitySound::None){ return; } \n    EmitSound(l_message.m_receiver, sound, false, \n      IsListener, l_message.m_int); \n    break; \n  } \n} \n\n```", "```cpp\nvoid S_Sound::EmitSound(const EntityId& l_entity, \n  const EntitySound& l_sound, bool l_useId, bool l_relative, \n  int l_checkFrame) \n{ \n  if (!HasEntity(l_entity)){ return; } \n  if (!m_systemManager->GetEntityManager()-> \n    HasComponent(l_entity, Component::SoundEmitter)) \n  { return; } \n  EntityManager* entities = m_systemManager->GetEntityManager(); \n  auto c_snd = entities->GetComponent<C_SoundEmitter>( \n    l_entity, Component::SoundEmitter); \n  if (c_snd->GetSoundID() != -1 && l_useId){ return; } \n  if (l_checkFrame != -1 && \n    !c_snd->IsSoundFrame(l_sound, l_checkFrame)) \n  { return; } \n  auto c_pos = entities-> \n    GetComponent<C_Position>(l_entity, Component::Position); \n  auto pos = (l_relative ? \n   sf::Vector3f(0.f, 0.f, 0.f) : \n   MakeSoundPosition(c_pos->GetPosition(),c_pos->GetElevation())); \n  if (l_useId){ \n    c_snd->SetSoundID(m_soundManager->Play( \n      c_snd->GetSound(l_sound), pos)); \n  } else { \n    m_soundManager->Play(c_snd->GetSound(l_sound), \n      pos, false, l_relative); \n  } \n} \n\n```", "```cpp\nsf::Vector3f S_Sound::MakeSoundPosition( \n  const sf::Vector2f& l_entityPos, unsigned int l_elevation) \n{ \n  return sf::Vector3f( \n    l_entityPos.x, \n    static_cast<float>(l_elevation * Sheet::Tile_Size), \n    l_entityPos.y \n  ); \n} \n\n```", "```cpp\nvoid State_MainMenu::OnCreate(){ \n  auto context = m_stateMgr->GetContext(); \n  GUI_Manager* gui = context->m_guiManager; \n  gui->LoadInterface(\"MainMenu.interface\", \"MainMenu\"); \n  gui->GetInterface(\"MainMenu\")->SetPosition( \n    sf::Vector2f(250.f, 168.f)); \n  EventManager* eMgr = context->m_eventManager; \n  eMgr->AddCallback(\"MainMenu_Play\", &State_MainMenu::Play, this); \n  eMgr->AddCallback(\"MainMenu_Quit\", &State_MainMenu::Quit, this); \n} \n\n```", "```cpp\nvoid State_MainMenu::OnDestroy(){ \n  m_stateMgr->GetContext()->m_guiManager-> \n    RemoveInterface(StateType::Game, \"MainMenu\"); \n  EventManager* eMgr = m_stateMgr->GetContext()->m_eventManager; \n  eMgr->RemoveCallback(StateType::MainMenu, \"MainMenu_Play\"); \n  eMgr->RemoveCallback(StateType::MainMenu, \"MainMenu_Quit\"); \n} \n\n```", "```cpp\nvoid State_MainMenu::Activate(){ \n  auto& play = *m_stateMgr->GetContext()->m_guiManager-> \n    GetInterface(\"MainMenu\")->GetElement(\"Play\"); \n  if (m_stateMgr->HasState(StateType::Game)){ \n    // Resume \n    play.SetText(\"Resume\"); \n  } else { \n    // Play \n    play.SetText(\"Play\"); \n  } \n} \n\n```", "```cpp\nvoid State_MainMenu::Play(EventDetails* l_details){ \n  m_stateMgr->SwitchTo(StateType::Game); \n} \nvoid State_MainMenu::Quit(EventDetails* l_details){ \n  m_stateMgr->GetContext()->m_wind->Close(); \n} \n\n```", "```cpp\nvoid State_Game::OnCreate() { \n  auto context = m_stateMgr->GetContext(); \n  EventManager* evMgr = context->m_eventManager; \n\n  evMgr->AddCallback(\"Key_Escape\", &State_Game::MainMenu, this); \n  evMgr->AddCallback(\"Player_MoveLeft\", \n    &State_Game::PlayerMove, this); \n  evMgr->AddCallback(\"Player_MoveRight\", \n    &State_Game::PlayerMove, this); \n  evMgr->AddCallback(\"Player_MoveUp\", \n    &State_Game::PlayerMove, this); \n  evMgr->AddCallback(\"Player_MoveDown\", \n    &State_Game::PlayerMove, this); \n\n  sf::Vector2u size = context->m_wind->GetWindowSize(); \n  m_view.setSize(static_cast<float>(size.x), \n    static_cast<float>(size.y)); \n  m_view.setCenter(static_cast<float>(size.x) / 2, \n    static_cast<float>(size.y) / 2); \n  m_view.zoom(0.6f); \n\n```", "```cpp\n  auto loading = m_stateMgr-> \n    GetState<State_Loading>(StateType::Loading); \n  context->m_gameMap->AddFile( \n    Utils::GetWorkingDirectory() + \"media/Maps/map1.map\"); \n  loading->AddLoader(context->m_gameMap); \n  loading->SetManualContinue(true); \n  context->m_soundManager->PlayMusic(\"TownTheme\", 50.f, true); \n} \n\n```", "```cpp\nvoid State_Game::OnDestroy(){ \n  auto context = m_stateMgr->GetContext(); \n  EventManager* evMgr = context->m_eventManager; \n  evMgr->RemoveCallback(StateType::Game, \"Key_Escape\"); \n  evMgr->RemoveCallback(StateType::Game, \"Key_O\"); \n  evMgr->RemoveCallback(StateType::Game, \"Player_MoveLeft\"); \n  evMgr->RemoveCallback(StateType::Game, \"Player_MoveRight\"); \n  evMgr->RemoveCallback(StateType::Game, \"Player_MoveUp\"); \n  evMgr->RemoveCallback(StateType::Game, \"Player_MoveDown\"); \n  context->m_gameMap->PurgeMap(); \n  context->m_gameMap->GetTileSet()->Purge(); \n} \n\n```", "```cpp\nvoid State_Game::Update(const sf::Time& l_time){ \n  auto context = m_stateMgr->GetContext(); \n  UpdateCamera(); \n  context->m_gameMap->Update(l_time.asSeconds()); \n  context->m_systemManager->Update(l_time.asSeconds()); \n} \n\n```", "```cpp\nvoid State_Game::UpdateCamera(){ \n  if (m_player == -1){ return; } \n  SharedContext* context = m_stateMgr->GetContext(); \n  auto pos = m_stateMgr->GetContext()->m_entityManager-> \n    GetComponent<C_Position>(m_player, Component::Position); \n\n  m_view.setCenter(pos->GetPosition()); \n  context->m_wind->GetRenderWindow()->setView(m_view); \n\n  sf::FloatRect viewSpace = context->m_wind->GetViewSpace(); \n  if (viewSpace.left <= 0){ \n    m_view.setCenter(viewSpace.width / 2, m_view.getCenter().y); \n    context->m_wind->GetRenderWindow()->setView(m_view); \n  } else if (viewSpace.left + viewSpace.width > \n    (context->m_gameMap->GetMapSize().x) * Sheet::Tile_Size) \n  { \n    m_view.setCenter( \n      ((context->m_gameMap->GetMapSize().x) * Sheet::Tile_Size) - \n        (viewSpace.width / 2), \n      m_view.getCenter().y); \n    context->m_wind->GetRenderWindow()->setView(m_view); \n  } \n\n  if (viewSpace.top <= 0){ \n    m_view.setCenter(m_view.getCenter().x, viewSpace.height / 2); \n    context->m_wind->GetRenderWindow()->setView(m_view); \n  } else if (viewSpace.top + viewSpace.height > \n    (context->m_gameMap->GetMapSize().y) * Sheet::Tile_Size) \n  { \n    m_view.setCenter( \n      m_view.getCenter().x, \n      ((context->m_gameMap->GetMapSize().y) * Sheet::Tile_Size) - \n        (viewSpace.height / 2)); \n    context->m_wind->GetRenderWindow()->setView(m_view); \n  } \n} \n\n```", "```cpp\nvoid State_Game::Draw(){ \n  auto context = m_stateMgr->GetContext(); \n  for (unsigned int i = 0; i < Sheet::Num_Layers; ++i){ \n    context->m_gameMap->Draw(i); \n    m_stateMgr->GetContext()->m_systemManager->Draw( \n      m_stateMgr->GetContext()->m_wind, i); \n  } \n} \n\n```", "```cpp\nvoid State_Game::PlayerMove(EventDetails* l_details){ \n  Message msg((MessageType)EntityMessage::Move); \n  if (l_details->m_name == \"Player_MoveLeft\"){ \n    msg.m_int = static_cast<int>(Direction::Left); \n  } else if (l_details->m_name == \"Player_MoveRight\"){ \n    msg.m_int = static_cast<int>(Direction::Right); \n  } else if (l_details->m_name == \"Player_MoveUp\"){ \n    msg.m_int = static_cast<int>(Direction::Up); \n  } else if (l_details->m_name == \"Player_MoveDown\"){ \n    msg.m_int = static_cast<int>(Direction::Down); \n  } \n  msg.m_receiver = m_player; \n  m_stateMgr->GetContext()->m_systemManager-> \n    GetMessageHandler()->Dispatch(msg); \n} \n\n```", "```cpp\nvoid State_Game::MainMenu(EventDetails* l_details){ \n  m_stateMgr->SwitchTo(StateType::MainMenu); \n} \n\nvoid State_Game::Activate() { \n  auto map = m_stateMgr->GetContext()->m_gameMap; \n\n  m_player = map->GetPlayerId(); \n  map->Redraw(); \n} \n\n```", "```cpp\nclass Game{ \npublic: \n  Game(); \n  ~Game(); \n  void Update(); \n  void Render(); \n  void LateUpdate(); \n  sf::Time GetElapsed(); \n  Window* GetWindow(); \nprivate: \n  void SetUpClasses(); \n  void SetUpECS(); \n  void SetUpStates(); \n  void RestartClock(); \n  sf::Clock m_clock; \n  sf::Time m_elapsed; \n  SharedContext m_context; \n  RandomGenerator m_rand; \n  Window m_window; \n  TextureManager m_textureManager; \n  FontManager m_fontManager; \n  AudioManager m_audioManager; \n  SoundManager m_soundManager; \n  GUI_Manager m_guiManager; \n  SystemManager m_systemManager; \n  EntityManager m_entityManager; \n  Map m_gameMap; \n  std::unique_ptr<StateManager> m_stateManager; \n}; \n\n```", "```cpp\nGame::Game() \n  : m_window(\"Chapter 2\", sf::Vector2u(800, 600), false), \n  m_entityManager(&m_systemManager, &m_textureManager), \n  m_guiManager(m_window.GetEventManager(), &m_context), \n  m_soundManager(&m_audioManager), \n  m_gameMap(&m_window, &m_entityManager, &m_textureManager) \n{ \n  SetUpClasses(); \n  SetUpECS(); \n  SetUpStates(); \n\n  m_fontManager.RequireResource(\"Main\"); \n  m_stateManager->SwitchTo(StateType::Intro); \n} \n\nGame::~Game(){ m_fontManager.ReleaseResource(\"Main\"); } \n\n```", "```cpp\nsf::Time Game::GetElapsed(){ return m_clock.getElapsedTime(); } \nvoid Game::RestartClock(){ m_elapsed = m_clock.restart(); } \nWindow* Game::GetWindow(){ return &m_window; } \n\n```", "```cpp\nvoid Game::Update(){ \n  m_window.Update(); \n  m_stateManager->Update(m_elapsed); \n  m_guiManager.Update(m_elapsed.asSeconds()); \n  m_soundManager.Update(m_elapsed.asSeconds()); \n\n  GUI_Event guiEvent; \n  while (m_context.m_guiManager->PollEvent(guiEvent)){ \n    m_window.GetEventManager()->HandleEvent(guiEvent); \n  } \n} \n\n```", "```cpp\nvoid Game::Render(){ \n  m_window.BeginDraw(); \n  // Render here. \n  m_stateManager->Draw(); \n  m_guiManager.Render(m_window.GetRenderWindow()); \n  m_window.EndDraw(); \n} \n\n```", "```cpp\nvoid Game::LateUpdate(){ \n  m_stateManager->ProcessRequests(); \n  RestartClock(); \n} \n\n```", "```cpp\nvoid Game::SetUpClasses() { \n  m_clock.restart(); \n  m_context.m_rand = &m_rand; \n  srand(static_cast<unsigned int>(time(nullptr))); \n  m_systemManager.SetEntityManager(&m_entityManager); \n\n  m_context.m_wind = &m_window; \n  m_context.m_eventManager = m_window.GetEventManager(); \n  m_context.m_textureManager = &m_textureManager; \n  m_context.m_fontManager = &m_fontManager; \n  m_context.m_audioManager = &m_audioManager; \n  m_context.m_soundManager = &m_soundManager; \n  m_context.m_gameMap = &m_gameMap; \n  m_context.m_systemManager = &m_systemManager; \n  m_context.m_entityManager = &m_entityManager; \n  m_context.m_guiManager = &m_guiManager; \n\n  m_stateManager = std::make_unique<StateManager>(&m_context); \n  m_gameMap.SetStateManager(m_stateManager.get()); \n} \n\n```", "```cpp\nvoid Game::SetUpECS() { \n  m_entityManager.AddComponentType<C_Position>( \n    Component::Position); \n  m_entityManager.AddComponentType<C_SpriteSheet>( \n    Component::SpriteSheet); \n  m_entityManager.AddComponentType<C_State>(Component::State); \n  m_entityManager.AddComponentType<C_Movable>(Component::Movable); \n  m_entityManager.AddComponentType<C_Controller>( \n    Component::Controller); \n  m_entityManager.AddComponentType<C_Collidable>( \n    Component::Collidable); \n  m_entityManager.AddComponentType<C_SoundEmitter>( \n    Component::SoundEmitter); \n  m_entityManager.AddComponentType<C_SoundListener>( \n    Component::SoundListener); \n\n  m_systemManager.AddSystem<S_State>(System::State); \n  m_systemManager.AddSystem<S_Control>(System::Control); \n  m_systemManager.AddSystem<S_Movement>(System::Movement); \n  m_systemManager.AddSystem<S_Collision>(System::Collision); \n  m_systemManager.AddSystem<S_SheetAnimation>( \n    System::SheetAnimation); \n  m_systemManager.AddSystem<S_Sound>(System::Sound); \n  m_systemManager.AddSystem<S_Renderer>(System::Renderer); \n\n  m_systemManager.GetSystem<S_Collision>(System::Collision)-> \n    SetMap(&m_gameMap); \n  m_systemManager.GetSystem<S_Movement>(System::Movement)-> \n    SetMap(&m_gameMap); \n  m_systemManager.GetSystem<S_Sound>(System::Sound)-> \n    SetUp(&m_audioManager, &m_soundManager); \n} \n\n```", "```cpp\nvoid Game::SetUpStates() { \n  m_stateManager->AddDependent(m_context.m_eventManager); \n  m_stateManager->AddDependent(&m_guiManager); \n  m_stateManager->AddDependent(&m_soundManager); \n  m_stateManager->RegisterState<State_Intro>(StateType::Intro); \n  m_stateManager->RegisterState<State_MainMenu>( \n    StateType::MainMenu); \n  m_stateManager->RegisterState<State_Game>(StateType::Game); \n} \n\n```", "```cpp\nvoid main(int argc, void** argv[]){ \n  // Program entry point. \n  { \n    Game game; \n    while(!game.GetWindow()->IsDone()){ \n      game.Update(); \n      game.Render(); \n      game.LateUpdate(); \n    } \n  } \n} \n\n```"]