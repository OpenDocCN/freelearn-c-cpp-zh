- en: Manual Robotics with Intel Edison
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用英特尔爱迪生的手动机器人
- en: 'In [Chapter 5](45fccd6a-a75e-465d-89dc-dad31f528ac1.xhtml), *Autonomous Robotics
    with Intel Edison*, we dealt with robotics and the autonomous side of it. Here,
    we are going to deep dive into the field of manual robotics. A manual robot may
    not typically be called a robot, so more specifically, we will deal with the manual
    control of robots that have some autonomous characteristics. We are primarily
    dealing with the development of UGVs and its control using WPF applications. WPF
    applications have already been discussed in [Chapter 3](3bd53219-a287-4d8f-9a58-5a06c5b14062.xhtml), *Intel
    Edison and IoT (Home Automation)*, where we communicated with Edison using the
    MQTT protocol. Here, we are going to do the same using serial port communication.
    We will also learn how to make our bot fully wireless. The topics we will be covering
    are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](45fccd6a-a75e-465d-89dc-dad31f528ac1.xhtml)《使用英特尔爱迪生的自主机器人》中，我们处理了机器人和其自主方面。在这里，我们将深入探讨手动机器人的领域。一个手动机器人可能通常不会被称作机器人，所以更具体地说，我们将处理具有一些自主特性的机器人的手动控制。我们主要处理UGVs的开发及其使用WPF应用程序的控制。WPF应用程序已经在[第3章](3bd53219-a287-4d8f-9a58-5a06c5b14062.xhtml)《英特尔爱迪生和物联网（家庭自动化）》中讨论过，在那里我们使用MQTT协议与爱迪生通信。在这里，我们将使用串行端口通信做同样的事情。我们还将学习如何使我们的机器人完全无线化。我们将讨论的主题如下：
- en: Manual robotic system—architecture and overview
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动机器人系统——架构和概述
- en: 2WD and 4WD mechanisms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两轮驱动和四轮驱动机制
- en: Serial port communication with Intel Edison
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用英特尔爱迪生的串行端口通信
- en: Making the bot wireless in robotics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使机器人无线化
- en: A simple WPF application to switch an LED on and off using Intel Edison
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的WPF应用程序，使用英特尔爱迪生开关LED的开关
- en: High performance motor driver example with code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带代码的高性能电机驱动器示例
- en: 'Black: e-track platform for UGV'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑色：地面无人车（UGV）的e-track平台
- en: Universal robot controller for UGV
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UGV的通用机器人控制器
- en: All the codes for this chapter will be written in Arduino IDE, and for the software
    side in Visual Studio we are using C# and xaml.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都将使用Arduino IDE编写，而在Visual Studio的软件方面，我们使用C#和xaml。
- en: Manual robotic system
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动机器人系统
- en: 'We have had a look at the autonomous robotic architecture. Manual robotics
    also deal with a similar architecture; the only difference being that we have
    a fully-fledged controller that is responsible for most of the action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了自主机器人架构。手动机器人也处理类似的架构；唯一的区别是我们有一个完整的控制器，负责大部分动作：
- en: '![](img/image_06_001.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_001.jpg)'
- en: Manual robot architecture
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 手动机器人架构
- en: There isn't much of a difference between the architecture discussed here and
    the one discussed in [Chapter 5](45fccd6a-a75e-465d-89dc-dad31f528ac1.xhtml),
    *Autonomous Robotics with Intel Edison*. We've added a receiver and a transmitter
    unit here which would have been present in the earlier use case as well. When
    dealing with robotics, the entire architecture falls under the same roof.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里讨论的架构与[第5章](45fccd6a-a75e-465d-89dc-dad31f528ac1.xhtml)中讨论的架构没有太大区别，即《使用英特尔爱迪生的自主机器人》。我们在这里增加了一个接收器和发射器单元，这在早期的用例中也是存在的。在处理机器人时，整个架构都处于同一屋檐下。
- en: Manual robotics may not be limited to only manual robots. It may be a blend
    of manual and autonomous functionality, because a fully manual robot may not typically
    be called a robot. However, we are aware of **Unmanned Ground Vehicles** (**UGVs**)
    and **Unmanned Aerial Vehicles** (**UAVs**). Sometimes the terminology may define
    them as robots, but until, and unless, they don't have at least some manual functionality,
    they may not be referred to as robots. This chapter mainly deals with UGVs, and
    like every robot or UGV, we need a sturdy chassis.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 手动机器人可能不仅限于只有手动机器人。它可能是手动和自主功能的结合，因为一个完全手动的机器人通常不会被称作机器人。然而，我们了解**地面无人车**（**UGVs**）和**无人机**（**UAVs**）。有时术语可能将它们定义为机器人，但除非它们至少有一些手动功能，否则可能不会被称作机器人。本章主要涉及UGVs，就像每个机器人或UGV一样，我们需要一个坚固的车架。
- en: 'Chassis in robotics: 2WD and 4WD'
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人车架：两轮驱动和四轮驱动
- en: The reader is expected to develop their own robot, and thus you will be required
    to learn about drive mechanisms and a choice of chassis. Ideally, there are two
    types of drive mechanisms and the choice for the chassis is done on the basis
    of the drive mechanism used. Normally we don't want a chassis that over-stresses
    our motors, nor do we want one that may get stuck while exposed to the outdoor
    environment. In a typical line follower robot, as discussed in [Chapter 5](45fccd6a-a75e-465d-89dc-dad31f528ac1.xhtml),
    *Autonomous Robotics with Intel Edison,* the most common and the most widely-used
    drive mechanism is a two-wheel drive, as normally these operate on smooth surfaces
    and in indoor environments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 预期读者将开发自己的机器人，因此你将需要了解驱动机制和底盘的选择。理想情况下，有两种类型的驱动机制，底盘的选择基于所使用的驱动机制。通常我们不希望底盘过度应力我们的电机，也不希望它在户外环境中可能会卡住。在典型的循线机器人中，如第5章[自主机器人与英特尔爱迪生](45fccd6a-a75e-465d-89dc-dad31f528ac1.xhtml)中讨论的，最常见且最广泛使用的驱动机制是两轮驱动，因为这些通常在平滑表面和室内环境中运行。
- en: Two-wheel drive
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两轮驱动
- en: '**Two-wheel drive** (**2WD**) refers to the driving mechanism involving two
    motors and two wheels, and it may typically contain a castor for balancing:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**两轮驱动（2WD**）指的是涉及两个电机和两个轮子的驱动机制，它可能通常包含一个万向轮以实现平衡：'
- en: '![](img/image_06_002.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_002.jpg)'
- en: 2WD typical layout
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 2WD典型布局
- en: 'The rear motors provide mobility and also acts as a steering mechanism for
    the robot. For the robot to move right, you may switch off the right motor and
    let the left motor do the work. However, in that way, the turning radius may be
    more extreme and the power consumption for the left motor increases as it needs
    to overcome the force of friction provided by the right wheel. The castor being
    omni-directional provides less resistance, but this isn''t necessarily preferred.
    The other way is to rotate the right wheel backwards while the left wheel moves
    forwards; this method allows the robot to turn on its own axis and provide a zero
    turning radius:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 后置电机提供移动性，并作为机器人的转向机制。为了使机器人向右移动，你可以关闭右侧电机，让左侧电机工作。然而，这样做的转弯半径可能会更极端，左侧电机的功耗会增加，因为它需要克服右侧轮子提供的摩擦力。万向轮提供的阻力较小，但这并不一定是首选的。另一种方法是让右侧轮子向后旋转，而左侧轮子向前移动；这种方法允许机器人在其轴上旋转，并提供零转弯半径：
- en: '![](img/image_06_003.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_003.jpg)'
- en: 2WD turning of robot on its own axis
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 2WD机器人在其轴上的转弯
- en: When we follow the preceding method, there is a lot less stress on the motors,
    and with the castor being omni-directional, the robot executes an almost perfect
    turn.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遵循前面的方法时，对电机的压力会小得多，由于万向轮是全方位的，机器人执行几乎完美的转弯。
- en: A chassis can be built with any material and the design should be such that
    it provides as less stress as possible on the motors.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 底盘可以用任何材料制成，设计应该是这样的，它对电机施加的压力尽可能小。
- en: 'However, when dealing with four-wheel drives, design plays a factor:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当处理四轮驱动时，设计起着作用：
- en: '![](img/image_06_004.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_004.jpg)'
- en: 4WD typical drive
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 4WD典型驱动
- en: Typically, these are powered by four motors (here, motor 1 are the left-side
    motors, whereas motor 2 are the right-side motors), which can be controlled independently.
    Usually during rotation, we don't stop the motors on the other side because it
    creates a lot of pressure on those motors. The other possible option is to rotate
    on opposite sides—but there is a catch.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些由四个电机（在这里，电机1是左侧电机，而电机2是右侧电机）提供动力，可以独立控制。通常在旋转时，我们不会停止另一侧的电机，因为这会给这些电机造成很大的压力。另一个可能的选择是在相对的侧面旋转——但是有一个陷阱。
- en: 'Usually, the length of the robot in these cases needs to be either equal to
    the breadth or even less so. Otherwise, a condition may arise called wheel slip.
    To prevent such a condition, the design is normally such that the entire model,
    along with its wheels, fits in a circle, shown as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在这些情况下，机器人的长度需要等于宽度，甚至更短。否则，可能会出现一种称为打滑的条件。为了防止这种情况，设计通常是整个模型及其轮子都适合在一个圆圈内，如下所示：
- en: '![](img/image_06_005.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_005.jpg)'
- en: 4WD—design
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 4WD—设计
- en: There is another parameter that may be considered and that is the distance between
    two wheels, as it must be less than the diameter of the wheels. This is because
    if we are exposed to rough terrain, the bot will be able to come out.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能考虑的参数是两个轮子之间的距离，因为它必须小于轮子的直径。这是因为如果我们遇到崎岖地形，机器人将能够出来。
- en: 'This will happen if the structure of the bot fits in a circle and the length
    and the distance between the front and rear wheels are less than the distance
    between the left and right side. Here, while wheel slip happens, it''s reduced
    considerably and is almost negligible. Have a look at the following image for
    more information:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果机器人的结构适合圆形，并且前后轮之间的长度和距离小于左右两侧的距离，这种情况就会发生。在这里，虽然会发生打滑，但打滑程度大大降低，几乎可以忽略不计。查看以下图片以获取更多信息：
- en: '![](img/image_06_006.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_006.jpg)'
- en: Rotation of a 4WD robot
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 4WD机器人的旋转
- en: In the preceding image, the concept should become clearer as the robot tends
    to stay in the circle it's enclosed in, executing more or less a pivotal turn
    or a zero radius turn.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，随着机器人倾向于保持在它所包围的圆形中，执行更多或更少的枢轴转向或零半径转向，这一概念应该会变得更加清晰。
- en: Now that we know how the robot chassis can be designed, let's have a look at
    the ready-made designs available. On sites such as Amazon and eBay, a lot of chassis
    are available pre-fabricated, following existing design patterns. If you want
    to fabricate your own chassis, then it's better to follow the preceding design
    pattern, especially in a 4WD configuration.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了如何设计机器人底盘，让我们看看可用的现成设计。在亚马逊和eBay等网站上，有许多底盘是预制好的，遵循现有的设计模式。如果你想要自己制造底盘，那么最好遵循前面的设计模式，尤其是在4WD配置中。
- en: Serial port communication with Intel Edison
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Intel Edison的串口通信
- en: 'When we have a manual robot, we need to control it. So, to control it we need
    some mode of communication. This is attained by using serial port communication.
    In Intel Edison, we have three serial ports; let''s call it Serialx, where x stands
    for 1 or 2\. These serial ports can be accessed by the Arduino IDE:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个手动机器人时，我们需要控制它。因此，为了控制它，我们需要某种通信方式。这是通过使用串口通信来实现的。在Intel Edison中，我们有三个串口；让我们称它为Serialx，其中x代表1或2。这些串口可以通过Arduino
    IDE访问：
- en: '**Serial**:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Serial**:'
- en: '**Name**: Multi-gadget, firmware programming, serial console, or OTG port'
  id: totrans-44
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Name**: 多功能，固件编程，串行控制台或OTG端口'
- en: '**Location**: USB-micro connector near the center of the Arduino breakout board'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Location**: Arduino扩展板中心附近的USB微型连接器'
- en: '**ArduinoSWname**: Serial'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ArduinoSWname**: Serial'
- en: '**Linuxname**: `/dev/ttyGS0`'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linuxname**: `/dev/ttyGS0`'
- en: This port allows us to program Intel Edison and is also the default port for
    the Arduino IDE. In the Arduino breakout board, this is activated when the toggle
    switch or SW1 is towards the OTG port and away from the USB slot.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端口允许我们编程Intel Edison，也是Arduino IDE的默认端口。在Arduino扩展板中，当切换开关或SW1指向OTG端口且远离USB插槽时，此端口被激活。
- en: '**Serial1**:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Serial1**:'
- en: '**Name**: UART1, the general-purpose TTL-level port (Arduino shield compatibility)'
  id: totrans-50
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Name**: UART1，通用TTL级端口（Arduino屏蔽兼容性）'
- en: '**Location**: Pins 0 (RX) and 1 (TX) on the Arduino shield interface headers.'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Location**: Arduino屏蔽接口引脚上的0（RX）和1（TX）。'
- en: '**ArduinoSWname**: Serial1'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ArduinoSWname**: Serial1'
- en: '**Linuxname**: `/dev/ttyMFD1`'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linuxname**: `/dev/ttyMFD1`'
- en: This port is the pin numbers 0 and 1, which are used as Rx and Tx. This port
    is used for the remote control of Edison over an RF network or any external Bluetooth
    device.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端口是0号和1号引脚，用作Rx和Tx。这个端口用于通过RF网络或任何外部蓝牙设备远程控制Edison。
- en: '**Serial2**:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Serial2**:'
- en: '**Name**: UART2, Linux kernel debug, or debug spew port'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Name**: UART2，Linux内核调试或调试喷口'
- en: '**Location**: USB-micro connector near the edge of the Arduino board'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Location**: Arduino板边缘附近的USB微型连接器'
- en: '**ArduinoSWname**: Serial2'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ArduinoSWname**: Serial2'
- en: '**Linuxname**: `/dev/ttyMFD2`'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linuxname**: `/dev/ttyMFD2`'
- en: This is one of the most useful ports whose communication baud rate is 115200\.
    This is usually the port that is accessed through the PuTTY console and is used
    to isolate boot problems. When the Serial2 object is created and initialized with
    `Serial2.begin()`, the kernel's access to the port is removed and the Arduino
    sketch is given control until `Serial2.end()` is invoked.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是其中一个最有用的端口，其通信波特率为115200。这通常是可以通过PuTTY控制台访问的端口，用于隔离启动问题。当创建并使用`Serial2.begin()`初始化Serial2对象时，内核对端口的访问被移除，直到调用`Serial2.end()`，Arduino草图将获得对端口的控制。
- en: '**Virtual ports**:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Virtual ports**:'
- en: '**Name**: VCP or virtual communications port (appears only when the Serial-over-USB
    device is connected)'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Name**: VCP或虚拟通信端口（仅在串行USB设备连接时出现）'
- en: '**Location**: Big type A USB port nearest the Arduino power connector'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Location**: 最靠近Arduino电源连接器的较大类型A USB端口'
- en: '**ArduinoSWname**: Not supported by default'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ArduinoSWname**: 默认不支持'
- en: '**Linuxname**: `/dev/ttyACMx` or `/dev/ttyUSBx`'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linuxname**: `/dev/ttyACMx` 或 `/dev/ttyUSBx`'
- en: This is the USB port of your Intel Edison's Arduino breakout board. The switch
    must be towards the USB port for enabling the device. Multiple USB devices can
    be connected using a USB hub.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是英特尔爱迪生的Arduino扩展板的USB端口。开关必须朝向USB端口以启用设备。可以使用USB集线器连接多个USB设备。
- en: 'Consider the following example of code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码示例：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will just print Hi, Reporting in from Intel Edison in the serial monitor.
    From the code, it's evident that `Serial` has been used, which is the default
    one.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在串行监视器中打印“Hi，来自英特尔爱迪生的报告”。从代码中可以看出，使用了`Serial`，这是默认的。
- en: Making the system wireless
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使系统无线化
- en: 'For making systems wireless in robotics, there are many options available.
    The choice of hardware and protocol depends on certain factors, which are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器人技术中使系统无线化，有许多可用的选项。硬件和协议的选择取决于某些因素，如下所述：
- en: Availability of mobile network coverage
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动网络覆盖的可用性
- en: Rules and regulations over RF in your operating country
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您所在运营国家的射频（RF）规则和规定
- en: Maximum distance required
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要的最大距离
- en: Availability of Internet connectivity
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接的可用性
- en: If we use a GSM module, then mobile network coverage is a must. We may need
    to get clearance for the RF and ensure that it does not interfere with other signals.
    The maximum distance is another factor to consider, as distance is limited when
    using Bluetooth. Bluetooth connectivity can be hampered if the distance exceeds.
    The same goes for RF, but RF coverage can be increased based on the antenna used.
    If there is Internet connectivity over an area, then MQTT itself can be used,
    which was again discussed in [Chapter 3](3bd53219-a287-4d8f-9a58-5a06c5b14062.xhtml),
    *Intel Edison and IoT (Home Automation)*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用GSM模块，那么移动网络覆盖是必须的。我们可能需要获得射频的许可，并确保它不会干扰其他信号。最大距离是另一个需要考虑的因素，因为在使用蓝牙时距离是有限的。如果距离超过，蓝牙连接可能会受到影响。对于射频来说也是一样，但基于使用的天线，射频覆盖可以增加。如果某个区域有互联网连接，那么可以使用MQTT本身，这已经在[第3章](3bd53219-a287-4d8f-9a58-5a06c5b14062.xhtml)中讨论过，*英特尔爱迪生和物联网（家庭自动化）*。
- en: RF, or radio frequency, can be used for small applications. Wi-Fi can also be
    used with Edison, but let's cover a wide spectrum of devices and take a look into
    how RF can be used.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 射频（RF）可用于小型应用。爱迪生也可以使用Wi-Fi，但让我们覆盖广泛的设备，并看看射频如何被使用。
- en: Normally, RF modules follow a **Universal Asynchronous Receiver Transmitter**
    (**UART**) protocol. These generally have a USB link and a serial link. A serial
    link can be converted with a USB link using a serial to USB converter. There are
    many options to choose from when buying an RF module set.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，射频模块遵循**通用异步接收发送器**（**UART**）协议。这些通常具有USB链路和串行链路。可以使用串行到USB转换器将串行链路转换为USB链路。购买射频模块套件时有很多选择。
- en: Make a note of what the maximum range and the operating frequency are. All details
    can be obtained from the place you buy the product.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 记录最大范围和操作频率。所有详细信息都可以从购买产品的地点获得。
- en: 'Normally, the pin out of a RF serial link is shown as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，射频串行链路的引脚图如下所示：
- en: '![](img/image_06_007.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_007.jpg)'
- en: RF serial link pin out
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 射频串行链路引脚图
- en: 'Here is a product of [http://robokits.co.in/](http://robokits.co.in/), which
    we used in our projects:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们项目中使用的产品[http://robokits.co.in/](http://robokits.co.in/)：
- en: '![](img/image_06_008.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_008.jpg)'
- en: RF USB Serial link. Picture source: [http://robokits.co.in/](http://robokits.co.in/)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 射频USB串行链路。图片来源：[http://robokits.co.in/](http://robokits.co.in/)
- en: The module can consist of five pins. We only need to deal with the four pins,
    as mentioned in the preceding figure.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块可以由五个引脚组成。我们只需要处理前面提到的四个引脚。
- en: 'An RF kit is used to manually control the robot wirelessly by sending commands.
    These are sent using serial port communication. The controller may use an RF module
    that has a USB link, or you can use a serial to USB converter to connect it to
    your PC. The connections of an RF serial link with a serial to USB converter is
    shown as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用射频套件可以通过发送命令手动控制机器人无线。这些命令是通过串行端口通信发送的。控制器可能使用具有USB链路的射频模块，或者您可以使用串行到USB转换器将其连接到您的PC。射频串行链路与串行到USB转换器的连接如下所示：
- en: '![](img/image_06_009.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_009.jpg)'
- en: Connections of RF serial link to a serial to USB converter
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将射频串行链路连接到串行转USB转换器的连接
- en: 'The connection shown earlier is for connecting an RF serial link to a USB.
    This applies to the computer side as we want to control it by a PC. We must use
    two RF modules; one is for Edison and the other is for the controller app or the
    PC. To connect the RF module to Intel Edison, have a look at the following image:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的连接用于将RF串行链路连接到USB。这适用于计算机端，因为我们想通过PC来控制它。我们必须使用两个RF模块；一个用于爱迪生，另一个用于控制器应用程序或PC。要将RF模块连接到英特尔爱迪生，请查看以下图像：
- en: '![](img/image_06_010.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_010.jpg)'
- en: Connections of a RF serial link to Intel Edison
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: RF串行链路连接到英特尔爱迪生的连接
- en: 'Intel Edison has Rx and Tx pins, which are pins 0 and 1 respectively. The overall
    architecture is shown as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔爱迪生具有Rx和Tx引脚，分别对应引脚0和1。整体架构如下所示：
- en: '![](img/image_06_011.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_011.jpg)'
- en: Wireless control of Intel Edison
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 无线控制英特尔爱迪生
- en: 'Now that we know how the hardware pieces are used for wireless communication,
    the programming part of the preceding model in Intel Edison is ridiculously simple.
    Just replace `Serial` with `Serial1`, as we are using the Rx and Tx pins:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了硬件组件如何用于无线通信，英特尔爱迪生中先前模型的编程部分非常简单。只需将`Serial`替换为`Serial1`，因为我们正在使用Rx和Tx引脚：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code sends data to a controller app by using the Rx and Tx pins
    over an RF network. Now we will have a look on the controller application side,
    where we will develop a WPF application to control our device.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码通过RF网络使用Rx和Tx引脚将数据发送到控制器应用程序。现在我们将查看控制器应用程序端，我们将开发一个WPF应用程序来控制我们的设备。
- en: WPF application for LED on and off
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LED开关的WPF应用程序
- en: In [Chapter 3](3bd53219-a287-4d8f-9a58-5a06c5b14062.xhtml), *Intel Edison and
    IoT (Home Automation), *we looked at using a WPF application and MQTT connection,
    learning that we could control our Intel Edison using MQTT protocol. However,
    here, we'll be dealing with serial port communication. Since we have already discussed
    WPF applications and how to create projects, and created an hello world application,
    we won't discuss the basics in this chapter, and will instead get into the application
    directly. Our problem statement in this chapter is to switch an LED on and off
    using a WPF application via serial port communication.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](3bd53219-a287-4d8f-9a58-5a06c5b14062.xhtml)中，我们探讨了使用WPF应用程序和MQTT连接，了解到我们可以使用MQTT协议来控制我们的英特尔爱迪生。然而，在这里，我们将处理串行端口通信。由于我们已经讨论了WPF应用程序以及如何创建项目，并创建了一个hello
    world应用程序，因此我们不会在本章中讨论基础知识，而是直接进入应用程序。本章的问题陈述是通过串行端口通信使用WPF应用程序开关LED。
- en: 'Start with creating a new WPF project and name it `RobotController`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从创建一个新的WPF项目并命名为`RobotController`开始：
- en: '![](img/image_06_012.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_012.png)'
- en: RobotController—1
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人控制器—1
- en: 'Next, in MainWindow.xaml, we''ll design the UI. We''ll use the following controls:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在MainWindow.xaml中，我们将设计UI。我们将使用以下控件：
- en: '`Buttons`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Buttons`'
- en: '`TextBox`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextBox`'
- en: '`TextBlocks`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextBlocks`'
- en: 'Design your UI as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式设计您的UI：
- en: '![](img/image_06_013.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_013.png)'
- en: RobotController—2
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人控制器—2
- en: 'The xaml code for the preceding UI is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述UI的xaml代码如下：
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By default, we have written `COM13`; however, that might change. A total of
    four buttons are added, which are on, off, connect, and disconnect. We also have
    a `TextBlock` to display the status. You can tamper with this code for more customization.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们已编写`COM13`；然而，这可能会改变。总共添加了四个按钮，分别是开、关、连接和断开连接。我们还有一个`TextBlock`来显示状态。您可以修改此代码以进行更多定制。
- en: Now our job is to write the backend for this code, which will also include the
    logic behind it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编写此代码的后端，这还将包括其背后的逻辑。
- en: 'Let''s first create event handlers. Double click on each of the buttons to
    create an event. The preceding code contains the event handlers. Once done, include
    the following namespace for the use of the `SerialPort `class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建事件处理程序。双击每个按钮以创建一个事件。前面的代码包含事件处理程序。完成后，包含以下命名空间以使用`SerialPort`类：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, create an object of the `SerialPort` class:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`SerialPort`类的对象：
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now navigate to the connect button''s event handler method, and here add the
    code required to connect your app to Intel Edison via a serial port. A try catch
    block is added to prevent crashes while connecting. The most common reason for
    a crash is an incorrect port number or the USB is not connected:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在导航到连接按钮的事件处理程序方法，并在此处添加通过串行端口将您的应用程序连接到英特尔爱迪生的代码。添加了try catch块以防止连接时崩溃。崩溃的最常见原因是端口号码不正确或USB未连接：
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we stored the `com` port number in a string type variable.
    Next, we assign the object's `PortName` member with the `portName`. We also set
    the baud rate to `9600`. Finally, we open the port and write in the status box
    `connected`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`com`端口号存储在一个字符串类型的变量中。接下来，我们将对象的`PortName`成员赋值为`portName`。我们还设置了波特率为`9600`。最后，我们打开端口并在状态框中写入`connected`。
- en: 'Next, we write the code for the disconnect event handler:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写断开连接的事件处理程序代码：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`sp.close()` disconnects the connection. It''s safe to write these under a
    try catch block.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`sp.close()`断开连接。在try catch块下编写这些代码是安全的。'
- en: 'Finally, we write the code for the on and off buttons'' event handlers:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们编写了开和关按钮的事件处理程序代码：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we used the `WriteLine` method and sent a string. The
    device, which is connected with the application using a serial port, receives
    the string and an action may be triggered. This sums up the entire process. The
    entire code for `MainWindow.xaml.cs` is provided as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`WriteLine`方法并发送了一个字符串。与使用串行端口连接到应用程序的设备接收到的字符串可能触发一个动作。这总结了整个过程。`MainWindow.xaml.cs`的整个代码如下所示：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we have the application ready to control our Intel Edison. Let's test it
    out. Open up the Arduino IDE. We'll write a small code for Intel Edison that will
    read serial data from the application so that the on board LED will turn on and
    off based on the incoming data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了控制英特尔爱迪生的应用程序。让我们来测试一下。打开Arduino IDE。我们将为英特尔爱迪生编写一小段代码，该代码将从应用程序读取串行数据，以便根据传入的数据使板载LED灯亮和灭。
- en: 'Write the following code to do the same:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 编写以下代码以执行相同操作：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you burn this code, go to Visual Studio and run your WPF application. Enter
    the port number; it must be the same as your Arduino programming port, that is,
    the serial port. After that, press the on button. The on board LED should glow.
    It should turn off when you press the off button. Thus, we now have a very basic
    understanding of how to communicate with Edison using serial port communication
    via a WPF application. As the chapter progresses, we'll see how to efficiently
    control a robot with keyboard controls.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你烧录此代码时，转到Visual Studio并运行你的WPF应用程序。输入端口号；它必须与你的Arduino编程端口相同，即串行端口。然后，按下开按钮。板载LED应该会发光。当你按下关按钮时，它应该熄灭。因此，我们现在对如何通过WPF应用程序使用串行端口通信与爱迪生进行通信有了非常基本的了解。随着章节的进展，我们将看到如何通过键盘控制有效地控制机器人。
- en: High performance motor driver sample with code
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带代码的高性能电机驱动器示例
- en: In [Chapter 5](45fccd6a-a75e-465d-89dc-dad31f528ac1.xhtml), *Autonomous Robotics
    with Intel Edison,* we saw an application of L293D and we also wrote some code
    for it to control motors. However, L293D fails in high performance applications.
    To tackle this, we had a brief discussion about an alternative high-power driver.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](45fccd6a-a75e-465d-89dc-dad31f528ac1.xhtml)“使用英特尔爱迪生的自主机器人”中，我们看到了L293D的应用，并为它编写了一些代码来控制电机。然而，L293D在高性能应用中失败了。为了解决这个问题，我们简要讨论了替代的高功率驱动器。
- en: 'Here, we''ll deep dive into the driver, as it has been my personal favorite
    and is used in virtually all our robots:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将深入探讨驱动器，因为它一直是我的最爱，并且几乎在我们的所有机器人中都得到了应用：
- en: '![](img/image_06_014.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_014.jpg)'
- en: 'Dual motor driver high power. Picture source: [http://robokits.co.in/motor-drives/dual-dc-motor-driver-20a](http://robokits.co.in/motor-drives/dual-dc-motor-driver-20a)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 双电机驱动高功率。图片来源：[http://robokits.co.in/motor-drives/dual-dc-motor-driver-20a](http://robokits.co.in/motor-drives/dual-dc-motor-driver-20a)
- en: 'The driver has the following five control pins:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动器有以下五个控制引脚：
- en: '**Gnd**: Ground'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gnd**：地'
- en: '**DIR**: When low, the motor rotates in one direction; when high, it rotates
    in another direction'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DIR**：当低电平时，电机朝一个方向旋转；当高电平时，朝另一个方向旋转'
- en: '**PWM**: Pulse width modulation to control the speed of the motor; the recommended
    frequency range is 20Hz - 400Hz'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PWM**：脉冲宽度调制以控制电机速度；推荐频率范围是20Hz - 400Hz'
- en: '**BRK**: When high, it halts the motor in operation'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BRK**：当处于高电平时，它将停止电机运行'
- en: '**5V**: Regulated 5V output from motor driver board'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5V**：电机驱动板输出的调节5V'
- en: 'Now let''s write a simple code to operate this driver with all the circuitry:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一段简单的代码来操作这个驱动器及其所有电路：
- en: '![](img/image_06_015.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_015.jpg)'
- en: Circuit diagram for motor driver
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 电机驱动电路图
- en: 'The preceding circuit is really simple to understand. You don''t need to connect
    the 5V pin. You may use a single ground by shorting two wires of the grounds from
    the board. Let''s now write a code to operate this. This motor driver is very
    efficient in controlling high torque motors. Since PWM functionality is used,
    we will therefore use half of the original speed of `122`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述电路非常简单易懂。您不需要连接5V引脚。您可以通过短路板上的两个地线来使用单个地线。现在让我们编写一段代码来操作这个驱动器。这个电机驱动器在控制高扭矩电机方面非常高效。由于使用了PWM功能，因此我们将使用原始速度`122`的一半：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, it is worth noting the functionalities of `Brake` and
    the `pwm`. Even if you are using a low torque motor, the motor won't rotate if
    the brake is set to high. Similarly, efficient speed control can be achieved by
    `pwm` pins. So, by default, we have set everything else on the `pwm` to low. This
    again depends on the polarity of your motors. Feel free to tamper with the connections
    so that everything is set with the preceding code. Reverse the connections of
    your motor if you find an opposite rotation of both sides in the forward condition.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，值得注意的是`Brake`和`pwm`的功能。即使您使用的是低扭矩电机，如果刹车设置为高，电机也不会旋转。同样，通过`pwm`引脚可以实现高效的速度控制。因此，我们默认将`pwm`上的其他所有设置都设置为低。这再次取决于您电机的极性。请随意调整连接，以确保所有设置都符合前面的代码。如果您在正向条件下发现两侧都出现相反的旋转，请反转电机连接。
- en: Observe how efficiently motors are controlled by a very simple code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 观察电机是如何通过一个非常简单的代码进行高效控制的。
- en: Now that we know how to control motors more effectively, we'll now move forward
    with our special black-e-track UGV platform where we developed our own controller
    for controlling the robot. Almost all the parts were bought from [http://robokits.co.in](http://robokits.co.in).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何更有效地控制电机，我们将继续介绍我们特殊的黑色轨道UGV平台，我们在该平台上开发了用于控制机器人的控制器。几乎所有部件都是从[http://robokits.co.in](http://robokits.co.in)购买的。
- en: 4WD UGV (black-e-track)
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4WD UGV（黑色轨道）
- en: 'The name might be a bit fancy but this UGV is quite simple with the only difference
    being that it contained four high torque motors powered by a single dual driver
    motor driver circuit. Initially, we used two driver circuits but then we shifted
    to one. It was powered by a Li-Po battery but all tests were conducted using an
    SMPS. The UGV was controlled by a WPF application with the name of universal remote
    controller. This UGV was also fitted with a camera with an operating frequency
    of 5.8 GHz. The UGV was also wireless using a 2.4 GHz RF module. Let''s have a
    look at the hardware required apart from the Intel Edison:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 名称可能有点花哨，但这个UGV相当简单，唯一的区别是它包含由单个双驱动器电机驱动电路供电的四个高扭矩电机。最初，我们使用了两个驱动电路，但后来我们转向使用一个。它由锂离子电池供电，但所有测试都是使用SMPS进行的。UGV由名为通用遥控器的WPF应用程序控制。这个UGV还配备了一个工作频率为5.8
    GHz的摄像头。UGV还使用2.4 GHz射频模块进行无线连接。让我们看看除了Intel Edison之外所需的硬件：
- en: 30 cm by 30 cm chassis(1)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 30 cm x 30 cm 底盘(1)
- en: 10 cm diameter wheels(4)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10 cm 直径的轮子(4)
- en: High torque motors 300 RPM 12V(4)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高扭矩电机 300 RPM 12V(4)
- en: 20A dual motor driver(1)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 20A 双电机驱动器(1)
- en: RF 2.4 GHz USB link(1)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RF 2.4 GHz USB 链路(1)
- en: RF 2.4 GHz Serial link(1)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RF 2.4 GHz 串行链路(1)
- en: 'Li-Po battery (minimum voltage supply: 12V; maximum current drawn: 3-4A)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锂离子电池（最小电压：12V；最大电流：3-4A）
- en: 'This section will cover the hardware aspect of it and how to develop the controller
    application using WPF. The chassis combined with the wheels falls under the deign
    principle discussed in preceding figure. Let''s have a look at the circuit diagram
    of the UGV. If the robot is made using the earlier mentioned hardware, then the
    robot will perform well in rough terrain and also be able to climb a steep slope
    of 60-65 degrees (tested):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖其硬件方面以及如何使用WPF开发控制器应用程序。底盘与车轮的组合属于前述图中讨论的设计原则。让我们看看UGV的电路图。如果机器人使用前面提到的硬件制作，那么机器人在崎岖地形上表现良好，并且能够爬上60-65度的陡坡（已测试）：
- en: '![](img/image_06_016.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_016.jpg)'
- en: Circuit Diagram for UGV
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: UGV 电路图
- en: 'Motor 1 represents the left hand side motors while motor 2 represents the right
    hand side motors. Both the left hand side motors are shorted and same goes for
    the left hand side motors as well. This particular UGV was programmed to receive
    certain characters through serial port communication and provide some action based
    on that. Now, let''s have a look at the code of the Intel Edison:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 电机1代表左侧电机，而电机2代表右侧电机。左侧电机是短路的，同样右侧电机也是如此。这个特定的UGV被编程通过串口通信接收某些字符，并根据这些字符执行某些操作。现在，让我们看看Intel
    Edison的代码：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code executes functions based on the data received. The following
    table summarises the characters responsible for the data received:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码根据接收到的数据执行函数。以下表格总结了负责接收数据的字符：
- en: '| **Character Received** | **Action Undertaken** |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **接收到的字符** | **执行的操作** |'
- en: '| `0` | Fast back |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 快速后退 |'
- en: '| `1` | Fast front |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `1` | 快速向前 |'
- en: '| `3` | Fast right |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `3` | 快速向右 |'
- en: '| `4` | Fast left |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `4` | 快速向左 |'
- en: '| `5` | Stop |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `5` | 停止 |'
- en: '| `6` | Slow front |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `6` | 慢速向前 |'
- en: '| `7` | Slow back |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `7` | 慢速后退 |'
- en: '| `8` | Slow right |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `8` | 慢速向右 |'
- en: '| `9` | Slow left |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `9` | 慢速向左 |'
- en: We have created two macros for max and slow speed. The parameters for methods
    of motion execution is the speed that is passed based on the data received. You
    can test it using your serial monitor. Now, that we have the hardware lets write
    a software for it. This software will be able to control the robot using keyboard
    as well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个宏，用于最大速度和慢速。运动执行方法参数是基于接收到的数据传递的速度。您可以使用串行监视器进行测试。现在，我们有了硬件，让我们为它编写软件。这个软件将能够通过键盘控制机器人。
- en: Universal robot controller for UGV
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UGV的通用机器人控制器
- en: 'Before deep diving into the controller, clone the following GitHub repository
    to your PC. The code is itself around 350+ lines so some parts are to be discussed:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨控制器之前，请将以下GitHub仓库克隆到您的电脑上。代码本身大约有350+行，因此需要讨论的部分：
- en: '[https://github.com/avirup171/bet_controller_urc](https://github.com/avirup171/bet_controller_urc)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/avirup171/bet_controller_urc](https://github.com/avirup171/bet_controller_urc)'
- en: 'So initially let''s design the UI first:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先设计UI：
- en: '![](img/image_06_017.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_017.png)'
- en: Screenshot of URC
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: URC截图
- en: For simplicity two sections of fast and slow controls are included. However
    it can be merged into one and using a checkbox. We have a connection pane on the
    right hand top side. The commands are displayed. A default password for `12345`
    was added which was done to avoid crashes and unauthorized use. However it's a
    simple controller and can be used with UGVs pretty much efficiently.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，包括了快速和慢速控制的两部分。然而，它们可以被合并为一个，并使用复选框。我们在右上角有一个连接面板。命令在此显示。添加了一个默认密码`12345`，这是为了避免崩溃和未经授权的使用。然而，这是一个简单的控制器，可以相当高效地与UGVs一起使用。
- en: 'If you have a close look over the UI, then you will find a button named Press
    to activate keyboard control. Once you click on the button, the keyboard control
    gets activated. Now here you need to assign keyboard pressed and keyboard release
    event. This can be done by selecting the control and in the properties windows,
    click on the following icon. This manages all the event handlers for the selected
    control:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细查看UI，会发现一个名为“按下以激活键盘控制”的按钮。一旦点击该按钮，键盘控制就会被激活。现在您需要分配键盘按下和键盘释放事件。这可以通过选择控件并在属性窗口中点击以下图标来完成。这管理着所选控件的全部事件处理器：
- en: '![](img/image_06_018.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_018.jpg)'
- en: Properties window
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 属性窗口
- en: When we press the key on a keyboard two events are triggered. The first is when
    we press the key and the second is when we release the key
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在键盘上按下键时，会触发两个事件。第一个事件是我们按下键时，第二个事件是我们释放键时
- en: 'Now when you click on it you will get all the possible events associated with
    it. Scroll down to KeyDown and KeyUp. Double click on both to create the associated
    event handlers. The control buttons have a different event associated with them.
    That is we send data when the button is pressed. When the button is released,
    5 which is for stop is sent. You can assign the events by the properties window
    as shown earlier:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您点击它时，您将得到与之相关的所有可能事件。滚动到KeyDown和KeyUp。双击两者以创建相关的事件处理器。控制按钮有不同的事件与之关联。也就是说，当按钮被按下时，我们发送数据。当按钮释放时，发送5，这是停止的代码。您可以通过属性窗口（如前所述）分配事件：
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Assign names to all the buttons and create their respective event handlers.
    We have also created three progress bars. A xaml code for a progress bar is shown
    as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有按钮分配名称并创建它们各自的事件处理程序。我们还创建了三个进度条。进度条的xaml代码如下所示：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For the keyboard up and down events, the respective xaml code is:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于键盘上下事件，相应的xaml代码如下：
- en: '[PRE14]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Two events are created. One for the key pressed and another for key released.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了两个事件。一个用于按键按下，另一个用于按键释放。
- en: 'The xaml code for the preceding UI is given as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 之前UI的xaml代码如下所示：
- en: '[PRE15]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that the UI is ready, let''s go to the main C# code. The event handlers
    are also in place. Initially include the `System.IO.Ports` namespace and create
    an object of that class. After that the keyboard pressed event will be handled
    with our code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在UI已经准备好，让我们转到主要的C#代码。事件处理程序也已就位。最初包含`System.IO.Ports`命名空间并创建该类的一个对象。之后，键盘按下事件将由我们的代码处理：
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code, we used the following keys:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了以下键：
- en: '| **Serial No** | **Keyboard keys** | **Commands executed** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **序列号** | **键盘按键** | **执行命令** |'
- en: '| `1` | *W* | Fast forward |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `1` | *W* | 快速前进 |'
- en: '| `2` | *A* | Fast left turn |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `2` | *A* | 快速左转 |'
- en: '| `3` | *S* | Fast backward |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `3` | *S* | 快速后退 |'
- en: '| `4` | *D* | Fast right turn |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `4` | *D* | 快速右转 |'
- en: '| `5` | Numpad *8* | Slow forward |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `5` | 数字键盘 *8* | 慢速前进 |'
- en: '| `6` | Numpad *2* | Slow Backward |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `6` | 数字键盘 *2* | 慢速后退 |'
- en: '| `7` | Numpad *4* | Slow left turn |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `7` | 数字键盘 *4* | 慢速左转 |'
- en: '| `8` | Numpad *6* | Slow right turn |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `8` | 数字键盘 *6* | 慢速右转 |'
- en: 'Based on the input, we sent that particular character. While for the key up
    or key released event, we simply send `5` which means stop:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 根据输入，我们发送特定的字符。而对于按键抬起或释放事件，我们简单地发送`5`，表示停止：
- en: '[PRE17]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The connect and disconnect events are same as before. Now each button will have
    two methods. The first one is of `GotMouseCapture` and the second one is of `LostMouseCapture`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 连接和断开事件与之前相同。现在每个按钮将有两个方法。第一个是`GotMouseCapture`，第二个是`LostMouseCapture`。
- en: 'Take the example of the front button under fast control:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以快速控制下的前按钮为例：
- en: '[PRE18]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly apply it for the other controls. Only 360 degree left and right is
    associated with a button click event. The entire code is pasted as shown below
    of `MainWindow.xaml.cs`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，应用于其他控制。只有左右360度旋转与按钮点击事件相关联。整个代码如下所示，粘贴自`MainWindow.xaml.cs`：
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, some facts to be noted are as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，需要注意以下事实：
- en: If the password is not entered, all the buttons are disabled
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未输入密码，所有按钮都将禁用。
- en: The password in `12345`
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码为`12345`
- en: All buttons are associated with `gotMouseCapture` and `lostMouseCapture`
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有按钮都与`gotMouseCapture`和`lostMouseCapture`相关联。
- en: Only 360 degree rotation button follows a click event
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有360度旋转按钮遵循点击事件
- en: 'Once you are able to successfully develop the project, test it out. Connect
    the RF USB link to your PC. Install all the required drivers and test it out.The
    entire process is mentioned as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您成功开发项目，进行测试。将射频USB链路连接到您的PC。安装所有必需的驱动程序并测试。整个过程如下所述：
- en: Connect the RF USB link to your PC.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将射频USB链路连接到您的PC。
- en: Make sure your Intel Edison is powered on and connected to our bot. You can
    use a USB hub to power the Intel Edison and connect the hub to a power bank.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的英特尔爱迪生已开启并连接到我们的机器人。您可以使用USB集线器为英特尔爱迪生供电，并将集线器连接到充电宝。
- en: After you click on connect, the WPF application should get connected to your
    RF device.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击连接后，WPF应用程序应连接到您的射频设备。
- en: Test whether your robot is working. Use a FPV 5.8 GHz camera to get a live view
    from your UGV.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试您的机器人是否工作。使用5.8 GHz FPV摄像头从您的UGV获取实时视图。
- en: Open-ended question for the reader
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对读者的开放式问题
- en: What we have developed so far is a kind of UGV and not typically a robot, although
    we can configure it to be one. To develop an autonomous and manual robot, we normally
    design a robot to perform a certain task, however we keep manual control as well
    so that we can take back control whenever we desire. More appropriately, it may
    not be fully manual nor fully autonomous. Think of a drone. We just specify the
    waypoints on the map and the drone follows the waypoints. That's one of the classic
    examples. Now the reader's job is to combine the line follower robot discussed
    previously and manual robot discussed here and combine it into a single platform.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止开发的是一种无人地面车辆（UGV），而不是典型的机器人，尽管我们可以配置它成为机器人。为了开发一个自主和手动控制的机器人，我们通常设计一个机器人来完成特定的任务，然而我们仍然保留手动控制，以便我们可以在任何时候取回控制权。更恰当地说，它可能既不完全手动也不完全自主。想想无人机。我们只需在地图上指定航点，无人机就会跟随航点。这是经典的例子之一。现在读者的任务是结合之前讨论的线跟踪机器人以及这里讨论的手动机器人，并将它们合并成一个单一的平台。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have come to the end of the chapter as well as to the end of the book. In
    this chapter, we had a chance to have a look at some in-depth concepts of manual
    robotics and UGVs. We developed our own software for robot controlling. We also
    learned how to make our robots wireless and the ways to access multiple serial
    ports. Finally, we controlled our robot using our own controller. In [Chapter
    3](3bd53219-a287-4d8f-9a58-5a06c5b14062.xhtml), *Intel Edison and IoT (Home Automation)*,we
    have learned how to control the Edison using an Android app with the MQTT protocol.
    That technique can also be used to control a robot by using the `mraa` library.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了本章以及本书的结尾。在本章中，我们有幸了解了手动机器人和UGVs的一些深入概念。我们为机器人控制开发了我们的软件。我们还学习了如何使我们的机器人无线，以及访问多个串行端口的方法。最后，我们使用自己的控制器控制了我们的机器人。在[第3章](3bd53219-a287-4d8f-9a58-5a06c5b14062.xhtml)“英特尔爱迪生和物联网（家庭自动化）”，我们学习了如何使用MQTT协议通过Android应用程序控制爱迪生。这项技术也可以通过使用`mraa`库来控制机器人。
- en: The entire book has covered multiple topics related to Intel Edison. Now it's
    your job to use the concepts discussed to come up with new projects and explore
    even further. The last two chapters purely concentrated on robotics based on Intel
    Edison, but these concepts may be applied to other devices, such as an Arduino.
    Visit [https://software.intel.com/en-us/iot/hardware/edison/documentation](https://software.intel.com/en-us/iot/hardware/edison/documentation) for
    more details and more in-depth study about the hardware.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 整本书涵盖了与英特尔爱迪生（Intel Edison）相关的多个主题。现在，你的任务是利用讨论的概念来提出新的项目，并进一步探索。最后两章纯粹集中在基于英特尔爱迪生的机器人技术，但这些概念也可以应用于其他设备，例如Arduino。访问[https://software.intel.com/en-us/iot/hardware/edison/documentation](https://software.intel.com/en-us/iot/hardware/edison/documentation)获取更多详细信息以及更深入的学习关于硬件的内容。
