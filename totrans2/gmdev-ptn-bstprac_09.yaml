- en: Decoupling Gameplay via the Observer Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow! The last two chapters were full of pointer craziness. Those two chapters
    combined, cover what are probably considered the hardest parts of C++. While all
    design patterns deal with pointers and using virtual functions at some level,
    it doesn't get much more difficult than what was covered in [Chapter 7](part0133.html#3UQQQ0-04600e4b10ea45a2839ef4fc3675aeb7),
    *Improving Performance with Object Pools* and [Chapter 8](part0143.html#48C0E0-04600e4b10ea45a2839ef4fc3675aeb7),
    *Controlling UI via the Command Pattern*.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](part0133.html#3UQQQ0-04600e4b10ea45a2839ef4fc3675aeb7), *Improving
    Performance with Object Pools*, we went very low-level into the guts of C++ memory.
    This involved casting and strange pointer manipulation that most people tend to
    avoid. In [Chapter 8](part0143.html#48C0E0-04600e4b10ea45a2839ef4fc3675aeb7),
    *Controlling UI via the Command Pattern*, we dealt with controlling the UI, which
    is more high-level. However, we learned how to control C++ objects and their methods
    in a way that allows us to create flexible code, but can also be very confusing.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel comfortable with those chapters, then you are doing great. If you
    felt that those topics were a little difficult, you are not alone. Either way,
    you should be excited to know that this chapter covers a pattern that is easy
    to understand, easy to implement, and easily allows us to decouple our core systems
    from the gameplay specific code that is likely to change often.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover a pattern called **Observer**, which is used
    to connect objects together in a decoupled way. As you will see, it is very simple
    to implement and can be applied in many places throughout our code base.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about learning how to decouple code using the Observer pattern.
    This chapter is a little different than the others because it isn't about using
    the Observer pattern to solve one big pattern; it is about learning to apply it
    to the many little situations that lead to sloppy code throughout a game's development.
    The Observer pattern will show you that there is a better way.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will explore the inevitable situation of gameplay code leaking into
    our engine code. Then, we will learn about the Observer pattern and how it can
    improve these situations. Along the way, we will look at some example code from
    the Mach5 Engine. However, since this pattern has so many uses, we will focus
    on how it can be incorporated into a game, as opposed to showing one large specific
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Your objectives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learn two ways that gameplay code can cause trouble for your engine code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the simple Observer pattern example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the pros and cons of the Observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How gameplay creeps into every system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first time someone makes a game, there is very likely no distinction between
    the game and the engine. This is usually because there is no engine. A common
    first game would include Ticktacktoe or Hangman. Games like these are simple enough
    that they can be completely written in main, or possibly using a few functions.
    They are also simple enough that they don't require complex systems like graphics
    or physics. There is no need for reusable engine code.
  prefs: []
  type: TYPE_NORMAL
- en: As you are learning to program more, you may decide to try making a 2D game
    using a graphics API, like DirectX or OpenGL. Code like this can be very difficult
    the first time it is used, so writing cleanly separated code isn't a top priority.
    Just as before, the game is made with just a few functions or classes. Drawing
    code is often mixed with collision code in one single file.
  prefs: []
  type: TYPE_NORMAL
- en: 'At some point, we all get to a place where the code is too complex and fragile.
    Hardcoding too many game object types or too many levels make us wish for a better
    way. Of course, that is the reason for this book. We are trying to find a better
    way to create games. Throughout this book there has been one major theme: things
    always change!'
  prefs: []
  type: TYPE_NORMAL
- en: To cope with this change, we have tried to create a clear distinction between
    the parts of our game that will change and the parts of the game that are unlikely
    to change. In clear terms, we are trying to separate our engine code from our
    gameplay code. This clear separation of parts has lead us through eight chapters
    of patterns that solve very large and specific problems in games. Every game must
    deal with creating flexible game objects with complex behaviors. So, we learned
    about the Component Object Model and Finite Stage Machines. Every game must deal
    with creating an easy to modify UI. So, we learned about using the Command pattern
    to read actions from a file. These are common problems with common solutions.
  prefs: []
  type: TYPE_NORMAL
- en: However, as you write more code and you start to add more features to your game,
    you will always find that the clear separation between engine and gameplay starts
    to blur. One place that this becomes obvious is physics. The physics engine is
    responsible for moving objects as well as testing for and resolving collisions.
  prefs: []
  type: TYPE_NORMAL
- en: While this engine should be purely mathematical, the fact is that a game is
    made up of more than just physics objects. It is made of bullets, raiders, players,
    and more. When a bullet collides with a player, we must execute some very specific
    gameplay code, such as deleting the bullet, creating a small particle effect at
    the collision point, and subtracting player health. The question is, where should
    this code be executed? If the code is placed inside the physics engine, it is
    highly coupled with every game object type. If it is executed outside of the engine,
    we need to get the collision information to the correct location in a clean way.
  prefs: []
  type: TYPE_NORMAL
- en: The same problem of creeping gameplay code occurs with achievements. Achievements
    are always game specific but they end up getting mixed all throughout a code base.
    They can range from tracking behavior such as how many bullets the player fired,
    to tracking total time played or how long the game has been paused. However, they
    could always be related to engine specific behavior such as how many times the
    resolution has been changed, how many network connections have been made, how
    many times a UFO game object was created or destroyed, or how many collision events
    of a certain kind have occurred. This blurred line between engine and gameplay
    code, as well as general increased dependencies, makes code reuse very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Hardcoding requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that introducing gameplay code to our engines increases dependencies
    and limits code reuse. We also know that for a given action, the requirements
    are likely to change as gameplay features are added. Imagine the situation of
    adding controller support for split screen multiplayer in our space shooter. As
    more controllers are plugged in, additional players are created, the game difficulty
    is increased, and we split the screen to follow the new player. In this case,
    the original controller detection occurs in the Input Manager, but we need to
    notify a few other engines that something has changed. An example of this code
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We might be reasonably certain that this code won't change. If we are, then
    hardcoding the requirements is fine. However, if we are not certain, it is good
    to assume that requirements always change. We might need to support online multiplayer
    and send a message to the Network Manager. We might allow the player to choose
    which type of space ship they want from a list of possible player ships, so we
    need to call a different Object Manager function or pause and switch to a new
    Ship Selection Stage via the Stage Manager.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we have a set of objects that need to be notified when an event
    occurs. We want the notification to happen automatically, but we don't want to
    change the Input Manager every time a new object needs to be notified. More generally,
    we have a broadcasting object that we don't want to change every time there is
    a new object that needs to listen. This would be like a Wi-Fi router needing to
    be updated every time a new device is in range.
  prefs: []
  type: TYPE_NORMAL
- en: The situation above describes interactions between different core engines. However,
    these interactions only happen this way because of the specific requirements of
    the game. Even though there is no gameplay code, the functionality of the specific
    game has crept into the input engine, and would need to be changed if we were
    making a different game. Of course, we could try to factor out some of this code
    into a game logic engine or just put similar code into a stage. Is there another
    way? We will consider that, but first, we will explore the problem from the other
    side.
  prefs: []
  type: TYPE_NORMAL
- en: Polling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite your best efforts, gameplay often turns into a mess. There are so many
    interacting parts that it is impossible to completely reduce coupling of gameplay
    code. While it makes sense that a graphics engine and a physics engine can be
    completely independent and decoupled, we shouldn't even try to do this with gameplay.
    Gameplay code is the game. The best we can do is to attempt to handle modifications
    to the game design gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious case of this is the state machines that we saw from [Chapter
    4](part0083.html#2F4UM0-04600e4b10ea45a2839ef4fc3675aeb7), *Artificial Intelligence
    using the State Pattern*. The states often need access to the Object Manager and
    so scan the entire list of objects looking for an object. They may also need access
    to physics to see if they are colliding with this frame or the next. The gameplay
    code is the code that glues everything else together, so it can't really be completely
    decoupled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of this could be drawing HUD objects in screen space. If the
    window resolution changes, the objects need to be reoriented. A button in the
    center of the screen at 800 x 600 must still be in the center of the screen at
    1280 x 1024\. That means the position can''t be hardcoded and must automatically
    adjust when the resolution changes. There are two ways of doing this. The first
    is the same as the example above; we could have the change resolution button call
    methods of other systems that care. The second would be for objects that care
    about resolution changes to ask the application for the resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here is an example `RepositionComponent`. Every frame, it asks the `M5App` for
    the window resolution and sets the object to the specified scale of the window.
    An object that needed to be in the center of the screen would have `x` and `y`
    scale values of `.5`. If the resolution is 800 x 600, the position of the object
    will be `x = 400`, `y = 300`. If the resolution changes to 1280 x 1024, the position
    of the object will be `x = 640`, `y = 512`.
  prefs: []
  type: TYPE_NORMAL
- en: This works exactly as expected, but it does a lot of unnecessary work. The problem
    isn't that this code will make your game slow; you could have thousands of objects
    doing this before seeing slowdown. Still, this component is asking for the resolution
    60 times a second, when a resolution change might only happen once per play session.
    More likely, the player will choose a resolution once, and the game settings will
    save it to a file and automatically load it every session after that.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this polling method is that the `RepositionComponent` has no
    way of knowing when the resolution changes. It would be nice if this code ran
    only when the data changed. Instead, it constantly asks for the exact same data,
    and calculates the exact same position every frame.
  prefs: []
  type: TYPE_NORMAL
- en: The example above is small. Problems like this may seem trivial. Individually,
    they won't even be a problem but, when added together, they can affect your game.
    This is true of all the examples so far in this chapter. They seem easy to solve
    one by one, but they can add up to lots of wasted CPU cycles as well as wasted
    developer time. It would be nice to have a pattern that is easy to implement that
    can solve little problems like these that pop up all over a game. Luckily, the
    Observer pattern will do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer pattern explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The intent of the Observer pattern is to define a one-to-many relationship between
    objects. When the state of one object changes, all its dependents are notified.
    The typical names for the objects in this pattern are the **Subject** (the one),
    and the **Observers** (the many). The Subject will contain data that the Observers
    need to know about. Instead of the usual situation of classes requesting data
    from another (polling), our Subject will notify a list of Observers when the data
    has changed.
  prefs: []
  type: TYPE_NORMAL
- en: The terms Subject and Observers may seem a little confusing at first. However,
    this concept is very easy, and one that most of us are familiar with. When trying
    to understand the Observer pattern, think of a blog and subscribers. In this case,
    the blog is the Subject and the subscribers are the Observers.
  prefs: []
  type: TYPE_NORMAL
- en: A blog may be updated once a day, once a week, once a month, or even less. Readers
    of the blog have the option to check for updates as much as they want, however
    this can waste a lot of time if the readers check more frequently than the blog
    is updated. Instead, fans will often choose to subscribe to an e-mail list so
    they can be notified of updates as they come. The blog keeps a list of subscribers
    and sends an e-mail to everyone on the list when an update is posted.
  prefs: []
  type: TYPE_NORMAL
- en: The Subject and Observer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a code example to understand this pattern better. There are
    a few different ways to implement this pattern, so we will discuss implementation
    strategies along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We start off with our `Observer` interface. As always, we make our destructor
    virtual. The only method we need is an `Update` method however, as always, the
    name isn't important. This is the method that the Subject will use to notify the
    Observers that something has changed. One thing you might notice is that the update
    is very specific. In this case, it has two floats as arguments. This is a dependency
    that might change and cause our code to break. We will address improvements a
    little later.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also notice that there is no member data. It could be possible to
    give the base class a pointer to the Subject, and have this class be responsible
    for registering and unregistering (subscribing and unsubscribing) with the Subject.
    We decided to move that behavior into the derived classes so we could keep the
    base class as simple as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our Subject is almost as simple as the Observer. The key methods we need are
    ways for the Observers to subscribe and unsubscribe to the Subject. Here, we called
    those methods `RegisterObserver` and `UnregisterObserver`. We have also added
    a `Notify` method which will be used to call `Update` on all registered Observers.
    There is no reason that this method needs to be public or even exist at all. As
    long as the derived class calls `Update` on the registered Observers, we are using
    the pattern correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Again, you will notice that there are no data members in this class. We could
    easily add a vector of Observer pointers here in the base class. In fact, we could
    easily implement these methods because they will almost always be the same. However,
    we have chosen to keep this class simple and let the derived classes choose how
    to implement these methods.
  prefs: []
  type: TYPE_NORMAL
- en: The Player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate how the Observer pattern can be used, we will look at a common
    situation in games. We will have a Player with some health that will need to be
    shared. The health of the Player can often be used for many things in a game.
    The value of health might be displayed as part of the HUD. It can also be displayed
    as a colored health bar in either the HUD or directly at the top or at the bottom
    of the Player. Additionally, the game may switch to a game over screen when the
    Player health is at or below zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'These display elements, as well as the stage switching mechanisms, are dependent
    directly on the Player''s health. Since it is very unlikely that these variables
    are all in the same scope, it would take some work if we tried to implement this
    via polling. In that case, each object would need to find the Player and ask for
    the health value. Since the health of the Player is unlikely to change every frame,
    most of this work is being wasted. Instead, we will make the Player derive from
    the Subject so it can notify all Observers when the health has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This `Player` class is very simple. Since this is only an example, we will
    only be focusing on the health. In the constructor, we can set the max health.
    The `AdjustHealth` method will be used to make the health change. Of course, we
    also implement each of the base class virtual methods. In the `private` section,
    we use an STL vector to keep track of our Observers. We also store our constructor
    value, as well as a variable for our current health:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Player` constructor sets data passed in by the user. Since the base `Subject`
    class has no data, there is nothing special to do here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RegisterObserver` method takes a pointer to an Observer and adds it to
    the vector of the Observers. Depending on the behavior of the Observer, being
    added to the list twice could cause a lot of problems and could be a difficult
    bug to track down. In this example, we have chosen to assert if the same Observer
    is added twice. After that, we add it to our vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `UnregisterObserver` class is a little more forgiving. If we don''t find
    the Observer in the vector, we ignore it, instead of throwing an assert. This
    will make a little more sense later. You will see that our Observers will automatically
    remove or unregister in their own destructors. However, unregistering twice is
    unlikely to cause a problem. The line `std::swap(*itor, *(--m_observers.end()))`
    might look a little scary. Remember that the end method returns an iterator to
    one past the end of the vector. So, before we dereference, we decrement our iterator
    so it is pointing at the last element in the vector. Then we swap and pop, removing
    the correct element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we said before, the `Notify` method doesn't need to exist. It would be fine
    if the class logic notifies the Observers internally, perhaps in `Setter` methods
    or when the data changes as in our `AdjustHealth` method. However, if there was
    more than one piece of data that the Observers cared about, the user could make
    many changes and send all the data to the Observers just once. Or, perhaps initializing
    the Observer data before the game has started.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is simple. It loops through the vector of the Observers and calls
    the `Update` method, sending the health data to those that care:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method simulates the Player gaining or losing health. As you can see, after
    the health is modified, the class calls its own `Notify` method, letting all Observers
    know about the change.
  prefs: []
  type: TYPE_NORMAL
- en: The Observers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this example, we have the three Observers that we mentioned before. Two
    are related to displaying the health of the Player in different ways; the other
    is used for quitting when the health of the Player is zero or less:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, each derived `Observer` class overloads the `Update` method
    from base. You will also notice that each constructor takes a pointer to a Subject
    as the only parameter, and saves that pointer into a member variable. This isn''t
    necessary, but it makes registering and unregistering more convenient because
    the objects take care of themselves. In this example, all three of the Observers''
    constructors and destructors do the exact same thing. Here is one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The choice of keeping a pointer to the Subject is up to you. It has some problems,
    which we will look at a little later; however, it allows the Observer to unregister
    in the destructor. This means that the user doesn't need to do it, which makes
    using the `Observers` classes very easy. If we don't keep this pointer, unregistering
    must be done manually and could be difficult depending on how you access the Subject
    and Observers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the `Observer` methods are simple and don''t interact with the
    Subject at all. Instead, the `Update` methods do some logic based on the values
    of `currentHealth` and `maxHealth`. For the two display elements, this means calculating
    some values; for the `StageLogic` class, this means setting `m_isQuitting` to
    true if the value of current health is zero or less. Let''s look at an example
    `Update` from one of the Observers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9 1 Interaction of Subjects and Observers
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `Update` methods aren''t very complicated. Nothing about
    the above method is using the Subject. The data could have come from anywhere.
    The part that is most interesting is how simple these objects are to use now.
    All three Observers are using the Player''s health, but they don''t need to call
    any `Player` methods. Even though these four objects interact, using them is incredibly
    simple. Let''s look at how we can use these objects together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` function starts out with a few `const` values to improve readability.
    After that, we create our objects. We first create our `Player`, which is our
    Subject. Then we create our Observers. Each Observer gets a pointer to the Subject.
    Remember, they are only dependent on the Subject interface, not to the derived
    `Player` class. Once all the Observers are created, the `Player` does an initial
    `Notify` call so the Observers start out with the correct data. Finally, we use
    our objects. The simplicity of this while loop is amazing. Since the code linking
    them together is all internal, using the objects together becomes very easy. Compare
    the example above with a version of the code that doesn''t use the Observer pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using the Observer pattern allows us to write code that is more elegant and
    simple to use. Unfortunately, many programmers write code that is closer to the
    second version. They don't realize that with just a little thought as to how the
    objects will interact, the code is easier to use, easier to read, and is more
    efficient because it only gets data from the Player when the data changes.
  prefs: []
  type: TYPE_NORMAL
- en: In this simple example, it may not seem like the code is much different, but
    remember that this is just demonstrating the pattern as simply as possible. The
    second version looks reasonable because all the objects are in the same scope.
    Except for the constructor, in a real project, the Observer code stays the same.
    However, the second version can become a mess of Singleton method calls and object
    look ups.
  prefs: []
  type: TYPE_NORMAL
- en: Push versus Pull
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One big problem with the Observer pattern that we have looked at so far is that
    the `Update` method in the base class is limited. In our case, it can only be
    used with Observers that expect two floats. If we want a different style of Observer,
    we need to create a new `Observer` class and a new Subject to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: This Push version of the pattern is great because the classes are completely
    decoupled. The derived classes don't need to know about each other at all. The
    price to pay for this decoupling is that we need to write lots of `Subject` and
    `Observer` base classes for each method signature we want to use. An alternative
    version of this pattern lets the Observers pull the data they want from the Subject.
    In the Pull version, the Subject sends itself as a parameter in the `Update` method,
    and the Observer uses `Getter` methods from the Subject to only pull the data
    it wants.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is exactly what is happening in our next example. The `PlayerHealthBar`
    class now takes a pointer to a Subject. In this case, we are expecting the Subject
    to be of type Player. The `Update` method can then use any Player data it needs
    to complete its task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the Pull version of the pattern, the `Observer` is dependent on the derived
    `Subject` class (in this case the Player), but the `Update` method is more flexible.
    Additionally, this Observer could be observing many different Subjects. The `Update`
    method could have a series of `if` statements to determine which of the many possible
    Subjects performed the call. The classes are more tightly coupled to specific
    objects. However, since an Observer can now observe multiple Subjects, the same
    `Observer` class can be used for a wider range of objects. For example, a single
    `Observer` class could be used to keep track of how many objects of each type
    in the game have died by registering itself with every game object that gets created
    and monitoring the health of all Subjects.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of using the Observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the start of this chapter we saw three problems with interacting gameplay
    code. As we said before, these problems aren't that big, but they creep up all
    over the place and can lead to inflexible code as the project moves forward. The
    Observer pattern solves these problems in a very simple way.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest benefit of using the Observer pattern is that we can reduce dependency
    and coupling. By using the Push version of the Observer pattern, our classes can
    interact completely through interfaces, so they don't depend on each other at
    all. In the preceding example, the Player and Player Display are completely decoupled.
    This means that changes to one won't affect the other. For starters, this makes
    each class easier to test and debug because they can be worked on separately.
    However, this also means that as the game changes, these classes can change independently.
    This means the individual class can easily be reused within the current project
    or in separate projects. The only problem with the Push version is that we are
    stuck with a single `Update` method signature.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Pull version of the Observer pattern increases the dependencies; however,
    the Subject/Observer system is much more flexible. An Observer can now listen
    to multiple Subjects, and a Subject can share different data with each of its
    Observers. Even though the dependencies are increased, this is only on the Observer
    side, since Subjects still don't need to know about their Observers. These increased
    dependencies are still better than the alternative, because they are limited to
    only the two classes that need to interact. Without using the Observer pattern,
    a third class would need to be used to link these two classes together.
  prefs: []
  type: TYPE_NORMAL
- en: The second benefit of this pattern is that we no longer need to hardcode methods
    or requirements. Since the event is broadcast to any object that registers, there
    is no need to recompile if a new object needs the event. This reduces compile
    times as well as limits the chance of breaking code.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't just limited to connecting systems to other systems. Since Observers
    can register and unregister at runtime, game objects can register themselves with
    other game objects. Imagine an Enemy Space Station that continuously spawns Raiders.
    By registering Raiders with the station that spawned them, each station can act
    as a mini commander, easily coordinating units for attack and defense.
  prefs: []
  type: TYPE_NORMAL
- en: The last benefit is that there is no need to poll objects. In the preceding
    example, we saw two `while` loops--one using the Observer pattern, and one polling
    for data every frame. We saw how much cleaner the code looked when using the Observer
    pattern. Besides just looking cleaner, the first example is less likely to have
    bugs because once registered, the Observer will always receive the updated data.
    In a larger project, the alternative requires that every object constantly asks
    for the data all over the code base. Ensuring that every object that needs the
    data asks every frame in many locations can be a Herculean task.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being very difficult to find and maintain each poll occurrence,
    this method leads to less efficient code. We shouldn't try to prematurely optimize
    our code, and most likely this won't be the bottleneck of our game, so that is
    why we mentioned it last. However, the fastest code is the code that never runs.
    When using the Observer pattern, if the data never changes and the event never
    occurs, the `Update` methods never get called. So, using the Observer method has
    the chance to boost our performance compared to polling dozens or hundreds of
    times per frame.
  prefs: []
  type: TYPE_NORMAL
- en: Problems using the Observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, the Observer pattern isn't a perfect solution. There is no perfect
    solution, if there was, this would be a very short book. As with every pattern,
    it is important to learn how to use it but also how not to use it. It is equally
    as important to learn when to use a pattern as it is to learn when not to use
    a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer pattern has some things that you need to look out for when using
    it. The goal of all patterns is to simplify the development cycle. However, if
    a pattern isn't fully understood, lots of time can be wasted debugging layers
    and layers of code that were meant to save time.
  prefs: []
  type: TYPE_NORMAL
- en: Dangling references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first major problem that everyone should be aware of is the problem of dangling
    references. We must ensure that the pointers held by our objects never become
    invalidated. The best way to understand this problem is to look at the Command
    pattern and compare it with the Observer.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest difference between the Command pattern and the Observer pattern
    is a difference in ownership. In the Command pattern, the client or user of the
    command owns a pointer. This means that the client is responsible for deleting
    the command. The reason this is important is because no other class owns the command
    pointer, so it should never become invalidated. In the Mach5 Engine, the `UIButtonComponent`
    owns a command. It deletes that command in the destructor or when it is given
    a new command pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Contrast this with the Observer pattern. The Subject contains a pointer to an
    Observer, and the Observer can hold a pointer to the Subject. Neither object owns
    the other, and either object can be deleted at any time. They are separate objects
    that just happen to communicate with each other via pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Before an Observer is deleted, it must be unregistered from every Subject it
    is observing. Otherwise, the Subjects will keep trying to Update it via the invalid
    pointer, causing undefined behavior. In the example, we do this by having the
    Observer hold a pointer to the Subject and unregistering itself in the destructor.
    This causes a problem if the Subject gets deleted first. In the example, there
    is no way for the Subject to tell the Observer that it will be deleted. If the
    Subject does get deleted first, the Observers will still try to unregister in
    their own destructor, causing undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: There are two solutions to this problem. First, we could ensure the Subject
    never gets deleted before the Observers. Second, we could remove the Subject pointer
    from the Observer and ensure that the Observer still gets unregistered from the
    correct Subject before it is deleted. Both solutions can be difficult to guarantee.
    If you implement the Observer pattern in your game, you must consider this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Overuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second problem with the Observer pattern is the danger of overuse. We stated
    before that the Observer pattern is a great choice when the requirements of a
    method aren't completely known or are likely to change. While it is true that
    anything in a game can change, taking this to the extreme would create a project
    that is impossible to program in and that will never be completed. In the most
    extreme case, every object could be both a Subject and an Observer. Every method
    would be ultimately flexible because we could change everything about it at runtime.
    Every call would notify Observers, which in turn would notify more Observers.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, no one would implement their engine to that extreme, but overuse
    of the Observer pattern is still a problem. It can be difficult to debug a method
    that notifies a long list of Observers. This becomes even worse if there are multiple
    layers to traverse before finding any real code. It can be difficult to find the
    right balance. If you feel like your code is becoming a spider web of interconnected
    pointers, it might be time to look for a better solution.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing to consider is the implementation of the Observer pattern. In
    the above example, the Subject and the Observer were designed to be interface
    classes. C++ doesn't have a language feature that supports interfaces but that
    doesn't mean we can't write code that uses them.
  prefs: []
  type: TYPE_NORMAL
- en: An interface is a class that contains no data members and has no method implementations.
    C++ does allow for the concept of abstract base classes. This is any class that
    marks at least one method a pure virtual, but using the `= 0` notation. This means
    that the class can't be instantiated and instead must be derived from. This is
    different from an interface because abstract base classes can contain member data
    as well as implementations for methods (including pure virtual methods).
  prefs: []
  type: TYPE_NORMAL
- en: This distinction is important to us because C++ allows for multiple inheritance,
    although it is strongly recommended that you do not use this feature. Inheriting
    from multiple base classes means that you could be inheriting data members and
    methods with the same name. Since each of the parents could also be inheriting
    from multiple classes, it can be difficult to fully understand the entire tree
    that any derived class gets the implementations from. This will almost certainly
    lead to unexpected behavior. That is why you should avoid multiple inheritances
    and instead stick with a single parent class that your implementation derives
    from.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces are a little different. Many languages do not let you inherit from
    multiple classes that contain implementations, but they do let you implement multiple
    interfaces. Since interfaces do not contain method implementations or data members,
    there is no chance of having name clashes or inheriting unexpected behavior. By
    implementing an interface, you are simply promising that your class will respond
    to a method call. It is the responsibility of the derived class to write the behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The Subject and Observer were written as interface classes in case they need
    to be used with Stages, Components, or any other class that already needs to derive
    from a base class. Of course, instead of using multiple inheritance, you could
    always find another solution. For example, you could create a new class that derives
    from the Observer and have your component contain, as opposed to inherit, that
    new class.
  prefs: []
  type: TYPE_NORMAL
- en: When to notify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final thing to consider when using the Observer pattern is when to notify
    the Observers. The first option is to notify the Observers after any data has
    changed. In the above example, the Player called `Notify` within the `AdjustHealth`
    method. This means that the Observers will have the most up to date information
    immediately. However, if the `AdjustHealth` method is called many times in one
    frame, time is wasted updating the Observers many times. This problem becomes
    worse if the Observers were observing more than just the Player's health.
  prefs: []
  type: TYPE_NORMAL
- en: The other option would be to notify the Observers after all data has changed.
    This solution is obviously more efficient but a lot depends on how your system
    works. In the preceding example, it could be possible to update all the Player
    information (in this case, just the health) first, then call `Notify` before displaying
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: In a game engine with many different Subjects and Observers that interact in
    different ways every frame, it can be difficult to know when all data has been
    updated. There might not be a way to sort the game objects such that all Subjects
    are updated before the Observers. It is possible that a HUD object that is an
    Observer has already been updated before the Subject gets updated. This becomes
    even more difficult since other systems such as physics can affect the data inside
    game objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, there isn't a correct time to notify the Observers. It can be more
    efficient to only notify them once. However, if the system is complex, it probably
    isn't worth the programming trouble trying to batch all `Notify` calls together.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on the communication between reusable engine code
    and game specific gameplay code. We learned that it can be difficult to make a
    clear distinction between these two parts because the gameplay code has the potential
    to creep into every system. This makes sense because to make a game, you must
    write code that interacts with every other system. However, this means reusing
    code is a little difficult.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that the solution to this was to decouple our engine and gameplay code
    by having all communication go through interface classes. These interface classes
    were the basis for what is known as the Observer pattern. By using this pattern,
    we can make our code much cleaner and easier to use, and reuse.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer pattern is as easy as it gets when it comes to design patterns.
    Few patterns are as simple to implement or understand. Once you start using it
    you will wonder how you ever programmed without it. However, we also learned there
    are some things to watch out for when using the pattern, the worst of which is
    dangling references.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a great tool for separating gameplay from our engine, let's
    move onto another problem related to code reuse. In the next chapter, we will
    talk about a pattern that allows us to reuse objects and save memory. Along the
    way, we will learn about making great particle systems.
  prefs: []
  type: TYPE_NORMAL
