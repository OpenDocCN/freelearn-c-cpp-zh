- en: Chapter 5. Implementing Optimizations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Writing a dead code elimination pass
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an inlining transformation pass
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a pass for memory optimization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining LLVM IR
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming and optimizing loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reassociating expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vectorizing IR
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other optimization passes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to write a pass in LLVM. We also demonstrated
    writing a few analysis passes with an example of alias analysis. Those passes
    just read the source code and gave us information about it. In this chapter, we
    will go further and write transformation passes that will actually change the
    source code, trying to optimize it for the faster execution of code. In the first
    two recipes, we will show you how a transformation pass is written and how it
    changes the code. After that, we will see how we can make changes in the code
    of passes to tinker with the behavior of the passes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Writing a dead code elimination pass
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to eliminate dead code from the program.
    By dead code elimination, we mean removing the code that has no effect whatsoever
    on the results that the source program outputs on executing. The main reasons
    to do so are reduction of the program size, which makes the code quality good
    and makes it easier to debug the code later on; and improving the run time of
    the program, as the unnecessary code is prevented from being executed. In this
    recipe, we will show you a variant of dead code elimination, called aggressive
    dead code elimination, that assumes every piece of code to be dead until proven
    otherwise. We will see how to implement this pass ourselves, and what modifications
    we need to make so that the pass can run just like other passes in the `lib/Transforms/Scalar`
    folder of the LLVM trunk.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To show the implementation of dead code elimination, we will need a piece of
    test code, on which we will run the aggressive dead code elimination pass:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this test code, we can see that a call to the `strlen` function is made in
    the `test` function, but the return value is not used. So, this should be treated
    as dead code by our pass.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file, include the `InitializePasses.h` file, located at `/llvm/`; and
    in the `llvm` namespace, add an entry for the pass that we are going to write:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `scalar.h` file, located at `include/llvm-c/scalar.h/Transform/`, add
    the entry for the pass:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `include/llvm/Transform/scalar.h` file, add the entry for the pass in
    the `llvm` namespace:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `lib/Transforms/Scalar/scalar.cpp` file, add the entry for the pass
    in two places. In the `void` `llvm::initializeScalarOpts(PassRegistry` `&Registry)`
    function, add the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now write the code for the pass:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the necessary header files:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Declare the structure of our pass:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Initialize the pass and its ID:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the actual pass in the `runOnFunction` function:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the preceding pass after compiling the `testcode.ll` file, which can be
    found in the *Getting ready* section of this recipe:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pass works by first collecting a list of all the root instructions that
    are live in the first `for` loop of the `runOnFunction` function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Using this information, we move backwards, propagating liveness to the operands
    in the `while` `(!Worklist.empty())` loop.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: In the next `for` loop, we remove the instructions that are not live, that is,
    dead. Also, we check whether any reference was made to these values. If so, we
    drop all such references, which are also dead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: On running the the pass on the test code, we see the dead code; the call to
    the `strlen` function is removed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Note that the code has been added to the LLVM trunk revision number 234045\.
    So, when you are actually trying to implement it, some definitions might be updated.
    In this case, modify the code accordingly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For various other kinds of dead code elimination method, you can refer to the
    `llvm/lib/Transfroms/Scalar` folder, where the code for other kinds of DCEs is
    present.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Writing an inlining transformation pass
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, by inlining we mean expanding the function body of the function
    called at the call site, as it may prove useful through faster execution of code.
    The compiler takes the decision whether to inline a function or not. In this recipe,
    you will learn to how to write a simple function-inlining pass that makes use
    of the implementation in LLVM for inlining. We will write a pass that will handle
    the functions marked with the `alwaysinline` attribute.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write a test code that we will run our pass on. Make the necessary changes
    in the `lib/Transforms/IPO/IPO.cpp` and `include/llvm/InitializePasses.h` files,
    the `include/llvm/Transforms/IPO.h` file, and the `/include/llvm-c/Transforms/IPO.h`
    file to include the following pass. Also make the necessary `makefile` changes
    to include his pass:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now write the code for the pass:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the necessary header files:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Describe the class for our pass:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Initialize the pass and add the dependencies:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Implement the function to get the inlining cost:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Write the other helper methods:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Compile the pass. After compiling, run it on the preceding test case:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pass that we have written will work for the functions with the `alwaysinline`
    attribute. The pass will always inline such functions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The main function at work here is `InlineCost` `getInlineCost(CallSite` `CS)`.
    This is a function in the `inliner.cpp` file, which needs to be overridden here.
    So, on the basis of the inlining cost calculated here, we decide whether or not
    to inline a function. The actual implementation, on how the inlining process works,
    is in the `inliner.cpp` file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we return `InlineCost::getAlways()`; for the functions marked
    with the `alwaysinline` attribute. For the others, we return `InlineCost::getNever()`.
    In this way, we can implement inlining for this simple case. If you want to dig
    deeper and try other variations of inlining—and learn how to make decisions about
    inlining—you can check out the `inlining.cpp` file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: When this pass is run over the test code, we see that the call of the `inner1`
    function is replaced by its actual function body.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Writing a pass for memory optimization
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will briefly discuss a transformation pass that deals with
    memory optimization.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need the opt tool installed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write the test code on which we will run the `memcpy` optimization pass:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the `memcpyopt` pass on the preceding test case:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Memcpyopt` pass deals with eliminating the `memcpy` calls wherever possible,
    or transforms them into other calls.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this `memcpy` call:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '`call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arr_i8, i8* bitcast ([3 x i32]*
    @cst to i8*), i64 12, i32 4, i1 false)`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding test case, this pass converts it into a `memset` call:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '`call void @llvm.memset.p0i8.i64(i8* %arr_i8, i8 -1, i64 12, i32 4, i1 false)`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: If we look into the source code of the pass, we realize that this transformation
    is brought about by the `tryMergingIntoMemset` function in the `MemCpyOptimizer.cpp`
    file in `llvm/lib/Transforms/Scalar`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The `tryMergingIntoMemset` function looks for some other pattern to fold away
    when scanning forward over instructions. It looks for stores in the neighboring
    memory and, on seeing consecutive ones, it attempts to merge them together into
    `memset`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The `processMemSet` function looks out for any other neighboring `memset` to
    this `memset`, which helps us widen out the `memset` call to create a single larger
    store.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see the details of the various types of memory optimization passes, go to
    [http://llvm.org/docs/Passes.html#memcpyopt-memcpy-optimization](http://llvm.org/docs/Passes.html#memcpyopt-memcpy-optimization).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Combining LLVM IR
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about instruction combining in LLVM. By instruction
    combining, we mean replacing a sequence of instructions with more efficient instructions
    that produce the same result in fewer machine cycles. In this recipe, we will
    see how we can make modifications in the LLVM code to combine certain instructions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test our implementation, we will write test code that we will use to verify
    that our implementation is working properly to combine instructions:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the `lib/Transforms/InstCombine/InstCombineAndOrXor.cpp` file.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `InstCombiner::visitXor(BinaryOperator` `&I)` function, go to the `if`
    condition—`if` `(Op0I` `&&` `Op1I)`—and add this:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now build LLVM again so that the Opt tool can use the new functionality and
    run the test case in this way:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we added code to the instruction combining file, which handles
    transformations involving the AND, OR, and XOR operators.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: We added code for matching the pattern of the `(A` `|` `(B` `^` `C))` `^` `((A`
    `^` `C)` `^` `B)` form, and reduced it to `A` `&` `(B` `^` `C)`. The `if (match(Op0I,
    m_Or(m_Xor(m_Value(B), m_Value(C)), m_Value(A))) && match(Op1I, m_Xor( m_Xor(m_Specific(A),
    m_Specific(C)), m_Specific(B))))` line looks out for the pattern similar to the
    one shown at the start of this paragraph.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The `return` `BinaryOperator::CreateAnd(A,` `Builder->CreateXor(B,C));` line
    returns the reduced value after building a new instruction, replacing the previous
    matched code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: When we run the `instcombine` pass over the test code, we get the reduced result.
    You can see the number of operations is reduced from five to two.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of instruction combining is very wide, and there are loads and loads
    of possibilities. Similar to the instruction combining function is the instruction
    simplify function, where we simplify complicated instructions but don't necessarily
    reduce the number of instructions, as is the case with instruction combining.
    To look more deeply into this, go through the code in the `lib/Transforms/InstCombine`
    folder
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming and optimizing loops
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can transform and optimize loops to get shorter
    execution times. We will mainly be looking into the **Loop-Invariant Code Motion**
    (**LICM**) optimization technique, and see how it works and how it transforms
    the code. We will also look at a relatively simpler technique called **loop deletion**,
    where we eliminate loops with non-infinite, computable trip counts that have no
    side effects on a function's return value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You must have the opt tool built for this recipe.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write the test cases for the LICM pass:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Execute the LICM pass on this test code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Write the test code for the loop deletion pass:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, run the loop deletion pass over the test code:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The LICM pass performs loop-invariant code motion; it tries to move the code
    that is not modified in the loop out of the loop. It can go either above the loop
    in the pre-header block, or after the loop exits from the exit block.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In the example shown earlier, we saw the `%i2` `=` `mul` `i32` `%i,` `17` part
    of the code being moved above the loop, as it is not getting modified within the
    loop block shown in that example.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The loop deletion pass looks out for loops with non-infinite trip counts that
    have no effect on the return value of the function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: In the test code, we saw how both the basic blocks `bb:` and `bb2:`, which have
    the loop part, get deleted. We also saw how the `foo` function directly branches
    to the return statement.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: There are many other techniques for optimizing loops, such as `loop-rotate`,
    `loop-unswitch`, and `loop-unroll`, which you can try yourself. You will then
    see how they affect the code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Reassociating expressions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about reassociating expressions and how it helps
    in optimization.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The opt tool should be installed for this recipe to work.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write the test case for a simple reassociate transformation:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the reassociate pass on this test case to see how the code is modified:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works …
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By reassociation, we mean applying algebraic properties such as associativity,
    commutativity, and distributivity to rearrange an expression to enable other optimizations,
    such as constant folding, LICM, and so on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we used the inverse property to eliminate patterns
    such as `"X` `+` `~X"` `->` `"-1"` using reassociation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The first three lines of the test case give us the expression of the form `(b+(a+1234))+~a`.
    In this expression, using the reassociate pass, we transform `a+~a` `to` `-1`.
    Hence, in the result, we get the final return value as `b+1234-1` `=` `b+1233`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The code that handles this transformation is in the `Reassociate.cpp` file,
    located under `lib/Transforms/Scalar`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look into this file, specifically the code segment, you can see that
    it checks whether there are `a` and `~a` in the operand list:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following code is responsible for handling and inserting the `-1` value
    when it gets such values in the expression:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Vectorizing IR
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Vectorization** is an important optimization for compilers where we can vectorize
    code to execute an instruction on multiple datasets in one go. If the backend
    architecture supports vector registers, a broad range of data can be loaded into
    those vector registers, and special vector instructions can be executed on the
    registers.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of vectorization in LLVM—**Superword-Level Parallelism**
    (**SLP**) and **loop vectorization**. Loop vectorization deals with vectorization
    opportunities in a loop, while SLP vectorization deals with vectorizing straight-line
    code in a basic block. In this recipe, we will see how straight-line code is vectorized.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SLP vectorization constructs a bottom-up tree of the IR expression, and broadly
    compares the nodes of the tree to see whether they are similar and hence can be
    combined to form vectors. The file to be modified is `lib/Transform/Vectorize/SLPVectorizer.cpp`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: We will try to vectorize a piece of straight-line code, such as `return` `a[0]`
    `+` `a[1]` `+` `a[2]` `+` `a[3]`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The expression tree for the preceding type of code will be a somewhat one-sided
    tree. We will run a DFS to store the operands and the operators.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'The IR for the preceding kind of expression will look like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The vectorization model follows three steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether it's legal to vectorize.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculating the profitability of the vectorized code over the scalarized code.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vectorizing the code if these two conditions are satisfied.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `SLPVectorizer.cpp` file. A new function needs to be implemented for
    DFS traversal of the expression tree for the IR shown in the *Getting ready* section:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Calculate the cost of the resultant vectorized IR and conclude whether it is
    profitable to vectorize. In the `SLPVectorizer.cpp` file, add the following lines
    to the `getReductionCost()` function:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the same function, after calculating `PairwiseRdxCost` and `SplittingRdxCost`,
    compare them with `HAddCost`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `vectorizeChainsInBlock()` function, call the `matchFlatReduction()`
    function you just defined:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define two global flags to keep a track of horizontal reduction, which feeds
    into a return:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Allow the vectorization of small trees if they feed into a return. Add the
    following line to the `isFullyVectorizableTinyTree()` function:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compile the LLVM project after saving the file containing the preceding code,
    and run the opt tool on the example IR, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `example.ll` file and paste the following IR in it:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the opt tool on `example.ll`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output will be vectorized code, like the following:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As observed, the code gets vectorized. The `matchFlatReduction()` function performs
    a DFS traversal of the expression and stores all the loads in `ReducedVals`, while
    adds are stored in `ReductionOps`. After this, the cost of horizontal vectorization
    is calculated in `HAddCost` and compared with scalar cost. It turns out to be
    profitable. Hence, it vectorizes the expression. This is handled in the `tryToReduce()`
    function, which is already implemented.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For detailed vectorization concepts, refer to the paper *Loop-Aware SLP in GCC*
    by Ira Rosen, Dorit Nuzman, and Ayal Zaks
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other optimization passes
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at some more transformational passes, which are
    more like of utility passes. We will look at the `strip-debug-symbols` pass and
    the `prune-eh` pass.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The opt tool must be installed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write a test case for checking the strip-debug pass, which strips off the debug
    symbols from the test code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the `strip-debug-symbols` pass by passing the `–strip-debug` command-line
    option to the `opt` tool:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Write a test case for checking the `prune-eh` pass:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Run the pass to remove unused exception information by passing the `–prune-eh`
    command-line option to the opt tool:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first case, where we are running the `strip-debug` pass, it removes the
    debug information from the code, and we can get compact code. This pass must be
    used only when we are looking for compact code, as it can delete the names of
    virtual registers and the symbols for internal global variables and functions,
    thus making the source code less readable and making it difficult to reverse engineer
    the code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The part of code that handles this transformation is located in the `llvm/lib/Transforms/IPO/StripSymbols.cpp`
    file, where the `StripDeadDebugInfo::runOnModule` function is responsible for
    stripping the debug information.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The second test is for removing unused exception information using the `prune-eh`
    pass, which implements an interprocedural pass. This walks the call-graph, turning
    invoke instructions into call instructions only if the callee cannot throw an
    exception, and marking functions as `nounwind` if they cannot throw the exceptions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试是使用`prune-eh`过程来移除未使用的异常信息，该过程实现了一个跨过程过程。它会遍历调用图，只有当被调用者不能抛出异常时，才将调用指令转换为调用指令，并且如果函数不能抛出异常，则将其标记为`nounwind`。
- en: See also
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to [http://llvm.org/docs/Passes.html#transform-passes](http://llvm.org/docs/Passes.html#transform-passes)
    for other transformation passes
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考以下链接了解其他转换过程：[http://llvm.org/docs/Passes.html#transform-passes](http://llvm.org/docs/Passes.html#transform-passes)
