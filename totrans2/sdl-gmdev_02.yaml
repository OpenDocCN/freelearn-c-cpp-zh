- en: Chapter 2. Drawing in SDL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphics are very important to games and they can also be one of the main performance
    bottlenecks if not handled correctly. With SDL 2.0 we can really take advantage
    of the GPU when rendering, which gives us a real boost in terms of the speed of
    rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of drawing with SDL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source and destination rectangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and displaying textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `SDL_image` extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic SDL drawing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter we created an SDL window but we have yet to render anything
    to the screen. SDL can use two structures to draw to the screen. One is the `SDL_Surface`
    structure, which contains a collection of pixels and is rendered using software
    rendering processes (not the GPU). The other is `SDL_Texture`; this can be used
    for hardware-accelerated rendering. We want our games to be as efficient as possible
    so we will focus on using `SDL_Texture`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting some images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need some images to load throughout this chapter. We do not want to spend
    any time creating art assets for our games at this point; we want to focus entirely
    on the programming side. In this book we will use assets from the `SpriteLib`
    collection available at [http://www.widgetworx.com/widgetworx/portfolio/spritelib.html](http://www.widgetworx.com/widgetworx/portfolio/spritelib.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'I have altered some of these files to allow us to easily use them in the upcoming
    chapters. These images are available with the source code download for this book.
    The first one we will use is the `rider.bmp` image file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting some images](img/6821OT_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating an SDL texture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First we will create a pointer to an `SDL_Texture` object as a member variable
    in our `Game.h` header file. We will also create some rectangles to be used when
    drawing the texture.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can load this texture in our game''s `init` function for now. Open up `Game.cpp`
    and follow the steps to load and draw an `SDL_Texture`:'
  prefs: []
  type: TYPE_NORMAL
- en: First we will make an assets folder to hold our images, place this in the same
    folder as your source code (not the executable code). When you want to distribute
    the game you will copy this assets folder along with your executable. But for
    development purposes we will keep it in the same folder as the source code. Place
    the `rider.bmp` file into this assets folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our game's `init` function we can load our image. We will use the `SDL_LoadBMP`
    function which returns an `SDL_Surface*`. From this `SDL_Surface*` we can create
    `SDL_Texture` structure using the `SDL_CreateTextureFromSurface` function. We
    then free the temporary surface, releasing any used memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have `SDL_Texture` ready to be drawn to the screen. We will first get
    the dimensions of the texture we have just loaded, and use them to set the width
    and height of `m_sourceRectangle` so that we can draw it correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Querying the texture will allow us to set the width and height of our source
    rectangle to the exact dimensions needed. So now that we have the correct height
    and width of our texture stored in `m_sourceRectangle` we must also set the destination
    rectangle's height and width. This is done so that our renderer knows which part
    of the window to draw our image to, and also the width and height of the image
    we want to render. We will set both x and y coordinates to `0` (top left). Window
    coordinates can be represented with an `x` and `y` value, with `x` being the horizontal
    position and `y` the vertical. Therefore the coordinates for the top-left of a
    window in SDL would be (0,0) and the center point would be the width of the window
    divided by two for `x`, and the height of the window divided by two for `y`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have a loaded texture and its dimensions, we can move on to rendering
    it to the screen. Move to our game's `render` function and we will add the code
    to draw our texture. Put this function between the calls to `SDL_RenderClear`
    and `SDL_RenderPresent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the project and you will see our loaded texture.![Creating an SDL texture](img/6821OT_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Source and destination rectangles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have something drawn to the screen, it is a good idea to cover the
    purpose of source and destination rectangles, as they will be extremely important
    for topics such as tile map loading and drawing. They are also important for sprite
    sheet animation which we will be covering later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of a source rectangle as defining the area we want to copy from
    a texture onto the window:'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we used the entire image so we could simply define
    the source rectangle's dimensions with the same dimensions as those of the loaded
    texture.![Source and destination rectangles](img/6821OT_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The red box in the preceding screenshot is a visual representation of the source
    rectangle we used when drawing to the screen. We want to copy pixels from inside
    the source rectangle to a specific area of the renderer, the destination rectangle
    (the red box in the following screenshot).![Source and destination rectangles](img/6821OT_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you would expect, these rectangles can be defined however you wish. For example,
    let's open up our `Game.cpp` file again and take a look at changing the size of
    the source rectangle. Place this code after the `SDL_QueryTexture` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now build again and you should see that only a 50 x 50 square of the image has
    been copied across to the renderer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Source and destination rectangles](img/6821OT_02_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now let us move the destination rectangle by changing its `x` and `y` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the project again and you will see that our source rectangle location
    has remained the same but the destination rectangle has moved. All we have done
    is move the location that we want the pixels inside the source rectangle to be
    copied to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Source and destination rectangles](img/6821OT_02_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: So far we have left the source rectangle's `x` and `y` coordinates at 0 but
    they can also be moved around to only draw the section of the image that you want.
    We can move the `x` and `y` coordinates of the source to draw the bottom-right
    section of the image rather than the top-left. Place this code just before where
    we set the destination rectangle's location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can see that we are still drawing to the same destination location but we
    are copying a different 50 x 50 section of the image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Source and destination rectangles](img/6821OT_02_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We can also pass null into the render copy for either rectangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Passing null into the source rectangle parameter will make the renderer use
    the entire texture. Likewise, passing null to the destination rectangle parameter
    will use the entire renderer for display.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Source and destination rectangles](img/6821OT_02_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We have covered a few different ways that we can use rectangles to define areas
    of images that we would like to draw. We will now put that knowledge into practice
    by displaying an animated sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Animating a sprite sheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can apply our understanding of source and destination rectangles to the
    animation of a sprite sheet. A sprite sheet is a series of animation frames all
    put together into one image. The separate frames need to have a very specific
    width and height so that they create a seamless motion. If one part of the sprite
    sheet is not correct it will make the whole animation look out of place or completely
    wrong. Here is an example sprite sheet that we will use for this demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating a sprite sheet](img/6821OT_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This animation is six frames long and each frame is 128 x 82 pixels. We know
    from the previous section that we can use a source rectangle to grab a certain
    part of an image. Therefore we can start by defining a source rectangle that encompasses
    the first frame of the animation only.![Animating a sprite sheet](img/6821OT_02_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we know the width, height, and location of the frame on the sprite sheet
    we can go ahead and hardcode these values into our source rectangle. First we
    must load the new `animate.bmp` file. Place it into your assets folder and alter
    the loading code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will now load our new sprite sheet BMP. We can remove the `SDL_QueryTexture`
    function as we are now defining our own sizes. Alter the size of the source rectangle
    to only get the first frame of the sheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will leave the `x` and `y` position of both rectangles at `0` so that we
    draw the image from the top-left corner and also copy it to the top-left corner
    of the renderer. We will also leave the dimensions of the destination rectangle
    as we want it to remain the same as the source rectangle. Pass both rectangles
    into the `SDL_RenderCopy` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now when we build we will have the first frame of the animation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Animating a sprite sheet](img/6821OT_02_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now that we have the first frame, we can move on to animating the sprite sheet.
    Each frame has the exact same dimensions. This is extremely important for this
    sheet to animate correctly. All we want to do is move the location of the source
    rectangle, not its dimensions.![Animating a sprite sheet](img/6821OT_02_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every time we want to move another frame, we simply move the location of the
    source rectangle and copy it to the renderer. To do this we will use our `update`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we have used `SDL_GetTicks()` to find out the amount of milliseconds since
    SDL was initialized. We then divide this by the amount of time (in ms) we want
    between frames and then use the modulo operator to keep it in range of the amount
    of frames we have in our animation. This code will (every 100 milliseconds) shift
    the `x` value of our source rectangle by 128 pixels (the width of a frame), multiplied
    by the current frame we want, giving us the correct position. Build the project
    and you should see the animation displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flipping images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most games, players, enemies, and so on, will move in more than one direction.
    To allow the sprite to face in the direction it is moving we will have to flip
    our sprite sheet. We could of course create a new row in our sprite sheet with
    the frames flipped, but this would use more memory, which we do not want. SDL
    2.0 has another render function that allows us to pass in the way we want our
    image to be flipped or rotated. The function we will use is `SDL_RenderCopyEx`.
    This function takes the same parameters as `SDL_RenderCopy` but also takes specific
    parameters for rotation and flipping. The fourth parameter is the angle we want
    the image to be displayed with parameter five being the center point we want for
    the rotation. The final parameter is an enumerated type called `SDL_RendererFlip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the available values for the `SDL_RendererFlip` enumerated
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| SDL_RendererFlip value | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SDL_FLIP_NONE` | No flipping |'
  prefs: []
  type: TYPE_TB
- en: '| `SDL_FLIP_HORIZONTAL` | Flip the texture horizontally |'
  prefs: []
  type: TYPE_TB
- en: '| `SDL_FLIP_VERTICAL` | Flip the texture vertically |'
  prefs: []
  type: TYPE_TB
- en: 'We can use this parameter to flip our image. Here is the revised render function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Build the project and you will see that the image has been flipped and is now
    facing to the left. Our characters and enemies will also have frames specifically
    for animations such as attack and jump. These can be added to different rows of
    the sprite sheet and the source rectangle's `y` value is incremented accordingly.
    (We will cover this in more detail when we create our game objects.)
  prefs: []
  type: TYPE_NORMAL
- en: Installing SDL_image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we have only been loading BMP image files. This is all that SDL supports
    without any extensions. We can use `SDL_image` to enable us to load many different
    image file types such as BMP, GIF, JPEG, LBM, PCX, PNG, PNM, TGA, TIFF, WEBP,
    XCF, XPM, and XV. First we will need to clone the latest build of `SDL_image`
    to ensure it will work with SDL 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `TortoiseHg` workbench and use *Ctrl* + *Shift* + *N* to clone a
    new repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The repository for SDL_image is listed on [http://www.libsdl.org/projects/SDL_image/](http://www.libsdl.org/projects/SDL_image/)
    and [http://hg.libsdl.org/SDL_image/](http://hg.libsdl.org/SDL_image/). So let's
    go ahead and type that into the **Source** box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our destination will be a new directory, `C:\SDL2_image`. After typing this
    into the **Destination** box, hit **clone** and wait for it to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have created this folder, navigate to our `C:\SDL2_image` cloned repository.
    Open up the `VisualC` folder and then open the `SDL_image_VS2010` VC++ project
    with Visual Studio 2010 express.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `SDL2_image` project and then click on **Properties**. Here
    we have to include the `SDL.h` header file. Change the configuration to **All
    Configurations**, navigate to **VC++ Directories**, click on the **Include Directories**
    drop-down, and then on **<Edit…>**. Here we can put in our `C:\SDL2\include\`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next move to **Library Directories** and add our `C:\SDL2\lib\` folder. Now
    navigate to **Linker** | **Input** | **Additional Dependencies** and add `SDL2.lib`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** and we are almost ready to build. We are now using `SDL2.lib`,
    so we can remove the `SDL.lib` and the `SDLmain.lib` files from the `SDL_image`
    project. Locate the files in the solution explorer, right-click and then remove
    the files. Change the build configuration to **release** and then build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An error about being unable to start the program may appear. Just click on **OK**
    and we can close the project and continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There will now be a `Release` folder inside our `C:\SDL2_image\VisualC\` folder.
    Open it and copy the `SDL_image.dll` to our game's executable folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next copy the `SDL2_image.lib` file into our original `C:\SDL2\lib\` directory.
    Also copy the `SDL_image` header from `C:\SDL2_image\` to the `C:\SDL2\include\`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We just have a few more libraries to get and we are done. Download the `SDL_image-1.2.12-win32.zip`
    file (or the x64 if you are targeting a 64 bit platform) from [http://www.libsdl.org/projects/SDL_image/](http://www.libsdl.org/projects/SDL_image/).
    Extract all and then copy all of the `.dll` files apart from `SDL_image.dll` into
    our game's executable folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up our game project and go into its properties. Navigate to **Linker**
    | **Input** | **Additional Dependencies** and add `SDL2_image.lib`.![Installing
    SDL_image](img/6821OT_02_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now installed `SDL_image` and can start to load all kinds of different
    image files. Copy the `animate.png` and `animate-alpha.png` images from the source
    downloads to our games assets folder and we can start loading PNG files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using SDL_image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So we have the library installed, now how do we use it? It is simple to use
    SDL_image in place of the regular SDL image loading. In our case we only need
    to replace one function and also add `#include <SDL_image.h>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will be changed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We are now loading a `.png` image. PNG files are great to work with, they have
    a small file size and support an alpha channel. Let's perform a test. Change our
    renderer clear color to red.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You will see that we still have our black background from the image we are using;
    this is definitely not ideal for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using SDL_image](img/6821OT_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When using PNG files, we can resolve this by using an alpha channel. We remove
    the background from the image and then when we load it, SDL will not draw anything
    from the alpha channel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using SDL_image](img/6821OT_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s load this image and see how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using SDL_image](img/6821OT_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tying it into the framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot on the subject of drawing images with SDL but we have
    yet to tie everything together into our framework so that it becomes reusable
    throughout our game. What we will now cover is creating a texture manager class
    that will have all of the functions we need to easily load and draw textures.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the texture manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The texture manager will have functions that allow us to load and create an
    `SDL_Texture` structure from an image file, draw the texture (either static or
    animated), and also hold a list of `SDL_Texture*`, so that we can use them whenever
    we need to. Let''s go ahead and create the `TextureManager.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: First we declare our `load` function. As parameters, the function takes the
    filename of the image we want to use, the ID we want to use to refer to the texture,
    and the renderer we want to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will create two draw functions, `draw` and `drawFrame`. They will both take
    the ID of the texture we want to draw, the `x` and `y` position we want to draw
    to, the height and width of the frame or the image we are using, the renderer
    we will copy to, and an `SDL_RendererFlip` value to describe how we want the image
    to be displayed (default is `SDL_FLIP_NONE`). The `drawFrame` function will take
    two additional parameters, the current frame we want to draw and which row it
    is on in the sprite sheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `TextureManager` class will also contain `std::map` of pointers to the `SDL_Texture`
    objects, keyed using `std::strings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now must define these functions in a `TextureManager.cpp` file. Let's start
    with the `load` function. We will take the code from our previous texture loading
    and use it within this `load` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we call this function we will then have `SDL_Texture` that can be used
    by accessing it from the map using its ID; we will use this in our `draw` functions.
    The `draw` function can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We again use `SDL_RenderCopyEx` using the passed in ID variable to get the
    `SDL_Texture` object we want to draw. We also build our source and destination
    variables using the passed in `x`, `y`, `width`, and `height` values. Now we can
    move onto `drawFrame`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this function, we create a source rectangle to use the appropriate frame
    of the animation using the `currentFrame` and `currentRow` variables. The source
    rectangle's `x` position for the current frame is the width of the source rectangle
    multiplied by the `currentFrame` value (covered in the *Animating a sprite sheet*
    section). Its `y` value is the height of the rectangle multiplied by `currentRow
    – 1` (it sounds more natural to use the first row, rather than the zeroth row).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now have everything we need to easily load and draw textures throughout our
    game. Let's go ahead and test it out using the `animated.png` image. Open up `Game.h`.
    We will not need our texture member variables or the rectangles anymore, so delete
    any of the code dealing with them from the `Game.h` and `Game.cpp` files. We will
    however create two new member variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use the `m_currentFrame` variable to allow us to animate our sprite
    sheet and we also need an instance of our new `TextureManager` class (ensure you
    include `TextureManager.h`). We can now load a texture in the game's `init` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have given this texture an ID of `"animate"` which we can use in our `draw`
    functions. We will start by drawing a static image at 0,0 and an animated image
    at 100,100\. Here is the render function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The drawFrame function uses our `m_currentFrame` member variable. We can increment
    this in the `update` function like we did before, but we now do the calculation
    of the source rectangle inside the `draw` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can build and see our hard work in action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Creating the texture manager](img/6821OT_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using texture manager as a singleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our texture manager in place we still have one problem. We
    want to reuse this `TextureManager` throughout our game so we don't want it to
    be a member of our `Game` class because then we would have to pass it into our
    draw function. A good option for us is to implement `TextureManager` as a singleton.
    A singleton is a class that can only have one instance. This works for us, as
    we want to reuse the same `TextureManager` throughout our game. We can make our
    `TextureManager` a singleton by first making its constructor private.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is to ensure that it cannot be created like other objects. It can only
    be created and accessed using the `Instance` function, which we will declare and
    define.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This function checks whether we already have an instance of our `TextureManager`.
    If not, then it constructs it, otherwise it simply returns the static instance.
    We will also `typedef` the `TextureManager`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We must also define the static instance in `TextureManager.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use our `TextureManager` as a singleton. We no longer have to have
    an instance of `TextureManager` in our `Game` class, we just include the header
    and use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When we load a texture in our `Game` (or any other) class we can then access
    it throughout our code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been all about rendering images onto the screen. We have covered
    source and destination rectangles and animating a sprite sheet. We took what we
    learned and applied it to creating a reusable texture manager class, enabling
    us to easily load and draw images throughout our game. In the next chapter, we
    will cover using inheritance and polymorphism to create a base game object class
    and use it within our game framework.
  prefs: []
  type: TYPE_NORMAL
