<html><head></head><body>
        

            
                <h1 class="header-title" id="calibre_pb_0">Sharing Objects with the Flyweight Pattern</h1>
            

            
                
<p class="calibre2">We previously learned about object pools in <a href="part0112.html#3APV00-04600e4b10ea45a2839ef4fc3675aeb7" class="calibre7">Chapter 7</a>, <em class="calibre12">Improving Performance with Object Pools</em>, and that they are great for avoiding slowdowns in our game due to dynamic memory allocation. But, there are still other steps that we can take to reduce the amount of memory that we use to begin with.</p>
<p class="calibre2">When creating projects, you'll often run into times where you want to have many objects on the screen at once. While computers have become much more powerful over the past few years, they still can't handle thousands of complex game objects on the screen by themselves.</p>
<p class="calibre2">In order to accomplish this feat, programmers need to think of ways to lighten the memory load on their program. Using the Flyweight pattern, we abstract the common parts of our object and share them with only the data that's unique to each instance (such as position and current health) being created.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Chapter overview</h1>
            

            
                
<p class="calibre2">In this chapter, we will construct a particle system consisting of two parts: the particle itself, which will be a simple struct, as well as a particle system class that contains the system's data.</p>
<p class="calibre2">We will construct two different types of particle system: an explosion that moves on its own, and a static one that spawns at the position of our player's ship. We will also explore two ways to deal with the system data. The first will be for each particle system to contain its own copy of the system data. Then, after learning about the Flyweight pattern, we will use it to construct separate system data classes that we can assign using files or code. Then, each particle system will simply reference an instance of the system data that it needs.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Your objectives</h1>
            

            
                
<p class="calibre2">This chapter will be split into a number of topics. It will contain a simple step-by-step process from beginning to end. Here is the outline of our tasks:</p>
<ul class="calibre17">
<li class="calibre18">Introduction to particles</li>
<li class="calibre18">Implementing particles in Mach5</li>
<li class="calibre18">Why memory is still an issue</li>
<li class="calibre18">Introduction to the Flyweight pattern</li>
<li class="calibre18">Transitioning to ParticleSystems</li>
</ul>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Introductions to particles</h1>
            

            
                
<p class="calibre2">In game development, you may have heard of particles. They are typically small 2D sprites or simple 3D models that are created in order to simulate <em class="calibre12">fuzzy</em> things such as fires, explosions, and smoke trails to add visual flair to your projects. This visual flair is sometimes referred to as <em class="calibre12">juiciness</em>. Made popular by indie developers <em class="calibre12">Martin Jonasson</em> and <em class="calibre12">Petri Purho</em>, making a game <em class="calibre12">juicy</em> makes it more enjoyable to play and increases the feedback the player receives by playing the game.</p>
<p class="calibre2">This is usually something worked on more toward the end of development of titles in order to polish the project and add more feedback, but it's a good example of how we can want to have many things on the screen at one time.</p>
<p>For more information on juiciness and to watch their Martin and Petri's GDC talk on the subject, check out <a href="http://www.gamasutra.com/view/news/178938/Video_Is_your_game_juicy_enough.php" target="_blank" class="calibre24">http://www.gamasutra.com/view/news/178938/Video_Is_your_game_juicy_enough.php</a>.</p>
<p class="calibre2">The reason that these objects are so simple is because they are spawned hundreds and sometimes thousands of times, and this is done over and over again.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Implementing particles in Mach5</h1>
            

            
                
<p class="calibre2">Now that we know what particles are, let's put them into Mach5 so we can get an example of how they work. We will be creating particles to follow our ship while it moves in a similar fashion to a smoke trail. This will be a great way to show an example of particles on the screen but, to have something to show, we will first need to bring a new archetype into the game.</p>
<p class="calibre2">To do that, open up the <kbd class="calibre14">Example Code</kbd> folder for this chapter and bring the <kbd class="calibre14">particle.tga</kbd> file into the <kbd class="calibre14">EngineTest/Textures</kbd> folder of your Visual Studio project.</p>
<p class="calibre2">After that, open up the <kbd class="calibre14">EngineTest/ArcheTypes</kbd> folder, create a new text file called <kbd class="calibre14">Particle.ini</kbd>, and fill it with the following info:</p>
<pre class="calibre23">
posX   = 0 <br class="title-page-name"/>posY   = 0 <br class="title-page-name"/>velX   = 0 <br class="title-page-name"/>velY   = 0 <br class="title-page-name"/>scaleX = 2.5 <br class="title-page-name"/>scaleY = 2.5 <br class="title-page-name"/>rot    = 0 <br class="title-page-name"/>rotVel = 0 <br class="title-page-name"/>components =  GfxComponent ParticleComponent <br class="title-page-name"/> <br class="title-page-name"/>[GfxComponent] <br class="title-page-name"/>texture = particle.tga <br class="title-page-name"/>drawSpace = world 
</pre>
<p class="calibre2">After that, we need the Mach5 engine to support our new object, so go to the <kbd class="calibre14">EngineTest</kbd> folder and then double-click on the <kbd class="calibre14">PreBuild.bat</kbd> file. The <kbd class="calibre14">M5ArcheTypes.h</kbd> file will be updated to include our particle:</p>
<pre class="calibre23">
//! AutoGenerated enum based on archetype ini file names   <br class="title-page-name"/>enum M5ArcheTypes {   <br class="title-page-name"/>AT_Bullet,  <br class="title-page-name"/>AT_Particle,  <br class="title-page-name"/>AT_Player,  <br class="title-page-name"/>AT_Raider,  <br class="title-page-name"/>AT_Splash,  <br class="title-page-name"/>AT_INVALID  <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">Nice! Now that we have the object in the game, there's still the issue of putting in the Particle component. Since this component is not exclusive to our game, let's move over to the Core/Components filter and create a new filter called <kbd class="calibre14">ParticleComp</kbd>. From there, create two new files, <kbd class="calibre14">ParticleComponent.h</kbd> and <kbd class="calibre14">ParticleComponent.cpp</kbd>, making sure their locations are set to the <kbd class="calibre14">Mach5-master\EngineTest\EngineTest\Source\</kbd> folder.</p>
<p class="calibre2">In the <kbd class="calibre14">.h</kbd> file, use the following code:</p>
<pre class="calibre23">
/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>\file   ParticleComponent.h <br class="title-page-name"/>\author John Doran <br class="title-page-name"/>\par    email: john@johnpdoran.com <br class="title-page-name"/>\par    Mach5 Game Engine <br class="title-page-name"/>\date   2016/12/06 <br class="title-page-name"/> <br class="title-page-name"/>Used to display a single particle on the screen. <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>#ifndef PARTICLE_COMPONENT_H <br class="title-page-name"/>#define PARTICLE_COMPONENT_H <br class="title-page-name"/> <br class="title-page-name"/>#include "Core\M5Component.h" <br class="title-page-name"/>#include "Core\M5Vec2.h" <br class="title-page-name"/> <br class="title-page-name"/> <br class="title-page-name"/>class ParticleComponent : public M5Component <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  ParticleComponent(); <br class="title-page-name"/>  virtual void Update(float dt); <br class="title-page-name"/>  virtual M5Component* Clone(void); <br class="title-page-name"/>  virtual void FromFile(M5IniFile&amp; iniFile); <br class="title-page-name"/>  bool activated; <br class="title-page-name"/>  float lifeTime; <br class="title-page-name"/>  float endScale; <br class="title-page-name"/>private: <br class="title-page-name"/>  M5Vec2 startScale; <br class="title-page-name"/>  float lifeLeft; <br class="title-page-name"/>  float Lerp(float start, float end, float fraction); <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>#endif // !PARTICLE_COMPONENT_H 
</pre>
<p class="calibre2">This class looks similar to other components that we've added in the past, but this time we've added a <kbd class="calibre14">startScale</kbd> property to keep track of what scale our object had at the start of its life, and an <kbd class="calibre14">endScale</kbd> property to be a modifier on how to change the scale. We also have <kbd class="calibre14">lifeTime</kbd>, which will be how long this object should live before we remove it, and <kbd class="calibre14">lifeLeft</kbd>, which will be how much longer this object has to live. Finally, since we are going to change our scale, we added another function, <kbd class="calibre14">Lerp</kbd>, to linearly interpolate between a starting and ending value.</p>
<p class="calibre2">In the <kbd class="calibre14">.cpp</kbd> file, use the following code:</p>
<pre class="calibre23">
/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>\file   ParticleComponent.cpp <br class="title-page-name"/>\author John Doran <br class="title-page-name"/>\par    email: john@johnpdoran.com <br class="title-page-name"/>\par    Mach5 Game Engine <br class="title-page-name"/>\date   2016/12/06 <br class="title-page-name"/> <br class="title-page-name"/>Particle system component. Allows you to draw many particles on the screen. <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>#include "ParticleComponent.h" <br class="title-page-name"/>#include "Core\M5Gfx.h" <br class="title-page-name"/>#include "Core\M5Math.h" <br class="title-page-name"/>#include "Core\M5Object.h" <br class="title-page-name"/>#include "EngineTest\M5ObjectPool.h" <br class="title-page-name"/>#include "Core\GfxComponent.h" <br class="title-page-name"/>#include "Core\M5IniFile.h" <br class="title-page-name"/> <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Construtor for ParticleSystem component.  Sets default values <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>ParticleComponent::ParticleComponent() : <br class="title-page-name"/>  M5Component(CT_ParticleComponent) <br class="title-page-name"/>{ <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Takes care of the particle system, decrease lifetime and adjust scaling. <br class="title-page-name"/>Will mark for destruction if needed. <br class="title-page-name"/> <br class="title-page-name"/>\param [in] dt <br class="title-page-name"/>The time in seconds since the last frame. <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>void ParticleComponent::Update(float dt) <br class="title-page-name"/>{ <br class="title-page-name"/>  // Decrease our life by the change in time this frame  <br class="title-page-name"/>    // (dt stands for delta time) <br class="title-page-name"/>  lifeLeft -= dt; <br class="title-page-name"/> <br class="title-page-name"/>  // Change our size based on where we want it to be <br class="title-page-name"/>  float currentPercentage = 1 - (lifeLeft / lifeTime); <br class="title-page-name"/>  m_pObj-&gt;scale.x = Lerp(startScale.x, <br class="title-page-name"/>     startScale.x * endScale, currentPercentage); <br class="title-page-name"/> <br class="title-page-name"/>  m_pObj-&gt;scale.y = Lerp(startScale.y, <br class="title-page-name"/>     startScale.y * endScale, currentPercentage); <br class="title-page-name"/> <br class="title-page-name"/>  // If there is no life left, destroy our object <br class="title-page-name"/>  if (lifeLeft &lt;= 0) <br class="title-page-name"/>  { <br class="title-page-name"/>    m_pObj-&gt;isDead = true; <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>} 
</pre>
<p class="calibre2">This code will modify the object's scale by using the <kbd class="calibre14">Lerp</kbd> function to interpolate between the starting and ending scale. We also will modify how much life the particle has left, and if it has none, mark the particle for deletion:</p>
<pre class="calibre23">
/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Will give you the percentage of the fraction from start to end <br class="title-page-name"/> <br class="title-page-name"/>\param [in] start <br class="title-page-name"/>What value to start from <br class="title-page-name"/> <br class="title-page-name"/>\param [in] end <br class="title-page-name"/>What value to end from <br class="title-page-name"/> <br class="title-page-name"/>\param [in] fraction <br class="title-page-name"/>What percentage of the way are we are from start to finish <br class="title-page-name"/> <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>float ParticleComponent::Lerp(float start, float end, float fraction) <br class="title-page-name"/>{ <br class="title-page-name"/>  return start + fraction * (end - start); <br class="title-page-name"/>} 
</pre>
<p class="calibre2"><strong class="calibre1">Linear interpolation</strong> (<strong class="calibre1">Lerp</strong>) allows us to obtain a value between <kbd class="calibre14">start</kbd> and <kbd class="calibre14">end</kbd> using the <kbd class="calibre14">fraction</kbd> property for how far along the transition it should be. If <kbd class="calibre14">fraction</kbd> is <kbd class="calibre14">0</kbd>, we would get the value of <kbd class="calibre14">start</kbd>. If we give <kbd class="calibre14">1</kbd>, we will get the value of <kbd class="calibre14">end</kbd>. If it's <kbd class="calibre14">.5</kbd>, then we would get the half-way point between <kbd class="calibre14">start</kbd> and <kbd class="calibre14">end</kbd>.</p>
<p>For more information on interpolation including linear interpolation, check out <em class="calibre25">Keith Maggio</em>'s notes on the topic at <a href="https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/" target="_blank" class="calibre24">https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/</a>.</p>
<pre class="calibre23">
/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Clones the current component and updates it with the correct information. <br class="title-page-name"/> <br class="title-page-name"/>\return <br class="title-page-name"/>A new component that is a clone of this one <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>M5Component * ParticleComponent::Clone(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  ParticleComponent * pNew = new ParticleComponent; <br class="title-page-name"/>  pNew-&gt;m_pObj = m_pObj; <br class="title-page-name"/>  pNew-&gt;startScale = m_pObj-&gt;scale; <br class="title-page-name"/>  pNew-&gt;lifeTime = lifeTime; <br class="title-page-name"/>  pNew-&gt;lifeLeft = lifeTime; <br class="title-page-name"/>  pNew-&gt;endScale = endScale; <br class="title-page-name"/>  return pNew; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">The <kbd class="calibre14">Clone</kbd> function allows us to create a copy of this object. It will create a new version of this component, and we will initialize the values of the new component with the values we currently have. This is used by the Mach5 engine in the creation of new game objects:</p>
<pre class="calibre23">
/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Reads in data from a preloaded ini file. <br class="title-page-name"/> <br class="title-page-name"/>\param [in] iniFile <br class="title-page-name"/>The preloaded inifile to read from. <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>void ParticleComponent::FromFile(M5IniFile&amp; iniFile) <br class="title-page-name"/>{ <br class="title-page-name"/>  // Get our life time value <br class="title-page-name"/>  std::string lifeTimeText; <br class="title-page-name"/>  iniFile.SetToSection("ParticleComponent"); <br class="title-page-name"/>  iniFile.GetValue("lifeTime", lifeTimeText); <br class="title-page-name"/> <br class="title-page-name"/>  // Convert the string into a float <br class="title-page-name"/>  lifeTime = std::stof(lifeTimeText); <br class="title-page-name"/>  lifeLeft = lifeTime; <br class="title-page-name"/> <br class="title-page-name"/>  // Then do the same for endScale <br class="title-page-name"/>  std::string endScaleText; <br class="title-page-name"/>  iniFile.GetValue("endScale", endScaleText); <br class="title-page-name"/>  endScale = std::stof(endScaleText); <br class="title-page-name"/> <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Just like before, the <kbd class="calibre14">FromFile</kbd> function will read in our <kbd class="calibre14">ini</kbd> file we created previously and will use the values from it to set the properties of this component. In our case, here we set <kbd class="calibre14">lifeTime</kbd>, <kbd class="calibre14">lifeLeft</kbd>, and <kbd class="calibre14">endScale</kbd>.</p>
<p class="calibre2">Finally, let's start putting these objects into our game. Open up the <kbd class="calibre14">PlayerInputComponent.cpp</kbd> file and add the following to the top of the <kbd class="calibre14">Update</kbd> function:</p>
<pre class="calibre23">
M5Object* particle = M5ObjectManager::CreateObject(AT_Particle); <br class="title-page-name"/> <br class="title-page-name"/>particle-&gt;pos = m_pObj-&gt;pos; 
</pre>
<p class="calibre2">This will cause a particle to get spawned in every single frame and have the same position as our ship. Now, if we run the game, we should see some cool stuff! We can see this in the following screenshot:</p>
<div><img class="image-border29" src="img/00057.jpeg"/></div>
<p class="calibre2">As you can see, our ship now has a trail following behind it. Each part is a particle!</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Why memory is still an issue</h1>
            

            
                
<p class="calibre2">The particle system that we are currently showing is probably running well enough on some computers, but note that a large number of the variables that we have created hold data that will never change once we've initialized them. Now, generally in programming we would mark a variable that wouldn't change as <kbd class="calibre14">const</kbd>, but we don't set the variable until we read from a file. We could potentially make the variables static, but there's also the chance that we may want to have more particle systems in the future and I don't want to create an archetype for each one.</p>
<p class="calibre2">If we continue to spawn many particles, the memory that it takes up will increase and we will be wasting valuable space in memory that we could be using for other purposes. To solve this issue, we will employ the Flyweight pattern.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Introduction to the Flyweight pattern</h1>
            

            
                
<p class="calibre2">The Gang of Four states that a Flyweight is a shared object that can be used in multiple contexts simultaneously. Similarly to flyweight in boxing, which is the lightweight boxing category, we can have a lighter object that can be used in different places in our system simultaneously.</p>
<p class="calibre2">While not used terribly often nowadays, the Flyweight pattern can be very helpful in scenarios when memory is constrained.</p>
<p class="calibre2">A Flyweight will consist of two parts: the intrinsic state and the extrinsic state. The intrinsic state is the part that can be shared. The extrinsic state is modified based on the context it's being used in and, as such, cannot be shared.</p>
<p class="calibre2">Let's take a look at a UML diagram to see a closer look:</p>
<div><img class="alignnone19" src="img/00058.jpeg"/></div>
<p class="calibre2">We have the <strong class="calibre1">FlyweightFactory</strong> class, which is used to manage the Flyweights. Whenever we request one, we will either give one that's been created or create a new one ourselves.</p>
<p class="calibre2">The <strong class="calibre1">Flyweight</strong> object itself has data that is of whatever type is needed, as long as it won't change depending on the object that we're working with.</p>
<p class="calibre2">Finally, we have the <strong class="calibre1">ConcreteFlyweight</strong>, which acts as our extrinsic information that can access and use our <strong class="calibre1">Flyweight</strong> via the <strong class="calibre1">FlyweightFactory</strong>.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Transitioning to ParticleSystems</h1>
            

            
                
<p class="calibre2">So with that in mind, what we will do is separate the information that will be shared by each particle, which we will call a <kbd class="calibre14">ParticleSystem</kbd>:</p>
<pre class="calibre23">
// Abstract class for us to derive from <br class="title-page-name"/>class ParticleSystem <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  float lifeTime; <br class="title-page-name"/>  M5Vec2 startScale; <br class="title-page-name"/>  float endScale; <br class="title-page-name"/> <br class="title-page-name"/>  // Pure virtual functions <br class="title-page-name"/>  virtual void Init(M5Object * object) = 0; <br class="title-page-name"/>  virtual void Update(M5Object * object, float dt, float lifeLeft) = 0; <br class="title-page-name"/> <br class="title-page-name"/>  float Lerp(float start, float end, float fraction); <br class="title-page-name"/> <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">The class acts as our intrinsic state, which is shared. Since the starting scale, end scale, and lifetime of our object never change, it makes sense for these variables to be shared instead of each object having one. In our previous example, we only had one particle system, but we may want the ability to have more as well, and it's when we start using it that some of the benefits of the Flyweight pattern become even more apparent. That's why we gave this class two virtual functions: <kbd class="calibre14">Init</kbd> and <kbd class="calibre14">Update</kbd>. We can have our extrinsic state call these functions, giving the function information about the particular object we're dealing with, and then we can modify it using these properties.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Creating different system types</h1>
            

            
                
<p class="calibre2">Let's add a new type of particle system in addition to our current one that doesn't move. Let's call it <kbd class="calibre14">Moving</kbd> and our previous one, <kbd class="calibre14">Static</kbd>. To differentiate between the two, let's add an <kbd class="calibre14">enum</kbd>:</p>
<pre class="calibre23">
enum ParticleType <br class="title-page-name"/>{ <br class="title-page-name"/>  PS_Static, <br class="title-page-name"/>  PS_Moving <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">We can now modify the original <kbd class="calibre14">ParticleComponent</kbd> class, by removing the previously created variables and instead including a reference to the kind of <kbd class="calibre14">ParticleSystem</kbd> we wish to use:</p>
<pre class="calibre23">
class ParticleComponent : public M5Component <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  ParticleComponent(); <br class="title-page-name"/>  virtual void Update(float dt); <br class="title-page-name"/>  virtual M5Component* Clone(void); <br class="title-page-name"/>  virtual void FromFile(M5IniFile&amp; iniFile); <br class="title-page-name"/>  bool activated; <br class="title-page-name"/>  float lifeLeft; <br class="title-page-name"/> <br class="title-page-name"/>private: <br class="title-page-name"/>  ParticleType particleType; <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">The <kbd class="calibre14">ParticleComponent</kbd> class acts as our extrinsic state, holding information about how much time it has left and the properties from the <kbd class="calibre14">M5Component</kbd> class, such as a reference to the object we want to create.</p>
<p class="calibre2">At this point, we need to create two classes to refer to each of these:</p>
<pre class="calibre23">
class StaticParticleSystem : public ParticleSystem <br class="title-page-name"/>{ <br class="title-page-name"/>  void Init(M5Object * obj);     <br class="title-page-name"/> <br class="title-page-name"/>  void Update(M5Object *, float, float); <br class="title-page-name"/> <br class="title-page-name"/>}; <br class="title-page-name"/> <br class="title-page-name"/>class MovingParticleSystem : public ParticleSystem <br class="title-page-name"/>{ <br class="title-page-name"/>  void Init(M5Object * obj); <br class="title-page-name"/> <br class="title-page-name"/>  void Update(M5Object *, float, float); <br class="title-page-name"/> <br class="title-page-name"/>}; 
</pre>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Developing the ParticleFactory</h1>
            

            
                
<p class="calibre2">We need some way for our <kbd class="calibre14">ParticleComponent</kbd> to access this information. With that in mind, we will make use of the Factory design pattern that we learned about in <a href="part0096.html#2RHM00-04600e4b10ea45a2839ef4fc3675aeb7" class="calibre7">Chapter 5</a>, <em class="calibre12">Decoupling Code via the Factory Method Pattern</em>, and create a <kbd class="calibre14">ParticleFactory</kbd> class:</p>
<pre class="calibre23">
class ParticleFactory <br class="title-page-name"/>{ <br class="title-page-name"/>public: <br class="title-page-name"/>  static int objectCount; <br class="title-page-name"/>  static std::map&lt;ParticleType, ParticleSystem *&gt; particleSystems; <br class="title-page-name"/> <br class="title-page-name"/>  // Getting our Flyweight <br class="title-page-name"/>  static ParticleSystem &amp; GetParticleSystem(ParticleType type); <br class="title-page-name"/>  ~ParticleFactory(); <br class="title-page-name"/>}; 
</pre>
<p class="calibre2">This <kbd class="calibre14">ParticleFactory</kbd> class is what we use to manage the creation of these Flyweights and to ensure that, if the object is already located in our map, we will return it. Otherwise, we will create a new object to be able to access it. I also added an <kbd class="calibre14">objectCount</kbd> variable to help us know how many objects currently exist and to verify that no memory leaks are occurring.</p>
<p class="calibre2">The <kbd class="calibre14">ParticleSystems</kbd> variable is of type map, which is actually one of my favorite containers in the <kbd class="calibre14">stl</kbd> and can be considered an <em class="calibre12">associative array</em>. By that, I mean instead of memorizing numbers in order to access certain indexes of an array, you can use a different type, such as a <kbd class="calibre14">string,</kbd> or in this case, an <kbd class="calibre14">enum</kbd>.</p>
<p>For more information on the map container, check out <a href="http://www.cprogramming.com/tutorial/stl/stlmap.html" target="_blank" class="calibre24">http://www.cprogramming.com/tutorial/stl/stlmap.html</a>.</p>
<p class="calibre2">After this, we will need to define the two static variables:</p>
<pre class="calibre23">
#include &lt;map&gt; <br class="title-page-name"/> <br class="title-page-name"/>// Define our static variables <br class="title-page-name"/>int ParticleFactory::objectCount = 0; <br class="title-page-name"/>std::map&lt;ParticleType, ParticleSystem *&gt; ParticleFactory::particleSystems; 
</pre>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Using the ParticleFactory</h1>
            

            
                
<p class="calibre2">Next, we will need to adjust our previously created Particle archetype and component to reflect these changes.</p>
<p class="calibre2">First, we want to change our <kbd class="calibre14">.ini</kbd> file. Since the <kbd class="calibre14">Particle</kbd> object is meant for all particle types, instead of having the properties being set there, we will instead set a base type for us to use:</p>
<pre class="calibre23">
posX   = 0 <br class="title-page-name"/>posY   = 0 <br class="title-page-name"/>velX   = 0 <br class="title-page-name"/>velY   = 0 <br class="title-page-name"/>scaleX = 2.5 <br class="title-page-name"/>scaleY = 2.5 <br class="title-page-name"/>rot    = 0 <br class="title-page-name"/>rotVel = 0 <br class="title-page-name"/>components =  GfxComponent ParticleComponent <br class="title-page-name"/> <br class="title-page-name"/>[GfxComponent] <br class="title-page-name"/>texture = particle.tga <br class="title-page-name"/>drawSpace = world <br class="title-page-name"/> <br class="title-page-name"/>[ParticleComponent] <br class="title-page-name"/>type = Moving 
</pre>
<p class="calibre2">This simplifies the particle object itself, but it's for a good cause. We will now update the code of the <kbd class="calibre14">ParticleComponent</kbd> class as follows:</p>
<pre class="calibre23">
/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Construtor for ParticleSystem component.  Sets default values <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>ParticleComponent::ParticleComponent() : <br class="title-page-name"/>  M5Component(CT_ParticleComponent) <br class="title-page-name"/>{ <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Takes care of the particle system, decrease lifetime and adjust scaling. <br class="title-page-name"/>Will mark for destruction if needed. <br class="title-page-name"/> <br class="title-page-name"/>\param [in] dt <br class="title-page-name"/>The time in seconds since the last frame. <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>void ParticleComponent::Update(float dt) <br class="title-page-name"/>{ <br class="title-page-name"/>  // Decrease our life by the change in time this frame (delta time, dt) <br class="title-page-name"/>  lifeLeft -= dt; <br class="title-page-name"/> <br class="title-page-name"/>  ParticleFactory::GetParticleSystem(particleType).Update(m_pObj, dt, lifeLeft); <br class="title-page-name"/> <br class="title-page-name"/>  // If there is no life left, destroy our object <br class="title-page-name"/>  if (lifeLeft &lt;= 0) <br class="title-page-name"/>  { <br class="title-page-name"/>    m_pObj-&gt;isDead = true; <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>} 
</pre>
<p class="calibre2">In this instance, you'll notice that instead of modifying the scale and/or movement being done here, we use the <kbd class="calibre14">ParticleFactory</kbd> to update our code based on the <kbd class="calibre14">particleType</kbd> property:</p>
<pre class="calibre23">
/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Clones the current component and updates it with the correct information. <br class="title-page-name"/> <br class="title-page-name"/>\return <br class="title-page-name"/>A new component that is a clone of this one <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>M5Component * ParticleComponent::Clone(void) <br class="title-page-name"/>{ <br class="title-page-name"/>  ParticleComponent * pNew = new ParticleComponent; <br class="title-page-name"/>  pNew-&gt;m_pObj = m_pObj; <br class="title-page-name"/>  pNew-&gt;particleType = particleType; <br class="title-page-name"/> <br class="title-page-name"/>  ParticleSystem &amp; system = <br class="title-page-name"/>     ParticleFactory::GetParticleSystem(particleType); <br class="title-page-name"/>  system.Init(pNew-&gt;m_pObj); <br class="title-page-name"/>  pNew-&gt;lifeLeft = system.lifeTime; <br class="title-page-name"/>  return pNew; <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Here, we call the <kbd class="calibre14">Init</kbd> function for our particle system based on its type from the factory:</p>
<pre class="calibre23">
/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Reads in data from a preloaded ini file. <br class="title-page-name"/> <br class="title-page-name"/>\param [in] iniFile <br class="title-page-name"/>The preloaded inifile to read from. <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>void ParticleComponent::FromFile(M5IniFile&amp; iniFile) <br class="title-page-name"/>{ <br class="title-page-name"/>  // Get our initial particle type <br class="title-page-name"/>  std::string particleTypeText; <br class="title-page-name"/>  iniFile.SetToSection("ParticleComponent"); <br class="title-page-name"/>  iniFile.GetValue("type", particleTypeText); <br class="title-page-name"/>   <br class="title-page-name"/>  if (particleTypeText == "Static") <br class="title-page-name"/>  { <br class="title-page-name"/>    particleType = PS_Static; <br class="title-page-name"/>  } <br class="title-page-name"/>  else if(particleTypeText == "Moving") <br class="title-page-name"/>  { <br class="title-page-name"/>    particleType = PS_Moving; <br class="title-page-name"/>  } <br class="title-page-name"/>   <br class="title-page-name"/>} 
</pre>
<p class="calibre2">We are now going to set our particle type based on what is marked on the <kbd class="calibre14">ini</kbd> file.</p>
<p class="calibre2">But, of course, now that we are using the <kbd class="calibre14">GetParticleSystem</kbd> function, we need to implement it for our code to compile:</p>
<pre class="calibre23">
/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Used to get our Flyweight object and access the shared properties of the  <br class="title-page-name"/>particles. <br class="title-page-name"/> <br class="title-page-name"/>\param type <br class="title-page-name"/>What kind of particle we want to get access to <br class="title-page-name"/> <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>ParticleSystem &amp; ParticleFactory::GetParticleSystem(ParticleType type) <br class="title-page-name"/>{ <br class="title-page-name"/>  // If our object exists, return it <br class="title-page-name"/>  if (particleSystems.find(type) != particleSystems.end()) <br class="title-page-name"/>  { <br class="title-page-name"/>    return  *particleSystems[type]; <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>  ParticleSystem * newSystem = nullptr; <br class="title-page-name"/> <br class="title-page-name"/>  // Otherwise, let's create one <br class="title-page-name"/>  switch (type) <br class="title-page-name"/>  { <br class="title-page-name"/>  case PS_Static: <br class="title-page-name"/>    newSystem = new StaticParticleSystem(); <br class="title-page-name"/>    newSystem-&gt;endScale = 0; <br class="title-page-name"/>    newSystem-&gt;lifeTime = 1.5; <br class="title-page-name"/>    newSystem-&gt;startScale = M5Vec2(2.5, 2.5); <br class="title-page-name"/> <br class="title-page-name"/>    particleSystems[PS_Static] = newSystem; <br class="title-page-name"/> <br class="title-page-name"/>    objectCount++; <br class="title-page-name"/>    break; <br class="title-page-name"/> <br class="title-page-name"/>  case PS_Moving: <br class="title-page-name"/>    newSystem = new MovingParticleSystem(); <br class="title-page-name"/>    newSystem-&gt;endScale = 0; <br class="title-page-name"/>    newSystem-&gt;lifeTime = 1.5; <br class="title-page-name"/>    newSystem-&gt;startScale = M5Vec2(2.5, 2.5); <br class="title-page-name"/>    particleSystems[PS_Moving] = newSystem; <br class="title-page-name"/>    objectCount++; <br class="title-page-name"/>    break; <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>  return *newSystem; <br class="title-page-name"/> <br class="title-page-name"/>} 
</pre>
<p class="calibre2">In this script, we make use of the <kbd class="calibre14">particleSystems</kbd> map that we talked about earlier. The first thing that we do is check if there is an object in the map that has our <kbd class="calibre14">ParticleType</kbd> in it. If not, then we need to create one. In this case, I added a <kbd class="calibre14">switch</kbd> statement that will assign different values depending on the value mentioned in the <kbd class="calibre14">case</kbd> statement, but you could easily read these values from a text file in a similar manner to how files are read for archetypes. You'll notice that we are calling new in order to create these, so we will need to call <kbd class="calibre14">delete</kbd> on them as well in order to avoid any memory leaks. To accomplish this, I've added in a destructor for the <kbd class="calibre14">ParticleFactory</kbd> class:</p>
<pre class="calibre23">
/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Deconstructor for the ParticleFactory. Removes all of the elements in ourparticleSystems map <br class="title-page-name"/> <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>ParticleFactory::~ParticleFactory() <br class="title-page-name"/>{ <br class="title-page-name"/>  for (auto iterator = particleSystems.begin();  <br class="title-page-name"/>     iterator != particleSystems.end();  <br class="title-page-name"/>     iterator++)  <br class="title-page-name"/>  { <br class="title-page-name"/>    // iterator-&gt;first = key <br class="title-page-name"/>    // iterator-&gt;second = value <br class="title-page-name"/>    delete iterator-&gt;second; <br class="title-page-name"/>  } <br class="title-page-name"/> <br class="title-page-name"/>} 
</pre>
<p class="calibre2">Finally, we need to write the implementations for our different <kbd class="calibre14">ParticleSystems</kbd>:</p>
<pre class="calibre23">
/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Will give you the percentage of the fraction from start to end <br class="title-page-name"/> <br class="title-page-name"/>\param start <br class="title-page-name"/>What value to start from <br class="title-page-name"/> <br class="title-page-name"/>\param end <br class="title-page-name"/>What value to end from <br class="title-page-name"/> <br class="title-page-name"/>\param fraction <br class="title-page-name"/>What percentage of the way we are from start to finish <br class="title-page-name"/> <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>float ParticleSystem::Lerp(float start, float end, float fraction) <br class="title-page-name"/>{ <br class="title-page-name"/>  return start + fraction * (end - start); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">The <kbd class="calibre14">Lerp</kbd> function does the same for either particle type, so it's fine the way it was:</p>
<pre class="calibre23">
/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Used to initialize the particle system and set any parameters needed <br class="title-page-name"/> <br class="title-page-name"/>\param obj <br class="title-page-name"/>A reference to the object <br class="title-page-name"/> <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>void StaticParticleSystem::Init(M5Object * obj) <br class="title-page-name"/>{ <br class="title-page-name"/>  obj-&gt;vel = M5Vec2(0, 0); <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Used to update the particle system. Called once per frame <br class="title-page-name"/> <br class="title-page-name"/>\param m_pObj <br class="title-page-name"/>A reference to the object <br class="title-page-name"/> <br class="title-page-name"/>\param dt <br class="title-page-name"/>Amount of time that has passed since the previous frame <br class="title-page-name"/> <br class="title-page-name"/>\param lifeLeft <br class="title-page-name"/>The amount of lifetime the object has left <br class="title-page-name"/> <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>void StaticParticleSystem::Update(M5Object * m_pObj, <br class="title-page-name"/>   float /*dt*/, float lifeLeft) <br class="title-page-name"/>{ <br class="title-page-name"/>  // Change our size based on where we want it to be <br class="title-page-name"/>  float currentPercentage = 1 - (lifeLeft / lifeTime); <br class="title-page-name"/>  m_pObj-&gt;scale.x = Lerp(startScale.x, <br class="title-page-name"/>     startScale.x * endScale, currentPercentage); <br class="title-page-name"/>  m_pObj-&gt;scale.y = Lerp(startScale.y, <br class="title-page-name"/>     startScale.y * endScale, currentPercentage); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">The static version of the <kbd class="calibre14">Init</kbd> and <kbd class="calibre14">Update</kbd> functions will just set our velocity to <kbd class="calibre14">0</kbd> so we don't move:</p>
<pre class="calibre23">
/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Used to initialize the particle system and set any parameters needed <br class="title-page-name"/> <br class="title-page-name"/>\param obj <br class="title-page-name"/>A reference to the object <br class="title-page-name"/> <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>void MovingParticleSystem::Init(M5Object * obj) <br class="title-page-name"/>{ <br class="title-page-name"/>  obj-&gt;vel = M5Vec2(M5Random::GetFloat(-1, 1), <br class="title-page-name"/>     M5Random::GetFloat(-1, 1)) * 10; <br class="title-page-name"/>} <br class="title-page-name"/> <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>/*! <br class="title-page-name"/>Used to update the particle system. Called once per frame <br class="title-page-name"/> <br class="title-page-name"/>\param m_pObj <br class="title-page-name"/>A reference to the object <br class="title-page-name"/> <br class="title-page-name"/>\param dt <br class="title-page-name"/>Amount of time that has passed since the previous frame <br class="title-page-name"/> <br class="title-page-name"/>\param lifeLeft <br class="title-page-name"/>The amount of lifetime the object has left <br class="title-page-name"/> <br class="title-page-name"/>*/ <br class="title-page-name"/>/******************************************************************************/ <br class="title-page-name"/>void MovingParticleSystem::Update(M5Object * m_pObj, float /*dt*/, float lifeLeft) <br class="title-page-name"/>{ <br class="title-page-name"/>  // Change our size based on where we want it to be <br class="title-page-name"/>  float currentPercentage = 1 - (lifeLeft / lifeTime); <br class="title-page-name"/>  m_pObj-&gt;scale.x = Lerp(startScale.x, <br class="title-page-name"/>     startScale.x * endScale, currentPercentage); <br class="title-page-name"/>  m_pObj-&gt;scale.y = Lerp(startScale.y, <br class="title-page-name"/>     startScale.y * endScale, currentPercentage); <br class="title-page-name"/>} 
</pre>
<p class="calibre2">For our moving particle system, we will set our velocity to a random number in the <em class="calibre12">x</em> and <em class="calibre12">y</em> axis, causing a nice explosion effect!</p>
<p class="calibre2">Now, instead of creating a copy of this data each time, we will have one copy that we will access, as shown in the following screenshot:</p>
<div><img class="image-border30" src="img/00059.jpeg"/></div>
<p class="calibre2">As we play, you'll notice that we now have a new particle system working and it's doing its job quite well.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    

        

            
                <h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            
                
<p class="calibre2">Over the course of this chapter, we learned about particles and how they can be used in order to improve the polish of our game project. We learned how we can implement a particle system inside of the Mach5 engine, and then learned about the Flyweight pattern and how it can be used effectively in order to reduce the memory usage on your projects. We saw how to do this by making use of the Factory pattern too, while making it a lot easier for us to create new particle system types as well. Keeping this in mind, it will be a lot easier in the future to break apart pieces of your programs that stay consistent and only create additional variables when you need to!</p>
<p class="calibre2">Moving forward, in the next chapter we will dive into graphics and the concepts needed to understand how our code will affect moving and animating game objects.</p>


            

            <footer class="calibre4">
                
            </footer>

        
    </body></html>