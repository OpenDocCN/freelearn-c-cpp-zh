<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Allocators</h1>
                
            
            
                
<p class="calibre2">We've seen in the preceding chapters that C++ has a love-hate relationship with dynamic memory allocation.</p>
<p class="calibre2">On one hand, dynamic memory allocation from the heap is a "code smell"; chasing pointers can hurt a program's performance, the heap can be exhausted unexpectedly (leading to exceptions of type <kbd class="calibre12">std::bad_alloc</kbd>), and manual memory management is so subtly difficult that C++11 introduced several different "smart pointer" types to manage the complexity (see <a href="part0093.html#2OM4A0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 6</a>, <em class="calibre22">Smart Pointers</em>). Successive versions of C++ after 2011 have also added a great number of non-allocating algebraic data types, such as <kbd class="calibre12">tuple</kbd>, <kbd class="calibre12">optional</kbd>, and <kbd class="calibre12">variant</kbd> (see <a href="part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 5</a>, <em class="calibre22">Vocabulary Types</em>) that can express ownership or containment without ever touching the heap.</p>
<p class="calibre2">On the other hand, the new smart pointer types do effectively manage the complexity of memory management; in modern C++ you can safely allocate and deallocate memory without ever using raw <kbd class="calibre12">new</kbd> or <kbd class="calibre12">delete</kbd> and without fear of memory leaks. And heap allocation is used "under the hood" of many of the new C++ features (<kbd class="calibre12">any</kbd>, <kbd class="calibre12">function</kbd>, <kbd class="calibre12">promise</kbd>) just as it continues to be used by many of the old ones (<kbd class="calibre12">stable_partition</kbd>, <kbd class="calibre12">vector</kbd>).</p>
<p class="calibre2">So there's a conflict here: How can we use these great new features (and the old ones) that depend on heap allocation, if we are simultaneously being told that good C++ code avoids heap allocation?</p>
<p class="calibre2">In most cases, you should err on the side of <em class="calibre22">using the features that C++ provides</em>. If you want a resizeable vector of elements, you <em class="calibre22">should</em> be using the default <kbd class="calibre12">std::vector</kbd>, unless you have measured an actual performance problem with using it in your case. But there also exists a class of programmers--working in very constrained environments such as flight software--who have to avoid touching the heap for a very simple reason: "the heap" does not exist on their platforms! In these embedded environments, the entire footprint of the program must be laid out at compile time. Some such programs simply avoid any algorithm that resembles heap allocation--you can never encounter unexpected resource exhaustion if you never dynamically allocate resources of any kind! Other such programs do use algorithms resembling heap allocation, but require that the "heap" be represented explicitly in their program (say, by a very large array of <kbd class="calibre12">char</kbd> and functions for "reserving" and "returning" consecutive chunks of that array).</p>
<p class="calibre2">It would be extremely unfortunate if programs of this last kind were unable to use the features that C++ provides, such as <kbd class="calibre12">std::vector</kbd> and <kbd class="calibre12">std::any</kbd>. So, ever since the original standard in 1998, the standard library has provided a feature known as <em class="calibre22">allocator-awareness</em>. When a type or an algorithm is <em class="calibre22">allocator-aware</em>, it provides a way for the programmer to specify exactly how the type or algorithm ought to reserve and return dynamic memory. This "how" is reified into an object known as an <em class="calibre22">allocator</em>.</p>
<p class="calibre2">In this chapter we'll learn:</p>
<ul class="calibre14">
<li class="calibre15">The definitions of "allocator" and "memory resource"</li>
<li class="calibre15">How to create your own memory resource that allocates out of a static buffer</li>
<li class="calibre15">How to make your own containers "allocator-aware"</li>
<li class="calibre15">The standard memory-resource types from namespace <kbd class="calibre12">std::pmr</kbd>, and their surprising pitfalls</li>
<li class="calibre15">That many of the strange features of the C++11 allocator model are intended purely to support <kbd class="calibre12">scoped_allocator_adaptor</kbd></li>
<li class="calibre15">What makes a type a "fancy pointer" type, and where such types might be useful</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">An allocator is a handle to a memory resource</h1>
                
            
            
                
<p class="calibre2">In reading this chapter, you'll have to keep in mind the difference between two fundamental concepts, which I am going to call <em class="calibre22">memory resource</em> and <em class="calibre22">allocator</em>. A <em class="calibre22">memory resource</em> (a name inspired by the standard's own terminology--you might find it more natural to call it "a heap") is a long-lived object that can dole out chunks of memory on request (usually by carving them out of a big block of memory that is owned by the memory resource itself). Memory resources have classically object-oriented semantics (see <a href="part0021.html#K0RQ0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 1</a>, <em class="calibre22">Classical Polymorphism and Generic Programming</em>): you create a memory resource once and never move or copy it, and equality for memory resources is generally defined by <em class="calibre22">object identity</em>. On the other hand, an <em class="calibre22">allocator</em> is a short-lived handle <em class="calibre22">pointing</em> to a memory resource. Allocators have pointer semantics: you can copy them, move them around, and generally mess with them as much as you want, and equality for allocators is generally defined by whether they point to the same memory resource. Instead of saying an allocator "points to" a particular memory resource, we might also say that the allocator is "backed by" that memory resource; the terms are interchangeable.</p>
<p class="calibre2">When I talk about "memory resources" and "allocators" in this chapter, I will be talking about the preceding concepts. The standard library also has a couple of types named <kbd class="calibre12">memory_resource</kbd> and <kbd class="calibre12">allocator</kbd>; whenever I'm talking about those types I'll be careful to use <kbd class="calibre12">typewriter text</kbd>. It shouldn't be too confusing. The situation is similar to <a href="part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 2</a>, <em class="calibre22">Iterators and Ranges</em>, where we talked about "iterators" and also about <kbd class="calibre12">std::iterator</kbd>. Of course that was easier because I only mentioned <kbd class="calibre12">std::iterator</kbd> in order to tell you never to use it; it has no place in well-written C++ code. In this chapter we'll learn that <kbd class="calibre12">std::pmr::memory_resource</kbd> <em class="calibre22">does</em> have a place in certain C++ programs!</p>
<p class="calibre2">Even though I described an allocator as a handle "pointing to" a memory resource, you should notice that sometimes the memory resource in question is a global singleton--one example of such a singleton is the global heap, whose accessors are the global <kbd class="calibre12">operator new</kbd> and <kbd class="calibre12">operator delete</kbd>. Just as a lambda which "captures" a global variable doesn't actually capture anything, an allocator backed by the global heap doesn't actually need any state. In fact, <kbd class="calibre12">std::allocator&lt;T&gt;</kbd> is just such a stateless allocator type--but we're getting ahead of ourselves here!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Refresher - Interfaces versus concepts</h1>
                
            
            
                
<p class="calibre2">Recall from <a href="part0021.html#K0RQ0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 1</a>, <em class="calibre22">Classical Polymorphism and Generic Programming</em>, that C++ offers two mostly incompatible ways of dealing with polymorphism. Static, compile-time polymorphism is called <em class="calibre22">generic programming</em>; it relies on expressing the polymorphic interface as a <em class="calibre22">concept</em> with many possible <em class="calibre22">models</em>, and the code that interacts with the interface is expressed in terms of <em class="calibre22">templates</em>. Dynamic, runtime polymorphism is called <em class="calibre22">classical polymorphism</em>; it relies on expressing the polymorphic interface as a <em class="calibre22">base class</em> with many possible <em class="calibre22">derived classes</em>, and the code that interacts with the interface is expressed in terms of calls to <em class="calibre22">virtual methods</em>.</p>
<p class="calibre2">In this chapter we'll have our first (and last) really close encounter with generic programming. It is impossible to make sense of C++ allocators unless you can hold in your mind two ideas at once: on one hand the <em class="calibre22">concept</em> <kbd class="calibre12">Allocator</kbd>, which defines an interface, and on the other hand some particular <em class="calibre22">model</em>, such as <kbd class="calibre12">std::allocator</kbd>, that implements behavior conforming to the <kbd class="calibre12">Allocator</kbd> concept.</p>
<p class="calibre2">To complicate matters further, the <kbd class="calibre12">Allocator</kbd> concept is really a templated family of concepts! It would be more accurate to talk about the family of concepts <kbd class="calibre12">Allocator&lt;T&gt;</kbd>; for example, <kbd class="calibre12">Allocator&lt;int&gt;</kbd> would be the concept defining "an allocator that allocates <kbd class="calibre12">int</kbd> objects," and <kbd class="calibre12">Allocator&lt;char&gt;</kbd> would be "an allocator that allocates <kbd class="calibre12">char</kbd> objects," and so on. And, for example, the concrete class <kbd class="calibre12">std::allocator&lt;int&gt;</kbd> is a model of the concept <kbd class="calibre12">Allocator&lt;int&gt;</kbd>, but it is <em class="calibre22">not</em> a model of <kbd class="calibre12">Allocator&lt;char&gt;</kbd>.</p>
<p class="calibre2">Every allocator of <kbd class="calibre12">T</kbd> (every <kbd class="calibre12">Allocator&lt;T&gt;</kbd>) is required to provide a member function named <kbd class="calibre12">allocate</kbd>, such that <kbd class="calibre12">a.allocate(n)</kbd> returns a pointer to enough memory for an array of <kbd class="calibre12">n</kbd> objects of type <kbd class="calibre12">T</kbd>. (That pointer will come from the memory resource that backs the allocator instance.) It is not specified whether the <kbd class="calibre12">allocate</kbd> member function ought to be static or non-static, nor whether it ought to take exactly one parameter (<kbd class="calibre12">n</kbd>) or perhaps some additional parameters with default values. So both of the following class types would be acceptable models of <kbd class="calibre12">Allocator&lt;int&gt;</kbd> in that respect:</p>
<pre class="calibre23">    struct int_allocator_2014 {<br class="title-page-name"/>      int *allocate(size_t n, const void *hint = nullptr);<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    struct int_allocator_2017 {<br class="title-page-name"/>      int *allocate(size_t n);<br class="title-page-name"/>    };</pre>
<p class="calibre2">The class designated <kbd class="calibre12">int_allocator_2017</kbd> is obviously a <em class="calibre22">simpler</em> way to model <kbd class="calibre12">Allocator&lt;int&gt;</kbd>, but <kbd class="calibre12">int_allocator_2014</kbd> is just as correct a model, because in both cases the expression <kbd class="calibre12">a.allocate(n)</kbd> will be accepted by the compiler; and that's all we ask for, when we're talking about <em class="calibre22">generic programming</em>.</p>
<p class="calibre2">In contrast, when we do classical polymorphism, we specify a fixed signature for each method of the base class, and derived classes are not allowed to deviate from that signature:</p>
<pre class="calibre23">    struct classical_base {<br class="title-page-name"/>      virtual int *allocate(size_t n) = 0;<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    struct classical_derived : public classical_base {<br class="title-page-name"/>      int *allocate(size_t n) override;<br class="title-page-name"/>    };</pre>
<p class="calibre2">The derived class <kbd class="calibre12">classical_derived</kbd> is not allowed to add any extra parameters onto the signature of the <kbd class="calibre12">allocate</kbd> method; it's not allowed to change the return type; it's not allowed to make the method <kbd class="calibre12">static</kbd>. The interface is more "locked down" with classical polymorphism than it is with generic programming.</p>
<p class="calibre2">Because a "locked-down" classical interface is naturally easier to describe than a wide-open conceptual one, we'll start our tour of the allocator library with C++17's brand-new, classically polymorphic <kbd class="calibre12">memory_resource</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Defining a heap with memory_resource</h1>
                
            
            
                
<p class="calibre2">Recall that on resource-constrained platforms, we might not be permitted to use "the heap" (for example via <kbd class="calibre12">new</kbd> and <kbd class="calibre12">delete</kbd>), because the platform's runtime might not support dynamic memory allocation. But we can make our own little heap--not "the heap," just "a heap"--and simulate the effect of dynamic memory allocation by writing a couple of functions <kbd class="calibre12">allocate</kbd> and <kbd class="calibre12">deallocate</kbd> that reserve chunks of a big statically allocated array of <kbd class="calibre12">char</kbd>, something like this:</p>
<pre class="calibre23">    static char big_buffer[10000];<br class="title-page-name"/>    static size_t index = 0;<br class="title-page-name"/><br class="title-page-name"/>    void *allocate(size_t bytes) {<br class="title-page-name"/>      if (bytes &gt; sizeof big_buffer - index) {<br class="title-page-name"/>        throw std::bad_alloc();<br class="title-page-name"/>      }<br class="title-page-name"/>      index += bytes;<br class="title-page-name"/>      return &amp;big_buffer[index - bytes];<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void deallocate(void *p, size_t bytes) {<br class="title-page-name"/>      // drop it on the floor<br class="title-page-name"/>    }</pre>
<p class="calibre2">To keep the code as simple as possible, I made <kbd class="calibre12">deallocate</kbd> a no-op. This little heap allows the caller to allocate up to 10,000 bytes of memory, and then starts throwing <kbd class="calibre12">bad_alloc</kbd> from then on.</p>
<p class="calibre2">With a little more investment in the code, we can allow the caller to allocate and deallocate an infinite number of times, as long as the total outstanding amount of allocated memory doesn't exceed 10,000 bytes and as long as the caller always follows a "last-allocated-first-deallocated" protocol:</p>
<pre class="calibre23">    void deallocate(void *p, size_t bytes) {<br class="title-page-name"/>      if ((char*)p + bytes == &amp;big_buffer[index]) {<br class="title-page-name"/>        // aha! we can roll back our index!<br class="title-page-name"/>        index -= bytes;<br class="title-page-name"/>      } else {<br class="title-page-name"/>        // drop it on the floor<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">The salient point here is that our heap has some <em class="calibre22">state</em> (in this case, <kbd class="calibre12">big_buffer</kbd> and <kbd class="calibre12">index</kbd>), and a couple of functions that manipulate this state. We've seen two different possible implementations of <kbd class="calibre12">deallocate</kbd> already--and there are other possibilities, with additional shared state, that wouldn't be so "leaky"--yet the interface, the signatures of <kbd class="calibre12">allocate</kbd> and <kbd class="calibre12">deallocate</kbd> themselves, has remained constant. This suggests that we could wrap up our state and accessor functions into a C++ object; and the wide variety of implementation possibilities plus the constancy of our function signatures suggests that we could use some classical polymorphism.</p>
<p class="calibre2">The C++17 allocator model does exactly that. The standard library provides the definition of a classically polymorphic base class, <kbd class="calibre12">std::pmr::memory_resource</kbd>, and then we implement our own little heap as a derived class. (In practice we might use one of the derived classes provided by the standard library, but let's finish up our little example before talking about those.) The base class <kbd class="calibre12">std::pmr::memory_resource</kbd> is defined in the standard header <kbd class="calibre12">&lt;memory_resource&gt;</kbd>:</p>
<pre class="calibre23">    class memory_resource {<br class="title-page-name"/>      virtual void *do_allocate(size_t bytes, size_t align) = 0;<br class="title-page-name"/>      virtual void do_deallocate(void *p, size_t bytes, size_t align) = 0;<br class="title-page-name"/>      virtual bool do_is_equal(const memory_resource&amp; rhs) const = 0;<br class="title-page-name"/>    public:<br class="title-page-name"/>      void *allocate(size_t bytes, size_t align) {<br class="title-page-name"/>        return do_allocate(bytes, align);<br class="title-page-name"/>      }<br class="title-page-name"/>      void deallocate(void *p, size_t bytes, size_t align) {<br class="title-page-name"/>        return do_deallocate(p, bytes, align);<br class="title-page-name"/>      }<br class="title-page-name"/>      bool is_equal(const memory_resource&amp; rhs) const {<br class="title-page-name"/>        return do_is_equal(rhs);<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">Notice the curious layer of indirection between the <kbd class="calibre12">public</kbd> interface of the class and the <kbd class="calibre12">virtual</kbd> implementation. Usually when we're doing classical polymorphism, we have just one set of methods that are both <kbd class="calibre12">public</kbd> and <kbd class="calibre12">virtual</kbd>; but in this case, we have a <kbd class="calibre12">public</kbd> non-virtual interface that calls down into the private virtual methods. This splitting of the interface from the implementation has a few obscure benefits--for example, it prevents any child class from invoking <kbd class="calibre12">this-&gt;SomeBaseClass::allocate()</kbd> using the "directly invoke a virtual method non-virtually" syntax--but honestly, its main benefit to us is that when we define a derived class, we don't have to use the <kbd class="calibre12">public</kbd> keyword at all. Because we are specifying only the <em class="calibre22">implementation</em>, not the interface, all the code we write can be <kbd class="calibre12">private</kbd>. Here's our trivial little leaky heap:</p>
<pre class="calibre23">    class example_resource : public std::pmr::memory_resource {<br class="title-page-name"/>      alignas(std::max_align_t) char big_buffer[10000];<br class="title-page-name"/>      size_t index = 0;<br class="title-page-name"/>      void *do_allocate(size_t bytes, size_t align) override {<br class="title-page-name"/>        if (align &gt; alignof(std::max_align_t) ||<br class="title-page-name"/>            (-index % align) &gt; sizeof big_buffer - index ||<br class="title-page-name"/>            bytes &gt; sizeof big_buffer - index - (-index % align))<br class="title-page-name"/>        {<br class="title-page-name"/>            throw std::bad_alloc();<br class="title-page-name"/>        }<br class="title-page-name"/>        index += (-index % align) + bytes;<br class="title-page-name"/>        return &amp;big_buffer[index - bytes];<br class="title-page-name"/>      }<br class="title-page-name"/>      void do_deallocate(void *, size_t, size_t) override {<br class="title-page-name"/>        // drop it on the floor<br class="title-page-name"/>      }<br class="title-page-name"/>      bool do_is_equal(const memory_resource&amp; rhs) const override {<br class="title-page-name"/>        return this == &amp;rhs;<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">Notice that the standard library's <kbd class="calibre12">std::pmr::memory_resource::allocate</kbd> takes not only a size in bytes, but also an alignment. We need to make sure that whatever pointer we return from <kbd class="calibre12">do_allocate</kbd> is suitably aligned; for example, if our caller is planning to store <kbd class="calibre12">int</kbd> in the memory we give him, he might ask for four-byte alignment.</p>
<p class="calibre2">The last thing to notice about our derived class <kbd class="calibre12">example_resource</kbd> is that it represents the actual resources controlled by our "heap"; that is, it actually contains, owns, and manages the <kbd class="calibre12">big_buffer</kbd> out of which it's allocating memory. For any given <kbd class="calibre12">big_buffer</kbd>, there will be exactly one <kbd class="calibre12">example_resource</kbd> object in our program that manipulates that buffer. Just as we said earlier: objects of type <kbd class="calibre12">example_resource</kbd> are "memory resources," and thus they are <em class="calibre22">not</em> intended to be copied or moved around; they are classically object-oriented, not value-semantic.</p>
<p class="calibre2">The standard library provides several species of memory resource, all derived from <kbd class="calibre12">std::pmr::memory_resource</kbd>. Let's look at a few of them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using the standard memory resources</h1>
                
            
            
                
<p class="calibre2">Memory resources in the standard library come in two flavors. Some of them are actual class types, of which you can create instances; and some of them are "anonymous" class types accessed only via singleton functions. Generally you can predict which is which by thinking about whether two objects of the type could ever possibly be "different," or whether the type is basically a singleton anyway.</p>
<p class="calibre2">The simplest memory resource in the <kbd class="calibre12">&lt;memory_resource&gt;</kbd> header is the "anonymous" singleton accessed via <kbd class="calibre12">std::pmr::null_memory_resource()</kbd>. The definition of this function is something like this:</p>
<pre class="calibre23">    class UNKNOWN : public std::pmr::memory_resource {<br class="title-page-name"/>      void *do_allocate(size_t, size_t) override {<br class="title-page-name"/>        throw std::bad_alloc();<br class="title-page-name"/>      }<br class="title-page-name"/>      void do_deallocate(void *, size_t, size_t) override {}<br class="title-page-name"/>      bool do_is_equal(const memory_resource&amp; rhs) const override {<br class="title-page-name"/>        return this == &amp;rhs;<br class="title-page-name"/>      }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    std::pmr::memory_resource *null_memory_resource() noexcept {<br class="title-page-name"/>      static UNKNOWN singleton;<br class="title-page-name"/>      return &amp;singleton;<br class="title-page-name"/>    }</pre>
<p class="calibre2">Notice that the function returns a pointer to the singleton instance. Generally, <kbd class="calibre12">std::pmr::memory_resource</kbd> objects will be manipulated via pointers, because the <kbd class="calibre12">memory_resource</kbd> objects themselves cannot move around.</p>
<p class="calibre2"><kbd class="calibre12">null_memory_resource</kbd> seems fairly useless; all it does is throw an exception when you try to allocate from it. However, it can be useful when you start using the more complicated memory resources which we'll see in a moment.</p>
<p class="calibre2">The next most complicated memory resource is the singleton accessed via <kbd class="calibre12">std::pmr::new_delete_resource()</kbd>; it uses <kbd class="calibre12">::operator new</kbd> and <kbd class="calibre12">::operator delete</kbd> to allocate and deallocate memory.</p>
<p class="calibre2">Now we move on to talking about the named class types. These are resources where it makes sense to have multiple resources of identical type in a single program. For example, there's <kbd class="calibre12">class std::pmr::monotonic_buffer_resource</kbd>. This memory resource is fundamentally the same as our <kbd class="calibre12">example_resource</kbd> from earlier, except for two differences: Instead of holding its big buffer as member data (<kbd class="calibre12">std::array</kbd>-style), it just holds a pointer to a big buffer allocated from somewhere else (<kbd class="calibre12">std::vector</kbd>-style). And when its first big buffer runs out, rather than immediately starting to throw <kbd class="calibre12">bad_alloc</kbd>, it will attempt to allocate a <em class="calibre22">second</em> big buffer, and allocate chunks out of that buffer until <em class="calibre22">it's</em> all gone; at which point it will allocate a third big buffer... and so on, until eventually it cannot even allocate any more big buffers. As with our <kbd class="calibre12">example_resource</kbd>, none of the deallocated memory is ever freed until the resource object itself is destroyed. There is one useful escape valve: If you call the method <kbd class="calibre12">a.release()</kbd>, the <kbd class="calibre12">monotonic_buffer_resource</kbd> will release all of the buffers it's currently holding, sort of like calling <kbd class="calibre12">clear()</kbd> on a vector.</p>
<p class="calibre2">When you construct a resource of type <kbd class="calibre12">std::pmr::monotonic_buffer_resource</kbd>, you need to tell it two things: Where is its first big buffer located? and, when that buffer is exhausted, who it should ask for another buffer? The first of these questions is answered by providing a pair of arguments <kbd class="calibre12">void*, size_t</kbd> that describes the first big buffer (optionally <kbd class="calibre12">nullptr</kbd>); and the second question is answered by providing a <kbd class="calibre12">std::pmr::memory_resource*</kbd> that points to this resource's "upstream" resource. One sensible thing to pass in for the "upstream" resource would be <kbd class="calibre12">std::pmr::new_delete_resource()</kbd>, so as to allocate new buffers using <kbd class="calibre12">::operator new</kbd>. Or, another sensible thing to pass in would be <kbd class="calibre12">std::pmr::null_memory_resource()</kbd>, so as to put a hard cap on the memory usage of this particular resource. Here's an example of the latter:</p>
<pre class="calibre23">    alignas(16) char big_buffer[10000];<br class="title-page-name"/><br class="title-page-name"/>    std::pmr::monotonic_buffer_resource a(<br class="title-page-name"/>      big_buffer, sizeof big_buffer,<br class="title-page-name"/>      std::pmr::null_memory_resource()<br class="title-page-name"/>    );<br class="title-page-name"/><br class="title-page-name"/>    void *p1 = a.allocate(100);<br class="title-page-name"/>    assert(p1 == big_buffer + 0);<br class="title-page-name"/><br class="title-page-name"/>    void *p2 = a.allocate(100, 16); // alignment<br class="title-page-name"/>    assert(p1 == big_buffer + 112);<br class="title-page-name"/><br class="title-page-name"/>    // Now clear everything allocated so far and start over.<br class="title-page-name"/>    a.release();<br class="title-page-name"/>    void *p3 = a.allocate(100);<br class="title-page-name"/>    assert(p3 == big_buffer + 0);<br class="title-page-name"/><br class="title-page-name"/>    // When the buffer is exhausted, a will go upstream<br class="title-page-name"/>    // to look for more buffers... and not find any.<br class="title-page-name"/>    try {<br class="title-page-name"/>      a.allocate(9901);<br class="title-page-name"/>    } catch (const std::bad_alloc&amp;) {<br class="title-page-name"/>      puts("The null_memory_resource did its job!");<br class="title-page-name"/>    }</pre>
<p class="calibre2">If you forget what upstream resource a particular <kbd class="calibre12">monotonic_buffer_resource</kbd> is using, you can always find out by calling <kbd class="calibre12">a.upstream_resource()</kbd>; that method returns a pointer to the upstream resource that was provided to the constructor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Allocating from a pool resource</h1>
                
            
            
                
<p class="calibre2">The final kind of memory resource provided by the C++17 standard library is what's called a "pool resource." A pool resource doesn't just manage one big buffer, such as <kbd class="calibre12">example_resource</kbd>; or even a monotonically increasing chain of buffers, such as <kbd class="calibre12">monotonic_buffer_resource</kbd>. Instead it manages a whole lot of "blocks" of various sizes. All the blocks of a given size are stored together in a "pool," so that we can talk about "the pool of blocks of size 4," "the pool of blocks of size 16," and so on. When a request comes in for an allocation of size <em class="calibre22">k</em>, the pool resource will look in the pool of blocks of size <em class="calibre22">k</em>, pull one out and return it. If the pool for size <em class="calibre22">k</em> is empty, then the pool resource will attempt to allocate some more blocks from its upstream resource. Also, if a request comes in for an allocation so large that we don't even have a pool for blocks of that size, then the pool resource is allowed to pass the request directly on to its upstream resource.</p>
<p class="calibre2">Pool resources come in two flavors: <em class="calibre22">synchronized</em> and <em class="calibre22">unsynchronized</em>, which is to say, thread-safe and thread-unsafe. If you're going to be accessing a pool from two different threads concurrently, then you should use <kbd class="calibre12">std::pmr::synchronized_pool_resource</kbd>, and if you're definitely never going to do that, and you want raw speed, then you should use <kbd class="calibre12">std::pmr::unsynchronized_pool_resource</kbd>. (By the way, <kbd class="calibre12">std::pmr::monotonic_buffer_resource</kbd> is always thread-unsafe; and <kbd class="calibre12">new_delete_resource()</kbd> is effectively thread-safe, since all it does is call <kbd class="calibre12">new</kbd> and <kbd class="calibre12">delete</kbd>.)</p>
<p class="calibre2">When you construct a resource of type <kbd class="calibre12">std::pmr::synchronized_pool_resource</kbd>, you need to tell it three things: Which block sizes it should keep in its pools; how many blocks it should glom together into a "chunk" when it goes to get more blocks from the upstream resource; and who is its upstream resource. Unfortunately, the standard interface leaves much to be desired here--so much so that frankly I recommend that if these parameters truly matter to you, you should be implementing your own derived <kbd class="calibre12">memory_resource</kbd> and not touching the standard library's version at all. The syntax for expressing these options is also fairly wonky:</p>
<pre class="calibre23">    std::pmr::pool_options options;<br class="title-page-name"/>    options.max_blocks_per_chunk = 100;<br class="title-page-name"/>    options.largest_required_pool_block = 256;<br class="title-page-name"/><br class="title-page-name"/>    std::pmr::synchronized_pool_resource a(<br class="title-page-name"/>      options,<br class="title-page-name"/>      std::pmr::new_delete_resource()<br class="title-page-name"/>    );</pre>
<p class="calibre2">Notice that there is no way to specify exactly which block sizes you want; that's left up to the vendor's implementation of <kbd class="calibre12">synchronized_pool_resource</kbd>. If you're lucky, it will choose decent block sizes that match your use-case; but personally I wouldn't rely on that assumption. Notice also that there's no way to use different upstream resources for the different block sizes, nor a different upstream resource for the "fallback" resource that's used when the caller requests an unusually sized allocation.</p>
<p class="calibre2">In short, I would steer clear of the built-in <kbd class="calibre12">pool_resource</kbd> derived classes for the foreseeable future. But the fundamental idea of deriving your own classes from <kbd class="calibre12">memory_resource</kbd> is solid. If you're concerned about memory allocation and managing your own little heaps, I'd recommend adopting <kbd class="calibre12">memory_resource</kbd> into your codebase.</p>
<p class="calibre2">Now, so far we've only been talking about various allocation strategies, as "personified" by the different <kbd class="calibre12">memory_resource</kbd> derived classes. We still need to see how to hook <kbd class="calibre12">memory_resource</kbd> into the algorithms and containers of the Standard Template Library. And to do that, we'll have to transition from the classically polymorphic world of <kbd class="calibre12">memory_resource</kbd> back into the value-semantic world of the C++03 STL.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The 500 hats of the standard allocator</h1>
                
            
            
                
<p class="calibre2">The standard allocator model must have seemed amazing in 2011. We're about to see how, with just one C++ type, we can accomplish all of the following feats:</p>
<ul class="calibre14">
<li class="calibre15">Specify a memory resource to be used for allocating memory.</li>
<li class="calibre15">Annotate each allocated pointer with some metadata that will be carried along<br class="title-page-name"/>
for its whole lifetime, all the way to deallocation time.</li>
<li class="calibre15">Associate a container object with a particular memory resource, and make sure<br class="title-page-name"/>
that association is "sticky"--this container object will always use the given<br class="title-page-name"/>
heap for its allocations.</li>
<li class="calibre15">Associate a container <em class="calibre22">value</em> with a particular memory resource, meaning<br class="title-page-name"/>
that the container can be efficiently moved around using value semantics without<br class="title-page-name"/>
forgetting how to deallocate its contents.</li>
<li class="calibre15">Choose between the two mutually exclusive behaviors above.</li>
<li class="calibre15">Specify a strategy for allocating memory at all levels of a multi-level<br class="title-page-name"/>
container, such as a vector of vectors.</li>
<li class="calibre15">Redefine what it means to "construct" the contents of a container, so that<br class="title-page-name"/>
for example, <kbd class="calibre12">vector&lt;int&gt;::resize</kbd> could be defined to default-initialize new elements instead of zero-initializing them.</li>
</ul>
<p class="calibre2">This is just an <em class="calibre22">insane</em> number of hats for any one class type to wear--a massive violation of the Single Responsibility Principle. Nevertheless, this is what the standard allocator model does; so let's try to explain all these features.</p>
<p class="calibre2">Remember that a "standard allocator" is just any class type that satisfies the concept <kbd class="calibre12">Allocator&lt;T&gt;</kbd> for some type <kbd class="calibre12">T</kbd>. The standard library provides three standard allocator types: <kbd class="calibre12">std::allocator&lt;T&gt;</kbd>, <kbd class="calibre12">std::pmr::polymorphic_allocator&lt;T&gt;</kbd>, and <kbd class="calibre12">std::scoped_allocator_adaptor&lt;A...&gt;</kbd>.</p>
<p class="calibre2">Let's start by looking at <kbd class="calibre12">std::allocator&lt;T&gt;</kbd>:</p>
<pre class="calibre23">    template&lt;class T&gt;<br class="title-page-name"/>    struct allocator {<br class="title-page-name"/>      using value_type = T;<br class="title-page-name"/><br class="title-page-name"/>      T *allocate(size_t n) {<br class="title-page-name"/>        return static_cast&lt;T *&gt;(::operator new(n * sizeof (T)));<br class="title-page-name"/>      }<br class="title-page-name"/>      void deallocate(T *p, size_t) {<br class="title-page-name"/>        ::operator delete(static_cast&lt;void *&gt;(p));<br class="title-page-name"/>      }<br class="title-page-name"/> <br class="title-page-name"/>      // NOTE 1<br class="title-page-name"/>      template&lt;class U&gt;<br class="title-page-name"/>      explicit allocator(const allocator&lt;U&gt;&amp;) noexcept {}<br class="title-page-name"/><br class="title-page-name"/>      // NOTE 2<br class="title-page-name"/>      allocator() = default;<br class="title-page-name"/>      allocator(const allocator&amp;) = default;<br class="title-page-name"/>    };</pre>
<p class="calibre2"><kbd class="calibre12">std::allocator&lt;T&gt;</kbd> has the member functions <kbd class="calibre12">allocate</kbd> and <kbd class="calibre12">deallocate</kbd> that are required by the <kbd class="calibre12">Allocator&lt;T&gt;</kbd> concept. Remember that we are in the world of concept-based generic programming now! The classically polymorphic <kbd class="calibre12">memory_resource</kbd> <em class="calibre22">also</em> had member functions named <kbd class="calibre12">allocate</kbd> and <kbd class="calibre12">deallocate</kbd>, but they always returned <kbd class="calibre12">void*</kbd>, not <kbd class="calibre12">T*</kbd>. (Also, <kbd class="calibre12">memory_resource::allocate()</kbd> took two arguments--<kbd class="calibre12">bytes</kbd> and <kbd class="calibre12">align</kbd>--whereas <kbd class="calibre12">allocator&lt;T&gt;::allocate()</kbd> takes only one argument. The first reason for this is that <kbd class="calibre12">allocator&lt;T&gt;</kbd> predated the mainstream understanding that alignment was a big deal; remember that the <kbd class="calibre12">sizeof</kbd> operator was inherited from C in the 1980s but the <kbd class="calibre12">alignof</kbd> operator only showed up in C++11. The second reason is that in the context of <kbd class="calibre12">std::allocator&lt;T&gt;</kbd>, we know that the type of the objects being allocated is <kbd class="calibre12">T</kbd>, and thus the requested alignment must necessarily be <kbd class="calibre12">alignof(T)</kbd>. <kbd class="calibre12">std::allocator&lt;T&gt;</kbd> doesn't use that information, because it predates <kbd class="calibre12">alignof</kbd>; but in principle it could, and that's why the <kbd class="calibre12">Allocator&lt;T&gt;</kbd> concept requires only the signature <kbd class="calibre12">a.allocate(n)</kbd> instead of <kbd class="calibre12">a.allocate(n, align)</kbd>.)</p>
<p class="calibre2">The constructor marked <kbd class="calibre12">NOTE 1</kbd> is important; every allocator needs a templated constructor modeled after this one. The constructors following the line marked <kbd class="calibre12">NOTE 2</kbd> are unimportant; the only reason we wrote them explicitly in the code is because if we had not written them, they would have been implicitly deleted due to the presence of a user-defined constructor (namely, the <kbd class="calibre12">NOTE 1</kbd> constructor).</p>
<p class="calibre2">The idea of any standard allocator is that we can plug it in as the very last template type parameter of any standard container (<a href="part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 4</a>, <em class="calibre22">The Container Zoo</em>) and the container will then use that allocator instead of its usual mechanisms anytime it needs to allocate memory for any reason. Let's see an example:</p>
<pre class="calibre23">    template&lt;class T&gt;<br class="title-page-name"/>    struct helloworld {<br class="title-page-name"/>      using value_type = T;<br class="title-page-name"/><br class="title-page-name"/>      T *allocate(size_t n) {<br class="title-page-name"/>        printf("hello world %zu\n", n);<br class="title-page-name"/>        return static_cast&lt;T *&gt;(::operator new(n * sizeof (T)));<br class="title-page-name"/>      }<br class="title-page-name"/>      void deallocate(T *p, size_t) {<br class="title-page-name"/>        ::operator delete(static_cast&lt;void *&gt;(p));<br class="title-page-name"/>      }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    void test() {<br class="title-page-name"/>      std::vector&lt;int, helloworld&lt;int&gt;&gt; v;<br class="title-page-name"/>      v.push_back(42); // prints "hello world 1"<br class="title-page-name"/>      v.push_back(42); // prints "hello world 2"<br class="title-page-name"/>      v.push_back(42); // prints "hello world 4"<br class="title-page-name"/>    }</pre>
<p class="calibre2">Here our class <kbd class="calibre12">helloworld&lt;int&gt;</kbd> models <kbd class="calibre12">Allocator&lt;int&gt;</kbd>; but we've omitted the templated constructor. This is fine if we're dealing only with <kbd class="calibre12">vector</kbd>, because <kbd class="calibre12">vector</kbd> will allocate only arrays of its element type. However, watch what happens if we change the test case to use <kbd class="calibre12">list</kbd> instead:</p>
<pre class="calibre23">    void test() {<br class="title-page-name"/>      std::list&lt;int, helloworld&lt;int&gt;&gt; v;<br class="title-page-name"/>      v.push_back(42);<br class="title-page-name"/>    }</pre>
<p class="calibre2">Under libc++, this code spews several dozen lines of error messages, which boil down to the essential complaint "no known conversion from <kbd class="calibre12">helloworld&lt;int&gt;</kbd> to <kbd class="calibre12">helloworld&lt;std::__1::__list_node&lt;int, void *&gt;&gt;</kbd>." Recall from the diagram in <a href="part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 4</a>, <em class="calibre22">The Container Zoo</em>, that <kbd class="calibre12">std::list&lt;T&gt;</kbd> stores its elements in nodes that are larger than the size of <kbd class="calibre12">T</kbd> itself. So <kbd class="calibre12">std::list&lt;T&gt;</kbd> isn't going to be trying to allocate any <kbd class="calibre12">T</kbd> objects; it wants to allocate objects of type <kbd class="calibre12">__list_node</kbd>. To allocate memory for <kbd class="calibre12">__list_node</kbd> objects, it needs an allocator that models the concept <kbd class="calibre12">Allocator&lt;__list_node&gt;</kbd>, not <kbd class="calibre12">Allocator&lt;int&gt;</kbd>.</p>
<p class="calibre2">Internally, the constructor of <kbd class="calibre12">std::list&lt;int&gt;</kbd> takes our <kbd class="calibre12">helloworld&lt;int&gt;</kbd> and attempts to "rebind" it to allocate <kbd class="calibre12">__list_node</kbd> objects instead of <kbd class="calibre12">int</kbd> objects. This is accomplished via a <em class="calibre22">traits class--</em>a C++ idiom that we first encountered in <a href="part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 2</a>, <em class="calibre22">Iterators and Ranges</em>:</p>
<pre class="calibre23">    using AllocOfInt = helloworld&lt;int&gt;;<br class="title-page-name"/><br class="title-page-name"/>    using AllocOfChar =<br class="title-page-name"/>      std::allocator_traits&lt;AllocOfInt&gt;::rebind_alloc&lt;char&gt;;<br class="title-page-name"/><br class="title-page-name"/>    // Now alloc_of_char is helloworld&lt;char&gt;</pre>
<p class="calibre2"/>
<p class="calibre2">The standard class template <kbd class="calibre12">std::allocator_traits&lt;A&gt;</kbd> wraps up a lot of information about the allocator type <kbd class="calibre12">A</kbd> into one place, so it's easy to get at. For example, <kbd class="calibre12">std::allocator_traits&lt;A&gt;::value_type</kbd> is an alias for the type <kbd class="calibre12">T</kbd> whose memory is allocated by <kbd class="calibre12">A</kbd>; and <kbd class="calibre12">std::allocator_traits&lt;A&gt;::pointer</kbd> is an alias for the corresponding pointer type (generally <kbd class="calibre12">T*</kbd>).</p>
<p class="calibre2">The nested alias template <kbd class="calibre12">std::allocator_traits&lt;A&gt;::rebind_alloc&lt;U&gt;</kbd> is a way of "converting" an allocator from one type <kbd class="calibre12">T</kbd> to another type <kbd class="calibre12">U</kbd>. This type trait uses metaprogramming to crack open the type <kbd class="calibre12">A</kbd> and see: first, whether <kbd class="calibre12">A</kbd> has a nested template alias <kbd class="calibre12">A::rebind&lt;U&gt;::other</kbd> (this is rare), and second, whether type <kbd class="calibre12">A</kbd> can be expressed in the form <kbd class="calibre12">Foo&lt;Bar,Baz...&gt;</kbd> (where <kbd class="calibre12">Baz...</kbd> is some list of types which might be an empty list). If <kbd class="calibre12">A</kbd> can be expressed that way, then <kbd class="calibre12">std::allocator_traits&lt;A&gt;::rebind_alloc&lt;U&gt;</kbd> will be a synonym for <kbd class="calibre12">Foo&lt;U,Baz...&gt;</kbd>. Philosophically, this is completely arbitrary; but in practice it works for every allocator type you'll ever see. In particular, it works for <kbd class="calibre12">helloworld&lt;int&gt;</kbd>--which explains why we didn't have to muck around with providing a nested alias <kbd class="calibre12">rebind&lt;U&gt;::other</kbd> in our <kbd class="calibre12">helloworld</kbd> class. By providing a sensible default behavior, the <kbd class="calibre12">std::allocator_traits</kbd> template has saved us some boilerplate. This is the reason <kbd class="calibre12">std::allocator_traits</kbd> exists.</p>
<p class="calibre2">You might wonder why <kbd class="calibre12">std::allocator_traits&lt;Foo&lt;Bar,Baz...&gt;&gt;::value_type</kbd> doesn't default to <kbd class="calibre12">Bar</kbd>. Frankly, I don't know either. It seems like a no-brainer; but the standard library doesn't do it. Therefore, every allocator type you write (remember now we're talking about classes modeling <kbd class="calibre12">Allocator&lt;T&gt;</kbd>, and <em class="calibre22">not</em> about classes derived from <kbd class="calibre12">memory_resource</kbd>) must provide a nested typedef <kbd class="calibre12">value_type</kbd> that is an alias for <kbd class="calibre12">T</kbd>.</p>
<p class="calibre2">However, once you've defined the nested typedef for <kbd class="calibre12">value_type</kbd>, you can rely on <kbd class="calibre12">std::allocator_traits</kbd> to infer the correct definitions for its nested typedef <kbd class="calibre12">pointer</kbd> (that is, <kbd class="calibre12">T*</kbd>), and <kbd class="calibre12">const_pointer</kbd> (that is, <kbd class="calibre12">const T*</kbd>), and <kbd class="calibre12">void_pointer</kbd> (that is, <kbd class="calibre12">void*</kbd>), and so on. If you were following the previous discussion of <kbd class="calibre12">rebind_alloc</kbd>, you might guess that "converting" a pointer type like <kbd class="calibre12">T*</kbd> to <kbd class="calibre12">void*</kbd> is just as difficult or easy as "converting" an allocator type <kbd class="calibre12">Foo&lt;T&gt;</kbd> to <kbd class="calibre12">Foo&lt;void&gt;</kbd>; and you'd be correct! The values of these pointer-related type aliases are all computed via a <em class="calibre22">second</em> standard traits class, <kbd class="calibre12">std::pointer_traits&lt;P&gt;</kbd>:</p>
<pre class="calibre23">    using PtrToInt = int*;<br class="title-page-name"/><br class="title-page-name"/>    using PtrToChar =<br class="title-page-name"/>      std::pointer_traits&lt;PtrToInt&gt;::rebind&lt;char&gt;;<br class="title-page-name"/><br class="title-page-name"/>    // Now PtrToChar is char*<br class="title-page-name"/><br class="title-page-name"/>    using PtrToConstVoid =<br class="title-page-name"/>      std::pointer_traits&lt;PtrToInt&gt;::rebind&lt;const void&gt;;<br class="title-page-name"/><br class="title-page-name"/>    // Now PtrToConstVoid is const void*</pre>
<p class="calibre2">This traits class becomes very important when we talk about the next responsibility of <kbd class="calibre12">Allocator&lt;T&gt;</kbd>, which was "annotate each allocated pointer with some metadata that will be carried along for its whole lifetime."</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Carrying metadata with fancy pointers</h1>
                
            
            
                
<p class="calibre2">Consider the following high-level design for a memory resource, which should remind you very much of <kbd class="calibre12">std::pmr::monotonic_buffer_resource</kbd>:</p>
<ul class="calibre14">
<li class="calibre15">Keep a list of chunks of memory we've gotten from the system. For each chunk, also store an <kbd class="calibre12">index</kbd> of how many bytes we've allocated from the beginning of the chunk; and store a count <kbd class="calibre12">freed</kbd> of how many bytes we've deallocated from this specific chunk.</li>
<li class="calibre15">When someone calls <kbd class="calibre12">allocate(n)</kbd>, increment any one of our chunks' <kbd class="calibre12">index</kbd> by the appropriate number of bytes if possible, or get a new chunk from the upstream resource if absolutely necessary.</li>
<li class="calibre15">When someone calls <kbd class="calibre12">deallocate(p, n)</kbd>, figure out which of our chunks <kbd class="calibre12">p</kbd> came from and increment its <kbd class="calibre12">freed += n</kbd>. If <kbd class="calibre12">freed == index</kbd>, then the entire chunk is empty, so set <kbd class="calibre12">freed = index = 0</kbd>.</li>
</ul>
<p class="calibre2">It's pretty straightforward to turn the foregoing description into code. The only problematic item is: in <kbd class="calibre12">deallocate(p, n)</kbd>, how do we figure out which of our chunks <kbd class="calibre12">p</kbd> came from?</p>
<p class="calibre2">This would be easy if we simply recorded the identity of the chunk in the "pointer" itself:</p>
<pre class="calibre23">    template&lt;class T&gt;<br class="title-page-name"/>    class ChunkyPtr {<br class="title-page-name"/>      T *m_ptr = nullptr;<br class="title-page-name"/>      Chunk *m_chunk = nullptr;<br class="title-page-name"/>    public:<br class="title-page-name"/>      explicit ChunkyPtr(T *p, Chunk *ch) :<br class="title-page-name"/>      m_ptr(p), m_chunk(ch) {}<br class="title-page-name"/><br class="title-page-name"/>      T&amp; operator *() const {<br class="title-page-name"/>        return *m_ptr;<br class="title-page-name"/>      }<br class="title-page-name"/>      explicit operator T *() const {<br class="title-page-name"/>        return m_ptr;<br class="title-page-name"/>      }<br class="title-page-name"/>      // ... and so on ...<br class="title-page-name"/><br class="title-page-name"/>      // ... plus this extra accessor:<br class="title-page-name"/>      auto chunk() const {<br class="title-page-name"/>        return m_chunk;<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">Then in our <kbd class="calibre12">deallocate(p, n)</kbd> function, all we'd have to do is to look at <kbd class="calibre12">p.chunk()</kbd>. But to make this work, we'd need to change the signature of the <kbd class="calibre12">allocate(n)</kbd> and <kbd class="calibre12">deallocate(p, n)</kbd> functions so that <kbd class="calibre12">deallocate</kbd> took a <kbd class="calibre12">ChunkyPtr&lt;T&gt;</kbd> instead of <kbd class="calibre12">T*</kbd>, and <kbd class="calibre12">allocate</kbd> returned <kbd class="calibre12">ChunkyPtr&lt;T&gt;</kbd> instead of <kbd class="calibre12">T*</kbd>.</p>
<p class="calibre2">Fortunately, the C++ standard library gives us a way to do this! All we need to do is define our own type that models <kbd class="calibre12">Allocator&lt;T&gt;</kbd> and give it a member typedef <kbd class="calibre12">pointer</kbd> that evaluates to <kbd class="calibre12">ChunkyPtr&lt;T&gt;</kbd>:</p>
<pre class="calibre23">    template&lt;class T&gt;<br class="title-page-name"/>    struct ChunkyAllocator {<br class="title-page-name"/>      using value_type = T;<br class="title-page-name"/>      using pointer = ChunkyPtr&lt;T&gt;;<br class="title-page-name"/><br class="title-page-name"/>      ChunkyAllocator(ChunkyMemoryResource *mr) :<br class="title-page-name"/>        m_resource(mr) {}<br class="title-page-name"/><br class="title-page-name"/>      template&lt;class U&gt;<br class="title-page-name"/>      ChunkyAllocator(const ChunkyAllocator&lt;U&gt;&amp; rhs) :<br class="title-page-name"/>        m_resource(rhs.m_resource) {}<br class="title-page-name"/><br class="title-page-name"/>      pointer allocate(size_t n) {<br class="title-page-name"/>        return m_resource-&gt;allocate(<br class="title-page-name"/>          n * sizeof(T), alignof(T));<br class="title-page-name"/>      } <br class="title-page-name"/>      void deallocate(pointer p, size_t n) {<br class="title-page-name"/>        m_resource-&gt;deallocate(<br class="title-page-name"/>          p, n * sizeof(T), alignof(T));<br class="title-page-name"/>      }<br class="title-page-name"/>    private:<br class="title-page-name"/>      ChunkyMemoryResource *m_resource;<br class="title-page-name"/><br class="title-page-name"/>      template&lt;class U&gt;<br class="title-page-name"/>      friend struct ChunkyAllocator;<br class="title-page-name"/>    };</pre>
<p class="calibre2">The traits classes <kbd class="calibre12">std::allocator_traits</kbd> and <kbd class="calibre12">std::pointer_traits</kbd> will take care of inferring the other typedefs--such as <kbd class="calibre12">void_pointer</kbd>, which through the magic of <kbd class="calibre12">pointer_traits::rebind</kbd> will end up as an alias for <kbd class="calibre12">ChunkyPtr&lt;void&gt;</kbd>.</p>
<p class="calibre2">I've left out the implementations of the <kbd class="calibre12">allocate</kbd> and <kbd class="calibre12">deallocate</kbd> functions here because they would depend on the interface of <kbd class="calibre12">ChunkyMemoryResource</kbd>. We might implement <kbd class="calibre12">ChunkyMemoryResource</kbd> something like this:</p>
<pre class="calibre23">    class Chunk {<br class="title-page-name"/>      char buffer[10000];<br class="title-page-name"/>      int index = 0;<br class="title-page-name"/>      int freed = 0;<br class="title-page-name"/>    public:<br class="title-page-name"/>      bool can_allocate(size_t bytes) {<br class="title-page-name"/>        return (sizeof buffer - index) &gt;= bytes;<br class="title-page-name"/>      }<br class="title-page-name"/>      auto allocate(size_t bytes) {<br class="title-page-name"/>        index += bytes;<br class="title-page-name"/>        void *p = &amp;buffer[index - bytes];<br class="title-page-name"/>        return ChunkyPtr&lt;void&gt;(p, this);<br class="title-page-name"/>      }<br class="title-page-name"/>      void deallocate(void *, size_t bytes) {<br class="title-page-name"/>        freed += bytes;<br class="title-page-name"/>        if (freed == index) {<br class="title-page-name"/>            index = freed = 0;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    class ChunkyMemoryResource {<br class="title-page-name"/>      std::list&lt;Chunk&gt; m_chunks;<br class="title-page-name"/>    public:<br class="title-page-name"/>      ChunkyPtr&lt;void&gt; allocate(size_t bytes, size_t align) {<br class="title-page-name"/>        assert(align &lt;= alignof(std::max_align_t));<br class="title-page-name"/>        bytes += -bytes % alignof(std::max_align_t);<br class="title-page-name"/>        assert(bytes &lt;= 10000);<br class="title-page-name"/><br class="title-page-name"/>        for (auto&amp;&amp; ch : m_chunks) {<br class="title-page-name"/>          if (ch.can_allocate(bytes)) {<br class="title-page-name"/>            return ch.allocate(bytes);<br class="title-page-name"/>          }<br class="title-page-name"/>        }<br class="title-page-name"/>        return m_chunks.emplace_back().allocate(bytes);<br class="title-page-name"/>      }<br class="title-page-name"/>      void deallocate(ChunkyPtr&lt;void&gt; p, size_t bytes, size_t) {<br class="title-page-name"/>        bytes += -bytes % alignof(std::max_align_t);<br class="title-page-name"/>        p.chunk()-&gt;deallocate(static_cast&lt;void*&gt;(p), bytes);<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">Now we can use our <kbd class="calibre12">ChunkyMemoryResource</kbd> to allocate memory for standard allocator-aware containers like this:</p>
<pre class="calibre23">    ChunkyMemoryResource mr;<br class="title-page-name"/>    std::vector&lt;int, ChunkyAllocator&lt;int&gt;&gt; v{&amp;mr};<br class="title-page-name"/>    v.push_back(42);<br class="title-page-name"/>    // All the memory for v's underlying array<br class="title-page-name"/>    // is coming from blocks owned by "mr".</pre>
<p class="calibre2">Now, I've chosen this example to make it look very simple and straightforward; and I've left out a lot of the details of the <kbd class="calibre12">ChunkyPtr&lt;T&gt;</kbd> type itself. If you try copying this code yourself, you'll find that you need to provide <kbd class="calibre12">ChunkyPtr</kbd> with a lot of overloaded operators such as <kbd class="calibre12">==</kbd>, <kbd class="calibre12">!=</kbd>, <kbd class="calibre12">&lt;</kbd>, <kbd class="calibre12">++</kbd>, <kbd class="calibre12">--</kbd>, and <kbd class="calibre12">-</kbd>; and you'll also need to provide a specialization for <kbd class="calibre12">ChunkyPtr&lt;void&gt;</kbd> that omits the overloaded <kbd class="calibre12">operator*</kbd>. Most of the details are the same as what we covered in <a href="part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 2</a>, <em class="calibre22">Iterators and Ranges</em>, when we implemented our own iterator type. In fact, every "fancy pointer" type is required to be usable as a <em class="calibre22">random-access iterator</em>--which means that you must provide the five nested typedefs listed at the end of <a href="part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 2</a>, <em class="calibre22">Iterators and Ranges</em>: <kbd class="calibre12">iterator_category</kbd>, <kbd class="calibre12">difference_type</kbd>, <kbd class="calibre12">value_type</kbd>, <kbd class="calibre12">pointer</kbd>, and <kbd class="calibre12">reference</kbd>.</p>
<p class="calibre2">Finally, if you want to use certain containers such as <kbd class="calibre12">std::list</kbd> and <kbd class="calibre12">std::map</kbd>, you'll need to implement a static member function with the surprising name <kbd class="calibre12">pointer_to(r)</kbd>:</p>
<pre class="calibre23">    static ChunkyPtr&lt;T&gt; pointer_to(T &amp;r) noexcept {<br class="title-page-name"/>      return ChunkyPtr&lt;T&gt;(&amp;r, nullptr);<br class="title-page-name"/>    }</pre>
<p class="calibre2">This is because--as you may recall from <a href="part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 4</a>, <em class="calibre22">The Container Zoo</em>--a few containers such as <kbd class="calibre12">std::list</kbd> store their data in nodes whose <kbd class="calibre12">prev</kbd> and <kbd class="calibre12">next</kbd> pointers need to be able to point <em class="calibre22">either</em> to an allocated node <em class="calibre22">or</em> to a node which is contained within the member data of the <kbd class="calibre12">std::list</kbd> object itself. There are two obvious ways to accomplish this: Either every <kbd class="calibre12">next</kbd> pointer must be stored in a sort of tagged union of a fancy pointer and a raw pointer (perhaps a <kbd class="calibre12">std::variant</kbd> as described in <a href="part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 5</a>, <em class="calibre22">Vocabulary Types</em>), or else we must find a way of encoding a raw pointer <em class="calibre22">as</em> a fancy pointer. The standard library chose the latter approach. So, whenever you write a fancy pointer type, not only must it do all the things required of it by the allocator, and not only must it satisfy the requirements of a random-access iterator, but it must <em class="calibre22">also</em> have a way of representing any arbitrary pointer in the program's address space--at least if you want to use your allocator with node-based containers such as <kbd class="calibre12">std::list</kbd>.</p>
<p class="calibre2">Even after jumping through all these hoops, you'll find that (as of press time) neither libc++ nor libstdc++ can handle fancy pointers in any container more complicated than <kbd class="calibre12">std::vector</kbd>. They support just enough to work with a single fancy pointer type--<kbd class="calibre12">boost::interprocess::offset_ptr&lt;T&gt;</kbd>, which carries no metadata. And the standard continues to evolve; <kbd class="calibre12">std::pmr::memory_resource</kbd> was newly introduced in C++17, and as of this writing it is still not implemented by libc++ nor libstdc++.</p>
<p class="calibre2">You may also have noticed the lack of any standard base class for memory resources that use fancy pointers. Fortunately, this is easy to write yourself:</p>
<pre class="calibre23">    namespace my {<br class="title-page-name"/><br class="title-page-name"/>      template&lt;class VoidPtr&gt;<br class="title-page-name"/>      class fancy_memory_resource {<br class="title-page-name"/>      public:<br class="title-page-name"/>        VoidPtr allocate(size_t bytes,<br class="title-page-name"/>          size_t align = alignof(std::max_align_t)) {<br class="title-page-name"/>          return do_allocate(bytes, align);<br class="title-page-name"/>        }<br class="title-page-name"/>        void deallocate(VoidPtr p, size_t bytes,<br class="title-page-name"/>          size_t align = alignof(std::max_align_t)) {<br class="title-page-name"/>          return do_deallocate(p, bytes, align);<br class="title-page-name"/>        }<br class="title-page-name"/>        bool is_equal(const fancy_memory_resource&amp; rhs) const noexcept {<br class="title-page-name"/>          return do_is_equal(rhs);<br class="title-page-name"/>        }<br class="title-page-name"/>        virtual ~fancy_memory_resource() = default;<br class="title-page-name"/>      private:<br class="title-page-name"/>        virtual VoidPtr do_allocate(size_t bytes, size_t align) = 0;<br class="title-page-name"/>        virtual void do_deallocate(VoidPtr p, size_t bytes,<br class="title-page-name"/>          size_t align) = 0;<br class="title-page-name"/>        virtual bool do_is_equal(const fancy_memory_resource&amp; rhs)<br class="title-page-name"/>          const noexcept = 0;<br class="title-page-name"/>      };<br class="title-page-name"/><br class="title-page-name"/>      using memory_resource = fancy_memory_resource&lt;void*&gt;;<br class="title-page-name"/><br class="title-page-name"/>    } // namespace my</pre>
<p class="calibre2">The standard library provides no allocators that use fancy pointers; every library-provided allocator type uses raw pointers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Sticking a container to a single memory resource</h1>
                
            
            
                
<p class="calibre2">The next hat worn by the standard allocator model--the next feature controlled by <kbd class="calibre12">std::allocator_traits</kbd>--is the ability to associate specific container objects with specific heaps. We used three bullet points to describe this feature earlier:</p>
<ul class="calibre14">
<li class="calibre15">Associate a container object with a particular memory resource, and make sure<br class="title-page-name"/>
that association is "sticky"--this container object will always use the given<br class="title-page-name"/>
heap for its allocations.</li>
<li class="calibre15">Associate a container <em class="calibre22">value</em> with a particular memory resource, meaning<br class="title-page-name"/>
that the container can be efficiently moved around using value semantics without<br class="title-page-name"/>
forgetting how to deallocate its contents.</li>
<li class="calibre15">Choose between the two mutually exclusive behaviors just mentioned.</li>
</ul>
<p class="calibre2">Let's look at an example, using <kbd class="calibre12">std::pmr::monotonic_buffer_resource</kbd> for our resource but using a hand-written class type for our allocator type. (Just to reassure you that you haven't missed anything: Indeed, we <em class="calibre22">still</em> haven't covered any standard-library-provided allocator types--except for <kbd class="calibre12">std::allocator&lt;T&gt;</kbd>, the trivial stateless allocator that is a handle to the global heap managed by <kbd class="calibre12">new</kbd> and <kbd class="calibre12">delete</kbd>.)</p>
<pre class="calibre23">    template&lt;class T&gt;<br class="title-page-name"/>    struct WidgetAlloc {<br class="title-page-name"/>      std::pmr::memory_resource *mr;<br class="title-page-name"/><br class="title-page-name"/>      using value_type = T;<br class="title-page-name"/><br class="title-page-name"/>      WidgetAlloc(std::pmr::memory_resource *mr) : mr(mr) {}<br class="title-page-name"/><br class="title-page-name"/>      template&lt;class U&gt;<br class="title-page-name"/>      WidgetAlloc(const WidgetAlloc&lt;U&gt;&amp; rhs) : mr(rhs.mr) {}<br class="title-page-name"/> <br class="title-page-name"/>      T *allocate(size_t n) {<br class="title-page-name"/>        return (T *)mr-&gt;allocate(n * sizeof(T), alignof(T));<br class="title-page-name"/>      }<br class="title-page-name"/>      void deallocate(void *p, size_t n) {<br class="title-page-name"/>        mr-&gt;deallocate(p, n * sizeof(T), alignof(T));<br class="title-page-name"/>      }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    class Widget {<br class="title-page-name"/>      char buffer[10000];<br class="title-page-name"/>      std::pmr::monotonic_buffer_resource mr {buffer, sizeof buffer};<br class="title-page-name"/>      std::vector&lt;int, WidgetAlloc&lt;int&gt;&gt; v {&amp;mr};<br class="title-page-name"/>      std::list&lt;int, WidgetAlloc&lt;int&gt;&gt; lst {&amp;mr};<br class="title-page-name"/>    public:<br class="title-page-name"/>      static void swap_elems(Widget&amp; a, Widget&amp; b) {<br class="title-page-name"/>        std::swap(a.v, b.v);<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">Here our <kbd class="calibre12">Widget</kbd> is a classically object-oriented class type; we expect it to live at a specific memory address for its entire lifetime. Then, to reduce heap fragmentation or to improve cache locality, we've placed a large buffer inside each <kbd class="calibre12">Widget</kbd> object and made the <kbd class="calibre12">Widget</kbd> use that buffer as the backing store for its data members <kbd class="calibre12">v</kbd> and <kbd class="calibre12">lst</kbd>.</p>
<p class="calibre2">Now look at the <kbd class="calibre12">Widget::swap_elems(a, b)</kbd> function. It swaps the <kbd class="calibre12">v</kbd> data members of <kbd class="calibre12">Widget a</kbd> and <kbd class="calibre12">Widget b</kbd>. You might recall from <a href="part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 4</a>, <em class="calibre22">The Container Zoo</em>, that a <kbd class="calibre12">std::vector</kbd> is little more than a pointer to a dynamically allocated array, and so <em class="calibre22">usually</em> the library can swap two instances of <kbd class="calibre12">std::vector</kbd> by simply swapping their underlying pointers, without moving any of the underlying data--making vector swap an O(1) operation instead of an O(<em class="calibre22">n</em>) operation.</p>
<p class="calibre2">Furthermore, <kbd class="calibre12">vector</kbd> is smart enough to know that if it swaps pointers, it also needs to swap allocators--so that the information about how to deallocate travels along with the pointer that will eventually be in need of deallocation.</p>
<p class="calibre2">But in this case, if the library just swapped the pointers and allocators, it would be disastrous! We'd have a vector <kbd class="calibre12">a.v</kbd> whose underlying array was now "owned" by <kbd class="calibre12">b.mr</kbd>, and vice versa. If we destroyed <kbd class="calibre12">Widget b</kbd>, then the next time we accessed the elements of <kbd class="calibre12">a.v</kbd> we'd be accessing freed memory. And furthermore, even if we never accessed <kbd class="calibre12">a.v</kbd> again, our program would likely crash when the destructor of <kbd class="calibre12">a.v</kbd> attempted to call the <kbd class="calibre12">deallocate</kbd> method of the long-dead <kbd class="calibre12">b.mr</kbd>!</p>
<p class="calibre2">Fortunately, the standard library saves us from this fate. One of the responsibilities of an allocator-aware container is to appropriately <em class="calibre22">propagate</em> its allocator on copy-assignment, move-assignment, and swap. For historical reasons this is handled by a whole mess of typedefs in the <kbd class="calibre12">allocator_traits</kbd> class template, but in order to <em class="calibre22">use</em> allocator propagation correctly, you only have to know a couple of things:</p>
<ul class="calibre14">
<li class="calibre15">Whether the allocator propagates itself, or whether it sticks firmly to a specific container, is a property of the <em class="calibre22">allocator type</em>. If you want one allocator to "stick" while another propagates, you <em class="calibre22">must</em> make them different types.</li>
<li class="calibre15">When an allocator is "sticky," it sticks to a particular (classical, object-oriented)<br class="title-page-name"/>
container object. Operations that with a non-sticky allocator type would be O(1) pointer-swaps may become O(<em class="calibre22">n</em>), because "adopting" elements from some other allocator's memory space into our own requires allocating room for them in our own memory space.</li>
<li class="calibre15">Stickiness has a clear use-case (as we have just shown with <kbd class="calibre12">Widget</kbd>), and<br class="title-page-name"/>
the effects of non-stickiness can be disastrous (again, see <kbd class="calibre12">Widget</kbd>). Therefore, <kbd class="calibre12">std::allocator_traits</kbd> assumes by default that an allocator type is sticky, unless it can tell that the allocator type is <em class="calibre22">empty</em> and thus is quite definitely <em class="calibre22">stateless</em>. The default for <em class="calibre22">empty</em> allocator types is effectively non-stickiness.</li>
<li class="calibre15">As a programmer, you basically always want the default: stateless allocators might as well propagate, and stateful allocators <em class="calibre22">probably</em> don't have much use outside of <kbd class="calibre12">Widget</kbd>-like scenarios where stickiness is required.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using the standard allocator types</h1>
                
            
            
                
<p class="calibre2">Let's talk about the allocator types provided by the standard library.</p>
<p class="calibre2"><kbd class="calibre12">std::allocator&lt;T&gt;</kbd> is the default allocator type; it is the default value of the template type parameter to every standard container. So for example when you write <kbd class="calibre12">std::vector&lt;T&gt;</kbd> in your code, that's secretly the exact same type as <kbd class="calibre12">std::vector&lt;T, std::allocator&lt;T&gt;&gt;</kbd>. As we've mentioned before in this chapter, <kbd class="calibre12">std::allocator&lt;T&gt;</kbd> is a stateless empty type; it is a "handle" to the global heap managed by <kbd class="calibre12">new</kbd> and <kbd class="calibre12">delete</kbd>. Because <kbd class="calibre12">std::allocator</kbd> is a stateless type, <kbd class="calibre12">allocator_traits</kbd> assumes (correctly) that it should be non-sticky. This means that operations such as <kbd class="calibre12">std::vector&lt;T&gt;::swap</kbd> and <kbd class="calibre12">std::vector&lt;T&gt;::operator=</kbd> are guaranteed to be very efficient pointer-swaps--because any object of type <kbd class="calibre12">std::vector&lt;T, std::allocator&lt;T&gt;&gt;</kbd> always knows how to deallocate memory that was originally allocated by any other <kbd class="calibre12">std::vector&lt;T, std::allocator&lt;T&gt;&gt;</kbd>.</p>
<p class="calibre2"><kbd class="calibre12">std::pmr::polymorphic_allocator&lt;T&gt;</kbd> is a new addition in C++17. It is a stateful, non-empty type; its one data member is a pointer to a <kbd class="calibre12">std::pmr::memory_resource</kbd>. (In fact, it is almost identical to <kbd class="calibre12">WidgetAlloc</kbd> in our sample code from earlier in this chapter!) Two different instances of <kbd class="calibre12">std::pmr::polymorphic_allocator&lt;T&gt;</kbd> are not necessarily interchangeable, because their pointers might point to completely different <kbd class="calibre12">memory_resource</kbd>s; this means that an object of type <kbd class="calibre12">std::vector&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;</kbd> does <em class="calibre22">not</em> necessarily know how to deallocate memory that was originally allocated by some other <kbd class="calibre12">std::vector&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;</kbd>. That, in turn, means that <kbd class="calibre12">std::pmr::polymorphic_allocator&lt;T&gt;</kbd> is a "sticky" allocator type; and <em class="calibre22">that</em> means that operations such as <kbd class="calibre12">std::vector&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;::operator=</kbd> can end up doing lots of copying.</p>
<p class="calibre2">By the way, it's quite tedious to write out the name of the type <kbd class="calibre12">std::vector&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;</kbd> over and over. Fortunately, the standard library implementors came to the same realization, and so the standard library provides type aliases in the <kbd class="calibre12">std::pmr</kbd> namespace:</p>
<pre class="calibre23">    namespace std::pmr {<br class="title-page-name"/><br class="title-page-name"/>      template&lt;class T&gt;<br class="title-page-name"/>      using vector = std::vector&lt;T,<br class="title-page-name"/>        polymorphic_allocator&lt;T&gt;&gt;;<br class="title-page-name"/><br class="title-page-name"/>      template&lt;class K, class V, class Cmp = std::less&lt;K&gt;&gt;<br class="title-page-name"/>      using map = std::map&lt;K, V, Cmp,<br class="title-page-name"/>        polymorphic_allocator&lt;typename std::map&lt;K, V&gt;::value_type&gt;&gt;;<br class="title-page-name"/><br class="title-page-name"/>      // ...<br class="title-page-name"/><br class="title-page-name"/>    } // namespace std::pmr</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Setting the default memory resource</h1>
                
            
            
                
<p class="calibre2">The biggest difference between the standard <kbd class="calibre12">polymorphic_allocator</kbd> and our example <kbd class="calibre12">WidgetAlloc</kbd> is that <kbd class="calibre12">polymorphic_allocator</kbd> is default-constructible. Default-constructibility is arguably an attractive feature of an allocator; it means that we can write the second of these two lines instead of the first:</p>
<pre class="calibre23">    std::pmr::vector&lt;int&gt; v2({1, 2, 3}, std::pmr::new_delete_resource());<br class="title-page-name"/>        // Specifying a specific memory resource<br class="title-page-name"/><br class="title-page-name"/>    std::pmr::vector&lt;int&gt; v1 = {1, 2, 3};<br class="title-page-name"/>        // Using the default memory resource</pre>
<p class="calibre2">On the other hand, when you look at that second line, you might wonder, "Where is the underlying array actually being allocated?" After all, the main point of specifying an allocator is that we want to know where our bytes are coming from! That's why the <em class="calibre22">normal</em> way to construct a standard <kbd class="calibre12">polymorphic_allocator</kbd> is to pass in a pointer to a <kbd class="calibre12">memory_resource</kbd>--in fact, this idiom is expected to be <em class="calibre22">so</em> common that the conversion from <kbd class="calibre12">std::pmr::memory_resource*</kbd> to <kbd class="calibre12">std::pmr::polymorphic_allocator</kbd> is an implicit conversion. But <kbd class="calibre12">polymorphic_allocator</kbd> does have a default, zero-argument constructor as well. When you default-construct a <kbd class="calibre12">polymorphic_allocator</kbd>, you get a handle to the "default memory resource," which by default is <kbd class="calibre12">new_delete_resource()</kbd>. However, you can change this! The default memory resource pointer is stored in a global atomic (thread-safe) variable which can be manipulated with the library functions <kbd class="calibre12">std::pmr::get_default_resource()</kbd> (which returns the pointer) and <kbd class="calibre12">std::pmr::set_default_resource()</kbd> (which assigns a new value to the pointer and returns the previous value).</p>
<p class="calibre2">If you want to avoid heap allocation via <kbd class="calibre12">new</kbd> and <kbd class="calibre12">delete</kbd> altogether, it might make sense to call <kbd class="calibre12">std::pmr::set_default_resource(std::pmr::null_memory_resource())</kbd> at the start of your program. Of course you can't stop any other part of your program from going rogue and calling <kbd class="calibre12">set_default_resource</kbd> itself; and because the same global variable is shared by every thread in your program, you might run into some very strange behavior if you <em class="calibre22">try</em> to modify the default resource during the program's execution. There is no way to say "set the default resource only for my current thread," for example. Furthermore, calling <kbd class="calibre12">get_default_resource()</kbd> (such as from the default constructor of <kbd class="calibre12">polymorphic_allocator</kbd>) performs an atomic access, which will tend to be marginally slower than if the atomic access could have been avoided. Therefore, your best course of action is to avoid the default constructor of <kbd class="calibre12">polymorphic_allocator</kbd>; always be explicit as to which memory resource you're trying to use. For absolute foolproofness, you might consider simply using the above <kbd class="calibre12">WidgetAlloc</kbd> instead of <kbd class="calibre12">polymorphic_allocator</kbd>; having <em class="calibre22">no</em> default constructor, <kbd class="calibre12">WidgetAlloc</kbd> flatly cannot be misused.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Making a container allocator-aware</h1>
                
            
            
                
<p class="calibre2">Having covered memory resources (heaps) and allocators (handles to heaps), let's turn now to the third leg of the tripod: container classes. Inside each allocator-aware container, at least four things have to happen:</p>
<ul class="calibre14">
<li class="calibre15">The container instance must store an allocator instance as member data. (Therefore the container must take the type of the allocator as a template parameter; otherwise it can't know how much space to reserve for that member variable.)</li>
<li class="calibre15">The container must provide constructors taking an allocator argument.</li>
<li class="calibre15">The container must actually use its allocator to allocate and deallocate memory; every use of <kbd class="calibre12">new</kbd> or <kbd class="calibre12">delete</kbd> must be banished.</li>
<li class="calibre15">The container's move constructor, move assignment operator, and <kbd class="calibre12">swap</kbd> function must all propagate the allocator according to its <kbd class="calibre12">allocator_traits</kbd>.</li>
</ul>
<p class="calibre2">Here is a very simple allocator-aware container--a container of just one single object, allocated on the heap. This is something like an allocator-aware version of <kbd class="calibre12">std::unique_ptr&lt;T&gt;</kbd> from <a href="part0093.html#2OM4A0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 6</a>, <em class="calibre22">Smart Pointers</em>:</p>
<pre class="calibre23">    template&lt;class T, class A = std::allocator&lt;T&gt;&gt;<br class="title-page-name"/>    class uniqueish {<br class="title-page-name"/>      using Traits = std::allocator_traits&lt;A&gt;;<br class="title-page-name"/>      using FancyPtr = typename Traits::pointer;<br class="title-page-name"/><br class="title-page-name"/>      A m_allocator;<br class="title-page-name"/>      FancyPtr m_ptr = nullptr;<br class="title-page-name"/><br class="title-page-name"/>    public:<br class="title-page-name"/>      using allocator_type = A;<br class="title-page-name"/><br class="title-page-name"/>      uniqueish(A a = {}) : m_allocator(a) {<br class="title-page-name"/>        this-&gt;emplace();<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>      ~uniqueish() {<br class="title-page-name"/>        clear();<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>      T&amp; value() { return *m_ptr; }<br class="title-page-name"/>      const T&amp; value() const { return *m_ptr; }<br class="title-page-name"/><br class="title-page-name"/>      template&lt;class... Args&gt;<br class="title-page-name"/>      void emplace(Args&amp;&amp;... args) {<br class="title-page-name"/>        clear();<br class="title-page-name"/>        m_ptr = Traits::allocate(m_allocator, 1);<br class="title-page-name"/>        try {<br class="title-page-name"/>          T *raw_ptr = static_cast&lt;T *&gt;(m_ptr);<br class="title-page-name"/>          Traits::construct(m_allocator, raw_ptr,<br class="title-page-name"/>              std::forward&lt;Args&gt;(args)...<br class="title-page-name"/>          );<br class="title-page-name"/>        } catch (...) {<br class="title-page-name"/>          Traits::deallocate(m_allocator, m_ptr, 1);<br class="title-page-name"/>          throw;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>      void clear() noexcept {<br class="title-page-name"/>        if (m_ptr) {<br class="title-page-name"/>          T *raw_ptr = static_cast&lt;T *&gt;(m_ptr);<br class="title-page-name"/>          Traits::destroy(m_allocator, raw_ptr);<br class="title-page-name"/>          Traits::deallocate(m_allocator, m_ptr, 1);<br class="title-page-name"/>          m_ptr = nullptr;<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">Notice that where <kbd class="calibre12">unique_ptr</kbd> uses <kbd class="calibre12">T*</kbd>, our present code uses <kbd class="calibre12">allocator_traits&lt;A&gt;::pointer</kbd>; and where <kbd class="calibre12">make_unique</kbd> uses <kbd class="calibre12">new</kbd> and <kbd class="calibre12">delete</kbd>, our present code uses the one-two punch of <kbd class="calibre12">allocator_traits&lt;A&gt;::allocate</kbd>/<kbd class="calibre12">construct</kbd> and <kbd class="calibre12">allocator_traits&lt;A&gt;::destroy</kbd>/<kbd class="calibre12">deallocate</kbd>. We've already discussed the purpose of <kbd class="calibre12">allocate</kbd> and <kbd class="calibre12">deallocate</kbd>--they deal with getting memory from the appropriate memory resource. But those chunks of memory are just raw bytes; to turn a chunk of memory into a usable object we have to construct an instance of <kbd class="calibre12">T</kbd> at that address. We could use "placement <kbd class="calibre12">new</kbd>" syntax for this purpose; but we'll see in the next section why it's important to use <kbd class="calibre12">construct</kbd> and <kbd class="calibre12">destroy</kbd> instead.</p>
<p class="calibre2">Finally, before we proceed, notice that the destructor of <kbd class="calibre12">uniqueish</kbd> checks to see whether an allocation exists before trying to deallocate it. This is important because it gives us a value of <kbd class="calibre12">uniqueish</kbd> representing the "empty object"--a value that can be constructed without allocating any memory, and that is a suitably "moved-from" representation for our type.</p>
<p class="calibre2">Now let's implement the move operations for our type. We'd like to ensure that after you move out of a <kbd class="calibre12">uniqueish&lt;T&gt;</kbd> object, the moved-from object is "empty." Furthermore, if the left-hand object and the right-hand object share the same allocator, or if the allocator type is "not sticky," then we'd like to avoid calling the move constructor of <kbd class="calibre12">T</kbd> at all--we'd like to transfer ownership of the allocated pointer from the right-hand-side object to the left-hand object:</p>
<pre class="calibre23">    uniqueish(uniqueish&amp;&amp; rhs) : m_allocator(rhs.m_allocator) <br class="title-page-name"/>    {<br class="title-page-name"/>      m_ptr = std::exchange(rhs.m_ptr, nullptr);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    uniqueish&amp; operator=(uniqueish&amp;&amp; rhs)<br class="title-page-name"/>    {<br class="title-page-name"/>      constexpr bool pocma =<br class="title-page-name"/>        Traits::propagate_on_container_move_assignment::value;<br class="title-page-name"/>      if constexpr (pocma) {<br class="title-page-name"/>        // We can adopt the new allocator, since<br class="title-page-name"/>        // our allocator type is not "sticky".<br class="title-page-name"/>        this-&gt;clear(); // using the old allocator<br class="title-page-name"/>        this-&gt;m_allocator = rhs.m_allocator;<br class="title-page-name"/>        this-&gt;m_ptr = std::exchange(rhs.m_ptr, nullptr);<br class="title-page-name"/>      } else if (m_allocator() == rhs.m_allocator()) {<br class="title-page-name"/>        // Our allocator is "stuck" to this container;<br class="title-page-name"/>        // but since it's equivalent to rhs's allocator,<br class="title-page-name"/>        // we can still adopt rhs's memory.<br class="title-page-name"/>        this-&gt;clear();<br class="title-page-name"/>        this-&gt;m_ptr = std::exchange(rhs.m_ptr, nullptr);<br class="title-page-name"/>      } else {<br class="title-page-name"/>        // We must not propagate this new allocator<br class="title-page-name"/>        // and thus cannot adopt its memory.<br class="title-page-name"/>        if (rhs.m_ptr) {<br class="title-page-name"/>          this-&gt;emplace(std::move(rhs.value()));<br class="title-page-name"/>          rhs.clear();<br class="title-page-name"/>        } else {<br class="title-page-name"/>          this-&gt;clear();<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>      return *this;<br class="title-page-name"/>    }</pre>
<p class="calibre2">The move <em class="calibre22">constructor</em> is just about as simple as it ever was. The only minor difference is that we have to remember to construct our <kbd class="calibre12">m_allocator</kbd> as a copy of the right-hand object's allocator.</p>
<p>We could use <kbd class="calibre25">std::move</kbd> to move the allocator instead of copying it, but I didn't think it was worth it for this example. Remember that an allocator is just a thin "handle" pointing to the actual memory resource, and that a lot of allocator types, such as <kbd class="calibre25">std::allocator&lt;T&gt;</kbd>, are actually empty. Copying an allocator type should always be relatively cheap. Still, using <kbd class="calibre25">std::move</kbd> here wouldn't have hurt.</p>
<p class="calibre2">The move <em class="calibre22">assignment operator</em>, on the other hand, is very complicated! The first thing we need to do is check whether our allocator type is "sticky" or not. Non-stickiness is denoted by having a true value for <kbd class="calibre12">propagate_on_container_move_assignment::value</kbd>, which we abbreviate to "<kbd class="calibre12">pocma</kbd>." (Actually, the standard says that <kbd class="calibre12">propagate_on_container_move_assignment</kbd> ought to be <em class="calibre22">exactly</em> the type <kbd class="calibre12">std::true_type</kbd>; and GNU's libstdc++ will hold you firmly to that requirement. So watch out when defining your own allocator types.) If the allocator type is non-sticky, then our most efficient course of action for move-assignment is to destroy our current value (if any)--making sure to use our old <kbd class="calibre12">m_allocator</kbd>--and then adopt the right-hand object's pointer along with its allocator. Because we adopt the allocator along with the pointer, we can be sure that we'll know how to deallocate the pointer down the road.</p>
<p class="calibre2">On the other hand, if our allocator type <em class="calibre22">is</em> "sticky," then we cannot adopt the allocator of the right-hand object. If our current ("stuck") allocator instance happens to be equal to the right-hand object's allocator instance, then we can adopt the right-hand object's pointer anyway; we already know how to deallocate pointers allocated by this particular allocator instance.</p>
<p class="calibre2">Finally, if we cannot adopt the right-hand object's allocator instance, and our current allocator instance isn't equal to the right-hand object's, then we cannot adopt the right-hand object's pointer--because at some point down the road we're going to have to free that pointer, and the only way to free that pointer is to use the right-hand object's allocator instance, and we're not allowed to adopt the right-hand object's allocator instance because our own instance is "stuck." In this case, we actually have to allocate a completely new pointer using our own allocator instance, and then copy over the data from <kbd class="calibre12">rhs.value()</kbd> to our own value by invoking the move constructor of <kbd class="calibre12">T</kbd>. This final case is the only one where we actually call the move constructor of <kbd class="calibre12">T</kbd>!</p>
<p class="calibre2">Copy assignment follows similar logic for the propagation of the right-hand allocator instance, except that it looks at the trait <kbd class="calibre12">propagate_on_container_copy_assignment</kbd>, or "<kbd class="calibre12">pocca</kbd>."</p>
<p class="calibre2">Swap is particularly interesting because its final case (when the allocator type is "sticky" and the allocator instances are unequal) requires extra allocations:</p>
<pre class="calibre23">    void swap(uniqueish&amp; rhs) noexcept {<br class="title-page-name"/>      constexpr bool pocs =<br class="title-page-name"/>        Traits::propagate_on_container_swap::value;<br class="title-page-name"/>      using std::swap;<br class="title-page-name"/>      if constexpr (pocs) {<br class="title-page-name"/>        // We can swap allocators, since<br class="title-page-name"/>        // our allocator type is not "sticky".<br class="title-page-name"/>        swap(this-&gt;m_allocator, rhs.m_allocator);<br class="title-page-name"/>        swap(this-&gt;m_ptr, rhs.m_ptr);<br class="title-page-name"/>      } else if (m_allocator == rhs.m_allocator) {<br class="title-page-name"/>        // Our allocator is "stuck" to this container;<br class="title-page-name"/>        // but since it's equivalent to rhs's allocator,<br class="title-page-name"/>        // we can still adopt rhs's memory and vice versa.<br class="title-page-name"/>        swap(this-&gt;m_ptr, rhs.m_ptr);<br class="title-page-name"/>      } else {<br class="title-page-name"/>        // Neither side can adopt the other's memory, and<br class="title-page-name"/>        // so one side or the other must allocate.<br class="title-page-name"/>        auto temp = std::move(*this);<br class="title-page-name"/>        *this = std::move(rhs); // might throw<br class="title-page-name"/>        rhs = std::move(temp); // might throw<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">On each of the two lines marked "might throw," we're calling the move assignment operator, which in this case might call <kbd class="calibre12">emplace</kbd>, which will ask the allocator for memory. If the underlying memory resource has been exhausted, then <kbd class="calibre12">Traits::allocate(m_allocator, 1)</kbd> might well throw an exception--and then we'd be in trouble, for two reasons. First, we've already started moving state around and deallocating old memory, and we might find it impossible to "unwind" back to a reasonable state. Second, and more importantly, <kbd class="calibre12">swap</kbd> is one of those functions that is so primitive and so fundamental that the standard library makes no provision for its failing--for example, the <kbd class="calibre12">std::swap</kbd> algorithm (<a href="part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 3</a>, <em class="calibre22">The Iterator-Pair Algorithms</em>) is declared as <kbd class="calibre12">noexcept</kbd>, which means it <em class="calibre22">must</em> succeed; it is not allowed to throw an exception.</p>
<p class="calibre2">Thus, if allocation fails during our <kbd class="calibre12">noexcept</kbd> swap function, we'll see a <kbd class="calibre12">bad_alloc</kbd> exception percolate up through the call stack until it reaches our <kbd class="calibre12">noexcept</kbd> swap function declaration; at which point the C++ runtime will stop unwinding and call <kbd class="calibre12">std::terminate</kbd>, which (unless the programmer has altered its behavior via <kbd class="calibre12">std::set_terminate</kbd>) will cause our program to crash and burn.</p>
<p class="calibre2">The C++17 Standard goes several steps further than this in its specification of what <em class="calibre22">ought</em> to happen during the swapping of standard container types. First, instead of saying that allocation failure during <kbd class="calibre12">swap</kbd> will result in a call to <kbd class="calibre12">std::terminate</kbd>, the Standard simply says that allocation failure during <kbd class="calibre12">swap</kbd> will result in <em class="calibre22">undefined behavior</em>. Second, the Standard does not limit that undefined behavior to allocation failure! According to the C++17 Standard, merely <em class="calibre22">calling</em> <kbd class="calibre12">swap</kbd> on any standard library container instances whose allocators do not compare equally will result in undefined behavior, whether an allocation failure would have been encountered or not!</p>
<p class="calibre2">In fact, libc++ exploits this optimization opportunity to generate code for all standard container <kbd class="calibre12">swap</kbd> functions that looks roughly like this:</p>
<pre class="calibre23">    void swap(uniqueish&amp; rhs) noexcept {<br class="title-page-name"/>      constexpr bool pocs =<br class="title-page-name"/>        Traits::propagate_on_container_swap::value;<br class="title-page-name"/>      using std::swap;<br class="title-page-name"/>      if constexpr (pocs) {<br class="title-page-name"/>        swap(this-&gt;m_allocator, rhs.m_allocator);<br class="title-page-name"/>      }<br class="title-page-name"/>      // Don't even check that we know how to free<br class="title-page-name"/>      // the adopted pointer; just assume that we can.<br class="title-page-name"/>      swap(this-&gt;m_ptr, rhs.m_ptr);<br class="title-page-name"/>    }</pre>
<p class="calibre2">Notice that if you use this code (as libc++ does) to <kbd class="calibre12">swap</kbd> two containers with unequal allocators, you'll wind up with a mismatch between pointers and their allocators, and then your program will probably crash--or worse--the next time you try to deallocate one of those pointers using the mismatched allocator. It is supremely important that you remember this pitfall when dealing with the C++17 "convenience" types such as <kbd class="calibre12">std::pmr::vector</kbd>!</p>
<pre class="calibre23">    char buffer[100];<br class="title-page-name"/>    auto mr = std::pmr::monotonic_buffer_resource(buffer, 100);<br class="title-page-name"/><br class="title-page-name"/>    std::pmr::vector&lt;int&gt; a {1,2,3};<br class="title-page-name"/>    std::pmr::vector&lt;int&gt; b({4,5,6}, &amp;mr);<br class="title-page-name"/><br class="title-page-name"/>    std::swap(a, b);<br class="title-page-name"/>      // UNDEFINED BEHAVIOR<br class="title-page-name"/><br class="title-page-name"/>    a.reserve(a.capacity() + 1);<br class="title-page-name"/>      // this line will undoubtedly crash, as<br class="title-page-name"/>      // it tries to delete[] a stack pointer</pre>
<p class="calibre2">If your code design allows containers backed by different memory resources to be swapped with each other, then you must avoid <kbd class="calibre12">std::swap</kbd> and instead use this safe idiom:</p>
<pre class="calibre23">    auto temp = std::move(a); // OK<br class="title-page-name"/>    a = std::move(b); // OK<br class="title-page-name"/>    b = std::move(temp); // OK</pre>
<p class="calibre2">When I say "avoid <kbd class="calibre12">std::swap</kbd>," I mean "avoid any of the permutative algorithms in the STL," including such algorithms as <kbd class="calibre12">std::reverse</kbd> and <kbd class="calibre12">std::sort</kbd>. This would be quite an undertaking and I do not advise attempting it!</p>
<p class="calibre2">If your code design allows containers backed by different memory resources to be swapped with each other, then really, you <em class="calibre22">might</em> want to reconsider your design. If you can fix it so that you only ever swap containers that share the same memory resource, or if you can avoid stateful and/or sticky allocators entirely, then you will never need to think about this particular pitfall.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Propagating downwards with scoped_allocator_adaptor</h1>
                
            
            
                
<p class="calibre2">In the preceding section, we introduced <kbd class="calibre12">std::allocator_traits&lt;A&gt;::construct(a, ptr, args...)</kbd> and described it as a preferable alternative to the placement-<kbd class="calibre12">new</kbd> syntax <kbd class="calibre12">::new ((void*)ptr) T(args...)</kbd>. Now we'll see why the author of a particular allocator might want to give it different semantics.</p>
<p class="calibre2">One perhaps obvious way to change the semantics of <kbd class="calibre12">construct</kbd> for our own allocator type would be to make it trivially default-initialize primitive types instead of zero-initializing them. That code would look like this:</p>
<pre class="calibre23">    template&lt;class T&gt;<br class="title-page-name"/>    struct my_allocator : std::allocator&lt;T&gt; <br class="title-page-name"/>    {<br class="title-page-name"/>      my_allocator() = default;<br class="title-page-name"/><br class="title-page-name"/>      template&lt;class U&gt;<br class="title-page-name"/>      my_allocator(const my_allocator&lt;U&gt;&amp;) {}<br class="title-page-name"/><br class="title-page-name"/>      template&lt;class... Args&gt;<br class="title-page-name"/>      void construct(T *p, Args&amp;&amp;... args) {<br class="title-page-name"/>        if (sizeof...(Args) == 0) {<br class="title-page-name"/>          ::new ((void*)p) T;<br class="title-page-name"/>        } else {<br class="title-page-name"/>          ::new ((void*)p) T(std::forward&lt;Args&gt;(args)...);<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">Now you can use <kbd class="calibre12">std::vector&lt;int, my_allocator&lt;int&gt;&gt;</kbd> as a "vector-like" type satisfying all the usual invariants of <kbd class="calibre12">std::vector&lt;int&gt;</kbd>, except that when you implicitly create new elements via <kbd class="calibre12">v.resize(n)</kbd> or <kbd class="calibre12">v.emplace_back()</kbd>, the new elements are created uninitialized, just like stack variables, instead of being zero-initialized.</p>
<p class="calibre2">In a sense, what we've designed here is an "adaptor" that fits over the top of <kbd class="calibre12">std::allocator&lt;T&gt;</kbd> and modifies its behavior in an interesting way. It would be even better if we could modify or "adapt" any arbitrary allocator in the same way; to do that, we'd just change our <kbd class="calibre12">template&lt;class T&gt;</kbd> to <kbd class="calibre12">template&lt;class A&gt;</kbd> and inherit from <kbd class="calibre12">A</kbd> where the old code inherited from <kbd class="calibre12">std::allocator&lt;T&gt;</kbd>. Of course our new adaptor's template parameter list no longer starts with <kbd class="calibre12">T</kbd>, so we'd have to implement <kbd class="calibre12">rebind</kbd> ourselves; this path quickly gets into deep metaprogramming, so I won't digress to show it.</p>
<p class="calibre2">However, there's another useful way we could fiddle with the <kbd class="calibre12">construct</kbd> method for our own allocator type. Consider the following code sample, which creates a vector of vectors of <kbd class="calibre12">int</kbd>:</p>
<pre class="calibre23">    std::vector&lt;std::vector&lt;int&gt;&gt; vv;<br class="title-page-name"/>    vv.emplace_back();<br class="title-page-name"/>    vv.emplace_back();<br class="title-page-name"/>    vv[0].push_back(1);<br class="title-page-name"/>    vv[1].push_back(2);<br class="title-page-name"/>    vv[1].push_back(3);</pre>
<p class="calibre2">Suppose we wanted to "stick" this container to a memory resource of our own devising, such as our favorite <kbd class="calibre12">WidgetAlloc</kbd>. We'd have to write something repetitive like this:</p>
<pre class="calibre23">    char buffer[10000];<br class="title-page-name"/>    std::pmr::monotonic_buffer_resource mr {buffer, sizeof buffer};<br class="title-page-name"/><br class="title-page-name"/>    using InnerAlloc = WidgetAlloc&lt;int&gt;;<br class="title-page-name"/>    using InnerVector = std::vector&lt;int, InnerAlloc&gt;;<br class="title-page-name"/>    using OuterAlloc = WidgetAlloc&lt;InnerVector&gt;;<br class="title-page-name"/><br class="title-page-name"/>    std::vector&lt;InnerVector, OuterAlloc&gt; vv(&amp;mr);<br class="title-page-name"/>    vv.emplace_back(&amp;mr);<br class="title-page-name"/>    vv.emplace_back(&amp;mr);<br class="title-page-name"/>    vv[0].push_back(1);<br class="title-page-name"/>    vv[1].push_back(2);<br class="title-page-name"/>    vv[1].push_back(3);</pre>
<p class="calibre2">Notice the repetition of the allocator object's initializer <kbd class="calibre12">&amp;mr</kbd> at both levels. The need to repeat <kbd class="calibre12">&amp;mr</kbd> makes it difficult to use our vector <kbd class="calibre12">vv</kbd> in generic contexts; for example, we can't easily pass it to a function template to populate it with data, because every time the callee would want to <kbd class="calibre12">emplace_back</kbd> a new vector-of-<kbd class="calibre12">int</kbd>, it would need to know the address <kbd class="calibre12">&amp;mr</kbd> that is only known to the caller. What we'd like to do is wrap up and reify the notion that "every time you construct an element of the vector-of-vectors, you need to tack <kbd class="calibre12">&amp;mr</kbd> onto the end of the argument list." And the standard library has us covered!</p>
<p class="calibre2">Since C++11, the standard library has provided (in the header named <kbd class="calibre12">&lt;scoped_allocator&gt;</kbd>) a class template called <kbd class="calibre12">scoped_allocator_adaptor&lt;A&gt;</kbd>. Just like our default-initializing "adaptor," <kbd class="calibre12">scoped_allocator_adaptor&lt;A&gt;</kbd> inherits from <kbd class="calibre12">A</kbd>, thus picking up all of <kbd class="calibre12">A</kbd>'s behaviors; and then it overrides the <kbd class="calibre12">construct</kbd> method to do something different. Namely, it attempts to figure out whether the <kbd class="calibre12">T</kbd> object it's currently constructing "uses an allocator," and if so, it will pass itself down as an extra argument to the constructor of <kbd class="calibre12">T</kbd>.</p>
<p class="calibre2">To decide whether type <kbd class="calibre12">T</kbd> "uses an allocator," <kbd class="calibre12">scoped_allocator_adaptor&lt;A&gt;::construct</kbd> defers to the type trait <kbd class="calibre12">std::uses_allocator_v&lt;T,A&gt;</kbd>, which (unless you've specialized it, which you probably shouldn't) will be true if and only if <kbd class="calibre12">A</kbd> is implicitly convertible to <kbd class="calibre12">T::allocator_type</kbd>. If <kbd class="calibre12">T</kbd> doesn't have an <kbd class="calibre12">allocator_type</kbd>, then the library will assume that <kbd class="calibre12">T</kbd> doesn't care about allocators, except in the special cases of <kbd class="calibre12">pair</kbd> and <kbd class="calibre12">tuple</kbd> (which all have special overloads of their constructors intended specifically to propagate allocators downward to their members) and in the special case of <kbd class="calibre12">promise</kbd> (which can allocate its shared state with an allocator even though it provides no way of referring to that allocator object afterward; we say that <kbd class="calibre12">promise</kbd>'s allocator support is "type-erased" even more thoroughly than the examples of type erasure we saw in <a href="part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 5</a>, <em class="calibre22">Vocabulary Types</em>).</p>
<p class="calibre2">For historical reasons, the constructors of allocator-aware types can follow either of two different patterns, and <kbd class="calibre12">scoped_allocator_adaptor</kbd> is smart enough to know them both. Older and simpler types (that is, everything except <kbd class="calibre12">tuple</kbd> and <kbd class="calibre12">promise</kbd>) tend to have constructors of the form <kbd class="calibre12">T(args..., A)</kbd> where the allocator <kbd class="calibre12">A</kbd> comes at the end. For <kbd class="calibre12">tuple</kbd> and <kbd class="calibre12">promise</kbd>, the standard library has introduced a new pattern: <kbd class="calibre12">T(std::allocator_arg, A, args...)</kbd> where the allocator <kbd class="calibre12">A</kbd> comes at the beginning but is preceded by the special tag value <kbd class="calibre12">std::allocator_arg</kbd>, whose sole purpose is to indicate that the next argument in the argument list represents an allocator, similarly to how the sole purpose of the tag <kbd class="calibre12">std::nullopt</kbd> is to indicate that an <kbd class="calibre12">optional</kbd> has no value (see <a href="part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 5</a>, <em class="calibre22">Vocabulary Types</em>). Just as the standard forbids creating the type <kbd class="calibre12">std::optional&lt;std::nullopt_t&gt;</kbd>, you will also find yourself in a world of trouble if you attempt to create <kbd class="calibre12">std::tuple&lt;std::allocator_arg_t&gt;</kbd>.</p>
<p class="calibre2">Using <kbd class="calibre12">scoped_allocator_adaptor</kbd>, we can rewrite our cumbersome example from earlier in a slightly less cumbersome way:</p>
<pre class="calibre23">    char buffer[10000];<br class="title-page-name"/>    std::pmr::monotonic_buffer_resource mr {buffer, sizeof buffer};<br class="title-page-name"/><br class="title-page-name"/>    using InnerAlloc = WidgetAlloc&lt;int&gt;;<br class="title-page-name"/>    using InnerVector = std::vector&lt;int, InnerAlloc&gt;;<br class="title-page-name"/>    using OuterAlloc = std::scoped_allocator_adaptor&lt;WidgetAlloc&lt;InnerVector&gt;&gt;;<br class="title-page-name"/><br class="title-page-name"/>    std::vector&lt;InnerVector, OuterAlloc&gt; vv(&amp;mr);<br class="title-page-name"/>    vv.emplace_back();<br class="title-page-name"/>    vv.emplace_back();<br class="title-page-name"/>    vv[0].push_back(1);<br class="title-page-name"/>    vv[1].push_back(2);<br class="title-page-name"/>    vv[1].push_back(3);</pre>
<p class="calibre2">Notice that the allocator type has gotten <em class="calibre22">more</em> cumbersome, but the important thing is that the <kbd class="calibre12">&amp;mr</kbd> argument to <kbd class="calibre12">emplace_back</kbd> has disappeared; we can now use <kbd class="calibre12">vv</kbd> in contexts that expect to be able to push back elements in a natural way, without having to remember to add <kbd class="calibre12">&amp;mr</kbd> all over the place. In our case, because we're using our <kbd class="calibre12">WidgetAlloc</kbd>, which is not default-constructible, the symptom of a forgotten <kbd class="calibre12">&amp;mr</kbd> is a spew of compile-time errors. But you may recall from preceding sections in this chapter that <kbd class="calibre12">std::pmr::polymorphic_allocator&lt;T&gt;</kbd> will happily allow you to default-construct it, with potentially disastrous results; so if you are planning to use <kbd class="calibre12">polymorphic_allocator</kbd>, it might also be wise to look into <kbd class="calibre12">scoped_allocator_adaptor</kbd> just in order to limit the number of places in which you might forget to specify your allocation strategy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Propagating different allocators</h1>
                
            
            
                
<p class="calibre2">In my introduction of <kbd class="calibre12">scoped_allocator_adaptor&lt;A&gt;</kbd>, I left out one more complication. The template parameter list isn't limited to just one allocator type argument! You can actually create a scoped-allocator type with multiple allocator type arguments, like this:</p>
<pre class="calibre23">    using InnerAlloc = WidgetAlloc&lt;int&gt;;<br class="title-page-name"/>    using InnerVector = std::vector&lt;int, InnerAlloc&gt;;<br class="title-page-name"/><br class="title-page-name"/>    using MiddleAlloc = std::scoped_allocator_adaptor&lt;<br class="title-page-name"/>      WidgetAlloc&lt;InnerVector&gt;,<br class="title-page-name"/>      WidgetAlloc&lt;int&gt;<br class="title-page-name"/>    &gt;;<br class="title-page-name"/>    using MiddleVector = std::vector&lt;InnerVector, MiddleAlloc&gt;;<br class="title-page-name"/><br class="title-page-name"/>    using OuterAlloc = std::scoped_allocator_adaptor&lt;<br class="title-page-name"/>      WidgetAlloc&lt;MiddleVector&gt;,<br class="title-page-name"/>      WidgetAlloc&lt;InnerVector&gt;,<br class="title-page-name"/>      WidgetAlloc&lt;int&gt;<br class="title-page-name"/>    &gt;;<br class="title-page-name"/>    using OuterVector = std::vector&lt;MiddleVector, OuterAlloc&gt;;</pre>
<p class="calibre2">Having set up these typedefs, we proceed to set up three distinct memory resources and construct an instance of <kbd class="calibre12">scoped_allocator_adaptor</kbd> capable of remembering all three of the memory resources (because it contains three distinct instances of <kbd class="calibre12">WidgetAlloc</kbd>, one per "level"):</p>
<pre class="calibre23">    char bi[1000];<br class="title-page-name"/>    std::pmr::monotonic_buffer_resource mri {bi, sizeof bi};<br class="title-page-name"/>    char bm[1000];<br class="title-page-name"/>    std::pmr::monotonic_buffer_resource mrm {bm, sizeof bm};<br class="title-page-name"/>    char bo[1000];<br class="title-page-name"/>    std::pmr::monotonic_buffer_resource mro {bo, sizeof bo};<br class="title-page-name"/><br class="title-page-name"/>    OuterAlloc saa(&amp;mro, &amp;mrm, &amp;mri);</pre>
<p class="calibre2">Finally, we can construct an instance of <kbd class="calibre12">OuterVector</kbd>, passing in our <kbd class="calibre12">scoped_allocator_adaptor</kbd> argument; and that's all! The overridden <kbd class="calibre12">construct</kbd> method hidden deep within our carefully crafted allocator type takes care of passing the argument <kbd class="calibre12">&amp;bm</kbd> or <kbd class="calibre12">&amp;bi</kbd> to any constructor that needs one of them:</p>
<pre class="calibre23">    OuterVector vvv(saa);<br class="title-page-name"/><br class="title-page-name"/>    vvv.emplace_back();<br class="title-page-name"/>      // This allocation comes from buffer "bo".<br class="title-page-name"/><br class="title-page-name"/>    vvv[0].emplace_back();<br class="title-page-name"/>      // This allocation comes from buffer "bm".<br class="title-page-name"/><br class="title-page-name"/>    vvv[0][0].emplace_back(42);<br class="title-page-name"/>      // This allocation comes from buffer "bi".</pre>
<p class="calibre2">As you can see, a deeply nested <kbd class="calibre12">scoped_allocator_adaptor</kbd> is not for the faint of heart; and they're really only usable at all if you make a lot of "helper" typedefs along the way, as we did in this example.</p>
<p class="calibre2">One last note about <kbd class="calibre12">std::scoped_allocator_adaptor&lt;A...&gt;</kbd>: if the nesting of containers goes deeper than the number of allocator types in the template parameter list, then <kbd class="calibre12">scoped_allocator_adaptor</kbd> will act as if the last allocator type in its parameter list repeats forever. For example:</p>
<pre class="calibre23">    using InnerAlloc = WidgetAlloc&lt;int&gt;;<br class="title-page-name"/>    using InnerVector = std::vector&lt;int, InnerAlloc&gt;;<br class="title-page-name"/><br class="title-page-name"/>    using MiddleAlloc = std::scoped_allocator_adaptor&lt;<br class="title-page-name"/>      WidgetAlloc&lt;InnerVector&gt;<br class="title-page-name"/>    &gt;;<br class="title-page-name"/>    using MiddleVector = std::vector&lt;InnerVector, MiddleAlloc&gt;;<br class="title-page-name"/><br class="title-page-name"/>    using TooShortAlloc = std::scoped_allocator_adaptor&lt;<br class="title-page-name"/>      WidgetAlloc&lt;MiddleVector&gt;,<br class="title-page-name"/>      WidgetAlloc&lt;InnerVector&gt;<br class="title-page-name"/>    &gt;;<br class="title-page-name"/>    using OuterVector = std::vector&lt;MiddleVector, TooShortAlloc&gt;;<br class="title-page-name"/><br class="title-page-name"/>    TooShortAlloc tsa(&amp;mro, WidgetAlloc&lt;InnerVector&gt;(&amp;mri));<br class="title-page-name"/>    OuterVector tsv(tsa);<br class="title-page-name"/><br class="title-page-name"/>    tsv.emplace_back();<br class="title-page-name"/>      // This allocation comes from buffer "bo".<br class="title-page-name"/><br class="title-page-name"/>    tsv[0].emplace_back();<br class="title-page-name"/>      // This allocation comes from buffer "bi".<br class="title-page-name"/><br class="title-page-name"/>    tsv[0][0].emplace_back(42);<br class="title-page-name"/>      // This allocation AGAIN comes from buffer "bi"!</pre>
<p class="calibre2">We actually relied on this behavior in our very first <kbd class="calibre12">scoped_allocator_adaptor</kbd> example, the one involving <kbd class="calibre12">vv</kbd>, even though I didn't mention it at the time. Now that you know about it, you might want to go back and study that example to see where the "repeat forever" behavior is being used, and how you'd change that code if you wanted to use a different memory resource for the inner array of <kbd class="calibre12">int</kbd> than for the outer array of <kbd class="calibre12">InnerVector</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">Allocators are a fundamentally arcane topic in C++, mainly for historical reasons. Several different interfaces, with different obscure use-cases, are piled one on top of the other; all of them involve intense metaprogramming; and vendor support for many of these features, even relatively old C++11 features such as fancy pointers, is still lacking.</p>
<p class="calibre2">C++17 offers the standard library type <kbd class="calibre12">std::pmr::memory_resource</kbd> to clarify the existing distinction between <em class="calibre22">memory resources</em> (a.k.a. <em class="calibre22">heaps</em>) and <kbd class="calibre12">allocators</kbd> (a.k.a. <em class="calibre22">handles</em> to heaps). Memory resources provide <kbd class="calibre12">allocate</kbd> and <kbd class="calibre12">deallocate</kbd> methods; allocators provide those methods as well as <kbd class="calibre12">construct</kbd> and <kbd class="calibre12">destroy</kbd>.</p>
<p class="calibre2">If you implement your own allocator type <kbd class="calibre12">A</kbd>, it must be a template; its first template parameter should be the type <kbd class="calibre12">T</kbd> that it expects to <kbd class="calibre12">allocate</kbd>. Your allocator type <kbd class="calibre12">A</kbd> must also have a templated constructor to support "rebinding" from <kbd class="calibre12">A&lt;U&gt;</kbd> to <kbd class="calibre12">A&lt;T&gt;</kbd>. Just like any other kind of pointer, an allocator type must support the <kbd class="calibre12">==</kbd> and <kbd class="calibre12">!=</kbd> operators.</p>
<p class="calibre2">A heap's <kbd class="calibre12">deallocate</kbd> method is allowed to require additional metadata attached to the incoming pointer. C++ handles this via <em class="calibre22">fancy pointers</em>. C++17's <kbd class="calibre12">std::pmr::memory_resource</kbd> does not support fancy pointers, but it's easy to implement your own.</p>
<p class="calibre2">Fancy pointer types must satisfy all the requirements of random access iterators, and must be nullable, and must be convertible to plain raw pointers. If you want to use your fancy pointer type with node-based containers such as <kbd class="calibre12">std::list</kbd>, you must give it a static <kbd class="calibre12">pointer_to</kbd> member function.</p>
<p class="calibre2">C++17 distinguishes between "sticky" and "non-sticky" allocator types. Stateless allocator types such as <kbd class="calibre12">std::allocator&lt;T&gt;</kbd> are non-sticky; stateful allocator types such as <kbd class="calibre12">std::pmr::polymorphic_allocator&lt;T&gt;</kbd> are sticky by default. Making your own allocator type of a non-default stickiness requires setting all three of the member typedefs familiarly known as "POCCA," "POCMA," and "POCS." Sticky allocator types such as <kbd class="calibre12">std::pmr::polymorphic_allocator&lt;T&gt;</kbd> are useful primarily--perhaps only--in classical object-oriented situations, where a container object is pinned to a particular memory address. Value-oriented programming (with lots of moves and swaps) calls for stateless allocator types, or else for everyone in the program to use the same heap and a single sticky but <em class="calibre22">effectively stateless</em> allocator type.</p>
<p class="calibre2"><kbd class="calibre12">scoped_allocator_adaptor&lt;A...&gt;</kbd> can help simplify the usage of deeply nested containers that use custom allocators or memory resources. Just about any deeply nested container using a non-default allocator type requires a lot of helper typedefs to remain even remotely readable.</p>
<p class="calibre2">Swapping two containers with unequal sticky allocators: in theory this invokes undefined behavior, and in practice it corrupts memory and segfaults. Don't do it!</p>


            

            
        
    </body></html>