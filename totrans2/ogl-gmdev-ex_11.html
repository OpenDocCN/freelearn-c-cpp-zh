<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Heads Up</h1></div></div></div><p>In this chapter, we will put some finishing touches on Space Racer 3D by adding some features that you would see in almost any game. Many of these features are similar to the finishing touches that we put on our Robo Racer 2D game, though there are some special considerations now that we are working in 3D. The topics that we will cover include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>2D in a 3D world</strong>: So far, we learned how to render in 2D and how to render in 3D. However, there are special considerations to create 2D in a 3D world. As our user interface is typically created in 2D, we will learn how to mix the two types of rendering.</li><li class="listitem" style="list-style-type: disc"><strong>Creating a heads-up-display (HUD)</strong>: It is very typical for first-person 3D games to have a continuous status showing information that is relevant to the game. We will learn how to create a basic heads-up-display or HUD.</li><li class="listitem" style="list-style-type: disc"><strong>More game state</strong>: Just as we did in Robo Racer 2D, we will create a basic state manager to handle the various modes in our completed game.</li><li class="listitem" style="list-style-type: disc"><strong>Scoring</strong>: We need a way to keep score in our game, and we need to set up the basic win and lose conditions.</li><li class="listitem" style="list-style-type: disc"><strong>Game over</strong>: When the game is over, we'll give some credit with a 3D twist.</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec62"/>Mixing things up</h1></div></div></div><p>Now that we are rendering in 3D, it isn't immediately obvious how we will render things in 2D. This is especially true of our user interface, which must be rendered on top of the 3D-scene and does not move or rotate with the rest of the world.</p><p>The trick to <a id="id622" class="indexterm"/>creating a 2D interface in a 3D world is to first render the 3D world, then switch modes in OpenGL, and then render the 2D content. The following image represents the 3D content that we need to render:</p><div><img src="img/8199OS_11_01.jpg" alt="Mixing things up"/></div><p>The next<a id="id623" class="indexterm"/> image represents the 2D text that we want to render:</p><div><img src="img/8199OS_11_02.jpg" alt="Mixing things up"/></div><p>We want<a id="id624" class="indexterm"/> the final result to be the combination of the 3D and 2D content, as shown in the following figure:</p><div><img src="img/8199OS_11_03.jpg" alt="Mixing things up"/></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec158"/>The saving state</h2></div></div></div><p>State is a term that is used in many different ways in game programming. For example, we will create <a id="id625" class="indexterm"/>a state manager later in the chapter that will manage different states, or modes, in the game. Another way to define state is a set of conditions. For example, when we set things up to render in 3D, this is one set of conditions or state. When we set up things to render in 2D, this is another set of conditions or state.</p><p>The trick to being able to render in both 2D and 3D is to be able to set up one state, and then change to another state. OpenGL saves state in matrices. In order to change from one state to another, we need a way to save the current matrix, set up another matrix, and then return to the previous matrix once we are done.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec159"/>Push and pop</h2></div></div></div><p>OpenGL provides<a id="id626" class="indexterm"/> two <a id="id627" class="indexterm"/>methods to save the current<a id="id628" class="indexterm"/> state and then <a id="id629" class="indexterm"/>retrieve it later:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">glPushMarix()</code>: This <a id="id630" class="indexterm"/>command saves the current state by placing it on the stack.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glPopMatrix()</code>: This <a id="id631" class="indexterm"/>command retrieves the previous state by pulling it off the stack.</li></ul></div><p>A <strong>stack</strong>
<a id="id632" class="indexterm"/> is a structure that allows you to put data on the top of it (a <strong>push</strong>), and then later retrieve the item from the top of it (a <strong>pop</strong>). A stack is useful when you want to save data in<a id="id633" class="indexterm"/> order, then later retrieve it in reverse order.</p><p>Let's say that<a id="id634" class="indexterm"/> we<a id="id635" class="indexterm"/> start with an initial set of conditions <a id="id636" class="indexterm"/>called <strong>State A</strong>:</p><div><img src="img/8199OS_11_04.jpg" alt="Push and pop"/></div><p>A call to <code class="literal">glPushMatrix()</code> will put <strong>State A</strong> on the stack:</p><div><img src="img/8199OS_11_05.jpg" alt="Push and pop"/></div><p>Next, we <a id="id637" class="indexterm"/>set up<a id="id638" class="indexterm"/> the conditions for <strong>State B</strong>. If we<a id="id639" class="indexterm"/> want to save this<a id="id640" class="indexterm"/> state, we issue another <code class="literal">glPushMatrix()</code> call:</p><div><img src="img/8199OS_11_06.jpg" alt="Push and pop"/></div><p>Now we <a id="id641" class="indexterm"/>have two items on the stack, and it should also be very clear why<a id="id642" class="indexterm"/> it is called a stack! We could then define <strong>State C</strong>. This<a id="id643" class="indexterm"/> sequence of steps can continue on as needed, creating a render state <a id="id644" class="indexterm"/>and then pushing it to the stack. In general, we want to unload the stack in the reverse order that <a id="id645" class="indexterm"/>we loaded it in. This is known as a <strong>FILO</strong> stack: first in, last out.</p><p>We take things off of the stack with the <code class="literal">glPopMatrix()</code> command:</p><div><img src="img/8199OS_11_07.jpg" alt="Push and pop"/></div><p>The<a id="id646" class="indexterm"/> result<a id="id647" class="indexterm"/> replaces <strong>State C</strong>, restoring<a id="id648" class="indexterm"/> the<a id="id649" class="indexterm"/> rendering settings to <strong>State B</strong>:</p><div><img src="img/8199OS_11_08.jpg" alt="Push and pop"/></div><p>Another <a id="id650" class="indexterm"/>call <a id="id651" class="indexterm"/>to <code class="literal">glPopMatrix()</code> empties <a id="id652" class="indexterm"/>the stack and restores the rendering settings to <a id="id653" class="indexterm"/>
<strong>State A</strong>:</p><div><img src="img/8199OS_11_09.jpg" alt="Push and pop"/></div><p>The model <a id="id654" class="indexterm"/>view allows 32 matrices to be put onto the stack. Each <a id="id655" class="indexterm"/>view has its own stack, so the projection view has a separate <a id="id656" class="indexterm"/>stack from the model view. Also, if you issue <code class="literal">glPopMatrix</code> and <a id="id657" class="indexterm"/>there is no matrix on the stack, you will receive an error. In other words, don't try to pop more than you have pushed!</p><div><div><h3 class="title"><a id="tip63"/>Tip</h3><p>In order to best manage memory, you should always pop the states that you have pushed, even if you don't need to do anything with them. This frees up the memory that was being used to hold the data that was part of the state that you were saving.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec160"/>Two state rendering</h2></div></div></div><p>We are now<a id="id658" class="indexterm"/> going to set up our code to be able to render in both 3D and 2D. Open <code class="literal">SpaceRacer3D.cpp</code>. We are going to split up the rendering into two functions: <code class="literal">Render3D</code>, and <code class="literal">Render2D</code>. Then, we are going to call these from the main <code class="literal">Render</code> function. Let's start with <code class="literal">Render3D</code>. Add the following code just above the <code class="literal">Render</code> function (you can just cut it from the <code class="literal">Render</code> function):</p><div><pre class="programlisting">void Render3D()
{
 if (gameState == GS_Running)
 {
  for (unsigned int i = 0; i &lt; asteroids.size(); i++)
  {
   asteroids[i]-&gt;Render();
  }
  ship-&gt;Render();
 }
}</pre></div><p>Next, we will <a id="id659" class="indexterm"/>create two support functions to turn 2D rendering on and off. The first will be <code class="literal">Enable2D</code>. Add the following function above the <code class="literal">Render3D</code> function:</p><div><pre class="programlisting">void Enable2D()
{
  glColor3f(1.0f, 1.0f, 1.0f);
  glEnable(GL_TEXTURE_2D);
  
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
  glOrtho(0, SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, 1);
  
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
  
  glPushAttrib(GL_DEPTH_BUFFER_BIT);
  glDisable(GL_DEPTH_TEST);
}</pre></div><p>
<code class="literal">Enable2D</code> performs<a id="id660" class="indexterm"/> the tasks that are necessary to change the rendering mode to 2D:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The call to <code class="literal">glColor3f</code> sets the current drawing color to white. This takes some explanation. We will always render 3D first, then switch to 2D. If we didn't set the color to white, then all of the colors in the 2D content would be blended with the last color that was used by the 3D rendering. Setting the render color to white essentially clears the render color so that the 2D content will be rendered accurately. Setting the color to white doesn't actually mean everything will be drawn in white. It means that no additional coloring will be added to the objects that we render in 2D.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">glEnable(GL_TEXTURE_2D)</code> call is essential if you want to render 2D textures. If this were left out, then any 2D textures would not render correctly.</li><li class="listitem" style="list-style-type: disc">The next four lines save the 3D projection matrix and set up the projection matrix to render in 2D. <code class="literal">glPushMatrix</code> pushes the current projection matrix to the stack. We then initialize the projection matrix with <code class="literal">glLoadIdentity</code>. Finally, we set up an orthographic projection with the call to <code class="literal">glOrtho</code>. Take a look at RoboRacer2D, and you will notice that it uses the same <code class="literal">glOrtho</code> call to set up 2D rendering!</li><li class="listitem" style="list-style-type: disc">The next three lines save the 3D model view matrix and initialize it for our 2D drawing. <code class="literal">glPushMatrix</code> pushes the current model view matrix to the stack. We then initialize the model view matrix with the call to <code class="literal">glLoadIdentity</code>.</li><li class="listitem" style="list-style-type: disc">Finally, we need to turn off checking on the depth buffer. The depth buffer check is only required for 3D rendering, and interferes with 2D rendering. <code class="literal">glPushAttrib</code> works just like <code class="literal">glPushMatrix</code>, except that it only pushes a single OpenGL attribute to the stack. In this case, we are pushing the current <code class="literal">GL_DEPTH_BUFFER_BIT</code> to the attribute stack, thus saving the current state of this bit from the previous 3D rendering. Next, we turn off depth checking with the <code class="literal">glDisable</code> call.</li></ul></div><p>So, setting things<a id="id661" class="indexterm"/> up for 2D rendering involves four steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Reset the render color and enable 2D textures.</li><li class="listitem">Save the 3D project matrix and set up the 2D projection matrix.</li><li class="listitem">Save the 3D model view matrix and initialize the 2D model view matrix.</li><li class="listitem">Save the 3D depth bit and turn off depth checking in 2D.</li></ol></div><p>Now, we are ready to code the <code class="literal">Disable2D</code> function. Create this new function just below the <code class="literal">Enable2D</code> function that we just created:</p><div><pre class="programlisting">void Disable2D()
{
  glPopAttrib();
  
  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();
  
  glDisable(GL_TEXTURE_2D);
}</pre></div><p>It shouldn't be too surprising that <code class="literal">Disable2D</code> performs actions in the reverse order that we performed them in <code class="literal">Enable2D</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we restore depth checking by calling <code class="literal">glPopAttrib()</code>, which takes the last attribute that was pushed to the attribute stack off the stack and restores that attribute in the current render state. This will restore depth checking to the state that it was in just before we started our 2D rendering.</li><li class="listitem" style="list-style-type: disc">The next two lines restore the projection matrix to the 3D state it was in. Again, the call to <code class="literal">glPopMatrix</code> takes the item on the top of the stack and applies it to the current render state.</li><li class="listitem" style="list-style-type: disc">The next two lines pop the model view matrix.</li><li class="listitem" style="list-style-type: disc">The final line disables 2D textures.</li></ul></div><p>Now, it is time to create our <code class="literal">Render2D</code> function. Add the following code just above the <code class="literal">Render3D</code> function:</p><div><pre class="programlisting">void Render2D()
{
  Enable2D();
  // Future 2D rendering code here
  Disable2D();
}</pre></div><p>The funny<a id="id662" class="indexterm"/> thing is that we don't have any 2D content to render yet! Later in the chapter, we will fill in the rest of the content of this function. The important thing to note here is that this function will take care of enabling 2D rendering with the call to <code class="literal">Enable2D</code>. Then the code will be added to render our 2D content. Finally, we will turn off 2D rendering with the call to <code class="literal">Disable2D</code>.</p><p>Now that we have all of the necessary supporting code to render in 2D and 3D, we will modify the <code class="literal">Render</code> function:</p><div><pre class="programlisting">void Render()
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  Render3D();
  Render2D();
  SwapBuffers(hDC);
}</pre></div><p>You will notice how simple this is now:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we clear the color buffer and reset the matrix. We always do this once before each frame of rendering.</li><li class="listitem">Next, we render the 3D content.</li><li class="listitem">Then we render the 2D content.</li><li class="listitem">Finally, we swap the buffers, which renders all of our content to the screen.</li></ol></div><p>If you run the game now, you should notice that nothing has changed. As we haven't created any 2D content to render, the 3D content will display just as it did before. Now we are ready add our 2D content. Along the way we will flesh out some additional features to make a more complete game.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec63"/>A matter of state</h1></div></div></div><p>Before we<a id="id663" class="indexterm"/> move on to actually rendering 2D items, we need to add a state machine to our game. Just as we did in RoboRacer2D, we need to be able to handle several different game states: displaying the splash screen, loading resources, displaying the main menu, running the game, pausing the game, and game over.</p><div><div><h3 class="title"><a id="tip64"/>Tip</h3><p>Don't let the word <strong>state</strong> confuse you as it is used in several different ways in computer programming. We just finished a section on render state, learning how to push and pop this state from the OpenGL stacks. Now, we are talking about game state, which you can think of as the different modes that our game is in. A framework that handles different game states is known as a <strong>state machine</strong>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec161"/>Adding the state machine</h2></div></div></div><p>Fortunately, we <a id="id664" class="indexterm"/>will be able to take some of the code directly from RoboRacer2D. Open up <code class="literal">RoboRacer2D.cpp</code>. You can do this from inside the SpaceRacer3D project by clicking <strong>File</strong>, then <strong>Open</strong>, and then browsing to <code class="literal">RoboRacer2D.cpp</code>. This will allow you to copy information from <code class="literal">RoboRacer2D.cpp</code> and paste it into SpaceRacer3D.</p><div><div><h3 class="title"><a id="tip65"/>Tip</h3><p>Opening a file loads it into the current project, but it does not add the file to the current project. However, you want to be careful because if you make changes to the file and save them, the original source file will be modified.</p></div></div><p>Copy the <code class="literal">GameState</code> enum and then paste it at the top of <code class="literal">SpaceRacer3D.cpp</code> just after the header files:</p><div><pre class="programlisting">enum GameState
{
  GS_Splash,
  GS_Loading,
  GS_Menu,
  GS_Credits,
  GS_Running,
  GS_NextLevel,
  GS_Paused,
  GS_GameOver,
};</pre></div><p>We will be copying more code from <code class="literal">RoboRacer2D.cpp</code>, so go ahead and leave it open.</p><p>Next, we need<a id="id665" class="indexterm"/> to create a global game state variable. Add the following definition in the global variables section of <code class="literal">SpaceRacer3D.cpp</code>:</p><div><pre class="programlisting">GameState gameState;</pre></div><p>The <code class="literal">gameState</code> variable <a id="id666" class="indexterm"/>will store the current game state.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec162"/>Getting ready for a splash</h2></div></div></div><p>Just as we did in RoboRacer2D, we are going to start our game with a splash screen. The splash screen <a id="id667" class="indexterm"/>will be quickly loaded before any other resources, and<a id="id668" class="indexterm"/> it will be displayed for a few seconds before moving on to loading the game assets and starting the game.</p><p>Just under the definition for <code class="literal">gameState</code>, add the following lines:</p><div><pre class="programlisting">float splashDisplayTimer;
float splashDisplayThreshold;</pre></div><p>These two variables will handle the splash screen timing. Our splash screen is going to be one of the many 2D assets that we load into the game. Let's go ahead and define some variables for our 2D assets. Add the following lines of code to the global variables section of <code class="literal">SpaceRacer3D.cpp</code>:</p><div><pre class="programlisting">Sprite* splashScreen;
Sprite* menuScreen;
Sprite* creditsScreen;
Sprite* playButton;
Sprite* creditsButton;
Sprite* exitButton;
Sprite* menuButton;
Sprite* gameOverScreen;
Sprite* replayButton;</pre></div><p>You will notice that all of our 2D assets are being handled as Sprites, a class that we borrowed from RoboRacer2D.</p><p>While we are here, let's add the following two lines as well:</p><div><pre class="programlisting">float uiTimer;
const float UI_THRESHOLD = 0.1f;</pre></div><p>These two variables will be used to add a timing buffer to mouse clicks. Now, let's create a function to load the splash screen. Add the following function to <code class="literal">SpaceRacer3D.cpp</code> somewhere before the <code class="literal">StartGame</code> function:</p><div><pre class="programlisting">void LoadSplash()
{
  gameState = GameState::GS_Splash;
  splashScreen = new Sprite(1);
  splashScreen-&gt;SetFrameSize(screenWidth, screenHeight);
  splashScreen-&gt;SetNumberOfFrames(1);
  splashScreen-&gt;AddTexture("resources/splash.png", false);
  splashScreen-&gt;IsActive(true);
  splashScreen-&gt;IsVisible(true);
  splashScreen-&gt;SetPosition(0.0f, 0.0f);
}</pre></div><p>This code is <a id="id669" class="indexterm"/>exactly the same as the code from RoboRacer2D. In <a id="id670" class="indexterm"/>fact, feel free to copy and paste it directly from <code class="literal">RoboRacer2D.cpp</code>.</p><p>Remember: we set up our 2D orthographic viewport to exactly replicate the settings that we had in RoboRacer2D. This allows us to use the same exact code and positions for our 2D objects. Even better, it allows us to use the <code class="literal">Sprite</code> class from RoboRacer2D without changing any of the code.</p><div><div><h3 class="title"><a id="tip66"/>Tip</h3><p>The <code class="literal">LoadSplash</code> function loads a file from the game resource folder called <code class="literal">splash.png</code>. You can download this file and all of the other 2D resources that are used in this chapter, from the book website. You should place all of them in a folder named <code class="literal">resources</code> under the same folder as the game source code. You also have to remember to add these resources to the <strong>Resource Files</strong> folder in the solution by right-clicking on <strong>Resource Files</strong>, then choosing <strong>Add Existing Item</strong>, then browsing to the <code class="literal">resources</code> folder and adding all of the items in that folder.</p></div></div><p>Next, we need to modify the <code class="literal">StartGame</code> function to load the splash screen. Move to the <code class="literal">StartGame</code> function add the following code:</p><div><pre class="programlisting">LoadSplash();
uiTimer = 0.0f;
splashDisplayTimer = 0.0f;
splashDisplayThreshold = 5.0f;</pre></div><p>The first thing that we do is call the <code class="literal">LoadSplash</code> function, which sets the game state to <code class="literal">GS_Splash</code>, and then loads the splash page. Next, we have to update and render the splash page. Move to the <code class="literal">Update</code> function and modify it so that it looks like this:</p><div><pre class="programlisting">void Update(const float p_deltaTime)
{
 switch (gameState)
 {
 case GameState::GS_Splash:
 case GameState::GS_Loading:
 {
  splashScreen-&gt;Update(p_deltaTime);
 }
 break;
 case GameState::GS_Running:
 {
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
  ship-&gt;Update(p_deltaTime);
  ship-&gt;SetVelocity(ship-&gt;GetVelocity() + ship-&gt;GetVelocity()*p_deltaTime/10.0f);
  speed = ship-&gt;GetVelocity() * 1000;
  if (maximumSpeed &lt; speed)
  {
   maximumSpeed = speed;
  }
  missionTime = missionTime + p_deltaTime * 100.0f;
  CheckCollisions();
  if (ship-&gt;GetPosition().z &gt; 10.0f)
  {
   gameState = GS_GameOver;
   menuButton-&gt;IsActive(true);
   gameOverScreen-&gt;IsActive(true);
  }
 }
 break;
 case GameState::GS_GameOver:
 {
  gameOverScreen-&gt;Update(p_deltaTime);
  replayButton-&gt;IsActive(true);
  replayButton-&gt;Update(p_deltaTime);
  exitButton-&gt;IsActive(true);
  exitButton-&gt;Update(p_deltaTime);
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
  ship-&gt;Update(p_deltaTime);
  CheckCollisions();
 }
 break;
 }
}</pre></div><p>The only real <a id="id671" class="indexterm"/>change is that we implemented part of the state <a id="id672" class="indexterm"/>machine. You will notice how we moved all of the code to run the game under the <code class="literal">GS_Running</code> game state case. Next, we added an update for the splash screen game state. We will eventually modify the <code class="literal">Update</code> function to handle all of the game states, but we have some more work to do yet.</p><p>Now, we are ready to render the splash screen. Move to the <code class="literal">Render2D</code> function and add the following line of code between the <code class="literal">Enable2D</code> and <code class="literal">Disable2D</code> calls:</p><div><pre class="programlisting">splashScreen-&gt;Render();</pre></div><p>At this point, if you run the game, you will see a splash screen render. The game will not move beyond the splash screen because we haven't added the code to move on yet.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec64"/>Creating the user interface</h1></div></div></div><p>We are now<a id="id673" class="indexterm"/> ready to define our user interface, which will consist of 2D screens, text, and buttons. These will all work exactly as they did in RoboRacer2D. Look at the tip in the <em>Getting ready for a splash</em> section earlier in this chapter for a reminder of how to include prebuilt 2D resources in your project.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec163"/>Defining the text system</h2></div></div></div><p>The 2D text <a id="id674" class="indexterm"/>system is built by first creating a font framework, then creating functions to display text on the screen. Open <code class="literal">RoboRacer2D.cpp</code> and copy the following functions. Then paste them into <code class="literal">SpaceRacer3D.cpp</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">BuildFont</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">KillFont</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">DrawText</code></li></ul></div><p>We are going to add some new variables to handle the data that we want to display. Add the following lines of code to the global variables section of <code class="literal">SpaceRacer3D.cpp</code>:</p><div><pre class="programlisting">int score;
int speed;
int missionTime;
int asteroidsHit;
int maximumSpeed;</pre></div><p>These variables will hold the stats and scoring used by the game:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">score</code>: This is the current game score</li><li class="listitem" style="list-style-type: disc"><code class="literal">speed</code>: This is the current speed of the ship</li><li class="listitem" style="list-style-type: disc"><code class="literal">missionTime</code>: This is the number of seconds that have elapsed since starting the mission</li><li class="listitem" style="list-style-type: disc"><code class="literal">asteroidsHit</code>: This is the number of asteroids hit by the player</li><li class="listitem" style="list-style-type: disc"><code class="literal">maximumSpeed</code>: This is the maximum speed obtained by the player</li></ul></div><p>
<code class="literal">Score</code>, <code class="literal">speed</code>, and <code class="literal">missionTime</code> will all be displayed on the heads-up-display (HUD) while the player is piloting the ship. <code class="literal">Score</code>, <code class="literal">asteroidsHit</code>, <code class="literal">missionTime</code>, and <code class="literal">maximumSpeed</code> will be displayed as stats at the end of the game.</p><p>Let's go to <code class="literal">StartGame</code> and initialize these variables:</p><div><pre class="programlisting">score = 0;
speed = 1.0f;
maximumSpeed = 0;
asteroidsHit = 0;
missionTime = 0;</pre></div><p>Now, let's create the functions to render these items on the screen. Add the following two functions to the game somewhere above the <code class="literal">Render2D</code> function:</p><div><pre class="programlisting">void DrawUi()
{
 float startY = screenHeight - 50.0f;
 float x1 = 50.0f;
 float x2 = screenWidth / 2.0f - 50.0f;
 float x3 = screenWidth - 250.0f;
 
 char scoreText[50];
 char speedText[50];
 char missionTimeText[50];

 sprintf_s(scoreText, 50, "Score: %i", score);
 sprintf_s(speedText, 50, "Speed: %i", speed);
 sprintf_s(missionTimeText, 50, "Time: %f", missionTime / 100.0f);
 DrawText(scoreText, x1, startY, 0.0f, 1.0f, 0.0f);
 DrawText(speedText, x2, startY, 0.0f, 1.0f, 0.0f);
 DrawText(missionTimeText, x3, startY, 0.0f, 1.0f, 0.0f);

}

void DrawStats()
{
 float startX = screenWidth - screenWidth / 2.5f;
 float startY = 275.0f;
 float spaceY = 30.0f;

 char asteroidsHitText[50];
 char maximumSpeedText[50];
 char scoreText[50];
 char missionTimeText[50];
 sprintf_s(asteroidsHitText, 50, "Asteroids Hit: %i", asteroidsHit);
 sprintf_s(maximumSpeedText, 50, "Maximum Speed: %i", maximumSpeed);
 sprintf_s(scoreText, 50, "Score: %i", score);
 sprintf_s(missionTimeText, 50, "Time: %f", missionTime / 100.0f);
 DrawText(asteroidsHitText, startX, startY, 0.0f, 1.0f, 0.0f);
 DrawText(maximumSpeedText, startX, startY + spaceY, 0.0f, 1.0f, 0.0f);
 DrawText(scoreText, startX, startY + spaceY * 2.0f, 0.0f, 1.0f, 0.0f);
 DrawText(missionTimeText, startX, startY + spaceY * 3.0f, 0.0f, 1.0f, 0.0f);
}
void DrawCredits()
{
 float startX = screenWidth - screenWidth / 2.5f;
 float startY = 300.0f;
 float spaceY = 30.0f;
 DrawText("Robert Madsen", startX, startY, 0.0f, 1.0f, 0.0f);
 DrawText("Author", startX, startY + spaceY, 0.0f, 1.0f, 0.0f);
}</pre></div><p>These<a id="id675" class="indexterm"/> functions work exactly like their corresponding functions in RoboRacer2D. First, we use <code class="literal">sprintf_s</code> to create a character string with the text that we want to display. Next, we use <code class="literal">glRasterPos2f</code> to set the render position in 2D. Then, we use <code class="literal">glCallLists</code> to actually render the font. In the <code class="literal">DrawCredits</code> function, we use the <code class="literal">DrawText</code> helper function to render the text.</p><p>Change <code class="literal">CheckCollisions</code> to look like the code below:</p><div><pre class="programlisting">void CheckCollisions()
{
 bool collision = false;
 for (int i = 0; i &lt; asteroids.size(); i++)
 {
  Model* item = asteroids[i];
  collision = ship-&gt;CollidedWith(item);
  if (collision)
  {
   item-&gt;IsCollideable(false);
   score++;
   asteroidsHit++;
  }
 }
}</pre></div><p>This code updates the score and asteroid stats.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec164"/>Defining textures</h2></div></div></div><p>Now, it's time<a id="id676" class="indexterm"/> to load all of our textures. Add the following function to the game:</p><div><pre class="programlisting">const bool LoadTextures()
{
 menuScreen = new Sprite(1);
 menuScreen-&gt;SetFrameSize(screenWidth, screenHeight);
 menuScreen-&gt;SetNumberOfFrames(1);
 menuScreen-&gt;AddTexture("resources/mainmenu.png", false);
 menuScreen-&gt;IsActive(true);
 menuScreen-&gt;IsVisible(true);
 menuScreen-&gt;SetPosition(0.0f, 0.0f);
 playButton = new Sprite(1);
 playButton-&gt;SetFrameSize(75.0f, 38.0f);
 playButton-&gt;SetNumberOfFrames(1);
 playButton-&gt;SetPosition(690.0f, 300.0f);
 playButton-&gt;AddTexture("resources/playButton.png");
 playButton-&gt;IsVisible(true);
 playButton-&gt;IsActive(false);
 inputManager-&gt;AddUiElement(playButton);
 creditsButton = new Sprite(1);
 creditsButton-&gt;SetFrameSize(75.0f, 38.0f);
 creditsButton-&gt;SetNumberOfFrames(1);
 creditsButton-&gt;SetPosition(690.0f, 350.0f);
 creditsButton-&gt;AddTexture("resources/creditsButton.png");
 creditsButton-&gt;IsVisible(true);
 creditsButton-&gt;IsActive(false);
 inputManager-&gt;AddUiElement(creditsButton);
 exitButton = new Sprite(1);
 exitButton-&gt;SetFrameSize(75.0f, 38.0f);
 exitButton-&gt;SetNumberOfFrames(1);
 exitButton-&gt;SetPosition(690.0f, 500.0f);
 exitButton-&gt;AddTexture("resources/exitButton.png");
 exitButton-&gt;IsVisible(true);
 exitButton-&gt;IsActive(false);
 inputManager-&gt;AddUiElement(exitButton);
 creditsScreen = new Sprite(1);
 creditsScreen-&gt;SetFrameSize(screenWidth, screenHeight);
 creditsScreen-&gt;SetNumberOfFrames(1);
 creditsScreen-&gt;AddTexture("resources/credits.png", false);
 creditsScreen-&gt;IsActive(true);
 creditsScreen-&gt;IsVisible(true);
 menuButton = new Sprite(1);
 menuButton-&gt;SetFrameSize(75.0f, 38.0f);
 menuButton-&gt;SetNumberOfFrames(1);
 menuButton-&gt;SetPosition(690.0f, 400.0f);
 menuButton-&gt;AddTexture("resources/menuButton.png");
 menuButton-&gt;IsVisible(true);
 menuButton-&gt;IsActive(false);
 inputManager-&gt;AddUiElement(menuButton);
 gameOverScreen = new Sprite(1);
 gameOverScreen-&gt;SetFrameSize(screenWidth, screenHeight);
 gameOverScreen-&gt;SetNumberOfFrames(1);
 gameOverScreen-&gt;AddTexture("resources/gameover.png", false);
 gameOverScreen-&gt;IsActive(true);
 gameOverScreen-&gt;IsVisible(true);
 replayButton = new Sprite(1);
 replayButton-&gt;SetFrameSize(75.0f, 38.0f);
 replayButton-&gt;SetNumberOfFrames(1);
 replayButton-&gt;SetPosition(690.0f, 400.0f);
 replayButton-&gt;AddTexture("resources/replayButton.png");
 replayButton-&gt;IsVisible(true);
 replayButton-&gt;IsActive(false);
 inputManager-&gt;AddUiElement(replayButton);
 return true;
}</pre></div><p>There is <a id="id677" class="indexterm"/>nothing new here! We are simply loading all of our 2D assets into the game as sprites. Here are a few reminders as to how this works:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Each sprite is loaded from a PNG file, specifying the number of frames. As none of these sprites are animated they all have one frame.</li><li class="listitem" style="list-style-type: disc">We position each sprite with a 2D coordinate.</li><li class="listitem" style="list-style-type: disc">We set the properties—visible means that it can be seen, and active means that it can be clicked on.</li><li class="listitem" style="list-style-type: disc">If the object is intended to be a button, we add it to the UI system.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec165"/>Wiring in render, update, and the game loop</h2></div></div></div><p>Now that <a id="id678" class="indexterm"/>we have finally loaded all of our <a id="id679" class="indexterm"/>2D assets, we are ready to finish<a id="id680" class="indexterm"/> the <code class="literal">Render2D</code> function:</p><div><pre class="programlisting">void Render2D()
{
 Enable2D();
 switch (gameState)
 {
 case GameState::GS_Loading:
 {
  splashScreen-&gt;Render();
 }
 break;
 case GameState::GS_Menu:
 {
  menuScreen-&gt;Render();
  playButton-&gt;Render();
  creditsButton-&gt;Render();
  exitButton-&gt;Render();
 }
 break;
 case GameState::GS_Credits:
 {
  creditsScreen-&gt;Render();
  menuButton-&gt;Render();
  DrawCredits();
 }
 break;
 case GameState::GS_Running:
 {
  DrawUi();
 }
 break;
 case GameState::GS_Splash:
 {
  splashScreen-&gt;Render();
 }
  break;
 case GameState::GS_GameOver:
 {
  gameOverScreen-&gt;Render();
  DrawStats();
  menuButton-&gt;Render();
 }
 break;
 }
 Disable2D();
}</pre></div><p>Again, there is nothing here that you haven't seen already. We are simply implementing the full state engine.</p><p>We can also implement the full <code class="literal">ProcessInput</code> function now that we have buttons to click. Add the following lines to the <code class="literal">switch</code> statement:</p><div><pre class="programlisting"> case Input::Command::CM_UI:
 {
  if (playButton-&gt;IsClicked())
  {
   playButton-&gt;IsClicked(false);
   exitButton-&gt;IsActive(false);
   playButton-&gt;IsActive(false);
   creditsButton-&gt;IsActive(false);
   gameState = GameState::GS_Running;
  }
  if (creditsButton-&gt;IsClicked())
  {
   creditsButton-&gt;IsClicked(false);
   exitButton-&gt;IsActive(false);
   playButton-&gt;IsActive(false);
   creditsButton-&gt;IsActive(false);
   gameState = GameState::GS_Credits;
  }
  if (menuButton-&gt;IsClicked())
  {
   menuButton-&gt;IsClicked(false);
   exitButton-&gt;IsActive(true);
   playButton-&gt;IsActive(true);
   menuButton-&gt;IsActive(false);
   switch (gameState)
   {
   case GameState::GS_Credits:
   {
    gameState = GameState::GS_Menu;
   }
   break;
   case GameState::GS_GameOver:
   {
    StartGame();
   }
   break;
   }
  }
  if (exitButton-&gt;IsClicked())
  {
   playButton-&gt;IsClicked(false);
   exitButton-&gt;IsActive(false);
   playButton-&gt;IsActive(false);
   creditsButton-&gt;IsActive(false);
   PostQuitMessage(0);
  }
 }
 break;
 }</pre></div><p>Yep, we've <a id="id681" class="indexterm"/>seen all this before. If you recall, the<a id="id682" class="indexterm"/> <code class="literal">Input</code> class assigns a command enum to <a id="id683" class="indexterm"/>each button that can be clicked. This code simply processes the command, if there was any, and sets the state based on which button was just clicked.</p><p>We now implement the full <code class="literal">Update</code> function to handle our new state machine:</p><div><pre class="programlisting">void Update(const float p_deltaTime)
{
 switch (gameState)
 {
 case GameState::GS_Splash:
 case GameState::GS_Loading:
 {
  splashScreen-&gt;Update(p_deltaTime);
  splashDisplayTimer += p_deltaTime;
  if (splashDisplayTimer &gt; splashDisplayThreshold)
  {
   gameState = GameState::GS_Menu;
  }
 }
 break;
 case GameState::GS_Menu:
 {
  menuScreen-&gt;Update(p_deltaTime);
  playButton-&gt;IsActive(true);
  creditsButton-&gt;IsActive(true);
  exitButton-&gt;IsActive(true);
  playButton-&gt;Update(p_deltaTime);
  creditsButton-&gt;Update(p_deltaTime);
  exitButton-&gt;Update(p_deltaTime);
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;
 case GameState::GS_Credits:
 {
  creditsScreen-&gt;Update(p_deltaTime);
  menuButton-&gt;IsActive(true);
  menuButton-&gt;Update(p_deltaTime);
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;
 case GameState::GS_Running:
 {
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
  ship-&gt;Update(p_deltaTime);
  ship-&gt;SetVelocity(ship-&gt;GetVelocity() + ship-&gt;GetVelocity()*p_deltaTime/10.0f);
  speed = ship-&gt;GetVelocity() * 1000;
  if (maximumSpeed &lt; speed)
  {
   maximumSpeed = speed;
  }
  missionTime = missionTime + p_deltaTime * 100.0f;
  CheckCollisions();
  if (ship-&gt;GetPosition().z &gt; 10.0f)
  {
   gameState = GS_GameOver;
   menuButton-&gt;IsActive(true);
   gameOverScreen-&gt;IsActive(true);
  }
 }
 break;
 case GameState::GS_GameOver:
 {
  gameOverScreen-&gt;Update(p_deltaTime);
  replayButton-&gt;IsActive(true);
  replayButton-&gt;Update(p_deltaTime);
  exitButton-&gt;IsActive(true);
  exitButton-&gt;Update(p_deltaTime);
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;
 }
}</pre></div><p>Finally, we<a id="id684" class="indexterm"/> need to modify the game loop<a id="id685" class="indexterm"/> so that it supports all of our new<a id="id686" class="indexterm"/> features. Move to the <code class="literal">GameLoop</code> function and modify it so that it looks like the following code:</p><div><pre class="programlisting">void GameLoop(const float p_deltatTime)
{
 if (gameState == GameState::GS_Splash)
 {
  BuildFont();
  LoadTextures();
  gameState = GameState::GS_Loading;
 }
 Update(p_deltatTime);
 Render();
}</pre></div><p>As always, the game loop calls the <code class="literal">Update</code> and <code class="literal">Render</code> functions. We add a special case to handle the splash screen. If we are in the <code class="literal">GS_Splash</code> game state, we then load the rest of the resources for the game and change the game state to <code class="literal">GS_Loading</code>.</p><p>Note that several of the functions referenced previously haven't been created yet! We will add support for sound, fonts, and textures as we continue.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec65"/>Summary</h1></div></div></div><p>We covered a lot of code in this chapter. The main lesson in this chapter was learning how to render 2D and 3D at the same time. We then added code to load all of our 2D resources as sprites. We also added the ability to render text, and now we can see our score, stats, and credits.</p><p>We implemented that state machine for the game and wired that into the input, update, render, and game loop systems. This included creating states for a splash screen, loading resources, playing the game, and displaying various game screens.</p><p>You now have a complete 3D game. Sure, there is more that you can do with it. In the next and final chapter, we will learn a few new tricks, then the rest is up to you!</p></div></body></html>