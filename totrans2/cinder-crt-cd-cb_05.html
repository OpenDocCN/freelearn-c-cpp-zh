<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Building Particle Systems"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Building Particle Systems</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a particle system in 2D</li><li class="listitem" style="list-style-type: disc">Applying repulsion and attraction forces</li><li class="listitem" style="list-style-type: disc">Simulating particles flying in the wind</li><li class="listitem" style="list-style-type: disc">Simulating flocking behavior</li><li class="listitem" style="list-style-type: disc">Making our particles sound reactive</li><li class="listitem" style="list-style-type: disc">Aligning particles to processed images</li><li class="listitem" style="list-style-type: disc">Aligning particles to mesh surfaces</li><li class="listitem" style="list-style-type: disc">Creating springs</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Introduction</h1></div></div></div><p>Particle systems are a computational technique of using a large number of small graphic objects to perform <a id="id281" class="indexterm"/>different types of simulations such as explosions, wind, fire, water, and flocking.</p><p>In this chapter, we are going to learn how to create and animate particles using popular and versatile physics algorithms.</p></div></div>
<div class="section" title="Creating a particle system in 2D"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Creating a particle system in 2D</h1></div></div></div><p>In this recipe, we are going to learn how<a id="id282" class="indexterm"/> we can build a basic particle system in two dimensions using the Verlet algorithm.<a id="id283" class="indexterm"/></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec128"/>Getting ready</h2></div></div></div><p>We will need to create two classes, a <code class="literal">Particle</code> class representing a single particle, and a <code class="literal">ParticleSystem</code> class to manage<a id="id284" class="indexterm"/> our particles.<a id="id285" class="indexterm"/></p><p>Using your IDE of choice, create the following files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Particle.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Particle.cpp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ParticleSystem.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ParticleSystem.cpp</code></li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec129"/>How to do it…</h2></div></div></div><p>We will learn how we can create a basic particle system. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, let's declare our <code class="literal">Particle</code> class in the <code class="literal">Particle.h</code> file and include the necessary Cinder files:<div class="informalexample"><pre class="programlisting">#pragma once

#include "cinder/gl/gl.h"
#include "cinder/Vector.h"

class Particle{
};</pre></div></li><li class="listitem">Let's add, to the class declaration, the necessary member variables – <code class="literal">ci::Vec2f</code> to store the position, previous position, and applied forces; and <code class="literal">float</code> to store particle radius, mass, and drag.<div class="informalexample"><pre class="programlisting">ci::Vec2f position, prevPosition;
ci::Vec2f forces;
float radius;
float mass;
float drag;</pre></div></li><li class="listitem">The last thing needed to finalize the <code class="literal">Particle</code> declaration is to add a constructor that takes the particle's initial position, radius, mass, and drag, and methods to update and draw the particle.<p>The following is the final <code class="literal">Particle</code> class declaration:</p><div class="informalexample"><pre class="programlisting">class Particle{
public:

Particle( const ci::Vec2f&amp; position, float radius, 
float mass, float drag );

void update();
void draw();

ci::Vec2f position, prevPosition;
ci::Vec2f forces;
float radius;
float mass;
float drag;
};</pre></div></li><li class="listitem">Let's move on to the <code class="literal">Particle.cpp</code> file and implement the <code class="literal">Particle</code> class.<p>The first necessary step is to include the <code class="literal">Particle.h</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">#include "Particle.h"</pre></div></li><li class="listitem">We initialize the member <a id="id286" class="indexterm"/>variables to the values passed in the<a id="id287" class="indexterm"/> constructor. We also initialize <code class="literal">forces</code> to <code class="literal">zero</code> and <code class="literal">prevPosition</code> to the initial position.<div class="informalexample"><pre class="programlisting">Particle::Particle( const ci::Vec2f&amp; position, float radius, float mass, float drag ){
  this-&gt;position = position;
  this-&gt;radius = radius;
  this-&gt;mass = mass;
  this-&gt;drag = drag;
  prevPosition = position;
  forces = ci::Vec2f::zero();
}</pre></div></li><li class="listitem">In the <code class="literal">update</code> method, we need to create a temporary <code class="literal">ci::Vec2f</code> variable to store the particle's position before it is updated.<div class="informalexample"><pre class="programlisting">ci::Vec2f temp = position;</pre></div></li><li class="listitem">We calculate the velocity of the particle by finding the difference between current and previous positions and multiplying it by <code class="literal">drag</code>. We store this value in <code class="literal">ci::Vec2f</code> temporarily for clarity.<div class="informalexample"><pre class="programlisting">ci::Vec2f vel = ( position – prevPosition ) * drag;</pre></div></li><li class="listitem">To update the particle's position, we add the previously calculated velocity and add <code class="literal">forces</code> divided by <code class="literal">mass</code>.<div class="informalexample"><pre class="programlisting">position += vel + forces / mass;</pre></div></li><li class="listitem">The final steps in the <code class="literal">update</code> method are to copy the previously stored position to <code class="literal">prevPosition</code> and reset <code class="literal">forces</code> to a <code class="literal">zero</code> vector.<p>The following is the<a id="id288" class="indexterm"/> complete <code class="literal">update</code> method implementation:</p><div class="informalexample"><pre class="programlisting">void Particle::update(){
    ci::Vec2f temp = position;
    ci::Vec2f vel = ( position - prevPosition ) * drag;
    position += vel + forces / mass;
    prevPosition = temp;
    forces = ci::Vec2f::zero();
}</pre></div></li><li class="listitem">In the <code class="literal">draw</code> implementation,<a id="id289" class="indexterm"/> we simply draw a circle at the particle's position using its radius.<div class="informalexample"><pre class="programlisting">void Particle::draw(){
    ci::gl::drawSolidCircle( position, radius );
}</pre></div></li><li class="listitem">Now with the <code class="literal">Particle</code> class complete, we need to begin working on the <code class="literal">ParticleSystem</code> class. Move to the <code class="literal">ParticleSystem.h</code> file, include the necessary files, and create the <code class="literal">ParticleSystem</code> class declaration.<div class="informalexample"><pre class="programlisting">#pragma once

#include "Particle.h"
#include &lt;vector&gt;

classParticleSystem{
public:

};</pre></div></li><li class="listitem">Let's add a destructor and methods to update and draw our particles. We'll also need to create methods to add and destroy particles and finally a <code class="literal">std::vector</code> variable to store the particles in this system. The following is the final class declaration:<div class="informalexample"><pre class="programlisting">Class ParticleSystem{
public:
  ~ParticleSystem();

  void update();
  void draw();

  void addParticle( Particle *particle );
  void destroyParticle( Particle *particle );

    std::vector&lt;Particle*&gt; particles;

};</pre></div></li><li class="listitem">Moving to the <code class="literal">ParticleSystem.cpp</code> file, let's begin working on the implementation. The first thing<a id="id290" class="indexterm"/> we need to do is include the file with the class declaration. <a id="id291" class="indexterm"/><div class="informalexample"><pre class="programlisting">#include "ParticleSystem.h"</pre></div></li><li class="listitem">Now let's implement the methods one by one. In the destructor, we iterate through all the particles and delete them.<div class="informalexample"><pre class="programlisting">ParticleSystem::~ParticleSystem(){
  for( std::vector&lt;Particle*&gt;::iterator it = particles.begin(); it!= particles.end(); ++it ){
  delete *it;
    }
  particles.clear();
}</pre></div></li><li class="listitem">The <code class="literal">update</code> method will be used to iterate all the particles and call <code class="literal">update</code> on each of them.<div class="informalexample"><pre class="programlisting">void ParticleSystem::update(){
  for( std::vector&lt;Particle*&gt;::iterator it = particles.begin(); it != particles.end(); ++it ){
        (*it)-&gt;update();
    }
}</pre></div></li><li class="listitem">The <code class="literal">draw</code> method will iterate all the particles and call <code class="literal">draw</code> on each of them.<div class="informalexample"><pre class="programlisting">void ParticleSystem::draw(){
  for( std::vector&lt;Particle*&gt;::iterator it = particles.begin(); it != particles.end(); ++it ){
        (*it)-&gt;draw();
    }
}</pre></div></li><li class="listitem">The <code class="literal">addParticle</code> method<a id="id292" class="indexterm"/> will insert the particle on the <code class="literal">particles</code> container.<div class="informalexample"><pre class="programlisting">void ParticleSystem::addParticle( Particle *particle ){
  particles.push_back( particle );
}</pre></div></li><li class="listitem">Finally, <code class="literal">destroyParticle</code> will delete the particle and remove it from the particles' list.<p>We'll find the particles' iterator and use it to delete and later remove the object from the container.</p><div class="informalexample"><pre class="programlisting">void ParticleSystem::destroyParticle( Particle *particle ){
  std::vector&lt;Particle*&gt;::iterator it = std::find( particles.begin(), particles.end(), particle );
  delete *it;
  particles.erase( it );
}</pre></div></li><li class="listitem">With our classes ready, <a id="id293" class="indexterm"/>let's go to our application's class and create some particles.<p>In our application's class, we need to include the <code class="literal">ParticleSystem</code> header file and the necessary header to use random numbers at the top of the source file:</p><div class="informalexample"><pre class="programlisting">#include "ParticleSystem.h"
#include "cinder/Rand.h"</pre></div></li><li class="listitem">Declare a <code class="literal">ParticleSystem</code> object on our class declaration.<div class="informalexample"><pre class="programlisting">ParticleSystem mParticleSystem;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method we can create 100 particles with random positions on our window and random radius. We'll define the mass to be the same as the radius as a way to have a<a id="id294" class="indexterm"/> relation between size and mass. <code class="literal">drag</code> will be set to 9.5.<p>Add the following code snippet inside the setup method:</p><div class="informalexample"><pre class="programlisting">int numParticle = 100;
  for( int i=0; i&lt;numParticle; i++ ){
  float x = ci::randFloat( 0.0f, getWindowWidth() );
  float y = ci::randFloat( 0.0f, getWindowHeight() );
  float radius = ci::randFloat( 5.0f, 15.0f );
  float mass = radius;radius;
  float drag = 0.95f;
        Particle *particle = new Particle
        ( Vec2f( x, y ), radius, mass, drag );
        mParticleSystem.addParticle( particle );
}</pre></div></li><li class="listitem">In the <code class="literal">update</code> method,<a id="id295" class="indexterm"/> we need to update the particles by calling the <code class="literal">update</code> method on <code class="literal">mParticleSystem</code>.<div class="informalexample"><pre class="programlisting">void MyApp::update(){
  mParticleSystem.update();
}</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method we need to clear the screen, set up the window's matrices, and call the <code class="literal">draw</code> method on <code class="literal">mParticleSystem</code>.<div class="informalexample"><pre class="programlisting">void ParticlesApp::draw()
{
  gl::clear( Color( 0, 0, 0 ) ); 
  gl::setMatricesWindow( getWindowWidth(), getWindowHeight() );
  mParticleSystem.draw();
}</pre></div></li><li class="listitem">Build and run the application<a id="id296" class="indexterm"/><a id="id297" class="indexterm"/> and you will see 100 random circles on screen, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/8703OS_5_1.jpg" alt="How to do it…"/></div></li></ol></div><p>In the next recipes we will learn how to animate the particles in organic and appealing ways.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec130"/>How it works...</h2></div></div></div><p>The method described previously uses a popular and versatile Verlet integrator. One of its main characteristics is an implicit approximation of velocity. This is accomplished by calculating, on each update of the simulation, the distance traveled since the last update of the simulation. This allows<a id="id298" class="indexterm"/> for greater stability as velocity is implicit to position and there is less chance these will ever <a id="id299" class="indexterm"/>get out of sync.</p><p>The <code class="literal">drag</code> member variable represents resistance to movement and should be a number between 0.0 and 1.0. A value of 0.0 represents such a great resistance that the particle will not be able to move. A value of 1.0 represents absence of resistance and will make the particle move indefinitely. We applied <code class="literal">drag</code> in step 7, where we multiplied <code class="literal">drag</code> by the velocity:</p><div class="informalexample"><pre class="programlisting">ci::Vec2f vel = ( position – prevPosition ) * drag;</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec131"/>There's more...</h2></div></div></div><p>To create a particle system in 3D it is necessary to use a 3D vector instead of a 2D one.</p><p>Since Cinder's vector 2D and 3D vector classes have a very similar class structure, we simply need to change <code class="literal">position</code>, <code class="literal">prevPosition</code>, and <code class="literal">forces</code> to be <code class="literal">ci::Vec3f</code> objects.</p><p>The constructor will also need to take a <code class="literal">ci::Vec3f</code> object as an argument instead.</p><p>The following is the class declaration with these changes:</p><div class="informalexample"><pre class="programlisting">class Particle{
public:

    Particle( const ci::Vec3f&amp; position, 
    float radius, float mass, float drag );

    void update();
    void draw();

    ci::Vec3f position, prevPosition;
    ci::Vec3f forces;
    float radius;
    float mass;
    float drag;
};</pre></div><p>The <code class="literal">draw</code> method <a id="id300" class="indexterm"/>should also be changed to allow for 3D drawing; we could, for example, draw a sphere instead of a circle: <a id="id301" class="indexterm"/></p><div class="informalexample"><pre class="programlisting">void Particle::draw(){
  ci::gl::drawSphere( position, radius );
} </pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec132"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more information <a id="id302" class="indexterm"/>on the implementation of the Verlet algorithm, please refer to the paper by Thomas Jakobsen, located at <a class="ulink" href="http://www.pagines.ma1.upc.edu/~susin/contingut/AdvancedCharacterPhysics.pdf">http://www.pagines.ma1.upc.edu/~susin/contingut/AdvancedCharacterPhysics.pdf</a></li><li class="listitem" style="list-style-type: disc">For more information on the Verlet integration, please read the wiki at <a class="ulink" href="http://en.wikipedia.org/wiki/Verlet_integration">http://en.wikipedia.org/wiki/Verlet_integration</a></li></ul></div></div></div>
<div class="section" title="Applying repulsion and attraction forces"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Applying repulsion and attraction forces</h1></div></div></div><p>In this recipe, we will show how<a id="id303" class="indexterm"/> you can apply repulsion and attraction forces to the particle system that we have implemented in the previous recipe.<a id="id304" class="indexterm"/></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec133"/>Getting ready</h2></div></div></div><p>In this recipe, we are going to use the code from the <span class="emphasis"><em>Creating particle system in 2D</em></span> recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec134"/>How to do it…</h2></div></div></div><p>We will illustrate how you can apply forces to the particle system. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add properties to your application's main class.<div class="informalexample"><pre class="programlisting">Vec2f attrPosition;
float attrFactor, repulsionFactor, repulsionRadius;</pre></div></li><li class="listitem">Set the default value inside the <code class="literal">setup</code> method.<a id="id305" class="indexterm"/><div class="informalexample"><pre class="programlisting">attrPosition = getWindowCenter();
attrFactor = 0.05f;
repulsionRadius = 100.f;
repulsionFactor = -5.f;</pre></div></li><li class="listitem">Implement the <a id="id306" class="indexterm"/><code class="literal">mouseMove</code> and <code class="literal">mouseDown</code> methods, as follows:<a id="id307" class="indexterm"/><div class="informalexample"><pre class="programlisting">void MainApp::mouseMove(MouseEvent event)
{
  attrPosition.x = event.getPos().x;
  attrPosition.y = event.getPos().y;
}

void MainApp::mouseDown(MouseEvent event)
{
for( std::vector&lt;Particle*&gt;::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ) {
  Vec2f repulsionForce = (*it)-&gt;position - event.getPos();
  repulsionForce = repulsionForce.normalized() * math&lt;float&gt;::max(0.f, repulsionRadius - repulsionForce.length());
          (*it)-&gt;forces += repulsionForce;
      }
}</pre></div></li><li class="listitem">At the beginning <a id="id308" class="indexterm"/>of the <code class="literal">update</code> method, add the following code snippet:<div class="informalexample"><pre class="programlisting">for( std::vector&lt;Particle*&gt;::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ) {
  Vec2f attrForce = attrPosition - (*it)-&gt;position;
  attrForce *= attrFactor;
    (*it)-&gt;forces += attrForce;
}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec135"/>How it works…</h2></div></div></div><p>In this example we added <a id="id309" class="indexterm"/>interaction to the particles engine introduced in the first recipe. The attraction force is pointing to your mouse cursor position but the repulsion vector points in the opposite direction. These forces were calculated and applied to each particle in steps 3 and 4, and then we made the particles follow your mouse cursor, but when you click on the left mouse button, they are suddenly moves away from the mouse cursor. This effect can be achieved with basic vector operations. Cinder lets you perform vector calculations pretty much the same way you usually do on scalars.</p><p>The repulsion force is calculated in step 3. We are using the normalized vector beginning at the mouse cursor position and the end of the particle position, multiplied by the repulsion factor, calculated on the basis of the distance between the particle and the mouse cursor position. Using the <a id="id310" class="indexterm"/>
<code class="literal">repulsionRadius</code> value, we can limit the range of the repulsion.</p><p>We are calculating the attraction force in step 4 taking the vector beginning at the particle position and the end at the mouse<a id="id311" class="indexterm"/> cursor position. We are <a id="id312" class="indexterm"/>multiplying this vector by the <code class="literal">attrFactor</code> value, which controls the strength of the attraction.</p><div class="mediaobject"><img src="graphics/8703OS_5_2.jpg" alt="How it works…"/></div></div></div>
<div class="section" title="Simulating particles flying in the wind"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Simulating particles flying in the wind</h1></div></div></div><p>In this recipe, we will explain how <a id="id313" class="indexterm"/>you can apply Brownian motion to your particles.<a id="id314" class="indexterm"/> Particles are going to behave like snowflakes or leaves flying in the wind.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec136"/>Getting ready</h2></div></div></div><p>In this recipe we are going to use the code base from the <span class="emphasis"><em>Creating a particle system in 2D</em></span> recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec137"/>How to do it…</h2></div></div></div><p>We will add <a id="id315" class="indexterm"/>movement to particles calculated from the Perlin noise and sine function. <a id="id316" class="indexterm"/>Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the necessary headers.<div class="informalexample"><pre class="programlisting">#include "cinder/Perlin.h"</pre></div></li><li class="listitem">Add properties to your application's main class.<div class="informalexample"><pre class="programlisting">float    mFrequency;
Perlin    mPerlin;</pre></div></li><li class="listitem">Set the default value inside the <code class="literal">setup</code> method.<div class="informalexample"><pre class="programlisting">mFrequency = 0.01f;
mPerlin = Perlin();</pre></div></li><li class="listitem">Change the number of the particles, their radius, and mass.<div class="informalexample"><pre class="programlisting">int numParticle = 300;
float radius = 1.f;
float mass = Rand::randFloat(1.f, 5.f);</pre></div></li><li class="listitem">At the beginning of the <code class="literal">update</code> method, add the following code snippet:<div class="informalexample"><pre class="programlisting">Vec2f oscilationVec;
oscilationVec.x = sin(getElapsedSeconds()*0.6f)*0.2f;
oscilationVec.y = sin(getElapsedSeconds()*0.2f)*0.1f;
std::vector&lt;Particle*&gt;::iterator it;
for(it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ) {
  Vec2f windForce = mPerlin.dfBm( (*it)-&gt;position * mFrequency );
    (*it)-&gt;forces += windForce * 0.1f;
    (*it)-&gt;forces += oscilationVec;
}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec138"/>How it works…</h2></div></div></div><p>The main movement calculations and forces are applied in step 5. As you can see we are using the Perlin noise algorithm implemented as a part of Cinder. It provides a method to retrieve Brownian motion vectors for each particle. We also add <code class="literal">oscilationVec</code> that makes particles swing from <a id="id317" class="indexterm"/>left-to-right and<a id="id318" class="indexterm"/> backwards, adding more realistic behavior.</p><div class="mediaobject"><img src="graphics/8703OS_5_3.jpg" alt="How it works…"/></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec139"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Perlin noise original source</strong></span><a id="id319" class="indexterm"/>: <a class="ulink" href="http://mrl.nyu.edu/~perlin/doc/oscar.html#noise">http://mrl.nyu.edu/~perlin/doc/oscar.html#noise</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Brownian motion</strong></span>: <a class="ulink" href="http://en.wikipedia.org/wiki/Brownian_motion">http://en.wikipedia.org/wiki/Brownian_motion</a></li></ul></div></div></div>
<div class="section" title="Simulating flocking behavior"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Simulating flocking behavior</h1></div></div></div><p>Flocking is a term applied to<a id="id320" class="indexterm"/> the behavior of birds and other flying animals that are organized into a swarm or flock.</p><p>From our point of view, it is especially interesting that flocking behavior can be simulated by applying only three rules to each particle (Boid). These rules are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Separation</strong></span>: Avoid neighbors that are too near<a id="id321" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Alignment</strong></span>: Steer towards the average velocity of neighbors<a id="id322" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cohesion</strong></span>: Steer towards the average position of neighbors<a id="id323" class="indexterm"/></li></ul></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec140"/>Getting ready</h2></div></div></div><p>In this recipe, we are going to use the code from the <span class="emphasis"><em>Creating a particle system in 2D</em></span> recipe.<a id="id324" class="indexterm"/></p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec141"/>How to do it…</h2></div></div></div><p>We will implement the rules for flocking behavior. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change the number of the particles, their radius, and mass.<div class="informalexample"><pre class="programlisting">int numParticle = 50;
float radius = 5.f;
float mass = 1.f;</pre></div></li><li class="listitem">Add a definition for new methods and properties to the <code class="literal">Particle</code> class inside the <code class="literal">Particle.h</code> header file.<div class="informalexample"><pre class="programlisting">void flock(std::vector&lt;Particle*&gt;&amp; particles);
ci::Vec2f steer(ci::Vec2f target, bool slowdown);
void borders(float width, float height);
ci::Vec2f separate(std::vector&lt;Particle*&gt;&amp; particles);
ci::Vec2f align(std::vector&lt;Particle*&gt;&amp; particles);
ci::Vec2f cohesion(std::vector&lt;Particle*&gt;&amp; particles);

float maxspeed;
float maxforce;
ci::Vec2f vel;</pre></div></li><li class="listitem">Set the default values for <code class="literal">maxspeed</code> and <code class="literal">maxforce</code> at the end of the <code class="literal">Particle</code> constructor inside the <code class="literal">Particle.cpp</code> source file.<div class="informalexample"><pre class="programlisting">this-&gt;maxspeed = 3.f;
this-&gt;maxforce = 0.05f;</pre></div></li><li class="listitem">Implement the new methods of the <code class="literal">Particle</code> class inside the <code class="literal">Particle.cpp</code> source file.<div class="informalexample"><pre class="programlisting">void Particle::flock(std::vector&lt;Particle*&gt;&amp; particles) {
  ci::Vec2f acc;
  acc += separate(particles) * 1.5f;
  acc += align(particles) * 1.0f;
  acc += cohesion(particles) * 1.0f;
  vel += acc;
  vel.limit(maxspeed);
}

ci::Vec2f Particle::steer(ci::Vec2f target, bool slowdown) {
ci::Vec2f steer;
ci::Vec2f desired = target - position;
float d = desired.length();
if (d &gt;0) {
  desired.normalize();
  if ((slowdown) &amp;&amp; (d &lt;100.0)) desired *= (maxspeed*(d/100.0));
  else desired *= maxspeed;
  steer = desired - vel;
  steer.limit(maxforce);
    }
else {
  steer = ci::Vec2f::zero();
    }
  return steer;
}

void Particle::borders(float width, float height) {
  if (position.x&lt; -radius) position.x = width+radius;
  if (position.y&lt; -radius) position.y = height+radius;
  if (position.x&gt;width+radius) position.x = -radius;
  if (position.y&gt;height+radius) position.y = -radius;
}</pre></div></li><li class="listitem">Add a method for <a id="id325" class="indexterm"/>the separation rule.<div class="informalexample"><pre class="programlisting">ci::Vec2f Particle::separate(std::vector&lt;Particle*&gt;&amp; particles) {
ci::Vec2f resultVec = ci::Vec2f::zero();
float targetSeparation = 30.f;
int count = 0;
for( std::vector&lt;Particle*&gt;::iterator it = particles.begin(); it != particles.end(); ++it ) {
  ci::Vec2f diffVec = position - (*it)-&gt;position;
  if( diffVec.length() &gt;0&amp;&amp;diffVec.length() &lt;targetSeparation ) {
    resultVec += diffVec.normalized() / diffVec.length();
    count++;
        }
    }

if (count &gt;0) {
  resultVec /= (float)count;
    }

if (resultVec.length() &gt;0) {
  resultVec.normalize();
  resultVec *= maxspeed;
  resultVec -= vel;
  resultVec.limit(maxforce);
    }

return resultVec;
}</pre></div></li><li class="listitem">Add a method for the alignment rule.<div class="informalexample"><pre class="programlisting">ci::Vec2f Particle::align(std::vector&lt;Particle*&gt;&amp; particles) {
ci::Vec2f resultVec = ci::Vec2f::zero();
float neighborDist = 50.f;
int count = 0;
for( std::vector&lt;Particle*&gt;::iterator it = particles.begin(); it != particles.end(); ++it ) {
ci::Vec2f diffVec = position - (*it)-&gt;position;
if( diffVec.length() &gt;0 &amp;&amp; diffVec.length() &lt;neighborDist ) {
resultVec += (*it)-&gt;vel;
count++;
        }
    }

if (count &gt;0) {
  resultVec /= (float)count;
}

  if (resultVec.length() &gt;0) {
  resultVec.normalize();
  resultVec *= maxspeed;
  resultVec -= vel;
  resultVec.limit(maxforce);
    }

  return resultVec;
}</pre></div></li><li class="listitem">Add a method for the cohesion rule.<div class="informalexample"><pre class="programlisting">ci::Vec2f Particle::cohesion(std::vector&lt;Particle*&gt;&amp; particles) {
ci::Vec2f resultVec = ci::Vec2f::zero();
float neighborDist = 50.f;
int count = 0;
for( std::vector&lt;Particle*&gt;::iterator it = particles.begin(); it != particles.end(); ++it ) {
  float d = position.distance( (*it)-&gt;position );
  if( d &gt;0 &amp;&amp; d &lt;neighborDist ) {
    resultVec += (*it)-&gt;position;
    count++;
        }
    }

if (count &gt;0) {
  resultVec /= (float)count;
  return steer(resultVec, false);
    }

  return resultVec;
}</pre></div></li><li class="listitem">Change<a id="id326" class="indexterm"/> the <code class="literal">update</code> method to read as follows<div class="informalexample"><pre class="programlisting">void Particle::update(){
  ci::Vec2f temp = position;
  position += vel + forces / mass;
  prevPosition = temp;
  forces = ci::Vec2f::zero();
}</pre></div></li><li class="listitem">Change the <code class="literal">drawing</code> method <a id="id327" class="indexterm"/>of <code class="literal">Particle</code>, as follows:<div class="informalexample"><pre class="programlisting">void Particle::draw(){
  ci::gl::color(1.f, 1.f, 1.f);
  ci::gl::drawSolidCircle( position, radius );
  ci::gl::color(1.f, 0.f, 0.f);
  ci::gl::drawLine(position,
  position+( position - prevPosition).normalized()*(radius+5.f) );
}</pre></div></li><li class="listitem">Change the <code class="literal">update</code> method of <code class="literal">ParticleSystem</code> inside the <code class="literal">ParticleSystem.cpp</code> source file, as follows:<div class="informalexample"><pre class="programlisting">void ParticleSystem::update(){
  for( std::vector&lt;Particle*&gt;::iterator it = particles.begin(); it!= particles.end(); ++it ){
        (*it)-&gt;flock(particles);
        (*it)-&gt;update();
        (*it)-&gt;borders(640.f, 480.f);
    }
}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec142"/>How it works…</h2></div></div></div><p>Three rules for flocking—separation, alignment, and cohesion—were implemented starting from step 4 and they were <a id="id328" class="indexterm"/>applied to each particle in step 10. In this step, we also prevented Boids from going out of the window boundaries by resetting their positions.</p><div class="mediaobject"><img src="graphics/8703OS_5_12.jpg" alt="How it works…"/></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec143"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Flocking</strong></span>: <a class="ulink" href="http://en.wikipedia.org/wiki/Flocking_(behavior)">http://en.wikipedia.org/wiki/Flocking_(behavior)</a><a id="id329" class="indexterm"/></li></ul></div></div></div>
<div class="section" title="Making our particles sound reactive"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Making our particles sound reactive</h1></div></div></div><p>In this recipe we will pick on the previous particle system and add animations based on <span class="strong"><strong>fast Fourier transform</strong></span> (<span class="strong"><strong>FFT</strong></span>) analysis from an audio file.</p><a id="id330" class="indexterm"/><p>The FFT analysis will return a list of values representing the amplitudes of several frequency windows. <a id="id331" class="indexterm"/>We will match each particle to a frequency window and use its value to animate the repulsion that each particle applies to all other particles.</p><p>This example uses Cinder's FFT processor, which is only available on Mac OS X.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec144"/>Getting ready</h2></div></div></div><p>We will be using the same particle system developed in the previous recipe, <span class="emphasis"><em>Creating a particle system in 2D</em></span>. Create the <code class="literal">Particle</code> and <code class="literal">ParticleSystem</code> classes described in that recipe, and include the <code class="literal">ParticleSystem.h</code> file at the top of the application's source file.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec145"/>How to do it…</h2></div></div></div><p>Using values from the FFT analysis we will animate our particles. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare a <code class="literal">ParticleSystem</code> object on your application's class and a variable to store the number of particles we will create.<div class="informalexample"><pre class="programlisting">ParticleSystem mParticleSystem;
int mNumParticles;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method we'll create 256 random particles. The number of particles will match the number of values we will receive from the audio analysis.<p>The particles will begin at a random position on the window and have a random size and mass. <code class="literal">drag</code> will be <code class="literal">0.9</code>.</p><div class="informalexample"><pre class="programlisting">mNumParticles = 256;
for( int i=0; i&lt;mNumParticles; i++ ){
  float x = ci::randFloat( 0.0f, getWindowWidth() );
  float y = ci::randFloat( 0.0f, getWindowHeight() );
  float radius = ci::randFloat( 5.0f, 15.0f );
  float mass = radius;
  float drag = 0.9f;
        Particle *particle = new Particle
        ( Vec2f( x, y ), radius, mass, drag );
mParticleSystem.addParticle( particle );
}</pre></div></li><li class="listitem">In the <code class="literal">update</code> method, we<a id="id332" class="indexterm"/> have to call the <code class="literal">update</code> method on the particle system.<div class="informalexample"><pre class="programlisting">void MyApp::update(){
mParticleSystem.update();
}</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, we have to clear the background, calculate the window's matrices, and call the <code class="literal">draw</code> method on the particle system.<div class="informalexample"><pre class="programlisting">void MyApp::draw()
{
  gl::clear( Color( 0, 0, 0 ) ); 
gl::setMatricesWindow( getWindowWidth(), getWindowHeight() );
mParticleSystem.draw();
}</pre></div></li><li class="listitem">Now let's load and play an audio file. We start by including the necessary files to load, play, and perform the FFT analysis. Add the following code snippet at the top of the source file:<div class="informalexample"><pre class="programlisting">#include "cinder/audio/Io.h"
#include "cinder/audio/FftProcessor.h"
#include "cinder/audio/PcmBuffer.h"
#include "cinder/audio/Output.h"</pre></div></li><li class="listitem">Now declare <code class="literal">ci::audio::TrackRef</code>, which is a reference to an audio track.<div class="informalexample"><pre class="programlisting">Audio::TrackRef mAudio;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method we will open a file dialog to allow the user to select which audio file to play.<p>If the retrieved path is not empty, we will use it to load and add a new audio track.</p><div class="informalexample"><pre class="programlisting">fs::path audioPath = getOpenFilePath();
if( audioPath.empty() == false ){
  mAudio = audio::Output::addTrack( audio::load( audioPath.string()   ) );
}</pre></div></li><li class="listitem">We'll check if <code class="literal">mAudio</code> <a id="id333" class="indexterm"/>was successfully loaded and played. We will also enable the PCM buffer and looping.<div class="informalexample"><pre class="programlisting">if( mAudio ){
  mAudio-&gt;enablePcmBuffering( true );
  mAudio-&gt;setLooping( true );
  mAudio-&gt;play();
}</pre></div></li><li class="listitem">Now that we have an audio file playing, we need to start animating the particles. First we need to apply an elastic force towards the center of the window. We do so by iterating the over all particles and adding a force, which is one-tenth of the difference between the particle's position and the window's center position.<p>Add the following code snippet to the <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">Vec2f center = getWindowCenter();
for( vector&lt;Particle*&gt;::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ){
        Particle *particle = *it;
        Vec2f force = 
        ( center - particle-&gt;position ) * 0.1f;
particle-&gt;forces += force;
    }</pre></div></li><li class="listitem">Now we have to calculate the FFT analysis. This will be done once after every frame in the update.<p>Declare a local variable <code class="literal">std::shared_ptr&lt;float&gt;</code>, where the result of the FFT will be stored.</p><p>We will get a reference to the PCM buffer of <code class="literal">mAudio</code> and perform an FFT analysis on its left channel. It is a good practice to perform a test to check the validity of <code class="literal">mAudio</code> and its buffer.</p><div class="informalexample"><pre class="programlisting">std::shared_ptr&lt;float&gt;fft;
if( mAudio ){
  audio::PcmBuffer32fRef pcmBuffer = mAudio-&gt;getPcmBuffer();
if( pcmBuffer ){
    fft = audio::calculateFft( pcmBuffer-&gt;getChannelData( audio::CHANNEL_FRONT_LEFT ), mNumParticles );
  }
    }</pre></div></li><li class="listitem">We will use the values from the FFT analysis to scale the repulsion each particle is applying.<a id="id334" class="indexterm"/><p>Add the following code snippet to the <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">if( fft ){
float *values = fft.get();
for( int i=0; i&lt;mParticleSystem.particles.size()-1; i++ ){
for( int j=i+1; j&lt;mParticleSystem.particles.size(); j++ ){
  Particle *particleA = 
  mParticleSystem.particles[i];
  Particle *particleB = 
  mParticleSystem.particles[j];
  Vec2f delta = particleA-&gt;position - 
  particleB-&gt;position;
  float distanceSquared = delta.lengthSquared();
  particleA-&gt;forces += ( delta / distanceSquared ) * particleB-&gt;mass * values[j] * 0.5f;
  particleB-&gt;forces -= ( delta / distanceSquared ) * particleA-&gt;mass * values[i] * 0.5f;</pre></div></li><li class="listitem">Build and run the application; you will be prompted to select an audio file. Select it and it will begin playing. The particles will move and push each other around according to the audio's frequencies.<div class="mediaobject"><img src="graphics/8703OS_5_6.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec146"/>How it works…</h2></div></div></div><p>We created a particle for <a id="id335" class="indexterm"/>each one of the values the FFT analysis returns and made each particle repulse every other particle according to its correspondent frequency window amplitude. As the music evolves, the animation will react accordingly.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec147"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To learn more about fast Fourier transform please visit <a class="ulink" href="http://en.wikipedia.org/wiki/Fast_Fourier_transform">http://en.wikipedia.org/wiki/Fast_Fourier_transform</a></li></ul></div></div></div>
<div class="section" title="Aligning particles to a processed image"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Aligning particles to a processed image</h1></div></div></div><p>In this recipe, we will show how you can use techniques you were introduced to in the previous recipes to make particles align to the edge detected in the image.<a id="id336" class="indexterm"/></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec148"/>Getting ready</h2></div></div></div><p>In this recipe, we are going to use the particles' implementation from the <span class="emphasis"><em>Creating a particle system in 2D</em></span> recipe; the image processing example from the <span class="emphasis"><em>Detecting edges</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. Using Image Processing Techniques">Chapter 3</a>, <span class="emphasis"><em>Using Image Processing Techniques</em></span>; as well as simulating repulsion covered in the <span class="emphasis"><em>Applying repulsion and attraction forces</em></span> recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec149"/>How to do it…</h2></div></div></div><p>We will create particles aligning to the detected edges in the image. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add an <code class="literal">anchor</code> property to the <code class="literal">Particle</code> class in the <code class="literal">Particle.h</code> file.<div class="informalexample"><pre class="programlisting">ci::Vec2f anchor;</pre></div></li><li class="listitem">Set the <code class="literal">anchor</code> value at the end of the <code class="literal">Particle</code> class constructor in the <code class="literal">Particle.cpp</code> source file.<div class="informalexample"><pre class="programlisting">anchor = position;</pre></div></li><li class="listitem">Add a new property to your application's main class.<div class="informalexample"><pre class="programlisting">float maxAlignSpeed;</pre></div></li><li class="listitem">At the end of the <code class="literal">setup</code> method, after image processing, add new particles, as follows:<div class="informalexample"><pre class="programlisting">mMouseDown = false;
repulsionFactor = -1.f;
maxAlignSpeed = 10.f;

mImage = loadImage( loadAsset("image.png") );
mImageOutput = Surface8u(mImage.getWidth(), mImage.getHeight(), false);

ip::grayscale(mImage, &amp;mImage);
ip::edgeDetectSobel(mImage, &amp;mImageOutput);

Surface8u::Iter pixelIter = mImageOutput.getIter(Area(1,1,mImageOutput.getWidth()-1,mImageOutput.getHeight()-1));

while( pixelIter.line() ) {
    while( pixelIter.pixel() ) {
        if(pixelIter.getPos().x &lt; mImageOutput.getWidth()
          &amp;&amp; pixelIter.getPos().y &lt; 
          mImageOutput.getHeight()
          &amp;&amp; pixelIter.r() &gt; 99) {
            float radius = 1.5f;
            float mass = Rand::randFloat(10.f, 20.f);
            float drag = 0.9f;
            Particle *particle = new Particle( 
            pixelIter.getPos(), radius, mass, drag );
            mParticleSystem.addParticle( particle );
        }
    }
}</pre></div></li><li class="listitem">Implement the <code class="literal">update</code> method for your main class,<a id="id337" class="indexterm"/> as follows:<div class="informalexample"><pre class="programlisting">void MainApp::update() {
  for( std::vector&lt;Particle*&gt;::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ) {

    if(mMouseDown) {
      Vec2f repulsionForce = (*it)-&gt;position - getMousePos();
      repulsionForce = repulsionForce.normalized() * math&lt;float&gt;::max(0.f, 100.f - repulsionForce.length());
                  (*it)-&gt;forces += repulsionForce;
        }

    Vec2f alignForce = (*it)-&gt;anchor - (*it)-&gt;position;
    alignForce.limit(maxAlignSpeed);
        (*it)-&gt;forces += alignForce;
    }

  mParticleSystem.update();
}</pre></div></li><li class="listitem">Change the <code class="literal">draw</code> method for <code class="literal">Particle</code> inside the <code class="literal">Particle.cpp</code> source file to read as follows<div class="informalexample"><pre class="programlisting">void Particle::draw(){
  glBegin(GL_POINTS);
  glVertex2f(position);
  glEnd();
}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec150"/>How it works…</h2></div></div></div><p>The first major step was to allocate particles at some characteristic points of the image. To do so, we detected the edges, which was<a id="id338" class="indexterm"/> covered in the <span class="emphasis"><em>Detecting edges</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. Using Image Processing Techniques">Chapter 3</a>, <span class="emphasis"><em>Using Image Processing Techniques</em></span>. In step 4 you can see that we iterated through each pixel of each processed image and placed particles only at detected features.</p><p>You can find another important calculation in step 5, where we tried to move back the particles to their original positions stored in the <code class="literal">anchor</code> property. To disorder particles, we used the same repulsion code that we used in the <span class="emphasis"><em>Applying repulsion and attraction forces</em></span> recipe.</p><div class="mediaobject"><img src="graphics/8703OS_5_8.jpg" alt="How it works…"/></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec151"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To learn more <a id="id339" class="indexterm"/>about fast Fourier transform, please visit <a class="ulink" href="http://en.wikipedia.org/wiki/Fast_Fourier_transform">http://en.wikipedia.org/wiki/Fast_Fourier_transform</a></li></ul></div></div></div>
<div class="section" title="Aligning particles to the mesh surface"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Aligning particles to the mesh surface</h1></div></div></div><p>In this recipe, we are going to use <a id="id340" class="indexterm"/>a 3D version of the particles' code base from the <span class="emphasis"><em>Creating a particle system in 2D</em></span> recipe. To navigate<a id="id341" class="indexterm"/> in 3D space, we will use <code class="literal">MayaCamUI</code> covered in the <span class="emphasis"><em>Using MayaCamUI</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Preparing for Development">Chapter 2</a>, <span class="emphasis"><em>Preparing for Development</em></span>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec152"/>Getting ready</h2></div></div></div><p>To simulate repulsion, we are using the code from the <span class="emphasis"><em>Applying repulsion and attraction forces</em></span> recipe with slight modifications for three-dimensional space. For this example, we are using the <code class="literal">ducky.mesh</code> mesh file that you can find in the <code class="literal">resources</code> directory of the Picking3D sample inside the Cinder package. Please copy this file to the <code class="literal">assets</code> folder in your project.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec153"/>How to do it…</h2></div></div></div><p>We will create particles aligned to the mesh. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add an <code class="literal">anchor</code> property<a id="id342" class="indexterm"/> to the <code class="literal">Particle</code> class in the <code class="literal">Particle.h</code> file.<div class="informalexample"><pre class="programlisting">ci::Vec3f anchor;</pre></div></li><li class="listitem">Set the <code class="literal">anchor</code> value at the end of the <code class="literal">Particle</code> class constructor in the <code class="literal">Particle.cpp</code> source file.<div class="informalexample"><pre class="programlisting">anchor = position;</pre></div></li><li class="listitem">Add the necessary headers in your main class.<div class="informalexample"><pre class="programlisting">#include "cinder/TriMesh.h"</pre></div></li><li class="listitem">Add the new properties to your application's main class.<div class="informalexample"><pre class="programlisting">ParticleSystem mParticleSystem;

float repulsionFactor;
float maxAlignSpeed;

CameraPersp  mCam;
MayaCamUI       mMayaCam;

TriMesh  mMesh;
Vec3f    mRepPosition;</pre></div></li><li class="listitem">Set the default values inside the <code class="literal">setup</code> method.<div class="informalexample"><pre class="programlisting">repulsionFactor = -1.f;
maxAlignSpeed = 10.f;
mRepPosition = Vec3f::zero();

mMesh.read( loadAsset("ducky.msh") );

mCam.setPerspective(45.0f, getWindowAspectRatio(), 0.1, 10000);
mCam.setEyePoint(Vec3f(7.f,7.f,7.f));
mCam.setCenterOfInterestPoint(Vec3f::zero());
mMayaCam.setCurrentCam(mCam);</pre></div></li><li class="listitem">At the end of the <code class="literal">setup</code> method, <a id="id343" class="indexterm"/>add the following code snippet:<div class="informalexample"><pre class="programlisting">for(vector&lt;Vec3f&gt;::iterator it = mMesh.getVertices().begin(); it != mMesh.getVertices().end(); ++it) {
  float mass = Rand::randFloat(2.f, 15.f);
  float drag = 0.95f;
  Particle *particle = new Particle
  ( (*it), 0.f, mass, drag );
  mParticleSystem.addParticle( particle );
}</pre></div></li><li class="listitem">Add methods for <a id="id344" class="indexterm"/>camera navigation.<div class="informalexample"><pre class="programlisting">void MainApp::resize( ResizeEvent event ){
    mCam = mMayaCam.getCamera();
    mCam.setAspectRatio(getWindowAspectRatio());
    mMayaCam.setCurrentCam(mCam);
}

void MainApp::mouseDown(MouseEvent event){
    mMayaCam.mouseDown( event.getPos() );
}

void MainApp::mouseDrag( MouseEvent event ){
  mMayaCam.mouseDrag( event.getPos(), event.isLeftDown(), 
  event.isMiddleDown(), event.isRightDown() );
}</pre></div></li><li class="listitem">Implement the <code class="literal">update</code> and <code class="literal">draw</code> methods for your main application class.<div class="informalexample"><pre class="programlisting">void MainApp::update() {

mRepPosition.x = cos(getElapsedSeconds()) * 3.f;
mRepPosition.y = sin(getElapsedSeconds()*2.f) * 3.f;
mRepPosition.z = cos(getElapsedSeconds()*1.5f) * 3.f;

for( std::vector&lt;Particle*&gt;::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ) {

  Vec3f repulsionForce = (*it)-&gt;position - mRepPosition;
  repulsionForce = repulsionForce.normalized() * math&lt;float&gt;::max(0.f, 3.f - repulsionForce.length());
  (*it)-&gt;forces += repulsionForce;

  Vec3f alignForce = (*it)-&gt;anchor - (*it)-&gt;position;
  alignForce.limit(maxAlignSpeed);
        (*it)-&gt;forces += alignForce;
    }

  mParticleSystem.update();
}

void MainApp::draw()
{
  gl::enableDepthRead();
  gl::enableDepthWrite();
  gl::clear( Color::black() );
  gl::setViewport(getWindowBounds());
  gl::setMatrices(mMayaCam.getCamera());

  gl::color(Color(1.f,0.f,0.f));
  gl::drawSphere(mRepPosition, 0.25f);

  gl::color(Color::white());
  mParticleSystem.draw();
}</pre></div></li><li class="listitem">Replace<a id="id345" class="indexterm"/> the <code class="literal">draw</code> method<a id="id346" class="indexterm"/> for <code class="literal">Particle</code> inside the <code class="literal">Particle.cpp</code> source file to read as follows<div class="informalexample"><pre class="programlisting">void Particle::draw(){
  glBegin(GL_POINTS);
  glVertex2f(position);
  glEnd();
}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec154"/>How it works…</h2></div></div></div><p>Firstly, we created particles in place of vertices of the mesh that you can see in step 6.</p><div class="mediaobject"><img src="graphics/8703OS_5_9.jpg" alt="How it works…"/></div><p>You can find another important calculation in step 8 where we tried <a id="id347" class="indexterm"/> to move particles back to their original positions stored in the <code class="literal">anchor</code> property. To<a id="id348" class="indexterm"/> displace the particles, we used the same repulsion code that we used in the <span class="emphasis"><em>Applying repulsion and attraction forces</em></span> recipe but with slight modifications for three-dimensional space. Basically, it is about using <code class="literal">Vec3f</code> types instead of <code class="literal">Vec2f</code>.</p><div class="mediaobject"><img src="graphics/8703OS_5_10.jpg" alt="How it works…"/></div></div></div>
<div class="section" title="Creating springs"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Creating springs</h1></div></div></div><p>In this recipe, we will learn how we can create springs.</p><p><span class="strong"><strong>Springs</strong></span> are objects<a id="id349" class="indexterm"/> that connect two particles and force them to be at a defined rest distance.</p><p>In this example, we will create random particles, and whenever the user presses a mouse button, two random particles will be connected by a new spring with a random rest distance.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec155"/>Getting ready</h2></div></div></div><p>We will be using the same particle <a id="id350" class="indexterm"/>system developed in the previous recipe, <span class="emphasis"><em>Creating a particle system in 2D</em></span>. Create the <code class="literal">Particle</code> and <code class="literal">ParticleSystem</code> classes described in that recipe and include the <code class="literal">ParticleSystem.h</code> file at the top of the application source file.</p><p>We will be creating a <code class="literal">Spring</code> class, so it is necessary to create the following files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Spring.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Spring.cpp</code></li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec156"/>How to do it…</h2></div></div></div><p>We will create springs that constrain the movement of particles. Perform the following steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">Spring.h</code> file, we will declare a <code class="literal">Spring</code> class. The first thing we need to do is to add the <code class="literal">#pragma once</code> macro and include the necessary files.<div class="informalexample"><pre class="programlisting">#pragma once
#include "Particle.h"
#include "cinder/gl/gl.h"</pre></div></li><li class="listitem">Next, declare the <code class="literal">Spring</code> class.<div class="informalexample"><pre class="programlisting">class Spring{

};</pre></div></li><li class="listitem">We will add member variables, two <code class="literal">Particle</code> pointers to reference the particles that will be connected by this spring, and the <code class="literal">rest</code> and <code class="literal">strengthfloat</code> variables.<div class="informalexample"><pre class="programlisting">class Spring{
public:
  Particle *particleA;
  Particle *particleB;
  float strength, rest;
};</pre></div></li><li class="listitem">Now we will declare the constructor that will take pointers to two <code class="literal">Particle</code> objects, and the <code class="literal">rest</code> and <code class="literal">strength</code> values.<p>We will also declare the <code class="literal">update</code> and <code class="literal">draw</code> methods.</p><p>The following is the final <code class="literal">Spring</code> class declaration:</p><div class="informalexample"><pre class="programlisting">class Spring{
public:

    Spring( Particle *particleA, Particle *particleB, 
    float rest, float strength );

    void update();
    void draw();

    Particle *particleA;
    Particle *particleB;
    float strength, rest;

};</pre></div></li><li class="listitem">Let's implement<a id="id351" class="indexterm"/> the <code class="literal">Spring</code> class in the <code class="literal">Spring.cpp</code> file.<p>In the constructor, we will set the values of the member values to the ones passed in the arguments.</p><div class="informalexample"><pre class="programlisting">Spring::Spring( Particle *particleA, Particle *particleB, float rest, float strength ){
  this-&gt;particleA = particleA;
  this-&gt;particleB = particleB;
  this-&gt;rest = rest;
  this-&gt;strength = strength;
}</pre></div></li><li class="listitem">In the <code class="literal">update</code> method of the <code class="literal">Spring</code> class, we will calculate the difference between the particles' distance and the spring's rest distance, and adjust them accordingly.<div class="informalexample"><pre class="programlisting">void Spring::update(){
    ci::Vec2f delta = particleA-&gt;position - particleB-&gt;position;
    float length = delta.length();
    float invMassA = 1.0f / particleA-&gt;mass;
    float invMassB = 1.0f / particleB-&gt;mass;
    float normDist = ( length - rest ) / ( length * ( invMassA + invMassB ) ) * strength;
    particleA-&gt;position -= delta * normDist * invMassA;
    particleB-&gt;position += delta * normDist * invMassB;
}</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method of the <code class="literal">Spring</code> class, we will simply draw a line connecting both particles.<div class="informalexample"><pre class="programlisting">void Spring::draw(){
    ci::gl::drawLine
    ( particleA-&gt;position, particleB-&gt;position );
}</pre></div></li><li class="listitem">Now we will have to make <a id="id352" class="indexterm"/>some changes in the <code class="literal">ParticleSystem</code> class to allow the addition of springs.<p>In the <code class="literal">ParticleSystem</code> file, include the <code class="literal">Spring.h</code> file.</p><div class="informalexample"><pre class="programlisting">#include "Spring.h"</pre></div></li><li class="listitem">Declare the <code class="literal">std::vector&lt;Spring*&gt;</code> member in the class declaration.<div class="informalexample"><pre class="programlisting">std::vector&lt;Spring*&gt; springs;</pre></div></li><li class="listitem">Declare the <code class="literal">addSpring</code> and <a id="id353" class="indexterm"/><code class="literal">destroySpring</code> methods to add and destroy springs to the system.<p>The following is the final <code class="literal">ParticleSystem</code> class declaration:</p><div class="informalexample"><pre class="programlisting">classParticleSystem{
public:

    ~ParticleSystem();

    void update();
    void draw();

    void addParticle( Particle *particle );
    void destroyParticle( Particle *particle );
    void addSpring( Spring *spring );
    void destroySpring( Spring *spring );

    std::vector&lt;Particle*&gt; particles;
    std::vector&lt;Spring*&gt; springs;

};</pre></div></li><li class="listitem">Let's implement the <code class="literal">addSpring</code> method. <a id="id354" class="indexterm"/>In the <code class="literal">ParticleSystem.cpp</code> file, add the following code snippet:<div class="informalexample"><pre class="programlisting">void ParticleSystem::addSpring( Spring *spring ){
  springs.push_back( spring );
}</pre></div></li><li class="listitem">In the implementation of <code class="literal">destroySpring</code>, we will find the correspondent iterator for the argument <code class="literal">Spring</code> and remove it from springs. We will also delete the object.<p>Add the following code snippet in the <code class="literal">ParticleSystem.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">void ParticleSystem::destroySpring( Spring *spring ){
  std::vector&lt;Spring*&gt;::iterator it = std::find( springs.begin(), springs.end(), spring );
  delete *it;
  springs.erase( it );
}</pre></div></li><li class="listitem">It is necessary to alter the <code class="literal">update</code> method to update all springs.<p>The following code snippet shows what the final update should look like:</p><div class="informalexample"><pre class="programlisting">void ParticleSystem::update(){
  for( std::vector&lt;Particle*&gt;::iterator it = particles.begin(); it != particles.end(); ++it ){
        (*it)-&gt;update();
    }
    for( std::vector&lt;Spring*&gt;::iterator it = 
    springs.begin(); it != springs.end(); ++it ){
        (*it)-&gt;update();
    }
}</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, we<a id="id355" class="indexterm"/> will also need to iterate over all springs and call the <code class="literal">draw</code> method on them.<p>The final implementation of the <a id="id356" class="indexterm"/>
<code class="literal">ParticleSystem::draw</code> method should be as follows:</p><div class="informalexample"><pre class="programlisting">void ParticleSystem::draw(){
    for( std::vector&lt;Particle*&gt;::iterator it = particles.begin(); it != particles.end(); ++it ){
        (*it)-&gt;draw();
    }
    for( std::vector&lt;Spring*&gt;::iterator it = 
    springs.begin(); it != springs.end(); ++it ){
        (*it)-&gt;draw();
    }
}</pre></div></li><li class="listitem">We have finished creating the <code class="literal">Spring</code> class and making all necessary changes to the <code class="literal">ParticleSystem</code> class.<p>Let's go to our application's class and include the <code class="literal">ParticleSystem.h</code> file:</p><div class="informalexample"><pre class="programlisting">#include "ParticleSystem.h"</pre></div></li><li class="listitem">Declare a <code class="literal">ParticleSystem</code> object.<div class="informalexample"><pre class="programlisting">ParticleSystem mParticleSystem;</pre></div></li><li class="listitem">Create some random<a id="id357" class="indexterm"/> particles by adding the following code snippet to the <code class="literal">setup</code> method:<div class="informalexample"><pre class="programlisting">for( int i=0; i&lt;100; i++ ){
        float x = randFloat( getWindowWidth() );
        float y = randFloat( getWindowHeight() );
        float radius = randFloat( 5.0f, 15.0f );
        float mass = radius;
        float drag = 0.9f;
        Particle *particle = 
        new Particle( Vec2f( x, y ), radius, mass, drag );
        mParticleSystem.addParticle( particle );
    }</pre></div></li><li class="listitem">In the <code class="literal">update</code> method, we will need to call the <code class="literal">update</code> method on <code class="literal">ParticleSystem</code>.<div class="informalexample"><pre class="programlisting">void MyApp::update(){
  mParticleSystem.update();
}</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, clear the background, define the window's matrices, and call the <code class="literal">draw</code> method on <code class="literal">mParticleSystem</code>.<div class="informalexample"><pre class="programlisting">void MyApp::draw(){
  gl::clear( Color( 0, 0, 0 ) );
  gl::setMatricesWindow( getWindowWidth(), getWindowHeight() );
  mParticleSystem.draw();
}</pre></div></li><li class="listitem">Since we want to create springs whenever the user presses the mouse, we will need to declare the <code class="literal">mouseDown</code> method.<a id="id358" class="indexterm"/><p>Add the following code snippet to your application's class declaration:</p><div class="informalexample"><pre class="programlisting">  void mouseDown( MouseEvent event );</pre></div></li><li class="listitem">In the <code class="literal">mouseDown</code> implementation<a id="id359" class="indexterm"/> we will connect two random particles.<p>Start by declaring a <code class="literal">Particle</code> pointer and defining it as a random particle in the particle system.</p><div class="informalexample"><pre class="programlisting">Particle *particleA = mParticleSystem.particles[ randInt( mParticleSystem.particles.size() ) ];</pre></div></li><li class="listitem">Now declare a second <code class="literal">Particle</code> pointer and make it equal to the first one. In the <code class="literal">while</code> loop, we will <a id="id360" class="indexterm"/>set its value to a random particle in <code class="literal">mParticleSystem</code> until both particles are different. This will avoid the case where both pointers point to the same particle.<div class="informalexample"><pre class="programlisting">Particle *particleB = particleA;
while( particleB == particleA ){
  particleB = mParticleSystem.particles[ randInt( mParticleSystem.particles.size() ) ];
    }</pre></div></li><li class="listitem">Now we'll create a <code class="literal">Spring</code> object that will connect both particles, define a random rest distance, and set <code class="literal">strength</code> to <code class="literal">1.0</code>. Add the created spring to <code class="literal">mParticleSystem</code>.<p>The following is the final <code class="literal">mouseDown</code> implementation:</p><div class="informalexample"><pre class="programlisting">void SpringsApp::mouseDown( MouseEvent event )
{
    Particle *particleA = mParticleSystem.particles[ 
    randInt( mParticleSystem.particles.size() ) ];
    Particle *particleB = particleA;
    while( particleB == particleA ){
  particleB = mParticleSystem.particles[ randInt( mParticleSystem.particles.size() ) ];
    }
    float rest = randFloat( 100.0f, 200.0f );
    float strength = 1.0f;
    Spring *spring = new Spring
    ( particleA, particleB, rest, strength );
    mParticleSystem.addSpring( spring );

}</pre></div></li><li class="listitem">Build and run the application. Every time a mouse button is pressed, two particles will become connected with a white line and their distance will remain unchangeable.<div class="mediaobject"><img src="graphics/87030s_5_11.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec157"/>How it works…</h2></div></div></div><p>A <code class="literal">Spring</code> object will calculate the difference between two particles and correct their positions, so that the distance between<a id="id361" class="indexterm"/> the two particles will be equal to the springs' rest value.</p><p>By using their masses, we will also take into account each particle's mass, so that the correction will take into account the particles' weight.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec158"/>There's more…</h2></div></div></div><p>The same principle can also be applied to particle systems in 3D.</p><p>If you are using a 3D particle, as explained in the <span class="emphasis"><em>There's more…</em></span> section of the <span class="emphasis"><em>Creating a particle system in 2D</em></span> recipe, the<a id="id362" class="indexterm"/> <code class="literal">Spring</code> class simply needs to change its calculations to use <code class="literal">ci::Vec3f</code> instead of <code class="literal">ci::Vec2f</code>.</p><p>The <code class="literal">update</code> method of the <code class="literal">Spring</code> class would need to look like the following code snippet:</p><div class="informalexample"><pre class="programlisting">void Spring::update(){
    ci::Vec3f delta = particleA-&gt;position - particleB-&gt;position;
    float length = delta.length();
    float invMassA = 1.0f / particleA-&gt;mass;
    float invMassB = 1.0f / particleB-&gt;mass;
    float normDist = ( length - rest ) / ( length * ( invMassA + invMassB ) ) * strength;
    particleA-&gt;position -= delta * normDist * invMassA;
    particleB-&gt;position += delta * normDist * invMassB;
}</pre></div></div></div></body></html>