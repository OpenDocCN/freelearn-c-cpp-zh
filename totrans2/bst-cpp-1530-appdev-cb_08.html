<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Metaprogramming</h1></div></div></div><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using type "vector of types"</li><li class="listitem" style="list-style-type: disc">Manipulating a vector of types</li><li class="listitem" style="list-style-type: disc">Getting a function's result type at compile time</li><li class="listitem" style="list-style-type: disc">Making a higher-order metafunction</li><li class="listitem" style="list-style-type: disc">Evaluating metafunctions lazily</li><li class="listitem" style="list-style-type: disc">Converting all the tuple elements to strings</li><li class="listitem" style="list-style-type: disc">Splitting tuples</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Introduction</h1></div></div></div><p>This chapter is devoted to some cool and hard to understand metaprogramming methods. These methods are not for everyday use, but they will be a real help in the development of generic libraries.</p><p><a class="link" href="ch04.html" title="Chapter 4. Compile-time Tricks">Chapter 4</a>, <em>Compile-time Tricks</em>, already covered the basics of metaprogramming. Reading it is recommended for better understanding. In this chapter we'll go deeper and see how multiple types can be packed into a single tuple like type. We'll make functions for manipulating collections of types, we'll see how types of compile-time collections can be changed, and how compile-time tricks can be mixed with runtime. All this is metaprogramming.</p><p>Fasten your seat belts and get ready, here we go!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Using type "vector of types"</h1></div></div></div><p>There are situations when it would <a id="id500" class="indexterm"/>be great to work with all the template parameters as if they were in a container. Imagine that we are writing something such as <code class="literal">Boost.Variant</code>:</p><div><pre class="programlisting">#include &lt;boost/mpl/aux_/na.hpp&gt;

// boost::mpl::na == n.a. == not available
template &lt;
    class T0 = boost::mpl::na, 
    class T1 = boost::mpl::na,
    class T2 = boost::mpl::na,
    class T3 = boost::mpl::na,
    class T4 = boost::mpl::na,
    class T5 = boost::mpl::na,
    class T6 = boost::mpl::na,
    class T7 = boost::mpl::na,
    class T8 = boost::mpl::na,
    class T9 = boost::mpl::na
&gt;
struct variant;</pre></div><p>And the preceding code is where all the following interesting tasks start to happen:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How can we remove constant and volatile qualifiers from all the types?</li><li class="listitem" style="list-style-type: disc">How can we remove duplicate types?</li><li class="listitem" style="list-style-type: disc">How can we get the sizes of all the types?</li><li class="listitem" style="list-style-type: disc">How can we get the maximum size of the input parameters?</li></ul></div><p>All these tasks can be easily solved using <code class="literal">Boost.MPL</code>.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec304"/>Getting ready</h2></div></div></div><p>A basic knowledge of <a class="link" href="ch04.html" title="Chapter 4. Compile-time Tricks">Chapter 4</a>, <em>Compile-time Tricks</em>, is required for this recipe. Gather your courage before reading—there will be a lot of metaprogramming in this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec305"/>How to do it…</h2></div></div></div><p>We have already seen how a type can be <a id="id501" class="indexterm"/>manipulated at compile time. Why can't we go further and combine multiple types in an array and perform operations for each element of that array?</p><div><ol class="orderedlist arabic"><li class="listitem">First of all, let's pack all the types in one of the <code class="literal">Boost.MPL</code> types containers:<div><pre class="programlisting">#include &lt;boost/mpl/vector.hpp&gt;
template &lt;
  class T0, class T1, class T2, class T3, class T4,
  class T5, class T6, class T7, class T8, class T9
&gt;
struct variant {
  typedef boost::mpl::vector&lt;T0, T1, T2, T3, T4, T5, T6, T7,T8, T9&gt; types;
};</pre></div></li><li class="listitem">Let's make our example less abstract and see how it will work if we specify types:<div><pre class="programlisting">#include &lt;string&gt;

struct declared{ unsigned char data[4096]; };

struct non_defined;

typedef variant&lt;
  volatile int, 
  const int, 
  const long, 
  declared, 
  non_defined, 
  std::string
&gt;::types types;</pre></div></li><li class="listitem">We can check everything at compile time. Let's assert that types is not empty:<div><pre class="programlisting">#include &lt;boost/static_assert.hpp&gt;
#include &lt;boost/mpl/empty.hpp&gt;
BOOST_STATIC_ASSERT((!boost::mpl::empty&lt;types&gt;::value));</pre></div></li><li class="listitem">We can also check that, for <a id="id502" class="indexterm"/>example, the <code class="literal">non_defined</code> types is <a id="id503" class="indexterm"/>still at the index <code class="literal">4</code> position:<div><pre class="programlisting">#include &lt;boost/mpl/at.hpp&gt;
#include &lt;boost/type_traits/is_same.hpp&gt;
BOOST_STATIC_ASSERT((boost::is_same&lt;
  non_defined, 
  boost::mpl::at_c&lt;types, 4&gt;::type
&gt;::value));</pre></div></li><li class="listitem">And that the last type is still <code class="literal">std::string</code>:<div><pre class="programlisting">#include &lt;boost/mpl/back.hpp&gt;
BOOST_STATIC_ASSERT((boost::is_same&lt;
  boost::mpl::back&lt;types&gt;::type,
  std::string
&gt;::value));</pre></div></li><li class="listitem">Now, when we are sure that types really contain all the types passed to our variant structure, we can do some transformations. We'll start with removing constant and volatile qualifiers:<div><pre class="programlisting">#include &lt;boost/mpl/transform.hpp&gt;
#include &lt;boost/type_traits/remove_cv.hpp&gt;
typedef boost::mpl::transform&lt;
  types, 
  boost::remove_cv&lt;boost::mpl::_1&gt; 
&gt;::type noncv_types;</pre></div></li><li class="listitem">Now we remove the duplicate types:<div><pre class="programlisting">#include &lt;boost/mpl/unique.hpp&gt;

typedef boost::mpl::unique&lt;
  noncv_types, 
  boost::is_same&lt;boost::mpl::_1, boost::mpl::_2&gt;
&gt;::type unique_types;</pre></div></li><li class="listitem">We can now check that the vector contains only <code class="literal">5</code> types:<div><pre class="programlisting">#include &lt;boost/mpl/size.hpp&gt;
BOOST_STATIC_ASSERT((boost::mpl::size&lt;unique_types&gt;::value == 5));</pre></div></li><li class="listitem">The next step is to <a id="id504" class="indexterm"/>compute sizes:<div><pre class="programlisting">// Without this we'll get an error:
// use of undefined type 'non_defined'
struct non_defined{};

#include &lt;boost/mpl/sizeof.hpp&gt;
typedef boost::mpl::transform&lt;
  unique_types, 
  boost::mpl::sizeof_&lt;boost::mpl::_1&gt;
&gt;::type sizes_types;</pre></div></li><li class="listitem">The final step is getting the maximum size:<div><pre class="programlisting">#include &lt;boost/mpl/max_element.hpp&gt;
typedef boost::mpl::max_element&lt;sizes_types&gt;::type max_size_type;</pre></div><p>We can assert that the maximum size of the type is equal to the declared size of the structure, which must be the largest one in our example:</p><div><pre class="programlisting">BOOST_STATIC_ASSERT(max_size_type::type::value == sizeof(declared));</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec306"/>How it works...</h2></div></div></div><p>The <code class="literal">boost::mpl::vector</code> class <a id="id505" class="indexterm"/>is a compile-time container that holds types. To be more precise, it is a type that holds types. We don't make instances of it; instead we are just using it in typedefs.</p><p>Unlike the STL containers, the <code class="literal">Boost.MPL</code> containers have no member methods. Instead, methods are declared in a separate header. So to use some methods we need to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Include the correct header</li><li class="listitem" style="list-style-type: disc">Call that method, usually by specifying the container as the first parameter</li></ul></div><p>Here is another example:</p><div><pre class="programlisting">#include &lt;boost/mpl/size.hpp&gt;
#include &lt;cassert&gt;

template &lt;class Vector&gt;
int foo_size() {
  return boost::mpl::size&lt;Vector&gt;::value;
}

int main() {
  typedef boost::mpl::vector&lt;int,int,int&gt; vector1_type;
  assert(foo_size&lt;vector1_type&gt;() == 3); 
}</pre></div><p>These methods should be familiar to you. <a id="id506" class="indexterm"/>We have already seen metafunctions in <a class="link" href="ch04.html" title="Chapter 4. Compile-time Tricks">Chapter 4</a>, <em>Compile-time Tricks</em>. By the way, we are also using some metafunctions (such as <code class="literal">boost::is_same</code>) from the familiar <code class="literal">Boost.TypeTraits</code> library.</p><p>So, in step 3, step 4, and step 5 we are just calling metafunctions for our container type.</p><p>The hardest part is coming up!</p><p>Remember, placeholders are widely used with the <code class="literal">boost::bind</code> and <code class="literal">Boost.Asio</code> libraries. <code class="literal">Boost.MPL</code> has them too and they are required for combining the metafunctions:</p><div><pre class="programlisting">typedef boost::mpl::transform&lt;
  types, 
  boost::remove_cv&lt;boost::mpl::_1&gt; 
&gt;::type noncv_types;</pre></div><p>Here, <code class="literal">boost::mpl::_1</code> is a placeholder and the whole expression means "for each type in types, do <code class="literal">boost::remove_cv&lt;&gt;::type</code> and push back that type to the resulting vector. Return the resulting vector via <code class="literal">::type</code>".</p><p>Let's move to step 7. Here, we specify a comparison metafunction for <code class="literal">boost::mpl::unique</code> using the <code class="literal">boost::is_same&lt;boost::mpl::_1, boost::mpl::_2&gt;</code> template parameter, where <code class="literal">boost::mpl::_1</code> and <code class="literal">boost::mpl::_2</code> are placeholders. You may find it similar to <code class="literal">boost::bind(std::equal_to(), _1, _2)</code>, and the whole expression in step 7 is similar to the following pseudo code:</p><div><pre class="programlisting">  std::vector&lt;type&gt; types;
  // ...
  std::unique(types.begin(), types.end(), 
    boost::bind(std::equal_to&lt;type&gt;(), _1, _2));</pre></div><p>There is something interesting, which is required for better understanding, in step 9. In the preceding code <code class="literal">sizes_types</code> is not a vector of values, but rather a vector of integral constants—types representing numbers. The <a id="id507" class="indexterm"/>
<code class="literal">sizes_types</code> typedef is actually the following type:</p><div><pre class="programlisting">    struct boost::mpl::vector&lt;
      struct boost::mpl::size_t&lt;4&gt;,
      struct boost::mpl::size_t&lt;4&gt;,
      struct boost::mpl::size_t&lt;4096&gt;,
      struct boost::mpl::size_t&lt;1&gt;,
      struct boost::mpl::size_t&lt;32&gt; 
    &gt;</pre></div><p>The final step should be clear now. It just gets the maximum element from the <code class="literal">sizes_types</code> typedef.</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>We can use the <code class="literal">Boost.MPL</code> metafunctions in any place where typedefs are allowed.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec307"/>There's more...</h2></div></div></div><p>The <code class="literal">Boost.MPL</code> library usage results in longer compilation time, but gives you the ability to do everything you want with types. It does not add runtime overhead and won't add even a single instruction to the binary. <a id="id508" class="indexterm"/>C++11 has no <code class="literal">Boost.MPL</code> classes, and <code class="literal">Boost.MPL</code> does not use features of C++11, such as the variadic templates. This makes the <code class="literal">Boost.MPL</code> compilation time longer on C++11 compilers, but makes it usable on C++03 compilers.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec308"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See <a class="link" href="ch04.html" title="Chapter 4. Compile-time Tricks">Chapter 4</a>, <em>Compile-time Tricks,</em> for the basics of metaprogramming</li><li class="listitem" style="list-style-type: disc">The <em>Manipulating a vector of types</em> recipe will give you even more information on metaprogramming and the <code class="literal">Boost.MPL</code> library</li><li class="listitem" style="list-style-type: disc">See the official <code class="literal">Boost.MPL</code> documentation for more examples and full references at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/in">http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/in</a><a class="ulink" href="http://dex.html">dex.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec78"/>Manipulating a vector of types</h1></div></div></div><p>The task of this recipe will be to <a id="id509" class="indexterm"/>modify the content of one <code class="literal">boost::mpl::vector</code> function depending on the content of a second <code class="literal">boost::mpl::vector</code> <a id="id510" class="indexterm"/>function. We'll be calling the second vector as the vector of modifiers and each of those modifiers can have the following type:</p><div><pre class="programlisting">// Make unsigned 
struct unsigne; // No typo: 'unsigned' is a keyword, we cannot use it.

// Make constant
struct constant;

// Otherwise we do not change type
struct no_change;</pre></div><p>So where shall we start?</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec309"/>Getting ready</h2></div></div></div><p>A basic knowledge of <code class="literal">Boost.MPL</code> is required. Reading the <em>Using type "vector of types"</em> recipe and <a class="link" href="ch04.html" title="Chapter 4. Compile-time Tricks">Chapter 4</a>, <em>Compile-time Tricks,</em> may help.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec310"/>How to do it...</h2></div></div></div><p>This recipe is similar to the previous one, but it also uses conditional compile-time statements. Get ready, it won't be easy!</p><div><ol class="orderedlist arabic"><li class="listitem">We shall start with headers:<div><pre class="programlisting">// we'll need this at step 3
#include &lt;boost/mpl/size.hpp&gt;
#include &lt;boost/type_traits/is_same.hpp&gt;
#include &lt;boost/static_assert.hpp&gt;

// we'll need this at step 4
#include &lt;boost/mpl/if.hpp&gt;
#include &lt;boost/type_traits/make_unsigned.hpp&gt;
#include &lt;boost/type_traits/add_const.hpp&gt;

// we'll need this at step 5
#include &lt;boost/mpl/transform.hpp&gt;</pre></div></li><li class="listitem">Now, let's put all the metaprogramming magic inside the structure, for simpler re-use:<div><pre class="programlisting">template &lt;class Types, class Modifiers&gt;
struct do_modifications {</pre></div></li><li class="listitem">It is a good idea to check that the passed vectors have the same size:<div><pre class="programlisting">  BOOST_STATIC_ASSERT((boost::is_same&lt;
    typename boost::mpl::size&lt;Types&gt;::type, 
    typename boost::mpl::size&lt;Modifiers&gt;::type 
  &gt;::value));</pre></div></li><li class="listitem">Now let's take care of modifying the metafunction:<div><pre class="programlisting">  typedef boost::mpl::if_&lt;
    boost::is_same&lt;boost::mpl::_2, unsigne&gt;,
    boost::make_unsigned&lt;boost::mpl::_1&gt;,
    boost::mpl::if_&lt;
      boost::is_same&lt;boost::mpl::_2, constant&gt;,
      boost::add_const&lt;boost::mpl::_1&gt;,
      boost::mpl::_1
    &gt;
  &gt; binary_operator_t;</pre></div></li><li class="listitem">And the final <a id="id511" class="indexterm"/>step:<div><pre class="programlisting">  typedef typename boost::mpl::transform&lt;
    Types,
    Modifiers,
    binary_operator_t
  &gt;::type type;
};</pre></div><p>We can now run some tests and make sure that our metafunction works correctly:</p><div><pre class="programlisting">#include &lt;boost/mpl/vector.hpp&gt;
typedef boost::mpl::vector&lt;unsigne, no_change, constant, unsigne&gt; modifiers;
typedef boost::mpl::vector&lt;int, char, short, long&gt; types;
typedef do_modifications&lt;types, modifiers&gt;::type result_type;

#include &lt;boost/mpl/at.hpp&gt;
BOOST_STATIC_ASSERT((boost::is_same&lt;
  boost::mpl::at_c&lt;result_type, 0&gt;::type,
  unsigned int
&gt;::value));

BOOST_STATIC_ASSERT((boost::is_same&lt;
  boost::mpl::at_c&lt;result_type, 1&gt;::type,
  char
&gt;::value));

BOOST_STATIC_ASSERT((boost::is_same&lt;
  boost::mpl::at_c&lt;result_type, 2&gt;::type,
  const short
&gt;::value));

BOOST_STATIC_ASSERT((boost::is_same&lt;
  boost::mpl::at_c&lt;result_type, 3&gt;::type,
  unsigned long
&gt;::value));</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec311"/>How it works...</h2></div></div></div><p>In step 3 we assert that the sizes are equal, but we do it in an unusual way. The <code class="literal">boost::mpl::size&lt;Types&gt;::type</code> metafunction actually returns the integral constant <code class="literal">struct boost::mpl::long_&lt;4&gt;</code>, so in a static assertion we actually compare two types, not two numbers. This can be rewritten in a more familiar way:</p><div><pre class="programlisting">  BOOST_STATIC_ASSERT((
    boost::mpl::size&lt;Types&gt;::type::value
    ==
    boost::mpl::size&lt;Modifiers&gt;::type::value
  ));</pre></div><div><div><h3 class="title"><a id="note31"/>Note</h3><p>Notice the <code class="literal">typename</code> keyword we use. Without it the compiler won't be able to decide if <code class="literal">::type</code> is actually a type or some variable. Previous recipes did not require it, because parameters for the metafunction were fully known at the point where we were using them. But in this recipe, the parameter for the metafunction is a template.</p></div></div><p>We'll take a look at step 5, before taking <a id="id512" class="indexterm"/>care of step 4. In step 5, we provide the <code class="literal">Types</code>, <code class="literal">Modifiers</code>, and <code class="literal">binary_operator_t</code> parameters from step 4 to the <a id="id513" class="indexterm"/>
<code class="literal">boost::mpl::transform</code> metafunction. This metafunction is rather simple—for each passed vector it takes an element and passes it to a third parameter—a binary metafunction. If we rewrite it in pseudo code, it will look like the following:</p><div><pre class="programlisting">  vector result;

  for (std::size_t i = 0; i &lt; Types.size(); ++i) {
    result.push_back(
      binary_operator_t(Types[i], Modifiers[i])
    );
  }

  return result;</pre></div><p>Step 4 may make someone's head hurt. At this step we are writing a metafunction that will be called for each pair of types from the <code class="literal">Types</code> and <code class="literal">Modifiers</code> vectors (see the preceding pseudo code). As we already know, <code class="literal">boost::mpl::_2</code> and <code class="literal">boost::mpl::_1</code> are placeholders. In this recipe, <code class="literal">_1</code> is a placeholder for a type from the <code class="literal">Types</code> vector and <code class="literal">_2</code> is a placeholder for a type from the <code class="literal">Modifiers</code> vector.</p><p>So the whole metafunction works like this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Compares the second parameter passed to it (via <code class="literal">_2</code>) with an <code class="literal">unsigned</code> type</li><li class="listitem" style="list-style-type: disc">If the types are equal, makes the first parameter passed to it (via <code class="literal">_1</code>) <code class="literal">unsigned</code> and returns that type</li><li class="listitem" style="list-style-type: disc">Otherwise, compares the second parameter passed to it (via <code class="literal">_2</code>) with a constant type</li><li class="listitem" style="list-style-type: disc">If the types are equal, makes the first parameter passed to it (via <code class="literal">_1</code>) constant and returns that type</li><li class="listitem" style="list-style-type: disc">Otherwise, returns the first parameter passed to it (via <code class="literal">_1</code>)</li></ul></div><p>We need to be very careful while constructing this metafunction. Additional care should be taken so as to not call <code class="literal">::type</code> at the end of it:</p><div><pre class="programlisting">&gt;::type binary_operator_t; // INCORRECT!</pre></div><p>If we call <code class="literal">::type</code>, the compiler will attempt to evaluate the binary operator at this point and this will lead to a compilation error. In <a id="id514" class="indexterm"/>pseudo code, such an attempt would look like this:</p><div><pre class="programlisting">binary_operator_t foo;
// Attempt to call binary_operator_t::operator() without parameters,
// when it has version only with two parameters
foo();</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec312"/>There's more...</h2></div></div></div><p>Working with metafunctions requires some practice. Even your humble servant cannot write some functions correctly at the first attempt (second and third attempts are also not good though). Do not be afraid to experiment!</p><p>The<code class="literal"> Boost.MPL</code> library is not a part of C++11 and does not use C++11 features, but it can be used with C++11 variadic templates:</p><div><pre class="programlisting">template &lt;class... T&gt;
struct vt_example {
  typedef typename boost::mpl::vector&lt;T...&gt; type;
};

BOOST_STATIC_ASSERT((boost::is_same&lt;
  boost::mpl::at_c&lt;vt_example&lt;int, char, short&gt;::type, 0&gt;::type,
  int
&gt;::value));</pre></div><p>As always, metafunctions won't add a single instruction to the resulting binary file and do not make performance worse. However, by using them you can make your code more tuned to a specific situation.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec313"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Read this chapter from the beginning to get more simple examples of <code class="literal">Boost.MPL</code> usage</li><li class="listitem" style="list-style-type: disc">See <a class="link" href="ch04.html" title="Chapter 4. Compile-time Tricks">Chapter 4</a>, <em>Compile-time Tricks</em>, especially the <em>Selecting an optimal operator for a template parameter</em> recipe, which contains code similar to the <code class="literal">binary_operator_t</code> metafunction</li><li class="listitem" style="list-style-type: disc">The official documentation for <code class="literal">Boost.MPL</code> <a id="id515" class="indexterm"/>has more examples and a full table of contents at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html">http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec79"/>Getting a function's result type at compile time</h1></div></div></div><p>Many features were <a id="id516" class="indexterm"/>added to C++11 to simplify the metaprogramming. One such feature is the alternative function syntax. It allows deducing the result type of a template function. Here is an example:</p><div><pre class="programlisting">template &lt;class T1, class T2&gt;
auto my_function_cpp11(const T1&amp; v1, const T2&amp; v2) 
  -&gt; decltype(v1 + v2) 
{
  return v1 + v2;
}</pre></div><p>It allows us to write generic functions more easily and work in difficult situations:</p><div><pre class="programlisting">#include &lt;cassert&gt;
struct s1 {};
struct s2 {};
struct s3 {};

inline s3 operator + (const s1&amp; /*v1*/, const s2&amp; /*v2*/) {
  return s3();
}

inline s3 operator + (const s2&amp; /*v1*/, const s1&amp; /*v2*/) {
  return s3();
}

int main() {
  s1 v1;
  s2 v2;
  my_function_cpp11(v1, v2);
  my_function_cpp11(v1, v2);
  assert(my_function_cpp11('\0', 1) == 1);
}</pre></div><p>But Boost has a lot of functions like these and it does not require C++11 to work.</p><p>How is that possible and how can we make a C++03 version of the <code class="literal">my_function_cpp11</code> function?</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec314"/>Getting ready</h2></div></div></div><p>A basic knowledge of C++ and templates is required for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec315"/>How to do it...</h2></div></div></div><p>C++11 greatly simplifies <a id="id517" class="indexterm"/>metaprogramming. A lot of code must be written in C++03 to make something close to the alternative functions syntax.</p><div><ol class="orderedlist arabic"><li class="listitem">We'll need to include the following header:<div><pre class="programlisting">#include &lt;boost/type_traits/common_type.hpp&gt;</pre></div></li><li class="listitem">Now we need to make a metafunction in the <code class="literal">result_of</code> namespace for any types:<div><pre class="programlisting">namespace result_of {

  template &lt;class T1, class T2&gt;
  struct my_function_cpp03 {
    typedef typename boost::common_type&lt;T1, T2&gt;::type type;
  };</pre></div></li><li class="listitem">And specialize it for types <code class="literal">s1</code>, and <code class="literal">s2</code>:<div><pre class="programlisting">  template &lt;&gt; 
  struct my_function_cpp03&lt;s1, s2&gt; {
    typedef s3 type;
  };

  template &lt;&gt;
  struct my_function_cpp03&lt;s2, s1&gt; {
    typedef s3 type;
  };
} // namespace result_of</pre></div></li><li class="listitem">Now we are ready to write the <code class="literal">my_function_cpp03</code> function:<div><pre class="programlisting">template &lt;class T1, class T2&gt;
inline typename result_of::my_function_cpp03&lt;T1, T2&gt;::type
  my_function_cpp03(const T1&amp; v1, const T2&amp; v2)
{
  return v1 + v2;
}</pre></div><p>That's it! Now we can use this function almost like a C++11 one:</p><div><pre class="programlisting">  s1 v1;
  s2 v2;

  my_function_cpp03(v1, v2);
  my_function_cpp03(v2, v1);
  assert(my_function_cpp03('\0', 1) == 1);</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec316"/>How it works...</h2></div></div></div><p>The main idea of this recipe is that we can make a special metafunction that will deduce the resulting type. Such a technique can be <a id="id518" class="indexterm"/>seen all through the Boost libraries, for example, in the <code class="literal">Boost.Variants</code> implementation of <code class="literal">boost::get&lt;&gt;</code> or in almost any function from <code class="literal">Boost.Fusion</code>.</p><p>Now, let's move through this step by step. The <a id="id519" class="indexterm"/>
<code class="literal">result_of</code> namespace is just a kind of tradition, but you can use your own and it won't matter. The <code class="literal">boost::common_type&lt;&gt;</code> metafunction <a id="id520" class="indexterm"/>deduces a type common to several types, so we use it as a general case. We also added two template specializations of the <code class="literal">my_function_cpp03</code> structures for the <code class="literal">s1</code> and <code class="literal">s2</code> types.</p><div><div><h3 class="title"><a id="note32"/>Note</h3><p>The disadvantage of writing metafunctions in C++03 is that sometimes we are required to write a lot of code. Compare the amount of code for <code class="literal">my_function_cpp11</code> and <code class="literal">my_function_cpp03</code> including the <code class="literal">result_of</code> namespace to see the difference.</p></div></div><p>When the metafunction is ready, we can deduce the resulting type without C++11, so writing <code class="literal">my_function_cpp03</code> will be as easy as a pie:</p><div><pre class="programlisting">template &lt;class T1, class T2&gt;
inline typename result_of::my_function_cpp03&lt;T1, T2&gt;::type
  my_function_cpp03(const T1&amp; v1, const T2&amp; v2)
{
  return v1 + v2;
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec317"/>There's more...</h2></div></div></div><p>This technique does not add runtime overhead but it may slow down compilation a little bit. You can use it with C++11 compilers as well.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec318"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The recipes <em>Enabling the usage of templated functions for integral types</em>, <em>Disabling templated functions' usage for real types</em>, and <em>Selecting an optimal operator for a template parameter</em> from <a class="link" href="ch04.html" title="Chapter 4. Compile-time Tricks">Chapter 4</a>, <em>Compile-time Tricks</em>, will give you much more information about <code class="literal">Boost.TypeTraits</code> and metaprogramming.</li><li class="listitem" style="list-style-type: disc">Consider the official <a id="id521" class="indexterm"/>documentation of <code class="literal">Boost.Typetraits</code> for more information about ready metafunctions at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec80"/>Making a higher-order metafunction</h1></div></div></div><p>Functions that accept other functions as an input parameter or functions that return other functions are called higher-order functions. For example, the following functions are higher-order:</p><div><pre class="programlisting">function_t higher_order_function1();
void higher_order_function2(function_t f);
function_t higher_order_function3(function_t f);</pre></div><p>We have already seen higher-order metafunctions in the recipes <em>Using type "vector of types"</em> and <em>Manipulating a vector of types</em> from this chapter, where we used <code class="literal">boost::transform</code>.</p><p>In this recipe, we'll try to make our own higher-order metafunction named <code class="literal">coalesce</code>, which accepts two types and two metafunctions. The <code class="literal">coalesce</code> metafunction applies the first type-parameter to the first metafunction and compares the resulting type with the <code class="literal">boost::mpl::false_ type</code> <a id="id522" class="indexterm"/>metafunction. If the resulting type is the <code class="literal">boost::mpl::false_ type</code> metafunction, it returns the result of applying the second type-parameter to the second metafunction, otherwise, it returns the first result type:</p><div><pre class="programlisting">template &lt;class Param1, class Param2, class Func1, class Func2&gt;
struct coalesce;</pre></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec319"/>Getting ready</h2></div></div></div><p>This recipe (and chapter) is a tricky one. Reading this chapter from the beginning is highly recommended.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec320"/>How to do it...</h2></div></div></div><p>The <code class="literal">Boost.MPL</code> metafunctions are actually structures, which can be easily passed as a template parameter. The hard part is to do it correctly.</p><div><ol class="orderedlist arabic"><li class="listitem">We'll need the following headers to write a higher-order metafunction:<div><pre class="programlisting">#include &lt;boost/mpl/apply.hpp&gt;
#include &lt;boost/mpl/if.hpp&gt;
#include &lt;boost/type_traits/is_same.hpp&gt;</pre></div></li><li class="listitem">The next step is to evaluate our functions:<div><pre class="programlisting">template &lt;class Param1, class Param2, class Func1, class Func2&gt;
struct coalesce {
  typedef typename boost::mpl::apply&lt;Func1, Param1&gt;::type type1;
  typedef typename boost::mpl::apply&lt;Func2, Param2&gt;::type type2;</pre></div></li><li class="listitem">Now we need to choose the correct result type:<div><pre class="programlisting">  typedef typename boost::mpl::if_&lt;
    boost::is_same&lt; boost::mpl::false_, type1&gt;,
    type2,
    type1
  &gt;::type type;
};</pre></div><p>That's it! we have completed a higher-order metafunction! Now we can use it, just like that:</p><div><pre class="programlisting">#include &lt;boost/static_assert.hpp&gt;
#include &lt;boost/mpl/not.hpp&gt;
using boost::mpl::_1;
using boost::mpl::_2;

typedef coalesce&lt;
  boost::mpl::true_,
  boost::mpl::true_,
  boost::mpl::not_&lt;_1&gt;,
  boost::mpl::not_&lt;_1&gt;
&gt;::type res1_t;
BOOST_STATIC_ASSERT((!res1_t::value));

typedef coalesce&lt;
  boost::mpl::true_,
  boost::mpl::false_,
  boost::mpl::not_&lt;_1&gt;,
  boost::mpl::not_&lt;_1&gt;
&gt;::type res2_t;
BOOST_STATIC_ASSERT((res2_t::value));</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec321"/>How it works...</h2></div></div></div><p>The main problem with writing the higher-order metafunctions is taking care of the placeholders. That's why we should not call <code class="literal">Func1&lt;Param1&gt;::type</code> directly. Instead, we shall use the <a id="id523" class="indexterm"/>
<code class="literal">boost::apply</code> metafunction, which accepts one function and up to five parameters that will be passed to this function.</p><div><div><h3 class="title"><a id="note33"/>Note</h3><p>You can configure <code class="literal">boost::mpl::apply</code> to accept even more parameters, defining the <code class="literal">BOOST_MPL_LIMIT_METAFUNCTION_ARITY</code> macro to the required amount of parameters, for example, to 6.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec322"/>There's more...</h2></div></div></div><p>C++11 has nothing close to the <code class="literal">Boost.MPL</code> library to apply a metafunction.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec323"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the official documentation, especially the <em>Tutorial</em> section, for more information about <a id="id524" class="indexterm"/><code class="literal">Boost.MPL</code> at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html">http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec81"/>Evaluating metafunctions lazily</h1></div></div></div><p>Lazy evaluation means that the function <a id="id525" class="indexterm"/>won't be called until we really need its result. Knowledge of this recipe is highly recommended for writing good metafunctions. The importance of lazy evaluation will be shown in the following example.</p><p>Imagine that we are writing a metafunction that accepts a function, a parameter, and a condition. The resulting type of that function must be a <code class="literal">fallback</code> type if the condition is <code class="literal">false</code> otherwise the result will be as follows:</p><div><pre class="programlisting">struct fallback;

template &lt;
  class Func,
  class Param,
  class Cond,
  class Fallback = fallback&gt;
struct apply_if;</pre></div><p>And the preceding code is the place where we cannot live without lazy evaluation.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec324"/>Getting ready</h2></div></div></div><p>Reading <a class="link" href="ch04.html" title="Chapter 4. Compile-time Tricks">Chapter 4</a>, <em>Compile-time Tricks</em>, is highly recommended. However, a good knowledge of metaprogramming should be enough.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec325"/>How to do it...</h2></div></div></div><p>We will see how this recipe is <a id="id526" class="indexterm"/>essential for writing good metafunctions:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll need the following headers:<div><pre class="programlisting">#include &lt;boost/mpl/apply.hpp&gt;
#include &lt;boost/mpl/eval_if.hpp&gt;
#include &lt;boost/mpl/identity.hpp&gt;</pre></div></li><li class="listitem">The beginning of the function is simple:<div><pre class="programlisting">template &lt;class Func, class Param, class Cond, class Fallback&gt;
struct apply_if {
  typedef typename boost::mpl::apply&lt;
    Cond, Param
  &gt;::type condition_t;</pre></div></li><li class="listitem">But we should be careful here:<div><pre class="programlisting">  typedef boost::mpl::apply&lt;Func, Param&gt; applied_type;</pre></div></li><li class="listitem">Additional care must be taken when evaluating an expression:<div><pre class="programlisting">  typedef typename boost::mpl::eval_if_c&lt;
    condition_t::value,
    applied_type,
    boost::mpl::identity&lt;Fallback&gt;
  &gt;::type type;
};</pre></div><p>That's it! Now we are free to use it like this:</p><div><pre class="programlisting">#include &lt;boost/static_assert.hpp&gt;
#include &lt;boost/type_traits/is_integral.hpp&gt;
#include &lt;boost/type_traits/make_unsigned.hpp&gt;
#include &lt;boost/type_traits/is_same.hpp&gt;

using boost::mpl::_1;
using boost::mpl::_2;

typedef apply_if&lt;
  boost::make_unsigned&lt;_1&gt;,
  int,
  boost::is_integral&lt;_1&gt;
&gt;::type res1_t;
BOOST_STATIC_ASSERT((
  boost::is_same&lt;res1_t, unsigned int&gt;::value
));

typedef apply_if&lt;
  boost::make_unsigned&lt;_1&gt;,
  float,
  boost::is_integral&lt;_1&gt;
&gt;::type res2_t;
BOOST_STATIC_ASSERT((
  boost::is_same&lt;res2_t, fallback&gt;::value
));</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec326"/>How it works...</h2></div></div></div><p>The main idea of this recipe is that we should not execute the metafunction if the condition is <code class="literal">false</code>. Because when the condition is <a id="id527" class="indexterm"/>
<code class="literal">false</code>, there is a chance that the metafunction for that type won't work:</p><div><pre class="programlisting">// will fail with static assert somewhere deep in implementation
// of boost::make_unsigned&lt;_1&gt; if we won't be evaluating function // lazy. 
typedef apply_if&lt;
    boost::make_unsigned&lt;_1&gt;,
    float,
    boost::is_integral&lt;_1&gt;
&gt;::type res2_t;
BOOST_STATIC_ASSERT((
    boost::is_same&lt;res2_t, fallback&gt;::value
));</pre></div><p>So, how do we evaluate a metafunction lazily?</p><p>The compiler won't look inside the metafunction if there is no access to the metafunction's internal types or values. In other words, the compiler will try to compile the metafunction when we try to get one of its members via <code class="literal">::</code>. This can be a call to <code class="literal">::type</code> or <code class="literal">::value</code>. That is what an incorrect version of <code class="literal">apply_if</code> looks like:</p><div><pre class="programlisting">template &lt;class Func, class Param, class Cond, class Fallback&gt;
struct apply_if {
  typedef boost::mpl::apply&lt;Cond, Param&gt; condition_t;

  // Incorrect, metafunction is evaluated when `::type` called
  typedef typename boost::mpl::apply&lt;Func, Param&gt;::type applied_type;

  typedef typename boost::mpl::if_c&lt;
    condition_t::value,
    applied_type,
    boost::mpl::identity&lt;Fallback&gt;
  &gt;::type type;
};</pre></div><p>This differs from our example, where we <a id="id528" class="indexterm"/>did not call <code class="literal">::type</code> at step 3 and implemented step 4 using <code class="literal">eval_if_c</code>, which calls <code class="literal">::type</code> only for one of its parameters. The <code class="literal">boost::mpl::eval_if_c</code> metafunction is implemented like this:</p><div><pre class="programlisting">template&lt;bool C, typename F1, typename F2&gt;
struct eval_if_c {
  typedef typename if_c&lt;C,F1,F2&gt;::type f_;
  typedef typename f_::type type;
};</pre></div><p>Because <code class="literal">boost::mpl::eval_if_c</code> calls <code class="literal">::type</code> for a success condition and <code class="literal">fallback</code> may have no <code class="literal">::type</code>, we were required to wrap <code class="literal">fallback</code> into the <code class="literal">boost::mpl::identity</code>. <code class="literal">boost::mpl::identity</code> class. This class is a very simple but useful structure that returns its template parameter via a <code class="literal">::type</code> call:</p><div><pre class="programlisting">template &lt;class T&gt;
struct identity {
    typedef T type;
};</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec327"/>There's more...</h2></div></div></div><p>As we previously mentioned, C++11 has no classes of <code class="literal">Boost.MPL</code>, but we can use <code class="literal">std::common_type&lt;T&gt;</code> with a single argument just like <code class="literal">boost::mpl::identity&lt;T&gt;</code>.</p><p>Just as always, metafunctions do not add a single line to the output binary file. So you can use metafunctions as many times as you want. The more you do at compile-time, the less will remain for runtime.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec328"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">boost::mpl::identity</code> type <a id="id529" class="indexterm"/>can be used to disable <strong>Argument Dependent Lookup</strong> (<strong>ADL</strong>) for template functions. See the sources of <code class="literal">boost::implicit_cast</code> in the <code class="literal">&lt;boost/implicit_cast.hpp&gt;</code> header.</li><li class="listitem" style="list-style-type: disc">Reading this chapter from the <a id="id530" class="indexterm"/>beginning and the official documentation for <code class="literal">Boost.MPL</code> may help: <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html">http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec82"/>Converting all the tuple elements to strings</h1></div></div></div><p>This recipe and the next one <a id="id531" class="indexterm"/>are devoted to a mix of compile time and runtime features. We'll be using the <code class="literal">Boost.Fusion</code> library to see what it can do.</p><p>Remember that we were talking about tuples and arrays in the first chapter. Now we want to write a single function that can stream elements of tuples and arrays to strings.</p><div><img src="img/4880OS_08_01.jpg" alt="Converting all the tuple elements to strings"/></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec329"/>Getting ready</h2></div></div></div><p>You should be aware of the <code class="literal">boost::tuple</code> and <code class="literal">boost::array</code> classes and of the <code class="literal">boost::lexical_cast</code> function.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec330"/>How to do it...</h2></div></div></div><p>We already know almost all the functions and classes that will be used in this recipe. We just need to gather all of them together.</p><div><ol class="orderedlist arabic"><li class="listitem">We need to write a functor that converts any type to a string:<div><pre class="programlisting">#include &lt;boost/lexical_cast.hpp&gt;
#include &lt;boost/noncopyable.hpp&gt;

struct stringize_functor: boost::noncopyable {
private:
  std::string&amp; result;

public:
  explicit stringize_functor(std::string&amp; res)
    : result(res)
  {}

  template &lt;class T&gt;
  void operator()(const T&amp; v) const {
    result += boost::lexical_cast&lt;std::string&gt;(v);
  }
};</pre></div></li><li class="listitem">And this is the tricky <a id="id532" class="indexterm"/>part of the code:<div><pre class="programlisting">#include &lt;boost/fusion/include/for_each.hpp&gt;

template &lt;class Sequence&gt;
std::string stringize(const Sequence&amp; seq) {
  std::string result;
  boost::fusion::for_each(seq, stringize_functor(result));
  return result;
}</pre></div></li><li class="listitem">That's all! Now we can convert anything we want to a string:<div><pre class="programlisting">struct cat{};

std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const cat&amp; ) {
  return os &lt;&lt; "Meow! ";
}

#include &lt;iostream&gt;
#include &lt;boost/fusion/adapted/boost_tuple.hpp&gt;
#include &lt;boost/fusion/adapted/std_pair.hpp&gt;
#include &lt;boost/fusion/adapted/boost_array.hpp&gt;

int main() {
  boost::fusion::vector&lt;cat, int, std::string&gt; tup1(cat(), 0, "_0");
  boost::tuple&lt;cat, int, std::string&gt; tup2(cat(), 0, "_0");
  std::pair&lt;cat, cat&gt; cats;
  boost::array&lt;cat, 10&gt; many_cats;

  std::cout &lt;&lt; stringize(tup1) &lt;&lt; '\n' 
    &lt;&lt; stringize(tup2) &lt;&lt; '\n'
    &lt;&lt; stringize(cats) &lt;&lt; '\n'
    &lt;&lt; stringize(many_cats) &lt;&lt; '\n';
}</pre></div><p>The preceding example will output the following:</p><div><pre class="programlisting">Meow! 0_0
Meow! 0_0
Meow! Meow! 
Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! </pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec331"/>How it works...</h2></div></div></div><p>The main problem with the <a id="id533" class="indexterm"/>
<code class="literal">stringize</code> function is that neither <code class="literal">boost::tuple</code> nor <code class="literal">std::pair</code> have <code class="literal">begin()</code> or <code class="literal">end()</code> methods, so we cannot call <code class="literal">std::for_each</code>. And this is where <code class="literal">Boost.Fusion</code> steps in.</p><p>The <code class="literal">Boost.Fusion</code> library contains lots of terrific algorithms that can manipulate structures at compile time.</p><p>The <code class="literal">boost::fusion::for_each</code> function <a id="id534" class="indexterm"/>iterates through elements in <a id="id535" class="indexterm"/>sequence and applies a functor to each of the elements.</p><p>Note that we have included:</p><div><pre class="programlisting">#include &lt;boost/fusion/adapted/boost_tuple.hpp&gt;
#include &lt;boost/fusion/adapted/std_pair.hpp&gt;
#include &lt;boost/fusion/adapted/boost_array.hpp&gt;</pre></div><p>This is required because, by default, <code class="literal">Boost.Fusion</code> works only with its own classes.<code class="literal">Boost.Fusion</code> has its own tuple class, <code class="literal">boost::fusion::vector</code>, which is quite close to <code class="literal">boost::tuple</code>:</p><div><pre class="programlisting">#include &lt;boost/tuple/tuple.hpp&gt;
#include &lt;string&gt;
#include &lt;cassert&gt;

void tuple_example() {
  boost::tuple&lt;int, int, std::string&gt; tup(1, 2, "Meow");
  assert(boost::get&lt;0&gt;(tup) == 1);
  assert(boost::get&lt;2&gt;(tup) == "Meow");
}

#include &lt;boost/fusion/include/vector.hpp&gt;
#include &lt;boost/fusion/include/at_c.hpp&gt;

void fusion_tuple_example() {
  boost::fusion::vector&lt;int, int, std::string&gt; tup(1, 2, "Meow");
  assert(boost::fusion::at_c&lt;0&gt;(tup) == 1);
  assert(boost::fusion::at_c&lt;2&gt;(tup) == "Meow");
}</pre></div><p>But <code class="literal">boost::fusion::vector</code> is not as simple as <code class="literal">boost::tuple</code>. We'll see the difference in the <em>Splitting tuples</em> recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec332"/>There's more...</h2></div></div></div><p>There is one fundamental difference between <code class="literal">boost::fusion::for_each</code> and <code class="literal">std::for_each</code>. The <a id="id536" class="indexterm"/>
<code class="literal">std::for_each</code> function contains a loop inside it and determinates at runtime, how many iterations will be done. However, <code class="literal">boost::fusion::for_each</code> knows the iteration count at compile time and fully unrolls the loop, generating the following <a id="id537" class="indexterm"/>code for <code class="literal">stringize(tup2)</code>:</p><div><pre class="programlisting">  std::string result;

  // Instead of
  // boost::fusion::for_each(seq, stringize_functor(result));
  // there'll be the following:
  {
    stringize_functor functor(result);
    functor(boost::fusion::at_c&lt;0&gt;(tup2));
    functor(boost::fusion::at_c&lt;1&gt;(tup2));
    functor(boost::fusion::at_c&lt;2&gt;(tup2));
  }
  return result;</pre></div><p>C++11 contains no <code class="literal">Boost.Fusion</code> classes. All the methods of <code class="literal">Boost.Fusion</code> are very effective. They do as much as possible at compile time and have some very advanced optimizations.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec333"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Splitting tuples</em> recipe will give more information about the true power of <code class="literal">Boost.Fusion</code></li><li class="listitem" style="list-style-type: disc">The official documentation for <a id="id538" class="indexterm"/><code class="literal">Boost.Fusion</code> contains some interesting examples and full references which can be found at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/fusion/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/fusion/doc/html/index.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec83"/>Splitting tuples</h1></div></div></div><p>This recipe will show a tiny piece <a id="id539" class="indexterm"/>of the <code class="literal">Boost.Fusion</code> library's abilities. We'll be splitting a single tuple into two tuples, one with arithmetic types and the other with all the other types.</p><div><img src="img/4880OS_08_02.jpg" alt="Splitting tuples"/></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec334"/>Getting ready</h2></div></div></div><p>This recipe requires knowledge of <code class="literal">Boost.MPL</code>, placeholders, and <code class="literal">Boost.Tuple</code>. Read the following recipes from <a class="link" href="ch01.html" title="Chapter 1. Starting to Write Your Application">Chapter 1</a>, <em>Starting to Write Your Application</em>, <em>Combining multiple values into one</em> for more information about tuples and <em>Reordering parameters of a function</em> for information about placeholders. Reading this chapter from the beginning is recommended.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec335"/>How to do it...</h2></div></div></div><p>This is possibly one of the hardest recipes in this chapter. Result types will be determined at compile time and values for those types will be filled at runtime.</p><div><ol class="orderedlist arabic"><li class="listitem">To implement that mix, we'll need the following headers:<div><pre class="programlisting">#include &lt;boost/fusion/include/remove_if.hpp&gt;
#include &lt;boost/type_traits/is_arithmetic.hpp&gt;</pre></div></li><li class="listitem">Now we are ready to make a function that returns non-arithmetic types:<div><pre class="programlisting">template &lt;class Sequence&gt;
typename boost::fusion::result_of::remove_if&lt;
  const Sequence, 
  boost::is_arithmetic&lt;boost::mpl::_1&gt; 
&gt;::type get_nonarithmetics(const Sequence&amp; seq) 
{
  return boost::fusion::remove_if&lt; 
    boost::is_arithmetic&lt;boost::mpl::_1&gt; 
  &gt;(seq);
}</pre></div></li><li class="listitem">And a function that returns arithmetic types:<div><pre class="programlisting">template &lt;class Sequence&gt;
typename boost::fusion::result_of::remove_if&lt;
  const Sequence, 
  boost::mpl::not_&lt; boost::is_arithmetic&lt;boost::mpl::_1&gt; &gt;
&gt;::type get_arithmetics(const Sequence&amp; seq) 
{
  return boost::fusion::remove_if&lt; 
    boost::mpl::not_&lt; boost::is_arithmetic&lt;boost::mpl::_1&gt; &gt;
  &gt;(seq);
}</pre></div></li></ol></div><p>That's it! Now we are capable of doing the following tasks:</p><div><pre class="programlisting">#include &lt;boost/fusion/include/vector.hpp&gt;
#include &lt;cassert&gt;
#include &lt;boost/fusion/include/at_c.hpp&gt;

int main() {
  typedef boost::fusion::vector&lt;
    int, boost::blank, boost::blank, float
  &gt; tup1_t;

  tup1_t tup1(8, boost::blank(), boost::blank(), 0.0);
  boost::fusion::vector&lt;boost::blank, boost::blank&gt; res_na
    = get_nonarithmetics(tup1);

  boost::fusion::vector&lt;int, float&gt; res_a = get_arithmetics(tup1);
  assert(boost::fusion::at_c&lt;0&gt;(res_a) == 8);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec336"/>How it works...</h2></div></div></div><p>The idea behind <code class="literal">Boost.Fusion</code> is that the <a id="id540" class="indexterm"/>compiler knows the structure layout at compile time and whatever the compiler knows at compile time, we can change at the same time. <a id="id541" class="indexterm"/>
<code class="literal">Boost.Fusion</code> allows us to modify different sequences, add and remove fields, and change field types. This is what we did in step 2 and step 3; we removed the non-required fields from the tuple.</p><p>Now let's take a very close look at <code class="literal">get_arithmetics</code>. First of all its result type is deduced using the following construction:</p><div><pre class="programlisting">typename boost::fusion::result_of::remove_if&lt;
  const Sequence, 
  boost::is_arithmetic&lt;boost::mpl::_1&gt; 
&gt;::type</pre></div><p>This should be familiar to us. We saw something like this in the <em>Getting a function's result type at compile time</em> recipe in this chapter. The <code class="literal">Boost.MPL</code> placeholder <code class="literal">boost::mpl::_1</code> should also be familiar.</p><p>Now let's move inside the function and we'll see the following code:</p><div><pre class="programlisting">  return boost::fusion::remove_if&lt; 
    boost::is_arithmetic&lt;boost::mpl::_1&gt; 
  &gt;(seq);</pre></div><p>Remember that the compiler knows all the types of <code class="literal">seq</code> at compile time. This means that <code class="literal">Boost.Fusion</code> can apply metafunctions to <a id="id542" class="indexterm"/>different elements of <code class="literal">seq</code> and get the metafunction results for them. This also means that <code class="literal">Boost.Fusion</code> will be capable of copying required fields from the old structure to the new one.</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>However, <code class="literal">Boost.Fusion</code> tries not to copy fields if at all possible.</p></div></div><p>The code in step 3 is very similar to the code in step 2, but it has a negated predicate for removing non-required types.</p><p>Our functions can be used with any type supported by <code class="literal">Boost.Fusion</code> and not just with <code class="literal">boost::fusion::vector</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec337"/>There's more...</h2></div></div></div><p>You can use <code class="literal">Boost.MPL</code> functions for the <code class="literal">Boost.Fusion</code> containers. You just need to include <code class="literal">#include &lt;boost/fusion/include/mpl.hpp&gt;</code>:</p><div><pre class="programlisting">#include &lt;boost/fusion/include/mpl.hpp&gt;
#include &lt;boost/mpl/transform.hpp&gt;
#include &lt;boost/type_traits/remove_const.hpp&gt;

template &lt;class Sequence&gt;
struct make_nonconst: boost::mpl::transform&lt;
  Sequence,
  boost::remove_const&lt;boost::mpl::_1&gt;
&gt; {};

typedef boost::fusion::vector&lt;
  const int, const boost::blank, boost::blank
&gt; type1;

typedef make_nonconst&lt;type1&gt;::type nc_type;

BOOST_STATIC_ASSERT((boost::is_same&lt;
  boost::fusion::result_of::value_at_c&lt;nc_type, 0&gt;::type,
  int
&gt;::value));</pre></div><div><div><h3 class="title"><a id="note35"/>Note</h3><p>We have used <code class="literal">boost::fusion::result_of::value_at_c</code> instead of <code class="literal">boost::fusion::result_of::at_c</code> because <code class="literal">boost::fusion::result_of::at_c</code> returns the exact type that will be used as a return type in the <code class="literal">boost::fusion::at_c</code> call, which is a reference. <code class="literal">boost::fusion::result_of::value_at_c</code> returns type without a reference.</p></div></div><p>The<code class="literal"> Boost.Fusion</code> and <code class="literal">Boost.MPL</code> libraries are not a part of C++11. <code class="literal">Boost.Fusion</code> is extremely fast. It has many optimizations. All the metafunctions that you use with it will be evaluated at compile time.</p><p>It is worth mentioning that we saw only a <a id="id543" class="indexterm"/>tiny part of the <code class="literal">Boost.Fusion</code> abilities. A separate book could be written about it.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec338"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Good tutorials and full documentation for <code class="literal">Boost.Fusion</code> is available at the Boost site <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/fusion/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/fusion/doc/html/index.html</a></li><li class="listitem" style="list-style-type: disc">You may also wish to <a id="id544" class="indexterm"/>see the official documentation for <code class="literal">Boost.MPL</code> at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html">http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html</a></li></ul></div></div></div></body></html>