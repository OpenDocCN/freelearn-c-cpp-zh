<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Working with the System</h1></div></div></div><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Listing files in a directory</li><li class="listitem" style="list-style-type: disc">Erasing and creating files and directories</li><li class="listitem" style="list-style-type: disc">Passing data quickly from one process to another</li><li class="listitem" style="list-style-type: disc">Syncing interprocess communications</li><li class="listitem" style="list-style-type: disc">Using pointers in shared memory</li><li class="listitem" style="list-style-type: disc">The fastest way to read files</li><li class="listitem" style="list-style-type: disc">Coroutines – saving the state and postponing the execution</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec100"/>Introduction</h1></div></div></div><p>Each operating system has many system calls doing almost the same things in slightly different ways. Those calls differ in performance and differ from one operating system to another. Boost provides portable and safe wrappers around those calls. Knowledge of those wrappers is essential for writing good programs.</p><p>This chapter is devoted to working with the operating system. We have seen how to deal with network communications and signals in <a class="link" href="ch06.html" title="Chapter 6. Manipulating Tasks">Chapter 6</a>, <em>Manipulating Tasks</em>. In this chapter, we'll take a closer look at the filesystem and creating and deleting files. We'll see how data can be passed between different system processes, how to read files at maximum speed, and how to perform other tricks.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec101"/>Listing files in a directory</h1></div></div></div><p>There are<a id="id637" class="indexterm"/> STL functions and classes to read and write data to files. But there<a id="id638" class="indexterm"/> are no functions to list files in a directory, to get the type of a file, or to get access rights for a file.</p><p>Let's see how such iniquities can be fixed using Boost. We'll be creating a program that lists names, write accesses, and types of files in the current directory.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec404"/>Getting ready</h2></div></div></div><p>Some basics of C++ would be more than enough to use this recipe.</p><p>This recipe requires linking against the <code class="literal">boost_system</code> and <code class="literal">boost_filesystem</code> libraries.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec405"/>How to do it...</h2></div></div></div><p>This recipe and <a id="id639" class="indexterm"/>the next one are about portable wrappers for working with a filesystem:</p><div><ol class="orderedlist arabic"><li class="listitem">We need to include the following two headers:<div><pre class="programlisting">#include &lt;boost/filesystem/operations.hpp&gt;
#include &lt;iostream&gt;</pre></div></li><li class="listitem">Now we need to specify a directory:<div><pre class="programlisting">int main() {
    boost::filesystem::directory_iterator begin("./");</pre></div></li><li class="listitem">After specifying the directory, loop through its content:<div><pre class="programlisting">    boost::filesystem::directory_iterator end;
    for (; begin != end; ++ begin) {</pre></div></li><li class="listitem">The next step is getting the file info:<div><pre class="programlisting">        boost::filesystem::file_status fs =
            boost::filesystem::status(*begin);</pre></div></li><li class="listitem">Now output the file info:<div><pre class="programlisting">        switch (fs.type()) {
        case boost::filesystem::regular_file:
            std::cout &lt;&lt; "FILE       "; 
            break;
        case boost::filesystem::symlink_file:
            std::cout &lt;&lt; "SYMLINK    "; 
            break;
        case boost::filesystem::directory_file:
            std::cout &lt;&lt; "DIRECTORY  "; 
            break;
        default:
            std::cout &lt;&lt; "OTHER      "; 
            break;
        }
        if (fs.permissions() &amp; boost::filesystem::owner_write) {
            std::cout &lt;&lt; "W ";
        } else {
            std::cout &lt;&lt; "  ";
        }</pre></div></li><li class="listitem">The final step would be to output the filename:<div><pre class="programlisting">        std::cout &lt;&lt; *begin &lt;&lt; '\n';
    } /*for*/
} /*main*/</pre></div></li></ol></div><p>That's it. Now, if we run the program, it will output something like this:</p><div><pre class="programlisting">FILE W "./main.o"
FILE W "./listing_files"
DIRECTORY W "./some_directory"
FILE W "./Makefile"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec406"/>How it works...</h2></div></div></div><p>Functions and classes of <code class="literal">Boost.Filesystem</code>
<a id="id640" class="indexterm"/> just wrap around system-specific functions to work with files.</p><p>Note the <a id="id641" class="indexterm"/>usage of <code class="literal">/</code> in step 2. POSIX systems use a slash to specify paths; Windows, by default, uses backslashes. However, Windows understands forward slashes too, so <code class="literal">./</code> will work on all of the popular operating systems, and it means "the current directory".</p><p>Take a look at step 3, where we are default constructing the <code class="literal">boost::filesystem::directory_iterator</code> class. It works just as a <code class="literal">std::istream_iterator</code> class, which acts as an <code class="literal">end</code> iterator when default constructed.</p><p>Step 4 is a tricky one, not because this function is hard to understand, but because lots of conversions are happening. Dereferencing the <code class="literal">begin</code> iterator returns <code class="literal">boost::filesystem::directory_entry</code>, which is implicitly converted to <code class="literal">boost::filesystem::path</code>, which is used as a parameter for the <code class="literal">boost::filesystem::status</code> function. Actually, we can do much better:</p><div><pre class="programlisting">boost::filesystem::file_status fs = begin-&gt;status();</pre></div><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>Read the reference documentation carefully to avoid unrequired implicit conversions.</p></div></div><p>Step 5 is obvious, so we are moving to step 6 where implicit conversion to the path happens again. A better solution would be the following:</p><div><pre class="programlisting">std::cout &lt;&lt; begin-&gt;path() &lt;&lt; '\n';</pre></div><p>Here, <code class="literal">begin-&gt;path()</code> returns a const reference to the <code class="literal">boost::filesystem::path</code> variable that is contained inside <code class="literal">boost::filesystem::directory_entry</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec407"/>There's more...</h2></div></div></div><p>Unfortunately, <code class="literal">Boost.Filesystem</code> is not a part of C++11, but it is proposed for inclusion in the next C++ standard. <code class="literal">Boost.Filesystem</code> currently misses support for rvalue references, but still remains one of the simplest and most portable libraries to work with a filesystem.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec408"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Erasing and creating files and directories</em> recipe will show another example of the usage of <code class="literal">Boost.Filesystem</code>.</li><li class="listitem" style="list-style-type: disc">Read Boost's official documentation for <code class="literal">Boost.Filesystem</code> to get more info about its abilities; it is available at the following link:<p><a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm">http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm</a>.</p></li><li class="listitem" style="list-style-type: disc">The <code class="literal">Boost.Filesystem</code> library is proposed for inclusion in C++1y. The draft is available at <a class="ulink" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3399.h">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3399.html</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec102"/>Erasing and creating files and directories</h1></div></div></div><p>Let's consider the following lines of code:</p><div><pre class="programlisting">    std::ofstream ofs("dir/subdir/file.txt");
    ofs &lt;&lt; "Boost.Filesystem is fun!";</pre></div><p>In these lines,<a id="id642" class="indexterm"/> we attempt to write something to <code class="literal">file.txt</code> in the <code class="literal">dir/subdir</code> directory. This attempt will fail if there is no such directory. The ability to work with filesystems is necessary for write a good working code.</p><p>In this recipe we'll <a id="id643" class="indexterm"/>construct a directory and a subdirectory, write some data to a file, and try to create <code class="literal">symlink</code>, and if the symbolic link's creation fails, erase the created file. We will also avoid using exceptions as a mechanism of error reporting, preferring some form of return codes.</p><p>Let's see how that can be done in an elegant way using Boost.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec409"/>Getting ready</h2></div></div></div><p>Basic knowledge of C++ and the <code class="literal">std::ofstream</code> class is required for this recipe. <code class="literal">Boost.Filesystem</code> is not a header-only library, so code in this recipe requires linking against the <code class="literal">boost_system</code> and <code class="literal">boost_filesystem</code> libraries.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec410"/>How to do it...</h2></div></div></div><p>We continue to <a id="id644" class="indexterm"/>deal with portable wrappers for a filesystem, and in this recipe <a id="id645" class="indexterm"/>we'll see how to modify the directory content:</p><div><ol class="orderedlist arabic"><li class="listitem">As always, we'll need to include some headers:<div><pre class="programlisting">#include &lt;boost/filesystem/operations.hpp&gt;
#include &lt;cassert&gt;
#include &lt;fstream&gt;</pre></div></li><li class="listitem">Now we need a variable to store errors (if any):<div><pre class="programlisting">int main() {
    boost::system::error_code error;</pre></div></li><li class="listitem">We will also create directories, if required, as follows:<div><pre class="programlisting">    boost::filesystem::create_directories(
        "dir/subdir", error);
    assert(!error);</pre></div></li><li class="listitem">Then we will write data to the file:<div><pre class="programlisting">    std::ofstream ofs("dir/subdir/file.txt");
    ofs &lt;&lt; "Boost.Filesystem is fun!";
    assert(ofs);
    ofs.close();</pre></div></li><li class="listitem">We need to attempt to create <code class="literal">symlink</code>:<div><pre class="programlisting">    boost::filesystem::create_directory_symlink("dir/subdir", "symlink", error);</pre></div></li><li class="listitem">Then we need to check that the file is accessible through <code class="literal">symlink</code>:<div><pre class="programlisting">    if (!error) {
        std::cerr &lt;&lt; "Symlink created\n";
        assert(boost::filesystem::exists("symlink/file.txt"));</pre></div></li><li class="listitem">Or remove the created file, if <code class="literal">symlink</code> creation failed:<div><pre class="programlisting">    } else {
        std::cerr &lt;&lt; "Failed to create a symlink\n";
        boost::filesystem::remove("dir/subdir/file.txt", error);
        assert(!error);
    } /*if (!error)*/
} /*main*/</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec411"/>How it works...</h2></div></div></div><p>We saw <code class="literal">boost::system::error_code</code> in action in almost all of the recipes in , <em>Manipulating Tasks</em>. It can store information about errors and is widely used throughout the Boost libraries.</p><div><div><h3 class="title"><a id="note43"/>Note</h3><p>If you do not provide an instance of <code class="literal">boost::system::error_code</code> to the <code class="literal">Boost.Filesystem</code> functions, the code will compile well, but when an error occurs, an exception will be thrown. Usually a <code class="literal">boost::filesystem::filesystem_error</code> exception is thrown unless you are having trouble with allocating memory.</p></div></div><p>Take a <a id="id646" class="indexterm"/>careful <a id="id647" class="indexterm"/>look at step 3. We used the <code class="literal">boost::filesystem::create_directories</code> function, not <code class="literal">boost::filesystem::create_directory</code>, because the latter cannot create subdirectories.</p><p>The remaining steps are trivial to understand and should not cause any trouble.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec412"/>There's more...</h2></div></div></div><p>The <code class="literal">boost::system::error_code</code> class<a id="id648" class="indexterm"/> is a part of C++11 and can be found in the <code class="literal">&lt;system_error&gt;</code> header in the <code class="literal">std::</code> namespace. The classes of <code class="literal">Boost.Filesystem</code> are not a part of C++11, but they are proposed for inclusion in C++1y, which will probably be ready in 2014.</p><p>Finally, a small recommendation for those who are going to use <code class="literal">Boost.Filesystem</code>; when the errors occurring during filesystem operations are routine, use <code class="literal">boost::system::error_codes</code>. Otherwise, catching exceptions is preferable and more reliable.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec413"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Listing files in a directory</em> recipe also contains information about <code class="literal">Boost.Filesystem</code>. Read Boost's official documentation to get more information and examples at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm">http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec103"/>Passing data quickly from one process to another</h1></div></div></div><p>Sometimes we write <a id="id649" class="indexterm"/>programs that will communicate with each other a lot. When programs are run on different machines, using sockets is the most common technique for communication. But if multiple processes run on a single machine, we can do much better!</p><p>Let's take a look at how to make a single memory fragment available from different processes using the <a id="id650" class="indexterm"/>
<code class="literal">Boost.Interprocess</code> library.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec414"/>Getting ready</h2></div></div></div><p>Basic knowledge of C++ is required for this recipe. Knowledge of atomic variables is also required (take a look at the <em>See also</em> section for more information about atomics). Some platforms require linking against the runtime library.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec415"/>How to do it...</h2></div></div></div><p>In this example we'll be sharing a single atomic variable between processes, making it increment when a new process starts and decrement when the process terminates:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll need to include the following header for interprocess communications:<div><pre class="programlisting">#include &lt;boost/interprocess/managed_shared_memory.hpp&gt;</pre></div></li><li class="listitem">Following the header, <code class="literal">typedef</code> and a check will help us make sure that atomics are usable for this example:<div><pre class="programlisting">#include &lt;boost/atomic.hpp&gt;

typedef boost::atomic&lt;int&gt; atomic_t;
#if (BOOST_ATOMIC_INT_LOCK_FREE != 2)
#error "This code requires lock-free boost::atomic&lt;int&gt;"
#endif</pre></div></li><li class="listitem">Create or get a shared segment of memory:<div><pre class="programlisting">boost::interprocess::managed_shared_memory 
     segment(boost::interprocess::open_or_create, "shm-cache", 1024);</pre></div></li><li class="listitem">Get or construct an <code class="literal">atomic</code> variable:<div><pre class="programlisting">  atomic_t&amp; atomic 
      = *segment.find_or_construct&lt;atomic_t&gt; //1
          ("shm-counter") // 2
          (0)             // 3
  ;</pre></div></li><li class="listitem">Work with the <code class="literal">atomic</code> variable in the usual way:<div><pre class="programlisting">    std::cout &lt;&lt; "I have index " &lt;&lt; ++ atomic 
        &lt;&lt; "\nPress any key...";
    std::cin.get();</pre></div></li><li class="listitem">Destroy the <code class="literal">atomic</code> variable:<div><pre class="programlisting">    int snapshot = -- atomic;
    if (!snapshot) {
        segment.destroy&lt;atomic_t&gt;("shm-counter");
        boost::interprocess::shared_memory_object
                ::remove("shm-cache");
    }
} /*main*/</pre></div></li></ol></div><p>That's all! Now if we run multiple instances of this program simultaneously, we'll see that each new instance increments its index value.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec416"/>How it works...</h2></div></div></div><p>The main idea<a id="id651" class="indexterm"/> of this recipe is to get a segment of memory that is visible to all processes, and place some data in it. Let's take a look at step 3, where we retrieve such a segment of memory. Here, <code class="literal">shm-cache</code> is the name of the segment (different segments differ in name); you can give any names you like to the segments. The first parameter is <code class="literal">boost::interprocess::open_or_create</code>, which says that <code class="literal">boost::interprocess::managed_shared_memory</code> will open an existing segment with the name <code class="literal">shm-cache</code>, or it will construct it. The last parameter is the size of the segment.</p><div><div><h3 class="title"><a id="note44"/>Note</h3><p>The size of the segment must be big enough to fit the <code class="literal">Boost.Interprocess</code> library-specific data in it. That's why we used <code class="literal">1024</code> and not <code class="literal">sizeof(atomic_t)</code>. But it does not really matter, because the operating system will round this value to the nearest larger supported value, which is usually equal to or larger than 4 kilobytes.</p></div></div><p>Step 4 is a tricky one as we are doing multiple tasks at the same time here. In part <code class="literal">2</code> of this step, we will find or construct a variable with the name <code class="literal">shm-counter</code> in the segment. In part <code class="literal">3</code> of step 4, we will provide a parameter, which will be used for the initialization of a variable if it has not been found in step 2. This parameter will be used only if the variable is not found and must be constructed, otherwise it is ignored. Take a closer look at the second line (part <code class="literal">1</code>). See the call to the dereference operator <code class="literal">*</code>. We are doing it because <code class="literal">segment.find_or_construct&lt;atomic_t&gt;</code> returns a pointer to <code class="literal">atomic_t</code>, and working with bare pointers in C++ is a bad style.</p><div><div><h3 class="title"><a id="note45"/>Note</h3><p>Note that we are using atomic variables in shared memory! This is required, because two or more processes can simultaneously work with the same <code class="literal">shm-counter</code> atomic variable.</p></div></div><p>You must be very careful when working with objects in shared memory; do not forget to destroy them! In step 6, we are destroying the object and segment using their names.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec417"/>There's more...</h2></div></div></div><p>Take a closer look at step 2 where we are checking for <code class="literal">BOOST_ATOMIC_INT_LOCK_FREE != 2</code>. We are <a id="id652" class="indexterm"/>checking that <code class="literal">atomic_t</code> won't use mutexes. This is very important, because usually, mutexes won't work in shared memory. So if <code class="literal">BOOST_ATOMIC_INT_LOCK_FREE</code> is not equal to <code class="literal">2</code>, we'll get an undefined behavior.</p><p>Unfortunately, C++11 has no interprocess classes, and as far as I know, <code class="literal">Boost.Interprocess</code> is not proposed for inclusion in C++1y.</p><div><div><h3 class="title"><a id="note46"/>Note</h3><p>Once a managed segment is created, it cannot increase in size! Make sure that you are creating segments big enough for your needs, or take a look at the <em>See also</em> section for information about increasing managed segments.</p></div></div><p>Shared memory is the fastest way for processes to communicate, and works for processes that can share memory. That usually means that the processes must run on the same host or on a <a id="id653" class="indexterm"/>
<strong>symmetric multiprocessing</strong> (<strong>SMP</strong>) cluster.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec418"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Syncing interprocess communications</em> recipe will tell you more about shared memory, interprocess communications, and syncing access to resources in shared memory</li><li class="listitem" style="list-style-type: disc">See the <em>Fast access to common resource using atomics</em> recipe in Chapter 5, Multithreading for more information about atomics</li><li class="listitem" style="list-style-type: disc">Boost's official documentation for <code class="literal">Boost.Interprocess</code> may also help; it is available at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html">http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html</a></li><li class="listitem" style="list-style-type: disc">How to increase managed segments is described at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_advanced_features.growin">http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_advanced_features.growin</a><a class="ulink" href="http://g_managed_memory">g_managed_memory</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec104"/>Syncing interprocess communications</h1></div></div></div><p>In the previous<a id="id654" class="indexterm"/> recipe, we saw how to create shared memory and how to place some objects in it. Now it's time to do something useful. Let's take an example from the <em>Creating a work_queue class</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Multithreading">Chapter 5</a>, <em>Multithreading</em>, and make it work for multiple processes. At the end of this example, we'll get a class that can store different tasks and pass them between processes.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec419"/>Getting ready</h2></div></div></div><p>This recipe uses techniques from the previous one. You will also need to read the <em>Creating a work_queue class</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Multithreading">Chapter 5</a>, <em>Multithreading</em>, and get its main idea. The example requires linking against the runtime library on some platforms.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec420"/>How to do it...</h2></div></div></div><p>It is considered that spawning separate subprocesses instead of threads makes a program more reliable, because termination of a subprocess won't terminate the main process. We won't argue with that assumption here, and just see how data sharing between processes can be implemented.</p><div><ol class="orderedlist arabic"><li class="listitem">A lot of headers are required for this recipe:<div><pre class="programlisting">#include &lt;boost/interprocess/managed_shared_memory.hpp&gt;
#include &lt;boost/interprocess/containers/deque.hpp&gt;
#include &lt;boost/interprocess/allocators/allocator.hpp&gt;
#include &lt;boost/interprocess/sync/interprocess_mutex.hpp&gt;
#include &lt;boost/interprocess/sync/interprocess_condition.hpp&gt;
#include &lt;boost/interprocess/sync/scoped_lock.hpp&gt;

#include &lt;boost/optional.hpp&gt;</pre></div></li><li class="listitem">Now we need to define our structure, <code class="literal">task_structure</code>, which will be used to store tasks:<div><pre class="programlisting">struct task_structure {
    // ...
};</pre></div></li><li class="listitem">Let's start writing the <code class="literal">work_queue</code> class:<div><pre class="programlisting">class work_queue {
public:
    typedef task_structure task_type;
    typedef boost::interprocess::managed_shared_memory
        managed_shared_memory_t;

    typedef boost::interprocess::allocator&lt;
        task_type, 
        managed_shared_memory_t::segment_manager
    &gt; allocator_t;</pre></div></li><li class="listitem">Write the members of <code class="literal">work_queue</code> as follows:<div><pre class="programlisting">private:
    managed_shared_memory_t segment_;
    const allocator_t allocator_;

    typedef boost::interprocess::deque&lt;task_type, allocator_t&gt;
        deque_t;

    typedef boost::interprocess::interprocess_mutex mutex_t;
    typedef boost::interprocess::interprocess_condition
        condition_t;
    typedef boost::interprocess::scoped_lock&lt;mutex_t&gt;
        scoped_lock_t;

    deque_t&amp; tasks_;
    mutex_t&amp; mutex_;
    boost::interprocess::interprocess_condition&amp; cond_;</pre></div></li><li class="listitem">Initialization <a id="id655" class="indexterm"/>of members should look like the following:<div><pre class="programlisting">public:
    explicit work_queue()
        : segment_(
              boost::interprocess::open_or_create,
              "work-queue",
              1024 * 1024 * 64
        )
        , allocator_(segment_.get_segment_manager())
        , tasks_(
            *segment_.find_or_construct&lt;deque_t&gt;
              ("work-queue:deque")(allocator_)
        )
        , mutex_(
            *segment_.find_or_construct&lt;mutex_t&gt;
              ("work-queue:mutex")()
        )
        , cond_(
            *segment_.find_or_construct&lt;condition_t&gt;
              ("work-queue:condition")()
        )
    {}</pre></div></li><li class="listitem">We need to make some minor changes to the member functions of <code class="literal">work_queue</code>, such as using <code class="literal">scoped_lock_t</code> instead of the original unique locks:<div><pre class="programlisting">    boost::optional&lt;task_type&gt; try_pop_task() {
        boost::optional&lt;task_type&gt; ret;
        scoped_lock_t lock(mutex_);
        if (!tasks_.empty()) {
            ret = tasks_.front();
            tasks_.pop_front();
        }
        return ret;
    }</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec421"/>How it works...</h2></div></div></div><p>In this recipe, <a id="id656" class="indexterm"/>we are doing almost exactly the same things as in the <em>Creating a work_queue class</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Multithreading">Chapter 5</a>, <em>Multithreading</em>, but when we allocate the data in shared memory, additional care must be taken when doing memory allocations or using synchronization primitives.</p><p>Take additional care when storing shared memory objects that have pointers or references as member fields. We'll see how to cope with pointers in the next recipe.</p><p>Take a look at step 2. We did not use <code class="literal">boost::function</code> as a task type because it has pointers in it, so it won't work in shared memory.</p><p>Step 3 is interesting because of <code class="literal">allocator_t</code>. It is a type of allocator that all containers must use to allocate elements. It is a stateful allocator, which means that it will be copied along with the container. Also, it cannot be default constructed.</p><p>If memory is not allocated from the shared memory segment, it won't be available to other processes; that's why a specific allocator for containers is required.</p><p>Step 4 is pretty trivial, except that we have only references to <code class="literal">tasks_</code>, <code class="literal">mutex_</code>, and <code class="literal">cond_</code>. This is done because objects themselves are constructed in the shared memory. So, <code class="literal">work_queue</code> can only store references to them.</p><p>In step 5 we are initializing members. This code will be familiar to you; we were doing exactly the same things in the previous recipe. Note that we are providing an instance of allocator to <code class="literal">tasks_</code> while constructing it. That's because <code class="literal">allocator_t</code> cannot be constructed by the container itself.</p><div><div><h3 class="title"><a id="note47"/>Note</h3><p>Shared memory is not destructed at the exit event of a process, so we can run the program once, post the tasks to a work queue, stop the program, start some other program, and get tasks stored by the first instance of the program. Shared memory will be destroyed only at restart, or if you explicitly call <code class="literal">segment.deallocate("work-queue");</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec422"/>There's more...</h2></div></div></div><p>As was mentioned in the previous recipe, C++11 has no classes from <code class="literal">Boost.Interprocess</code>. Moreover, you must not use C++11 or C++03 containers in shared memory segments. Some of those containers may work, but that behavior is not portable.</p><p>If you look inside some of the <code class="literal">&lt;boost/interprocess/containers/*.hpp&gt;</code> headers, you'll find that they just use containers from the <code class="literal">Boost.Containers</code> library:</p><div><pre class="programlisting">namespace boost { namespace interprocess {
    using boost::container::vector;
}}</pre></div><p>Containers of <code class="literal">Boost.Interprocess</code>
<a id="id657" class="indexterm"/> have all of the benefits of the <code class="literal">Boost.Containers</code> library, including rvalue references and their emulation on older compilers.</p><p><code class="literal">Boost.Interprocess</code> is the fastest solution for communication between processes that are running on the same machine.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec423"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using pointers in shared memory</em> recipe</li><li class="listitem" style="list-style-type: disc">Read <a class="link" href="ch05.html" title="Chapter 5. Multithreading">Chapter 5</a>, <em>Multithreading</em>, for more information about synchronization primitives and multithreading</li><li class="listitem" style="list-style-type: disc">Refer to Boost's official documentation for the <code class="literal">Boost.Interprocess</code> library for more examples and information; it is available at the following link:<p><a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html">http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html</a></p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec105"/>Using pointers in shared memory</h1></div></div></div><p>It is hard to imagine<a id="id658" class="indexterm"/> writing some C++ core classes without pointers. Pointers and references are everywhere in C++, and they do not work in shared memory! So if <a id="id659" class="indexterm"/>we have a structure like this in shared memory and assign the address of some integer variable in shared memory to <code class="literal">pointer_</code>, we won't get the correct address in the other process that will attempt to use <code class="literal">pointer_</code> from that instance of <code class="literal">with_pointer</code>:</p><div><pre class="programlisting">struct with_pointer {
    int* pointer_;
    // ...
    int value_holder_;
};</pre></div><p>How can we fix that?</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec424"/>Getting ready</h2></div></div></div><p>The previous <a id="id660" class="indexterm"/>recipe is required for understanding <a id="id661" class="indexterm"/>this one. The example requires linking against the runtime system library on some platforms.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec425"/>How to do it...</h2></div></div></div><p>Fixing it is very simple; we need only to replace the pointer with <code class="literal">offset_ptr&lt;&gt;</code>:</p><div><pre class="programlisting">#include &lt;boost/interprocess/offset_ptr.hpp&gt;
struct correct_struct {
    boost::interprocess::offset_ptr&lt;int&gt; pointer_;
    // ...
    int value_holder_;
};</pre></div><p>Now we are free to use it as a normal pointer:</p><div><pre class="programlisting">correct_struct&amp; ref = *segment
    .construct&lt;correct_struct&gt;("structure")();

ref.pointer_ = &amp;ref.value_holder_;
assert(ref.pointer_ == &amp;ref.value_holder_);
assert(*ref.pointer_ == ref.value_holder_);

ref.value_holder_ = ethalon_value;
assert(*ref.pointer_ == ethalon_value);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec426"/>How it works...</h2></div></div></div><p>We cannot use pointers in shared memory because when a piece of shared memory is mapped into the address space of a process, its address is valid only for that process. When we are getting the address of a variable, it is just a local address for that process; other processes will map shared memory to a different base address, and as a result the variable address will differ.</p><div><img src="img/4880OS_11_01.jpg" alt="How it works..."/></div><p>So how can we work with an address that is always changing? There is a trick! As the pointer and <a id="id662" class="indexterm"/>structure are in the same shared memory segment, the distance between them does not change. The idea behind <code class="literal">boost::interprocess::offset_ptr</code> is to remember that distance, and on dereference, add the distance value to the process-dependent address of the <code class="literal">offset_ptr</code> variable.</p><p>The offset pointer imitates the behavior of pointers, so it is a drop-in replacement that can be applied fast.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Do not place classes that may have pointers or references into shared memory!</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec427"/>There's more...</h2></div></div></div><p>An offset pointer works slightly slower than the usual pointer because on each dereference, it is required to compute the address. But this difference is not usually sufficient to bother you.</p><p>C++11 has no offset pointers.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec428"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Boost's official documentation contains many examples and more advanced <code class="literal">Boost.Interprocess</code> features; it is available at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html">http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html</a></li><li class="listitem" style="list-style-type: disc">The <em>fastest way to read files</em> recipe contains information about some nontraditional usage of the <code class="literal">Boost.Interprocess</code> library</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec106"/>The fastest way to read files</h1></div></div></div><p>All around<a id="id663" class="indexterm"/> the Internet, people are asking "What is the fastest way to read files?". Let's make our task for this recipe even harder: "What is the fastest and most portable way to read binary files?"</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec429"/>Getting ready</h2></div></div></div><p>Basic knowledge of C++ and the <code class="literal">std::fstream</code> containers is required for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec430"/>How to do it...</h2></div></div></div><p>The technique from this recipe is widely used by applications critical to input and output performance.</p><div><ol class="orderedlist arabic"><li class="listitem">We'll need to include two headers from the <code class="literal">Boost.Interprocess</code> library:<div><pre class="programlisting">#include &lt;boost/interprocess/file_mapping.hpp&gt;
#include &lt;boost/interprocess/mapped_region.hpp&gt;</pre></div></li><li class="listitem">Now we need to open a file:<div><pre class="programlisting">const boost::interprocess::mode_t mode = boost::interprocess::read_only;
boost::interprocess::file_mapping fm(filename, mode);</pre></div></li><li class="listitem">The main part of this recipe is mapping all of the files to memory:<div><pre class="programlisting">boost::interprocess::mapped_region region(fm, mode, 0, 0);</pre></div></li><li class="listitem">Getting a pointer to the data in the file:<div><pre class="programlisting">const char* begin
   = reinterpret_cast&lt;const char*&gt;(region.get_address());</pre></div></li></ol></div><p>That's it! Now we can work with a file just as with normal memory:</p><div><pre class="programlisting">const char* pos = std::find(begin, begin + region.get_size(), '\1');</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec431"/>How it works...</h2></div></div></div><p>All popular operating systems have the ability to map a file to processes' address space. After such mapping is done, the process can work with those addresses just as with normal memory. The operating system will take care of all of the file operations, such as caching and read-ahead.</p><p>Why is it faster than traditional read/writes? That's because in most cases read/write is implemented as memory mapping and copying data to a user-specified buffer. So read usually does more work.</p><p>Just as in the <a id="id664" class="indexterm"/>case of STL, we must provide an open mode when opening a file. See step 2 where we provided the <code class="literal">boost::interprocess::read_only</code> mode.</p><p>See step 3 where we mapped a whole file at once. This operation is actually really fast, because the OS does not read data from the disk, but waits for the requests to be a part of the mapped region. After a part of the mapped region was requested, the OS loads that part of the file from the disk. As we can see, memory mapping operations are lazy, and the size of the mapped region does not affect performance.</p><div><div><h3 class="title"><a id="note48"/>Note</h3><p>However, a 32-bit OS cannot memory-map large files, so you'll need to map them in pieces. POSIX (Linux) operating systems require <code class="literal">_FILE_OFFSET_BITS=64</code> to be defined for the whole project to work with large files on a 32-bit platform. Otherwise, the OS won't be able to map parts of the file that are beyond 4 GB.</p></div></div><p>Now it's time to measure the performance:</p><div><pre class="programlisting">
<strong>$ TIME="%E" time ./reading_files m</strong>

<strong>mapped_region: 0:00.08</strong>


<strong>$ TIME="%E" time ./reading_files r</strong>

<strong>ifstream: 0:00.09</strong>

<strong>$ TIME="%E" time ./reading_files a</strong>

<strong>C:</strong>
<strong> 0:00.09</strong>
</pre></div><p>Just as expected, memory-mapped files are slightly faster than traditional reads. We can also see that pure C methods have the same performance as that of the C++ <code class="literal">std::ifstream</code> class, so please do not use functions related to <code class="literal">FILE*</code> in C++. They are just for C, not for C++!</p><p>For optimal performance of <code class="literal">std::ifstream</code>, do not forget to open files in binary mode and read data by blocks:</p><div><pre class="programlisting">std::ifstream f(filename, std::ifstream::binary);
// ...
char c[kilobyte];
f.read(c, kilobyte);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec432"/>There's more...</h2></div></div></div><p>Unfortunately, classes for memory mapping files are not part of C++11, and it looks like they won't be in C++14 either.</p><p>Writing to memory-mapped regions is also a very fast operation. The OS will cache the writes and won't flush modifications to the disc immediately. There is a difference between the OS and the <code class="literal">std::ofstream</code> data caching. If the <code class="literal">std::ofstream</code> data is cached by an application and it terminates, the cached data can be lost. When data is cached by the OS, termination of the application won't lead to data loss. Power failures and system crashes lead to data loss in both cases.</p><p>If multiple processes map a single file, and one of the processes modifies the mapped region, the changes are immediately visible to the other processes.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec433"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Boost</code>.<code class="literal">Interprocess</code> library contains a lot of useful features to work with the system; not all of them are covered in this book. You can read more about this great library at the official site:<p><a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/interproces">http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html</a></p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec107"/>Coroutines – saving the state and postponing the execution</h1></div></div></div><p>Nowadays, plenty <a id="id665" class="indexterm"/>of embedded devices still have only a single core. Developers write for those devices, trying to squeeze maximum performance out of them. Using <code class="literal">Boost.Threads</code> or some other thread library for such devices is not effective; the OS will be forced to schedule threads for execution, manage resources, and so on, as the hardware cannot run them in parallel.</p><p>So how can we make a program switch to the execution of a subprogram while waiting for some resource in the main part?</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec434"/>Getting ready</h2></div></div></div><p>Basic knowledge of C++ and templates is required for this recipe. Reading some recipes about <code class="literal">Boost.Function</code> may also help.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec435"/>How to do it...</h2></div></div></div><p>This recipe is about<a id="id666" class="indexterm"/> coroutines, subroutines<a id="id667" class="indexterm"/> that allow multiple entry points. Multiple entry points give us an ability to suspend and resume the execution of a program at certain locations, switching to/from other subprograms.</p><div><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">Boost.Coroutine</code> library<a id="id668" class="indexterm"/> will take care of almost everything. We just need to include its header:<div><pre class="programlisting">#include &lt;boost/coroutine/coroutine.hpp&gt;</pre></div></li><li class="listitem">Make<a id="id669" class="indexterm"/> a coroutine type with the required signature:<div><pre class="programlisting">typedef boost::coroutines::coroutine&lt; 
    std::string&amp;(std::size_t max_characters_to_process) 
&gt; corout_t;</pre></div></li><li class="listitem">Make a coroutine:<div><pre class="programlisting">void coroutine_task(corout_t::caller_type&amp; caller);

int main() {
    corout_t coroutine(coroutine_task);</pre></div></li><li class="listitem">Now we can execute the subprogram while waiting for an event in the main program:<div><pre class="programlisting">    // Doing some work
    // ...    
    while (!spinlock.try_lock()) {
        // We may do some useful work, before 
        // attempting to lock a spinlock once more
        coroutine(10); // Small delays
    }
    // Spinlock is locked

    // ...
    while (!port.block_ready()) {
        // We may do some useful work, before 
        // attempting to get block of data once more
        coroutine(300);  // Bigger delays
        std::string&amp; s = coroutine.get();
        // ...
    }</pre></div></li><li class="listitem">The coroutine method should look like this:<div><pre class="programlisting">void coroutine_task(corout_t::caller_type&amp; caller) {
    std::string result;

    // Returning back to main program
    caller(result);

    while (1) {
        std::size_t max_characters_to_process = caller.get();
        // Do process some characters
        // ...

        // Returning result, switching back
        // to main program
        caller(result);
    } /*while*/
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec436"/>How it works...</h2></div></div></div><p>At step 2, we <a id="id670" class="indexterm"/>are describing the signature of our subprogram using the function signature <code class="literal">std::string&amp; (std::size_t)</code> as a template parameter. This means that the subprogram accepts <code class="literal">std::size_t</code> and returns a reference to a string.</p><p>Step 3 is interesting because of the <code class="literal">coroutine_task</code> signature. Note that this signature is common for all coroutine tasks. <code class="literal">caller</code> is the variable that will be used to get parameters from the caller and to return the result of the execution back. </p><p>Step 3 requires additional care because the constructor of <code class="literal">corout_t</code> will automatically start the coroutine execution. That's why we call <code class="literal">caller(result)</code> at the beginning of the coroutine task (it returns us to the <code class="literal">main</code> method).</p><p>When we call <code class="literal">coroutine(10)</code> in step 4, we are causing a coroutine program to execute. Execution will jump to step 5 right after the first <code class="literal">caller(result)</code> method, where we'll get a value <code class="literal">10</code> from <code class="literal">caller.get()</code> and will continue our execution until <code class="literal">caller(result)</code>. After that, execution will return to step 4, right after the <code class="literal">coroutine(10)</code> call. Next, a call to <code class="literal">coroutine(10)</code> or <code class="literal">coroutine(300)</code> will continue the execution of the subprogram from the place right after the second <code class="literal">caller(result)</code> method at step 5.</p><div><img src="img/4880OS_11_02.jpg" alt="How it works..."/></div><p>Take a look at <code class="literal">std::string&amp; s = coroutine.get()</code> in step 4. Here, we'll be getting a reference to the <code class="literal">std::string</code> result from the beginning of <code class="literal">coroutine_task</code> described in step 5. We can<a id="id671" class="indexterm"/> even modify it, and <code class="literal">coroutine_task</code> will see the modified value. Let me describe the main difference between coroutines and threads. When a coroutine is executed, the main task does nothing. When the main task is executed, the coroutine task does nothing. You have no such guarantee with threads. With coroutines, you explicitly specify when to start a subtask and when to finish it. In a single core environment, threads can switch at any moment of time; you cannot control that behavior.</p><div><div><h3 class="title"><a id="note49"/>Note</h3><p>Do not use thread's local storage and do not call <code class="literal">boost::coroutines::coroutine&lt;&gt;::operator()</code> from inside the same coroutine; do not call <code class="literal">boost::coroutines::coroutine&lt;&gt;::get()</code> when a coroutine task is finished. These operations lead to undefined behavior.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec437"/>There's more...</h2></div></div></div><p>While switching threads, the OS does a lot of work, so it is not a very fast operation. However, with coroutines, you have full control over switching tasks; moreover, you do not need to do any OS-specific internal kernel work. Switching coroutines is much faster than switching threads, however, it's not as fast as calling <code class="literal">boost::function</code>.</p><p>The <a id="id672" class="indexterm"/>
<code class="literal">Boost.Coroutine</code> library will take care of calling a destructor for variables in a coroutine task, so there's no need to worry about leaks.</p><div><div><h3 class="title"><a id="note50"/>Note</h3><p>Coroutines use the <code class="literal">boost::coroutines::detail::forced_unwind</code> exception to free resources that are not derived from <code class="literal">std::exception</code>. You must take care not to catch that exception in coroutine tasks.</p></div></div><p>C++11 has no coroutines. But coroutines use features of C++11 when possible, and even emulate rvalue references on C++03 compilers. You cannot copy <code class="literal">boost::coroutines::coroutine&lt;&gt;</code>, but you can move them using <code class="literal">Boost.Move</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec438"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Boost's official documentation contains more examples, performance notes, restrictions, and use cases for the <code class="literal">Boost.Coroutines</code> library; it is available at the following link:<p><a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.htm">http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.htm</a></p></li><li class="listitem" style="list-style-type: disc">Take a look at recipes from <a class="link" href="ch03.html" title="Chapter 3. Managing Resources">Chapter 3</a>, <em>Managing Resources</em>, and <a class="link" href="ch05.html" title="Chapter 5. Multithreading">Chapter 5</a>, <em>Multithreading</em>, to get the difference between the <code class="literal">Boost.Coroutine</code>, <code class="literal">Boost.Thread</code>, and <code class="literal">Boost.Function</code> libraries</li></ul></div></div></div></body></html>