<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Qt GUI Programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Qt GUI Programming</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>This chapter will help you learn how to use Qt to develop applications with a graphical user interface using the Qt Creator IDE. We will get familiar with the core Qt functionality, property system, and the signals and slots mechanism that we will later use to create complex systems such as games. We will also cover the various actions and resource system of Qt. By the end of this chapter, you will be able to write your own programs that communicate with the user through windows and widgets.</em></span></p></blockquote></div><div class="section" title="Windows and dialogs"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Windows and dialogs</h1></div></div></div><p>The most basic <a id="id64" class="indexterm"/>skill that you need to learn is creating windows, showing them on a screen, and managing their content.</p><div class="section" title="Creating a Qt project"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Creating a Qt project</h2></div></div></div><p>The first step to <a id="id65" class="indexterm"/>develop an application with Qt Creator is to create a project using one of the templates provided by the editor.</p></div></div></div>
<div class="section" title="Time for action &#x2013; creating a Qt Desktop project"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Time for action – creating a Qt Desktop project</h1></div></div></div><p>When you <a id="id66" class="indexterm"/>first start Qt Creator, you will see a welcome screen. From the <span class="strong"><strong>File</strong></span> menu, choose <span class="strong"><strong>New File or Project</strong></span>. There are a number of project types to choose from. follow the given steps for creating a Qt Desktop project:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">For a widget-based application, choose the <span class="strong"><strong>Applications</strong></span> group and the <span class="strong"><strong>Qt Gui Application</strong></span> template:<div class="mediaobject"><img src="graphics/8874OS_03_01.jpg" alt="Time for action – creating a Qt Desktop project"/></div></li><li class="listitem">The next <a id="id67" class="indexterm"/>step is to choose a name and location for your new project:<div class="mediaobject"><img src="graphics/8874OS_03_02.jpg" alt="Time for action – creating a Qt Desktop project"/></div></li><li class="listitem">We are going to create a simple tic-tac-toe game, so we will name our project <code class="literal">tictactoe</code> and provide a nice location for it.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>If you have a common directory where you put all your projects, you can tick the <span class="strong"><strong>Use as default project location</strong></span> checkbox for Creator to remember the location and suggest it the next time when you start a new project.</p></div></div></li><li class="listitem">When you click on <span class="strong"><strong>Next</strong></span>, you will be presented with a window that lets you choose one or more of the defined compilation kits for the project. Proceed to the next step without changing anything. You will be presented with the option of creating the first widget for your project. Fill in the data as shown in the following <a id="id68" class="indexterm"/>screenshot:<div class="mediaobject"><img src="graphics/8874OS_03_03.jpg" alt="Time for action – creating a Qt Desktop project"/></div></li><li class="listitem">Then, click on <span class="strong"><strong>Next</strong></span> and <span class="strong"><strong>Finish</strong></span>.</li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>Creator created a new subdirectory in the directory that you previously chose for the location of the project and where you put a number of files. Two of these files (<code class="literal">tictactoewidget.h</code> and <code class="literal">tictactoewidget.cpp</code>) implement the <code class="literal">TicTacToeWidget</code> class as the subclass of <code class="literal">QWidget</code>. The third file called <code class="literal">main.cpp</code> contains code for the entry point of the application:</p><div class="informalexample"><pre class="programlisting">#include "tictactoewidget.h"
#include &lt;QApplication&gt;

int main(int argc, char *argv[]) {
  QApplication a(argc, argv);
  TicTacToeWidget w;
  w.show();
  return a.exec();
}</pre></div><p>This file creates an instance of the <code class="literal">QApplication</code> class and feeds it with standard arguments to the <code class="literal">main()</code> function. Then, it instantiates our <code class="literal">TicTacToeWidget</code> class, calls its <code class="literal">show</code> method, and finally returns a value returned by the <code class="literal">exec</code> method of the application object.</p><p>
<code class="literal">QApplication</code> is a singleton class that manages the whole application. In particular, it is responsible for processing events that come from within the application or from external sources. For events to be processed, an event loop needs to be running. The loop waits for incoming events and dispatches them to proper routines. Most things in Qt are done through events—input handling, redrawing, receiving data over the network, triggering timers, and so on. This is the reason we say that Qt is an event-oriented framework. Without an active event loop, nothing would function properly. The <code class="literal">exec</code> call in <code class="literal">QApplication</code> (or to be more specific, in its base class—<code class="literal">QCoreApplication</code>) is responsible for entering the main event loop of the application. The function does not return until your <a id="id69" class="indexterm"/>application requests the event loop to be terminated. When this eventually happens, the <code class="literal">main</code> function returns and your application ends.</p><p>The final file that was generated is called <code class="literal">tictactoe.pro</code> and is the project configuration file. It contains all the information that is required to build your project using the tools Qt provides. Let's analyze this file:</p><div class="informalexample"><pre class="programlisting">QT += core gui
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets
TARGET = tictactoe
TEMPLATE = app
SOURCES += main.cpp tictactoewidget.cpp
HEADERS += tictactoewidget.h</pre></div><p>The first two lines enable Qt's <code class="literal">core</code>, <code class="literal">gui</code>, and <code class="literal">widgets</code> modules. The next two lines specify that your project file describes an application (as opposed to, for example, a library) and declares the name of the target that is executable to be <code class="literal">tictactoe</code>. The last two lines add files that Creator generated for us to build the process.</p><p>What we have now is a complete minimal Qt GUI project. To build and run it, simply choose the <span class="strong"><strong>Run</strong></span> entry from the <span class="strong"><strong>Build</strong></span> drop-down menu or click on the green triangle icon on the left-hand side of the Qt Creator window. After a while, you should see a window pop up. Since we didn't add anything to the window, it is blank.</p></div><div class="section" title="Adding child widgets to a window"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Adding child widgets to a window</h2></div></div></div><p>After we <a id="id70" class="indexterm"/>managed to get a blank window on screen, the next step is to add some content to it. To do this, you need to create widgets and tell Qt to position them in the window. The basic way to do this is to provide a parent to a widget.</p><p>In Qt, we group objects (such as widgets) into parent-child relationships. This scheme is defined in the superclass of <code class="literal">QWidget</code>—<code class="literal">QObject</code>, which is the most important class in Qt, and we will cover it in more detail later in this chapter. What is important now is that each object can have a parent object and an arbitrary number of children. In the case of widgets, there is a rule that a child occupies a subarea of its parent. If it doesn't have a parent, then it becomes a top-level window that can usually be dragged around, resized, and closed. We can set a parent for an object in two ways. One way is to call the <code class="literal">setParent</code> method defined in <code class="literal">QObject</code> that accepts a <code class="literal">QObject</code> pointer. Because of the rule mentioned earlier, <code class="literal">QWidget</code> wants to have other widgets as parents, so the method is overloaded in <code class="literal">QWidget</code> to accept a <code class="literal">QWidget</code> pointer. The other way is to pass a pointer to the parent object to the <code class="literal">QWidget</code> constructor of the child object. If you look at the code of the widget that was generated by Creator, you will notice that the constructor also accepts a pointer to a widget as its last (optional) argument:</p><div class="informalexample"><pre class="programlisting">TicTacToeWidget::TicTacToeWidget(QWidget *parent)
    : QWidget(parent)
{
}</pre></div><p>It then passes that pointer to the constructor of its base class. Therefore, it is important that you always <a id="id71" class="indexterm"/>remember to create a constructor for your widgets that accepts a pointer to a <code class="literal">QWidget</code> instance and passes it up the inheritance tree. All standard Qt widgets also behave this way.</p><div class="section" title="Managing widget content"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec03"/>Managing widget content</h3></div></div></div><p>Making a <a id="id72" class="indexterm"/>widget display as part of its parent is not enough to make a good user interface. You also need to set its position and size and react to the changes that happen to its content and to the content of its parent widget. In Qt, we do this using a mechanism called layouts.</p><p>Layouts allow us to arrange the content of a widget, making sure that its space is used efficiently. When we set a layout on a widget, we can start adding widgets and even other layouts, and the mechanism will resize and reposition them according to the rules that we specify. When something happens in the user interface that influences how widgets should be displayed (for example, the button text is replaced with longer text, which makes the button require more space to show its content; if not, one of the widgets gets hidden), the layout is triggered again, which recalculates all positions and sizes and updates widgets as necessary.</p><p>Qt comes with a predefined set of layouts that are derived from the <code class="literal">QLayout</code> class, but you can also create your own. Those that we already have at our disposal are <code class="literal">QHBoxLayout</code> and <code class="literal">QVBoxLayout</code>, which position items horizontally and vertically; <code class="literal">QGridLayout</code>, which arranges items in a grid so that an item can span across columns or rows; and <code class="literal">QFormLayout</code>, which creates two columns of items with item descriptions in one column and item content in the other. There is also <code class="literal">QStackedLayout</code>, which is rarely used directly and which makes one of the items assigned to it possess all the available space. You can see the most common layouts in action in the following figure:</p><div class="mediaobject"><img src="graphics/8874OS_03_04.jpg" alt="Managing widget content"/></div><p>To use a layout, we <a id="id73" class="indexterm"/>need to create an instance of it and pass a pointer to a widget that we want it to manage. Then, we can start adding widgets to the layout:</p><div class="informalexample"><pre class="programlisting">QHBoxLayout *layout = new QHBoxLayout(parentWidget);
QPushButton *button1 = new QPushButton;
QPushButton *button2 = new QPushButton;
layout-&gt;addWidget(button1);
layout-&gt;addWidget(button2);</pre></div><p>We can even move widgets further from each other by setting spacing on the layout and setting custom margins on the layout:</p><div class="informalexample"><pre class="programlisting">layout-&gt;setSpacing(10);
layout-&gt;setMargins(10, 5, 10, 5); // left, top, right, bottom</pre></div><p>After building and running this code, you see two buttons that are evenly distributed in their parent space. Note that, even though we didn't explicitly pass the parent widget pointer, adding a widget to a layout makes it reparent the newly added widget to the widget that the layout manages. Resizing the parent horizontally would also cause buttons to resize again, covering all the space available. However, if you resize <code class="literal">parentWidget</code> vertically, buttons will change their position but not their height.</p><p>This is because each widget has an attribute called a size policy, which decides how a widget is to be resized by a layout. You can set separate size policies for horizontal and vertical directions. A button has a vertical size policy of <code class="literal">Fixed</code>, which means that the height of the widget will not change from the default height regardless of how much space there is available. The following are the available size policies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Ignore</code>: In this, the default size of the widget is ignored and the widget can freely grow and shrink</li><li class="listitem" style="list-style-type: disc"><code class="literal">Fixed</code>: In this, the default size is the only allowed size of the widget</li><li class="listitem" style="list-style-type: disc"><code class="literal">Preferred</code>: In this, the default size is the desired size, but both smaller and bigger sizes are acceptable</li><li class="listitem" style="list-style-type: disc"><code class="literal">Minimum</code>: In this, the default size is the smallest acceptable size for the widget, but the widget can be made larger without hurting its functionality</li><li class="listitem" style="list-style-type: disc"><code class="literal">Maximum</code>: In this, the default size is the largest size of the widget and the widget can be shrunk (even to nothing) without hurting its functionality</li><li class="listitem" style="list-style-type: disc"><code class="literal">Expanding</code>: In this, the default size is the desired size; a smaller size (even zero) is acceptable but the widget is able to increase its usefulness when more and more space is assigned to it</li><li class="listitem" style="list-style-type: disc"><code class="literal">MinimumExpanding</code>: This is a combination of <code class="literal">Minimum</code> and <code class="literal">Expanding</code>—the widget is greedy in terms of space and it cannot be made smaller than its default size</li></ul></div><p>How do we determine the <a id="id74" class="indexterm"/>default size? The answer is by the size returned by the <code class="literal">sizeHint</code> virtual method. For layouts, the size is calculated based on the sizes and size policies of their child widgets and nested layouts. For basic widgets, the value returned by <code class="literal">sizeHint</code> depends on the content of the widget. In the case of a button, if it holds a line of text and an icon, <code class="literal">sizeHint</code> will return the size that is required to fully encompass the text, icon, some space between them, the button frame, and the padding between the frame and content itself.</p></div></div></div>
<div class="section" title="Time for action &#x2013; implementing a tic-tac-toe game board"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Time for action – implementing a tic-tac-toe game board</h1></div></div></div><p>We will now <a id="id75" class="indexterm"/>create a widget that implements a <a id="id76" class="indexterm"/>game board for tic-tac-toe using buttons.</p><p>Open the <code class="literal">tictactoewidget.h</code> file in Creator and update it by adding the highlighted code:</p><div class="informalexample"><pre class="programlisting">#ifndef TICTACTOEWIDGET_H
#define TICTACTOEWIDGET_H
#include &lt;QWidget&gt;
<span class="strong"><strong>class QPushButton;</strong></span>

class TicTacToeWidget : public QWidget
{
  Q_OBJECT
  
public:
  TicTacToeWidget(QWidget *parent = 0);
  ~TicTacToeWidget();
<span class="strong"><strong>private:</strong></span>
<span class="strong"><strong>  QList&lt;QPushButton*&gt; board;</strong></span>
};
#endif // TICTACTOEWIDGET_H</pre></div><p>Our additions create a list that can hold pointers to instances of the <code class="literal">QPushButton</code> class, which is the most commonly used button class in Qt. It will represent our game board. We have to teach the compiler to understand the classes that we use; thus, we add a forward declaration of the <code class="literal">QPushButton</code> class.</p><p>The next step is to create a method that will help us create all the buttons and use a layout to manage their geometries. Go to the header file again and add a <code class="literal">void setupBoard();</code> declaration in the <code class="literal">private</code> section of the class. To quickly implement a freshly declared method, we can ask Qt Creator to create the skeleton code for us by positioning the text cursor just before after <a id="id77" class="indexterm"/>the method declaration (before the semicolon), pressing <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Enter</em></span> on the keyboard, and choosing <span class="strong"><strong>Add definition in tictactoewidget.cpp</strong></span> from the pop-up.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>It also works the other way around. You can write the method body first and then position the cursor on the method signature, press <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Enter</em></span>, and choose <span class="strong"><strong>Add public declaration</strong></span> from the quick fix menu. There are also various other context-dependent fixes that are available in Creator.</p></div></div><p>Because in the <a id="id78" class="indexterm"/>header file we only forward-declared <code class="literal">QPushButton</code>, we now need to provide a full class definition for it by including an appropriate header file. In Qt, all classes are declared in the header files that are called exactly the same as the classes themselves. Thus, to include a header file for <code class="literal">QPushButton</code>, we need to add a <code class="literal">#include &lt;QPushButton&gt;</code> line to the implementation file. We are also going to use the <code class="literal">QGridLayout</code> class to manage the space in our widget, so we need <code class="literal">#include &lt;QGridLayout&gt;</code> as well.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>From now on, this book will not remind you about adding the <code class="literal">include</code> directives to your source code—you will have to take care of this by yourself. This is really easy, just remember that to use a Qt class, you need to include a file named after that class.</p></div></div><p>Now, let's add the code to the body of the <code class="literal">setupBoard</code> method. First, let's create a layout that will hold our buttons:</p><div class="informalexample"><pre class="programlisting">QGridLayout *gridLayout = new QGridLayout;</pre></div><p>Then, we can start adding buttons to the layout:</p><div class="informalexample"><pre class="programlisting">for(int row = 0; row &lt; 3; ++row) {
  for(int column = 0; column &lt; 3; ++column) {
    QPushButton *button = new QPushButton;
    button-&gt;setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Minimum);
    button-&gt;setText(" ");
    gridLayout-&gt;addWidget(button, row, column);
    board.append(button);
  }
}</pre></div><p>The code creates a loop over rows and columns of the board. In each iteration, it creates an instance of the <code class="literal">QPushButton</code> class and sets the button's size policy to <code class="literal">Minimum</code>/<code class="literal">Minimum</code> so that when we resize the widget, buttons also get resized. A button is assigned a single space as its content so that it gets the correct initial size. Then, we add the button to the layout in <code class="literal">row</code> and <code class="literal">column</code>. At the end, we store the pointer to the button in the list that was declared earlier. This lets us reference any of the buttons later on. They are stored in the <a id="id79" class="indexterm"/>list in such an order that the first three buttons of the first row are stored first, then the buttons from the second row, and <a id="id80" class="indexterm"/>finally those from the last row.</p><p>The last thing to do is to tell our widget that <code class="literal">gridLayout</code> is going to manage its size:</p><div class="informalexample"><pre class="programlisting">setLayout(gridLayout);</pre></div><p>Alternatively, we might have passed this as a parameter to the layout's constructor.</p><p>Now that we have code that will prepare our board, we need to have it invoked somewhere. A good place to do this is the class constructor:</p><div class="informalexample"><pre class="programlisting">TicTacToeWidget::TicTacToeWidget(QWidget *parent)
        : QWidget(parent)
{
<span class="strong"><strong>  setupBoard();</strong></span>
}</pre></div><p>Now, build and run the program.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>You should get a window containing nine buttons positioned in a grid-like fashion. If you start resizing the window, the buttons are going to be resized as well. This is because we set a grid layout with three columns and three rows that evenly distributes widgets in the managed area, as shown in the following figure:</p><div class="mediaobject"><img src="graphics/8874OS_03_05.jpg" alt="What just happened?"/></div><p>While we're here, add another <code class="literal">public</code> method to the class and name it <code class="literal">initNewGame</code>. We will use this method to clear the board when a new game is started. The body of the method should look as follows:</p><div class="informalexample"><pre class="programlisting">void TicTacToeWidget::initNewGame() {
  for(int i=0; i&lt;9; ++i) board.at(i)-&gt;setText(" ");
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>You might have noticed that although we created a number of objects in <code class="literal">setupBoard</code> using the <code class="literal">new</code> operator, we didn't destroy those objects anywhere (for example, in the destructor). This is because of the way the memory is managed by Qt. Qt doesn't do any garbage collecting (as Java does), but it has this nice feature related to <code class="literal">QObject</code> parent-child hierarchies. The rule is that whenever a <code class="literal">QObject</code> instance is destroyed, it also deletes all its children. Since both the layout object <a id="id81" class="indexterm"/>and the buttons are the <a id="id82" class="indexterm"/>children of the <code class="literal">TicTacToeWidget</code> instance, they will all be deleted when the main widget is destroyed. This is another reason to set parents to the objects that we create—if we do this, we don't have to care about explicitly freeing any memory.</p></div></div></div></div>
<div class="section" title="Qt meta-objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Qt meta-objects</h1></div></div></div><p>Most of the <a id="id83" class="indexterm"/>special functionality that Qt offers revolves around the <code class="literal">QObject</code> class and the meta-object paradigm that we will take a closer look at now. The paradigm says that with every <code class="literal">QObject</code> subclass, there is a special object associated that contains information about that class. It allows us to make runtime queries to learn useful things about the class—the class name, superclass, constructors, methods, fields, enumerations, and so on. The meta-object is generated for the class at compile time when three conditions are met:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The class is a descendant of <code class="literal">QObject</code></li><li class="listitem" style="list-style-type: disc">It contains a special <code class="literal">Q_OBJECT</code> macro in a private section of its definition</li><li class="listitem" style="list-style-type: disc">Code of the class is preprocessed by a special <span class="strong"><strong>Meta-Object Compiler</strong></span> (<span class="strong"><strong>moc</strong></span>) tool</li></ul></div><p>We can comply to the first two conditions ourselves by writing proper code for the class just like Qt Creator does when we create a class derived from <code class="literal">QObject</code>. The last condition is met automatically when you use a tool chain that comes with Qt (and Qt Creator) to build your project. Then, it is enough to make sure that the file containing the class definition is added to the <code class="literal">HEADERS</code> variable of the project file and Qt will take care of the rest. What really happens is that moc generates some code for us that is later compiled in the main program.</p><p>All features discussed in <a id="id84" class="indexterm"/>this section of the chapter require a meta-object for the class. Therefore, it is essential to make sure that the three conditions I mentioned are met if you want a class to use any of those features.</p><div class="section" title="Signals and slots"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Signals and slots</h2></div></div></div><p>To trigger functionality as a response to something that happens in an application, Qt uses a mechanism of signals and slots. This is based on connecting a notification (which we call a <span class="strong"><strong>signal</strong></span>) about a change of state in some object with a function or method (called a <span class="strong"><strong>slot</strong></span>) that is executed when such a notification arises.</p><p>Signals and <a id="id85" class="indexterm"/>slots can be used with all classes that inherit <code class="literal">QObject</code>. A signal can be connected to a slot, member function, or functor (which includes a regular global function). When an object emits a signal, any of these entities that are connected to that signal will be called. A signal can also be connected to another signal in which case, emitting the first signal will make the other signal be emitted as well. You can connect any <a id="id86" class="indexterm"/>number of slots to a single signal and any number of signals to a single slot.</p><p>A signal slot connection is defined by the following four attributes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An object that changes its state (sender)</li><li class="listitem" style="list-style-type: disc">A signal in the sender object</li><li class="listitem" style="list-style-type: disc">An object that contains the function to be called (receiver)</li><li class="listitem" style="list-style-type: disc">A slot in the receiver</li></ul></div><p>To declare a signal, we put its declaration, that is, a regular member function declaration in a special class scope called signals. However, we don't implement such a function—this will be done automatically by moc. To declare a slot, we put the declaration in the class scope of either public slots, protected slots, or private slots. Slots are regular methods and can be called directly in code just like any other method. Contrary to signals, we need to provide bodies for slot methods.</p><p>A sample class implementing some signals and slots looks like as shown in the following code:</p><div class="informalexample"><pre class="programlisting">class ObjectWithSignalsAndSlots : public QObject {
  Q_OBJECT
public:
  ObjectWithSignalsAndSlots(QObject *parent = 0) : QObject(parent) {
  }
public slots:
  void setValue(int v) { … }
  void setColor(QColor c) { … }
private slots:
  void doSomethingPrivate();
signals:
  void valueChanged(int);
  void colorChanged(QColor);
};

void ObjectWithSignalsAndSlots::doSomethingPrivate() {
  // …
}</pre></div><p>Signals and slots can be connected and disconnected dynamically using the <code class="literal">connect()</code> and <code class="literal">disconnect()</code> statements.</p><p>The classic <code class="literal">connect</code> statement looks as follows:</p><div class="informalexample"><pre class="programlisting">connect(spinBox, SIGNAL(valueChanged(int)), dial, SLOT(setValue(int)));</pre></div><p>This statement <a id="id87" class="indexterm"/>establishes a connection between <code class="literal">SIGNAL</code> of the <code class="literal">spinBox</code> object <a id="id88" class="indexterm"/>called <code class="literal">valueChanged</code> that carries an <code class="literal">int</code> parameter and a <code class="literal">setValue</code> slot in the <code class="literal">dial</code> object that accepts an <code class="literal">int</code> parameter. It is forbidden to put variable names or values in a <code class="literal">connect</code> statement. You can only make a connection between a signal and slot that have matching signatures, which means that they accept the same types of arguments (any type casts are not allowed, and type names have to match exactly) with the exception that the slot can omit an arbitrary number of last arguments. Therefore, the following <code class="literal">connect</code> statement is valid:</p><div class="informalexample"><pre class="programlisting">connect(spinBox, SIGNAL(valueChanged(int)), lineEdit, SLOT(clear()));</pre></div><p>This is because the parameter of the <code class="literal">valueChanged</code> signal can be discarded before <code class="literal">clear</code> is called. However, the following statement is invalid:</p><div class="informalexample"><pre class="programlisting">connect(button, SIGNAL(clicked()), lineEdit, SLOT(setText(QString)));</pre></div><p>There is nowhere to get the value that is to be passed to <code class="literal">setText</code>, so such a connection will fail.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>It is important that you wrap signal and slot signatures into the <code class="literal">SIGNAL</code> and <code class="literal">SLOT</code> macros and that when you specify signatures, you only pass argument types and not values or variable names. Otherwise, the connection will fail.</p></div></div><p>Since Qt 5, there are a couple of different connect syntax available that don't require a meta-object for the class implementing the slot. The <code class="literal">QObject</code> legacy is still a requirement though, and the meta-object is still required for the class that emits the signal.</p><p>The first additional syntax that we can use is the one where we pass a pointer to the signal method and a pointer to the slot method instead of wrapping signatures in the <code class="literal">SIGNAL</code> and <code class="literal">SLOT</code> macros:</p><div class="informalexample"><pre class="programlisting">connect(button, &amp;QPushButton::clicked, lineEdit, &amp;QLineEdit::clear);</pre></div><p>In this situation, the <a id="id89" class="indexterm"/>slot can be any member function of any <code class="literal">QObject</code> subclass that <a id="id90" class="indexterm"/>has argument types that match the signal or such that can be converted to match the signal. This means that you can, for example, connect a signal carrying a double value with a slot taking an int parameter:</p><div class="informalexample"><pre class="programlisting">class MyClass : public QObject {
  Q_OBJECT
public:
  MyClass(QObject *parent = 0) : QObject(parent) {
<span class="strong"><strong>    connect(this, &amp;MyClass::somethingHappened, this, &amp;MyClass::setValue);</strong></span>
  }
  void setValue(int v) { … }
signals:
  void somethingHappened(double);
};</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>An important aspect is that you cannot freely mix meta-object-based and function-pointer-based approaches. If you decide to use pointers to member methods in a particular connection, you have to do that for both the signal and the slot.</p></div></div><p>We can even go a step further and have a signal connected to a standalone function:</p><div class="informalexample"><pre class="programlisting">connect(button, &amp;QPushButton::clicked, &amp;someFunction);</pre></div><p>If you use C++11, the function can also be a lambda expression in which case, it is possible to write the body of the slot directly in the <code class="literal">connect</code> statement:</p><div class="informalexample"><pre class="programlisting">connect(pushButton, SIGNAL(clicked()), []() { std::cout &lt;&lt; "clicked!" &lt;&lt; std::endl; });</pre></div><p>It is especially useful if you want to invoke a slot with a fixed argument value that can't be carried by a signal because it has less arguments. A solution is to invoke the slot from a lambda function (or a standalone function):</p><div class="informalexample"><pre class="programlisting">connect(pushButton, SIGNAL(clicked()), [label]() { label-&gt;setText("button was clicked"); });</pre></div><p>A function can even be replaced with a function object (functor). To do this, we create a class for which we overload the call operator that is compatible with the signal that we wish to connect to, as shown in the following snippet:</p><div class="informalexample"><pre class="programlisting">class Functor {
public:
  Functor(Object *object, const QString &amp;str) : m_object(object), m_str(str) {}
  void operator()(int x, int y) const {
    m_object-&gt;set(x, y, m_str);
  }
private:
  Object *m_object;
  QString m_str;
};

connect(obj1, SIGNAL(coordChanged(int, int)), Functor("Some Text"));</pre></div><p>This is often a nice <a id="id91" class="indexterm"/>way to execute a slot with an additional parameter that is not <a id="id92" class="indexterm"/>carried by the signal, as this is much cleaner than using a lambda expression.</p><p>There are some aspects of signals and slots that we have not covered here. We will come back to them later when we deal with multithreading.</p></div><div class="section" title="Pop quiz – making signal-slot connections"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Pop quiz – making signal-slot connections</h2></div></div></div><p>Q1. For <a id="id93" class="indexterm"/>which of the following do you have to provide your own implementation?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A signal</li><li class="listitem">A slot</li><li class="listitem">Both</li></ol></div><p>Q2. Which of the following statements are valid?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">connect(sender, SIGNAL(textEdited(QString)), receiver, SLOT(setText("foo")))</code></li><li class="listitem"><code class="literal">connect(sender, SIGNAL(toggled(bool)), receiver, SLOT(clear()));</code></li><li class="listitem"><code class="literal">connect(sender, SIGNAL(valueChanged(7)), receiver, SLOT(setValue(int)));</code></li><li class="listitem"><code class="literal">connect(sender, &amp;QPushButton::clicked, receiver, &amp;QLineEdit::clear);</code></li></ol></div></div></div>
<div class="section" title="Time for action &#x2013; functionality of a tic-tac-toe board"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Time for action – functionality of a tic-tac-toe board</h1></div></div></div><p>We need to <a id="id94" class="indexterm"/>implement a function that will be called upon by clicking on any of the nine buttons on the board. It has to change the text of the button that was clicked on—either <code class="literal">X</code> or <code class="literal">O</code>—based on which player made the move; then, it has to check whether the move resulted in winning the game by the player (or a draw if no more moves are possible), and if the game ended, it should emit an appropriate signal, informing the environment about the event.</p><p>When the user clicks on a button, the <code class="literal">clicked()</code> signal is emitted. Connecting this signal to a custom slot lets us implement the mentioned functionality, but since the signal doesn't carry any parameters, how do we tell which button caused the slot to be triggered? We could connect each button to a separate slot but that's an ugly solution. Fortunately, there are two ways of working around this problem. When a slot is invoked, a pointer to the object that caused the signal to be sent is accessible through a special method in <code class="literal">QObject</code> called <code class="literal">sender()</code>. We can use that pointer to find out which of the nine buttons stored in the board list is the one that caused the signal to fire:</p><div class="informalexample"><pre class="programlisting">void TicTacToeWidget::someSlot() {
<span class="strong"><strong>  QObject *btn = sender();</strong></span>
  int idx = board.indexOf(btn);
  QPushButton *button = board.at(idx);
  // ...
}</pre></div><p>While <code class="literal">sender()</code> is a useful call, we should try to avoid it in our own code as it breaks some principles of object-oriented programming. Moreover, there are situations where calling this function is not safe. A better way is to use a dedicated class called <code class="literal">QSignalMapper</code>, which lets us achieve a similar result without using <code class="literal">sender()</code> directly. Modify the <code class="literal">setupBoard()</code> method in <code class="literal">TicTacToeWidget</code> as follows:</p><div class="informalexample"><pre class="programlisting">QGridLayout *gridLayout = new QGridLayout;
<span class="strong"><strong>QSignalMapper *mapper = new QSignalMapper(this);</strong></span>
for(int row = 0; row &lt; 3; ++row) {
  for(int column = 0; column &lt; 3; ++column) {
    QPushButton *button = new QPushButton;
    button-&gt;setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Minimum);
    button-&gt;setText(" ");
    gridLayout-&gt;addWidget(button, row, column);
    board.append(button);
<span class="strong"><strong>    mapper-&gt;setMapping(button, board.count()-1);</strong></span>
<span class="strong"><strong>    connect(button, SIGNAL(clicked()), mapper, SLOT(map()));</strong></span>
  }
}
<span class="strong"><strong>connect(mapper, SIGNAL(mapped(int)), this, SLOT(handleButtonClick(int)));</strong></span>
setLayout(gridLayout);</pre></div><p>Here, we first created an instance of <code class="literal">QSignalMapper</code> and passed a pointer to the board widget as its parent so that the mapper is deleted when the widget is deleted. Then, when we create buttons, we "teach" the mapper that each of the buttons has a number associated with it—the first button will have the number <code class="literal">0</code>, the second one will be bound to the number <code class="literal">1</code>, and so on. By connecting the <code class="literal">clicked()</code> signal from the button to mapper's <code class="literal">map()</code> slot, we tell the mapper to do its magic upon receiving that signal. What the mapper will do is that it will then find the mapping of the sender of the signal and emit another signal—<code class="literal">mapped()</code>—with the mapped number as its parameter. This allows us to connect to that signal with a slot (<code class="literal">handleButtonClick</code>) that takes the index of the button in the board list.</p><p>Now it is time to <a id="id95" class="indexterm"/>implement the slot itself (remember to declare it in the header file!). However, before we do that, let's add a useful enum and a few helper methods to the class:</p><div class="informalexample"><pre class="programlisting">enum Player {
  Invalid, Player1, Player2, Draw
};</pre></div><p>This enum lets us specify information about players in the game. We can use it immediately to mark whose move it is now. To do so, add a private field to the class:</p><div class="informalexample"><pre class="programlisting">Player m_currentPlayer;</pre></div><p>Then, add the two public methods to manipulate the value of this field:</p><div class="informalexample"><pre class="programlisting">Player currentPlayer() const { return m_currentPlayer; }
void setCurrentPlayer(Player p) {
  if(m_currentPlayer == p) return;
  m_currentPlayer = p;
  emit currentPlayerChanged(p);
}</pre></div><p>The last method emits a signal, so we have to add the signal declaration to the class definition along with another signal that we are going to use:</p><div class="informalexample"><pre class="programlisting">signals:
<span class="strong"><strong>  void currentPlayerChanged(Player);</strong></span>
<span class="strong"><strong>  void gameOver(TicTacToeWidget::Player);</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>Note that we only emit the <code class="literal">currentPlayerChanged</code> signal when the current player really changes. You always have to pay attention that you don't emit a "changed" signal when you set a value to a field to the same value that it had before the function was called. Users of your classes expect that if a signal is called changed, it is emitted when the value really changes. Otherwise, this can lead to an infinite loop in signal emissions if you have two objects that connect their value setters to the other object's changed signal.</p></div></div><p>Now let's <a id="id96" class="indexterm"/>declare the <code class="literal">handleButtonClick</code> slot:</p><div class="informalexample"><pre class="programlisting">public slots:
    void handleButtonClick(int);</pre></div><p>And then implement it in the <code class="literal">.cpp </code>file:</p><div class="informalexample"><pre class="programlisting">void TicTacToeWidget::handleButtonClick(int index) {
  if(index &lt; 0 || index &gt;= board.size()) return; // out of bounds check
  QPushButton *button = board.at(index);
  if(button-&gt;text() != " ") return; // invalid move
  button-&gt;setText(currentPlayer() == Player1 ? "X" : "O");
  Player winner = checkWinCondition(index / 3, index % 3);
  if(winner == Invalid) {
    setCurrentPlayer(currentPlayer() == Player1 ? Player2 : Player1);
    return;
  } else {
    emit gameOver(winner);
  }
}</pre></div><p>Here, we first retrieve a pointer to the button based on its index. Then, we check whether the button contains any text—if so, then this means that it doesn't participate in the game anymore, so we return from the method so that the player can pick another field in the board. Next, we set the current player's mark on the button. Then, we check whether the player has won the game, passing it the row (<code class="literal">index / 3</code>) and column (<code class="literal">index % 3</code>) index of the current move. If the game didn't end, we switch the current player and return. Otherwise, we emit a <code class="literal">gameOver()</code> signal, telling our environment who won the game. The <code class="literal">checkWinCondition()</code> method returns <code class="literal">Player1</code>, <code class="literal">Player2</code>, or <code class="literal">Draw</code> if the game has ended and <code class="literal">Invalid</code> otherwise. We will not show the implementation of this method here as it is quite complex. Try implementing it on your own and if you encounter problems, you can see the solution in the code bundle that accompanies this book.</p><div class="section" title="Properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Properties</h2></div></div></div><p>Apart from signals and slots, Qt <a id="id97" class="indexterm"/>meta-objects also give programmers an ability to use the so-called properties that are essentially named attributes that can be assigned values of a particular type. They are useful to express important features of an <a id="id98" class="indexterm"/>object—like text of a button, size of a widget, player names in games, and so on.</p><div class="section" title="Declaring a property"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec04"/>Declaring a property</h3></div></div></div><p>To create a property, we <a id="id99" class="indexterm"/>first need to declare it in a private section of a class that inherits <code class="literal">QObject</code> using a special <code class="literal">Q_PROPERTY</code> macro, which lets Qt know how to use the property. A minimal declaration contains the type of the property, its name, and information about a method name that is used to retrieve a value of the property. For example, the following code declares a property of the type <code class="literal">double</code> that is called <code class="literal">height</code> and uses a method called <code class="literal">height</code> to read the property value:</p><div class="informalexample"><pre class="programlisting">Q_PROPERTY(double height READ height)</pre></div><p>The getter method has to be declared and implemented as usual. Its prototype has to comply with these rules: it has to be a public method that returns a value or constant reference of a type of the property, and it can't take any input parameters and the method itself has to be constant. Typically, a property will manipulate a private member variable of the class:</p><div class="informalexample"><pre class="programlisting">class Tower : public QObject {
  Q_OBJECT // enable meta-object generation
  Q_PROPERTY(double height READ height) // declare the property
  public:
    Tower(QObject *parent = 0) : QObject(parent) { m_height = 6.28; }
    double height() const { return m_height; } // return property value
  private:
    double m_height; // internal member variable holding the property value
};</pre></div><p>Such a property is practically useless because there is no way to change its value. Luckily, we can extend the declaration to include the information about how to write a value to the property:</p><div class="informalexample"><pre class="programlisting">Q_PROPERTY(double height READ height WRITE setHeight)</pre></div><p>Again, we have to declare and implement <code class="literal">setHeight</code> so that it behaves as the setter method for the property—it needs to be a public method that takes a value or constant reference of the type of the property and returns void:</p><div class="informalexample"><pre class="programlisting">void setHeight(double newHeight) { m_height = newHeight; }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>Property setters are good candidates for public slots so that you can easily manipulate property values using signals and slots.</p></div></div><p>We will learn about some <a id="id100" class="indexterm"/>of the other extensions to <code class="literal">Q_PROPERTY</code> declarations in the later chapters of this book.</p></div><div class="section" title="Using a property"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec05"/>Using a property</h3></div></div></div><p>There are two ways in <a id="id101" class="indexterm"/>which you can access properties. One is of course, to use getter and setter methods that we declared with <code class="literal">READ</code> and <code class="literal">WRITE</code> keywords in the <code class="literal">Q_PROPERTY</code> macro—this will naturally work since they are regular C++ methods.</p><p>The other way is to use facilities offered by <code class="literal">QObject</code> and the meta-object system. They allow to us access properties by name using two methods that accept property names as strings. A generic property getter (which returns the property value) is a method called <code class="literal">property</code>. Its setter counterpart (that takes the value and returns void) is <code class="literal">setProperty</code>. Since we can have properties with different data types, what is the data structure that is used by those two methods that hold values for different kinds of properties? Qt has a special class for this called <code class="literal">QVariant</code>, which behaves a lot like a C union in the way that it can store values of different types. There are a couple of advantages to using a union though—the three most important are that you can ask the object what type of data it currently holds, you can convert some of the types to other types (for example, a string to an integer), and you can teach it to operate on your own custom types.</p></div></div></div>
<div class="section" title="Time for action &#x2013; adding properties to the board class"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Time for action – adding properties to the board class</h1></div></div></div><p>In this exercise, we <a id="id102" class="indexterm"/>will be adding a useful property to the board class. The property is going to hold information about the player who should make the next move. The type of the property is going to be the <code class="literal">TicTacToeWidget::Player</code> enumeration that we created earlier. For the getter and the setter methods, we are going to use the two functions that we created earlier: <code class="literal">currentPlayer()</code> and <code class="literal">setCurrentPlayer()</code>.</p><p>Open the header file for our class and modify the class definition as shown in the following code:</p><div class="informalexample"><pre class="programlisting">class TicTacToeWidget : public QWidget {
  Q_OBJECT
<span class="strong"><strong>  Q_ENUMS(Player)</strong></span>
<span class="strong"><strong>  Q_PROPERTY(Player currentPlayer READ currentPlayer</strong></span>
<span class="strong"><strong>  WRITE setCurrentPlayer</strong></span>
<span class="strong"><strong>  NOTIFY currentPlayerChanged)</strong></span>
public:
  enum Player { Invalid, Player1, Player2, Draw };</pre></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>Since we want to use an enumeration as a type of a property, we have to inform Qt's meta-object system about the enum. This is done with the <code class="literal">Q_ENUMS</code> macro. Then, we declare a property called <code class="literal">currentPlayer</code> and mark our two existing methods as getter and setter for the <a id="id103" class="indexterm"/>property. We also use the <code class="literal">NOTIFY</code> keyword to mark <code class="literal">currentPlayerChanged</code> as a signal that is sent to inform about a change in the value of the property. We won't be using this extra information in our small game, and we don't require <code class="literal">currentPlayer</code> to be a property at all, but it is always a good idea to try and find good candidates for properties and expose them because some day, someone might want to use our class in a way we hadn't predicted and a particular property might become useful.</p></div></div>
<div class="section" title="Designing GUIs"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Designing GUIs</h1></div></div></div><p>So far, we have <a id="id104" class="indexterm"/>coded all the user interfaces manually by writing C++ code that instantiates widgets, arranges them in layouts, and connects signals to slots. It is not that hard for simple widgets, but becomes tedious and time-consuming when the UI becomes more and more complex. Fortunately, Qt provides tools to do all this in a more pleasant way. Instead of writing C++ code, we can create forms using a graphical tool by dragging and dropping widgets on a canvas, applying layouts to them, and even establishing signal-slot connections using the point-and-click technique. Later during the compilation, such forms will get converted into C++ code for us and will be ready for applying onto a widget.</p><p>The tool is called Qt <a id="id105" class="indexterm"/>Designer and is integrated with Qt Creator. To use it, select <span class="strong"><strong>New File</strong></span> or <span class="strong"><strong>Project</strong></span> from the <span class="strong"><strong>File</strong></span> menu and choose the <span class="strong"><strong>Qt Designer Form Class</strong></span> template available after selecting Qt in the <span class="strong"><strong>Files and Classes</strong></span> section of the dialog box. You get to choose a template for the form and configure details such as the names of the files to create. In the end, three files will get created—two of them implement a C++ class derived from <code class="literal">QWidget</code> or one of its subclasses and the last one contains data for the form itself.</p><p>After closing the wizard, we are taken to Qt Creator's <span class="strong"><strong>Design</strong></span> mode that looks as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8874OS_03_06.jpg" alt="Designing GUIs"/></div><p>The <span class="strong"><strong>Design</strong></span> mode consists of four major parts that are marked on the preceding figure with numbers.</p><p>The area marked as <span class="strong"><strong>1</strong></span> is the main worksheet. It contains a graphical representation of the form being designed where you can move widgets around, compose them into layouts, and see how they react. It also allows further manipulation of the form using the point-and-click method that we will learn later.</p><p>The second area <span class="strong"><strong>2</strong></span> is the widget box. It contains a list of available types of widget that are arranged into groups containing items with a related or similar functionality. Over the list, you can see a box that lets you filter widgets that are displayed in the list to only show those that match the <a id="id106" class="indexterm"/>entered expression. In the beginning of the list, there are also items that are not really widgets—one group contains layouts and the other one contains so-called spacers, which are a way to push other items away from each other.</p><p>The main purpose of the widget box is to add widgets to the form in the worksheet. You can do that by grabbing a widget from the list with the mouse, dragging it to the canvas, and releasing the mouse button. The widget will appear in the form and can be further manipulated with further tools in Creator's Design mode.</p><p>The next area <span class="strong"><strong>3</strong></span>, which we are going to talk about, is situated on the right-hand side of the window and consists of two parts. At the top of the figure, you can see Object Inspector. It presents the parent-child relationship of all widgets that are currently present in the edited form. Each line contains the name of the object and the name of its class as seen by the meta-object system. If you click on an entry, a corresponding widget in the form gets selected (and vice versa).</p><p>The lower part of the figure shows the property editor. You can use it to change the values of all the properties that each object has. Properties are grouped by their classes that they have been declared in, starting from <code class="literal">QObject</code> (the base class implementing properties), which declares only one but an important property—<code class="literal">objectName</code>. Following <code class="literal">QObject</code>, there are properties declared in <code class="literal">QWidget</code>, which is a direct descendant of <code class="literal">QObject</code>. They are mainly related to the geometry and layout policies of the widget. Lower in the list, you can find properties that come from further derivations of <code class="literal">QWidget</code>. If you prefer a pure alphabetical order where properties are not grouped by their class, you can switch the view using a pop-up menu that becomes available after you click on the wrench icon positioned over the property list; however, once you get familiar with the hierarchy of Qt classes, it will be much easier to navigate the list when it is sorted by a class.</p><p>Having a closer look at the <a id="id107" class="indexterm"/>property editor, you can see that some of them have arrows beneath them that reveal new rows when clicked. These are composed properties where the complete property value is determined from more than one subproperty values; for example, if there is a property called <code class="literal">geometry</code> that defines a rectangle, it can be expanded to show four subproperties: <code class="literal">x</code>, <code class="literal">y</code>, <code class="literal">width</code>, and <code class="literal">height</code>. Another thing that you should quickly notice is that some property names are displayed in bold. This means that the property value was modified and is different from the default value for this property. This lets you quickly find those properties that you have modified.</p><p>The last group of functionality <span class="strong"><strong>4</strong></span> that we will explain now is the one positioned in the lower part of the window. By default, you will see two tabs—<span class="strong"><strong>Action Editor</strong></span> and <span class="strong"><strong>Signal/Slot Editor</strong></span>. They allow us to create helper entities such as actions for the menus and toolbars or signal-slot connections between widgets using a clean tabular interface.</p><p>What was described here is the basic tool layout. If you don't like it, you can invoke the context menu from the main worksheet, uncheck the <span class="strong"><strong>Locked</strong></span> entry, and rearrange all the windows to your liking or even close the ones you currently don't need.</p></div>
<div class="section" title="Time for action &#x2013; designing the game configuration dialog"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Time for action – designing the game configuration dialog</h1></div></div></div><p>Now, we will <a id="id108" class="indexterm"/>use Qt Designer forms to build a simple game configuration dialog that will let us choose names for our players.</p><p>First, invoke the new file dialog from the menu and choose to create a new <span class="strong"><strong>Qt Designer Form Class</strong></span> as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8874OS_03_07.jpg" alt="Time for action – designing the game configuration dialog"/></div><p>In the window <a id="id109" class="indexterm"/>that appears, choose <span class="strong"><strong>Dialog with Buttons Bottom</strong></span>:</p><div class="mediaobject"><img src="graphics/8874OS_03_08.jpg" alt="Time for action – designing the game configuration dialog"/></div><p>Adjust the class name to <code class="literal">ConfigurationDialog</code>, leave the rest of the settings at their default values, and complete the wizard.</p><p>Drag and drop two labels and two line edits on the form, position them roughly in a grid, double-click on <a id="id110" class="indexterm"/>each of the labels, and adjust their captions to receive a result similar to the following figure:</p><div class="mediaobject"><img src="graphics/8874OS_03_09.jpg" alt="Time for action – designing the game configuration dialog"/></div><p>Select the first line to edit and look at the property editor. Find a property called <code class="literal">objectName</code> and change it to <code class="literal">player1Name</code>. Do the same for the other line and call it <code class="literal">player2Name</code>. Then, click on some empty space in the form and choose the <span class="strong"><strong>Layout in a grid</strong></span> entry in the upper toolbar. You should see the widgets snap into place—that's because you have just applied a layout to the form. When you're done, open the <span class="strong"><strong>Tools</strong></span> menu, go to the <span class="strong"><strong>Form Editor</strong></span> submenu, and choose the <span class="strong"><strong>Preview</strong></span> entry.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>You can see a new window open that looks exactly like the form we just designed. You can resize the window and interact with the objects inside to monitor the behavior of the layouts and widgets. What really happened here is that Qt Creator built a real window for us based on the description that we provided in all the areas of the design mode. Without any compilation, in a blink of an eye we received a fully working window with all the layouts working and all the properties adjusted to our liking. This is a very important tool so make sure to use it often to verify that your layouts are controlling all the widgets as you intended them to—it is much faster than compiling and running the whole application just to check whether the widgets stretch or squeeze properly. It's all possible thanks to Qt's meta-object system.</p></div></div>
<div class="section" title="Time for action &#x2013; polishing the dialog"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Time for action – polishing the dialog</h1></div></div></div><p>Now that the <a id="id111" class="indexterm"/>GUI itself works as we intended it to, we can focus on giving the dialog some more polish.</p><div class="section" title="Accelerators and label buddies"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Accelerators and label buddies</h2></div></div></div><p>The first <a id="id112" class="indexterm"/>thing we are going to do is add accelerators to our widgets. These are keyboard shortcuts that, when activated, cause particular widgets to gain keyboard focus or <a id="id113" class="indexterm"/>perform a predetermined action (for example, toggle a <a id="id114" class="indexterm"/>checkbox or push a button). Accelerators are usually marked by underlining them, as shown in the following figure:</p><div class="mediaobject"><img src="graphics/8874OS_03_10.jpg" alt="Accelerators and label buddies"/></div><p>We will set accelerators to our line edits so that when the user activates an accelerator for the first field, it will gain focus. Through this we can enter the name of the first player, and similarly, when the accelerator for the second line edit is triggered, we can start typing in the name for the second player.</p><p>Start by selecting the label on the left-hand side of the first line edit. Press <span class="emphasis"><em>F2</em></span> or double-click on the label (alternatively, find the text property of the label in the property editor and activate its value field). This enables us to change the text of the label. Navigate using cursor keys so that the text cursor is placed before the character <code class="literal">1</code> and type the <code class="literal">&amp;</code> character. This character marks the character directly after it as an accelerator for the widget. For widgets that are composed of both text and the actual functionality (for example, a button), this is enough to make accelerators work. However, since <code class="literal">QLineEdit</code> does not have any text associated with it, we have to use a separate widget for that. This is why we have set the <a id="id115" class="indexterm"/>accelerator on the label. Now, we need to associate the label with the <a id="id116" class="indexterm"/>line edit so that the activation of the label's accelerator will forward it to the widget of our choice. This is done by setting a so-called buddy for the label. You can do this in code using the <code class="literal">setBuddy</code> method of the <code class="literal">QLabel</code> class or using Creator's form designer. Since we're already in the Design mode, we'll use the <a id="id117" class="indexterm"/>latter approach. For that, we need to activate a dedicated mode in the form designer.</p><p>Look at the upper part of Creator's window; directly above the form, you will find a toolbar containing a couple of icons. Click on the one labeled <span class="strong"><strong>Edit buddies</strong></span> or just press <span class="emphasis"><em>F5</em></span> on your keyboard. Now, move the mouse cursor over the label, press the mouse button, and drag from the label towards the line edit. When you drag the label over the line edit, you'll see a graphical visualization of a connection being set between the label and the line edit. If you release the button now, the association will be made permanent. You should notice that when such an association is made, the ampersand character (<code class="literal">&amp;</code>) vanishes from the label and the character behind it gets an underscore. Repeat this for the other label and corresponding line edit. Now, you can preview the form again and check whether accelerators work as expected.</p></div><div class="section" title="The tab order"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>The tab order</h2></div></div></div><p>While you're <a id="id118" class="indexterm"/>previewing the form, you can check another aspect of the UI design. Start by <a id="id119" class="indexterm"/>pressing the <span class="emphasis"><em>Tab</em></span> key and see how the focus moves from widget to widget. There is a good chance that the focus will start jumping back and forth between buttons and line edits instead of a linear progress from top to bottom (which is an intuitive order for this particular dialog). To check and modify the order of focus, leave the preview and switch to the tab order editing mode by clicking on the icon called Edit Tab Order in the toolbar.</p><p>This mode associates a box with a number to each focusable widget. By clicking on the rectangle in the order <a id="id120" class="indexterm"/>you wish the widgets to gain focus, you can reorder values, thus reordering focus. Now, make it so that the order is as shown in the following figure:</p><div class="mediaobject"><img src="graphics/8874OS_03_11.jpg" alt="The tab order"/></div><p>Enter the preview again and check whether the focus changes according to what you've set.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>When deciding about the tab order, it is good to consider which fields in the dialog are mandatory and which are optional. It is a good habit to allow the user to tab through all the <a id="id121" class="indexterm"/>mandatory fields first, then to the dialog confirmation button (for example, one that says <span class="strong"><strong>OK</strong></span> or <span class="strong"><strong>Accept</strong></span>), and then cycle through all the optional fields. Thanks to this, the user will be able to quickly fill all the mandatory fields and accept the dialog without the need to cycle through all the optional fields that the user wants to leave at their default values.</p></div></div></div><div class="section" title="Signals and slots"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Signals and slots</h2></div></div></div><p>The last thing we <a id="id122" class="indexterm"/>are going to do right now is make sure that the signal-slot <a id="id123" class="indexterm"/>connections are set up properly. To do this, switch to the signal-slot editor mode by pressing <span class="emphasis"><em>F4</em></span> or choosing <span class="strong"><strong>Edit Signals/Slots</strong></span> from the toolbar. The <span class="strong"><strong>Dialog with Buttons Bottom</strong></span> widget template predefines two connections for us, which should now become visible in the main canvas area:</p><div class="mediaobject"><img src="graphics/8874OS_03_12.jpg" alt="Signals and slots"/></div><p>The <code class="literal">QDialog</code> class that implements dialogs in Qt has two useful slots—<code class="literal">accept()</code> and <code class="literal">reject()</code>—which inform the caller whether the action represented by the dialog was accepted or not. For our convenience, these slots should already be connected to the respective <code class="literal">accepted()</code> and <code class="literal">rejected()</code> signals from the group of buttons (which is an instance of the <code class="literal">QDialogButtonBox</code> class) that by default, contain the <span class="strong"><strong>OK</strong></span> and <span class="strong"><strong>Cancel</strong></span> buttons. If you click on any of them signal <code class="literal">accepted()</code> or respectively, <code class="literal">rejected()</code> will be emitted by the box.</p><p>At this point, we can add some more connections to make our dialog more functional. Let's make it such that the button to accept the dialog is only enabled when neither of the two line edits is empty (that is, when both the fields contain player names). While we will implement the logic itself later, we can now make connections to a slot that will perform the task.</p><p>Since no such slot <a id="id124" class="indexterm"/>exists by default, we need to inform the form editor that such a <a id="id125" class="indexterm"/>slot will exist at the time when the application is compiled. To do this, we need to switch back to the default mode of the form editor by pressing <span class="emphasis"><em>F3</em></span> or choosing <span class="strong"><strong>Edit Widgets</strong></span> from the toolbar. Then, you can invoke the form's context menu and choose <span class="strong"><strong>Change signals/slots</strong></span>. A window will pop up such as the one shown in the following figure that lists the available signals and slots:</p><div class="mediaobject"><img src="graphics/8874OS_03_13.jpg" alt="Signals and slots"/></div><p>Click on the <span class="strong"><strong>+</strong></span> button <a id="id126" class="indexterm"/>in the <span class="strong"><strong>Slots</strong></span> group and create a slot called <code class="literal">updateOKButtonState()</code>:</p><div class="mediaobject"><img src="graphics/8874OS_03_14.jpg" alt="Signals and slots"/></div><p>Then, accept the dialog and go back to the <span class="strong"><strong>Signals/Slots</strong></span> mode. Create a new connection by grabbing one of the line edits with your mouse. When you move the cursor outside the widget, you will notice a red line following your pointer. If the line encounters a valid target, the line will change <a id="id127" class="indexterm"/>to an arrow and the target object will be highlighted. The form itself can also be a target (or a source); in this case, the line will end with a ground mark (two short horizontal lines).</p><p>When you release the mouse button, a window will pop up, listing all the signals of the source object and all the slots of the target object. Choose the <code class="literal">textChanged(QString)</code> signal. Note that when you do this, some of the available slots will disappear. This is because the tool only allows us to choose from slots that are compatible with the highlighted signal. Select our newly created slot and accept the dialog. Repeat the same for the other line edit.</p><p>What we have done here is that we've created two connections that will trigger when the text of either of the two line edits is changed. They will execute a slot that doesn't exist yet—by "creating" the slot, we only declared our intention to implement it in a <code class="literal">QDialog</code> subclass that was also created for us. You can now go ahead and save the form.</p></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We performed a number of tasks that make our form follow standard behaviors known from many applications—this makes form navigation easy and shows the user which actions can be undertaken and which are currently not available.</p></div><div class="section" title="Using designer forms"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Using designer forms</h2></div></div></div><p>If you open the form in a text editor (for example, by switching to the Creator's <span class="strong"><strong>Edit</strong></span> pane), you will notice that it is really an XML file. So how do we use this file?</p><p>As part of the build process, Qt calls a special tool called <span class="strong"><strong>User Interface Compiler</strong></span> (<span class="strong"><strong>uic</strong></span>) that reads the file and generates a C++ class that contains a <code class="literal">setupUi()</code> method. This method accepts a pointer to a widget and contains code, which instantiates all the widgets, sets <a id="id128" class="indexterm"/>their properties, and establishes signal-slot <a id="id129" class="indexterm"/>connections, and it is our responsibility to call it to prepare the GUI. The class itself, which is named after your form (that is after the value of the <code class="literal">objectName</code> property of the form object) with a <code class="literal">Ui</code> namespace prepended to it (for example, <code class="literal">Ui::MyForm</code>) is not derived from a widget class but is rather meant to be used with one. There are basically three ways of doing this.</p><div class="section" title="Direct approach"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec06"/>Direct approach</h3></div></div></div><p>The most basic <a id="id130" class="indexterm"/>way to use a Qt Designer form is to instantiate a widget and the form object and to call <code class="literal">setupUi</code> on the widget, like this:</p><div class="informalexample"><pre class="programlisting">QWidget *widget = new QWidget
Ui_form ui * = new Ui_form;
ui-&gt;setupUi(widget);</pre></div><p>This approach has a number of flaws. First of all, it creates a potential memory leak of the <code class="literal">ui</code> object (remember, it is not <code class="literal">QObject</code>, so you can't set a parent to it so that it's deleted when the parent is deleted). Second, since all the widgets of the form are variables of the <code class="literal">ui</code> object that is not tied to the widget object, it breaks encapsulation, which is one of the most important paradigms of object-oriented programming. However, there is a situation when such a construct is acceptable. This is when you create a simple short-lived modal dialog. You surely need to remember that to show regular widgets, we have been using the <code class="literal">show()</code> method. This is fine for non-modal widgets, but for modal dialogs you should instead call the <code class="literal">exec()</code>method that is defined in the <code class="literal">QDialog</code> class. This is a blocking method that doesn't return until the dialog is closed. This allows us to modify the code so that it becomes:</p><div class="informalexample"><pre class="programlisting">QDialog dialog;
Ui_form ui;
ui.setupUi(&amp;dialog);
dialog.exec();</pre></div><p>Since we're creating <a id="id131" class="indexterm"/>objects on the stack, the compiler will take care of deleting them when the local scope ends.</p></div><div class="section" title="The multiple-inheritance approach"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec07"/>The multiple-inheritance approach</h3></div></div></div><p>The second <a id="id132" class="indexterm"/>way of using Designer forms is to create a class derived from both <code class="literal">QWidget</code> (or one of its subclasses) and the form class itself. We can then call <code class="literal">setupUi</code> from the constructor:</p><div class="informalexample"><pre class="programlisting">class Widget : public QWidget, private Ui::MyForm {
public:
  Widget(QWidget *parent = 0) : QWidget(parent) {
    setupUi(this);
  }
};</pre></div><p>This way, we keep the encapsulation as our class inherits fields and methods from the <code class="literal">Ui</code> class, and we can call any of them directly from within the class code while restricting access from the outside world by using private inheritance. The drawback of this approach is that we pollute the class namespace, for example, if we had a name object in <code class="literal">Ui::MyForm</code>, we wouldn't be able to create a <code class="literal">name</code> method in <code class="literal">Widget</code>.</p></div><div class="section" title="The single inheritance approach"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec08"/>The single inheritance approach</h3></div></div></div><p>Fortunately, we <a id="id133" class="indexterm"/>can work around this using the composition instead of inheritance. We can derive our widget class only from <code class="literal">QWidget</code> and instead of also subclassing <code class="literal">Ui::MyForm</code>, we can make an instance of it a private member of the new class:</p><div class="informalexample"><pre class="programlisting">class Widget : public QWidget {
public:
  Widget(QWidget *parent = 0) : QWidget(parent) {
    ui = new Ui::MyForm;
    ui-&gt;setupUi(this);
  }
  ~Widget() { delete ui; }
private:
  Ui::MyForm *ui;
};</pre></div><p>At the cost of having to manually create and destroy the instance of <code class="literal">Ui::MyForm</code>, we can have the additional benefit of containing all variables and code of the form in a dedicated object, which prevents the aforementioned namespace pollution.</p><p>This is the recommended way of using Designer forms, and it's also the default mode of operation when you tell Qt Creator to generate a Designer form class for you.</p></div></div></div>
<div class="section" title="Time for action &#x2013; the logic of the dialog"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Time for action – the logic of the dialog</h1></div></div></div><p>Now, it is time to make our game settings dialog work. Earlier, we declared a signal-slot connection but now the slot itself needs to be implemented.</p><p>Open the form <a id="id134" class="indexterm"/>class generated by Creator. If you're still in the Design mode, you can quickly jump to the respective form class file using the <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>F4</em></span> keyboard shortcut. Create a public slots section of the class and declare a <code class="literal">void updateOKButtonState()</code> slot. Open the refactorization menu (<span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>Enter</em></span>) and ask Creator to create the skeleton implementation of the slot for you. Fill the function body with the following code:</p><div class="informalexample"><pre class="programlisting">void ConfigurationDialog::updateOKButtonState() {
    bool pl1NameEmpty = ui-&gt;player1Name-&gt;text().isEmpty();
    bool pl2NameEmpty = ui-&gt;player2Name-&gt;text().isEmpty();
    QPushButton *okButton = ui-&gt;buttonBox-&gt;button(QDialogButtonBox::Ok);
    okButton-&gt;setDisabled(pl1NameEmpty || pl2NameEmpty);
}</pre></div><p>This code retrieves player names and checks whether either of them is empty. Then, it asks the button box that currently contains the <span class="strong"><strong>OK</strong></span> and <span class="strong"><strong>Cancel</strong></span> buttons to give a pointer to the button that accepts the dialog. Then, we set the button's disabled state based on whether both player names contain valid values or not. The button state also needs to be updated when we first create the dialog, so add invocation of <code class="literal">updateOKButtonState()</code> to the constructor of the dialog:</p><div class="informalexample"><pre class="programlisting">ConfigurationDialog::ConfigurationDialog(QWidget *parent) :
  QDialog(parent), ui(new Ui::ConfigurationDialog)
{
  ui-&gt;setupUi(this);
  <span class="strong"><strong>updateOKButtonState();</strong></span>
}</pre></div><p>The next thing to do is to allow to store and read player names from outside the dialog—since the <code class="literal">ui</code> component is private, there is no access to it from outside the class code. This is a common situation and one that Qt is also compliant with. Each data field in almost every Qt class is private and may contain accessors (a getter and optionally a setter), which are public methods that allow to read and store values for data fields. Our dialog has two such fields—the names for the two players. At this point, we should note that they are good candidates for properties so at the end, we'll declare them as such. But first, let's start by implementing the accessors.</p><p>Setter methods in Qt are usually named using the lowercase pattern, for example, <code class="literal">set</code> followed by the name of the property with the first letter converted to uppercase. In our situation, the two setters will be called <code class="literal">setPlayer1Name</code> and s<code class="literal">etPlayer2Name</code> and they will both accept <code class="literal">QString</code> and return <code class="literal">void</code>. Declare them in the class header as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">void setPlayer1Name(const QString &amp;p1name);
void setPlayer2Name(const QString &amp;p2name);</pre></div><p>Implement their bodies in the <code class="literal">.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">void ConfiguratiosDialog::setPlayer1Name(const QString &amp;p1name) {
  ui-&gt;player1Name-&gt;setText(p1name);
}
void ConfigurationDialog::setPlayer2Name(const QString &amp;p2name) {
 ui-&gt;player2Name-&gt;setText(p2name);
}</pre></div><p>Getter methods in Qt are usually called the same as the property that they are related to—<code class="literal">player1Name</code> and <code class="literal">player2Name</code>. Put the following code in the header file:</p><div class="informalexample"><pre class="programlisting">QString player1Name() const;
QString player2Name() const;</pre></div><p>Put the following code in the implementation file:</p><div class="informalexample"><pre class="programlisting">QString ConfigurationDialog::player1Name() const { return ui-&gt;player1Name-&gt;text(); }
QString ConfigurationDialog::player2Name() const { return ui-&gt;player2Name-&gt;text(); }</pre></div><p>The only thing left to do now is to declare the properties. Add the highlighted lines to the class declaration:</p><div class="informalexample"><pre class="programlisting">class ConfigurationDialog : public QDialog {
  Q_OBJECT
<span class="strong"><strong>  Q_PROPERTY(QString player1Name READ player1Name WRITE setPlayer1Name)</strong></span>
<span class="strong"><strong>  Q_PROPERTY(QString player2Name READ player2Name WRITE setPlayer2Name)</strong></span>
public:
  ConfigurationDialog(QWidget *parent = 0);</pre></div><p>Our dialog is now <a id="id135" class="indexterm"/>ready. You can test it by creating an instance of it in <code class="literal">main()</code> and calling <code class="literal">show()</code> or <code class="literal">exec()</code>.</p><div class="section" title="An application's main window"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>An application's main window</h2></div></div></div><p>We already have two <a id="id136" class="indexterm"/>major components in our game—the game board and configuration dialog. Now, we will need to bind them together. To do this, we will use another important component—the <code class="literal">QMainWindow</code> class. A "main window" represents the control center of an application. It can contain menus, toolbars, docking widgets, a status bar, and the actual widget content called a "central widget", as presented in the following diagram:</p><div class="mediaobject"><img src="graphics/8874OS_03_15.jpg" alt="An application's main window"/></div><p>The central widget part doesn't need any extra explanation—it is a regular widget like any other. We will also not focus on dock widgets or the status bar here. They are useful components but they are so easy to master that you can learn about them yourself. Instead, we will spend some time mastering menus and toolbars. You have surely seen and used toolbars and menus in many applications and you know how important they are for good user experience.</p><p>The main hero <a id="id137" class="indexterm"/>shared by both these concepts is a class called <code class="literal">QAction</code>, which represents a functionality that can be invoked by a user. A single action can have more than one incarnation—it can be an entry in a menu (the <code class="literal">QMenu</code> instances), a toolbar (<code class="literal">QToolBar</code>), button, or keyboard shortcut (<code class="literal">QShortcut</code>). Manipulating the action (for example, changing its text) causes all its incarnations to update. For example, if you have a <span class="strong"><strong>Save</strong></span> entry in the menu (with a keyboard shortcut bound to it), a Save icon in the toolbar, and maybe also a <span class="strong"><strong>Save</strong></span> button somewhere else in your user interface and you want to disallow saving the document (for example, a map in your dungeons and dragons game level editor) because its contents haven't changed since the document was last loaded. In this case, if, the menu entry, toolbar icon, and button are all linked to the same <code class="literal">QAction</code> instance then, once you set the <code class="literal">enabled</code> property of the action to <code class="literal">false</code>, all the three entities will become disabled as well. This is an easy way to keep different parts of your application in sync—if you disable an action object, you can be sure that all entries that trigger the functionality represented by the action are also disabled. Actions can be instantiated in code or created graphically using <span class="strong"><strong>Action Editor</strong></span> in Qt Creator. An action can have different pieces of data associated with it—a text, tooltip, status bar tip, icons, and others that are less often used. All these are used by incarnations <a id="id138" class="indexterm"/>of your actions.</p><div class="section" title="The Qt resource system"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec09"/>The Qt resource system</h3></div></div></div><p>While <a id="id139" class="indexterm"/>speaking of icons, there is an important feature in Qt that you should learn. A natural way of creating icons is by loading images from the filesystem. The problem with this is that you have to install a bunch of files together with your application and you need to always know where they are located to be able to provide paths to access them. This is difficult but fortunately, Qt has a solution to this—it allows you to embed arbitrary files (such as images for icons) directly in the application that is executable. This is done by preparing resource files that are later compiled in the binary. Fortunately, Qt Creator provides a graphical tool for this as well.</p></div></div></div>
<div class="section" title="Time for action &#x2013; the main window of the application"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Time for action – the main window of the application</h1></div></div></div><p>Create a new <span class="strong"><strong>Qt </strong></span><a id="id140" class="indexterm"/>
<span class="strong"><strong>Designer Form Class</strong></span> application. As a template, choose <span class="strong"><strong>Main Window</strong></span>. Accept the default values for the rest of the wizard.</p><p>Create an action using the action editor and enter the following values in the dialog:</p><div class="mediaobject"><img src="graphics/8874OS_03_16.jpg" alt="Time for action – the main window of the application"/></div><p>Now, create another action and fill it with the values shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8874OS_03_17.jpg" alt="Time for action – the main window of the application"/></div><p>We want our game to look nice, so we will provide icons for the actions and we will embed images for <a id="id141" class="indexterm"/>them in our application using the resource system. Create a new file and make it <span class="strong"><strong>Qt Resource File</strong></span>. Call it <code class="literal">resources.qrc</code>. Click on the <span class="strong"><strong>Add</strong></span> button and choose <span class="strong"><strong>Add Prefix</strong></span>. Change the value for the prefix to <code class="literal">/</code>. Then, click on the <span class="strong"><strong>Add</strong></span> button again and choose <span class="strong"><strong>Add Files</strong></span>. Find appropriate images for your actions and add them to the resource file. A dialog will appear asking whether you want to copy the files to the project directory. Agree by choosing <span class="strong"><strong>Copy</strong></span>.</p><div class="mediaobject"><img src="graphics/8874OS_03_18.jpg" alt="Time for action – the main window of the application"/></div><p>Now, edit the actions <a id="id142" class="indexterm"/>again in the Action Editor and choose icons for them.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We added a resource file to our project. In that resource file, we created entries for a number of images. Each of the images is put under a <code class="literal">/</code> prefix, which stands for the root node of the artificial filesystem that we create. Each entry in a resource file can be accessed directly from the manually written code as a file with a special name. This name is assembled from three components. First comes a colon character (<code class="literal">:</code>), which identifies the resource filesystem. This is followed by a prefix (for example, <code class="literal">/</code>) and a full path of the entry in the resource (for example, <code class="literal">exit.png</code>). This makes an image called <code class="literal">exit.png</code> accessible through the <code class="literal">:/exit.png</code> path. When we build the project, the file will be transformed into a C data array code and integrated with the application binary. Having prepared the resource file, we used images embedded there as icons for our actions.</p><p>The next step is to add these actions to a menu and toolbar.</p></div></div>
<div class="section" title="Time for action &#x2013; adding a pull-down menu"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Time for action – adding a pull-down menu</h1></div></div></div><p>To create a <a id="id143" class="indexterm"/>menu for the window, double-click on the <span class="strong"><strong>Type Here</strong></span> text on the top of the form and replace the text with <code class="literal">&amp;File</code>. Then, drag the <span class="strong"><strong>New Game</strong></span> action from the action editor over the newly created menu but <a id="id144" class="indexterm"/>do not drop it there yet. The menu should open now and you can drag the action so that a red bar appears in the submenu in the position where you want the menu entry to appear—now you can release the mouse button to create the entry. Afterwards, open the menu again by clicking on <span class="strong"><strong>File</strong></span> and choose <span class="strong"><strong>Add Separator</strong></span>. Then, repeat the drag-and-drop operation for the <span class="strong"><strong>Quit</strong></span> action to insert a menu entry for it just below the separator in the <span class="strong"><strong>File</strong></span> menu, as shown in the following figure:</p><div class="mediaobject"><img src="graphics/8874OS_03_19.jpg" alt="Time for action – adding a pull-down menu"/></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>Using graphical tools, we created a menu for our program and added a number of actions (that were automatically transformed into menu items) to that menu. Each menu entry received some text and an icon specified by the action that was dropped in the menu.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>To create <a id="id145" class="indexterm"/>submenus, first create a menu entry by clicking on the <span class="strong"><strong>Type Here</strong></span> line and entering the submenu name. Then, drag and hover an action over such a submenu. After a short time, a submenu will pop up and you will be able to drop your action there to <a id="id146" class="indexterm"/>create an entry in the second-level menu.</p></div></div></div></div>
<div class="section" title="Time for action &#x2013; creating a toolbar"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Time for action – creating a toolbar</h1></div></div></div><p>To create a <a id="id147" class="indexterm"/>toolbar, invoke the context menu on the form and choose <span class="strong"><strong>Add Tool Bar</strong></span>. Then, drag the <span class="strong"><strong>New Game</strong></span> action over the toolbar and drop <a id="id148" class="indexterm"/>it there. Open a context menu for the toolbar and choose <span class="strong"><strong>Append Separator</strong></span>. Then, drag the <span class="strong"><strong>Quit</strong></span> action from the Action Editor and drop it in the toolbar behind the separator. The following figure presents the final layout that you should have now:</p><div class="mediaobject"><img src="graphics/8874OS_03_20.jpg" alt="Time for action – creating a toolbar"/></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>Creating toolbars is very similar to creating menus. You first create the container (the toolbar) and then drag-and-drop actions from the action editor. You can even drag an action from the menu bar and drop it on the toolbar and vice versa!</p></div></div>
<div class="section" title="Time for action &#x2013; filling in the central widget"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Time for action – filling in the central widget</h1></div></div></div><p>Add two <a id="id149" class="indexterm"/>labels in the main window area—one at the top for the first player name and one at the bottom of the form for the second player name—and then change their <code class="literal">objectName</code> property to <code class="literal">player1</code> and <code class="literal">player2</code>, respectively. Clear their text property so that they don't display anything. Then, drag <span class="strong"><strong>Widget</strong></span> from the widget box, drop it between the two labels' and set its object name to <code class="literal">gameBoard</code>. Invoke the context menu on the widget that you just dropped and choose <span class="strong"><strong>Promote to</strong></span>. This allows us to substitute a widget in the form with another class; in our case, we will want to replace the empty widget with our game board. Fill the dialog that has just appeared with the values shown in the following figure:</p><div class="mediaobject"><img src="graphics/8874OS_03_21.jpg" alt="Time for action – filling in the central widget"/></div><p>Then, click on <a id="id150" class="indexterm"/>the button labeled <span class="strong"><strong>Add</strong></span> and then <span class="strong"><strong>Promote</strong></span> to close the dialog and confirm the promotion. You will not notice any changes in the form because the replacement only takes place during compilation. Now, apply a vertical layout on the form so that the labels and the empty widget snap into place.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>Not all widget types are directly available in the form designer. Sometimes, we need to use widget classes that will only be created in the project that is being built. The simplest way to be able to put custom widgets on a form is to ask the designer to replace class names with some of the objects when C++ code for the form is to be generated. By promoting an object to a different class, we saved a lot of work trying to otherwise fit our game board into the user interface.</p></div></div>
<div class="section" title="Time for action &#x2013; putting it all together"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Time for action – putting it all together</h1></div></div></div><p>The visual part of the game is ready and what remains is to complete the logic of the main window and put all the pieces together. Add a public slot to the class and call it <code class="literal">startNewGame</code>. In the class constructor, connect the <span class="strong"><strong>New Game</strong></span> action's triggered signal to this slot and connect the application's quit slot to the other action:</p><div class="informalexample"><pre class="programlisting">connect(ui-&gt;actionNewGame, SIGNAL(triggered()), this, SLOT(startNewGame()));
connect(ui-&gt;actionQuit, SIGNAL(triggered()), qApp, SLOT(quit()));</pre></div><p>The <code class="literal">qApp</code> special macro represents a pointer to the application object instance, so the preceding code will call the <code class="literal">quit()</code> slot on the <code class="literal">QApplication</code> object created in <code class="literal">main()</code>, which in turn will eventually cause the application to end.</p><p>Let's implement the <code class="literal">startNewGame</code> slot as follows:</p><div class="informalexample"><pre class="programlisting">void MainWindow::startNewGame() {
  ConfigurationDialog dlg(this);
  if(dlg.exec() == QDialog::Rejected) {
    return; // do nothing if dialog rejected
  }
  ui-&gt;player1-&gt;setText(dlg.player1Name());
  ui-&gt;player2-&gt;setText(dlg.player2Name());
  ui-&gt;gameBoard-&gt;initNewGame();
  ui-&gt;gameBoard-&gt;setEnabled(true);
}</pre></div><p>In this slot, we create <a id="id151" class="indexterm"/>the settings dialog and show it to the user, forcing him to enter player names. If the dialog was canceled, we abandon the creation of a new game. Otherwise, we ask the dialog for player names and set them on appropriate labels. Finally, we initialize the board and enable it so that users can interact with it.</p><p>While writing a turn-based board game, it is a good idea to always clearly mark whose turn it is now to make a move. We will do this by marking the moving player's name in bold. There is already a signal in the board class that tells us that a valid move was made, which we can react to in order to update the labels. Let's add an appropriate code into the constructor of the main window class:</p><div class="informalexample"><pre class="programlisting">connect(ui-&gt;gameBoard, SIGNAL(currentPlayerChanged(Player)), this, SLOT(updateNameLabels()));</pre></div><p>Now for the slot itself; let add a private slot's section to the class and declare the slot there:</p><div class="informalexample"><pre class="programlisting">private slots:
  void updateNameLabels();</pre></div><p>Now, we can implement it:</p><div class="informalexample"><pre class="programlisting">void MainWindow::updateNameLabels() {
  QFont f = ui-&gt;player1-&gt;font();
  f.setBold(ui-&gt;gameBoard-&gt;currentPlayer() == TicTacToeWidget::Player1);
  ui-&gt;player1-&gt;setFont(f);
  f.setBold(ui-&gt;gameBoard-&gt;currentPlayer() == TicTacToeWidget::Player2);
  ui-&gt;player2-&gt;setFont(f);
}</pre></div><p>In addition to the slot being called after a signal is emitted, we can also use it to set the initial data for the <a id="id152" class="indexterm"/>labels when the game is starting. Since all the slots are also regular methods, we can simply call <code class="literal">updateNameLabels()</code> from <code class="literal">startNewGame()</code>—go ahead and invoke <code class="literal">updateNameLabels()</code> at the end of <code class="literal">startNewGame()</code>.</p><p>The last thing that needs to be done is to handle the situation when the game ends. Connect the <code class="literal">gameOver()</code> signal from the board to a new slot in the main window class. Implement the slot as follows:</p><div class="informalexample"><pre class="programlisting">void MainWindow::handleGameOver(TicTacToeWidget::Player winner) {
  ui-&gt;gameBoard-&gt;setEnabled(false);
  QString message;
  if(winner == TicTacToeWidget::Draw) {
    message = "Game ended with a draw.";
  } else {
    message = QString("%1 wins").arg(winner == TicTacToeWidget::Player1
    ? ui-&gt;player1-&gt;text() : ui-&gt;player2-&gt;text());
  }
  QMessageBox::information(this, "Info", message);
}</pre></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>Our code does two things. First, it disables the board so that players can no longer interact with it. Second, it checks who won the game, assembles the message (we will learn more about <code class="literal">QString</code> in the next chapter), and shows it using a static method <code class="literal">QMessageBox::information()</code> that shows a modal dialog containing the message and a button that allows us to close the dialog. The last thing that remains is to update the <code class="literal">main()</code> function in order to create an instance of our <code class="literal">MainWindow</code> class:</p><div class="informalexample"><pre class="programlisting">#include "mainwindow.h"
#include &lt;QApplication&gt;
int main(int argc, char *argv[])
{
  QApplication a(argc, argv);
  MainWindow w;
  w.show();
  return a.exec();
}</pre></div><p>Now, you can run your first Qt game.</p></div><div class="section" title="Have a go hero – extending the game"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Have a go hero – extending the game</h2></div></div></div><p>As an additional <a id="id153" class="indexterm"/>exercise, you can try to modify the code we have written in this chapter to allow playing the game on boards bigger than 3 x 3. Let the user decide about the size of the board (you can modify the game options dialog for that and use <code class="literal">QSlider</code> and <code class="literal">QSpinBox</code> to allow the user to choose the size of the board) and you can then instruct <code class="literal">TicTacToeWidget</code> to build the board based on the size it gets. Remember to adjust the game winning logic! If at any point you run into a dead end and do not know which classes and functions to use, consult the reference manual.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>To quickly find the documentation for a class (or any other page in the docs), switch to the <span class="strong"><strong>Help</strong></span> pane, choose <span class="strong"><strong>Index</strong></span> from the drop-down list on top of the sidebar, and type in the search term, such as <code class="literal">QAction</code>. Also, the <span class="emphasis"><em>F1</em></span> key is very helpful for browsing the manual. Position the mouse pointer or text cursor in the code editor over the name of a class, function, or object and press <span class="emphasis"><em>F1</em></span> on your keyboard. By doing this, Qt Creator will happily show you the available help information on the chosen subject.</p></div></div></div><div class="section" title="Pop quiz – using widgets"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Pop quiz – using widgets</h2></div></div></div><p>Q1. A method that returns the preferred size of a widget is called:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">preferredSize</code></li><li class="listitem"><code class="literal">sizeHint</code></li><li class="listitem"><code class="literal">defaultSize</code></li></ol></div><p>Q2. What is the name of a Qt class that can carry values for any property?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">QVariant</code></li><li class="listitem"><code class="literal">QUnion</code></li><li class="listitem"><code class="literal">QPropertyValue</code></li></ol></div><p>Q3. What is the purpose of the <code class="literal">QAction</code> object?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">It represents a functionality that a user can invoke in the program.</li><li class="listitem">It holds a key sequence to move the focus on a widget.</li><li class="listitem">It is a base class for all forms generated using Qt Designer.</li></ol></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, you learned how to create simple graphical user interfaces with Qt. We went through two approaches—creating user interface classes by writing all the code directly and designing the user interface with a graphical tool that generates most of the code for us. There is no telling which of the two approaches is better; each of them is better in some areas and worse in others. In general, you should prefer using Qt Designer forms to write code directly because it's faster and less prone to errors as most of the code is generated. However, if you want to retain more control over the code or your GUI is highly dynamic, writing all the code yourself will be easier, especially when you gain enough experience with Qt to avoid common pitfalls and learn to use advanced programming constructs.</p><p>We also learned how the heart of Qt—the meta-object system—works. You should now be able to create simple user interfaces and fill them with logic by connecting signals to slots—predefined ones as well as custom ones that you now know how to define and fill with code.</p><p>Qt contains many widget types but I didn't introduce them to you one by one. There is a really nice explanation of many widget types in the Qt manual called <span class="emphasis"><em>Qt Widget Gallery</em></span>, which shows most of them in action.</p><p>If you have any doubts about using any of those widgets, you can check the example code and also look up the appropriate class in the Qt reference manual to learn more about them.</p><p>Using Qt is much more than just dragging-and-dropping widgets on forms and providing some code to glue the pieces together. In the next chapter, you will learn about some of the most useful functionalities that Qt has to offer; they do not relate to showing graphics on screen, but rather let you manipulate various kind of data. This is essential for any game that is more complicated than a simple tic-tac-toe.</p></div></body></html>