- en: Chapter 12. The Auxiliary Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。辅助类
- en: 'Small Windows includes a set of auxiliary classes, which are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 小型Windows包括一组辅助类，如下所示：
- en: '`Size`, `Point`, `Rect`, `Color`, and `Font`: These wrap the Win32 API structures
    which are `SIZE`, `POINT`, `RECT`, `COLORREF`, and `LOGFONT`. They are equipped
    with methods to communicate with files, the clipboard, and the registry. The Registry
    is a database in the Windows system that we can use to store values between the
    executions of our applications.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Size`、`Point`、`Rect`、`Color`和`Font`：这些封装了Win32 API结构`SIZE`、`POINT`、`RECT`、`COLORREF`和`LOGFONT`。它们配备了与文件、剪贴板和注册表通信的方法。注册表是Windows系统中的一个数据库，我们可以用它来在应用程序执行之间存储值。'
- en: '`Cursor`: is a type representing the Windows cursor.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cursor`：表示Windows光标。'
- en: '`DynamicList`: holds a list of dynamic size with a set of callback functions.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DynamicList`：包含具有一组回调函数的动态大小列表。'
- en: '`Tree`: holds a recursive tree structure.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tree`：包含递归树结构。'
- en: '`InfoList`: holds a list of generic information that can be transformed to
    and from a memory buffer.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InfoList`：包含可以转换到和从内存缓冲区转换的通用信息列表。'
- en: There is also a small set of string manipulation functions.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一些字符串操作函数。
- en: The Size class
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Size`类'
- en: 'The `Size` class is a small class holding the width and height:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`Size`类是一个包含宽度和高度的简单类：'
- en: '**Size.h**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Size.h**'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `ZeroSize` object is an object with its width and height set to zero:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZeroSize`对象是一个其宽度和高度设置为零的对象：'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The default constructor initializes the width and height to zero. The size
    can be initialized by, and assigned to, another size. The `Size` class uses the
    assignment operator to assign a size to another size:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数将宽度和高度初始化为零。大小可以通过初始化和赋值给另一个大小来初始化。`Size`类使用赋值运算符将大小赋给另一个大小：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A `Size` object can be initialized and assigned to a value of the Win32 API
    `SIZE` structure, and a `Size` object can be converted to a `SIZE`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Size`对象可以被初始化并赋值为Win32 API `SIZE`结构体的值，并且`Size`对象可以被转换为`SIZE`：'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When comparing two sizes, the widths are compared first. If they are equal,
    the heights are then compared:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个大小时，首先比较宽度。如果它们相等，然后比较高度：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The multiplication operators multiply both the width and height with the factor.
    Note that even though the factor is a double, the resulting width and height are
    always rounded to integers:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法运算符将因子乘以宽度和高度。请注意，尽管因子是双精度浮点数，但得到的宽度和高度始终被四舍五入为整数：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is also possible to multiply the size with a pair of values, where the first
    value is multiplied by the width and the second value is multiplied by the height.
    Also, in this case, the resulting width and height are integers:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用一对值来乘以大小，其中第一个值乘以宽度，第二个值乘以高度。此外，在这种情况下，得到的宽度和高度都是整数：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first set of addition operators adds and subtracts the distance to both
    the width and height:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组加法运算符将距离加到宽度和高度上：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The second set of addition operators adds and subtracts the widths and heights
    separately:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组加法运算符分别将宽度和高度相加和相减：
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The size can be written to, and read from, a file stream, the clipboard, and
    the registry:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大小可以被写入到文件流、剪贴板和注册表中，也可以从这些地方读取：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The width and height are inspected by the constant methods and modified by
    the non-constant methods:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度和高度通过常量方法进行检查，并通过非常量方法进行修改：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The implementation of the `Size` class is rather straightforward:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Size`类的实现相当直接：'
- en: '**Size.cpp**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**Size.cpp**'
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As mentioned earlier, when comparing two sizes, the widths are compared first.
    If they are equal the heights are then compared:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，比较两个大小时，首先比较宽度。如果它们相等，然后比较高度：
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that `Min` and `Max` return the right-hand side value if the values are
    equal. We could let it return the left-hand side value instead. However, since
    the `Size` objects in that case hold the same *x* and *y* values and the methods
    return objects rather than references to an object, it does not matter. The same
    value is returned:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果`Min`和`Max`返回的值相等，则返回右侧的值。我们可以让它返回左侧的值。然而，由于在这种情况下`Size`对象持有的`x`和`y`值相同，并且方法返回的是对象而不是对象的引用，所以这并不重要。返回的是相同的值：
- en: '[PRE13]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As mentioned earlier, the resulting width and height are always rounded to
    integers, even though the factor is a double:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，得到的宽度和高度始终被四舍五入为整数，即使因子是双精度浮点数：
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When writing the size to the registry, we convert the size to a `SIZE` structure
    that is sent to `WriteBuffer` in `Registry`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当将大小写入注册表时，我们将大小转换为 `SIZE` 结构，并将其发送到 `Registry` 中的 `WriteBuffer`：
- en: '[PRE15]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When reading the size from the registry, we convert the default size to a `SIZE`
    structure that is sent to `ReadBuffer` in `Registry`. The result is then converted
    back to a `Size` object:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当从注册表中读取大小，我们将默认大小转换为 `SIZE` 结构，并将其发送到 `Registry` 中的 `ReadBuffer`。然后，结果被转换回
    `Size` 对象：
- en: '[PRE16]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Point class
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点类
- en: 'The `Point` class is a small class holding the *x* and *y* position of a two-dimensional
    point:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point` 类是一个小的类，包含二维点的 *x* 和 *y* 位置：'
- en: '**Point.h**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**Point.h**'
- en: '[PRE17]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The default constructor initializes the *x* and *y* value to zero. The point
    can be initialized by, and assigned to, another point:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数将 *x* 和 *y* 值初始化为零。点可以通过另一个点初始化和赋值：
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similar to the `Size` class mentioned earlier, `Point` uses the assignment
    operator:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面提到的 `Size` 类类似，`Point` 使用赋值运算符：
- en: '[PRE19]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similar to `SIZE` in the preceding section, there is a `POINT` Win32 API structure.
    A `Point` object can be initialized by, and assigned to, a `POINT` structure,
    and a `Point` object can be converted to `POINT`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一部分中的 `SIZE` 类似，存在一个 `POINT` Win32 API 结构。`Point` 对象可以通过 `POINT` 结构初始化和赋值，并且
    `Point` 对象可以转换为 `POINT`：
- en: '[PRE20]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When comparing two points, the *x* values are first compared. If they are equal,
    the *y* values are then compared:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个点时，首先比较 *x* 值。如果它们相等，然后比较 *y* 值：
- en: '[PRE21]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Similar to the `Size` class mentioned earlier, the *x* and *y* values of the
    point can be multiplied by a factor. Note that even though the factor is a double,
    the resulting *x* and *y* values are always rounded to integers:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面提到的 `Size` 类类似，点的 *x* 和 *y* 值可以乘以一个因子。请注意，尽管因子是一个双精度值，但生成的 *x* 和 *y* 值始终四舍五入为整数：
- en: '[PRE22]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It is also possible to multiply the point with a pair of values, where the
    first value is multiplied with the *x* value and the second value is multiplied
    with the *y* value. Also, in this case, the resulting *x* and *y* values are integers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将点与一对值相乘，其中第一个值乘以 *x* 值，第二个值乘以 *y* 值。在这种情况下，生成的 *x* 和 *y* 值也是整数：
- en: '[PRE23]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first set of addition operators adds and subtracts the integer distance
    to both the *x* and *y* value of the point:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组加法运算符将整数距离加到点的 *x* 和 *y* 值上：
- en: '[PRE24]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second set of addition operators adds and subtracts the width and height
    of the size to the *x* and *y* values of the point:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组加法运算符将大小宽度和高度加到点的 *x* 和 *y* 值上：
- en: '[PRE25]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The third set of addition operators adds and subtracts the *x* and *y* values
    of the points:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第三组加法运算符将点的 *x* 和 *y* 值加和减去：
- en: '[PRE26]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The point can be written to, and read from, a file stream, the clipboard, and
    the registry:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 点可以写入、读取文件流、剪贴板和注册表：
- en: '[PRE27]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The *x* and *y* value of the point are inspected by the constant methods and
    modified by the non-constant methods:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 点的 *x* 和 *y* 值由常量方法检查并由非常量方法修改：
- en: '[PRE28]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The implementation of the `Point` class is also rather straightforward:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point` 类的实现也很直接：'
- en: '**Point.cpp**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**Point.cpp**'
- en: '[PRE29]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the assignment operator, it is a good custom to verify that we do not assign
    the same object. However, it is not completely necessary in this case since we
    just assign the integer values of *x* and *y*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在赋值运算符中，一个好的习惯是验证我们不会分配相同的对象。然而，在这种情况下并不完全必要，因为我们只是分配了 *x* 和 *y* 的整数值：
- en: '[PRE30]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The Rect class
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rect类
- en: 'The `Rect` class holds the four borders of a rectangle: left, top, right, and
    bottom.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rect` 类包含矩形的四个边：左、上、右和下。'
- en: '**Rect.h**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rect.h**'
- en: '[PRE31]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The default constructor sets all the four borders to zero. The rectangle can
    be initialized by, or assigned to, another rectangle. It is also possible to initialize
    the rectangle with the top-left and bottom-right corners, as well as the top-left
    corner and a size holding the width and height of the rectangle:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数将所有四个边设置为零。矩形可以通过另一个矩形初始化或赋值。也可以使用左上角和右下角以及包含矩形宽度和高度的尺寸初始化矩形：
- en: '[PRE32]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Similar to `SIZE` and `POINT` in the previous sections, a rectangle can be
    initialized and assigned to a value of the Win32 API `RECT` structure. A `Rect`
    object can also be converted to a `RECT`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几节中的 `SIZE` 和 `POINT` 类似，矩形可以初始化和赋值给 Win32 API `RECT` 结构的值。`Rect` 对象也可以转换为
    `RECT`：
- en: '[PRE33]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The compare operators first compare the top-left corners. If they are equal,
    the bottom-right corners are then compared:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符首先比较左上角。如果它们相等，然后比较右下角：
- en: '[PRE34]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The multiplication operators multiply all sides with the factor. Even though
    the factor is a double, the border values are always integers, similar to the
    `Size` and `Point` cases of the previous sections:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法运算符将所有边乘以因子。尽管因子是双精度浮点数，但边框值始终是整数，类似于前几节中的`Size`和`Point`情况：
- en: '[PRE35]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It is also possible to multiply the rectangle with a pair of values, where
    the first value is multiplied with `left` and `right`, and the second value is
    multiplied with `top` and `bottom`. Also, in this case, the resulting values are
    integers:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将矩形与一对值相乘，其中第一个值与`left`和`right`相乘，第二个值与`top`和`bottom`相乘。此外，在这种情况下，结果值都是整数：
- en: '[PRE36]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following operators are a little bit special: the addition operator adds
    the size to the bottom-right corner and leaves the top-left corner unchanged while
    the subtraction operator subtracts the size from the top-left corner and leaves
    the bottom-right corner unchanged:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下运算符有点特殊：加法运算符将大小添加到右下角，同时保持左上角不变，而减法运算符从左上角减去大小，同时保持右下角不变：
- en: '[PRE37]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'However, the following operators add and subtract the size to and from both
    the top-left and bottom-right corners:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下运算符将大小添加到或从左上角和右下角：
- en: '[PRE38]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following operators take a point as a parameter and add the point to, and
    subtract it from, both the top-left and bottom-right corner:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下运算符接受一个点作为参数，并将该点添加到，并从左上角和右下角减去：
- en: '[PRE39]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The width of a rectangle is the absolute difference between the left and right
    border, and its height is the absolute difference between the top and bottom border:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形的宽度是左右边框之间的绝对差值，其高度是上下边框之间的绝对差值：
- en: '[PRE40]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `GetSize` method returns the width and height of the rectangle. It is not
    possible to name it `Size`, since there is a class with that name. However, it
    is still possible to define an operator returning a `Size` object. The `Size`
    and `Point` operators return the size and top-left corner of the rectangle:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetSize`方法返回矩形的宽度和高度。由于存在具有该名称的类，因此无法将其命名为`Size`。然而，仍然可以定义返回`Size`对象的运算符。`Size`和`Point`运算符返回矩形的尺寸和左上角：'
- en: '[PRE41]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The top-left and bottom-right corner can both be inspected and modified. It
    is not appropriate to define methods returning a reference to a point since there
    are no corresponding fields for the corners:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 左上角和右下角都可以进行检查和修改。由于没有对应于角落的字段，因此不适当定义返回点引用的方法：
- en: '[PRE42]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `Clear` method sets all four corners to zero, `Normalize` swaps the left
    and right borders and the top and bottom borders if they appear in the wrong order,
    and `PointInside` returns `true` if the point is located inside the rectangle,
    assuming that it has been normalized:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clear`方法将所有四个角设置为0，`Normalize`方法如果左右边框和上下边框出现错误顺序，则交换左右边框和上下边框，`PointInside`方法如果点位于矩形内部，则返回`true`，假设它已经被归一化：'
- en: '[PRE43]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The rectangle can be written to and read from a file stream, the clipboard,
    and the registry:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形可以写入和读取文件流、剪贴板和注册表：
- en: '[PRE44]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The four corners are inspected by the constant methods and modified by the
    non-constant methods:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 四个角通过常量方法进行检查，并通过非常量方法进行修改：
- en: '[PRE45]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Similar to `Size` and `Point`, the implementation of `Rect` is rather straightforward.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Size`和`Point`类似，`Rect`的实现相当直接。
- en: '**Rect.cpp**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rect.cpp**'
- en: '[PRE46]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The Color class
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色类
- en: The `Color` class is a wrapper class for the Win32 API `COLORREF` structure,
    which holds a color in accordance with the Red-Green-Blue (RGB) standard. Each
    component of the color is represented by a value between 0 and 255, inclusive,
    which gives a theoretical total number of 256³ = 16,777,216 different colors,
    among which `Color` defines 142 standard colors.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color`类是Win32 API `COLORREF`结构的包装类，它按照红-绿-蓝（RGB）标准存储颜色。颜色的每个分量都由一个介于0到255之间的值表示，这给出了理论上的总数256³
    = 16,777,216种不同的颜色，其中`Color`定义了142种标准颜色。'
- en: '**Color.h**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**Color.h**'
- en: '[PRE47]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The default constructor initializes the color with zero for each of the red,
    green, and blue values, which corresponds to black. A color object can also be
    initialized by, and assigned to, another color:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数将红色、绿色和蓝色值初始化为零，这对应于黑色。颜色对象也可以通过另一个颜色初始化和赋值：
- en: '[PRE48]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The equality operators compare the red, green, and blue values:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 等价运算符比较红色、绿色和蓝色值：
- en: '[PRE49]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `Inverse` function returns the inverted color and `GrayScale` returns the
    corresponding grayscale color:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Inverse` 函数返回反转的颜色，而 `GrayScale` 返回相应的灰度颜色：'
- en: '[PRE50]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The color can be written to, and read from, a file stream, the clipboard, and
    the registry:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色可以被写入、从文件流、剪贴板和注册表中读取：
- en: '[PRE51]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The wrapped `COLORREF` structure value is inspected by the constant method
    and modified by the non-constant method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过常量方法检查包装的 `COLORREF` 结构值，并通过非常量方法进行修改：
- en: '[PRE52]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The predefined colors are constant objects:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的颜色是常量对象：
- en: '[PRE53]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The implementation of `Color` is rather straightforward. The Win32 `RGB` macro
    creates a `COLORREF` value based on the three color components.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color` 的实现相当直接。Win32 的 `RGB` 宏根据三个颜色组件创建一个 `COLORREF` 值。'
- en: '**Color.cpp**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**Color.cpp**'
- en: '[PRE54]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Two colors are equal if their wrapped `COLORREF` structures are equal, and they
    are compared with the C standard function `memcpy`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 两个颜色相等，如果它们的包装 `COLORREF` 结构相等，并且它们通过 C 标准函数 `memcpy` 进行比较。
- en: '[PRE55]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `Inverse` function returns the inverted color with each component subtracted
    from 255, and `GrayScale` returns the corresponding grayscale color with each
    component holding the average value of the red, green, and blue components. `GetRValue`,
    `GetGValue`, and `GetBValue` are Win32 API macros that extract the red, green,
    and blue components:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Inverse` 函数返回每个组件从 255 减去的反转颜色，而 `GrayScale` 返回每个组件持有红色、绿色和蓝色组件平均值的相关灰度颜色。`GetRValue`、`GetGValue`
    和 `GetBValue` 是 Win32 API 宏，用于提取红色、绿色和蓝色组件：'
- en: '[PRE56]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Each of the predefined colors calls the constructor that takes the red, green,
    and blue components:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个预定义的颜色都调用接受红色、绿色和蓝色组件的构造函数：
- en: '[PRE57]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The Font class
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Font` 类'
- en: The `Font` class is a wrapper class for the Win32 API `LOGFONT` structure. The
    structure holds a large set of properties; however, we only take into consideration
    the fields for the font's name and size and whether the font is italic, bold,
    or underlined; the other fields are set to zero. The system font is the font where
    all fields in the `LOGFONT` structure are set to zero, which results in the standard
    font of the system. Finally, the `Font` class also includes a `Color` object.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Font` 类是 Win32 API `LOGFONT` 结构的包装类。该结构包含大量属性；然而，我们只考虑字体名称和大小以及字体是否为斜体、粗体或下划线的字段；其他字段设置为零。系统字体是所有
    `LOGFONT` 结构字段都设置为零的字体，这导致系统的标准字体。最后，`Font` 类还包括一个 `Color` 对象。'
- en: '**Font.h**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**Font.h**'
- en: '[PRE58]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The default constructor sets the name to the empty string and all other values
    to zero, resulting in the system font, usually 10 points Arial. The size of the
    font is given in typographic points (1 point = 1/72 of an inch = 1/72 * 25.4 mm
    ≈ 0.35 mm). A font can also be initialized by, or assigned to, another font:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数将名称设置为空字符串，并将所有其他值设置为零，从而得到系统字体，通常是 10 点 Arial。字体的大小以排版点给出（1 点 = 1/72
    英寸 = 1/72 * 25.4 毫米 ≈ 0.35 毫米）。字体也可以通过另一个字体初始化或赋值：
- en: '[PRE59]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Two fonts are equal if they hold the same name and size as well as the same
    italic, bold, and underline status (all other fields are assumed to be zero):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个字体具有相同的名称和大小，以及相同的斜体、粗体和下划线状态（所有其他字段假定为零），则两个字体相等：
- en: '[PRE60]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The font can be written to, and read from, a file stream, the clipboard, and
    the registry:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 字体可以被写入、从文件流、剪贴板和注册表中读取：
- en: '[PRE61]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `PointToMeters` function converts a typographic point to logical units
    (hundredths of millimeters):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`PointToMeters` 函数将排版点转换为逻辑单位（毫米的百分之一）：'
- en: '[PRE62]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The wrapped `LOGFONT` structure is inspected by the constant method and modified
    by the non-constant method:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过常量方法检查包装的 `LOGFONT` 结构，并通过非常量方法进行修改：
- en: '[PRE63]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `color` field can also be inspected by the constant method and modified
    by the non-constant method:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`color` 字段也可以通过常量方法进行检查，并通过非常量方法进行修改：'
- en: '[PRE64]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**Font.cpp**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Font.cpp**'
- en: '[PRE65]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Two fonts are equal if their wrapped `LOGFONT` structures and their `Color`
    fields are equal:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个字体的包装 `LOGFONT` 结构和它们的 `Color` 字段相等，则两个字体相等：
- en: '[PRE66]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `write` and `read` methods write and read the wrapped `LOGFONT` structure
    and call the `Color` write and read methods:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 和 `read` 方法写入和读取包装的 `LOGFONT` 结构，并调用 `Color` 的写入和读取方法：'
- en: '[PRE67]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'A typographic point is 1/72^(th) of an inch, and an inch is 25.4 millimeters.
    To transform a font typographical unit to logical units (hundredths of millimeters),
    we divide the width and height by 72, multiply by 2,540 (2,540 logical units equals
    25.4 millimeters) and the zoom factor:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个排版点等于1/72英寸，一个英寸等于25.4毫米。要将字体排版单位转换为逻辑单位（毫米的百分之一），我们需要将宽度和高度除以72，乘以2,540（2,540逻辑单位等于25.4毫米）以及缩放因子：
- en: '[PRE68]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The Cursor class
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cursor类
- en: There is a set of cursors available in the Win32 API, all with names starting
    with `IDC_`. In Small Windows, they have been given other names, which are hopefully
    easier to understand. Unlike other cases, we cannot use an enumeration for the
    cursors, since they are actually zero-terminated C++ strings (character pointers).
    Instead, every cursor is a pointer to a zero-terminated string. `LPCTSTR` stands
    for **Long Pointer to Constant TChar String**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 API中有一组可用的光标，所有这些光标的名称都以`IDC_`开头。在小窗口中，它们被赋予了其他名称，希望这些名称更容易理解。与其他情况不同，我们不能为光标使用枚举，因为它们实际上是零终止的C++字符串（字符指针）。相反，每个光标都是一个指向零终止字符串的指针。`LPCTSTR`代表**长指针到常量TChar字符串**。
- en: The reason the cursor has its own class, while the caret has a method in the
    `Document` class is that the caret does need a window handle to be set, while
    the cursor does not.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 光标有自己类的原因，而光标在`Document`类中有方法，是因为光标确实需要一个窗口句柄来设置，而光标则不需要。
- en: '**Cursor.h**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cursor.h**'
- en: '[PRE69]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '**Cursor.cpp**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cursor.cpp**'
- en: '[PRE70]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `Set` method sets the cursor by calling the Win32 API functions `LoadCursor`
    and `SetCursor`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`方法通过调用Win32 API函数`LoadCursor`和`SetCursor`来设置光标：'
- en: '[PRE71]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The DynamicList class
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DynamicList类
- en: 'The `DynamicList` class can be regarded as a more advanced version of the C++
    standard classes `list` and `vector`. It varies its size dynamically:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`DynamicList`类可以被视为C++标准类`list`和`vector`的更高级版本。它动态地改变其大小：'
- en: '**DynamicList.h**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**DynamicList.h**'
- en: '[PRE72]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `IfFuncPtr` pointer is a function prototype that is used when testing (without
    changing) a value in the list. It takes a constant value and a `void` pointer
    and returns a `Boolean` value. `DoFuncPtr` is used when changing a value in the
    list and takes a (non-constant) value and a `void` pointer. The void pointers
    are sent by the calling methods; they hold additional information:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`IfFuncPtr`指针是一个函数原型，用于在测试（不更改）列表中的值时使用。它接受一个常量值和一个`void`指针，并返回一个`Boolean`值。`DoFuncPtr`用于更改列表中的值，并接受一个（非常量）值和一个`void`指针。这些`void`指针由调用方法传递；它们包含额外的信息：'
- en: '[PRE73]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The list can be initialized by, and assigned to, another list. The default
    constructor creates an empty list, and the destructor deallocates the memory from
    the list:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以通过另一个列表初始化和赋值。默认构造函数创建一个空列表，析构函数则释放列表的内存：
- en: '[PRE74]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `Empty` function returns `true` if the list is empty, `Size` returns the
    number of values in the list, `Clear` removes every value in the list, and `IndexOf`
    gives the zero-based index of the given value, or returns minus one if there is
    no such value in the list:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty`函数如果列表为空则返回`true`，`Size`返回列表中的值的数量，`Clear`移除列表中的每个值，而`IndexOf`返回给定值的零基于索引，如果没有这样的值在列表中，则返回负一：'
- en: '[PRE75]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `begin` and `end` methods return pointers to the beginning and end of the
    list. They are included in order for the list to be iterated by the `for` statement:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin`和`end`方法返回列表的开始和结束指针。它们被包含进来是为了使列表可以通过`for`语句迭代：'
- en: '[PRE76]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The index method inspects or modifies the value with the given zero-based index
    in the list:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 索引方法检查或修改列表中给定零基于索引的值：
- en: '[PRE77]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `Front` and `Back` methods inspect and modify the first and the last value
    of the list by calling the index methods mentioned previously:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Front`和`Back`方法通过调用之前提到的索引方法来检查和修改列表的第一个和最后一个值：'
- en: '[PRE78]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `PushFront` and `PushBack` methods add a value or a list at the beginning
    or at the end of the list, and `Insert` inserts a value or a list at the given
    index:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`PushFront`和`PushBack`方法在列表的开始或结束处添加一个值或一个列表，而`Insert`在指定的索引处插入一个值或一个列表：'
- en: '[PRE79]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `Erase` function deletes the value at the given index, and `Remove` deletes
    the list from `firstIndex` to `lastIndex`, inclusive, or the end of the list if
    `lastIndex` is minus one. If `firstIndex` is zero and `lastIndex` is minus one,
    the whole list is deleted. The methods have been given different names since `lastIndex`
    in `Remove` is a default parameter. Giving the methods the same name would be
    a violation of the overload rules:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Erase` 函数删除给定索引处的值，而 `Remove` 删除从 `firstIndex` 到 `lastIndex`（包含）的列表，如果 `lastIndex`
    为负一，则删除列表的末尾。如果 `firstIndex` 为零且 `lastIndex` 为负一，则删除整个列表。由于 `Remove` 中的 `lastIndex`
    是默认参数，因此方法已被赋予不同的名称。给方法赋予相同的名称将违反重载规则：'
- en: '[PRE80]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `Copy` function copies the list from `firstIndex` to `lastIndex`, inclusive,
    to `copyList` or the rest of the list if `lastIndex` is minus one, which implies
    that the whole list is copied if `firstIndex` is zero and `lastIndex` is minus
    one:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Copy` 函数将 `firstIndex` 到 `lastIndex`（包含）的列表复制到 `copyList` 或 `lastIndex` 为负一时的列表的其余部分。如果
    `firstIndex` 为零且 `lastIndex` 为负一，则整个列表被复制：'
- en: '[PRE81]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `AnyOf` function returns `true` if at least one value satisfies `ifFuncPtr`.
    That is, if `ifFuncPtr` returns `true` when called with the value as parameter.
    The `AllOf` function returns `true` if all values satisfy `ifFuncPtr`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnyOf` 函数如果至少有一个值满足 `ifFuncPtr`，则返回 `true`。也就是说，如果 `ifFuncPtr` 在以值作为参数调用时返回
    `true`，则 `AllOf` 函数返回 `true` 如果所有值都满足 `ifFuncPtr`：'
- en: '[PRE82]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `FirstOf` and `LastOf` methods set the `value` parameter to the first and
    last value satisfying `ifFuncPtr`; they return `false` is there are no such values:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`FirstOf` 和 `LastOf` 方法将 `value` 参数设置为满足 `ifFuncPtr` 的第一个和最后一个值；如果没有这样的值，则返回
    `false`：'
- en: '[PRE83]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `Apply` method calls `doFuncPtr` for all values in the list, and `ApplyIf`
    calls `doFuncPtr` for each value in the list that satisfies `ifFuncPtr`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Apply` 方法对列表中的所有值调用 `doFuncPtr`，而 `ApplyIf` 方法对列表中满足 `ifFuncPtr` 的每个值调用 `doFuncPtr`：'
- en: '[PRE84]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `CopyIf` method copies each value in the list satisfying `ifFuncPtr` to
    `copyList`. `RemoveIf` removes the values satisfying `ifFuncPtr`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`CopyIf` 方法将列表中满足 `ifFuncPtr` 的每个值复制到 `copyList`。`RemoveIf` 移除满足 `ifFuncPtr`
    的值：'
- en: '[PRE85]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `ApplyRemoveIf` method calls `doFuncPtr` to each value satisfying `ifFuncPtr`
    and then removes them. It may seem strange to apply a function to values that
    are to be removed. However, it is useful when removing dynamically allocated values,
    where `doFuncPtr` deallocates the memory of each value before it is removed from
    the list. It would not work to simply call `ApplyIf` and `RemoveIf`. When the
    values have been deleted by `ApplyIf`, they cannot be parameters to `ifFuncPtr`
    calls in `RemoveIf`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplyRemoveIf` 方法对满足 `ifFuncPtr` 的每个值调用 `doFuncPtr`，然后移除它们。将函数应用于要删除的值可能看起来很奇怪。然而，当删除动态分配的值时，这在其中
    `doFuncPtr` 在从列表中删除每个值之前释放每个值的内存时非常有用。简单地调用 `ApplyIf` 和 `RemoveIf` 是不起作用的。当值被
    `ApplyIf` 删除后，它们不能成为 `RemoveIf` 中 `ifFuncPtr` 调用的参数：'
- en: '[PRE86]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The size is the number of values in the list and the buffer holds the values
    themselves. The size of the buffer is dynamic and changes when values are added
    to, or removed from, the list. When the list is empty, the buffer points are null:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 大小是列表中的值的数量，缓冲区持有这些值本身。缓冲区的大小是动态的，当向列表中添加或从列表中删除值时，它会改变。当列表为空时，缓冲区指针为空：
- en: '[PRE87]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The default constructor and assignment operator iterates through the given
    list and copies each value. For this to work, the type must support the assignment
    operator, which all types, except arrays, do:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数和赋值运算符遍历给定的列表并复制每个值。为此，类型必须支持赋值运算符，除了数组之外的所有类型都支持：
- en: '[PRE88]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In the assignment operator, we first delete the buffer, as it may hold values.
    If the list is empty, the buffer points are null and the delete operator does
    nothing:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在赋值运算符中，我们首先删除缓冲区，因为它可能包含值。如果列表为空，缓冲区指针为空，删除运算符不执行任何操作：
- en: '[PRE89]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The destructor simply deletes the buffer. Again, if the list is empty, the
    buffer points are null and the delete operator does nothing:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数简单地删除缓冲区。再次强调，如果列表为空，缓冲区指针为空，删除运算符不执行任何操作：
- en: '[PRE90]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `Clear` method sets the size to zero and the buffer to null:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clear` 方法将大小设置为零并将缓冲区设置为空：'
- en: '[PRE91]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `IndexOf` method iterates through the list and returns the index of the
    found value, or it returns minus one if there is no such value:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexOf` 方法遍历列表并返回找到的值的索引，如果没有这样的值，则返回负一：'
- en: '[PRE92]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The `begin` method returns the address of the first value in the list:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin` 方法返回列表中第一个值的地址：'
- en: '[PRE93]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `end` method returns the address one step beyond the last value in the
    list, which is the convention of list iterators in C++:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'An assertion occurs if the index is beyond the list:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'When adding a value at the end of the original list, we need to allocate a
    new list with one extra value and add the new value at the end:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'When adding a new list at the end of the original list, we need to allocate
    a new list with the size of the original and new lists, and copy the values from
    the original list to the new list:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'When inserting a new value at the beginning of the list, we need to copy all
    the values in the original list one step forward to make room for the new value:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'When inserting a new list, at the beginning of the list, we need to copy all
    its values and the number of steps corresponding to the size of the new list to
    make room for its values:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We move the values of the original list in order to make room for the new list:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'When we have made room for the new list, we copy it to the original list at
    the beginning:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The `Insert` method works in ways similar to `PushFront`. We need to allocate
    a new list and copy values in the original list to make room for the new values,
    and then copy the new values into the original list:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'When erasing a value in the list, we allocate a new smaller list and copy the
    remaining values to that list:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'First, we copy the values before the delete index:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then, we copy the values after the delete index:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The `Remove` method works in the same way as `Delete`; the difference is that
    more than one value can be removed from the list; `removeSize` holds the number
    of values to be removed:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The `Copy` method simply calls `PushBack` for each value to be copied:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The `AnyOf` method iterates through the list and returns `true` if at least
    one value satisfies the function:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The `AllOf` method iterates through the list and returns `false` if at least
    one value does not satisfy the function:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The `FirstOf` method finds the first value in the list that satisfies the function,
    copies it to the value parameter, and returns `true`. If it does not find any
    value satisfying the function, `false` is returned:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The `LastOf` method finds the last value satisfying the function in the same
    way as `FirstOf`; the difference is that the search is performed backward:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The `Apply` method iterates through the list and calls `doFuncPtr` for each
    value, the value may be modified (actually, the point of `Apply` is that the value
    is modified) since the parameter to `doFuncPtr` is not constant:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The `ApplyIf` method iterates through the list and calls `doFuncPtr` for each
    value that satisfies `ifFuncPtr`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The `CopyIf` method copies every value that satisfies `ifFuncPtr` to `copyList`
    by calling `PushBack`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The `RemoveIf` method removes every value that satisfies `ifFuncPtr` by calling
    `Delete` for each value:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The `ApplyRemoveIf` method applies `doFuncPtr` to each value that satisfies
    `ifFuncPtr`. We cannot simply call `Apply` and `RemoveIf`, since `doFuncPtr` may
    deallocate the values in `Apply`, and `ifFuncPtr` in `RemoveIf` would not work
    when called on deleted values. Instead, we call `doFuncPtr` and call `Erase` immediately
    after. In this way, the values are not accessed after the call to `doFuncPtr`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplyRemoveIf` 方法将 `doFuncPtr` 应用到满足 `ifFuncPtr` 的每个值。我们不能简单地调用 `Apply` 和
    `RemoveIf`，因为 `doFuncPtr` 可能会释放 `Apply` 中的值，而 `RemoveIf` 中的 `ifFuncPtr` 在调用已删除的值时不会工作。相反，我们调用
    `doFuncPtr` 并在调用后立即调用 `Erase`。这样，在调用 `doFuncPtr` 之后不会访问值：'
- en: '[PRE116]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The Tree class
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树类
- en: 'The C++ standard library hold a set of container classes for arrays, lists,
    vectors, sets, and maps. However, there is no class for a tree structure. Therefore,
    the `Tree` class has been added to Small Windows. A tree is made up of a set of
    nodes, among which, one is the root node. Each node holds a (possibly empty) list
    of child nodes:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 标准库包含一组用于数组、列表、向量、集合和映射的容器类。然而，没有用于树结构的类。因此，`Tree` 类被添加到 Small Windows 中。树由一组节点组成，其中之一是根节点。每个节点持有一个（可能为空）的子节点列表：
- en: '**Tree.h**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tree.h**'
- en: '[PRE117]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The tree can be written to, and read from, a file stream or the clipboard:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 树可以被写入和从文件流或剪贴板读取：
- en: '[PRE118]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Each tree node holds a value that is inspected by the constant method and modified
    by the non-constant method:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 每个树节点持有一个值，该值由常量方法检查并由非常量方法修改：
- en: '[PRE119]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The tree node also holds a list of child nodes, which is inspected by the constant
    method and modified by the non-constant method:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 树节点还持有一个子节点列表，该列表由常量方法检查，并由非常量方法修改：
- en: '[PRE120]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The child list is an initializer list of tree nodes; it is empty by default:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 子节点列表是一个树节点的初始化列表；默认情况下它是空的：
- en: '[PRE121]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The default constructor and the assignment operator call `Init` to do the actual
    initialization of the tree:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数和赋值运算符调用 `Init` 来执行树的实际初始化：
- en: '[PRE122]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The destructor deletes the children recursively:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数递归地删除子节点：
- en: '[PRE123]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The `WriteTreeToStream` method writes the node value and the number of children
    to the stream, and then calls itself recursively for each child:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteTreeToStream` 方法将节点值和子节点数量写入流，然后对每个子节点递归调用自身：'
- en: '[PRE124]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The `ReadTreeFromStream` method reads the node value and the number of children
    from the stream, creates the children, and calls itself recursively for each child:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadTreeFromStream` 方法从流中读取节点值和子节点数量，创建子节点，并对每个子节点递归调用自身：'
- en: '[PRE125]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The `WriteTreeToClipboard` and `ReadTreeFromClipboard` methods work in ways
    similar to `WriteTreeToStream` and `ReadTreeFromStream`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteTreeToClipboard` 和 `ReadTreeFromClipboard` 方法的工作方式与 `WriteTreeToStream`
    和 `ReadTreeFromStream` 类似：'
- en: '[PRE126]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The InfoList class
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InfoList 类
- en: The `InfoList` class is an auxiliary class with template methods that stores
    information in a character list; information can be added and extracted; or written
    to, or read from, a buffer.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`InfoList` 类是一个具有模板方法的辅助类，它将信息存储在字符列表中；信息可以被添加和提取；或者写入，或从缓冲区读取：'
- en: '**InfoList** **.h**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**InfoList** **.h**'
- en: '[PRE127]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The `Align` function increases the list one byte at a time until the size of
    the align type is a divisor of the list size:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Align` 函数逐字节增加列表，直到对齐类型的大小是列表大小的除数：'
- en: '[PRE128]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The `AddValue` function adds a value of the template type by adding its value
    byte by byte to the list, while `GetValue` gets the value at the beginning of
    the list by extracting it byte by byte from the list:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddValue` 函数通过逐字节将模板类型的值添加到列表中来添加值，而 `GetValue` 通过逐字节从列表中提取值来获取列表开头的值：'
- en: '[PRE129]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The `AddString` function adds the characters of the text to the list along
    with a terminating zero character, while `GetString` reads the text from the list
    until it encounters the terminating zero character:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddString` 函数将文本的字符添加到列表中，并附带一个终止零字符，而 `GetString` 从列表中读取文本，直到遇到终止零字符：'
- en: '[PRE130]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '**InfoList.cpp**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**InfoList.cpp**'
- en: '[PRE131]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The `FromBuffer` function adds each byte of the buffer to the list, while `ToBuffer`
    extracts and copies each byte of the list to the buffer:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromBuffer` 函数将缓冲区的每个字节添加到列表中，而 `ToBuffer` 从列表中提取并复制每个字节到缓冲区：'
- en: '[PRE132]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Strings
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'There are a small set of string functions:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有少量字符串函数：
- en: '`CharPtrToGenericString`: This takes text as a `char` character pointer and
    returns the same text as a generic `String` object. Remember that the `String`
    class holds values of the `TCHAR` type, of which many are `char` or `wchar_t`
    depending on system settings.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharPtrToGenericString`：这接受文本作为一个 `char` 字符指针，并以一个通用的 `String` 对象返回相同的文本。请记住，`String`
    类持有 `TCHAR` 类型的值，其中许多是 `char` 或 `wchar_t`，这取决于系统设置。'
- en: '`Split`: This takes a string and returns a list of strings holding the space-separated
    words of the text.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Split`：这接受一个字符串并返回一个包含文本空格分隔单词的字符串列表。'
- en: '`IsNumeric`: This returns`true` if the text holds a numeric value.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsNumeric`：如果文本包含一个数值，则此函数返回`true`。'
- en: '`Trim`: This removes spaces at the beginning and at the end of the text.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trim`：这会移除文本开头和结尾的空格。'
- en: '`ReplaceAll`: This replaces one string with another string.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReplaceAll`：这会将一个字符串替换为另一个字符串。'
- en: '`WriteStringToStream` and `ReadStringFromStream`: These write and read a string
    to and from a stream.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteStringToStream` 和 `ReadStringFromStream`：这些函数将字符串写入和从流中读取。'
- en: '`StartsWith` and `EndsWith`: These return`true` if the text starts or ends
    with the subtext.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StartsWith` 和 `EndsWith`：如果文本以子文本开头或结尾，则这些函数返回`true`。'
- en: '**String.h**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**String.h**'
- en: '[PRE133]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '**String.cpp**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**String.cpp**'
- en: '[PRE134]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The `IsNumeric` method uses the `IStringStream` method to read the value of
    the string and compare the number of characters read with the length of the text.
    If all the characters of the text are read, the text will hold a numeric value
    and `true` will be returned:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsNumeric` 方法使用 `IStringStream` 方法读取字符串的值，并将读取的字符数与文本长度进行比较。如果读取了文本的所有字符，则文本将包含一个数值，并返回
    `true`：'
- en: '[PRE135]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we studied the auxiliary classes used by Small Windows. In
    [Chapter 13](ch13.html "Chapter 13. The Registry, Clipboard, Standard Dialogs,
    and Print Preview"), *The Clipboard, Standard Dialogs, and Print Preview*, we
    will look into the registry, the clipboard, standard dialogs, and print preview.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Small Windows所使用的辅助类。在[第13章](ch13.html "第13章。注册表、剪贴板、标准对话框和打印预览")，*剪贴板、标准对话框和打印预览*中，我们将探讨注册表、剪贴板、标准对话框和打印预览。
