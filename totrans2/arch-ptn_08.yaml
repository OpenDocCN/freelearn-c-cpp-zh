- en: Event-Driven Architectural Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动架构模式
- en: Why do organizations need **event-driven architecture** (**EDA**)? Organizations
    across the world are operating in an agile manner and changing their structure
    frequently. They are evolving into business structures that can operate as independent
    service providers and consumers. These service providers and consumers need not
    necessarily exist within the organization. Some business services are outsourced
    to external business partners and other business services within the organization
    are looking to provide their services to external organizations in addition to
    internal business lines. All these emerging trends necessitate process architectures
    that have high levels of autonomy, or in other words, loose coupling between various
    application components that exist within an organization. The need for loosely
    coupled architecture with high levels of autonomy led to the evolution of EDA.
    Using EDA, organizations can rapidly reorganize their structure without changing
    their application constructions. Now, let us get started with the details of EDA.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么组织需要**事件驱动架构**（**EDA**）？全球的组织都在以敏捷的方式运营，并频繁地改变其结构。它们正在演变成为可以独立作为服务提供者和消费者的商业结构。这些服务提供者和消费者不一定存在于组织内部。一些商业服务外包给外部商业伙伴，而组织内部的其他商业服务正在寻求向外部组织提供其服务，除了内部业务线。所有这些新兴趋势都需要具有高度自主性的流程架构，换句话说，就是组织内部各种应用组件之间的高度松散耦合。对高度松散耦合架构的需求导致了EDA的演变。使用EDA，组织可以快速重组其结构，而无需改变其应用程序结构。现在，让我们开始探讨EDA的细节。
- en: 'An event in a generic sense refers to any change in state that is of interest
    to an organization/business/end user. The signal in a car indicating that the
    gas is low, the ringing of a mobile phone, and the ringing of a smoke alarm in
    a house are all examples of some real-world events that we come across in our
    everyday lives. Understanding the concept of an event is easier with the help
    of an example, as depicted in the following diagram:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在广义上，事件指的是任何对组织/企业/最终用户感兴趣的状态变化。汽车中指示汽油低量的信号、手机铃声以及家中烟雾报警器的铃声都是我们在日常生活中遇到的某些真实世界事件的例子。通过以下图例的帮助，理解事件的概念更容易一些：
- en: '![](img/c2f95cf4-938d-4c8d-b0d0-964293edf98a.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c2f95cf4-938d-4c8d-b0d0-964293edf98a.png)'
- en: The diagram depicts the flow of actions in an order management system. As soon
    as an order management system receives an order from a website or from an order
    entry system, the next step would be to notify other systems about the order.
    In this step, receiving an order is an event. This event needs to be published
    to other systems that would be interested in this event. In this example, the
    other systems that would be interested in this event are a warehouse management
    system that would check the order item in the inventory stored in the warehouse
    to ensure its availability and a finance system that would check the credit balance
    or the payment mechanism that is associated with the order.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 该图描述了一个订单管理系统中的动作流程。一旦订单管理系统从网站或订单录入系统接收到订单，下一步就是通知其他系统关于该订单的信息。在这一步中，接收订单是一个事件。这个事件需要发布给其他可能对此事件感兴趣的系统。在这个例子中，可能对此事件感兴趣的其他系统是一个仓库管理系统，它会检查存储在仓库中的库存中的订单项以确保其可用性，以及一个财务系统，它会检查与订单相关的信用余额或支付机制。
- en: Each of these systems will, in turn, publish an event to other systems that
    are required to complete the next step in order processing. Accordingly, the warehouse
    system may publish an inventory allocated event and the financial system may publish
    a payment validated event to the shipping system. The shipping system will, in
    turn, make necessary arrangements to ship the order to the customer. In this specific
    flow of events, these are the component systems that are a part of the event flow.
    But there could be several other systems that could form a part of the event flow
    based on the outcomes of event processing at each step. For example, if the warehouse
    management system detects low inventory levels for the item placed in the order,
    it will trigger an event to the procurement system to procure the item. Similarly,
    if the financial system detects a low credit balance or an incorrect payment option,
    it will trigger an email notification to the customer that the credit balance
    is low or the payment was not completed successfully.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统都会依次向其他需要完成下一步订单处理的系统发布事件。因此，仓库系统可能会发布一个分配库存的事件，而财务系统可能会向运输系统发布一个支付验证的事件。运输系统随后将进行必要的安排，将订单发送给客户。在这个特定的事件流程中，这些是事件流程的一部分的组件系统。但根据每个步骤事件处理的结果，可能还有其他几个系统可以成为事件流程的一部分。例如，如果仓库管理系统检测到订单中放置的物品库存水平低，它将触发一个事件到采购系统以采购该物品。同样，如果财务系统检测到信用余额低或支付选项不正确，它将向客户发送电子邮件通知，告知信用余额低或支付未成功完成。
- en: 'From this example, we understand that the crux of EDA is the concept of **publish**/**subscribe.**
    In the preceding example, the order management system publishes the order event
    to two other interested parties that have subscribed to the event warehouse management
    system and financial system. These two systems, in turn, publish events to shipping
    systems and so on. The three important definitions in the context of the EDA pattern
    are the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们了解到EDA的核心概念是**发布**/**订阅**。在先前的例子中，订单管理系统向两个已订阅该事件的感兴趣方发布订单事件，即仓库管理系统和财务系统。这两个系统随后将事件发布到运输系统等。在EDA模式背景下，有三个重要的定义如下：
- en: '**Event**: An event is a runtime operation, executed by a software element
    to make some information (including the information that it occurred) available
    for potential use by software elements not specified by the operation.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：事件是由软件元素在运行时执行的操作，用于使某些信息（包括它发生的信息）可供潜在的非指定操作软件元素使用。'
- en: '**Publisher**: To trigger (or publish) an event is to execute it. A software
    element that may trigger events is a publisher. A software element that may use
    the event''s information is a subscriber.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布者**：触发（或发布）一个事件就是执行它。可能触发事件的软件元素是发布者。可能使用事件信息的软件元素是订阅者。'
- en: '**Context**: In event-driven design, a context is a Boolean expression speciﬁed
    by a subscriber at registration time, but evaluated at triggering time, such that
    the registered action will only be executed if the evaluation yields true.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：在事件驱动设计中，上下文是在注册时由订阅者指定的布尔表达式，但在触发时评估，这样注册的动作只有在评估结果为真时才会执行。'
- en: The event-driven pattern is a class of patterns that has gained a lot of traction
    of late because of the rapidly changing industry paradigm. Many folks get easily
    confused between **service-oriented architecture** (**SOA**) and EDA patterns.
    In the next section, we will try to analyze and understand the differences between
    the two.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动模式是一类近年来由于行业范式快速变化而获得大量关注的模式。许多人容易混淆**面向服务的架构**（SOA）和EDA模式。在下一节中，我们将尝试分析和理解两者之间的区别。
- en: Service-oriented architecture and event-driven architecture (SOA versus EDA)
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向服务的架构和事件驱动架构（SOA与EDA）
- en: Organizations across the world are changing their structures rapidly and are
    moving toward on-demand business models. There is an increase in the movement
    toward setting up network-oriented business structures that will have autonomous
    service providers and consumers. Outsourcing is also very prominent as many parts
    of the business process will also be outsourced to external business partners.
    Various departments and business units who are present within organizations are
    taking on the role of service providers. The focus of these service providers
    is to increasingly provide services to the external market entities. This necessitates
    organizations being agile enough to quickly respond to changes or events that
    happen in the external environment. All these aspects demand a paradigm shift
    from a command-driven, tightly coupled, service-driven SOA concept to a more loosely
    coupled model that is driven by events. EDA is a publish/subscribe type of pattern.
    In the context of EDA, the publisher is completely unaware of the subscriber,
    and vice versa. Components of the EDA pattern are so loosely coupled that only
    the semantics of the message is shared between them. Now, the decision that needs
    to be made is when to use SOA and when to use EDA.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 世界各地的组织正在迅速改变其结构，并向按需商业模式转变。设置以网络为中心的商业结构趋势在增加，这将拥有自主的服务提供者和消费者。外包也非常突出，因为业务流程的许多部分也将外包给外部商业伙伴。组织内部存在的各个部门和业务单元正在承担服务提供者的角色。这些服务提供者的重点是越来越多地向外部市场实体提供服务。这要求组织足够敏捷，能够快速应对外部环境中的变化或事件。所有这些方面都要求从命令驱动、紧密耦合、服务驱动的SOA概念向更松散耦合的事件驱动模型转变。EDA是一种发布/订阅类型的模式。在EDA的背景下，发布者对订阅者一无所知，反之亦然。EDA模式中的组件耦合非常松散，它们之间只有消息的语义是共享的。现在，需要做出的决定是何时使用SOA和何时使用EDA。
- en: 'There is a common tendency to use EDA and SOA interchangeably because of the
    nature of their working. But that should not be the case. There are clear differentiators
    between the two architectural options. For situations that demand a strong cohesion
    in the business processes, SOA is the ideal choice of architecture. The following
    are the various scenarios in which a command/control style of SOA could be an
    ideal choice of architecture for organizations:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的工作性质，人们普遍倾向于将EDA和SOA互换使用。但情况不应如此。这两个架构选项之间存在明显的区别。对于需要业务流程强凝聚力的场景，SOA是理想的架构选择。以下是一些命令/控制风格的SOA可能成为组织理想架构选择的场景：
- en: If there exists a vertical interaction between the various hierarchical layers
    of functions that exist in an organization
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在组织内各种功能层级之间的垂直交互
- en: If there are functional request-and-reply processes such as man-machine dialogues
    where the user feeds a question and waits for an answer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在功能请求和回复流程，例如人机对话，其中用户提出问题并等待答案
- en: If there are processes that are transactional in nature that requires commit
    and rollback features
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在需要提交和回滚功能的交易性质流程
- en: If data enrichment is required in a message for it to be published to its full
    content in a formal format
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要数据丰富化，以便以正式格式发布消息的全部内容
- en: 'EDA is the preferred style for organizations that require a loose coupling
    between their various processes. EDA is the choice of architecture in federated
    and autonomous processing environments. The following are some of the scenarios
    in which EDA is an ideal choice of architecture for organizations:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: EDA是那些需要在各种流程之间实现松散耦合的组织的首选风格。EDA是联邦和自主处理环境中的架构选择。以下是一些EDA作为组织理想架构选择的场景：
- en: If there exists a horizontal communication between various tiers that are part
    of process chain
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在属于流程链各层的横向通信
- en: If there are workflow types of processes in an organization
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个组织中有工作流程类型的流程
- en: If there exist processes that involve cross-functional borders of organizations,
    for example, a B2B process
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在涉及组织跨职能边界的流程，例如，B2B流程
- en: 'Aiming for loose coupling in architecture always provides the flexibility and
    the agility that is necessary for present-day organizations. So, the rule of thumb
    to be followed while designing architectures for organizations is use loose coupling
    whenever possible and use tightly coupled architectural options only if required.
    Other aspects of design, such as performance, response time, and so on, should
    also be taken into consideration while making architectural design choices. In
    a typical enterprise-level organization, the bifurcation and the relationship
    of processes with regard to EDA and SOA architecture are depicted in the following
    diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构中追求松散耦合始终为现代组织提供必要的灵活性和敏捷性。因此，在设计组织架构时应遵循的规则是尽可能使用松散耦合，只有在必要时才使用紧密耦合的架构选项。在做出架构设计选择时，还应考虑设计的其他方面，如性能、响应时间等。在一个典型的企业级组织中，以下图展示了与EDA和SOA架构相关的流程的分支和关系：
- en: '![](img/b39f1fe8-62e9-46e2-ab44-97553635e40e.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b39f1fe8-62e9-46e2-ab44-97553635e40e.png)'
- en: In the diagram, the circles at the top denote loosely coupled systems, which
    are good candidates to be chosen as decoupling points or events. At these decoupling
    points, the various system components can be connected or disconnected without
    altering the connected peer systems. Data exchange between various domains in
    an organization takes place only at these decoupling points and not at the lower
    levels of systems that are tightly coupled. Within the reuse domain (indicated
    at the bottom of the figure), a fine-grained EDA implementation would be required
    to decouple the components because of their tight integration. The more fine-grained
    the EDA implementation is, the greater the flexibility of IT systems will be,
    but this would also reduce the scope of reuse of domains.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，顶部的圆圈表示松散耦合的系统，这些系统是作为解耦点或事件的理想选择。在这些解耦点上，各个系统组件可以连接或断开，而不会改变连接的相邻系统。组织内部各个领域之间的数据交换仅在解耦点上发生，而不是在紧密耦合的系统较低层级上。在重用领域（如图底部所示），由于组件之间紧密集成，需要精细粒度的EDA实现来解耦。EDA实现越精细，IT系统的灵活性就越大，但这也将减少领域的重用范围。
- en: 'In the preceding diagram, if web services technology is used at decoupling
    points along with a common infrastructure backbone such as an enterprise service
    bus, it is very easy to establish connectivity between heterogeneous systems.
    Systems that are present downstream need not be SOA alone; they can also be SOAP-wrapped
    legacy systems, **commercial off-the-shelf software** (**COTS**), or other applications
    such as ERP. The following diagram shows the integration of EDA and SOA . In this
    diagram, components are connected through decoupling points, which are events:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，如果在解耦点使用Web服务技术，并结合如企业服务总线这样的通用基础设施骨干，建立异构系统之间的连接就非常容易。下游存在的系统不必仅仅是SOA；它们也可以是SOAP包装的遗留系统、**商业现货软件**（**COTS**）或其他如ERP等应用程序。以下图展示了EDA与SOA的集成。在这个图中，组件通过解耦点连接，这些解耦点是事件：
- en: '![](img/c4831894-3af5-4267-b849-3beb6c8a512f.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4831894-3af5-4267-b849-3beb6c8a512f.png)'
- en: Now, we have clearly learned the differences between EDA and SOA. In the next
    section, we will learn the components of an EDA pattern. These components should
    be part of any architecture that uses EDA patterns.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经清楚地了解了EDA和SOA之间的区别。在下一节中，我们将学习EDA模式的部分。这些组件应该是任何使用EDA模式的架构的一部分。
- en: Key characteristics of event-driven patterns
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动模式的关键特性
- en: 'If there is a component in a system that publishes and accepts events, can
    you consider that as an example of an EDA pattern? The answer to the question
    is a clear no. In this section, we will examine the characteristics of EDA patterns.
    Their main characteristics are the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个系统中的组件发布和接受事件，你能将其视为EDA模式的一个例子吗？对这个问题的答案是明确的否定。在本节中，我们将检查EDA模式的特点。它们的主要特点如下：
- en: '**Multicast communications**: The publishers or the participating systems have
    the capability to send events to multiple systems that have subscribed to it.
    In other words, it is not a unicast communication in which one sender can send
    data only to one receiver.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多播通信**：发布者或参与系统有向已订阅该事件的多系统发送事件的能力。换句话说，这不是单播通信，其中发送者只能向一个接收者发送数据。'
- en: '**Real-time transmission**: Publishers publish the events as and when they
    occur in real time to the subscribers. In other words, the mode of processing
    or transmission involved here is real time and not batch processing.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时传输**：发布者将事件实时发布给订阅者。换句话说，这里涉及的处理或传输模式是实时，而不是批量处理。'
- en: '**Asynchronous communication**: The publisher does not wait for the receiver
    to process an event before sending the next event.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步通信**：发布者在发送下一个事件之前不会等待接收者处理当前事件。'
- en: '**Fine-grained communication**: Publishers keep publishing individual fine-grained
    events instead of waiting for a single aggregated event.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细粒度通信**：发布者继续发布单个细粒度事件，而不是等待单个聚合事件。'
- en: '**Ontology**: EDA systems always have a technique to classify events in terms
    of some form of a group/hierarchy based on their common characteristics. This
    gives flexibility to the subscribers to subscribe to a specific event or specific
    category of events.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本体**：EDA 系统总是有一种根据事件的一些共同特征将事件分类为某种形式的组/层次结构的技术。这为订阅者提供了订阅特定事件或特定类别事件的灵活性。'
- en: Components of an EDA pattern
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EDA 模式的组件
- en: 'The main components of the EDA pattern are the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: EDA 模式的核心组件如下：
- en: Event specifications
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件规范
- en: Event processing
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理
- en: Event tooling
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件工具
- en: Enterprise integration
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业集成
- en: Sources and targets
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源和目标
- en: 'All these components and the various other subcomponents are summarized in
    the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些组件以及各种其他子组件总结在下图中：
- en: '![](img/dd43f4d5-37fc-42f8-be7f-bbb670fe9221.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd43f4d5-37fc-42f8-be7f-bbb670fe9221.png)'
- en: 'The core component of any EDA is strong metadata architecture. The core components
    of event metadata architecture are the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 任何电子设计自动化（EDA）的核心组件都是强大的元数据架构。事件元数据架构的核心组件包括以下内容：
- en: '**Event specifications**: These event specifications should be made available
    to event generators, event processing engines, and event transformers. There is
    no industry-approved standard for event definition and processing at the moment;
    they are just in the evolving phase.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件规范**：这些事件规范应提供给事件生成器、事件处理引擎和事件转换器。目前还没有行业认可的事件定义和处理标准；它们正处于发展阶段。'
- en: '**Event processing**: This is a technique for processing and analyzing streams
    of data about events with an objective of deriving some kind of a conclusion from
    them, for example, a weather prediction system whose main function is to predict
    the onset of cyclones. For the system to derive this conclusion, it should take
    into consideration several patterns, such as wind speed, the direction of flow,
    atmospheric pressure, moisture content, and so on. All these parameters constitute
    the event data, and this data should be processed by an event engine in order
    to arrive at specific conclusions. So, the essential components that are required
    for any event processing are the following:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件处理**：这是一种处理和分析事件数据流的技术，目的是从中得出某种结论，例如，一个主要功能是预测气旋发生的天气预测系统。为了得出这个结论，系统应该考虑几个模式，如风速、流向方向、大气压力、含水量等。所有这些参数构成了事件数据，这些数据应由事件引擎处理，以便得出特定的结论。因此，任何事件处理所需的必要组件如下：'
- en: Event engine
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件引擎
- en: Event data
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件数据
- en: '**Event tooling**: Event development tools provide the following key functions
    with regard to the processing of events:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件工具**：事件开发工具在事件处理方面提供了以下关键功能：'
- en: Define event specifications
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义事件规范
- en: Define event processing rules
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义事件处理规则
- en: Manage event subscriptions
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理事件订阅
- en: They also provide add-on functions such as monitoring of event processing infrastructure
    and event flows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还提供附加功能，如监控事件处理基础设施和事件流。
- en: '**Enterprise integration**: This has a pivotal role to play in EDA design.
    Some of the necessary integration services that are required are the following:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业集成**：这在 EDA 设计中扮演着关键角色。一些必要的集成服务包括以下内容：'
- en: Event preprocessing
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件预处理
- en: Event channel transport
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件通道传输
- en: Service invocation
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务调用
- en: Publication and subscription
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布和订阅
- en: Enterprise information access
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业信息访问
- en: '**Sources and targets**: Sources refer to the components of the enterprise
    that generate events. This could refer to systems, services, automated agents,
    or even people who are responsible for creating events. Targets refer to the components
    that perform an action based on the occurrence of events or based on the event
    outcomes. The topology of sources and targets of events are governed by several
    parameters, such asthe following:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来源和目标**：来源指的是生成事件的企业的组件。这可能指的是系统、服务、自动化代理，甚至是负责创建事件的人。目标指的是基于事件发生或基于事件结果执行动作的组件。事件来源和目标拓扑由多个参数控制，如下所示：'
- en: Event flows
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件流
- en: Event occurrence volumes
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件发生量
- en: Location of sources and targets and so on
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来源和目标的位置等
- en: Event flows are a very important component of EDA architecture. In the next
    section, we will see the various logical layers that are present in an event flow.
    These logical layer components need to be carefully chosen and designed for successful
    implementation of EDA patterns.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 事件流是EDA架构的一个重要组成部分。在下一节中，我们将看到事件流中存在的各种逻辑层。这些逻辑层组件需要仔细选择和设计，以确保EDA模式的成功实施。
- en: Event flow layers
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件流层
- en: 'The four logical layers present in the event flow are the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 事件流中存在的四个逻辑层如下：
- en: Event generators
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件生成器
- en: Event channel
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件通道
- en: Event processing
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理
- en: Downstream event-driven activity
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下游事件驱动活动
- en: Event generators
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件生成器
- en: The sources from where events are generated are called **event generators**.
    The source could be an application, service, business process, sensor, database,
    or even a human being. An event that is generated is evaluated for notability
    by an event filter, and if the evaluation is successful, leads to the generation
    of a notable event. Since there are diverse sources for the generation of events,
    not all generated events will be in a format that is suitable for processing.
    For such events, it is necessary to ensure that they are converted into a compatible
    format before they are sent to the event channel.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 生成事件的来源被称为**事件生成器**。来源可以是应用程序、服务、业务流程、传感器、数据库，甚至是人类。一个生成的事件将通过事件过滤器进行显著性的评估，如果评估成功，则导致显著事件的生成。由于事件生成的来源多种多样，并非所有生成的事件都适合处理。对于此类事件，在将它们发送到事件通道之前，有必要确保它们被转换为兼容的格式。
- en: Event channel
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件通道
- en: This acts a transmission medium and messaging backbone for EDA. It receives
    standard formatted events from the event generator and sends them to other event
    generators, event processing engines, and downstream subscribers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这充当了EDA的传输介质和消息骨干。它从事件生成器接收标准格式的事件并将它们发送到其他事件生成器、事件处理引擎和下游订阅者。
- en: Event processing
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理
- en: Once the events are received, they are processed and evaluated based on some
    rules that are stored in the event processing engine. Based on the results of
    the evaluation, a specific course of action is initiated. The event rules are
    created based on the criteria specified by the organization and/or other interested
    parties. Event processing could result in several courses of action, such as notifying
    a certain system/agency, taking an alternate course of action, initiating a business
    process, and so on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦接收到事件，它们将根据存储在事件处理引擎中的某些规则进行处理和评估。根据评估结果，将启动特定的行动方案。事件规则是根据组织和其他相关方指定的标准创建的。事件处理可能导致多个行动方案，例如通知某个系统/机构、采取替代行动方案、启动业务流程等。
- en: Downstream event-driven activity
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下游事件驱动活动
- en: Any event can trigger a sequence of downstream activities that could be a response
    to the event. The event could be a push notification by the event processing engine
    or pull notifications by the subscribers. Subscribers in this context could refer
    to an application, humans, services, or business processes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 任何事件都可以触发一系列下游活动，这可能是对事件的响应。事件可以是事件处理引擎的推送通知或订阅者的拉取通知。在此上下文中，订阅者可以指应用程序、人类、服务或业务流程。
- en: Design considerations for event-driven patterns
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动模式的设计考虑因素
- en: 'In this section, we will explain the various design considerations that need
    to be kept in mind before choosing EDA patterns for architecture implementation.
    The main considerations are the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释在选择架构实现前的EDA模式时需要考虑的各种设计因素。主要考虑因素如下：
- en: '**Agility**: Agility refers to the ability to cope with the rapid changes that
    happen in the environment. In the EDA pattern, components are loosely coupled.
    This ensures that changes that happen to one component do not affect the other
    components in the system. Hence, the degree of agility offered by the EDA pattern
    is high, making it an ideal choice for the design of systems that require continuous
    changes without any downtime.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**敏捷性**：敏捷性指的是应对环境快速变化的能力。在EDA模式中，组件是松散耦合的。这确保了某个组件的变化不会影响系统中的其他组件。因此，EDA模式提供的敏捷度很高，使其成为设计需要持续变化且无需停机时间的系统的理想选择。'
- en: '**Ease of deployment**: The EDA pattern components are loosely coupled in nature,
    which makes their deployment very easy. For solutions that require maximum ease
    of deployment, event broker topology is a better option than event mediator topology.
    This is due to the fact that in event mediator topology, there exists a relatively
    tight coupling between the event mediator and event processor.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署简便性**：EDA模式组件本质上是松散耦合的，这使得它们的部署非常容易。对于需要最大部署简便性的解决方案，事件代理拓扑比事件中介拓扑更好。这是因为事件中介拓扑中，事件中介和事件处理器之间存在相对紧密的耦合。'
- en: '**Testability**: Unit testing of EDA pattern components is difficult because
    of the fact that it requires special test clients and test tools to generate events
    that are required for testing purposes.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：由于需要特殊的测试客户端和测试工具来生成测试所需的事件，因此EDA模式组件的单元测试比较困难。'
- en: '**Performance**: EDA has the capability to perform asynchronous operations
    in parallel, which provides very high performance for the architecture, irrespective
    of the time lag involved in queuing and dequeuing messages.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：EDA能够并行执行异步操作，这为架构提供了非常高的性能，无论涉及的消息排队和出队的时间滞后如何。'
- en: '**Scalability**: EDA offers a high level of scalability because of the highly
    decoupled nature of the components.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：由于组件高度解耦，EDA提供了高水平的可伸缩性。'
- en: '**Ease of development**: Ease of development using this pattern is low because
    of the asynchronous nature of the pattern.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发简便性**：由于模式的异步特性，使用此模式进行开发的简便性较低。'
- en: Though there are well-defined components for an EDA pattern, the implementation
    style of the pattern varies based on the type of system functionality and complexity.
    In the next section, we will learn about the various styles in which EDA patterns
    are implemented.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管EDA模式有明确的组件，但其实现风格根据系统功能类型和复杂度而变化。在下一节中，我们将了解EDA模式实现的多种风格。
- en: Implementation variants of EDA patterns
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EDA模式的实现变体
- en: 'The various styles in which EDA patterns are implemented are the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: EDA模式实现的多种风格如下：
- en: Simple event processing patterns
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单事件处理模式
- en: Event stream processing patterns
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件流处理模式
- en: Complex event processing patterns
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂事件处理模式
- en: Simple event processing patterns
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单事件处理模式
- en: 'These patterns are used to measure events that are related to specific measurable
    changes in conditions. These patterns are used in scenarios that demand real-time
    flow of work to be triggered without any other constraints or considerations.
    Parameters such as lag time and costs related to business are not taken into consideration
    while using simple event processing patterns in architecture. Some scenarios for
    usage of this type of pattern could be a detection of temperature/pressure changes
    by a sensor. Let us explain simple event processing with the help of the order
    management system example we used at the beginning of the chapter. The diagram
    is repeated here for quick reference:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式用于测量与特定可测量条件变化相关的事件。这些模式用于需要触发实时工作流而没有任何其他约束或考虑的场景。在架构中使用简单事件处理模式时，不考虑滞后时间和与业务相关的成本。此类模式的使用场景可能包括通过传感器检测温度/压力变化。让我们借助本章开头使用的订单管理系统示例来解释简单事件处理。以下是重复的图表，供快速参考：
- en: '**![](img/76801b14-541a-4908-8882-62c6daffdd02.png)**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/76801b14-541a-4908-8882-62c6daffdd02.png)**'
- en: 'In this example, after the order enters the order management system, the first
    event is triggering a notification to the warehouse management system for checking
    inventory levels and to the financial system for payment validation. For simplicity,
    we will consider only one flow of events: the events related to the warehouse
    management (related to inventory check). Once the order enters the warehouse management
    system, the items in the order are checked against the inventory present in the
    warehouse using the check inventory service. The check inventory service allocates
    the inventory pertaining to the items present in the order and then checks the
    remaining inventory for optimal levels of inventory threshold. If the stock in
    the warehouse falls under the available threshold, the check inventory service
    generates a low inventory threshold event. This event is received by the simple
    event processing engine, as depicted in the following diagram. The event processing
    rules in this example will initiate two sets of events to handle the low inventory
    threshold situation: the first one would be a process to reorder the inventory,
    and the second one would be for publishing the event for consumption by the subscribers.
    In this particular example, the subscribers are inventory buyers and a notification
    to the inventory controller would also be generated. All these activities are
    depicted in the following diagram:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，订单进入订单管理系统后，第一个事件是触发对仓库管理系统进行库存水平检查的通知，以及对财务系统进行支付验证的通知。为了简化，我们只考虑一个事件流：与仓库管理（与库存检查相关）相关的事件。一旦订单进入仓库管理系统，订单中的项目就会使用库存检查服务与仓库中现有的库存进行核对。库存检查服务分配与订单中现有项目相关的库存，然后检查剩余库存以确定库存阈值的最佳水平。如果仓库中的库存低于可用阈值，库存检查服务会生成一个低库存阈值事件。此事件由以下图中所示的单个事件处理引擎接收。在此示例中，事件处理规则将启动两组事件来处理低库存阈值情况：第一组是重新订购库存的过程，第二组是发布事件供订阅者消费。在这个特定的例子中，订阅者是库存买家，还会生成一个通知给库存控制员。所有这些活动都在以下图中展示：
- en: '![](img/6cb4cc77-ec81-4c2a-8006-1ec92432f1a1.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6cb4cc77-ec81-4c2a-8006-1ec92432f1a1.png)'
- en: Event stream processing patterns
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件流处理模式
- en: In event stream processing, ordinary events that occur are filtered for notability
    and sent to subscribers. This style is used in order to ensure that real-time
    information flows in and around the enterprise. This pattern facilitates real-time
    decision-making.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件流处理中，发生的事件会被筛选出值得注意的部分，然后发送给订阅者。这种风格的使用是为了确保实时信息在企业内部和外部流动。这种模式促进了实时决策。
- en: Let us demonstrate this type of event further with the help of the order processing
    example that we have been discussing in this chapter. In the order processing
    example, if we consider the sequence of events at the warehouse, the RFID sensor
    generates an event for each product that moves out of the warehouse. In this scenario,
    suppose, for example, a retailer wants to be informed when high-value products
    leave the warehouse. To meet this requirement, a local event filter has been designed,
    which has rules to filter out events for items priced less than $5,000\. Suppose
    there is a purchase of a high-value item for $6,000\. This event, which is a high-value
    event, is reformatted to a standard event format and placed in the event channel.
    The event processing engine receives the event maps it to the rules for high-end
    products leaving the warehouse, and publishes it. The subscribers who have subscribed
    to this event receive it; in this example, it could be an inventory manager’s
    dashboard.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过本章中讨论的订单处理示例进一步演示这种类型的事件。在订单处理示例中，如果我们考虑仓库中的事件序列，RFID传感器会为每个离开仓库的产品生成一个事件。在这种情况下，例如，假设一个零售商希望在高档产品离开仓库时得到通知。为了满足这一要求，已经设计了一个本地事件过滤器，其中包含过滤掉价格低于$5,000的物品事件的规则。假设购买了一个价值$6,000的高价值物品。这个事件，即高价值事件，被重新格式化为标准事件格式，并放置在事件通道中。事件处理引擎接收事件，将其映射到仓库中高档产品离开的规则，并发布它。订阅了此事件的订阅者会收到它；在这个例子中，它可能是一个库存经理的仪表板。
- en: Complex event processing (CEP) patterns
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂事件处理（CEP）模式
- en: 'In CEP, a combination of simple and ordinary events is taken into consideration
    in order to judge it a complex event has happened. The various events that are
    taken into consideration may be evaluated over a long period of time. The event
    correlation between the various events may occur in various dimensions, such as
    temporal, causal, and spatial. For this evaluation to happen, CEP requires the
    following components:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在CEP中，考虑简单事件和普通事件的组合，以判断是否发生了复杂事件。考虑的各种事件可能需要在长时间内评估。各种事件之间的相关性可能发生在多个维度上，如时间、因果和空间。为了进行这种评估，CEP需要以下组件：
- en: Event interpreters
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件解释器
- en: Event pattern definition
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件模式定义
- en: Event pattern matching
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件模式匹配
- en: Event correlation techniques
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件相关性技术
- en: CEP is generally used to respond to anomalies in business, and in order to assess
    the opportunities and threats.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: CEP通常用于响应业务中的异常，以及评估机会和威胁。
- en: EDA patterns come in two different flavors or topologies. Each topology needs
    to be implemented only in specific scenarios as their features and characteristics
    are different. Hence, it is very important to understand these topologies so wise
    decisions can be made regarding their choice and implementation. In the next section,
    we will understand the various EDA pattern topologies.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: EDA模式有两种不同的风味或拓扑。每种拓扑只需要在特定场景中实现，因为它们的特性和特征不同。因此，了解这些拓扑非常重要，以便在它们的选择和实施方面做出明智的决定。在下一节中，我们将了解各种EDA模式拓扑。
- en: Types of event-driven patterns
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动模式类型
- en: 'There are two types of topologies for event-driven patterns:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动模式有两种拓扑类型：
- en: Event mediator topology pattern
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件中介拓扑模式
- en: Event broker topology pattern
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件代理拓扑模式
- en: The mediator topology pattern is used when it is required to orchestrate multiple
    steps that are part of an event with the help of a central mediator. The broker
    topology is used when it is required to chain multiple events together without
    the need for a central mediator. The architecture and components of each of these
    patterns are discussed next.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要通过中央中介编排事件的一部分的多个步骤时，使用中介拓扑模式。当需要将多个事件链接在一起而不需要中央中介时，使用代理拓扑。接下来将讨论每种模式的架构和组件。
- en: Event mediator topology pattern
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件中介拓扑模式
- en: 'The mediator topology pattern is used to design systems/processes that will
    need some level of coordination/orchestration in order to process the event. The
    ideal example of this scenario could be the order processing example, where there
    are multiple steps, such as order entry, inventory validation, finance validation,
    and so on. All these steps require some level of orchestration in order to assess
    whether they can be performed serially or in parallel. There are four main components
    within the mediator topology:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 中介拓扑模式用于设计需要一定程度的协调/编排以处理事件的系统/流程。这种场景的理想例子可以是订单处理示例，其中包含多个步骤，如订单录入、库存验证、财务验证等。所有这些步骤都需要一定程度的编排，以便评估它们是否可以串行或并行执行。中介拓扑中有四个主要组件：
- en: Event queue
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件队列
- en: Event mediator
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件中介
- en: Event channels
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件通道
- en: Event processors
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理器
- en: 'All these components are depicted in the following diagram:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些组件都在以下图中表示：
- en: '![](img/88f83ee2-ad29-448a-b57a-31d427e1c05a.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88f83ee2-ad29-448a-b57a-31d427e1c05a.png)'
- en: 'The client sends an event, which is then received by the event queue. The event
    queue transfers the event to the event mediator. The event mediator receives the
    event and orchestrates it. This is done by sending additional asynchronous events
    to the various event channels, which in turn will execute each step of the process.
    Event processors receive the event from the event channel and apply business logic
    to process the event. There can be any number of event queues in an EDA. An event
    queue can be implemented as a message queue, web service component, or in any
    other form that is suitable for the system under consideration. There are two
    types of events that are provided by this pattern:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送一个事件，然后由事件队列接收。事件队列将事件传输到事件中介。事件中介接收事件并编排它。这是通过向各个事件通道发送额外的异步事件来完成的，这些事件通道随后将执行每个步骤。事件处理器从事件通道接收事件并应用业务逻辑来处理事件。在EDA中可以有任意数量的事件队列。事件队列可以实施为消息队列、Web服务组件或任何适合考虑的系统的其他形式。此模式提供了两种类型的事件：
- en: '**Initial event**: This refers to the original event that is received by the
    mediator'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始事件**：这指的是中介者接收到的原始事件'
- en: '**Processing event**: This refers to the events that are generated by the mediator
    and are sent to the event processing components'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理事件**：这指的是由中介者生成并发送到事件处理组件的事件'
- en: The event mediator is mainly responsible for performing orchestration of the
    various steps that are present within the initial event. In order to perform each
    step in the initial event, the event mediator sends a specific processing event
    to the event channel. This processing event is received and processed by the event
    processor. Event channels are used to pass processing events associated with each
    step to the event processors. Event channels can either be in the form of message
    queues or in the form of message topics. The application logic that is required
    for processing the events is present in the event processor. Event processors
    are typically highly decoupled architectural components that are associated with
    a specific task in the system.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 事件中介者主要负责对初始事件中存在的各个步骤进行编排。为了执行初始事件中的每个步骤，事件中介者会将特定的处理事件发送到事件通道。这个处理事件被事件处理器接收并处理。事件通道用于将每个步骤关联的处理事件传递给事件处理器。事件通道可以是消息队列的形式，也可以是消息主题的形式。处理事件所需的应用逻辑存在于事件处理器中。事件处理器通常是高度解耦的架构组件，与系统中的特定任务相关联。
- en: Event broker topology pattern
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件代理拓扑模式
- en: 'The event broker topology pattern is used in scenarios where the event flow
    is relatively simple in nature and does not require any central event orchestration.
    The two main components of the event broker topology pattern are the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 事件代理拓扑模式用于事件流相对简单且不需要任何中央事件编排的场景。事件代理拓扑模式的主要组件如下：
- en: Broker
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Event processor
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理器
- en: 'The components of an event broker topology pattern are depicted in the following
    diagram:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 事件代理拓扑模式的组件在以下图中展示：
- en: '![](img/fa9ec3ff-a42b-429d-b0ca-a1d7e7fb6ed3.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa9ec3ff-a42b-429d-b0ca-a1d7e7fb6ed3.png)'
- en: The event broker component contains all the event channels and can be designed
    in a centralized or federated manner. The main difference between the event broker
    topology pattern and the event mediator topology pattern is the absence of an
    event mediator component which controls and orchestrates the event. Instead of
    an event mediator, the event processor performs that role of processing and publishing
    each event, indicating that the particular action is just completed. The broker
    component can be centralized or federated and contains all of the event channels
    that are used within the event flow. The event channels contained within the broker
    component can be message queues, message topics, or a combination of both.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 事件代理组件包含所有事件通道，可以设计为集中式或联邦式。事件代理拓扑模式与事件中介者拓扑模式的主要区别在于缺少控制并编排事件的组件。而不是事件中介者，事件处理器执行处理和发布每个事件的角色，表明特定操作已完成。代理组件可以是集中式或联邦式，并包含事件流中使用的所有事件通道。代理组件中包含的事件通道可以是消息队列、消息主题或两者的组合。
- en: In the next section, we will discuss some of the variants of event-driven patterns.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一些事件驱动模式的变体。
- en: Hub and spoke pattern
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中辐射模式
- en: 'The hub and spoke pattern is a variant of the event broker topology pattern.
    In the hub and spoke architecture, the hub acts as the centralized broker and
    the spoke act as adapters that connect applications to the hub. The spoke establishes
    a connection with an application and converts application data into a format that
    the hub understands. The hub translates the incoming data into a format that is
    understood by the destination system and performs routing of messages accordingly.
    The presence of a single hub makes this architecture easy to manage, but at the
    same time imposes limits on the scalability of the architecture:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 集中辐射模式是事件代理拓扑模式的一种变体。在集中辐射架构中，中心作为集中式代理，辐射作为连接应用程序到中心的适配器。辐射与一个应用程序建立连接，并将应用程序数据转换为中心可以理解的格式。中心将传入的数据转换为目的地系统可以理解的格式，并相应地进行消息路由。存在单个中心使这种架构易于管理，但同时也限制了架构的可扩展性：
- en: '![](img/452ef8f6-375a-48fa-a625-07b7565fde3a.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/452ef8f6-375a-48fa-a625-07b7565fde3a.png)'
- en: In order to overcome this limitation, the concept of the federated hub and spoke
    architecture has evolved. In the federated hub and spoke architecture, multiple
    hubs are present. Each hub has a local metadata and rules, as well as global metadata.
    Any changes to the global metadata and rules are automatically propagated to other
    local hubs. The federated hub and spoke architecture provides scalability and
    also flexibility by facilitating centralized management of hubs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一限制，联邦中心辐射式架构的概念已经发展起来。在联邦中心辐射式架构中，存在多个中心。每个中心拥有本地元数据和规则，以及全局元数据。对全局元数据和规则的任何更改都会自动传播到其他本地中心。联邦中心辐射式架构通过促进中心的集中管理，提供了可扩展性和灵活性。
- en: Broadcast pattern
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广播模式
- en: In a broadcast pattern, also a called **publish**/**subscribe** broadcast pattern,
    information is sent to all the parties that are present in the network. Only interested
    parties receive the message; the others discard the message. If the systems in
    a network have the efficiency to discard unwanted messages, then this pattern
    works very well for the design of such systems. When it comes to implementation
    of this pattern at the network level, a variant of **Internet Protocol** (**IP**) called
    **User Datagram Protocol** (**UDP**) allows us to send a piece of information
    to all computers that are part of a network. This is a variant of the event broadcast
    pattern that is applicable to networks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在广播模式中，也称为**发布**/**订阅**广播模式，信息被发送到网络中所有存在的各方。只有感兴趣的各方接收消息；其他人丢弃消息。如果网络中的系统具有丢弃不需要消息的效率，那么这种模式非常适合设计此类系统。当涉及到在网络级别实现这种模式时，一种称为**用户数据报协议**（UDP）的**互联网协议**（IP）变体允许我们向网络中的所有计算机发送一条信息。这是适用于网络的广播事件模式的一种变体。
- en: Polling pattern
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询模式
- en: In this pattern, subscribers contact the publishers to find out whether they
    have anything that is of interest to them. This is not used much as it involves
    a lot of wastage of system resources. Imagine a subscriber polling a publisher
    50 times when it has nothing new for them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式中，订阅者联系发布者以了解他们是否有任何感兴趣的内容。这很少使用，因为它涉及大量的系统资源浪费。想象一下，当订阅者没有新内容时，他们向发布者轮询50次。
- en: Event-driven patterns of late are implemented in a slightly different manner
    in an attempt to adapt to the changing technology landscape. In the next section,
    we will understand the actual implementation of event-driven patterns in systems.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动模式近年来在实现方式上略有不同，以适应不断变化的技术环境。在下一节中，我们将了解系统中事件驱动模式的实际实现。
- en: EDA pattern implementation in systems/processes
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统或过程中的EDA模式实现
- en: 'In this section, we will discuss the implementation of event-driven patterns
    in processes. The main components that are involved in this implementation are
    the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论在过程中实现事件驱动模式。涉及此实现的主要组件如下：
- en: Event queue
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件队列
- en: Event log
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件日志
- en: Event collectors
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件收集器
- en: Reply queue
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回复队列
- en: Read versus write events
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读事件与写事件
- en: 'Each of these components and the overall functioning of this architecture will
    be explained in this section. The core component for this implementation is a
    central event queue. All events are inserted into a central event queue before
    they are processed. The following diagram depicts this queue-based architecture:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将解释这些组件以及该架构的整体功能。此实现的核心组件是一个中心事件队列。所有事件在处理之前都插入到中心事件队列中。以下图展示了基于队列的架构：
- en: '![](img/0ef9c87b-9984-462f-b678-a4e7663a77df.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0ef9c87b-9984-462f-b678-a4e7663a77df.png)'
- en: Events are placed in an order when they are inserted into the queue so that
    it is possible to track the sequence in which the system responds to events.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件被插入队列时，它们被放置在一定的顺序中，以便可以跟踪系统响应事件的顺序。
- en: Event log
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件日志
- en: 'There needs to be a backup and recovery mechanism for the messages that are
    added to the central event queue. This is done by writing all the event details
    to an event log, which is typically placed in a disk. In the event of a system
    crash, the system''s state can be rebuilt by recovering its state from the event
    log. So, the main purpose of an event log is to ensure that events persist. In
    order to make the backup mechanism stronger, backups of the event log can be taken,
    which is equivalent to taking a backup of the system''s state. These backup copies
    can also be used to do pilot performance tests on new releases before they are
    actually deployed in production. The diagram of the event log is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对添加到中央事件队列的消息有一个备份和恢复机制。这是通过将所有事件细节写入事件日志来完成的，该日志通常放置在磁盘上。在系统崩溃的情况下，可以通过从事件日志中恢复其状态来重建系统的状态。因此，事件日志的主要目的是确保事件持久化。为了使备份机制更强大，可以备份事件日志，这相当于备份了系统的状态。这些备份副本也可以在它们实际部署到生产之前用于对新版本进行试点性能测试。以下是对事件日志的图表：
- en: '![](img/84fe5645-63b8-4de1-861e-63e08ec230d1.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84fe5645-63b8-4de1-861e-63e08ec230d1.png)'
- en: Event collectors
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件收集器
- en: 'Event requests originate from different types of sources, and they reach the
    system through some network in the form of HTTP requests or in some other formats.
    These events are collected from diverse sources using event collectors. The following
    diagram depicts the EDA with collectors:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 事件请求来自不同的来源，它们以HTTP请求或其他格式通过网络形式到达系统。这些事件通过事件收集器从不同的来源收集。以下图表展示了带有收集器的EDA：
- en: '![](img/c72babfb-ba3a-4a0c-9bd3-8973a7590f18.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c72babfb-ba3a-4a0c-9bd3-8973a7590f18.png)'
- en: Reply queue
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回复队列
- en: 'In some scenarios, it is required to send a response back to an event request.
    In such situations, it is required to have a response or reply queue to provide
    support. The following diagram depicts one such example. From the diagram, it
    is clear that the response needs to be sent back to the appropriate event collector.
    For example, if the incoming request is in HTTP format and is sent by the HTTP
    collector into the event queue, then the response has to be sent back to the source
    through the HTTP collector only. The point to be noted here is that the responses
    are not recorded in the event log:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，需要向事件请求发送响应。在这种情况下，需要有一个响应或回复队列来提供支持。以下图表展示了一个这样的例子。从图表中可以看出，响应需要发送回适当的事件收集器。例如，如果传入的请求是以HTTP格式发送的，并且是由HTTP收集器发送到事件队列的，那么响应必须通过HTTP收集器仅发送回源地址。这里需要注意的是，响应不会记录在事件日志中：
- en: '![](img/820bbc94-9076-48f0-a475-693ecbf2a219.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/820bbc94-9076-48f0-a475-693ecbf2a219.png)'
- en: Improving the performance of EDA-based processes/systems
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高基于事件驱动架构（EDA）的过程/系统的性能
- en: In the case of persisting events, all events that are pushed to the event queue
    are persisted to the event log. This makes the system slow. In order to improve
    the performance of the system, there should be a mechanism to persist only events
    that have the capability to alter the state of the system, that is, read events
    do not alter the state of the system whereas write events will alter the state.
    So, there should be a mechanism in place to persist only write events.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在持久化事件的情况下，所有推送到事件队列的事件都会持久化到事件日志中。这使得系统变慢。为了提高系统的性能，应该有一个机制来只持久化那些能够改变系统状态的事件，也就是说，读取事件不会改变系统的状态，而写入事件将会改变状态。因此，应该有一个机制来只持久化写入事件。
- en: 'This can be made possible with the event collectors by differentiating read
    events and write events. There should also be separate queues to handle read and
    write events. Using this mechanism, it is easy to ensure that events in the read
    event queue are not persisted and only the events in the write event queue are
    persisted. This concept is depicted in the following diagram:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过事件收集器通过区分读取事件和写入事件来实现。还应该有单独的队列来处理读取和写入事件。使用这种机制，可以很容易地确保读取事件队列中的事件不被持久化，而只有写入事件队列中的事件被持久化。这一概念在以下图表中展示：
- en: '![](img/ff8a0d81-8b0e-4789-a5e9-91bdc7003a68.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff8a0d81-8b0e-4789-a5e9-91bdc7003a68.png)'
- en: 'So in practice, there will be three queues: the read event queue, the write
    event queue, and the reply queue. Though it looks complex, from the implementation
    perspective it is fairly simple.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，将会有三个队列：读取事件队列、写入事件队列和回复队列。尽管看起来很复杂，但从实现的角度来看，它相当简单。
- en: The ability to recreate system state from the event log is the most important
    benefit of systems that use EDA.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从事件日志中重新创建系统状态是使用 EDA 系统的最重要好处。
- en: Most of the EDA pattern implementations are done in the form of COTS products
    and/or home-grown solutions. In the next section, we will see IBM WebSphere MQ,
    which is one of the most prominent EDA products on the market.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 EDA 模式实现都是以 COTS 产品和/或自建解决方案的形式完成的。在下一节中，我们将看到 IBM WebSphere MQ，这是市场上最突出的
    EDA 产品之一。
- en: IBM WebSphere MQ
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IBM WebSphere MQ
- en: 'IBM WebSphere MQ is used to provide messaging support for applications. It
    has the capability to transmit messages across diverse networks. The application
    can connect to IBM WebSphere MQ whenever there is a need to send or receive a
    message. IBM WebSphere MQ can handle diverse types of processors, operating systems,
    subsystems, and other communication protocols while transferring the message between
    systems. Another feature is that while transferring a message, if it finds that
    a processor is not available, it can place the message in a queue and transfer
    it later once the processor or system becomes available. The following are the
    different modes of operation supported by IBM WebSphere MQ, which is considered
    a messaging and queuing application:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: IBM WebSphere MQ 用于为应用程序提供消息支持。它具有在多种网络中传输消息的能力。当需要发送或接收消息时，应用程序可以连接到 IBM WebSphere
    MQ。IBM WebSphere MQ 可以处理不同类型的处理器、操作系统、子系统和其他通信协议，在系统之间传输消息时。另一个特性是在传输消息时，如果它发现处理器不可用，可以将消息放入队列，并在处理器或系统可用后再次传输。以下是
    IBM WebSphere MQ 支持的不同操作模式，它被认为是一个消息和队列应用程序：
- en: Point-to-point transfer
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点对点传输
- en: Publish/subscribe
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布/订阅
- en: File transfer
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件传输
- en: 'The key features of WebSphere MQ are explained as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: WebSphere MQ 的关键特性如下所述：
- en: '**Messaging**: Processes communicate with each other by sending messages, and
    not by means of calls.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息传递**: 进程通过发送消息相互通信，而不是通过调用。'
- en: '**Queuing**: Messages that are sent are placed in queues and then processed
    in order so that the different processes can work independently without having
    any direct connection and the associated overhead.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列**: 发送的消息被放置在队列中，然后按顺序处理，这样不同的进程可以独立工作，而无需任何直接连接和相关的开销。'
- en: '**Point-to-point**: It is possible to send multicast/broadcast messages to
    a list of queues. So it is necessary for the sender to know the destination name,
    but not necessarily the location of the destination.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点对点**: 可以向一系列队列发送多播/广播消息。因此，发送者需要知道目标名称，但不必知道目标的位置。'
- en: '**Publish**/**subscribe**: All the applications that are interested in specific
    types or categories of messages will subscribe to those messages that are published
    by specific applications/processes.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**/**订阅**: 所有对特定类型或类别的消息感兴趣的应用程序都将订阅由特定应用程序/进程发布的那些消息。'
- en: '**Multicast**: This speeds up the pace at which messages are transmitted. It
    gives the capability to a publisher to send messages to multiple subscribers in
    the network at the same time.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多播**: 这加快了消息传输的速度。它使发布者能够同时向网络中的多个订阅者发送消息。'
- en: '**Telemetry**: IBM WebSphere MQ Telemetry is designed to support messaging
    for devices. It sets up a connection between device and application messaging.
    It provides connectivity between the various components, such as the application,
    internet, services, and so on, with networks of instrumented devices. IBM WebSphere
    MQ Telemetry comes with a very efficient protocol that provides messaging support
    for a large number of devices that are connected over a network. This messaging
    protocol is published so that it can be added to the devices.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遥测**: IBM WebSphere MQ Telemetry 设计用于支持设备消息传递。它建立设备与应用程序消息之间的连接。它提供了应用程序、互联网、服务等各种组件与仪器化设备网络之间的连接。IBM
    WebSphere MQ Telemetry 随带一个非常高效的协议，为通过网络连接的大量设备提供消息支持。此消息协议已发布，以便可以将其添加到设备中。'
- en: Emerging trends in EDA
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EDA 的新兴趋势
- en: In this section, we will examine some of the very recent advancements in the
    field of event-driven architectural patterns.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨事件驱动架构模式领域的一些最新进展。
- en: Event-driven microservices
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动微服务
- en: 'Most organizations are moving away from the present siloed monolithic applications
    to the concept of microservices in order to achieve agility and also gain a competitive
    edge in the market. One of the main issues that arise with the use of microservices
    is distributed data management. Each microservice has its own private database.
    Designing business transactions that update entities that are owned by multiple
    microservices in multiple diverse databases is a major concern. This poses great
    difficulties in maintaining the consistency of data that is present in databases.
    This is depicted in the following diagram:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数组织正在从目前分立的单体应用程序转向微服务的概念，以实现敏捷性并在市场上获得竞争优势。使用微服务时出现的一个主要问题是分布式数据管理。每个微服务都有自己的私有数据库。设计更新多个微服务在多个不同数据库中拥有的实体的业务事务是一个主要问题。这给维护数据库中现有数据的一致性带来了极大的困难。以下图表展示了这一点：
- en: '![](img/a1059d1a-2708-4a84-ac7f-a826fc3d0f33.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1059d1a-2708-4a84-ac7f-a826fc3d0f33.png)'
- en: 'EDA provides a solution for this issue that occurs in distributed databases
    while using microservices. In an EDA, a service publishes events when there is
    a change. Other services that would be of interest would have subscribed to these
    events. As and when an event is received, the service typically updates its own
    state and also publishes more events that in turn might get consumed by other
    services. The event-driven approach provides the features to implement consistent
    transactions. The following diagram depicts how EDA helps in the implementation
    of consistency in business transactions that are used by multiple services. The
    example in the diagram refers to the order management example that we used at
    the start of the chapter:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: EDA为使用微服务时分布式数据库中出现的这个问题提供了一个解决方案。在EDA中，当有变化时，一个服务会发布事件。其他感兴趣的服务会订阅这些事件。一旦收到事件，服务通常会更新其自身状态，并发布更多事件，这些事件反过来可能被其他服务消费。事件驱动的方法提供了实现一致事务的功能。以下图表描述了EDA如何帮助实现多个服务使用的业务事务的一致性。图表中的示例是我们在本章开头使用的订单管理示例：
- en: '![](img/dd8608ed-b2f8-4df2-b5b1-4e25cce5b435.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd8608ed-b2f8-4df2-b5b1-4e25cce5b435.png)'
- en: Complex event processing
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂事件处理
- en: Of late, many interesting use cases have evolved around complex events. Statistical
    functions such as event correlation and aggregation along with computational algorithms
    are being applied to event data to uncover meaningful patterns that provide valuable
    use cases for several domains/industries. One of the prominent use cases is in
    the field of banking to detect frauds in transactions. Another promising use case
    is in weather forecasting, where several atmospheric parameters are correlated
    to predict cyclones, earthquakes, and so on. Many of the command centers that
    are used for weather forecasting across the world work on the basis of EDA.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 近期，许多有趣的用例在复杂事件周围发展起来。统计函数，如事件相关性和聚合，以及计算算法正在应用于事件数据，以揭示有意义的模式，为多个领域/行业提供有价值的用例。其中一个突出的用例是在银行领域检测交易欺诈。另一个有希望的应用是天气预报，其中几个大气参数被关联起来以预测台风、地震等。世界上许多用于天气预报的指挥中心都是基于EDA运行的。
- en: Internet of Things (IoT) and EDA
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网（IoT）与EDA
- en: IoT refers to the interconnection of all objects around the computing devices
    that are embedded in them, which in turn helps them to send and receive data.
    In this scenario, any object around us will become a smart object and can keep
    sending messages to other objects that have subscribed to receive its messages.
    Using IoT, 3 trillion objects are expected to be interconnected by 2020\. All
    these objects in turn function with the help of EDA architecture. This goes to
    show the huge potential that EDA has in years to come.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网（IoT）指的是嵌入在计算设备中的所有对象的相互连接，这反过来又帮助它们发送和接收数据。在这种情况下，我们周围的任何物体都将变成智能物体，并且可以持续向已订阅接收其消息的其他物体发送消息。到2020年，预计将有3万亿个物体通过物联网相互连接。所有这些物体都通过EDA架构来运行。这表明EDA在未来几年具有巨大的潜力。
- en: References
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[http://tutorials.jenkov.com/software-architecture/event-driven-architecture.html](http://tutorials.jenkov.com/software-architecture/event-driven-architecture.html)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://tutorials.jenkov.com/software-architecture/event-driven-architecture.html](http://tutorials.jenkov.com/software-architecture/event-driven-architecture.html)'
- en: '[https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.5.0/com.ibm.mq.pro.doc/q001020_.htm](https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.5.0/com.ibm.mq.pro.doc/q001020_.htm)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.5.0/com.ibm.mq.pro.doc/q001020_.htm](https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.5.0/com.ibm.mq.pro.doc/q001020_.htm)'
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the various aspects of EDA patterns. We started
    with the definition and description of the event and event-driven patterns. Then
    we discussed in detail the various components of EDA. EDA patterns have two topology
    variants and each of them has specific usage scenarios based on the system requirements.
    These patterns and their components were discussed in detail.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 EDA 模式的各个方面。我们首先介绍了事件和事件驱动模式的定义和描述。然后我们详细讨论了 EDA 的各种组件。EDA 模式有两种拓扑变体，每种变体根据系统需求都有特定的使用场景。这些模式和它们的组件都进行了详细讨论。
- en: There are multiple variants of EDA patterns. These patterns and their features
    were discussed in detail in the chapter. EDA patterns have multiple layers in
    which they work. These layers and the components that are present in each layer
    were discussed in the chapter. SOA and EDA are related concepts and they complement
    each other. Their similarities, differences, and usage scenarios were discussed
    in detail in this chapter. The chapter concluded with a discussion about the emerging
    trends in the EDA space.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: EDA 模式有多种变体。本章详细讨论了这些模式及其特性。EDA 模式在其工作中有多个层次，每个层次都包含特定的组件。本章讨论了这些层次及其组件。SOA
    和 EDA 是相关概念，它们相互补充。本章详细讨论了它们的相似性、差异和使用场景。本章最后讨论了 EDA 领域的新兴趋势。
