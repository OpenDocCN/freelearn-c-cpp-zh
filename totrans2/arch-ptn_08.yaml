- en: Event-Driven Architectural Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do organizations need **event-driven architecture** (**EDA**)? Organizations
    across the world are operating in an agile manner and changing their structure
    frequently. They are evolving into business structures that can operate as independent
    service providers and consumers. These service providers and consumers need not
    necessarily exist within the organization. Some business services are outsourced
    to external business partners and other business services within the organization
    are looking to provide their services to external organizations in addition to
    internal business lines. All these emerging trends necessitate process architectures
    that have high levels of autonomy, or in other words, loose coupling between various
    application components that exist within an organization. The need for loosely
    coupled architecture with high levels of autonomy led to the evolution of EDA.
    Using EDA, organizations can rapidly reorganize their structure without changing
    their application constructions. Now, let us get started with the details of EDA.
  prefs: []
  type: TYPE_NORMAL
- en: 'An event in a generic sense refers to any change in state that is of interest
    to an organization/business/end user. The signal in a car indicating that the
    gas is low, the ringing of a mobile phone, and the ringing of a smoke alarm in
    a house are all examples of some real-world events that we come across in our
    everyday lives. Understanding the concept of an event is easier with the help
    of an example, as depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2f95cf4-938d-4c8d-b0d0-964293edf98a.png)'
  prefs: []
  type: TYPE_IMG
- en: The diagram depicts the flow of actions in an order management system. As soon
    as an order management system receives an order from a website or from an order
    entry system, the next step would be to notify other systems about the order.
    In this step, receiving an order is an event. This event needs to be published
    to other systems that would be interested in this event. In this example, the
    other systems that would be interested in this event are a warehouse management
    system that would check the order item in the inventory stored in the warehouse
    to ensure its availability and a finance system that would check the credit balance
    or the payment mechanism that is associated with the order.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these systems will, in turn, publish an event to other systems that
    are required to complete the next step in order processing. Accordingly, the warehouse
    system may publish an inventory allocated event and the financial system may publish
    a payment validated event to the shipping system. The shipping system will, in
    turn, make necessary arrangements to ship the order to the customer. In this specific
    flow of events, these are the component systems that are a part of the event flow.
    But there could be several other systems that could form a part of the event flow
    based on the outcomes of event processing at each step. For example, if the warehouse
    management system detects low inventory levels for the item placed in the order,
    it will trigger an event to the procurement system to procure the item. Similarly,
    if the financial system detects a low credit balance or an incorrect payment option,
    it will trigger an email notification to the customer that the credit balance
    is low or the payment was not completed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this example, we understand that the crux of EDA is the concept of **publish**/**subscribe.**
    In the preceding example, the order management system publishes the order event
    to two other interested parties that have subscribed to the event warehouse management
    system and financial system. These two systems, in turn, publish events to shipping
    systems and so on. The three important definitions in the context of the EDA pattern
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event**: An event is a runtime operation, executed by a software element
    to make some information (including the information that it occurred) available
    for potential use by software elements not specified by the operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publisher**: To trigger (or publish) an event is to execute it. A software
    element that may trigger events is a publisher. A software element that may use
    the event''s information is a subscriber.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context**: In event-driven design, a context is a Boolean expression speciﬁed
    by a subscriber at registration time, but evaluated at triggering time, such that
    the registered action will only be executed if the evaluation yields true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event-driven pattern is a class of patterns that has gained a lot of traction
    of late because of the rapidly changing industry paradigm. Many folks get easily
    confused between **service-oriented architecture** (**SOA**) and EDA patterns.
    In the next section, we will try to analyze and understand the differences between
    the two.
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented architecture and event-driven architecture (SOA versus EDA)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizations across the world are changing their structures rapidly and are
    moving toward on-demand business models. There is an increase in the movement
    toward setting up network-oriented business structures that will have autonomous
    service providers and consumers. Outsourcing is also very prominent as many parts
    of the business process will also be outsourced to external business partners.
    Various departments and business units who are present within organizations are
    taking on the role of service providers. The focus of these service providers
    is to increasingly provide services to the external market entities. This necessitates
    organizations being agile enough to quickly respond to changes or events that
    happen in the external environment. All these aspects demand a paradigm shift
    from a command-driven, tightly coupled, service-driven SOA concept to a more loosely
    coupled model that is driven by events. EDA is a publish/subscribe type of pattern.
    In the context of EDA, the publisher is completely unaware of the subscriber,
    and vice versa. Components of the EDA pattern are so loosely coupled that only
    the semantics of the message is shared between them. Now, the decision that needs
    to be made is when to use SOA and when to use EDA.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a common tendency to use EDA and SOA interchangeably because of the
    nature of their working. But that should not be the case. There are clear differentiators
    between the two architectural options. For situations that demand a strong cohesion
    in the business processes, SOA is the ideal choice of architecture. The following
    are the various scenarios in which a command/control style of SOA could be an
    ideal choice of architecture for organizations:'
  prefs: []
  type: TYPE_NORMAL
- en: If there exists a vertical interaction between the various hierarchical layers
    of functions that exist in an organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are functional request-and-reply processes such as man-machine dialogues
    where the user feeds a question and waits for an answer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are processes that are transactional in nature that requires commit
    and rollback features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If data enrichment is required in a message for it to be published to its full
    content in a formal format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EDA is the preferred style for organizations that require a loose coupling
    between their various processes. EDA is the choice of architecture in federated
    and autonomous processing environments. The following are some of the scenarios
    in which EDA is an ideal choice of architecture for organizations:'
  prefs: []
  type: TYPE_NORMAL
- en: If there exists a horizontal communication between various tiers that are part
    of process chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are workflow types of processes in an organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there exist processes that involve cross-functional borders of organizations,
    for example, a B2B process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aiming for loose coupling in architecture always provides the flexibility and
    the agility that is necessary for present-day organizations. So, the rule of thumb
    to be followed while designing architectures for organizations is use loose coupling
    whenever possible and use tightly coupled architectural options only if required.
    Other aspects of design, such as performance, response time, and so on, should
    also be taken into consideration while making architectural design choices. In
    a typical enterprise-level organization, the bifurcation and the relationship
    of processes with regard to EDA and SOA architecture are depicted in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b39f1fe8-62e9-46e2-ab44-97553635e40e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the diagram, the circles at the top denote loosely coupled systems, which
    are good candidates to be chosen as decoupling points or events. At these decoupling
    points, the various system components can be connected or disconnected without
    altering the connected peer systems. Data exchange between various domains in
    an organization takes place only at these decoupling points and not at the lower
    levels of systems that are tightly coupled. Within the reuse domain (indicated
    at the bottom of the figure), a fine-grained EDA implementation would be required
    to decouple the components because of their tight integration. The more fine-grained
    the EDA implementation is, the greater the flexibility of IT systems will be,
    but this would also reduce the scope of reuse of domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, if web services technology is used at decoupling
    points along with a common infrastructure backbone such as an enterprise service
    bus, it is very easy to establish connectivity between heterogeneous systems.
    Systems that are present downstream need not be SOA alone; they can also be SOAP-wrapped
    legacy systems, **commercial off-the-shelf software** (**COTS**), or other applications
    such as ERP. The following diagram shows the integration of EDA and SOA . In this
    diagram, components are connected through decoupling points, which are events:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4831894-3af5-4267-b849-3beb6c8a512f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have clearly learned the differences between EDA and SOA. In the next
    section, we will learn the components of an EDA pattern. These components should
    be part of any architecture that uses EDA patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Key characteristics of event-driven patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If there is a component in a system that publishes and accepts events, can
    you consider that as an example of an EDA pattern? The answer to the question
    is a clear no. In this section, we will examine the characteristics of EDA patterns.
    Their main characteristics are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multicast communications**: The publishers or the participating systems have
    the capability to send events to multiple systems that have subscribed to it.
    In other words, it is not a unicast communication in which one sender can send
    data only to one receiver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time transmission**: Publishers publish the events as and when they
    occur in real time to the subscribers. In other words, the mode of processing
    or transmission involved here is real time and not batch processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous communication**: The publisher does not wait for the receiver
    to process an event before sending the next event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fine-grained communication**: Publishers keep publishing individual fine-grained
    events instead of waiting for a single aggregated event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ontology**: EDA systems always have a technique to classify events in terms
    of some form of a group/hierarchy based on their common characteristics. This
    gives flexibility to the subscribers to subscribe to a specific event or specific
    category of events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components of an EDA pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main components of the EDA pattern are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Event specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event tooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterprise integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sources and targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these components and the various other subcomponents are summarized in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd43f4d5-37fc-42f8-be7f-bbb670fe9221.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The core component of any EDA is strong metadata architecture. The core components
    of event metadata architecture are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event specifications**: These event specifications should be made available
    to event generators, event processing engines, and event transformers. There is
    no industry-approved standard for event definition and processing at the moment;
    they are just in the evolving phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event processing**: This is a technique for processing and analyzing streams
    of data about events with an objective of deriving some kind of a conclusion from
    them, for example, a weather prediction system whose main function is to predict
    the onset of cyclones. For the system to derive this conclusion, it should take
    into consideration several patterns, such as wind speed, the direction of flow,
    atmospheric pressure, moisture content, and so on. All these parameters constitute
    the event data, and this data should be processed by an event engine in order
    to arrive at specific conclusions. So, the essential components that are required
    for any event processing are the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event engine
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Event data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event tooling**: Event development tools provide the following key functions
    with regard to the processing of events:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define event specifications
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Define event processing rules
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage event subscriptions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They also provide add-on functions such as monitoring of event processing infrastructure
    and event flows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Enterprise integration**: This has a pivotal role to play in EDA design.
    Some of the necessary integration services that are required are the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event preprocessing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Event channel transport
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Service invocation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Publication and subscription
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterprise information access
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sources and targets**: Sources refer to the components of the enterprise
    that generate events. This could refer to systems, services, automated agents,
    or even people who are responsible for creating events. Targets refer to the components
    that perform an action based on the occurrence of events or based on the event
    outcomes. The topology of sources and targets of events are governed by several
    parameters, such asthe following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event flows
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Event occurrence volumes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Location of sources and targets and so on
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Event flows are a very important component of EDA architecture. In the next
    section, we will see the various logical layers that are present in an event flow.
    These logical layer components need to be carefully chosen and designed for successful
    implementation of EDA patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Event flow layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The four logical layers present in the event flow are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Event generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downstream event-driven activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sources from where events are generated are called **event generators**.
    The source could be an application, service, business process, sensor, database,
    or even a human being. An event that is generated is evaluated for notability
    by an event filter, and if the evaluation is successful, leads to the generation
    of a notable event. Since there are diverse sources for the generation of events,
    not all generated events will be in a format that is suitable for processing.
    For such events, it is necessary to ensure that they are converted into a compatible
    format before they are sent to the event channel.
  prefs: []
  type: TYPE_NORMAL
- en: Event channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This acts a transmission medium and messaging backbone for EDA. It receives
    standard formatted events from the event generator and sends them to other event
    generators, event processing engines, and downstream subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Event processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the events are received, they are processed and evaluated based on some
    rules that are stored in the event processing engine. Based on the results of
    the evaluation, a specific course of action is initiated. The event rules are
    created based on the criteria specified by the organization and/or other interested
    parties. Event processing could result in several courses of action, such as notifying
    a certain system/agency, taking an alternate course of action, initiating a business
    process, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Downstream event-driven activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any event can trigger a sequence of downstream activities that could be a response
    to the event. The event could be a push notification by the event processing engine
    or pull notifications by the subscribers. Subscribers in this context could refer
    to an application, humans, services, or business processes.
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations for event-driven patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will explain the various design considerations that need
    to be kept in mind before choosing EDA patterns for architecture implementation.
    The main considerations are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Agility**: Agility refers to the ability to cope with the rapid changes that
    happen in the environment. In the EDA pattern, components are loosely coupled.
    This ensures that changes that happen to one component do not affect the other
    components in the system. Hence, the degree of agility offered by the EDA pattern
    is high, making it an ideal choice for the design of systems that require continuous
    changes without any downtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of deployment**: The EDA pattern components are loosely coupled in nature,
    which makes their deployment very easy. For solutions that require maximum ease
    of deployment, event broker topology is a better option than event mediator topology.
    This is due to the fact that in event mediator topology, there exists a relatively
    tight coupling between the event mediator and event processor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: Unit testing of EDA pattern components is difficult because
    of the fact that it requires special test clients and test tools to generate events
    that are required for testing purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: EDA has the capability to perform asynchronous operations
    in parallel, which provides very high performance for the architecture, irrespective
    of the time lag involved in queuing and dequeuing messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: EDA offers a high level of scalability because of the highly
    decoupled nature of the components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of development**: Ease of development using this pattern is low because
    of the asynchronous nature of the pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though there are well-defined components for an EDA pattern, the implementation
    style of the pattern varies based on the type of system functionality and complexity.
    In the next section, we will learn about the various styles in which EDA patterns
    are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation variants of EDA patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The various styles in which EDA patterns are implemented are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple event processing patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event stream processing patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex event processing patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple event processing patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These patterns are used to measure events that are related to specific measurable
    changes in conditions. These patterns are used in scenarios that demand real-time
    flow of work to be triggered without any other constraints or considerations.
    Parameters such as lag time and costs related to business are not taken into consideration
    while using simple event processing patterns in architecture. Some scenarios for
    usage of this type of pattern could be a detection of temperature/pressure changes
    by a sensor. Let us explain simple event processing with the help of the order
    management system example we used at the beginning of the chapter. The diagram
    is repeated here for quick reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/76801b14-541a-4908-8882-62c6daffdd02.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, after the order enters the order management system, the first
    event is triggering a notification to the warehouse management system for checking
    inventory levels and to the financial system for payment validation. For simplicity,
    we will consider only one flow of events: the events related to the warehouse
    management (related to inventory check). Once the order enters the warehouse management
    system, the items in the order are checked against the inventory present in the
    warehouse using the check inventory service. The check inventory service allocates
    the inventory pertaining to the items present in the order and then checks the
    remaining inventory for optimal levels of inventory threshold. If the stock in
    the warehouse falls under the available threshold, the check inventory service
    generates a low inventory threshold event. This event is received by the simple
    event processing engine, as depicted in the following diagram. The event processing
    rules in this example will initiate two sets of events to handle the low inventory
    threshold situation: the first one would be a process to reorder the inventory,
    and the second one would be for publishing the event for consumption by the subscribers.
    In this particular example, the subscribers are inventory buyers and a notification
    to the inventory controller would also be generated. All these activities are
    depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cb4cc77-ec81-4c2a-8006-1ec92432f1a1.png)'
  prefs: []
  type: TYPE_IMG
- en: Event stream processing patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In event stream processing, ordinary events that occur are filtered for notability
    and sent to subscribers. This style is used in order to ensure that real-time
    information flows in and around the enterprise. This pattern facilitates real-time
    decision-making.
  prefs: []
  type: TYPE_NORMAL
- en: Let us demonstrate this type of event further with the help of the order processing
    example that we have been discussing in this chapter. In the order processing
    example, if we consider the sequence of events at the warehouse, the RFID sensor
    generates an event for each product that moves out of the warehouse. In this scenario,
    suppose, for example, a retailer wants to be informed when high-value products
    leave the warehouse. To meet this requirement, a local event filter has been designed,
    which has rules to filter out events for items priced less than $5,000\. Suppose
    there is a purchase of a high-value item for $6,000\. This event, which is a high-value
    event, is reformatted to a standard event format and placed in the event channel.
    The event processing engine receives the event maps it to the rules for high-end
    products leaving the warehouse, and publishes it. The subscribers who have subscribed
    to this event receive it; in this example, it could be an inventory manager’s
    dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Complex event processing (CEP) patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In CEP, a combination of simple and ordinary events is taken into consideration
    in order to judge it a complex event has happened. The various events that are
    taken into consideration may be evaluated over a long period of time. The event
    correlation between the various events may occur in various dimensions, such as
    temporal, causal, and spatial. For this evaluation to happen, CEP requires the
    following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Event interpreters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event pattern definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event correlation techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CEP is generally used to respond to anomalies in business, and in order to assess
    the opportunities and threats.
  prefs: []
  type: TYPE_NORMAL
- en: EDA patterns come in two different flavors or topologies. Each topology needs
    to be implemented only in specific scenarios as their features and characteristics
    are different. Hence, it is very important to understand these topologies so wise
    decisions can be made regarding their choice and implementation. In the next section,
    we will understand the various EDA pattern topologies.
  prefs: []
  type: TYPE_NORMAL
- en: Types of event-driven patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of topologies for event-driven patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Event mediator topology pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event broker topology pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mediator topology pattern is used when it is required to orchestrate multiple
    steps that are part of an event with the help of a central mediator. The broker
    topology is used when it is required to chain multiple events together without
    the need for a central mediator. The architecture and components of each of these
    patterns are discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Event mediator topology pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The mediator topology pattern is used to design systems/processes that will
    need some level of coordination/orchestration in order to process the event. The
    ideal example of this scenario could be the order processing example, where there
    are multiple steps, such as order entry, inventory validation, finance validation,
    and so on. All these steps require some level of orchestration in order to assess
    whether they can be performed serially or in parallel. There are four main components
    within the mediator topology:'
  prefs: []
  type: TYPE_NORMAL
- en: Event queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event mediator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event processors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these components are depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88f83ee2-ad29-448a-b57a-31d427e1c05a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The client sends an event, which is then received by the event queue. The event
    queue transfers the event to the event mediator. The event mediator receives the
    event and orchestrates it. This is done by sending additional asynchronous events
    to the various event channels, which in turn will execute each step of the process.
    Event processors receive the event from the event channel and apply business logic
    to process the event. There can be any number of event queues in an EDA. An event
    queue can be implemented as a message queue, web service component, or in any
    other form that is suitable for the system under consideration. There are two
    types of events that are provided by this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial event**: This refers to the original event that is received by the
    mediator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processing event**: This refers to the events that are generated by the mediator
    and are sent to the event processing components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event mediator is mainly responsible for performing orchestration of the
    various steps that are present within the initial event. In order to perform each
    step in the initial event, the event mediator sends a specific processing event
    to the event channel. This processing event is received and processed by the event
    processor. Event channels are used to pass processing events associated with each
    step to the event processors. Event channels can either be in the form of message
    queues or in the form of message topics. The application logic that is required
    for processing the events is present in the event processor. Event processors
    are typically highly decoupled architectural components that are associated with
    a specific task in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Event broker topology pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The event broker topology pattern is used in scenarios where the event flow
    is relatively simple in nature and does not require any central event orchestration.
    The two main components of the event broker topology pattern are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Broker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event processor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The components of an event broker topology pattern are depicted in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa9ec3ff-a42b-429d-b0ca-a1d7e7fb6ed3.png)'
  prefs: []
  type: TYPE_IMG
- en: The event broker component contains all the event channels and can be designed
    in a centralized or federated manner. The main difference between the event broker
    topology pattern and the event mediator topology pattern is the absence of an
    event mediator component which controls and orchestrates the event. Instead of
    an event mediator, the event processor performs that role of processing and publishing
    each event, indicating that the particular action is just completed. The broker
    component can be centralized or federated and contains all of the event channels
    that are used within the event flow. The event channels contained within the broker
    component can be message queues, message topics, or a combination of both.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss some of the variants of event-driven patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Hub and spoke pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The hub and spoke pattern is a variant of the event broker topology pattern.
    In the hub and spoke architecture, the hub acts as the centralized broker and
    the spoke act as adapters that connect applications to the hub. The spoke establishes
    a connection with an application and converts application data into a format that
    the hub understands. The hub translates the incoming data into a format that is
    understood by the destination system and performs routing of messages accordingly.
    The presence of a single hub makes this architecture easy to manage, but at the
    same time imposes limits on the scalability of the architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/452ef8f6-375a-48fa-a625-07b7565fde3a.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to overcome this limitation, the concept of the federated hub and spoke
    architecture has evolved. In the federated hub and spoke architecture, multiple
    hubs are present. Each hub has a local metadata and rules, as well as global metadata.
    Any changes to the global metadata and rules are automatically propagated to other
    local hubs. The federated hub and spoke architecture provides scalability and
    also flexibility by facilitating centralized management of hubs.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcast pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a broadcast pattern, also a called **publish**/**subscribe** broadcast pattern,
    information is sent to all the parties that are present in the network. Only interested
    parties receive the message; the others discard the message. If the systems in
    a network have the efficiency to discard unwanted messages, then this pattern
    works very well for the design of such systems. When it comes to implementation
    of this pattern at the network level, a variant of **Internet Protocol** (**IP**) called
    **User Datagram Protocol** (**UDP**) allows us to send a piece of information
    to all computers that are part of a network. This is a variant of the event broadcast
    pattern that is applicable to networks.
  prefs: []
  type: TYPE_NORMAL
- en: Polling pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this pattern, subscribers contact the publishers to find out whether they
    have anything that is of interest to them. This is not used much as it involves
    a lot of wastage of system resources. Imagine a subscriber polling a publisher
    50 times when it has nothing new for them.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven patterns of late are implemented in a slightly different manner
    in an attempt to adapt to the changing technology landscape. In the next section,
    we will understand the actual implementation of event-driven patterns in systems.
  prefs: []
  type: TYPE_NORMAL
- en: EDA pattern implementation in systems/processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will discuss the implementation of event-driven patterns
    in processes. The main components that are involved in this implementation are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Event queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event collectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reply queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read versus write events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these components and the overall functioning of this architecture will
    be explained in this section. The core component for this implementation is a
    central event queue. All events are inserted into a central event queue before
    they are processed. The following diagram depicts this queue-based architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ef9c87b-9984-462f-b678-a4e7663a77df.png)'
  prefs: []
  type: TYPE_IMG
- en: Events are placed in an order when they are inserted into the queue so that
    it is possible to track the sequence in which the system responds to events.
  prefs: []
  type: TYPE_NORMAL
- en: Event log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There needs to be a backup and recovery mechanism for the messages that are
    added to the central event queue. This is done by writing all the event details
    to an event log, which is typically placed in a disk. In the event of a system
    crash, the system''s state can be rebuilt by recovering its state from the event
    log. So, the main purpose of an event log is to ensure that events persist. In
    order to make the backup mechanism stronger, backups of the event log can be taken,
    which is equivalent to taking a backup of the system''s state. These backup copies
    can also be used to do pilot performance tests on new releases before they are
    actually deployed in production. The diagram of the event log is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84fe5645-63b8-4de1-861e-63e08ec230d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Event collectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Event requests originate from different types of sources, and they reach the
    system through some network in the form of HTTP requests or in some other formats.
    These events are collected from diverse sources using event collectors. The following
    diagram depicts the EDA with collectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c72babfb-ba3a-4a0c-9bd3-8973a7590f18.png)'
  prefs: []
  type: TYPE_IMG
- en: Reply queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some scenarios, it is required to send a response back to an event request.
    In such situations, it is required to have a response or reply queue to provide
    support. The following diagram depicts one such example. From the diagram, it
    is clear that the response needs to be sent back to the appropriate event collector.
    For example, if the incoming request is in HTTP format and is sent by the HTTP
    collector into the event queue, then the response has to be sent back to the source
    through the HTTP collector only. The point to be noted here is that the responses
    are not recorded in the event log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/820bbc94-9076-48f0-a475-693ecbf2a219.png)'
  prefs: []
  type: TYPE_IMG
- en: Improving the performance of EDA-based processes/systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case of persisting events, all events that are pushed to the event queue
    are persisted to the event log. This makes the system slow. In order to improve
    the performance of the system, there should be a mechanism to persist only events
    that have the capability to alter the state of the system, that is, read events
    do not alter the state of the system whereas write events will alter the state.
    So, there should be a mechanism in place to persist only write events.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be made possible with the event collectors by differentiating read
    events and write events. There should also be separate queues to handle read and
    write events. Using this mechanism, it is easy to ensure that events in the read
    event queue are not persisted and only the events in the write event queue are
    persisted. This concept is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff8a0d81-8b0e-4789-a5e9-91bdc7003a68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So in practice, there will be three queues: the read event queue, the write
    event queue, and the reply queue. Though it looks complex, from the implementation
    perspective it is fairly simple.'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to recreate system state from the event log is the most important
    benefit of systems that use EDA.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the EDA pattern implementations are done in the form of COTS products
    and/or home-grown solutions. In the next section, we will see IBM WebSphere MQ,
    which is one of the most prominent EDA products on the market.
  prefs: []
  type: TYPE_NORMAL
- en: IBM WebSphere MQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IBM WebSphere MQ is used to provide messaging support for applications. It
    has the capability to transmit messages across diverse networks. The application
    can connect to IBM WebSphere MQ whenever there is a need to send or receive a
    message. IBM WebSphere MQ can handle diverse types of processors, operating systems,
    subsystems, and other communication protocols while transferring the message between
    systems. Another feature is that while transferring a message, if it finds that
    a processor is not available, it can place the message in a queue and transfer
    it later once the processor or system becomes available. The following are the
    different modes of operation supported by IBM WebSphere MQ, which is considered
    a messaging and queuing application:'
  prefs: []
  type: TYPE_NORMAL
- en: Point-to-point transfer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish/subscribe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File transfer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The key features of WebSphere MQ are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Messaging**: Processes communicate with each other by sending messages, and
    not by means of calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queuing**: Messages that are sent are placed in queues and then processed
    in order so that the different processes can work independently without having
    any direct connection and the associated overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Point-to-point**: It is possible to send multicast/broadcast messages to
    a list of queues. So it is necessary for the sender to know the destination name,
    but not necessarily the location of the destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publish**/**subscribe**: All the applications that are interested in specific
    types or categories of messages will subscribe to those messages that are published
    by specific applications/processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multicast**: This speeds up the pace at which messages are transmitted. It
    gives the capability to a publisher to send messages to multiple subscribers in
    the network at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Telemetry**: IBM WebSphere MQ Telemetry is designed to support messaging
    for devices. It sets up a connection between device and application messaging.
    It provides connectivity between the various components, such as the application,
    internet, services, and so on, with networks of instrumented devices. IBM WebSphere
    MQ Telemetry comes with a very efficient protocol that provides messaging support
    for a large number of devices that are connected over a network. This messaging
    protocol is published so that it can be added to the devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emerging trends in EDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will examine some of the very recent advancements in the
    field of event-driven architectural patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most organizations are moving away from the present siloed monolithic applications
    to the concept of microservices in order to achieve agility and also gain a competitive
    edge in the market. One of the main issues that arise with the use of microservices
    is distributed data management. Each microservice has its own private database.
    Designing business transactions that update entities that are owned by multiple
    microservices in multiple diverse databases is a major concern. This poses great
    difficulties in maintaining the consistency of data that is present in databases.
    This is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1059d1a-2708-4a84-ac7f-a826fc3d0f33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'EDA provides a solution for this issue that occurs in distributed databases
    while using microservices. In an EDA, a service publishes events when there is
    a change. Other services that would be of interest would have subscribed to these
    events. As and when an event is received, the service typically updates its own
    state and also publishes more events that in turn might get consumed by other
    services. The event-driven approach provides the features to implement consistent
    transactions. The following diagram depicts how EDA helps in the implementation
    of consistency in business transactions that are used by multiple services. The
    example in the diagram refers to the order management example that we used at
    the start of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd8608ed-b2f8-4df2-b5b1-4e25cce5b435.png)'
  prefs: []
  type: TYPE_IMG
- en: Complex event processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of late, many interesting use cases have evolved around complex events. Statistical
    functions such as event correlation and aggregation along with computational algorithms
    are being applied to event data to uncover meaningful patterns that provide valuable
    use cases for several domains/industries. One of the prominent use cases is in
    the field of banking to detect frauds in transactions. Another promising use case
    is in weather forecasting, where several atmospheric parameters are correlated
    to predict cyclones, earthquakes, and so on. Many of the command centers that
    are used for weather forecasting across the world work on the basis of EDA.
  prefs: []
  type: TYPE_NORMAL
- en: Internet of Things (IoT) and EDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IoT refers to the interconnection of all objects around the computing devices
    that are embedded in them, which in turn helps them to send and receive data.
    In this scenario, any object around us will become a smart object and can keep
    sending messages to other objects that have subscribed to receive its messages.
    Using IoT, 3 trillion objects are expected to be interconnected by 2020\. All
    these objects in turn function with the help of EDA architecture. This goes to
    show the huge potential that EDA has in years to come.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[http://tutorials.jenkov.com/software-architecture/event-driven-architecture.html](http://tutorials.jenkov.com/software-architecture/event-driven-architecture.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.5.0/com.ibm.mq.pro.doc/q001020_.htm](https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_7.5.0/com.ibm.mq.pro.doc/q001020_.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the various aspects of EDA patterns. We started
    with the definition and description of the event and event-driven patterns. Then
    we discussed in detail the various components of EDA. EDA patterns have two topology
    variants and each of them has specific usage scenarios based on the system requirements.
    These patterns and their components were discussed in detail.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple variants of EDA patterns. These patterns and their features
    were discussed in detail in the chapter. EDA patterns have multiple layers in
    which they work. These layers and the components that are present in each layer
    were discussed in the chapter. SOA and EDA are related concepts and they complement
    each other. Their similarities, differences, and usage scenarios were discussed
    in detail in this chapter. The chapter concluded with a discussion about the emerging
    trends in the EDA space.
  prefs: []
  type: TYPE_NORMAL
