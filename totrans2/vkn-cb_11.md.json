["```cpp\nmax( 0.0, dot( normal_vector, light_vector ) )\n\n```", "```cpp\n      #version 450 \n      layout( location = 0 ) in vec4 app_position; \n      layout( location = 1 ) in vec3 app_normal; \n      layout( set = 0, binding = 0 ) uniform UniformBuffer { \n        mat4 ModelViewMatrix; \n        mat4 ProjectionMatrix; \n      }; \n      layout( location = 0 ) out float vert_color; \n      void main() { \n        gl_Position = ProjectionMatrix * ModelViewMatrix * \n        app_position; \n        vec3 normal = mat3( ModelViewMatrix ) * app_normal; \n\n        vert_color = max( 0.0, dot( normal, vec3( 0.58, 0.58, 0.58 ) )          ) + 0.1; \n      }\n\n```", "```cpp\n      #version 450 \n      layout( location = 0 ) in float vert_color; \n      layout( location = 0 ) out vec4 frag_color; \n      void main() { \n        frag_color = vec4( vert_color ); \n      }\n\n```", "```cpp\nif( !Load3DModelFromObjFile( \"Data/Models/knot.obj\", true, false, false, true, Model ) ) { \n  return false; \n} \nInitVkDestroyer( LogicalDevice, VertexBuffer ); \nif( !CreateBuffer( *LogicalDevice, sizeof( Model.Data[0] ) * Model.Data.size(), VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, *VertexBuffer ) ) { \n  return false; \n} \nInitVkDestroyer( LogicalDevice, VertexBufferMemory ); \nif( !AllocateAndBindMemoryObjectToBuffer( PhysicalDevice, *LogicalDevice, *VertexBuffer, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, *VertexBufferMemory ) ) { \n  return false; \n} \nif( !UseStagingBufferToUpdateBufferWithDeviceLocalMemoryBound( PhysicalDevice, *LogicalDevice, sizeof( Model.Data[0] ) * Model.Data.size(), &Model.Data[0], *VertexBuffer, 0, 0, VK_ACCESS_TRANSFER_WRITE_BIT, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, VK_PIPELINE_STAGE_VERTEX_INPUT_BIT, GraphicsQueue.Handle, FrameResources.front().CommandBuffer, {} ) ) { \n  return false; \n}\n\n```", "```cpp\nInitVkDestroyer( LogicalDevice, UniformBuffer ); \nInitVkDestroyer( LogicalDevice, UniformBufferMemory ); \nif( !CreateUniformBuffer( PhysicalDevice, *LogicalDevice, 2 * 16 * sizeof( float ), VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, \n  *UniformBuffer, *UniformBufferMemory ) ) { \n  return false; \n}\n\n```", "```cpp\nVkDescriptorSetLayoutBinding descriptor_set_layout_binding = { \n  0, \n  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n  1, \n  VK_SHADER_STAGE_VERTEX_BIT, \n  nullptr \n}; \nInitVkDestroyer( LogicalDevice, DescriptorSetLayout ); \nif( !CreateDescriptorSetLayout( *LogicalDevice, { descriptor_set_layout_binding }, *DescriptorSetLayout ) ) { \n  return false; \n} \nVkDescriptorPoolSize descriptor_pool_size = { \n  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n  1 \n}; \nInitVkDestroyer( LogicalDevice, DescriptorPool ); \nif( !CreateDescriptorPool( *LogicalDevice, false, 1, { descriptor_pool_size }, *DescriptorPool ) ) { \n  return false; \n} \nif( !AllocateDescriptorSets( *LogicalDevice, *DescriptorPool, { *DescriptorSetLayout }, DescriptorSets ) ) { \n  return false; \n} \nBufferDescriptorInfo buffer_descriptor_update = { \n  DescriptorSets[0], \n  0, \n  0, \n  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n  { \n    { \n      *UniformBuffer, \n      0, \n      VK_WHOLE_SIZE \n    } \n  } \n}; \nUpdateDescriptorSets( *LogicalDevice, {}, { buffer_descriptor_update }, {}, {} );\n\n```", "```cpp\nstd::vector<VkAttachmentDescription> attachment_descriptions = { \n  { \n    0, \n    Swapchain.Format, \n    VK_SAMPLE_COUNT_1_BIT, \n    VK_ATTACHMENT_LOAD_OP_CLEAR, \n    VK_ATTACHMENT_STORE_OP_STORE, \n    VK_ATTACHMENT_LOAD_OP_DONT_CARE, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR \n  }, \n  { \n    0, \n    DepthFormat, \n    VK_SAMPLE_COUNT_1_BIT, \n    VK_ATTACHMENT_LOAD_OP_CLEAR, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_ATTACHMENT_LOAD_OP_DONT_CARE, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL \n  } \n}; \nVkAttachmentReference depth_attachment = { \n  1, \n  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL \n}; \nstd::vector<SubpassParameters> subpass_parameters = { \n  { \n    VK_PIPELINE_BIND_POINT_GRAPHICS, \n    {}, \n    { \n      { \n        0, \n        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, \n      } \n    }, \n    {}, \n    &depth_attachment, \n    {} \n  } \n}; \nstd::vector<VkSubpassDependency> subpass_dependencies = { \n  { \n    VK_SUBPASS_EXTERNAL, \n    0, \n    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, \n    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, \n    VK_ACCESS_MEMORY_READ_BIT, \n    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, \n    VK_DEPENDENCY_BY_REGION_BIT \n  }, \n  { \n    0, \n    VK_SUBPASS_EXTERNAL, \n    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, \n    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, \n    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, \n    VK_ACCESS_MEMORY_READ_BIT, \n    VK_DEPENDENCY_BY_REGION_BIT \n  } \n}; \nInitVkDestroyer( LogicalDevice, RenderPass ); \nif( !CreateRenderPass( *LogicalDevice, attachment_descriptions, subpass_parameters, subpass_dependencies, *RenderPass ) ) { \n  return false; \n}\n\n```", "```cpp\nInitVkDestroyer( LogicalDevice, StagingBuffer ); \nif( !CreateBuffer( *LogicalDevice, 2 * 16 * sizeof(float), VK_BUFFER_USAGE_TRANSFER_SRC_BIT, *StagingBuffer ) ) { \n  return false; \n} \nInitVkDestroyer( LogicalDevice, StagingBufferMemory ); \nif( !AllocateAndBindMemoryObjectToBuffer( PhysicalDevice, *LogicalDevice, *StagingBuffer, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT, *StagingBufferMemory ) ) { \n  return false; \n}\n\n```", "```cpp\nMatrix4x4 rotation_matrix = PrepareRotationMatrix( vertical_angle, { 1.0f, 0.0f, 0.0f } ) * PrepareRotationMatrix( horizontal_angle, { 0.0f, -1.0f, 0.0f } ); \nMatrix4x4 translation_matrix = PrepareTranslationMatrix( 0.0f, 0.0f, -4.0f ); \nMatrix4x4 model_view_matrix = translation_matrix * rotation_matrix; \nif( !MapUpdateAndUnmapHostVisibleMemory( *LogicalDevice, *StagingBufferMemory, 0, sizeof( model_view_matrix[0] ) * model_view_matrix.size(), &model_view_matrix[0], true, nullptr ) ) { \n  return false; \n} \nMatrix4x4 perspective_matrix = PreparePerspectiveProjectionMatrix( static_cast<float>(Swapchain.Size.width) / static_cast<float>(Swapchain.Size.height), \n  50.0f, 0.5f, 10.0f ); \nif( !MapUpdateAndUnmapHostVisibleMemory( *LogicalDevice, *StagingBufferMemory, sizeof( model_view_matrix[0] ) * model_view_matrix.size(), \n  sizeof( perspective_matrix[0] ) * perspective_matrix.size(), &perspective_matrix[0], true, nullptr ) ) { \n  return false;\n\n```", "```cpp\nif( !BeginCommandBufferRecordingOperation( command_buffer, VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, nullptr ) ) { \n  return false; \n} \nif( UpdateUniformBuffer ) { \n  UpdateUniformBuffer = false; \n  BufferTransition pre_transfer_transition = { \n    *UniformBuffer, \n    VK_ACCESS_UNIFORM_READ_BIT, \n    VK_ACCESS_TRANSFER_WRITE_BIT, \n    VK_QUEUE_FAMILY_IGNORED, \n    VK_QUEUE_FAMILY_IGNORED \n  }; \n  SetBufferMemoryBarrier( command_buffer, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, { pre_transfer_transition } ); \n  std::vector<VkBufferCopy> regions = { \n    { \n      0, \n      0, \n      2 * 16 * sizeof( float ) \n    } \n  }; \n  CopyDataBetweenBuffers( command_buffer, *StagingBuffer, *UniformBuffer, regions ); \n  BufferTransition post_transfer_transition = { \n    *UniformBuffer, \n    VK_ACCESS_TRANSFER_WRITE_BIT, \n    VK_ACCESS_UNIFORM_READ_BIT, \n    VK_QUEUE_FAMILY_IGNORED, \n    VK_QUEUE_FAMILY_IGNORED \n  }; \n  SetBufferMemoryBarrier( command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_VERTEX_SHADER_BIT, { post_transfer_transition } ); \n}\n\n```", "```cpp\nif( PresentQueue.FamilyIndex != GraphicsQueue.FamilyIndex ) { \n  ImageTransition image_transition_before_drawing = { \n    Swapchain.Images[swapchain_image_index], \n    VK_ACCESS_MEMORY_READ_BIT, \n    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, \n    PresentQueue.FamilyIndex, \n    GraphicsQueue.FamilyIndex, \n    VK_IMAGE_ASPECT_COLOR_BIT \n  }; \n  SetImageMemoryBarrier( command_buffer, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, { image_transition_before_drawing } ); \n} \nBeginRenderPass( command_buffer, *RenderPass, framebuffer, { { 0, 0 }, Swapchain.Size }, { { 0.1f, 0.2f, 0.3f, 1.0f },{ 1.0f, 0 } }, VK_SUBPASS_CONTENTS_INLINE ); \nVkViewport viewport = { \n  0.0f, \n  0.0f, \n  static_cast<float>(Swapchain.Size.width), \n  static_cast<float>(Swapchain.Size.height), \n  0.0f, \n  1.0f, \n}; \nSetViewportStateDynamically( command_buffer, 0, { viewport } ); \nVkRect2D scissor = { \n  { \n    0, \n    0 \n  }, \n  { \n    Swapchain.Size.width, \n    Swapchain.Size.height \n  } \n}; \nSetScissorsStateDynamically( command_buffer, 0, { scissor } ); \nBindVertexBuffers( command_buffer, 0, { { *VertexBuffer, 0 } } ); \nBindDescriptorSets( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, *PipelineLayout, 0, DescriptorSets, {} ); \nBindPipelineObject( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, *Pipeline ); \nfor( size_t i = 0; i < Model.Parts.size(); ++i ) { \n  DrawGeometry( command_buffer, Model.Parts[i].VertexCount, 1, Model.Parts[i].VertexOffset, 0 ); \n} \nEndRenderPass( command_buffer ); \nif( PresentQueue.FamilyIndex != GraphicsQueue.FamilyIndex ) { \n  ImageTransition image_transition_before_present = { \n    Swapchain.Images[swapchain_image_index], \n    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, \n    VK_ACCESS_MEMORY_READ_BIT, \n    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, \n    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, \n    GraphicsQueue.FamilyIndex, \n    PresentQueue.FamilyIndex, \n    VK_IMAGE_ASPECT_COLOR_BIT \n  }; \n  SetImageMemoryBarrier( command_buffer, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, { image_transition_before_present } ); \n} \nif( !EndCommandBufferRecordingOperation( command_buffer ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\ngl_Position = ProjectionMatrix * ModelViewMatrix * app_position; \nvec3 normal = mat3( ModelViewMatrix ) * app_normal; \nvert_color = max( 0.0, dot( normal, vec3( 0.58, 0.58, 0.58 ) ) ) + 0.1;\n\n```", "```cpp\npow( dot( half_vector, normal_vector ), shinniness );\n\n```", "```cpp\nvec3 view_vector = normalize( eye_position.xyz - vert_position.xyz ); \nvec3 light_vector = normalize( light_position.xyz - vert_position.xyz ); \nvec3 half_vector = normalize( view_vector + light_vector );\n\n```", "```cpp\n      #version 450 \n      layout( location = 0 ) in vec4 app_position; \n      layout( location = 1 ) in vec3 app_normal; \n      layout( set = 0, binding = 0 ) uniform UniformBuffer { \n        mat4 ModelViewMatrix; \n        mat4 ProjectionMatrix; \n      }; \n      layout( location = 0 ) out vec3 vert_position; \n      layout( location = 1 ) out vec3 vert_normal; \n      void main() { \n        vec4 position = ModelViewMatrix * app_position; \n\n        vert_position = position.xyz; \n        vert_normal = mat3( ModelViewMatrix ) * app_normal; \n        gl_Position = ProjectionMatrix * position; \n      }\n\n```", "```cpp\n      #version 450 \n      layout( location = 0 ) in vec3 vert_position; \n      layout( location = 1 ) in vec3 vert_normal; \n      layout( push_constant ) uniform LightParameters { \n        vec4 Position; \n      } Light; \n      layout( location = 0 ) out vec4 frag_color; \n      void main() { \n        vec3 normal_vector = normalize( vert_normal ); \n        vec3 light_vector = normalize( Light.Position.xyz - \n      vert_position ); \n        float diffuse_term = max( 0.0, dot( normal_vector, light_vector       ) ); \n\n        frag_color = vec4( diffuse_term + 0.1 ); \n        if( diffuse_term > 0.0 ) { \n          vec3 view_vector = normalize( vec3( 0.0, 0.0, 0.0 ) - \n      vert_position.xyz ); \n          vec3 half_vector = normalize( view_vector + light_vector ); \n          float shinniness = 60.0; \n          float specular_term = pow( dot( half_vector, normal_vector ),       shinniness ); \n          frag_color += vec4( specular_term ); \n        } \n      }\n\n```", "```cpp\nstd::vector<VkPushConstantRange> push_constant_ranges = { \n  { \n    VK_SHADER_STAGE_FRAGMENT_BIT,   // VkShaderStageFlags     stageFlags \n    0,                              // uint32_t               offset \n    sizeof( float ) * 4             // uint32_t               size \n  } \n}; \nInitVkDestroyer( LogicalDevice, PipelineLayout ); \nif( !CreatePipelineLayout( *LogicalDevice, { *DescriptorSetLayout }, push_constant_ranges, *PipelineLayout ) ) { \n  return false; \n}\n\n```", "```cpp\nBindVertexBuffers( command_buffer, 0, { { *VertexBuffer, 0 } } ); \nBindDescriptorSets( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, *PipelineLayout, 0, DescriptorSets, {} ); \nBindPipelineObject( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, *Pipeline ); \nstd::array<float, 4> light_position = { 5.0f, 5.0f, 0.0f, 0.0f }; \nProvideDataToShadersThroughPushConstants( command_buffer, *PipelineLayout, VK_SHADER_STAGE_FRAGMENT_BIT, 0, sizeof( float ) * 4, &light_position[0] );\n\n```", "```cpp\n      #version 450 \n      layout( location = 0 ) in vec4 app_position; \n      layout( location = 1 ) in vec3 app_normal; \n      layout( location = 2 ) in vec2 app_texcoord; \n      layout( location = 3 ) in vec3 app_tangent; \n      layout( location = 4 ) in vec3 app_bitangent; \n      layout( set = 0, binding = 0 ) uniform UniformBuffer { \n        mat4 ModelViewMatrix; \n        mat4 ProjectionMatrix; \n      }; \n      layout( location = 0 ) out vec3 vert_position; \n      layout( location = 1 ) out vec2 vert_texcoord; \n      layout( location = 2 ) out vec3 vert_normal; \n      layout( location = 3 ) out vec3 vert_tanget; \n      layout( location = 4 ) out vec3 vert_bitanget; \n      void main() { \n        vec4 position = ModelViewMatrix * app_position; \n        gl_Position = ProjectionMatrix * position; \n\n        vert_position = position.xyz; \n        vert_texcoord = app_texcoord; \n        vert_normal = mat3( ModelViewMatrix ) * app_normal; \n        vert_tanget = mat3( ModelViewMatrix ) * app_tangent; \n        vert_bitanget = mat3( ModelViewMatrix ) * app_bitangent; \n      }\n\n```", "```cpp\n      #version 450 \n      layout( location = 0 ) in vec3 vert_position; \n      layout( location = 1 ) in vec2 vert_texcoord; \n      layout( location = 2 ) in vec3 vert_normal; \n      layout( location = 3 ) in vec3 vert_tanget; \n      layout( location = 4 ) in vec3 vert_bitanget; \n      layout( set = 0, binding = 1 ) uniform sampler2D ImageSampler; \n      layout( push_constant ) uniform LightParameters { \n        vec4 Position; \n      } Light; \n      layout( location = 0 ) out vec4 frag_color; \n      void main() { \n        vec3 normal = 2 * texture( ImageSampler, vert_texcoord ).rgb - \n      1.0; \n        vec3 normal_vector = normalize( mat3( vert_tanget, \n      vert_bitanget, vert_normal) * normal ); \n        vec3 light_vector = normalize( Light.Position.xyz - \n      vert_position ); \n        float diffuse_term = max( 0.0, dot( normal_vector, light_vector \n      ) ) * max( 0.0, dot( vert_normal, light_vector ) ); \n        frag_color = vec4( diffuse_term + 0.1 ); \n        if( diffuse_term > 0.0 ) { \n          vec3 half_vector = normalize(normalize( -vert_position.xyz  ) \n      + light_vector); \n          float specular_term = pow( dot( half_vector, normal_vector ), \n      60.0 ); \n          frag_color += vec4( specular_term ); \n        } \n      }\n\n```", "```cpp\nint width = 1; \nint height = 1; \nstd::vector<unsigned char> image_data; \nif( !LoadTextureDataFromFile( \"Data/Textures/normal_map.png\", 4, image_data, &width, &height ) ) { \n  return false; \n} \nInitVkDestroyer( LogicalDevice, Sampler ); \nInitVkDestroyer( LogicalDevice, Image ); \nInitVkDestroyer( LogicalDevice, ImageMemory ); \nInitVkDestroyer( LogicalDevice, ImageView ); \nif( !CreateCombinedImageSampler( PhysicalDevice, *LogicalDevice, VK_IMAGE_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, { (uint32_t)width, (uint32_t)height, 1 }, \n  1, 1, VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT, VK_IMAGE_VIEW_TYPE_2D, VK_IMAGE_ASPECT_COLOR_BIT, VK_FILTER_LINEAR, \n  VK_FILTER_LINEAR, VK_SAMPLER_MIPMAP_MODE_NEAREST, VK_SAMPLER_ADDRESS_MODE_REPEAT, VK_SAMPLER_ADDRESS_MODE_REPEAT, \n  VK_SAMPLER_ADDRESS_MODE_REPEAT, 0.0f, false, 1.0f, false, VK_COMPARE_OP_ALWAYS, 0.0f, 1.0f, VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK, \n  false, *Sampler, *Image, *ImageMemory, *ImageView ) ) { \n  return false; \n} \nVkImageSubresourceLayers image_subresource_layer = { \n  VK_IMAGE_ASPECT_COLOR_BIT,    // VkImageAspectFlags     aspectMask \n  0,                            // uint32_t               mipLevel \n  0,                            // uint32_t               baseArrayLayer \n  1                             // uint32_t               layerCount \n}; \nif( !UseStagingBufferToUpdateImageWithDeviceLocalMemoryBound( PhysicalDevice, *LogicalDevice, static_cast<VkDeviceSize>(image_data.size()), \n  &image_data[0], *Image, image_subresource_layer, { 0, 0, 0 }, { (uint32_t)width, (uint32_t)height, 1 }, VK_IMAGE_LAYOUT_UNDEFINED, \n  VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, 0, VK_ACCESS_SHADER_READ_BIT, VK_IMAGE_ASPECT_COLOR_BIT, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, \n  VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, GraphicsQueue.Handle, FrameResources.front().CommandBuffer, {} ) ) { \n  return false; \n}\n\n```", "```cpp\nuint32_t vertex_stride = 0; \nif( !Load3DModelFromObjFile( \"Data/Models/ice.obj\", true, true, true, true, Model, &vertex_stride ) ) { \n  return false; \n}\n\n```", "```cpp\nstd::vector<VkDescriptorSetLayoutBinding> descriptor_set_layout_bindings = { \n  { \n    0, \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1, \n    VK_SHADER_STAGE_VERTEX_BIT, \n    nullptr \n  }, \n  { \n    1, \n    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n    1, \n    VK_SHADER_STAGE_FRAGMENT_BIT, \n    nullptr \n  } \n}; \nInitVkDestroyer( LogicalDevice, DescriptorSetLayout ); \nif( !CreateDescriptorSetLayout( *LogicalDevice, descriptor_set_layout_bindings, *DescriptorSetLayout ) ) { \n  return false; \n}\n\n```", "```cpp\nstd::vector<VkDescriptorPoolSize> descriptor_pool_sizes = { \n  { \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1 \n  }, \n  { \n    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n    1 \n  } \n}; \nInitVkDestroyer( LogicalDevice, DescriptorPool ); \nif( !CreateDescriptorPool( *LogicalDevice, false, 1, descriptor_pool_sizes, *DescriptorPool ) ) { \n  return false; \n} \nif( !AllocateDescriptorSets( *LogicalDevice, *DescriptorPool, { *DescriptorSetLayout }, DescriptorSets ) ) { \n  return false; \n}\n\n```", "```cpp\nBufferDescriptorInfo buffer_descriptor_update = { \n  DescriptorSets[0], \n  0, \n  0, \n  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n  { \n    { \n      *UniformBuffer, \n      0, \n      VK_WHOLE_SIZE \n    } \n  } \n}; \nImageDescriptorInfo image_descriptor_update = { \n  DescriptorSets[0], \n  1, \n  0, \n  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n  { \n    { \n      *Sampler, \n      *ImageView, \n      VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL \n    } \n  } \n}; \nUpdateDescriptorSets( *LogicalDevice, { image_descriptor_update }, { buffer_descriptor_update }, {}, {} );\n\n```", "```cpp\nstd::vector<VkVertexInputBindingDescription> vertex_input_binding_descriptions = { \n  { \n    0, \n    vertex_stride, \n    VK_VERTEX_INPUT_RATE_VERTEX \n  } \n}; \nstd::vector<VkVertexInputAttributeDescription> vertex_attribute_descriptions = { \n  { \n    0, \n    0, \n    VK_FORMAT_R32G32B32_SFLOAT, \n    0 \n  }, \n  { \n    1, \n    0, \n    VK_FORMAT_R32G32B32_SFLOAT, \n    3 * sizeof( float ) \n  }, \n  { \n    2, \n    0, \n    VK_FORMAT_R32G32_SFLOAT, \n    6 * sizeof( float ) \n  }, \n  { \n    3, \n    0, \n    VK_FORMAT_R32G32B32_SFLOAT, \n    8 * sizeof( float ) \n  }, \n  { \n    4, \n    0, \n    VK_FORMAT_R32G32B32_SFLOAT, \n    11 * sizeof( float ) \n  } \n}; \nVkPipelineVertexInputStateCreateInfo vertex_input_state_create_info; \nSpecifyPipelineVertexInputState( vertex_input_binding_descriptions, vertex_attribute_descriptions, vertex_input_state_create_info );\n\n```", "```cpp\nvec4 position = ModelViewMatrix * app_position; \ngl_Position = ProjectionMatrix * position; \n\nvert_position = position.xyz; \nvert_texcoord = app_texcoord; \nvert_normal = mat3( ModelViewMatrix ) * app_normal; \nvert_tangent = mat3( ModelViewMatrix ) * app_tangent; \nvert_bitangent = mat3( ModelViewMatrix ) * app_bitangent;\n\n```", "```cpp\nvec3 normal = 2 * texture( ImageSampler, vert_texcoord ).rgb - 1.0;\n\n```", "```cpp\nvec3 normal_vector = normalize( mat3( vert_tanget, vert_bitanget, vert_normal) * normal );\n\n```", "```cpp\n      #version 450 \n      layout( location = 0 ) in vec4 app_position; \n      layout( location = 1 ) in vec3 app_normal; \n      layout( set = 0, binding = 0 ) uniform UniformBuffer { \n        mat4 ModelViewMatrix; \n        mat4 ProjectionMatrix; \n      }; \n      layout( location = 0 ) out vec3 vert_position; \n      layout( location = 1 ) out vec3 vert_normal; \n      void main() { \n        vert_position = app_position.xyz; \n        vert_normal = app_normal; \n\n        gl_Position = ProjectionMatrix * ModelViewMatrix * \n      app_position; \n      }\n\n```", "```cpp\n      #version 450 \n      layout( location = 0 ) in vec3 vert_position; \n      layout( location = 1 ) in vec3 vert_normal; \n      layout( set = 0, binding = 1 ) uniform samplerCube Cubemap; \n      layout( push_constant ) uniform LightParameters { \n        vec4 Position; \n      } Camera; \n      layout( location = 0 ) out vec4 frag_color; \n      void main() { \n        vec3 view_vector = vert_position - Camera.Position.xyz; \n\n        float angle = smoothstep( 0.3, 0.7, dot( normalize( -\n      view_vector ), vert_normal ) ); \n\n        vec3 reflect_vector = reflect( view_vector, vert_normal ); \n        vec4 reflect_color = texture( Cubemap, reflect_vector ); \n\n        vec3 refrac_vector = refract( view_vector, vert_normal, 0.3 ); \n        vec4 refract_color = texture( Cubemap, refrac_vector ); \n\n        frag_color = mix( reflect_color, refract_color, angle ); \n      }\n\n```", "```cpp\nif( !CreateCombinedImageSampler( PhysicalDevice, *LogicalDevice, VK_IMAGE_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, { 1024, 1024, 1 }, 1, 6, \n  VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_ASPECT_COLOR_BIT, VK_FILTER_LINEAR, \n  VK_FILTER_LINEAR, VK_SAMPLER_MIPMAP_MODE_NEAREST, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, \n  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, 0.0f, false, 1.0f, false, VK_COMPARE_OP_ALWAYS, 0.0f, 1.0f, VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK, \n  false, *CubemapSampler, *CubemapImage, *CubemapImageMemory, *CubemapImageView ) ) { \n  return false; \n}\n\n```", "```cpp\nstd::vector<std::string> cubemap_images = { \n  \"Data/Textures/Skansen/posx.jpg\", \n  \"Data/Textures/Skansen/negx.jpg\", \n  \"Data/Textures/Skansen/posy.jpg\", \n  \"Data/Textures/Skansen/negy.jpg\", \n  \"Data/Textures/Skansen/posz.jpg\", \n  \"Data/Textures/Skansen/negz.jpg\" \n}; \nfor( size_t i = 0; i < cubemap_images.size(); ++i ) { \n  std::vector<unsigned char> cubemap_image_data; \n  int image_data_size; \n  if( !LoadTextureDataFromFile( cubemap_images[i].c_str(), 4, cubemap_image_data, nullptr, nullptr, nullptr, &image_data_size ) ) { \n    return false; \n  } \n  VkImageSubresourceLayers image_subresource = { \n    VK_IMAGE_ASPECT_COLOR_BIT, \n    0, \n    static_cast<uint32_t>(i), \n    1 \n  }; \n  UseStagingBufferToUpdateImageWithDeviceLocalMemoryBound( PhysicalDevice, *LogicalDevice, image_data_size, &cubemap_image_data[0], \n    *CubemapImage, image_subresource, { 0, 0, 0 }, { 1024, 1024, 1 }, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, \n    0, VK_ACCESS_SHADER_READ_BIT, VK_IMAGE_ASPECT_COLOR_BIT, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, \n    GraphicsQueue.Handle, FrameResources.front().CommandBuffer, {} ); \n}\n\n```", "```cpp\nstd::vector<VkDescriptorSetLayoutBinding> descriptor_set_layout_bindings = { \n  { \n    0, \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1, \n    VK_SHADER_STAGE_VERTEX_BIT, \n    nullptr \n  }, \n  { \n    1, \n    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n    1, \n    VK_SHADER_STAGE_FRAGMENT_BIT, \n    nullptr \n  } \n}; \nInitVkDestroyer( LogicalDevice, DescriptorSetLayout ); \nif( !CreateDescriptorSetLayout( *LogicalDevice, descriptor_set_layout_bindings, *DescriptorSetLayout ) ) { \n  return false; \n}\n\n```", "```cpp\nstd::vector<VkDescriptorPoolSize> descriptor_pool_sizes = { \n  { \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1 \n  }, \n  { \n    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n    1 \n  } \n}; \nInitVkDestroyer( LogicalDevice, DescriptorPool ); \nif( !CreateDescriptorPool( *LogicalDevice, false, 1, descriptor_pool_sizes, *DescriptorPool ) ) { \n  return false; \n} \nif( !AllocateDescriptorSets( *LogicalDevice, *DescriptorPool, { *DescriptorSetLayout }, DescriptorSets ) ) { \n  return false; \n}\n\n```", "```cpp\nBufferDescriptorInfo buffer_descriptor_update = { \n  DescriptorSets[0], \n  0, \n  0, \n  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n  { \n    { \n      *UniformBuffer, \n      0, \n      VK_WHOLE_SIZE \n    } \n  } \n}; \nImageDescriptorInfo image_descriptor_update = { \n  DescriptorSets[0], \n  1, \n  0, \n  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n  { \n    { \n      *CubemapSampler, \n      *CubemapImageView, \n      VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL \n    } \n  } \n}; \nUpdateDescriptorSets( *LogicalDevice, { image_descriptor_update }, { buffer_descriptor_update }, {}, {} );\n\n```", "```cpp\nstd::vector<VkPushConstantRange> push_constant_ranges = { \n  { \n    VK_SHADER_STAGE_FRAGMENT_BIT, \n    0, \n    sizeof( float ) * 4 \n  } \n}; \nInitVkDestroyer( LogicalDevice, PipelineLayout ); \nif( !CreatePipelineLayout( *LogicalDevice, { *DescriptorSetLayout }, push_constant_ranges, *PipelineLayout ) ) { \n  return false; \n}\n\n```", "```cpp\nvert_position = app_position.xyz; \nvert_normal = app_normal; \n\ngl_Position = ProjectionMatrix * ModelViewMatrix * app_position;\n\n```", "```cpp\nvec3 view_vector = vert_position - Camera.Position.xyz; \n\nfloat angle = smoothstep( 0.3, 0.7, dot( normalize( -view_vector ), vert_normal ) ); \n\nvec3 reflect_vector = reflect( view_vector, vert_normal ); \nvec4 reflect_color = texture( Cubemap, reflect_vector ); \n\nvec3 refrac_vector = refract( view_vector, vert_normal, 0.3 ); \nvec4 refract_color = texture( Cubemap, refrac_vector ); \n\nfrag_color = mix( reflect_color, refract_color, angle );\n\n```", "```cpp\nBindDescriptorSets( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, *PipelineLayout, 0, DescriptorSets, {} ); \nBindPipelineObject( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, *ModelPipeline ); \nBindVertexBuffers( command_buffer, 0, { { *ModelVertexBuffer, 0 } } ); \nProvideDataToShadersThroughPushConstants( command_buffer, *PipelineLayout, VK_SHADER_STAGE_FRAGMENT_BIT, 0, sizeof( float ) * 4, &Camera.GetPosition()[0] ); \nfor( size_t i = 0; i < Model.Parts.size(); ++i ) { \n  DrawGeometry( command_buffer, Model.Parts[i].VertexCount, 1, Model.Parts[i].VertexOffset, 0 ); \n}\n\n```", "```cpp\nBindPipelineObject( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, *SkyboxPipeline ); \nBindVertexBuffers( command_buffer, 0, { { *SkyboxVertexBuffer, 0 } } ); \nfor( size_t i = 0; i < Skybox.Parts.size(); ++i ) { \n  DrawGeometry( command_buffer, Skybox.Parts[i].VertexCount, 1, Skybox.Parts[i].VertexOffset, 0 ); \n}\n\n```", "```cpp\n      #version 450 \n      layout( location = 0 ) in vec4 app_position; \n      layout( set = 0, binding = 0 ) uniform UniformBuffer { \n        mat4 ShadowModelViewMatrix; \n        mat4 SceneModelViewMatrix; \n        mat4 ProjectionMatrix; \n      }; \n      void main() { \n        gl_Position = ProjectionMatrix * ShadowModelViewMatrix *       \n      app_position; \n      }\n\n```", "```cpp\n      #version 450 \n\n      layout( location = 0 ) in vec4 app_position; \n      layout( location = 1 ) in vec3 app_normal; \n\n      layout( set = 0, binding = 0 ) uniform UniformBuffer { \n        mat4 ShadowModelViewMatrix; \n        mat4 SceneModelViewMatrix; \n        mat4 ProjectionMatrix; \n      }; \n\n      layout( push_constant ) uniform LightParameters { \n        vec4 Position; \n      } Light; \n\n      layout( location = 0 ) out vec3 vert_normal; \n      layout( location = 1 ) out vec4 vert_texcoords; \n      layout( location = 2 ) out vec3 vert_light; \n\n      const mat4 bias = mat4(  \n        0.5, 0.0, 0.0, 0.0, \n        0.0, 0.5, 0.0, 0.0, \n        0.0, 0.0, 1.0, 0.0, \n        0.5, 0.5, 0.0, 1.0 ); \n\n      void main() { \n        gl_Position = ProjectionMatrix * SceneModelViewMatrix * \n      app_position; \n\n        vert_normal = mat3( SceneModelViewMatrix ) * app_normal; \n        vert_texcoords = bias * ProjectionMatrix * \n      ShadowModelViewMatrix * app_position; \n        vert_light = (SceneModelViewMatrix * vec4( Light.Position.xyz, \n      0.0 ) ).xyz; \n      }\n\n```", "```cpp\n#version 450 \n\nlayout( location = 0 ) in vec3 vert_normal; \nlayout( location = 1 ) in vec4 vert_texcoords; \nlayout( location = 2 ) in vec3 vert_light; \n\nlayout( set = 0, binding = 1 ) uniform sampler2D ShadowMap; \n\nlayout( location = 0 ) out vec4 frag_color; \n\nvoid main() { \n  float shadow = 1.0; \n  vec4 shadow_coords = vert_texcoords / vert_texcoords.w; \n\n  if( texture( ShadowMap, shadow_coords.xy ).r < shadow_coords.z - 0.005 ) { \n    shadow = 0.5; \n  } \n\n  vec3 normal_vector = normalize( vert_normal ); \n  vec3 light_vector = normalize( vert_light ); \n  float diffuse_term = max( 0.0, dot( normal_vector, light_vector ) ); \n\n  frag_color = shadow * vec4( diffuse_term ) + 0.1; \n}\n\n```", "```cpp\nif( !CreateCombinedImageSampler( PhysicalDevice, *LogicalDevice, VK_IMAGE_TYPE_2D, DepthFormat, { 512, 512, 1 }, 1, 1, \n  VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_VIEW_TYPE_2D, VK_IMAGE_ASPECT_DEPTH_BIT, VK_FILTER_LINEAR, \n  VK_FILTER_LINEAR, VK_SAMPLER_MIPMAP_MODE_NEAREST, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, \n  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, 0.0f, false, 1.0f, false, VK_COMPARE_OP_ALWAYS, 0.0f, 1.0f, VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK, \n  false, *ShadowMapSampler, *ShadowMap.Image, *ShadowMap.Memory, *ShadowMap.View ) ) { \n  return false; \n}\n\n```", "```cpp\nstd::vector<VkDescriptorSetLayoutBinding> descriptor_set_layout_bindings = { \n  { \n    0, \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1, \n    VK_SHADER_STAGE_VERTEX_BIT, \n    nullptr \n  }, \n  { \n    1, \n    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n    1, \n    VK_SHADER_STAGE_FRAGMENT_BIT, \n    nullptr \n  } \n}; \nInitVkDestroyer( LogicalDevice, DescriptorSetLayout ); \nif( !CreateDescriptorSetLayout( *LogicalDevice, descriptor_set_layout_bindings, *DescriptorSetLayout ) ) { \n  return false; \n} \n\nstd::vector<VkDescriptorPoolSize> descriptor_pool_sizes = { \n  { \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1 \n  }, \n  { \n    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n    1 \n  } \n}; \nInitVkDestroyer( LogicalDevice, DescriptorPool ); \nif( !CreateDescriptorPool( *LogicalDevice, false, 1, descriptor_pool_sizes, *DescriptorPool ) ) { \n  return false; \n} \nif( !AllocateDescriptorSets( *LogicalDevice, *DescriptorPool, { *DescriptorSetLayout }, DescriptorSets ) ) { \n  return false; \n}\n\n```", "```cpp\nBufferDescriptorInfo buffer_descriptor_update = { \n  DescriptorSets[0], \n  0, \n  0, \n  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n  { \n    { \n      *UniformBuffer, \n      0, \n      VK_WHOLE_SIZE \n    } \n  } \n}; \n\nImageDescriptorInfo image_descriptor_update = { \n  DescriptorSets[0], \n  1, \n  0, \n  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, \n  { \n    { \n      *ShadowMapSampler, \n      *ShadowMap.View, \n      VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL \n    } \n  } \n}; \nUpdateDescriptorSets( *LogicalDevice, { image_descriptor_update }, { buffer_descriptor_update }, {}, {} );\n\n```", "```cpp\nstd::vector<VkAttachmentDescription> shadow_map_attachment_descriptions = { \n  { \n    0 \n    DepthFormat, \n    VK_SAMPLE_COUNT_1_BIT, \n    VK_ATTACHMENT_LOAD_OP_CLEAR, \n    VK_ATTACHMENT_STORE_OP_STORE, \n    VK_ATTACHMENT_LOAD_OP_DONT_CARE, \n    VK_ATTACHMENT_STORE_OP_DONT_CARE, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL \n  } \n}; \nVkAttachmentReference shadow_map_depth_attachment = { \n  0, \n  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL \n}; \nstd::vector<SubpassParameters> shadow_map_subpass_parameters = { \n  { \n    VK_PIPELINE_BIND_POINT_GRAPHICS, \n    {}, \n    {}, \n    {}, \n    &shadow_map_depth_attachment, \n    {} \n  } \n}; \nstd::vector<VkSubpassDependency> shadow_map_subpass_dependencies = { \n  { \n    VK_SUBPASS_EXTERNAL, \n    0, \n    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, \n    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, \n    VK_ACCESS_SHADER_READ_BIT, \n    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, \n    VK_DEPENDENCY_BY_REGION_BIT \n  }, \n  { \n    0, \n    VK_SUBPASS_EXTERNAL, \n    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT, \n    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, \n    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, \n    VK_ACCESS_SHADER_READ_BIT, \n    VK_DEPENDENCY_BY_REGION_BIT \n  } \n}; \nInitVkDestroyer( LogicalDevice, ShadowMapRenderPass ); \nif( !CreateRenderPass( *LogicalDevice, shadow_map_attachment_descriptions, shadow_map_subpass_parameters, shadow_map_subpass_dependencies, \n  *ShadowMapRenderPass ) ) { \n  return false; \n} \nInitVkDestroyer( LogicalDevice, ShadowMap.Framebuffer ); \nif( !CreateFramebuffer( *LogicalDevice, *ShadowMapRenderPass, { *ShadowMap.View }, 512, 512, 1, *ShadowMap.Framebuffer ) ) { \n  return false; \n}\n\n```", "```cpp\nstd::vector<VkPushConstantRange> push_constant_ranges = { \n  { \n    VK_SHADER_STAGE_VERTEX_BIT, \n    0, \n    sizeof( float ) * 4 \n  } \n}; \nInitVkDestroyer( LogicalDevice, PipelineLayout ); \nif( !CreatePipelineLayout( *LogicalDevice, { *DescriptorSetLayout }, push_constant_ranges, *PipelineLayout ) ) { \n  return false; \n}\n\n```", "```cpp\nvert_normal = mat3( SceneModelViewMatrix ) * app_normal; \nvert_light = (SceneModelViewMatrix * vec4( Light.Position.xyz, 0.0 ) ).xyz;\n\n```", "```cpp\nvert_texcoords = bias * ProjectionMatrix * ShadowModelViewMatrix * app_position;\n\n```", "```cpp\nfloat shadow = 1.0; \nvec4 shadow_coords = vert_texcoords / vert_texcoords.w; \nif( texture( ShadowMap, shadow_coords.xy ).r < shadow_coords.z - 0.005 ) { \n  shadow = 0.5; \n}\n\n```", "```cpp\nBeginRenderPass( command_buffer, *ShadowMapRenderPass, *ShadowMap.Framebuffer, { { 0, 0, }, { 512, 512 } }, { { 1.0f, 0 } }, VK_SUBPASS_CONTENTS_INLINE ); \nBindVertexBuffers( command_buffer, 0, { { *VertexBuffer, 0 } } ); \nBindDescriptorSets( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, *PipelineLayout, 0, DescriptorSets, {} ); \nBindPipelineObject( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, *ShadowMapPipeline ); \nDrawGeometry( command_buffer, Scene[0].Parts[0].VertexCount + Scene[1].Parts[0].VertexCount, 1, 0, 0 ); \nEndRenderPass( command_buffer ); \nif( PresentQueue.FamilyIndex != GraphicsQueue.FamilyIndex ) { \n  ImageTransition image_transition_before_drawing = { \n    Swapchain.Images[swapchain_image_index], \n    VK_ACCESS_MEMORY_READ_BIT, \n    VK_ACCESS_MEMORY_READ_BIT, \n    VK_IMAGE_LAYOUT_UNDEFINED, \n    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, \n    PresentQueue.FamilyIndex, \n    GraphicsQueue.FamilyIndex, \n    VK_IMAGE_ASPECT_COLOR_BIT \n  }; \n  SetImageMemoryBarrier( command_buffer, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, { image_transition_before_drawing } ); \n} \nBeginRenderPass( command_buffer, *SceneRenderPass, framebuffer, { { 0, 0 }, Swapchain.Size }, { { 0.1f, 0.2f, 0.3f, 1.0f }, { 1.0f, 0 } }, VK_SUBPASS_CONTENTS_INLINE ); \n\nVkViewport viewport = { \n  0.0f, \n  0.0f, \n  static_cast<float>(Swapchain.Size.width), \n  static_cast<float>(Swapchain.Size.height), \n  0.0f, \n  1.0f, \n}; \nSetViewportStateDynamically( command_buffer, 0, { viewport } ); \n\nVkRect2D scissor = { \n  { \n    0, \n    0 \n  }, \n  { \n    Swapchain.Size.width, \n    Swapchain.Size.height \n  } \n}; \nSetScissorsStateDynamically( command_buffer, 0, { scissor } ); \nBindPipelineObject( command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, *ScenePipeline ); \nProvideDataToShadersThroughPushConstants( command_buffer, *PipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof( float ) * 4, &LightSource.GetPosition()[0] ); \nDrawGeometry( command_buffer, Scene[0].Parts[0].VertexCount + Scene[1].Parts[0].VertexCount, 1, 0, 0 ); \nEndRenderPass( command_buffer );\n\n```"]