<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Gathering Platform and Compiler Information"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Gathering Platform and Compiler Information</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Detecting int128 support</li><li class="listitem" style="list-style-type: disc">Detecting RTTI support</li><li class="listitem" style="list-style-type: disc">Speeding up compilation using C++11 extern templates</li><li class="listitem" style="list-style-type: disc">Writing metafunctions using simpler methods</li><li class="listitem" style="list-style-type: disc">Reducing code size and increasing performance of user-defined types (UDTs) in C++11</li><li class="listitem" style="list-style-type: disc">The portable way to export and import functions and classes</li><li class="listitem" style="list-style-type: disc">Detecting the Boost version and getting latest features</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec92"/>Introduction</h1></div></div></div><p>Different projects and companies have different coding requirements. Some of them forbid exceptions or RTTI and some forbid C++11. If you are willing to write portable code that can be used by a wide range of projects, this chapter is for you.</p><p>Want to make your code as fast as possible and use the latest C++ features? You'll definitely need a tool for detecting compiler features.</p><p>Some compilers have unique features that may greatly simplify your life. If you are targeting a single compiler, you can save many hours and use those features. No need to implement their analogues from scratch!</p><p>This chapter is devoted to different helper macros used to detect compiler, platform, and Boost features. Those macro are widely used across Boost libraries and are essential for writing portable code that is able to work with any compiler flags.</p></div></div>
<div class="section" title="Detecting int128 support"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec93"/>Detecting int128 support</h1></div></div></div><p>Some compilers have support for <a id="id601" class="indexterm"/>extended arithmetic types such as 128-bit floats or integers. Let's take a quick glance at how to use them using Boost. We'll be creating a method that accepts three parameters and returns the multiplied value of those methods.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec369"/>Getting ready</h2></div></div></div><p>Only basic knowledge of C++ is required.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec370"/>How to do it...</h2></div></div></div><p>What do we need to work with 128-bit integers? Macros that show that they are available and a few typedefs to have portable type names across platforms.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll need only a single header:<div class="informalexample"><pre class="programlisting">#include &lt;boost/config.hpp&gt;</pre></div></li><li class="listitem">Now we need to detect int128 support:<div class="informalexample"><pre class="programlisting">#ifdef BOOST_HAS_INT128</pre></div></li><li class="listitem">Add some typedefs and implement the method as follows:<div class="informalexample"><pre class="programlisting">typedef boost::int128_type int_t;
typedef boost::uint128_type uint_t;

inline int_t mul(int_t v1, int_t v2, int_t v3) {
    return v1 * v2 * v3;
}</pre></div></li><li class="listitem">For compilers that do not support the int128 type, we may require support of the int64 type:<div class="informalexample"><pre class="programlisting">#else // BOOST_NO_LONG_LONG

#ifdef BOOST_NO_LONG_LONG
#error "This code requires at least int64_t support"
#endif</pre></div></li><li class="listitem">Now we need to provide some implementation for compilers without int128 support using int64:<div class="informalexample"><pre class="programlisting">struct int_t { boost::long_long_type hi, lo; };
struct uint_t { boost::ulong_long_type hi, lo; };

inline int_t mul(int_t v1, int_t v2, int_t v3) {
    // Some hand written math
    // ...
}

#endif // BOOST_NO_LONG_LONG</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec371"/>How it works...</h2></div></div></div><p>The header <code class="literal">&lt;boost/config.hpp&gt;</code> contains a lot of macros to describe compiler and platform features. In this example, we used <code class="literal">BOOST_HAS_INT128</code> to detect support of 128-bit integers and <code class="literal">BOOST_NO_LONG_LONG</code> to detect support of 64-bit integers.</p><p>As we may see from the example, Boost has typedefs for 64-bit signed and unsigned integers:</p><div class="informalexample"><pre class="programlisting">boost::long_long_type 
boost::ulong_long_type </pre></div><p>It also has typedefs for 128-bit signed and unsigned integers:</p><div class="informalexample"><pre class="programlisting">boost::int128_type
boost::uint128_type</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec372"/>There's more...</h2></div></div></div><p>C++11 has support of 64-bit types via the <code class="literal">long long int</code> and <code class="literal">unsigned long long int</code> built-in types. Unfortunately, not all <a id="id602" class="indexterm"/>compilers support C++11, so <code class="literal">BOOST_NO_LONG_LONG</code> will be useful for you. 128-bit integers are not a part of C++11, so typedefs and macros from Boost are the only way to write portable code.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec373"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Read the recipe <span class="emphasis"><em>Detecting RTTI support</em></span> for more information about <code class="literal">Boost.Config</code>.</li><li class="listitem" style="list-style-type: disc">Read the official documentation of <a id="id603" class="indexterm"/><code class="literal">Boost.Config</code> for more information about its abilities at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html</a>.</li><li class="listitem" style="list-style-type: disc">There is a library in Boost that allows constructing types of unlimited precision. Take a look at the <code class="literal">Boost.Multiprecision</code> library at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/multiprecision/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/multiprecision/doc/html/index.html</a>.</li></ul></div></div></div>
<div class="section" title="Detecting RTTI support"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec94"/>Detecting RTTI support</h1></div></div></div><p>Some companies and libraries have <a id="id604" class="indexterm"/>specific requirements for their C++ code, such as successful compilation without <span class="strong"><strong>Runtime type information</strong></span> (<span class="strong"><strong>RTTI</strong></span>). In this small recipe, we'll take a look at how we can detect disabled RTTI, how to store information about types, and compare types at runtime, even without <code class="literal">typeid</code>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec374"/>Getting ready</h2></div></div></div><p>Basic knowledge of C++ RTTI usage is required for this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec375"/>How to do it...</h2></div></div></div><p>Detecting disabled RTTI, storing information about types, and comparing types at runtime are tricks that are widely used across Boost libraries. The examples are <code class="literal">Boost.Exception</code> and <code class="literal">Boost.Function</code>.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To do this, we first need to include the following header:<div class="informalexample"><pre class="programlisting">#include &lt;boost/config.hpp&gt;</pre></div></li><li class="listitem">Let's first look at the situation where RTTI is enabled and the C++11 <code class="literal">std::type_index</code> class is available:<div class="informalexample"><pre class="programlisting">#if !defined(BOOST_NO_RTTI) \
    &amp;&amp; !defined(BOOST_NO_CXX11_HDR_TYPEINDEX)

#include &lt;typeindex&gt;
using std::type_index;

template &lt;class T&gt;
type_index type_id() {
    return typeid(T);
}</pre></div></li><li class="listitem">Otherwise, we need to construct our own <code class="literal">type_index</code> class:<div class="informalexample"><pre class="programlisting">#else

#include &lt;cstring&gt;

struct type_index {
    const char* name_;

    explicit type_index(const char* name)
        : name_(name)
    {}
};

inline bool operator == (const type_index&amp; v1, 
    const type_index&amp; v2) 
{
    return !std::strcmp(v1.name_, v2.name_);
}

inline bool operator != (const type_index&amp; v1, 
    const type_index&amp; v2) 
{
    // '!!' to supress warnings
    return !!std::strcmp(v1.name_, v2.name_);
}</pre></div></li><li class="listitem">The final step is to define the <code class="literal">type_id</code> function:<div class="informalexample"><pre class="programlisting">#include &lt;boost/current_function.hpp&gt;

template &lt;class T&gt;
inline type_index type_id() {
    return type_index(BOOST_CURRENT_FUNCTION);
}
#endif</pre></div></li><li class="listitem">Now we can compare types:<div class="informalexample"><pre class="programlisting">    assert(type_id&lt;unsigned int&gt;() == type_id&lt;unsigned&gt;());
    assert(type_id&lt;double&gt;() != type_id&lt;long double&gt;());</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec376"/>How it works...</h2></div></div></div><p>The macro <code class="literal">BOOST_NO_RTTI</code> will be defined if RTTI is disabled, and the macro <code class="literal">BOOST_NO_CXX11_HDR_TYPEINDEX</code> will be defined when the compiler has no <code class="literal">&lt;typeindex&gt;</code> header and no <code class="literal">std::type_index</code> class.</p><p>The handwritten <code class="literal">type_index</code> structure from step 3 of the previous section only holds the pointer to some string; nothing really interesting here.</p><p>Take a look at the <code class="literal">BOOST_CURRENT_FUNCTION</code> <a id="id605" class="indexterm"/>macro. It returns the full name of the current function, including template parameters, arguments, and the return type. For example, <code class="literal">type_id&lt;double&gt;()</code> will be represented as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>type_index type_id() [with T = double]</strong></span>
</pre></div><p>So, for any other type, <a id="id606" class="indexterm"/>
<code class="literal">BOOST_CURRENT_FUNCTION</code> will return a different string, and that's why the <code class="literal">type_index</code> variable from the example won't compare equal-to it.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec377"/>There's more...</h2></div></div></div><p>Different compilers have different macros for getting the full function name and RTTI. Using macros from Boost is the most portable solution. The <code class="literal">BOOST_CURRENT_FUNCTION</code> macro returns the name at compile time, so it implies minimal runtime penalty.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec378"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Read the upcoming recipes for <a id="id607" class="indexterm"/>more information on <code class="literal">Boost.Config</code></li><li class="listitem" style="list-style-type: disc">Browse to <a class="ulink" href="https://github.com/apolukhin/type_index">https://github.com/apolukhin/type_index</a> and refer to the library there, which uses all the tricks from this recipe to implement <code class="literal">type_index</code></li><li class="listitem" style="list-style-type: disc">Read the official documentation of <code class="literal">Boost.Config</code> at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html</a></li></ul></div></div></div>
<div class="section" title="Speeding up compilation using C++11 extern templates"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec95"/>Speeding up compilation using C++11 extern templates</h1></div></div></div><p>Remember some situations <a id="id608" class="indexterm"/>where you were using some complicated template class declared in the header file? Examples of such classes would be <code class="literal">boost::variant</code>, containers from <code class="literal">Boost.Container</code>, or <code class="literal">Boost.Spirit</code> parsers. When we use such classes or methods, they are usually compiled (instantiated) separately in each source file that is using them, and duplicates are thrown away during linking. On some compilers, that may lead to slow compilation speed.</p><p>If only there was some way to tell the compiler in which source file to instantiate it!</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec379"/>Getting ready</h2></div></div></div><p>Basic knowledge of templates is required for this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec380"/>How to do it...</h2></div></div></div><p>This method is widely used in modern C++ standard libraries for compilers that do support it. For example, the STL library, which is shipped with GCC, uses this technique to instantiate <code class="literal">std::basic_string&lt;char&gt;</code> and <code class="literal">std::basic_fstream&lt;char&gt;</code>.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To do it by ourselves, we need to include the following header:<div class="informalexample"><pre class="programlisting">#include &lt;boost/config.hpp&gt;</pre></div></li><li class="listitem">We also need to include a header file that contains a template class whose instantiation count we wish to reduce:<div class="informalexample"><pre class="programlisting">#include &lt;boost/variant.hpp&gt;
#include &lt;boost/blank.hpp&gt;
#include &lt;string&gt;</pre></div></li><li class="listitem">The following is the code for compilers with support for C++11 extern templates:<div class="informalexample"><pre class="programlisting">#ifndef BOOST_NO_CXX11_EXTERN_TEMPLATE

extern template class boost::variant&lt;
    boost::blank,
    int,
    std::string,
    double
&gt;;

#endif</pre></div></li><li class="listitem">Now we need to add the <a id="id609" class="indexterm"/>following code to the source file where we wish the template to be instantiated:<div class="informalexample"><pre class="programlisting">// Header with 'extern template'
#include "header.hpp"

#ifndef BOOST_NO_CXX11_EXTERN_TEMPLATE
template class boost::variant&lt;
    boost::blank,
    int,
    std::string,
    double
&gt;;
#endif</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec381"/>How it works...</h2></div></div></div><p>The C++11 keyword <code class="literal">extern template</code> just tells the compiler not to instantiate the template without an explicit request to do that.</p><p>The code in step 4 is an explicit request to instantiate the template in this source file.</p><p>The <a id="id610" class="indexterm"/>
<code class="literal">BOOST_NO_CXX11_EXTERN_TEMPLATE</code> macro is defined when the compiler has support of C++11 extern templates.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec382"/>There's more...</h2></div></div></div><p>Extern templates do not affect the runtime performance of your program, but can significantly reduce the compilation time of some template classes. Do not overuse them; they are nearly useless for small <a id="id611" class="indexterm"/>template classes.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec383"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Read the other recipes of this chapter to get more information about <code class="literal">Boost.Config</code></li><li class="listitem" style="list-style-type: disc">Read the official documentation of <code class="literal">Boost.Config</code> for information about macros that was not covered in this chapter, at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html</a></li></ul></div></div></div>
<div class="section" title="Writing metafunctions using simpler methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec96"/>Writing metafunctions using simpler methods</h1></div></div></div><p><a class="link" href="ch04.html" title="Chapter 4. Compile-time Tricks">Chapter 4</a>, <span class="emphasis"><em>Compile-time Tricks</em></span>, and <a class="link" href="ch08.html" title="Chapter 8. Metaprogramming">Chapter 8</a>, <span class="emphasis"><em>Metaprogramming</em></span>, were devoted to metaprogramming. If you were trying to use <a id="id612" class="indexterm"/>techniques from those chapters, you may have noticed that writing a metafunction can take a lot of time. So it may be a good idea to experiment with metafunctions using more user-friendly methods, such as C++11 <code class="literal">constexpr</code>, before writing a portable implementation.</p><p>In this recipe, we'll take a look at how to detect <code class="literal">constexpr</code> support.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec384"/>Getting ready</h2></div></div></div><p>The <code class="literal">constexpr</code> functions are <a id="id613" class="indexterm"/>functions that can be evaluated at compile time. That is all we need to know for this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec385"/>How to do it...</h2></div></div></div><p>Currently, not many compilers support the <code class="literal">constexpr</code> feature, so a good new compiler may be required for experiments. Let's see how we can detect compiler support for the <code class="literal">constexpr</code> feature:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Just like in other recipes from this chapter, we start with the following header:<div class="informalexample"><pre class="programlisting">#include &lt;boost/config.hpp&gt;</pre></div></li><li class="listitem">Now we will work with <code class="literal">constexpr</code>:<div class="informalexample"><pre class="programlisting">#if !defined(BOOST_NO_CXX11_CONSTEXPR) \
    &amp;&amp; !defined(BOOST_NO_CXX11_HDR_ARRAY)

template &lt;class T&gt;
constexpr int get_size(const T&amp; val) {
    return val.size() * sizeof(typename T::value_type);
}</pre></div></li><li class="listitem">Let's print an error if C++11 features are missing:<div class="informalexample"><pre class="programlisting">#else
#error "This code requires C++11 constexpr and std::array"
#endif</pre></div></li><li class="listitem">That's it; now we are free to write code such as the following:<div class="informalexample"><pre class="programlisting">std::array&lt;short, 5&gt; arr;
assert(get_size(arr) == 5 * sizeof(short));

unsigned char data[get_size(arr)];</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec386"/>How it works...</h2></div></div></div><p>The <code class="literal">BOOST_NO_CXX11_CONSTEXPR</code> <a id="id614" class="indexterm"/>macro is defined when C++11 <code class="literal">constexpr</code> is available.</p><p>The <code class="literal">constexpr</code> keyword <a id="id615" class="indexterm"/>tells the compiler that the function can be evaluated at compile time if all the inputs for that function are compile-time constants. C++11 imposes a lot of limitations on what a <code class="literal">constexpr</code> function can do. C++14 will remove some of the limitations.</p><p>The <code class="literal">BOOST_NO_CXX11_HDR_ARRAY</code> <a id="id616" class="indexterm"/>macro is defined when the C++11 <code class="literal">std::array</code> class and the <code class="literal">&lt;array&gt;</code> header are available.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec387"/>There's more...</h2></div></div></div><p>However, there are other usable and interesting macros for <code class="literal">constexpr</code> too, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">BOOST_CONSTEXPR</code> macro expands to <code class="literal">constexpr</code> or does not expand</li><li class="listitem" style="list-style-type: disc">The <code class="literal">BOOST_CONSTEXPR_OR_CONST</code> macro expands to <code class="literal">constexpr</code> or <code class="literal">const</code></li><li class="listitem" style="list-style-type: disc">The <code class="literal">BOOST_STATIC_CONSTEXPR</code> macro is the same as <code class="literal">static BOOST_CONSTEXPR_OR_CONST</code></li></ul></div><p>Using those macros, it is possible to write code that takes advantage of C++11 constant expression features if they are available:</p><div class="informalexample"><pre class="programlisting">template &lt;class T, T Value&gt;
struct integral_constant {
    BOOST_STATIC_CONSTEXPR T value = Value;
   
    BOOST_CONSTEXPR operator T() const {
        return this-&gt;value;
    }
};</pre></div><p>Now, we can use <code class="literal">integral_constant</code> as shown in the following code:</p><div class="informalexample"><pre class="programlisting">char array[integral_constant&lt;int, 10&gt;()];</pre></div><p>In the example, <code class="literal">BOOST_CONSTEXPR operator T()</code> will be called to get the array size.</p><p>The C++11 constant expressions may improve compilation speed and diagnostic information in case of error. It's a good feature to use.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec388"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">More information about <a id="id617" class="indexterm"/><code class="literal">constexpr</code> usage can be read at <a class="ulink" href="http://en.cppreference.com/w/cpp/language/constexpr">http://en.cppreference.com/w/cpp/language/constexpr</a></li><li class="listitem" style="list-style-type: disc">Read the official documentation of <code class="literal">Boost.Config</code> for more information about macros at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html</a></li></ul></div></div></div>
<div class="section" title="Reducing code size and increasing performance of user-defined types (UDTs) in C++11"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec97"/>Reducing code size and increasing performance of user-defined types (UDTs) in C++11</h1></div></div></div><p>C++11 has very specific logic when <span class="strong"><strong>user-defined types</strong></span> (<span class="strong"><strong>UDTs</strong></span>) are used in STL containers. Containers will use move assignment and move construction only if the move constructor does not throw exceptions <a id="id618" class="indexterm"/>or there is no copy constructor.</p><p>Let's see how we can ensure the <code class="literal">move_nothrow</code> assignment operator and <code class="literal">move_nothrow</code> constructor of our type do not <a id="id619" class="indexterm"/>throw exceptions.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec389"/>Getting ready</h2></div></div></div><p>Basic knowledge of C++11 rvalue references is required for this recipe. Knowledge of STL containers will also serve you well.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec390"/>How to do it...</h2></div></div></div><p>Let's take a look at how we can improve our C++ classes using Boost.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">All we need to do is mark the <code class="literal">move_nothrow</code> assignment operator and <code class="literal">move_nothrow</code> constructor with the <code class="literal">BOOST_NOEXCEPT</code> macro:<div class="informalexample"><pre class="programlisting">#include &lt;boost/config.hpp&gt;
class move_nothrow {
    // Some class class members go here
    // ...
public:
    move_nothrow() BOOST_NOEXCEPT {}
    move_nothrow(move_nothrow&amp;&amp;) BOOST_NOEXCEPT
        // : members initialization
        // ...
    {}

    move_nothrow&amp; operator=(move_nothrow&amp;&amp;) BOOST_NOEXCEPT {
        // Implementation
        // ...
        return *this;
    }

    move_nothrow(const move_nothrow&amp;);
    move_nothrow&amp; operator=(const move_nothrow&amp;);
};</pre></div></li><li class="listitem">Now we may use the class <a id="id620" class="indexterm"/>with <code class="literal">std::vector</code> in C++11 without any modifications:<div class="informalexample"><pre class="programlisting">    std::vector&lt;move_nothrow&gt; v(10);
    v.push_back(move_nothrow());</pre></div></li><li class="listitem">If we remove <code class="literal">BOOST_NOEXCEPT</code> from the move constructor, we'll get the following error for GCC-4.7 and later compilers:<div class="informalexample"><pre class="programlisting">/usr/include/c++/4.7/bits/stl_construct.h:77: undefined reference to `move_nothrow::move_nothrow(move_nothrow const&amp;)'</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec391"/>How it works...</h2></div></div></div><p>The <code class="literal">BOOST_NOEXCEPT</code> macro expands <a id="id621" class="indexterm"/>to <code class="literal">noexcept</code> on compilers that support it. The STL containers use type traits to detect if the constructor throws an exception or not. Type traits make their decision mainly based on <code class="literal">noexcept</code> specifiers.</p><p>Why do we get an error without <code class="literal">BOOST_NOEXCEPT</code>? GCC's type traits return the move constructor that <code class="literal">move_nothrow</code> throws, so <code class="literal">std::vector</code> will try to use the copy constructor of <code class="literal">move_nothrow</code>, which is not defined.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec392"/>There's more...</h2></div></div></div><p>The <code class="literal">BOOST_NOEXCEPT</code> macro also reduces binary size irrespective of whether the definition of the <code class="literal">noexcept</code> <a id="id622" class="indexterm"/>function or method is in a separate source file or not.</p><div class="informalexample"><pre class="programlisting">// In header file
int foo() BOOST_NOEXCEPT;

// In source file
int foo() BOOST_NOEXCEPT {
    return 0;
}</pre></div><p>That's because in the latter case, the compiler knows that the function will not throw exceptions and so there is no need to generate code that handles them.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>If a function marked as <code class="literal">noexcept</code> does throw an exception, your program will terminate without calling destructors for the constructed objects.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec393"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A document describing why move <a id="id623" class="indexterm"/>constructors are allowed to throw exceptions and how containers must move objects is available at <a class="ulink" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html</a></li><li class="listitem" style="list-style-type: disc">Read the official documentation of <code class="literal">Boost.Config</code> for more examples of <code class="literal">noexcept</code> macros existing in Boost, at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/conf">http://www.boost.org/doc/libs/1_53_0/libs/conf</a><a class="ulink" href="http://ig/doc/html/index.html">ig/doc/html/index.html</a></li></ul></div></div></div>
<div class="section" title="The portable way to export and import functions and classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec98"/>The portable way to export and import functions and classes</h1></div></div></div><p>Almost all modern languages <a id="id624" class="indexterm"/>have the ability to make libraries, which is a collection of classes and methods that have a well-defined interface. C++ is no exception to this rule. We have <a id="id625" class="indexterm"/>two types of libraries: runtime (also called shared or <a id="id626" class="indexterm"/>dynamic load) and static. But writing libraries is not a trivial task in C++. Different platforms have different methods for describing which symbols must be exported from the shared library.</p><p>Let's have a look at how to manage symbol visibility in a portable way using Boost.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec394"/>Getting ready</h2></div></div></div><p>Experience in creating dynamic and static libraries will be useful in this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec395"/>How to do it...</h2></div></div></div><p>The code for this recipe consists of two parts. The first part is the library itself. The second part is the code that uses that library. Both parts use the same header, in which the library methods are declared. Managing symbol visibility in a portable way using Boost is simple and can be done using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the header file, we'll <a id="id627" class="indexterm"/>need <a id="id628" class="indexterm"/>definitions from the following <code class="literal">include</code> header:<div class="informalexample"><pre class="programlisting">#include &lt;boost/config.hpp&gt;</pre></div></li><li class="listitem">The following code must also be added to the header file:<div class="informalexample"><pre class="programlisting">#if defined(MY_LIBRARY_LINK_DYNAMIC)
# if defined(MY_LIBRARY_COMPILATION)
#   define MY_LIBRARY_API BOOST_SYMBOL_EXPORT
# else
#   define MY_LIBRARY_API BOOST_SYMBOL_IMPORT
# endif
#else
# define MY_LIBRARY_API
#endif</pre></div></li><li class="listitem">Now all the declarations must use the <code class="literal">MY_LIBRARY_API</code> macro:<div class="informalexample"><pre class="programlisting">int MY_LIBRARY_API foo();
class MY_LIBRARY_API bar { 
public:
    /* ... */ 
    int meow() const;
};</pre></div></li><li class="listitem"> Exceptions must be declared with <code class="literal">BOOST_SYMBOL_VISIBLE</code>, otherwise they can be caught only using <code class="literal">catch(...)</code> in the code that will use the library:<div class="informalexample"><pre class="programlisting">#include &lt;stdexcept&gt;
struct BOOST_SYMBOL_VISIBLE bar_exception
    : public std::exception 
{};</pre></div></li><li class="listitem">Library source files must include the header file:<div class="informalexample"><pre class="programlisting">#define MY_LIBRARY_COMPILATION
#include "my_library.hpp"</pre></div></li><li class="listitem">Definitions of methods must also be in the source files of the library:<div class="informalexample"><pre class="programlisting">int MY_LIBRARY_API foo() {
    // Implementation
    // ...
    return 0;
}
int bar::meow() const {
    throw bar_exception();
}</pre></div></li><li class="listitem">Now we can use the library as shown in the following code:<div class="informalexample"><pre class="programlisting">#include "../my_library/my_library.hpp"
#include &lt;cassert&gt;

int main() {
    assert(foo() == 0);
    bar b;
    try {
        b.meow();
        assert(false);
    } catch (const bar_exception&amp;) {}
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec396"/>How it works...</h2></div></div></div><p>All the work is done in step 2. There <a id="id629" class="indexterm"/>we are defining the macro <code class="literal">MY_LIBRARY_API</code>, which will be applied to classes and methods that we wish to export from our library. In step 2, we check for <code class="literal">MY_LIBRARY_LINK_DYNAMIC</code>; if it is not defined, we are building a static library <a id="id630" class="indexterm"/>and there is no need to define <code class="literal">MY_LIBRARY_API</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>The developer must take care of <code class="literal">MY_LIBRARY_LINK_DYNAMIC</code>! It will not define itself. So we need to make our build system to define it, if we are making a dynamic library.</p></div></div><p>If <code class="literal">MY_LIBRARY_LINK_DYNAMIC</code> is defined, we are building a runtime library, and that's where the workarounds start. You, as the developer, must tell the compiler that we are now exporting these methods to the user. The user must tell the compiler that he/she is importing methods from the library. To have a single header file for both library import and export, we use the following code:</p><div class="informalexample"><pre class="programlisting"># if defined(MY_LIBRARY_COMPILATION)
#   define MY_LIBRARY_API BOOST_SYMBOL_EXPORT
# else
#   define MY_LIBRARY_API BOOST_SYMBOL_IMPORT
# endif</pre></div><p>When exporting the library (or, in other words, compiling it), we must define <code class="literal">MY_LIBRARY_COMPILATION</code>. This leads to <code class="literal">MY_LIBRARY_API</code> being defined to <code class="literal">BOOST_SYMBOL_EXPORT</code>. For example, see step 5, where we defined <code class="literal">MY_LIBRARY_COMPILATION</code> before including <code class="literal">my_library.hpp</code>. If <code class="literal">MY_LIBRARY_COMPILATION</code> is not defined, the header is included by the user, who doesn't know anything about that macro. And, if the header is included by the user, the symbols must be imported from the library.</p><p>The <code class="literal">BOOST_SYMBOL_VISIBLE</code> macro must be used only for those classes that are not exported and are used by RTTI. Examples of <a id="id631" class="indexterm"/>such classes are exceptions and classes being cast using <code class="literal">dynamic_cast</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec397"/>There's more...</h2></div></div></div><p>Some compilers export all the symbols by <a id="id632" class="indexterm"/>default but provide flags to disable such behavior. For example, GCC provides <code class="literal">-fvisibility=hidden</code>. It is highly recommended to use those flags because it leads to smaller binary size, faster loading of dynamic libraries, and better logical structuring of binary input. Some inter-procedural optimizations can perform better when fewer symbols are exported.</p><p>C++11 has generalized attributes that someday may be used to provide a portable way to work with visibilities, but until then we have to use macros from Boost.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec398"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Read this chapter from the beginning to get more examples of <code class="literal">Boost.Config</code> usage</li><li class="listitem" style="list-style-type: disc">Consider reading the official documentation of <code class="literal">Boost.Config</code> for the full list of the <code class="literal">Boost.Config</code> macro and their description at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.htm">http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html</a></li></ul></div></div></div>
<div class="section" title="Detecting the Boost version and getting latest features"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec99"/>Detecting the Boost version and getting latest features</h1></div></div></div><p>Boost is being actively developed, so <a id="id633" class="indexterm"/>each release contains new features and libraries. Some people wish to have libraries that compile for different versions of Boost and also want to use some of the features of the new versions.</p><p>Let's take a look at the <code class="literal">boost::lexical_cast</code> change log. According to it, Boost 1.53 has a <code class="literal">lexical_cast(const CharType* chars, std::size_t count)</code> function overload. Our task for this recipe will be to use that function overload for new versions of Boost, and work around that missing function overload for older versions.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec399"/>Getting ready</h2></div></div></div><p>Only basic knowledge of C++ and the <code class="literal">Boost.Lexical</code> library is required.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec400"/>How to do it...</h2></div></div></div><p>Well, all we need to do is get a version of Boost and use it to write optimal code. This can be done as shown in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We need to include headers containing the Boost version and <code class="literal">boost::lexical_cast</code>:<div class="informalexample"><pre class="programlisting">#include &lt;boost/version.hpp&gt;
#include &lt;boost/lexical_cast.hpp&gt;</pre></div></li><li class="listitem">We will use the new feature of <code class="literal">Boost.LexicalCast</code> if it is available:<div class="informalexample"><pre class="programlisting">#if (BOOST_VERSION &gt;= 105200)
int to_int(const char* str, std::size_t length) {
    return boost::lexical_cast&lt;int&gt;(str, length);
}</pre></div></li><li class="listitem">Otherwise, we are required to copy data to <code class="literal">std::string</code> first:<div class="informalexample"><pre class="programlisting">#else
int to_int(const char* str, std::size_t length) {
    return boost::lexical_cast&lt;int&gt;(
        std::string(str, length)
    );
}
#endif</pre></div></li><li class="listitem">Now we can use the code as shown here:<div class="informalexample"><pre class="programlisting">assert(to_int("10000000", 3) == 100);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec401"/>How it works...</h2></div></div></div><p>The <code class="literal">BOOST_VERSION</code> macro <a id="id634" class="indexterm"/>contains the Boost version written in the following format: a single number for the major version, followed by three numbers for the minor version, and <a id="id635" class="indexterm"/>then two numbers for the patch level. For example, Boost 1.46.1 will contain the <code class="literal">104601</code> number in the <code class="literal">BOOST_VERSION</code> macro.</p><p>So, we will check the Boost version in step 2 and choose the correct implementation of the <code class="literal">to_int</code> function according to the abilities of <code class="literal">Boost.LexicalCast</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec402"/>There's more...</h2></div></div></div><p>Having a version macro is a common practice for big libraries. Some of the Boost libraries allow you to specify the version of the <a id="id636" class="indexterm"/>library to use; see <code class="literal">Boost.Thread</code> and its <code class="literal">BOOST_THREAD_VERSION</code> macro for an example.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec403"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Read the recipe <span class="emphasis"><em>Creating an execution thread</em></span> in <a class="link" href="ch05.html" title="Chapter 5. Multithreading">Chapter 5</a>, <span class="emphasis"><em>Multithreading</em></span>, for more information about <code class="literal">BOOST_THREAD_VERSION</code> and how it affects the <code class="literal">Boost.Thread</code> library, or read the documentation at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/thread/changes.html">http://www.boost.org/doc/libs/1_53_0/doc/html/thread/changes.html</a></li><li class="listitem" style="list-style-type: disc">Read this chapter from the beginning or consider reading the official documentation of <code class="literal">Boost.Config</code> at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/config/doc/html/index.html</a></li></ul></div></div></div></body></html>