- en: Chapter 2. Preparing for Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 准备开发
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Setting up a GUI for tweaking parameters
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置用于调整参数的图形用户界面（GUI）
- en: Saving and loading configurations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和加载配置
- en: Making a snapshot of the current parameter state
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获当前参数状态的快照
- en: Using MayaCamUI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MayaCamUI
- en: Using 3D space guides
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用3D空间指南
- en: Communicating with other software
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他软件通信
- en: Preparing your application for iOS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为iOS准备您的应用程序
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will introduce several simple recipes that can be very useful
    during the development process.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些在开发过程中非常有用的简单配方。
- en: Setting up a GUI for tweaking parameters
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用于调整参数的GUI
- en: '**Graphical User Interface** (**GUI**) is often required for controlling and
    tuning your Cinder application. In many cases, you spend more time tweaking the
    application parameters to achieve the desired result than writing the code. It
    is true especially when you are working on some generative graphics.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形用户界面**（**GUI**）通常用于控制和调整您的Cinder应用程序。在许多情况下，您花费更多的时间调整应用程序参数以实现所需的结果，而不是编写代码。这在您正在处理一些生成图形时尤其如此。'
- en: Cinder provides a convenient and easy-to-use GUI via the `InterfaceGl` class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder通过`InterfaceGl`类提供了一个方便且易于使用的GUI。
- en: '![Setting up a GUI for tweaking parameters](img/8703OS_02_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![设置用于调整参数的GUI](img/8703OS_02_01.jpg)'
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To make the `InterfaceGl` class available in your Cinder application, all you
    have to do is include one header file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`InterfaceGl`类在您的Cinder应用程序中可用，您只需包含一个头文件即可。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Follow the steps given here to add a GUI to your Cinder application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 按照此处给出的步骤将GUI添加到您的Cinder应用程序中。
- en: Let's start with preparing different types of variables within our main class,
    which we will be manipulating using the GUI.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在我们的主类中准备不同类型的变量开始，我们将使用GUI来操作这些变量。
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, declare the `InterfaceGl` class member like this:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明`InterfaceGl`类成员如下：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we move to the `setup` method and initialize our GUI window passing `"Parameters"`
    as the window caption and size to the `InterfaceGl` constructor:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们转向`setup`方法，并初始化我们的GUI窗口，将`"Parameters"`作为窗口标题传递给`InterfaceGl`构造函数：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And now we can add and configure controls for our variables:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以添加和配置变量的控件：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Take a look at the `addParam` method and its parameters. The first parameter
    is just the field caption. The second parameter is a pointer to the variable where
    the value is stored. There are a bunch of supported variable types, such as `bool`,
    `float`, `double`, `int`, `Vec3f`, `Quatf`, `Color`, `ColorA`, and `std::string`.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看`addParam`方法和其参数。第一个参数只是字段标题。第二个参数是存储值的变量的指针。有许多支持的变量类型，例如`bool`、`float`、`double`、`int`、`Vec3f`、`Quatf`、`Color`、`ColorA`和`std::string`。
- en: 'The possible variables types and their interface representations are tabulated
    in the following table:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能的变量类型及其接口表示在以下表中列出：
- en: '| Type | Representation |'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 类型 | 表示 |'
- en: '| --- | --- |'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `std:string` | ![How to do it…](img/8703OS_02_02.jpg) |'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `std::string` | ![如何操作…](img/8703OS_02_02.jpg) |'
- en: '| `Numerical: int, float, double` | ![How to do it…](img/8703OS_02_03.jpg)
    |'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `Numerical: int, float, double` | ![如何操作…](img/8703OS_02_03.jpg) |'
- en: '| `bool` | ![How to do it…](img/8703OS_02_04.jpg) |'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `bool` | ![如何操作…](img/8703OS_02_04.jpg) |'
- en: '| `ci::Vec3f` | ![How to do it…](img/8703OS_02_05.jpg) |'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `ci::Vec3f` | ![如何操作…](img/8703OS_02_05.jpg) |'
- en: '| `ci::Quatf` | ![How to do it…](img/8703OS_02_06.jpg) |'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `ci::Quatf` | ![如何操作…](img/8703OS_02_06.jpg) |'
- en: '| `ci::Color` | ![How to do it…](img/8703OS_02_07.jpg) |'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `ci::Color` | ![如何操作…](img/8703OS_02_07.jpg) |'
- en: '| `ci::ColorA` | ![How to do it…](img/8703OS_02_08.jpg) |'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `ci::ColorA` | ![如何操作…](img/8703OS_02_08.jpg) |'
- en: '| Enumerated parameter | ![How to do it…](img/8703OS_02_09.jpg) |'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 枚举参数 | ![如何操作…](img/8703OS_02_09.jpg) |'
- en: 'The third parameter defines the control options. In the following table, you
    can find some commonly used options and their short explanations:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三个参数定义了控制选项。在下面的表中，您可以找到一些常用选项及其简短说明：
- en: '| Name | Explanation |'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 名称 | 说明 |'
- en: '| --- | --- |'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `min` | The minimum possible value of a numeric variable |'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `min` | 数值变量的可能最小值 |'
- en: '| `max` | The maximum possible value of a numeric variable |'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `max` | 数值变量的可能最大值 |'
- en: '| `step` | Defines the number of significant digits printed after the period
    for floating point variables |'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `step` | 定义浮点变量小数点后打印的显著数字的数量 |'
- en: '| `key` | Keyboard shortcut for calling button callback |'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `key` | 调用按钮回调的键盘快捷键 |'
- en: '| `keyIncr` | Keyboard shortcut for incrementing the value |'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `keyIncr` | 增加值的键盘快捷键 |'
- en: '| `keyDecr` | Keyboard shortcut for decrementing the value |'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `keyDecr` | 减少值的键盘快捷键 |'
- en: '| `readonly` | Setting the value to `true` makes a variable read-only in GUI
    |'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `readonly` | 将值设置为`true`使变量在GUI中为只读 |'
- en: '| `precision` | Defines the number of significant digits printed after the
    period for floating point variables |'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `precision` | 定义浮点变量小数点后打印的显著数字的数量 |'
- en: Tip
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can find the complete documentation of the available options on the AntTweakBar
    page at the following address: [http://anttweakbar.sourceforge.net/doc/tools:anttweakbar:varparamsyntax](http://anttweakbar.sourceforge.net/doc/tools:anttweakbar:varparamsyntax).'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在以下地址的AntTweakBar页面找到可用选项的完整文档：[http://anttweakbar.sourceforge.net/doc/tools:anttweakbar:varparamsyntax](http://anttweakbar.sourceforge.net/doc/tools:anttweakbar:varparamsyntax)。
- en: 'The last thing to do is invoke the `InterfaceGl::draw()` method. We will do
    this at the end of the `draw` method in our main class by typing the following
    code line:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一件要做的事情是调用`InterfaceGl::draw()`方法。我们将在主类中的`draw`方法末尾通过输入以下代码行来完成此操作：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `setup` method we will set up the GUI window and then add controls, setting
    up a name in the first parameter of the `addParam` method. In a second parameter,
    we are pointing to the variable we want to link the GUI element to. Whenever we
    change values through the GUI, the linked variable will be updated.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup`方法中，我们将设置GUI窗口并添加控件，在`addParam`方法的第一个参数中设置一个名称。在第二个参数中，我们指向我们想要链接GUI元素的变量。每次我们通过GUI更改值时，链接的变量都会更新。
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: There are a few more options for `InterfaceGl`, if you need more control over
    built-in GUI mechanism, please refer to the *AntTweakBar* documentation which
    you can find on the project page mentioned in the *See also* section of this recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`InterfaceGl`，如果您需要更多控制内置GUI机制，请参阅*AntTweakBar*文档，您可以在本菜谱的*也见*部分提到的项目页面上找到。
- en: Buttons
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按钮
- en: 'You can also add buttons to the InterfaceGl (CIT) panel with callbacks to some
    functions. For example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以向InterfaceGl (CIT)面板添加按钮，并为其分配一些函数的回调。例如：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Clicking on the **Start** button in the GUI fires the `start` method of the
    `MainApp` class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI中点击**开始**按钮将触发`MainApp`类的`start`方法。
- en: Panel position
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面板位置
- en: 'A convenient way to control the position of the GUI panel is through the usage
    of the *AntTweekBar* facility. You have to include an additional header file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 控制GUI面板位置的便捷方式是通过使用*AntTweekBar*工具。您必须包含一个额外的头文件：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And now you can change the position of the GUI panel with this code line:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用以下代码行更改GUI面板的位置：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, `Parameters` is the GUI panel name and the `position` option takes
    x and y as values.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Parameters`是GUI面板名称，`position`选项接受x和y作为值。
- en: See also
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也见
- en: There are some good looking GUI libraries available as CinderBlocks. Cinder
    has an extensions system called blocks. The idea behind CinderBlocks is to provide
    easy-to-use integration with many third-party libraries. You can find how to add
    examples of CinderBlocks to your project in the *Communicating with other software*
    recipe.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CinderBlocks中提供了一些看起来不错的GUI库。Cinder有一个名为blocks的扩展系统。CinderBlocks背后的理念是提供与许多第三方库的易于使用的集成。您可以在*与其他软件通信*菜谱中找到如何将CinderBlocks示例添加到您的项目的说明。
- en: SimpleGUI
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SimpleGUI
- en: An alternative GUI developed by *Marcin Ignac* as a CinderBlock can be found
    at [https://github.com/vorg/MowaLibs/tree/master/SimpleGUI](https://github.com/vorg/MowaLibs/tree/master/SimpleGUI).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/vorg/MowaLibs/tree/master/SimpleGUI](https://github.com/vorg/MowaLibs/tree/master/SimpleGUI)找到由*Marcin
    Ignac*开发的作为CinderBlock的替代GUI。
- en: ciUI
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ciUI
- en: You can check out an alternative user interface developed by *Reza Ali* as a
    CinderBlock at [http://www.syedrezaali.com/blog/?p=2366](http://www.syedrezaali.com/blog/?p=2366).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看由*Reza Ali*开发的作为CinderBlock的替代用户界面，地址为[http://www.syedrezaali.com/blog/?p=2366](http://www.syedrezaali.com/blog/?p=2366)。
- en: AntTweakBar
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AntTweakBar
- en: '`InterfaceGl` in Cinder is built on top of *AntTweakBar*; you can find its
    documentation at [http://www.antisphere.com/Wiki/tools:anttweakbar](http://www.antisphere.com/Wiki/tools:anttweakbar).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder中的`InterfaceGl`是在*AntTweakBar*之上构建的；您可以在[http://www.antisphere.com/Wiki/tools:anttweakbar](http://www.antisphere.com/Wiki/tools:anttweakbar)找到其文档。
- en: Saving and loading configurations
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和加载配置
- en: Many applications that you will develop operate on input parameters set by the
    user. For example, it could be the color or position of some graphical elements
    or parameters used to set up communication with other applications. Reading configurations
    from external files is necessary for your applications. We will use a built-in
    Cinder support for reading and writing XML files to implement the configuration
    persistence mechanism.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要开发的大多数应用程序都会操作用户设置的输入参数。例如，这可能是某些图形元素的色彩或位置，或者用于设置与其他应用程序通信的参数。从外部文件读取配置对于你的应用程序是必要的。我们将使用
    Cinder 内置的读取和写入 XML 文件的支持来实现配置持久化机制。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create two configurable variables in the main class: the IP address and the
    port of the host we are communicating with.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在主类中创建两个可配置的变量：我们正在与之通信的主机的 IP 地址和端口号。
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Now we will implement the `loadConfig` and `saveConfig` methods and use them
    to load the configuration on application startup and save the changes while closing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现 `loadConfig` 和 `saveConfig` 方法，并在应用程序启动时加载配置，在关闭时保存更改。
- en: 'Include the two following additional headers:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含以下两个额外的头文件：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will prepare two methods for loading and saving the XML configuration file.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为加载和保存 XML 配置文件准备两种方法。
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now in the `setup` method, inside our main class, we will put:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在主类的 `setup` 方法中，我们将放置以下内容：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After this we will implement the `shutdown` method as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们将按照以下方式实现 `shutdown` 方法：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And don''t forget to declare the `shutdown` method in the main class:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且不要忘记在主类中声明 `shutdown` 方法：
- en: '[PRE14]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first two methods, `loadConfig` and `saveConfig`, are essential. The `loadConfig`
    method tries to open the `config.xml` file and find the `general` node. Inside
    the `general` node should be the `hostIP` and `hostPort` nodes. The values of
    these nodes will be assigned to corresponding variables in our application: `mHostIP`
    and `mHostPort`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个方法，`loadConfig` 和 `saveConfig`，是必不可少的。`loadConfig` 方法尝试打开 `config.xml` 文件并找到
    `general` 节点。在 `general` 节点中应该有 `hostIP` 和 `hostPort` 节点。这些节点的值将被分配到我们应用程序中相应的变量：`mHostIP`
    和 `mHostPort`。
- en: 'The `shutdown` method is automatically triggered by Cinder just before the
    application closes, so our configuration values will be stored in the XML file
    when we quit the application. Finally, our configuration XML file looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutdown` 方法在 Cinder 应用程序关闭前自动触发，因此当我们退出应用程序时，我们的配置值将被存储在 XML 文件中。最后，我们的配置
    XML 文件看起来像这样：'
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see clearly that the nodes are referring to application variables.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到节点正在引用应用程序变量。
- en: See also
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: You can write your own configuration loader and saver or use the existing CinderBlock.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写自己的配置加载器和保存器，或者使用现有的 CinderBlock。
- en: Cinder-Config
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cinder-Config
- en: Cinder-Config is a small CinderBlock for creating configuration files along
    with `InterfaceGl`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder-Config 是一个小的 CinderBlock，用于创建配置文件以及 `InterfaceGl`。
- en: '[https://github.com/dawidgorny/Cinder-Config](https://github.com/dawidgorny/Cinder-Config)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/dawidgorny/Cinder-Config](https://github.com/dawidgorny/Cinder-Config)'
- en: Making a snapshot of the current parameter state
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作当前参数状态的快照
- en: We will implement a simple but useful mechanism for saving and loading the parameters'
    states. The code used in the examples will be based on the previous recipes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个简单但有用的机制来保存和加载参数的状态。示例中使用的代码将基于之前的配方。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s say we have a variable that we are changing frequently. In this case,
    it will be the color of some element we are drawing and the main class will have
    the following member variable:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个频繁更改的变量。在这种情况下，它将是我们在绘图中更改的某个元素的色彩，主类将具有以下成员变量：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will use a built-in XML parser and the `fileDrop` event handler.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用内置的 XML 解析器和 `fileDrop` 事件处理器。
- en: 'We have to include the following additional headers:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须包含以下额外的头文件：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'First, we implement two methods for loading and saving parameters:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们实现两个用于加载和保存参数的方法：
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we declare a class member. It will be the flag to trigger snapshot creation:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们声明一个类成员。它将是一个触发快照创建的标志：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Assign a value to it value inside the `setup` method:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中为其赋值：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At the end of the `draw` method we put the following code, just before the
    `params::InterfaceGl::draw();` line:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `draw` 方法的末尾，我们在 `params::InterfaceGl::draw();` 行之前放置以下代码：
- en: '[PRE21]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We want to make a button in our `InterfaceGl` window:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想在 `InterfaceGl` 窗口中创建一个按钮：
- en: '[PRE22]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see we don''t have the `makeSnapshotClick` method yet. It is simple
    to implement:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如你所见，我们还没有`makeSnapshotClick`方法。实现起来很简单：
- en: '[PRE23]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The last step will be adding the following method for *drag-and-drop* support:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步将是添加以下方法以支持*拖放*：
- en: '[PRE24]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have two methods for loading and storing the `mColor` values in an XML file.
    These methods are `loadParameters` and `saveParameters`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法用于在XML文件中加载和存储`mColor`值。这些方法是`loadParameters`和`saveParameters`。
- en: The code we put inside the `draw` method needs some explanation. We are waiting
    for the `mMakeSnapshot` method to be set to `true` and then we are creating a
    timestamp to avoid overwriting previous snapshots.The next two lines store the
    chosen values by invoking the `saveParameters` method and save a current window
    view as a PNG file using the `writeImage` function. Please notice that we have
    put that code before invoking `InterfaceGl::draw`, so we save the window view
    without the GUI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放在`draw`方法内部的代码需要一些解释。我们正在等待`mMakeSnapshot`方法被设置为`true`，然后我们创建一个时间戳以避免覆盖之前的快照。接下来的两行通过调用`saveParameters`方法存储所选值，并使用`writeImage`函数将当前窗口视图保存为PNG文件。请注意，我们在调用`InterfaceGl::draw`之前放置了这段代码，所以我们保存的窗口视图没有GUI。
- en: A nice thing we have here is the *drag-and-drop* feature for loading snapshot
    files. It's implemented in the `fileDrop` method; Cinder invokes this method every
    time files are dropped to your application window. First, we get a path to the
    dropped file; in the case of multiple files, we are taking only one. Then we invoke
    the `loadParameters` method with the dropped file path as an argument.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个很好的功能是加载快照文件的*拖放*功能。它在`fileDrop`方法中实现；每当文件被拖放到你的应用程序窗口时，Cinder都会调用此方法。首先，我们获取被拖放文件的路径；在多个文件的情况下，我们只取一个。然后我们使用被拖放文件的路径作为参数调用`loadParameters`方法。
- en: Using MayaCamUI
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MayaCamUI
- en: We are going to add to your 3D scene a navigation facility known to us since
    we modelled a 3D software. Using `MayaCamUI`, you can do this with just a few
    lines of code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向你的3D场景添加一个导航功能，这是我们自从建模3D软件以来就熟知的。使用`MayaCamUI`，你只需几行代码就能做到这一点。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need to have some 3D objects in our scene. You can use some primitives provided
    by Cinder, for example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在场景中有些3D对象。你可以使用Cinder提供的某些原语，例如：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A color cube is a cube with a different color on each face, so it is easy to
    determine the orientation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个彩色立方体是一个每个面都有不同颜色的立方体，因此很容易确定方向。
- en: '![Getting ready](img/8703OS_02_10.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/8703OS_02_10.jpg)'
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to create camera navigation:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建相机导航：
- en: 'We need the `MayaCam.h` header file:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要`MayaCam.h`头文件：
- en: '[PRE26]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also need some member declarations in the main class:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在主类中添加一些成员声明：
- en: '[PRE27]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Inside the `setup` method, we are going to set up the camera''s initial state:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法内部，我们将设置相机的初始状态：
- en: '[PRE28]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we have to implement three methods:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须实现三个方法：
- en: '[PRE29]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Apply camera matrices before your 3D drawing stuff inside the `draw` method:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法内部应用相机矩阵：
- en: '[PRE30]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Inside the `setup` method, we set the initial camera settings. While the window
    is resizing, we have to update the aspect ratio of our camera, so we put the code
    for this in the `resize` method. This method is automatically invoked by Cinder
    each time the window of our application is resized. We catch mouse events inside
    the `mouseDown` and `mouseDrag` methods. You can click and drag your mouse for
    tumbling, right-click for zooming, and use the middle button for panning. Now
    you have interaction similar to a common 3D modeling software in your own application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup`方法内部，我们设置初始的相机设置。当窗口调整大小时，我们必须更新相机的纵横比，因此我们将这段代码放在`resize`方法中。每当我们的应用程序窗口调整大小时，Cinder都会自动调用此方法。我们在`mouseDown`和`mouseDrag`方法内部捕获鼠标事件。你可以点击并拖动鼠标进行旋转，右键点击进行缩放，使用中间按钮进行平移。现在你已经在自己的应用程序中拥有了类似于常见3D建模软件的交互功能。
- en: Using 3D space guides
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用3D空间指南
- en: We will try to use built-in Cinder methods to visualize some basic information
    about the scene we are working on. It should make working with 3D space more comfortable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用内置的Cinder方法来可视化我们正在工作的场景的一些基本信息。这应该会使在3D空间中工作更加舒适。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will need the `MayaCamUI` navigation that we have implemented in the previous
    recipe.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要我们在上一个菜谱中实现的`MayaCamUI`导航。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will draw some objects that will help to visualize and find the orientation
    of a 3D scene.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制一些有助于可视化和找到 3D 场景方向的物体。
- en: 'We will add another camera besides `MayaCamUI`. Let''s start by adding member
    declarations to the main class:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在 `MayaCamUI` 之外添加另一个相机。让我们先在主类中添加成员声明：
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then we will set the initial values inside the `setup` method:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在 `setup` 方法内部设置初始值：
- en: '[PRE32]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have to update the aspect ratio of `mSceneCamera` inside the `resize` method:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须在 `resize` 方法中更新 `mSceneCamera` 的纵横比：
- en: '[PRE33]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we will implement the `keyDown` method that will switch between two cameras
    by pressing the *1* or *2* keys on the keyboard:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将实现 `keyDown` 方法，通过按键盘上的 *1* 或 *2* 键在两个相机之间切换：
- en: '[PRE34]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Another method we are going to use is `drawGrid`, which looks like this:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要使用的方法是 `drawGrid`，它看起来是这样的：
- en: '[PRE35]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After that, we can implement our main drawing routine, so here is the whole
    `draw` method:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以实现我们的主要绘图程序，所以这里是整个 `draw` 方法：
- en: '[PRE36]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have two cameras; `mSceneCam` is for final rendering and `mMayaCam` is for
    the preview of objects in our scene. You can switch between them by pressing the
    *1* or *2* keys. The default camera is `MayaCam`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个相机；`mSceneCam` 用于最终渲染，`mMayaCam` 用于场景中物体的预览。你可以通过按 *1* 或 *2* 键在它们之间切换。默认相机是
    `MayaCam`。
- en: '![How it works...](img/8703OS_02_11.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/8703OS_02_11.jpg)'
- en: In the previous screenshot, you can see the whole scene set up with the elements,
    such as the origin of the coordinate system, the construction grid that lets you
    keep orientation in 3D space easily, and the `mSceneCam` frustum and vector visualization
    between two points in 3D space. You can navigate through this space using `MayaCamUI`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到整个场景设置，包括坐标系统的原点、帮助你轻松保持 3D 空间方向的构造网格，以及 `mSceneCam` 之间的视锥体和向量可视化。你可以使用
    `MayaCamUI` 在这个空间中导航。
- en: 'If you press the *2* key, you will switch to the view of `mSceneCam`, so you
    will see only your 3D objects without guides as shown in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下 *2* 键，你将切换到 `mSceneCam` 的视图，因此你将只看到你的 3D 对象，没有引导，如下面的截图所示：
- en: '![How it works...](img/8703OS_02_12.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/8703OS_02_12.jpg)'
- en: Communicating with other software
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他软件通信
- en: We will implement an example communication between two Cinder applications written
    in Cinder to illustrate how we can send and receive signals. Each of these two
    applications can be replaced by a non-Cinder application very easily.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现两个 Cinder 应用程序之间的示例通信，以说明我们如何发送和接收信号。这两个应用程序中的每一个都可以很容易地被非 Cinder 应用程序替换。
- en: We are going to use the **Open Sound Control** (**OSC**) messaging format, which
    is dedicated for communication between wide ranges of multimedia devices over
    the network. OSC uses UDP protocol, providing flexibility and performance. Each
    message consists of URL-like addresses and arguments of integer, float, or string
    type. The popularity of OSC makes it a great tool for connecting different environments
    or applications developed with different technologies over the network or even
    on the local machine.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用 **Open Sound Control** (**OSC**) 消息格式，它是为网络中广泛的多媒体设备之间的通信而设计的。OSC 使用
    UDP 协议，提供灵活性和性能。每个消息由类似 URL 的地址和整数、浮点或字符串类型的参数组成。OSC 的流行使其成为连接使用不同技术开发的网络或本地机器上的不同环境或应用程序的绝佳工具。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: While downloading the Cinder package we are also downloading four primary blocks.
    One of them is the `osc` block located in the `blocks` directory. First, we will
    add a new group to our XCode project root and name it `Blocks`, and after that
    we will drag the `osc` folder inside the `Blocks` group. Be sure the **Create
    groups for any added folders** options and **MainApp** in the **Add to targets**
    section are checked.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下载 Cinder 包的同时，我们也在下载四个主要块。其中之一是位于 `blocks` 目录中的 `osc` 块。首先，我们将向我们的 XCode 项目根目录添加一个新的组，并将其命名为
    `Blocks`，然后我们将拖动 `osc` 文件夹到 `Blocks` 组中。确保选中 **Create groups for any added folders**
    选项和 **MainApp** 在 **Add to targets** 部分中。
- en: '![Getting ready](img/8703OS_02_13.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/8703OS_02_13.jpg)'
- en: 'We only need to include an `src` from the `osc` folders, so we will delete
    references to the `lib` and `samples` folders from our project tree. The final
    project structure should look like the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要包含 `osc` 文件夹中的 `src`，因此我们将从我们的项目树中删除对 `lib` 和 `samples` 文件夹的引用。最终的项目结构应该看起来像下面的截图：
- en: '![Getting ready](img/8703OS_02_14.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/8703OS_02_14.jpg)'
- en: 'Now we have to add a path to the `OSC` library file as another linker flag''s
    position in your project''s build settings:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在项目的构建设置中将 `OSC` 库文件的路径添加为另一个链接器标志的位置：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**CINDER_PATH** should be set as a user-defined setting in the build settings
    of your project and it should be the path to Cinder root directory.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**CINDER_PATH** 应该在项目的构建设置中设置为用户定义的设置，并且它应该是 Cinder 根目录的路径。'
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: First we will cover instructions for the *sender*, and then for the *listener*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍关于 *发送者* 的说明，然后是 *监听者*。
- en: Sender
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送者
- en: We will implement an application that sends OSC messages.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个发送 OSC 消息的应用程序。
- en: 'We have to include an additional header file:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须包含一个额外的头文件：
- en: '[PRE38]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After that we can use the `osc::Sender` class, so let''s declare the needed
    properties in the main class:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以使用 `osc::Sender` 类，因此让我们在主类中声明所需的属性：
- en: '[PRE39]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we have to set up our sender inside the `setup` method:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须在 `setup` 方法中设置我们的发送者：
- en: '[PRE40]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Set the default value for `mObjectPosition` to be the center of the window:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `mObjectPosition` 的默认值设置为窗口的中心：
- en: '[PRE41]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can now implement the `mouseDrag` method, which includes two major operations—updating
    the object position according to the mouse position and sending the position information
    via OSC.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以实现 `mouseDrag` 方法，它包括两个主要操作——根据鼠标位置更新对象位置，并通过 OSC 发送位置信息。
- en: '[PRE42]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The last thing we need to do is to draw a method just to visualize the position
    of the object:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后需要做的是绘制一个方法，仅用于可视化对象的位置：
- en: '[PRE43]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Listener
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听者
- en: We will implement an application that receives `OSC` messages.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个接收 `OSC` 消息的应用程序。
- en: 'We have to include an additional header file:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须包含一个额外的头文件：
- en: '[PRE44]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After that we can use the `osc::Listener` class, so let''s declare the required
    properties in the main class:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以使用 `osc::Listener` 类，因此让我们在主类中声明所需的属性：
- en: '[PRE45]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we have to set up our listener object inside the `setup` method, passing
    the port number for listening as a parameter:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须在 `setup` 方法中设置我们的监听者对象，传递监听端口作为参数：
- en: '[PRE46]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And the default value for `mObjectPosition` to be the center of the window:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且将 `mObjectPosition` 的默认值设置为窗口的中心：
- en: '[PRE47]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Inside the `update` method, we will be listening for the incoming `OSC` messages:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `update` 方法内部，我们将监听传入的 `OSC` 消息：
- en: '[PRE48]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Our `draw` method will be almost the same as the sender version, but instead
    of stroked circle we will draw a filled circle:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `draw` 方法将与发送者版本几乎相同，但我们将绘制一个填充的圆圈而不是描边的圆圈：
- en: '[PRE49]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We have implemented the sender application that sends the position of the mouse
    via OSC protocol. Those messages, with the address `/obj/position`, can be received
    by any non-Cinder OSC application implemented in many other frameworks and programming
    languages. The first argument in the message is the x axis position of the mouse
    and the second argument is the y axis position. Both are of the `float` type.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了发送应用程序，该应用程序通过 OSC 协议发送鼠标位置。这些消息，带有地址 `/obj/position`，可以被任何在许多其他框架和编程语言中实现的非
    Cinder OSC 应用程序接收。消息的第一个参数是鼠标的 x 轴位置，第二个参数是 y 轴位置。两者都是 `float` 类型。
- en: '![How it works...](img/8703OS_02_15.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8703OS_02_15.jpg)'
- en: In our case, the application that receives messages is another Cinder application
    that draws a filled circle at exactly the same position where you point it in
    the sender application window.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，接收消息的应用程序是另一个 Cinder 应用程序，它会在你指向发送应用程序窗口中的确切位置绘制一个填充的圆圈。
- en: '![How it works...](img/8703OS_02_16.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8703OS_02_16.jpg)'
- en: There's more...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: That was just a short example of the possibilities that OSC offers. This simple
    communication method can be applied even in very complex projects. OSC works great
    when several devices are working as independent units. But at some point, data
    coming from them is processed; for example, frames coming from the camera can
    be processed by the computer vision software and results sent over the network
    to another machine projecting the visualization. Implementation on top of the
    UDP protocol gives not only performance, because of the fact that transmitting
    data is faster than using TCP, but also implementation is much simpler without
    a connection handshake.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 OSC 提供的可能性的一个简短示例。这种简单的通信方法甚至可以应用于非常复杂的项目。当多个设备作为独立单元工作时，OSC 工作得非常好。但到了某个时候，来自它们的数据需要被处理；例如，来自摄像机的帧可以被计算机视觉软件处理，并将结果通过网络发送到另一台投影可视化的机器。基于
    UDP 协议的实现不仅因为传输数据比使用 TCP 快而提供性能，而且由于不需要连接握手，实现也更为简单。
- en: Broadcast
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广播
- en: 'You can send OSC messages to all the hosts on your network by setting a broadcast
    address as a destination host: `255.255.255.255`. For example, in case of subnets,
    you can use `192.168.1.255` .'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过设置一个广播地址作为目标主机来向您网络上的所有主机发送 OSC 消息：`255.255.255.255`。例如，在子网的情况下，您可以使用 `192.168.1.255`。
- en: Tip
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have problems with compilation under Mac OS X 10.7 because of a linker
    error, try to set **Inline Methods Hidden** to **No** in your project's build
    settings.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 Mac OS X 10.7 下编译时遇到链接错误，请尝试在您的项目构建设置中将 **内联方法隐藏** 设置为 **否**。
- en: See also
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can find more information about OSC implementations by checking out the
    following links.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看以下链接来获取有关 OSC 实现的更多信息。
- en: OSC in Flash
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flash 中的 OSC
- en: 'To support receiving and sending OSC messages in your ActionScript 3.0 code
    you can use the following library: [http://bubblebird.at/tuioflash/](http://bubblebird.at/tuioflash/)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的 ActionScript 3.0 代码中支持接收和发送 OSC 消息，您可以使用以下库：[http://bubblebird.at/tuioflash/](http://bubblebird.at/tuioflash/)
- en: OSC in Processing
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理中的 OSC
- en: 'To support **OSC** protocol in your **Processing** sketch you can use following
    library: [http://www.sojamo.de/libraries/oscP5/](http://www.sojamo.de/libraries/oscP5/)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的 **Processing** 草图中支持 **OSC** 协议，您可以使用以下库：[http://www.sojamo.de/libraries/oscP5/](http://www.sojamo.de/libraries/oscP5/)
- en: OSC in openFrameworks
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: openFrameworks 中的 OSC
- en: 'To support receiving and sending OSC messages in your `openFrameworks` project,
    you can use the `ofxOsc` add-on: [http://ofxaddons.com/repos/112](http://ofxaddons.com/repos/112)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的 `openFrameworks` 项目中支持接收和发送 OSC 消息，您可以使用 `ofxOsc` 扩展程序：[http://ofxaddons.com/repos/112](http://ofxaddons.com/repos/112)
- en: OpenSoundControl Protocol
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenSoundControl 协议
- en: 'You can find more information about OSC protocol and related tools at its official
    site: [http://opensoundcontrol.org/](http://opensoundcontrol.org/).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在其官方网站上找到有关 OSC 协议和相关工具的更多信息：[http://opensoundcontrol.org/](http://opensoundcontrol.org/)。
- en: Preparing your application for iOS
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 iOS 准备应用程序
- en: The big benefit of using Cinder is the resulting multiplatform code. In most
    cases, your application can be compiled on Windows, Mac OS X, and iOS without
    significant modifications.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cinder 的主要好处是生成的多平台代码。在大多数情况下，您的应用程序可以在 Windows、Mac OS X 和 iOS 上编译，而无需进行重大修改。
- en: Getting ready
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you want to run your applications on iOS devices, you will need to register
    as an Apple Developer and purchase the iOS Developer Program.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 iOS 设备上运行应用程序，您需要注册为 Apple 开发者并购买 iOS 开发者计划。
- en: How to do it...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: After registering yourself as an Apple Developer or purchasing the iOS Developer
    Program, you can create an initial XCode project for iOS using Tinderbox.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册为 Apple 开发者或购买 iOS 开发者计划后，您可以使用 Tinderbox 创建一个初始的 XCode iOS 项目。
- en: After running Tinderbox you have to set **Target** to **Cocoa Touch**.![How
    to do it...](img/8703OS_02_18.jpg)
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行 Tinderbox 后，您必须将 **目标** 设置为 **Cocoa Touch**。![如何操作...](img/8703OS_02_18.jpg)
- en: It will generate a project structure for you, supporting iOS events that are
    specific for multitouch screens.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将为您生成一个项目结构，支持针对多点触控屏幕的特定 iOS 事件。
- en: We can use events for multiple touches and for easy access to accelerometer
    data. The main difference between touch and mouse events is that there can be
    more than one active touch points while there is only one mouse cursor. Because
    of that, each touch session has an ID that can be read from `TouchEvent` object.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用事件来处理多个触摸操作，并轻松访问加速度计数据。触摸事件和鼠标事件之间的主要区别在于，在只有一个鼠标光标的情况下，可以有多个活跃的触摸点。正因为如此，每个触摸会话都有一个
    ID，可以从 `TouchEvent` 对象中读取。
- en: '| Method | Describe |'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `touchesBegan( TouchEvent event )` | Beginning of a multitouch sequence |'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `touchesBegan( TouchEvent event )` | 多指触摸序列的开始 |'
- en: '| `touchesMoved( TouchEvent event )` | Drags during a multitouch sequence |'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `touchesMoved( TouchEvent event )` | 在多指触摸序列中拖动 |'
- en: '| `touchesEnded( TouchEvent event )` | The end of a multitouch sequence |'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `touchesEnded( TouchEvent event )` | 多指触摸序列的结束 |'
- en: '| `getActiveTouches()` | Returns all active touches |'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `getActiveTouches()` | 返回所有活动触摸 |'
- en: '| `accelerated( AccelEvent event )` | Vector 3D of the acceleration direction
    |'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `accelerated( AccelEvent event )` | 加速度方向的3D向量 |'
- en: See also
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'I recommend you take a look at the sample projects included in the Cinder package:
    `MultiTouchBasic` and `iPhoneAccelerometer`.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你查看Cinder包中包含的示例项目：`MultiTouchBasic` 和 `iPhoneAccelerometer`。
- en: Apple Developer Center
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 苹果开发者中心
- en: 'You can find more information about the iOS Developer Program here: [https://developer.apple.com/](https://developer.apple.com/)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到有关iOS开发者计划的更多信息：[https://developer.apple.com/](https://developer.apple.com/)
