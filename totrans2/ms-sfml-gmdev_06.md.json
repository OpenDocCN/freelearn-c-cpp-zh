["```cpp\n#version 450 \n\nvoid main() \n{ \n    gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix \n      * gl_Vertex; \n    gl_FrontColor = gl_Color; // Send colour to fragment shader. \n} \n\n```", "```cpp\n#version 450 \n\nvoid main() \n{ \n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); // White pixel. \n} \n\n```", "```cpp\n#version 450 \nuniform float r; \nuniform float g; \nuniform float b; \n\nvoid main() \n{ \n    gl_FragColor = vec4(r, g, b, 1.0); \n} \n\n```", "```cpp\nif(!sf::Shader::isAvailable()){ // Shaders not available! } \n\n```", "```cpp\nsf::Shader shader; // Create a shader instance. \n\n// Loading a single type of shader. \nif (!shader.loadFromFile(\"shader.vert\", sf::Shader::Vertex)) { \n  // Failed loading. \n} \n// OR \nif (!shader.loadFromFile(\"shader.frag\", sf::Shader::Fragment)) { \n  // Failed loading. \n} \n\n// load both shaders \nif (!shader.loadFromFile(\"shader.vert\", \"shader.frag\")) { \n  // Failed loading. \n} \n\n```", "```cpp\nsf::Shader shader; \nconst std::string code = \"...\"; \n// String that contains all shader code. \n\n```", "```cpp\nif (!shader.loadFromMemory(code, sf::Shader::Vertex)) { \n  // Failed loading. \n} \n\n```", "```cpp\nwindow.draw(drawable, &shader); \n\n```", "```cpp\nshader.setUniform(\"r\",  0.5f); \n\n```", "```cpp\nusing ShaderList = std::unordered_map<std::string, \n  std::unique_ptr<sf::Shader>>; \n\n```", "```cpp\nclass Renderer { \npublic: \n  Renderer(Window* l_window, bool l_useShaders = true); \n\n  void AdditiveBlend(bool l_flag); \n  bool UseShader(const std::string& l_name); \n  void DisableShader(); \n  sf::Shader* GetShader(const std::string& l_name); \n\n  void BeginDrawing(); \n  bool IsDrawing()const; \n  void Draw(const sf::Shape& l_shape, \n    sf::RenderTarget* l_target = nullptr); \n  void Draw(const sf::Sprite& l_sprite, \n    sf::RenderTarget* l_target = nullptr); \n  void Draw(const sf::Drawable& l_drawable, \n    sf::RenderTarget* l_target = nullptr); \n  void EndDrawing(); \nprivate: \n  void LoadShaders(); \n\n  Window* m_window; \n  ShaderList m_shaders; \n  sf::Shader* m_currentShader; \n  bool m_addBlend; \n  bool m_drawing; \n  bool m_useShaders; \n  unsigned int m_drawCalls; // For debug purposes. \n}; \n\n```", "```cpp\nRenderer::Renderer(Window* l_window, bool l_useShaders) \n  : m_window(l_window), m_useShaders(l_useShaders), \n     m_drawing(false), m_addBlend(false), m_drawCalls(0), \n  m_currentShader(nullptr) {} \n\n```", "```cpp\nvoid Renderer::LoadShaders() { \n  if(!m_useShaders) { return; } \n  auto directory = Utils::GetWorkingDirectory() +\"media/Shaders/\"; \n  auto v_shaders = Utils::GetFileList(directory, \"*.vert\", false); \n  auto f_shaders = Utils::GetFileList(directory, \"*.frag\", false); \n\n  for (auto& shader : v_shaders) { \n    auto& file = shader.first; \n    auto name = file.substr(0, file.find(\".vert\")); \n    auto fragShader = std::find_if( \n      f_shaders.begin(), f_shaders.end(), \n      [&name](std::pair<std::string, bool>& l_pair) { \n        return l_pair.first == name + \".frag\"; \n      } \n    ); \n\n    auto shaderItr = m_shaders.emplace(name, \n      std::move(std::make_unique<sf::Shader>())); \n    auto& shader = shaderItr.first->second; \n    if (fragShader != f_shaders.end()) { \n      shader->loadFromFile(directory + name + \".vert\", \n        directory + name + \".frag\"); \n      f_shaders.erase(fragShader); \n    } else { \n      shader->loadFromFile(directory + name + \".vert\", \n        sf::Shader::Vertex); \n    } \n  } \n\n  for (auto& shader : f_shaders) { \n    auto& file = shader.first; \n    auto name = file.substr(0, file.find(\".frag\")); \n    auto shaderItr = m_shaders.emplace(name, \n      std::move(std::make_unique<sf::Shader>())); \n    auto& shader = shaderItr.first->second; \n    shader->loadFromFile(directory + name + \".frag\", \n      sf::Shader::Fragment); \n  } \n} \n\n```", "```cpp\nsf::Shader* Renderer::GetShader(const std::string& l_name) { \n  if(!m_useShaders) { return nullptr;  } \n  auto shader = m_shaders.find(l_name); \n  if (shader == m_shaders.end()) { return nullptr; } \n  return shader->second.get(); \n} \n\n```", "```cpp\nbool Renderer::UseShader(const std::string& l_name) { \n  if(!m_useShaders) { return false; } \n  m_currentShader = GetShader(l_name); \n  return (m_currentShader != nullptr); \n} \n\n```", "```cpp\nvoid Renderer::Draw(const sf::Shape& l_shape, \n  sf::RenderTarget* l_target) \n{ \n  if (!l_target) { \n    if (!m_window->GetViewSpace().intersects( \n      l_shape.getGlobalBounds())) \n    { return; } \n  } \n  Draw((const sf::Drawable&)l_shape, l_target); \n} \n\nvoid Renderer::Draw(const sf::Sprite& l_sprite, \n  sf::RenderTarget* l_target) \n{ \n  if (!l_target) { \n    if (!m_window->GetViewSpace().intersects( \n      l_sprite.getGlobalBounds())) \n    { return; } \n  } \n  Draw((const sf::Drawable&)l_sprite, l_target); \n} \n\n```", "```cpp\nvoid Renderer::Draw(const sf::Drawable& l_drawable, \n  sf::RenderTarget* l_target) \n{ \n  if (!l_target) { l_target = m_window->GetRenderWindow(); } \n  l_target->draw(l_drawable, \n    (m_addBlend ? sf::BlendAdd : m_currentShader && m_useShaders ? \n      m_currentShader : sf::RenderStates::Default)); \n  ++m_drawCalls; \n} \n\n```", "```cpp\nvoid Renderer::AdditiveBlend(bool l_flag) { m_addBlend = l_flag; } \nvoid Renderer::DisableShader() { m_currentShader = nullptr; } \nvoid Renderer::BeginDrawing(){ m_drawing = true; m_drawCalls = 0;} \nbool Renderer::IsDrawing() const { return m_drawing; } \nvoid Renderer::EndDrawing() { m_drawing = false; } \n\n```", "```cpp\nclass Window{ \npublic: \n  ... \n  Renderer* GetRenderer(); \n  ... \nprivate: \n  ... \n  Renderer m_renderer; \n}; \n\n```", "```cpp\nWindow::Window(...) : m_renderer(this, l_useShaders) { ... } \n\n```", "```cpp\nvoid Window::BeginDraw() { \n  m_window.clear(sf::Color::Black); \n  m_renderer.BeginDrawing(); \n} \nvoid Window::EndDraw() { \n  m_window.display(); \n  m_renderer.EndDrawing(); \n} \n\n```", "```cpp\nvoid Window::Create() { \n  ... \n  sf::ContextSettings settings; \n  settings.depthBits = 24; \n  settings.stencilBits = 8; \n  settings.antialiasingLevel = 0; \n  settings.majorVersion = 4;\n  settings.minorVersion = 5;\n  m_window.create(sf::VideoMode(m_windowSize.x, m_windowSize.y, \n    32), m_windowTitle, style, settings); \n  if (!m_shadersLoaded) { \n    m_renderer.LoadShaders(); \n    m_shadersLoaded = true; \n  } \n} \n\n```", "```cpp\nclass ParticleSystem : ... { \npublic: \n  ... \n  void Draw(Window* l_window, int l_elevation); \n}; \n\nclass S_Renderer : ... { \npublic: \n  ... \n  void Render(Window* l_wind, unsigned int l_layer); \n}; \n\nclass SpriteSheet{ \npublic: \n  ... \n  void Draw(Window* l_wnd); \n}; \n\n```", "```cpp\nvoid ParticleSystem::Draw(Window* l_window, int l_elevation) { \n  ... \n  auto state = m_stateManager->GetCurrentStateType(); \n  if (state == StateType::Game || state == StateType::MapEditor) { \n    renderer->UseShader(\"default\"); \n  } else { \n    renderer->DisableShader(); \n  } \n\n  for (size_t i = 0; i < container->m_countAlive; ++i) { \n    ... \n    renderer->AdditiveBlend(blendModes[i]); \n    renderer->Draw(drawables[i]); \n  } \n  renderer->AdditiveBlend(false); \n} \n\n```", "```cpp\nvoid S_Renderer::Render(Window* l_wind, unsigned int l_layer) \n{ \n  EntityManager* entities = m_systemManager->GetEntityManager(); \n  l_wind->GetRenderer()->UseShader(\"default\"); \n  for(auto &entity : m_entities) { \n    ... \n    drawable->Draw(l_wind); \n  } \n} \n\nvoid SpriteSheet::Draw(Window* l_wnd) { \n  l_wnd->GetRenderer()->Draw(m_sprite); \n} \n\n```", "```cpp\nvoid Map::Draw(unsigned int l_layer) { \n  if (l_layer >= Sheet::Num_Layers) { return; } \n  ... \n  m_window->GetRenderer()->UseShader(\"default\"); \n  m_window->GetRenderer()->Draw(m_layerSprite); \n} \n\n```", "```cpp\nclass Map : ... { \n  ... \nprotected: \n  ... \n  float m_gameTime; \n  float m_dayLength; \n}; \n\n```", "```cpp\nvoid Map::Update(float l_dT) { \n  m_gameTime += l_dT; \n  if (m_gameTime > m_dayLength * 2) { m_gameTime = 0.f; } \n  float timeNormal = m_gameTime / m_dayLength; \n  if(timeNormal > 1.f){ timeNormal = 2.f - timeNormal; } \n   m_window->GetRenderer()->GetShader(\"default\")-> \n    setUniform(\"timeNormal\", timeNormal); \n} \n\n```", "```cpp\nMap::Map(...) : ..., m_gameTime(0.f), m_dayLength(30.f) \n{ ... } \n\n```", "```cpp\n#version 450 \nvoid main() \n{ \n  // transform the vertex position \n  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; \n\n  // transform the texture coordinates \n  gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0; \n\n  // forward the vertex color \n  gl_FrontColor = gl_Color; \n} \n\n```", "```cpp\n#version 450 \nuniform sampler2D texture; \nuniform float timeNormal; \n\nvoid main() \n{ \n  // lookup the pixel in the texture \n  vec4 pixel = texture2D(texture, gl_TexCoord[0].xy); \n  if(pixel == vec4(0.0, 0.0, 0.0, 1.0)) \n    pixel = vec4(1.0, 1.0, 1.0, 1.0); \n\n  // multiply it by the color \n  gl_FragColor = gl_Color * pixel; \n  gl_FragColor[0] -= timeNormal; \n  gl_FragColor[1] -= timeNormal; \n  gl_FragColor[2] -= timeNormal; \n  gl_FragColor[2] += 0.2; \n} \n\n```"]