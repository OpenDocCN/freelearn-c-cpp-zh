<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Compile-time Tricks</h1></div></div></div><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Checking sizes at compile time</li><li class="listitem" style="list-style-type: disc">Enabling the usage of templated functions for integral types</li><li class="listitem" style="list-style-type: disc">Disabling templated functions' usage for real types</li><li class="listitem" style="list-style-type: disc">Creating a type from number</li><li class="listitem" style="list-style-type: disc">Implementing a type trait</li><li class="listitem" style="list-style-type: disc">Selecting an optimal operator for a template parameter</li><li class="listitem" style="list-style-type: disc">Getting a type of expression in C++03</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Introduction</h1></div></div></div><p>In this chapter we'll see some basic examples on how the Boost libraries can be used in compile-time checking, for tuning algorithms, and in other metaprogramming tasks.</p><p>Some readers may ask, "Why shall we care about compile-time things?". That's because the released version of the program is compiled once, and runs multiple times. The more we do at compile time, the less work remains for runtime, resulting in much faster and reliable programs. <a id="id222" class="indexterm"/>Runtime checks are executed only if a part of the code with check is executed. Compile-time <a id="id223" class="indexterm"/>checks won't give you to compile a program with error.</p><p>This chapter is possibly one of the most important. Understanding Boost sources and other Boost-like libraries is impossible without it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Checking sizes at compile time</h1></div></div></div><p>Let's imagine that we are <a id="id224" class="indexterm"/>writing some serialization function that stores values in buffer of a specified size:</p><div><pre class="programlisting">#include &lt;cstring&gt;
#include &lt;boost/array.hpp&gt;

template &lt;class T, std::size_t BufSizeV&gt;
void serialize(const T&amp; value, boost::array&lt;unsigned char, BufSizeV&gt;&amp; buffer) {
    // TODO: fixme
    std::memcpy(&amp;buffer[0], &amp;value, sizeof(value));
}</pre></div><p>This code has the following troubles:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The size of the buffer is not checked, so it may overflow</li><li class="listitem" style="list-style-type: disc">This function can be used with <a id="id225" class="indexterm"/>non-plain old data (POD) types, which would lead to incorrect behavior</li></ul></div><p>We may partially fix it by adding some asserts, for example:</p><div><pre class="programlisting">template &lt;class T, std::size_t BufSizeV&gt;
void serialize(const T&amp; value, boost::array&lt;unsigned char, BufSizeV&gt;&amp; buffer) {
    assert(BufSizeV &gt;= sizeof(value));
    // TODO: fixme
    std::memcpy(&amp;buffer[0], &amp;value, sizeof(value));
}</pre></div><p>But, this is a bad solution. The <a id="id226" class="indexterm"/>
<code class="literal">BufSizeV</code> and <a id="id227" class="indexterm"/>
<code class="literal">sizeof(value)</code> values are known at compile time, so we can potentially <a id="id228" class="indexterm"/>make this code to fail compilation if the buffer is too small, instead of having a runtime assert (which may not trigger during debug, if function was not called, and may even be optimized out in release mode, so very bad things may happen).</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec149"/>Getting ready</h2></div></div></div><p>This recipe requires some knowledge of C++ templates and the <code class="literal">Boost.Array</code> library.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec150"/>How to do it...</h2></div></div></div><p>Let's use the <code class="literal">Boost.StaticAssert</code> and <code class="literal">Boost.TypeTraits</code> libraries to correct the solutions, and the output will be as follows:</p><div><pre class="programlisting">#include &lt;boost/static_assert.hpp&gt;
#include &lt;boost/type_traits/is_pod.hpp&gt;

template &lt;class T, std::size_t BufSizeV&gt;
void serialize(const T&amp; value, boost::array&lt;unsigned char, BufSizeV&gt;&amp; buffer) {
    BOOST_STATIC_ASSERT(BufSizeV &gt;= sizeof(value));
    BOOST_STATIC_ASSERT(boost::is_pod&lt;T&gt;::value);
    std::memcpy(&amp;buffer[0], &amp;value, sizeof(value));
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec151"/>How it works...</h2></div></div></div><p>The <code class="literal">BOOST_STATIC_ASSERT</code> macro <a id="id229" class="indexterm"/>can be used only if an assert expression can be evaluated at compile time and implicitly convertible to <code class="literal">bool</code>. It means that you may only use <code class="literal">sizeof()</code>, static constants, and other constant expressions in it. If assert expression will evaluate to <code class="literal">false</code>, <code class="literal">BOOST_STATIC_ASSERT</code> will stop our program compilation. In case of <code class="literal">serialization()</code> function, if <a id="id230" class="indexterm"/>first static assertion fails, it means that someone used that function for a very small buffer and that code must be fixed by the programmer. The C++11 standard has a <code class="literal">static_assert</code> keyword that is equivalent to Boost's version.</p><p>Here are some more examples:</p><div><pre class="programlisting">BOOST_STATIC_ASSERT(3 &gt;= 1);

struct some_struct { enum enum_t { value = 1}; };
BOOST_STATIC_ASSERT(some_struct::value);

template &lt;class T1, class T2&gt;
struct some_templated_struct {
    enum enum_t { value = (sizeof(T1) == sizeof(T2))};
};
BOOST_STATIC_ASSERT((some_templated_struct&lt;int, unsigned int&gt;::value));</pre></div><div><div><h3 class="title"><a id="note08"/>Note</h3><p>If the <code class="literal">BOOST_STATIC_ASSERT</code> macro's assert expression has a comma sign in it, we must wrap the whole expression in additional brackets.</p></div></div><p>The last example is very close to what we can see on the second line of the <code class="literal">serialize()</code> function. So now it is time to know more about the <code class="literal">Boost.TypeTraits</code> library. This library provides a large number of <a id="id231" class="indexterm"/>compile-time metafunctions that allow us to get information about types and modify types. The metafunctions usages look like <code class="literal">boost::function_name&lt;parameters&gt;::value</code> or <code class="literal">boost::function_name&lt;parameters&gt;::type</code>. The metafunction <code class="literal">boost::is_pod&lt;T&gt;::value</code> will return <code class="literal">true</code>, only if <code class="literal">T</code> is a POD type.</p><p>Let's take a look at some more examples:</p><div><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;boost/type_traits/is_unsigned.hpp&gt;
#include &lt;boost/type_traits/is_same.hpp&gt;
#include &lt;boost/type_traits/remove_const.hpp&gt;

template &lt;class T1, class T2&gt;
void type_traits_examples(T1&amp; /*v1*/, T2&amp; /*v2*/) {
    // Returns true if T1 is an unsigned number
    std::cout &lt;&lt; boost::is_unsigned&lt;T1&gt;::value;

    // Returns true if T1 has exactly the same type, as T2
    std::cout &lt;&lt; boost::is_same&lt;T1, T2&gt;::value;

    // This line removes const modifier from type of T1.
    // Here is what will happen with T1 type if T1 is:
    // const int =&gt; int
    // int =&gt; int
    // int const volatile =&gt; int volatile
    // const int&amp; =&gt; const int&amp;
    typedef typename boost::remove_const&lt;T1&gt;::type t1_nonconst_t;
}</pre></div><div><div><h3 class="title"><a id="note09"/>Note</h3><p>Some compilers may compile this code even without the <code class="literal">typename</code> keyword, but such behavior violates the C++ standard, so it is highly recommended to write <code class="literal">typename</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec152"/>There's more...</h2></div></div></div><p>The <code class="literal">BOOST_STATIC_ASSSERT</code> macro <a id="id232" class="indexterm"/>has a more verbose variant called <a id="id233" class="indexterm"/>
<code class="literal">BOOST_STATIC_ASSSERT_MSG</code> that will output an error message in the compiler log (or in the IDE window) if assertion fails. <a id="id234" class="indexterm"/>Take a look at the following code:</p><div><pre class="programlisting">template &lt;class T, std::size_t BufSizeV&gt;
void serialize2(const T&amp; value, boost::array&lt;unsigned char, BufSizeV&gt;&amp; buf) {
    BOOST_STATIC_ASSERT_MSG(boost::is_pod&lt;T&gt;::value,
        "This serialize2 function may be used only "
        "with POD types."
    );

    BOOST_STATIC_ASSERT_MSG(BufSizeV &gt;= sizeof(value),
        "Can not fit value to buffer. "
        "Make buffer bigger."
    );

    std::memcpy(&amp;buf[0], &amp;value, sizeof(value));
}

    // Somewhere in code:
    boost::array&lt;unsigned char, 1&gt; buf;
    serialize2(std::string("Hello word"), buf);</pre></div><p>The preceding code will give the following result during compilation on the g++ compiler in the C++11 mode:</p><div><pre class="programlisting">../../../BoostBook/Chapter4/static_assert/main.cpp: In instantiation of 'void serialize2(const T&amp;, boost::array&lt;unsigned char, BufSizeV&gt;&amp;) [with T = std::basic_string&lt;char&gt;; long unsigned int BufSizeV = 1ul]':
../../../BoostBook/Chapter4/static_assert/main.cpp:77:46: required from here
../../../BoostBook/Chapter4/static_assert/main.cpp:58:5: error: static assertion failed: This serialize2 function may be used only with POD types.
../../../BoostBook/Chapter4/static_assert/main.cpp:63:5: error: static assertion failed: Can not fit value to buffer. Make buffer bigger.</pre></div><p>Neither <code class="literal">BOOST_STATIC_ASSSERT</code>, nor <code class="literal">BOOST_STATIC_ASSSERT_MSG</code>, nor any of the type traits library imply runtime penalty. All those functions are executed at compile time, and won't add a single assembly instruction in binary file.</p><p>The <code class="literal">Boost.TypeTraits</code> library was partially accepted into the C++11 standard; you may thus find traits in the <code class="literal">&lt;type_traits&gt;</code> header in the <code class="literal">std::</code> namespace. C++11 <code class="literal">&lt;type_traits&gt;</code> has some functions that do not exist in <code class="literal">Boost.TypeTraits</code>, but some metafunctions exist only in Boost. When there is a similar function in Boost and STL, the STL version (in rare cases) may work slightly better because of compiler-specific intrinsics usage.</p><p>As we have already mentioned earlier, the <a id="id235" class="indexterm"/>
<code class="literal">BOOST_STATIC_ASSERT_MSG</code> macro was also accepted into C++11 (and even into C11) as the keyword <code class="literal">static_assert(expression, message)</code>.</p><p>Use the Boost version of those <a id="id236" class="indexterm"/>libraries if you need portability across compilers or metafunctions that does not exist in STLs <code class="literal">&lt;type_traits&gt;</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec153"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The next recipes in this chapter will give you more examples and ideas on how static asserts and type traits may be used</li><li class="listitem" style="list-style-type: disc">Read the official documentation of <code class="literal">Boost.StaticAssert</code> for more examples at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/boost_sta">http://www.boost.org/doc/libs/1_53_0/doc/html/boost_sta</a><a class="ulink" href="http://ticassert.html">ticassert.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Enabling the usage of templated functions for integral types</h1></div></div></div><p>It's a common situation, <a id="id237" class="indexterm"/>when we have a templated class that implements some functionality. Have a look at the following code snippet:</p><div><pre class="programlisting">// Generic implementation
template &lt;class T&gt;
class data_processor {
    double process(const T&amp; v1, const T&amp; v2, const T&amp; v3);
};</pre></div><p>After execution of the preceding code, we have additional two optimized versions of that class, one for integral, and another for real types:</p><div><pre class="programlisting">// Integral types optimized version
template &lt;class T&gt;
class data_processor {
    typedef int fast_int_t;
    double process(fast_int_t v1, fast_int_t v2, fast_int_t v3);
};

// SSE optimized version for float types
template &lt;class T&gt;
class data_processor {
    double process(double v1, double v2, double v3);
};</pre></div><p>Now the question, how to make the compiler to automatically choose the correct class for a specified type, arises.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec154"/>Getting ready</h2></div></div></div><p>This recipe requires the knowledge of C++ templates.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec155"/>How to do it...</h2></div></div></div><p>We'll be using <code class="literal">Boost.Utility</code> and <code class="literal">Boost.TypeTraits</code> to resolve this problem:</p><div><ol class="orderedlist arabic"><li class="listitem">Let's start with including headers:<div><pre class="programlisting">#include &lt;boost/utility/enable_if.hpp&gt;
#include &lt;boost/type_traits/is_integral.hpp&gt;
#include &lt;boost/type_traits/is_float.hpp&gt;</pre></div></li><li class="listitem">Let's add an additional template parameter with default value to our generic implementation:<div><pre class="programlisting">// Generic implementation
template &lt;class T, class Enable = void&gt;
class data_processor {
    // ...
};</pre></div></li><li class="listitem">Modify optimized versions in the following way, so that now they will be treated by the compiler as template partial specializations:<div><pre class="programlisting">// Integral types optimized version
template &lt;class T&gt;
class data_processor&lt;T, typename boost::enable_if_c&lt;
    boost::is_integral&lt;T&gt;::value 
&gt;::type&gt; { /* ... */ };

// SSE optimized version for float types
template &lt;class T&gt;
class data_processor&lt;T, typename boost::enable_if_c&lt;
    boost::is_float&lt;T&gt;::value 
&gt;::type&gt; { /* ... */ };</pre></div></li><li class="listitem">And, that's it! Now the <a id="id238" class="indexterm"/>compiler will automatically choose the correct class:<div><pre class="programlisting">template &lt;class T&gt;
double example_func(T v1, T v2, T v3) {
    data_processor&lt;T&gt; proc;
    return proc.process(v1, v2, v3);
}

int main () {
    // Integral types optimized version
    // will be called
    example_func(1, 2, 3);
    short s = 0;
    example_func(s, s, s);

    // Real types version will be called
    example_func(1.0, 2.0, 3.0);
    example_func(1.0f, 2.0f, 3.0f);

    // Generic version will be called
    example_func("Hello", "word", "processing");
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec156"/>How it works...</h2></div></div></div><p>The <code class="literal">boost::enable_if_c</code> <a id="id239" class="indexterm"/>template is a tricky <a id="id240" class="indexterm"/>one. It makes use of the <strong>SFINAE</strong> (<strong>Substitution Failure Is Not An Error</strong>) principle, which is used during template instantiation. Here is how the principle works: if an invalid argument or return type is formed during the instantiation of a function or class template, the instantiation is removed from the overload resolution set and does not cause a compilation error. Now let's get back to the solution, and we'll see how it works with different types passed to the <code class="literal">data_processor</code> class as the <code class="literal">T</code> parameter.</p><p>If we pass an <code class="literal">int</code> as <code class="literal">T</code> type, first the compiler will try to instantiate template partial specializations, before using our nonspecialized (generic) version. When it tries to instantiate a <code class="literal">float</code> version, the <a id="id241" class="indexterm"/>
<code class="literal">boost::is_float&lt;T&gt;::value</code> metafunction will return <code class="literal">false</code>. The <a id="id242" class="indexterm"/>
<code class="literal">boost::enable_if_c&lt;false&gt;::type</code> metafunction cannot be correctly instantiated (because <code class="literal">boost::enable_if_c&lt;false&gt;</code> has no <code class="literal">::type</code>), and that is the place where SFINAE will act. Because class template cannot be instantiated, and this must be interpreted as not an error, <a id="id243" class="indexterm"/>compiler will skip this template specialization. Next, partial specialization is the one that is optimized for integral types. The <code class="literal">boost::is_integral&lt;T&gt;::value</code> metafunction will return <code class="literal">true</code>, and <code class="literal">boost::enable_if_c&lt;true&gt;::type</code> can be instantiated, which makes it possible to instantiate the whole <code class="literal">data_processor</code> specialization. The compiler found a matching partial specialization, so it does not need to try to instantiate the nonspecialized method.</p><p>Now, let's try to pass some nonarithmetic type (for example, <code class="literal">const char *</code>), and let's see what the compiler will do. First the compiler will try to instantiate template partial specializations. The specializations with <code class="literal">is_float&lt;T&gt;::value</code> and <code class="literal">is_integral&lt;T&gt;::value</code> will fail to instantiate, so the compiler will try to instantiate our generic version, and will succeed.</p><p>Without <code class="literal">boost::enable_if_c&lt;&gt;</code>, all the partial specialized versions may be instantiated at the same time for any type, which leads to ambiguity and failed compilation.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>If you are using templates and compiler reports that cannot choose between two template classes of methods, you probably need <code class="literal">boost::enable_if_c&lt;&gt;</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec157"/>There's more...</h2></div></div></div><p>Another version of this method is called <a id="id244" class="indexterm"/>
<code class="literal">boost::enable_if</code> (without <code class="literal">_c</code> at the end). Difference between them is that <code class="literal">enable_if_c</code> accepts constant as a template parameter; however, the short version accepts an object that has a <code class="literal">value</code> static member. For example, <code class="literal">boost::enable_if_c&lt;boost::is_integral&lt;T&gt;::value &gt;::type</code> is equal to <code class="literal">boost::enable_if&lt;boost::is_integral&lt;T&gt; &gt;::type&gt;</code>.</p><p>C++11 has an <code class="literal">std::enable_if</code> defined in the <code class="literal">&lt;type_traits&gt;</code> header, which behaves exactly like <code class="literal">boost::enable_if_c</code>. No difference between them exists, except that Boost's version will work on non C++11 compilers too, providing better portability.</p><p>All the enabling functions are executed only at compile time and do not add a performance overhead at runtime. However, adding an additional template parameter may produce a bigger class name in <code class="literal">typeid(T).name()</code>, and add an extremely tiny performance overhead when comparing <a id="id245" class="indexterm"/>two <code class="literal">typeid()</code> results on some platforms.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec158"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Next recipes will give you more examples on <code class="literal">enable_if</code> usage.</li><li class="listitem" style="list-style-type: disc">You may also consult the official documentation of <code class="literal">Boost.Utility</code>. It contains many examples and a lot of useful classes (which are used widely in this book). Read about it at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm">http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm</a>.</li><li class="listitem" style="list-style-type: disc">You may also read some articles about template partial specializations at <a class="ulink" href="http://msdn.microsoft.com/en-us/library/3967w96f%28v=vs.110%29.aspx">http://msdn.microsoft.com/en-us/library/3967w96f%28v=vs.110%29.aspx</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Disabling templated functions' usage for real types</h1></div></div></div><p>We  continue working <a id="id246" class="indexterm"/>with Boost metaprogramming libraries. In the previous recipe, we saw how to use <code class="literal">enable_if_c</code> with classes, now it is time to take a look at its usage in template functions. Consider the following example.</p><p>Initially, we had a template function that works with all the available types:</p><div><pre class="programlisting">template &lt;class T&gt;
T process_data(const T&amp; v1, const T&amp; v2, const T&amp; v3);</pre></div><p>Now that we write code using <code class="literal">process_data</code> function, we use an optimized <code class="literal">process_data</code> version for types that do have an <code class="literal">operator += </code> function:</p><div><pre class="programlisting">template &lt;class T&gt;
T process_data_plus_assign(const T&amp; v1, const T&amp; v2, const T&amp; v3);</pre></div><p>But, we do not want to change the already written code; instead whenever it is possible, we want to force the compiler to automatically use optimized function in place of the default one.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec159"/>Getting ready</h2></div></div></div><p>Read the previous recipe to get an idea of what <code class="literal">boost::enable_if_c</code> does, and for understanding the concept of SFINAE. However, the knowledge of templates is still required.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec160"/>How to do it...</h2></div></div></div><p>Template magic can be done using the Boost libraries. Let's see how to do it:</p><div><ol class="orderedlist arabic"><li class="listitem">We will need the <code class="literal">boost::has_plus_assign&lt;T&gt;</code> metafunction and the <code class="literal">&lt;boost/enable_if.hpp&gt;</code> header:<div><pre class="programlisting">#include &lt;boost/utility/enable_if.hpp&gt;
#include &lt;boost/type_traits/has_plus_assign.hpp&gt;</pre></div></li><li class="listitem">Now we will disable default implementation for types with plus assign operator:<div><pre class="programlisting">// Modified generic version of process_data
template &lt;class T&gt;
typename boost::disable_if_c&lt;boost::has_plus_assign&lt;T&gt;::value,T&gt;::type
    process_data(const T&amp; v1, const T&amp; v2, const T&amp; v3);</pre></div></li><li class="listitem">Enable optimized version for <a id="id247" class="indexterm"/>types with plus assign operator:<div><pre class="programlisting">// This process_data will call a process_data_plus_assign
template &lt;class T&gt;
typename boost::enable_if_c&lt;boost::has_plus_assign&lt;T&gt;::value, T&gt;::type
    process_data(const T&amp; v1, const T&amp; v2, const T&amp; v3)
{
    return process_data_plus_assign(v1, v2, v3);
}</pre></div></li><li class="listitem">Now, users won't feel the difference, but the optimized version will be used wherever possible:<div><pre class="programlisting">int main() {
    int i = 1;
    // Optimized version
    process_data(i, i, i);

    // Default version
    // Explicitly specifing template parameter
    process_data&lt;const char*&gt;("Testing", "example", "function");
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec161"/>How it works...</h2></div></div></div><p>The <code class="literal">boost::disable_if_c&lt;bool_value&gt;::type</code> metafunction disables method, if <code class="literal">bool_value</code> equals to <code class="literal">true</code> (works just like <code class="literal">boost::enable_if_c&lt;!bool_value&gt;::type</code>).</p><p>If we pass a class as the second parameter for <code class="literal">boost::enable_if_c</code> or <code class="literal">boost::disable_if_c</code>, it will be returned via <code class="literal">::type</code> in case of successful evaluation.</p><p>Let's go through the instantiation of templates step-by-step. If we pass <code class="literal">int</code> as <code class="literal">T</code> type, first the compiler will search for function overload with required signature. Because there is no such function, the next step will be to instantiate a template version of this function. For example, the compiler started from our second (optimized) version; in that case, it will successfully evaluate the <code class="literal">typename boost::enable_if_c&lt;boost::has_plus_assign&lt;T&gt;::value, T&gt;::type</code> expression, and will get the <code class="literal">T</code> return type. But, the compiler won't stop; it will continue instantiation attempts. It'll try to <a id="id248" class="indexterm"/>instantiate our first version of function, but will get a failure during evaluation of <code class="literal">typename boost::disable_if_c&lt;boost::has_plus_assign&lt;T&gt;::value</code>. This failure won't be treated as an error (refer SFINAE). As you can see, without <code class="literal">enable_if_c</code> and <code class="literal">disable_if_c</code>, there will be ambiguity.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec162"/>There's more...</h2></div></div></div><p>As in case of <code class="literal">enable_if_c</code> and <code class="literal">enable_if</code>, there is a <code class="literal">disable_if</code> version of the disabling function:</p><div><pre class="programlisting">// First version
template &lt;class T&gt;
typename boost::disable_if&lt;boost::has_plus_assign&lt;T&gt;, T&gt;::type
process_data2(const T&amp; v1, const T&amp; v2, const T&amp; v3);

// process_data_plus_assign
template &lt;class T&gt;
typename boost::enable_if&lt;boost::has_plus_assign&lt;T&gt;, T&gt;::type
process_data2(const T&amp; v1, const T&amp; v2, const T&amp; v3);</pre></div><p>C++11 has neither <code class="literal">disable_if_c</code>, nor <code class="literal">disable_if</code> (you may use <code class="literal">std::enable_if&lt;!bool_value&gt;::type</code> instead).</p><p>As it was mentioned in the previous recipe, all the enabling and disabling functions are executed only at compile time, and do not add performance overhead at runtime.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec163"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Read this chapter from the beginning to get more examples of compile-time tricks.</li><li class="listitem" style="list-style-type: disc">Consider reading the <a id="id249" class="indexterm"/><code class="literal">Boost.TypeTraits</code> official documentation for more examples and full list of metafunctions at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Boost.Utility</code> library may provide you more examples of <code class="literal">boost::enable_if</code> usage. Read about it at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm">http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Creating a type from number</h1></div></div></div><p>We have now seen examples <a id="id250" class="indexterm"/>of how we can choose between functions without <code class="literal">boost::enable_if_c</code> usage. Let's consider the following example, where we have a generic method for processing POD datatypes:</p><div><pre class="programlisting">#include &lt;boost/static_assert.hpp&gt;
#include &lt;boost/type_traits/is_pod.hpp&gt;

// Generic implementation
template &lt;class T&gt;
T process(const T&amp; val) {
    BOOST_STATIC_ASSERT((boost::is_pod&lt;T&gt;::value));
    // ...
}</pre></div><p>And, we have the same function optimized for sizes 1, 4, and 8 bytes. How do we rewrite process function, so that it can dispatch calls to optimized versions?</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec164"/>Getting ready</h2></div></div></div><p>Reading at least the first recipe from this chapter is highly recommended, so that you will not be confused by all the things that are happening here. Templates and metaprogramming shall not scare you (or just get ready to see a lot of them).</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec165"/>How to do it...</h2></div></div></div><p>We are going to see how the size of a template type can be converted to a variable of some type, and how that variable can be used for deducing the right function overload.</p><div><ol class="orderedlist arabic"><li class="listitem">Let's define our generic and optimized versions of <code class="literal">process_impl</code> function:<div><pre class="programlisting">#include &lt;boost/mpl/int.hpp&gt;

namespace detail {
    // Generic implementation
    template &lt;class T, class Tag&gt;
    T process_impl(const T&amp; val, Tag /*ignore*/) {
        // ...
    }

    // 1 byte optimized implementation
    template &lt;class T&gt;
    T process_impl(const T&amp; val, boost::mpl::int_&lt;1&gt; /*ignore*/) {
        // ...
    }

    // 4 bytes optimized implementation
    template &lt;class T&gt;
    T process_impl(const T&amp; val, boost::mpl::int_&lt;4&gt; /*ignore*/) {
        // ...
    }

    // 8 bytes optimized implementation
    template &lt;class T&gt;
    T process_impl(const T&amp; val, boost::mpl::int_&lt;8&gt; /*ignore*/) {
        // ...
    }
} // namespace detail</pre></div></li><li class="listitem">Now we are ready to <a id="id251" class="indexterm"/>write process function:<div><pre class="programlisting">// will be only dispatching calls
template &lt;class T&gt;
T process(const T&amp; val) {
    BOOST_STATIC_ASSERT((boost::is_pod&lt;T&gt;::value));
    return detail::process_impl(
        val, boost::mpl::int_&lt;sizeof(T)&gt;());
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec166"/>How it works...</h2></div></div></div><p>The most interesting part here is <code class="literal">boost::mpl::int_&lt;sizeof(T)&gt;(). sizeof(T)</code> executes at compile time, so its <a id="id252" class="indexterm"/>output can be used as a template parameter. The class <code class="literal">boost::mpl::int_&lt;&gt;</code> is just an empty class that holds a compile-time value of integral type (in the <code class="literal">Boost.MPL</code> library, such classes are called Integral Constants). It can be implemented as shown in the following code:</p><div><pre class="programlisting">template &lt;int Value&gt;
struct int_ {
    static const int value = Value;
    typedef int_&lt;Value&gt; type;
    typedef int value_type;
};</pre></div><p>We need an instance of this class, that is why we have a round parentheses at the end of <code class="literal">boost::mpl::int_&lt;sizeof(T)&gt;()</code>.</p><p>Now, let's take a closer look at how the compiler will decide which <code class="literal">process_impl</code> function to use. First of all, the compiler will try to match functions that have a second parameter and not a template. If <code class="literal">sizeof(T)</code> is 4, the compiler will try to search the function with signatures like <code class="literal">process_impl(T, boost::mpl::int_&lt;8&gt;)</code>, and will find our 4 bytes optimized version from the <code class="literal">detail</code> namespace. If <code class="literal">sizeof(T)</code> is 34, compiler won't find the function with signature like <code class="literal">process_impl(T, boost::mpl::int_&lt;34&gt;)</code>,and will use a templated variant <code class="literal">process_impl(const T&amp; val, Tag /*ignore*/)</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec167"/>There's more...</h2></div></div></div><p>The <code class="literal">Boost.MPL</code> library has several <a id="id253" class="indexterm"/>data structures for metaprogramming. In this recipe, we only scratched a top of the iceberg. You may find the following Integral Constant classes from MPL useful:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">bool_</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">int_</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">long_</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">size_t</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">char_</code></li></ul></div><p>All the <code class="literal">Boost.MPL</code> functions <a id="id254" class="indexterm"/>(except the <code class="literal">for_each</code> runtime function) are executed at compile time and won't add runtime overhead. The <code class="literal">Boost.MPL</code> library is not a part of C++11, but many STL libraries implement functions from it for their own needs.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec168"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The recipes from <a class="link" href="ch08.html" title="Chapter 8. Metaprogramming">Chapter 8</a>, <em>Metaprogramming</em>, will give you more examples of the <code class="literal">Boost.MPL</code> library usage. If you feel confident, you may also try to read its documentation at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html">http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html</a>.</li><li class="listitem" style="list-style-type: disc">Read more examples of tags <a id="id255" class="indexterm"/>usage at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/boost_typetraits/examples/fill.html">http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/boost_typetraits/examples/fill.html</a> and <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/boost_typetraits/examples/copy.html">http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/boost_typetraits/examples/copy.html</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Implementing a type trait</h1></div></div></div><p>We need to implement a type trait that <a id="id256" class="indexterm"/>returns true if the <code class="literal">std::vector</code> type is passed to it <a id="id257" class="indexterm"/>as a template parameter.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec169"/>Getting ready</h2></div></div></div><p>Some basic knowledge of the <code class="literal">Boost.TypeTrait</code> or STL type traits is required.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec170"/>How to do it...</h2></div></div></div><p>Let's see how to implement a type trait:</p><div><pre class="programlisting">#include &lt;vector&gt;
#include &lt;boost/type_traits/integral_constant.hpp&gt;

template &lt;class T&gt;
struct is_stdvector: boost::false_type {};

template &lt;class T, class Allocator&gt;
struct is_stdvector&lt;std::vector&lt;T, Allocator&gt; &gt;: boost::true_type {};</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec171"/>How it works...</h2></div></div></div><p>Almost all the work is done by the <code class="literal">boost::true_type</code> and <code class="literal">boost::false_type</code> classes. The <code class="literal">boost::true_type</code> <a id="id258" class="indexterm"/>class has a boolean <code class="literal">::value</code> static constant in it that equals to <code class="literal">true</code>, the <code class="literal">boost::false_type</code> class has a boolean <code class="literal">::value</code> static constant in it that equals to <code class="literal">false</code>. They also have some typedefs, and are usually derived from <code class="literal">boost::mpl::integral_c</code>, which makes it easy to use types derived from <code class="literal">true_type/false_type</code> with <code class="literal">Boost.MPL</code>.</p><p>Our first <code class="literal">is_stdvector</code> <a id="id259" class="indexterm"/>structure is a generic structure that will be used always when template specialized version of such structure is not found. Our second <code class="literal">is_stdvector</code> structure is a template specialization for the <code class="literal">std::vector</code> types (note that it is derived from <code class="literal">true_type</code>!). So, when we pass vector type to the <code class="literal">is_stdvector</code> structure, template specialized version will be used, otherwise generic version will be used, which is derived from <code class="literal">false_type</code>.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>3 lines There is no public keyword before <code class="literal">boost::false_type</code> and <code class="literal">boost::true_type</code> in our trait because we use <code class="literal">struct</code> keyword, and by default it uses public inheritance.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec172"/>There's more...</h2></div></div></div><p>Those readers who use the C++11 compatible compilers may use the <code class="literal">true_type</code> and <code class="literal">false_type</code> types declared in the <code class="literal">&lt;type_traits&gt;</code> header from the <code class="literal">std::</code> namespace for creating their own type traits.</p><p>As usual, the Boost version is more portable because it can be used on C++03 compilers.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec173"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Almost all the recipes from this <a id="id260" class="indexterm"/>chapter use type traits. Refer to the <code class="literal">Boost.TypeTraits</code> documentation for more examples and information at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/i">http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/i</a><a class="ulink" href="http://ndex.html">ndex.html</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Selecting an optimal operator for a template parameter</h1></div></div></div><p>Imagine that we are <a id="id261" class="indexterm"/>working with classes from different vendors that implement different amounts of arithmetic operations and have constructors from integers. And, we do want to make a function that increments by one when <a id="id262" class="indexterm"/>any class is passed to it. Also, we want this function to be effective! Take a look at the following code:</p><div><pre class="programlisting">template &lt;class T&gt;
void inc(T&amp; value) {
    // call ++value
    // or call value ++
    // or value += T(1);
    // or value = value + T(1);
}</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec174"/>Getting ready</h2></div></div></div><p>Some basic knowledge of the C++ templates, and the <code class="literal">Boost.TypeTrait</code> or STL type traits is required.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec175"/>How to do it...</h2></div></div></div><p>All the selecting can be done at <a id="id263" class="indexterm"/>compile time. This can be achieved using the <code class="literal">Boost.TypeTraits</code> library, as shown in the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Let's start from making correct functional objects:<div><pre class="programlisting">namespace detail {
    struct pre_inc_functor {
        template &lt;class T&gt;
        void operator()(T&amp; value) const {
           ++ value;
        }
    };

    struct post_inc_functor {
        template &lt;class T&gt;
        void operator()(T&amp; value) const {
            value++;
        }
    };

    struct plus_assignable_functor {
        template &lt;class T&gt;
        void operator()(T&amp; value) const {
            value += T(1);
        }
    };

    struct plus_functor {
        template &lt;class T&gt;
        void operator()(T&amp; value) const {
            value = value + T(1);
        }
    };
}</pre></div></li><li class="listitem">After that we will <a id="id264" class="indexterm"/>need a bunch of type traits:<div><pre class="programlisting">#include &lt;boost/type_traits/conditional.hpp&gt;
#include &lt;boost/type_traits/has_plus_assign.hpp&gt;
#include &lt;boost/type_traits/has_plus.hpp&gt;
#include &lt;boost/type_traits/has_post_increment.hpp&gt;
#include &lt;boost/type_traits/has_pre_increment.hpp&gt;</pre></div></li><li class="listitem">And, we are ready to <a id="id265" class="indexterm"/>deduce correct functor and use it:<div><pre class="programlisting">template &lt;class T&gt;
void inc(T&amp; value) {
    typedef detail::plus_functor step_0_t;

    typedef typename boost::conditional&lt;
      boost::has_plus_assign&lt;T&gt;::value,
      detail::plus_assignable_functor,
      step_0_t
    &gt;::type step_1_t;

    typedef typename boost::conditional&lt;
      boost::has_post_increment&lt;T&gt;::value,
      detail::post_inc_functor,
      step_1_t
    &gt;::type step_2_t;

    typedef typename boost::conditional&lt;
      boost::has_pre_increment&lt;T&gt;::value,
      detail::pre_inc_functor,
      step_2_t
    &gt;::type step_3_t;

    step_3_t() // default constructing functor
        (value); // calling operator() of a functor
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec176"/>How it works...</h2></div></div></div><p>All the magic is done via the <code class="literal">conditional&lt;bool Condition, class T1, class T2&gt;</code> metafunction. When this metafunction accepts <code class="literal">true</code> as a first parameter, it returns <code class="literal">T1</code> via the <code class="literal">::type</code> typedef. When the <code class="literal">boost::conditional</code> metafunction accepts <code class="literal">false</code> as a first parameter, it returns <a id="id266" class="indexterm"/>
<code class="literal">T2</code> via the <code class="literal">::type</code> typedef. It acts like some kind of compile-time <code class="literal">if</code> statement.</p><p>So, <code class="literal">step0_t</code> holds a <code class="literal">detail::plus_functor</code> metafunction and <code class="literal">step1_t</code> will hold <code class="literal">step0_t</code> or <code class="literal">detail::plus_assignable_functor</code>. The <code class="literal">step2_t</code> type will hold <code class="literal">step1_t</code> or <code class="literal">detail::post_inc_functor</code>. The <code class="literal">step3_t</code> type will hold <code class="literal">step2_t</code> or <code class="literal">detail::pre_inc_functor</code>. What each <code class="literal">step*_t</code> typedef holds is deduced using type trait.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec177"/>There's more...</h2></div></div></div><p>There is a C++11 version of this function, which can be found in the <code class="literal">&lt;type_traits&gt;</code> header in the <code class="literal">std::</code> namespace. Boost has multiple versions of this function in different libraries, for example, <code class="literal">Boost.MPL</code> has function <code class="literal">boost::mpl::if_c</code>, which acts exactly like <code class="literal">boost::conditional</code>. It also has a <a id="id267" class="indexterm"/>version <code class="literal">boost::mpl::if_</code> (without <code class="literal">c</code> at the end), which will call <code class="literal">::type</code> for its first template argument; and if it is derived from <code class="literal">boost::true_type</code> (or is a <code class="literal">boost::true_type</code> type), it will return its second argument during the <code class="literal">::type</code> call, otherwise it will return the last template parameter. We can rewrite our <code class="literal">inc()</code> function to use <code class="literal">Boost.MPL</code>, as shown in the following code:</p><div><pre class="programlisting">#include &lt;boost/mpl/if.hpp&gt;

template &lt;class T&gt;
void inc_mpl(T&amp; value) {
    typedef detail::plus_functor step_0_t;

    typedef typename boost::mpl::if_&lt;
      boost::has_plus_assign&lt;T&gt;,
      detail::plus_assignable_functor,
      step_0_t
    &gt;::type step_1_t;

    typedef typename boost::mpl::if_&lt;
      boost::has_post_increment&lt;T&gt;,
      detail::post_inc_functor,
      step_1_t
    &gt;::type step_2_t;

    typedef typename boost::mpl::if_&lt;
      boost::has_pre_increment&lt;T&gt;,
      detail::pre_inc_functor,
      step_2_t
    &gt;::type step_3_t;

    step_3_t() // default constructing functor
        (value); // calling operator() of a functor
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec178"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The recipe <em>Enabling the usage of templated functions for integral types</em></li><li class="listitem" style="list-style-type: disc">The recipe <em>Disabling templated functions' usage for real types</em></li><li class="listitem" style="list-style-type: disc">The <code class="literal">Boost.TypeTraits</code> documentation has a full list of available metafunctions. <a id="id268" class="indexterm"/>Read about it at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html</a>.</li><li class="listitem" style="list-style-type: disc">The recipes from <a class="link" href="ch08.html" title="Chapter 8. Metaprogramming">Chapter 8</a>, <em>Metaprogramming</em>, will give you more examples of the <code class="literal">Boost.MPL</code> library usage. If you feel confident, you may also try to read its documentation at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html">http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html</a>.</li><li class="listitem" style="list-style-type: disc">There is a proposal to add type switch to C++, and you may find it interesting. Read <a id="id269" class="indexterm"/>about it at <a class="ulink" href="http://www.stroustrup.com/OOPSLA-ty">http://www.stroustrup.com/OOPSLA-ty</a><a class="ulink" href="http://peswitch-draft.pdf">peswitch-draft.pdf</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Getting a type of expression in C++03</h1></div></div></div><p>In the previous recipes, we <a id="id270" class="indexterm"/>saw some examples on <code class="literal">boost::bind</code> usage. It is a good <a id="id271" class="indexterm"/>and useful tool with a small drawback; it is hard to store <code class="literal">boost::bind</code> metafunction's functor as a variable in C++03.</p><div><pre class="programlisting">#include &lt;functional&gt;
#include &lt;boost/bind.hpp&gt;

const ??? var = boost::bind(std::plus&lt;int&gt;(), _1, _1);</pre></div><p>In C++11, we can use <code class="literal">auto</code> <a id="id272" class="indexterm"/>keyword instead of <code class="literal">???</code>, and that will work. Is there a way to do it in C++03?</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec179"/>Getting ready</h2></div></div></div><p>The knowledge of the C++11 <code class="literal">auto</code> and <code class="literal">decltype</code> keywords may help you to understand this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec180"/>How to do it...</h2></div></div></div><p>We will need a <code class="literal">Boost.Typeof</code> library for getting return type of expression:</p><div><pre class="programlisting">#include &lt;boost/typeof/typeof.hpp&gt;
BOOST_AUTO(var, boost::bind(std::plus&lt;int&gt;(), _1, _1));</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec181"/>How it works...</h2></div></div></div><p>It just creates a variable with the name <code class="literal">var</code>, and the value of the expression is passed as a second argument. Type of <code class="literal">var</code> is detected from the type of expression.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec182"/>There's more...</h2></div></div></div><p>An experienced C++11 reader will note that there are more keywords in the new standard for detecting the types of expression. <a id="id273" class="indexterm"/>Maybe <code class="literal">Boost.Typeof</code> has macro for them too. Let's take a look at the following C++11 code:</p><div><pre class="programlisting">typedef decltype(0.5 + 0.5f) type;</pre></div><p>Using <code class="literal">Boost.Typeof</code>, the preceding code can be written like the following code:</p><div><pre class="programlisting">typedef BOOST_TYPEOF(0.5 + 0.5f) type;</pre></div><p>C++11 version's <code class="literal">decltype(expr)</code> deduces and returns the type of <code class="literal">expr</code>.</p><div><pre class="programlisting">template&lt;class T1, class T2&gt;
auto add(const T1&amp; t1, const T2&amp; t2) -&gt;decltype(t1 + t2) {
    return t1 + t2;
};</pre></div><p>Using <code class="literal">Boost.Typeof</code>, the preceding code can be written like the following code:</p><div><pre class="programlisting">template&lt;class T1, class T2&gt;
BOOST_TYPEOF_TPL(T1() + T2()) add(const T1&amp; t1, const T2&amp; t2) {
    return t1 + t2;
};</pre></div><div><div><h3 class="title"><a id="note12"/>Note</h3><p>C++11 has a special syntax for specifying return type at the end of the function declaration. Unfortunately, this cannot be emulated in C++03, so we cannot use <code class="literal">t1</code> and <code class="literal">t2</code> variables in macro.</p></div></div><p>You can freely use the results of <a id="id274" class="indexterm"/>the <code class="literal">BOOST_TYPEOF()</code> functions in templates and in any other compile-time expressions:</p><div><pre class="programlisting">#include &lt;boost/static_assert.hpp&gt;
#include &lt;boost/type_traits/is_same.hpp&gt;
BOOST_STATIC_ASSERT((boost::is_same&lt;BOOST_TYPEOF(add(1, 1)), int&gt;::value));</pre></div><p>But unfortunately, this magic does not always work without help. For example, user-defined classes are not always detected, so the following code may fail on some compilers:</p><div><pre class="programlisting">namespace readers_project {
    template &lt;class T1, class T2, class T3&gt;
    struct readers_template_class{};
}

#include &lt;boost/tuple/tuple.hpp&gt;

typedef
    readers_project::readers_template_class&lt;int, int, float&gt;
readers_template_class_1;

typedef BOOST_TYPEOF(boost::get&lt;0&gt;(
    boost::make_tuple(readers_template_class_1(), 1)
)) readers_template_class_deduced;

BOOST_STATIC_ASSERT((
    boost::is_same&lt;
        readers_template_class_1,
        readers_template_class_deduced
    &gt;::value
));</pre></div><p>In such situations, you may <a id="id275" class="indexterm"/>give <code class="literal">Boost.Typeof</code> a helping hand and register a template:</p><div><pre class="programlisting">BOOST_TYPEOF_REGISTER_TEMPLATE(
        readers_project::readers_template_class /*class name*/,
        3 /*number of template classes*/
)</pre></div><p>However, three most popular compilers correctly detected type even without <code class="literal">BOOST_TYPEOF_REGISTER_TEMPLATE</code> and without C++11.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec183"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The official <a id="id276" class="indexterm"/>documentation of <code class="literal">Boost.Typeof</code> has more examples. Read about it at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/typeof.html">http://www.boost.org/doc/libs/1_53_0/doc/html/typeof.html</a>.</li><li class="listitem" style="list-style-type: disc"><em>Bjarne Stroustrup</em> may introduce some of the C++11 features to you. Read about it at <a class="ulink" href="http://www.stroustrup.com/C++11FAQ.html">http://www.stroustrup.com/C++11FAQ.html</a>.</li></ul></div></div></div></body></html>