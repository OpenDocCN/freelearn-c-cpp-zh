- en: Chapter 4. Building Scenes and Layers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：构建场景和层
- en: 'The following topics will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating scenes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建场景
- en: Transitioning between scenes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景间的切换
- en: Transitioning scenes with effects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用效果切换场景
- en: Making original transitions for replacing scenes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为替换场景制作原创过渡效果
- en: Making original transitions for popping scenes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为弹出场景制作原创过渡效果
- en: Creating layers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建层
- en: Creating modal layers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模态层
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One screen has one scene. A scene is a container that holds Sprite, Labels,
    and other objects. For example, a scene can be a title scene, a game scene, or
    an option menu scene. Each scene has multiple layers. A layer is a transparent
    sheet similar to Photoshop's layer. Objects that added to layers are displayed
    on the screen. In this chapter, we will explain how to use the `Scene` class and
    the `Layer` class and how to transition between scenes. Finally, by the end of
    this chapter, you will be able to create original scenes and layers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一屏有一个场景。场景是一个容器，它包含精灵、标签和其他对象。例如，场景可以是标题场景、游戏场景或选项菜单场景。每个场景都有多个层。层是一个类似于Photoshop层的透明纸。添加到层中的对象将在屏幕上显示。在本章中，我们将解释如何使用`Scene`类和`Layer`类以及如何在场景间进行切换。最后，在本章结束时，你将能够创建原创的场景和层。
- en: Creating scenes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建场景
- en: In Cocos2d-x, your games should have one or more scenes. A scene is basically
    a node. In this recipe, we will explain how to create and use a `Scene` class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cocos2d-x中，你的游戏应该有一个或多个场景。场景基本上是一个节点。在本食谱中，我们将解释如何创建和使用`Scene`类。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we will use the project that was created in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Cocos2d-x"), *Getting Started with Cocos2d-x*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用在[第一章](ch01.html "第一章：Cocos2d-x入门")中创建的项目，即*Cocos2d-x入门*。
- en: Firstly, duplicate the `HelloWorldScene.cpp` and `HelloWorldScene.h` files at
    `Finder` and rename them as `TitleScene.cpp` and `TitleScene.h`. Secondly, add
    them to the Xcode project. The result is shown in the following image:![How to
    do it...](img/B0561_04_01.jpg)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Finder`中复制`HelloWorldScene.cpp`和`HelloWorldScene.h`文件，并将它们重命名为`TitleScene.cpp`和`TitleScene.h`。其次，将它们添加到Xcode项目中。结果如下所示：![如何做...](img/B0561_04_01.jpg)
- en: Next, we have to change `HelloWorldScene` to `TitleScene` and place the search
    and replace method in the tips section.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须将`HelloWorldScene`更改为`TitleScene`，并将搜索和替换方法放在提示部分。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**How to search for and replace a class name?**'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**如何搜索和替换类名？**'
- en: 'In this case, select `TitleScene.h` and then the **Find** | **Find and Replace
    …** menu in Xcode. Then, enter `HelloWorld` in the **String Matching** area and
    `TitleScene` in the **Replacement String** area. Execute all replacements. Follow
    the same process for `TitleScene.cpp`. The result is the following code for `TitleScene.h`:'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此情况下，选择`TitleScene.h`，然后在Xcode中选择**查找** | **查找和替换…**菜单。然后，在**字符串匹配**区域输入`HelloWorld`，在**替换字符串**区域输入`TitleScene`。执行所有替换。对`TitleScene.cpp`执行相同的操作。结果如下所示：
- en: 'The result obtained for `TitleScene.h` is as follows:'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TitleScene.h`的结果如下：'
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, the result for `TitleScene.cpp` is as follows:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，`TitleScene.cpp`的结果如下：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, add a label to the difference between `TitleScene` and `HelloWorldScene`.
    Add it before the return line in the `TitleScene::init` method as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`TitleScene`和`HelloWorldScene`之间的差异处添加一个标签。在`TitleScene::init`方法的返回行之前添加如下：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Similarly, add the label in the `HelloWorld::init` method.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，在`HelloWorld::init`方法中添加标签。
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, to display the `TitleScene` class, change `AppDelegate.cpp` as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了显示`TitleScene`类，按照以下方式修改`AppDelegate.cpp`：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result is shown in the following image:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![How to do it...](img/B0561_04_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B0561_04_02.jpg)'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, you need to create `TitleScene` by duplicating the `HelloWorldScene`
    class files. It is pretty difficult to create an original `Scene` class from a
    blank file. However, a basic class of `Scene` is patterned. So, you can create
    it easily by duplicating and modifying the `HelloWorldScene` class files. While
    you are developing your game, you need to execute this step when you need a new
    scene.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要通过复制`HelloWorldScene`类文件来创建`TitleScene`。从空白文件创建一个原创的`Scene`类相当困难。然而，`Scene`的基本类是模式化的。因此，你可以通过复制和修改`HelloWorldScene`类文件来轻松创建它。当你开发游戏时，当你需要新的场景时，你需要执行此步骤。
- en: 'Finally, we change the `AppDelegate.cpp` file. The `AppDelegate` class is the
    first class to be executed in Cocos2d-x. The `AppDelegate:: applicationDidFinishLaunching`
    method is executed when the application is ready to run. This method will prepare
    the execution of Cocos2d-x. Then, it will create the first scene and run it.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更改 `AppDelegate.cpp` 文件。`AppDelegate` 类是 Cocos2d-x 中首先执行的一个类。当应用程序准备好运行时，会执行
    `AppDelegate::applicationDidFinishLaunching` 方法。此方法将准备 Cocos2d-x 的执行。然后，它将创建第一个场景并运行它。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `TitleScene::createScene` method is used to create a title scene, and the
    `runWithScene` method is used to run it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`TitleScene::createScene` 方法用于创建一个标题场景，而 `runWithScene` 方法用于运行它。'
- en: Transitioning between scenes
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景之间的转换
- en: Your games have to transition between scenes. For example, after launching your
    games, the title scene is displayed. Then, it is transitioned into the level selection
    scene, game scene, and so on. In this recipe, we will explain how to facilitate
    transition between scenes, which would improve the gameplay and the flow of the
    game.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您的游戏需要在场景之间进行转换。例如，在启动游戏后，会显示标题场景。然后，它会转换到关卡选择场景、游戏场景等等。在这个菜谱中，我们将解释如何促进场景之间的转换，这将提高游戏玩法和游戏流程。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: A game has a lot of scenes. So, you might need to move between scenes in your
    game. Perhaps, when a game is started, a title scene will be displayed. Then,
    a game scene will appear in the next title scene. There are two ways to transition
    to a scene.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个游戏有很多场景。因此，您可能需要在游戏中在不同场景之间移动。也许，当游戏开始时，会显示一个标题场景。然后，在下一个标题场景中会出现一个游戏场景。有两种方法可以转换到场景。
- en: One is to use the `Director::replaceScene` method. This method replaces a scene
    outright.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种方法是使用 `Director::replaceScene` 方法。此方法直接替换场景。
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The other is to use the `Director::pushScene` method. This method suspends the
    execution of the running scene and pushes a new scene on the stack of the suspended
    scene.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `Director::pushScene` 方法。此方法挂起正在运行的场景，并在挂起场景的堆栈上推入一个新的场景。
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, the old scene is suspended. You can get back to the old scene
    to pop up a new scene.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，旧场景被挂起。您可以回到旧场景以弹出新的场景。
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Layer, Sprite, and other nodes can be displayed by using the `addChild` method.
    However, Scene cannot be displayed by using the `addChild` method; it can be displayed
    by using the `Director::replaceScene` or `Director::pushScene` methods. That's
    why `Scene` is visible only on one screen at the same time. `Scene` and `Layer`
    are similar, but there is a significant difference.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `addChild` 方法来显示层、精灵和其他节点。然而，场景不能通过 `addChild` 方法来显示；它可以通过使用 `Director::replaceScene`
    或 `Director::pushScene` 方法来显示。这就是为什么场景在同一时间只能在一个屏幕上可见。`Scene` 和 `Layer` 类似，但存在显著差异。
- en: Usually, you will use the `replaceScene` method when you change the scene from
    the title scene to the game scene. Further, you can use the `pushScene` method
    to display a modal scene, as in the case of pausing a scene during a game. In
    this case, an easy way to suspend a game scene is to pause the game.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当您从标题场景切换到游戏场景时，您会使用 `replaceScene` 方法。进一步，您可以使用 `pushScene` 方法显示模态场景，例如在游戏暂停期间。在这种情况下，挂起游戏场景的一个简单方法是暂停游戏。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When scenes are replaced in a game, the applications will release the memory
    used by the old scenes. However, if games push scenes, they will not release the
    memory used by the old scenes because it will suspend it. Further, games are resumed
    when new scenes are popped. If you added a lot of scenes by using the `pushScene`
    method, the device memory will no longer be enough.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当在游戏中替换场景时，应用程序将释放旧场景使用的内存。然而，如果游戏推入场景，它们将不会释放旧场景使用的内存，因为它们将挂起它。此外，当弹出新场景时，游戏将恢复。如果您使用
    `pushScene` 方法添加了大量的场景，设备内存将不再足够。
- en: Transitioning scenes with effects
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带效果的场景转换
- en: Popular games display some effects when transitioning scenes. These effects
    can be natural, dramatic, and so on. Cocos2d-x has a lot of transitioning effects.
    In this recipe, we will explain how to use a transitioning effect and the effect
    produced.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 流行游戏在场景转换时显示一些效果。这些效果可以是自然的、戏剧性的等等。Cocos2d-x 有很多转换效果。在这个菜谱中，我们将解释如何使用转换效果及其产生的效果。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: You can add visual effects to a scene transition by using the `Transition` class.
    Cocos2d-x has many kinds of `Transition` classes. However, there is only one pattern
    for how to use them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Transition` 类为场景过渡添加视觉效果。Cocos2d-x 有许多种 `Transition` 类。然而，使用它们的模式只有一种。
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It can be used when a scene was pushed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在场景被推入时使用。
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Firstly, you need to create the `nextscene` object. Then, you need to create
    a `transition` object with a set duration and an incoming scene object. Lastly,
    you need to run `Director::pushScene` with the `transition` object. This recipe
    sets the duration for the transition scene and the fade action as one second.
    The following table lists some of the major `Transition` classes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要创建 `nextscene` 对象。然后，您需要创建一个具有设定持续时间和即将进入的场景对象的 `transition` 对象。最后，您需要使用
    `transition` 对象运行 `Director::pushScene`。此配方将过渡场景的持续时间和淡入淡出动作设置为1秒。以下表格列出了主要的 `Transition`
    类：
- en: '| Transition Class | Description |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `Transition Class` | 描述 |'
- en: '| --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `TransitionRotoZoom` | Rotates and zooms out of the outgoing scene, and then,
    rotates and zooms into the incoming scene. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionRotoZoom` | 旋转并缩放即将离开的场景，然后旋转并缩放进入即将进入的场景。|'
- en: '| `TransitionJumpZoom` | Zooms out and jumps the outgoing scene, and then jumps
    and zooms into the incoming scene. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionJumpZoom` | 缩放并跳转到即将离开的场景，然后跳转并缩放进入即将进入的场景。|'
- en: '| `TransitionMoveInL` | Moves scene in from right to the left. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionMoveInL` | 从右向左移动场景。|'
- en: '| `TransitionSlideInL` | Slides in the incoming scene from the left border.
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionSlideInL` | 从左侧滑入即将进入的场景。|'
- en: '| `TransitionShrinkGrow` | Shrinks the outgoing scene while enlarging the incoming
    scene. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionShrinkGrow` | 在缩小即将离开的场景的同时放大即将进入的场景。|'
- en: '| `TransitionFlipX` | Flips the screen horizontally. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionFlipX` | 水平翻转屏幕。|'
- en: '| `TransitionZoomFlipX` | Flips the screen horizontally by doing a zoom out/in.
    The front face shows the outgoing scene, and the back face shows the incoming
    scene. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionZoomFlipX` | 通过缩放和平移水平翻转屏幕。正面显示的是即将离开的场景，背面显示的是即将进入的场景。|'
- en: '| `TransitionFlipAngular` | Flips the screen half horizontally and half vertically.
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionFlipAngular` | 将屏幕水平翻转一半，垂直翻转一半。|'
- en: '| `TransitionZoomFlipAngular` | Flips the screen half horizontally and half
    vertically by zooming out/in a little. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionZoomFlipAngular` | 通过稍微缩放和平移水平翻转一半，垂直翻转一半。|'
- en: '| `TransitionFade` | Fades out of the outgoing scene, and then, fades into
    the incoming scene. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionFade` | 从即将离开的场景淡出，然后淡入即将进入的场景。|'
- en: '| `TransitionCrossFade` | Cross-fades two scenes by using the `RenderTexture`
    object. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionCrossFade` | 使用 `RenderTexture` 对象交叉淡入两个场景。|'
- en: '| `TransitionTurnOffTiles` | Turns off the tiles of the outgoing scene in an
    random order. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionTurnOffTiles` | 以随机顺序关闭即将离开的场景的瓦片。|'
- en: '| `TransitionSplitCols` | The odd columns go upwards, while the even columns
    go downwards. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionSplitCols` | 奇数列向上移动，偶数列向下移动。|'
- en: '| `TransitionSplitRows` | The odd rows go to the left, while the even rows
    go to the right. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionSplitRows` | 奇数行向左移动，偶数行向右移动。|'
- en: '| `TransitionFadeTR` | Fades the tiles of the outgoing scene from the left-bottom
    corner to the top-right corner. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionFadeTR` | 从左下角到右上角渐变即将离开的场景的瓦片。|'
- en: '| `TransitionFadeUp` | Fades the tiles of the outgoing scene from the bottom
    to the top. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionFadeUp` | 从底部到顶部渐变即将离开的场景的瓦片。|'
- en: '| `TransitionPageTurn` | Peels back the bottom right-hand corner of a scene
    to transition to the scene beneath it, thereby simulating a page turn. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionPageTurn` | 将场景的右下角翻起，以过渡到下面的场景，从而模拟翻页效果。|'
- en: '| `TransitionProgressRadialCW` | Counterclockwise radial transition to the
    next scene. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `TransitionProgressRadialCW` | 逆时针径向过渡到下一个场景。|'
- en: There's more...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can also learn the beginning and the end of the transition scene by using
    the `onEnterTransitionDidFinish` method and the `onExitTransitionDidStart` method.
    When your game shows the new scene completely, the `onEnterTransitionDidFinish`
    method is called. When the old scene starts disappearing, the `onExitTransitionDidStart`
    method is called. If you'd like to do something during the time that the scenes
    appear or disappear, you will need to use these methods.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用 `onEnterTransitionDidFinish` 方法和 `onExitTransitionDidStart` 方法来学习过渡场景的开始和结束。当您的游戏完全显示新场景时，`onEnterTransitionDidFinish`
    方法会被调用。当旧场景开始消失时，`onExitTransitionDidStart` 方法会被调用。如果您想在场景出现或消失期间做些事情，您将需要使用这些方法。
- en: 'Let''s now look at an example of using the `onEnterTransitionDidFinish` and
    `onExitTransitionDidStart` methods. `HelloWorldScene.h` has the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个使用 `onEnterTransitionDidFinish` 和 `onExitTransitionDidStart` 方法的例子。`HelloWorldScene.h`
    包含以下代码：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Making original transitions for replacing scenes
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为替换场景制作原创过渡
- en: You know that Cocos2d-x has a lot of transitioning effects. However, if it does
    not have an effect that you need, it is difficult to create an original transitioning
    effect. However, you can create it if you have the basic knowledge of transitioning
    effects. In this recipe, we will show you how to create original transitions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道 Cocos2d-x 有很多过渡效果。然而，如果你需要的过渡效果它没有，那么创建一个原创的过渡效果是困难的。但是，如果你有基本的过渡效果知识，你仍然可以创建它。在这个菜谱中，我们将向你展示如何创建原创的过渡效果。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Even though Cocos2d-x has a lot of different types of `Transition` classes,
    you may not find a transition effect that you need. In this recipe, you can create
    an original transition effect such as opening a door. When the replacement of
    a scene begins, the previous scene is divided into two and open to the left or
    right.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Cocos2d-x 有很多不同类型的 `Transition` 类，但你可能找不到你需要的过渡效果。在这个菜谱中，你可以创建一个如开门这样的原创过渡效果。当场景替换开始时，上一个场景被分割成两部分并向左或向右打开。
- en: You have to create new files named "`TransactionDoor.h`" and "`TransactionDoor.cpp`,"
    and add them to your project.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须创建名为 "`TransactionDoor.h`" 和 "`TransactionDoor.cpp`" 的新文件，并将它们添加到你的项目中。
- en: '`TransactionDoor.h` has the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransactionDoor.h` 包含以下代码：'
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use the following code for `TransactionDoor.cpp`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码为 `TransactionDoor.cpp`：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following code will allow us to use the `TransitionDoor` effect:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将允许我们使用 `TransitionDoor` 效果：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All types of transitions have `TransitionScene` as `SuperClass`. `TransitionScene`
    is a basic class and has a basic transition process. If you would like to create
    the original transition effect in an easier way, you would look for a similar
    transition effect in Cocos2d-x. You can then create your class from a similar
    class. The `TransitionDoor` class is created from the `TransitionSplitCol` class.
    Then, add and modify them where necessary. However, it is necessary to have basic
    knowledge about them in order to fix them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型的过渡都以 `TransitionScene` 作为 `SuperClass`。`TransitionScene` 是一个基本类，具有基本的过渡过程。如果你想以更简单的方式创建原创的过渡效果，你会在
    Cocos2d-x 中寻找类似的过渡效果。然后，你可以从类似的类创建你的类。`TransitionDoor` 类是从 `TransitionSplitCol`
    类创建的。然后，根据需要添加和修改它们。然而，为了修复它们，你需要对这些有基本的知识。
- en: 'The following are some of the important properties of the `Transition` class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transition` 类的一些重要属性如下：'
- en: '| Properties | Description |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `_inScene` | Pointer of the next scene. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `_inScene` | 指向下一个场景的指针。 |'
- en: '| `_outScene` | Pointer of the out scene. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `_outScene` | 出场景的指针。 |'
- en: '| `_duration` | Duration of the transition, a float value specified by the
    create method. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `_duration` | 过渡的持续时间，由创建方法指定的浮点值。 |'
- en: '| `_isInSceneOnTop` | Boolean value; if it is true, the next scene is the top
    of the scene graph. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `_isInSceneOnTop` | 布尔值；如果为真，则下一个场景是场景图的顶部。 |'
- en: 'Some of the important properties of the `transition` class are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`transition` 类的一些重要属性如下：'
- en: '| Properties | Description |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `onEnter` | To start the transition effect. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `onEnter` | 开始过渡效果。 |'
- en: '| `Action` | To create an effect action. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `Action` | 创建效果动作。 |'
- en: '| `onExit` | To finish the transition effect and clean up. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `onExit` | 完成过渡效果并进行清理。 |'
- en: In the case of the `TransitionDoor` class, the next scene is set to be visible
    and the previous scene in split into two grids in the `onEnter` method. Then,
    an effect such as opening a door is started. In the action method, an instance
    of the `Action` class is created by using the `SplitDoor` class. The `SplitDoor`
    class is based on the `SplitCol` class in Cocos2d-x. The `SplitDoor` class moves
    two grids of the previous scene to the left or the right.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TransitionDoor` 类的情况下，下一个场景在 `onEnter` 方法中被设置为可见，上一个场景在分割成两个网格。然后，开始一个如开门这样的效果。在动作方法中，通过使用
    `SplitDoor` 类创建 `Action` 类的实例。`SplitDoor` 类基于 Cocos2d-x 中的 `SplitCol` 类。`SplitDoor`
    类将上一个场景的两个网格向左或向右移动。
- en: There's more...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: There are some necessary methods in addition to those described above. These
    methods are defined in the `Node` class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述描述的方法之外，还有一些必要的方法。这些方法在 `Node` 类中定义。
- en: '| Properties | Description |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `onEnter` | Node starts appearing on the screen |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `onEnter` | 节点开始出现在屏幕上 |'
- en: '| `onExit` | Node disappears from the screen |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `onExit` | 节点从屏幕消失 |'
- en: '| `onEnterTransitionDidFinish` | Node finishes the transition effect after
    appearing on the screen |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `onEnterTransitionDidFinish` | 节点在屏幕上出现后完成过渡效果 |'
- en: '| `onExitTransitionDidStart` | Node starts the transition effect before disappearing
    from the screen |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `onExitTransitionDidStart` | 节点在从屏幕消失前开始过渡效果 |'
- en: If you want to play background music when the scene appears on the screen, you
    can play it by using the `onEnter` method. If you want to play it before finishing
    the transition effect, use the `onEnterTransitionDidFinish` method. Other than
    these, the initial process in the `onEnter` method starts the animation in the
    `onEnterTransitionDidFinish` method, cleans up the process in the `onExit` method,
    and so on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在场景出现在屏幕上时播放背景音乐，您可以通过使用 `onEnter` 方法来播放它。如果您想在过渡效果完成之前播放它，请使用 `onEnterTransitionDidFinish`
    方法。除此之外，`onEnter` 方法中的初始过程在 `onEnterTransitionDidFinish` 方法中开始动画，在 `onExit` 方法中清理过程，等等。
- en: Making original transitions for popping scenes
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为弹出场景创建原创过渡效果
- en: Cocos2d-x has transition effects for pushing a scene. For some reason, it does
    not have transition effects for popping scenes. We'd like to transition with an
    effect for popping scenes after pushing scenes with effects. In this recipe, we
    will explain how to create an original transition for popping scenes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x 为推入场景提供了过渡效果。但由于某种原因，它没有为弹出场景提供过渡效果。我们希望在推入场景后使用效果弹出场景。在本教程中，我们将解释如何为弹出场景创建一个原创的过渡效果。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will understand how to pop a transition scene with effects.
    You will need a new class, so you have to make new class files called `DirectorEx.h`
    and `DirectorEx.cpp` and add them to your project.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将了解如何使用效果弹出过渡场景。您需要创建一个新的类，因此您必须创建名为 `DirectorEx.h` 和 `DirectorEx.cpp`
    的新类文件，并将它们添加到您的项目中。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Cocos2d-x has a transition scene with effects for pushing scenes. However, it
    does not have transition effects for popping scenes. Therefore, we create an original
    class called `DirectorEx` to create a transition effect for popping scenes. The
    code snippet is given next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x 为推入场景提供了带有效果的过渡场景。然而，它没有为弹出场景提供过渡效果。因此，我们创建了一个名为 `DirectorEx` 的原创类来为弹出场景创建过渡效果。接下来的代码片段提供了代码示例。
- en: '`DirectorEx.h` has the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`DirectorEx.h` 包含以下代码：'
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`DirectorEx.cpp` has the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`DirectorEx.cpp` 包含以下代码：'
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This class can be used as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此类可以使用如下：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If we customized the `Director` class in Cocos2d-x, it can transition with
    the effect for popping a scene. However, this is not a good idea. Therefore, we
    create a sub-class of the `Director` class called the `DirectorEx` class and use
    this class as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们自定义了 Cocos2d-x 中的 `Director` 类，它可以使用弹出场景的效果进行过渡。然而，这并不是一个好主意。因此，我们创建了一个名为
    `DirectorEx` 的 `Director` 类的子类，并使用此类如下：
- en: Firstly, you can get an instance of the `DirectorEx` class to cast an instance
    of the `Director` class.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您可以通过获取 `DirectorEx` 类的实例来将 `Director` 类的实例进行转换。
- en: '[PRE18]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Further, you have to get an instance of the previous scene.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，您还需要获取前一个场景的实例。
- en: '[PRE19]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, you have to create a transition effect.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您必须创建一个过渡效果。
- en: '[PRE20]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, you can pop a scene with this effect by using the `DirectorEx::popScene`
    method.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以使用 `DirectorEx::popScene` 方法使用此效果弹出场景。
- en: '[PRE21]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating layers
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建层
- en: A layer is an object that can be used on `Scene`. It is a transparent sheet
    similar to Photoshop's layer. All the objects are added to `Layer` in order to
    be displayed on the screen. Further, a scene can have multiple layers. Layers
    are also responsible for accepting inputs, drawing, and touching. For example,
    in the game, a scene has a background layer, hud layer, and a player's layer.
    In this recipe, we will explain how to use `Layer`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 层是一个可以在 `Scene` 上使用的对象。它类似于 Photoshop 中的图层的一个透明层。所有对象都添加到 `Layer` 中，以便在屏幕上显示。此外，一个场景可以有多个层。层还负责接受输入、绘制和触摸。例如，在游戏中，一个场景有一个背景层、HUD
    层和一个玩家的层。在本教程中，我们将解释如何使用 `Layer`。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following code shows how to create a layer and add it to a scene:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何创建一个层并将其添加到场景中：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That's easy. If you have a color layer, you can do it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。如果您有一个颜色层，您就可以做到。
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Scene class is the one displayed on the screen, but the `Layer` class can
    be stacked in many layers. Scene has one or more layers, and Sprite has to be
    on a layer. The `Layer` class is a transparent sheet. In addition, a transparent
    node needs more CPU power. So, you need to be careful not to stack too many layers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类是显示在屏幕上的，但 `Layer` 类可以堆叠在多个层中。场景有一个或多个层，精灵必须位于一个层上。`Layer` 类是一个透明的纸。此外，一个透明的节点需要更多的CPU资源。因此，你需要小心不要堆叠太多的层。
- en: Creating modal layers
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模态层
- en: In user interface design, a modal layer is an important layer. A modal layer
    is like a child window. When a modal layer is showing, players cannot touch any
    other button outside the modal layer. They can only touch the button on the modal
    layer. We will need modal layers when we confirm something with the players. In
    this recipe, we will explain how to create modal layers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面设计中，模态层是一个重要的层。模态层就像一个子窗口。当模态层显示时，玩家不能触摸模态层外的任何其他按钮。他们只能触摸模态层上的按钮。当我们需要与玩家确认某些事情时，我们需要模态层。在这个菜谱中，我们将解释如何创建模态层。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Firstly, you have to two new files named `ModalLayer.h` and `ModalLayer.cpp`.
    They should contain the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建两个名为 `ModalLayer.h` 和 `ModalLayer.cpp` 的新文件。它们应该包含以下代码：
- en: '`ModalLayer.h` should have the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModalLayer.h` 应该包含以下代码：'
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You should create a sub-class from the `ModalLayer` class and add a menu button
    or some design that you need. You then have to create an instance of it and add
    it to the running scene. Then, it should enable the buttons on the modal layer
    but disable the buttons at the bottom of the modal layer.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从 `ModalLayer` 类创建一个子类，并添加一个菜单按钮或你需要的设计。然后，你必须创建它的一个实例并将其添加到正在运行的场景中。然后，它应该启用模态层上的按钮，但禁用模态层底部的按钮。
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'It is easy to create a modal layer in Cocos2d-x version 3\. In version 3, a
    touch event occurs from the top of the layer. So, if the modal layer picks up
    all the touch events, the nodes under the modal layer are notified of these. The
    modal layer is picking up all of the events. Refer to the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cocos2d-x 版本 3 中创建模态层很容易。在版本 3 中，触摸事件从层的顶部发生。所以，如果模态层捕捉到所有触摸事件，那么位于模态层下的节点会收到这些事件的通知。模态层正在捕捉所有的事件。请参考以下代码：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This modal layer can pick up all touching events. However, Android has key events
    like the back key. When a player touches the back key when the modal layer is
    displayed, you have to decide to do it. In one of the cases, the modal is closed,
    and in another, the back key is ignored.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模态层可以捕捉所有触摸事件。然而，Android 有像返回键这样的按键事件。当玩家在模态层显示时触摸返回键，你必须决定如何处理。在一种情况下，模态层会被关闭，在另一种情况下，返回键会被忽略。
