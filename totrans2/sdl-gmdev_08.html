<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Creating Alien Attack"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Creating Alien Attack</h1></div></div></div><p>The framework has come on in leaps and bounds and we are almost ready to make our first game. We are going to create a simple 2D sidescrolling shooter in the vein of the classic '80's and '90's shooter games such as R-Type or Pulstar. However, the game will not be set in space. Aliens<a class="indexterm" id="id462"/> have attacked earth and only you and your weaponized helicopter can stop them. One level of fast-paced action is available in the source code downloads and this chapter will cover the steps taken to create it. Here is a screenshot of the game we will be creating:</p><div class="mediaobject"><img alt="Creating Alien Attack" src="graphics/6821OT_08_01.jpg"/></div><p>And another slightly more hectic shot:</p><div class="mediaobject"><img alt="Creating Alien Attack" src="graphics/6821OT_08_02.jpg"/></div><p>There <a class="indexterm" id="id463"/>are still a few things that the framework must handle before we can create this game. These <a class="indexterm" id="id464"/>additions include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sound</li><li class="listitem" style="list-style-type: disc">Collision detection</li></ul></div><p>By the end of the chapter you will have a good understanding of how this game was built using the framework and you will have the ability to continue and improve it. In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implementing sound</li><li class="listitem" style="list-style-type: disc">Creating game-specific object classes</li><li class="listitem" style="list-style-type: disc">Shooting and detecting bullets</li><li class="listitem" style="list-style-type: disc">Creating different enemy types</li><li class="listitem" style="list-style-type: disc">Developing a game</li></ul></div><div class="section" title="Using the SDL_mixer extension for sound"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec42"/>Using the SDL_mixer extension for sound</h1></div></div></div><p>The <a class="indexterm" id="id465"/>SDL_mixer extension has its own Mercurial repository that can be used to grab the latest source for the extension. It is located at <a class="ulink" href="http://hg.libsdl.org/SDL_mixer">http://hg.libsdl.org/SDL_mixer</a>. The TortoiseHg application can again be used to <a class="indexterm" id="id466"/>clone the extension's Mercurial repository. Follow these steps to build the library:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open up TortoiseHg and press <span class="emphasis"><em>CTRL</em></span>+<span class="emphasis"><em>SHIFT</em></span>+<span class="emphasis"><em>N</em></span> to start cloning a new repository.</li><li class="listitem">Type <a class="ulink" href="http://hg.libsdl.org/SDL_mixer">http://hg.libsdl.org/SDL_mixer</a> into the source box.</li><li class="listitem">The <span class="strong"><strong>Destination</strong></span> will be <code class="literal">C:\SDL2_mixer</code>.</li><li class="listitem">Hit <span class="strong"><strong>Clone</strong></span> and wait for completion.</li><li class="listitem">Navigate to <code class="literal">C:\SDL2_mixer\VisualC\</code> and open <code class="literal">SDL_mixer.vcproj</code> in Visual Studio 2010.</li><li class="listitem">As long as the x64 folder outlined in <a class="link" href="ch02.html" title="Chapter 2. Drawing in SDL">Chapter 2</a>, <span class="emphasis"><em>Drawing in SDL</em></span> was created, the project will convert with no issues.</li><li class="listitem">We are going to build the library without MP3 support as we are not going to need it, and also it does not work particularly well with SDL 2.0.</li><li class="listitem">Add <code class="literal">MP3_MUSIC_DISABLED</code> to the <span class="strong"><strong>Preprocessor Definitions</strong></span> in the project properties, which can be found by navigating to <span class="strong"><strong>C/C++</strong></span> | <span class="strong"><strong>Preprocessor</strong></span>, and build as per the <code class="literal">SDL_image</code> instructions in <a class="link" href="ch02.html" title="Chapter 2. Drawing in SDL">Chapter 2</a>, <span class="emphasis"><em>Drawing in SDL</em></span>.</li></ol></div><div class="section" title="Creating the SoundManager class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec57"/>Creating the SoundManager class</h2></div></div></div><p>The game created<a class="indexterm" id="id467"/> in this chapter will not need any advanced sound manipulation, meaning the <code class="literal">SoundManager</code> class is quite basic. The class has only been tested using the <code class="literal">.ogg</code> files for music and the <code class="literal">.wav</code> files for sound effects. Here is the header file:</p><div class="informalexample"><pre class="programlisting">enum sound_type
{
  SOUND_MUSIC = 0,
  SOUND_SFX = 1
};

class SoundManager
{
public:

  static SoundManager* Instance()
  {
    if(s_pInstance == 0)
    {
      s_pInstance = newSoundManager();
      return s_pInstance;
    }
    return s_pInstance;
  }

  bool load(std::string fileName, std::string id, sound_type type);

  void playSound(std::string id, int loop);
  void playMusic(std::string id, int loop);

  private:

  static SoundManager* s_pInstance;

  std::map&lt;std::string, Mix_Chunk*&gt; m_sfxs;
  std::map&lt;std::string, Mix_Music*&gt; m_music;

  SoundManager();
  ~SoundManager();

  SoundManager(const SoundManager&amp;);
  SoundManager &amp;operator=(const SoundManager&amp;);
};

typedef SoundManager TheSoundManager;</pre></div><p>The <code class="literal">SoundManager</code> class is a singleton; this makes sense because there should only be one place <a class="indexterm" id="id468"/>that the sounds are stored and it should be accessible from anywhere in the game. Before sound can be used, <code class="literal">Mix_OpenAudio</code> must be called to set up the audio for the game. <code class="literal">Mix_OpenAudio</code> takes the following parameters:</p><div class="informalexample"><pre class="programlisting">(int frequency, Uint16 format, int channels, int chunksize)</pre></div><p>This is done<a class="indexterm" id="id469"/> in the <code class="literal">SoundManager</code>'s constructor with values that will work well for most games.</p><div class="informalexample"><pre class="programlisting">SoundManager::SoundManager()
{
  Mix_OpenAudio(22050, AUDIO_S16, 2, 4096);
}</pre></div><p>The <code class="literal">SoundManager</code> class stores sounds in two different <code class="literal">std::map </code>containers:</p><div class="informalexample"><pre class="programlisting">std::map&lt;std::string, Mix_Chunk*&gt; m_sfxs;
std::map&lt;std::string, Mix_Music*&gt; m_music;</pre></div><p>These maps store pointers to one of two different types used by <code class="literal">SDL_mixer</code> (<code class="literal">Mix_Chunk*</code> and <code class="literal">Mix_Music*</code>), keyed using strings. The <code class="literal">Mix_Chunk*</code> types are used for sound effects and the <code class="literal">Mix_Music*</code> types are of course used for music. When loading a music file or a sound effect into <code class="literal">SoundManager</code>, we pass in the type of sound we are loading as an <code class="literal">enum</code> called <code class="literal">sound_type</code>.</p><div class="informalexample"><pre class="programlisting">bool load(std::string fileName, std::string id, sound_type type);</pre></div><p>This type is then used to decide which <code class="literal">std::map</code> to add the loaded sound to and also which <code class="literal">load</code> function to use from <code class="literal">SDL_mixer</code>. The<a class="indexterm" id="id470"/> <code class="literal">load</code> function is defined in <code class="literal">SoundManager.cpp</code>.</p><div class="informalexample"><pre class="programlisting">bool SoundManager::load(std::string fileName, std::string id, sound_type type)
{
  if(type == SOUND_MUSIC)
  {
    Mix_Music* pMusic = Mix_LoadMUS(fileName.c_str());

    if(pMusic == 0)
    {
      std::cout &lt;&lt; "Could not load music: ERROR - "
      &lt;&lt; Mix_GetError() &lt;&lt; std::endl;
      return false;
    }

    m_music[id] = pMusic;
    return true;
  }
  else if(type == SOUND_SFX)
  {
    Mix_Chunk* pChunk = Mix_LoadWAV(fileName.c_str());
    if(pChunk == 0)
    {
      std::cout &lt;&lt; "Could not load SFX: ERROR - "
      &lt;&lt; Mix_GetError() &lt;&lt; std::endl;

      return false;
    }

    m_sfxs[id] = pChunk;
    return true;
  }
  return false;
}</pre></div><p>Once a sound<a class="indexterm" id="id471"/> has been loaded it can be played using the <a class="indexterm" id="id472"/>
<span class="strong"><strong>playSound</strong></span> or <span class="strong"><strong>playMusic</strong></span> functions:</p><div class="informalexample"><pre class="programlisting">void playSound(std::string id, int loop);
void playMusic(std::string id, int loop);</pre></div><p>Both of these functions take the ID of the sound to be played and the amount of times that it is to be looped. Both functions are very similar.</p><div class="informalexample"><pre class="programlisting">void SoundManager::playMusic(std::string id, int loop)
{
  Mix_PlayMusic(m_music[id], loop);
}

void SoundManager::playSound(std::string id, int loop)
{
  Mix_PlayChannel(-1, m_sfxs[id], loop);
}</pre></div><p>One difference between <code class="literal">Mix_PlayMusic</code> and <code class="literal">Mix_PlayChannel</code> is that the latter takes an <code class="literal">int</code> as the first parameter; this is the channel that the sound is to be played on. A value of <span class="strong"><strong>-1</strong></span> (as seen in the preceding code) tells <code class="literal">SDL_mixer</code> to play the sound on any available channel.</p><p>Finally, when the <a class="indexterm" id="id473"/>
<code class="literal">SoundManager</code> class is destroyed, it will call <code class="literal">Mix_CloseAudio</code>:</p><div class="informalexample"><pre class="programlisting">SoundManager::~SoundManager()
{
  Mix_CloseAudio();
}</pre></div><p>And that's it for the <code class="literal">SoundManager</code> class.</p></div></div></div>
<div class="section" title="Setting up the basic game objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec43"/>Setting up the basic game objects</h1></div></div></div><p>The majority of the work that went into creating Alien Attack was done in the object classes, while almost <a class="indexterm" id="id474"/>everything else was already <a class="indexterm" id="id475"/>being handled by manager classes in the framework. Here are the most important changes:</p><div class="section" title="GameObject revamped"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec58"/>GameObject revamped</h2></div></div></div><p>The <code class="literal">GameObject</code> base class<a class="indexterm" id="id476"/> has a lot more to it than it previously did.</p><div class="informalexample"><pre class="programlisting">class GameObject
{
public:
  // base class needs virtual destructor
  virtual ~GameObject() {}
  // load from file 
  virtual void load(std::unique_ptr&lt;LoaderParams&gt; const &amp;pParams)=0;
  // draw the object
  virtual void draw()=0;
  // do update stuff
  virtual void update()=0;
  // remove anything that needs to be deleted
  virtual void clean()=0;
  // object has collided, handle accordingly
  virtual void collision() = 0;
  // get the type of the object
  virtual std::string type() = 0;
  // getters for common variables
  Vector2D&amp; getPosition() { return m_position; }
  int getWidth() { return m_width; }
  int getHeight() { return m_height; }
  // scroll along with tile map
  void scroll(float scrollSpeed) { m_position.setX(m_position.getX() - 
  scrollSpeed); }
  // is the object currently being updated?
  bool updating() { return m_bUpdating; }
  // is the object dead?
  bool dead() { return m_bDead; }
  // is the object doing a death animation?
  bool dying() { return m_bDying; }
  // set whether to update the object or not
  void setUpdating(bool updating) { m_bUpdating = updating; }

protected:

  // constructor with default initialisation list
  GameObject() :  m_position(0,0),
  m_velocity(0,0),
  m_acceleration(0,0),
  m_width(0),
  m_height(0),
  m_currentRow(0),
  m_currentFrame(0),
  m_bUpdating(false),
  m_bDead(false),
  m_bDying(false),
  m_angle(0),
  m_alpha(255)
  {
  }
  // movement variables
  Vector2D m_position;
  Vector2D m_velocity;
  Vector2D m_acceleration;
  // size variables
  int m_width;
  int m_height;
  // animation variables
  int m_currentRow;
  int m_currentFrame;
  int m_numFrames;
  std::string m_textureID;
  // common boolean variables
  bool m_bUpdating;
  bool m_bDead;
  bool m_bDying;
  // rotation
  double m_angle;
  // blending
  int m_alpha;
};</pre></div><p>This class now has a lot of the member variables that used to be in <code class="literal">SDLGameObject</code>. New variables for checking whether an object is updating, doing the death animation, or is dead, have been added. <a class="indexterm" id="id477"/>Updating is set to true when an object is within the game screen after scrolling with the game level.</p><p>In place of a regular pointer to <code class="literal">LoaderParams</code> in the load function, an <code class="literal">std::unique_ptr</code> pointer is now used; this is part of the new <a class="indexterm" id="id478"/>
<span class="strong"><strong>C++11 standard</strong></span> and ensures that the pointer is deleted after going out of scope.</p><div class="informalexample"><pre class="programlisting">virtual void load(std::unique_ptr&lt;LoaderParams&gt; const &amp;pParams)=0;</pre></div><p>There are two new functions that each derived object must now implement (whether it's owned or inherited):</p><div class="informalexample"><pre class="programlisting"> // object has collided, handle accordingly
virtual void collision() = 0;

 // get the type of the object
virtual std::string type() = 0;</pre></div></div><div class="section" title="SDLGameObject is now ShooterObject"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec59"/>SDLGameObject is now ShooterObject</h2></div></div></div><p>The <code class="literal">SDLGameObject</code> <a class="indexterm" id="id479"/>class has now been renamed to <code class="literal">ShooterObject</code> and is a lot more specific to this type of game:</p><div class="informalexample"><pre class="programlisting">class ShooterObject : public GameObject
{
public:

  virtual ~ShooterObject() {}// for polymorphism
  virtual void load(std::unique_ptr&lt;LoaderParams&gt; const
  &amp;pParams);
  virtual void draw();
  virtual void update();
  virtual void clean() {}// not implemented in this class
  virtual void collision() {}//not implemented in this class
  virtual std::string type() { return "SDLGameObject"; }

protected:

  // we won't directly create ShooterObject's
  ShooterObject();

  // draw the animation for the object being destroyed
  void doDyingAnimation();

  // how fast will this object fire bullets? with a counter
  int m_bulletFiringSpeed;
  int m_bulletCounter;

  // how fast will this object move?
  int m_moveSpeed;

  // how long will the death animation takes? with a counter
  int m_dyingTime;
  int m_dyingCounter;

  // has the explosion sound played?
  bool m_bPlayedDeathSound;
};</pre></div><p>This class has default implementations for draw and update that can be used in derived classes; they are<a class="indexterm" id="id480"/> essentially the same as the previous <code class="literal">SDLGameObject</code> class, so we will not cover them here. A new function that has been added is <code class="literal">doDyingAnimation</code>. This function is responsible for updating the animation when enemies explode and then setting them to dead so that they can be removed from the game.</p><div class="informalexample"><pre class="programlisting">void ShooterObject::doDyingAnimation()
{
  // keep scrolling with the map
  scroll(TheGame::Instance()-&gt;getScrollSpeed());

  m_currentFrame = int(((SDL_GetTicks() / (1000 / 3)) % 
  m_numFrames));

  if(m_dyingCounter == m_dyingTime)
  {
    m_bDead = true;
  }
  m_dyingCounter++; //simple counter, fine with fixed frame rate
}</pre></div></div><div class="section" title="Player inherits from ShooterObject"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec60"/>Player inherits from ShooterObject</h2></div></div></div><p>The <span class="strong"><strong>Player</strong></span> object now inherits from the new <code class="literal">ShooterObject</code> class and implements its own update function. <a class="indexterm" id="id481"/>Some new game-specific functions and variables have been added:</p><div class="informalexample"><pre class="programlisting">private:

  // bring the player back if there are lives left
  void ressurect();

  // handle any input from the keyboard, mouse, or joystick
  void handleInput();

  // handle any animation for the player
  void handleAnimation();

  // player can be invulnerable for a time
  int m_invulnerable;
  int m_invulnerableTime;
  int m_invulnerableCounter;
};</pre></div><p>The <code class="literal">ressurect</code> function resets the player back to the center of the screen and temporarily<a class="indexterm" id="id482"/> makes the <code class="literal">Player</code> object invulnerable; this is visualized using <code class="literal">alpha</code> of the texture. This function is also responsible for resetting the size value of the texture which is changed in <code class="literal">doDyingAnimation</code> to accommodate for the explosion texture:</p><div class="informalexample"><pre class="programlisting">void Player::ressurect()
{
  TheGame::Instance()-&gt;setPlayerLives(TheGame::Instance()
  -&gt;getPlayerLives() - 1);

  m_position.setX(10);
  m_position.setY(200);
  m_bDying = false;

  m_textureID = "player";

  m_currentFrame = 0;
  m_numFrames = 5;
  m_width = 101;
  m_height = 46;

  m_dyingCounter = 0;
  m_invulnerable = true;
}</pre></div><p>Animation is a big part of the feel of the <code class="literal">Player</code> object; from flashing (when invulnerable), to rotating (when moving in a forward or backward direction). This has led to there being a separate function dedicated to handling animation:</p><div class="informalexample"><pre class="programlisting">void Player::handleAnimation()
{
  // if the player is invulnerable we can flash its alpha to let 
  people know
  if(m_invulnerable)
  {
    // invulnerability is finished, set values back
    if(m_invulnerableCounter == m_invulnerableTime)
    {
      m_invulnerable = false;
      m_invulnerableCounter = 0;
      m_alpha = 255;
    }
    else// otherwise, flash the alpha on and off
    {
      if(m_alpha == 255)
      {
        m_alpha = 0;
      }
      else
      {
        m_alpha = 255;
      }
    }

    // increment our counter
    m_invulnerableCounter++;
  }

  // if the player is not dead then we can change the angle with 
  the velocity to give the impression of a moving helicopter
  if(!m_bDead)
  {
    if(m_velocity.getX() &lt; 0)
    {
      m_angle = -10.0;
    }
    else if(m_velocity.getX() &gt; 0)
    {
      m_angle = 10.0;
    }
    else
    {
      m_angle = 0.0;
    }
  }

  // our standard animation code - for helicopter propellors
  m_currentFrame = int(((SDL_GetTicks() / (100)) % m_numFrames));
}</pre></div><p>The angle and <code class="literal">alpha</code> of<a class="indexterm" id="id483"/> an object are changed using new parameters to the <code class="literal">drawFrame</code> function of <code class="literal">TextureManager</code>:</p><div class="informalexample"><pre class="programlisting">void TextureManager::drawFrame(std::string id, int x, int y, int 
width, int height, int currentRow, int currentFrame, SDL_Renderer 
*pRenderer, double angle, int alpha, SDL_RendererFlip flip)
{
  SDL_Rect srcRect;
  SDL_Rect destRect;
  srcRect.x = width * currentFrame;
  srcRect.y = height * currentRow;
  srcRect.w = destRect.w = width;
  srcRect.h = destRect.h = height;
  destRect.x = x;
  destRect.y = y;

  // set the alpha of the texture and pass in the angle
  SDL_SetTextureAlphaMod(m_textureMap[id], alpha);
  SDL_RenderCopyEx(pRenderer, m_textureMap[id], &amp;srcRect, 
  &amp;destRect, angle, 0, flip);
}</pre></div><p>Finally the <code class="literal">Player::update</code> function ties this all together while also having extra logic to handle when a level is complete:</p><div class="informalexample"><pre class="programlisting">void Player::update()
{
  // if the level is complete then fly off the screen
  if(TheGame::Instance()-&gt;getLevelComplete())
  {
    if(m_position.getX() &gt;= TheGame::Instance()-&gt;getGameWidth())
    {
      TheGame::Instance()-&gt;setCurrentLevel(TheGame::Instance()
      -&gt;getCurrentLevel() + 1);
    }
    else
    {
      m_velocity.setY(0);
      m_velocity.setX(3);
      ShooterObject::update();
      handleAnimation();
    }
  }
  else
  {
    // if the player is not doing its death animation then update 
    it normally
    if(!m_bDying)
    {
      // reset velocity
      m_velocity.setX(0);
      m_velocity.setY(0);

      // get input
      handleInput();
      // do normal position += velocity update
      ShooterObject::update();

      // update the animation
      handleAnimation();
    }
    else // if the player is doing the death animation
    {
      m_currentFrame = int(((SDL_GetTicks() / (100)) % 
      m_numFrames));

      // if the death animation has completed
      if(m_dyingCounter == m_dyingTime)
      {
        // ressurect the player
        ressurect();
      }

      m_dyingCounter++;
    }
  }
}</pre></div><p>Once a level is <a class="indexterm" id="id484"/>complete and the player has flown offscreen, the <a class="indexterm" id="id485"/>
<code class="literal">Player::update</code> function also tells the game to increment the current level:</p><div class="informalexample"><pre class="programlisting">TheGame::Instance()-&gt;setCurrentLevel(TheGame::Instance()-&gt;getCurrentLevel() + 1);</pre></div><p>The <a class="indexterm" id="id486"/>
<code class="literal">Game::setCurrentLevel</code> function<a class="indexterm" id="id487"/> changes the state to <code class="literal">BetweenLevelState</code>:</p><div class="informalexample"><pre class="programlisting">void Game::setCurrentLevel(int currentLevel)
{
  m_currentLevel = currentLevel;
  m_pGameStateMachine-&gt;changeState(new BetweenLevelState());
  m_bLevelComplete = false;
}</pre></div></div><div class="section" title="Lots of enemy types"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec61"/>Lots of enemy types</h2></div></div></div><p>A game such as Alien Attack needs a lot of enemy types to keep things interesting; each with its own behavior. Enemies <a class="indexterm" id="id488"/>should be easy to create and automatically added to the collision detection list. With this in mind, the <code class="literal">Enemy</code> class has now become a base class:</p><div class="informalexample"><pre class="programlisting">// Enemy base class
class Enemy : public ShooterObject
{
public:
  virtual std::string type() { return"Enemy"; }

protected:
  int m_health;

  Enemy() : ShooterObject() {}
  virtual ~Enemy() {} // for polymorphism

};</pre></div><p>All enemy types will derive from this class, but it is important that they do not override the <code class="literal">type</code> method. The reason for this will become clear once we move onto our games collision detection classes. Go ahead and take a look at the enemy types in the Alien Attack source code to see how simple they are to create.</p><div class="mediaobject"><img alt="Lots of enemy types" src="graphics/6821OT_08_10.jpg"/></div></div><div class="section" title="Adding a scrolling background"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec62"/>Adding a scrolling background</h2></div></div></div><p>Scrolling backgrounds are important to 2D games like this; they help give an illusion of depth and movement. This <a class="indexterm" id="id489"/>
<code class="literal">ScrollingBackground</code> class uses two destination rectangles and two source rectangles; one expands <a class="indexterm" id="id490"/>while the other contracts. Once the expanding rectangle has reached its full width, both rectangles are reset and the loop continues:</p><div class="informalexample"><pre class="programlisting">void ScrollingBackground::load(std::unique_ptr&lt;LoaderParams&gt; const &amp;pParams)
{
  ShooterObject::load(std::move(pParams));
  m_scrollSpeed = pParams-&gt;getAnimSpeed();

  m_scrollSpeed = 1;

  m_srcRect1.x = 0;
  m_destRect1.x = m_position.getX();
  m_srcRect1.y = 0;
  m_destRect1.y = m_position.getY();

  m_srcRect1.w = m_destRect1.w = m_srcRect2Width = 
  m_destRect1Width = m_width;
  m_srcRect1.h = m_destRect1.h = m_height;

  m_srcRect2.x = 0;
  m_destRect2.x = m_position.getX() + m_width;
  m_srcRect2.y = 0;
  m_destRect2.y = m_position.getY();

  m_srcRect2.w = m_destRect2.w = m_srcRect2Width = 
  m_destRect2Width = 0;
  m_srcRect2.h = m_destRect2.h = m_height;
}

void ScrollingBackground::draw()
{
  // draw first rect
  SDL_RenderCopyEx(TheGame::Instance()-&gt;getRenderer(), 
  TheTextureManager::Instance()-&gt;getTextureMap()[m_textureID], 
  &amp;m_srcRect1, &amp;m_destRect1, 0, 0, SDL_FLIP_NONE);

  // draw second rect
  SDL_RenderCopyEx(TheGame::Instance()-&gt;getRenderer(), 
  TheTextureManager::Instance()-&gt;getTextureMap()[m_textureID], 
  &amp;m_srcRect2, &amp;m_destRect2, 0, 0, SDL_FLIP_NONE);

}

void ScrollingBackground::update()
{
  if(count == maxcount)
  {
    // make first rectangle smaller
    m_srcRect1.x += m_scrollSpeed;
    m_srcRect1.w -= m_scrollSpeed;
    m_destRect1.w -= m_scrollSpeed;

    // make second rectangle bigger
    m_srcRect2.w += m_scrollSpeed;
    m_destRect2.w += m_scrollSpeed;
    m_destRect2.x -= m_scrollSpeed;

    // reset and start again
    if(m_destRect2.w &gt;= m_width)
    {
      m_srcRect1.x = 0;
      m_destRect1.x = m_position.getX();
      m_srcRect1.y = 0;
      m_destRect1.y = m_position.getY();

      m_srcRect1.w = m_destRect1.w = m_srcRect2Width = 
      m_destRect1Width = m_width;
      m_srcRect1.h = m_destRect1.h = m_height;

      m_srcRect2.x = 0;
      m_destRect2.x = m_position.getX() + m_width;
      m_srcRect2.y = 0;
      m_destRect2.y = m_position.getY();

      m_srcRect2.w = m_destRect2.w = m_srcRect2Width = 
      m_destRect2Width = 0;
      m_srcRect2.h = m_destRect2.h = m_height;
    }
    count = 0;
  }

  count++;
}</pre></div></div></div>
<div class="section" title="Handling bullets"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Handling bullets</h1></div></div></div><p>Most objects in the game fire bullets and they all pretty much need to be checked for collisions against<a class="indexterm" id="id491"/> bullets as well; the bottom line—bullets are important in Alien Attack. The game <a class="indexterm" id="id492"/>has a dedicated <code class="literal">BulletHandler</code> class that handles the creation, destruction, updating, and rendering of bullets.</p><div class="section" title="Two types of bullets"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec63"/>Two types of bullets</h2></div></div></div><p>There are two types of bullets in the game, <code class="literal">PlayerBullet</code> and <code class="literal">EnemyBullet</code>, both of which are handled in the same <a class="indexterm" id="id493"/>
<code class="literal">BulletManager</code> class. Both of the bullet classes are declared and defined in <code class="literal">Bullet.h</code>:</p><div class="informalexample"><pre class="programlisting">class PlayerBullet : public ShooterObject
{
public:

  PlayerBullet() : ShooterObject()
  {
  }

  virtual ~PlayerBullet() {}

  virtual std::string type() { return "PlayerBullet"; }

  virtual void load(std::unique_ptr&lt;LoaderParams&gt; pParams, Vector2D 
  heading)
  {
    ShooterObject::load(std::move(pParams));
    m_heading = heading;
  }

  virtual void draw()
  {
    ShooterObject::draw();
  }

  virtual void collision()
  {
    m_bDead = true;
  }

  virtual void update()
  {
    m_velocity.setX(m_heading.getX());
    m_velocity.setY(m_heading.getY());

    ShooterObject::update();
  }

  virtual void clean()
  {
    ShooterObject::clean();
  }

private:

  Vector2D m_heading;
};

// Enemy Bullet is just a Player Bullet with a different typename
class EnemyBullet : public PlayerBullet
{
public:

  EnemyBullet() : PlayerBullet()
  {
  }

  virtual ~EnemyBullet() {}

  virtual std::string type() { return "EnemyBullet"; }
};</pre></div><p>Bullets are very simple, they just<a class="indexterm" id="id494"/> move in one direction and at a certain speed.</p></div><div class="section" title="The BulletHandler class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec64"/>The BulletHandler class</h2></div></div></div><p>The <code class="literal">BulletHandler</code> class uses two public functions to add bullets:</p><div class="informalexample"><pre class="programlisting">void addPlayerBullet(int x, int y, int width, int height, std::string textureID, int numFrames, Vector2D heading);
void addEnemyBullet(int x, int y, int width, int height, std::string textureID, int numFrames, Vector2D heading);</pre></div><p>The <a class="indexterm" id="id495"/>
<code class="literal">BulletHandler</code> class<a class="indexterm" id="id496"/> is also a singleton. So, if an object wants to add a bullet to the game, it can do so using one of the above functions. Here is an example from the <code class="literal">ShotGlider</code> class:</p><div class="informalexample"><pre class="programlisting">TheBulletHandler::Instance()-&gt;addEnemyBullet(m_position.getX(), m_position.getY() + 15, 16, 16, "bullet2", 1, Vector2D(-10, 0));</pre></div><p>This will add a bullet at the current location of <code class="literal">ShotGlider</code>, with a heading vector of <span class="emphasis"><em>V</em></span>(-10,0).</p><p>Both <code class="literal">add</code> functions are very similar; they create a new instance of <code class="literal">PlayerBullet</code> or <code class="literal">EnemyBullet</code> and then push it into the correct vector. Here are their definitions:</p><div class="informalexample"><pre class="programlisting">void BulletHandler::addPlayerBullet(int x, int y, int width, int 
  height, std::string textureID, int numFrames, Vector2D heading)
{
  PlayerBullet* pPlayerBullet = newPlayerBullet();
  pPlayerBullet-&gt;load(std::unique_ptr&lt;LoaderParams&gt;(new 
  LoaderParams(x, y, width, height, textureID, numFrames)), 
  heading);

  m_playerBullets.push_back(pPlayerBullet);
}

void BulletHandler::addEnemyBullet(int x, int y, int width, int 
height, std::string textureID, int numFrames, Vector2D heading)
{
  EnemyBullet* pEnemyBullet = new EnemyBullet();
  pEnemyBullet-&gt;load(std::unique_ptr&lt;LoaderParams&gt;(new 
  LoaderParams(x, y, width, height, textureID, numFrames)), 
  heading);

  m_enemyBullets.push_back(pEnemyBullet);
}</pre></div><p>A big advantage of having a separate place to store bullets like this, rather than have objects themselves manage their own bullets, is that there is no need to pass objects around just to get their bullets to check collisions against. This <code class="literal">BulletHandler</code> class gives us a centralized location that we can then easily pass to the collision handler.</p><p>The <code class="literal">update</code>
<a class="indexterm" id="id497"/> and <a class="indexterm" id="id498"/>
<code class="literal">draw</code> functions<a class="indexterm" id="id499"/> are essentially just loops that call each bullet's respective functions, however the <code class="literal">update</code> function will also destroy any bullets that have gone off the screen:</p><div class="informalexample"><pre class="programlisting">for (std::vector&lt;PlayerBullet*&gt;::iterator p_it = 
m_playerBullets.begin(); p_it != m_playerBullets.end();)
{
  if((*p_it)-&gt;getPosition().getX() &lt; 0 || (*p_it)
  -&gt;getPosition().getX() &gt;TheGame::Instance()-&gt;getGameWidth()
  || (*p_it)-&gt;getPosition().getY() &lt; 0 || (*p_it)-&gt;
  getPosition().getY() &gt;TheGame::Instance()-&gt;getGameHeight() || 
  (*p_it)-&gt;dead())// if off screen or dead
  {
    delete * p_it; // delete the bullet
    p_it = m_playerBullets.erase(p_it); //remove
  }
  else// continue to update and loop
  {
    (*p_it)-&gt;update();
    ++p_it;
  }
}</pre></div></div></div>
<div class="section" title="Dealing with collisions"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Dealing with collisions</h1></div></div></div><p>With so many bullets flying around and having the <code class="literal">Enemy</code> objects to check collisions against, it is important that there be a separate class that does this collision checking for us. This way we<a class="indexterm" id="id500"/> know where to look if we decide we want to implement a new way of checking for <a class="indexterm" id="id501"/>collisions or optimize the current code. The <code class="literal">Collision.h</code> file contains a static method that checks for collisions between two <code class="literal">SDL_Rect</code> objects:</p><div class="informalexample"><pre class="programlisting">const static int s_buffer = 4;

static bool RectRect(SDL_Rect* A, SDL_Rect* B)
{
  int aHBuf = A-&gt;h / s_buffer;
  int aWBuf = A-&gt;w / s_buffer;

  int bHBuf = B-&gt;h / s_buffer;
  int bWBuf = B-&gt;w / s_buffer;

  // if the bottom of A is less than the top of B - no collision
  if((A-&gt;y + A-&gt;h) - aHBuf &lt;= B-&gt;y + bHBuf)  { return false; }

  // if the top of A is more than the bottom of B = no collision
  if(A-&gt;y + aHBuf &gt;= (B-&gt;y + B-&gt;h) - bHBuf)  { return false; }

  // if the right of A is less than the left of B - no collision
  if((A-&gt;x + A-&gt;w) - aWBuf &lt;= B-&gt;x +  bWBuf) { return false; }

  // if the left of A is more than the right of B - no collision
  if(A-&gt;x + aWBuf &gt;= (B-&gt;x + B-&gt;w) - bWBuf)  { return false; }

  // otherwise there has been a collision
 return true;
}</pre></div><p>The function makes use of a buffer, which is a value that is used to make the rectangles slightly smaller.<a class="indexterm" id="id502"/> In a game such as Alien Attack, exact collision on bounding rectangles would be slightly unfair and also not much fun. With the buffer value, more direct hits are needed before they will be registered as a collision. Here the buffer is set to <code class="literal">4</code>; this will take a fourth off of each side of the rectangle.</p><p>The <code class="literal">Player</code> class will not handle its own collisions. This requires a way to separate out the player from the rest of the <code class="literal">GameObject</code> instants when the level is loaded. The <code class="literal">Level</code> class now stores a pointer to <code class="literal">Player</code>:</p><div class="informalexample"><pre class="programlisting">Player* m_pPlayer;</pre></div><p>With a public getter and setter:</p><div class="informalexample"><pre class="programlisting">Player* getPlayer() { return m_pPlayer; }
void setPlayer(Player* pPlayer) { m_pPlayer = pPlayer; }</pre></div><p>The <code class="literal">LevelParser</code> instance sets this pointer when it loads in <code class="literal">Player</code> from the level file:</p><div class="informalexample"><pre class="programlisting">pGameObject-&gt;load(std::unique_ptr&lt;LoaderParams&gt;(new LoaderParams(x, y, width, height, textureID, numFrames,callbackID, animSpeed)));

if(type == "Player") // check if it's the player
{
  pLevel-&gt;setPlayer(dynamic_cast&lt;Player*&gt;(pGameObject));
}

pObjectLayer-&gt;getGameObjects()-&gt;push_back(pGameObject);</pre></div><p>Another addition to <code class="literal">Level</code> is that it holds a separate <code class="literal">std::vector</code> of <code class="literal">TileLayer*</code> which are tile layers that the game will <a class="indexterm" id="id503"/>check against for collisions. This value is passed in from the <code class="literal">.tmx</code> file and any <code class="literal">TileLayer</code> that needs to be checked for collisions must set <code class="literal">collidable</code> as a property in the tiled application.</p><div class="mediaobject"><img alt="Dealing with collisions" src="graphics/6821OT_08_07.jpg"/></div><p>This also requires a slight alteration in<a class="indexterm" id="id504"/> <code class="literal">LevelParser::parseLevel</code> when checking for object layers, just in case the layer does contain properties (in which case data would no longer be the first child element):</p><div class="informalexample"><pre class="programlisting">else if(e-&gt;FirstChildElement()-&gt;Value() == std::string("data") || (e-&gt;FirstChildElement()-&gt;NextSiblingElement() != 0 &amp;&amp; e-&gt;FirstChildElement()-&gt;NextSiblingElement()-&gt;Value() == std::string("data")))
{
  parseTileLayer(e, pLevel-&gt;getLayers(), pLevel-&gt;getTilesets(), 
  pLevel-&gt;getCollisionLayers());
}</pre></div><p>The <code class="literal">LevelParser</code> instance can now add collision layers to the collision layers array in <code class="literal">parseTileLayer</code>:</p><div class="informalexample"><pre class="programlisting">// local temporary variable
bool collidable = false;

// other code…

for(TiXmlElement* e = pTileElement-&gt;FirstChildElement(); e != NULL; e = e-&gt;NextSiblingElement())
{
  if(e-&gt;Value() == std::string("properties"))
  {
    for(TiXmlElement* property = e-&gt;FirstChildElement(); property != NULL; property = property-&gt;NextSiblingElement())
    {
      if(property-&gt;Value() == std::string("property"))
      {
        if(property-&gt;Attribute("name") == std::string("collidable"))
        {
          collidable = true;
        }
      }
    }
  }

  if(e-&gt;Value() == std::string("data"))
  {
    pDataNode = e;
  }
}

// other code…

// push into collision array if necessary
if(collidable)
{
  pCollisionLayers-&gt;push_back(pTileLayer);
}

pLayers-&gt;push_back(pTileLayer);</pre></div><div class="section" title="Creating a CollisionManager class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec65"/>Creating a CollisionManager class</h2></div></div></div><p>The class<a class="indexterm" id="id505"/> responsible for checking<a class="indexterm" id="id506"/> and handling all of these collisions<a class="indexterm" id="id507"/> is the <code class="literal">CollisionManager</code> class. Here is its declaration:</p><div class="informalexample"><pre class="programlisting">class CollisionManager
{
public:

  void checkPlayerEnemyBulletCollision(Player* pPlayer);
  void checkPlayerEnemyCollision(Player* pPlayer, const 
  std::vector&lt;GameObject*&gt; &amp;objects);
  void checkEnemyPlayerBulletCollision(const 
  std::vector&lt;GameObject*&gt; &amp;objects);
  void checkPlayerTileCollision(Player* pPlayer, const 
  std::vector&lt;TileLayer*&gt; &amp;collisionLayers);
};</pre></div><p>Looking at the source<a class="indexterm" id="id508"/> code you will see that these functions are pretty big, yet they are relatively simple. They loop through each object that requires a collision test, create a rectangle for each,<a class="indexterm" id="id509"/> and then pass it to the static <code class="literal">RectRect</code> function defined in <code class="literal">Collision.h</code>. If a collision occurred then it calls the <code class="literal">collision</code> function for that object. The <code class="literal">checkEnemyPlayerBulletCollision</code>
<a class="indexterm" id="id510"/> and <a class="indexterm" id="id511"/>
<code class="literal">checkPlayerEnemyCollision</code> functions perform an extra check to see if the object is actually of <code class="literal">Enemy</code> type:</p><div class="informalexample"><pre class="programlisting">if(objects[i]-&gt;type() != std::string("Enemy") || !objects[i]-&gt;updating())
{
 continue;
}</pre></div><p>If it is not, then it does not check the collision. This is why it is important that the <code class="literal">Enemy</code> subtypes do not override the <a class="indexterm" id="id512"/>
<code class="literal">type</code> function or if they do, their type must also be added to this check. This condition also checks whether the object is updating or not; if it is not, then it is offscreen and does not need to be checked against for collision.</p><p>Checking for collision against tiles requires a similar method to working out where to start drawing the tiles from, which was implemented in the <code class="literal">TileLayer::render</code> function. Here is the <code class="literal">checkPlayerTileCollision</code> definition:</p><div class="informalexample"><pre class="programlisting">void CollisionManager::checkPlayerTileCollision(Player* pPlayer, 
  const std::vector&lt;TileLayer*&gt; &amp;collisionLayers)
{
  // iterate through collision layers
  for(std::vector&lt;TileLayer*&gt;::const_iterator it = 
  collisionLayers.begin(); it != collisionLayers.end(); ++it)
  {
    TileLayer* pTileLayer = (*it);
    std::vector&lt;std::vector&lt;int&gt;&gt; tiles = pTileLayer-
    &gt;getTileIDs();

    // get this layers position
    Vector2D layerPos = pTileLayer-&gt;getPosition();

    int x, y, tileColumn, tileRow, tileid = 0;

    // calculate position on tile map
    x = layerPos.getX() / pTileLayer-&gt;getTileSize();
    y = layerPos.getY() / pTileLayer-&gt;getTileSize();

    // if moving forward or upwards
    if(pPlayer-&gt;getVelocity().getX() &gt;= 0 || pPlayer-
    &gt;getVelocity().getY() &gt;= 0)
    {
      tileColumn = ((pPlayer-&gt;getPosition().getX() + pPlayer-
      &gt;getWidth()) / pTileLayer-&gt;getTileSize());
      tileRow = ((pPlayer-&gt;getPosition().getY() + pPlayer-
      &gt;getHeight()) 
      / pTileLayer-&gt;getTileSize());
      tileid = tiles[tileRow + y][tileColumn + x];
    }
    else if(pPlayer-&gt;getVelocity().getX() &lt; 0 || pPlayer-
    &gt;getVelocity().getY() &lt; 0) // if moving backwards or downwards
    {
      tileColumn = pPlayer-&gt;getPosition().getX() / pTileLayer-
      &gt;getTileSize();
      tileRow = pPlayer-&gt;getPosition().getY() / pTileLayer-
      &gt;getTileSize();
      tileid = tiles[tileRow + y][tileColumn + x];
    }
    if(tileid != 0) // if the tile id not blank then collide
    {
      pPlayer-&gt;collision();
    }
  }
}</pre></div></div></div>
<div class="section" title="Possible improvements"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Possible improvements</h1></div></div></div><p>Alien Attack is a pretty robust game at the moment; we highly recommend looking through the source code and becoming familiar with every aspect of it. Once you have a good understanding of most of the areas of the game, it is a lot easier to see where certain areas could be enhanced. Here are some ideas that could be added to improve the game:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Bullets<a class="indexterm" id="id513"/> could be created at the start of a level and stored in an object pool; so rather than creating and deleting bullets all the time they can be pulled from and put back into the object pool. The main advantage of this approach is that the creation and destruction of objects can be quite expensive when it comes to performance. Eliminating this while the game is running could give a real performance boost.</li><li class="listitem" style="list-style-type: disc">Collision detection could be optimized further, possibly through the addition of a <span class="strong"><strong>Quadtree</strong></span><a class="indexterm" id="id514"/> to stop unnecessary collision checks.</li><li class="listitem" style="list-style-type: disc">The source code has a few areas that use string comparisons to check types. This can be a bit of a performance hog, so other options such as using <code class="literal">enums</code> as types may be a better option.</li></ul></div><p>You may have noticed areas yourself that you feel you could improve upon. Working on these within the context of a game, where you can test the results, is a great learning experience.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Summary</h1></div></div></div><p>The framework has been successfully used to create a game—Alien Attack. Throughout this chapter, the most important parts of the game were covered, along with a short explanation of why they were designed in such a way. With the source code for this game available, there is now a great project to start practicing with.</p></div></body></html>