<html><head></head><body><div class="appendix" title="Appendix&#xA0;A.&#xA0;Rational and Complex Numbers"><div class="titlepage"><div><div><h1 class="title"><a id="appA"/>Appendix A. Rational and Complex Numbers</h1></div></div></div><p>This Appendix defines the <code class="literal">Rational</code> and <code class="literal">Complex</code> classes from the <span class="emphasis"><em>Converters</em></span> section in the previous chapter.</p><div class="section" title="Rational numbers"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec79"/>Rational numbers</h1></div></div></div><p>A <span class="strong"><strong>rational </strong></span>
<span class="strong"><strong>number</strong></span> can be expressed as a fraction of two integers, called the <span class="strong"><strong>numerator</strong></span> and <span class="strong"><strong>denominator</strong></span>.</p><p>
<span class="strong"><strong>Rational.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class NotaRationalNumber : public exception { &#13;
    public: &#13;
      NotaRationalNumber() {/* Empty. */} &#13;
  }; &#13;
</pre><p>The default constructor initializes the numerator and denominator to 0 and 1, respectively. The second constructor takes a string and throws a <code class="literal">NotaRationalNumber</code> exception if the string does not hold a valid rational number. The copy constructor and the assignment operator take another rational number. The <code class="literal">String</code> conversion operator returns the rational number as a string:</p><pre class="programlisting">  class Rational { &#13;
    public: &#13;
      Rational(int numerator = 0, int denominator = 1); &#13;
      Rational(const String&amp; text); &#13;
      Rational(const Rational &amp;rational); &#13;
      Rational operator=(const Rational &amp;complex); &#13;
      operator String() const; &#13;
      bool operator==(const Rational &amp;rational) const; &#13;
      bool operator!=(const Rational &amp;rational) const; &#13;
      bool operator&lt; (const Rational &amp;rational) const; &#13;
      bool operator&lt;=(const Rational &amp;rational) const; &#13;
      bool operator&gt; (const Rational &amp;rational) const; &#13;
      bool operator&gt;=(const Rational &amp;rational) const; &#13;
      Rational operator+(const Rational &amp;rational) const; &#13;
      Rational operator-(const Rational &amp;rational) const; &#13;
      Rational operator*(const Rational &amp;rational) const; &#13;
      Rational operator/(const Rational &amp;rational) const; &#13;
</pre><p>A rational number is always normalized when it has been created by the constructor or any of the arithmetic operators: the numerator and the denominator are divided by their <span class="strong"><strong>Greatest Common Divisor</strong></span> (<span class="strong"><strong>GCD</strong></span>):</p><pre class="programlisting">    private: &#13;
      void Normalize(); &#13;
      int GCD(int iNum1, int iNum2); &#13;
      int numerator, denominator; &#13;
  }; &#13;
}; &#13;
</pre><p>
<span class="strong"><strong>Rational.cpp</strong></span>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
</pre><p>The default constructor initializes the numerator and the denominator, and throws an exception if the denominator is zero. This constructor and the next constructor that takes a string are actually the only places where the denominator can be zero. The following constructors and arithmetic operators always produce a rational number with non-zero denominators:</p><pre class="programlisting">namespace SmallWindows { &#13;
  Rational::Rational(int numerator /* = 0 */, &#13;
                     int denominator /* = 1 */) &#13;
   :numerator(numerator), &#13;
    denominator(denominator) { &#13;
    if (denominator == 0) { &#13;
      throw NotaRationalNumber(); &#13;
    } &#13;
    Normalize(); &#13;
  } &#13;
</pre><p>Text can hold a rational number in two formats: as an integer followed by a slash (<span class="strong"><strong>/</strong></span>) and another integer, or as a single integer. We start by initializing the numerator and the denominator to 0 and 1:</p><pre class="programlisting">  Rational::Rational(const String&amp; text) &#13;
   :numerator(0), &#13;
    denominator(1) { &#13;
    String trimText(Trim(text)); &#13;
</pre><p>First, we try two integers and a slash; we read the numerator, slash, and denominator. Before the slash we set the <code class="literal">skipws</code> flag, which causes the stream to skip any potential white spaces before the slash. If we have reached the end of the line, the denominator is not 0, the character read into the <code class="literal">slash</code> variable really is a slash, the text holds a rational number, and we have read the numerator and denominator, then we are done and we return:</p><pre class="programlisting">    { IStringStream totalStream(trimText); &#13;
      TCHAR slash; &#13;
      totalStream &gt;&gt; numerator &gt;&gt; setiosflags(ios::skipws) &#13;
                  &gt;&gt; slash &gt;&gt; denominator; &#13;
      if (totalStream.eof() &amp;&amp; (denominator != 0) &amp;&amp; &#13;
          (slash == TEXT('/'))) { &#13;
        Normalize(); &#13;
        return; &#13;
      } &#13;
    } &#13;
</pre><p>If using two integers and a slash does not work, we try the case of a single integer. We create a new stream and read the numerator. If we have reached the end of the stream after that, the string holds a valid integer. We let the numerator hold its initialized value, which was 1, and return.</p><pre class="programlisting">    { IStringStream numeratorStream(trimText); &#13;
      numeratorStream &gt;&gt; numerator; &#13;
      if (numeratorStream.eof()) { &#13;
        return; &#13;
      } &#13;
    } &#13;
</pre><p>If two integers and a slash as well as a single integer both failed, we have to draw the conclusion that the string does not hold a valid rational number, and we throw a <code class="literal">NotaRationalNumber</code> exception:</p><pre class="programlisting">    throw NotaRationalNumber(); &#13;
  } &#13;
</pre><p>The copy constructor simply copies the numerator and denominator of the rational number:</p><pre class="programlisting">  Rational::Rational(const Rational &amp;rational) &#13;
   :numerator(rational.numerator), &#13;
    denominator(rational.denominator) { &#13;
    // Empty. &#13;
  } &#13;
</pre><p>The assignment operator also copies the numerator and denominator of the rational number and returns its own <code class="literal">Rational</code> object (<code class="literal">*this</code>):</p><pre class="programlisting">  Rational Rational::operator=(const Rational &amp;rational) { &#13;
    numerator = rational.numerator; &#13;
    denominator = rational.denominator; &#13;
    return *this; &#13;
  } &#13;
</pre><p>The <code class="literal">String</code> conversion operator creates an <code class="literal">OStringStream</code> object and looks into the denominator. If it is 1, the rational number can be expressed as a single integer; otherwise, it needs to be expressed as a fraction of the numerator and denominator. Finally, the stream is converted into a string that is returned:</p><pre class="programlisting">  Rational::operator String() const { &#13;
    OStringStream outStream; &#13;
 &#13;
    if (denominator == 1) { &#13;
      outStream &lt;&lt; numerator; &#13;
    } &#13;
    else { &#13;
      outStream &lt;&lt; numerator &lt;&lt; TEXT("/") &lt;&lt; denominator; &#13;
    } &#13;
 &#13;
    return outStream.str(); &#13;
  } &#13;
</pre><p>As rational numbers are always normalized, we can conclude that two rational numbers are equal if they have the same numerator and denominator:</p><pre class="programlisting">  bool Rational::operator==(const Rational &amp;rational) const { &#13;
    return (numerator == rational.numerator) &amp;&amp; &#13;
           (denominator == rational.denominator); &#13;
  } &#13;
 &#13;
  bool Rational::operator!=(const Rational &amp;rational) const { &#13;
    return !(*this == rational); &#13;
  } &#13;
</pre><p>When deciding whether a rational number is smaller than another rational number, in order not to involve floating values, we multiply both sides by the denominator and compare the products:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_Appendix_01.jpg" alt="Rational numbers"/></div><p>
</p><pre class="programlisting">  bool Rational::operator&lt;(const Rational &amp;rational) const { &#13;
    return ((numerator * rational.denominator) &lt; &#13;
            (rational.numerator * denominator)); &#13;
  } &#13;
 &#13;
  bool Rational::operator&lt;=(const Rational &amp;rational) const { &#13;
    return ((*this &lt; rational) || (*this == rational)); &#13;
  } &#13;
 &#13;
  bool Rational::operator&gt;(const Rational &amp;rational) const { &#13;
    return !(*this &lt;= rational); &#13;
  } &#13;
 &#13;
  bool Rational::operator&gt;=(const Rational &amp;rational) const { &#13;
    return !(*this &lt; rational); &#13;
  } &#13;
</pre><p>When adding two rational numbers, we multiply the numerator by the opposite denominator in each term:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_Appendix_02.jpg" alt="Rational numbers"/></div><p>
</p><pre class="programlisting"> &#13;
  Rational Rational::operator+(const Rational &amp;rational) const { &#13;
    Rational result((numerator * rational.denominator) + &#13;
                    (rational.numerator * denominator), &#13;
                    denominator * rational.denominator); &#13;
    result.Normalize(); &#13;
    return result; &#13;
  } &#13;
</pre><p>When subtracting two rational numbers, we also multiply the numerator by the opposite denominator in each term:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_Appendix_03.jpg" alt="Rational numbers"/></div><p>
</p><pre class="programlisting"> &#13;
  Rational Rational::operator-(const Rational &amp;rational) const { &#13;
    Rational result((numerator * rational.denominator) - &#13;
                    (rational.numerator * denominator), &#13;
                    denominator * rational.denominator); &#13;
&#13;
&#13;
    result.Normalize(); &#13;
    return result; &#13;
  } &#13;
</pre><p>When multiplying two rational numbers, we simply multiply the numerators and denominators:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_Appendix_04.jpg" alt="Rational numbers"/></div><p>
</p><pre class="programlisting">  Rational Rational::operator*(const Rational &amp;rational) const { &#13;
    Rational result(numerator * rational.numerator, &#13;
                    denominator * rational.denominator); &#13;
    result.Normalize(); &#13;
    return result; &#13;
  } &#13;
</pre><p>When dividing two rational numbers, we invert the second operand and then multiply the numerators and denominators:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_Appendix_05.jpg" alt="Rational numbers"/></div><p>
</p><pre class="programlisting">  Rational Rational::operator/(const Rational &amp;rational) const { &#13;
    assert(rational.numerator != 0); &#13;
    Rational result(numerator * rational.denominator, &#13;
                    denominator * rational.numerator); &#13;
    result.Normalize(); &#13;
    return result; &#13;
  } &#13;
</pre><p>When normalizing the rational number, we first look into the numerator. If it is 0, we set the denominator to 1 regardless of its previous value and return:</p><pre class="programlisting">  void Rational::Normalize() { &#13;
    if (numerator == 0) { &#13;
      denominator = 1; &#13;
      return; &#13;
    } &#13;
</pre><p>However, if the numerator is not 0, we look into the denominator. If it is less than 0, we switch the sign of both the numerator and denominator so that the denominator is always greater than 0:</p><pre class="programlisting">    if (denominator &lt; 0) { &#13;
      numerator = -numerator; &#13;
      denominator = -denominator; &#13;
    } &#13;
</pre><p>Then we calculate the Greatest Common Divisor by calling <code class="literal">GCD</code>, and then we divide both the numerator and denominator by the Greatest Common Divisor:</p><pre class="programlisting">    int gcd = GCD(abs(numerator), denominator); &#13;
    numerator /= gcd; &#13;
    denominator /= gcd; &#13;
  } &#13;
</pre><p>The <code class="literal">GCD</code> method calls itself recursively by comparing the numbers and subtracting the smaller number from the larger number. When they are equal, we return the number. The GCD algorithm is regarded as the world's oldest non-trivial algorithm.</p><pre class="programlisting">  int Rational::GCD(int number1, int number2) { &#13;
    if (number1 &gt; number2) { &#13;
      return GCD(number1 - number2, number2); &#13;
    } &#13;
    else if (number1 &lt; number2) { &#13;
      return GCD(number1, number2 - number1); &#13;
    } &#13;
    else { &#13;
      return number1; &#13;
    } &#13;
  } &#13;
}; &#13;
</pre></div></div>
<div class="section" title="Complex numbers"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec80"/>Complex numbers</h1></div></div></div><p>A <span class="strong"><strong>complex </strong></span>
<span class="strong"><strong>number</strong></span>
<span class="emphasis"><em> z</em></span> = <span class="emphasis"><em>x</em></span> + <span class="emphasis"><em>yi</em></span> is the sum of a real number <span class="emphasis"><em>x</em></span> and a real number <span class="emphasis"><em>y</em></span> multiplied by the <span class="strong"><strong>imaginary unit</strong></span>
<span class="emphasis"><em>i</em></span>, <span class="emphasis"><em>i</em></span>
<sup>2</sup> = -1 ⇒ <span class="emphasis"><em>i</em></span> = ±√(-1) , which is the solution of the equation <span class="emphasis"><em>x</em></span>
<sup>2</sup> + 1 = 0.</p><p>
<span class="strong"><strong>Complex.h</strong></span>
</p><pre class="programlisting">namespace SmallWindows { &#13;
  class NotaComplexNumber : public exception { &#13;
    public: &#13;
      NotaComplexNumber() {/* Empty. */} &#13;
  }; &#13;
 &#13;
  extern double Square(double value); &#13;
</pre><p>The constructors, assignment operators, and the <code class="literal">String</code> conversion operator are similar to their counterparts in <code class="literal">Rational</code>:</p><pre class="programlisting">  class Complex { &#13;
    public: &#13;
      Complex(double x = 0, double y = 0); &#13;
      Complex(const Complex &amp;complex); &#13;
      Complex operator=(const Complex &amp;complex); &#13;
      bool ReadStream(const String&amp; text); &#13;
      Complex(const String&amp; text); &#13;
      operator String() const; &#13;
</pre><p>When comparing two complex number, their absolute values (refer to <code class="literal">Abs</code>) are compared.</p><pre class="programlisting">      bool operator==(const Complex &amp;complex) const; &#13;
      bool operator!=(const Complex &amp;complex) const; &#13;
      bool operator&lt;(const Complex &amp;complex) const; &#13;
      bool operator&lt;=(const Complex &amp;complex) const; &#13;
      bool operator&gt;(const Complex &amp;complex) const; &#13;
      bool operator&gt;=(const Complex &amp;complex) const; &#13;
</pre><p>The arithmetic operators apply to complex numbers and double values:</p><pre class="programlisting">      Complex operator+=(double x); &#13;
      Complex operator+=(Complex &amp;complex); &#13;
      friend Complex operator+(double x, const Complex &amp;complex); &#13;
      friend Complex operator+(const Complex &amp;complex, double x); &#13;
      friend Complex operator+(const Complex &amp;complex1, &#13;
                               const Complex &amp;complex2); &#13;
 &#13;
      Complex operator-=(double x); &#13;
      Complex operator-=(Complex &amp;complex); &#13;
      friend Complex operator-(double x, const Complex &amp;complex); &#13;
      friend Complex operator-(const Complex &amp;complex, double x); &#13;
      friend Complex operator-(const Complex &amp;complex1, &#13;
                               const Complex &amp;complex2); &#13;
 &#13;
      Complex operator*=(double x); &#13;
      Complex operator*=(Complex &amp;complex); &#13;
      friend Complex operator*(double x, const Complex &amp;complex); &#13;
      friend Complex operator*(const Complex &amp;complex, double x); &#13;
      friend Complex operator*(const Complex &amp;complex1, &#13;
                               const Complex &amp;complex2); &#13;
 &#13;
      Complex operator/=(double x); &#13;
      Complex operator/=(Complex &amp;complex); &#13;
      friend Complex operator/(double x, const Complex &amp;complex); &#13;
      friend Complex operator/(const Complex &amp;complex, double x); &#13;
      friend Complex operator/(const Complex &amp;complex1, &#13;
                               const Complex &amp;complex2); &#13;
</pre><p>The absolute value of a complex number (and its value converted to a <code class="literal">double</code>) is the Pythagoras theorem of the real and imaginary part, that is, the square root of the sum of the squares of the parts:</p><pre class="programlisting">      double Abs() const {return sqrt(Square(x) + Square(y));} &#13;
      operator double() const {return Abs();} &#13;
 &#13;
    private: &#13;
      double x, y; &#13;
  }; &#13;
}; &#13;
</pre><p>
<span class="strong"><strong>Complex.cpp</strong></span>
</p><pre class="programlisting">#include "SmallWindows.h" &#13;
 &#13;
namespace SmallWindows { &#13;
  double Square(double value) { &#13;
    return value * value; &#13;
  } &#13;
 &#13;
  Complex::Complex(double x, double y) &#13;
   :x(x), y(y) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Complex::Complex(const Complex &amp;complex) &#13;
   :x(complex.x), &#13;
    y(complex.y) { &#13;
    // Empty. &#13;
  } &#13;
 &#13;
  Complex Complex::operator=(const Complex &amp;complex) { &#13;
    x = complex.x; &#13;
    y = complex.y; &#13;
    return *this; &#13;
  } &#13;
</pre><p>When interpreting a text holding a rational number, we read the text from a stream, and we need some auxiliary functions to start with. The <code class="literal">ReadWhiteSpaces</code> method reads (and disposes of) all white spaces at the beginning of the stream:</p><pre class="programlisting">  void ReadWhiteSpaces(IStringStream&amp; inStream) { &#13;
    while (true) { &#13;
      TCHAR tChar = inStream.peek(); &#13;
&#13;
&#13;
 &#13;
      if ((tChar &gt;= 0) &amp;&amp; (tChar &lt;= 255) &amp;&amp; isspace(tChar)) { &#13;
        inStream.get(); &#13;
      } &#13;
      else { &#13;
        break; &#13;
      } &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">Peek</code> method reads the white spaces and returns the zero character (\0) if it has reached the end of the stream. If not, we look into what comes next in the stream by calling <code class="literal">peek</code>, and return its resulting value. Note that <code class="literal">peek</code> does not consume the character from the stream; it just checks out the next character:</p><pre class="programlisting">  TCHAR Peek(IStringStream&amp; inStream) { &#13;
    ReadWhiteSpaces(inStream); &#13;
 &#13;
    if (inStream.eof()) { &#13;
      return TEXT('\0'); &#13;
    } &#13;
    else { &#13;
      return (TCHAR) inStream.peek(); &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">ReadI</code> method verifies whether the next character in the stream is <span class="strong"><strong>i</strong></span> or <span class="strong"><strong>I</strong></span>. If it is, it reads the character from the stream and returns <code class="literal">true</code>:</p><pre class="programlisting">bool ReadI(IStringStream&amp; inStream) { &#13;
    if (tolower(Peek(inStream)) == TEXT('i')) { &#13;
      inStream.get(); &#13;
      return true; &#13;
    }  &#13;
    return false; &#13;
  } &#13;
</pre><p>The <code class="literal">ReadSign</code> method verifies that the next character in the stream is a plus or minus sign. If it is, it reads the character from the stream, sets the sign parameter to <span class="strong"><strong>+</strong></span> or <span class="strong"><strong>-</strong></span>, and returns <code class="literal">true</code>:</p><pre class="programlisting">  bool ReadSign(IStringStream&amp; inStream, TCHAR&amp; sign) { &#13;
    TCHAR tChar = Peek(inStream); &#13;
     &#13;
    switch (tChar) { &#13;
      case TEXT('+'): &#13;
        inStream.get(); &#13;
        sign = TEXT('+'); &#13;
        return true; &#13;
 &#13;
      case TEXT('-'): &#13;
        inStream.get(); &#13;
        sign = TEXT('-'); &#13;
        return true; &#13;
 &#13;
      default: &#13;
        return false; &#13;
    } &#13;
  } &#13;
</pre><p>The <code class="literal">ReadValue</code> method verifies that the next two characters in the stream are a plus or a minus sign followed by a digit or a dot, or whether the first character is a digit or a dot. If the latter is the case, it reads the <code class="literal">value</code> parameter from the beginning of the stream and returns <code class="literal">true</code>:</p><pre class="programlisting">  bool ReadValue(IStringStream&amp; inStream, double&amp; value) { &#13;
    TCHAR tChar = Peek(inStream); &#13;
 &#13;
    if ((tChar == TEXT('+')) || (tChar == TEXT('-'))) {       &#13;
      inStream.get(); &#13;
      tChar = Peek(inStream); &#13;
      inStream.unget(); &#13;
 &#13;
      if (isdigit(tChar) || (tChar == TEXT('.'))) {         &#13;
        inStream &gt;&gt; value; &#13;
        return true; &#13;
      } &#13;
    } &#13;
    else if (isdigit(tChar) || (tChar == TEXT('.'))) { &#13;
      inStream &gt;&gt; value; &#13;
      return true; &#13;
    } &#13;
 &#13;
    return false; &#13;
  } &#13;
</pre><p>The <code class="literal">EndOfLine</code> method simply returns <code class="literal">true</code> if the next character in the stream is the zero character (\0), in which case we have reached the end of the string:</p><pre class="programlisting">  bool EndOfLine(IStringStream&amp; inStream) { &#13;
    return Peek(inStream) == TEXT('\0'); &#13;
  } &#13;
</pre><p>Now we are ready to interpret a string as a rational number. We have the following ten cases, where <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> are real values, <span class="emphasis"><em>i</em></span> is the imaginary unit, and ± is plus or minus. All ten cases represent valid complex numbers:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="emphasis"><em>x</em></span> ± <span class="emphasis"><em>yi</em></span></li><li class="listitem"><span class="emphasis"><em>x</em></span> ± ±<span class="emphasis"><em>i</em></span></li><li class="listitem"><span class="emphasis"><em>x</em></span> ±<span class="emphasis"><em> i</em></span></li><li class="listitem"><span class="emphasis"><em>yi</em></span> ±<span class="emphasis"><em> x</em></span></li><li class="listitem">±<span class="emphasis"><em>i</em></span> ±<span class="emphasis"><em> x</em></span></li><li class="listitem"><span class="emphasis"><em>i</em></span> ±<span class="emphasis"><em> x</em></span></li><li class="listitem"><span class="emphasis"><em>yi</em></span></li><li class="listitem">±<span class="emphasis"><em>i</em></span></li><li class="listitem"><span class="emphasis"><em>i</em></span></li><li class="listitem"><span class="emphasis"><em>x</em></span></li></ol></div><p>The <code class="literal">ReadStream</code> method creates an input stream from the text and tries to interpret it as one of the preceding ten cases. The idea is that we read the stream and try one part of the potential complex number at a time:</p><pre class="programlisting">  bool Complex::ReadStream(const String&amp; text) { &#13;
    IStringStream inStream(Trim(text)); &#13;
    double value1, value2; &#13;
    TCHAR sign1, sign2; &#13;
</pre><p>If the stream is made up of a value, a sign, another value, and i or I, we set <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> in accordance with case 1 (<span class="emphasis"><em>x</em></span> ± <span class="emphasis"><em>yi</em></span>) and return <code class="literal">true</code>. The <span class="emphasis"><em>y</em></span> field is negative if the sign is minus. However, the second value may also be negative, in which case <span class="emphasis"><em>y</em></span>is positive:</p><pre class="programlisting">    if (ReadValue(inStream, value1)) { &#13;
      if (ReadSign(inStream, sign1)) { &#13;
        if (ReadValue(inStream, value2) &amp;&amp; ReadI(inStream) &amp;&amp; &#13;
            EndOfLine(inStream)) { &#13;
          x = value1; &#13;
          y = (sign1 == TEXT('-')) ? -value2 : value2; &#13;
          return true; &#13;
        } &#13;
</pre><p>If the sign is not followed by a value, but by another sign and i or I, case 2 (<span class="emphasis"><em>x</em></span> ± ±<span class="emphasis"><em>i</em></span>) applies and we return <code class="literal">true</code>. In this case, we actually have to adjust the value of <span class="emphasis"><em>y</em></span> twice in accordance with both signs:</p><pre class="programlisting">        else if (ReadSign(inStream, sign2)) { &#13;
          if (ReadI(inStream) &amp;&amp; EndOfLine(inStream)) { &#13;
            x = value1; &#13;
            y = (sign1 == TEXT('-')) ? -1 : 1; &#13;
            y = (sign2 == TEXT('-')) ? -y : y; &#13;
            return true; &#13;
          } &#13;
        } &#13;
</pre><p>If the sign is not followed by a value or another sign, but by i or I, case 3 (<span class="emphasis"><em>x</em></span> ± <span class="emphasis"><em>i</em></span>) applies and we return <code class="literal">true</code>:</p><pre class="programlisting">        else if (ReadI(inStream) &amp;&amp; EndOfLine(inStream)) { &#13;
          x = value1; &#13;
          y = (sign1 == TEXT('-')) ? -1 : 1; &#13;
          return true; &#13;
        } &#13;
      } &#13;
</pre><p>If the value is not followed by a sign but by i or I, another sign, and another value, case 4 (<span class="emphasis"><em>yi</em></span> ± <span class="emphasis"><em>x</em></span>) applies and we return <code class="literal">true</code>:</p><pre class="programlisting">      else if (ReadI(inStream)) { &#13;
        if (ReadSign(inStream, sign1)) { &#13;
          if (ReadValue(inStream, value2) &amp;&amp; EndOfLine(inStream)){ &#13;
            y = value1; &#13;
            x = (sign1 == TEXT('-')) ? -value2 : value2; &#13;
            return true; &#13;
          } &#13;
        } &#13;
</pre><p>If the value is followed by i or I and nothing else, case 7 (<span class="emphasis"><em>yi</em></span>) applies and we return <code class="literal">true</code>:</p><pre class="programlisting">        else if(EndOfLine(inStream)) { &#13;
          y = value1; &#13;
          x = 0; &#13;
          return true; &#13;
        } &#13;
      } &#13;
</pre><p>If the value is followed by nothing else, case 10 (<span class="emphasis"><em>x</em></span>) applies and we return <code class="literal">true</code>:</p><pre class="programlisting">      else if (EndOfLine(inStream)) { &#13;
        x = value1; &#13;
        y = 0; &#13;
        return true; &#13;
      } &#13;
    } &#13;
</pre><p>If the stream does not start with a value, but with a sign followed by i or I, another sign and another value, case 5 (±<span class="emphasis"><em>i</em></span> ± <span class="emphasis"><em>x</em></span>) applies and we return <code class="literal">true</code>:</p><pre class="programlisting">    else if (ReadSign(inStream, sign1)) { &#13;
      if (ReadI(inStream)) { &#13;
        if (ReadSign(inStream, sign2)) { &#13;
          if (ReadValue(inStream, value2) &amp;&amp; EndOfLine(inStream)){ &#13;
            y = (sign1 == TEXT('-')) ? -1 : 1; &#13;
            x = (sign2 == TEXT('-')) ? -value2 : value2; &#13;
            return true; &#13;
          } &#13;
        } &#13;
</pre><p>If the stream starts with a sign followed by i or I and nothing else, case 8 (±<span class="emphasis"><em>i</em></span>) applies and we return <code class="literal">true</code>:</p><pre class="programlisting">        else if (EndOfLine(inStream)) { &#13;
          y = (sign1 == TEXT('-')) ? -1 : 1; &#13;
          x = 0; &#13;
          return true; &#13;
        } &#13;
      } &#13;
    } &#13;
</pre><p>If the stream does not start with a value or a sign, but with i or I followed by a sign and a value, case 6 (<span class="emphasis"><em>i</em></span> ± <span class="emphasis"><em>x</em></span>) applies and we return <code class="literal">true</code>:</p><pre class="programlisting">    else if (ReadI(inStream)) { &#13;
      if (ReadSign(inStream, sign2)) { &#13;
        if (ReadValue(inStream, value2) &amp;&amp; EndOfLine(inStream)) { &#13;
          y = 1; &#13;
          x = (sign2 == TEXT('-')) ? -value2 : value2; &#13;
          return true; &#13;
        } &#13;
      } &#13;
</pre><p>If the stream is made up by i or I and nothing else, case 9 (<span class="emphasis"><em>i</em></span>) applies and we return <code class="literal">true</code>:</p><pre class="programlisting">      else if (EndOfLine(inStream)) { &#13;
        y = 1; &#13;
        x = 0; &#13;
        return true; &#13;
      } &#13;
    } &#13;
</pre><p>Finally, if none of the above cases apply, the text does not hold a complex number and we return <code class="literal">false</code>:</p><pre class="programlisting">    return false; &#13;
  } &#13;
</pre><p>The constructor that takes a text simply calls <code class="literal">ReadStream</code> and throws a <code class="literal">NotaComplexNumber</code> exception if <code class="literal">ReadStream</code> returns <code class="literal">false</code>. However, if <code class="literal">ReadStream</code> returns <code class="literal">true</code>, <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> are set to the appropriate values:</p><pre class="programlisting">  Complex::Complex(const String&amp; text) { &#13;
    if (!ReadStream(text)) { &#13;
      throw NotaComplexNumber(); &#13;
    } &#13;
  } &#13;
</pre><p>In the <code class="literal">String</code> conversion operator, we look into several different cases:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="emphasis"><em>x</em></span> +<span class="emphasis"><em> i</em></span></li><li class="listitem"><span class="emphasis"><em>x</em></span> -<span class="emphasis"><em> i</em></span></li><li class="listitem"><span class="emphasis"><em>x</em></span> ±<span class="emphasis"><em> i</em></span></li><li class="listitem"><span class="emphasis"><em>x</em></span></li><li class="listitem">+<span class="emphasis"><em>i</em></span></li><li class="listitem">-<span class="emphasis"><em>i</em></span></li><li class="listitem"><span class="emphasis"><em>yi</em></span></li><li class="listitem">0</li></ol></div><p>If the real part <span class="emphasis"><em>x</em></span> is not 0, we write its value on the stream and look into the first four cases with regard to the imaginary part, <span class="emphasis"><em>y</em></span>. If <span class="emphasis"><em>y</em></span> is plus or minus 1, we simply write <code class="literal">+i</code> or <code class="literal">-i</code>. If it is not plus or minus 1, and not 0, we write its value with the <code class="literal">showpos</code> flag, which forces the plus sign to be present in the case of a positive value. Finally, if <span class="emphasis"><em>y</em></span> is 0, we do not write it at all:</p><pre class="programlisting">  Complex::operator String() const { &#13;
    OStringStream outStream; &#13;
 &#13;
    if (x != 0) { &#13;
      if (y == 1) { &#13;
        outStream &lt;&lt; x &lt;&lt; TEXT("+i"); &#13;
      } &#13;
      else if (y == -1) { &#13;
        outStream &lt;&lt; x &lt;&lt; TEXT("-i"); &#13;
      } &#13;
      else if (y != 0) { &#13;
        outStream &lt;&lt; x &lt;&lt; setiosflags(ios::showpos) &#13;
                  &lt;&lt; y &lt;&lt; TEXT("i"); &#13;
      } &#13;
      else { &#13;
        outStream &lt;&lt; x; &#13;
      } &#13;
    } &#13;
</pre><p>If <span class="emphasis"><em>x</em></span> is zero, we omit it and write the value of <span class="emphasis"><em>y</em></span> in the same manner as we did earlier. However, if <span class="emphasis"><em>y</em></span> is zero, we write 0; otherwise, nothing will be written if both <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> are 0. Moreover, we omit the <code class="literal">showpos</code> flag, since it is not necessary to write the plus sign in the case of a positive value:</p><pre class="programlisting">    else { &#13;
      if (y == 1) { &#13;
        outStream &lt;&lt; TEXT("i"); &#13;
      } &#13;
      else if (y == -1) { &#13;
        outStream &lt;&lt; TEXT("-i"); &#13;
      } &#13;
      else if (y != 0) { &#13;
        outStream &lt;&lt; y &lt;&lt; TEXT("i"); &#13;
      } &#13;
      else { &#13;
        outStream &lt;&lt; TEXT("0"); &#13;
      } &#13;
    }  &#13;
    return outStream.str(); &#13;
  } &#13;
</pre><p>Two complex numbers are equal if their real and imaginary parts are equal:</p><pre class="programlisting">  bool Complex::operator==(const Complex &amp;complex) const { &#13;
    return ((x == complex.x) &amp;&amp; (y == complex.y)); &#13;
  } &#13;
 &#13;
  bool Complex::operator!=(const Complex &amp;complex) const { &#13;
    return !(*this == complex); &#13;
  } &#13;
</pre><p>When deciding whether a complex number is smaller than another complex number, we chose to compare their absolute values, which is given by the <code class="literal">Abs</code> method:</p><pre class="programlisting">  bool Complex::operator&lt;(const Complex &amp;complex) const { &#13;
    return (Abs() &lt; complex.Abs()); &#13;
  } &#13;
 &#13;
  bool Complex::operator&lt;=(const Complex &amp;complex) const { &#13;
    return ((*this &lt; complex) || (*this == complex)); &#13;
  } &#13;
 &#13;
  bool Complex::operator&gt;(const Complex &amp;complex) const { &#13;
    return !(*this &lt;= complex); &#13;
  } &#13;
 &#13;
  bool Complex::operator&gt;=(const Complex &amp;complex) const { &#13;
    return !(*this &lt; complex); &#13;
  } &#13;
</pre><p>The addition operators all call the following final operator, which works for all four arithmetic operators:</p><pre class="programlisting">  Complex Complex::operator+=(double x) { &#13;
    *this = (*this + Complex(x)); &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Complex Complex::operator+=(Complex &amp;complex) { &#13;
    *this = (*this + complex); &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Complex operator+(double x, const Complex &amp;complex) { &#13;
    return (Complex(x) + complex); &#13;
  } &#13;
 &#13;
  Complex operator+(const Complex &amp;complex, double x) { &#13;
    return (complex + Complex(x)); &#13;
  } &#13;
</pre><p>When adding two complex numbers, we add the real and imaginary parts separately:</p><pre class="programlisting">  Complex operator+(const Complex &amp;complex1, &#13;
                    const Complex &amp;complex2) { &#13;
    return Complex(complex1.x + complex2.x, &#13;
                   complex1.y + complex2.y); &#13;
  } &#13;
 &#13;
  Complex Complex::operator-=(double x) { &#13;
    return (*this - Complex(x)); &#13;
  } &#13;
 &#13;
  Complex Complex::operator-=(Complex &amp;complex) { &#13;
    return (*this - complex); &#13;
  } &#13;
 &#13;
  Complex operator-(double x, const Complex &amp;complex) { &#13;
    return (Complex(x) - complex); &#13;
  } &#13;
 &#13;
  Complex operator-(const Complex &amp;complex, double x) { &#13;
    return (complex - Complex(x)); &#13;
  } &#13;
</pre><p>When subtracting two complex numbers, we subtract the real and imaginary parts separately:</p><pre class="programlisting">  Complex operator-(const Complex &amp;complex1, &#13;
                    const Complex &amp;complex2) { &#13;
    return Complex(complex1.x - complex2.x, &#13;
                   complex1.y - complex2.y); &#13;
  } &#13;
 &#13;
  Complex Complex::operator*=(double x) { &#13;
    *this = (*this * Complex(x)); &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Complex Complex::operator*=(Complex &amp;complex) { &#13;
    *this = (*this * complex); &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Complex operator*(double x, const Complex &amp;complex) { &#13;
    return (Complex(x) * complex); &#13;
  } &#13;
 &#13;
  Complex operator*(const Complex &amp;complex, double x) { &#13;
    return (complex * Complex(x)); &#13;
  } &#13;
</pre><p>The product of two complex numbers can be established by some algebra:</p><p>(<span class="emphasis"><em>x</em></span>
<sub>1</sub> + <span class="emphasis"><em>y</em></span>
<sub>1</sub><span class="emphasis"><em>i</em></span>)(<span class="emphasis"><em>x</em></span>
<sub>2</sub> + <span class="emphasis"><em>y<sub>2</sub>i</em></span>) = <span class="emphasis"><em>x</em></span>
<sub>1</sub><span class="emphasis"><em>x</em></span>
<sub>2</sub> + <span class="emphasis"><em>x</em></span>
<sub>1</sub><span class="emphasis"><em>y</em></span>
<sub>2</sub><span class="emphasis"><em>i</em></span> +<span class="emphasis"><em> y</em></span>
<sub>1</sub><span class="emphasis"><em>ix</em></span>
<sub>2</sub> +<span class="emphasis"><em> y</em></span>
<sub>1</sub><span class="emphasis"><em>y</em></span>
<sub>2</sub><span class="emphasis"><em>i</em></span>
<sup>2</sup> =<span class="emphasis"><em> x</em></span>
<sub>1</sub><span class="emphasis"><em>x</em></span>
<sub>2</sub> +<span class="emphasis"><em> x</em></span>
<sub>1</sub><span class="emphasis"><em>y</em></span>
<sub>2</sub><span class="emphasis"><em>i</em></span> +<span class="emphasis"><em> y</em></span>
<sub>1</sub><span class="emphasis"><em>ix</em></span>
<sub>2</sub><span class="emphasis"><em> + y</em></span>
<sub>1</sub><span class="emphasis"><em>y</em></span>
<sub>2</sub> (-1) = <span class="emphasis"><em>x</em></span>
<sub>1</sub><span class="emphasis"><em>x</em></span>
<sub>2</sub> + <span class="emphasis"><em>x</em></span>
<sub>1</sub><span class="emphasis"><em>y</em></span>
<sub>2</sub><span class="emphasis"><em>i</em></span> + <span class="emphasis"><em>x</em></span>
<sub>2</sub><span class="emphasis"><em>y</em></span>
<sub>1</sub><span class="emphasis"><em>i</em></span> - <span class="emphasis"><em>y</em></span>
<sub>1</sub><span class="emphasis"><em>y</em></span>
<sub>2</sub> = (<span class="emphasis"><em>x</em></span>
<sub>1</sub><span class="emphasis"><em>x</em></span>
<sub>2</sub> - <span class="emphasis"><em>y</em></span>
<sub>1</sub><span class="emphasis"><em>y</em></span>
<sub>2</sub>) + (<span class="emphasis"><em>x</em></span>
<sub>1</sub><span class="emphasis"><em>y</em></span>
<sub>2</sub> + <span class="emphasis"><em>x</em></span>
<sub>2</sub><span class="emphasis"><em>y</em></span>
<sub>1</sub>)<span class="emphasis"><em>i</em></span>
</p><pre class="programlisting">  Complex operator*(const Complex &amp;complex1, &#13;
                    const Complex &amp;complex2) { &#13;
    return Complex((complex1.x * complex2.x) - &#13;
                   (complex1.y * complex2.y), &#13;
                   (complex1.x * complex2.y) + &#13;
                   (complex2.x * complex1.y)); &#13;
  } &#13;
&#13;
&#13;
 &#13;
  Complex Complex::operator/=(double x) { &#13;
    *this = (*this / Complex(x)); &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Complex Complex::operator/=(Complex &amp;complex) { &#13;
    *this = (*this / complex); &#13;
    return *this; &#13;
  } &#13;
 &#13;
  Complex operator/(double x, const Complex &amp;complex) { &#13;
    return (Complex(x) / complex); &#13;
  } &#13;
 &#13;
  Complex operator/(const Complex &amp;complex, double x) { &#13;
    return (complex / Complex(x)); &#13;
  } &#13;
</pre><p>The quotient between two complex numbers can also be established by some algebra. The <span class="strong"><strong>conjugate</strong></span> of a complex number <span class="emphasis"><em>x</em></span>
<sub>2</sub> +<span class="emphasis"><em> y</em></span>
<sub>2</sub><span class="emphasis"><em>i</em></span> is <span class="emphasis"><em>x</em></span>
<sub>2</sub> -<span class="emphasis"><em> y</em></span>
<sub>2</sub><span class="emphasis"><em>i</em></span>, which we can use in the conjugate rule:</p><p>(<span class="emphasis"><em>x</em></span>
<sub>2</sub>+ <span class="emphasis"><em>y</em></span>
<sub>2</sub><span class="emphasis"><em>i</em></span>)(<span class="emphasis"><em>x</em></span>
<sub>2</sub> - <span class="emphasis"><em>y</em></span>
<sub>2</sub><span class="emphasis"><em>i</em></span>) = <span class="emphasis"><em>x</em></span>
<sub>2</sub><sup>2</sup> - <span class="emphasis"><em>x</em></span>
<sub>2</sub><span class="emphasis"><em>y</em></span>
<sub>2</sub><span class="emphasis"><em>i</em></span> + <span class="emphasis"><em>x</em></span>
<sub>2</sub><span class="emphasis"><em>y</em></span>
<sub>2</sub><span class="emphasis"><em>i</em></span> - <span class="emphasis"><em>y</em></span>
<sub>2</sub><sup>2</sup> (-1) = <span class="emphasis"><em>x</em></span>
<sub>2</sub><sup>2</sup> - <span class="emphasis"><em>x</em></span>
<sub>2</sub><span class="emphasis"><em>y</em></span>
<sub>2</sub><span class="emphasis"><em>i</em></span> + <span class="emphasis"><em>x</em></span>
<sub>2</sub><span class="emphasis"><em>y</em></span>
<sub>2</sub><span class="emphasis"><em>i</em></span> + <span class="emphasis"><em>y</em></span>
<sub>2</sub><sup>2</sup> = <span class="emphasis"><em>x</em></span>
<sub>2</sub><sup>2</sup> + <span class="emphasis"><em>y</em></span>
<sub>2</sub><sup>2</sup></p><p>We can use the conjugate rule when dividing two complex numbers by multiplying the conjugate by both the numerator and the denominator:</p><p>
</p><div class="mediaobject"><img src="graphics/B05475_Appendix_08.jpg" alt="Complex numbers"/></div><p>
</p><pre class="programlisting">  Complex operator/(const Complex &amp;complex1, &#13;
                    const Complex &amp;complex2) { &#13;
    double sum = Square(complex2.x) + Square(complex2.y); &#13;
    double x = ((complex1.x * complex2.x) + &#13;
                (complex1.y * complex2.y)) / sum,    &#13;
           y = ((complex2.x * complex1.y) + &#13;
                (complex1.x * complex2.y)) / sum; &#13;
    return Complex(x, y); &#13;
  } &#13;
}; &#13;
</pre></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec81"/>Summary</h1></div></div></div><p>By reading this book you have learned how to develop applications in Windows with Small Windows, a C++ object-oriented class library for graphical applications in Windows.
I hope you have enjoyed the book!</p></div></body></html>