<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Extending the Frontend and Adding JIT Support" id="aid-173721"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Extending the Frontend and Adding JIT Support</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Handling decision making paradigms – if/then/else constructs</li><li class="listitem">Generating code for loops</li><li class="listitem">Handling user-defined operators – binary operators</li><li class="listitem">Handling user-defined operators – unary operators</li><li class="listitem">Adding JIT support</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Introduction</h1></div></div></div><p>In the last chapter, the basics of the frontend component for a language were defined. This included defining tokens for different types of expressions, writing a lexer to tokenize a stream of input, chalking out a skeleton for the abstract syntax tree of various expressions, writing a parser, and generating code for the language. Also, how various optimizations can be hooked to the frontend was explained.</p><p>A language is more powerful and expressive when it has control flow and loops to decide the flow of a program. JIT support explores the possibility of compiling code on-the-fly. In this chapter, implementation of these more sophisticated programming paradigms will be discussed. This chapter deals with enhancements of a programming language that make it more meaningful and powerful to use. The recipes in this chapter demonstrate how to include those enhancements for a given language.</p></div></div>
<div class="section" title="Handling decision making paradigms &#x2013; if/then/else constructs"><div class="titlepage" id="aid-181NK2"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Handling decision making paradigms – if/then/else constructs</h1></div></div></div><p>In any programming language, executing <a id="id120" class="indexterm"/>a statement based on certain conditions gives a very powerful advantage to the language. The <code class="literal">if</code>/<code class="literal">then</code>/<code class="literal">else</code> constructs provide the capability to alter the control flow of a program, based on certain conditions. The condition is present in an <code class="literal">if</code> construct. If the condition is true, the expression following the <code class="literal">then</code> construct is executed. If it is <code class="literal">false</code>, the expression following the <code class="literal">else</code> construct is executed. This recipe demonstrates a basic infrastructure to parse and generate code for the<a id="id121" class="indexterm"/> <code class="literal">if</code>/<code class="literal">then</code>/<code class="literal">else</code> construct.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec95"/>Getting ready</h2></div></div></div><p>The TOY language for <code class="literal">if</code>/<code class="literal">then</code>/<code class="literal">else</code> can be <a id="id122" class="indexterm"/>defined as:</p><div class="informalexample"><pre class="programlisting">if x &lt; 2 then
x + y
else
x - y</pre></div><p>For checking a condition, a comparison operator is required. A simple <span class="emphasis"><em>less than</em></span> operator, <code class="literal">&lt;</code>, will serve the purpose. To handle <code class="literal">&lt;</code>, precedence needs to be defined in the <code class="literal">init_precedence()</code> function, as shown here:</p><div class="informalexample"><pre class="programlisting">static void init_precedence() {
  Operator_Precedence['&lt;'] = 0;
  …
  …
}</pre></div><p>Also, the <code class="literal">codegen()</code> function for binary expressions needs to be included for <code class="literal">&lt;</code>:</p><div class="informalexample"><pre class="programlisting">Value* BinaryAST::Codegen() {
…
…
…
case '&lt;' :
L = Builder.CreateICmpULT(L, R, "cmptmp");
return Builder.CreateZExt(L, Type::getInt32Ty(getGlobalContext()),
                                "booltmp");…
…
}</pre></div><p>Now, the LLVM IR will generate a comparison instruction and a Boolean instruction as a result of the comparison, which will be used to determine where the control of the program will flow. It's time to handle the <code class="literal">if</code>/<code class="literal">then</code>/<code class="literal">else</code> paradigm now.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec96"/>How to do it...</h2></div></div></div><p>Do the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The lexer in the <code class="literal">toy.cpp</code> file <a id="id123" class="indexterm"/>has to be extended to <a id="id124" class="indexterm"/>handle the <code class="literal">if</code>/<code class="literal">then</code>/<code class="literal">else</code> constructs. This can be done by appending a token for this in the <code class="literal">enum</code> of tokens:<div class="informalexample"><pre class="programlisting">enum Token_Type{
…
…
IF_TOKEN,
THEN_TOKEN,
ELSE_TOKEN
}</pre></div></li><li class="listitem">The next step is to append the entries for these tokens in the <code class="literal">get_token()</code> function, where we match strings and return the appropriate tokens:<div class="informalexample"><pre class="programlisting">static int get_token() {
…
…
…
if (Identifier_string == "def")  return DEF_TOKEN;
if(Identifier_string == "if") return IF_TOKEN;
if(Identifier_string == "then") return THEN_TOKEN;
if(Identifier_string == "else") return ELSE_TOKEN;
…
…
}</pre></div></li><li class="listitem">Then we define an AST node in the <code class="literal">toy.cpp</code> file:<div class="informalexample"><pre class="programlisting">class ExprIfAST : public BaseAST {
  BaseAST *Cond, *Then, *Else;

public:
  ExprIfAST(BaseAST *cond, BaseAST *then, BaseAST * else_st)
      : Cond(cond), Then(then), Else(else_st) {}
  Value *Codegen() override;
};</pre></div></li><li class="listitem">The next step is to define the parsing logic for the <code class="literal">if</code>/<code class="literal">then</code>/<code class="literal">else</code> constructs:<div class="informalexample"><pre class="programlisting">static BaseAST *If_parser() {
  next_token();

  BaseAST *Cond = expression_parser();
  if (!Cond)
    return 0;

  if (Current_token != THEN_TOKEN)
    return 0;
  next_token();

  BaseAST *Then = expression_parser();
  if (Then == 0)
    return 0;

  if (Current_token != ELSE_TOKEN)
    return 0;

  next_token();

  BaseAST *Else = expression_parser();
  if (!Else)
    return 0;

  return new ExprIfAST(Cond, Then, Else);
}</pre></div><p>The parser logic is <a id="id125" class="indexterm"/>simple: first, the <code class="literal">if</code> token<a id="id126" class="indexterm"/> is searched for and the expression following it is parsed for the condition. After that, the <code class="literal">then</code> token is identified and the true condition expression is parsed. Then the <code class="literal">else</code> token is searched for and the false condition expression is parsed.</p></li><li class="listitem">Next we hook up the previously defined function with <code class="literal">Base_Parser()</code>:<div class="informalexample"><pre class="programlisting">static BaseAST* Base_Parser() {
switch(Current_token) {
…
…
…
case IF_TOKEN : return If_parser();
…
}</pre></div></li><li class="listitem">Now that the AST of <code class="literal">if</code>/<code class="literal">then</code>/<code class="literal">else</code> is filled with the expression by the parser, it's time to generate the <a id="id127" class="indexterm"/>LLVM IR for the <a id="id128" class="indexterm"/>conditional paradigm. Let's define the <code class="literal">Codegen()</code> function:<div class="informalexample"><pre class="programlisting">Value *ExprIfAST::Codegen() {
  Value *Condtn = Cond-&gt;Codegen();
  if (Condtn == 0)
    return 0;

  Condtn = Builder.CreateICmpNE(
      Condtn, Builder.getInt32(0), "ifcond");

  Function *TheFunc = Builder.GetInsertBlock()-&gt;getParent();

  BasicBlock *ThenBB =
      BasicBlock::Create(getGlobalContext(), "then", TheFunc);
  BasicBlock *ElseBB = BasicBlock::Create(getGlobalContext(), "else");
  BasicBlock *MergeBB = BasicBlock::Create(getGlobalContext(), "ifcont");

  Builder.CreateCondBr(Condtn, ThenBB, ElseBB);

  Builder.SetInsertPoint(ThenBB);

  Value *ThenVal = Then-&gt;Codegen();
  if (ThenVal == 0)
    return 0;

  Builder.CreateBr(MergeBB);
  ThenBB = Builder.GetInsertBlock();

  TheFunc-&gt;getBasicBlockList().push_back(ElseBB);
  Builder.SetInsertPoint(ElseBB);

  Value *ElseVal = Else-&gt;Codegen();
  if (ElseVal == 0)
    return 0;

  Builder.CreateBr(MergeBB);
  ElseBB = Builder.GetInsertBlock();

  TheFunc-&gt;getBasicBlockList().push_back(MergeBB);
  Builder.SetInsertPoint(MergeBB);
  PHINode *Phi = Builder.CreatePHI(Type::getInt32Ty(getGlobalContext()), 2, "iftmp");

  Phi-&gt;addIncoming(ThenVal, ThenBB);
  Phi-&gt;addIncoming(ElseVal, ElseBB);
  return Phi;
}</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>Now that we are <a id="id129" class="indexterm"/>ready with the code, let's compile and run it on a sample program containing the <code class="literal">if</code>/<code class="literal">then</code>/<code class="literal">else</code> constructs.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec97"/>How it works…</h2></div></div></div><p>Do the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Compile<a id="id130" class="indexterm"/> the <code class="literal">toy.cpp</code> file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ g++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core ` -O3 -o toy</strong></span>
</pre></div></li><li class="listitem">Open an example file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vi example</strong></span>
</pre></div></li><li class="listitem">Write the following <code class="literal">if</code>/<code class="literal">then</code>/<code class="literal">else</code> code in the example file:<div class="informalexample"><pre class="programlisting">def fib(x)
  if x &lt; 3 then
    1
  Else
    fib(x-1)+fib(x-2);</pre></div></li><li class="listitem">Compile the example file with the TOY compiler:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./toy example</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>The LLVM IR generated for the <code class="literal">if</code>/<code class="literal">then</code>/<code class="literal">else</code> code will look like this:</p><div class="informalexample"><pre class="programlisting">; ModuleID = 'my compiler'
target datalayout = "e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128"

define i32 @fib(i32 %x) {
entry:
  %cmptmp = icmp ult i32 %x, 3
  br i1 %cmptmp, label %ifcont, label %else

else:                                             ; preds = %entry
  %subtmp = add i32 %x, -1
  %calltmp = call i32 @fib(i32 %subtmp)
  %subtmp1 = add i32 %x, -2
  %calltmp2 = call i32 @fib(i32 %subtmp1)
  %addtmp = add i32 %calltmp2, %calltmp
  br label %ifcont

ifcont:                                           ; preds = %entry, %else
  %iftmp = phi i32 [ %addtmp, %else ], [ 1, %entry ]
  ret i32 %iftmp
}</pre></div><p>Here's what the output looks like:</p><div class="mediaobject"><img src="../Images/image00254.jpeg" alt="How it works…"/></div><p style="clear:both; height: 1em;"> </p><p>The parser identifies<a id="id131" class="indexterm"/> the <code class="literal">if</code>/<code class="literal">then</code>/<code class="literal">else</code> constructs and the<a id="id132" class="indexterm"/> statements that are to be executed in true and false conditions, and stores them in the AST. The code generator then converts the AST into LLVM IR, where the condition statement is generated. IR is generated for true as well as false conditions. Depending on the state of the condition variable, the appropriate statement is executed at runtime.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec98"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">For a detailed example on how an <a id="id133" class="indexterm"/><code class="literal">if else</code> statement is handled in C++ by Clang, refer to<a class="ulink" href="http://clang.llvm.org/doxygen/classclang_1_1IfStmt.html"> http://clang.llvm.org/doxygen/classclang_1_1IfStmt.html</a>.</li></ul></div></div></div>
<div class="section" title="Generating code for loops"><div class="titlepage" id="aid-190862"><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Generating code for loops</h1></div></div></div><p>Loops make a language <a id="id134" class="indexterm"/>powerful enough to perform the same operation several times, with limited lines of code. Loops are present in almost every language. This recipe demonstrates how loops are handled in the TOY language.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec99"/>Getting ready</h2></div></div></div><p>A loop typically has a start that initializes the induction variable, a step that indicates an increment or decrement in the induction variable, and an end condition for termination of the loop. The loop in our TOY language can be defined as follows:</p><div class="informalexample"><pre class="programlisting">for i = 1, i &lt; n, 1 in
     x + y;</pre></div><p>The start expression is the initialization of <code class="literal">i = 1</code>. The end condition for the loop is <code class="literal">i&lt;n</code>. The first line of the code indicates <code class="literal">i</code> be incremented by <code class="literal">1</code>.</p><p>As long as the end condition is true, the loop iterates and, after each iteration, the induction variable, <code class="literal">i</code>, is incremented by 1. An interesting thing called <span class="strong"><strong>PHI</strong></span> node<a id="id135" class="indexterm"/> comes into the picture to decide which value the induction variable, <code class="literal">i</code>, will take. Remember that our IR is in the <span class="strong"><strong>single static assignment</strong></span> (<span class="strong"><strong>SSA</strong></span>)<a id="id136" class="indexterm"/> form. In a control flow graph, for a given variable, the values can come from two different blocks. To represent SSA in LLVM IR, the <code class="literal">phi</code> instruction is defined. Here is an example of <code class="literal">phi</code>:</p><div class="informalexample"><pre class="programlisting">%i = phi i32 [ 1, %entry ], [ %nextvar, %loop ]</pre></div><p>The preceding IR indicates that the value for <code class="literal">i</code> can come from two basic blocks: <code class="literal">%entry</code> and <code class="literal">%loop</code>. The value from the <code class="literal">%entry</code> block will be <code class="literal">1</code>, while the <code class="literal">%nextvar</code> variable will be from <code class="literal">%loop</code>. We will see the details after implementing the loop for our toy compiler.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec100"/>How to do it...</h2></div></div></div><p>Like any other expression, loops are also handled by including states in lexer, defining the AST data structure to hold loop values, and defining the parser and the <code class="literal">Codegen()</code> function to generate the LLVM IR:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is to define tokens in the lexer in <code class="literal">toy.cpp</code> file:<div class="informalexample"><pre class="programlisting">enum Token_Type {
  …
  …
  FOR_TOKEN,
  IN_TOKEN
  …
  …
};</pre></div></li><li class="listitem">Then we include the logic in the lexer:<div class="informalexample"><pre class="programlisting">static int get_token() {
  …
  …
if (Identifier_string == "else")
      return ELSE_TOKEN;
    if (Identifier_string == "for")
      return FOR_TOKEN;
    if (Identifier_string == "in")
      return IN_TOKEN;
  …
  …
}</pre></div></li><li class="listitem">The next<a id="id137" class="indexterm"/> step is to define the AST for the <code class="literal">for</code> <a id="id138" class="indexterm"/>loop:<div class="informalexample"><pre class="programlisting">class ExprForAST  : public BaseAST {
  std::string Var_Name;
  BaseAST *Start, *End, *Step, *Body;

public:
  ExprForAST (const std::string &amp;varname, BaseAST *start, BaseAST *end,
             BaseAST *step, BaseAST *body)
      : Var_Name(varname), Start(start), End(end), Step(step), Body(body) {}
  Value *Codegen() override;
};</pre></div></li><li class="listitem">Then we define the parser logic for the loop:<div class="informalexample"><pre class="programlisting">static BaseAST *For_parser() {
  next_token();

  if (Current_token != IDENTIFIER_TOKEN)
    return 0;

  std::string IdName = Identifier_string;
  next_token();

  if (Current_token != '=')
    return 0;
  next_token();

  BaseAST *Start = expression_parser();
  if (Start == 0)
    return 0;
  if (Current_token != ',')
    return 0;
  next_token();

  BaseAST *End = expression_parser();
  if (End == 0)
    return 0;

  BaseAST *Step = 0;
  if (Current_token == ',') {
    next_token();
    Step = expression_parser();
    if (Step == 0)
      return 0;
  }

  if (Current_token != IN_TOKEN)
    return 0;
  next_token();

  BaseAST *Body = expression_parser();
  if (Body == 0)
    return 0;

  return new ExprForAST (IdName, Start, End, Step, Body);
}</pre></div></li><li class="listitem">Next we<a id="id139" class="indexterm"/> define the <code class="literal">Codegen()</code> function to generate the<a id="id140" class="indexterm"/> LLVM IR:<div class="informalexample"><pre class="programlisting">Value *ExprForAST::Codegen() {

  Value *StartVal = Start-&gt;Codegen();
  if (StartVal == 0)
    return 0;

  Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();
  BasicBlock *PreheaderBB = Builder.GetInsertBlock();
  BasicBlock *LoopBB =
      BasicBlock::Create(getGlobalContext(), "loop", TheFunction);

  Builder.CreateBr(LoopBB);

  Builder.SetInsertPoint(LoopBB);

  PHINode *Variable = Builder.CreatePHI(Type::getInt32Ty(getGlobalContext()), 2, Var_Name.c_str());
  Variable-&gt;addIncoming(StartVal, PreheaderBB);

  Value *OldVal = Named_Values[Var_Name];
  Named_Values[Var_Name] = Variable;

  if (Body-&gt;Codegen() == 0)
    return 0;

  Value *StepVal;
  if (Step) {
    StepVal = Step-&gt;Codegen();
    if (StepVal == 0)
      return 0;
  } else {
    StepVal = ConstantInt::get(Type::getInt32Ty(getGlobalContext()), 1);
  }

  Value *NextVar = Builder.CreateAdd(Variable, StepVal, "nextvar");

  Value *EndCond = End-&gt;Codegen();
  if (EndCond == 0)
    return EndCond;

  EndCond = Builder.CreateICmpNE(
      EndCond, ConstantInt::get(Type::getInt32Ty(getGlobalContext()), 0), "loopcond");

  BasicBlock *LoopEndBB = Builder.GetInsertBlock();
  BasicBlock *AfterBB =
      BasicBlock::Create(getGlobalContext(), "afterloop", TheFunction);

  Builder.CreateCondBr(EndCond, LoopBB, AfterBB);

  Builder.SetInsertPoint(AfterBB);

  Variable-&gt;addIncoming(NextVar, LoopEndBB);

  if (OldVal)
    Named_Values[Var_Name] = OldVal;
  else
    Named_Values.erase(Var_Name);

  return Constant::getNullValue(Type::getInt32Ty(getGlobalContext()));
}</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec101"/>How it works...</h2></div></div></div><p>Do the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Compile <a id="id141" class="indexterm"/>the <code class="literal">toy.cpp</code> file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ g++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core ` -O3 -o toy</strong></span>
</pre></div></li><li class="listitem">Open an<a id="id142" class="indexterm"/> example file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vi example</strong></span>
</pre></div></li><li class="listitem">Write the following code for a <code class="literal">for</code> loop in the example file:<div class="informalexample"><pre class="programlisting">def printstar(n x)
  for i = 1, i &lt; n, 1.0 in
    x + 1</pre></div></li><li class="listitem">Compile the example file with the TOY compiler:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./toy example</strong></span>
</pre></div></li><li class="listitem">The LLVM IR for the preceding <code class="literal">for</code> loop code will be generated, as follows:<div class="informalexample"><pre class="programlisting">; ModuleID = 'my compiler'
target datalayout = "e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128"

define i32 @printstar(i32 %n, i32 %x) {
entry:
  br label %loop

loop:                                             ; preds = %loop, %entry
  %i = phi i32 [ 1, %entry ], [ %nextvar, %loop ]
  %nextvar = add i32 %i, 1
  %cmptmp = icmp ult i32 %i, %n
  br i1 %cmptmp, label %loop, label %afterloop

afterloop:                                        ; preds = %loop
  ret i32 0
}</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>The parser you just saw identifies the loop, initialization of the induction variable, the termination condition, the step value for the induction variable, and the body of the loop. It then converts each of the blocks in LLVM IR, as seen previously.</p><p>As seen<a id="id143" class="indexterm"/> previously, a <code class="literal">phi</code> instruction gets two values for the variable <code class="literal">i</code> from<a id="id144" class="indexterm"/> two basic blocks: <code class="literal">%entry</code> and <code class="literal">%loop</code>. In the preceding case, the <code class="literal">%entry</code> block represents the value assigned to the induction variable at the start of the loop (this is <code class="literal">1</code>). The next updated value of <code class="literal">i</code> comes from the <code class="literal">%loop</code> block, which completes one iteration of the loop.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec102"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">To get a detailed overview of how loops<a id="id145" class="indexterm"/> are handled for C++ in Clang, visit <a class="ulink" href="http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Parse/ParseExprCXX.cpp">http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Parse/ParseExprCXX.cpp</a></li></ul></div></div></div>
<div class="section" title="Handling user-defined operators &#x2013; binary operators"><div class="titlepage" id="aid-19UOO2"><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Handling user-defined operators – binary operators</h1></div></div></div><p>User-defined operators are similar to the C++ concept of operator overloading, where a default definition of an operator is altered to operate on a wide variety of objects. Typically, operators are unary or binary operators. Implementing binary operator overloading is easier with the existing infrastructure. Unary operators need some additional code to handle. First, binary operator overloading will be defined, and then unary operator overloading will be looked into.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec103"/>Getting ready</h2></div></div></div><p>The first part is to define a <a id="id146" class="indexterm"/>binary operator for overloading. The logical OR operator (<code class="literal">|</code>) is a good example to start with. The <code class="literal">|</code> operator in our TOY language can be used as follows:</p><div class="informalexample"><pre class="programlisting">def binary | (LHS RHS)
if LHS then
1
else if RHS then
1
else
0;</pre></div><p>As seen in the preceding code, if any of the values of the LHS or RHS are not equal to 0, then we return <code class="literal">1</code>. If both the LHS and RHS are null, then we return <code class="literal">0</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec104"/>How to do it...</h2></div></div></div><p>Do the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step, as usual, is<a id="id147" class="indexterm"/> to append the <code class="literal">enum</code> states for the binary operator and return the enum states on encountering the <code class="literal">binary</code> keyword:<div class="informalexample"><pre class="programlisting"> enum Token_Type {
…
…
BINARY_TOKEN
}
static int get_token() {
…
…
if (Identifier_string == "in") return IN_TOKEN;
if (Identifier_string == "binary") return BINARY_TOKEN;
…
…
}</pre></div></li><li class="listitem">The next step is to add an AST for the same. Note that it doesn't need a new AST to be defined. It can be handled with the function declaration AST. We just need to modify it by adding a flag to represent whether it's a binary operator. If it is, then determine its precedence:<div class="informalexample"><pre class="programlisting">class FunctionDeclAST {
  std::string Func_Name;
  std::vector&lt;std::string&gt; Arguments;
  bool isOperator;
  unsigned Precedence;
public:
  FunctionDeclAST(const std::string &amp;name, const std::vector&lt;std::string&gt; &amp;args,
               bool isoperator = false, unsigned prec = 0)
      : Func_Name(name), Arguments(args), isOperator(isoperator), Precedence(prec) {}

  bool isUnaryOp() const { return isOperator &amp;&amp; Arguments.size() == 1; }
  bool isBinaryOp() const { return isOperator &amp;&amp; Arguments.size() == 2; }

  char getOperatorName() const {
    assert(isUnaryOp() || isBinaryOp());
    return Func_Name[Func_Name.size() - 1];
  }

  unsigned getBinaryPrecedence() const { return Precedence; }

  Function *Codegen();
};</pre></div></li><li class="listitem">Once the modified AST<a id="id148" class="indexterm"/> is ready, the next step is to modify the parser of the function declaration:<div class="informalexample"><pre class="programlisting">static FunctionDeclAST *func_decl_parser() {
  std::string FnName;

  unsigned Kind = 0;
  unsigned BinaryPrecedence = 30;

  switch (Current_token) {
  default:
    return 0;
  case IDENTIFIER_TOKEN:
    FnName = Identifier_string;
    Kind = 0;
    next_token();
    break;
  case UNARY_TOKEN:
    next_token();
    if (!isascii(Current_token))
      return 0;
    FnName = "unary";
    FnName += (char)Current_token;
    Kind = 1;
    next_token();
    break;
  case BINARY_TOKEN:
    next_token();
    if (!isascii(Current_token))
      return 0;
    FnName = "binary";
    FnName += (char)Current_token;
    Kind = 2;
    next_token();

    if (Current_token == NUMERIC_TOKEN) {
      if (Numeric_Val &lt; 1 || Numeric_Val &gt; 100)
        return 0;
      BinaryPrecedence = (unsigned)Numeric_Val;
      next_token();
    }
    break;
  }

  if (Current_token != '(')
    return 0;

  std::vector&lt;std::string&gt; Function_Argument_Names;
  while (next_token() == IDENTIFIER_TOKEN)
    Function_Argument_Names.push_back(Identifier_string);
  if (Current_token != ')')
    return 0;

  next_token();

  if (Kind &amp;&amp; Function_Argument_Names.size() != Kind)
    return 0;

  return new FunctionDeclAST(FnName, Function_Argument_Names, Kind != 0, BinaryPrecedence);
}</pre></div></li><li class="listitem">Then we modify <a id="id149" class="indexterm"/>the <code class="literal">Codegen()</code> function for the binary AST:<div class="informalexample"><pre class="programlisting">Value* BinaryAST::Codegen() {
 Value* L = LHS-&gt;Codegen();
Value* R = RHS-&gt;Codegen();
switch(Bin_Operator) {
case '+' : return Builder.CreateAdd(L, R, "addtmp");
case '-' : return Builder.CreateSub(L, R, "subtmp");
case '*': return Builder.CreateMul(L, R, "multmp");
case '/': return Builder.CreateUDiv(L, R, "divtmp");
case '&lt;' :
L = Builder.CreateICmpULT(L, R, "cmptmp");
return Builder.CreateUIToFP(L, Type::getIntTy(getGlobalContext()), "booltmp");
default :
break;
}
Function *F = TheModule-&gt;getFunction(std::string("binary")+Op);
  Value *Ops[2] = { L, R };
  return Builder.CreateCall(F, Ops, "binop");
}</pre></div></li><li class="listitem">Next we modify the function definition; it can be defined as:<div class="informalexample"><pre class="programlisting">Function* FunctionDefnAST::Codegen() {
Named_Values.clear();
Function *TheFunction = Func_Decl-&gt;Codegen();
if (!TheFunction) return 0;
if (Func_Decl-&gt;isBinaryOp())
    Operator_Precedence [Func_Decl-&gt;getOperatorName()] = Func_Decl-&gt;getBinaryPrecedence();
BasicBlock *BB = BasicBlock::Create(getGlobalContext(), "entry", TheFunction);
Builder.SetInsertPoint(BB);
if (Value* Return_Value = Body-&gt;Codegen()) {
    Builder.CreateRet(Return_Value);
…
…</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec105"/>How it works...</h2></div></div></div><p>Do the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Compile<a id="id150" class="indexterm"/> the <code class="literal">toy.cpp</code> file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ g++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core ` -O3 -o toy</strong></span>
</pre></div></li><li class="listitem">Open an example file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vi example</strong></span>
</pre></div></li><li class="listitem">Write the following binary operator overloading code in the example file:<div class="informalexample"><pre class="programlisting">def binary| 5 (LHS RHS)
  if LHS then
    1
  else if RHS then
    1
  else
    0;</pre></div></li><li class="listitem">Compile the example file with the TOY compiler:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./toy example</strong></span>

<span class="strong"><strong>output :</strong></span>

<span class="strong"><strong>; ModuleID = 'my compiler'</strong></span>
<span class="strong"><strong>target datalayout = "e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128"</strong></span>

<span class="strong"><strong>define i32 @"binary|"(i32 %LHS, i32 %RHS) {</strong></span>
<span class="strong"><strong>entry:</strong></span>
<span class="strong"><strong>  %ifcond = icmp eq i32 %LHS, 0</strong></span>
<span class="strong"><strong>  %ifcond1 = icmp eq i32 %RHS, 0</strong></span>
<span class="strong"><strong>  %. = select i1 %ifcond1, i32 0, i32 1</strong></span>
<span class="strong"><strong>  %iftmp5 = select i1 %ifcond, i32 %., i32 1</strong></span>
<span class="strong"><strong>  ret i32 %iftmp5</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>The binary operator<a id="id151" class="indexterm"/> we just defined will be parsed. Its definition is also parsed. Whenever the <code class="literal">|</code> binary operator is encountered, the LHS and RHS are initialized and the definition body is executed, giving the appropriate result as per the definition. In the preceding example, if either the LHS or RHS is nonzero, then the result is <code class="literal">1</code>. If both the LHS and RHS are zero, then the result is <code class="literal">0</code>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec106"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">For detailed examples on handling other<a id="id152" class="indexterm"/> binary operators, refer to <a class="ulink" href="http://llvm.org/docs/tutorial/LangImpl6.html">http://llvm.org/docs/tutorial/LangImpl6.html</a></li></ul></div></div></div>
<div class="section" title="Handling user-defined operators &#x2013; unary operators"><div class="titlepage" id="aid-1AT9A2"><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Handling user-defined operators – unary operators</h1></div></div></div><p>We saw in the previous recipe how binary operators can be handled. A language may also have some unary operator, operating on 1 operand. In this recipe, we will see how to handle unary operators.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec107"/>Getting ready</h2></div></div></div><p>The first step is to define a unary operator<a id="id153" class="indexterm"/> in the TOY language. A simple unary NOT operator (<code class="literal">!</code>) can serve as a good example; let's see one definition:</p><div class="informalexample"><pre class="programlisting">def unary!(v)
  if v then
    0
  else
    1;</pre></div><p>If the value <code class="literal">v</code> is equal to <code class="literal">1</code>, then <code class="literal">0</code> is returned. If the value is <code class="literal">0</code>, <code class="literal">1</code> is returned as the output.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec108"/>How to do it...</h2></div></div></div><p>Do the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is to define the <code class="literal">enum</code> token for the unary operator in the <code class="literal">toy.cpp</code> file:<div class="informalexample"><pre class="programlisting">enum Token_Type {
…
…
BINARY_TOKEN,
UNARY_TOKEN
}</pre></div></li><li class="listitem">Then we identify the <a id="id154" class="indexterm"/>unary string and return a unary token:<div class="informalexample"><pre class="programlisting">static int get_token() {
…
…
if (Identifier_string == "in") return IN_TOKEN;
if (Identifier_string == "binary") return BINARY_TOKEN;
if (Identifier_string == "unary") return UNARY_TOKEN;

…
…
}</pre></div></li><li class="listitem">Next, we define an AST for the unary operator:<div class="informalexample"><pre class="programlisting">class ExprUnaryAST : public BaseAST {
  char Opcode;
  BaseAST *Operand;
public:
  ExprUnaryAST(char opcode, BaseAST *operand)
    : Opcode(opcode), Operand(operand) {}
  virtual Value *Codegen();
};</pre></div></li><li class="listitem">The AST is now ready. Let's define a parser for the unary operator:<div class="informalexample"><pre class="programlisting">static BaseAST *unary_parser() {

  if (!isascii(Current_token) || Current_token == '(' || Current_token == ',')
    return Base_Parser();

    int Op = Current_token;

  next_token();

  if (ExprAST *Operand = unary_parser())
    return new ExprUnaryAST(Opc, Operand);

return 0;
}</pre></div></li><li class="listitem">The next step is to call the <code class="literal">unary_parser()</code> function from the binary operator parser:<div class="informalexample"><pre class="programlisting">static BaseAST *binary_op_parser(int Old_Prec, BaseAST *LHS) {

  while (1) {
    int Operator_Prec = getBinOpPrecedence();

    if (Operator_Prec &lt; Old_Prec)
      return LHS;

    int BinOp = Current_token;
    next_token();

    BaseAST *RHS = unary_parser();
    if (!RHS)
      return 0;

    int Next_Prec = getBinOpPrecedence();
    if (Operator_Prec &lt; Next_Prec) {
      RHS = binary_op_parser(Operator_Prec + 1, RHS);
      if (RHS == 0)
        return 0;
    }

    LHS = new BinaryAST(std::to_string(BinOp), LHS, RHS);
  }
}</pre></div></li><li class="listitem">Now let's call<a id="id155" class="indexterm"/> the <code class="literal">unary_parser()</code> function from the expression parser:<div class="informalexample"><pre class="programlisting">static BaseAST *expression_parser() {
  BaseAST *LHS = unary_parser();
  if (!LHS)
    return 0;

  return binary_op_parser(0, LHS);
}</pre></div></li><li class="listitem">Then we modify the <a id="id156" class="indexterm"/>function declaration parser:<div class="informalexample"><pre class="programlisting">static FunctionDeclAST* func_decl_parser() {
std::string Function_Name = Identifier_string;
unsigned Kind = 0;
unsigned BinaryPrecedence = 30;
switch (Current_token) {
  default:
    return 0;
  case IDENTIFIER_TOKEN:
    Function_Name = Identifier_string;
    Kind = 0;
    next_token();
    break;
  case UNARY_TOKEN:
  next_token();
if (!isascii(Current_token))
      return0;
    Function_Name = "unary";
    Function_Name += (char)Current_token;
    Kind = 1;
    next_token();
    break;
  case BINARY_TOKEN:
    next_token();
    if (!isascii(Current_token))
      return 0;
    Function_Name = "binary";
    Function_Name += (char)Current_token;
    Kind = 2;
   next_token();
   if (Current_token == NUMERIC_TOKEN) {
      if (Numeric_Val &lt; 1 || Numeric_Val &gt; 100)
        return 0;
      BinaryPrecedence = (unsigned)Numeric_Val;
      next_token();
    }
    break;
  }
if (Current_token ! = '(') {
printf("error in function declaration");
return 0;
}
std::vector&lt;std::string&gt; Function_Argument_Names;
while(next_token() == IDENTIFIER_TOKEN) Function_Argument_Names.push_back(Identifier_string);
if(Current_token != ')')  {                      printf("Expected ')' ");                      return 0;
}
next_token();
if (Kind &amp;&amp; Function_Argument_Names.size() != Kind)
    return 0;
return new FunctionDeclAST(Function_Name, Function_Arguments_Names, Kind !=0, BinaryPrecedence);
}</pre></div></li><li class="listitem">The final step is to <a id="id157" class="indexterm"/>define the <code class="literal">Codegen()</code> function for the unary operator:<div class="informalexample"><pre class="programlisting">Value *ExprUnaryAST::Codegen() {

  Value *OperandV = Operand-&gt;Codegen();

  if (OperandV == 0) return 0;

  Function *F = TheModule-&gt;getFunction(std::string("unary")+Opcode);

  if (F == 0)
    return 0;

  return Builder.CreateCall(F, OperandV, "unop");
}</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec109"/>How it works...</h2></div></div></div><p>Do the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Compile <a id="id158" class="indexterm"/>the <code class="literal">toy.cpp</code> file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ g++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core ` -O3 -o toy</strong></span>
</pre></div></li><li class="listitem">Open an example file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vi example</strong></span>
</pre></div></li><li class="listitem">Write the following unary operator overloading code in the example file:<div class="informalexample"><pre class="programlisting">def unary!(v)
  if v then
    0
  else
    1;</pre></div></li><li class="listitem">Compile the example file with the TOY compiler:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./toy example</strong></span>
</pre></div><p>The output should be as shown:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>; ModuleID = 'my compiler'</strong></span>
<span class="strong"><strong>target datalayout = "e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128"</strong></span>

<span class="strong"><strong>define i32 @"unary!"(i32 %v) {</strong></span>
<span class="strong"><strong>entry:</strong></span>
<span class="strong"><strong>  %ifcond = icmp eq i32 %v, 0</strong></span>
<span class="strong"><strong>  %. = select i1 %ifcond, i32 1, i32 0</strong></span>
<span class="strong"><strong>  ret i32 %.</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>The unary operator defined by the user will be parsed, and IR will be generated for it. In the case you just saw, if the <a id="id159" class="indexterm"/>unary operand is not zero then the result is <code class="literal">0</code>. If the operand is zero, then the result is <code class="literal">1</code>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec110"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">To learn more detailed implementations of <a id="id160" class="indexterm"/>unary operators, visit <a class="ulink" href="http://llvm.org/docs/tutorial/LangImpl6.html">http://llvm.org/docs/tutorial/LangImpl6.html</a></li></ul></div></div></div>
<div class="section" title="Adding JIT support" id="aid-1BRPS1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec40"/>Adding JIT support</h1></div></div></div><p>A wide variety of tools can be<a id="id161" class="indexterm"/> applied to LLVM IR. For example, as demonstrated in <a class="link" title="Chapter 1. LLVM Design and Use" href="part0015.xhtml#aid-E9OE1">Chapter 1</a>, <span class="emphasis"><em>LLVM Design and Use</em></span>, the IR can be dumped into bitcode or into an assembly. An optimization tool called opt can be run on IR. IR acts as the common platform—an abstract layer for all of these tools.</p><p>JIT support can also be added. It immediately evaluates the top-level expressions typed in. For example, <code class="literal">1 + 2;</code>, as soon as it is typed in, evaluates the code and prints the value as <code class="literal">3</code>.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec111"/>How to do it...</h2></div></div></div><p>Do the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define a static global variable for the execution engine in the <code class="literal">toy.cpp</code> file:<div class="informalexample"><pre class="programlisting">static ExecutionEngine *TheExecutionEngine;</pre></div></li><li class="listitem">In the <code class="literal">toy.cpp</code> file's <code class="literal">main()</code> function, write the code for JIT:<div class="informalexample"><pre class="programlisting">int main() {
…
…
init_precedence();
TheExecutionEngine = EngineBuilder(TheModule).create();
…
…
}</pre></div></li><li class="listitem">Modify the<a id="id162" class="indexterm"/> top-level expression parser in the <code class="literal">toy.cpp</code> file:<div class="informalexample"><pre class="programlisting">static void HandleTopExpression() {

if (FunctionDefAST *F = expression_parser())
   if (Function *LF = F-&gt;Codegen()) {
        LF -&gt; dump();
       void *FPtr = TheExecutionEngine-&gt;getPointerToFunction(LF);
      int (*Int)() = (int (*)())(intptr_t)FPtr;

    printf("Evaluated to %d\n", Int());
}
   else
next_token();
}</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec112"/>How it works…</h2></div></div></div><p>Do the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Compile the <code class="literal">toy.cpp</code> program:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ g++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native` -O3 -o toy</strong></span>
</pre></div></li><li class="listitem">Open an example file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vi example</strong></span>
</pre></div></li><li class="listitem">Write the following TOY code in the example file:<div class="informalexample"><pre class="programlisting">…
4+5;</pre></div></li><li class="listitem">Finally, run the TOY compiler on the example file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./toy example</strong></span>
<span class="strong"><strong>The output will be</strong></span>
<span class="strong"><strong>define i32 @0() {</strong></span>
<span class="strong"><strong>entry:</strong></span>
<span class="strong"><strong>  ret i32 9</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>The LLVM JIT compiler matches the native platform ABI, casts the result pointer into a function pointer of that type, and calls it directly. There is no difference between JIT-compiled code and native machine code that is <a id="id163" class="indexterm"/>statically linked to the application.</p></div></div></body></html>