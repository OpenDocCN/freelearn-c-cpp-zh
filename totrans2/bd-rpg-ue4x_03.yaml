- en: Chapter 3. Exploration and Combat
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 探索与战斗
- en: We have a design for our game and an Unreal project set up for our game. It's
    now time to dive into the actual game code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的游戏设计了游戏界面，并设置了用于游戏的Unreal项目。现在是时候深入实际的游戏代码了。
- en: 'In this chapter, we''ll be making a game character that moves around the world,
    defining our game data, and prototyping a basic combat system for the game. We
    will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将制作一个在世界上移动的游戏角色，定义我们的游戏数据，并为游戏原型设计一个基本的战斗系统。本章将涵盖以下主题：
- en: Creating the player pawn
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建玩家角色
- en: Defining characters, classes, and enemies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义角色、类和敌人
- en: Keeping track of active party members
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪活跃的队伍成员
- en: Creating a basic turn-based combat engine
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个基本的回合制战斗引擎
- en: Triggering a game over screen
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发游戏结束屏幕
- en: This particular chapter is the most C++ heavy portion of the book, and provides
    the basic framework that the rest of the book is going to use. Because this chapter
    provides much of the backend of our game, the code in this chapter must work to
    completion before moving on to the rest of the content in the book. If you bought
    this book because you are a programmer looking for more background in creating
    a framework for an RPG, this chapter is for you! If you bought this book because
    you are a designer, and care more about building upon the framework rather than
    programming it from scratch, you will probably be more into the upcoming chapters
    because those chapters contain less C++ and more UMG and Blueprints. No matter
    who you are, it is a good idea to download the source code provided through the
    directions located in the preface of the book in case you get stuck or would like
    to skip chapters based on your interests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分是本书中最注重C++的部分，并为本书的其余部分提供了一个基本框架。由于这一章节提供了我们游戏的后端大部分内容，因此在这一章节中的代码必须完整无误地工作，才能继续阅读本书的其余内容。如果你购买这本书是因为你是一名程序员，正在寻找更多关于创建RPG框架的背景知识，那么这一章节就是为你准备的！如果你购买这本书是因为你是一名设计师，更关心在框架上构建而不是从头开始编程，你可能对即将到来的章节更感兴趣，因为那些章节包含更少的C++和更多的UMG和蓝图。无论你是谁，下载前言中提供的源代码都是一个好主意，以防你遇到困难或想根据你的兴趣跳过某些章节。
- en: Creating the player pawn
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建玩家角色
- en: The very first thing we are going to do is create a new Pawn class. In Unreal,
    the *Pawn* is the representation of a character. It handles the movement, physics,
    and rendering of a character.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是创建一个新的Pawn类。在Unreal中，*Pawn*是角色的表示。它处理角色的移动、物理和渲染。
- en: 'Here''s how our character pawn is going to work. The player is divided into
    two parts: there''s the Pawn that, as mentioned earlier, is responsible for handling
    the movement, physics, and rendering. Then there''s the Player Controller, responsible
    for translating the player''s input into making the Pawn perform what the player
    wants.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的角色Pawn将要如何工作。玩家分为两部分：有一个Pawn，如前所述，负责处理移动、物理和渲染。然后是Player Controller，负责将玩家的输入转换为让Pawn执行玩家想要的动作。
- en: The Pawn
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pawn
- en: Now, let's create the actual pawn.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建实际的Pawn。
- en: 'Create a new C++ class and select `Character` as the parent class for it. We
    will be deriving this class from the `Character` class because `Character` has
    a lot of built-in move functions that we can use for our field player. Name the
    class `RPGCharacter`. Open `RPGCharacter.h` and change the class definition using
    the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的C++类，并将其父类设置为`Character`。我们将从这个`Character`类中派生这个类，因为`Character`类有很多内置的移动函数，我们可以为我们的场地上玩家使用。将类命名为`RPGCharacter`。打开`RPGCharacter.h`，并使用以下代码更改类定义：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, open `RPGCharacter.cpp` and replace it with the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`RPGCharacter.cpp`，并用以下代码替换它：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you have ever created and worked with the C++ **ThirdPerson** game template,
    you will notice that we are not reinventing the wheel here. The `RPGCharacter`
    class should look familiar because it is a modified version of the ThirdPerson
    `Character` class code given to us when we create a C++ ThirdPerson template,
    provided for us to use by Epic Games.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经创建并使用过C++的**ThirdPerson**游戏模板，你会注意到我们在这里并没有重新发明轮子。`RPGCharacter`类应该看起来很熟悉，因为它是我们创建C++
    ThirdPerson模板时提供的`Character`类代码的修改版本，由Epic Games提供给我们使用。
- en: Since we are not creating a fast-paced action game and are simply using the
    Pawn as an RPG character to maneuver out in the field, we eliminated mechanics
    that are often associated with action games, such as jumping. But we kept in the
    code that is important to us, which is the ability to move forward, backward,
    left, and right; rotational behaviors of the pawn; a camera that will follow the
    character around in an isometric view; a collision capsule for the character to
    be able to collide with collidable objects; configuration for character movement;
    and a camera boom, which will allow the camera to move closer to the character
    in case it runs into collisions such as a wall or other meshes, important for
    not blocking a player's view. If you want to edit the character mechanics, feel
    free to do so by following the comments in the code to change the values of some
    specific mechanics such as `TargetArmLength` to change the distance of the camera
    from the player, or adding jumping, which can be seen in the ThirdPerson character
    template that came with the Engine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不是在制作快节奏的动作游戏，而是简单地将Pawn用作RPG角色在战场上移动，因此我们消除了与动作游戏经常相关的机制，例如跳跃。但我们保留了对我们重要的代码，这包括向前、向后、向左和向右移动的能力；Pawn的旋转行为；一个以等距视角跟随角色的相机；一个用于角色能够与可碰撞对象碰撞的碰撞胶囊；角色移动的配置；以及一个相机吊杆，它允许相机在角色遇到墙壁或其他网格等碰撞时靠近角色，这对于不让玩家视线受阻非常重要。如果您想编辑角色机制，请随意通过遵循代码中的注释来更改某些特定机制的价值，例如将`TargetArmLength`的值更改以改变相机与玩家之间的距离，或者添加跳跃，这可以在与引擎一起提供的ThirdPerson角色模板中看到。
- en: Because we derived the `RPGCharacter` class from the `Character` class, its
    default camera is not rotated for an isometric view; instead, the camera rotations
    and locations are zeroed out by default to the pawn's location. So what we did
    was add a `CameraBoom` relative location in `RPGCharacter.cpp` (`CameraBoom->RelativeLocation
    = FVector(0.f, 0.f, 500.f);`); this offsets the camera 500 units up on the *z*
    axis. Along with rotating the camera that follows the player -45 units on the
    pitch (`FollowCamera->RelativeRotation = FRotator(-45.f, 0.f, 0.f);`), we get
    a traditional isometric view. If you would like to edit these values to customize
    your camera even more, it is suggested; for instance, if you still think your
    camera is too close to the player, you can simply change the relative location
    of `CameraBoom` on the *z* axis to a value higher than 500 units, and/or adjust
    `TargetArmLength` to something larger than 300.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是从`Character`类派生出了`RPGCharacter`类，其默认相机在等距视角下没有旋转；相反，相机的旋转和位置默认为零，设置为Pawn的位置。所以我们做的是在`RPGCharacter.cpp`中添加了一个相对位置`CameraBoom`（`CameraBoom->RelativeLocation
    = FVector(0.f, 0.f, 500.f);`）；这使相机在*Z*轴上向上偏移了500个单位。与旋转跟随玩家的相机-45单位在俯仰（`FollowCamera->RelativeRotation
    = FRotator(-45.f, 0.f, 0.f);`）一起，我们得到了传统的等距视角。如果您想编辑这些值以进一步自定义相机，建议这样做；例如，如果您仍然认为您的相机离玩家太近，您只需将`CameraBoom`在*Z*轴上的相对位置更改为大于500个单位的值，或者调整`TargetArmLength`到一个大于300的值。
- en: Lastly, if you take a look at the `MoveForward` and `MoveRight` movement functions,
    you will notice that no movement is being added to the pawn unless the value that
    is passed to `MoveForward` or `MoveRight` is not equal to 0\. Later on in this
    chapter, we will bind keys *W*, *A*, *S*, and *D* to these functions and set each
    one of these inputs to pass a scalar of 1 or -1 to the corresponding movement
    function as values. This 1 or -1 value is then used as a multiplier to the direction
    of the pawn, which will then allow the player to move in a specific direction
    based on its walk speed. For instance, if we set *W* as a keybind to `MoveForward`
    with a scalar of 1, and *S* as a keybind to `MoveFoward` with a scalar of -1,
    when the player presses *W*, the value in the `MoveFoward` function will be equal
    to 1 and cause the pawn to move in the positive forward direction as a result.
    Alternatively, if the player presses the *S* key, -1 is then passed into the value
    used by the `MoveForward` function, which will cause the pawn to move in the negative
    forward direction (in other words, backwards). Similar logic can be said about
    the `MoveRight` function, which is why we don't have a `MoveLeft` function—simply
    because pressing the *A* key would cause the player to move in the negative right
    direction, which is in fact left.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你查看 `MoveForward` 和 `MoveRight` 移动函数，你会注意到，除非传递给 `MoveForward` 或 `MoveRight`
    的值不等于 0，否则不会向 pawn 添加任何移动。在本章的后面部分，我们将把键 *W*、*A*、*S* 和 *D* 绑定到这些函数上，并将每个输入设置为传递
    1 或 -1 的标量值给相应的移动函数。这个 1 或 -1 的值随后用作 pawn 方向的乘数，这将允许玩家根据其行走速度向特定方向移动。例如，如果我们把
    *W* 作为 `MoveForward` 的键绑定并使用标量 1，把 *S* 作为 `MoveFoward` 的键绑定并使用标量 -1，当玩家按下 *W*
    时，`MoveFoward` 函数中的值将等于 1，从而使 pawn 向正前方移动。相反，如果玩家按下 *S* 键，-1 就会被传递到 `MoveForward`
    函数使用的值中，这将使 pawn 向负前方移动（换句话说，向后）。关于 `MoveRight` 函数的类似逻辑也可以这么说，这就是为什么我们没有 `MoveLeft`
    函数——仅仅是因为按下 *A* 键会导致玩家向负右方向移动，这实际上是向左。
- en: The GameMode class
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏模式类
- en: Now, in order to use this pawn as a player character, we need to set up a new
    game mode class. This game mode will then specify the default pawn and player
    controller classes to use. We'll also be able to make a Blueprint of the game
    mode and override these defaults.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用这个 pawn 作为玩家角色，我们需要设置一个新的游戏模式类。这个游戏模式将指定默认的 pawn 和玩家控制器类。我们还将能够创建游戏模式的蓝图并覆盖这些默认设置。
- en: Create a new class and choose `GameMode` as the parent class. Name this new
    class `RPGGameMode` (if `RPGGameMode` already exists in your project, simply navigate
    to your C++ source directory and proceed to open up `RPGGameMode.h`, as listed
    in the next step).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类，并将 `GameMode` 作为父类。将这个新类命名为 `RPGGameMode`（如果 `RPGGameMode` 在你的项目中已经存在，只需导航到你的
    C++ 源代码目录，然后继续打开 `RPGGameMode.h`，如下一步所述）。
- en: 'Open `RPGGameMode.h` and change the class definition using the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `RPGGameMode.h` 并使用以下代码更改类定义：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just as we've done before, we're just defining a constructor for the CPP file
    to implement.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们只是在定义一个用于实现 CPP 文件的构造函数。
- en: 'We''re going to implement that constructor now in `RPGGameMode.cpp`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在这个 `RPGGameMode.cpp` 中实现那个构造函数：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we include the `RPGCharacter.h` file so that we can reference these classes.
    Then, in the constructor, we set the class as the default class to use for the
    Pawn.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包含 `RPGCharacter.h` 文件，以便我们可以引用这些类。然后，在构造函数中，我们将该类设置为 Pawn 的默认类。
- en: Now, if you compile this code, you should be able to assign your new game mode
    class as the default game mode. To do this, go to **Edit** | **Project Settings**,
    find the **Default Modes** box, expand the **Default GameMode** drop-down menu,
    and select **RPGGameMode**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你编译这段代码，你应该能够将你的新游戏模式类作为默认游戏模式。为此，转到 **编辑** | **项目设置**，找到 **默认模式** 框，展开
    **默认游戏模式** 下拉菜单，并选择 **RPGGameMode**。
- en: However, we don't necessarily want to use this class directly. Instead, if we
    make a Blueprint, we can expose the properties of the game mode that can be modified
    in the Blueprint.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不一定想直接使用这个类。相反，如果我们创建一个蓝图，我们可以暴露游戏模式中可以修改的属性。
- en: 'So, let''s make a new Blueprint Class in **Content** | **Blueprints**, pick
    `RPGGameMode` as its parent class, and call it `DefaultRPGGameMode`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在 **内容** | **蓝图** 中创建一个新的蓝图类，将其父类选择为 `RPGGameMode`，并将其命名为 `DefaultRPGGameMode`：
- en: '![The GameMode class](img/B04548_03_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![游戏模式类](img/B04548_03_01.jpg)'
- en: 'If you open the Blueprint and navigate to the **Defaults** tab, you can modify
    the settings for the game mode for **Default Pawn Class**, **HUD Class**, **Player
    Controller Class**, and more settings:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开蓝图并导航到**默认**选项卡，你可以修改游戏模式设置，包括**默认兵类**、**HUD 类**、**玩家控制器类**等更多设置：
- en: '![The GameMode class](img/B04548_03_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![游戏模式类](img/B04548_03_02.jpg)'
- en: However, we still have one extra step before we can test our new Pawn. If you
    run the game, you will not see the Pawn at all. In fact, it will appear as if
    nothing is happening. We need to give our Pawn a skinned mesh and also make the
    camera follow the pawn.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们能够测试我们新的兵之前，我们还需要额外的一步。如果你运行游戏，你将完全看不到兵。实际上，它看起来就像什么都没发生一样。我们需要给我们的兵一个带皮肤的网格，并且让摄像机跟随兵。
- en: Adding the skinned mesh
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加带皮肤的网格
- en: 'For now, we''re just going to import the prototype character that comes with
    the ThirdPerson sample. To do this, make a new project based on the ThirdPerson
    sample. Locate the `ThirdPersonCharacter` Blueprint class in **Content** | **ThirdPersonCPP**
    | **Blueprints** and migrate it to the `Content` folder of your RPG project by
    right-clicking on the `ThirdPersonCharacter` Blueprint class and navigating to
    **Asset Actions** | **Migrate…**. This action should copy `ThirdPersonCharacter`
    with all its assets into your RPG project:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只是将要导入与 ThirdPerson 示例一起提供的原型角色。为此，基于 ThirdPerson 示例创建一个新的项目。在**内容** |
    **ThirdPersonCPP** | **蓝图**中找到 `ThirdPersonCharacter` 蓝图类，通过右键单击 `ThirdPersonCharacter`
    蓝图类并导航到**资产操作** | **迁移…**将其迁移到 RPG 项目的**内容**文件夹。此操作应将 `ThirdPersonCharacter` 及其所有资产复制到你的
    RPG 项目中：
- en: '![Adding the skinned mesh](img/B04548_03_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![添加带皮肤的网格](img/B04548_03_03.jpg)'
- en: Now, let's create a new Blueprint for our Pawn. Create a new Blueprint class
    and select **RPGCharacter** as the parent class. Name it **FieldPlayer**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的兵创建一个新的蓝图。创建一个新的蓝图类，并将**RPGCharacter**作为父类。将其命名为**FieldPlayer**。
- en: 'Expand **Mesh** located in the **Details** tab when selecting the **Mesh**
    component from the **Components** tab and choose **SK_Mannequin** as the skeletal
    mesh for the pawn. Next, expand **Animation** and choose **ThirdPerson_AnimBP**
    as the animation Blueprint to use. You will most likely need to move your character''s
    mesh down the *z* axis so that the bottom of the character''s feet meet the bottom
    of the collision capsule. Also be sure that the character mesh is facing the same
    direction that the blue arrow in the component is facing. You may need to rotate
    the character on the *z* axis as well to ensure that the character is facing the
    right direction:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当从**组件**选项卡中选择**网格**组件时，在**详细信息**选项卡中展开**网格**，并将**SK_Mannequin**作为兵的骨骼网格选择。接下来，展开**动画**并选择要使用的**ThirdPerson_AnimBP**动画蓝图。你很可能会需要将角色的网格沿
    *z* 轴向下移动，以便角色的脚底与碰撞胶囊的底部对齐。同时确保角色网格面向与组件中蓝色箭头相同的方向。你可能还需要在 *z* 轴上旋转角色，以确保角色面向正确的方向：
- en: '![Adding the skinned mesh](img/B04548_03_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![添加带皮肤的网格](img/B04548_03_04.jpg)'
- en: Finally, open your game mode Blueprint and change the pawn to your new **FieldPlayer**
    Blueprint.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开你的游戏模式蓝图，并将兵更改为你的新**FieldPlayer**蓝图。
- en: 'Now, our character will be visible, but we may not be able to move it yet because
    we have not bound keys to any of our movement variables. To do so, go into **Project
    Settings** and locate **Input**. Expand **Bindings** and then expand **Axis Mappings**.
    Add an axis mapping by pressing the **+** button. Call the first axis mapping
    **MoveRight**, which should match the `MoveRight` movement variable you created
    earlier in this chapter. Add two key bindings for **MoveRight** by pressing the
    **+** button. Let one of those keys be *A* with a scale of -1 and other be *D*
    with a scale of 1\. Add another axis mapping for **MoveForward**; only this time,
    have a *W* key binding with a scale of 1 and an *S* key binding with a scale of
    -1:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的角色将变得可见，但我们可能还不能移动它，因为我们还没有将任何按键绑定到我们的移动变量上。要做到这一点，请进入**项目设置**并找到**输入**。展开**绑定**然后展开**轴映射**。通过按**+**按钮添加一个轴映射。将第一个轴映射命名为**MoveRight**，它应该与您在本章
    earlier 创建的 `MoveRight` 移动变量相匹配。通过按**+**按钮添加两个**MoveRight**的键绑定。让其中一个键是 *A*，缩放为
    -1，另一个是 *D*，缩放为 1。为**MoveForward**添加另一个轴映射；这次，有一个 *W* 键绑定，缩放为 1，一个 *S* 键绑定，缩放为
    -1：
- en: '![Adding the skinned mesh](img/B04548_03_05.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![添加带皮肤的网格](img/B04548_03_05.jpg)'
- en: Once you play test, you should see your character moving and animating using
    the *W*, *A*, *S*, and *D* keys you bound to the player.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进行游戏测试，你应该会看到你的角色使用你绑定的 *W*、*A*、*S* 和 *D* 键移动和动画。
- en: When you run the game, the camera should track the player in an overhead view.
    Now that we have a character that can explore the game world, let's take a look
    at defining characters and party members.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行游戏时，摄像机应该以俯视角度跟踪玩家。现在我们有一个可以探索游戏世界的角色，让我们来看看如何定义角色和队伍成员。
- en: Defining characters and enemies
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义角色和敌人
- en: In the last chapter, we covered how to use Data Tables to import custom data.
    Before that, we decided on what stats would play into combat and how. Now we're
    going to combine those to define our game's characters, classes, and enemy encounters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了如何使用数据表导入自定义数据。在此之前，我们决定哪些属性会影响战斗以及如何影响。现在，我们将结合这些属性来定义我们的游戏角色、类别和敌人遭遇。
- en: Classes
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别
- en: 'Remember that in [Chapter 1](ch01.html "Chapter 1. Getting Started with RPG
    Design in Unreal"), *Getting Started with RPG Design in Unreal*, we established
    that our characters have the following stats:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在[第1章](ch01.html "第1章。在Unreal中开始RPG设计")中，我们确立了我们的角色具有以下属性：
- en: Health
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命值
- en: Max health
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大生命值
- en: Magic
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 魔法
- en: Max magic
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大魔法值
- en: Attack power
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击力
- en: Defense
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防御力
- en: Luck
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幸运值
- en: Of these, we can discard health and magic because they vary during the game,
    while the other values are predefined based on the character class. The remaining
    stats are what we will define in the Data Table. As mentioned in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with RPG Design in Unreal"), *Getting Started with
    RPG Design in Unreal*, we also need to store what the value should be at level
    50 (the maximum level). Characters will also have some abilities they start out
    with, and some they learn as they level up.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些属性中，我们可以丢弃生命值和魔法值，因为它们在游戏过程中会变化，而其他值是基于角色类别预先定义的。剩余的属性是我们将在数据表中定义的。如[第1章](ch01.html
    "第1章。在Unreal中开始RPG设计")中所述，我们还需要存储在50级（最大等级）时的值。角色还将有一些初始能力，以及随着等级提升而学习的能力。
- en: 'We''ll define these in the character class spreadsheet, along with the name
    of the class. So our character class schema will look something like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在角色类别电子表格中定义这些属性，包括类名。因此，我们的角色类别架构将类似于以下内容：
- en: Class name (string)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名（字符串）
- en: Starting max HP (integer)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始最大生命值（整数）
- en: Max HP at level 50 (integer)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50级最大生命值（整数）
- en: Starting max MP (integer)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始最大魔法值（整数）
- en: Max MP at level 50 (integer)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50级最大魔法值（整数）
- en: Starting attack (integer)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始攻击力（整数）
- en: Attack at level 50 (integer)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50级攻击力（整数）
- en: Starting defense (integer)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始防御力（整数）
- en: Defense at level 50 (integer)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50级防御力（整数）
- en: Starting luck (integer)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始幸运值（整数）
- en: Luck at level 50 (integer)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50级幸运值（整数）
- en: Starting abilities (string array)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始能力（字符串数组）
- en: Learned abilities (string array)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学到的能力（字符串数组）
- en: Learned ability levels (integer array)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学到的能力等级（整数数组）
- en: The ability string arrays will contain the ID of the ability (the value of the
    reserved `name` field in UE4). Additionally, there are two separate cells for
    learned abilities—one that contains the ability IDs, another that contains the
    levels at which those abilities are learned.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 能力字符串数组将包含能力的ID（UE4中保留的`name`字段的值）。此外，还有两个单独的单元格用于学习到的能力——一个包含能力ID，另一个包含学习这些能力时的等级。
- en: In a production game, one thing you might consider is writing a custom tool
    to help manage this data and reduce human error. However, writing such a tool
    is outside the scope of this book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个生产游戏中，你可能考虑写一个自定义工具来帮助管理这些数据并减少人为错误。然而，编写这样的工具超出了本书的范围。
- en: Now, instead of creating a spreadsheet for this, we're actually going to first
    create the class and then the Data Table inside Unreal. The reason for this is
    that at the time of writing, the proper syntax to specify arrays in a cell of
    a Data Table is not well documented. However, arrays can still be edited from
    inside the Unreal editor, so we'll simply create the table there and use Unreal's
    array editor.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不是为这个创建电子表格，而是首先在Unreal中创建类，然后创建数据表。这样做的原因是，在撰写本文时，指定数据表单元格中数组的正确语法并未得到很好的记录。然而，数组仍然可以从Unreal编辑器内部进行编辑，因此我们只需在那里创建表格并使用Unreal的数组编辑器。
- en: Firstly, as usual, create a new class. The class will be used as an object that
    you can call from, so choose `Object` as the parent class. Name this class `FCharacterClassInfo`
    and, for organization purposes, path your new class to your `Source/RPG/Data`
    folder.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，像往常一样，创建一个新的类。这个类将用作你可以从中调用的对象，因此选择`Object`作为父类。将此类命名为`FCharacterClassInfo`，为了组织目的，将新类路径到你的`Source/RPG/Data`文件夹。
- en: 'Open `FCharacterClassInfo.h` and replace the class definition with the following
    code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`FCharacterClassInfo.h`并将类定义替换为以下代码：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Most of this code should be familiar to you already; however, you may not recognize
    the last three fields. These are all of the `TArray` type, which is a dynamic
    array type provided by Unreal. Essentially, a `TArray` can have elements dynamically
    added to it and removed from it, unlike a standard C++ array.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的大部分您可能已经熟悉；然而，您可能不认识最后三个字段。这些都是`TArray`类型，这是Unreal提供的一种动态数组类型。本质上，`TArray`可以动态地向其中添加元素并从中移除元素，这与标准C++数组不同。
- en: Upon compiling this code, create a new folder called `Data` within your `Content`
    folder so that you can stay organized by keeping Data Tables that you create within
    the `Data` folder. Navigate to **Content** | **Data** in the Content Browser and
    create a new Data Table by right-clicking on **Content Browser** and choosing
    **Miscellaneous** | **Data Table**. Then, select **Character Class Info** from
    the drop-down list. Name your Data Table **CharacterClasses** and then double-click
    to open it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此代码后，在您的“内容”文件夹内创建一个名为“Data”的新文件夹，以便通过将您创建的数据表保存在“Data”文件夹中保持组织有序。在内容浏览器中导航到**内容**
    | **数据**，通过右键单击**内容浏览器**并选择**杂项** | **数据表**来创建一个新的数据表。然后，从下拉列表中选择**角色类信息**。将您的数据表命名为**CharacterClasses**，然后双击打开它。
- en: To add a new entry, hit the **+** button. Then, give a name to the new entry
    by entering something in the **Row Name** field and pressing *Enter*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新条目，请点击**+**按钮。然后，在**行名称**字段中输入新条目的名称并按*Enter*键。
- en: After an entry has been added, you can select the entry in the **Data Table**
    pane and edit its properties in the **Row Editor** pane.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 添加条目后，您可以在**数据表**面板中选择条目，并在**行编辑器**面板中编辑其属性。
- en: 'Let''s add a Soldier class to the list. We will it give the name `S1` (which
    we''ll use to refer to the character class from other Data Tables) and it will
    have the following properties:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在列表中添加一个士兵类。我们将给它命名为`S1`（我们将用它来引用其他数据表中的角色类）并且它将具有以下属性：
- en: '**Class Name**: Soldier'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类名**：士兵'
- en: '**Start MHP**: 100'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始MHP**：100'
- en: '**Start MMP**: 100'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始MMP**：100'
- en: '**Start ATK**: 5'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始ATK**：5'
- en: '**Start DEF**: 0'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始DEF**：0'
- en: '**Start Luck**: 0'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始幸运**：0'
- en: '**End MHP**: 800'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结束MHP**：800'
- en: '**End MMP**: 500'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结束MMP**：500'
- en: '**End ATK**: 20'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结束ATK**：20'
- en: '**End DEF**: 20'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结束DEF**：20'
- en: '**End Luck**: 10'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结束幸运**：10'
- en: '**Starting Abilities**: (leave empty for now)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**起始能力**：（目前留空）'
- en: '**Learned Abilities**: (leave empty for now)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习能力**：（目前留空）'
- en: '**Learned Ability Levels**: (leave empty for now)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习能力等级**：（目前留空）'
- en: 'When you are finished, your Data Table should look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，你的数据表应该看起来像这样：
- en: '![Classes](img/B04548_03_06.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![类](img/B04548_03_06.jpg)'
- en: If you have more character classes that you would like to define, continue to
    add them to your Data Table.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想定义更多的角色类，请继续将它们添加到您的数据表中。
- en: Characters
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: 'With classes defined, let''s take a look at characters. Since most of the important
    combat-related data is already defined as part of a character''s class, the character
    itself is going to be quite a bit simpler. In fact, for now, our characters will
    be defined by just two things: the name of the character and the character''s
    class.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了类之后，让我们来看看角色。由于大多数重要的战斗相关数据已经作为角色类的一部分定义，因此角色本身将会相当简单。实际上，目前我们的角色将由以下两点定义：角色的名称和角色的类。
- en: 'Firstly, create a new C++ class called `FCharacterInfo` whose parent is `Object`,
    and path it to the `Source/RPG/Data` folder. Now, replace the class definition
    in `FCharacterInfo.h` with this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`FCharacterInfo`的新C++类，其父类为`Object`，并将其路径设置为`Source/RPG/Data`文件夹。现在，将`FCharacterInfo.h`中的类定义替换为以下内容：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we did earlier, we're just defining the two fields for the character (character
    name and class ID).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们只是定义了角色的两个字段（角色名称和类ID）。
- en: After compiling, create a new Data Table in your `Data` folder that you created
    earlier from within the Content Browser and select **CharacterInfo** as the class;
    call it `Characters`. Add a new entry with the name `S1`. You can name this character
    whatever you like (we named our character soldier **Kumo**), but for class ID,
    enter `S1` (as this is the name of the Soldier class we defined earlier).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，在您之前创建的内容浏览器中的“Data”文件夹内创建一个新的数据表，并选择**CharacterInfo**作为类；命名为“Characters”。添加一个名为`S1`的新条目。您可以给这个角色起任何名字（我们给我们的角色命名为士兵**Kumo**），但请在类ID中输入`S1`（因为这是我们之前定义的士兵类的名称）。
- en: Enemies
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敌人
- en: As for enemies, rather than defining a separate character and class information,
    we'll create a simplified combined table for these two pieces of information.
    An enemy generally does not have to deal with experience and leveling up, so we
    can omit any data related to this. Additionally, enemies do not consume MP as
    players do, so we can omit this data as well.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 至于敌人，我们不会为单独的角色和职业信息定义一个类，而是为这两部分信息创建一个简化的组合表。敌人通常不需要处理经验和升级，因此我们可以省略与此相关的任何数据。此外，敌人不会像玩家那样消耗MP，因此我们也可以省略这部分数据。
- en: 'Therefore, our enemy data will have the following properties:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的敌人数据将具有以下属性：
- en: Enemy name (string array)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人名称（字符串数组）
- en: MHP (integer)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大生命值（整数）
- en: ATK (integer)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击力（整数）
- en: DEF (integer)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防御力（整数）
- en: Luck (integer)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幸运值（整数）
- en: Abilities (string array)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能力（字符串数组）
- en: Much like the previous Data Class creations, we create a new C++ class that
    derives from `Object`, but this time we will call it `FEnemyInfo` and place it
    with the rest of our data in the `Source/RPG/Data` directory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的数据类创建类似，我们创建一个新的从 `Object` 派生的 C++ 类，但这次我们将它命名为 `FEnemyInfo` 并将其放置在 `Source/RPG/Data`
    目录中的其他数据旁边。
- en: 'At this point, you should have an understanding of how to construct the class
    for this data, but let''s take a look at the struct header anyway. In `FEnemyInfo.h`,
    replace your class definition with the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该已经了解了如何为这些数据构建类，但无论如何，让我们看一下结构头文件。在 `FEnemyInfo.h` 中，将你的类定义替换为以下内容：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After compiling, create a new Data Table, select `EnemyInfo` as the class,
    and call the Data Table `Enemies`. Add a new entry with the name `S1` and the
    following properties:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后，创建一个新的数据表，选择 `EnemyInfo` 作为类，并将数据表命名为 `Enemies`。添加一个名为 `S1` 的新条目，并具有以下属性：
- en: '**Enemy Name**: Goblin'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**敌人名称**: 哥布林'
- en: '**MHP**: 20'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大生命值**: 20'
- en: '**ATK**: 5'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**攻击力**: 5'
- en: '**DEF**: 0'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DEF**: 0'
- en: '**Luck**: 0'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幸运值**: 0'
- en: '**Abilities**: (leave empty for now)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**能力**:（目前留空）'
- en: At this point, we've got the data for a character, the character's class, and
    a single enemy for the character to fight. Next, let's start keeping track of
    which characters are in the active party and what their current stats are.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了角色的数据、角色的职业以及角色要与之战斗的单一敌人。接下来，让我们开始跟踪哪些角色在活动队伍中，以及他们的当前状态。
- en: Party members
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队伍成员
- en: Before we can keep track of party members, we'll need a way to track a character's
    current state, such as how much HP the character has or what it has equipped.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够跟踪队伍成员之前，我们需要一种方法来跟踪角色的当前状态，比如角色有多少HP或者装备了什么。
- en: To do this, we'll create a new class named `GameCharacter`. As usual, create
    a new class and pick `Object` as the parent class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将创建一个新的类名为 `GameCharacter`。像往常一样，创建一个新的类并将 `Object` 作为父类。
- en: 'The header for this class looks like the following code snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的头文件看起来像以下代码片段：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For now, we're keeping track of the character's name, character's source class
    information, and character's current stats. Later, we will use the `UCLASS` and
    `UPROPERTY` macros to expose information to the Blueprint. We'll add other information
    later as we work on the combat system.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在跟踪角色的名字、角色的来源职业信息以及角色的当前状态。稍后，我们将使用 `UCLASS` 和 `UPROPERTY` 宏将信息暴露给蓝图。我们将在开发战斗系统时添加其他信息。
- en: 'As for the `.cpp` file, it will look like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `.cpp` 文件，它看起来像这样：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `CreateGameCharacter` factory for our `UGameCharacter` class takes a pointer
    to an `FCharacterInfo` struct, which is returned from a Data Table, and also an
    `Outer` object, which is passed to the `NewObject` function. It then attempts
    to find the character class Data Table from a path, and if the result is not null,
    it locates the proper row in the Data Table, stores the result, and also initializes
    the stats and the `CharacterName` field. In the preceding code, you can see the
    path where the character class Data Table is located. You can get this path by
    right-clicking on your Data Table from the Content Browser, selecting **Copy Reference**,
    and then pasting the result into your code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `UGameCharacter` 类的 `CreateGameCharacter` 工厂函数接受一个指向 `FCharacterInfo` 结构的指针，该结构由数据表返回，并且还接受一个
    `Outer` 对象，该对象传递给 `NewObject` 函数。然后它尝试从一个路径中找到角色类数据表，如果结果不为空，它将定位到数据表中的正确行，存储结果，并初始化状态和
    `CharacterName` 字段。在前面的代码中，你可以看到角色类数据表所在的路径。你可以通过在内容浏览器中右键单击你的数据表，选择 **复制引用**，然后将结果粘贴到你的代码中。
- en: While this is currently a very basic bare-bones representation of a character,
    it will work for now. Next, we're going to store a list of these characters as
    the current party.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这目前是一个非常基本的骨架式的人物表示，但暂时可以工作。接下来，我们将存储这些人物的列表作为当前党派。
- en: The GameInstance class
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏实例类
- en: We have already created a `GameMode` class, and this might seem like the perfect
    place to keep track of information such as party members and inventory, right?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个`GameMode`类，这似乎是跟踪党派成员和库存等信息的一个完美的位置，对吧？
- en: However, `GameMode` does not persist between level loads! This means that unless
    you save some information to disk, you lose all of that data whenever you load
    a new area.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`GameMode`在关卡加载之间不会持久化！这意味着除非你将一些信息保存到磁盘上，否则每次加载新区域时都会丢失所有这些数据。
- en: The `GameInstance` class was introduced to deal with just this sort of problem.
    A `GameInstance` class persists through the whole game, regardless of level loads,
    unlike `GameMode`. We're going to create a new `GameInstance` class to keep track
    of our persistent data, such as party members and inventory.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameInstance`类是为了解决这类问题而引入的。`GameInstance`类在整个游戏过程中都保持持久，与`GameMode`不同。我们将创建一个新的`GameInstance`类来跟踪我们的持久数据，例如党派成员和库存。'
- en: Create a new class, and this time, select `GameInstance` as the parent class
    (you'll have to search for it). Name it `RPGGameInstance`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类，这次选择`GameInstance`作为父类（你可能需要搜索它）。将其命名为`RPGGameInstance`。
- en: 'In the header file, we''re going to add a `TArray` of the `UGameCharacter`
    pointers, a flag to know whether the game has been initialized, and an `Init`
    function. Your `RPGGameInstance.h` file should look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中，我们将添加一个`UGameCharacter`指针的`TArray`，一个表示游戏是否已初始化的标志，以及一个`Init`函数。你的`RPGGameInstance.h`文件应该看起来像这样：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `Init` function for the game instance, we''ll add a single default party
    member and then set the `isInitialized` flag to `true`. Your `RPGGameInstance.cpp`
    should look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏实例的`Init`函数中，我们将添加一个默认的党派成员，并将`isInitialized`标志设置为`true`。你的`RPGGameInstance.cpp`应该看起来像这样：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You may run into a linker error at this point if you try to compile. It is recommended
    that before you move on, save and close everything. Then restart your project.
    After you do that, compile the project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试编译，可能会遇到链接错误。建议在继续之前保存并关闭所有内容。然后重新启动你的项目。之后，编译项目。
- en: To set this class as your `GameInstance` class, in Unreal, open **Edit** | **Project
    Settings**, go to **Maps & Modes**, scroll down to the **Game Instance** box,
    and pick **RPGGameInstance** from the drop-down list. Finally, from the game mode,
    we override `BeginPlay` to call this `Init` function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此类设置为你的`GameInstance`类，在Unreal中，打开**编辑** | **项目设置**，转到**地图与模式**，滚动到**游戏实例**框，并从下拉列表中选择**RPGGameInstance**。最后，从游戏模式中重写`BeginPlay`以调用此`Init`函数。
- en: 'Open `RPGGameMode.h` and add `virtual void BeginPlay() override;` at the end
    of your class so that your header will now look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`RPGGameMode.h`，并在你的类末尾添加`virtual void BeginPlay() override;`，这样你的头文件现在看起来像这样：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And in `RPGGameMode.cpp`, cast `RPGGameInstance` at `BeginPlay` so that `RPGGameMode.cpp`
    now looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在`RPGGameMode.cpp`中，在`BeginPlay`时将`RPGGameInstance`进行转换，这样`RPGGameMode.cpp`现在看起来像这样：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once you compile the code, you now have a list of active party members. It's
    time to start prototyping the combat engine.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译代码，你现在就有一个活跃的党派成员列表。现在是时候开始原型设计战斗引擎了。
- en: Turn-based combat
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回合制战斗
- en: So, as mentioned in [Chapter 1](ch01.html "Chapter 1. Getting Started with RPG
    Design in Unreal"), *Getting Started with RPG Design in Unreal*, combat is turn-based.
    All characters first choose an action to perform; then, the actions are executed
    in order.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如[第1章](ch01.html "第1章。在Unreal中开始RPG设计")中提到的，*在Unreal中开始RPG设计*，战斗是回合制的。所有角色首先选择要执行的动作；然后，按照顺序执行这些动作。
- en: 'Combat will be split into two main phases: **Decision**, in which all characters
    decide on their course of action; and **Action**, in which all characters execute
    their chosen course of action.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 战斗将分为两个主要阶段：**决策**，在这个阶段，所有角色决定他们的行动方案；和**行动**，在这个阶段，所有角色执行他们选择的行动方案。
- en: 'Let''s create a class with an empty parent to handle combat for us, which we''ll
    call `CombatEngine`, and path it to a new directory located in `Source/RPG/Combat`,
    where we can organize all of our combat-related classes. Formulate the header
    file to look like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个没有父类的类来为我们处理战斗，我们可以将其称为`CombatEngine`，并将其放置在`Source/RPG/Combat`的新目录中，我们可以在这里组织所有与战斗相关的类。将头文件制定如下：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There's a lot going on here, so I'll explain.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行，所以我将进行解释。
- en: Firstly, our combat engine is designed to be allocated when an encounter starts
    and deleted when combat is over.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的战斗引擎设计为在遭遇开始时分配，在战斗结束时删除。
- en: 'An instance of `CombatEngine` keeps three `TArray`: one for combat order (a
    list of all participants in combat, in the order they will take turns in), another
    for a list of players, and the third one for a list of enemies. It also keeps
    track of `CombatPhase`. There are two main phases of combat: `Decision` and `Action`.
    Each round starts in `Decision`; in this phase, all characters are allowed to
    choose their course of action. Then, combat transitions to the `Action` phase;
    in this phase, all characters perform their previously chosen course of action.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`CombatEngine` 实例维护了三个 `TArray`：一个用于战斗顺序（所有参与战斗的成员列表，按照他们轮流行动的顺序），另一个用于玩家列表，第三个用于敌人列表。它还跟踪
    `CombatPhase`。战斗有两个主要阶段：`Decision` 和 `Action`。每一轮从 `Decision` 阶段开始；在这个阶段，所有角色都可以选择他们的行动方案。然后，战斗过渡到
    `Action` 阶段；在这个阶段，所有角色将执行他们之前选择的行动方案。'
- en: The `GameOver` and `Victory` phases will be transitioned to when all enemies
    are dead or all players are dead, respectively (which is why the player and enemy
    lists are kept separate).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有敌人死亡或所有玩家死亡时，将过渡到 `GameOver` 和 `Victory` 阶段（这就是为什么玩家和敌人列表被分开保留的原因）。
- en: The `CombatEngine` class defines a `Tick` function. This will be called by the
    game mode of every frame as long as combat is not over, and it returns `true`
    when combat has finished (or `false` otherwise). It takes the duration of the
    last frame in seconds as a parameter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`CombatEngine` 类定义了一个 `Tick` 函数。这个函数将在战斗未结束的情况下，由每一帧的游戏模式调用，当战斗结束时返回 `true`（否则返回
    `false`）。它接受上一帧的持续时间作为参数。'
- en: There's also the `currentTickTarget` and `tickTargetIndex`. During the `Decision`
    and `Action` phases, we'll keep a pointer to a single character. For instance,
    during the `Decision` phase, this pointer starts with the first character in the
    combat order. At every frame, the character will be asked to make a decision—which
    will be a function that returns `true` if the character has made a decision, or
    `false` otherwise. If the function returns `true`, the pointer will advance to
    the next character and so on until all characters have decided at which point
    the combat transitions to the `Action` phase.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 还有 `currentTickTarget` 和 `tickTargetIndex`。在 `Decision` 和 `Action` 阶段，我们将保持对单个角色的指针。例如，在
    `Decision` 阶段，这个指针从战斗顺序中的第一个角色开始。在每一帧，都会要求角色做出决策——这将是一个返回 `true` 如果角色已经做出决策，否则返回
    `false` 的函数。如果函数返回 `true`，指针将移动到下一个角色，依此类推，直到所有角色都做出决策，此时战斗过渡到 `Action` 阶段。
- en: 'The CPP for this file is fairly big, so let''s take it in small chunks. Firstly,
    the constructor and destructor are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的 CPP 代码相当大，所以让我们分块来看。首先，构造函数和析构函数如下：
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The constructor first assigns the player party and enemy party fields and then
    adds all players followed by all enemies to the combat order list. Finally, it
    sets the `tick` target index to 0 (the first character in the combat order) and
    the combat phase to `Decision`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数首先分配玩家团体和敌人团体字段，然后添加所有玩家，接着添加所有敌人到战斗顺序列表中。最后，它将 `tick` 目标索引设置为 0（战斗顺序中的第一个角色）并将战斗阶段设置为
    `Decision`。
- en: 'Next, the `Tick` function is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`Tick` 函数如下：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Firstly, we switch on the current combat phase. In the case of `Decision`, it
    currently just selects the next character or, if there is no next character, switches
    to the `Action` phase. It is the same for `Action`—except that if there is no
    next character, it loops back to the `Decision` phase.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们切换到当前的战斗阶段。在 `Decision` 的情况下，它目前只是选择下一个角色，如果没有下一个角色，则切换到 `Action` 阶段。对于
    `Action` 也是如此——除非没有下一个角色，它会循环回到 `Decision` 阶段。
- en: Later, this will be modified to call functions on the character in order to
    make and execute decisions (and additionally, the "select next character" code
    will only be called once the character has finished deciding or executing).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，这将修改为调用角色的函数以做出和执行决策（此外，“选择下一个角色”的代码只有在角色完成决策或执行后才会被调用）。
- en: In the case of `GameOver` or `Victory`, `Tick` returning `true` means combat
    is over. Otherwise, it first checks whether all players are dead (in this case,
    it is game over) or whether all enemies are dead (in this case, players win combat).
    In both cases, the function will return `true` as combat is finished.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameOver`或`Victory`的情况下，`Tick`返回`true`表示战斗结束。否则，它首先检查是否所有玩家都已死亡（在这种情况下，游戏结束）或是否所有敌人都已死亡（在这种情况下，玩家赢得战斗）。在这两种情况下，函数将返回`true`，因为战斗已经结束。
- en: The very end of the function returns `false`, which means combat has not yet
    finished.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最后一部分返回`false`，这意味着战斗尚未结束。
- en: 'Next, we have the `SetPhase` function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`SetPhase`函数：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function sets the combat phase, and in the case of `Action` or `Decision`,
    it sets the `tick` target to the first character in the combat order. Both `Victory`
    and `GameOver` have stubs to handle the respective states.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数设置战斗阶段，在`Action`或`Decision`的情况下，将`tick`目标设置为战斗顺序中的第一个角色。`Victory`和`GameOver`都有处理相应状态的存根。
- en: 'Finally, we have the `SelectNextCharacter` function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`SelectNextCharacter`函数：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function starts at the current `tickTargetIndex` and, from there, finds
    the first non-dead character in the combat order. If one is found, it sets the
    `tick` target index to the next index and the `tick` target to the found character.
    Otherwise, it sets the `tick` target index to -1 and the `tick` target to a null
    pointer (which is interpreted to mean no remaining characters in combat order).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从当前的`tickTargetIndex`开始，并从那里找到战斗顺序中的第一个非死亡角色。如果找到了一个，它将`tick`目标索引设置为下一个索引，并将`tick`目标设置为找到的角色。否则，它将`tick`目标索引设置为-1，并将`tick`目标设置为空指针（这被解释为战斗顺序中没有剩余的角色）。
- en: 'There''s a very important thing missing at this point: characters cannot yet
    make or execute decisions.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，缺少了一个非常重要的事情：角色还不能做出或执行决策。
- en: Let's add this to the `GameCharacter` class. For now, they will just be stubs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其添加到`GameCharacter`类中。目前，它们只是存根。
- en: 'Firstly, we''ll add the `testDelayTimer` field to `GameCharacter.h`. This will
    just be for testing purposes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向`GameCharacter.h`添加`testDelayTimer`字段。这只是为了测试目的：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we add several public functions to the class:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向类中添加几个公共函数：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We split `Decision` and `Action` into two functions each—the first function
    tells the character to begin making a decision or executing an action, the second
    function essentially queries the character until the decision is made or action
    is finished.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Decision`和`Action`分成两个函数每个——第一个函数告诉角色开始做出决策或执行动作，第二个函数本质上会查询角色直到决策做出或动作完成。
- en: 'The implementation for these two functions in `GameCharacter.cpp` will, for
    now, just log a message and a delay for 1 second:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这两个函数在`GameCharacter.cpp`中的实现只是记录一条消息和1秒的延迟：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''re also going to add a pointer to the combat instance. Since the combat
    engine references characters, having characters reference the combat engine would
    produce a circular dependency. To solve this, we''re going to add a forward declaration
    at the top of `GameCharacter.h` directly after our includes:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个指向战斗实例的指针。由于战斗引擎引用角色，而角色引用战斗引擎会产生循环依赖。为了解决这个问题，我们将在`GameCharacter.h`的顶部直接在我们的包含之后添加一个前向声明：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, the `include` statement for the combat engine will actually be placed
    in `GameCharacter.cpp` rather than in the header file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用于战斗引擎的`include`语句实际上会被放置在`GameCharacter.cpp`文件中，而不是头文件中：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we''ll make the combat engine call the `Decision` and `Action` functions.
    Firstly, we''ll add a protected variable to `CombatEngine.h`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使战斗引擎调用`Decision`和`Action`函数。首先，我们在`CombatEngine.h`中添加一个受保护的变量：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will be used to switch between, for example, `BeginMakeDecision` and `MakeDecision`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用于在例如`BeginMakeDecision`和`MakeDecision`之间切换。
- en: 'Next, we''ll modify the `Decision` and `Action` phases in the `Tick` function.
    Firstly, we''ll modify the `Decision` switch case:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改`Tick`函数中的`Decision`和`Action`阶段。首先，我们将修改`Decision`的switch case：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If `waitingForCharacter` is `false`, it calls `BeginMakeDecision` and sets `waitingForCharacter`
    to `true`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`waitingForCharacter`为`false`，它将调用`BeginMakeDecision`并将`waitingForCharacter`设置为`true`。
- en: Keep note of the brackets enclosing the whole case statement—if you do not add
    these brackets, you will get compile errors about the `decisionMade` initialization
    being skipped by the case statement.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 记住整个情况语句括号内的内容——如果你不添加这些括号，你将得到关于`decisionMade`初始化被情况语句跳过的编译错误。
- en: Next, it calls `MakeDecision` and passes the frame time. If this function returns
    `true`, it selects the next character, or failing that, switches to the `Action`
    phase.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它调用 `MakeDecision` 并传递帧时间。如果此函数返回 `true`，则选择下一个角色，或者如果没有成功，则切换到 `Action`
    阶段。
- en: 'The `Action` phase looks identical to the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action` 阶段看起来与以下内容相同：'
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we''ll modify `SelectNextCharacter` so that it sets `waitingForCharacter`
    to `false`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改 `SelectNextCharacter` 以将其 `waitingForCharacter` 设置为 `false`：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, a few remaining details: our combat engine should set the `CombatInstance`
    pointer of all characters to point to itself, which we''ll do in the constructor;
    then we''ll clear the pointer in the destructor and also release enemy pointers.
    So first, create a pointer to `combatInstance` in `GameCharacter.h` right after
    your `UProperty` declarations and before your protected variables:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一些剩余的细节：我们的战斗引擎应该将所有角色的 `CombatInstance` 指针设置为指向自身，我们将在构造函数中这样做；然后，在析构函数中清除指针，并释放敌人指针。所以首先，在
    `GameCharacter.h` 中创建一个指向 `combatInstance` 的指针，在你的 `UProperty` 声明之后和受保护的变量之前：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, in `CombatEngine.cpp`, replace your constructor and deconstructor with
    this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `CombatEngine.cpp` 中，将你的构造函数和析构函数替换为以下内容：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The combat engine itself is almost fully functional at this point. We still
    need to hook it up to the rest of the game, but with a way to trigger combat and
    update it from the game mode.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，战斗引擎几乎完全可用。我们仍然需要将其连接到游戏的其他部分，但要以一种可以从游戏模式触发战斗并更新它的方式。
- en: 'So, firstly in our `RPGGameMode` class, we will add a pointer to the current
    combat instance and also override the `Tick` function; additionally, keep track
    of a list of enemy characters (decorated with `UPROPERTY` so that enemies can
    be garbage-collected):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先在我们的 `RPGGameMode` 类中，我们将添加一个指向当前战斗实例的指针，并重写 `Tick` 函数；此外，跟踪一个敌人角色的列表（用
    `UPROPERTY` 装饰，以便敌人可以被垃圾回收）：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, in the `.cpp` file, we implement the `Tick` function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `.cpp` 文件中，我们实现 `Tick` 函数：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For now, this simply checks whether there is currently an instance of combat;
    if so, it calls that instance's `Tick` function. If it returns `true`, the game
    mode checks for either `Victory` or `GameOver` (for now, it just logs a message
    to the console). Then, it deletes the combat instance, sets the pointer to null,
    and clears the enemy party list (which will make the enemies eligible for garbage
    collection since the list was decorated with the `UPROPERTY` macro). It also enables
    the tick of the player actor (we're going to disable the tick when combat begins
    so that the player actor freezes in place for the duration of combat).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这仅仅检查是否当前有战斗实例；如果有，它将调用该实例的 `Tick` 函数。如果它返回 `true`，游戏模式将检查 `Victory` 或 `GameOver`（目前，它只是将消息记录到控制台）。然后，它删除战斗实例，将指针设置为空，并清除敌人队伍列表（这将使敌人有资格进行垃圾回收，因为列表被
    `UPROPERTY` 宏装饰）。它还启用了玩家角色的 `Tick`（我们将在战斗开始时禁用 `Tick`，以便玩家角色在战斗期间保持原地不动）。
- en: However, we aren't ready to start combat encounters just yet! There are no enemies
    for players to fight.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有准备好开始战斗遭遇战！玩家没有敌人可以战斗。
- en: We have a table of enemies defined, but our `GameCharacter` class does not support
    being initialized from `EnemyInfo`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个敌人表，但我们的 `GameCharacter` 类不支持从 `EnemyInfo` 初始化。
- en: 'To support this, we will add a new factory to the `GameCharacter` class (be
    sure you add the `include` statement for the `EnemyInfo` class as well):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一点，我们将在 `GameCharacter` 类中添加一个新的工厂（确保你也添加了 `EnemyInfo` 类的 `include` 语句）：
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Also, the implementation of this constructor overload in `GameCharacter.cpp`
    would be as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`GameCharacter.cpp` 中此构造函数重载的实现如下：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It's very simple by comparison; simply assign the name and null for `ClassInfo`
    (as enemies do not have classes associated with them) and other stats (both MMP
    and MP are set to zero, as enemy abilities will not consume MP).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相比，这非常简单；只需为 `ClassInfo` 分配名称和空值（因为敌人没有与之关联的类）以及其他统计数据（MMP 和 MP 都设置为零，因为敌人的能力不会消耗
    MP）。
- en: 'To test our combat system, we will create a function in `RPGGameMode.h` that
    can be called from the Unreal console:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的战斗系统，我们将在 `RPGGameMode.h` 中创建一个可以从 Unreal 控制台调用的函数：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `UFUNCTION(exec)` macro is what allows this function to be called as a console
    command.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`UFUNCTION(exec)` 宏允许此函数作为控制台命令被调用。'
- en: 'The implementation of this function is placed in `RPGGameMode.cpp`, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的实现位于 `RPGGameMode.cpp` 中，如下所示：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It locates the enemy Data Table, picks the enemy with ID `S1`, constructs a
    new `GameCharacter`, constructs a list of enemies, adds the new enemy character,
    and then creates a new instance of `CombatEngine`, passing the player party and
    the enemy list. It also disables the tick of the player actor so that the player
    stops updating when combat begins.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 它定位敌人数据表，选择 ID 为 `S1` 的敌人，构建一个新的 `GameCharacter`，构建一个敌人列表，添加新的敌人角色，然后创建一个新的
    `CombatEngine` 实例，传递玩家团体和敌人列表。它还禁用了玩家演员的 tick，这样当战斗开始时玩家就停止更新。
- en: Finally, you should be able to test the combat engine. Start the game and press
    the tilde (*~*) key to bring up the console command textbox. Enter `TestCombat`
    and press *Enter*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该能够测试战斗引擎。启动游戏并按波浪号 (*~*) 键打开控制台命令文本框。输入 `TestCombat` 并按 *Enter*。
- en: 'Take a look at the output window and you should see something like the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 查看输出窗口，你应该看到以下内容：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This shows that the combat engine is working as intended—firstly, all characters
    make a decision, execute their decisions, then they make a decision again, and
    so on. Since nobody is actually doing anything (much less dealing any damage),
    combat just goes on forever at the moment.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明战斗引擎按预期工作——首先，所有角色做出决策，执行他们的决策，然后再次做出决策，依此类推。由于实际上没有人真正采取任何行动（更不用说造成任何伤害），目前战斗只是无限期地进行。
- en: 'There are two issues with this: firstly, the aforementioned problem that nobody
    actually does anything yet. Additionally, player characters need to have a different
    way of making decisions than enemies (player characters will need a UI to pick
    actions, whereas enemies should pick actions automatically).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有两个问题：首先，上述问题实际上没有人真正采取任何行动。此外，玩家角色需要有一种不同于敌人的决策方式（玩家角色将需要一个用户界面来选择动作，而敌人应该自动选择动作）。
- en: We'll solve the first issue before tackling decision making.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在处理决策之前解决第一个问题。
- en: Performing actions
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行动作
- en: In order to allow characters to perform actions, we will boil all combat actions
    down to a single common interface. A good place to start is for this interface
    to map to what we already have—that is, the character's `BeginExecuteAction` and
    `ExecuteAction` functions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许角色执行动作，我们将所有战斗动作简化为单个通用接口。一个好的开始是让这个接口映射到我们已有的东西——也就是说，角色的 `BeginExecuteAction`
    和 `ExecuteAction` 函数。
- en: 'Let''s create a new `ICombatAction` interface for this, which can start off
    as a class that is not parented to anything and in a new path called `Source/RPG/Combat/Actions`;
    the `ICombatAction.h` file should look like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个创建一个新的 `ICombatAction` 接口，它可以从一个没有任何父类的类开始，并放在一个名为 `Source/RPG/Combat/Actions`
    的新路径中；`ICombatAction.h` 文件应该看起来像这样：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`BeginExecuteAction` takes a pointer to the character that this action is executing
    for. `ExecuteAction`, as before, takes the duration of the previous frame in seconds.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeginExecuteAction` 接收执行此动作的角色指针。`ExecuteAction` 如前所述，接收上一帧的持续时间（以秒为单位）。'
- en: 'In `ICombatAction.cpp`, remove the default constructor and deconstructor so
    that the file looks like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ICombatAction.cpp` 中，移除默认构造函数和析构函数，使文件看起来像这样：
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Next, we can create a new empty C++ class to implement this interface. Just
    as a test, we'll replicate the functionality that the characters are already doing
    (that is, absolutely nothing) in a new class called `TestCombatAction` to be pathed
    to the `Source/RPG/Combat/Actions` folder.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个新的空 C++ 类来实现这个接口。仅作为一个测试，我们将在一个名为 `TestCombatAction` 的新类中复制角色已经执行的功能（即，绝对不做任何事情），并将其路径设置为
    `Source/RPG/Combat/Actions` 文件夹。
- en: 'Firstly, the header will be as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，头文件将如下所示：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `.cpp` file will be as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`.cpp` 文件将如下所示：'
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next, we'll change the character so that it can store and execute actions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更改角色，使其能够存储和执行动作。
- en: 'Firstly, let''s replace the test delay timer field with a combat action pointer.
    Later, we''ll make it public for when we create a decision making system in `GameCharacter.h`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们用战斗动作指针替换测试延迟计时器字段。稍后，我们将使其在 `GameCharacter.h` 中创建决策系统时公开：
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Also remember to include `ICombatAction` at the top of `GameCharacter.h`, followed
    by a class declaration for `ICombatAction`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得在 `GameCharacter.h` 的顶部包含 `ICombatAction`，然后声明 `ICombatAction` 类：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we need to change our decision functions to assign a combat action, and
    the action functions to execute this action in `GameCharacter.cpp`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更改我们的决策函数以分配战斗动作，并将动作函数执行此动作在 `GameCharacter.cpp` 中：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Also remember to use `include TestCombatAction` at the top of `GameCharacter.cpp`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记得在`GameCharacter.cpp`的顶部使用`include TestCombatAction`：
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`BeginMakeDecision` now assigns a new instance of `TestCombatAction`. `MakeDecision`
    just returns `true`. `BeginExecuteAction` calls the function of the same name
    on the stored combat action, passing the character as the pointer. Finally, `ExecuteAction`
    calls the function of the same name, and if the result is `true`, it deletes the
    pointer and returns `true`; otherwise it returns `false`.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeginMakeDecision`现在分配一个新的`TestCombatAction`实例。`MakeDecision`仅返回`true`。`BeginExecuteAction`调用存储的战斗动作上的同名函数，并将角色作为指针传递。最后，`ExecuteAction`调用同名函数，如果结果是`true`，则删除指针并返回`true`；否则返回`false`。'
- en: By running this and testing combat, you should get nearly identical output,
    but now it says `does nothing` instead of `executing action`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行此代码并测试战斗，你应该得到几乎相同的输出，但现在它显示的是`does nothing`而不是`executing action`。
- en: Now that we have a way for characters to store and execute actions, we can work
    on a decision making system for characters.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种让角色存储和执行动作的方法，我们可以着手为角色开发一个决策系统。
- en: Making decisions
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做出决策
- en: 'As we did with actions, we''re going to create an interface for decision making
    that follows a similar pattern to the `BeginMakeDecision` and `MakeDecision` functions.
    Similar to the `ICombatAction` class, we will create an empty `IDecisionMaker`
    class and we will path it to a new directory, `Source/RPG/Combat/DecisionMakers`.
    The following will be `IDecisionMaker.h`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对动作所做的那样，我们将创建一个用于决策的接口，其模式与`BeginMakeDecision`和`MakeDecision`函数相似。类似于`ICombatAction`类，我们将创建一个空的`IDecisionMaker`类，并将其放置到新的目录`Source/RPG/Combat/DecisionMakers`中。以下将是`IDecisionMaker.h`的内容：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Also, remove the constructor and deconstructor to `IDecisionMaker.cpp`, so
    that it looks like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从`IDecisionMaker.cpp`中删除构造函数和析构函数，使其看起来像这样：
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we can create the `TestDecisionMaker` C++ class and path it to `Source/RPG/Combat/DecisionMakers`
    as well. Then, program `TestDecisionMaker.h` as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建`TestDecisionMaker` C++类，并将其放置到`Source/RPG/Combat/DecisionMakers`目录中。然后，按照以下方式编程`TestDecisionMaker.h`：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, program `TestDecisionMaker.cpp` as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式编程`TestDecisionMaker.cpp`：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we''ll add a pointer to `IDecisionMaker` to the game character class
    and modify the `BeginMakeDecision` and `MakeDecision` functions to use the decision
    maker in `GameCharacter.h`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在游戏角色类中添加一个指向`IDecisionMaker`的指针，并修改`BeginMakeDecision`和`MakeDecision`函数以在`GameCharacter.h`中使用决策者：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Also remember to include `ICombatAction` at the top of `GameCharacter.h` followed
    by a class declaration for `ICombatAction`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记得在`GameCharacter.h`的顶部包含`ICombatAction`，然后声明`ICombatAction`类：
- en: '[PRE49]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, replace the `BeginDestroy`, `BeginMakeDecision`, and `MakeDecision` functions
    in `GameCharacter.cpp` with this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`GameCharacter.cpp`中的`BeginDestroy`、`BeginMakeDecision`和`MakeDecision`函数替换为以下内容：
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that we delete the decision maker in the destructor. The decision maker
    will be assigned when the character is created, and should therefore be deleted
    when the character is released.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在析构函数中删除决策者。决策者将在角色创建时分配，因此当角色释放时应该删除。
- en: 'We will then include `TestDecisionMaker` implementations to allow each party
    to make combat decisions, so include `TestDecisionMaker` at the top of the class:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将包含`TestDecisionMaker`实现，以便每个阵营都能做出战斗决策，因此请在类的顶部包含`TestDecisionMaker`：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The final step here is to assign a decision maker in the constructors for the
    character. To both constructor overloads, add the following line of code: `character->decisionMaker
    = new TestDecisionMaker();`. When you are finished, the player and enemy character
    constructors should look like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，最终的步骤是为角色的构造函数分配一个决策者。为两个构造函数重载添加以下代码行：`character->decisionMaker = new TestDecisionMaker();`。当你完成时，玩家和敌人角色的构造函数应该看起来像这样：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Run the game and test combat again, and you should get very similar output to
    what was already there. However, the big difference is that it's now possible
    to assign different implementations of a decision maker to different characters,
    and those decision makers have an easy way to assign combat actions to be executed.
    For instance, it will now be easy to make our test combat action deal with the
    damage of a target. However, before we do this, let's make a small change to the
    `GameCharacter` class.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并再次测试战斗，你应该得到与之前非常相似的输出。然而，最大的不同之处在于现在可以为不同的角色分配不同的决策者实现，并且这些决策者有简单的方法来分配要执行的战斗动作。例如，现在将我们的测试战斗动作处理目标伤害将变得很容易。然而，在我们这样做之前，让我们对`GameCharacter`类做一些小的更改。
- en: Target selection
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择目标
- en: We're going to add a field to `GameCharacter` that identifies a character as
    either a player or an enemy. Additionally, we'll add a `SelectTarget` function
    that selects the first live character from either the current combat instance's
    `enemyParty` or `playerParty`, depending on whether this character is a player
    or an enemy.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`GameCharacter`中添加一个字段来标识角色是玩家还是敌人。此外，我们还将添加一个`SelectTarget`函数，该函数从当前的战斗实例的`enemyParty`或`playerParty`中选择第一个活着的角色，具体取决于该角色是玩家还是敌人。
- en: 'Firstly, in `GameCharacter.h`, we''ll add a public `isPlayer` field:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`GameCharacter.h`中，我们将添加一个公共的`isPlayer`字段：
- en: '[PRE53]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, we''ll add a `SelectTarget` function, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个`SelectTarget`函数，如下所示：
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In `GameCharacter.cpp`, we''ll assign the `isPlayer` field in the constructors
    (this is easy enough, as we have separate constructors for players and enemies):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameCharacter.cpp`中，我们将在构造函数中分配`isPlayer`字段（这很简单，因为我们有玩家和敌人分开的构造函数）：
- en: '[PRE55]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, the `SelectTarget` function is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`SelectTarget`函数如下所示：
- en: '[PRE56]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This first figures out which list (enemies or players) to use as potential targets
    and then goes through that list to find the first non-dead target. If there is
    no target, this function returns a null pointer.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这首先确定使用哪个列表（敌人或玩家）作为潜在的目标，然后遍历该列表以找到第一个非死亡目标。如果没有目标，此函数返回一个空指针。
- en: Dealing damage
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 造成伤害
- en: Now that there's an easy way to select targets, let's make our `TestCombatAction`
    class finally deal some damage!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了选择目标的方法，让我们让`TestCombatAction`类最终造成一些伤害！
- en: 'We''ll add a couple of fields to maintain references to the character and the
    target, and also a constructor that takes the target as a parameter:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一些字段来维护对角色和目标的引用，并添加一个接受目标作为参数的构造函数：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Also, the implementation is by creating and updating the `BeginExecuteAction`
    function in `TestCombatAction.cpp`, as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，实现方式是通过在`TestCombatAction.cpp`中创建和更新`BeginExecuteAction`函数，如下所示：
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And then have the constructor of the class set the target:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让类的构造函数设置目标：
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Firstly, the constructor assigns the target pointer. Then, the `BeginExecuteAction`
    function assigns the character reference and checks to see whether the target
    is alive. If the target is dead, it picks a new target via the `SelectTarget`
    function we just created. If the target pointer is now null, there is no target
    and this function just returns null. Otherwise, it logs a message of the form
    *[character] attacks [target]*, subtracts some HP from the target, and sets the
    delay timer as before.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构造函数分配目标指针。然后，`BeginExecuteAction`函数分配角色引用并检查目标是否存活。如果目标是死亡的，它将通过我们刚刚创建的`SelectTarget`函数选择一个新的目标。如果目标指针现在是空，则没有目标，此函数仅返回空。否则，它记录一个类似*[character]
    attacks [target]*的消息，从目标中减去一些HP，并设置延迟计时器，就像之前一样。
- en: 'The next step is to change our `TestDecisionMaker` to pick a target and pass
    this target to the `TestCombatAction` constructor. This is a relatively simple
    change in `TestDecisionMaker.cpp`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将我们的`TestDecisionMaker`更改为选择一个目标并将其传递给`TestCombatAction`构造函数。这在`TestDecisionMaker.cpp`中是一个相对简单的更改：
- en: '[PRE60]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'At this point, you should be able to run the game, start a test encounter,
    and also see an output similar to the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够运行游戏，开始测试遭遇战，并看到以下类似的输出：
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Finally, we have a combat system in which our two parties can attack each other
    and one or the other can win.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个战斗系统，其中我们的两个阵营可以互相攻击，一方或另一方可以获胜。
- en: Next, we'll begin hooking this up to a user interface.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始将其连接到用户界面。
- en: Combat UI with UMG
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用UMG的战斗UI
- en: To get started, we'll need to set up our project to properly import UMG and
    Slate-related classes.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要设置我们的项目以正确导入UMG和Slate相关的类。
- en: 'First, open `RPG.Build.cs` (or `[ProjectName].Build.cs`) and change the first
    line of the constructor to the following code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开 `RPG.Build.cs`（或 `[ProjectName].Build.cs`）并将构造函数的第一行代码更改为以下代码：
- en: '[PRE62]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This adds the `UMG`, `Slate`, and `SlateCore` strings to the existing string
    array.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `UMG`、`Slate` 和 `SlateCore` 字符串添加到现有的字符串数组中。
- en: 'Next, open `RPG.h` and make sure the following lines of code are there:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `RPG.h` 并确保以下代码行存在：
- en: '[PRE63]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now compile the project. This may take a while.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译项目。这可能需要一段时间。
- en: Next, we're going to create a base class for the combat UI. Basically, we'll
    use this base class to allow our C++ game code to communicate with Blueprint UMG
    code by defining Blueprint-implementable functions in the header, which are functions
    that can be implemented by Blueprint and called from C++.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个用于战斗 UI 的基类。基本上，我们将使用这个基类来允许我们的 C++ 游戏代码通过在头文件中定义蓝图可实现的函数与蓝图 UMG
    代码进行通信，这些函数是蓝图可以实现的函数，可以从 C++ 中调用。
- en: 'Create a new class named `CombatUIWidget` and select `UserWidget` as the parent
    class; then path it to `Source/RPG/UI`. Replace the contents of `CombatUIWidget.h`
    with the following code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `CombatUIWidget` 的新类，并将其父类选择为 `UserWidget`；然后将其路径设置为 `Source/RPG/UI`。用以下代码替换
    `CombatUIWidget.h` 中的内容：
- en: '[PRE64]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: For the most part, we're just defining a couple of functions. The `AddPlayerCharacterPanel`
    and `AddEnemyCharacterPanel` functions will be responsible for taking a character
    pointer and spawning a widget for that character (to display the character's current
    status).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们只是在定义几个函数。`AddPlayerCharacterPanel` 和 `AddEnemyCharacterPanel` 函数将负责接受一个角色指针并为该角色生成一个小部件（以显示角色的当前状态）。
- en: Next, after compiling the code, back in the editor, create a new folder in the
    `Contents/Blueprints` directory called `UI`. In the `Content/Blueprints/UI` directory,
    create a new Widget Blueprint named `CombatUI`. After you've created and opened
    the Blueprint, go to **File** | **Reparent Blueprint** and select **CombatUIWidget**
    as the parent class.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 编译代码后，回到编辑器中，在 `Contents/Blueprints` 目录中创建一个名为 `UI` 的新文件夹。在 `Content/Blueprints/UI`
    目录中，创建一个名为 `CombatUI` 的新 Widget 蓝图。在创建并打开蓝图后，转到 **文件** | **重新父化蓝图** 并选择 **CombatUIWidget**
    作为父类。
- en: In the **Designer** interface, create two Horizontal Box widgets and name them
    `enemyPartyStatus` and `playerPartyStatus`. These will hold child widgets for
    enemies and players respectively, to display the status of each character. For
    both of these, be sure to enable the **Is Variable** checkbox so that they will
    be available as variables to Blueprint. Save and compile the Blueprint.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **设计师** 界面中，创建两个水平框小部件并将它们命名为 `enemyPartyStatus` 和 `playerPartyStatus`。这些将分别持有敌人和玩家的子小部件，以显示每个角色的状态。对于这两个，务必确保启用
    **Is Variable** 复选框，这样它们就会作为变量对蓝图可用。保存并编译蓝图。
- en: We will position the `enemyPartyStatus` Horizontal Box at the top of the Canvas
    Panel. It will help to first set a top horizontal anchor.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `enemyPartyStatus` 水平框定位在画布面板的顶部。首先设置一个顶部水平锚点会有所帮助。
- en: 'Then set the values for the Horizontal Box as follows, **Offset Left**: 10,
    **Position Y**: 10, **Offset Right**: 10, **Size Y**: 200.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '然后将水平框的值设置为以下内容，**偏移左**: 10，**位置 Y**: 10，**偏移右**: 10，**大小 Y**: 200。'
- en: 'Proceed to position the `playerPartyStatus` Horizontal Box in a similar way;
    the only major difference is that we will anchor the box to the bottom of the
    Canvas Panel and position it so it spans the bottom of the screen:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式定位 `playerPartyStatus` 水平框；唯一的重大区别是我们将框锚定在画布面板的底部，并定位使其跨越屏幕底部：
- en: '![Combat UI with UMG](img/B04548_03_07.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![带有 UMG 的战斗 UI](img/B04548_03_07.jpg)'
- en: Next, we'll create widgets to display player and enemy character statuses. Firstly,
    we'll make a base widget that each will inherit from.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建用于显示玩家和敌人角色状态的小部件。首先，我们将创建一个基小部件，每个小部件都将从中继承。
- en: Create a new Widget Blueprint and name it `BaseCharacterCombatPanel`. In this
    Blueprint, navigate to the graph, then add a new variable from the **MyBlueprint**
    tab, **CharacterTarget**, and select the **Game Character** variable type from
    the **Object Reference** category.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Widget 蓝图并将其命名为 `BaseCharacterCombatPanel`。在这个蓝图里，导航到图表，然后从 **MyBlueprint**
    选项卡添加一个新的变量，**CharacterTarget**，并从 **对象引用** 类别中选择 **Game Character** 变量类型。
- en: Next, we'll make separate widgets for the enemies and players.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为敌人和玩家创建单独的小部件。
- en: Create a new Widget Blueprint and name it `PlayerCharacterCombatPanel`. Set
    the new Blueprint's parent to `BaseCharacterCombatPanel`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Widget 蓝图并将其命名为 `PlayerCharacterCombatPanel`。将新蓝图的父母设置为 `BaseCharacterCombatPanel`。
- en: 'In the **Designer** interface, add three text widgets. One label will be for
    the character''s name, another for the character''s HP, and third one for the
    character''s MP. Position each Text Block so that they are anchored to the bottom
    left of the screen, and well within the 200 high pixels of the `playerPartyStatus`
    box size that we created in the `CombatUI` widget:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Designer**界面中添加三个文本小部件。一个标签用于角色的名称，另一个用于角色的HP，第三个用于角色的MP。将每个文本块定位在屏幕的左下角，并且完全在`playerPartyStatus`框大小的200高像素内，这是我们之前在`CombatUI`小部件中创建的：
- en: '![Combat UI with UMG](img/B04548_03_08.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![战斗UI与UMG](img/B04548_03_08.jpg)'
- en: Also be sure to check **Size to Content** located in the **Details** panel of
    each Text Block so that the Text Block can resize if the content does not fit
    within the Text Block parameters.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 确保检查每个文本块的**Details**面板中的**Size to Content**，以便文本块可以根据内容调整大小，如果内容不适合文本块参数。
- en: 'Create a new binding for each of these by selecting the widget and clicking
    on **Bind** next to the **Text** input in the **Details** panel:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择小部件并点击**Details**面板中**Text**输入旁边的**Bind**来为这些创建新的绑定：
- en: '![Combat UI with UMG](img/B04548_03_09.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![战斗UI与UMG](img/B04548_03_09.jpg)'
- en: This will create a new Blueprint function that will be responsible for generating
    the Text Block.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的蓝图函数，该函数将负责生成文本块。
- en: 'To bind the HP Text Block, for example, you can execute the following steps:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要绑定HP文本块，例如，您可以执行以下步骤：
- en: Right-click in an open area in the grid, search for **Get Character Target**,
    and then select it.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网格的空白区域右键单击，搜索**Get Character Target**，然后选择它。
- en: Drag the output pin of this node and select **Get HP** under **Variables** |
    **Character Info**.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此节点的输出引脚拖动并选择**Variables** | **Character Info**下的**Get HP**。
- en: 'Create a new **Format Text** node. Set the text to **HP: {HP}** and then connect
    the output of **Get HP** to the **HP** input of the **Format Text** node.'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个新的**Format Text**节点。将文本设置为**HP: {HP}**，然后将**Get HP**的输出连接到**Format Text**节点的**HP**输入。'
- en: Finally, connect the output of the **Format Text** node to the **Return** value
    of the **Return** node.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将**Format Text**节点的输出连接到**Return**节点的**Return**值。
- en: You can repeat similar steps for the character name and MP Text Blocks.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重复类似的步骤为角色名称和MP文本块。
- en: After you've created `PlayerCharacterCombatPanel`, you can repeat the same steps
    to create `EnemyCharacterCombatPanel`, except without the MP Text Block (as mentioned
    before, enemies do not consume MP). The only major difference is that the Text
    Blocks in `EnemyCharacterCombatPanel` need to be placed at the top of the screen
    to match the positioning of the `enemyPartyStatus` Horizontal Box from the `CombatUI`
    widget.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在您创建`PlayerCharacterCombatPanel`之后，您可以重复相同的步骤来创建`EnemyCharacterCombatPanel`，除了不需要MP文本块（如前所述，敌人不消耗MP）。唯一的重大区别是`EnemyCharacterCombatPanel`中的文本块需要放置在屏幕顶部，以匹配`CombatUI`小部件中的`enemyPartyStatus`水平框的位置。
- en: 'The resulting graph for displaying the MP will look something like the following
    screenshot:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 显示MP的结果图将类似于以下截图：
- en: '![Combat UI with UMG](img/B04548_03_10.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![战斗UI与UMG](img/B04548_03_10.jpg)'
- en: Now that we have widgets for players and enemies, let's implement the `AddPlayerCharacterPanel`
    and `AddEnemyCharacterPanel` functions in the `CombatUI` Blueprint.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了玩家和敌人的小部件，让我们在`CombatUI`蓝图实现`AddPlayerCharacterPanel`和`AddEnemyCharacterPanel`函数。
- en: 'Firstly, we''ll create a helper Blueprint function to spawn character status
    widgets. Name this new function `SpawnCharacterWidget` and add the following parameters
    to the input:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个辅助蓝图函数来生成角色状态小部件。将此新函数命名为`SpawnCharacterWidget`，并将以下参数添加到输入中：
- en: '**Target Character** (of type Game Character Reference)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标角色**（类型为Game Character Reference）'
- en: '**Target Panel** (of type Panel Widget Reference)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标面板**（类型为Panel Widget Reference）'
- en: '**Class** (of type Base Character Combat Panel Class)'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Class**（类型为Base Character Combat Panel Class）'
- en: 'This function will perform the following steps:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将执行以下步骤：
- en: Create a new widget of the given class using **Create Widget**.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Create Widget**创建给定类的新小部件。
- en: Cast the new widget to the `BaseCharacterCombatPanel` type.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新小部件投射到`BaseCharacterCombatPanel`类型。
- en: Set the **Character Target** of the result to the **TargetCharacter** input.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果的**Character Target**设置为**TargetCharacter**输入。
- en: Add the new widget as a child of the **TargetPanel** input.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新小部件作为**TargetPanel**输入的子项添加。
- en: 'And that looks like this in Blueprint:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图中的样子如下所示：
- en: '![Combat UI with UMG](img/B04548_03_11.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![战斗UI与UMG](img/B04548_03_11.jpg)'
- en: 'Next, in the event graph for the `CombatUI` Blueprint, right-click and add
    the `EventAddPlayerCharacterPanel` and `EventAddEnemyCharacterPanel` events. Hook
    each of these up to a `SpawnCharacterWidget` node, connecting the **Target** output
    to the **Target Character** input and the appropriate panel variable to the **Target
    Panel** input, as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`CombatUI`蓝图的事件图中，右键单击并添加`EventAddPlayerCharacterPanel`和`EventAddEnemyCharacterPanel`事件。将每个事件连接到`SpawnCharacterWidget`节点，将**目标**输出连接到**目标角色**输入，将适当的面板变量连接到**目标面板**输入，如下所示：
- en: '![Combat UI with UMG](img/B04548_03_12.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![带有UMG的战斗UI](img/B04548_03_12.jpg)'
- en: 'Finally, we can spawn this UI from our game mode at the beginning of combat
    and destroy it at the end of combat. In the header of `RPGGameMode`, add a pointer
    to `UCombatUIWidget` and also a class to spawn for the combat UI (so we can select
    a Widget Blueprint that inherits from our `CombatUIWidget` class); these should
    be public:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在战斗开始时从我们的游戏模式中生成这个UI，并在战斗结束时销毁它。在`RPGGameMode`的头部添加一个指向`UCombatUIWidget`的指针，并添加一个用于生成战斗UI的类（这样我们就可以选择继承自我们的`CombatUIWidget`类的Widget蓝图）；这些应该是公共的：
- en: '[PRE65]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Also make sure that `RPGGameMode.h` includes the `CombatWidget`; at this point,
    your list of includes at the top of `RPGGameMode.h` should look like this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保`RPGGameMode.h`包含`CombatWidget`；在这个时候，`RPGGameMode.h`顶部的内容列表应该看起来像这样：
- en: '[PRE66]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'At the end of the `TestCombat` function in `RPGGameMode.cpp`, we''ll spawn
    a new instance of this widget, as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RPGGameMode.cpp`中的`TestCombat`函数结束时，我们将生成这个小部件的新实例，如下所示：
- en: '[PRE67]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This creates the widget, adds the viewport to it, adds a mouse cursor, and then
    calls its `AddPlayerCharacterPanel` and `AddEnemyCharacterPanel` functions for
    all players and enemies respectively.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建小部件，将其添加到视图中，添加鼠标光标，然后分别调用其`AddPlayerCharacterPanel`和`AddEnemyCharacterPanel`函数，为所有玩家和敌人。
- en: 'After combat is over, we''ll remove the widget from the viewport and set the
    reference to null so it can be garbage-collected; your `Tick` function should
    now look like this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 战斗结束后，我们将从视图中移除小部件，并将引用设置为null，以便它可以被垃圾回收；你的`Tick`函数现在应该看起来像这样：
- en: '[PRE68]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: At this point, you can compile, but the game will crash if you test the combat.
    That is because you need to set `DefaultRPGGameMode` class defaults to use `CombatUI`
    as the `CombatUIClass` that you created in `RPGGameMode.h`. Otherwise, the system
    will not know that the `CombatUIClass` variable is to be pointing to `CombatUI`,
    which is a widget, and therefore won't be able to create the widget. Note that
    the editor may crash the first time you do this step.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可以编译，但如果测试战斗，游戏将会崩溃。这是因为你需要设置`DefaultRPGGameMode`类的默认值，使用`CombatUI`作为你在`RPGGameMode.h`中创建的`CombatUIClass`。否则，系统将不知道`CombatUIClass`变量应该指向`CombatUI`，这是一个小部件，因此无法创建它。请注意，编辑器在执行此步骤时可能会崩溃。
- en: '![Combat UI with UMG](img/B04548_03_13.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![带有UMG的战斗UI](img/B04548_03_13.jpg)'
- en: Now, if you run the game and start combat, you should see the status of the
    goblin and the status of the player. Both should have their HP reducing until
    the goblin's health reaches zero; at this point, the UI disappears (as combat
    is over).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行游戏并开始战斗，你应该能看到哥布林的状态和玩家的状态。两者的生命值都应该会减少，直到哥布林的生命值达到零；在这个时候，用户界面将消失（因为战斗已经结束）。
- en: Next, we're going to change things so that instead of the player characters
    automatically making decisions, the player gets to choose their actions via the
    UI.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进行一些更改，使得玩家角色不再是自动做出决策，而是玩家可以通过用户界面选择他们的行动。
- en: UI-driven decision making
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI驱动的决策制定
- en: One idea is to change how the decision maker is assigned to the player—rather
    than assigning one when the player is first created, we could make our `CombatUIWidget`
    class implement the decision maker and just assign it when combat starts (and
    clear the pointer when combat ends).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 一个想法是改变决策者分配给玩家的方式——而不是在玩家首次创建时分配，我们可以在战斗开始时让我们的`CombatUIWidget`类实现决策者，并在战斗开始时分配它（在战斗结束时清除指针）。
- en: 'We''re going to have to make a couple of changes to `GameCharacter.cpp`. First,
    in the player overload of `CreateGameCharacter`, remove the following line of
    code:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`GameCharacter.cpp`进行一些更改。首先，在`CreateGameCharacter`的玩家重载中，删除以下代码行：
- en: '[PRE69]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, in the `BeginDestroy` function, we''ll wrap the `delete` line in an `if`
    statement:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`BeginDestroy`函数中，我们将`delete`行包裹在一个`if`语句中：
- en: '[PRE70]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The reason for this is that the decision maker for players will be the UI—and
    we do not want to delete the UI manually (doing so would crash Unreal). Instead,
    the UI will be garbage-collected automatically as long as there are no `UPROPERY`
    decorated pointers to it.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是玩家的决策者将是UI——我们不希望手动删除UI（这样做会导致Unreal崩溃）。相反，只要没有用`UPROPERTY`装饰的指针指向它，UI将自动进行垃圾回收。
- en: 'Next, in `CombatUIWidget.h`, we''ll make the class implement the `IDecisionMaker`
    interface and add `BeginMakeDecision` and `MakeDecision` as public functions:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`CombatUIWidget.h`中，我们将使类实现`IDecisionMaker`接口，并添加`BeginMakeDecision`和`MakeDecision`作为公共函数：
- en: '[PRE71]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We''re also going to add a couple of helper functions that can be called by
    our UI Blueprint graph:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加几个辅助函数，这些函数可以在我们的UI蓝图图中调用：
- en: '[PRE72]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The first function retrieves a list of potential targets for the current character.
    The second function will give the character a new `TestCombatAction` with the
    given target.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数检索当前角色的潜在目标列表。第二个函数将为角色提供一个带有指定目标的新的`TestCombatAction`。
- en: 'Additionally, we''ll add a function to be implemented in the Blueprint that
    will show a set of actions for the current character:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将添加一个在蓝图中实现的功能，用于显示当前角色的操作集：
- en: '[PRE73]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We''re also going to add a flag and a definition for `currentTarget`, as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个标志和`currentTarget`的定义，如下所示：
- en: '[PRE74]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This will be used to signal that a decision has been made (and that `MakeDecision`
    should return `true`).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用于表示已做出决策（并且`MakeDecision`应该返回`true`）。
- en: 'The implementations of these four functions are fairly straightforward in `CombatUIWidget.cpp`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这些四个函数的实现相当简单，在`CombatUIWidget.cpp`中：
- en: '[PRE75]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`BeginMakeDecision` sets the current target, sets the `finishedDecision` flag
    to `false`, and then calls `ShowActionsPanel` (which will be handled in our UI
    Blueprint graph).'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeginMakeDecision`设置当前目标，将`finishedDecision`标志设置为`false`，然后调用`ShowActionsPanel`（这将在我们的UI蓝图图中处理）。'
- en: '`MakeDecision` simply returns the value of the `finishedDecision` flag.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeDecision`简单地返回`finishedDecision`标志的值。'
- en: '`AttackTarget` assigns a new `TestCombatAction` to the character and then sets
    `finishedDecision` to `true` to signal that a decision has been made.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttackTarget`将一个新的`TestCombatAction`分配给角色，并将`finishedDecision`设置为`true`以表示已做出决策。'
- en: Finally, `GetCharacterTargets` returns an array of this character's possible
    opponents.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`GetCharacterTargets`返回一个包含此角色可能对手的数组。
- en: 'Since the UI now implements the `IDecisionMaker` interface, we can assign it
    as the decision maker for the player characters. Firstly, in the `TestCombat`
    function of `RPGGameMode.cpp`, we''ll change the loop that iterates over the characters
    so that it assigns the UI as the decision maker:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 由于UI现在实现了`IDecisionMaker`接口，我们可以将其分配为玩家角色的决策者。首先，在`RPGGameMode.cpp`中的`TestCombat`函数，我们将改变遍历角色的循环，使其将UI分配为决策者：
- en: '[PRE76]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then, we''ll set the players'' decision makers to null when combat is over:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当战斗结束时，我们将玩家的决策者设置为null：
- en: '[PRE77]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now, player characters will use the UI to make decisions. However, the UI currently
    does nothing. We'll need to work in Blueprint to add this functionality.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩家角色将使用UI来做出决策。然而，UI目前什么也不做。我们需要在蓝图编辑器中添加这个功能。
- en: Firstly, we'll create a widget for the attack target options. Name it `AttackTargetOption`,
    add a button, and put a Text Block in the button. Check **Size to Content** so
    that the button will dynamically resize to any Text Block that is in the button.
    Then position it at the top-left corner of the Canvas Panel.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个用于攻击目标选项的小部件。命名为`AttackTargetOption`，添加一个按钮，并在按钮中放置一个文本块。勾选**大小适应内容**，以便按钮可以动态调整大小以适应按钮中的任何文本块。然后将其放置在画布面板的左上角。
- en: In the Graph, add two new variables. One is the `targetUI` of the Combat UI
    Reference type. The other is the `target` of the Game Character Reference type.
    From the **Designer** view, click on your button, then scroll down the **Details**
    panel and click on **OnClicked** to create an event for the button. The button
    will use the `targetUI` reference to call the **Attack Target** function and the
    `target` reference (which is the target this button represents) to pass to the
    **Attack Target** function.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中添加两个新的变量。一个是战斗UI引用类型的`targetUI`。另一个是游戏角色引用类型的`target`。从**设计师**视图，点击你的按钮，然后滚动到**详情**面板并点击**OnClicked**来为按钮创建一个事件。按钮将使用`targetUI`引用来调用**攻击目标**函数，并将`target`引用（即此按钮代表的目标）传递给**攻击目标**函数。
- en: 'The graph for the button-click event is fairly simple; just route the execution
    to the **Attack Target** function of the assigned `targetUI` and pass the `target`
    reference as a parameter:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮点击事件的图相当简单；只需将执行路由到分配的`targetUI`的**攻击目标**函数，并将`target`引用作为参数传递：
- en: '![UI-driven decision making](img/B04548_03_14.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![UI驱动的决策制定](img/B04548_03_14.jpg)'
- en: 'Next, we''ll add a panel for character actions to the main combat UI. This
    is a Canvas Panel with a single button child for **Attack** and a Vertical Box
    for the target list:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为主战斗UI添加一个用于角色动作的面板。这是一个包含单个用于**攻击**的按钮子项和用于目标列表的垂直框的画布面板：
- en: '![UI-driven decision making](img/B04548_03_15.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![UI驱动的决策制定](img/B04548_03_15.jpg)'
- en: Name the **Attack** button `attackButton`. Name the Vertical Box `targets`.
    And name the Canvas Panel encapsulating these items as `characterActions`. These
    should have **Is Variable** enabled so that they are visible to Blueprint.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 将**攻击**按钮命名为`attackButton`。将垂直框命名为`targets`。将封装这些项的画布面板命名为`characterActions`。这些应该启用**是变量**，以便它们对蓝图可见。
- en: 'Then, in the Blueprint graph, we''ll implement the **Show Actions Panel** event.
    This will first route execution to a **Set Visibility** node, which will enable
    the **Actions** panel and then route execution to another **Set Visibility** node
    that hides the target list:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在蓝图图中，我们将实现**显示动作面板**事件。这首先将执行路由到**设置可见性**节点，该节点将启用**动作**面板，然后路由执行到另一个**设置可见性**节点，该节点将隐藏目标列表：
- en: '![UI-driven decision making](img/B04548_03_16.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![UI驱动的决策制定](img/B04548_03_16.jpg)'
- en: The Blueprint graph for when the **Attack** button is clicked is fairly large,
    so we'll take a look at it in small chunks.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击**攻击**按钮时的蓝图图相当大，所以我们将分块查看它。
- en: 'Firstly, create an `OnClicked` event for your `attackButton` by selecting the
    button in the **Designer** view and clicking on **OnClicked** in the **Events**
    portion of the **Details** panel. In the graph, we then use a **Clear Children**
    node when the button is clicked to clear out any target options that may have
    been previously added:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过在**设计师**视图中选择按钮并点击**详情**面板的**事件**部分的**OnClicked**来为你的`attackButton`创建一个`OnClicked`事件。在图中，我们然后使用一个**清除子项**节点在按钮点击时清除可能之前添加的任何目标选项：
- en: '![UI-driven decision making](img/B04548_03_17.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![UI驱动的决策制定](img/B04548_03_17.jpg)'
- en: 'Then, we use a **ForEachLoop** coupled with a **CompareInt** node to iterate
    over all characters returned by **Get Character Targets** that have HP > 0 (not
    dead):'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用一个**ForEachLoop**和一个**CompareInt**节点结合使用，遍历由**Get Character Targets**返回的所有HP
    > 0（未死亡）的角色。
- en: '![UI-driven decision making](img/B04548_03_18.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![UI驱动的决策制定](img/B04548_03_18.jpg)'
- en: 'From the **>** (greater than) pin of the **CompareInt** node, we create a new
    instance of the **AttackTargetOption** widget and add it to the attack target
    list Vertical Box:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 从**CompareInt**节点的**>**（大于）引脚，我们创建一个新的**AttackTargetOption**小部件实例，并将其添加到攻击目标列表的垂直框中：
- en: '![UI-driven decision making](img/B04548_03_19.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![UI驱动的决策制定](img/B04548_03_19.jpg)'
- en: 'Then, for the widget we just added, we connect a **Self** node to set its `targetUI`
    variable and pass the **Array Element** pin of the **ForEachLoop** to set its
    `target` variable:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于我们刚刚添加的小部件，我们将一个**Self**节点连接到它，以设置其`targetUI`变量，并将**ForEachLoop**的**数组元素**引脚传递给它以设置其`target`变量：
- en: '![UI-driven decision making](img/B04548_03_20.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![UI驱动的决策制定](img/B04548_03_20.jpg)'
- en: 'Finally, from the **Completed** pin of the **ForEachLoop**, we set the visibility
    of the target option list to **Visible**:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从**完成**的**ForEachLoop**引脚，我们将目标选项列表的可见性设置为**可见**：
- en: '![UI-driven decision making](img/B04548_03_21.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![UI驱动的决策制定](img/B04548_03_21.jpg)'
- en: 'After all this is done, we still need to hide the **Actions** panel when an
    action is chosen. We''ll add a new function to the `CombatUI` called **Hide Action
    Panel**. This function is very simple; it just sets the visibility of the action
    panel to **Hidden**:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些之后，我们仍然需要在选择动作时隐藏**动作面板**。我们将在`CombatUI`中添加一个名为**隐藏动作面板**的新函数。这个函数非常简单；它只是将动作面板的可见性设置为**隐藏**：
- en: '![UI-driven decision making](img/B04548_03_22.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![UI驱动的决策制定](img/B04548_03_22.jpg)'
- en: 'Also, in the click handler in the **AttackTargetOption** graph, we connect
    the execution pin of the **Attack Target** node to this **Hide Action Panel**
    function:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在**AttackTargetOption**图中的点击处理程序中，我们将**攻击目标**节点的执行引脚连接到这个**隐藏动作面板**函数：
- en: '![UI-driven decision making](img/B04548_03_23.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![UI驱动的决策制定](img/B04548_03_23.jpg)'
- en: 'Lastly, you will need to bind the Text Block that was in the button located
    in the **AttackTargetOption** widget. So go into the **Designer** view and create
    a bind for the text just like you have done with previous Text Blocks in this
    chapter. Now in the graph, link **target** to the **Character Name**, and adjust
    the format of the text to show the `CharacterName` variable, and link it to the
    **return** node of your text. This Blueprint should show the current target''s
    character name on the button:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要将位于 **AttackTargetOption** 小部件中的按钮中的文本块绑定。所以进入 **设计器** 视图并创建一个与本章中之前创建的文本块相同的绑定。现在在图中，将
    **目标** 连接到 **角色名称**，并调整文本的格式以显示 `CharacterName` 变量，并将其连接到文本的 **返回** 节点。这个 Blueprint
    应该在按钮上显示当前目标的角色名称：
- en: '![UI-driven decision making](img/B04548_03_24.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![UI 驱动的决策制定](img/B04548_03_24.jpg)'
- en: After all this, you should be able to run the game and start a test encounter,
    and on the player's turn, you'll see an **Attack** button that allows you to pick
    the goblin to attack.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些之后，你应该能够运行游戏并开始测试遭遇战，在玩家的回合，你会看到一个 **攻击** 按钮允许你选择攻击哥布林。
- en: Our combat engine is now fully functional. The final step of this chapter will
    be to create a game over screen so that when all party members have died, the
    player will see a **Game Over** message.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏引擎现在完全功能化。本章的最后一步将是创建一个游戏结束界面，这样当所有团队成员都死亡时，玩家将看到 **游戏结束** 信息。
- en: Creating the game over screen
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建游戏结束界面
- en: 'The first step is to create the screen itself. Create a new Widget Blueprint
    called **GameOverScreen**. We''ll just add an image to which we can do a full-screen
    anchor, and zero out the offsets in the **Details** panel. You can also set the
    color to black. Also add a Text Block with the text **Game Over**, and a button
    with a child Text Block **Restart**:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建屏幕本身。创建一个新的 Widget Blueprint，命名为 **GameOverScreen**。我们只需添加一个图像，我们可以将其设置为全屏锚点，并在
    **详细信息** 面板中将偏移量设置为 0。你也可以将颜色设置为黑色。还可以添加一个带有文本 **Game Over** 的文本块和一个带有子文本块 **Restart**
    的按钮：
- en: '![Creating the game over screen](img/B04548_03_25.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![创建游戏结束界面](img/B04548_03_25.jpg)'
- en: 'Create an `OnClicked` event for the **Restart** button. In the Blueprint graph,
    link the event for the button to Restart Game whose target is **Get Game Mode**
    (you may have to uncheck **Context Sensitive** to find this node):'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 为 **Restart** 按钮创建一个 `OnClicked` 事件。在 Blueprint 图中，将按钮的事件链接到重启游戏，其目标是 **获取游戏模式**（你可能需要取消选中
    **上下文相关** 以找到此节点）：
- en: '![Creating the game over screen](img/B04548_03_26.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![创建游戏结束界面](img/B04548_03_26.jpg)'
- en: 'You will also need to show the mouse cursor here. The best way to do this is
    from **Event Construct**; link **Set Show Mouse Cursor**, whose target is **Get
    Player Controller**. Be sure to check the **Show Mouse Cursor** box. Between **Event
    Construct** and **Set Show Mouse Cursor**, put a 0.2-second delay so that you
    are assured that the mouse re-appears after you removed it when combat ended:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在这里显示鼠标光标。最好的方法是使用 **事件构造**；链接 **设置显示鼠标光标**，其目标是 **获取玩家控制器**。务必勾选 **显示鼠标光标**
    复选框。在 **事件构造** 和 **设置显示鼠标光标** 之间放置一个 0.2 秒的延迟，以确保在战斗结束后移除鼠标后鼠标重新出现：
- en: '![Creating the game over screen](img/B04548_03_27.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![创建游戏结束界面](img/B04548_03_27.jpg)'
- en: 'Next, in `RPGGameMode.h`, we add a public property for the widget type to be
    used for game over:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `RPGGameMode.h` 中，我们添加一个用于游戏结束的公共属性来指定小部件类型：
- en: '[PRE78]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In the case of game over, we create the widget and add it to the viewport,
    which we can add as a condition nested in the `if( combatOver )` condition within
    `void ARPGGameMode::Tick( float DeltaTime )` in `RPGGameMode.cpp`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏结束的情况下，我们创建小部件并将其添加到视图中，这可以作为 `void ARPGGameMode::Tick(float DeltaTime)`
    中的 `if(combatOver)` 条件嵌套条件添加，该文件位于 `RPGGameMode.cpp`：
- en: '[PRE79]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As you can see, we''re also calling a `PrepareReset` function on the game instance.
    This function isn''t defined yet, so we''ll create it now in `RPGGameInstance.h`
    as a public function:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们还在游戏实例上调用了一个 `PrepareReset` 函数。这个函数尚未定义，所以我们现在在 `RPGGameInstance.h` 中创建它，作为一个公共函数：
- en: '[PRE80]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then implement it in `RPGGameInstance.cpp`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `RPGGameInstance.cpp` 中实现它：
- en: '[PRE81]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In this case, the purpose of `PrepareReset` is to set `isInitialized` to `false`
    so that the next time `Init` is called, the party members are reloaded. We are
    also emptying the `partyMembers` array so that when party members are added back
    into the array, we don't append them to instances of party members from our last
    playthrough (we don't want to reset the game with dead party members).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`PrepareReset`的作用是将`isInitialized`设置为`false`，以便下次调用`Init`时，小组成员将被重新加载。我们还在清空`partyMembers`数组，这样当小组成员被重新添加到数组中时，我们不会将它们附加到我们上次游玩中的小组成员实例（我们不希望带着已死亡的小组成员重置游戏）。
- en: 'At this point, you can compile. But before we can test this, we need to set
    the **Game Over UIClass** that we created and set it to **GameOverScreen** as
    a class default in **DefaultRPGGameMode**:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以进行编译。但在我们能够测试之前，我们需要设置我们创建的**游戏结束 UIClass**，并将其设置为**GameOverScreen**作为**DefaultRPGGameMode**中的类默认值：
- en: '![Creating the game over screen](img/B04548_03_28.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![创建游戏结束屏幕](img/B04548_03_28.jpg)'
- en: Much like the last time you did this, the editor may crash, but when you come
    back to **DefaultRPGGameMode**, you should see that **GameOverScreen** is set
    correctly.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上次你做的那样，编辑器可能会崩溃，但当你回到**DefaultRPGGameMode**时，你应该会看到**GameOverScreen**被正确设置。
- en: In order to test this, we'll need to give the goblin more health than the player.
    Open the enemies table and give the goblin anything over 100 HP (for instance,
    200 would do). Then, start an encounter and play until the main party member runs
    out of health. You should then see a **Game Over** screen pop up, and by clicking
    on **Restart**, you will restart the level and the main party member will be back
    up to 100 HP.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们需要给哥布林比玩家更多的生命值。打开敌人表格，给哥布林分配超过100 HP的任何数值（例如，200就足够了）。然后，开始一场遭遇战并玩到主要小组成员的生命值耗尽。此时，你应该会看到一个**游戏结束**屏幕弹出，点击**重新开始**，你将重新开始这一关卡，主要小组成员的生命值将恢复到100
    HP。
- en: Summary
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a foundation for the core gameplay of an RPG. We
    have a character that can explore the overworld, a system for keeping track of
    party members, a turn-based combat engine, and a game over condition.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为RPG的核心玩法打下了基础。我们有一个可以探索世界地图的角色，一个跟踪小组成员的系统，一个回合制战斗引擎，以及一个游戏结束条件。
- en: In the next chapters, we'll expand this by adding an inventory system, allowing
    the player to consume items, and give their party members equipment to boost their
    stats.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过添加库存系统来扩展这一功能，允许玩家消耗物品，并为他们的小组成员提供装备以提升他们的属性。
