- en: Chapter 7. Dynamic Memory Allocation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。动态内存分配
- en: In the previous chapter, we talked about class definitions and how to devise
    your own custom class. We discussed how by devising our own custom classes, we
    can construct variables that represented entities within your game or program.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了类定义以及如何设计自己的自定义类。我们讨论了通过设计自己的自定义类，我们可以构建代表游戏或程序中实体的变量。
- en: In this chapter, we will talk about dynamic memory allocations and how to create
    space in memory for groups of objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论动态内存分配以及如何在内存中为对象组创建空间。
- en: 'Assume that we have a simplified version of `class Player`, as before, with
    only a constructor and a destructor:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简化的 `class Player` 版本，如之前所述，只有一个构造函数和一个析构函数：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We talked earlier about the *scope* of a variable in C++; to recap, the scope
    of a variable is the section of the program where that variable can be used. The
    scope of a variable is generally inside the block in which it was declared. A
    block is just any section of code contained between { and }. Here is a sample
    program that illustrates variable scope:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过 C++ 中变量的 *作用域*；为了回顾，变量的作用域是该变量可以被使用的程序部分。变量的作用域通常在其声明的代码块内部。代码块只是任何位于
    { 和 } 之间的代码部分。以下是一个示例程序，说明了变量作用域：
- en: '![Dynamic Memory Allocation](img/00071.jpeg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![动态内存分配](img/00071.jpeg)'
- en: In this sample program, the x variable has scope through all of main(). The
    y variable's scope is only inside the if block
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例程序中，x 变量的作用域贯穿整个 `main()` 函数。y 变量的作用域仅限于 if 块内部
- en: 'We mentioned previously that in general variables are destroyed when they go
    out of scope. Let''s test this idea out with instances of `class Player`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，通常变量在超出作用域时被销毁。让我们通过 `class Player` 的实例来测试这个想法：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of this program is as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出如下：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The destructor for the player object is called at the end of the player object's
    scope. Since the scope of a variable is the block within which it is defined in
    the three lines of code, the `Player` object would be destroyed immediately at
    the end of `main()`, when it goes out of scope.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家对象的析构函数在玩家对象的作用域结束时被调用。由于变量的作用域是在定义它的三行代码中的代码块，因此 `Player` 对象将在 `main()` 函数结束时立即被销毁，当它超出作用域时。
- en: Dynamic memory allocation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态内存分配
- en: Now, let's try allocating a `Player` object dynamically. What does that mean?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试动态分配一个 `Player` 对象。这是什么意思？
- en: We use the `new` keyword to allocate it!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `new` 关键字来分配它！
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of this program is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出如下：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The player does not die! How do we kill the player? We must explicitly call
    `delete` on the `player` pointer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家没有死！我们如何杀死玩家？我们必须显式地调用 `delete` 在 `player` 指针上。
- en: The delete keyword
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除关键字
- en: 'The `delete` operator invokes the destructor on the object being deleted, as
    shown in the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 操作符会调用正在删除的对象的析构函数，如下面的代码所示：'
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of the program is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出如下：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, only "normal" (or "automatic" also called as non-pointer type) variable
    types get destroyed at the end of the block in which they were declared. Pointer
    types (variables declared with `*` and `new`) are not automatically destroyed
    even when they go out of scope.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只有“正常”（或“自动”，也称为非指针类型）的变量类型在它们声明的代码块结束时被销毁。指针类型（使用 `*` 和 `new` 声明的变量）即使在超出作用域时也不会自动销毁。
- en: What is the use of this? Dynamic allocations let you control when an object
    is created and destroyed. This will come in handy later.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么用？动态分配允许你控制对象的创建和销毁时间。这将在以后派上用场。
- en: Memory leaks
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存泄漏
- en: So dynamically allocated objects created with `new` are not automatically deleted,
    unless you explicitly call `delete` on them. There is a risk here! It is called
    a *memory leak*. Memory leaks happen when an object allocated with `new` is not
    ever deleted. What can happen is that if a lot of objects in your program are
    allocated with `new` and then you stop using them, your computer will run out
    of memory eventually due to memory leakage.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 `new` 创建的动态分配的对象不会自动删除，除非你明确地调用 `delete`。这里有一个风险！这被称为 *内存泄漏*。当使用 `new`
    分配的对象从未被删除时，就会发生内存泄漏。可能发生的情况是，如果你的程序中有许多对象使用 `new` 分配，然后你停止使用它们，由于内存泄漏，你的计算机最终会耗尽内存。
- en: 'Here is a ridiculous sample program to illustrate the problem:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个荒谬的示例程序来说明这个问题：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This program, if left to run long enough, will eventually gobble the computer''s
    memory, as shown in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个程序运行足够长的时间，最终会消耗掉计算机的内存，如下面的截图所示：
- en: '![Memory leaks](img/00072.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![内存泄漏](img/00072.jpeg)'
- en: 2 GB of RAM used for Player objects!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 `Player` 对象的 2 GB RAM！
- en: Note that no one ever intends to write a program with this type of problem in
    it! Memory leak problems happen accidentally. You must take care of your memory
    allocations and `delete` objects that are no longer in use.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有人打算编写包含这种类型问题的程序！内存泄漏问题意外发生。你必须注意你的内存分配，并删除不再使用的对象。
- en: Regular arrays
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常规数组
- en: 'An array in C++ can be declared as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的数组可以声明如下：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The way this looks in memory is something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，它看起来可能像这样：
- en: '![Regular arrays](img/00073.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![常规数组](img/00073.jpeg)'
- en: That is, inside the `array` variable are five slots or elements. Inside each
    of the slots is a regular `int` variable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 即，在 `array` 变量中有五个槽位或元素。每个槽位中都有一个常规的 `int` 变量。
- en: The array syntax
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组语法
- en: 'So, how do you access one of the `int` values in the array? To access the individual
    elements of an array, we use square brackets, as shown in the following line of
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你是如何访问数组中的一个 `int` 值的呢？要访问数组的单个元素，我们使用方括号，如下面的代码行所示：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding line of code would change the element at slot 0 of the array
    to a 10:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行会将数组槽位 0 的元素更改为 10：
- en: '![The array syntax](img/00074.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![数组语法](img/00074.jpeg)'
- en: 'In general, to get to a particular slot of an array, you will write the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，要访问数组的特定槽位，你会写下以下内容：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Keep in mind that array slots are always indexed starting from 0\. To get into
    the first slot of the array, use `array[0]`. The second slot of the array is `array[1]`
    (not `array[2]`). The final slot of the array above is `array[4]` (not `array[5]`).
    The `array[5]` data type is out of bounds of the array! (There is no slot with
    index 5 in the preceding diagram. The highest index is 4.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，数组槽位始终从 0 开始索引。要进入数组的第一个槽位，使用 `array[0]`。数组的第二个槽位是 `array[1]`（不是 `array[2]`）。上面数组的最后一个槽位是
    `array[4]`（不是 `array[5]`）。`array[5]` 的数据类型超出了数组的范围！（前面图中没有索引为 5 的槽位。最高的索引是 4。）
- en: Don't go out of bounds of the array! It might work some times, but other times
    your program will crash with a **memory access violation** (accessing memory that
    doesn't belong to your program). In general, accessing memory that does not belong
    to your program is going to cause your app to crash, and if it doesn't do so immediately,
    there will be a hidden bug in your program that only causes problems once in a
    while. You must always be careful when indexing an array.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不要超出数组的范围！有时它可能起作用，但有时你的程序会因为**内存访问违规**（访问不属于你的程序的内存）而崩溃。一般来说，访问不属于你的程序的内存会导致你的应用程序崩溃，而且如果它没有立即这样做，你的程序中会有一个隐藏的漏洞，它只会偶尔引起问题。你总是在索引数组时必须小心。
- en: Arrays are built into C++, that is, you don't need to include anything special
    to have immediate use of arrays. You can have arrays of any type of data that
    you want, for example, arrays of `int`, `double`, `string`, and even your own
    custom object types (`Player`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是 C++ 内置的，也就是说，你不需要包含任何特殊的东西就可以立即使用数组。你可以有任何类型的数据的数组，例如，`int`、`double`、`string`，甚至你自己的自定义对象类型（`Player`）。
- en: Exercise
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Create an array of five strings and put inside it some names (made up or random,
    it doesn't matter).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含五个字符串的数组，并在其中放入一些名字（可以是虚构的或随机的，这无关紧要）。
- en: Create an array of doubles called `temps` with three elements and store the
    temperature for the last three days in it.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `temps` 的双精度浮点数数组，包含三个元素，并将过去三天内的温度存储在其中。
- en: Solutions
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: 'The following is a sample program with an array of five strings:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是一个包含五个字符串数组的示例程序：
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is just the array:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下只是一个数组：
- en: '[PRE12]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: C++ style dynamic size arrays (new[] and delete[])
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 风格的动态大小数组（new[] 和 delete[]）
- en: It probably occurred to you that we won't always know the size of an array at
    the start of a program. We would need to allocate the array's size dynamically.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经想到，我们并不总是在程序开始时就知道数组的大小。我们需要动态地分配数组的大小。
- en: However, if you've tried it, you might have noticed that this doesn't work!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试过，你可能已经注意到这并不起作用！
- en: 'Let''s try and use the `cin` command to take in an array size from the user.
    Let''s ask the user how big he wants his array and try to create one for him of
    that size:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用 `cin` 命令从用户那里获取数组大小。让我们询问用户他想要多大的数组，并尝试为他创建一个该大小的数组：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We get the following error:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下错误：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The problem is that the compiler wants to allocate the size of the array. However,
    unless the variable size is marked `const`, the compiler will not be sure of its
    value at compile time. The C++ compiler cannot size the array at compile time,
    so it generates a compile time error.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于编译器想要分配数组的大小。然而，除非变量的大小被标记为 `const`，否则编译器在编译时无法确定其值。C++ 编译器无法在编译时确定数组的大小，因此会生成编译时错误。
- en: 'To fix this, we have to allocate the array dynamically (on the "heap"):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们必须动态分配数组（在“堆”上）：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So the lessons here are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的教训如下：
- en: To allocate an array of some type (for example, `int`) dynamically, you must
    use new `int[numberOfElementsInArray]`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了动态分配某种类型（例如，`int`）的数组，你必须使用 `new int[numberOfElementsInArray]`。
- en: Arrays allocated with `new[]` must be later deleted with `delete[]`, otherwise
    you'll get a memory leak! (that's `delete[]` with square brackets! Not regular
    delete).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `new[]` 分配的数组必须在之后使用 `delete[]` 删除，否则您将得到内存泄漏！（这是 `delete[]` 带有方括号的！不是常规的
    `delete`）。
- en: Dynamic C-style arrays
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态 C 风格数组
- en: C-style arrays are a legacy topic, but they are still worth discussing since
    even though they are old, you might still see them used sometimes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: C 风格数组是一个遗留话题，但它们仍然值得讨论，因为尽管它们很旧，您有时仍然可能会看到它们被使用。
- en: 'The way we declare a C-style array is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明 C 风格数组的做法如下：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The differences here are highlighted.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里突出显示了差异。
- en: 'A C-style array is created using the `malloc()` function. The word malloc stands
    for "memory allocate". This function requires you to pass in the size of the array
    in bytes to create and not just the number of elements you want in the array.
    For this reason, we multiply the number of elements requested (size) by `sizeof`
    of the type inside the array. The size in bytes of a few typical C++ types is
    listed in the following table:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `malloc()` 函数创建 C 风格数组。malloc 一词代表“内存分配”。此函数要求您传入数组的字节数以创建，而不仅仅是您想在数组中包含的元素数量。因此，我们将请求的元素数量（大小）乘以数组内类型的
    `sizeof`。以下表格列出了几种典型 C++ 类型在字节数上的大小：
- en: '| C++ primitive type | sizeof (size in bytes) |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| C++ 原始类型 | sizeof (字节大小) |'
- en: '| --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `int` | 4 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 4 |'
- en: '| `float` | 4 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 4 |'
- en: '| `double` | 8 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `double` | 8 |'
- en: '| `long long` | 8 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `long long` | 8 |'
- en: Memory allocated with the `malloc()` function must later be released using `free()`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `malloc()` 函数分配的内存必须在之后使用 `free()` 释放。
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to C and C++ style arrays. In most of the UE4 code,
    you will use the UE4 editor built in collection classes (`TArray<T>`). However,
    you need familiarity with the basic C and C++ style arrays to be a very good C++
    programmer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了 C 和 C++ 风格的数组。在大多数 UE4 代码中，您将使用 UE4 编辑器内置的集合类 (`TArray<T>`)。然而，为了成为一名优秀的
    C++ 程序员，您需要熟悉基本的 C 和 C++ 风格数组。
