- en: Chapter 2. Give It Some Structure – Building the Game Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working on a project with poor structure is much like building a house with
    no foundation: it''s difficult to maintain, extremely unstable, and will probably
    cause you to abandon it shortly. While the code we worked on in [Chapter 1](ch01.html
    "Chapter 1. It''s Alive! It''s Alive! – Setup and First Program"), *It''s Alive!
    It''s Alive! – Setup and First Program*, is functional and can be managed on a
    very small scale, expanding it without first building a solid framework would
    most likely result in tons of *spaghetti code* (not to be confused with ravioli
    code or lasagna code) being present. Although it sounds delicious, this pejorative
    term describes the pain of a new feature being exponentially more difficult to
    implement within the source code that is unstructured and executes in a "tangled"
    manner, which is something we''ll be focusing on avoiding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a window class, along with a main game class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code restructuring and proper architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of proper time management in applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `sf::Clock` and `sf::Time` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed and variable time-steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graduating to ravioli
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start small. Every game needs to have a window, and as you already know
    from [Chapter 1](ch01.html "Chapter 1. It''s Alive! It''s Alive! – Setup and First
    Program"), *It''s Alive! It''s Alive! – Setup and First Program*, it needs to
    be created, destroyed, and its events need to be processed. It also needs to be
    able to clear the screen and update itself to show anything drawn after the screen
    was cleared. Additionally, keeping track of whether the window is being closed
    and if it''s in full-screen mode, as well as having a method to toggle the latter
    would be quite useful. Lastly, we will, of course, need to draw to the window.
    Knowing all of that, the header of our window class will predictably look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Because we want to handle setting up our window internally, the setup method
    is made private, as well as the destroy and create methods. Think of these as
    just helper methods that the user of this class doesn't need to know about. It's
    a good idea to keep certain information around after the setup is done, such as
    the window size or the title that's being displayed above it. Lastly, we keep
    around two Boolean variables to keep track of the window being closed and its
    state regarding full screen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The naming convention that''s being employed in our window class is referred
    to as the **Hungarian notation**. Using it is, of course, not required, but it
    can prove useful when dealing with lots of code, trying to track down bugs, and
    working in larger groups of people. We''ll be utilizing it throughout this book.
    More information about it can be found here: [http://en.wikipedia.org/wiki/Hungarian_notation](http://en.wikipedia.org/wiki/Hungarian_notation)'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the window class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our blueprint, let''s begin actually building our window class.
    The entry and exit points seem as good a place as any to start with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Both implementations of the constructor and destructor simply utilize the helper
    methods which we''ll be implementing shortly. There''s also a default constructor
    that takes no arguments and initializes some pre-set default values, which is
    not necessary, but it''s convenient. With that said, let''s take a look at the
    setup method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, this is quite simple. As mentioned before, it initializes and keeps
    track of some of the window properties that will be passed to the constructor.
    Aside from that, it calls another method named `Create` to break up the code even
    more, which is what we''ll be implementing next in addition to the `Destroy` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we introduce a new data type that SFML offers: `sf::Uint32`. It gets
    stored inside the `style` local variable, which is automatically deduced to said
    type by using the `auto` keyword. It''s simply an unsigned, fixed size integer
    type. In this particular case, we''re using the *32-bit* integer, although SFML
    offers both signed and unsigned types of *8*, *16*, and *32* bits. We use this
    value to hold the current style for a window using a *ternary operator* and assigning
    it to either the default or full screen styles of the window style enumeration.
    This is the full list of all possible window styles within SFML:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Enumerator | Description | Mutually exclusive |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| None | No border or title bar. The most minimalistic style. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Fullscreen | Full screen mode. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Titlebar | Title bar and a fixed border. | No |'
  prefs: []
  type: TYPE_TB
- en: '| Close | Title bar and a close button. | No |'
  prefs: []
  type: TYPE_TB
- en: '| Resize | Title bar, resizable border and a maximize button. | No |'
  prefs: []
  type: TYPE_TB
- en: '| Default | Title bar, resizable border, maximize and close buttons. | No |'
  prefs: []
  type: TYPE_TB
- en: 'The mutually exclusive column simply denotes whether the style in question
    can be used with other styles in tandem. For example, it is possible to have a
    window with a title bar, resizable border, the maximize button, and a close button
    by combining two styles together using the bitwise *or* operator in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If, however, a style is mutually exclusive, it cannot be used with any other
    styles in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our style, we can simply pass it to the `create` method of our
    window, in addition to the `sf::VideoMode` type that gets constructed, using uniform
    initialization. It's that simple.
  prefs: []
  type: TYPE_NORMAL
- en: The `destroy` method of our `Window` class will simply close the window by invoking
    its `close` method. It's important to note here that the closed window will have
    all of its attached resources destroyed, but you can still call its `create` method
    again to re-create the window. Polling events and calling the `display` method
    will still work if a window is closed. It will just have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed in breaking up our once solid chunk of code by processing the
    events of the window in the appropriate `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s the same drill as before, we''re simply handling events. Instead of closing
    the window right off the bat, however, we simply flip the Boolean flag we keep
    around for checking if the window has been closed or not: `m_isDone`. Since we''re
    also interested in toggling between full screen and normal states of our window,
    we need to keep an eye out for another type of event: `sf::Event::KeyPressed`.
    This event gets dispatched whenever a keyboard key is pressed down and it includes
    information about that key stored in the `event.key` struct. For now, we''re only
    interested in the code of the key being pressed, which we can then check against
    the `sf::Keyboard` enumeration table. Upon receiving an event of an *F5* key being
    pressed, we call the `ToggleFullscreen` method, which is fairly simple to implement
    now that we have broken up the code into manageable sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the only thing we do here is invert the value of our *Boolean*
    class member, `m_isFullscreen`, that keeps track of the window state. Afterwards,
    we need to destroy and re-create the window in order to make it honor our changes.
    Let''s take a look at the drawing methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing new gets introduced here. We''re simply wrapping the functionality
    of clearing and displaying in `BeginDraw` and `EndDraw` methods. All that''s left
    now are the simple helper methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These basic methods provide the means for retrieving information about the window
    without giving too much control to anything outside the window class. For now,
    our window class is more than sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Building the game class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve done a good job at wrapping up the basic functionality of our window
    class, but that''s not the only chunk of code in need of refactoring. In [Chapter
    1](ch01.html "Chapter 1. It''s Alive! It''s Alive! – Setup and First Program"),
    *It''s Alive! It''s Alive! – Setup and First Program*, we''ve discussed the main
    game loop and its contents, mainly processing input, updating the game world and
    the player, and finally, rendering everything on screen. Cramming all of that
    functionality into the game loop alone is generally known to produce spaghetti
    code, and since we want to move away from that, let''s consider a better structure
    that would allow this kind of behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The code above represents the *entire* content of our `main.cpp` file and perfectly
    illustrates the use of a properly structured game class, which doesn''t go beyond
    calling the proper methods in the right order in an endless loop until the window
    is closed. Just for the sake of clarity, let''s take a look at a simplified version
    of the game class header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the game class holds an instance of our window. It can be done differently,
    but for our current needs this will more than suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Putting our code to work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re now ready to re-implement the bouncing mushroom demo from [Chapter 1](ch01.html
    "Chapter 1. It''s Alive! It''s Alive! – Setup and First Program"), *It''s Alive!
    It''s Alive! – Setup and First Program*. Given how simple it is, we''ll walk you
    through the entire process of adapting our previously written code to our new
    structure. Let''s begin by setting up our window and graphics we''ll be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we have nothing to clean up, our game destructor will remain empty
    for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have no need to check for input for this example, so let''s leave that method
    alone for now. What we will be doing, however, is updating the position of our
    sprite each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Literally the first thing you''ll probably notice is the update method call
    of our window class. We''ve already covered the importance of *event processing*
    in SFML, but it''s still worthy to note that one more time. The rest of the code
    is pretty much the same, except we now have a separate method that is responsible
    for updating the position of the mushroom sprite. We used two local variables
    to hold the window and texture sizes in order to increase readability, but that''s
    about it. Time to draw our sprite to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the code is fairly straight forward. Our window class does all the
    work, and all we have to do is call the `Draw` method and pass in our `sf::Drawable`
    right in between the wrapper methods for clearing the screen and displaying the
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Putting everything together and running it should produce the exact same bouncing
    mushroom we had back in [Chapter 1](ch01.html "Chapter 1. It's Alive! It's Alive!
    – Setup and First Program"), *It's Alive! It's Alive! – Setup and First Program*.
    However, you may have noticed that the sprite moves differently based on how busy
    your computer is. In this observation lies an important lesson about game development.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware and execution time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s travel back in time to May 5, 1992\. Apogee Software begins publishing
    the now known cult classic *Wolfenstein 3D* developed by *id Software*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hardware and execution time](img/4284_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The man with the vision, *John Carmack*, took massive strides forward and not
    only popularized, but also revolutionized the first person shooter genre on the
    PC. Its massive success cannot be overstated, as even now it's difficult to accurately
    predict how many times it has been downloaded. Having grown up at right around
    that time, one can't help but feel nostalgic sometimes and attempt to play this
    game again. Ever since its original release for the *DOS* operating system on
    the PC, it has been ported to many other operating systems and consoles. While
    it's still possible to play it, we've come a long way since the days of using
    DOS. The environment our software runs in has fundamentally changed, ergo the
    software from the past is no longer compatible, hence the need for emulation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An **emulator** is either software, hardware, or the combination of both, that
    simulates the functionality of a certain system, usually referred to as a guest,
    on a primary system, referred to as the host.
  prefs: []
  type: TYPE_NORMAL
- en: Every emulator used for this purpose not only has to imitate the software of
    a system that would be compatible with a title you're attempting to play, but
    also the hardware. Why is that important? Most games in the days of DOS counted
    on the hardware being roughly similar. In the case of Wolfenstein 3D, it assumed
    it was running on a *4.77 MHz* system, which allowed the developers to save some
    clock cycles for the sake of efficiency by not writing internal timing loops.
    A game like Wolfenstein 3D consumed all of the processing power, which was a fine
    strategy for the time, until more powerful and faster processors came about. Today,
    the puny 4.77 MHz speed is dwarfed by comparison, even when looking at all of
    the cheapest consumer-grade processors, so proper emulation of a specific system
    also requires the reduction of CPU clock cycles, otherwise these games will run
    too fast, which is exactly what happens when an emulator is set up in the wrong
    way and doesn't throttle the speed enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is the most extreme example, speed management is an important component
    of any piece of software today that has to run at a constant speed. Different
    choices of hardware and architecture aside, your software might run faster or
    slower simply based on how busy your system is at the time or the different tasks
    your code needs to accomplish every iteration before the image is rendered. Consider
    the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hardware and execution time](img/4284_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The changes on the left side as well as the right side both take place over
    a 1 second interval. The code is exactly the same in both cases. The only difference
    is the number of iterations the main loop manages to complete during that interval.
    Predictably, the slower hardware will take longer to execute your code and therefore
    will yield fewer iterations, resulting in the sprite being moved fewer times during
    our 1 second time interval and end up looking like the left side. As a game developer,
    it is important to ensure that your product runs the same on all systems within
    the designated specification guidelines. This is where SFML time management comes
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the frame-rate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SFML provides a means of setting a frame-rate cap for your applications. It''s
    a method in the `sf::RenderWindow` class, appropriately called `setFramerateLimit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Although this feature is not absolutely reliable, it ensures that the application's
    frame-rate is capped at the provided maximum value with reasonable precision,
    as long as the provided cap isn't too high. Keep in mind that capping the frame-rate
    reduces the overall CPU consumption of the program as well, since it doesn't need
    to update and re-draw the same scene as many times anymore. It does, however,
    raise a problem for slower hardware. If the frame-rate is lower than the provided
    value, the simulation will run slower too. Setting the limit solves only half
    of our problem. Let's take a look at something more practical. Enter `sf::Clock`!
  prefs: []
  type: TYPE_NORMAL
- en: Using the SFML clock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sf::Clock` class is very simple and lightweight, so it has only two methods:
    `getElapsedTime()` and `restart()`. Its sole purpose is to measure elapsed time
    since the last instance of the clock being restarted, or since its creation, in
    the most precise manner the operating system can provide. When retrieving the
    elapsed time using the `getElapsedTime` method, it returns a type `sf::Time`.
    The main reasoning behind that is an additional layer of abstraction to provide
    flexibility and avoid imposing any fixed data types. The `sf::Time` class is also
    lightweight and provides three useful methods for conversion of elapsed time to
    seconds which returns a *floating point* value, milliseconds, which returns *a
    32-bit integer* value and microseconds, which returns a *64-bit integer* value,
    as represented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `restart` method also returns an `sf::Time` value. This
    is provided in order to avoid calling `getElapsedTime` right before calling the
    `restart` method and having some time pass between those two calls that would
    otherwise be unaccounted for. How is this useful for us? Well, the problem we
    were dealing with was the same code running differently on other platforms because
    we couldn''t account for their speed. We moved our sprite across the screen using
    this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_increment` vector here is used with an assumption that the time between
    iterations is constant, but that''s obviously not true. Recall the magic triangle
    for the speed, time, and distance formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the SFML clock](img/4284_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finding the distance a sprite should travel in between updates can be done
    by first defining a set speed at which it moves. The time value here is simply
    how long it takes for an entire cycle of the program to finish. In order to accurately
    measure that, we''re going to be adjusting the `Game` class to utilize the `sf::Clock`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The two new public methods we''ve added can be implemented like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that is done, it''s important to actually utilize this functionality and
    restart the game clock after each iteration. That can be achieved in the main
    game loop by simply calling the `RestartClock` method after all the work is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line in the loop will make sure that the `m_elapsed` member of the
    game class will always have a value of the time passed during the previous iteration,
    so let''s use that time and determine how far our sprite should have moved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now using `m_increment` as a variable of speed, not distance. By looking
    at our previous code in the constructor, we''ve set both *x* and *y* values of
    the `m_increment` vector to a value of `4`. Since we''re expressing our elapsed
    time as seconds, this is essentially like saying that the sprite needs to move
    *4* pixels a second. That''s really slow, so let''s change it to something a little
    bit more stimulating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon compiling and running the project, you should see our sprite happily bouncing
    across the screen. It will now be moved the same distance on every single machine
    it''s executed on, no matter how choppy the frame-rate is. For extra points, try
    it out yourself by artificially slowing down the game loop with the `sf::sleep`
    function that SFML provides, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to adjust the argument passed to the sleep function. You will notice
    that it moves the sprite across exactly the same distance, no matter how long
    each iteration takes to finish.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed time-step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some cases, the code for time management that we''ve written doesn''t really
    apply correctly. Let''s say we only want to call certain methods at a fixed rate
    of 60 times per second. It could be a physics system that requires updating only
    a certain amount of times, or it can be useful if the game is grid-based. Whatever
    the case is, when an update rate is really important, a fixed time-step is your
    friend. Unlike the variable time-step, where the next update and draw happens
    as soon as the previous one is done, the fixed time-step approach will ensure
    that certain game logic is only happening at a provided rate. It''s fairly simple
    to implement a fixed time-step. First, we must make sure that instead of overwriting
    the elapsed time value of the previous iteration, we add to it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic expression for calculating the amount of time for an individual update
    throughout a 1 second interval is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixed time-step](img/4284_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s say we want our game to update *60* times a second. To find the frame
    time, we would divide *1* by *60* and check if the elapsed time has exceeded that
    value, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice the subtraction at the end. This is how we reset the cycle and keep the
    simulation running at a *constant* speed. Depending on your application, you might
    want to put it to *sleep* in between updates in order to relieve the CPU. Aside
    from that detail, these are the bare bones of the fixed time-step. This is the
    exact technique that will be used in the game that we will finish building in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Common mistakes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, when using clocks, newbies to SFML tend to stick them in the wrong places
    and restart them at the wrong times. Things like that can result in "funky" behavior
    at best.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that every line of code that isn't empty or commented out takes
    time to execute. Depending on how a function that is being called, or a class
    that is being constructed, is implemented, the time value might range from miniscule
    to infinite.
  prefs: []
  type: TYPE_NORMAL
- en: Things like updating all of the game entities in the world, performing calculations,
    and rendering are fairly computationally expensive, so make sure to not somehow
    exclude these calls from the span of your time measurement. Always make sure that
    restarting the clock and grabbing the elapsed time is the *last* thing you're
    doing before the main game loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another mistake is having your clock object within the wrong scope. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that the intention of this code was to measure anything else other
    than the time since the `sf::Clock` object was initiated, this code will produce
    faulty results. Creating an instance of a clock simply measures the time it has
    been alive within its scope, not anything else. This is the reason why the clock
    in the game class was declared as the class member. Since the clock is *created
    on the stack*, as soon as the method above concludes, the clock will be destroyed
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping an elapsed time in a `float` data type, or any other data type that
    isn''t `sf::Time` for that matter, is also something that''s generally frowned
    upon. Something like this would not be a great example of proper use of SFML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Although it works, this isn't exactly type-safe. It also requires more type
    conversions along the way, since you have to call one of the three conversion
    methods each time the clock gets restarted. One more nail to seal the coffin would
    be code readability. SFML provides its own time class for a reason and convenience,
    so unless there's a good reason not to use it, do avoid any other data types.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing that deserves a mention since we're talking about time is the
    console output in C++. While it's just fine to print something out every now and
    then, even for just debugging purposes, constant console spam will slow your application
    down. The console output itself is quite slow and cannot be expected to execute
    at exactly the same speed as the rest of your program. Printing something on every
    iteration of the main game loop, for example, would throttle your application
    speed horribly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on finishing the second chapter of this book! As mentioned previously,
    it is imperative that you understand everything covered in this chapter, since
    everything that follows will rely heavily on what we covered here.
  prefs: []
  type: TYPE_NORMAL
- en: Smooth and consistent results on different platforms and under different conditions
    are just as important as a good structure of an application, which is yet another
    layer of lasagna, if you will. Upon successful completion of this chapter, you
    are left yet again with sufficient knowledge to produce applications that can
    utilize both fixed and variable time-steps in order to create simulations that
    run identically and independently of the underlying architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will leave you with a piece of good advice. The first few chapters
    are something most readers follow relatively closely and literally. While that's
    an acceptable way of doing things, we'd prefer you to use this more like a guide
    instead of a recipe. The most amazing thing about human knowledge is that it isn't
    simply absorbed through endless memorization. Experimentation and gaining actual
    experience is the other half of the key to successfully mastering this, so go
    ahead and write code. Write it good or bad, compile it, or get a bunch of errors,
    run it or crash it, it's good either way. Try out new things and fail miserably
    in order to one day succeed spectacularly. You are well on your way to getting
    your hands dirty, as we will actually begin implementing our first game project
    for this book in the next chapter. See you there!
  prefs: []
  type: TYPE_NORMAL
