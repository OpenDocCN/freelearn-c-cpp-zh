- en: Shaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Converting GLSL shaders to SPIR-V assemblies
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 GLSL 着色器转换为 SPIR-V 汇编
- en: Writing vertex shaders
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写顶点着色器
- en: Writing tessellation control shaders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写细分控制着色器
- en: Writing tessellation evaluation shaders
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写细分评估着色器
- en: Writing geometry shaders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写几何着色器
- en: Writing fragment shaders
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写片段着色器
- en: Writing compute shaders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写计算着色器
- en: Writing a vertex shader that multiplies a vertex position by a projection matrix
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个将顶点位置乘以投影矩阵的顶点着色器
- en: Using push constants in shaders
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在着色器中使用推送常量
- en: Writing a texturing vertex and fragment shaders
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写纹理顶点和片段着色器
- en: Displaying polygon normals with a geometry shader
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用几何着色器显示多边形法线
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Most modern graphics hardware platforms render images using programmable pipeline.
    3D graphics data, such as vertices and fragments/pixels, are processed in a series
    of steps called stages. Some stages always perform the same operations, which
    we can only configure to a certain extent. However, there are other stages that
    need to be programmed. Small programs that control the behavior of these stages
    are called shaders.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代图形硬件平台使用可编程管线渲染图像。3D 图形数据，如顶点和片段/像素，在一系列称为阶段的步骤中处理。某些阶段始终执行相同的操作，我们只能将其配置到一定程度。然而，还有一些阶段需要编程。控制这些阶段行为的程序称为着色器。
- en: In Vulkan, there are five programmable graphics pipeline stages--vertex, tessellation
    control, evaluation, geometry, and fragment. We can also write compute shader
    programs for a compute pipeline. In the core Vulkan API, we control these stages
    with programs written in a SPIR-V. It is an intermediate language that allows
    us to process graphics data and perform mathematical calculation on vectors, matrices,
    images, buffers, or samplers. The low-level nature of this language improves compilation
    times. However, it also makes writing shaders harder. That's why the Vulkan SDK
    contains a tool called glslangValidator.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中，有五个可编程图形管线阶段--顶点、细分控制、评估、几何和片段。我们还可以为计算管线编写计算着色器程序。在核心 Vulkan API
    中，我们使用 SPIR-V 编写的程序来控制这些阶段。它是一种中间语言，允许我们对图形数据进行处理，并在向量、矩阵、图像、缓冲区或采样器上执行数学计算。这种语言的底层特性提高了编译时间。然而，这也使得编写着色器变得更加困难。这就是为什么
    Vulkan SDK 中包含一个名为 glslangValidator 的工具。
- en: glslangValidator allows us to convert shader programs written in an OpenGL Shading
    Language (in short GLSL) into SPIR-V assemblies. This way, we can write shaders
    in a much more convenient high-level shading language, we can also easily validate
    them and then convert to a representation accepted by the Vulkan API, before we
    ship them with our Vulkan application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: glslangValidator 允许我们将用 OpenGL 着色语言（简称 GLSL）编写的着色器程序转换为 SPIR-V 汇编。这样，我们可以用更方便的高级着色语言编写着色器，也可以轻松验证它们，然后在将它们与我们的
    Vulkan 应用程序一起发布之前，将它们转换为 Vulkan API 所接受的表示形式。
- en: In this chapter, we will learn how to write shaders using GLSL. We will see
    how to implement shaders for all programmable stages, how to implement tessellation
    or texturing, and how to use geometry shaders for debugging purposes. We will
    also see how to convert shaders written in a GLSL into SPIR-V assemblies using
    the glslangValidator program distributed with the Vulkan SDK.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 GLSL 编写着色器。我们将了解如何实现所有可编程阶段的着色器，如何实现细分或纹理，以及如何使用几何着色器进行调试。我们还将了解如何使用与
    Vulkan SDK 一起分发的 glslangValidator 程序将用 GLSL 编写的着色器转换为 SPIR-V 汇编。
- en: Converting GLSL shaders to SPIR-V assemblies
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 GLSL 着色器转换为 SPIR-V 汇编
- en: The Vulkan API requires us to provide shaders in the form of SPIR-V assemblies.
    It is a binary, intermediate representation, so writing it manually is a very
    hard and cumbersome task. It is much easier and quicker to write shader programs
    in a high-level shading language such as GLSL. After that we just need to convert
    them into a SPIR-V form using the glslangValidator tool.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan API 要求我们以 SPIR-V 汇编的形式提供着色器。它是一种二进制、中间表示形式，因此手动编写它是一项非常困难且繁琐的任务。在 GLSL
    等高级着色语言中编写着色器程序要容易得多。之后，我们只需使用 glslangValidator 工具将它们转换为 SPIR-V 格式即可。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Download and install the Vulkan SDK (refer to the *Downloading Vulkan SDK* recipe
    from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml), *Instance and Devices*).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装 Vulkan SDK（请参阅第 1 章[下载 Vulkan SDK](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml)，*实例和设备*）。
- en: Open the command prompt/terminal and go to the folder which contains shader
    files that should be converted.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符/终端，转到包含应转换的着色器文件的文件夹。
- en: 'To convert a GLSL shader stored in the `<input>` file into a SPIR-V assembly
    stored in the `<output>` file, run the following command:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将存储在`<input>`文件中的GLSL着色器转换为存储在`<output>`文件中的SPIR-V汇编，请运行以下命令：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The glslangValidator tool is distributed along with the Vulkan SDK. It is located
    in the `VulkanSDK/<version>/bin` (for 64-bit version) or `VulkanSDK/<version>/bin32`
    (for 32-bit version) subfolder of the SDK. It has many features, but one of its
    main functions is the ability to convert GLSL shaders into SPIR-V assemblies that
    can be consumed by the Vulkan applications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: glslangValidator工具与Vulkan SDK一起分发。它位于SDK的`VulkanSDK/<version>/bin`（64位版本）或`VulkanSDK/<version>/bin32`（32位版本）子文件夹中。它具有许多功能，但其主要功能之一是将GLSL着色器转换为SPIR-V汇编，这些汇编可以被Vulkan应用程序消费。
- en: The glslangValidator tool that converts GLSL shaders into SPIR-V assemblies
    is distributed with the Vulkan SDK.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将GLSL着色器转换为SPIR-V汇编的glslangValidator工具与Vulkan SDK一起分发。
- en: 'The tool automatically detects the shader stage based on the extension of the
    `<input>` file. The available options are:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 工具会自动根据`<input>`文件的扩展名检测着色器阶段。可用选项包括：
- en: '`vert` for the vertex shader stage'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vert`用于顶点着色器阶段'
- en: '`tesc` for the tessellation control shader stage'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tesc`用于细分控制着色器阶段'
- en: '`tese` for the tessellation evaluation shader stage'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tese`用于细分评估着色器阶段'
- en: '`geom` for the geometry shader stage'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom`用于几何着色器阶段'
- en: '`frag` for the fragment shader stage'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frag`用于片段着色器阶段'
- en: '`comp` for the compute shader'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comp`用于计算着色器'
- en: The tool may also display the SPIR-V assembly in a readable, text form. The
    command presented in this recipe, stores such form in the selected `<output_txt>`
    file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 工具还可以以可读的文本形式显示SPIR-V汇编。本配方中提供的命令将此类形式存储在选定的`<output_txt>`文件中。
- en: After GLSL shaders are converted into SPIR-V, these can be loaded in the application
    and used to create shader modules (refer to the *Creating a shader module* recipe
    from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在将GLSL着色器转换为SPIR-V之后，这些着色器可以在应用程序中加载并用于创建着色器模块（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，“图形和计算管线”中的“创建着色器模块”配方）。
- en: See also
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml), *Instances and
    Devices*, see the following recipe:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml)，“实例和设备”中，查看以下配方：
- en: '*Downloading Vulkan SDK*'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下载Vulkan SDK*'
- en: 'The following recipes in this chapter:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Writing vertex shaders*'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写顶点着色器*'
- en: '*Writing tessellation control shaders*'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写细分控制着色器*'
- en: '*Writing tessellation evaluation shaders*'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写细分评估着色器*'
- en: '*Writing geometry shaders*'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写几何着色器*'
- en: '*Writing fragment shaders*'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写片段着色器*'
- en: '*Writing compute shaders*'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写计算着色器*'
- en: '*Creating a shader module*'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: Writing vertex shaders
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写顶点着色器
- en: Vertex processing is a first graphics pipeline stage that can be programmed.
    Its main purpose is to convert positions of vertices, which form our geometry,
    from their local coordinate system into a coordinate system called a clip space.
    The clip coordinate system is used to allow graphics hardware to perform all following
    steps in a much easier and more optimal way. One of these steps is clipping, which
    clips processed vertices to only those that can be potentially visible, hence
    the name of the coordinate system. Apart from that, we can perform all the other
    operations, which are executed once per each vertex of drawn geometry.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点处理是第一个可编程的图形管线阶段。其主要目的是将构成我们几何形状的顶点的位置从它们的局部坐标系转换为称为裁剪空间的坐标系。裁剪坐标系用于允许图形硬件以更简单、更优化的方式执行所有后续步骤。其中一步是裁剪，它将处理后的顶点裁剪到可能可见的顶点，因此得名该坐标系。除此之外，我们还可以执行所有其他操作，这些操作对绘制的几何形状的每个顶点执行一次。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a text file. Select a name for the file, but use a `vert` extension for
    it (for example, `shader.vert`).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文本文件。为文件选择一个名称，但使用`vert`扩展名（例如，`shader.vert`）。
- en: Insert `#version 450` in the first line of the file.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的第一行插入`#version 450`。
- en: 'Define a set of vertex input variables (attributes) that will be provided from
    the application for each vertex (unless otherwise specified). For each input variable:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一组顶点输入变量（属性），这些变量将应用于每个顶点（除非另有说明）。对于每个输入变量：
- en: 'Define its location with a location layout qualifier and an index of the attribute:'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置布局限定符和属性索引定义其位置：
- en: '` layout( location = <index> )`'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '` layout( location = <index> )`'
- en: Provide an `in` storage qualifier
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个 `in` 存储限定符
- en: Specify the type of input variable (such as `vec4`, `float`, `int3`)
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定输入变量的类型（例如 `vec4`、`float`、`int3`）
- en: Provide a unique name of the input variable
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供输入变量的唯一名称
- en: 'If necessary, define an output (varying) variable that will be passed (and
    interpolated, unless otherwise specified) to the later pipeline stages. To define
    each output variable:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，定义一个输出（可变）变量，该变量将被传递（除非另有说明，否则将进行插值）到后续管道阶段。要定义每个输出变量：
- en: 'Provide the variable''s location using a location layout qualifier and an index:'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置布局限定符和索引提供变量的位置：
- en: '`layout( location = <index> )`'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout( location = <index> )`'
- en: Specify an `out` storage qualifier
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定一个 `out` 存储限定符
- en: Specify the type of output variable (such as `vec3` or `int`)
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定输出变量的类型（例如 `vec3` 或 `int`）
- en: Select a unique name of the output variable
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择输出变量的唯一名称
- en: 'If necessary, define uniform variables that correspond to descriptor resources
    created in the application. To define a uniform variable:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，定义与应用程序中创建的描述符资源对应的统一变量。要定义统一变量：
- en: 'Specify the number of descriptor set and a binding number in which a given
    resource can be accessed:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定描述符集的数量和绑定号，其中可以访问给定资源：
- en: '`layout (set=<set index>, binding=<binding index>)`'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout (set=<set index>, binding=<binding index>)`'
- en: Provide a `uniform` storage qualifier
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个 `uniform` 存储限定符
- en: Specify the type of the variable (such as `sampler2D`, `imageBuffer`)
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定变量的类型（例如 `sampler2D`、`imageBuffer`）
- en: Define a unique name for the variable
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为变量定义一个唯一的名称
- en: 'Create a `void main()` function in which:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `void main()` 函数中创建：
- en: Perform the desired operations
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行所需的操作
- en: Pass input variables into output variables (with or without transformations)
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入变量传递到输出变量（带有或不带变换）
- en: Store the position of the processed vertex (possibly transformed) in the `gl_Position`
    built-in variable.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将处理过的顶点（可能已变换）的位置存储在 `gl_Position` 内置变量中。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The vertex processing (via the vertex shader) is the first programmable stage
    in a graphics pipeline. It is obligatory in every graphics pipeline that we create
    in Vulkan. Its main purpose is to transform positions of the vertices passed from
    the application from their local coordinate system into a clip space. How the
    transformation is done is up to us; we can omit it and provide coordinates that
    are already in the clip space. It is also possible for the vertex shader to do
    nothing at all, if later stages (tessellation or geometry shaders) calculate positions
    and pass them down the pipeline.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点处理（通过顶点着色器）是图形管道中的第一个可编程阶段。在Vulkan中创建的每个图形管道都必须包含它。其主要目的是将应用程序传递的顶点位置从局部坐标系转换为裁剪空间。如何进行转换取决于我们；我们可以省略它并提供已在裁剪空间中的坐标。如果后续阶段（细分或几何着色器）计算位置并将它们传递到管道中，则顶点着色器也可以完全不执行任何操作。
- en: Usually though, the vertex shader takes the position provided from the application
    as one of the input variables (coordinates) and multiplies it (on the left side)
    by a model-view-projection matrix.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，顶点着色器将应用程序提供的位置作为输入变量（坐标）之一，并将其（在左侧）与模型视图投影矩阵相乘。
- en: The main purpose of the vertex shader is to take the position of a vertex, multiply
    a model-view-projection matrix by it, and store the result in the `gl_Position`
    built-in variable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器的主要目的是获取顶点的位置，将其与模型视图投影矩阵相乘，并将结果存储在 `gl_Position` 内置变量中。
- en: The vertex shader can also perform other operations, pass their results to later
    stages of the graphics pipeline, or store them in storage images or buffers. However, we
    must remember that all calculations are performed once per vertex of a drawn geometry.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器还可以执行其他操作，将结果传递到图形管道的后续阶段，或将它们存储在存储图像或缓冲区中。然而，我们必须记住，所有计算都是针对绘制几何体的每个顶点单独执行的。
- en: In the following image, a single triangle is drawn with a wireframe rendering
    enabled in the pipeline object. To be able to draw nonsolid geometry, we need
    to enable a `fillModeNonSolid` feature during the logical device creation (refer
    to the *Getting features and properties of a physical device* and *Creating a
    logical device* recipes from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml),
    *Instance and Devices*).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，使用管线对象中启用了线框渲染的单个三角形被绘制。为了能够绘制非实体几何体，我们需要在创建逻辑设备时启用`fillModeNonSolid`功能（请参阅[第1章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml)，*实例和设备*中的*获取物理设备的特性和属性*和*创建逻辑设备*食谱）。
- en: '![](img/image_07_001.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_07_001.png)'
- en: 'To draw this triangle, a simple vertex shader was used. Here''s the source
    code of this shader written in a GLSL:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制这个三角形，使用了简单的顶点着色器。以下是此着色器的源代码，使用GLSL编写：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: See also
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Converting GLSL shaders to SPIR-V assemblies*'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将GLSL着色器转换为SPIR-V汇编*'
- en: '*Writing a vertex shader that multiplies a vertex position by a projection
    matrix*'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写乘以投影矩阵的顶点位置的顶点着色器*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下食谱：
- en: '*Creating a shader module*'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Specifying pipeline vertex binding description, attribute description, and
    input state*'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线顶点绑定描述、属性描述和输入状态*'
- en: '*Creating a graphics pipeline*'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: Writing tessellation control shaders
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写细分控制着色器
- en: Tessellation is a process that divides geometry into much smaller parts. In
    graphics programming, it allows us to improve the number of details of rendered
    objects or to dynamically change their parameters, such as smoothness or shape,
    in much more flexible way.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 细分是一个将几何体分成更小部分的过程。在图形编程中，它允许我们以更灵活的方式提高渲染对象的细节数量，或动态地改变它们的参数，如平滑度或形状。
- en: Tessellation in Vulkan is optional. If enabled, it is performed after the vertex
    shader. It has three steps, of which two are programmable. The first programmable
    tessellation stage is used to set up parameters that control how the tessellation
    is performed. We do this by writing tessellation control shaders that specify
    values of tessellation factors.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，细分是可选的。如果启用，它将在顶点着色器之后执行。它有三个步骤，其中两个是可编程的。第一个可编程细分阶段用于设置控制细分如何执行参数。我们通过编写细分控制着色器来指定细分因子的值。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Create a text file. Select a name for the file, but use a `tesc` extension for
    it (for example, `shader.tesc`).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文本文件。为文件选择一个名称，但使用`tesc`扩展名（例如，`shader.tesc`）。
- en: Insert `#version 450` in the first line of the file.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的第一行插入`#version 450`。
- en: 'Define the number of vertices that will form an output patch:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义将形成输出补丁的顶点数量：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Define a set of input variables (attributes) that are provided from (written
    in) a vertex shader stage. For each input variable:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一组从（写入）顶点着色器阶段提供的输入变量（属性）。对于每个输入变量：
- en: 'Define its location with a location layout qualifier and an index of the attribute:'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置布局限定符和属性索引定义其位置：
- en: '`layout( location = <index> )`'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout( location = <index> )`'
- en: Provide an `in` storage qualifier
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个`in`存储限定符
- en: Specify the type of input variable (such as `vec3`, `float`)
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定输入变量的类型（例如`vec3`，`float`)
- en: Provide a unique name of the input variable
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供输入变量的唯一名称
- en: 'If necessary, define an output (varying) variable that will be passed (and
    interpolated, unless otherwise specified) to the later pipeline stages. To define
    each output variable:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，定义一个输出（可变）变量，该变量将被传递（除非另有说明，否则将进行插值）到后续管线阶段。为了定义每个输出变量：
- en: 'Provide the variable''s location using a location layout qualifier and an index:'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置布局限定符和索引提供变量的位置：
- en: '`layout( location = <index> )`'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout( location = <index> )`'
- en: Specify an `out` storage qualifier
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定一个`out`存储限定符
- en: Specify the type of output variable (such as `ivec2` or `bool`)
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定输出变量的类型（例如`ivec2`或`bool`)
- en: Select a unique name of the output variable
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择输出变量的唯一名称
- en: Make sure it is defined as an unsized array
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保它被定义为无大小数组
- en: 'If necessary, define uniform variables that correspond to descriptor resources
    created in the application, which can be accessed in the tessellation control
    stage. To define a uniform variable:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，定义与在应用程序中创建的描述符资源对应的统一变量，这些变量可以在细分控制阶段访问。为了定义一个统一变量：
- en: 'Through a layout qualifier, specify the number of descriptor set and a binding
    number in which a given resource can be accessed:'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过布局限定符，指定可以访问给定资源的描述符集数量和绑定号：
- en: '`layout (set=<set index>, binding=<binding index>)`'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout (set=<集合索引>, binding=<绑定索引>)`'
- en: Provide a `uniform` storage qualifier.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个 `uniform` 存储限定符。
- en: Specify the type of the variable (such as `sampler`, `image1D`).
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定变量的类型（例如 `sampler`, `image1D`）。
- en: Define a unique name of the variable.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义变量的唯一名称。
- en: 'Create a `void main()` function in which:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中创建一个 `void main()` 函数：
- en: Perform the desired operations.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行所需的操作。
- en: Pass input variables into output arrays of the variables (with or without transformations).
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入变量传递到变量的输出数组中（带有或不带变换）。
- en: Specify the inner tessellation level factor through a `gl_TessLevelInner` variable.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `gl_TessLevelInner` 变量指定内部细分级别因子。
- en: Specify the outer tessellation level factor through a `gl_TessLevelOuter` variable.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `gl_TessLevelOuter` 变量指定外部细分级别因子。
- en: Store the position of the processed patch's vertex (possibly transformed) in
    a `gl_out[gl_InvocationID].gl_Position` variable.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将处理过的补丁顶点的位置（可能已变换）存储在 `gl_out[gl_InvocationID].gl_Position` 变量中。
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Tessellation shaders are optional in Vulkan; we don't have to use them. When
    we want to use them, we always need to use both tessellation control and tessellation
    evaluation shaders. We also need to enable a `tessellationShader` feature during
    the logical device creation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，细分着色器是可选的；我们不必使用它们。当我们想要使用它们时，我们总是需要同时使用细分控制和细分评估着色器。我们还需要在创建逻辑设备时启用
    `tessellationShader` 功能。
- en: When we want to use tessellation in our application, we need to enable a `tessellationShader`
    feature during the logical device creation and we need to specify both tessellation
    control and evaluation shader stages during the graphics pipeline creation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在我们的应用程序中使用细分时，我们需要在创建逻辑设备时启用 `tessellationShader` 功能，并且在创建图形管线时需要指定细分控制和评估着色器阶段。
- en: The tessellation stage operates on patches. Patches are formed from vertices,
    but (opposed to traditional polygons) each patch may have an arbitrary number
    of them--from 1 to at least 32.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 细分阶段在补丁上操作。补丁由顶点形成，但（与传统多边形相反）每个补丁可能具有任意数量的顶点--从1个到至少32个。
- en: The tessellation control shader, as the name suggests, specifies the way in
    which geometry formed from the patch is tessellated. This is done through inner
    and outer tessellation factors that must be specified in the shader code. An inner
    factor, represented by the built-in `gl_TessLevelInner[]` array, specifies how
    the internal part of the patch is tessellated. The outer factor, which corresponds
    to the `gl_TessLevelOuter[]` built-in array, defines how the outer edges of the
    patches are tessellated. Each array element corresponds to a given edge of the
    patch.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，细分控制着色器指定由补丁形成的几何形状的细分方式。这是通过在着色器代码中指定的内部和外部细分因子来完成的。内部因子由内置的 `gl_TessLevelInner[]`
    数组表示，指定补丁内部部分的细分方式。外部因子对应于 `gl_TessLevelOuter[]` 内置数组，定义补丁外部边缘的细分方式。每个数组元素对应于补丁的给定边缘。
- en: The tessellation control shader is executed once for each vertex in the output
    patch. The index of the current vertex is available in the built-in `gl_InvocationID`
    variable. Only a currently processed vertex (corresponding to the current invocation)
    can be written to, but the shader has access to all vertices of the input patch
    through a `gl_in[].gl_Position` variable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器细分控制阶段为输出补丁中的每个顶点执行一次。当前顶点的索引可在内置的 `gl_InvocationID` 变量中找到。只能写入当前正在处理的顶点（对应于当前调用），但着色器可以通过
    `gl_in[].gl_Position` 变量访问输入补丁的所有顶点。
- en: 'An example of a tessellation control shader that specifies arbitrary tessellation
    factors and passes unmodified positions may look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个指定任意细分因子并传递未修改位置的细分控制着色器的示例可能如下所示：
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The same triangle as seen in the *Writing vertex shaders* recipe, drawn with
    the preceding tessellation control shader and with the tessellation evaluation
    shader from the *Writing tessellation evaluation shaders* recipe, should look
    like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与在 *编写顶点着色器* 配方中看到的相同三角形，使用前面的细分控制着色器和来自 *编写细分评估着色器* 配方的细分评估着色器绘制，应该看起来像这样：
- en: '![](img/image_07_002.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_002.png)'
- en: See also
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'The following recipe in this chapter:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Converting GLSL shaders to SPIR-V assemblies*'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将GLSL着色器转换为SPIR-V汇编*'
- en: '*Writing tessellation evaluation shaders*'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写细分评估着色器*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml) *图形和计算管线* 中，查看以下配方：
- en: '*Creating a shader module*'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Specifying pipeline tessellation state*'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线细分状态*'
- en: '*Creating a graphics pipeline*'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: Writing tessellation evaluation shaders
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写细分评估着色器
- en: Tessellation evaluation is the second programmable stage in the tessellation
    process. It is executed when the geometry is already tessellated (subdivided)
    and is used to gather results of the tessellation to form the new vertices and
    further modify them. When the tessellation is enabled, we need to write tessellation
    evaluation shaders to acquire the locations of generated vertices and provide
    them to the consecutive pipeline stages.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 细分评估是细分过程中的第二个可编程阶段。它在几何体已经细分（细分）时执行，用于收集细分结果以形成新顶点并进一步修改它们。当启用细分时，我们需要编写细分评估着色器以获取生成顶点的位置并将它们提供给后续的管线阶段。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a text file. Select a name for the file and use a `tese` extension for
    it (for example, `shader.tese`).
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文本文件。为文件选择一个名称，并使用`tese`扩展名（例如，`shader.tese`）。
- en: Insert `#version 450` in the first line of the file.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的第一行插入`#version 450`。
- en: 'Using the `in` layout qualifier, define the type of formed primitives (`isolines`,
    `triangles,` or `quads`), the spacing between formed vertices (`equal_spacing`,
    `fractional_even_spacing` or `fractional_odd_spacing`), and a winding order of
    generated triangles (`cw` to keep the winding provided in an application or `ccw`
    to reverse the winding provided in an application):'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`in`布局限定符，定义形成的原语类型（`isolines`、`triangles`或`quads`），形成顶点之间的间距（`equal_spacing`、`fractional_even_spacing`或`fractional_odd_spacing`），以及生成三角形的绕行顺序（`cw`以保持应用程序中提供的绕行或`ccw`以反转应用程序中提供的绕行）：
- en: '[PRE4]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define a set of input array variables that are provided from a tessellation
    control stage. For each input variable:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一组从细分控制阶段提供的输入数组变量。对于每个输入变量：
- en: 'Define its location with a location layout qualifier and an index of the attribute:'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置布局限定符和属性索引定义其位置：
- en: '`layout( location = <index> )`'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout( location = <index> )`'
- en: Provide an `in` storage qualifier
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个`in`存储限定符
- en: Specify the type of input variable (such as `vec2` or `int3`)
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定输入变量的类型（例如`vec2`或`int3`）
- en: Provide a unique name of the input variable
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供输入变量的唯一名称
- en: Make sure it is defined as an array.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保它被定义为数组。
- en: 'If necessary, define an output (varying) variable that will be passed (and
    interpolated, unless otherwise specified) to later pipeline stages. To define
    each output variable:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，定义一个输出（可变）变量，该变量将被传递（除非另有说明，否则将插值）到后续的管线阶段。为了定义每个输出变量：
- en: 'Provide the variable''s location using a location layout qualifier and an index:'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置布局限定符和索引提供变量的位置：
- en: '`layout( location = <index> )`'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout( location = <index> )`'
- en: Specify an `out` storage qualifier
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定`out`存储限定符
- en: Specify the type of output variable (such as `vec4`)
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定输出变量的类型（例如`vec4`）
- en: Select a unique name of the output variable.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择输出变量的唯一名称。
- en: 'If necessary, define uniform variables that correspond to descriptor resources
    created in the application for which the tessellation evaluation stage can have
    access. To define a uniform variable:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，定义与在应用程序中创建的描述符资源对应的统一变量。为了定义统一变量：
- en: 'Specify the number of descriptor set and a binding number in which a given
    resource can be accessed:'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定描述符集的数量和绑定号，以便可以访问给定的资源：
- en: '`layout (set=<set index>, binding=<binging index>)`'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout (set=<set index>, binding=<binging index>)`'
- en: Provide a `uniform` storage qualifier
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个`uniform`存储限定符
- en: Specify the type of the variable (such as `sampler`, `image1D`)
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定变量的类型（例如`sampler`、`image1D`）
- en: Define a unique name of the variable.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义变量的唯一名称。
- en: 'Create a `void main()` function in which:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`void main()`函数，在其中：
- en: Perform the desired operations
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行所需的操作
- en: Use the built-in `gl_TessCoord` vector variable to generate a position of a
    new vertex using the positions of all the patch's vertices; modify the result
    to achieve the desired result, and store it in the `gl_Position` built-in variable
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置的`gl_TessCoord`向量变量，使用所有补丁顶点的位置生成新顶点的位置；修改结果以实现所需的结果，并将其存储在内置变量`gl_Position`中
- en: In a similar way, use `gl_TessCoord` to generate interpolated values of all
    other input variables and store them in the output variables (with additional
    transformations if required).
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以类似的方式，使用`gl_TessCoord`生成所有其他输入变量的插值值，并将它们存储在输出变量中（如果需要，进行额外的转换）。
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Tessellation control and evaluation shaders form two programmable stages required
    for the tessellation to work correctly. Between them is a stage that does the
    actual tessellation based on the parameters provided in the control stage. Results
    of the tessellation are acquired in the evaluation stage, where they are applied
    to form the new geometry.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 细分控制着色器和评估着色器是细分正确工作所需的两个可编程阶段。它们之间是一个基于控制阶段提供的参数执行实际细分的阶段。细分的结果在评估阶段获得，在该阶段它们被应用于形成新几何形状。
- en: 'Through tessellation evaluation we can control the way in which new primitives
    are aligned and formed: we specify their winding order and spacing between the
    generated vertices. We can also select whether we want the tessellation stage
    to create `isolines`, `triangles,` or `quads`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过细分评估，我们可以控制新基本类型的对齐和形成方式：我们指定它们的绕行顺序和生成顶点之间的间距。我们还可以选择是否希望细分阶段创建`等高线`、`三角形`或`四边形`。
- en: New vertices are not created directly--the tessellator generates only barycentric
    tessellation coordinates for new vertices (weights), which are provided in the built-in
    `gl_TessCoord` variable. We can use these coordinates to interpolate between the
    original positions of vertices that formed a patch and place new vertices in the
    correct positions. That's why the evaluation shader, though executed once per
    generated vertex, has access to all vertices forming the patch. Their positions
    are provided through the `gl_Position` member of a built-in array variable, `gl_in[]`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 新顶点不是直接创建的--细分器只为新顶点（权重）生成重心的细分坐标，这些坐标在内置的`gl_TessCoord`变量中提供。我们可以使用这些坐标在形成补丁的原顶点位置之间进行插值，并将新顶点放置在正确的位置。这就是为什么评估着色器，尽管它对每个生成的顶点只执行一次，但可以访问形成补丁的所有顶点。它们的位置通过内置数组变量`gl_in[]`的`gl_Position`成员提供。
- en: 'In case of commonly used triangles, the tessellation evaluation shader that
    just passes new vertices without further modifications may look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常用的三角形，仅传递新顶点而不进行进一步修改的细分评估着色器可能看起来像这样：
- en: '[PRE5]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See also
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipe in this chapter:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Converting GLSL shaders to SPIR-V assemblies*'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将GLSL着色器转换为SPIR-V汇编*'
- en: '*Writing tessellation control shaders*'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写细分控制着色器*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下配方：
- en: '*Creating a shader module*'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Specifying a pipeline tessellation state*'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线细分状态*'
- en: '*Creating a graphics pipeline*'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: Writing geometry shaders
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写几何着色器
- en: 3D scenes are composed of objects called meshes. Mesh is a collection of vertices
    that form the external surface of an object. This surface is usually represented
    by triangles. When we render an object, we provide vertices and specify what type
    of primitives (`points`, `lines`, `triangles`) they build. After the vertices
    are processed by the vertex and optional tessellation stages, they are assembled
    into specified types of primitives. We can enable, also optional, the geometry
    stage and write geometry shaders that control or change the process of forming
    primitives from vertices. In geometry shaders, we can even create new primitives
    or destroy the existing ones.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 3D场景由称为网格的对象组成。网格是由形成对象外部表面的顶点集合。这个表面通常由三角形表示。当我们渲染一个对象时，我们提供顶点并指定它们构成的基本类型（`points`、`lines`、`triangles`）。在顶点和可选的细分阶段处理顶点之后，它们被组装成指定的基本类型。我们还可以启用（也是可选的）几何阶段，并编写控制或改变从顶点形成基本类型过程的几何着色器。在几何着色器中，我们甚至可以创建新的基本类型或销毁现有的基本类型。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a text file. Select a name for the file and use a `geom` extension for
    it (for example, `shader.geom`).
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文本文件。为文件选择一个名称，并使用`geom`扩展名（例如，`shader.geom`）。
- en: Insert `#version 450` in the first line of the file.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的第一行插入`#version 450`。
- en: 'Using the `in` layout qualifier, define the type of primitives that are drawn
    in an application: `points`, `lines`, `lines_adjacency`, `triangles,` or `triangles_adjacency`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`in`布局限定符，定义在应用程序中绘制的原语类型：`points`、`lines`、`lines_adjacency`、`triangles`或`triangles_adjacency`：
- en: '[PRE6]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using the `out` layout qualifier, define the type of primitives that are formed
    (output) by the geometry shader (`points`, `line_strip` or `triangle_strip`),
    and the maximal number of vertices that the shader may generate:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `out` 布局限定符，定义几何着色器形成的原语类型（输出）（`points`, `line_strip` 或 `triangle_strip`），以及着色器可能生成的最大顶点数：
- en: '[PRE7]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define a set of input array variables that are provided from a vertex or tessellation
    evaluation stage. For each input variable:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一组从顶点或细分评估阶段提供的输入数组变量。对于每个输入变量：
- en: 'Define its location with a location layout qualifier and an index of the attribute:'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置布局限定符和属性索引定义其位置：
- en: '`layout( location = <index> )`'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout( location = <index> )`'
- en: Provide an `in` storage qualifier
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个 `in` 存储限定符
- en: Specify the type of input variable (such as `ivec4`, `int` or `float`)
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定输入变量的类型（例如 `ivec4`, `int` 或 `float`）
- en: Provide a unique name of the input variable
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供输入变量的唯一名称
- en: Make sure the variable is defined as an unsized array
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保变量被定义为无大小数组
- en: 'If necessary, define an output (varying) variable that will be passed (and
    interpolated, unless otherwise specified) to the fragment shader stage. To define
    each output variable:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，定义一个输出（可变）变量，该变量将被传递（除非另有说明，否则将进行插值）到片段着色器阶段。要定义每个输出变量：
- en: 'Provide variable''s location using a location layout qualifier and an index:'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置布局限定符和索引提供变量的位置：
- en: '`layout( location = <index> )`'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout( location = <index> )`'
- en: Specify an `out` storage qualifier
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定一个 `out` 存储限定符
- en: Specify the type of output variable (such as `vec3` or `uint`)
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定输出变量的类型（例如 `vec3` 或 `uint`）
- en: Select a unique name of the output variable
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择输出变量的唯一名称
- en: 'If necessary, define uniform variables that correspond to descriptor resources
    created in the application for which the geometry stage may have access. To define
    a uniform variable:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，定义与在应用程序中创建的描述符资源对应的统一变量。要定义统一变量：
- en: 'Specify the number of descriptor set and a binding number in which a given
    resource can be accessed:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定描述符集的数量和一个绑定号，以便可以访问给定的资源：
- en: '`layout (set=<set index>, binding=<binging index>)`'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout (set=<set index>, binding=<binging index>)`'
- en: Provide a `uniform` storage qualifier
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个 `uniform` 存储限定符
- en: Specify the type of the variable (such as `image2D`, `sampler1DArray`)
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定变量的类型（例如 `image2D`, `sampler1DArray`）
- en: Define a unique name of the variable
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义变量的唯一名称
- en: 'Create a `void main()` function in which:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `void main()` 函数中创建：
- en: Perform the desired operations
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行所需的操作
- en: 'For each generated or passed vertex:'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个生成的或传递的顶点：
- en: Write values to output variables
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值写入输出变量
- en: Store the position of the vertex (possibly transformed) in the built-in `gl_Position`
    variable
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将顶点的位置（可能已变换）存储在内置的 `gl_Position` 变量中
- en: Call `EmitVertex()` to add a vertex to the primitive
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `EmitVertex()` 向原语添加顶点
- en: Finish the generation of the primitive by calling `EndPrimitive()` function
    (another primitive is implicitly started).
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `EndPrimitive()` 函数完成原语的生成（隐式地开始另一个原语）。
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Geometry is an optional stage in a graphics pipeline. Without it, when we draw
    geometry, primitives are automatically generated based on the type specified during
    the graphics pipeline creation. Geometry shaders allow us to create additional
    vertices and primitives, destroy the ones drawn in an application, or to change
    the type of primitives formed from vertices.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 几何阶段是图形管线中的一个可选阶段。如果没有它，当我们绘制几何图形时，基于在图形管线创建期间指定的类型，会自动生成原语。几何着色器允许我们创建额外的顶点和原语，销毁应用程序中绘制的原语，或者更改由顶点形成原语的类型。
- en: The geometry shader is executed once for each primitive in a geometry drawn
    by the application. It has access to all vertices that constitute the primitive,
    or even to the adjacent ones. With this data it can pass the same or create new
    vertices and primitives. We must remember that we shouldn't create too many vertices
    in a geometry shader. If we want to create many new vertices, tessellation shaders
    are better suited for this task (and have a better performance). Just increasing
    the maximal number of vertices the geometry shader may create, even if we don't
    always form them; may lower the performance of our application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 几何着色器对应用程序绘制的每个几何原语执行一次。它可以访问构成原语的所有顶点，甚至相邻的顶点。有了这些数据，它可以传递相同的或创建新的顶点和原语。我们必须记住，我们不应该在几何着色器中创建太多的顶点。如果我们想创建许多新的顶点，细分着色器更适合这项任务（并且性能更好）。仅仅增加几何着色器可能创建的最大顶点数，即使我们并不总是形成它们，也可能降低我们应用程序的性能。
- en: We should keep the number of vertices emitted by the geometry shader as low
    as possible.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该尽可能降低几何着色器发出的顶点数。
- en: 'Geometry shaders always generate strip primitives. If we want to create separate
    primitives that do not form a strip, we just need to end a primitive at an appropriate
    moment--vertices emitted after the primitive is ended are added to the next strip
    so we can create as many separate strips as we choose to. Here''s an example which
    creates three separate triangles in the original triangle''s corners:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 几何着色器始终生成条带原语。如果我们想创建不形成条带的单独原语，我们只需在适当的时候结束原语即可--在原语结束后发出的顶点被添加到下一个条带中，这样我们就可以创建我们选择的任意数量的单独条带。以下是一个示例，它创建了原始三角形角落中的三个单独的三角形：
- en: '[PRE8]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When a single triangle is drawn with a simple pass-through vertex and fragment
    shaders, and with the preceding geometry shader, the result should look like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用简单的透传顶点着色器和片段着色器绘制单个三角形，并且使用前面的几何着色器时，结果应该看起来像这样：
- en: '![](img/image_07_003.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_003.png)'
- en: See also
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Converting GLSL shaders to SPIR-V assemblies*'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将GLSL着色器转换为SPIR-V汇编*'
- en: '*Displaying polygon normals with a geometry shader*'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用几何着色器显示多边形法线*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管道*中，查看以下食谱：
- en: '*Creating a shader module*'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Specifying a pipeline input assembly state*'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管道输入装配状态*'
- en: '*Creating a graphics pipeline*'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管道*'
- en: Writing fragment shaders
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写片段着色器
- en: Fragments (or pixels) are parts of the image that can be potentially displayed
    on screen. They are created from geometry (drawn primitives) in a process called
    rasterization. They have specific screen space coordinates (x, y, and depth) but
    don't have any other data. We need to write a fragment shader to specify the color
    that needs to be displayed on screen. In the fragment shader, we can also select
    an attachment into which a given color should be written.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 片段（或像素）是图像的组成部分，可能显示在屏幕上。它们是通过称为光栅化的过程从几何（绘制的原语）创建的。它们具有特定的屏幕空间坐标（x、y和深度），但没有其他数据。我们需要编写一个片段着色器来指定需要在屏幕上显示的颜色。在片段着色器中，我们还可以选择一个附件，将给定的颜色写入其中。
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a text file. Select a name for the file, but use a `frag` extension for
    it (for example, `shader.frag`).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文本文件。为文件选择一个名称，但使用一个`frag`扩展名（例如，`shader.frag`）。
- en: Insert `#version 450` in the first line of the file.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的第一行插入`#version 450`。
- en: 'Define a set of input variables (attributes) that are provided from the earlier
    pipeline stages. For each input variable:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一组从早期管道阶段提供的输入变量（属性）。对于每个输入变量：
- en: 'Define its location with a location layout qualifier and an index of the attribute:'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置布局限定符和属性索引定义其位置：
- en: '`layout( location = <index> )`'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout( location = <index> )`'
- en: Provide an `in` storage qualifier
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个`in`存储限定符
- en: Specify the type of input variable (such as `vec4`, `float`, `ivec3`)
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定输入变量的类型（例如`vec4`、`float`、`ivec3`）
- en: Provide a unique name of the input variable
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供输入变量的唯一名称
- en: 'Define an output variable for each attachment into which a color should be
    written. To define each output variable:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个输出变量，用于写入颜色。要定义每个输出变量：
- en: 'Provide the variable''s location (index of the attachment) using a location
    layout qualifier and a number:'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置布局限定符和数字提供变量的位置（附件的索引）：
- en: '`layout( location = <index> )`'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout( location = <index> )`'
- en: Specify an `out` storage qualifier
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定一个`out`存储限定符
- en: Specify the type of the output variable (such as `vec3` or `vec4`)
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定输出变量的类型（例如`vec3`或`vec4`）
- en: Select a unique name of the output variable
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择输出变量的唯一名称
- en: 'If necessary, define uniform variables that correspond to descriptor resources
    created in the application. To define a uniform variable:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，定义与在应用程序中创建的描述符资源对应的统一变量。要定义一个统一变量：
- en: 'Specify the number of descriptor set and a binding number in which a given
    resource can be accessed:'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定描述符集的数量和一个绑定号，以便可以访问给定的资源：
- en: '`layout (set=<set index>, binding=<binding index>)`'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout (set=<set index>, binding=<binding index>)`'
- en: Provide a `uniform` storage qualifier
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个`uniform`存储限定符
- en: Specify the type of the variable (such as `sampler1D`, `subpassInput,` or `imageBuffer`)
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定变量的类型（例如`sampler1D`、`subpassInput`或`imageBuffer`）
- en: Define a unique name of the variable
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义变量的唯一名称
- en: 'Create a `void main()` function in which:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中创建一个`void main()`函数：
- en: Perform the desired operations and calculations
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行所需的操作和计算
- en: Store the color of the processed fragment in an output variable
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将处理过的片段的颜色存储在输出变量中
- en: How it works...
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Geometry, which we draw in our application, is formed from primitives. These
    primitives are converted into fragments (pixels) in a process called rasterization.
    For each such fragment, a fragment shader is executed. Fragments may be discarded
    inside the shader or during framebuffer tests, such as depth, stencil, or scissor tests,
    so they won't even become pixels--that's why they are called fragments, not pixels.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中绘制的几何形状由原语组成。这些原语在称为光栅化的过程中被转换为片段（像素）。对于每个这样的片段，都会执行一个片段着色器。片段可能在着色器内部或在进行帧缓冲区测试（如深度、模板或裁剪测试）时被丢弃，因此它们甚至不会成为像素——这就是为什么它们被称为片段而不是像素。
- en: The main purpose of a fragment shader is to set a color that will be (potentially)
    written to an attachment. We usually use them to perform lighting calculations
    and texturing. Along with compute shaders, fragment shaders are often used for
    post-processing effects such as bloom or deferred shading/lighting. Also, only
    fragment shaders can access input attachments defined in a render pass (refer
    to the *Creating an input attachment* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器的主要目的是设置将被（可能）写入附件的颜色。我们通常使用它们来执行光照计算和纹理映射。与计算着色器一样，片段着色器常用于后处理效果，如辉光或延迟着色/光照。此外，只有片段着色器可以访问在渲染过程中定义的输入附件（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)中的*创建输入附件*配方，*描述符集*）。
- en: '![](img/image_07_004.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_004.png)'
- en: 'To draw the triangle in the preceding figure, a simple fragment shader is used,
    which stores a chosen, hardcoded color:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制前面图中的三角形，使用了一个简单的片段着色器，它存储了一个选择的、硬编码的颜色：
- en: '[PRE9]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Converting GLSL shaders to SPIR-V assemblies*'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将GLSL着色器转换为SPIR-V汇编*'
- en: '*Writing a texturing vertex and fragment shaders*'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写纹理着色器顶点和片段着色器*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), Graphics and Compute
    Pipelines, see the following recipes:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，图形和计算管线中，查看以下配方：
- en: '*Creating a shader module*'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Specifying a pipeline rasterization state*'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线光栅化状态*'
- en: '*Creating a graphics pipeline*'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: Writing compute shaders
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写计算着色器
- en: Compute shaders are used, as the name suggests, for general mathematical calculations.
    They are executed in (local) groups of a defined, three-dimensional size, which
    may have access to a common set of data. At the same time, many local groups can
    be executed to generate results faster.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器，正如其名所示，用于通用数学计算。它们在定义的、三维大小的（本地）组中执行，这些组可能可以访问一组公共数据。同时，可以执行许多本地组以更快地生成结果。
- en: How to do it...
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a text file. Select a name for the file, but use a `comp` extension for
    it (for example, `shader.comp`).
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文本文件。为文件选择一个名称，但使用 `comp` 扩展名（例如，`shader.comp`）。
- en: Insert `#version 450` in the first line of the file.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的第一行插入 `#version 450`。
- en: 'Using an input layout qualifier, define the size of the local workgroup:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用输入布局限定符，定义本地工作组的尺寸：
- en: '[PRE10]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define uniform variables that correspond to descriptor resources created in
    the application. To define a uniform variable:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义与应用程序中创建的描述符资源对应的统一变量。要定义统一变量：
- en: 'Specify the number of descriptor set and a binding number in which a given
    resource can be accessed:'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定描述符集的数量和绑定号，以便可以访问给定的资源：
- en: '`layout (set=<set index>, binding=<binding index>)`'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout (set=<set index>, binding=<binding index>)`'
- en: Provide a `uniform` storage qualifier
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个 `uniform` 存储限定符
- en: Specify the type of the variable (such as `image2D` or `buffer`)
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定变量的类型（例如 `image2D` 或 `buffer`)
- en: Define a unique name of the variable
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义变量的唯一名称
- en: 'Create a `void main()` function in which:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `void main()` 函数，其中：
- en: Perform the desired operations and calculations
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行所需的操作和计算
- en: Store the results in selected uniform variables
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果存储在选定的统一变量中
- en: How it works...
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Compute shaders can be used only in a dedicated compute pipeline. They also
    cannot be executed (dispatched) inside render passes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器只能在专用计算管线中使用。它们也不能在渲染过程中（调度）执行。
- en: Compute shaders don't have any input nor output (user defined) variables passed
    from earlier or to later pipeline stages--it is the only stage in a compute pipeline.
    Uniform variables must be used for the source of compute shader data. Similarly,
    results of calculations performed in the compute shader can be stored only in
    the uniform variables.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器没有从早期或传递到后续管线阶段的输入或输出（用户定义）变量--它是计算管线中的唯一阶段。必须使用统一变量作为计算着色器数据的来源。同样，在计算着色器中执行的计算结果只能存储在统一变量中。
- en: 'There are some built-in input variables that provide information about the
    index of a given shader invocation within a local workgroup (through the `uvec3
    gl_LocalInvocationID` variable), the number of workgroups dispatched at the same
    time (through the `uvec3 gl_NumWorkGroups` variable), or a number of the current
    workgroup (`uvec3 gl_WorkGroupID` variable). There is also a variable that uniquely
    identifies the current shader within all invocations in all workgroups--`uvec3
    gl_GlobalInvocationID`. Its value is calculated like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些内置输入变量可以提供有关给定着色器调用在局部工作组中的索引（通过`uvec3 gl_LocalInvocationID`变量）、同时分发的作业组数量（通过`uvec3
    gl_NumWorkGroups`变量）或当前工作组的数量（`uvec3 gl_WorkGroupID`变量）的信息。还有一个变量可以唯一标识所有工作组中所有调用中的当前着色器--`uvec3
    gl_GlobalInvocationID`。其值计算如下：
- en: '[PRE11]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The size of the local workgroup is defined through the input layout qualifier.
    Inside the shader, the defined size is also available through the `uvec3 gl_WorkGroupSize`
    built-in variable.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入布局限定符定义局部工作组的大小。在着色器内部，定义的大小也通过内置变量`uvec3 gl_WorkGroupSize`可用。
- en: 'In the following code, you can find a compute shader example that uses the
    `gl_GlobalInvocationID` variable to generate a simple, static fractal image:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，你可以找到一个使用`gl_GlobalInvocationID`变量生成简单静态分形图像的计算着色器示例：
- en: '[PRE12]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding compute shader generates the following result when dispatched:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的计算着色器在分发时生成以下结果：
- en: '![](img/image_07_005.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_005.png)'
- en: See also
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipe in this chapter:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Converting GLSL shaders to SPIR-V assemblies*'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将GLSL着色器转换为SPIR-V汇编*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下食谱：
- en: '*Creating a shader module*'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Creating a compute pipeline*'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建计算管线*'
- en: Writing a vertex shader that multiplies vertex position by a projection matrix
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写乘以投影矩阵的顶点位置的计算着色器
- en: Transforming geometry from local to clip space is usually performed by the vertex
    shader, though any other vertex processing stage (tessellation or geometry) may
    accomplish this task. The transformation is done by specifying model, view, and
    projection matrices and providing them from the application to the shaders as
    three separate matrices, or as one, joined model-view-projection matrix (in short
    MVP). The most common and easy way is to use a uniform buffer through which we
    can provide such a matrix.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 将几何体从局部空间转换到裁剪空间通常由顶点着色器执行，尽管任何其他顶点处理阶段（细分或几何）也可能完成此任务。转换是通过指定模型、视图和投影矩阵，并将它们作为三个单独的矩阵或一个连接的模型-视图-投影矩阵（简称MVP）从应用程序提供给着色器来完成的。最常见和简单的方法是通过统一缓冲区提供这样的矩阵。
- en: How to do it...
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a vertex shader in a text file called `shader.vert` (refer to the *Writing
    vertex shaders* recipe).
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`shader.vert`的文本文件中创建一个顶点着色器（参考*编写顶点着色器*食谱）。
- en: 'Define an input variable (attribute) through which vertex positions will be
    provided to the vertex shader:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个通过它将顶点位置提供给顶点着色器的输入变量（属性）：
- en: '[PRE13]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Define a uniform buffer with a variable of type `mat4` through which data for
    the combined model-view-projection matrix will be provided:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含`mat4`类型变量的统一缓冲区，通过该缓冲区提供组合模型-视图-投影矩阵的数据：
- en: '[PRE14]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inside a `void main()` function, calculate vertex position in the clip space
    by multiplying the `ModelViewProjectionMatrix` uniform variable by the `app_position`
    input variable and storing the result in the `gl_Position` built-in variable like
    this:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`void main()`函数内部，通过将`ModelViewProjectionMatrix`统一变量与`app_position`输入变量相乘，并在以下方式中将结果存储在内置变量`gl_Position`中，计算裁剪空间中的顶点位置：
- en: '[PRE15]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we prepare a geometry that will be drawn in a 3D application, the geometry
    is usually modeled in the local coordinate system--the one in which it is more
    convenient for the artist to create the model. However, the graphics pipeline
    expects the vertices to be transformed to a clip space, as it is easier (and faster)
    to perform many operations in this coordinate system. Usually it is the vertex
    shader that performs this transformation. For this, we need to prepare a matrix
    that represents a perspective or orthogonal projection. Transformation from the
    local space to the clip space is performed by just multiplying the matrix by the
    position of a vertex.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备在 3D 应用程序中绘制的几何体时，几何体通常在局部坐标系中建模——这是艺术家创建模型更方便的坐标系。然而，图形管线期望顶点被转换到裁剪空间，因为这个坐标系进行许多操作更容易（并且更快）。通常，是顶点着色器执行这个转换。为此，我们需要准备一个表示透视或正交投影的矩阵。从局部空间到裁剪空间的转换只需将矩阵乘以顶点的位置。
- en: 'The same matrix, apart from the projection, may also contain other operations,
    commonly referred to as model-view transformations. And because drawn geometry
    may contain hundreds or thousands of vertices, it is usually more optimal to multiply
    model, view, and projection matrices in the application, and provide a single,
    concatenated MVP matrix to the shader which needs to perform only a single multiplication:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 除了投影之外，相同的矩阵还可能包含其他操作，通常称为模型视图变换。由于绘制的几何体可能包含数百或数千个顶点，通常在应用程序中乘以模型、视图和投影矩阵会更优，并提供一个单一的、连接的
    MVP 矩阵给需要执行单个乘法的着色器：
- en: '[PRE16]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding shader requires the application to prepare a buffer in which data
    for the matrix is stored (refer to the *Creating a uniform buffer* recipe from
    [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*). This
    buffer is then provided (in the current example) at a `0`^(th) binding to a descriptor
    set, which is later bound to the command buffer as the `0`^(th) set (refer to
    the *Updating descriptor sets* and *Binding descriptor sets* recipes from [Chapter
    5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的着色器要求应用程序准备一个缓冲区，其中存储矩阵数据（参考第 5 章，*描述符集*中的*创建统一缓冲区*食谱）。然后，这个缓冲区（在当前示例中）被绑定到描述符集的`0`号绑定，该描述符集随后被绑定到命令缓冲区作为`0`号集（参考第
    5 章，*描述符集*中的*更新描述符集*和*绑定描述符集*食谱）。
- en: '![](img/image_07_006.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_006.png)'
- en: See also
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In Chapter 5, *Descriptor Sets*, see the following recipes:'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 5 章，*描述符集*中，查看以下食谱：
- en: '*Creating a uniform buffer*'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建统一缓冲区*'
- en: '*Updating descriptor sets*'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新描述符集*'
- en: '*Binding descriptor sets*'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定描述符集*'
- en: 'The following recipes in this chapter:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Converting GLSL shaders to SPIR-V assemblies*'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将 GLSL 着色器转换为 SPIR-V 汇编*'
- en: '*Writing vertex shaders*'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写顶点着色器*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 8 章，*图形和计算管线*中，查看以下食谱：
- en: '*Creating a shader module*'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Creating a graphics pipeline*'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: Using push constants in shaders
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在着色器中使用推送常量
- en: When we provide data to shaders, we usually use uniform buffers, storage buffers,
    or other types of descriptor resources. Unfortunately, updating such resources
    may not be too convenient, especially when we need to provide data that changes
    frequently.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向着色器提供数据时，通常使用统一缓冲区、存储缓冲区或其他类型的描述符资源。不幸的是，更新这些资源可能并不太方便，尤其是当我们需要提供频繁变化的数据时。
- en: For this purpose, push constants were introduced. Through them we can provide
    data in a simplified and much faster way than by updating descriptor resources.
    However, we need to fit into a much smaller amount of available space.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，引入了推送常量。通过它们，我们可以以简化和更快的方式提供数据，而不是通过更新描述符资源。然而，我们需要适应更小的可用空间。
- en: Accessing push constants in GLSL shaders is similar to using uniform buffers.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GLSL 着色器中访问推送常量与使用统一缓冲区类似。
- en: How to do it...
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a shader file.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建着色器文件。
- en: 'Define a uniform block:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个统一块：
- en: 'Provide a `push_constant `layout qualifier:'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个`push_constant`布局限定符：
- en: '`layout( push_constant )`'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`layout(push_constant)`'
- en: Use a `uniform` storage qualifier
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`uniform`存储限定符
- en: Provide a unique name of the block
  id: totrans-347
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供块的唯一名称
- en: Inside the braces, define a set of uniform variables
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在大括号内，定义一组统一变量
- en: Specify the name of the block instance `<instance name>`.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定块实例的名称`<instance name>`。
- en: 'Inside the `void main()` function, access uniform variables using a block instance
    name:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`void main()`函数内部，使用块实例名称访问统一变量：
- en: '[PRE17]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Push constants are defined and accessed in a way similar to uniform blocks
    are specified in GLSL shaders, but there are some differences we need to remember:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 推送常量的定义和访问方式类似于在GLSL着色器中指定统一块，但有一些差异我们需要记住：
- en: We need to use a `layout( push_constant )` qualifier before the definition of
    the block
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在块的定义之前使用`layout(push_constant)`限定符
- en: We must specify an instance name for the block
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须为该块指定一个实例名称
- en: We can define only one such block per shader
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在每个着色器中定义这样一个块
- en: 'We access push constant variables by preceding their name with the instance
    name of the block:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在变量名前加上块的实例名称来访问推送常量变量：
- en: '[PRE18]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Push constants are useful for providing small amounts of data that change frequently,
    such as the transformation matrix or current time value--updating the push constants
    block should be much faster than updating descriptor resources such as uniform
    buffers. We just need to remember about the data size which is much smaller than
    it is for descriptor resources. Specification requires push constants to store
    at least 128 bytes of data. Each hardware platform may allow for more storage,
    but it may not be considerably bigger.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 推送常量对于提供频繁变化的小量数据非常有用，例如变换矩阵或当前时间值--更新推送常量块应该比更新描述符资源（如统一缓冲区）快得多。我们只需要记住数据大小，它比描述符资源小得多。规范要求推送常量至少存储128字节的数据。每个硬件平台可能允许更多的存储空间，但可能不会显著更大。
- en: Push constants can store at least 128 bytes of data.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 推送常量可以存储至少128字节的数据。
- en: 'An example of defining and using push constants in a fragment shader through
    which a color is provided may look like this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 定义和使用推送常量的一个示例，通过片段着色器提供颜色，可能看起来像这样：
- en: '[PRE19]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: See also
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Converting GLSL shaders to SPIR-V assemblies*'
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将GLSL着色器转换为SPIR-V汇编*'
- en: '*Writing a vertex shader that multiplies a vertex position by a projection
    matrix*'
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写一个乘以投影矩阵的顶点位置的顶点着色器*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下食谱：
- en: '*Creating a shader module*'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Creating a pipeline layout*'
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建管线布局*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipe:'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*中，查看以下食谱：
- en: '*Providing data to shaders through push constants*'
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过推送常量向着色器提供数据*'
- en: Writing texturing vertex and fragment shaders
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写纹理化的顶点着色器和片段着色器
- en: Texturing is a common technique that significantly improves the quality of rendered
    images. It allows us to load an image and wrap it around the object like a wallpaper.
    It increases the memory usage, but saves the performance which would be wasted
    on processing much more complex geometry.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理化是一种常见的技巧，它可以显著提高渲染图像的质量。它允许我们加载一个图像并将其像壁纸一样包裹在对象周围。这会增加内存使用量，但可以节省性能，否则这些性能会被浪费在处理更复杂的几何形状上。
- en: How to do it...
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Create a vertex shader in a text file called `shader.vert` (refer to the *Writing
    vertex shaders* recipe).
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`shader.vert`的文本文件中创建一个顶点着色器（参考*编写顶点着色器*食谱）。
- en: 'Apart from the vertex position, define an additional input variable (attribute)
    in the vertex shader through which texture coordinates are provided from the application:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了顶点位置之外，在顶点着色器中定义一个额外的输入变量（属性），通过该变量从应用程序提供纹理坐标：
- en: '[PRE20]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the vertex shader, define an output (varying) variable through which texture
    coordinates will be passed from the vertex shader to a fragment shader:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶点着色器中，定义一个输出（可变）变量，通过该变量将从顶点着色器传递纹理坐标到片段着色器：
- en: '[PRE21]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the vertex shader''s `void main()` function, assign the `app_tex_coordinates`
    variable to the `vert_tex_coordinates` variable:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶点着色器的`void main()`函数中，将`app_tex_coordinates`变量赋值给`vert_tex_coordinates`变量：
- en: '[PRE22]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Create a fragment shader (refer to the *Writing fragment shaders* recipe).
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个片段着色器（参考*编写片段着色器*食谱）。
- en: 'In the fragment shader, define an input variable in which texture coordinates
    provided from the vertex shader will be passed:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器中，定义一个输入变量，其中将从顶点着色器提供的纹理坐标传递过来：
- en: '[PRE23]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a uniform `sampler2D` variable that will represent the texture which
    should be applied to the geometry:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个统一的 `sampler2D` 变量，它将代表应用于几何体的纹理：
- en: '[PRE24]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Define an output variable in which the fragment''s final color (read from the
    texture) will be stored:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个输出变量，其中将存储片段的最终颜色（从纹理中读取）：
- en: '[PRE25]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the fragment shader''s `void main()` function, sample the texture and store
    the result in the `frag_color` variable:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器的 `void main()` 函数中，采样纹理并将结果存储在 `frag_color` 变量中：
- en: '[PRE26]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To draw an object, we need all its vertices. To be able to use a texture and
    apply it to the model, apart from vertex positions, we also need texture coordinates
    specified for each vertex. These attributes (position and texture coordinate)
    are passed to the vertex shader. It takes the position and transforms it to the
    clip space (if necessary), and passes the texture coordinates to the fragment
    shader:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制一个对象，我们需要它的所有顶点。为了能够使用纹理并将其应用于模型，除了顶点位置外，我们还需要为每个顶点指定纹理坐标。这些属性（位置和纹理坐标）传递给顶点着色器。它将位置转换到裁剪空间（如果需要），并将纹理坐标传递给片段着色器：
- en: '[PRE27]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The texturing operation is performed in the fragment shader. The texture coordinates
    from all the vertices forming a polygon are interpolated and provided to the fragment
    shader. It uses these coordinates to read (sample) a color from the texture. This
    color is stored in the output and (potentially) in the attachment:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理操作在片段着色器中执行。构成多边形的所有顶点的纹理坐标进行插值并提供给片段着色器。它使用这些坐标从纹理中读取（采样）一个颜色。此颜色存储在输出中，并（可能）在附加中：
- en: '[PRE28]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Apart from providing texture coordinates to shaders, the application also needs
    to prepare the texture itself. Usually, this is done by creating a combined image
    sampler (refer to the *Creating a combined image sampler* recipe from [Chapter
    5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*) and providing
    it to a descriptor set at `0`^(th) binding (in this sample). The Descriptor set
    must be bound to a `0`^(th) set index.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 除了向着色器提供纹理坐标外，应用程序还需要准备纹理本身。通常，这是通过创建一个组合图像采样器（参考 [第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*
    中的 *创建组合图像采样器* 食谱）并将其提供给描述符集在第 `0` 个绑定（在本示例中）来实现。描述符集必须绑定到第 `0` 个集合索引。
- en: '![](img/image_07_007.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_007.png)'
- en: See also
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipes:'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*，查看以下食谱：
- en: '*Creating a combined image sampler*'
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建组合图像采样器*'
- en: '*Updating descriptor sets*'
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新描述符集*'
- en: '*Binding descriptor sets*'
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定描述符集*'
- en: 'The following recipes in this chapter:'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Converting GLSL shaders to SPIR-V assemblies*'
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将GLSL着色器转换为SPIR-V汇编*'
- en: '*Writing vertex shaders*'
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写顶点着色器*'
- en: '*Writing fragment shaders*'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写片段着色器*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*，查看以下食谱：
- en: '*Creating a shader module*'
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Creating a graphics pipeline*'
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: Displaying polygon normals with a geometry shader
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用几何着色器显示多边形法线
- en: When rendering a geometry, we usually provide multiple attributes for each vertex--positions
    to draw the model, texture coordinates for texturing, and normal vectors for lighting
    calculation. Checking if all this data is correct may not be easy, but sometimes,
    when our rendering technique doesn't work as expected, it may be necessary.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染几何体时，我们通常为每个顶点提供多个属性--用于绘制模型的顶点位置、用于纹理化的纹理坐标以及用于光照计算的法线向量。检查所有这些数据是否正确可能并不容易，但有时，当我们的渲染技术没有按预期工作，这可能是有必要的。
- en: In graphics programming, there are some debugging methods that are commonly
    used. Texture coordinates, which are usually two-dimensional, are displayed instead
    of the usual color. We can do the same with the normal vectors, but as they are
    three-dimensional, we can also display them in a form of lines. For this purpose,
    a geometry shader may be used.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形编程中，有一些常用的调试方法。纹理坐标，通常是二维的，显示为通常的颜色。我们可以用同样的方式显示法线向量，但因为是三维的，我们也可以以线条的形式显示它们。为此，可以使用几何着色器。
- en: How to do it...
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Create a vertex shader called `normals.vert` (refer to the *Writing vertex shaders*
    recipe).
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `normals.vert` 的顶点着色器（参考 *编写顶点着色器* 食谱）。
- en: 'Define an input variable in which the vertex position will be provided to the
    vertex shader:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个输入变量，其中顶点位置将被提供给顶点着色器：
- en: '[PRE29]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define a second input variable in which the vertex normal vector will be provided:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义第二个输入变量，其中将提供顶点法线向量：
- en: '[PRE30]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define a uniform block with two matrices--one for a model-view transformation,
    the other for a projection matrix:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含两个矩阵的统一块——一个用于模型视图变换，另一个用于投影矩阵：
- en: '[PRE31]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define an output variable through which we will provide to a geometry shader
    a normal vector converted from a local space to a view space:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个输出变量，通过该变量我们将提供一个从局部空间转换为视图空间的法线向量给几何着色器：
- en: '[PRE32]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Convert a vertex position to a view space by multiplying the `ModelViewMatrix`
    variable and storing the result in the `gl_Position` built-in variable:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`ModelViewMatrix`变量与顶点位置相乘，将顶点位置转换为视图空间，并将结果存储在`gl_Position`内置变量中：
- en: '[PRE33]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In a similar way, convert the vertex normal to a view space, scale the result
    by a chosen value, and store the result in the `vert_normal` output variable:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以类似的方式，将顶点法线转换为视图空间，将结果按选定的值缩放，并将结果存储在`vert_normal`输出变量中：
- en: '[PRE34]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Create a geometry shader called `normal.geom` (refer to the *Writing geometry
    shaders* recipe).
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`normal.geom`的几何着色器（参考*编写几何着色器*配方）。
- en: 'Define a `triangle` input primitive type:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`triangle`输入原语类型：
- en: '[PRE35]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define an input variable through which the view-space vertex normal will be
    provided from the vertex shader:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个输入变量，通过该变量将从顶点着色器提供视图空间顶点法线：
- en: '[PRE36]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Define a uniform block with two matrices--one for a model-view transformation,
    the other for a projection matrix:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含两个矩阵的统一块——一个用于模型视图变换，另一个用于投影矩阵：
- en: '[PRE37]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Through an output layout qualifier, specify a `line_strip` as a generated primitive
    type with up to six vertices.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输出布局限定符，指定一个最多有六个顶点的`line_strip`作为生成的原语类型。
- en: '[PRE38]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Define an output variable through which a color will be provided from the geometry
    shader to a fragment shader:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个输出变量，通过该变量将从几何着色器提供颜色给片段着色器：
- en: '[PRE39]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Inside the `void main()` function, use a variable of type `int` named `vertex`
    to loop over all the input vertices. Perform the following operations for each
    input vertex:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`void main()`函数内部，使用名为`vertex`的`int`类型变量来遍历所有输入顶点。对每个输入顶点执行以下操作：
- en: 'Multiply `ProjectionMatrix` by an input vertex position and store the result
    in the `gl_Position` built-in variable:'
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ProjectionMatrix`与输入顶点位置相乘，并将结果存储在`gl_Position`内置变量中：
- en: '`gl_Position = ProjectionMatrix * gl_in[vertex].gl_Position; `'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`gl_Position = ProjectionMatrix * gl_in[vertex].gl_Position;`'
- en: 'In the `geom_color` output variable, store the desired color for the vertex
    normal at the contact point between geometry (vertex) and the vertex normal line:'
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`geom_color`输出变量中，存储在几何（顶点）与顶点法线线接触点处的顶点法线所需颜色：
- en: '`geom_color = vec4( <chosen color> );`'
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`geom_color = vec4( <chosen color> );`'
- en: Generate a new vertex by calling the `EmitVertex()` function.
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`EmitVertex()`函数生成一个新的顶点。
- en: 'Multiply `ProjectionMatrix` by the input vertex position offset by the `vert_normal`
    input variable. Store the result in the `gl_Position` built-in variable:'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ProjectionMatrix`与通过`vert_normal`输入变量偏移的输入顶点位置相乘。将结果存储在`gl_Position`内置变量中：
- en: '`gl_Position = ProjectionMatrix * (gl_in[vertex].gl_Position + vert_normal[vertex]);`'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`gl_Position = ProjectionMatrix * (gl_in[vertex].gl_Position + vert_normal[vertex]);`'
- en: 'Store the color of the vertex normal''s end point in the `geom_color` output
    variable:'
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顶点法线端点的颜色存储在`geom_color`输出变量中：
- en: '`geom_color = vec4( <chosen color> );`'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`geom_color = vec4( <chosen color> );`'
- en: Generate a new vertex by calling the `EmitVertex()` function.
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`EmitVertex()`函数生成一个新的顶点。
- en: Generate a primitive (a line with two points) by calling the `EndPrimitive()`
    function.
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`EndPrimitive()`函数生成一个原语（一个有两个点的线）。
- en: Create a fragment shader named `normals.frag` (refer to the *Writing fragment
    shaders* recipe).
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`normals.frag`的片段着色器（参考*编写片段着色器*配方）。
- en: 'Define an input variable through which a color, interpolated between two vertices
    of a line generated by the geometry shader, will be provided to the fragment shader:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过一个输入变量定义一个颜色，该颜色通过几何着色器生成的线的两个顶点之间的插值提供给片段着色器：
- en: '[PRE40]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Define an output variable for the fragment''s color:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个输出变量用于片段的颜色：
- en: '[PRE41]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Inside the `void main()` function, store the value of the `geom_color` input
    variable in the `frag_color` output variable:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`void main()`函数内部，将`geom_color`输入变量的值存储在`frag_color`输出变量中：
- en: '[PRE42]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Displaying vertex normal vectors from the application side is performed in
    two steps: first we draw geometry in a normal way with the usual set of shaders.
    The second step is to draw the same model but with a pipeline object that uses
    the vertex, geometry, and fragment shaders specified in this recipe.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序端显示顶点法向量分为两个步骤：首先，我们以常规方式使用一组常规着色器绘制几何图形。第二步是绘制相同的模型，但使用在此食谱中指定的顶点、几何和片段着色器的管线对象。
- en: 'The vertex shader just needs to pass a vertex position and a normal vector
    to the geometry shader. It may transform both to the view-space, but the same
    operation can be performed in the geometry shader. The sample source code of the
    vertex shader that does the transformation provided through a uniform buffer is
    presented in the following code:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器只需将顶点位置和法向量传递给几何着色器。它可以将两者都转换到视图空间，但相同的操作也可以在几何着色器中执行。以下代码展示了通过统一缓冲区提供的执行转换的顶点着色器的示例源代码：
- en: '[PRE43]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, the position and normal vector are both transformed to
    the view space with a model-view matrix. If we intend to scale a model non-uniformly
    (not the same scale for all dimensions), the normal vector must be transformed
    using an inverse transpose of the model-view matrix.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，位置和法向量都使用模型视图矩阵转换到视图空间。如果我们打算非均匀地缩放模型（不是所有维度的缩放相同），则必须使用模型视图矩阵的逆转置来转换法向量。
- en: 'The most important part of the code is performed inside geometry. It takes
    vertices that form the original primitive type (usually triangles), but outputs
    vertices forming line segments. It takes one input vertex, transforms it to a
    clip space and passes it further. The same vertex is used a second time, but this
    time it is offset by the vertex normal. After the translation, it is transformed
    to the clip space and passed to the output. These operations are performed for
    all vertices forming the original primitive. The source code for the whole geometry
    shader may look like this:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 代码最重要的部分是在几何内部执行的。它接收构成原始原语类型（通常是三角形）的顶点，但输出构成线段的顶点。它接收一个输入顶点，将其转换到裁剪空间并传递出去。相同的顶点被第二次使用，但这次它偏移了顶点法向量。在平移之后，它被转换到裁剪空间并传递到输出。这些操作对构成原始原语的所有顶点都执行。整个几何着色器的源代码可能看起来像这样：
- en: '[PRE44]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The geometry shader takes vertices converted by the vertex shader to the view
    space and transforms them further to the clip space. This is done with a projection
    matrix provided through the same uniform buffer as the one used in a vertex shader.
    Why do we define two matrix variables in a single uniform buffer, if we use just
    one of them in the vertex shader and a second one in the geometry shader? Such
    an approach is more convenient, because we just need to create a single buffer
    and we need to bind only one descriptor set to the command buffer. In general,
    the less operations we perform or record in the command buffer, the more performance
    we achieve. So this approach should also be faster.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 几何着色器接收由顶点着色器转换到视图空间的顶点，并将它们进一步转换到裁剪空间。这是通过在顶点着色器中使用的相同统一缓冲区提供的投影矩阵来完成的。如果我们只在顶点着色器中使用一个矩阵变量，而在几何着色器中使用第二个矩阵变量，为什么我们定义单个统一缓冲区中的两个矩阵变量？这种做法更方便，因为我们只需要创建一个缓冲区，并且只需要将一个描述符集绑定到命令缓冲区。一般来说，我们执行或记录在命令缓冲区中的操作越少，我们获得的性能就越高。因此，这种方法也应该更快。
- en: 'The fragment shader is simple as it only passes interpolated colors stored
    by the geometry shader:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器很简单，因为它只传递由几何着色器存储的插值颜色：
- en: '[PRE45]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The result of using the preceding shaders to draw a geometry, along with a
    model drawn in a normal way, can be seen in the following image:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的着色器绘制几何图形的结果，以及以常规方式绘制的模型，可以在以下图像中看到：
- en: '![](img/image_07_008.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_008.png)'
- en: See also
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Converting GLSL shaders to SPIR-V assemblies*'
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将GLSL着色器转换为SPIR-V汇编*'
- en: '*Writing vertex shaders*'
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写顶点着色器*'
- en: '*Writing geometry shaders*'
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写几何着色器*'
- en: '*Writing fragment shaders*'
  id: totrans-474
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写片段着色器*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下食谱：
- en: '*Creating a shader module*'
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Creating a graphics pipeline*'
  id: totrans-477
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
