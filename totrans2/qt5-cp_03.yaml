- en: Chapter 3. Cooking an RSS Reader with Qt Quick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on developing applications with Qt Quick. For
    touchscreen-enabled devices, Qt Quick applications are much more responsive and
    easy to write. An RSS reader is used as a demonstration in this chapter. The following
    topics will enable you to build elegant Qt Quick applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding model and view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing RSS Feeds by `XmlListModel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tweaking the categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing `ScrollView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding `BusyIndicator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a frameless window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding model and view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, Qt Quick applications are different from traditional Qt
    Widgets applications. You are going to write QML instead of C++ code. So, let's
    create a new project, a Qt Quick application named `RSS_Reader`. This time, we
    will use Qt Quick 2.3 as the component set. Since we won't use the widgets provided
    by Qt Quick Controls, we'll write our own widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Before getting our hands dirty, let's sketch out what this application looks
    like. According to the following diagram, there will be two sections. The left-hand
    panel provides some categories so that users can choose interesting categories.
    The right-hand panel is the main area, which displays news under the current category.
    This is a typical RSS news reader's user interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding model and view](img/4615OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can implement the **Categories** panel by using `ListView`. This type (we
    say "type" instead of "class" in QML) is used to display data from all sorts of
    list models. So let''s edit our `main.qml` to something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`ListView` needs a model to get data from. In this case, we can utilize `ListModel`
    for its simplicity. To achieve this, let''s create a new `Feeds.qml` file, which
    will contain a custom `ListModel` example:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Add New…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Qt** | **QML File (Qt Quick 2)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the `Feeds.qml` filename.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the content of `Feeds.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use BBC News RSS as feeds, but you may wish to change it to another.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the preceding `ListModel` example has two roles, `name` and
    `url`. A "role" is basically a fancy way of saying the child item. These can be
    bound to by the `ListView` delegate that we are about to create. In this way,
    roles usually represent the properties of an entity or columns of a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me explain the relation between view, model, and delegate, which is another
    important yet difficult concept in the world of Qt. This is officially called
    **model-view** architecture. In addition to the traditional view, Qt decouples
    the view and controller so that the data can be rendered and edited in many customized
    ways. The latter is much more elegant and efficient. The following diagram helps
    you understand this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding model and view](img/4615OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Take `ListModel`, which is a model used to arrange data, as an example to elaborate
    the relationship. `CategoriesDelegate`, shown in the following code, is a delegate
    and is used to control how to display the roles from the model. Lastly, we use
    a view, which is `ListView` in this case, to render the delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The communication between the models, views, and delegates are based on the
    signals and slots mechanism. It''ll take you some time to fully understand this
    concept. Hopefully, we can shorten this time by practicing this example. At this
    stage, we already have a view and a model. We have to define a delegate, which
    is `CategoriesDelegate` as mentioned before, to control the data from the model
    and render it on the view. Add a new `CategoriesDelegate.qml` file, whose content
    is pasted in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should have some idea about the relation between the model, delegate, and
    view. Here, we use `Rectangle` as the delegate type. Inside the `Rectangle` type
    is a `Text` object that displays the `name` from our `ListModel` example. As for
    the `font` property, here we use `pointSize` to specify the size of text, while
    you can use `pixelSize` as an alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish the model-view architecture, go back to the `main.qml` edit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Take note of the third line; it's crucial to import this directory into `qrc`.
    We use `"qrc:/"` because we need to put the QML files in the root directory. Modify
    it if you use a subdirectory to keep `Feeds.qml` and `CategoriesDelegate.qml`.
    In this example, these files are left unorganized. But it's highly recommended
    to keep them categorized as a different module. If you didn't import the directory,
    you won't be able to use these QML files.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Window` item, we create `Feeds`, which is exactly an element of
    `ListModel` from `Feeds.qml`. Then, we give this `Feeds` item a `categoriesModel`
    ID and use it as the model of `ListView`. Specifying the delegate is quite similar
    to specifying the model for views. Instead of declaring it outside `ListView`,
    we have to define it inside the `delegate` scope, otherwise the `delegate` item,
    `CategoriesDelegate`, won't be able to get data from the model. As you can see,
    we can manipulate the `width` of `categoriesDelegate`. This is to ensure that
    the text won't lie outside the boundary of `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything is done correctly, click on **Run** and you''ll see it run like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding model and view](img/4615OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Parsing RSS Feeds by XmlListModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's true that we now have categories, but they don't seem to be involved with
    RSS at all. Also, if you dig deeper, you'll find that the RSS feeds are in fact
    the XML documents. Qt already provides a useful type to help us parse them. We
    don't need to reinvent the wheel. This powerful type is the so-called `XmlListModel`
    element and it uses `XmlRole` to query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we need to expose the `url` role of `categoriesModel` to the main
    scope. This is done by declaring the property storing the model''s current element,
    `url`, inside `ListView`. Then, we can add an `XmlListModel` element and use that
    `url` element as its `source`. Accordingly, the modified `main.qml` file is pasted
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objects' values are changed dynamically and updated implicitly in Qt Quick.
    You don't need to give new values explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use this element, you will need to import the module by adding
    an `import QtQuick.XmlListModel 2.0` line. Additionally, `XmlListModel` is a read-only
    model which means that you can''t modify the data source through this model. This
    is completely acceptable since what we need is to retrieve the news data from
    the RSS feeds. Take `Top Stories` as an example; the following code is a part
    of this XML document content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `namespaceDeclarations` property needs to be set because the XML document
    has the XML namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, `xmlns` stands for the XML namespace, so we declare the namespace accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In fact, you can just declare a `media` namespace and safely ignore an `atom`
    namespace. However, if you didn't declare the `media` namespace, the application
    would end up failing to parse the XML document. Hence, go back to see the XML
    document and you'll find it has a hierarchy to order data. What we want here are
    these items. Take the top-level as root, `/`, so the path of `item` can be written
    as `/rss/channel/item`. This is exactly what we put in `query`.
  prefs: []
  type: TYPE_NORMAL
- en: All the `XmlRole` elements are created using `query` as the base. For `XmlRole`,
    `name` defines its name, which doesn't need to be the same as in the XML document.
    It's similar to `id` for the regular Qt Quick items. However, the query of `XmlRole`
    must use a relative path to the query of `XmlListModel`. Although it's a `string()`
    type in most cases, it still must be declared explicitly. If there are elements
    sharing the same keys, it'd be an array where the element listed first has the
    first index.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first index in XPath is `1` instead of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to get an attribute `thumbnail`. This is the `url` attribute
    of the `media:thumbnail` tag. In this case, it's the `@` symbol that will do all
    the magic we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to these categories, we have to write a delegate for the `XmlListModel`
    element to render the view. The new QML `NewsDelegate.qml` file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference is that this time we use `Column` to organize the news data
    and represent it in an intuitive way. The relevant diagram is sketched as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing RSS Feeds by XmlListModel](img/4615OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, this is why we use `Row` inside `Column` to box **Thumbnail** and **Title**
    together. Thus, we need to put an empty `item` element in front to separate each
    news delegate. Apart from these self-explanatory lines, there is a tip for dealing
    with links. You need to specify the slot for the `onLinkActivated` signal, which
    is `Qt.openUrlExternally(link)` in this case. Otherwise, nothing will happen when
    you click on the link.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all this, it''s time to write a view in `main.qml` to display our news:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to define the `width` of `NewsDelegate` in case it displays abnormally.
    Click on **Run**; the application will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing RSS Feeds by XmlListModel](img/4615OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tweaking the categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This application is still incomplete. For example, the news view won't change
    at all after you click on the other categories. In this stage, we're going to
    work this out and make it more beautiful.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do is add `MouseArea` to `CategoriesDelegate`. This element
    is used to deal with a variety of mouse interactions, including clicking. The
    new `CategoriesDelegate.qml` file''s code is pasted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, once a delegate gets clicked on, it'll change `categories.currentIndex`
    and `currentUrl` if necessary, or simply let `newsModel` reload. As mentioned
    before, QML is a dynamic language, which changes `categories.currentUrl`, the
    `source` property of `newsModel`, and would automatically cause `newsModel` to
    reload.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help users distinguish a currently-selected category from others, we may
    wish to change its size and scale. There are some attached properties, which are
    attached to each instance of a delegate or are simply shared among them. The `.isCurrentItem`
    property is the one that would so us a favor. It''s a Boolean value that holds
    whether this delegate is the current item or not. However, only the root item
    of a delegate can access these attached properties directly. In order to code
    in a clean way, we add a line to `Rectangle` of `CategoriesDelegate` to hold this
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can utilize `selected` in `Text` by adding the following lines to the
    `Text` item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`Text` will be scaled to `0.8` if it''s not selected and will behave as usual
    when it''s active. A similar condition is in place for its color. The `#AAA` color
    code is an extremely light gray color, which makes the active black text stand
    out more. However, there is no animation for these changes. While we want these
    transitions to be more natural, Qt Quick provides **Behavior with State** to make
    these transitions happen. By adding these lines to the `Text` item, we get the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Animations are expected to present when you change the current delegate, which
    results in changes in the color and scale. If you''re not sure whether you''ve
    performed the correct modification, the following code shows you the newly modified
    `CategoriesDelegate.qml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There is room to improve the categories, including the background image which
    is simply an `Image` element, and could form part of your exercises. However,
    it won't be covered in this chapter. Here, what we do next is to change the displaying
    fonts on the Windows platform. We're going to change the font to `Times New Roman`
    by adding a few lines in `main.cpp` (not `main.qml`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use a predefined macro to limit this change for the Windows platforms.
    By setting the font of `app` whose type is `QGuiApplication`, all the children
    widgets, including `engine`, are subjected to this change. Now run the application
    again; you should expect a new RSS reader with this newspaper-like font:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tweaking the categories](img/4615OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Utilizing ScrollView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our RSS news reader is shaping up now. From now on, let's focus on the unpleasant
    details. The first thing we're going to add is a scroll bar. To be more specific,
    `ScrollView` is about to be added.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the Qt 4 era, you had to write your own `ScrollView` component to gain
    this small yet very nice feature. Although you can utilize KDE Plasma Components'
    `ScrollArea` on X11 Platforms, there are no Qt bundled modules for this purpose,
    which means you can't use these on Windows and Mac OS X. Thanks to the open governance
    of the Qt project, a lot of community code gets merged, especially from the KDE
    community. From Qt 5.1 onwards, we have the `QtQuick.Controls` module, which has
    many built-in desktop components, including `ScrollView`.
  prefs: []
  type: TYPE_NORMAL
- en: It's a very easy to use element that provides scroll bars and content frames
    for its child item. There can be only one direct `Item` child, and this child
    is implicitly anchored to fill the `ScrollView` component. This means that we
    only need to anchor the `ScrollView` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to specify the child item. The first one is to declare the
    child item inside the `ScrollView` component''s scope, and the item which is inside
    will implicitly become the child of the `ScrollView` component. Another way is
    to set the `contentItem` property, which is an explicit method. In this chapter''s
    example, both ways are demonstrated for you. The content of `main.qml` is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since the child item is automatically filled with `anchors`, some lines inside
    `ListView` are deleted. Most of them are just moved to `ScrollView` though. You
    can see that we use the explicit way for `categories` and the implicit way for
    `newsList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking into `ScrollView`, we defined a custom `style` element by forcing `transientScrollBars`
    to `true`. It''s noted that the default value of `transientScrollBars` is platform
    dependent. The transient scroll bars only appear when the content is scrolled
    and then disappear when they are no longer needed. Anyway, it''s `false` by default
    on Windows, so we turn it on explicitly, resulting in a better visual style shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing ScrollView](img/4615OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding BusyIndicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The absence of a busy indicator makes people uncomfortable as well. No matter
    how short or long indicator it is, it takes time to download data and parse XML.
    I'm pretty sure you'd like to add such an indicator, which tells users to calm
    down and wait. Luckily, `BusyIndicator`, which is simply a running circle, is
    an element of `QtQuick.Controls`. This does exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'What you need to do is to add these lines to `main.qml` inside the `Window`
    item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that we don't need to change the `visible` property of `BusyIndicator`,
    because `BusyIndicator` is only visible when the `running` property is set to
    `true`. In this case, we set `running` to `true` when the `newsModel` status is
    `Loading`.
  prefs: []
  type: TYPE_NORMAL
- en: Making a frameless window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to what we did in the previous chapter, here we don''t want the borders
    of the system window to decorate our Qt Quick application. This is partly because
    it looks like a web application, which makes it seems odd with native window decorations.
    This job is even easier in QML than in C++. We can add the following line to `Window`
    in `main.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Although our RSS reader runs in a frameless style, there is no way to move it
    and it's difficult to close it, just like the situation in the previous chapter.
    Since our mouse has many duties for the categories and news `ListView` along with
    `ScrollView`, we can't simply use a new `MouseArea` element to fill the `Window`
    root. Therefore, what we're going to do is to draw our own title bar and, of course,
    the exit button.
  prefs: []
  type: TYPE_NORMAL
- en: To add the exit button image to the `qrc` file, right-click on `qml.qrc`, select
    **Open in Editor**, navigate to **Add** | **Add Files**, and then select `close.png`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It'd be better to use different resource files (`qrc`) for different types of
    files, which make it more organized. We'll talk more about resource files in [Chapter
    8](ch08.xhtml "Chapter 8. Enabling Your Qt Application to Support Other Languages"),
    *Enabling Your Qt Application to Support Other Languages*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a new QML `TitleBar.qml` file whose content is pasted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use a `QPoint` object, `mPos`, to store the position when the mouse
    button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we may have declared it as `var` or `variant` in the past, for maximum
    performance you should avoid the use of `var`. Also note that `variant` is deprecated
    now, so it shouldn't be used under any circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: The `MouseArea` element, which is used for moving, is located inside the `Rectangle`
    element. There are lots of predefined signals and slots for `MouseArea`. Note
    that we use the `onPressed` slot instead of `onClicked` here to get the mouse
    position. This is because the `clicked` signal is only emitted when the mouse
    button is pressed and then released, which makes it unsuitable for moving the
    window.
  prefs: []
  type: TYPE_NORMAL
- en: The `positionChanged` signal is emitted when the mouse button is pressed and
    then moved. In addition to this, there is a property called `hoverEnabled`, which
    is `false` by default. If you set it to `true`, all the mouse events will be handled
    even when no mouse button is clicked. In other words, the `positionChanged` signal
    will be emitted when the mouse is moving, regardless of whether it's clicked or
    not. Therefore, we don't set `hoverEnabled` to `true` in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's go back and check the `Image` item. The `fillMode` element determines
    how an image should be adjusted. By default, it'll be stretched despite the ratio.
    Here, we set it to preserve the ratio while we fit the `Image`. The `source` property
    holds the image file path. In this case, it's the `close.png` file that is in
    the `Resources` file, `qml.qrc`. Here we go; this is another `MouseArea`, which
    simply makes `Image` into a closed button.
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, it''s time to add `TitleBar` to `main.qml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We also use a `Text` element, `windowTitle`, to display the window title in
    `titleBar`. Since we retrieve data from BBC News, it's not a bad idea to call
    it `BBC News Reader` or just name it whatever you like.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the addition of the title bar, some code needs to be modified to
    spare room for it. Both the `ScrollView` component's anchored `top` should be
    changed to `titleBar.bottom` instead of `parent.top`, otherwise the title bar
    will be placed partially on top of these two scroll views.
  prefs: []
  type: TYPE_NORMAL
- en: Give the application a run; it should deliver a new visual style. Although it
    looks more like a web application, the whole interface is clean and integrated.
    Another benefit of this change is a unified UI across all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making a frameless window](img/4615OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debugging QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most common practice to debug QML is the use of the API console. JavaScript
    developers should be familiar with this because of the console support in QML.
    The relationships between the `console` functions and the Qt/C++ `QDebug` functions
    are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| QML | Qt/C++ |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `console.log()` | `qDebug()` |'
  prefs: []
  type: TYPE_TB
- en: '| `console.debug()` | `qDebug()` |'
  prefs: []
  type: TYPE_TB
- en: '| `console.info()` | `qDebug()` |'
  prefs: []
  type: TYPE_TB
- en: '| `console.warn()` | `qWarning()` |'
  prefs: []
  type: TYPE_TB
- en: '| `console.error()` | `qCritical()` |'
  prefs: []
  type: TYPE_TB
- en: 'With the preceding supports present, QML is just like JavaScript programming.
    At the same time, the following functions are also introduced in QML:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Functions | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `console.assert()` | This function tests whether the expression is true.
    If not, it will write an optional message to the console and print the stack trace.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `console.exception()` | This function prints an error message together with
    the stack trace of the JavaScript execution at the point it is called. |'
  prefs: []
  type: TYPE_TB
- en: '| `console.trace()` | This function prints the stack trace of the JavaScript
    execution at the point it is called. |'
  prefs: []
  type: TYPE_TB
- en: '| `console.count()` | This function prints the current number of times a particular
    piece of code has been executed, along with a message. |'
  prefs: []
  type: TYPE_TB
- en: '| `console.time()``console.timeEnd()` | This pair of functions will print the
    time that a particular piece of code between them takes in milliseconds. |'
  prefs: []
  type: TYPE_TB
- en: '| `console.profile()``console.profileEnd()` | This pair of functions profiles
    both the state of `QDeclarativeEngine` as well as the V8 call methods. However,
    you need to attach the QML Profiler tool to the application before `console.profileEnd()`
    is called. |'
  prefs: []
  type: TYPE_TB
- en: 'In addition to the preceding useful functions, the common **Debug** mode in
    Qt Creator is available for QML as well. The operations are almost identical to
    C++ debugging. You can set the breakpoints, observe values, and so on. However,
    there is one more thing provided for QML. It''s the **QML/JS Console**! Qt Creator
    doesn''t show the **QML/JS Console** by default, you have to turn it on manually.
    Just click on the small button (the red circle in the following screenshot), and
    then tick **QML/JS Console**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging QML](img/4615OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the application is interrupted by a breakpoint, you can use the **QML/JS
    Console** to execute the JavaScript expressions in the current context. You can
    change the property values temporarily, without editing the source, and view the
    results in the running application.
  prefs: []
  type: TYPE_NORMAL
- en: The **QML/JS Console** tab shows the debug output, both the Qt debug messages
    and JavaScript console messages, in an appealing way. It provides a button group
    to help you filter information, warnings, and errors. Therefore, just use this
    **QML/JS Console** tab to replace **Application Output** when you debug Qt Quick
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through a thorough introduction to Qt Quick. We also
    covered model-view programming, which is a vital concept in both Qt/C++ and Qt
    Quick/QML. You may also find that QML is in some way an extensible version of
    JavaScript. This is an additional bonus for JavaScript developers. However, it's
    not difficult to start if you've never written a script before. Once you start,
    you'll get to explore the fascinating qualities of Qt Quick. We're going to show
    you how to access camera devices using Qt in the next chapter.
  prefs: []
  type: TYPE_NORMAL
