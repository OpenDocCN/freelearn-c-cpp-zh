- en: Chapter 8. Using 3D Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to work and draw with 3D graphics. The recipes
    in this chapter will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Drawing 3D geometric primitives
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating, scaling, and translating
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing to an offscreen canvas
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing in 3D with the mouse
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding lights
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking in 3D
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a height map from an image
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a terrain with Perlin noise
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving mesh data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn the basics of creating graphics in 3D. We will
    use OpenGL and some useful wrappers that Cinder includes on some advanced OpenGL
    features.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Drawing 3D geometric primitives
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to draw the following 3D geometric shapes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Cube
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sphere
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Torus
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cylinder
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Include the necessary header to draw in OpenGL using Cinder commands and statements.
    Add the following code to the top of your source file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create several geometric primitives using Cinder's methods for drawing
    in 3D.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the member variables with information of our primitives:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Initialize the member variables with the position and sizes of the geometry.
    Add the following code in the `setup` method:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Before we draw the shapes, let''s also create a camera to rotate around our
    shapes to give us a better sense of perspective. Declare a `ci::CameraPersp` object:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Initialize it in the `setup` method:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the `update` method, we will make the camera rotate around our scene. Add
    the following code in the `update` method:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `draw` method, we will clear the background with black and use `mCamera`
    to define the window''s matrices. We will also enable OpenGL to read and write
    to the depth buffers. Add the following code in the `draw` method:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Cinder allows you to draw filled and stroked cubes, so let''s draw a cube with
    a white fill and black stroke:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's define the drawing color again as white, and draw a sphere with `mSphereCenter`
    and `mSphereRadius` as the sphere's position and radius, and the number of segments
    as `30`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Draw a line that begins at `mLineBegin` and ends at `mLineEnd`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Cinder draws a `Torus` at the coordinates of the origin `[0,0]`. So, we will
    have to translate it to the desired position at `mTorusPos`. We will be using
    `mTorusOuterRadius` and `mTorusInnerRadius` to define the shape''s inner and outer
    sizes:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, Cinder will draw a cylinder at the origin `[0,0]`, so we will have
    to translate it to the position defined in `mCylinderPosition`. We will also be
    using `mCylinderBaseRadius` and `mCylinderTopRadius`, to set the cylinder''s bottom
    and top sizes and `mCylinderHeight`, to set its height:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![How to do it…](img/8703OS_8_1.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cinder's drawing methods use OpenGL calls internally to provide fast and easy
    drawing routines.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The method `ci::gl::color` sets the drawing color so that all shapes will be
    drawn with that color until another color is set by calling `ci::gl::color` again.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about OpenGL transformations such as translation, scale, and rotation,
    please read the recipe *Rotating, scaling, and translating*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 OpenGL 变换（如平移、缩放和旋转）的信息，请阅读配方 *旋转、缩放和平移*。
- en: Rotating, scaling, and translating
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转、缩放和平移
- en: In this recipe, we will learn how to transform our graphics using OpenGL transformations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何使用 OpenGL 变换来转换我们的图形。
- en: We will draw a unit cube at `[0,0,0]` coordinates and then we will translate
    it to the center of the window, apply rotation, and scale it to a more visible
    size.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `[0,0,0]` 坐标处绘制一个单位立方体，然后将其平移到窗口中心，应用旋转，并将其缩放到更可见的大小。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Include the necessary files to draw with OpenGL and add the helpful `using`
    statements. Add the following code to the top of the source file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 包含必要的文件以使用 OpenGL 绘图并添加有用的 `using` 语句。将以下代码添加到源文件顶部：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We will apply rotation, translation, and scaling to alter the way our cube is
    rendered. We will use Cinder's wrappers for OpenGL.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用旋转、平移和缩放来改变我们的立方体渲染方式。我们将使用 Cinder 的 OpenGL 包装器。
- en: 'Let''s declare variables to store our values for the translation, rotation,
    and scale transformations:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明变量来存储平移、旋转和缩放变换的值：
- en: '[PRE13]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To define the translation amount, let''s translate half the window''s width
    on the x axis and half the window''s height on the y axis. This will bring anything
    we draw at `[0,0,0]` to the center of the window. Add the following code in the
    `setup` method:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了定义平移量，让我们在 x 轴上平移窗口宽度的一半，在 y 轴上平移窗口高度的一半。这将使我们绘制的 `[0,0,0]` 上的任何内容移动到窗口中心。在
    `setup` 方法中添加以下代码：
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s set the scale factor to be `100` on the x axis, `200` on the y axis,
    and `100` on the z axis. Anything we draw will be 100 times bigger on the x and
    z axes and 200 times bigger on the y axis. Add the following code in the `setup`
    method:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将缩放因子设置为 x 轴上的 `100`，y 轴上的 `200`，z 轴上的 `100`。我们绘制的任何内容在 x 和 z 轴上将是原来的 100
    倍，在 y 轴上是原来的 200 倍。在 `setup` 方法中添加以下代码：
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the `update` method, we will animate the rotation values by incrementing
    the rotation on the x and y axes.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `update` 方法中，我们将通过增加 x 和 y 轴上的旋转来动画化旋转值。
- en: '[PRE16]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `draw` method, let''s begin by clearing the background with black, setting
    the windows matrices to allow for drawing in 3D, and enabling OpenGL to read and
    write the depth buffer:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `draw` 方法中，我们首先用黑色清除背景，设置窗口矩阵以允许在 3D 中绘图，并启用 OpenGL 读取和写入深度缓冲区：
- en: '[PRE17]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s add a new matrix to the stack and translate, scale, and rotate using
    the previously defined variables:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在堆栈中添加一个新的矩阵，并使用之前定义的变量进行平移、缩放和旋转：
- en: '[PRE18]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Draw a unit quad at the origin `[0,0,0]` with a white fill and black stroke:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原点 `[0,0,0]` 处绘制一个单位四边形，填充为白色，轮廓为黑色：
- en: '[PRE19]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, remove the previously added matrix:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，移除之前添加的矩阵：
- en: '[PRE20]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![How to do it…](img/8703OS_8_2.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/8703OS_8_2.jpg)'
- en: How it works…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The calls to `ci::gl::enableDepthRead` and `ci::gl::enableDepthWrite` respectively,
    enable reading and writing to the depth buffer. The depth buffer is where the
    depth information is stored.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `ci::gl::enableDepthRead` 和 `ci::gl::enableDepthWrite` 分别启用对深度缓冲区的读取和写入。深度缓冲区是存储深度信息的地方。
- en: When reading and writing to the depth buffer is enabled, OpenGL will sort objects
    so that closer objects are drawn in front of farther objects. When reading and
    writing to the depth buffer, the disabled objects will be drawn in the order they
    where created.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用读取和写入深度缓冲区时，OpenGL 将对对象进行排序，使较近的对象在较远对象之前绘制。当读取和写入深度缓冲区时，禁用的对象将按照它们创建的顺序绘制。
- en: The methods `ci::gl::translate`, `ci::gl::rotate`, and `ci::gl::scale` are wrappers
    of OpenGL commands for translating, rotating, and scaling, which allow you to
    pass Cinder types as parameters.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `ci::gl::translate`、`ci::gl::rotate` 和 `ci::gl::scale` 是用于平移、旋转和缩放的 OpenGL
    命令的包装器，允许您将 Cinder 类型作为参数传递。
- en: Transformations in OpenGL are applied by multiplying vertex coordinates with
    transformation matrices. When we call the method `ci::gl::pushMatrices`, we add
    a copy of the current transformation matrix to the matrix stack. Calls to `ci::gl::translate`,
    `ci::gl::rotate`, or `ci::gl::scale` will apply the correspondent transformations
    to the last matrix in the stack, which will be applied to whatever geometry is
    created after calling the transformation methods. A call to `ci::gl::popMatrix`
    will remove the last transformation matrix in the stack so that transformations
    added to the last matrix will no longer affect our geometry.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenGL 中，通过将顶点坐标与变换矩阵相乘来应用变换。当我们调用 `ci::gl::pushMatrices` 方法时，我们将当前变换矩阵的副本添加到矩阵栈中。调用
    `ci::gl::translate`、`ci::gl::rotate` 或 `ci::gl::scale` 将将相应的变换应用到栈中的最后一个矩阵，这将应用到调用变换方法之后创建的任何几何体。调用
    `ci::gl::popMatrix` 将从栈中移除最后一个变换矩阵，这样添加到最后一个矩阵的变换将不再影响我们的几何体。
- en: Drawing to an offscreen canvas
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在离屏画布上绘制
- en: In this recipe, we will learn how to draw in an offscreen canvas using the OpenGL
    **Frame Buffer Object** (**FBO**).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何使用 OpenGL **帧缓冲对象**（**FBO**）在离屏画布上绘制。
- en: We will draw in an FBO and draw it onscreen as well as texture a rotating cube.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 FBO 中绘制，并将其绘制到屏幕上，同时纹理化一个旋转的立方体。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Include the necessary files to work with OpenGL and the FBOs as well as the
    useful `include` directives.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 包含必要的文件以使用 OpenGL 和 FBO，以及有用的 `include` 指令。
- en: 'Add the following code to the top of the source file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到源文件顶部：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We will use a `ci::gl::Fbo` object, a wrapper to an OpenGL FBO, to draw in an
    offscreen destination.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个 `ci::gl::Fbo` 对象，它是 OpenGL FBO 的包装器，以在离屏目标上绘制。
- en: 'Declare a `ci::gl::Fbo` object as well as a `ci::Vec3f` object to define the
    cube''s rotation:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `ci::gl::Fbo` 对象以及一个 `ci::Vec3f` 对象来定义立方体的旋转：
- en: '[PRE22]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Initialize `mFbo` with a size of 256 x 256 pixels by adding the following code
    in the `setup` method:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中添加以下代码以初始化 `mFbo`，大小为 256 x 256 像素：
- en: '[PRE23]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Animate `mCubeRotation` in the `update` method:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `update` 方法中动画化 `mCubeRotation`：
- en: '[PRE24]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Declare a method where we will draw to the FBO:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个我们将绘制到 FBO 的方法：
- en: '[PRE25]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the implementation of `drawToFbo`, we will begin by creating a `ci::gl::SaveFramebufferBinding`
    object and then bind `mFbo`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `drawToFbo` 的实现中，我们首先创建一个 `ci::gl::SaveFramebufferBinding` 对象，然后绑定 `mFbo`。
- en: '[PRE26]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now we will clear the background with a dark gray color and set the matrices
    using the FBO's width and height.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用深灰色清除背景，并使用 FBO 的宽度和高度设置矩阵。
- en: '[PRE27]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we will draw a rotating color cube at the center of the FBO with size `100`
    and using `mCubeRotation` to rotate the cube.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将绘制一个大小为 `100` 的旋转彩色立方体，位于 FBO 的中心，并使用 `mCubeRotation` 旋转立方体。
- en: '[PRE28]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s move to the implementation of the `draw` method. Start by calling the
    method `drawToFbo`, clearing the background with black, setting the window''s
    matrices, and enable reading and writing to the depth buffer. Add the following
    code in the `draw` method:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转向 `draw` 方法的实现。首先调用 `drawToFbo` 方法，用黑色清除背景，设置窗口的矩阵，并启用对深度缓冲区的读写。在 `draw`
    方法中添加以下代码：
- en: '[PRE29]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lets draw our Fbo at the top left corner of the window using mFbo texture:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们使用 mFbo 纹理在窗口的左上角绘制我们的 Fbo：
- en: '[PRE30]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Enable and bind the texture of `mFbo`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用并绑定 `mFbo` 的纹理：
- en: '[PRE31]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Draw a rotating cube at the center of the window using `mCubeRotation` to define
    its rotation:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `mCubeRotation` 定义其旋转，在窗口中心绘制一个旋转的立方体：
- en: '[PRE32]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To finalize, unbind the texture of `mFbo`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成，解绑 `mFbo` 的纹理：
- en: '[PRE33]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![How to do it…](img/8703OS_8_3.jpg)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/8703OS_8_3.jpg)'
- en: How it works…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The class `ci::gl::Fbo` wraps an OpenGL FBO**.**
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `ci::gl::Fbo` 包装了一个 OpenGL FBO**。**
- en: Frame Buffer Objects are OpenGL objects that contain a collection of buffers
    that can be used as rendering destinations. The OpenGL context provides a default
    frame buffer where rendering occurs. Frame Buffer Objects allow rendering to alternative,
    offscreen locations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 帧缓冲对象是 OpenGL 对象，包含一组可以作为渲染目标的缓冲区。OpenGL 上下文提供了一个默认的帧缓冲区，渲染在其中发生。帧缓冲对象允许将渲染到替代的离屏位置。
- en: The FBO has a color texture where the graphics are stored, and it can be bound
    and drawn like a regular OpenGL texture.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: FBO 有一个颜色纹理，图形存储在其中，它可以像常规 OpenGL 纹理一样绑定和绘制。
- en: On step 5, we created a `ci::gl::SaveFramebufferBinding` object, which is a
    helper class that restores the previous FBO state. When using OpenGL ES, this
    object will restore and bind the previously bound FBO (usually the *screen* FBO)
    when it is destroyed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 步中，我们创建了一个 `ci::gl::SaveFramebufferBinding` 对象，这是一个辅助类，用于恢复之前的 FBO 状态。当使用
    OpenGL ES 时，此对象将在销毁时恢复并绑定之前绑定的 FBO（通常是 *screen* FBO）。
- en: See also
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the recipe *Rotating, scaling, and translating* to learn more about OpenGL
    transformations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 查看关于 OpenGL 变换的更多信息的配方 *旋转、缩放和移动*。
- en: Drawing in 3D with the mouse
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用鼠标在 3D 中绘制
- en: In this recipe, we will draw with the mouse on a 3D space. We will draw lines
    when dragging the mouse or rotate the scene in 3D when dragging and pressing the
    *Shift* key simultaneously.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用鼠标在 3D 空间中绘制。当拖动鼠标时，我们将绘制线条；当同时拖动并按下 *Shift* 键时，我们将旋转 3D 场景。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Include the necessary files to draw using OpenGL, as well as the files needed
    to use Cinder's perspective, Maya camera, and poly lines.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 包含绘制所需的必要文件，以及使用 Cinder 的透视、Maya 相机和多边形的文件。
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Also, add the following `using` statements:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 还要添加以下 `using` 语句：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How to do it…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We will use the `ci::CameraPersp` and `ci::Ray` classes to convert the mouse
    coordinates to our rotated 3D scene.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `ci::CameraPersp` 和 `ci::Ray` 类将鼠标坐标转换为我们的旋转 3D 场景。
- en: 'Declare a `ci::MayaCamUI` object and a `std::vector` object of `ci::PolyLine<ci::Vec3f>`
    to store the drawn lines:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `ci::MayaCamUI` 对象和一个 `ci::PolyLine<ci::Vec3f>` 的 `std::vector` 对象来存储绘制的线条：
- en: '[PRE36]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the `setup` method, we will create `ci::CameraPersp` and set it up so that
    the point of interest is the center of the window. We will also set the camera
    as the current camera of `mCamera:`
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中，我们将创建 `ci::CameraPersp` 并将其设置为中心点为窗口的中心。我们还将设置相机为 `mCamera:` 的当前相机。
- en: '[PRE37]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the `draw` method, let's clear the background with black and use our camera
    to set the window's matrices.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `draw` 方法中，让我们用黑色清除背景，并使用我们的相机设置窗口的矩阵。
- en: '[PRE38]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now let''s iterate `mLines` and draw each `ci::PolyLine`. Add the following
    code to the `draw` method:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们迭代 `mLines` 并绘制每个 `ci::PolyLine`。将以下代码添加到 `draw` 方法中：
- en: '[PRE39]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With our scene set up and the lines being drawn, we need to create the 3D perspective!
    Let''s start by declaring a method to convert coordinates from the screen position
    to world position. Add the following method declaration:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景设置好并且线条正在绘制时，我们需要创建 3D 透视！让我们首先声明一个将坐标从屏幕位置转换为全局位置的方法。将以下方法声明添加到以下代码中：
- en: '[PRE40]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `screenToWorld` implementation, we need to generate a ray from `point`
    using the cameras perspective. Add the following code in `screenToWorld`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `screenToWorld` 的实现中，我们需要使用相机的透视从 `point` 生成一条射线。在 `screenToWorld` 中添加以下代码：
- en: '[PRE41]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we need to calculate where the ray will intersect with a perpendicular
    plane at the camera''s center of interest and then return the intersection point.
    Add the following code in the `screenToWorld` implementation:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要计算射线将在相机中心兴趣点的垂直平面上相交的位置，然后返回交点。在 `screenToWorld` 的实现中添加以下代码：
- en: '[PRE42]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s use the previously defined method to draw with the mouse. Declare the
    `mouseDown` and `mouseDrag` event handlers:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用之前定义的方法用鼠标绘制。声明 `mouseDown` 和 `mouseDrag` 事件处理器：
- en: '[PRE43]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the implementation of `mouseDown`, we will check if the *Shift* key is being
    pressed. If it is, we will call the `mouseDown` method of `mCamera`, otherwise,
    we will add `ci::PolyLine<ci::Vec3f>` to `mLines`, calculate the world position
    of the mouse cursor using `screenToWorld`, and add it:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `mouseDown` 的实现中，我们将检查是否按下了 *Shift* 键。如果是，我们将调用 `mCamera` 的 `mouseDown` 方法；否则，我们将向
    `mLines` 中添加 `ci::PolyLine<ci::Vec3f>`，使用 `screenToWorld` 计算鼠标光标的全局位置，并将其添加：
- en: '[PRE44]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the implementation of `mouseDrag`, we will check if the *Shift* key is being
    pressed. If it is, we will call the `mouseDrag` method to `mCamera`, otherwise,
    we will calculate the world position of the mouse cursor and add it to last line
    in `mLines`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `mouseDrag` 的实现中，我们将检查是否按下了 *Shift* 键。如果是，我们将调用 `mCamera` 的 `mouseDrag` 方法；否则，我们将计算鼠标光标的全局位置并将其添加到
    `mLines` 的最后一行。
- en: '[PRE45]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Build and run the application. Press and drag the mouse to draw a line. Press
    the *Shift* key and press and drag the mouse to rotate the scene.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。按住并拖动鼠标以绘制线条。按住 *Shift* 键并按住并拖动鼠标以旋转场景。
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We use `ci::MayaCamUI` to easily rotate our scene.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ci::MayaCamUI` 来轻松旋转场景。
- en: The `ci::Ray` class is a representation of a ray, containing an origin, direction,
    and an infinite length. It provides useful methods to calculate intersections
    between rays and triangles or planes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ci::Ray`类是对射线的表示，包含一个起点、方向和无限长度。它提供了有用的方法来计算射线与三角形或平面的交点。'
- en: To calculate the world position of the mouse cursor we calculated a ray going
    from the camera's eye position in the camera's view direction.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算鼠标光标的全局位置，我们计算了一个从相机眼睛位置沿相机视图方向的射线。
- en: We then calculated the intersection of the ray with the plane at the center
    of the scene, perpendicular to the camera.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后计算了射线与场景中心的平面的交点，该平面垂直于相机。
- en: The calculated position is then added to a `ci::PolyLine<ci::Vec3f>` object
    to draw the lines.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将计算出的位置添加到`ci::PolyLine<ci::Vec3f>`对象中，以绘制线条。
- en: See also
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more on how to use `ci::MayaCamUI`, please refer to the recipe *Using
    MayaCamUI* from [Chapter 2](ch02.html "Chapter 2. Preparing for Development"),
    *Preparing for Development*.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于如何使用`ci::MayaCamUI`的信息，请参阅第2章中的配方*使用MayaCamUI*，*准备工作*。
- en: To learn how to draw in 2D, please read the recipe *Drawing arbitrary shapes
    with the mouse* from [Chapter 7](ch07.html "Chapter 7. Using 2D Graphics"), *Using
    2D Graphics*.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解如何在2D中绘制，请阅读第7章中的配方*使用鼠标绘制任意形状*，*使用2D图形*。
- en: Adding lights
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加灯光
- en: In this chapter, we will learn how to illuminate a 3D scene using OpenGL lights.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用OpenGL灯光照亮3D场景。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Include the necessary files to use OpenGL lights, materials, and draw. Add
    the following code to the top of the source file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 包含必要的文件以使用OpenGL灯光、材质和绘制。将以下代码添加到源文件顶部：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also add the following `using` statements:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 还需添加以下`using`语句：
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How to do it…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We will use the default OpenGL light rendering methods to illuminate our scene.
    We will use the `ci::gl::Material` and `ci::gl::Light` classes, which are wrappers
    around the OpenGL functionality.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用默认的OpenGL灯光渲染方法来照亮我们的场景。我们将使用`ci::gl::Material`和`ci::gl::Light`类，这些类是OpenGL功能的包装器。
- en: Declare `ci::gl::Material` to define the material properties of the objects
    being drawn and `ci::Vec3f` to define the lights position.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`ci::gl::Material`以定义正在绘制的物体的材质属性，以及`ci::Vec3f`以定义灯光的位置。
- en: '[PRE48]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s set the materials `Ambient`, `Diffuse`, `Specular`, `Emission`, and
    `Shininess` properties by adding the following code in the `setup` method:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`setup`方法中添加以下代码来设置材质的`Ambient`、`Diffuse`、`Specular`、`Emission`和`Shininess`属性。
- en: '[PRE49]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the `update` method, we will use the mouse to define the light position.
    Add the following code in the `update` method:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们将使用鼠标来定义灯光位置。在`update`方法中添加以下代码：
- en: '[PRE50]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the `draw` method, we will begin by clearing the background, setting the
    window's matrices, and enabling reading and writing to the depth buffer.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法中，我们将首先清除背景，设置窗口的矩阵，并启用读取和写入深度缓冲区。
- en: '[PRE51]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Let's create an OpenGL light using a `ci::gl::Light` object. We will define
    it as a `POINT` light and set its ID to `0`. We will also set its position to
    `mLightPos` and define its attenuation.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`ci::gl::Light`对象创建一个OpenGL灯光。我们将将其定义为`POINT`灯光，并将其ID设置为`0`。我们还将将其位置设置为`mLightPos`并定义其衰减。
- en: '[PRE52]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Let's enable OpenGL lighting, the previously created light, and apply the material.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们启用OpenGL灯光、之前创建的灯光并应用材质。
- en: '[PRE53]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s draw a rotating `Torus` at the center of the window and use the elapsed
    seconds to rotate it. Add the following code to the `draw` method:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在窗口中心绘制一个旋转的`Torus`，并使用经过的时间来旋转它。将以下代码添加到`draw`方法中：
- en: '[PRE54]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, disable the light:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，禁用灯光：
- en: '[PRE55]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Build and run the application; you will see a red rotating torus. Move the mouse
    to change the lights position.![How to do it…](img/8703OS_8_4.jpg)
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序；您将看到一个红色的旋转环面。移动鼠标以更改灯光的位置。![如何操作…](img/8703OS_8_4.jpg)
- en: How it works…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 的工作原理…
- en: We are using the `ci::gl::Material` and `ci::gl::Light` objects, which are helper
    classes to define the properties of lights and materials.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`ci::gl::Material`和`ci::gl::Light`对象，这些是定义灯光和材质属性的辅助类。
- en: 'The material properties defined in the `setup` method, work in the following
    ways:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup`方法中定义的材质属性按以下方式工作：
- en: '| Material Property | Function |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 材质属性 | 功能 |'
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Ambient | How an object can reflect light that comes in all directions. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 环境光 | 物体如何反射来自各个方向的光线。|'
- en: '| Diffuse | How an object reflects light that comes from a specific direction
    or position. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| Diffuse | 物体如何反射来自特定方向或位置的光。 |'
- en: '| Specular | The light that an object will reflect as a result of diffuse lighting.
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| Specular | 由于漫射光照，物体将反射的光。 |'
- en: '| Emission | Light emitted by the object. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| Emission | 物体发出的光线。 |'
- en: '| Shininess | The angle that the object will reflect specular light. Has to
    be a value between 1 and 128. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| Shininess | 物体反射镜面光的角度。必须是介于 1 和 128 之间的值。 |'
- en: The material ambient, diffuse, and specular colors will multiply with the ambient,
    diffuse, and specular colors coming from the light source, which are all white
    by default.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 材料的环境、漫射和镜面颜色将与来自光源的环境、漫射和镜面颜色相乘，默认情况下这些颜色都是白色。
- en: It is possible to define three different types of lights. In the previous example,
    we defined our light source to be of type `ci::gl::Light::POINT`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义三种不同类型的灯光。在先前的例子中，我们将我们的光源定义为类型 `ci::gl::Light::POINT`。
- en: 'Here are the available types of light and their properties:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是可用的灯光类型及其属性：
- en: '| Light Type | Properties |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 灯光类型 | 属性 |'
- en: '| --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ci::gl::Light::POINT` | Point light is the light coming from a specific
    position in space and illuminating in all directions. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `ci::gl::Light::POINT` | 点光源是从空间中的特定位置发出的光线，向所有方向照明。 |'
- en: '| `ci::gl::Light::DIRECTION` | Directional light simulates light coming from
    a position so far away that all light rays are parallel and arrive in the same
    direction. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `ci::gl::Light::DIRECTION` | 方向光模拟来自非常远的位置的光，所有光束都是平行的，并且以相同方向到达。 |'
- en: '| `ci::gl::Light::SPOTLIGHT` | Spotlight is the light coming from a specific
    position in space and a specific direction. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `ci::gl::Light::SPOTLIGHT` | 聚光灯是从空间中的特定位置和特定方向发出的光线。 |'
- en: We also defined the attenuation values. Lights in OpenGL allow for defining
    the values for the constant attenuation, linear attenuation, and quadratic attenuation.
    These define how the light becomes dimmer as the distance from the light source
    increases.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了衰减值。OpenGL中的灯光允许定义常量衰减、线性衰减和二次衰减的值。这些值定义了随着与光源距离的增加，光线如何变暗。
- en: To illuminate geometry, it is necessary to calculate the normal for each vertex.
    All shapes created using Cinder's commands have their normal calculated for us,
    so we don't have to worry about that.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要照亮几何体，必须计算每个顶点的法线。使用 Cinder 的命令创建的所有形状都会为我们计算法线，所以我们不必担心这一点。
- en: There's more…
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: It is also possible to define the ambient, diffuse, and specular colors coming
    from the light source. The values defined in these colors will multiply with the
    correspondent colors of the material.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以定义来自光源的环境、漫射和镜面颜色。这些颜色中定义的值将与材料的相应颜色相乘。
- en: 'Here are the `ci::gl::Light` methods that allow you to define the light colors:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是允许您定义灯光颜色的 `ci::gl::Light` 方法：
- en: '| Method | Light |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 灯光 |'
- en: '| --- | --- |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `setAmbient( const Color& color )` | Color of the ambient light. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `setAmbient( const Color& color )` | 环境光的颜色。 |'
- en: '| `setDiffuse( const Color& color )` | Color of the diffuse light. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `setDiffuse( const Color& color )` | 漫射光的颜色。 |'
- en: '| `setSpecular( const Color& color )` | Color of the specular light. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `setSpecular( const Color& color )` | 镜面光的颜色。 |'
- en: It is possible to create more than one light source. The amount of lights is
    dependent on the implementation of the graphics card, but it is always at least
    `8`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建多个光源。灯光的数量取决于显卡的实现，但至少总是 `8` 个。
- en: To create more light sources, simply create more `ci::gl::Light` objects and
    make sure each gets a unique ID.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建更多光源，只需创建更多的 `ci::gl::Light` 对象，并确保每个都获得一个唯一的 ID。
- en: See also
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Please read the recipe *Calculating vertex normals* to learn how to calculate
    the vertex normals for user created geometry.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请阅读 *计算顶点法线* 菜谱，了解如何计算用户创建的几何体的顶点法线。
- en: Picking in 3D
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D 选择
- en: In this recipe, we will calculate the intersection of the mouse cursor with
    a 3D model.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将计算鼠标光标与 3D 模型的交点。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Include the necessary files to draw using OpenGL, use textures and load images,
    load 3D models, define OpenGL lights and materials, and use Cinder's Maya camera.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 包含必要的文件以使用 OpenGL 绘图，使用纹理和加载图像，加载 3D 模型，定义 OpenGL 灯光和材料，并使用 Cinder 的 Maya 相机。
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Also, add the following `using` statements:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，添加以下 `using` 语句：
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We will use a 3D model, so place a file and its texture in the `assets` folder.
    For this example, we will be using a mesh file named `ducky.msh` and a texture
    named `ducky.png`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个 3D 模型，所以将文件及其纹理放在 `assets` 文件夹中。在这个例子中，我们将使用一个名为 `ducky.msh` 的网格文件和一个名为
    `ducky.png` 的纹理。
- en: How to do it…
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We will use the `ci::CameraPersp` and `ci::Ray` classes to convert the mouse
    coordinates to our rotated 3D scene and calculate the intersection with a 3D model.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `ci::CameraPersp` 和 `ci::Ray` 类将鼠标坐标转换为我们的旋转 3D 场景并计算与 3D 模型的交点。
- en: 'Declare the members to define the 3D model and its intersection with the mouse,
    as well as a `ci::MayaCamUI` object for easy navigation, and a `ci::gl::Material`
    for lighting:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明成员以定义 3D 模型及其与鼠标的交点，以及一个用于轻松导航的 `ci::MayaCamUI` 对象和一个用于照明的 `ci::gl::Material`：
- en: '[PRE58]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Declare a method where we will calculate the intersection between a `ci::Ray`
    class and the triangles that make up `mMesh`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个方法，我们将计算 `ci::Ray` 类与组成 `mMesh` 的三角形之间的交点。
- en: '[PRE59]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the `setup` method, lets load the model and texture and calculate its bounding
    box:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中，让我们加载模型和纹理并计算其边界框：
- en: '[PRE60]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s define the camera and make it look as if it''s at the center of the
    model. Add the following code in the `setup` method:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `setup` 方法中定义相机并使其看起来位于模型的中心。在 `setup` 方法中添加以下代码：
- en: '[PRE61]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Finally, set up the material for the model's lighting.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，设置模型的照明材质。
- en: '[PRE62]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Declare the handlers for the `mouseDown` and `mouseDrag` events.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `mouseDown` 和 `mouseDrag` 事件的处理器。
- en: '[PRE63]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Implement these methods by calling the necessary methods of `mCam`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `mCam` 的必要方法来实现这些方法：
- en: '[PRE64]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let''s implement the `update` method and calculate the intersection between
    the mouse cursor and our model. Let''s begin by getting the mouse position and
    then calculate `ci::Ray` emitting from our camera:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现 `update` 方法并计算鼠标光标与我们的模型之间的交点。让我们先获取鼠标位置，然后计算从我们的相机发出的 `ci::Ray`：
- en: '[PRE65]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Let's perform a fast test and check if the ray intersects with the model's bounding
    box. If the result is `true`, we will call the `calcIntersectionWithMeshTriangles`
    method.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进行快速测试，检查射线是否与模型的边界框相交。如果结果是 `true`，我们将调用 `calcIntersectionWithMeshTriangles`
    方法。
- en: '[PRE66]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Let's implement the `calcIntersectionWithMeshTriangles` method. We will iterate
    over all the triangles of our model and calculate the nearest intersection and
    store its index.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现 `calcIntersectionWithMeshTriangles` 方法。我们将遍历我们模型的全部三角形，计算最近的交点并存储其索引。
- en: '[PRE67]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Let's check if there was any intersection and calculate its position and normal.
    If no intersection was found, we will simply set `mIntersects` to `false`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查是否有任何交点并计算其位置和法向量。如果没有找到交点，我们将简单地设置 `mIntersects` 为 `false`。
- en: '[PRE68]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'With the intersection calculated, let''s draw the model, intersection point,
    and normal. Start by clearing the background with black, setting the window''s
    matrices using our camera, and enabling reading and writing to the depth buffer.
    Add the following code in the `draw` method:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算出交点后，让我们绘制模型、交点和法向量。首先用黑色清除背景，使用我们的相机设置窗口的矩阵，并启用深度缓冲区的读写。在 `draw` 方法中添加以下代码：
- en: '[PRE69]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now let's create a light and set its position as the camera's eye position.
    We'll also enable the light and apply the material.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个光源并将其位置设置为相机的眼睛位置。我们还将启用光源并应用材质。
- en: '[PRE70]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now enable and bind the models texture, draw the model, and disable both texture
    and lighting.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，启用并绑定模型的纹理，绘制模型，然后禁用纹理和照明。
- en: '[PRE71]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Finally, we will check if `mIntersects` is `true` and draw a sphere at the intersection
    point and the normal vector.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将检查 `mIntersects` 是否为 `true`，并在交点处绘制一个球体以及法向量。
- en: '[PRE72]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '![How to do it…](img/8703OS_8_5.jpg)'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/8703OS_8_5.jpg)'
- en: How it works…
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To calculate the intersection of the mouse with the model in 3D, we generated
    a ray from the mouse position towards the view direction of the camera.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 3D 中鼠标与模型的交点，我们从一个鼠标位置向相机的观察方向生成一个射线。
- en: For performance reasons, we first calculate if the ray intersects with the model's
    bounding box. In case there is an intersection with the model, we further calculate
    the intersection between the ray and each triangle that makes up the model. For
    every intersection found, we check its distance and calculate the intersection
    point and the normal of only the nearest intersection.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于性能原因，我们首先计算射线是否与模型的边界框相交。如果与模型相交，我们进一步计算射线与组成模型的每个三角形的交点。对于找到的每个交点，我们检查其距离并仅计算最近交点的交点和法向量。
- en: Creating a height map from an image
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从图像创建高度图
- en: In this recipe, we will learn how to create a point cloud based on an image
    selected by the user. We will create a grid of points where each point will correspond
    to a pixel. The x and y coordinates of each point will be equal to the pixel's
    position on the image, and the z coordinate will be calculated based on its color.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何根据用户选择的图像创建点云。我们将创建一个点阵，其中每个点将对应一个像素。每个点的x和y坐标将等于图像上像素的位置，而z坐标将基于其颜色计算。
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Include the necessary files to work with OpenGL, image surfaces, VBO meshes,
    and loading images.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 包含必要的文件以使用OpenGL、图像表面、VBO网格和加载图像。
- en: 'Add the following code to the top of the source file:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到源文件顶部：
- en: '[PRE73]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Also, add the following `using` statements:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 还要添加以下`using`语句：
- en: '[PRE74]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How to do it…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We will learn how to read pixel values from an image and create a point cloud.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何从图像中读取像素值并创建点云。
- en: Declare `ci::Surface32f` to store the image pixels, `ci::gl::VboMesh` that we
    will use as the point cloud, and `ci::MayaCamUI` for easy rotation of our scene.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`ci::Surface32f`以存储图像像素，`ci::gl::VboMesh`我们将用作点云，以及`ci::MayaCamUI`以方便地旋转我们的场景。
- en: '[PRE75]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the `setup` method, we will first open a file load dialog and then let the
    user select the image to use and check if it returns a valid path.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，我们首先打开一个文件加载对话框，然后让用户选择要使用的图像并检查它是否返回一个有效的路径。
- en: '[PRE76]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Next, let's load the image and initialize `mPointCloud`. We will set the `ci::gl::VboMesh::Layout`
    to have dynamic positions and colors so that we will be able to change them later.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们加载图像并初始化`mPointCloud`。我们将设置`ci::gl::VboMesh::Layout`以具有动态位置和颜色，这样我们就可以稍后更改它们。
- en: '[PRE77]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Next, we'll iterate over the image's pixels and update the vertices in `mPointCloud`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将遍历图像的像素并更新`mPointCloud`中的顶点。
- en: '[PRE78]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Now we will set up the camera so that it will rotate around the center of the
    point cloud and close the `if` statement we began on the second step.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置相机，使其围绕点云的中心旋转，并关闭我们在第二步开始时的`if`语句。
- en: '[PRE79]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Let's declare and implement the necessary mouse event handlers to use `mCam`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明并实现必要的鼠标事件处理程序以使用`mCam`。
- en: '[PRE80]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'And implement them:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并实现它们：
- en: '[PRE81]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In the `draw` method, we will begin by clearing the background, setting the
    window's matrices defined by `mCam`, and enable reading and writing the depth
    buffer.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法中，我们将首先清除背景，设置由`mCam`定义的窗口矩阵，并启用读取和写入深度缓冲区。
- en: '[PRE82]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Finally, we will check if `mPointCloud` is a valid object and draw it.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将检查`mPointCloud`是否是一个有效的对象，并绘制它。
- en: '[PRE83]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Build and run the application. You will be prompted with a dialog box to select
    an image file. Select it and you will see a point cloud representation of the
    image. Drag the mouse cursor to rotate the scene.![How to do it…](img/8703OS_8_6.jpg)
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。您将看到一个对话框提示您选择一个图像文件。选择它，您将看到图像的点云表示。拖动鼠标光标以旋转场景。![如何做…](img/8703OS_8_6.jpg)
- en: How it works…
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We started by loading an image into `ci::Surface32f.` This surface stores pixels
    as float numbers in the range from `0` to `1`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将图像加载到`ci::Surface32f`中。此表面将像素存储为范围从`0`到`1`的浮点数。
- en: We created a grid of points where the `x` and `y` coordinates represented the
    pixel's position on the image and the `z` coordinate was the length of the color's
    vector.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个点阵，其中`x`和`y`坐标代表图像上像素的位置，而`z`坐标是颜色向量的长度。
- en: The point cloud is represented by a `ci::gl::VboMesh`, which is a mesh of vertices,
    normal, colors, and indexes with an underlying Vertex Buffer Object. It allows
    for optimized drawing of geometry.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 点云由一个`ci::gl::VboMesh`表示，它是一个由顶点、法线、颜色和索引组成的网格，其下是一个顶点缓冲对象。它允许优化几何图形的绘制。
- en: Creating a terrain with Perlin noise
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Perlin噪声创建地形
- en: In this recipe, we will learn how to construct a surface in 3D using **Perlin
    noise** to create organic deformations that resemble a piece of terrain.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用**Perlin噪声**在3D中构建表面，以创建类似于地形的有机构变形。
- en: Getting ready
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Include the necessary files to draw using OpenGL, Perlin noise, a Maya camera
    for navigation, and Cinder''s math utilities. Add the following code to the top
    of the source file:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 包含必要的文件以使用OpenGL绘制、Perlin噪声、Maya相机进行导航和Cinder的数学工具。将以下代码添加到源文件顶部：
- en: '[PRE84]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Also, add the following `using` statements:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 还要添加以下`using`语句：
- en: '[PRE85]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: How to do it…
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We will create a grid of 3D points and use Perlin noise to calculate a smooth
    surface.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个3D点阵，并使用Perlin噪声计算一个平滑的表面。
- en: 'Declare `struct` to store the vertices of the terrain by adding the following
    code before the applications class declaration:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序类声明之前添加以下代码来声明存储地形顶点的`struct`：
- en: '[PRE86]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Add the following members to the applications class declaration:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序类声明中添加以下成员：
- en: '[PRE87]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In the `setup` method, define the number of rows and lines that will make up
    the terrain's grid. Also, define the gap distance between each point.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，定义将构成地形网格的行数和列数。还要定义每个点之间的间隔距离。
- en: '[PRE88]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Add the vertices to `mTerrain` by creating a grid of points laid on the `x`
    and `z` axis. We will use the values generated by `ci::Perlin` to calculate each
    points height. We will also use the height of the points to define their color:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个位于`x`和`z`轴上的点网格，将顶点添加到`mTerrain`中。我们将使用`ci::Perlin`生成的值来计算每个点的海拔高度。我们还将使用点的海拔高度来定义它们的颜色：
- en: '[PRE89]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now let's define our camera so that it points to the center of the terrain.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们定义我们的相机，使其指向地形的中心。
- en: '[PRE90]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Declare the mouse event handlers to use `mCam`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明鼠标事件处理程序以使用`mCam`。
- en: '[PRE91]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Now let's implement the mouse handlers.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们实现鼠标处理程序。
- en: '[PRE92]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In the `draw` method, let's start by clearing the background, setting the matrices
    using `mCam`, and enabling reading and writing of the depth buffer.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法中，让我们首先清除背景，使用`mCam`设置矩阵，并启用深度缓冲区的读写。
- en: '[PRE93]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now enable OpenGL to use the `VERTEX` and `COLOR` arrays:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在启用OpenGL以使用`VERTEX`和`COLOR`数组：
- en: '[PRE94]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We will use a nested `for` loop to iterate over the terrain and draw each strip
    of terrain as `GL_TRIANGLE_STRIP`.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用嵌套的`for`循环遍历地形，并将每个地形条绘制为`GL_TRIANGLE_STRIP`。
- en: '[PRE95]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '![How to do it…](img/8703OS_8_7.jpg)'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/8703OS_8_7.jpg)'
- en: How it works…
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Perlin noise is a coherent random number generator capable of creating organic
    textures and transitions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Perlin噪声是一个连续的随机数生成器，能够创建有机纹理和过渡。
- en: We used the values created by the `ci::Perlin` object to calculate the height
    of the vertices that make up the terrain and create smooth transitions between
    vertices.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ci::Perlin`对象创建的值来计算构成地形的顶点的高度，并在顶点之间创建平滑的过渡。
- en: There's more…
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'We can also animate our terrain by adding an increasing offset to the coordinates
    used to calculate the Perlin noise. Declare the following member variables in
    your class declaration:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过向用于计算Perlin噪声的坐标添加递增偏移来动画化我们的地形。在你的类声明中声明以下成员变量：
- en: '[PRE96]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In the `setup` method, initialize them.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup`方法中初始化它们。
- en: '[PRE97]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In the `update` method animate each offset value by adding `0.01`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法中，通过添加`0.01`来动画化每个偏移值。
- en: '[PRE98]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Also in the `update` method, we will iterate over all the vertices of `mTerrain`.
    For each vertex we will use its `x` and `z` coordinates to calculate the `Y` coordinate
    with `mPerlin noise`, but we will offset the coordinates.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在`update`方法中，我们将遍历`mTerrain`的所有顶点。对于每个顶点，我们将使用其`x`和`z`坐标，通过`mPerlin noise`计算`Y`坐标，但我们将偏移坐标。
- en: '[PRE99]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Saving mesh data
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存网格数据
- en: Provided that you are using a `TriMesh` class to store 3D geometry, we will
    show you how to save it in a file.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在使用`TriMesh`类来存储3D几何形状，我们将向你展示如何将其保存到文件中。
- en: Getting ready
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We are assuming that you are using a 3D model stored in `TriMesh` object. Sample
    application loading 3D geometry can be found in `Cinder samples` directory in
    the folder: `OBJLoaderDemo`.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你正在使用存储在`TriMesh`对象中的3D模型。示例应用程序加载3D几何形状可以在`Cinder samples`目录中的文件夹：`OBJLoaderDemo`中找到。
- en: How to do it…
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will implement saving a 3D mesh data.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现保存3D网格数据。
- en: 'Include necessary headers:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件：
- en: '[PRE100]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Implement your `keyDown` method as follows:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式实现你的`keyDown`方法：
- en: '[PRE101]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: How it works…
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In Cinder we are using a `TriMesh` class to store 3D geometry. Using `TriMesh`
    we can store and manipulate geometry loaded from 3D model files or add each vertices
    with code.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cinder中，我们使用`TriMesh`类来存储3D几何形状。使用`TriMesh`，我们可以存储和操作从3D模型文件加载的几何形状，或者通过代码添加每个顶点。
- en: Every time you hit the *S* key on the keyboard, a saving dialog pops up to ask
    you where to save binary data of the `TriMesh` object. When you press the *O*
    key, the OBJ format file will be saved into your `documents` folder. If you don't
    have to exchange data with other software, binary data saving and loading is usually
    faster.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你按下键盘上的*S*键时，会弹出一个保存对话框，询问你将`TriMesh`对象的二进制数据保存到何处。当你按下*O*键时，OBJ格式文件将被保存到你的`documents`文件夹中。如果你不需要与其他软件交换数据，二进制数据的保存和加载通常更快。
