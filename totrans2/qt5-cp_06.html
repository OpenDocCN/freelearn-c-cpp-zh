<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Chapter 6. Getting Wired and Managing Downloads"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title"><a id="ch06" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Chapter 6. Getting Wired and Managing Downloads</h1></div></div></div><p class="calibre9">Network modules have become crucial nowadays and are also a must-have feature for development frameworks; therefore, Qt does provide APIs for network programming. Sit tight, we're going to get wired and download files from the network. In addition to this, threading is included in this chapter, which is a vital programming skill to avoid blocking. This chapter's topics are listed as follows:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Introducing Qt network programming</li><li class="listitem">Utilizing <code class="literal">QNetworkAccessManager</code></li><li class="listitem">Making use of the progress bar</li><li class="listitem">Writing multithreaded applications</li><li class="listitem">Managing a system network session</li></ul></div><div class="calibre2" title="Introducing Qt network programming"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch06lvl1sec42" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Introducing Qt network programming</h1></div></div></div><p class="calibre9">Qt supports network programming and provides lots of high-level APIs to ease your work. <code class="literal">QNetworkRequest</code>, <code class="literal">QNetworkReply</code>, and <code class="literal">QNetworkAccessManager</code> use common protocols to <a id="id282" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>perform network operations. Qt also offers lower-level classes to represent low level network concepts.</p><p class="calibre9">In this chapter, we're going to<a id="id283" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> utilize the high-level APIs that Qt has offered to write a downloader to retrieve the Internet files and save them to your disk. As I mentioned earlier, the application will need the <code class="literal">QNetworkRequest</code>, <code class="literal">QNetworkReply</code>, and <code class="literal">QNetworkAccessManager</code> classes.</p><p class="calibre9">Firstly, all network requests are represented by the<a id="id284" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">QNetworkRequest</code> class, which is a general container for information associated with a request, including the header and encryption. Currently, HTTP, FTP, and local file URLs are supported for uploading and downloading.</p><p class="calibre9">Once a request has been created, the <a id="id285" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/><code class="literal">QNetworkAccessManager</code> class is used to dispatch it and emits signals, reporting the progress. Then, it creates the reply to a network request, represented by the <code class="literal">QNetworkReply</code> class. At the same time, the signals provided by <code class="literal">QNetworkReply</code> can be used to monitor each reply individually. Some developers will discard the reference to the reply and use the <code class="literal">QNetworkAccessManager</code> class's signals for that purpose, though. All replies can be handled synchronously or <a id="id286" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>asynchronously, because <code class="literal">QNetworkReply</code> is a subclass of <code class="literal">QIODevice</code>, which means that it's possible to implement nonblocking operations.</p><p class="calibre9">Here is a diagram that describes the relationship between these classes:</p><div class="mediaobject"><img src="Images/4615OS_06_01.jpg" alt="Introducing Qt network programming" class="calibre60"/></div><p class="calibre9">Likewise, the network-related stuff is offered in the network module. To use this module, you need to edit the project file and add network to QT. Now, create a new Qt Widget Application project and edit the project file. In our <code class="literal">Downloader_Demo</code> example, the <code class="literal">downloader_demo.pro</code> project file is shown here:</p><div class="calibre2"><pre class="programlisting">QT       += core gui network

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

TARGET = Downloader_Demo
TEMPLATE = app


SOURCES +=  main.cpp\
            mainwindow.cpp \
            downloader.cpp \
            downloaddialog.cpp

HEADERS  += mainwindow.h \
            downloader.h \
            downloaddialog.h

FORMS    += mainwindow.ui \
            downloaddialog.ui</pre></div></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Utilizing QNetworkAccessManager"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch06lvl1sec43" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Utilizing QNetworkAccessManager</h1></div></div></div><p class="calibre9">Now, we're going to discover how to write an application that is able to download files from other locations. By<a id="id287" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> other locations, we mean that you can download files from a local position; it doesn't have to be an Internet address, since the local file URLs are supported by Qt as well.</p><p class="calibre9">First of all, let's create a <code class="literal">Downloader</code> class that will use <code class="literal">QNetworkAccessManager</code> to do the downloading work for us. The <code class="literal">downloader.h</code> header file is pasted shown as follows:</p><div class="calibre2"><pre class="programlisting">#ifndef DOWNLOADER_H
#define DOWNLOADER_H

#include &lt;QObject&gt;
#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkRequest&gt;
#include &lt;QNetworkReply&gt;

class Downloader : public QObject
{
  Q_OBJECT
public:
  explicit Downloader(QObject *parent = 0);

public slots:
  void download(const QUrl &amp;url, const QString &amp;file);

signals:
  void errorString(const QString &amp;);
  void available(bool);
  void running(bool);
  void downloadProgress(qint64, qint64);

private:
  QNetworkAccessManager *naManager;
  QString saveFile;

  void saveToDisk(QNetworkReply *);

private slots:
  void onDownloadFinished(QNetworkReply *);
};

#endif // DOWNLOADER_H</pre></div><p class="calibre9">We expose the download slot to get the URL and the saving target. Accordingly, <code class="literal">saveFile</code> is used to store the saving target. In addition to this, we use an <code class="literal">naManager</code> object of the <code class="literal">QNetworkAccessManager</code> class to manage the downloading process.</p><p class="calibre9">Let's check the definitions of these functions in the <code class="literal">downloader.cpp</code> file. In the following constructor, we<a id="id288" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> connect the <code class="literal">naManager</code> object's <code class="literal">finished</code> signal to the <code class="literal">onDownloadFinished</code> slot. Therefore, when a network connection is finished, a relevant <code class="literal">QNetworkReply</code> reference will be passed via this signal.</p><div class="calibre2"><pre class="programlisting">Downloader::Downloader(QObject *parent) :
  QObject(parent)
{
  naManager = new QNetworkAccessManager(this);
  connect(naManager, &amp;QNetworkAccessManager::finished, this, &amp;Downloader::onDownloadFinished);
}</pre></div><p class="calibre9">Accordingly, in the <code class="literal">onDownloadFinished</code> slot, we have to handle <code class="literal">QNetworkReply</code> with caution. If there is any error, which means that the download has failed, we expose the <code class="literal">errorString()</code> function by the <code class="literal">errorString</code> signal. Otherwise, we call the <code class="literal">saveToDisk</code> function to save the file to the disk. Then, we use <code class="literal">deleteLater()</code> to release the <code class="literal">QNetworkReply</code> object safely. As stated in the Qt documentation, it's not safe to use the <code class="literal">delete</code> statement directly; since it's finished, we emit the available and running signals. Those signals will later be used to change the user interface.</p><div class="calibre2"><pre class="programlisting">void Downloader::onDownloadFinished(QNetworkReply *reply)
{
  if (reply-&gt;error() != QNetworkReply::NoError) {
    emit errorString(reply-&gt;errorString());
  }
  else {
    saveToDisk(reply);
  }
  reply-&gt;deleteLater();
  emit available(true);
  emit running(false);
}</pre></div><p class="calibre9">In the <code class="literal">saveToDisk</code> function, we just implement <code class="literal">QFile</code> to save all the downloaded data to the disk. This is feasible because <code class="literal">QNetworkReply</code> inherits from <code class="literal">QIODevice</code>. Therefore, in addition to the networking APIs, you can treat <code class="literal">QNetworkReply</code> as a normal <code class="literal">QIODevice</code> object. In this case, use the <code class="literal">readAll()</code> function to get all data:</p><div class="calibre2"><pre class="programlisting">void Downloader::saveToDisk(QNetworkReply *reply)
{
  QFile f(saveFile);
  f.open(QIODevice::WriteOnly | QIODevice::Truncate);
  f.write(reply-&gt;readAll());
  f.close();
}</pre></div><p class="calibre9">Finally, let's see inside the <code class="literal">download</code> function that will be used by <code class="literal">MainWindow</code> later. Firstly, we store the saved file to <code class="literal">saveFile</code>. Then, we construct <code class="literal">QNetworkRequest req</code> using the <code class="literal">QUrl</code> object, <code class="literal">url</code>. Next, we send <code class="literal">req</code> to the <code class="literal">naManager</code> object of <code class="literal">QNetworkAccessManager</code>, while saving the reference to the created <code class="literal">QNetworkManager</code> object to <code class="literal">reply</code>. After this, we<a id="id289" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> connect the two <code class="literal">downloadProgress</code> signals together, which is simply exposing the <code class="literal">downloadProgress</code> signal of the reply. At last, we end up emitting two signals, indicating the availability and running status respectively.</p><div class="calibre2"><pre class="programlisting">void Downloader::download(const QUrl &amp;url, const QString &amp;file)
{
  saveFile = file;
  QNetworkRequest req(url);
  QNetworkReply *reply = naManager-&gt;get(req);
  connect(reply, &amp;QNetworkReply::downloadProgress, this, &amp;Downloader::downloadProgress);
  emit available(false);
  emit running(true);
}</pre></div><p class="calibre9">We described the <code class="literal">Downloader</code> class. Now, we're going to add <code class="literal">DownloadDialog</code> by navigating to <span class="strong"><strong class="calibre10">Qt Designer</strong></span> | <span class="strong"><strong class="calibre10">Dialog with Buttons Bottom</strong></span>. This class is used to get the URL and save the path for the user. For the design of <code class="literal">downloaddialog.ui</code>, we use the two <code class="literal">QLineEdit</code> objects to get the URL and saved path respectively. One of the object names is <code class="literal">urlEdit</code>, and the other is <code class="literal">saveAsEdit</code>. In order to open a file dialog for the user to choose the saving location, a <code class="literal">saveAsButton</code> attribute of <code class="literal">QPushButton</code> is added to the right-hand side of <code class="literal">saveAsEdit</code>. The following screenshot shows you the layout of this UI file:</p><div class="mediaobject"><img src="Images/4615OS_06_02.jpg" alt="Utilizing QNetworkAccessManager" class="calibre61"/></div><p class="calibre9">You need to change the layout of this dialog to <span class="strong"><strong class="calibre10">Lay Out in a Grid</strong></span>. In a similar way as we did before, in order to <a id="id290" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>pass the values to the main window, we need to delete the default <code class="literal">accepted</code> signal and slot connection in <span class="strong"><strong class="calibre10">Signals &amp; Slots Editor</strong></span>.</p><p class="calibre9">The contents of this class's <code class="literal">downloaddialog.h</code> header file are shown here:</p><div class="calibre2"><pre class="programlisting">#ifndef DOWNLOADDIALOG_H
#define DOWNLOADDIALOG_H

#include &lt;QDialog&gt;

namespace Ui {
  class DownloadDialog;
}

class DownloadDialog : public QDialog
{
  Q_OBJECT

public:
  explicit DownloadDialog(QWidget *parent = 0);
  ~DownloadDialog();

signals:
  void accepted(const QUrl &amp;, const QString &amp;);

private:
  Ui::DownloadDialog *ui;

private slots:
  void onButtonAccepted();
  void onSaveAsButtonClicked();
};

#endif // DOWNLOADDIALOG_H</pre></div><p class="calibre9">As you can see, a new signal named <code class="literal">accepted</code> is added to pass the URL and save the location. Besides, the two <code class="literal">private</code> slots are used to handle the <code class="literal">accepted</code> event of the button box and the <code class="literal">saveAsButtonClicked</code> signal, respectively.</p><p class="calibre9">The definitions are<a id="id291" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> in the <code class="literal">downloaddialog.cpp</code> source file, which is shown here:</p><div class="calibre2"><pre class="programlisting">#include &lt;QFileDialog&gt;
#include "downloaddialog.h"
#include "ui_downloaddialog.h"

DownloadDialog::DownloadDialog(QWidget *parent) :
  QDialog(parent),
  ui(new Ui::DownloadDialog)
{
  ui-&gt;setupUi(this);

  connect(ui-&gt;buttonBox, &amp;QDialogButtonBox::accepted, this, &amp;DownloadDialog::onButtonAccepted);
  connect(ui-&gt;saveAsButton, &amp;QPushButton::clicked, this, &amp;DownloadDialog::onSaveAsButtonClicked);
}

DownloadDialog::~DownloadDialog()
{
  delete ui;
}

void DownloadDialog::onButtonAccepted()
{
  emit accepted(QUrl(ui-&gt;urlEdit-&gt;text()), ui-&gt;saveAsEdit-&gt;text());
  this-&gt;accept();
}

void DownloadDialog::onSaveAsButtonClicked()
{
  QString str = QFileDialog::getSaveFileName(this, "Save As");
  if (!str.isEmpty()) {
    ui-&gt;saveAsEdit-&gt;setText(str);
  }
}</pre></div><p class="calibre9">In the constructor of <code class="literal">DownloadDialog</code>, just connect the signals and slots. In the <code class="literal">onButtonAccepted</code> slot, we emit the <code class="literal">accepted</code> signal, which is to pass the URL and the saving path, where a temporary <code class="literal">QUrl</code> class is constructed using the text of <code class="literal">urlEdit</code>. Then, the <code class="literal">accept</code> function is invoked to close the dialog. Meanwhile, in the <code class="literal">onSaveAsButtonClicked</code> slot function, we use the <code class="literal">static</code> function provided by the <code class="literal">QFileDialog</code> class<a id="id292" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> to obtain the saving location. Do nothing if the <code class="literal">QString</code> return is empty; this means that the user may have clicked on <span class="strong"><strong class="calibre10">Cancel</strong></span> in the file dialog.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Making use of the progress bar"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch06lvl1sec44" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Making use of the progress bar</h1></div></div></div><p class="calibre9">An intuitive way to indicate the downloading progress is by using a progress bar. In Qt, it is the <code class="literal">QProgressBar</code> class<a id="id293" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> that provides a <a id="id294" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>horizontal or vertical progress bar widget. It uses <code class="literal">minimum</code>, <code class="literal">value</code>, and <code class="literal">maximum</code> to determine the completed percentage. The percentage is calculated by the formula, <code class="literal">(value – minimum) / (maximum – minimum)</code>. We'll use this useful widget in our example application by performing the following steps:</p><div class="calibre2"><ol class="orderedlist"><li class="listitem1">Go back to the <code class="literal">MainWindow</code> class.</li><li class="listitem1">Edit the <code class="literal">mainwindow.ui</code> file in the <span class="strong"><strong class="calibre10">Design</strong></span> mode.</li><li class="listitem1">Drag <span class="strong"><strong class="calibre10">Push Button</strong></span> and rename it as <code class="literal">newDownloadButton</code> with <code class="literal">New Download</code> as its text.</li><li class="listitem1">Drag <span class="strong"><strong class="calibre10">Progress Bar</strong></span> just beneath <code class="literal">newDownloadButton</code>.</li><li class="listitem1">Change the layout to <span class="strong"><strong class="calibre10">Lay Out Vertically</strong></span>.</li><li class="listitem1">Uncheck <code class="literal">textVisible</code> in the <code class="literal">progressBar</code> widget's property.</li></ol></div><p class="calibre9">The push button, <code class="literal">newDownloadButton</code>, is used to popup <code class="literal">DownloadDialog</code> to get a new download task. We need to apply some modifications to <code class="literal">mainwindow.h</code>, as suggested here:</p><div class="calibre2"><pre class="programlisting">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;
<span class="strong"><strong class="calibre10">#include "downloader.h"</strong></span>
<span class="strong"><strong class="calibre10">#include "downloaddialog.h"</strong></span>

namespace Ui {
  class MainWindow;
}

class MainWindow : public QMainWindow
{
  Q_OBJECT

public:
  explicit MainWindow(QWidget *parent = 0);
  ~MainWindow();

private:
  Ui::MainWindow *ui;
<span class="strong"><strong class="calibre10">  Downloader *downloader;</strong></span>
<span class="strong"><strong class="calibre10">  DownloadDialog *ddlg;</strong></span>

private slots:
  void onNewDownloadButtonPressed();
  void showMessage(const QString &amp;);
  void onDownloadProgress(qint64, qint64);
};

#endif // MAINWINDOW_H</pre></div><p class="calibre9">In order to use the <code class="literal">Downloader</code> and <code class="literal">DownloadDialog</code> classes, we have to include them in the <code class="literal">header</code> file. Then, we can<a id="id295" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> include them as the <code class="literal">private</code> pointers. For the <code class="literal">private</code> slots, <code class="literal">onNewDownloadButtonPressed</code> is used to handle the <code class="literal">newDownloadButton</code> clicked signal. While <code class="literal">showMessage</code> is a slot function that displays the message on status bar, the last one, <code class="literal">onDownloadProgress</code>, is used to update the progress bar.</p><p class="calibre9">Similarly, for the <code class="literal">mainwindow.cpp</code> source file, we connect the signals and slots in the constructor, shown as follows:</p><div class="calibre2"><pre class="programlisting">MainWindow::MainWindow(QWidget *parent) :
  QMainWindow(parent),
  ui(new Ui::MainWindow)
{
  ui-&gt;setupUi(this);
  ui-&gt;progressBar-&gt;setVisible(false);

  downloader = new Downloader(this);

  connect(ui-&gt;newDownloadButton, &amp;QPushButton::clicked, this, &amp;MainWindow::onNewDownloadButtonPressed);
  connect(downloader, &amp;Downloader::errorString, this, &amp;MainWindow::showMessage);
  connect(downloader, &amp;Downloader::downloadProgress, this, &amp;MainWindow::onDownloadProgress);
  connect(downloader, &amp;Downloader::available, ui-&gt;newDownloadButton, &amp;QPushButton::setEnabled);
  connect(downloader, &amp;Downloader::running, ui-&gt;progressBar, &amp;QProgressBar::setVisible);
}</pre></div><p class="calibre9">Before beginning to create these connections, we need to hide the progress bar and create a new <code class="literal">Downloader</code> class, using <code class="literal">MainWindow</code> as the <code class="literal">QObject</code> parent. Meanwhile, in these connections, the first one is to connect the <code class="literal">newDownloadButton</code> clicked signal. Then, we connect the <code class="literal">errorString</code> signal of downloader to <code class="literal">showMessage</code>, which enables the status bar to show the error message<a id="id296" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> directly. Next, we connect the <code class="literal">downloadProgress</code> signal to our <code class="literal">onDownloadProgress</code> handler. As for the available and running signals, they're connected to control the availability and visibility of <code class="literal">newDownloadButton</code> and <code class="literal">progressBar</code>, respectively.</p><p class="calibre9">Inside the <code class="literal">onNewDownloadButtonPressed</code> slot function, we construct a <code class="literal">DownloadDialog</code> object, <code class="literal">ddlg</code>, then connect the accepted signal of <code class="literal">DownloadDialog</code> to the <code class="literal">Downloader</code> class's download slot. Then, use <code class="literal">exec</code> to run the dialog and block the event loop. After this, we call <code class="literal">deleteLater</code> to safely release the resource allocated for <code class="literal">ddlg</code>.</p><div class="calibre2"><pre class="programlisting">void MainWindow::onNewDownloadButtonPressed()
{
  ddlg = new DownloadDialog(this);
  connect(ddlg, &amp;DownloadDialog::accepted, downloader, &amp;Downloader::download);
  ddlg-&gt;exec();
  ddlg-&gt;deleteLater();
}</pre></div><p class="calibre9">As for the <code class="literal">showMessage</code> slot function, it simply calls the <code class="literal">showMessage</code> function of <code class="literal">statusBar</code> with a three second timeout, as shown here:</p><div class="calibre2"><pre class="programlisting">void MainWindow::showMessage(const QString &amp;es)
{
  ui-&gt;statusBar-&gt;showMessage(es, 3000);
}</pre></div><p class="calibre9">At last, we can update the progress bar via the <code class="literal">onDownloadProgress</code> function, which is shown in the following code. Since the <code class="literal">minimum</code> value is <code class="literal">0</code> by default, we don't need to change it. Instead, we change the <code class="literal">maximum</code> value to the total bytes of the download, and <code class="literal">value</code> to the current downloaded bytes. Note that if the total size is unknown, then the value of the total size is <code class="literal">-1</code>, which will happen to make the progress bar display in a busy style.</p><div class="calibre2"><pre class="programlisting">void MainWindow::onDownloadProgress(qint64 r, qint64 t)
{
  ui-&gt;progressBar-&gt;setMaximum(t);
  ui-&gt;progressBar-&gt;setValue(r);
}</pre></div><p class="calibre9">Now, give the application a run and click on the <span class="strong"><strong class="calibre10">New Download</strong></span> button. The <span class="strong"><strong class="calibre10">Add New Download</strong></span> dialog will pop up, where you can add a new download task as shown here:</p><div class="mediaobject"><img src="Images/4615OS_06_03.jpg" alt="Making use of the progress bar" class="calibre62"/></div><p class="calibre9">Click on <span class="strong"><strong class="calibre10">OK</strong></span>, if there is no<a id="id297" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> error; a progress bar is expected to show up and display the current download progress, shown as follows:</p><div class="mediaobject"><img src="Images/4615OS_06_04.jpg" alt="Making use of the progress bar" class="calibre63"/></div><p class="calibre9">As you can see, the <span class="strong"><strong class="calibre10">New Download</strong></span> button is not enabled now, since it is associated with the available signal of <code class="literal">downloader</code>. Besides, the progress bar won't even show if <code class="literal">downloader</code> isn't running.</p><p class="calibre9">While this downloader demo still lacks a basic function, which is to cancel downloading, it is, in fact, easy to implement. There is a slot function called <code class="literal">abort</code> in the <code class="literal">QNetworkReply</code> class. You may have to store the reference to <code class="literal">QNetworkReply</code> and then call abort if some button in <code class="literal">MainWindow</code> is clicked. This won't be demonstrated here. It has been left up to you to practice on your own.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Writing multithreaded applications"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch06lvl1sec45" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Writing multithreaded applications</h1></div></div></div><p class="calibre9">I bet multithread or threading isn't unfamiliar to you. Using other threads saves the GUI application from freezing. If the <a id="id298" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>application runs on a single thread, it'll get stuck if there it's a synchronous time-consuming operation. Multiple threads make application running much smoother. Although most of the Qt Network APIs are nonblocking, it is not that difficult to practice on it.</p><p class="calibre9">Qt provides a<a id="id299" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">QThread</code> class to implement threading on all supported platforms. In other words, we don't need to write platform-specific code utilizing POSIX Threads or a Win32 API. Instead, <code class="literal">QThread</code> provides a platform-independent way to manage threads. A <code class="literal">QThread</code> object manages a thread within the program, which begins executing in <code class="literal">run()</code> and ends when calling <code class="literal">quit()</code> or <code class="literal">exit()</code>.</p><p class="calibre9">For some historical reason, it's still possible to subclass <code class="literal">QThread</code> and put the blocking or time-consuming code in the reimplemented <code class="literal">run()</code> function. However, it's considered an incorrect practice and is not recommended to do so. The right way is to use <code class="literal">QObject::moveToThread</code>, which will be demonstrated later.</p><p class="calibre9">We're going to put the <code class="literal">Downloader::download</code> function into a new thread. In fact, it's the <code class="literal">QNetworkAccessManager::get</code> function that will be moved onto another thread. Let's create a new C++ class, <code class="literal">DownloadWorker</code>, whose <code class="literal">downloadworker.h</code> header file is pasted as follows:</p><div class="calibre2"><pre class="programlisting">#ifndef DOWNLOADWORKER_H
#define DOWNLOADWORKER_H

#include &lt;QObject&gt;
#include &lt;QNetworkReply&gt;
#include &lt;QNetworkRequest&gt;
#include &lt;QNetworkAccessManager&gt;

class DownloadWorker : public QObject
{
  Q_OBJECT

public slots:
  void doDownload(const QUrl &amp;url, QNetworkAccessManager *nm);

signals:
  void downloadProgress(qint64, qint64);
};

#endif // DOWNLOADWORKER_H</pre></div><p class="calibre9">The constructor is removed from the code because we can't make a child object that will be in another thread. This is almost the only limitation of <code class="literal">QThread</code>. In contrast to this, you can connect signals and slots between different threads without any problems.</p><p class="calibre9">Don't split parent and children between threads. Parent objects and children objects can only be in the same thread.</p><p class="calibre9">We declare the <code class="literal">doDownload</code> slot function to do the <code class="literal">QNetworkAccessManager::get</code> function work for us. On the<a id="id300" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> other hand, the <code class="literal">downloadProgress</code> signal is used to expose the <code class="literal">downloadProgress</code> signal of <code class="literal">QNetworkReply</code> as we did. The contents of <code class="literal">downloadworker.cpp</code> is shown as follows:</p><div class="calibre2"><pre class="programlisting">#include "downloadworker.h"

void DownloadWorker::doDownload(const QUrl &amp;url, QNetworkAccessManager *nm)
{
  QNetworkRequest req(url);
  QNetworkReply *reply = nm-&gt;get(req);
  connect(reply, &amp;QNetworkReply::downloadProgress, this, &amp;DownloadWorker::downloadProgress);
}</pre></div><p class="calibre9">The preceding code is an example of a simple <code class="literal">worker</code> class. Now, we have to change the <code class="literal">Downloader</code> class to use the <code class="literal">DownloadWorker</code> class. The <code class="literal">header</code> file of the <code class="literal">Downloader</code> class, <code class="literal">downloader.h</code>, needs a few modifications, shown here:</p><div class="calibre2"><pre class="programlisting">#ifndef DOWNLOADER_H
#define DOWNLOADER_H

#include &lt;QObject&gt;
#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkRequest&gt;
#include &lt;QNetworkReply&gt;
#include &lt;QThread&gt;
#include "downloadworker.h"

class Downloader : public QObject
{
  Q_OBJECT
public:
  explicit Downloader(QObject *parent = 0);
  ~Downloader();

public slots:
  void download(const QUrl &amp;url, const QString &amp;file);

signals:
  void errorString(const QString &amp;);
  void available(bool);
  void running(bool);
  void downloadProgress(qint64, qint64);

private:
  QString saveFile;
  QNetworkAccessManager *naManager;
  DownloadWorker *worker;
  QThread workerThread;

  void saveToDisk(QNetworkReply *);

private slots:
  void onDownloadFinished(QNetworkReply *);
};

#endif // DOWNLOADER_H</pre></div><p class="calibre9">As you can see, we <a id="id301" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>have declared a new <code class="literal">private</code> member, <code class="literal">workerThread</code>, which is a type of <code class="literal">QThread</code>. Also, a <code class="literal">DownloadWorker</code> object worker has been declared as well. There are more changes in the <code class="literal">downloader.cpp</code> source file, as displayed here:</p><div class="calibre2"><pre class="programlisting">#include &lt;QFile&gt;
#include "downloader.h"

Downloader::Downloader(QObject *parent) :
  QObject(parent)
{
  naManager = new QNetworkAccessManager(this);
  worker = new DownloadWorker;
  worker-&gt;moveToThread(&amp;workerThread);

  connect(naManager, &amp;QNetworkAccessManager::finished, this, &amp;Downloader::onDownloadFinished);
  connect(&amp;workerThread, &amp;QThread::finished, worker, &amp;DownloadWorker::deleteLater);
  connect(worker, &amp;DownloadWorker::downloadProgress, this, &amp;Downloader::downloadProgress);

  workerThread.start();
}

Downloader::~Downloader()
{
  workerThread.quit();
  workerThread.wait();
}

void Downloader::download(const QUrl &amp;url, const QString &amp;file)
{
  saveFile = file;
  worker-&gt;doDownload(url, naManager);
  emit available(false);
  emit running(true);
}

void Downloader::onDownloadFinished(QNetworkReply *reply)
{
  if (reply-&gt;error() != QNetworkReply::NoError) {
    emit errorString(reply-&gt;errorString());
  }
  else {
    saveToDisk(reply);
  }
  reply-&gt;deleteLater();
  emit available(true);
  emit running(false);
}

void Downloader::saveToDisk(QNetworkReply *reply)
{
  QFile f(saveFile);
  f.open(QIODevice::WriteOnly | QIODevice::Truncate);
  f.write(reply-&gt;readAll());
  f.close();
}</pre></div><p class="calibre9">In the constructor, we will create a new <code class="literal">DownloadWorker</code> class, and move it to another thread, <code class="literal">workerThread</code>. By connecting the <code class="literal">finished</code> signal of <code class="literal">workerThread</code> to the <code class="literal">deleteLater</code> function of <code class="literal">worker</code>, the<a id="id302" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> resources of <code class="literal">worker</code> can be deleted safely after the exit of <code class="literal">workerThread</code>. Then, we need to expose <code class="literal">downloadProgress</code> again, since it's moved into <code class="literal">worker</code>. At last, we call the <code class="literal">start()</code> function, to start <code class="literal">workerThread</code>.</p><p class="calibre9">As a reverse operation, we call the <code class="literal">quit()</code> function to exit <code class="literal">workerThread</code> and then use <code class="literal">wait()</code> to ensure it quits successfully.</p><p class="calibre9">Since a lot of code has been moved into the <code class="literal">doDownload</code> function of <code class="literal">worker</code>, we only need to call <code class="literal">doDownload</code> of <code class="literal">worker</code> here. In fact, the function calling is inter-thread, which means that the main thread won't be blocked by that statement.</p><p class="calibre9">Since <code class="literal">get</code> is not blocking, you may not feel the difference. However, I'm sure you have some applications that have frozen, which therefore need to be modified to adapt to <code class="literal">QThread</code>. Always remember to put only the background blocking operations in another thread. This is mainly because<a id="id303" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> these operations are easily separated from GUI into single objects without parents or children. Due to this limitation, almost all the GUI objects must be in the same thread, which is the main thread in most cases.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Managing a system network session"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch06lvl1sec46" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Managing a system network session</h1></div></div></div><p class="calibre9">In addition to networking<a id="id304" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> applications, Qt also provides you with cross-platform APIs to control network interfaces and access points. Although it's not very common to control the network state, there are some certain situations where it's required to do this.</p><p class="calibre9">First, I'd like to introduce<a id="id305" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">QNetworkConfigurationManager</code> to you. This class manages the network configurations provided by the system. It enables you access to them, as well as to detect the system's capabilities during runtime. The network configuration is presented by the <code class="literal">QNetworkConfiguration</code> <a id="id306" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>class, which abstracts a set of configuration options concerning how a network interface has to be configured in order to connect to the target network. To control the network session, you need to use the <code class="literal">QNetworkSession</code> <a id="id307" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>class. This class provides you with control over the system's access points and enables session management. It also enables you to control network interfaces that are represented by the <code class="literal">QNetworkInterface</code> class. To help you figure out this relationship, a diagram is shown here:</p><div class="mediaobject"><img src="Images/4615OS_06_05.jpg" alt="Managing a system network session" class="calibre64"/></div><p class="calibre9">As you can see, the structure is similar to <code class="literal">QNetworkAccessManager</code>, <code class="literal">QNetworkReply</code>, and <code class="literal">QNetworkRequest</code>. Especially, there is another manager class. Let's see how to deal with these classes in practice.</p><p class="calibre9">Create a new Qt Widgets<a id="id308" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> Application project as usual. The example regarding this topic is called <code class="literal">NetworkManager_Demo</code>. Remember to add network to Qt in your project file, as we did in the previous example. Then, edit <code class="literal">mainwindow.ui</code> in the <span class="strong"><strong class="calibre10">Design</strong></span> mode and perform the following steps:</p><div class="calibre2"><ol class="orderedlist"><li class="listitem1">Remove the status bar, menu bar, and tool bar since we don't need them in this application.</li><li class="listitem1">Add <span class="strong"><strong class="calibre10">List View</strong></span> (under the <span class="strong"><strong class="calibre10">Item Views (Model-Based)</strong></span> category).</li><li class="listitem1">Drag <span class="strong"><strong class="calibre10">Vertical Layout</strong></span> to the right of <code class="literal">listView</code>.</li><li class="listitem1">Change <span class="strong"><strong class="calibre10">Lay out</strong></span> in <span class="strong"><strong class="calibre10">MainWindow</strong></span> to <span class="strong"><strong class="calibre10">Lay Out Horizontally</strong></span>.</li><li class="listitem1">Drag <span class="strong"><strong class="calibre10">Label</strong></span> into <code class="literal">verticalLayout</code> and rename it as <code class="literal">onlineStatus</code>.</li><li class="listitem1">Drag <span class="strong"><strong class="calibre10">Progress Bar</strong></span> into <code class="literal">verticalLayout</code>. Change its <code class="literal">maximum</code> value to <code class="literal">0</code> and uncheck <code class="literal">textVisible</code> so that it can be used as a busy indicator.</li><li class="listitem1">Add three <span class="strong"><strong class="calibre10">Push Button</strong></span> buttons; <span class="strong"><strong class="calibre10">Refresh</strong></span>, <span class="strong"><strong class="calibre10">Connect</strong></span>, and <span class="strong"><strong class="calibre10">Disconnect</strong></span>; beneath the progress bar. Their object names are <code class="literal">refreshButton</code>, <code class="literal">connectButton</code>, and <code class="literal">disconnectButton</code>, respectively.</li><li class="listitem1">At last, drag <span class="strong"><strong class="calibre10">Vertical Spacer</strong></span> between <code class="literal">progressBar</code> and <code class="literal">onlineStatus</code> to separate them.</li></ol></div><p class="calibre9">As usual, we need to do some declarations in <code class="literal">mainwindow.h</code> header file as shown here:</p><div class="calibre2"><pre class="programlisting">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;
#include &lt;QNetworkConfigurationManager&gt;
#include &lt;QNetworkConfiguration&gt;
#include &lt;QNetworkSession&gt;
#include &lt;QStandardItemModel&gt;

namespace Ui {
  class MainWindow;
}

class MainWindow : public QMainWindow
{
  Q_OBJECT

public:
  explicit MainWindow(QWidget *parent = 0);
  ~MainWindow();

private:
  Ui::MainWindow *ui;
  QNetworkConfigurationManager *networkConfManager;
  QStandardItemModel *confListModel;

private slots:
  void onOnlineStateChanged(bool isOnline);
  void onConfigurationChanged(const QNetworkConfiguration &amp;config);
  void onRefreshClicked();
  void onRefreshCompleted();
  void onConnectClicked();
  void onDisconnectClicked();
};

#endif // MAINWINDOW_H</pre></div><p class="calibre9">In this case, we only utilize<a id="id309" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the <code class="literal">QNetworkConfigurationManager</code>, <code class="literal">QNetworkConfiguration</code>, and <code class="literal">QNetworkSession</code> classes to manage the system network sessions. Therefore, we need to include them in an appropriate location.</p><div class="sidebar" title="Note"><div class="inner"><h3 class="title4"><a id="note20" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">Note that we only need to declare a <code class="literal">private</code> member, in this case <code class="literal">networkConfManager</code>, of the <code class="literal">QNetworkConfigurationManager</code> class, because the <code class="literal">QNetworkConfiguration</code> can be retrieved from this manager, while <code class="literal">QNetworkSession</code> is bound to <code class="literal">QNetworkConfiguration</code>.</p></div></div><p class="calibre9">As for <code class="literal">QStandardItemModel</code>, remember the model/view stuff in <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch03.xhtml" title="Chapter 3. Cooking an RSS Reader with Qt Quick">Chapter 3</a>, <span class="strong"><em class="calibre14">Cooking an RSS Reader with Qt Quick</em></span>. The only difference between that chapter and this one is that we wrote QML in the former. However, we are using a C++ application in this chapter. They share the same concept, though, and it's just the tool that changes. <code class="literal">QStandardItemModel *confListModel</code> is the exact model of <code class="literal">listView</code> in the UI file.</p><p class="calibre9">Last, but not least, is the declaration of some slots. Apart from the button click handlers, the first two are <a id="id310" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>used to monitor the network system. This is explained later.</p><p class="calibre9">Let's edit the <code class="literal">mainwindow.cpp</code> file and take a look at the constructor of <code class="literal">MainWindow</code>:</p><div class="calibre2"><pre class="programlisting">MainWindow::MainWindow(QWidget *parent) :
  QMainWindow(parent),
  ui(new Ui::MainWindow)
{
  ui-&gt;setupUi(this);

  networkConfManager = new QNetworkConfigurationManager(this);
  confListModel = new QStandardItemModel(0, 1, this);

  ui-&gt;listView-&gt;setModel(confListModel);
  ui-&gt;progressBar-&gt;setVisible(false);

  connect(networkConfManager, &amp;QNetworkConfigurationManager::onlineStateChanged, this, &amp;MainWindow::onOnlineStateChanged);
  connect(networkConfManager, &amp;QNetworkConfigurationManager::configurationChanged, this, &amp;MainWindow::onConfigurationChanged);
  connect(networkConfManager, &amp;QNetworkConfigurationManager::updateCompleted, this, &amp;MainWindow::onRefreshCompleted);

  connect(ui-&gt;refreshButton, &amp;QPushButton::clicked, this, &amp;MainWindow::onRefreshClicked);
  connect(ui-&gt;connectButton, &amp;QPushButton::clicked, this, &amp;MainWindow::onConnectClicked);
  connect(ui-&gt;disconnectButton, &amp;QPushButton::clicked, this, &amp;MainWindow::onDisconnectClicked);

  onOnlineStateChanged(networkConfManager-&gt;isOnline());
  onRefreshClicked();
}</pre></div><p class="calibre9">We construct <code class="literal">QNetworkConfigurationManager</code> with this object, also known as <code class="literal">MainWindow</code> as its <code class="literal">QObject</code> parent. Then, we look at the construction of <code class="literal">confListModel</code>. The arguments are the count of row, the count of column, and the <code class="literal">QObject</code> parent, which is this as usual. We will use only one column because we use <span class="strong"><strong class="calibre10">List View</strong></span> to display the data. If you use <span class="strong"><strong class="calibre10">Table View</strong></span>, you will probably use more columns. Then, we bind this model to <code class="literal">listView</code> of <code class="literal">ui</code>. After this, we hide <code class="literal">progressBar</code> because it's a <code class="literal">busy</code> indicator, which only shows up when there is work running. There will be several <code class="literal">connect</code> statements before we call two member functions explicitly. Among them, you may want to look into<a id="id311" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the signals of <code class="literal">QNetworkConfigurationManager</code>. The <code class="literal">onlineStateChanged</code> signal is emitted if the <code class="literal">online</code> status of the system is changed, that is, <code class="literal">offline</code> from <code class="literal">online</code>. The <code class="literal">configurationChanged</code> signal is emitted whenever the state of <code class="literal">QNetworkConfiguration</code> is changed. Once <code class="literal">QNetworkConfigurationManager</code> finished <code class="literal">updateConfigurations</code>, the <code class="literal">updateCompleted</code> signal will be emitted. In the end of the constructor, we call <code class="literal">onOnlineStateChanged</code> directly in order to set up the text of <code class="literal">onlineStatus</code>. Similarly, calling <code class="literal">onRefreshClicked</code> enables an application to scan for all the network configurations at the start.</p><p class="calibre9">As mentioned before, the<a id="id312" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">onOnlineStateChanged</code> function is used to set up <code class="literal">onlineStatus</code>. It'll display <code class="literal">Online</code> if the system is considered to be connected to another device via an active network interface; otherwise, it'll display <code class="literal">Offline</code>. This function's definition is shown as follows:</p><div class="calibre2"><pre class="programlisting">void MainWindow::onOnlineStateChanged(bool isOnline)
{
  ui-&gt;onlineStatus-&gt;setText(isOnline ? "Online" : "Offline");
}</pre></div><p class="calibre9">Inside the <code class="literal">onConfigurationChanged</code> slot function, which is shown in the following code, we change the item's background color to indicate whether a configuration is active or not. We use the <code class="literal">findItems</code> function to get <code class="literal">itemList</code>, which contains only some <code class="literal">QStandardItem</code> that matches <code class="literal">config.name()</code> exactly. However, the configuration name may not be unique. This is why we use a <code class="literal">foreach</code> loop to compare the identifier of <code class="literal">config</code>, which is a unique string, where the <code class="literal">data</code> function is used to retrieve the specific data whose type is <code class="literal">QVariant</code>. Then, we use <code class="literal">toString</code> to cast it back to <code class="literal">QString</code>. <code class="literal">QStandardItem</code> enables us set multiple data into one item.</p><div class="calibre2"><pre class="programlisting">void MainWindow::onConfigurationChanged(const QNetworkConfiguration &amp;config)
{
  QList&lt;QStandardItem *&gt; itemList = confListModel-&gt;findItems(config.name());
  foreach (QStandardItem *i, itemList) {
    if (i-&gt;data(Qt::UserRole).toString().compare(config.identifier()) == 0) {
      if (config.state().testFlag(QNetworkConfiguration::Active)) {
        i-&gt;setBackground(QBrush(Qt::green));
      }
      else {
        i-&gt;setBackground(QBrush(Qt::NoBrush));
      }
    }
  }
}</pre></div><p class="calibre9">This means that we store <code class="literal">identifier</code> as a <code class="literal">Qt::UserRole</code> data. It won't be displayed on the screen; instead, it serves as a specific data carrier, which turns out to be very helpful in this case. Thus, after this, if it's active, we set the background color to green; otherwise, use no brush, which means a default background. Note that the <code class="literal">state</code> function of <code class="literal">QNetworkConfiguration</code> returns <code class="literal">StateFlags</code>, which is actually a <code class="literal">QFlag</code> template class, where the best practice<a id="id313" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> is to check whether or not a flag is set is to use the <code class="literal">testFlag</code> function.</p><p class="calibre9">Let's check the <code class="literal">onRefreshClicked</code> function, which is shown in the following code before <code class="literal">onRefreshCompleted</code>. It'll call <code class="literal">updateConfigurations</code> of the <code class="literal">QNetworkConfigurationManager *networkConfManager</code>. This function is a time consuming one, especially if it needs to scan WLAN. Therefore, we show <code class="literal">progressBar</code> to tell users to be patient and disable <code class="literal">refreshButton</code>, since it's refreshing.</p><div class="calibre2"><pre class="programlisting">void MainWindow::onRefreshClicked()
{
  ui-&gt;progressBar-&gt;setVisible(true);
  ui-&gt;refreshButton-&gt;setEnabled(false);
  networkConfManager-&gt;updateConfigurations();
}</pre></div><p class="calibre9">When the update has been completed, the <code class="literal">updateCompleted</code> signal is emitted and the <code class="literal">onRefreshCompleted</code> bound slot is executed. Check the following function shown here, where we need to purge the list. However, instead of calling the <code class="literal">clear</code> function, we use <code class="literal">removeRows</code>, which would spare the column. If you're calling <code class="literal">clear</code>, beware to add the column back; otherwise, there is literally no column, which means that there is no place to put the item. In the <code class="literal">foreach</code> loop, we add all the configurations that <code class="literal">networkConfManager</code> has found to <code class="literal">confListModel</code>. As I mentioned previously, we use the name as displaying <code class="literal">text</code>, while we set its identifier as a hidden user role data. After the loop, hide <code class="literal">progressBar</code> as the refreshing is finished, and then enable <code class="literal">refreshButton</code>.</p><div class="calibre2"><pre class="programlisting">void MainWindow::onRefreshCompleted()
{
  confListModel-&gt;removeRows(0, confListModel-&gt;rowCount());
  foreach(QNetworkConfiguration c, networkConfManager-&gt;allConfigurations()) {
    QStandardItem *item = new QStandardItem(c.name());
    item-&gt;setData(QVariant(c.identifier()), Qt::UserRole);
    if (c.state().testFlag(QNetworkConfiguration::Active)) {
      item-&gt;setBackground(QBrush(Qt::green));
    }
    confListModel-&gt;appendRow(item);
  }
  ui-&gt;progressBar-&gt;setVisible(false);
  ui-&gt;refreshButton-&gt;setEnabled(true);
}</pre></div><p class="calibre9">The remaining two are handlers to the <code class="literal">connect</code> and <code class="literal">disconnect</code> buttons. For <code class="literal">connectButton</code>, we show <code class="literal">progressBar</code> because it may take a long time to get the IP address from the router. Then, we get <code class="literal">identifier</code> from the data of <code class="literal">confListModel</code> directly and save it as <code class="literal">QString ident</code>, where the <code class="literal">currentIndex</code> function of <code class="literal">listView</code> will return the current <code class="literal">QModelIndex</code> of the view. By using this index, we can get the currently selected data from the model. Then, we construct <code class="literal">QNetworkConfiguration</code> from <code class="literal">ident</code> by calling <code class="literal">configurationFromIdentifier</code> of <code class="literal">networkConfManager</code>. The <code class="literal">QNetworkSession</code> session is constructed using <code class="literal">QNetworkConfiguration</code>. At last, open this network session<a id="id314" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> and wait for 1,000 milliseconds. Then, call <code class="literal">deleteLater</code> to safely release the session. Also, hide <code class="literal">progressBar</code> after all these works in the end.</p><div class="calibre2"><pre class="programlisting">void MainWindow::onConnectClicked()
{
  ui-&gt;progressBar-&gt;setVisible(true);
  QString ident = confListModel-&gt;data(ui-&gt;listView-&gt;currentIndex(), Qt::UserRole).toString();
  QNetworkConfiguration conf = networkConfManager-&gt;configurationFromIdentifier(ident);
  QNetworkSession *session = new QNetworkSession(conf, this);
  session-&gt;open();
  session-&gt;waitForOpened(1000);
  session-&gt;deleteLater();
  ui-&gt;progressBar-&gt;setVisible(false);
}

void MainWindow::onDisconnectClicked()
{
  QString ident = confListModel-&gt;data(ui-&gt;listView-&gt;currentIndex(), Qt::UserRole).toString();
  QNetworkConfiguration conf = networkConfManager-&gt;configurationFromIdentifier(ident);
  QNetworkSession *session = new QNetworkSession(conf, this);
  if (networkConfManager-&gt;capabilities().testFlag(QNetworkConfigurationManager::SystemSessionSupport)) {
    session-&gt;close();
  }
  else {
    session-&gt;stop();
  }
  session-&gt;deleteLater();
}</pre></div><p class="calibre9">As for <code class="literal">disconnectButton</code>, the <code class="literal">onDisconnectClicked</code> handler will do the reverse, which is to stop the network session. The first three lines are identical to those in <code class="literal">onConnectClicked</code>. However, we<a id="id315" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> then need to test whether the platform supports out-of-process sessions. As stated in the Qt documentation, the result of calling <code class="literal">close</code> will be as follows:</p><div class="calibre2"><blockquote class="blockquote"><p class="calibre17"><span class="strong"><em class="calibre14">void QNetworkSession::close() [slot]</em></span></p><p class="calibre17"><span class="strong"><em class="calibre14">Decreases the session counter on the associated network configuration. If the session counter reaches zero the active network interface is shut down. This also means that state() will only change from Connected to Disconnected if the current session was the last open session.</em></span></p></blockquote></div><p class="calibre9">However, if the platform doesn't support out-of-process sessions, the <code class="literal">close</code> function won't stop the interface, in which case we need to use stop instead.</p><p class="calibre9">Therefore, we call the <code class="literal">capabilities</code> function of <code class="literal">networkConfManager</code> to check whether it has <code class="literal">SystemSessionSupport</code>. Call <code class="literal">close</code> if it does, otherwise call <code class="literal">stop</code>. Then, we just call <code class="literal">deleteLater</code> to safely release the session.</p><p class="calibre9">Now, run this application, and you'll expect it works as the following screenshot:</p><div class="mediaobject"><img src="Images/4615OS_06_06.jpg" alt="Managing a system network session" class="calibre18"/></div><p class="calibre9">On Windows, the network architecture is different from that of the world of Unix. So, you may find some odd configurations in the list, such as <span class="strong"><strong class="calibre10">Teredo Tunneling Pseudo-Interface</strong></span> in the screenshot. Don't worry about these configurations and just ignore them! Also, there is no Qt API to allow<a id="id316" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> you to connect to a newly discovered encrypted Wi-Fi access point. This is because there is no implementation in place to access the WLAN system passwords. In other words, it can only be used to control the network sessions that are already known to the system.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Summary"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title2"><a id="ch06lvl1sec47" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Summary</h1></div></div></div><p class="calibre9">In this chapter, you have had a chance to practice what you have learned in the previous chapters while picking up new skills in Qt. So far, you'll have gained an insight into the architecture of Qt that is commonly seen and shared by its submodules. After all, networking and threading will definitely bring your applications to a higher level.</p><p class="calibre9">In the next chapter, besides parsing XML and JSON documents, we're going to rock Android with Qt!</p></div></div>



  </body></html>