["```cpp\n    template<typename Container>\n    void double_each_element(Container& arr) \n    {\n      for (int i=0; i < arr.size(); ++i) {\n        arr.at(i) *= 2;\n      }\n    }\n```", "```cpp\n    class list_of_ints {\n      struct node {\n        int data;\n        node *next;\n      };\n      node *head_ = nullptr;\n      node *tail_ = nullptr;\n      int size_ = 0;\n    public:\n      int size() const { return size_; }\n      int& at(int i) {\n        if (i >= size_) throw std::out_of_range(\"at\");\n        node *p = head_;\n        for (int j=0; j < i; ++j) {\n          p = p->next;\n        }\n        return p->data;\n      }\n      void push_back(int value) {\n        node *new_tail = new node{value, nullptr};\n        if (tail_) {\n          tail_->next = new_tail;\n        } else {\n          head_ = new_tail;\n        }\n        tail_ = new_tail;\n        size_ += 1;\n      }\n      ~list_of_ints() {\n        for (node *next, *p = head_; p != nullptr; p = next) {\n          next = p->next;\n          delete p;\n        }\n      }\n    };\n```", "```cpp\n    for (node *p = lst.head_; p != nullptr; p = p->next) {\n      if (pred(p->data)) {\n        sum += 1;\n      }\n   }\n```", "```cpp\n    struct list_node {\n      int data;\n      list_node *next;\n    };\n\n    class list_of_ints_iterator {\n      list_node *ptr_;\n\n      friend class list_of_ints;\n      explicit list_of_ints_iterator(list_node *p) : ptr_(p) {}\n    public:\n      int& operator*() const { return ptr_->data; }\n      list_of_ints_iterator& operator++() { ptr_ = ptr_->next; return *this; }\n      list_of_ints_iterator operator++(int) { auto it = *this; ++*this; return it; }\n      bool operator==(const list_of_ints_iterator& rhs) const\n        { return ptr_ == rhs.ptr_; }\n      bool operator!=(const list_of_ints_iterator& rhs) const\n        { return ptr_ != rhs.ptr_; }\n    };\n\n    class list_of_ints {\n      list_node *head_ = nullptr;\n      list_node *tail_ = nullptr;\n      // ...\n    public:\n      using iterator = list_of_ints_iterator;\n      iterator begin() { return iterator{head_}; }\n      iterator end() { return iterator{nullptr}; }\n    }; \n\n    template<class Container, class Predicate>\n    int count_if(Container& ctr, Predicate pred)\n    {\n      int sum = 0;\n      for (auto it = ctr.begin(); it != ctr.end(); ++it) {\n        if (pred(*it)) {\n            sum += 1;\n        }\n      }\n      return sum;\n   }\n```", "```cpp\n    struct list_node {\n      int data;\n      list_node *next;\n    };\n\n    template<bool Const>\n    class list_of_ints_iterator {\n      friend class list_of_ints;\n      friend class list_of_ints_iterator<!Const>;\n\n      using node_pointer = std::conditional_t<Const, const list_node*, list_node*>;\n      using reference = std::conditional_t<Const, const int&, int&>;\n\n      node_pointer ptr_;\n\n      explicit list_of_ints_iterator(node_pointer p) : ptr_(p) {}\n    public:\n      reference operator*() const { return ptr_->data; }\n      auto& operator++() { ptr_ = ptr_->next; return *this; }\n      auto operator++(int) { auto result = *this; ++*this; return result; }\n\n      // Support comparison between iterator and const_iterator types\n      template<bool R>\n      bool operator==(const list_of_ints_iterator<R>& rhs) const\n        { return ptr_ == rhs.ptr_; }\n\n      template<bool R>\n      bool operator!=(const list_of_ints_iterator<R>& rhs) const\n        { return ptr_ != rhs.ptr_; }\n\n      // Support implicit conversion of iterator to const_iterator\n      // (but not vice versa)\n      operator list_of_ints_iterator<true>() const\n        { return list_of_ints_iterator<true>{ptr_}; }\n    };\n\n    class list_of_ints {\n      list_node *head_ = nullptr;\n      list_node *tail_ = nullptr;\n      // ...\n    public:\n      using const_iterator = list_of_ints_iterator<true>;\n      using iterator = list_of_ints_iterator<false>;\n\n      iterator begin() { return iterator{head_}; }\n      iterator end() { return iterator{nullptr}; }\n      const_iterator begin() const { return const_iterator{head_}; }\n      const_iterator end() const { return const_iterator{nullptr}; }\n    };\n```", "```cpp\n    template<class Iterator>\n    void double_each_element(Iterator begin, Iterator end) \n    {\n      for (auto it = begin; it != end; ++it) {\n        *it *= 2;\n      } \n    }\n\n    int main() \n    {\n      std::vector<int> v {1, 2, 3, 4, 5, 6};\n      double_each_element(v.begin(), v.end());\n        // double each element in the entire vector\n      double_each_element(v.begin(), v.begin()+3);\n        // double each element in the first half of the vector\n      double_each_element(&v[0], &v[3]);\n        // double each element in the first half of the vector\n    }\n```", "```cpp\n    template<typename Iterator>\n    int distance(Iterator begin, Iterator end) \n    {\n      int sum = 0;\n      for (auto it = begin; it != end; ++it) {\n        sum += 1;\n      }\n      return sum;\n    }\n\n    template<typename Iterator, typename Predicate>\n    int count_if(Iterator begin, Iterator end, Predicate pred) \n    {\n      int sum = 0;\n      for (auto it = begin; it != end; ++it) {\n        if (pred(*it)) {\n            sum += 1;\n        }\n      }\n      return sum; \n    }\n\n    void test() \n    {\n      std::vector<int> v = {3, 1, 4, 1, 5, 9, 2, 6};\n\n      int number_above = count_if(v.begin(), v.end(), [](int e) { return e > 5; });\n      int number_below = count_if(v.begin(), v.end(), [](int e) { return e < 5; });\n\n      int total = distance(v.begin(), v.end()); // DUBIOUS \n\n      assert(number_above == 2);\n      assert(number_below == 5);\n      assert(total == 8);\n    }\n```", "```cpp\n    template<typename Iterator>\n    int distance(Iterator begin, Iterator end)\n    {\n      int sum = 0;\n      for (auto it = begin; it != end; ++it) {\n        sum += 1;\n      }\n      return sum;\n    }\n\n    template<> \n    int distance(int *begin, int *end) \n    {\n      return end - begin;\n    }\n```", "```cpp\n    class getc_iterator {\n      char ch;\n    public:\n      getc_iterator() : ch(getc(stdin)) {}\n      char operator*() const { return ch; }\n      auto& operator++() { ch = getc(stdin); return *this; }\n      auto operator++(int) { auto result(*this); ++*this; return result; }\n      bool operator==(const getc_iterator&) const { return false; }\n      bool operator!=(const getc_iterator&) const { return true; }\n    };\n```", "```cpp\n    class putc_iterator {\n      struct proxy {\n        void operator= (char ch) { putc(ch, stdout); }\n      };\n    public:\n      proxy operator*() const { return proxy{}; }\n      auto& operator++() { return *this; }\n      auto& operator++(int) { return *this; }\n      bool operator==(const putc_iterator&) const { return false; }\n      bool operator!=(const putc_iterator&) const { return true; }\n    };\n\n    void test()\n    {\n      putc_iterator it;\n      for (char ch : {'h', 'e', 'l', 'l', 'o', '\\n'}) {\n        *it++ = ch;\n      }\n    }\n```", "```cpp\n    class getc_iterator {\n      char ch;\n    public:\n      using iterator_category = std::input_iterator_tag;\n\n      // ...\n    };\n\n    class putc_iterator {\n      struct proxy {\n        void operator= (char ch) { putc(ch, stdout); }\n      };\n    public:\n      using iterator_category = std::output_iterator_tag;\n\n      // ...\n    };\n\n    template<bool Const>\n    class list_of_ints_iterator {\n      using node_pointer = std::conditional_t<Const, const list_node*,\n       list_node*>;\n      node_pointer ptr_;\n\n    public:\n      using iterator_category = std::forward_iterator_tag;\n\n      // ...\n    };\n```", "```cpp\n    struct input_iterator_tag { };\n    struct output_iterator_tag { };\n    struct forward_iterator_tag : public input_iterator_tag { };\n    struct bidirectional_iterator_tag : public forward_iterator_tag { };\n    struct random_access_iterator_tag : public bidirectional_iterator_tag\n    { };\n```", "```cpp\n    void foo(std::bidirectional_iterator_tag t [[maybe_unused]])\n    {\n      puts(\"std::vector's iterators are indeed bidirectional...\"); \n    }\n\n    void bar(std::random_access_iterator_tag)\n    {\n      puts(\"...and random-access, too!\");\n    }\n\n    void bar(std::forward_iterator_tag)\n    {\n      puts(\"forward_iterator_tag is not as good a match\");\n    }\n\n    void test()\n    {\n      using It = std::vector<int>::iterator;\n      foo(It::iterator_category{});\n      bar(It::iterator_category{});\n    }\n```", "```cpp\n    struct list_node {\n      int data;\n      list_node *next;\n    };\n\n    template<bool Const>\n    class list_of_ints_iterator {\n      friend class list_of_ints;\n      friend class list_of_ints_iterator<!Const>;\n\n      using node_pointer = std::conditional_t<Const, const list_node*,\n        list_node*>;\n      node_pointer ptr_;\n\n      explicit list_of_ints_iterator(node_pointer p) : ptr_(p) {}\n    public:\n      // Member typedefs required by std::iterator_traits\n      using difference_type = std::ptrdiff_t;\n      using value_type = int;\n      using pointer = std::conditional_t<Const, const int*, int*>;\n      using reference = std::conditional_t<Const, const int&, int&>;\n      using iterator_category = std::forward_iterator_tag;\n\n      reference operator*() const { return ptr_->data; }\n      auto& operator++() { ptr_ = ptr_->next; return *this; }\n      auto operator++(int) { auto result = *this; ++*this; return result; }\n\n      // Support comparison between iterator and const_iterator types\n      template<bool R>\n      bool operator==(const list_of_ints_iterator<R>& rhs) const\n        { return ptr_ == rhs.ptr_; }\n\n      template<bool R>\n      bool operator!=(const list_of_ints_iterator<R>& rhs) const\n        { return ptr_ != rhs.ptr_; }\n\n      // Support implicit conversion of iterator to const_iterator\n      // (but not vice versa)\n      operator list_of_ints_iterator<true>() const { return \n        list_of_ints_iterator<true>{ptr_}; }\n    };\n\n    class list_of_ints {\n      list_node *head_ = nullptr;\n      list_node *tail_ = nullptr;\n      int size_ = 0;\n    public:\n      using const_iterator = list_of_ints_iterator<true>;\n      using iterator = list_of_ints_iterator<false>;\n\n      // Begin and end member functions\n      iterator begin() { return iterator{head_}; }\n      iterator end() { return iterator{nullptr}; }\n      const_iterator begin() const { return const_iterator{head_}; }\n      const_iterator end() const { return const_iterator{nullptr}; }\n\n      // Other member operations\n      int size() const { return size_; }\n      void push_back(int value) {\n        list_node *new_tail = new list_node{value, nullptr};\n        if (tail_) {\n          tail_->next = new_tail;\n        } else {\n          head_ = new_tail;\n        }\n        tail_ = new_tail;\n        size_ += 1;\n      }\n      ~list_of_ints() {\n        for (list_node *next, *p = head_; p != nullptr; p = next) {\n          next = p->next;\n          delete p;\n        }\n      }\n    };\n```", "```cpp\n    template<typename Iterator>\n    auto distance(Iterator begin, Iterator end)\n    {\n      using Traits = std::iterator_traits<Iterator>;\n      if constexpr (std::is_base_of_v<std::random_access_iterator_tag,\n        typename Traits::iterator_category>) {\n          return (end - begin);\n        } else {\n         auto result = typename Traits::difference_type{};\n         for (auto it = begin; it != end; ++it) {\n           ++result;\n         }\n         return result;\n      }\n    }\n\n    template<typename Iterator, typename Predicate>\n    auto count_if(Iterator begin, Iterator end, Predicate pred) \n    {\n      using Traits = std::iterator_traits<Iterator>;\n      auto sum = typename Traits::difference_type{};\n      for (auto it = begin; it != end; ++it) {\n        if (pred(*it)) {\n          ++sum;\n        }\n      }\n      return sum;\n    }\n\n    void test()\n    {\n       list_of_ints lst;\n       lst.push_back(1);\n       lst.push_back(2);\n       lst.push_back(3);\n       int s = count_if(lst.begin(), lst.end(), [](int i){\n          return i >= 2;\n       });\n       assert(s == 2);\n       int d = distance(lst.begin(), lst.end());\n       assert(d == 3);\n    }\n```", "```cpp\n    namespace std {\n      template<\n        class Category,\n        class T,\n        class Distance = std::ptrdiff_t,\n        class Pointer = T*,\n        class Reference = T&\n      > struct iterator {\n        using iterator_category = Category;\n        using value_type = T;\n        using difference_type = Distance;\n        using pointer = Pointer;\n        using reference = Reference;\n      };\n    }\n\n    class list_of_ints_iterator :\n      public std::iterator<std::forward_iterator_tag, int>\n    {\n       // ...\n    };\n```", "```cpp\n    template<\n      bool Const,\n      class Base = std::iterator<\n        std::forward_iterator_tag,\n        int,\n        std::ptrdiff_t,\n        std::conditional_t<Const, const int*, int*>,\n        std::conditional_t<Const, const int&, int&>\n      >\n    >\n    class list_of_ints_iterator : public Base\n    {\n      using typename Base::reference; // Awkward!\n\n      using node_pointer = std::conditional_t<Const, const list_node*,\n        list_node*>;\n      node_pointer ptr_;\n\n    public:\n      reference operator*() const { return ptr_->data; }\n      // ...\n    };\n```", "```cpp\n    template<typename... Ts, typename Predicate>\n    int count_if(const std::iterator<Ts...>& begin,\n                 const std::iterator<Ts...>& end,\n                 Predicate pred);\n```", "```cpp\n    #include <boost/iterator/iterator_facade.hpp>\n\n    template<bool Const>\n    class list_of_ints_iterator : public boost::iterator_facade<\n      list_of_ints_iterator<Const>,\n      std::conditional_t<Const, const int, int>,\n      std::forward_iterator_tag\n    >\n    {\n      friend class boost::iterator_core_access;\n      friend class list_of_ints;\n      friend class list_of_ints_iterator<!Const>;\n\n      using node_pointer = std::conditional_t<Const, const list_node*,\n        list_node*>;\n      node_pointer ptr_;\n\n      explicit list_of_ints_iterator(node_pointer p) : ptr_(p) {} \n\n      auto& dereference() const { return ptr_->data; }\n      void increment() { ptr_ = ptr_->next; }\n\n      // Support comparison between iterator and const_iterator types\n      template<bool R>\n      bool equal(const list_of_ints_iterator<R>& rhs) const {\n        return ptr_ == rhs.ptr_;}\n\n    public:\n      // Support implicit conversion of iterator to const_iterator\n      // (but not vice versa)\n      operator list_of_ints_iterator<true>() const { return\n        list_of_ints_iterator<true>{ptr_}; }\n    };\n```"]