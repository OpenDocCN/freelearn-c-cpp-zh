<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Scratching the Tip of the Iceberg"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Scratching the Tip of the Iceberg</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working with graphs</li><li class="listitem" style="list-style-type: disc">Visualizing graphs</li><li class="listitem" style="list-style-type: disc">Using a true random number generator</li><li class="listitem" style="list-style-type: disc">Using portable math functions</li><li class="listitem" style="list-style-type: disc">Writing test cases</li><li class="listitem" style="list-style-type: disc">Combining multiple test cases in one test module</li><li class="listitem" style="list-style-type: disc">Manipulating images</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec108"/>Introduction</h1></div></div></div><p>Boost<a id="id673" class="indexterm"/> is a huge collection of libraries. Some of those libraries are small and meant for everyday use and others require a separate book to describe all of their features. This chapter is devoted to some of those big libraries and to give you some basics to start with.</p><p>The first two recipes will explain the usage of <code class="literal">Boost.Graph</code>
<a id="id674" class="indexterm"/>. It is a big library with an insane number of algorithms. We'll see some basics and probably the most important part of it visualization of graphs.</p><p>We'll also see a very useful recipe for generating true random numbers. This is a very important requirement for writing secure cryptography systems.</p><p>Some C++ standard libraries lack math functions. We'll see how that can be fixed using Boost. But the format of this book leaves no space to describe all of the functions.</p><p>Writing test cases is described in the <span class="emphasis"><em>Writing test cases</em></span> and <span class="emphasis"><em>Combining multiple test cases in one test module</em></span> recipes. This is important for any production-quality system.</p><p>The last recipe is about a library that helped me in many courses during my university days. Images can be created and modified using it. I personally used it to visualize different algorithms, hide data in images, sign images, and generate textures.</p><p>Unfortunately, even this chapter cannot tell you about all of the Boost libraries. Maybe someday I'll write another book... and then a few more.</p></div></div>
<div class="section" title="Working with graphs"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec109"/>Working with graphs</h1></div></div></div><p>Some tasks<a id="id675" class="indexterm"/> require a graphical representation of data. <code class="literal">Boost.Graph</code> is a library that was designed to provide a flexible way of constructing and representing graphs in memory. It also contains a lot of algorithms to work with graphs, such as topological sort, breadth first search, depth first search, and Dijkstra shortest paths.</p><p>Well, let's perform some basic tasks with <code class="literal">Boost.Graph</code>!</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec439"/>Getting ready</h2></div></div></div><p>Only basic knowledge of C++ and templates is required for this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec440"/>How to do it...</h2></div></div></div><p>In this recipe, we'll describe a graph type, create a graph of that type, add some vertexes and edges to the graph, and search for a specific vertex. That should be enough to start using <code class="literal">Boost.Graph</code>.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start with describing the graph type:<div class="informalexample"><pre class="programlisting">#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;string&gt;

typedef std::string vertex_t;
typedef boost::adjacency_list&lt;
    boost::vecS
    , boost::vecS
    , boost::bidirectionalS
    , vertex_t
&gt; graph_type;</pre></div></li><li class="listitem">Now we construct it:<div class="informalexample"><pre class="programlisting">    graph_type graph;</pre></div></li><li class="listitem">Let's use a non portable trick that speeds up graph construction:<div class="informalexample"><pre class="programlisting">    static const std::size_t vertex_count = 5;
    graph.m_vertices.reserve(vertex_count);</pre></div></li><li class="listitem">Now we are ready to add vertexes to the graph:<div class="informalexample"><pre class="programlisting">typedef boost::graph_traits&lt;graph_type&gt;
            ::vertex_descriptor descriptor_t;
    
    descriptor_t cpp 
        = boost::add_vertex(vertex_t("C++"), graph);
    descriptor_t stl 
        = boost::add_vertex(vertex_t("STL"), graph);
    descriptor_t boost 
        = boost::add_vertex(vertex_t("Boost"), graph);
    descriptor_t guru 
        = boost::add_vertex(vertex_t("C++ guru"), graph);
    descriptor_t ansic 
        = boost::add_vertex(vertex_t("C"), graph);</pre></div></li><li class="listitem">It is time<a id="id676" class="indexterm"/> to connect vertexes with edges:<div class="informalexample"><pre class="programlisting">    boost::add_edge(cpp, stl, graph);
    boost::add_edge(stl, boost, graph);
    boost::add_edge(boost, guru, graph);
    boost::add_edge(ansic, guru, graph);</pre></div></li><li class="listitem">We make a function that searches for a vertex:<div class="informalexample"><pre class="programlisting">template &lt;class GraphT&gt;
void find_and_print(const GraphT&amp; g, boost::string_ref name) {</pre></div></li><li class="listitem">Now we will write code that gets iterators to all vertexes:<div class="informalexample"><pre class="programlisting">    typedef typename boost::graph_traits&lt;graph_type&gt;
            ::vertex_iterator vert_it_t;

    vert_it_t it, end;
    boost::tie(it, end) = boost::vertices(g);</pre></div></li><li class="listitem">It's time to run a search for the required vertex:<div class="informalexample"><pre class="programlisting">    typedef boost::graph_traits&lt;graph_type&gt;::vertex_descriptor desc_t;
    for (; it != end; ++ it) {
        desc_t desc = *it;
        if (boost::get(boost::vertex_bundle, g)[desc] 
                 == name.data()) {
            break;
        }
    }
    assert(it != end);
    std::cout &lt;&lt; name &lt;&lt; '\n';
} /* find_and_print */</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec441"/>How it works...</h2></div></div></div><p>In step 1, we <a id="id677" class="indexterm"/>are describing what our graph must look like and upon what types it must be based. <a id="id678" class="indexterm"/>
<code class="literal">boost::adjacency_list</code> is a class that represents graphs as a two-dimensional structure, where the first dimension contains vertexes and the second dimension contains edges for that vertex. <code class="literal">boost::adjacency_list</code> must be the default choice for representing a graph; it suits most cases.</p><p>The first template parameter, <code class="literal">boost::adjacency_list</code>, describes the structure used to represent the edge list for each of the vertexes; the second one describes a structure to store vertexes. We can choose different STL containers for those structures using specific selectors, as listed in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Selector</p>
</th><th style="text-align: left" valign="bottom">
<p>STL container</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">boost::vecS</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">std::vector</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">boost::listS</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">std::list</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">boost::slistS</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">std::slist</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">boost::setS</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">std::set</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">boost::multisetS</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">std::multiset</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">boost::hash_setS</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">std::hash_set</code></p>
</td></tr></tbody></table></div><p>The third template parameter is used to make an undirected, directed, or bidirectional graph. Use the <a id="id679" class="indexterm"/>
<code class="literal">boost::undirectedS</code>, <code class="literal">boost::directedS</code>, <a id="id680" class="indexterm"/>and <a id="id681" class="indexterm"/>
<code class="literal">boost::bidirectionalS</code> selectors respectively.</p><p>The fifth template parameter describes the datatype that will be used as the vertex. In our example, we chose <code class="literal">std::string</code>. We can also support a datatype for edges and provide it as a template parameter.</p><p>Steps 2 and 3 are trivial, but at step 4 you will see a non portable way to speed up graph construction. In our example, we use <code class="literal">std::vector</code> as a container for storing vertexes, so we can force it to reserve memory for the required amount of vertexes. This leads to less memory allocations/deallocations and copy operations during insertion of vertexes into the graph. This step is non-portable because it is highly dependent on the current implementation of <code class="literal">boost::adjacency_list</code>
<a id="id682" class="indexterm"/> and on the chosen container type for storing vertexes.</p><p>At step 4, we see how vertexes can be added to the graph. Note how <code class="literal">boost::graph_traits&lt;graph_type&gt;</code> has been used. The <code class="literal">boost::graph_traits</code> class is used to get types that are specific for a graph type. We'll see its usage and the description of some graph-specific types later in this chapter. Step 5 shows what we need do to connect vertexes with edges.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note51"/>Note</h3><p>If we had provided a datatype for the edges, adding an edge would look as follows:</p><p><code class="literal">boost::add_edge(ansic, guru, edge_t(initialization_parameters), graph)</code></p></div></div><p>Note that at step 6 the graph type is a <code class="literal">template</code> parameter. This is recommended to achieve better code reusability and make this function work with other graph types.</p><p>At step 7, <a id="id683" class="indexterm"/>we see how to iterate over all of the vertexes of the graph. The type of vertex iterator is received from <code class="literal">boost::graph_traits</code>. The function <code class="literal">boost::tie</code> is a part of <code class="literal">Boost.Tuple</code> and is used for getting values from tuples to the variables. So calling <code class="literal">boost::tie(it, end) = boost::vertices(g)</code> will put the <code class="literal">begin</code> iterator into the <code class="literal">it</code> variable and the <code class="literal">end</code> iterator into the <code class="literal">end</code> variable.</p><p>It may come as a surprise to you, but dereferencing a vertex iterator does not return vertex data. Instead, it returns the vertex descriptor <code class="literal">desc</code>, which can be used in <code class="literal">boost::get(boost::vertex_bundle, g)[desc]</code> to get vertex data, just as we have done in step 8. The vertex descriptor type is used in many of the <code class="literal">Boost.Graph</code> functions; we saw its use in the edge construction function in step 5.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note52"/>Note</h3><p>As already mentioned, the <code class="literal">Boost.Graph</code> library contains the implementation of many algorithms. You will find many search policies implemented, but we won't discuss them in this book. We will limit this recipe to only the basics of the graph library.</p></div></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec442"/>There's more...</h2></div></div></div><p>The <code class="literal">Boost.Graph</code> library<a id="id684" class="indexterm"/> is not a part of C++11 and it won't be a part of C++1y. The current implementation does not support C++11 features. If we are using vertexes that are heavy to copy, we may gain speed using the following trick:</p><div class="informalexample"><pre class="programlisting">vertex_descriptor desc = boost::add_vertex(graph);boost::get(boost::vertex_bundle, g_)[desc] = std::move(vertex_data);</pre></div><p>It avoids copy constructions of <code class="literal">boost::add_vertex(vertex_data, graph)</code> and uses the default construction with <code class="literal">move</code> assignment instead.</p><p>The efficiency of <code class="literal">Boost.Graph</code> depends on multiple factors, such as the underlying containers types, graph representation, edge, and vertex datatypes.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec443"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reading the <span class="emphasis"><em>Visualizing graphs</em></span> recipe can help you work more easily with graphs. You may also consider reading its official documentation at the following link:<p><a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/graph/doc/table_of_contents.html">http://www.boost.org/doc/libs/1_53_0/libs/graph/doc/table_of_contents.html</a></p></li></ul></div></div></div>
<div class="section" title="Visualizing graphs"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec110"/>Visualizing graphs</h1></div></div></div><p>Making programs<a id="id685" class="indexterm"/> that manipulate graphs was never easy because of issues with visualization. When we work with STL containers such as <code class="literal">std::map</code> and <code class="literal">std::vector</code>, we can always print the container's contents and see what is going on inside. But when we work with complex graphs, it is hard to visualize the content in a clear way: too many vertexes and too many edges.</p><p>In this recipe, we'll take a look at the visualization of <code class="literal">Boost.Graph</code> using the <a id="id686" class="indexterm"/>
<span class="strong"><strong>Graphviz</strong></span> tool.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec444"/>Getting ready</h2></div></div></div><p>To visualize graphs, you will need a Graphviz visualization tool. Knowledge of the preceding recipe is also required.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec445"/>How to do it...</h2></div></div></div><p>Visualization is<a id="id687" class="indexterm"/> done in two phases. In the first phase, we make our program output the graph's description in a text format; in the second phase, we import the output from the first step to some visualization tool. The numbered steps in this recipe are all about the first phase.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's write the <code class="literal">std::ostream</code> operator for <code class="literal">graph_type</code> as done in the preceding recipe:<div class="informalexample"><pre class="programlisting">#include &lt;boost/graph/graphviz.hpp&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const graph_type&amp; g) {
    detail::vertex_writer&lt;graph_type&gt; vw(g);
    boost::write_graphviz(out, g, vw);
    return out;
}</pre></div></li><li class="listitem">The <code class="literal">detail::vertex_writer</code> structure, used in the preceding step, must be defined as follows:<div class="informalexample"><pre class="programlisting">namespace detail {

    template &lt;class GraphT&gt;
    class vertex_writer {
        const GraphT&amp; g_;

    public:
        explicit vertex_writer(const GraphT&amp; g)
            : g_(g)
        {}

        template &lt;class VertexDescriptorT&gt;
        void operator()(std::ostream&amp; out, 
           const VertexDescriptorT&amp; d) const 
        {
           out &lt;&lt; " [label=\""
               &lt;&lt; boost::get(boost::vertex_bundle, g_)[d] 
               &lt;&lt; "\"]"; 
        }
    }; // vertex_writer

} // namespace detail</pre></div></li></ol></div><p>That's all. Now, <a id="id688" class="indexterm"/>if we visualize the graph from the previous recipe using the <code class="literal">std::cout &lt;&lt; graph;</code> command, the output can be used to create graphical pictures using the <a id="id689" class="indexterm"/>
<code class="literal">dot</code> command-line utility:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ dot -Tpng -o dot.png</strong></span>

<span class="strong"><strong>digraph G {</strong></span>

<span class="strong"><strong>0 [label="C++"];</strong></span>

<span class="strong"><strong>1 [label="STL"];</strong></span>

<span class="strong"><strong>2 [label="Boost"];</strong></span>

<span class="strong"><strong>3 [label="C++ guru"];</strong></span>

<span class="strong"><strong>4 [label="C"];</strong></span>

<span class="strong"><strong>0-&gt;1 ;</strong></span>

<span class="strong"><strong>1-&gt;2 ;</strong></span>

<span class="strong"><strong>2-&gt;3 ;</strong></span>

<span class="strong"><strong>4-&gt;3 ;</strong></span>

<span class="strong"><strong>}</strong></span>
</pre></div><p>The output of the preceding command is depicted in the following figure:</p><div class="mediaobject"><img src="graphics/4880OS_12_02.jpg" alt="How to do it..."/></div><p>We can also <a id="id690" class="indexterm"/>use the <span class="strong"><strong>Gvedit</strong></span>
<a id="id691" class="indexterm"/> or <span class="strong"><strong>XDot</strong></span>
<a id="id692" class="indexterm"/> programs for visualization if the command line frightens you.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec446"/>How it works...</h2></div></div></div><p>The <code class="literal">Boost.Graph</code> library contains function to output graphs in Graphviz (DOT) format. If we write <code class="literal">boost::write_graphviz(out, g)</code> with two parameters in step 1, the function will output a graph picture with vertexes numbered from <code class="literal">0</code>. That's not very useful, so we provide an instance of the <code class="literal">vertex_writer</code> class<a id="id693" class="indexterm"/> that outputs vertex names.</p><p>As we can see in step 2, the format of output must be DOT, which is understood by the Graphviz tool. You may need to read the Graphviz documentation for more info about the DOT format.</p><p>If you wish to add some data to the edges during visualization, we need to provide an instance of the edge visualizer as a fourth parameter to <code class="literal">boost::write_graphviz</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec447"/>There's more...</h2></div></div></div><p>C++11 does not contain <code class="literal">Boost.Graph</code> or the tools for graph visualization. But you do not need to worry—there are a lot of other graph formats and visualization tools and <code class="literal">Boost.Graph</code> can work with plenty of them.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec448"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Working with graphs</em></span> recipe contains information about the construction of <code class="literal">Boost.Graphs</code></li><li class="listitem" style="list-style-type: disc">You will find a lot of information about the DOT format and Graphviz at <a class="ulink" href="http://www.graphviz.org/">http://www.graphviz.org/</a></li><li class="listitem" style="list-style-type: disc">Boost's official documentation for the <code class="literal">Boost.Graph</code> library contains multiple examples and useful information, and can be found at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/graph/doc/table_of_">http://www.boost.org/doc/libs/1_53_0/libs/graph/doc/table_of_</a><a class="ulink" href="http://contents.html">contents.html</a></li></ul></div></div></div>
<div class="section" title="Using a true random number generator"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec111"/>Using a true random number generator</h1></div></div></div><p>I know of<a id="id694" class="indexterm"/> many examples of commercial products that use incorrect methods for getting random numbers. It's a shame that some companies still use <code class="literal">rand()</code> in cryptography and banking software.</p><p>Let's see how to get a fully random uniform distribution using <code class="literal">Boost.Random</code> that is suitable for banking software.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec449"/>Getting ready</h2></div></div></div><p>Basic knowledge of C++ is required for this recipe. Knowledge of different types of distributions will also be helpful. The code in this recipe requires linking against the <code class="literal">boost_random</code> library.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec450"/>How to do it...</h2></div></div></div><p>To create a true random number, we need some help from the operating system or processor. This is how it can be done using Boost:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll need to include the following headers:<div class="informalexample"><pre class="programlisting">#include &lt;boost/config.hpp&gt;
#include &lt;boost/random/random_device.hpp&gt;
#include &lt;boost/random/uniform_int_distribution.hpp&gt;</pre></div></li><li class="listitem">Advanced random number providers have different names under different platforms:<div class="informalexample"><pre class="programlisting">    static const std::string provider =
#ifdef BOOST_WINDOWS
        "Microsoft Strong Cryptographic Provider"
#else
        "/dev/urandom"
#endif
    ;</pre></div></li><li class="listitem">Now we are ready to initialize the generator with <code class="literal">Boost.Random</code>:<div class="informalexample"><pre class="programlisting">    boost::random_device device(provider);</pre></div></li><li class="listitem">Let's get a uniform distribution that returns a value between 1000 and 65535:<div class="informalexample"><pre class="programlisting">    boost::random::uniform_int_distribution&lt;unsigned short&gt; random(1000);</pre></div></li></ol></div><p>That's it. Now we can get true random numbers using the <code class="literal">random(device)</code> call.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec451"/>How it works...</h2></div></div></div><p>Why does<a id="id695" class="indexterm"/> the <code class="literal">rand()</code> function<a id="id696" class="indexterm"/> not suit banking? Because it generates pseudo-random numbers, which means that the hacker could predict the next generated number. This is an issue with all pseudo-random number algorithms. Some algorithms are easier to predict and some harder, but it's still possible.</p><p>That's why we are using <code class="literal">boost::random_device</code> in this example (see step 3). That device gathers information about random events from all around the operating system to construct an unpredictable hardware-generated number. The examples of such events are delays between pressed keys, delays between some of the hardware interruptions, and the internal CPU random number generator.</p><p>Operating systems may have more than one such type of random number generators. In our example for POSIX systems, we used <code class="literal">/dev/urandom</code> instead of the more secure <code class="literal">/dev/random</code> because the latter remains in a blocked state until enough random events have been captured by the OS. Waiting for entropy could take seconds, which is usually unsuitable for applications. Use <code class="literal">/dev/random</code> to create long-lifetime <code class="literal">GPG/SSL/SSH</code> keys.</p><p>Now that we are done with generators, it's time to move to step 4 and talk about distribution classes. If the generator just generates numbers (usually uniformly distributed), the distribution class maps one distribution to another. In step 4, we made a uniform distribution that returns a random number of unsigned short type. The parameter <code class="literal">1000</code> means that distribution must return numbers greater or equal to <code class="literal">1000</code>. We can also provide the maximum number as a second parameter, which is by default equal to the maximum value storable in the return type.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec452"/>There's more...</h2></div></div></div><p><code class="literal">Boost.Random</code>
<a id="id697" class="indexterm"/> has a huge number of true/pseudo random generators and distributions for different needs. Avoid copying distributions and generators; this could turn out to be an expensive operation.</p><p>C++11 has support <a id="id698" class="indexterm"/>for different distribution classes and generators. You will find all of the classes from this example in the <code class="literal">&lt;random&gt;</code> header in the <code class="literal">std::</code> namespace. The <code class="literal">Boost.Random</code> libraries do not use C++11 features, and they are not really required for that library either. Should you use Boost implementation or STL? Boost provides better portability across systems; however, some STL implementations may have assembly-optimized implementations and might provide some useful extensions.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec453"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The official documentation contains a full list of generators and distributions with descriptions; it is available at the following link:<p><a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html">http://www.boost.org/doc/libs/1_53_0/doc/html</a>
<a class="ulink" href="http:///boost_random.html">/boost_random.html</a></p></li></ul></div></div></div>
<div class="section" title="Using portable math functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec112"/>Using portable math functions</h1></div></div></div><p>Some projects <a id="id699" class="indexterm"/>require specific trigonometric functions, a library for numerically solving ordinary differential equations, and working with distributions and constants. All of those parts of <code class="literal">Boost.Math</code> would be hard to fit into even a separate book. A single recipe definitely won't be enough. So let's focus on very basic everyday-use functions to work with float types.</p><p>We'll write a portable function that checks an input value for infinity and not-a-number (NaN) values and changes the sign if the value is negative.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec454"/>Getting ready</h2></div></div></div><p>Basic knowledge of C++ is required for this recipe. Those who know C99 standard will find a lot in common in this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec455"/>How to do it...</h2></div></div></div><p>Perform the following steps to check the input value for infinity and NaN values and change the sign if the value is negative:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll need the following headers:<div class="informalexample"><pre class="programlisting">#include &lt;boost/math/special_functions.hpp&gt;
#include &lt;cassert&gt;</pre></div></li><li class="listitem">Asserting for infinity and NaN can be done like this:<div class="informalexample"><pre class="programlisting">template &lt;class T&gt;
void check_float_inputs(T value) {
    assert(!boost::math::isinf(value));
    assert(!boost::math::isnan(value));</pre></div></li><li class="listitem">Use the following code to change the sign:<div class="informalexample"><pre class="programlisting">    if (boost::math::signbit(value)) {
        value = boost::math::changesign(value);
    }

    // ...
} // check_float_inputs</pre></div></li></ol></div><p>That's it! Now <a id="id700" class="indexterm"/>we can check that <code class="literal">check_float_inputs(std::sqrt(-1.0))</code> and <code class="literal">check_float_inputs(std::numeric_limits&lt;double&gt;::max() * 2.0)</code> will cause asserts.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec456"/>How it works...</h2></div></div></div><p>Real types have specific values that cannot be checked using equality operators. For example, if the variable <code class="literal">v</code> contains NaN, <code class="literal">assert(v!=v)</code> may or may not pass depending on the compiler.</p><p>For such cases, <code class="literal">Boost.Math</code> provides functions that can reliably check for infinity and NaN values.</p><p>Step 3 contains the <code class="literal">boost::math::signbit</code> function, which requires clarification. This function returns a signed bit, which is 1 when the number is negative and 0 when the number is positive. In other words, it returns <code class="literal">true</code> if the value is negative.</p><p>Looking at step 3 some readers might ask, "Why can't we just multiply by <code class="literal">-1</code> instead of calling <code class="literal">boost::math::changesign</code>?". We can. But multiplication may work slower than <code class="literal">boost::math::changesign</code> and won't work for special values. For example, if your code can work with <code class="literal">nan</code>, the code in step 3 will be able to change the sign of <code class="literal">-nan</code> and write <code class="literal">nan</code> to the variable.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note53"/>Note</h3><p>The <code class="literal">Boost.Math</code> library maintainers recommend wrapping math functions from this example in round parenthesis to avoid collisions with C macros. It is better to write <code class="literal">(boost::math::isinf)(value)</code> instead of <code class="literal">boost::math::isinf(value)</code>.</p></div></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec457"/>There's more...</h2></div></div></div><p>C99 contains all of the functions described in this recipe. Why do we need them in Boost? Well, some compiler vendors think that programmers do not need them, so you won't find them in <a id="id701" class="indexterm"/>one very popular compiler. Another reason is that the <code class="literal">Boost.Math</code> functions canbe used for classes that behave like numbers.</p><p><code class="literal">Boost.Math</code>
<a id="id702" class="indexterm"/> is a very fast, portable, reliable library.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec458"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Boost's official documentation contains lots of interesting examples and tutorials that will help you get used to <code class="literal">Boost.Math</code>; browse to <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/math/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/math/doc/html/index.html</a></li></ul></div></div></div>
<div class="section" title="Writing test cases"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec113"/>Writing test cases</h1></div></div></div><p>This recipe <a id="id703" class="indexterm"/>and the next one are devoted to auto-testing the <code class="literal">Boost.Test</code> library, which is used by many Boost libraries. Let's get hands-on with it and write some tests for our own class.</p><div class="informalexample"><pre class="programlisting">#include &lt;stdexcept&gt;
struct foo {
    int val_;

    operator int() const;
    bool is_not_null() const;
    void throws() const; // throws(std::logic_error)
};</pre></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec459"/>Getting ready</h2></div></div></div><p>Basic knowledge of C++ is required for this recipe. The code of this recipe requires linking against the static version of the<a id="id704" class="indexterm"/> <code class="literal">boost_unit_test_framework</code> library.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec460"/>How to do it...</h2></div></div></div><p>To be honest, there is more than one test library in Boost. We'll take a look at the most functional one.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To use it, we'll need to define the macro and include the following header:<div class="informalexample"><pre class="programlisting">#define BOOST_TEST_MODULE test_module_name
#include &lt;boost/test/unit_test.hpp&gt;</pre></div></li><li class="listitem">Each set of tests must be written in the test case:<div class="informalexample"><pre class="programlisting">BOOST_AUTO_TEST_CASE(test_no_1) {</pre></div></li><li class="listitem">Checking some function for the <code class="literal">true</code> result is done as follows:<div class="informalexample"><pre class="programlisting">    foo f1 = {1}, f2 = {2};
    BOOST_CHECK(f1.is_not_null());</pre></div></li><li class="listitem">Checking for nonequality is implemented in the following way:<div class="informalexample"><pre class="programlisting">    BOOST_CHECK_NE(f1, f2);</pre></div></li><li class="listitem">Checking for an exception being thrown will look like this:<div class="informalexample"><pre class="programlisting">    BOOST_CHECK_THROW(f1.throws(), std::logic_error);
} // BOOST_AUTO_TEST_CASE(test_no_1)</pre></div></li></ol></div><p>That's it! <a id="id705" class="indexterm"/>After compilation and linking, we'll get an executable file that automatically tests <code class="literal">foo</code> and outputs test results in a human-readable format.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec461"/>How it works...</h2></div></div></div><p>Writing unit tests is easy; you know how the function works and what result it should produce in specific situations. So you just check if the expected result is the same as the function's actual output. That's what we did in step 3. We know that <code class="literal">f1.is_not_null()</code> will return <code class="literal">true</code> and we checked it. At step 4, we know that <code class="literal">f1</code> is not equal to <code class="literal">f2</code>, so we checked it too. The call to <code class="literal">f1.throws()</code> will produce the <code class="literal">std::logic_error</code> exception and we check that an exception of the expected type is thrown.</p><p>At step 2, we are making a test case – a set of checks to validate correct behavior of the <code class="literal">foo</code> structure. We can have multiple test cases in a single source file. For example, if we add the following code:</p><div class="informalexample"><pre class="programlisting">BOOST_AUTO_TEST_CASE(test_no_2) {
    foo f1 = {1}, f2 = {2};
    BOOST_REQUIRE_NE(f1, f2);
    // ...
} // BOOST_AUTO_TEST_CASE(test_no_2)</pre></div><p>This code will run along with the <code class="literal">test_no_1</code> test case. The parameter passed to the <code class="literal">BOOST_AUTO_TEST_CASE</code> macro is just a unique name of the test case that will be shown in case of error.</p><div class="informalexample"><pre class="programlisting">Running 2 test cases...
main.cpp(15): error in "test_no_1": check f1.is_not_null() failed
main.cpp(17): error in "test_no_1": check f1 != f2 failed [0 == 0]
main.cpp(19): error in "test_no_1": exception std::logic_error is expected
main.cpp(24): fatal error in "test_no_2": critical check f1 != f2 failed [0 == 0]

*** 4 failures detected in test suite "test_module_name"</pre></div><p>There is a small difference between the <code class="literal">BOOST_REQUIRE_*</code> and <code class="literal">BOOST_CHECK_*</code> macros. If the <code class="literal">BOOST_REQUIRE_*</code> macro check fails, the execution of the current test case will stop and <code class="literal">Boost.Test</code> will run the next test case. However, failing <code class="literal">BOOST_CHECK_*</code> won't stop the execution of the current test case.</p><p>Step 1 requires <a id="id706" class="indexterm"/>additional care. Note the <code class="literal">BOOST_TEST_MODULE</code> macro definition. This macro must be defined before including the <code class="literal">Boost.Test</code> headers, otherwise linking of the program will fail. More information can be found in the <span class="emphasis"><em>See also</em></span> section of this recipe.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec462"/>There's more...</h2></div></div></div><p>Some readers may wonder, "Why did we write <code class="literal">BOOST_CHECK_NE(f1, f2)</code> in step 4 instead of <code class="literal">BOOST_CHECK(f1 != f2)</code>?". The answer is simple: the macro at step 4 provides a more readable and verbose output.</p><p>C++11 lacks support for unit testing. However, the <code class="literal">Boost.Test</code> library can be used to test C++11 code. Remember that the more tests you have, the more reliable code you get!</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec463"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Combining multiple test cases in one test module</em></span> recipe contains more information about testing and the <code class="literal">BOOST_TEST_MODULE</code> macro</li><li class="listitem" style="list-style-type: disc">Refer to Boost's official documentation for a full list of test macros and information about advanced features of <code class="literal">Boost.Test</code>; it's available at the following link:<p><a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/test/doc/html/index.html">http://www.boost.org/doc/libs/1_53_0/libs/test/doc/html/index.html</a></p></li></ul></div></div></div>
<div class="section" title="Combining multiple test cases in one test module"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec114"/>Combining multiple test cases in one test module</h1></div></div></div><p>Writing auto <a id="id707" class="indexterm"/>tests is good for your project. But managing test cases is hard when the project is large and many developers are working on it. In this recipe, we'll take a look at how to run individual tests and how to combine multiple test cases in a single module.</p><p>Let's pretend that two developers are testing the <code class="literal">foo</code> structure declared in the <code class="literal">foo.hpp</code> header and we wish to give them separate source files to write a test to. In that way, the developers won't bother each other and can work in parallel. However, the default test run must execute the tests of both developers.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec464"/>Getting ready</h2></div></div></div><p>Basic knowledge of C++ is required for this recipe. This recipe partially reuses code from the previous recipe and it also requires linking against the static version of the <code class="literal">boost_unit_test_framework</code> library.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec465"/>How to do it...</h2></div></div></div><p>This recipe uses <a id="id708" class="indexterm"/>the code from the previous one. This is a very useful recipe for testing large projects; do not underestimate it.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Of all the headers in <code class="literal">main.cpp</code> from the previous recipe, leave only these two lines:<div class="informalexample"><pre class="programlisting">#define BOOST_TEST_MODULE test_module_name
#include &lt;boost/test/unit_test.hpp&gt;</pre></div></li><li class="listitem">Let's move the tests cases from the previous example into two different source files:<div class="informalexample"><pre class="programlisting">// developer1.cpp
#include &lt;boost/test/unit_test.hpp&gt;
#include "foo.hpp"
BOOST_AUTO_TEST_CASE(test_no_1) {
    // ...
}

///////////////////////////////////////////////////////////

// developer2.cpp
#include &lt;boost/test/unit_test.hpp&gt;
#include "foo.hpp"
BOOST_AUTO_TEST_CASE(test_no_2) {
    // ...
}</pre></div></li></ol></div><p>That's it! Thus compiling and linking all of the sources and both test cases will work on program execution.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec466"/>How it works...</h2></div></div></div><p>All of the magic is done by the <code class="literal">BOOST_TEST_MODULE</code> macro. If it is defined before <code class="literal">&lt;boost/test/unit_test.hpp&gt;</code>, <code class="literal">Boost.Test</code> thinks that this source file is the main one and all of the helper testing infrastructure must be placed in it. Otherwise, only the test macro will be included from <code class="literal">&lt;boost/test/unit_test.hpp&gt;</code>.</p><p>All of the <code class="literal">BOOST_AUTO_TEST_CASE</code> tests are run if you link them with the source file that contains the <code class="literal">BOOST_TEST_MODULE</code> macro<a id="id709" class="indexterm"/>. When working on a big project, each developer may<a id="id710" class="indexterm"/> enable compilation and linking of only their own sources. That gives independence from other developers and increases the speed of development—no need to compile alien sources and run alien tests while debugging.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec467"/>There's more...</h2></div></div></div><p>The <code class="literal">Boost.Test</code> library is good because of its ability to run tests selectively. We can choose which tests to run and pass them as command-line arguments. For example, the following command will run only the <code class="literal">test_no_1</code> test case:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>./testing_advanced –run=test_no_1</strong></span>
</pre></div><p>The following command will run two test cases:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>./testing_advanced –run=test_no_1,test_no_2</strong></span>
</pre></div><p>Unfortunately, C++11 standard does not have built-in testing support and it looks like C++1y won't adopt the classes and methods of <code class="literal">Boost.Test</code> either.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec468"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Writing test cases</em></span> recipe contains more information about the <code class="literal">Boost.Test</code> library. Read Boost's official documentation for more information about <code class="literal">Boost.Test</code>, at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/test/doc/html/utf.html">http://www.boost.org/doc/libs/1_53_0/libs/test/doc/html/utf.html</a>.</li><li class="listitem" style="list-style-type: disc">Brave readers can take a look at some of the test cases from the Boost library. Those test cases are allocated in the <code class="literal">libs</code> subfolder located in the <code class="literal">boost</code> folder. For example, <code class="literal">Boost.LexicalCast</code> tests cases are allocated at <code class="literal">boost_1_53_0\libs\conversion\test</code>.</li></ul></div></div></div>
<div class="section" title="Manipulating images"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec115"/>Manipulating images</h1></div></div></div><p>I've left you <a id="id711" class="indexterm"/>something really tasty for dessert – Boost's<span class="strong"><strong> Generic Image Library</strong></span> (<span class="strong"><strong>GIL</strong></span>)<a id="id712" class="indexterm"/>, which allows you to manipulate images and not care much about image formats.</p><p>Let's do something simple and interesting with it; let's make a program that negates any picture.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec469"/>Getting ready</h2></div></div></div><p>This recipe requires basic knowledge of C++, templates, and <code class="literal">Boost.Variant</code>. The example requires linking against the PNG library.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec470"/>How to do it...</h2></div></div></div><p>For simplicity<a id="id713" class="indexterm"/>, we'll be working with only PNG images.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's start with including the header files:<div class="informalexample"><pre class="programlisting">#include &lt;boost/gil/gil_all.hpp&gt;
#include &lt;boost/gil/extension/io/png_dynamic_io.hpp&gt;
#include &lt;string&gt;</pre></div></li><li class="listitem">Now we need to define the image types that we wish to work with:<div class="informalexample"><pre class="programlisting">    typedef boost::mpl::vector&lt;
            boost::gil::gray8_image_t,
            boost::gil::gray16_image_t,
            boost::gil::rgb8_image_t,
            boost::gil::rgb16_image_t
    &gt; img_types;</pre></div></li><li class="listitem">Opening an existing PNG image can be implemented like this:<div class="informalexample"><pre class="programlisting">    std::string file_name(argv[1]);
    boost::gil::any_image&lt;img_types&gt; source;
    boost::gil::png_read_image(file_name, source);</pre></div></li><li class="listitem">We need to apply the operation to the picture as follows:<div class="informalexample"><pre class="programlisting">    boost::gil::apply_operation(
        view(source),
        negate()
    );</pre></div></li><li class="listitem">The following code line will help you to write an image:<div class="informalexample"><pre class="programlisting">    boost::gil::png_write_view("negate_" + file_name, 
      const_view(source));</pre></div></li><li class="listitem">Let's take a look at the modifying operation:<div class="informalexample"><pre class="programlisting">struct negate {
    typedef void result_type; // required

    template &lt;class View&gt;
    void operator()(const View&amp; source) const {
        // ...
    }
}; // negate</pre></div></li><li class="listitem">The body of <code class="literal">operator()</code> consists of getting a channel type:<div class="informalexample"><pre class="programlisting">typedef typename View::value_type value_type;
typedef typename boost::gil::channel_type&lt;value_type&gt;::type 
    channel_t;</pre></div></li><li class="listitem">It also<a id="id714" class="indexterm"/> iterates through pixels:<div class="informalexample"><pre class="programlisting">const std::size_t channels 
    = boost::gil::num_channels&lt;View&gt;::value;
const channel_t max_val = (std::numeric_limits&lt;channel_t&gt;::max)();

for (unsigned int y = 0; y &lt; source.height(); ++y) {
    for (unsigned int x = 0; x &lt; source.width(); ++x) {
        for (unsigned int c = 0; c &lt; channels; ++c) {
            source(x, y)[c] = max_val - source(x, y)[c];
        }
    }
}</pre></div></li></ol></div><p>Now let's see the results of our program:</p><div class="mediaobject"><img src="graphics/4880OS_12_01.jpg" alt="How to do it..."/></div><p>The previous picture is the negative of the one that follows:</p><div class="mediaobject"><img src="graphics/4880OS_12_03.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec471"/>How it works...</h2></div></div></div><p>In step 2, we <a id="id715" class="indexterm"/>are describing the types of images we wish to work with. Those images are gray images with 8 and 16 bits per pixel and RGB pictures with 8 and 16 bits per pixel.</p><p>The <code class="literal">boost::gil::any_image&lt;img_types&gt;</code> class is a kind of <code class="literal">Boost.Variant</code> that can hold an image of one of the <code class="literal">img_types</code> variable. As you may have already guessed, <code class="literal">boost::gil::png_read_image</code> reads images into image variables.</p><p>The <code class="literal">boost::gil::apply_operation</code> function<a id="id716" class="indexterm"/> at step 4 is almost equal to <code class="literal">boost::apply_visitor</code> from the <code class="literal">Boost.Variant</code> library. Note the usage of <code class="literal">view(source)</code>. The <code class="literal">boost::gil::view</code> function<a id="id717" class="indexterm"/> constructs a light wrapper around the image that interprets it as a two-dimensional array of pixels.</p><p>Do you remember that for <code class="literal">Boost.Variant</code> we were deriving visitors from <code class="literal">boost::static_visitor</code>? When we are using GIL's version of variant, we need to make a <code class="literal">result_type</code> typedef inside <code class="literal">visitor</code>. You can see it in step 6.</p><p>A little bit of theory: images consist of points called pixels. Single images have pixels of the same type. However, pixels of different images can differ in channel count and color bits for a single channel. A channel represents a primary color. In the case of an RGB image, we'll have a pixel consisting of three channels—red, green, and blue. In the case of a gray image, we'll have a single channel representing gray.</p><p>Back to our image. In step 2, we described the types of images we wish to work with. In step 3, one of those image types is read from file and stored in the source variable. In step 4, the <code class="literal">operator()</code> method<a id="id718" class="indexterm"/> of the <code class="literal">negate</code> visitor is instantiated for all image types.</p><p>In step 7, we <a id="id719" class="indexterm"/>can see how to get the channel type from the image view.</p><p>In step 8, we iterate through pixels and channels and negate them. Negation is done via <code class="literal">max_val - source(x, y)[c]</code> and the result is written back to the image view.</p><p>We write an image back in step 5.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec472"/>There's more...</h2></div></div></div><p>C++11 has no built-in methods for working with images.</p><p>The <code class="literal">Boost.GIL</code> library<a id="id720" class="indexterm"/> is fast and efficient. The compilers optimize its code very well and we can even help the optimizer using some of the <code class="literal">Boost.GIL</code> methods to unroll loops. But this chapter talks about only some of the library basics, so it is time to stop.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec473"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">More information about <code class="literal">Boost.GIL</code> can be found at Boost's official documentation; go to <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/libs/gil/doc/index.html">http://www.boost.org/doc/libs/1_53_0/libs/gil/doc/index.html</a></li><li class="listitem" style="list-style-type: disc">See the <span class="emphasis"><em>Storing multiple chosen types in a variable/container</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Starting to Write Your Application">Chapter 1</a>, <span class="emphasis"><em>Starting to Write Your Application</em></span>, for more information about the <code class="literal">Boost.Variant</code> library</li></ul></div></div></div></body></html>