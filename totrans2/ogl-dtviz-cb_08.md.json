["```cpp\n    package com.android.gl3jni;\n    …\n    import android.hardware.Sensor;\n    import android.hardware.SensorEvent;\n    import android.hardware.SensorEventListener;\n    import android.hardware.SensorManager;\n    …\n    ```", "```cpp\n    public class GL3JNIActivity extends Activity implements SensorEventListener{\n    ```", "```cpp\n      …\n      private SensorManager mSensorManager;\n      private Sensor mAccelerometer;\n      private Sensor mGyro;\n      private Sensor mMag;\n    ```", "```cpp\n    @Override protected void onCreate(Bundle icicle) {\n      super.onCreate(icicle);\n      setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n\n      mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);\n      mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);\n      mGyro = mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);\n      mMag = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);\n      mView = new GL3JNIView(getApplication());\n      setContentView(mView);\n    }\n    ```", "```cpp\n    @Override protected void onPause() {\n      super.onPause();\n      mView.onPause();\n      //unregister accelerometer and other sensors\n      mSensorManager.unregisterListener(this, mAccelerometer);\n      mSensorManager.unregisterListener(this, mGyro);\n      mSensorManager.unregisterListener(this, mMag);\n    }\n\n    @Override protected void onResume() {\n      super.onResume();\n      mView.onResume();\n      /* register and activate the sensors. Start streaming data and handle with callback functions */\n      mSensorManager.registerListener(this, mAccelerometer, SensorManager.SENSOR_DELAY_GAME);\n      mSensorManager.registerListener(this, mGyro, SensorManager.SENSOR_DELAY_GAME);\n      mSensorManager.registerListener(this, mMag, SensorManager.SENSOR_DELAY_GAME);\n    }\n    ```", "```cpp\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n      //included for completeness\n    }\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n      //handle the accelerometer data\n      //All values are in SI units (m/s^2)\n      if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {\n        float ax, ay, az;\n        ax = event.values[0];\n        ay = event.values[1];\n        az = event.values[2];\n        GL3JNILib.addAccelData(ax, ay, az);\n      }\n      /* All values are in radians/second and measure the rate of rotation around the device's local X, Y, and Z axes */\n      if (event.sensor.getType() == Sensor.TYPE_GYROSCOPE) {\n        float gx, gy, gz;\n        //angular speed\n        gx = event.values[0];\n        gy = event.values[1];\n        gz = event.values[2];\n        GL3JNILib.addGyroData(gx, gy, gz);\n      }\n      //All values are in micro-Tesla (uT) and measure the ambient magnetic field in the X, Y and Z axes.\n      if (event.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD) {\n        float mx, my, mz;\n        mx = event.values[0];\n        my = event.values[1];\n        mz = event.values[2];\n        GL3JNILib.addMagData(mx, my, mz);\n      }\n    }\n    ```", "```cpp\npackage com.android.gl3jni;\n\npublic class GL3JNILib {\n  static {\n    System.loadLibrary(\"gl3jni\");\n  }\n\n  public static native void init(int width, int   height);\n  public static native void step();\n\n  public static native void addAccelData(float ax, float ay, float az);\n  public static native void addGyroData(float gx, float gy, float gz);\n  public static native void addMagData(float mx, float my, float mz);\n}\n```", "```cpp\n#ifndef SENSOR_H_\n#define SENSOR_H_\n#include <stdlib.h>\n#include <jni.h>\n#include <GLES3/gl3.h>\n#include <math.h>\n\nclass Sensor {\n  public:\n    Sensor();\n    Sensor(unsigned int size);\n    virtual ~Sensor();\n\n    //Resize buffer size dynamically with this function\n    void init(unsigned int size);\n    //Append new data to the buffer\n    void appendAccelData(GLfloat x, GLfloat y,GLfloat z);\n    void appendGyroData(GLfloat x, GLfloat y, GLfloat z);\n    void appendMagData(GLfloat x, GLfloat y, GLfloat z);\n\n    //Get sensor data buffer\n    GLfloat *getAccelDataPtr(int channel);\n    GLfloat *getGyroDataPtr(int channel);\n    GLfloat *getMagDataPtr(int channel);\n    GLfloat *getAxisPtr();\n\n    //Auto rescale factors based on max and min\n    GLfloat getAccScale();\n    GLfloat getGyroScale();\n    GLfloat getMagScale();\n\n  unsigned int getBufferSize();\n\nprivate:\n  unsigned int buffer_size;\n\n  GLfloat **accel_data;\n  GLfloat **gyro_data;\n  GLfloat **mag_data;\n  GLfloat *x_axis;\n\n  GLfloat abs_max_acc;\n  GLfloat abs_max_mag;\n  GLfloat abs_max_gyro;\n\n  void createBuffers(unsigned int size);\n  void free_all();\n\n  void findAbsMax(GLfloat *src, GLfloat *max);\n  void appendData(GLfloat *src, GLfloat data);\n  void setNormalizedAxis(GLfloat *data, unsigned int size, float min, float max);\n};\n\n#endif /* SENSOR_H_ */\n```", "```cpp\n    #include \"Sensor.h\"\n    Sensor::Sensor() {\n      //use default size\n      init(256);\n    }\n    // Initialize with different buffer size\n    Sensor::Sensor(unsigned int size) {\n      init(size);\n    }\n    Sensor::~Sensor() {\n      free_all();\n    }\n    ```", "```cpp\n    void Sensor::init(unsigned int size){\n      buffer_size = size;\n      //delete the old memory if already exist\n      free_all();\n      //allocate the memory for the buffer\n      createBuffers(size);\n      setNormalizedAxis(x_axis, size, -1.0f, 1.0f);\n      abs_max_acc = 0;\n      abs_max_gyro = 0;\n      abs_max_mag = 0;\n    }\n    ```", "```cpp\n    // Allocate memory for all sensor data buffers\n    void Sensor::createBuffers(unsigned int buffer_size){\n      accel_data = (GLfloat**)malloc(3*sizeof(GLfloat*));\n      gyro_data = (GLfloat**)malloc(3*sizeof(GLfloat*));\n      mag_data = (GLfloat**)malloc(3*sizeof(GLfloat*));\n\n      //3 channels for accelerometer\n      accel_data[0] = (GLfloat*)calloc(buffer_size,sizeof(GLfloat));\n      accel_data[1] = (GLfloat*)calloc(buffer_size,sizeof(GLfloat));\n      accel_data[2] = (GLfloat*)calloc(buffer_size,sizeof(GLfloat));\n\n      //3 channels for gyroscope\n      gyro_data[0] = (GLfloat*)calloc(buffer_size,sizeof(GLfloat));\n      gyro_data[1] = (GLfloat*)calloc(buffer_size,sizeof(GLfloat));\n      gyro_data[2] = (GLfloat*)calloc(buffer_size,sizeof(GLfloat));\n\n      //3 channels for digital compass\n      mag_data[0] = (GLfloat*)calloc(buffer_size,sizeof(GLfloat));\n      mag_data[1] = (GLfloat*)calloc(buffer_size,sizeof(GLfloat));\n      mag_data[2] = (GLfloat*)calloc(buffer_size,sizeof(GLfloat));\n\n      //x-axis precomputed\n      x_axis = (GLfloat*)calloc(buffer_size,sizeof(GLfloat));\n    }\n    ```", "```cpp\n    // Deallocate all memory\n    void Sensor::free_all(){\n      if(accel_data){\n        free(accel_data[0]);\n        free(accel_data[1]);\n        free(accel_data[2]);\n        free(accel_data);\n      }\n      if(gyro_data){\n        free(gyro_data[0]);\n        free(gyro_data[1]);\n        free(gyro_data[2]);\n        free(gyro_data);\n      }\n      if(mag_data){\n        free(mag_data[0]);\n        free(mag_data[1]);\n        free(mag_data[2]);\n        free(mag_data);\n      }\n      if(x_axis){\n        free(x_axis);\n      }\n    }\n    ```", "```cpp\n    // Append acceleration data to the buffer\n    void Sensor::appendAccelData(GLfloat x, GLfloat y, GLfloat z){\n      abs_max_acc = 0;\n      float data[3] = {x, y, z};\n      for(int i=0; i<3; i++){\n        appendData(accel_data[i], data[i]);\n        findAbsMax(accel_data[i], &abs_max_acc);\n      }\n    }\n\n    // Append the gyroscope data to the buffer\n    void Sensor::appendGyroData(GLfloat x, GLfloat y, GLfloat z){\n      abs_max_gyro = 0;\n      float data[3] = {x, y, z};\n      for(int i=0; i<3; i++){\n        appendData(gyro_data[i], data[i]);\n        findAbsMax(gyro_data[i], &abs_max_gyro);\n      }\n    }\n\n    // Append the magnetic field data to the buffer\n    void Sensor::appendMagData(GLfloat x, GLfloat y, GLfloat z){\n      abs_max_mag = 0;\n      float data[3] = {x, y, z};\n      for(int i=0; i<3; i++){\n        appendData(mag_data[i], data[i]);\n        findAbsMax(mag_data[i], &abs_max_mag);\n      }\n    }\n\n    // Append Data to the end of the buffer\n    void Sensor::appendData(GLfloat *src, GLfloat data){\n      //shift the data by one\n      int i;\n      for(i=0; i<buffer_size-1; i++){\n        src[i]=src[i+1];\n      }\n      //set the last element with the new data\n      src[buffer_size-1]=data;\n    }\n    ```", "```cpp\n    // Return the x-axis buffer\n    GLfloat* Sensor::getAxisPtr() {\n      return x_axis;\n    }\n\n    // Get the acceleration data buffer\n    GLfloat* Sensor::getAccelDataPtr(int channel) {\n      return accel_data[channel];\n    }\n\n    // Get the Gyroscope data buffer\n    GLfloat* Sensor::getGyroDataPtr(int channel) {\n      return gyro_data[channel];\n    }\n    // Get the Magnetic field data buffer\n    GLfloat* Sensor::getMagDataPtr(int channel) {\n      return mag_data[channel];\n    }\n    ```", "```cpp\n    // Return buffer size\n    unsigned int Sensor::getBufferSize() {\n      return buffer_size;\n    }\n\n    /* Return the global max for the acceleration data buffer (for rescaling and fitting purpose) */\n    GLfloat Sensor::getAccScale() {\n      return abs_max_acc;\n    }\n\n    /* Return the global max for the gyroscope data buffer (for rescaling and fitting purpose) */\n    GLfloat Sensor::getGyroScale() {\n      return abs_max_gyro;\n    }\n\n    /* Return the global max for the magnetic field data buffer (for rescaling and fitting purpose) */\n    GLfloat Sensor::getMagScale() {\n      return abs_max_mag;\n    }\n\n    // Pre-compute the x-axis for the plot\n    void Sensor::setNormalizedAxis(GLfloat *data, unsigned int size, float min, float max){\n      float step_size = (max - min)/(float)size;\n      for(int i=0; i<size; i++){\n        data[i]=min+step_size*i;\n      }\n    }\n\n    // Find the absolute maximum from the buffer\n    void Sensor::findAbsMax(GLfloat *src, GLfloat *max){\n      int i=0;\n      for(i=0; i<buffer_size; i++){\n        if(*max < fabs(src[i])){\n          *max= fabs(src[i]);\n        }\n      }\n    }\n    ```", "```cpp\n    #include <Sensor.h>\n    ...\n    ```", "```cpp\n    GLuint gProgram;\n    GLuint gxPositionHandle;\n    GLuint gyPositionHandle;\n    GLuint gColorHandle;\n    GLuint gOffsetHandle;\n    GLuint gScaleHandle;\n    static Sensor g_sensor_data;\n    ```", "```cpp\n    // Vertex shader source code\n    static const char g_vshader_code[] = \"#version 300 es\\n\"\n      \"in float yPosition;\\n\"\n      \"in float xPosition;\\n\"\n      \"uniform float scale;\\n\"\n      \"uniform float offset;\\n\"\n      \"void main() {\\n\"\n        \"  vec4 position = vec4(xPosition, yPosition*scale+offset, 0.0, 1.0);\\n\"\n        \"  gl_Position = position;\\n\"\n      \"}\\n\";\n\n    // fragment shader source code\n    static const char g_fshader_code[] = \"#version 300 es\\n\"\n      \"precision mediump float;\\n\"\n      \"uniform vec4 color;\\n\"\n      \"out vec4 color_out;\\n\"\n      \"void main() {\\n\"\n        \"  color_out = color;\\n\"\n      \"}\\n\";\n    ```", "```cpp\n    bool setupGraphics(int w, int h) {\n\n      ...\n\n      gxPositionHandle = glGetAttribLocation(gProgram,\"xPosition\");\n      checkGlError(\"glGetAttribLocation\");\n      LOGI(\"glGetAttribLocation(\\\"vPosition\\\") = %d\\n\", gxPositionHandle);\n\n      gyPositionHandle = glGetAttribLocation(gProgram,   \"yPosition\");\n      checkGlError(\"glGetAttribLocation\");\n      LOGI(\"glGetAttribLocation(\\\"vPosition\\\") = %d\\n\", gyPositionHandle);\n\n      gColorHandle = glGetUniformLocation(gProgram, \"color\");\n      checkGlError(\"glGetUniformLocation\");\n      LOGI(\"glGetUniformLocation(\\\"color\\\") = %d\\n\", gColorHandle);\n\n      gOffsetHandle = glGetUniformLocation(gProgram, \"offset\");\n      checkGlError(\"glGetUniformLocation\");\n      LOGI(\"glGetUniformLocation(\\\"offset\\\") = %d\\n\", gOffsetHandle);\n\n      gScaleHandle = glGetUniformLocation(gProgram, \"scale\");\n      checkGlError(\"glGetUniformLocation\");\n      LOGI(\"glGetUniformLocation(\\\"scale\\\") = %d\\n\", gScaleHandle);\n\n      glViewport(0, 0, w, h);\n      width = w;\n      height = h;\n\n      checkGlError(\"glViewport\");\n\n      return true;\n    }\n    ```", "```cpp\n    void draw2DPlot(GLfloat *data, unsigned int size, GLfloat scale, GLfloat offset){\n      glVertexAttribPointer(gyPositionHandle, 1, GL_FLOAT, GL_FALSE, 0, data);\n      checkGlError(\"glVertexAttribPointer\");\n\n      glEnableVertexAttribArray(gyPositionHandle);\n      checkGlError(\"glEnableVertexAttribArray\");\n\n      glUniform1f(gOffsetHandle, offset);\n      checkGlError(\"glUniform1f\");\n\n      glUniform1f(gScaleHandle, scale);\n      checkGlError(\"glUniform1f\");\n\n      glDrawArrays(GL_LINE_STRIP, 0, g_sensor_data.getBufferSize());\n      checkGlError(\"glDrawArrays\");\n    }\n    ```", "```cpp\n    void renderFrame() {\n      glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n      checkGlError(\"glClearColor\");\n\n      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n      checkGlError(\"glClear\");\n\n      glUseProgram(gProgram);\n      checkGlError(\"glUseProgram\");\n\n      glVertexAttribPointer(gxPositionHandle, 1, GL_FLOAT, GL_FALSE, 0, g_sensor_data.getAxisPtr());\n      checkGlError(\"glVertexAttribPointer\");\n\n      glEnableVertexAttribArray(gxPositionHandle);\n      checkGlError(\"glEnableVertexAttribArray\");\n\n      //Obtain the scaling factor based on the dataset\n      //0.33f for 1/3 of the screen for each graph\n      float acc_scale = 0.33f/g_sensor_data.getAccScale();\n      float gyro_scale = 0.33f/g_sensor_data.getGyroScale();\n      float mag_scale = 0.33f/g_sensor_data.getMagScale();\n\n      glLineWidth(4.0f);\n\n      //set the rendering color\n      glUniform4f(gColorHandle, 1.0f, 0.0f, 0.0f, 1.0f);\n      checkGlError(\"glUniform1f\");\n      /* Render the accelerometer, gyro, and digital compass data. As the vertex shader does not use any projection matrix, every visible vertex has to be in the range of [-1, 1].  0.67f, 0.0f, and -0.67f define the vertical positions of each graph */\n      draw2DPlot(g_sensor_data.getAccelDataPtr(0), g_sensor_data.getBufferSize(), acc_scale, 0.67f);\n      draw2DPlot(g_sensor_data.getGyroDataPtr(0), g_sensor_data.getBufferSize(), gyro_scale, 0.0f);\n      draw2DPlot(g_sensor_data.getMagDataPtr(0), g_sensor_data.getBufferSize(), mag_scale, -0.67f);\n\n      glUniform4f(gColorHandle, 0.0f, 1.0f, 0.0f, 1.0f);\n      checkGlError(\"glUniform1f\");\n      draw2DPlot(g_sensor_data.getAccelDataPtr(1), g_sensor_data.getBufferSize(), acc_scale, 0.67f);\n      draw2DPlot(g_sensor_data.getGyroDataPtr(1), g_sensor_data.getBufferSize(), gyro_scale, 0.0f);\n      draw2DPlot(g_sensor_data.getMagDataPtr(1), g_sensor_data.getBufferSize(), mag_scale, -0.67f);\n\n      glUniform4f(gColorHandle, 0.0f, 0.0f, 1.0f, 1.0f);\n      checkGlError(\"glUniform1f\");\n      draw2DPlot(g_sensor_data.getAccelDataPtr(2), g_sensor_data.getBufferSize(), acc_scale, 0.67f);\n      draw2DPlot(g_sensor_data.getGyroDataPtr(2), g_sensor_data.getBufferSize(), gyro_scale, 0.0f);\n      draw2DPlot(g_sensor_data.getMagDataPtr(2), g_sensor_data.getBufferSize(), mag_scale, -0.67f);\n    }\n    ```", "```cpp\n    //external calls for Java\n    extern \"C\" {\n      JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_init(JNIEnv * env, jobject obj, jint width, jint height);\n      JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_step(JNIEnv * env, jobject obj);\n      JNIEXPORT void JNICALL\n        Java_com_android_gl3jni_GL3JNILib_addAccelData\n       (JNIEnv * env, jobject obj, jfloat ax, jfloat ay, jfloat az);\n      JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_addGyroData (JNIE nv * env, jobject obj, jfloat gx, jfloat gy, jfloat gz);\n      JNIEXPORT void JNICALL \n    Java_com_android_gl3jni_GL3JNILib_addMagData\n    (JNIEnv * env, jobject obj, jfloat mx, jfloat my, jfloat mz)\n    {\n      g_sensor_data.appendMagData(mx, my, mz);\n    }\n    };\n\n    //link to internal calls\n    JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_init(JNIEnv * env, jobject obj,  jint width, jint height)\n    {\n      setupGraphics(width, height);\n    }\n    JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_step(JNIEnv * env, jobject obj)\n    {\n      renderFrame();\n    }\n    JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_addAccelData(JNIEnv * env, jobject obj,  jfloat ax, jfloat ay, jfloat az){\n      g_sensor_data.appendAccelData(ax, ay, az);\n    }\n    JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_addGyroData(JNIEnv * env, jobject obj,  jfloat gx, jfloat gy, jfloat gz){\n      g_sensor_data.appendGyroData(gx, gy, gz);\n    }\n    JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_addMagData(JNIEnv * env, jobject obj,  jfloat mx, jfloat my, jfloat mz){\n      g_sensor_data.appendMagData(mx, my, mz);\n    }\n    ```", "```cpp\n    public class GL3JNIActivity extends Activity implements SensorEventListener{\n      GL3JNIView mView;\n      private SensorManager mSensorManager;\n      private Sensor mRotate;\n      private float[] mRotationMatrix=new float[16];\n      private float[] orientationVals=new float[3];\n    ```", "```cpp\n    @Override protected void onCreate(Bundle icicle) {\n      super.onCreate(icicle);\n      //lock the screen orientation for this demo\n      //otherwise the canvas will rotate\n      setRequestedOrientation (ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n\n      mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);\n        //TYPE_ROTATION_VECTOR for device orientation\n        mRotate = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);\n\n        mView = new GL3JNIView(getApplication());\n        setContentView(mView);\n    }\n    ```", "```cpp\n    @Override protected void onResume() {\n      super.onResume();\n      mView.onResume();\n      mSensorManager.registerListener(this, mRotate, SensorManager.SENSOR_DELAY_GAME);\n    }\n    ```", "```cpp\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n      if (event.sensor.getType() == Sensor.TYPE_ROTATION_VECTOR){\n        SensorManager.getRotationMatrixFromVector (mRotationMatrix,event.values);\n        SensorManager.getOrientation (mRotationMatrix, orientationVals);\n        GL3JNILib.addRotData(orientationVals[0], orientationVals[1],orientationVals[2]);\n      }\n    }\n    ```", "```cpp\n    package com.android.gl3jni;\n    ...\n    import android.view.MotionEvent;\n    import android.view.ScaleGestureDetector;\n    ...\n    ```", "```cpp\n    class GL3JNIView extends GLSurfaceView {\n      private ScaleGestureDetector mScaleDetector;\n      ...\n\n      public GL3JNIView(Context context) {\n        super(context);\n        ...\n        //handle gesture input\n        mScaleDetector = new ScaleGestureDetector (context, new ScaleListener());\n      }\n    ```", "```cpp\n    @Override\n    public boolean onTouchEvent(MotionEvent ev) {\n      // Let ScaleGestureDetector inspect all events.\n      mScaleDetector.onTouchEvent(ev);\n      return true;\n    }\n    ```", "```cpp\n    private class ScaleListener extends ScaleGestureDetector.SimpleOnScaleGestureListener {\n      private float mScaleFactor = 1.f;\n      @Override\n      public boolean onScale(ScaleGestureDetector detector) \n      {\n        //scaling factor\n        mScaleFactor *= detector.getScaleFactor();\n        //Don't let the object get too small/too large.\n        mScaleFactor = Math.max(0.1f, Math.min(mScaleFactor, 5.0f));\n        invalidate();\n        GL3JNILib.setScale(mScaleFactor);\n        return true;\n      }\n    }\n    ```", "```cpp\npackage com.android.gl3jni;\n\npublic class GL3JNILib {\n  static {\n    System.loadLibrary(\"gl3jni\");\n  }\n\n  public static native void init(int width, int height);\n  public static native void step();\n\n  /* pass the rotation angles and scaling factor to the native code */\n  public static native void addRotData(float rx, float ry, float rz);\n  public static native void setScale(float scale);\n}\n```", "```cpp\n    #define GLM_FORCE_RADIANS\n\n    //header for JNI\n    #include <jni.h>\n    ...\n\n    //header for GLM library\n    #include <glm/glm.hpp>\n    #include <glm/gtc/matrix_transform.hpp>\n    ```", "```cpp\n    //shader program handlers\n    GLuint gProgram;\n    GLuint gvPositionHandle;\n    GLuint matrixHandle;\n    GLuint sigmaHandle;\n    GLuint scaleHandle;\n    ```", "```cpp\n    //the view matrix and projection matrix\n    glm::mat4 g_view_matrix;\n    glm::mat4 g_projection_matrix;\n\n    //initial position of the camera\n    glm::vec3 g_position = glm::vec3( 0, 0, 4 );\n\n    //FOV of the camera\n    float g_initial_fov = glm::pi<float>()*0.25f;\n    //rotation angles, set by sensors or by touch screen\n    float rx, ry, rz;\n    float scale=1.0f; \n    //vertices for the grid\n    const unsigned int GRID_SIZE=400;\n    GLfloat gGrid[GRID_SIZE*GRID_SIZE*3]={0};\n    ```", "```cpp\n    // Vertex shader source code\n    static const char g_vshader_code[] = \n      \"#version 300 es\\n\"\n        \"in vec4 vPosition;\\n\"\n        \"uniform mat4 MVP;\\n\"\n      \"uniform float sigma;\\n\"\n      \"uniform float scale;\\n\"\n        \"out vec4 color_based_on_position;\\n\"\n        \"// Heat map generator                \\n\"\n        \"vec4 heatMap(float v, float vmin, float vmax){\\n\"\n        \"    float dv;\\n\"\n        \"    float r=1.0, g=1.0, b=1.0;\\n\"\n        \"  if (v < vmin){\\n\"\n        \"    v = vmin;}\\n\"\n        \"  if (v > vmax){\\n\"\n        \"    v = vmax;}\\n\"\n        \"  dv = vmax - vmin;\\n\"\n        \"  if (v < (vmin + 0.25 * dv)) {\\n\"\n        \"    r = 0.0;\\n\"\n        \"    g = 4.0 * (v - vmin) / dv;\\n\"\n        \"  } else if (v < (vmin + 0.5 * dv)) {\\n\"\n        \"    r = 0.0;\\n\"\n        \"    b = 1.0 + 4.0 * (vmin + 0.25 * dv - v) /   dv;\\n\"\n        \"  } else if (v < (vmin + 0.75 * dv)) {\\n\"\n        \"    r = 4.0 * (v - vmin - 0.5 * dv) / dv;\\n\"\n        \"    b = 0.0;\\n\"\n        \"  } else {\\n\"\n        \"    g = 1.0 + 4.0 * (vmin + 0.75 * dv - v) /   dv;\\n\"\n        \"    b = 0.0;\\n\"\n        \"  }\\n\"\n        \"    return vec4(r, g, b, 0.1);\\n\"\n        \"}\\n\"\n        \"void main() {\\n\"\n      \"  //Simulation on GPU \\n\"\n        \"  float x_data = vPosition.x;\\n\"\n        \"  float y_data = vPosition.y;\\n\"\n        \"  float sigma2 = sigma*sigma;\\n\"\n        \"  float z = exp(-0.5*(x_data*x_data)/(sigma2)-0.5*(y_data*y_data)/(sigma2));\\n\"\n        \"  vec4 position = vPosition;\\n\"\n      // scale the graphics based on user gesture input\n      \"  position.z = z*scale;\\n\"\n      \"  position.x = position.x*scale;\\n\"\n      \"  position.y = position.y*scale;\\n\"\n      \"  gl_Position = MVP*position;\\n\"\n        \"  color_based_on_position = heatMap(position.z, 0.0, 0.5);\\n\"\n      \"  gl_PointSize = 5.0*scale;\\n\"\n        \"}\\n\";\n\n    // fragment shader source code\n    static const char g_fshader_code[] =\n      \"#version 300 es\\n\"\n        \"precision mediump float;\\n\"\n        \"in vec4 color_based_on_position;\\n\"\n      \"out vec4 color;\\n\"\n        \"void main() {\\n\"\n        \"  color = color_based_on_position;\\n\"\n        \"}\\n\";\n    ```", "```cpp\n    void computeGrid(){\n      float grid_x = GRID_SIZE;\n      float grid_y = GRID_SIZE;\n      unsigned int data_counter = 0;\n      //define a grid ranging from -1 to +1\n      for(float x = -grid_x/2.0f; x<grid_x/2.0f; x+=1.0f){\n        for(float y = -grid_y/2.0f; y<grid_y/2.0f; y+=1.0f){\n          float x_data = 2.0f*x/grid_x;\n          float y_data = 2.0f*y/grid_y;\n          gGrid[data_counter] = x_data;\n          gGrid[data_counter+1] = y_data;\n          gGrid[data_counter+2] = 0;\n          data_counter+=3;\n        }\n      }\n    }\n    ```", "```cpp\n    void setAngles(float irx, float iry, float irz){\n      rx = irx;\n      ry = iry;\n      rz = irz;\n    }\n    ```", "```cpp\n    void computeProjectionMatrices(){\n      //direction vector for z \n      glm::vec3 direction_z(0, 0, -1.0);\n      //up vector\n      glm::vec3 up = glm::vec3(0,-1,0);\n\n      float aspect_ratio = (float)width/(float)height;\n      float nearZ = 0.1f;\n      float farZ = 100.0f;\n      float top = tan(g_initial_fov/2*nearZ);\n      float right = aspect_ratio*top;\n      float left = -right;\n      float bottom = -top;\n      g_projection_matrix = glm::frustum(left, right, bottom, top, nearZ, farZ);\n\n      // update the view matrix\n      g_view_matrix = glm::lookAt( \n        g_position,             // camera position\n        g_position+direction_z, // view direction\n        up                      // up direction\n      );\n    }\n    ```", "```cpp\n    bool setupGraphics(int w, int h) {\n      ...\n      gvPositionHandle = glGetAttribLocation(gProgram, \"vPosition\");\n      checkGlError(\"glGetAttribLocation\");\n      LOGI(\"glGetAttribLocation(\\\"vPosition\\\") = %d\\n\", gvPositionHandle);\n\n      matrixHandle = glGetUniformLocation(gProgram, \"MVP\");\n      checkGlError(\"glGetUniformLocation\");\n      LOGI(\"glGetUniformLocation(\\\"MVP\\\") = %d\\n\", matrixHandle);\n\n      sigmaHandle = glGetUniformLocation(gProgram, \"sigma\");\n      checkGlError(\"glGetUniformLocation\");\n      LOGI(\"glGetUniformLocation(\\\"sigma\\\") = %d\\n\", sigmaHandle);\n\n      scaleHandle = glGetUniformLocation(gProgram, \"scale\");\n      checkGlError(\"glGetUniformLocation\");\n      LOGI(\"glGetUniformLocation(\\\"scale\\\") = %d\\n\", scaleHandle);\n\n      ...\n\n      computeGrid();\n      return true;\n    }\n    ```", "```cpp\n    void renderFrame() {\n      glEnable(GL_BLEND);\n      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\n      static float sigma;\n\n      //update the variables for animations\n      sigma+=0.002f;\n      if(sigma>0.5f){\n        sigma = 0.002f;\n      }\n\n      /* gets the View and Model Matrix and apply to the rendering */\n      computeProjectionMatrices();\n      glm::mat4 projection_matrix = g_projection_matrix;\n      glm::mat4 view_matrix = g_view_matrix;\n      glm::mat4 model_matrix = glm::mat4(1.0);\n      model_matrix = glm::rotate(model_matrix, rz, glm::vec3(-1.0f, 0.0f, 0.0f));\n      model_matrix = glm::rotate(model_matrix, ry, glm::vec3(0.0f, -1.0f, 0.0f));\n      model_matrix = glm::rotate(model_matrix, rx, glm::vec3(0.0f, 0.0f, 1.0f));\n      glm::mat4 mvp = projection_matrix * view_matrix * model_matrix;\n\n      glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n      checkGlError(\"glClearColor\");\n\n      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n      checkGlError(\"glClear\");\n\n      glUseProgram(gProgram);\n      checkGlError(\"glUseProgram\");\n\n      glUniformMatrix4fv(matrixHandle, 1, GL_FALSE, &mvp[0][0]);\n      checkGlError(\"glUniformMatrix4fv\");\n\n      glUniform1f(sigmaHandle, sigma);\n      checkGlError(\"glUniform1f\");\n\n      glUniform1f(scaleHandle, scale);\n      checkGlError(\"glUniform1f\");\n\n      glVertexAttribPointer(gvPositionHandle, 3, GL_FLOAT, GL_FALSE, 0, gGrid);\n      checkGlError(\"glVertexAttribPointer\");\n\n      glEnableVertexAttribArray(gvPositionHandle);\n      checkGlError(\"glEnableVertexAttribArray\");\n\n      glDrawArrays(GL_POINTS, 0, GRID_SIZE*GRID_SIZE);\n      checkGlError(\"glDrawArrays\");\n    }\n    ```", "```cpp\n    extern \"C\" {\n      JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_init(JNIEnv * env, jobject obj, jint width, jint height);\n      JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_step(JNIEnv * env, jobject obj);\n      JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_addRotData(JNIEnv * env, jobject obj, jfloat rx, jfloat ry, jfloat rz);\n      JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_setScale(JNIEnv * env, jobject obj,  jfloat jscale);\n    };\n    ```", "```cpp\n    JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_init(JNIEnv * env, jobject obj,  jint width, jint height)\n    {\n      setupGraphics(width, height);\n    }\n    JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_step(JNIEnv * env, jobject obj)\n    {\n      renderFrame();\n    }\n    JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_addRotData(JNIEnv * env, jobject obj, jfloat rx, jfloat ry, jfloat rz)\n    {\n      setAngles(rx, ry, rz);\n    }\n    JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_setScale(JNIEnv * env, jobject obj, jfloat jscale)\n    {\n      scale = jscale;\n      LOGI(\"Scale is %lf\", scale);\n    }\n    ```", "```cpp\n    LOCAL_PATH:= $(call my-dir)\n\n    include $(CLEAR_VARS)\n\n    LOCAL_MODULE    := libgl3jni\n    LOCAL_CFLAGS    := -Werror\n    LOCAL_SRC_FILES := main.cpp\n    LOCAL_LDLIBS    := -llog -lGLESv3\n    #The GLM library is installed in one of these two folders by default\n    LOCAL_C_INCLUDES := /opt/local/include /usr/local/include \n\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```cpp\n    APP_ABI := armeabi-v7a\n    #required for GLM and other static libraries\n    APP_STL := gnustl_static\n    ```", "```cpp\n    #!/bin/bash\n    ANDROID_SDK_PATH=\"../../../3rd_party/android/android-sdk-macosx\"\n    ANDROID_NDK_PATH=\"../../../3rd_party/android/android-ndk-r10e\"\n\n    $ANDROID_SDK_PATH/tools/android update project -p . -s --target \"android-18\"\n    $ANDROID_NDK_PATH/ndk-build\n    ant debug\n\n    ```", "```cpp\n    ANDROID_SDK_PATH=\"../../../3rd_party/android/android-sdk-macosx\"\n    $ANDROID_SDK_PATH/platform-tools/adb install -r bin/GL3JNIActivity-debug.apk\n\n    ```"]