<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Regular Expressions</h1>
                
            
            
                
<p class="calibre2">In the previous chapter, we learned all about formatted input and output in C++. We saw that there are good solutions for formatted output--as long as you make sure you're in the <kbd class="calibre12">C</kbd> locale--but that despite the many approaches to input parsing, even the simple task of parsing an <kbd class="calibre12">int</kbd> out of a string can be quite difficult. (Recall that of the two most foolproof methods, <kbd class="calibre12">std::stoi(x)</kbd> requires converting <kbd class="calibre12">x</kbd> to a heap-allocated <kbd class="calibre12">std::string</kbd>, and the verbose <kbd class="calibre12">std::from_chars(x.begin(), x.end(), &amp;value, 10)</kbd> is lagging the rest of C++17 in vendor adoption.) The fiddliest part of parsing numbers is figuring out what to do with the part of the input that <em class="calibre22">isn't</em> numeric!</p>
<p class="calibre2">Parsing gets easier if you can split it into two subtasks: First, figure out exactly how many bytes of the input correspond to one "input item" (this is called <em class="calibre22">lexing</em>); and second, parse the value of that item, with some error recovery in the case that the item's value is out of range or otherwise nonsensical. If we apply this approach to integer input, <em class="calibre22">lexing</em> corresponds to finding the longest initial sequence of digits in the input, and <em class="calibre22">parsing</em> corresponds to computing the numeric value of that sequence in base 10.</p>
<p class="calibre2"><em class="calibre22">Regular expressions</em> (or <em class="calibre22">regexes</em>) is a tool provided by many programming languages that solve the lexing problem, not just for sequences of digits but for arbitrarily complicated input formats. Regular expressions have been part of the C++ standard library since 2011, in the <kbd class="calibre12">&lt;regex&gt;</kbd> header. In this chapter we'll show you how to use regexes to simplify some common parsing tasks.</p>
<p class="calibre2">Bear in mind that regexes are likely to be overkill for <em class="calibre22">most</em> parsing tasks that you'll face in your daily work. They can be slow and bloated, and unavoidably require heap allocation (that is, the regex data types are not <em class="calibre22">allocator-aware</em> as described in <a href="part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 8</a>, <em class="calibre22">Allocators</em>). Where regexes really shines is for complicated tasks where hand-written parsing code would be just as slow anyway; and for extremely simple tasks where the readability and robustness of regular expressions outweigh their performance costs. In short, regex support has taken C++ one step closer to the everyday usability of scripting languages such as Python and Perl.</p>
<p class="calibre2">In this chapter we'll learn:</p>
<ul class="calibre14">
<li class="calibre15">"Modified ECMAScript", the dialect used by C++ regexes</li>
<li class="calibre15">How to match, search, and even replace substrings using regexes</li>
<li class="calibre15">Further dangers of dangling iterators</li>
<li class="calibre15">Regex features to avoid</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">What are regular expressions?</h1>
                
            
            
                
<p class="calibre2">A <em class="calibre22">regular expression</em> is a way of writing down the rules for recognizing a string of bytes or characters as belonging (or not belonging) to a certain "language." In this context, a "language" can be anything from "the set of all digit-sequences" to "the set of all sequences of valid C++ tokens." Essentially, a "language" is just a rule for dividing the world of all strings into two sets--the set of strings matching the rules of the language, and the set of strings that <em class="calibre22">don't</em> match.</p>
<p class="calibre2">Some kinds of languages follow simple enough rules that they can be recognized by a <em class="calibre22">finite state machine</em>, a computer program with no memory at all--just a program counter and a pointer that scans over the input in a single pass. The language of "digit-sequences" is certainly in the category of languages that can be recognized by a finite state machine. We call these languages <em class="calibre22">regular languages</em>.</p>
<p class="calibre2">There also exist non-regular languages. One very common non-regular language is "valid arithmetic expressions," or, to boil it down to its essence, "properly matched parentheses." Any program that can distinguish the properly matched string <kbd class="calibre12">(((())))</kbd> from the improperly matched strings <kbd class="calibre12">(((()))</kbd> and <kbd class="calibre12">(((()))))</kbd> must essentially be able to "count"--to distinguish the case of <em class="calibre22">four</em> parentheses from the cases of <em class="calibre22">three</em> or <em class="calibre22">five</em>. Counting in this way cannot be done without a modifiable variable or a push-down stack; so parenthesis-matching is <em class="calibre22">not</em> a regular language.</p>
<p class="calibre2">It turns out that, given any regular language, there is a nice straightforward way to write a representation of the finite state machine that recognizes it, which of course is also a representation of the rules of the language itself. We call this representation a <em class="calibre22">regular expression</em>, or <em class="calibre22">regex</em>. The standard notation for regexes was developed in the 1950s, and was really set in stone by the late 1970s in Unix programs such as <kbd class="calibre12">grep</kbd> and <kbd class="calibre12">sed</kbd>--programs which are still very much worth learning today, but which are of course outside the scope of this book.</p>
<p class="calibre2">The C++ standard library offers several different "flavors" of regex syntax, but the default flavor (and the one you should always use) was borrowed wholesale from the standard for ECMAScript--the language better known as JavaScript--with only minor modifications in the vicinity of square-bracket constructs. I've included a primer on ECMAScript regex syntax near the end of this chapter; but if you've ever used <kbd class="calibre12">grep</kbd>, you'll be able to follow the rest of this chapter easily without consulting that section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A note on backslash-escaping</h1>
                
            
            
                
<p class="calibre2">In this chapter, we'll be referring frequently to strings and regular expressions that contain literal backslashes. As you know, to write a string containing a literal backslash in C++, you have to <em class="calibre22">escape</em> the backslash with another backslash: thus <kbd class="calibre12">"\n"</kbd> represents a newline character but <kbd class="calibre12">"\\n"</kbd> represents the two-character string of "backslash" followed by "n". This kind of thing is usually easy to keep track of, but in this chapter we're going to have to take special pains. Regexes are implemented purely as a library feature; so when you write <kbd class="calibre12">std::regex("\n")</kbd> the regex library will see a "regex" containing only a single whitespace character, and if you write <kbd class="calibre12">std::regex("\\n")</kbd> the library will see a two-character string starting with a backslash, which <em class="calibre22">the library will interpret</em> as a two-character escape sequence meaning "newline." If you want to communicate the idea of a <em class="calibre22">literal</em> backslash-n to the regex library, you'll have to get the regex library to see the three-character string <kbd class="calibre12">\\\\n</kbd>, which means writing the five-character string <kbd class="calibre12">"\\\\n"</kbd> in your C++ source code.</p>
<p class="calibre2">You might have noticed in the preceding paragraph the solution I'm going to be using in this chapter. When I talk about a <em class="calibre22">C++ string literal</em> or string value, I will put it in double quotes, like this: <kbd class="calibre12">"cat"</kbd>, <kbd class="calibre12">"a\\.b"</kbd>. When I talk about a <em class="calibre22">regular expression</em> as you would type it in an email or a text editor, or hand it to the library for evaluation, I will express it without quotes: <kbd class="calibre12">cat</kbd>, <kbd class="calibre12">a\.b</kbd>. Just remember that when you see an unquoted string, that's a literal sequence of characters, and if you want to put it into a C++ string literal, you'll need to double up all the backslashes, thus: <kbd class="calibre12">a\.b</kbd> goes into your source code as <kbd class="calibre12">std::regex("a\\.b")</kbd>.</p>
<p class="calibre2">I hear some of you asking: What about <em class="calibre22">raw string literals</em>? Raw string literals are a C++11 feature that allows you to write the character sequence <kbd class="calibre12">a\.b</kbd> by "escaping" the entire string with an <kbd class="calibre12">R</kbd> and some parentheses, like this--<kbd class="calibre12">R"(a\.b)"</kbd>--instead of escaping each backslash in the string. If your string contains parentheses itself, then you can get fancier by writing any arbitrary string before the first parenthesis and after the last, like this: <kbd class="calibre12">R"fancy(a\.b)fancy"</kbd>. A raw string literal like this one is allowed to contain any characters--backslashes, quotation marks, even newlines--as long as it doesn't contain the consecutive sequence <kbd class="calibre12">)fancy"</kbd> (and if you think there's a chance it might contain that sequence, then you just pick a new arbitrary string, such as <kbd class="calibre12">)supercalifragilisticexpialidocious"</kbd>).</p>
<p class="calibre2">The syntax of C++ raw string literals, with its leading <kbd class="calibre12">R</kbd>, is reminiscent of the raw string literal syntax in Python (with its leading <kbd class="calibre12">r</kbd>). In Python, <kbd class="calibre12">r"a\.b"</kbd> similarly represents the literal string <kbd class="calibre12">a\.b</kbd>; and it is both common and idiomatic to represent regular expressions in code by strings such as <kbd class="calibre12">r"abc"</kbd> even if they don't contain any special characters. But notice the all-important difference between <kbd class="calibre12">r"a\.b"</kbd> and <kbd class="calibre12">R"(a\.b)"</kbd>--the C++ version has an extra set of parentheses! And parentheses are <em class="calibre22">significant special characters</em> in the regex grammar. The C++ string literals <kbd class="calibre12">"(cat)"</kbd> and <kbd class="calibre12">R"(cat)"</kbd> are as different as night and day--the former represents the five-character regex <kbd class="calibre12">(cat)</kbd>, and the latter represents the three-character regex <kbd class="calibre12">cat</kbd>. If you trip up and write <kbd class="calibre12">R"(cat)"</kbd> when you meant <kbd class="calibre12">"(cat)"</kbd> (or equivalently, <kbd class="calibre12">R"((cat))"</kbd>), your program will have a very subtle bug. Even more sadistically, <kbd class="calibre12">R"a*(b*)a*"</kbd> is a valid regex with a surprising meaning! Therefore, I recommend that you use raw string literals for regexes with great caution; generally it is safer and clearer to double <em class="calibre22">all</em> your backslashes than to worry about doubling only the <em class="calibre22">outermost</em> of your parentheses.</p>
<p class="calibre2">Where raw string literals <em class="calibre22">are</em> useful is for what other languages call "heredocs":</p>
<pre class="calibre23">    void print_help() {<br class="title-page-name"/>      puts(R"(The regex special characters are:<br class="title-page-name"/>      \ - escaping<br class="title-page-name"/>      | - separating alternatives<br class="title-page-name"/>      . - match any character<br class="title-page-name"/>      [] - character class or set<br class="title-page-name"/>      () - capturing parentheses, or lookahead<br class="title-page-name"/>      ?*+ - "zero or one", "zero or more", "one or more"<br class="title-page-name"/>      {} - "exactly N" or "M to N" repetitions<br class="title-page-name"/>      ^$ - beginning and end of a "line"<br class="title-page-name"/>      \b - word boundary<br class="title-page-name"/>      \d \s \w - digit, space, and word<br class="title-page-name"/>      (?=foo) (?!foo) - lookahead; negative lookahead<br class="title-page-name"/>    )");</pre>
<p class="calibre2">That is, raw string literals are the only kind of string literal in C++ that can encode newline characters without any kind of escaping. This is useful for printing long messages to the user, or maybe for things such as HTTP headers; but raw strings' behavior with parentheses makes them mildly dangerous for use with regular expressions--I will not be using them in this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Reifying regular expressions into std::regex objects</h1>
                
            
            
                
<p class="calibre2">To use regular expressions in C++, you can't use a string such as <kbd class="calibre12">"c[a-z]*t"</kbd> directly. Instead, you have to use that string to construct a <em class="calibre22">regular expression object</em> of type <kbd class="calibre12">std::regex</kbd>, and then pass the <kbd class="calibre12">regex</kbd> object as one of the arguments to a <em class="calibre22">matching function</em> such as <kbd class="calibre12">std::regex_match</kbd>, <kbd class="calibre12">std::regex_search</kbd>, or <kbd class="calibre12">std::regex_replace</kbd>. Each object of type <kbd class="calibre12">std::regex</kbd> encodes a complete finite state machine for the given expression, and constructing this finite state machine requires a lot of computation and memory allocation; so if we are going to match a lot of input text against the same regex, it is convenient that the library gives us a way to pay for that expensive construction just once. On the other hand, this means that the <kbd class="calibre12">std::regex</kbd> objects are relatively slow to construct and expensive to copy; constructing a regex inside a tight inner loop is a good way to kill your program's performance:</p>
<pre class="calibre23">    std::regex rx("(left|right) ([0-9]+)");<br class="title-page-name"/>    // Construct the regex object "rx" outside the loop.<br class="title-page-name"/>    std::string line;<br class="title-page-name"/>    while (std::getline(std::cin, line)) {<br class="title-page-name"/>      // Inside the loop, use the same "rx" over and over.<br class="title-page-name"/>      if (std::regex_match(line, rx)) {<br class="title-page-name"/>        process_command(line);<br class="title-page-name"/>      } else {<br class="title-page-name"/>        puts("Unrecognized command.");<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">Keep in mind that this <kbd class="calibre12">regex</kbd> object has value semantics; when we "match" an input string against a regex, we aren't mutating the <kbd class="calibre12">regex</kbd> object itself. A regex has no memory of what it's been matched against. Therefore, when we want to pull information out of a regex-matching operation--such as "did the command say to move left or right? what was the number we saw?"--we'll have to introduce a new entity that we can mutate.</p>
<p class="calibre2">A <kbd class="calibre12">regex</kbd> object offers the following methods:</p>
<p class="calibre2"><kbd class="calibre12">std::regex(str, flags)</kbd> constructs a new <kbd class="calibre12">std::regex</kbd> object by translating (or "compiling") the given <kbd class="calibre12">str</kbd> into a finite state machine. Options affecting the compilation process itself can be specified via the bitmask argument <kbd class="calibre12">flags</kbd>:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre12">std::regex::icase</kbd>: Treat all alphabetic characters as case-insensitive</li>
<li class="calibre15"><kbd class="calibre12">std::regex::nosubs</kbd>: Treat all parenthesized groups as non-capturing</li>
<li class="calibre15"><kbd class="calibre12">std::regex::multiline</kbd>: Make the non-consuming assertion <kbd class="calibre12">^</kbd> (and <kbd class="calibre12">$</kbd>) match immediately after (and before) a <kbd class="calibre12">"\n"</kbd> character in the input, rather than only at the beginning (and end) of the input</li>
</ul>
<p class="calibre2">There are several other options that you could bitwise-OR into flags; but the others either change the "flavor" of regex syntax away from ECMAScript towards less well-documented and less well-tested flavors (<kbd class="calibre12">basic</kbd>, <kbd class="calibre12">extended</kbd>, <kbd class="calibre12">awk</kbd>, <kbd class="calibre12">grep</kbd>, <kbd class="calibre12">egrep</kbd>), introduce locale dependencies (<kbd class="calibre12">collate</kbd>), or simply don't do anything at all (<kbd class="calibre12">optimize</kbd>). Therefore, you should avoid all of them in production code.</p>
<p class="calibre2">Notice that even though the process of turning a string into a <kbd class="calibre12">regex</kbd> object is often called "compiling the regex," it is still a dynamic process that happens at runtime when the <kbd class="calibre12">regex</kbd> constructor is called, not during the compilation of your C++ program. If you make a syntax error in your regular expression, it will be caught not at compile time, but at runtime--the <kbd class="calibre12">regex</kbd> constructor will throw an exception of type <kbd class="calibre12">std::regex_error</kbd>, which is a subclass of <kbd class="calibre12">std::runtime_error</kbd>. Properly robust code should also be prepared for the <kbd class="calibre12">regex</kbd> constructor to throw <kbd class="calibre12">std::bad_alloc</kbd>; recall that <kbd class="calibre12">std::regex</kbd> is not allocator-aware.</p>
<p class="calibre2"><kbd class="calibre12">rx.mark_count()</kbd> returns the number of parenthesized capturing groups in the regex. The name of this method comes from the phrase "marked subexpression," an older synonym for "capturing group."</p>
<p class="calibre2"><kbd class="calibre12">rx.flags()</kbd> returns the bit-mask that was passed to the constructor originally.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Matching and searching</h1>
                
            
            
                
<p class="calibre2">To ask whether a given input string <kbd class="calibre12">haystack</kbd> conforms to a given regex <kbd class="calibre12">rneedle</kbd>, you can use <kbd class="calibre12">std::regex_match(haystack, rneedle)</kbd>. The regex always comes last, which is reminiscent of JavaScript's syntax <kbd class="calibre12">haystack.match(rneedle)</kbd> and Perl's <kbd class="calibre12">haystack =~ rneedle</kbd> even as it's opposed to Python's <kbd class="calibre12">re.match(rneedle, haystack)</kbd>. The <kbd class="calibre12">regex_match</kbd> function returns <kbd class="calibre12">true</kbd> if the regex matches the entire input string, and <kbd class="calibre12">false</kbd> otherwise:</p>
<pre class="calibre23">    std::regex rx("(left|right) ([0-9]+)");<br class="title-page-name"/>    std::string line;<br class="title-page-name"/>    while (std::getline(std::cin, line)) {<br class="title-page-name"/>      if (std::regex_match(line, rx)) {<br class="title-page-name"/>        process_command(line);<br class="title-page-name"/>      } else {<br class="title-page-name"/>        printf("Unrecognized command '%s'.\n",<br class="title-page-name"/>          line.c_str());<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">The <kbd class="calibre12">regex_search</kbd> function returns <kbd class="calibre12">true</kbd> if the regex matches any portion of the input string. Essentially, it just puts <kbd class="calibre12">.*</kbd> on both sides of the regex you provided and then runs the <kbd class="calibre12">regex_match</kbd> algorithm; but implementations can generally perform a <kbd class="calibre12">regex_search</kbd> faster than they could recompile a whole new regex.</p>
<p class="calibre2">To match within just part of a character buffer (such as you might do when pulling data in bulk over a network connection or from a file), you can pass an iterator pair to <kbd class="calibre12">regex_match</kbd> or <kbd class="calibre12">regex_search</kbd>, very similarly to what we saw in <a href="part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 3</a>, <em class="calibre22">The Iterator-Pair Algorithms</em>. In the following example, bytes outside the range <kbd class="calibre12">[p, end)</kbd> are never considered, and the "string" <kbd class="calibre12">p</kbd> doesn't need to be null-terminated:</p>
<pre class="calibre23">    void parse(const char *p, const char *end)<br class="title-page-name"/>    {<br class="title-page-name"/>      static std::regex rx("(left|right) ([0-9]+)");<br class="title-page-name"/>      if (std::regex_match(p, end, rx)) {<br class="title-page-name"/>        process_command(p, end);<br class="title-page-name"/>      } else {<br class="title-page-name"/>        printf("Unrecognized command '%.*s'.\n",<br class="title-page-name"/>          int(end - p), p);<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">This interface is similar to what we saw with <kbd class="calibre12">std::from_chars</kbd> in <a href="part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 9</a>, <em class="calibre22">Iostreams</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Pulling submatches out of a match</h1>
                
            
            
                
<p class="calibre2">To use regexes for the <em class="calibre22">lexing</em> stage of input, you'll need a way to pull out the input substrings that matched each capturing group. The way you do this in C++ is by creating a <em class="calibre22">match object</em> of type <kbd class="calibre12">std::smatch</kbd>. No, that's not a typo! The name of the match-object type really is <kbd class="calibre12">smatch</kbd>, which stands for <kbd class="calibre12">std::string</kbd> match; there is also <kbd class="calibre12">cmatch</kbd> for <kbd class="calibre12">const char *</kbd> match. The difference between <kbd class="calibre12">smatch</kbd> or <kbd class="calibre12">cmatch</kbd> is the <em class="calibre22">type of iterator</em> they store internally: <kbd class="calibre12">smatch</kbd> stores <kbd class="calibre12">string::const_iterator</kbd>, while <kbd class="calibre12">cmatch</kbd> stores <kbd class="calibre12">const char *</kbd>.</p>
<p class="calibre2">Having constructed an empty <kbd class="calibre12">std::smatch</kbd> object, you'll pass it by reference as the middle parameter to <kbd class="calibre12">regex_match</kbd> or <kbd class="calibre12">regex_search</kbd>. Those functions will "fill in" the <kbd class="calibre12">smatch</kbd> object with information about the substrings that matched, <em class="calibre22">if</em> the regex match actually succeeded. If the match failed, then the <kbd class="calibre12">smatch</kbd> object will become (or remain) empty.</p>
<p class="calibre2">Here's an example of using <kbd class="calibre12">std::smatch</kbd> to pull out the substrings matching the direction and the integer distance from our "robot command":</p>
<pre class="calibre23">    std::pair&lt;std::string, std::string&gt;<br class="title-page-name"/>    parse_command(const std::string&amp; line)<br class="title-page-name"/>    {<br class="title-page-name"/>      static std::regex rx("(left|right) ([0-9]+)");<br class="title-page-name"/>      std::smatch m;<br class="title-page-name"/>      if (std::regex_match(line, <strong class="calibre1">m</strong>, rx)) {<br class="title-page-name"/>        return { m[1], m[2] };<br class="title-page-name"/>      } else {<br class="title-page-name"/>        throw "Unrecognized command!";<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test() {<br class="title-page-name"/>      auto [dir, dist] = parse_command("right 4");<br class="title-page-name"/>      assert(dir == "right" &amp;&amp; dist == "4");<br class="title-page-name"/>    }</pre>
<p class="calibre2">Notice that we use a <kbd class="calibre12">static</kbd> regex object to avoid constructing ("compiling") a new regex object every time the function is entered. Here's the same code using <kbd class="calibre12">const char *</kbd> and <kbd class="calibre12">std::cmatch</kbd> just for comparison:</p>
<pre class="calibre23">    std::pair&lt;std::string, std::string&gt;<br class="title-page-name"/>    parse_command(const char *p, const char *end)<br class="title-page-name"/>    {<br class="title-page-name"/>      static std::regex rx("(left|right) ([0-9]+)");<br class="title-page-name"/>      std::cmatch m;<br class="title-page-name"/>      if (std::regex_match(p, end, m, rx)) {<br class="title-page-name"/>        return { m[1], m[2] };<br class="title-page-name"/>      } else {<br class="title-page-name"/>        throw "Unrecognized command!";<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test() {<br class="title-page-name"/>      char buf[] = "left 20";<br class="title-page-name"/>      auto [dir, dist] = parse_command(buf, buf + 7);<br class="title-page-name"/>      assert(dir == "left" &amp;&amp; dist == "20");<br class="title-page-name"/>    }</pre>
<p class="calibre2">In both cases, something interesting happens on the line with the <kbd class="calibre12">return</kbd>. Having successfully matched the input string against our regex, we can query the match object <kbd class="calibre12">m</kbd> to find out which pieces of the input string correspond to the individual capturing groups in our regex. The first capturing group (<kbd class="calibre12">(left|right)</kbd> in our example) corresponds to <kbd class="calibre12">m[1]</kbd>, the second group (<kbd class="calibre12">([0-9]+)</kbd> in our example) corresponds to <kbd class="calibre12">m[2]</kbd>, and so on. If you try to refer to a group that doesn't exist in the regex, such as <kbd class="calibre12">m[3]</kbd> in our example, you'll get an empty string; accessing a match object will never throw an exception.</p>
<p class="calibre2">The group <kbd class="calibre12">m[0]</kbd> is a special case: it refers to the entire matched sequence. If the match was filled in by <kbd class="calibre12">std::regex_match</kbd>, this will always be the entire input string; if the match was filled in by <kbd class="calibre12">std::regex_search</kbd>, then this will be just the part of the string that matched the regex.</p>
<p class="calibre2">There are also two named groups: <kbd class="calibre12">m.prefix()</kbd> and <kbd class="calibre12">m.suffix()</kbd>. These refer to the sequences that were <em class="calibre22">not</em> part of the match--before the matched substring and after it, respectively. It is an invariant that if the match succeeded at all, then <kbd class="calibre12">m.prefix() + m[0] + m.suffix()</kbd> represents the entire input string.</p>
<p class="calibre2">All of these "group" objects are represented not by <kbd class="calibre12">std::string</kbd> objects--that would be too expensive--but by lightweight objects of type <kbd class="calibre12">std::sub_match&lt;It&gt;</kbd> (where <kbd class="calibre12">It</kbd> is either <kbd class="calibre12">std::string::const_iterator</kbd> or <kbd class="calibre12">const char *</kbd> as noted previously). Every <kbd class="calibre12">sub_match</kbd> object is implicitly convertible to <kbd class="calibre12">std::string</kbd>, and otherwise behaves a lot like a <kbd class="calibre12">std::string_view</kbd>: you can compare submatches against string literals, ask them for their lengths, and even output them to a C++ stream with <kbd class="calibre12">operator&lt;&lt;</kbd>, without ever converting them to <kbd class="calibre12">std::string</kbd>. The downside of this lightweight efficiency is the same downside we get every time we deal with iterators pointing into a container we may not own: we run the risk of <em class="calibre22">dangling iterators</em>:</p>
<pre class="calibre23">    static std::regex rx("(left|right) ([0-9]+)");<br class="title-page-name"/>    std::string line = "left 20";<br class="title-page-name"/>    std::smatch m;<br class="title-page-name"/>    std::regex_match(line, m, rx);<br class="title-page-name"/>      // m[1] now holds iterators into line<br class="title-page-name"/>    line = "hello world";<br class="title-page-name"/>      // reallocate line's underlying buffer<br class="title-page-name"/>    std::string oops = m[1];<br class="title-page-name"/>      // this invokes undefined behavior because<br class="title-page-name"/>      // of iterator invalidation
const char *</kbd> to <kbd class="calibre12">std::string</kbd>) might cause iterator-invalidation bugs in harmless-looking code. Consider the following:</pre>
<pre class="calibre23">    static std::regex rx("(left|right) ([0-9]+)");<br class="title-page-name"/>    std::smatch m;<br class="title-page-name"/>    std::regex_match("left 20", m, rx);<br class="title-page-name"/>      // m[1] would hold iterators into a temporary<br class="title-page-name"/>      // string, so they would ALREADY be invalid.<br class="title-page-name"/>      // Fortunately this overload is deleted.</pre>
<p class="calibre2">Fortunately, the standard library foresaw this lurking horror and evaded it by providing a special-case overload <kbd class="calibre12">regex_match(std::string&amp;&amp;, std::smatch&amp;, const std::regex&amp;)</kbd>, which is <em class="calibre22">explicitly deleted</em> (using the same <kbd class="calibre12">=delete</kbd> syntax you'd use to delete an unwanted special member function). This ensures that the preceding innocent-looking code will fail to compile, rather than being a source of iterator-invalidation bugs. Still, iterator invalidation bugs can happen, as in the previous example; to prevent them, you should treat <kbd class="calibre12">smatch</kbd> objects as extremely temporary, kind of like a <kbd class="calibre12">[&amp;]</kbd> lambda that captures the world by reference. Once a <kbd class="calibre12">smatch</kbd> object has been filled in, don't touch anything else in the environment until you've extracted the parts of the <kbd class="calibre12">smatch</kbd> that you care about!</p>
<p class="calibre2">To summarize, a <kbd class="calibre12">smatch</kbd> or <kbd class="calibre12">cmatch</kbd> object offers the following methods:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre12">m.ready()</kbd>: True if <kbd class="calibre12">m</kbd> has been filled in at all, in the time since its construction.</li>
<li class="calibre15"><kbd class="calibre12">m.empty()</kbd>: True if <kbd class="calibre12">m</kbd> represents a failed match (that is, if it was most recently filled in by a failed <kbd class="calibre12">regex_match</kbd> or <kbd class="calibre12">regex_search</kbd>); false if <kbd class="calibre12">m</kbd> represents a successful match.</li>
<li class="calibre15"><kbd class="calibre12">m.prefix()</kbd>, <kbd class="calibre12">m[0]</kbd>, <kbd class="calibre12">m.suffix()</kbd>: <kbd class="calibre12">sub_match</kbd> objects representing the unmatched prefix, matched, and unmatched suffix parts of the input string. (If <kbd class="calibre12">m</kbd> represents a failed match, then none of these are meaningful.)</li>
<li class="calibre15"><kbd class="calibre12">m[k]</kbd>: A <kbd class="calibre12">sub_match</kbd> object representing the part of the input string matched by the <em class="calibre22">k</em>th capturing group. <kbd class="calibre12">m.str(k)</kbd> is a convenient shorthand for <kbd class="calibre12">m[k].str()</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">m.size()</kbd>: Zero if <kbd class="calibre12">m</kbd> represents a failed match; otherwise, one more than the number of capturing groups in the regex whose successful match is represented by <kbd class="calibre12">m</kbd>. Notice that <kbd class="calibre12">m.size()</kbd> always agrees with <kbd class="calibre12">operator[]</kbd>; the range of meaningful submatch objects is always <kbd class="calibre12">m[0]</kbd> through <kbd class="calibre12">m[m.size()-1]</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">m.begin()</kbd>, <kbd class="calibre12">m.end()</kbd>: Iterators enabling ranged for-loop syntax over a match object.</li>
</ul>
<p class="calibre2">And a <kbd class="calibre12">sub_match</kbd> object offers the following methods:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre12">sm.first</kbd>: The iterator to the beginning of the matched input substring.</li>
<li class="calibre15"><kbd class="calibre12">sm.second</kbd>: The iterator to the end of the matched input substring.</li>
<li class="calibre15"><kbd class="calibre12">sm.matched</kbd>: True if <kbd class="calibre12">sm</kbd> was involved in the successful match; false if <kbd class="calibre12">sm</kbd> was part of an optional branch that got bypassed. For example, if the regex was <kbd class="calibre12">(a)|(b)</kbd> and the input was <kbd class="calibre12">"a"</kbd>, we would have <kbd class="calibre12">m[1].matched &amp;&amp; !m[2].matched</kbd>; whereas if the input were <kbd class="calibre12">"b"</kbd>, we would have <kbd class="calibre12">m[2].matched &amp;&amp; !m[1].matched</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">sm.str()</kbd>: The matched input substring, pulled out and converted to <kbd class="calibre12">std::string</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">sm.length()</kbd>: The length of the matched input substring (<kbd class="calibre12">second - first</kbd>). Equivalent to <kbd class="calibre12">sm.str().length()</kbd>, but much faster.</li>
<li class="calibre15"><kbd class="calibre12">sm == "foo"</kbd>: Comparison against <kbd class="calibre12">std::string</kbd>, <kbd class="calibre12">const char *</kbd>, or a single <kbd class="calibre12">char</kbd>. Equivalent to <kbd class="calibre12">sm.str() == "foo"</kbd>, but much faster. Unfortunately, the C++17 standard library does not provide any overload of <kbd class="calibre12">operator==</kbd> taking <kbd class="calibre12">std::string_view</kbd>.</li>
</ul>
<p class="calibre2">Although you will likely never have a use for this in real code, it is possible to create a match or submatch object storing iterators into containers other than <kbd class="calibre12">std::string</kbd> or buffers of <kbd class="calibre12">char</kbd>. For example, here's our same function, but matching our regex against a <kbd class="calibre12">std::list&lt;char&gt;</kbd>--silly, but it works!</p>
<pre class="calibre23">    template&lt;class Iter&gt;<br class="title-page-name"/>    std::pair&lt;std::string, std::string&gt;<br class="title-page-name"/>    parse_command(Iter begin, Iter end) <br class="title-page-name"/>    {<br class="title-page-name"/>      static std::regex rx("(left|right) ([0-9]+)");<br class="title-page-name"/>      std::match_results&lt;Iter&gt; m;<br class="title-page-name"/>      if (std::regex_match(begin, end, m, rx)) {<br class="title-page-name"/>        return { m.str(1), m.str(2) };<br class="title-page-name"/>      } else {<br class="title-page-name"/>        throw "Unrecognized command!";<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test() {<br class="title-page-name"/>      char buf[] = "left 20";<br class="title-page-name"/>      std::list&lt;char&gt; lst(buf, buf + 7);<br class="title-page-name"/>      auto [dir, dist] = parse_command(lst.begin(), lst.end());<br class="title-page-name"/>      assert(dir == "left" &amp;&amp; dist == "20");<br class="title-page-name"/>    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Converting submatches to data values</h1>
                
            
            
                
<p class="calibre2">Just to close the loop on parsing, here's an example of how we could parse string and integer values out of our submatches to actually move our robot:</p>
<pre class="calibre23">    int main()<br class="title-page-name"/>    {<br class="title-page-name"/>      std::regex rx("(left|right) ([0-9]+)");<br class="title-page-name"/>      int pos = 0;<br class="title-page-name"/>      std::string line;<br class="title-page-name"/>      while (std::getline(std::cin, line)) {<br class="title-page-name"/>        try {<br class="title-page-name"/>          std::smatch m;<br class="title-page-name"/>          if (!std::regex_match(line, m, rx)) {<br class="title-page-name"/>              throw std::runtime_error("Failed to lex");<br class="title-page-name"/>          }<br class="title-page-name"/>          int how_far = std::stoi(m.str(2));<br class="title-page-name"/>          int direction = (m[1] == "left") ? -1 : 1;<br class="title-page-name"/>          pos += how_far * direction;<br class="title-page-name"/>          printf("Robot is now at %d.\n", pos);<br class="title-page-name"/>        } catch (const std::exception&amp; e) {<br class="title-page-name"/>          puts(e.what());<br class="title-page-name"/>          printf("Robot is still at %d.\n", pos);<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">Any unrecognized or invalid string input is diagnosed either by our custom<kbd class="calibre12">"Failed to lex"</kbd> exception or by the <kbd class="calibre12">std::out_of_range</kbd> exception thrown by <kbd class="calibre12">std::stoi()</kbd>. If we were to add a check for integer overflow before modifying <kbd class="calibre12">pos</kbd>, we'd have a rock-solid input parser.</p>
<p class="calibre2">If we wanted to handle negative integers and case-insensitive directions, the following modifications would do the trick:</p>
<pre class="calibre23">    int main()<br class="title-page-name"/>    {<br class="title-page-name"/>      std::regex rx("(<strong class="calibre1">(left)</strong>|right) (<strong class="calibre1">-?</strong>[0-9]+)", <strong class="calibre1">std::regex::icase</strong>);<br class="title-page-name"/>      int pos = 0;<br class="title-page-name"/>      std::string line;<br class="title-page-name"/>      while (std::getline(std::cin, line)) {<br class="title-page-name"/>        try {<br class="title-page-name"/>          std::smatch m;<br class="title-page-name"/>          if (!std::regex_match(line, m, rx)) {<br class="title-page-name"/>            throw std::runtime_error("Failed to lex");<br class="title-page-name"/>          }<br class="title-page-name"/>          int how_far = std::stoi(m.str(3));<br class="title-page-name"/>          int direction = <strong class="calibre1">m[2].matched</strong> ? -1 : 1;<br class="title-page-name"/>          pos += how_far * direction;<br class="title-page-name"/>          printf("Robot is now at %d.\n", pos);<br class="title-page-name"/>        } catch (const std::exception&amp; e) {<br class="title-page-name"/>          puts(e.what());<br class="title-page-name"/>          printf("Robot is still at %d.\n", pos);<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Iterating over multiple matches</h1>
                
            
            
                
<p class="calibre2">Consider the regex <kbd class="calibre12">(?!\d)\w+</kbd>, which matches a single C++ identifier. We already know how to use <kbd class="calibre12">std::regex_match</kbd> to tell whether an input string <em class="calibre22">is</em> a C++ identifier, and how to use <kbd class="calibre12">std::regex_search</kbd> to find the <em class="calibre22">first</em> C++ identifier in a given input line. But what if we want to find <em class="calibre22">all</em> the C++ identifiers in a given input line?</p>
<p class="calibre2">The fundamental idea here is to call <kbd class="calibre12">std::regex_search</kbd> in a loop. This gets complicated, though, because of the non-consuming "lookbehind" anchors such as <kbd class="calibre12">^</kbd> and <kbd class="calibre12">\b</kbd>. To implement a loop over <kbd class="calibre12">std::regex_search</kbd> correctly from scratch, we'd have to preserve the state of these anchors. <kbd class="calibre12">std::regex_search</kbd> (and <kbd class="calibre12">std::regex_match</kbd> for that matter) supports this use-case by providing flags of its own--flags which determine the <em class="calibre22">starting state</em> of the finite state machine for this particular matching operation. For our purposes, the only important flag is <kbd class="calibre12">std::regex::match_prev_avail</kbd>, which tells the library that the iterator <kbd class="calibre12">begin</kbd>, representing the start of the input, is not actually at the "beginning" of the input (that is, it might not match <kbd class="calibre12">^</kbd>) and that if you want to know the previous character of the input for purposes of <kbd class="calibre12">\b</kbd>, it is safe to inspect <kbd class="calibre12">begin[-1]</kbd>:</p>
<pre class="calibre23">    auto get_all_matches(<br class="title-page-name"/>      const char *begin, const char *end,<br class="title-page-name"/>      const std::regex&amp; rx,<br class="title-page-name"/>      bool be_correct)<br class="title-page-name"/>    {<br class="title-page-name"/>      auto flags = be_correct ?<br class="title-page-name"/>      std::regex_constants::match_prev_avail :<br class="title-page-name"/>      std::regex_constants::match_default;<br class="title-page-name"/>      std::vector&lt;std::string&gt; result;<br class="title-page-name"/>      std::cmatch m;<br class="title-page-name"/>      std::regex_search(begin, end, m, rx);<br class="title-page-name"/>      while (!m.empty()) {<br class="title-page-name"/>        result.push_back(m[0]);<br class="title-page-name"/>        begin = m[0].second;<br class="title-page-name"/>        std::regex_search(begin, end, m, rx, flags);<br class="title-page-name"/>      }<br class="title-page-name"/>      return result;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test() {<br class="title-page-name"/>      char buf[] = "baby";<br class="title-page-name"/>      std::regex rx("\\bb.");<br class="title-page-name"/>        // get the first 2 letters of each word starting with "b"<br class="title-page-name"/>      auto v = get_all_matches(buf, buf+4, rx, false);<br class="title-page-name"/>      assert(v.size() == 2);<br class="title-page-name"/>        // oops, "by" is considered to start on a word boundary! <br class="title-page-name"/><br class="title-page-name"/>      v = get_all_matches(buf, buf+4, rx, true);<br class="title-page-name"/>      assert(v.size() == 1);<br class="title-page-name"/>        // "by" is correctly seen as part of the word "baby"<br class="title-page-name"/>    }</pre>
<p class="calibre2">In the preceding example, when <kbd class="calibre12">!be_correct</kbd>, each <kbd class="calibre12">regex_search</kbd> invocation is treated independently, so there is no difference between searching for <kbd class="calibre12">\bb.</kbd> from the first letter of the word <kbd class="calibre12">"by"</kbd> or from the third letter of the word <kbd class="calibre12">"baby"</kbd>. But when we pass <kbd class="calibre12">match_prev_avail</kbd> to the later invocations of <kbd class="calibre12">regex_search</kbd>, it takes a step back--literally--to see whether the letter before <kbd class="calibre12">"by"</kbd> was a "word" letter or not. Since the preceding <kbd class="calibre12">"a"</kbd> is a word letter, the second <kbd class="calibre12">regex_search</kbd> correctly refuses to treat <kbd class="calibre12">"by"</kbd> as a match.</p>
<p class="calibre2">Using <kbd class="calibre12">regex_search</kbd> in a loop like this is easy... unless the given regex might match an empty string! If the regex ever returns a successful match <kbd class="calibre12">m</kbd> where <kbd class="calibre12">m[0].length() == 0</kbd>, then we'll have an infinite loop. So the inner loop of our <kbd class="calibre12">get_all_matches()</kbd> should really look more like this:</p>
<pre class="calibre23">    while (!m.empty()) {<br class="title-page-name"/>      result.push_back(m[0]);<br class="title-page-name"/>      begin = m[0].second;<br class="title-page-name"/>      if (begin == end) break;<br class="title-page-name"/>      if (m[0].length() == 0) ++begin;<br class="title-page-name"/>      if (begin == end) break;<br class="title-page-name"/>      std::regex_search(begin, end, m, rx, flags);<br class="title-page-name"/>    }</pre>
<p class="calibre2">The standard library provides a "convenience" type called <kbd class="calibre12">std::regex_iterator</kbd> that will encapsulate the preceding code snippets' logic; using <kbd class="calibre12">regex_iterator</kbd> might conceivably save you some subtle bugs related to zero-length matches. Sadly, it won't save you any typing, and it slightly increases the chances of dangling-iterator pitfalls. <kbd class="calibre12">regex_iterator</kbd> is templated on its underlying iterator type in the same way as <kbd class="calibre12">match_results</kbd>, so if you're matching <kbd class="calibre12">std::string</kbd> input you want <kbd class="calibre12">std::sregex_iterator</kbd> and if you're matching on <kbd class="calibre12">const char *</kbd> input you want <kbd class="calibre12">std::cregex_iterator</kbd>. Here's the preceding example, recoded in terms of <kbd class="calibre12">sregex_iterator</kbd>:</p>
<pre class="calibre23">    auto get_all_matches(<br class="title-page-name"/>      const char *begin, const char *end,<br class="title-page-name"/>      const std::regex&amp; rx)<br class="title-page-name"/>    {<br class="title-page-name"/>      std::vector&lt;std::string&gt; result;<br class="title-page-name"/>      using It = std::cregex_iterator;<br class="title-page-name"/>      for (It it(begin, end, rx); it != It{}; ++it) {<br class="title-page-name"/>        auto m = *it;<br class="title-page-name"/>        result.push_back(m[0]);<br class="title-page-name"/>      }<br class="title-page-name"/>      return result;<br class="title-page-name"/>    }</pre>
<p class="calibre2">Consider how this awkward for-loop might benefit from a helper class, along the lines<br class="title-page-name"/>
of <kbd class="calibre12">streamer&lt;T&gt;</kbd> from the example near the end of <a href="part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 9</a>, <em class="calibre22">Iostreams</em>.</p>
<p class="calibre2">You can also iterate over the submatches within each match, either manually or using a "convenience" library type. Manually, it would look something like this:</p>
<pre class="calibre23">    auto get_tokens(const char *begin, const char *end,<br class="title-page-name"/>      const std::regex&amp; rx)<br class="title-page-name"/>    {<br class="title-page-name"/>      std::vector&lt;std::string&gt; result;<br class="title-page-name"/>      using It = std::cregex_iterator;<br class="title-page-name"/>      std::optional&lt;std::csub_match&gt; opt_suffix;<br class="title-page-name"/>      for (It it(begin, end, rx); it != It{}; ++it) {<br class="title-page-name"/>        auto m = *it;<br class="title-page-name"/>        std::csub_match nonmatching_part = m.prefix();<br class="title-page-name"/>        result.push_back(nonmatching_part);<br class="title-page-name"/>        std::csub_match matching_part = m[0];<br class="title-page-name"/>        result.push_back(matching_part);<br class="title-page-name"/>        opt_suffix = m.suffix();<br class="title-page-name"/>      }<br class="title-page-name"/>      if (opt_suffix.has_value()) {<br class="title-page-name"/>        result.push_back(opt_suffix.value());<br class="title-page-name"/>      }<br class="title-page-name"/>      return result;<br class="title-page-name"/>    }</pre>
<p class="calibre2">Recall that <kbd class="calibre12">regex_iterator</kbd> is just a wrapper around <kbd class="calibre12">regex_search</kbd>, so <kbd class="calibre12">m.prefix()</kbd> in this case is guaranteed to hold an entire non-matching portion, all the way back to the end of the previous match. By alternately pushing back non-matching prefixes and matches, and finishing with a special case for the non-matching suffix, we split the input string into a vector of "words" alternating with "word separators." It's easy to modify this code to save only the "words" or only the "separators" if that's all you need; or even to save <kbd class="calibre12">m[1]</kbd> instead of <kbd class="calibre12">m[0]</kbd>, and so forth.</p>
<p class="calibre2">The library type <kbd class="calibre12">std::sregex_token_iterator</kbd> encapsulates all of this logic very directly, although its constructor interface is fairly confusing if you aren't already familiar with the preceding manual code. <kbd class="calibre12">sregex_token_iterator</kbd>'s constructor takes an input iterator-pair, a regex, and then a <em class="calibre22">vector of submatch indices</em>, where the index <kbd class="calibre12">-1</kbd> is a special case meaning "prefixes (and also, suffix)."</p>
<pre class="calibre23">    auto get_tokens(const char *begin, const char *end,<br class="title-page-name"/>      const std::regex&amp; rx)<br class="title-page-name"/>    {<br class="title-page-name"/>      std::vector&lt;std::string&gt; result;<br class="title-page-name"/>      using TokIt = std::cregex_token_iterator;<br class="title-page-name"/>      for (TokIt it(begin, end, rx, {-1, 0}); it != TokIt{}; ++it) {<br class="title-page-name"/>        std::csub_match some_part = *it;<br class="title-page-name"/>        result.push_back(some_part);<br class="title-page-name"/>      }<br class="title-page-name"/>      return result;<br class="title-page-name"/>    }</pre>
<p class="calibre2">If we change the array <kbd class="calibre12">{-1, 0}</kbd> to just <kbd class="calibre12">{0}</kbd>, then our resulting vector will contain<br class="title-page-name"/>
only the pieces of the input string matching <kbd class="calibre12">rx</kbd>. If we change it to <kbd class="calibre12">{1, 2, 3}</kbd>, our<br class="title-page-name"/>
loop will see only those submatches (<kbd class="calibre12">m[1]</kbd>, <kbd class="calibre12">m[2]</kbd>, and <kbd class="calibre12">m[3]</kbd>) in each match <kbd class="calibre12">m</kbd> of <kbd class="calibre12">rx</kbd>. Recall that because of the <kbd class="calibre12">|</kbd> operator, submatches can be bypassed, leaving <kbd class="calibre12">m[k].matched</kbd> false. <kbd class="calibre12">regex_token_iterator</kbd> does not skip those matches. For example:</p>
<pre class="calibre23">    std::string input = "abc123...456...";<br class="title-page-name"/>    std::vector&lt;std::ssub_match&gt; v;<br class="title-page-name"/>    std::regex rx("([0-9]+)|([a-z]+)");<br class="title-page-name"/>    using TokIt = std::sregex_token_iterator;<br class="title-page-name"/>    std::copy(<br class="title-page-name"/>      TokIt(input.begin(), input.end(), rx, {1, 2}),<br class="title-page-name"/>      TokIt(),<br class="title-page-name"/>      std::back_inserter(v)<br class="title-page-name"/>    );<br class="title-page-name"/>    assert(!v[0].matched); assert(v[1] == "abc");<br class="title-page-name"/>    assert(v[2] == "123"); assert(!v[3].matched);<br class="title-page-name"/>    assert(v[4] == "456"); assert(!v[5].matched);</pre>
<p class="calibre2">The most attractive use of <kbd class="calibre12">regex_token_iterator</kbd> might be to split a string into "words" at whitespace boundaries. Unfortunately it is not significantly easier to use--or to debug--than old-school approaches such as <kbd class="calibre12">istream_iterator&lt;string&gt;</kbd> (see <a href="part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 9</a>, <em class="calibre22">Iostreams</em>) or <kbd class="calibre12">strtok_r</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using regular expressions for string replacement</h1>
                
            
            
                
<p class="calibre2">If you're coming from Perl, or if you often use the command-line utility <kbd class="calibre12">sed</kbd>, you probably think of regexes primarily as a way to <em class="calibre22">modify</em> strings--for example, "remove all substrings matching this regex," or "replace all instances of this word with another word." The C++ standard library does provide a sort of replace-by-regex functionality, under the name <kbd class="calibre12">std::regex_replace</kbd>. It's based on the JavaScript <kbd class="calibre12">String.prototype.replace</kbd> method, which means that it comes with its own idiosyncratic formatting mini-language.</p>
<p class="calibre2"><kbd class="calibre12">std::regex_replace(str, rx, "replacement")</kbd> returns a <kbd class="calibre12">std::string</kbd> constructed by searching through <kbd class="calibre12">str</kbd> for every substring matching the regex <kbd class="calibre12">rx</kbd> and replacing each such substring with the literal string <kbd class="calibre12">"replacement"</kbd>. For example:</p>
<pre class="calibre23">    std::string s = "apples and bananas";<br class="title-page-name"/>    std::string t = std::regex_replace(s, std::regex("a"), "e");<br class="title-page-name"/>    assert(t == "epples end benenes");<br class="title-page-name"/>    std::string u = std::regex_replace(s, std::regex("[ae]"), "u");<br class="title-page-name"/>    assert(u == "upplus und bununus");</pre>
<p class="calibre2">However, if <kbd class="calibre12">"replacement"</kbd> contains any <kbd class="calibre12">'$'</kbd> characters, special things will happen!</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre12">"$&amp;"</kbd> is replaced with the entire matching substring, <kbd class="calibre12">m[0]</kbd>. Both libstdc++ and libc++ support <kbd class="calibre12">"$0"</kbd> as a non-standard synonym for <kbd class="calibre12">"$&amp;"</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">"$1"</kbd> is replaced with the first submatch, <kbd class="calibre12">m[1]</kbd>; <kbd class="calibre12">"$2"</kbd> is replaced with <kbd class="calibre12">m[2]</kbd>; and so on, all the way up to <kbd class="calibre12">"$99"</kbd>. There is no way to refer to the 100th submatch. <kbd class="calibre12">"$100"</kbd> represents "<kbd class="calibre12">m[10]</kbd> followed by a literal <kbd class="calibre12">'0'</kbd>." To express "<kbd class="calibre12">m[1]</kbd> followed by a literal <kbd class="calibre12">'0'</kbd>," write <kbd class="calibre12">"$010"</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">"$`"</kbd> (that's a backtick) is replaced with <kbd class="calibre12">m.prefix()</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">"$'"</kbd> (that's a single-quote) is replaced with <kbd class="calibre12">m.suffix()</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">"$$"</kbd> is replaced with a literal dollar sign.</li>
</ul>
<p class="calibre2">Notice that <kbd class="calibre12">"$`"</kbd> and <kbd class="calibre12">"$'"</kbd> are far from symmetrical, because <kbd class="calibre12">m.prefix()</kbd> always refers to the part of the string between the end of the last match and the start of the current one, but <kbd class="calibre12">m.suffix()</kbd> always refers to the part of the string between the end of the current match and the <em class="calibre22">end of the string</em>! You'll never use either <kbd class="calibre12">"$`"</kbd> or <kbd class="calibre12">"$'"</kbd> in real code.</p>
<p class="calibre2">Here's an example of using <kbd class="calibre12">regex_replace</kbd> to remove all the instances of <kbd class="calibre12">std::</kbd> from a piece of code, or to change them all to <kbd class="calibre12">my::</kbd>:</p>
<pre class="calibre23">    auto s = "std::sort(std::begin(v), std::end(v))";<br class="title-page-name"/>    auto t = std::regex_replace(s, std::regex("\\bstd::(\\w+)"), "$1");<br class="title-page-name"/>    assert(t == "sort(begin(v), end(v))");<br class="title-page-name"/>    auto u = std::regex_replace(s, std::regex("\\bstd::(\\w+)"), "my::$1");<br class="title-page-name"/>    assert(u == "my::sort(my::begin(v), my::end(v))");</pre>
<p class="calibre2">JavaScript's <kbd class="calibre12">String.prototype.replace</kbd> allows you to pass in an arbitrary function instead of a dollar-sign-studded format string. C++'s <kbd class="calibre12">regex_replace</kbd> doesn't support arbitrary functions yet, but it's easy to write your own version that does:</p>
<pre class="calibre23">    template&lt;class F&gt;<br class="title-page-name"/>    std::string regex_replace(std::string_view haystack,<br class="title-page-name"/>      const std::regex&amp; rx, const F&amp; f)<br class="title-page-name"/>    {<br class="title-page-name"/>      std::string result;<br class="title-page-name"/>      const char *begin = haystack.data();<br class="title-page-name"/>      const char *end = begin + haystack.size();<br class="title-page-name"/>      std::cmatch m, lastm;<br class="title-page-name"/>      if (!std::regex_search(begin, end, m, rx)) {<br class="title-page-name"/>        return std::string(haystack);<br class="title-page-name"/>      }<br class="title-page-name"/>      do {<br class="title-page-name"/>        lastm = m;<br class="title-page-name"/>        result.append(m.prefix());<br class="title-page-name"/>        result.append(f(m));<br class="title-page-name"/>        begin = m[0].second;<br class="title-page-name"/>        begin += (begin != end &amp;&amp; m[0].length() == 0);<br class="title-page-name"/>        if (begin == end) break;<br class="title-page-name"/>      } while (std::regex_search(begin, end, m, rx,<br class="title-page-name"/>        std::regex_constants::match_prev_avail));<br class="title-page-name"/>      result.append(lastm.suffix());<br class="title-page-name"/>      return result;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void test()<br class="title-page-name"/>    {<br class="title-page-name"/>      auto s = "std::sort(std::begin(v), std::end(v))";<br class="title-page-name"/>      auto t = regex_replace(s, std::regex("\\bstd::(\\w+)"),<br class="title-page-name"/>        [](auto&amp;&amp; m) {<br class="title-page-name"/>          std::string result = m[1].str();<br class="title-page-name"/>          std::transform(m[1].first, m[1].second,<br class="title-page-name"/>          begin(result), ::toupper);<br class="title-page-name"/>          return result;<br class="title-page-name"/>        });<br class="title-page-name"/>      assert(t == "SORT(BEGIN(v), END(v))");<br class="title-page-name"/>    }</pre>
<p class="calibre2">With this improved <kbd class="calibre12">regex_replace</kbd> in hand, you can perform complicated operations such as "convert every identifier from <kbd class="calibre12">snake_case</kbd> to <kbd class="calibre12">CamelCase</kbd>" with ease.</p>
<p class="calibre2">This concludes our whirlwind tour of the facilities provided in C++'s <kbd class="calibre12">&lt;regex&gt;</kbd> header. The remainder of this chapter consists of a detailed introduction to the ECMAScript dialect of regex notation. I hope it will be useful to readers who haven't worked with regexes before, and that it will serve as a refresher and reference for those who have.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A primer on the ECMAScript regex grammar</h1>
                
            
            
                
<p class="calibre2">The rules for reading and writing regexes in the ECMAScript dialect are simple. A regex is just a string of characters (such as <kbd class="calibre12">a[bc].d*e</kbd>), and you read it from left to right. Most characters represent only themselves, so that <kbd class="calibre12">cat</kbd> is a valid regex and matches only the literal string <kbd class="calibre12">"cat"</kbd>. The only characters that don't represent themselves--and thus the only way to build regexes that represent languages more interesting than <kbd class="calibre12">"cat"</kbd>--are the following punctuation characters:</p>
<pre class="calibre23">    ^ $ \ . * + ? ( ) [ ] { } |</pre>
<p class="calibre2"><kbd class="calibre12">\</kbd>--if you're using a regex to describe a set of strings involving punctuation characters, you can use a backslash to escape those special characters. For example, <kbd class="calibre12">\$42\.00</kbd> is a regex for the singleton language whose only member is the string <kbd class="calibre12">"$42.00"</kbd>. Perhaps confusingly, backslash is <em class="calibre22">also</em> used to turn some normal characters into special characters! <kbd class="calibre12">n</kbd> is a regex for the letter "n", but <kbd class="calibre12">\n</kbd> is a regex for the newline character. <kbd class="calibre12">d</kbd> is a regex for the letter "d", but <kbd class="calibre12">\d</kbd> is a regex equivalent to <kbd class="calibre12">[0-9]</kbd>.</p>
<p class="calibre2">The complete list of backslash characters recognized by C++'s regex grammar is:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre12">\1</kbd>, <kbd class="calibre12">\2</kbd>, ... <kbd class="calibre12">\10</kbd>, ... for backreferences (to be avoided)</li>
<li class="calibre15"><kbd class="calibre12">\b</kbd> for a word boundary and <kbd class="calibre12">\B</kbd> for <kbd class="calibre12">(?!\b)</kbd></li>
<li class="calibre15"><kbd class="calibre12">\d</kbd> for <kbd class="calibre12">[[:digit:]]</kbd> and <kbd class="calibre12">\D</kbd> for <kbd class="calibre12">[^[:digit:]]</kbd></li>
<li class="calibre15"><kbd class="calibre12">\s</kbd> for <kbd class="calibre12">[[:space:]]</kbd> and <kbd class="calibre12">\S</kbd> for <kbd class="calibre12">[^[:space:]]</kbd></li>
<li class="calibre15"><kbd class="calibre12">\w</kbd> for <kbd class="calibre12">[0-9A-Za-z_]</kbd> and <kbd class="calibre12">\W</kbd> for <kbd class="calibre12">[^0-9A-Za-z_]</kbd></li>
<li class="calibre15"><kbd class="calibre12">\cX</kbd> for various "control characters" (to be avoided)</li>
<li class="calibre15"><kbd class="calibre12">\xXX</kbd> for hexadecimal, with the usual meaning</li>
<li class="calibre15"><kbd class="calibre12">\u00XX</kbd> for Unicode, with the usual meaning</li>
<li class="calibre15"><kbd class="calibre12">\0</kbd>, <kbd class="calibre12">\f</kbd>, <kbd class="calibre12">\n</kbd>, <kbd class="calibre12">\r</kbd>, <kbd class="calibre12">\t</kbd>, <kbd class="calibre12">\v</kbd> with their usual meanings</li>
</ul>
<p class="calibre2"><kbd class="calibre12">.</kbd>--This special character represents "exactly one character," with almost no other requirements. For example, <kbd class="calibre12">a.c</kbd> is a valid regex and matches inputs such as <kbd class="calibre12">"aac"</kbd>, <kbd class="calibre12">"a!c"</kbd>, and <kbd class="calibre12">"a\0c"</kbd>. However, <kbd class="calibre12">.</kbd> will <em class="calibre22">never</em> match a newline or carriage-return character; and because C++ regexes work at the byte level, not the Unicode level, <kbd class="calibre12">.</kbd> will match any single byte (other than <kbd class="calibre12">'\\n'</kbd> and <kbd class="calibre12">'\\r'</kbd>) but will never match a sequence of multiple bytes even if they happen to make up a valid UTF-8 codepoint.</p>
<p class="calibre2"><kbd class="calibre12">[]</kbd>--A group of characters enclosed in square brackets represents "exactly one of this set," so that <kbd class="calibre12">c[aou]t</kbd> is a valid regex and matches the strings <kbd class="calibre12">"cat"</kbd>, <kbd class="calibre12">"cot"</kbd>, and <kbd class="calibre12">"cut"</kbd>. You can use square-bracket syntax to "escape" most characters; for example, <kbd class="calibre12">[$][.][*][+][?][(][)][[][{][}][|]</kbd> is a regex for the singleton language whose only member is the string <kbd class="calibre12">"$.*+?()[{}|"</kbd>. However, you cannot use brackets to escape <kbd class="calibre12">]</kbd>, <kbd class="calibre12">\</kbd>, or <kbd class="calibre12">^</kbd>.</p>
<p class="calibre2"><kbd class="calibre12">[^]</kbd>--A group of characters enclosed in square brackets with a leading <kbd class="calibre12">^</kbd> represents "exactly one, <em class="calibre22">not</em> of this set," so that <kbd class="calibre12">c[^aou]t</kbd> will match <kbd class="calibre12">"cbt"</kbd> or <kbd class="calibre12">"c^t"</kbd> but not <kbd class="calibre12">"cat"</kbd>. The ECMAScript dialect does not treat the trivial cases <kbd class="calibre12">[]</kbd> or <kbd class="calibre12">[^]</kbd> specially; <kbd class="calibre12">[]</kbd> means "exactly one character from the empty set" (which is to say, it never matches anything), and <kbd class="calibre12">[^]</kbd> means "exactly one character <em class="calibre22">not</em> from the empty set" (which is to say, it matches any single character--just like <kbd class="calibre12">.</kbd> but better, because it <em class="calibre22">will</em> match newline and carriage-return characters).</p>
<p class="calibre2">The <kbd class="calibre12">[]</kbd> syntax treats a couple more characters specially: If <kbd class="calibre12">-</kbd> appears inside square brackets anywhere except as the first or last character, it denotes a "range" with its left and right neighbors. So <kbd class="calibre12">ro[s-v]e</kbd> is a regex for the language whose members are the four strings <kbd class="calibre12">"rose"</kbd>, <kbd class="calibre12">"rote"</kbd>, <kbd class="calibre12">"roue"</kbd>, and <kbd class="calibre12">"rove"</kbd>. A few commonly useful ranges--the same ranges exposed via the <kbd class="calibre12">&lt;ctype.h&gt;</kbd> header--are built in using the syntax <kbd class="calibre12">[:foo:]</kbd> inside square brackets: <kbd class="calibre12">[[:digit:]]</kbd> is the same as <kbd class="calibre12">[0-9]</kbd>, <kbd class="calibre12">[[:upper:][:lower:]]</kbd> is the same as <kbd class="calibre12">[[:alpha:]]</kbd> is the same as <kbd class="calibre12">[A-Za-z]</kbd>, and so on.</p>
<p class="calibre2">There are also built-in syntaxes that look like <kbd class="calibre12">[[.x.]]</kbd> and <kbd class="calibre12">[[=x=]]</kbd>; they deal with locale-dependent comparisons and you will never have to use them. Merely be aware that if you ever need to include the character <kbd class="calibre12">[</kbd> inside a square-bracketed character class, it will be in your best interest to backslash-escape it: both <kbd class="calibre12">foo[=([;]</kbd> and <kbd class="calibre12">foo[(\[=;]</kbd> match the strings <kbd class="calibre12">"foo="</kbd>, <kbd class="calibre12">"foo("</kbd>, <kbd class="calibre12">"foo["</kbd>, and <kbd class="calibre12">"foo;"</kbd>, but <kbd class="calibre12">foo[([=;]</kbd> is an invalid regex and will throw an exception at runtime when you try to construct a <kbd class="calibre12">std::regex</kbd> object from it.</p>
<p class="calibre2"><kbd class="calibre12">+</kbd>--An expression or single character followed immediately by <kbd class="calibre12">+</kbd> matches the previous expression or character any positive number of times. For example, the regex <kbd class="calibre12">ba+</kbd> matches the strings <kbd class="calibre12">"ba"</kbd>, <kbd class="calibre12">"baa"</kbd>, <kbd class="calibre12">"baaa"</kbd>, and so on.</p>
<p class="calibre2"><kbd class="calibre12">*</kbd>--An expression or single character followed immediately by <kbd class="calibre12">*</kbd> matches the previous expression or character any number of times--even no times at all! So the regex <kbd class="calibre12">ba*</kbd> matches the strings <kbd class="calibre12">"ba"</kbd>, <kbd class="calibre12">"baa"</kbd>, and <kbd class="calibre12">"baaa"</kbd>, and also matches <kbd class="calibre12">"b"</kbd> alone.</p>
<p class="calibre2"><kbd class="calibre12">?</kbd>--An expression or single character followed immediately by <kbd class="calibre12">?</kbd> matches the previous expression or character exactly zero or one times. For example, <kbd class="calibre12">coo?t</kbd> is a regex matching only <kbd class="calibre12">"cot"</kbd> and <kbd class="calibre12">"coot"</kbd>.</p>
<p class="calibre2"><kbd class="calibre12">{n}</kbd>--An expression or single character followed immediately by a curly-braced integer matches the previous expression or character exactly the number of times indicated. For example, <kbd class="calibre12">b(an){2}a</kbd> is a regex matching <kbd class="calibre12">"banana"</kbd>; <kbd class="calibre12">b(an){3}a</kbd> is a regex matching <kbd class="calibre12">"bananana"</kbd>.</p>
<p class="calibre2"><kbd class="calibre12">{m,n}</kbd>--When the curly-braced construct has the form of two integers <em class="calibre22">m</em> and <em class="calibre22">n</em> separated by a comma, the construct matches the previous expression or character anywhere from <em class="calibre22">m</em> to <em class="calibre22">n</em> times (inclusive). So <kbd class="calibre12">b(an){2,3}a</kbd> is a regex matching only the strings <kbd class="calibre12">"banana"</kbd> and <kbd class="calibre12">"bananana"</kbd>.</p>
<p class="calibre2"><kbd class="calibre12">{m,}</kbd>--Leaving <em class="calibre22">n</em> blank effectively makes it infinite; so <kbd class="calibre12">x{42,}</kbd> means "match <kbd class="calibre12">x</kbd> 42 or more times," and is equivalent to <kbd class="calibre12">x{42}x*</kbd>. The ECMAScript dialect does not allow leaving <em class="calibre22">m</em> blank.</p>
<p class="calibre2"><kbd class="calibre12">|</kbd>--Two regular expressions can be "glued together" with <kbd class="calibre12">|</kbd> to express the idea of <em class="calibre22">either-or</em>. For example, <kbd class="calibre12">cat|dog</kbd> is a regex matching only the strings <kbd class="calibre12">"cat"</kbd> and <kbd class="calibre12">"dog"</kbd>; and <kbd class="calibre12">(tor|shark)nado</kbd> matches either <kbd class="calibre12">"tornado"</kbd> or <kbd class="calibre12">"sharknado"</kbd>. The <kbd class="calibre12">|</kbd> operator has very low precedence in regexes, just as it does in C++ expressions.</p>
<p class="calibre2"><kbd class="calibre12">()</kbd>--Parentheses work just as in mathematics, to enclose a sub-expression that you want to bind tightly together and treat as a unit. For example, <kbd class="calibre12">ba*</kbd> means "the character <kbd class="calibre12">b</kbd>, and then zero or more instances of <kbd class="calibre12">a</kbd>; but <kbd class="calibre12">(ba)*</kbd> means "zero or more instances of <kbd class="calibre12">ba</kbd>." So the former matches <kbd class="calibre12">"b"</kbd>, <kbd class="calibre12">"ba"</kbd>, <kbd class="calibre12">"baa"</kbd>, and so on; but the version with parentheses matches <kbd class="calibre12">""</kbd>, <kbd class="calibre12">"ba"</kbd>, <kbd class="calibre12">"baba"</kbd>, and so on.</p>
<p class="calibre2">Parentheses also have a second purpose--they are used not just for <em class="calibre22">grouping</em> but also for <em class="calibre22">capturing</em> parts of a match for further processing. Each opening <kbd class="calibre12">(</kbd> in the regex generates another submatch in the resulting <kbd class="calibre12">std::smatch</kbd> object.</p>
<p class="calibre2">If you want to group some subexpression tightly together without generating a submatch, you can use a <em class="calibre22">non-capturing</em> group with the syntax <kbd class="calibre12">(?:foo)</kbd>:</p>
<pre class="calibre23">    std::string s = "abcde";<br class="title-page-name"/>    std::smatch m;<br class="title-page-name"/>    std::regex_match(s, m, std::regex("(a|b)*(.*)e"));<br class="title-page-name"/>    assert(m.size() == 3 &amp;&amp; m[2] == "cd");<br class="title-page-name"/>    std::regex_match(s, m, std::regex("(?:a|b)*(.*)e"));<br class="title-page-name"/>    assert(m.size() == 2 &amp;&amp; m[1] == "cd");</pre>
<p class="calibre2">Non-capturing might be useful in some obscure context; but generally, it will be clearer to the reader if you just use regular capturing <kbd class="calibre12">()</kbd> and ignore the submatches you don't care about, as opposed to scattering <kbd class="calibre12">(?:)</kbd> around your codebase in an attempt to squelch all unused submatches. Unused submatches are very cheap, performance-wise.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Non-consuming constructs</h1>
                
            
            
                
<p class="calibre2"><kbd class="calibre12">(?=foo)</kbd> matches the pattern <kbd class="calibre12">foo</kbd> against the input, and then "rewinds" so that none of the input is actually consumed. This is called "lookahead." So for example <kbd class="calibre12">c(?=a)(?=a)(?=a)at</kbd> matches <kbd class="calibre12">"cat"</kbd>; and <kbd class="calibre12">(?=.*[A-Za-z])(?=.*[0-9]).*</kbd> matches any string containing at least one alphabetic character and at least one digit.</p>
<p class="calibre2"><kbd class="calibre12">(?!foo)</kbd> is a "negative lookahead"; it looks ahead to match <kbd class="calibre12">foo</kbd> against the input, but then <em class="calibre22">rejects</em> the match if <kbd class="calibre12">foo</kbd> would have accepted, and <em class="calibre22">accepts</em> the match if <kbd class="calibre12">foo</kbd> would have rejected. So, for example, <kbd class="calibre12">(?!\d)\w+</kbd> matches any C++ identifier or keyword--that is, any sequence of alphanumeric characters that does <em class="calibre22">not</em> start with a digit. Notice that the first character must not match <kbd class="calibre12">\d</kbd> but is not consumed by the <kbd class="calibre12">(?!\d)</kbd> construct; it must still be accepted by <kbd class="calibre12">\w</kbd>. The similar-looking regex <kbd class="calibre12">[^0-9]\w+</kbd> would "erroneously" accept strings such as <kbd class="calibre12">"#xyzzy"</kbd> which are not valid identifiers.</p>
<p class="calibre2">Both <kbd class="calibre12">(?=)</kbd> and <kbd class="calibre12">(?!)</kbd> are not only non-consuming but also <em class="calibre22">non-capturing</em>, just like <kbd class="calibre12">(?:)</kbd>. But it is perfectly fine to write <kbd class="calibre12">(?=(foo))</kbd> to capture all or part of the "looked-ahead" portion.</p>
<p class="calibre2"><kbd class="calibre12">^</kbd> and <kbd class="calibre12">$</kbd>--A caret <kbd class="calibre12">^</kbd> on its own, outside any square brackets, matches only at the beginning of the string to be matched; and <kbd class="calibre12">$</kbd> matches only at the end. This is useful to "anchor" the regex to the beginning or end of the input string, in the context of <kbd class="calibre12">std::regex_search</kbd>. In <kbd class="calibre12">std::regex::multiline</kbd> regexes, <kbd class="calibre12">^</kbd> and <kbd class="calibre12">$</kbd> act as "lookbehind" and "lookahead" assertions respectively:</p>
<pre class="calibre23">    std::string s = "ab\ncd";<br class="title-page-name"/>    std::regex rx("^ab$[^]^cd$", std::regex::multiline);<br class="title-page-name"/><br class="title-page-name"/>    assert(std::regex_match(s, rx));</pre>
<p class="calibre2">Putting it all together, we might write the regex <kbd class="calibre12">foo[a-z_]+(\d|$)</kbd> to match "the letters <kbd class="calibre12">foo</kbd>, followed by one or more other letters and/or underscore; followed by either a digit or the end of the line."</p>
<p class="calibre2">If you need a deeper dive into regex syntax, consult <a href="https://cppreference.com" class="calibre4">cppreference.com</a>. And if that's not enough--the best thing about C++'s copying the ECMAScript flavor of regexes is that any tutorial on JavaScript regexes will also be applicable to C++! You can even test out regular expressions in your browser's console. The only difference between C++ regexes and JavaScript regexes is that C++ supports the double-square-bracket syntax for character classes such as <kbd class="calibre12">[[:digit:]]</kbd>, <kbd class="calibre12">[[.x.]]</kbd>, and <kbd class="calibre12">[[=x=]]</kbd>, whereas JavaScript doesn't. JavaScript treats those regexes as equivalent to <kbd class="calibre12">[\[:digt]\]</kbd>, <kbd class="calibre12">[\[.x]\]</kbd>, and <kbd class="calibre12">[\[=x]\]</kbd> respectively.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Obscure ECMAScript features and pitfalls</h1>
                
            
            
                
<p class="calibre2">Earlier in this chapter I mentioned a few features of <kbd class="calibre12">std::regex</kbd> that you would be better off to avoid, such as <kbd class="calibre12">std::regex::collate</kbd>, <kbd class="calibre12">std::regex::optimize</kbd>, and flags that change the dialect away from ECMAScript. The ECMAScript regex grammar itself contains a few obscure and avoid worthy features as well.</p>
<p class="calibre2">A backslash followed by one or more digits (other than <kbd class="calibre12">\0</kbd>) creates a <em class="calibre22">backreference</em>. The backreference <kbd class="calibre12">\1</kbd> matches "the same sequence of characters that was matched by my first capturing group"; so for example the regex <kbd class="calibre12">(cat|dog)\1</kbd> will match the strings <kbd class="calibre12">"catcat"</kbd> and <kbd class="calibre12">"dogdog"</kbd> but not <kbd class="calibre12">"catdog"</kbd>, and <kbd class="calibre12">(a*)(b*)c\2\1</kbd> will match <kbd class="calibre12">"aabbbcbbbaa"</kbd> but not <kbd class="calibre12">"aabbbcbbba"</kbd>. Backreferences can have subtly weird semantics, especially when combined with non-consuming constructs such as <kbd class="calibre12">(?=foo)</kbd>, and I recommend avoiding them when possible.</p>
<p>If you're having trouble with backreferences, the first thing to check is your backslash-escaping. Remember that <kbd class="calibre25">std::regex("\1")</kbd> is a regex matching ASCII control character number 1. What you meant to type was <kbd class="calibre25">std::regex("\\1")</kbd>.</p>
<p class="calibre2">Using backreferences takes you out of the world of <em class="calibre22">regular languages</em> and into the wider world of <em class="calibre22">context-sensitive languages</em>, which means that the library must trade in its extremely efficient finite-state-machine-based matching algorithm for more powerful but expensive and slow "backtracking" algorithms. This seems like another good reason to avoid backreferences unless they're absolutely necessary.</p>
<p class="calibre2">However, as of 2017, most vendors do not actually switch algorithms based on the <em class="calibre22">presence</em> of backreferences in a regex; they'll use the slower backtracking algorithm based on the <em class="calibre22">mere possibility</em> of backreferences in the ECMAScript regex dialect. And then, because no vendor wants to implement a whole second algorithm just for the backreference-less dialects <kbd class="calibre12">std::regex::awk</kbd> and <kbd class="calibre12">std::regex::extended</kbd>, they end up using the backtracking algorithm even for those dialects! Similarly, most vendors will implement <kbd class="calibre12">regex_match(s, rx)</kbd> in terms of <kbd class="calibre12">regex_match(s, m, rx)</kbd> and then throw out the expensively computed <kbd class="calibre12">m</kbd>, rather than using a potentially faster algorithm for <kbd class="calibre12">regex_match(s, rx)</kbd>. Optimizations like this might come to a library near you sometime in the next 10 years, but I wouldn't hold your breath waiting for them.</p>
<p class="calibre2">Another obscure quirk is that the <kbd class="calibre12">*</kbd>, <kbd class="calibre12">+</kbd>, and <kbd class="calibre12">?</kbd> quantifiers are all <em class="calibre22">greedy</em> by default, meaning that, for example, <kbd class="calibre12">(a*)</kbd> will prefer to match as many <kbd class="calibre12">a</kbd> characters as it can. You can turn a greedy quantifier <em class="calibre22">non-greedy</em> by suffixing an extra <kbd class="calibre12">?</kbd>; so for example <kbd class="calibre12">(a*?)</kbd> matches the <em class="calibre22">smallest</em> number of <kbd class="calibre12">a</kbd> characters it can. This makes no difference at all unless you're using capturing groups. Here's an example:</p>
<pre class="calibre23">    std::string s = "abcde";<br class="title-page-name"/>    std::smatch m;<br class="title-page-name"/>    std::regex_match(s, m, std::regex(".*([bcd].*)e"));<br class="title-page-name"/>    assert(m[1] == "d");<br class="title-page-name"/>    std::regex_match(s, m, std::regex(".*?([bcd].*)e"));<br class="title-page-name"/>    assert(m[1] == "bcd");</pre>
<p class="calibre2">In the first case, <kbd class="calibre12">.*</kbd> greedily matches <kbd class="calibre12">abc</kbd>, leaving only <kbd class="calibre12">d</kbd> to be matched by the capturing group. In the second case, <kbd class="calibre12">.*?</kbd> non-greedily matches only <kbd class="calibre12">a</kbd>, leaving <kbd class="calibre12">bcd</kbd> for the capturing group. (In fact, <kbd class="calibre12">.*?</kbd> would have preferred to match the empty string; but it couldn't do that without the overall match being rejected.)</p>
<p class="calibre2">Notice that the syntax for non-greediness doesn't follow the "normal" rules of operator composition. From what we know of C++'s operator syntax, we'd expect that <kbd class="calibre12">a+*</kbd> would mean <kbd class="calibre12">(a+)*</kbd> (which it does) and <kbd class="calibre12">a+?</kbd> would mean <kbd class="calibre12">(a+)?</kbd> (which it doesn't). So, if you see consecutive punctuation characters in a regular expression, watch out--it may mean something different from what your intuition tells you!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">Regular expressions (regexes) are a good way to <em class="calibre22">lex</em> out the pieces of an input string before parsing them. The default regex dialect in C++ is the same as in JavaScript. Use this to your advantage.</p>
<p class="calibre2">Prefer to avoid raw string literals in situations where an extra pair of parentheses could be confusing. When possible, limit the number of escaped backslashes in your regexes by using square brackets to escape special characters instead.</p>
<p class="calibre2"><kbd class="calibre12">std::regex rx</kbd> is basically immutable and represents a finite state machine. <kbd class="calibre12">std::smatch m</kbd> is mutable and holds information about a particular match within the haystack string. Submatch <kbd class="calibre12">m[0]</kbd> represents the whole matched substring; <kbd class="calibre12">m[k]</kbd> represents the <em class="calibre22">k</em>th capturing group.</p>
<p class="calibre2"><kbd class="calibre12">std::regex_match(s, m, rx)</kbd> matches the needle against the <em class="calibre22">entire</em> haystack string; <kbd class="calibre12">std::regex_search(s, m, rx)</kbd> looks for the needle <em class="calibre22">in</em> the haystack. Remember that the haystack goes first and the needle goes last, just like in JavaScript and Perl.</p>
<p class="calibre2"><kbd class="calibre12">std::regex_iterator</kbd>, <kbd class="calibre12">std::regex_token_iterator</kbd>, and <kbd class="calibre12">std::regex_replace</kbd> are relatively inconvenient "convenience" functions built on top of <kbd class="calibre12">regex_search</kbd>. Get comfortable with <kbd class="calibre12">regex_search</kbd> before worrying about these wrappers.</p>
<p class="calibre2">Beware of dangling-iterator bugs! Never modify or destroy a <kbd class="calibre12">regex</kbd> that is still referenced by <kbd class="calibre12">regex_iterator</kbd>; and never modify or destroy a <kbd class="calibre12">string</kbd> that is still referenced by <kbd class="calibre12">smatch</kbd>.</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>


            

            
        
    </body></html>