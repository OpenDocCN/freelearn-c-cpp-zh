<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Rediscovering Fire &#x2013; Common Game Design Elements"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Rediscovering Fire – Common Game Design Elements</h1></div></div></div><p>Video games are getting more and more intricate every day. It seems that innovative ideas are on the rise, especially with the increasing popularity of indie games, such as <span class="emphasis"><em>Minecraft</em></span> and <span class="emphasis"><em>Super Meat Boy</em></span>. While the game ideas themselves are getting more and more abstract, at least on the outside, the rigid skeleton behind the pretty skin that keeps it standing and helps it retain shape is still taking the place of the lowest common denominator in the eyes of game developers. Even if the focus of the game centers around two unicorns who spend their free time smoking fairy dust and helping Dracula make muffins so that Neptune doesn't blow up, that concept coming to life is going to depend greatly on the underlying logic of the game before anything else. If there are no entities in the game, there are no unicorns. If the entities are simply bouncing around a black screen, the game is not engaging. These are the most common game design elements that any project must be able to fall back on, otherwise it is doomed to fail.</p><p>In this chapter, we will be covering the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing and implementing the game map class</li><li class="listitem" style="list-style-type: disc">Populating the map by creating and managing entities</li><li class="listitem" style="list-style-type: disc">Checking for and handling collisions</li><li class="listitem" style="list-style-type: disc">Meshing all of our code together into a finished game</li></ul></div><div class="section" title="The game map"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec61"/>The game map</h1></div></div></div><p>The actual<a id="id217" class="indexterm"/> environment and surroundings a player explores are just as important as the rest of the game. Without the world being present, the player is simply left spinning in an empty void of the screen clear color. Designing a good interface to bring out various parts of the game, ranging from the level backdrop to numerous hazards our player has to face can be tricky. Let's build a solid foundation for that right now, starting with defining what our map format is going to be like, as we take a look ahead to determine what we want to accomplish:</p><div class="mediaobject"><img src="graphics/B04284_07_01.jpg" alt="The game map"/></div><p>First, we <a id="id218" class="indexterm"/>want to specify a texture handle as the background. Then, we want to clearly define the map size and set up the gravity, which determines how fast entities fall to the ground. Additionally, we need to store the default friction, which determines how slippery the average tile is. The last property we want to store is the name of the next map that gets loaded when the end of the current map is reached. Here is a snippet from one of the maps that we will be working with, <code class="literal">Map1.map</code>:</p><div class="informalexample"><pre class="programlisting">|type|~id|x|y|
BACKGROUND Bg1
SIZE 63 32
GRAVITY 512
DEFAULT_FRICTION 0.8 0
NEXTMAP map2.map
|PLAYER 0 512
|ENEMY Rat 128 512
TILE 0 0 25
TILE 1 0 26 WARP
...</pre></div><p>As you can tell, in addition to defining all of the things discussed, the map file also stores the player position, as well as different enemies and their spawn positions. The last but definitely not the least important part of it is tile storage and the indication of which tile is going to "warp" the <a id="id219" class="indexterm"/>player to the next stage when touched.</p><div class="section" title="What is a tile?"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec25"/>What is a tile?</h2></div></div></div><p>The term "tile" keeps <a id="id220" class="indexterm"/>getting thrown around, but it hasn't been defined yet. To put it simply, a tile is one of the many segments that make up the world. Tiles are blocks that create the game environment, whether it's the grass you're standing on or the spikes you're falling onto. The map uses a tile sheet, which is fairly similar to a sprite sheet, in that it holds many different sprites at once. The main difference is how those sprites are obtained from the tile sheet. This is what the texture that is going to be used as a tile sheet looks like in our case:</p><div class="mediaobject"><img src="graphics/B04284_07_02.jpg" alt="What is a tile?"/></div><p>Each tile also has unique properties, which we will want to load from the <code class="literal">Tiles.cfg</code> file:</p><div class="informalexample"><pre class="programlisting">|id|name|friction x|friction y|deadly
0 Grass 0.8 0 0
1 Dirt 0.8 0 0
2 Stone 0.8 0 0
3 Brick 0.8 0 0
4 Brick_Red 0.8 0 0
5 Rock 0.8 0 0
6 Icy_Rock 0.6 0 0
7 Spikes 1.0 0 1
8 Ice 0.25 0 0</pre></div><p>It is quite simple and only contains the tile ID, name, both axes of friction, and a binary flag for the tile being deadly to touch.</p></div></div></div>
<div class="section" title="Building the game world"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Building the game world</h1></div></div></div><p>Since tiles<a id="id221" class="indexterm"/> are going to play such a huge role in our game design, it would be greatly helpful to have a separate data structure that all tile information can be localized to. A good place to start is by defining some constants of the tile size, as well as dimensions of the tile sheets that are going to be used. A simple enumeration can be quite helpful when storing this information:</p><div class="informalexample"><pre class="programlisting">enum Sheet{Tile_Size = 32, Sheet_Width = 256, Sheet_Height = 256};</pre></div><p>Here, we<a id="id222" class="indexterm"/> make it so all tiles are going to be 32 px wide and 32 px tall and every single tile sheet is going to be 256 px wide and 256 px tall. These constants, obviously, can be changed, but the idea here is to keep them the same during runtime.</p><p>To keep our code a little shorter, we can also benefit from a type alias for tile IDs:</p><div class="informalexample"><pre class="programlisting">using TileID = unsigned int;</pre></div><div class="section" title="The flyweight pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec26"/>The flyweight pattern</h2></div></div></div><p>Each <a id="id223" class="indexterm"/>tile, obviously, has to have a sprite that represents its type graphically speaking. In order to draw a grass tile, we want to adjust the sprite to be cropped to only the grass tile in the tile sheet. Then, we set its position on the screen and draw it. Seems simple enough, but consider the following situation: you have a map that's 1000x1000 tiles in size, and perhaps 25% of that map's size is actual tiles that aren't just air, which leaves you with the total amount of 62,500 tiles to draw. Now imagine you're storing a sprite with each tile. Granted, sprites are lightweight objects, but that's still a huge waste of resources. This is where the flyweight pattern comes in.</p><p>Storing huge chunks of redundant data is obviously a waste, so why not just store one instance of each type and simply store a pointer to the type in the tile? That, in a nutshell, is the flyweight pattern. Let's see it in action, by implementing a tile information structure:</p><div class="informalexample"><pre class="programlisting">struct TileInfo{
  TileInfo(SharedContext* l_context, 
    const std::string&amp; l_texture = "", TileID l_id = 0)
    : m_context(l_context), m_id(0), m_deadly(false)
  {
    TextureManager* tmgr = l_context-&gt;m_textureManager;
    if (l_texture == ""){ m_id = l_id; return; }
    if (!tmgr-&gt;RequireResource(l_texture)){ return; }
    m_texture = l_texture;
    m_id = l_id;
    m_sprite.setTexture(*tmgr-&gt;GetResource(m_texture));
    sf::IntRect tileBoundaries(m_id %
     (Sheet::Sheet_Width / Sheet::Tile_Size) * Sheet::Tile_Size,
     m_id/(Sheet::Sheet_Height/Sheet::Tile_Size)*Sheet::Tile_Size,
     Sheet::Tile_Size,Sheet::Tile_Size);
    m_sprite.setTextureRect(tileBoundaries);
  }

  ~TileInfo(){
    if (m_texture == ""){ return; }
    m_context-&gt;m_textureManager-&gt;ReleaseResource(m_texture);
  }

  sf::Sprite m_sprite;

  TileID m_id;
  std::string m_name;
  sf::Vector2f m_friction;
  bool m_deadly;

  SharedContext* m_context;
  std::string m_texture;
};</pre></div><p>This <code class="literal">struct</code> essentially holds everything about every tile type that isn't unique. It stores the texture <a id="id224" class="indexterm"/>that it's using, as well as the sprite that will represent the tile. As you can see, in the constructor of this structure, we set the sprite to point to the tile sheet texture and then crop it based on its tile ID. This type of cropping is a little different than the one in the sprite sheet class, because now we only have the tile ID to work with, and we don't know which row the sprite is on. Using some basic math allows us to first figure out how many columns and rows the tile sheet has, by dividing our sheet dimensions by the tile size. In this case, a 256x256 px sized sprite sheet with tiles of 32x32 px in size would have eight tiles per row and column. Obtaining the coordinate of a tile ID on an <span class="emphasis"><em>x</em></span> axis can be done by using the modulus operator <code class="literal">%</code>. In a case of eight tiles per row, it would return values from 0 to 7, based on the ID. Figuring out the <span class="emphasis"><em>y</em></span> coordinate is done simply by dividing the ID by the number of tiles per column. This gives us the top-left coordinate of the tile sprite in the tile sheet, so we finish the cropping by passing in the <code class="literal">Sheet::Tile_Size</code>.</p><p>The <code class="literal">TileInfo</code> destructor simply frees the texture used for the tile sheet. The rest of the values stored in this structure will be initialized when the map is loaded. Now let's define our tile structure:</p><div class="informalexample"><pre class="programlisting">struct Tile{
    TileInfo* m_properties;
    bool m_warp; // Is the tile a warp.
    // Other flags unique to each tile.
};</pre></div><p>This is the reason why the flyweight pattern is so powerful. The tile objects are incredibly lightweight, if they only store information that can be unique to each tile and not the tile type. The only flag we're interested in so far is if the tile is a warp, which means it loads the next level when the player is standing on it.</p></div><div class="section" title="Designing the map class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec27"/>Designing the map class</h2></div></div></div><p>With tiles <a id="id225" class="indexterm"/>out of the way, we can move on to higher-level structures, such as the game map. Let's begin by creating a few suitable types of containers that will hold the map information, as well as the tile type information:</p><div class="informalexample"><pre class="programlisting">using TileMap = std::unordered_map&lt;TileID,Tile*&gt;;
using TileSet = std::unordered_map&lt;TileID,TileInfo*&gt;;</pre></div><p>The <code class="literal">TileMap</code> type is an <code class="literal">unordered_map</code> container, which holds pointers to <code class="literal">Tile</code> objects that are addressed by an unsigned integer.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>In cases where tile counts are known in advance, it would be prudent to use a container that will not change in size (such as <code class="literal">std::array</code> or a pre-allocated <code class="literal">std::vector</code>) in order to achieve continuous storage, and in turn, much faster access.</p></div></div><p>But wait a minute! Aren't we working in two dimensions? How are we mapping the tiles to only one integer, if the coordinates are represented by two numbers? Well, with a little bit of mathematics, it's entirely possible to manipulate indices of two dimensions to be represented as a single number. This will be covered shortly.</p><p>The <code class="literal">TileSet</code> data type represents the container of all different types of tiles, which are tied to a tile ID that's represented by the unsigned integer. This brings us everything we need in order to write the map header file, which might look a little something like this:</p><div class="informalexample"><pre class="programlisting">class Map{
public:
  Map(SharedContext* l_context, BaseState* l_currentState);
  ~Map();
  Tile* GetTile(unsigned int l_x, unsigned int l_y);
  TileInfo* GetDefaultTile();
  float GetGravity()const;
  unsigned int GetTileSize()const;
  const sf::Vector2u&amp; GetMapSize()const;
  const sf::Vector2f&amp; GetPlayerStart()const;
  void LoadMap(const std::string&amp; l_path);
  void LoadNext();
  void Update(float l_dT);
  void Draw();
private:
  // Method for converting 2D coordinates to 1D ints.
  unsigned int ConvertCoords(unsigned int l_x, unsigned int l_y);
  void LoadTiles(const std::string&amp; l_path);
  void PurgeMap();
  void PurgeTileSet();

  TileSet m_tileSet;
  TileMap m_tileMap;
  sf::Sprite m_background;
  TileInfo m_defaultTile;
  sf::Vector2u m_maxMapSize;
  sf::Vector2f m_playerStart;
  unsigned int m_tileCount;
  unsigned int m_tileSetCount;
  float m_mapGravity;
  std::string m_nextMap;
  bool m_loadNextMap;
  std::string m_backgroundTexture;
  BaseState* m_currentState;
  SharedContext* m_context;
};</pre></div><p>First, we<a id="id226" class="indexterm"/> define all the predictable methods, such as obtaining a tile at specific coordinates, getting various information from the class, and, of course, methods for updating and drawing the map. Let's move on to the implementation of these methods, in order to talk about them more in depth:</p><div class="informalexample"><pre class="programlisting">Map::Map(SharedContext* l_context, BaseState* l_currentState)
    :m_context(l_context), m_defaultTile(l_context), m_maxMapSize(32, 32), m_tileCount(0), m_tileSetCount(0),m_mapGravity(512.f), m_loadNextMap(false),m_currentState(l_currentState)
{
    m_context-&gt;m_gameMap = this;
    LoadTiles("tiles.cfg");
}</pre></div><p>The map constructor initializes its data members to some default values and calls a private method in order to load different types of tiles from the <code class="literal">tiles.cfg</code> file. Fairly standard. Predictably enough, the destructor of this class does nothing out of the ordinary either:</p><div class="informalexample"><pre class="programlisting">Map::~Map(){
    PurgeMap();
    PurgeTileSet();
    m_context-&gt;m_gameMap = nullptr;
}</pre></div><p>Obtaining tiles from the map is done by first converting the 2D coordinates provided as arguments to this method into a single number, and then locating the specific tile in an unordered map:</p><div class="informalexample"><pre class="programlisting">Tile* Map::GetTile(unsigned int l_x, unsigned int l_y){
  auto itr = m_tileMap.find(ConvertCoords(l_x,l_y));
  return(itr != m_tileMap.end() ? itr-&gt;second : nullptr);
}</pre></div><p>The<a id="id227" class="indexterm"/> conversion of coordinates looks like this:</p><div class="informalexample"><pre class="programlisting">unsigned int Map::ConvertCoords(const unsigned int&amp; l_x, const unsigned int&amp; l_y)
{
    return (l_x * m_maxMapSize.x) + l_y; // Row-major.
}</pre></div><p>In order for this to work, we must have the maximum size of the map defined, otherwise it will produce wrong results.</p><p>Updating the map is another crucial part:</p><div class="informalexample"><pre class="programlisting">void Map::Update(float l_dT){
  if(m_loadNextMap){
    PurgeMap();
    m_loadNextMap = false;
    if(m_nextMap != ""){
      LoadMap("media/maps/"+m_nextMap);
    } else {
      m_currentState-&gt;GetStateManager()-&gt;
        SwitchTo(StateType::GameOver);
    }
    m_nextMap = "";
  }
  sf::FloatRect viewSpace = m_context-&gt;m_wind-&gt;GetViewSpace();
  m_background.setPosition(viewSpace.left, viewSpace.top);
}</pre></div><p>Here, it checks the <code class="literal">m_loadNextMap</code> flag. If it's set to <code class="literal">true</code>, the map information gets purged and the next map is loaded, if the data member that holds its handle is set. If it isn't, the application state is set to <code class="literal">GameOver</code>, which will be created later. This will simulate the player beating the game. Finally, we obtain the view space of the window and set our map background's top-left corner to the view space's left corner in order for the background to follow the camera. Let's draw these changes on the screen:</p><div class="informalexample"><pre class="programlisting">void Map::Draw(){
  sf::RenderWindow* l_wind = m_context-&gt;m_wind-&gt;GetRenderWindow();
  l_wind-&gt;draw(m_background);
  sf::FloatRect viewSpace = m_context-&gt;m_wind-&gt;GetViewSpace();

  sf::Vector2i tileBegin(
    floor(viewSpace.left / Sheet::Tile_Size),
    floor(viewSpace.top / Sheet::Tile_Size));
  sf::Vector2i tileEnd(
    ceil((viewSpace.left + viewSpace.width) / Sheet::Tile_Size),
    ceil((viewSpace.top + viewSpace.height) / Sheet::Tile_Size));

  unsigned int count = 0;
  for(int x = tileBegin.x; x &lt;= tileEnd.x; ++x){
    for(int y = tileBegin.y; y &lt;= tileEnd.y; ++y){
      if(x &lt; 0 || y &lt; 0){ continue; }
      Tile* tile = GetTile(x,y);
      if (!tile){ continue; }
      sf::Sprite&amp; sprite = tile-&gt;m_properties-&gt;m_sprite;
      sprite.setPosition(x * Sheet::Tile_Size,
        y * Sheet::Tile_Size);
      l_wind-&gt;draw(sprite);
      ++count;
    }
  }
}</pre></div><p>A pointer <a id="id228" class="indexterm"/>to the render window is obtained through the share context and the background is drawn in the first two lines here. The next three lines serve a purpose, simply known by a name of culling. It is a technique that any good game programmer should utilize, where anything that's not currently within the view space of the screen should be left undrawn. Once again, consider the situation where you have a massive map of size 1000x1000. Although modern hardware nowadays could draw that really fast, there's still no need to waste those clock-cycles when they could instead be used to perform a much better task, instead of bringing something to the screen that isn't even visible. If you are not culling anything in your game, it will eventually start taking serious performance hits.</p><p>The tile coordinates all the way from the top-left corner of the view space to its bottom-right corner are fed into a loop. First, they get evaluated to be positive. If they're negative, the way we calculate our 1D index for the map container will produce some mirroring artifacts, where the same map you see will be repeated over and over again if you go up or left far enough.</p><p>A pointer to a tile is obtained by passing in the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates from the loop. If it is a valid tile, we obtain its sprite from the pointer to the <code class="literal">TileInfo</code> structure. The position of the sprite is set to match the coordinates of the tile and the sprite is drawn on screen.</p><p>Now for a way to erase the entire map:</p><div class="informalexample"><pre class="programlisting">void Map::PurgeMap(){
  m_tileCount = 0;
  for (auto &amp;itr : m_tileMap){
    delete itr.second;
  }
  m_tileMap.clear();
  m_context-&gt;m_entityManager-&gt;Purge();

  if (m_backgroundTexture == ""){ return; }
  m_context-&gt;m_textureManager-&gt;ReleaseResource(m_backgroundTexture);
  m_backgroundTexture = "";
}</pre></div><p>In addition<a id="id229" class="indexterm"/> to clearing the map container, you will notice that we're calling the <code class="literal">Purge</code> method of an entity manager. For now, ignore that line. Entities will be covered shortly. We must also not forget to free up the background texture when erasing the map.</p><p>Emptying the container of different tile types is also a necessary part:</p><div class="informalexample"><pre class="programlisting">void Map::PurgeTileSet(){
  for (auto &amp;itr : m_tileSet){
    delete itr.second;
  }
  m_tileSet.clear();
  m_tileSetCount = 0;
}</pre></div><p>This will most likely only be called in the destructor, but it's still nice to have a separate method. Speaking of different tile types, we need to load them in from a file:</p><div class="informalexample"><pre class="programlisting">void Map::LoadTiles(const std::string&amp; l_path){
  std::ifstream file;
  file.open(Utils::GetWorkingDirectory() + l_path);
  if (!file.is_open()){
    std::cout &lt;&lt; "! Failed loading tile set file: "&lt;&lt; l_path &lt;&lt; std::endl;
    return;
  }
  std::string line;
  while(std::getline(file,line)){
    if (line[0] == '|'){ continue; }
    std::stringstream keystream(line);
    int tileId;
    keystream &gt;&gt; tileId;
    if (tileId &lt; 0){ continue; }
    TileInfo* tile = new TileInfo(m_context,"TileSheet",tileId);
    keystream &gt;&gt; tile-&gt;m_name &gt;&gt; tile-&gt;m_friction.x &gt;&gt; tile-&gt;m_friction.y &gt;&gt; tile-&gt;m_deadly;
    if(!m_tileSet.emplace(tileId,tile).second){
      // Duplicate tile detected!
      std::cout &lt;&lt; "! Duplicate tile type: "&lt;&lt; tile-&gt;m_name &lt;&lt; std::endl;
      delete tile;
    }
  }
  file.close();
}</pre></div><p>The tile ID <a id="id230" class="indexterm"/>gets loaded first, as the <code class="literal">tiles.cfg</code> format suggests. It gets checked for being out of bounds, and if it isn't, dynamic memory is allocated for the tile type, at which point all of its internal data members are initialized to the values from the string stream. If the tile information object cannot be inserted into the tile set container, there must be a duplicate entry, and the dynamic memory is de-allocated.</p><p>Now for the grand finale of the map – the loading method. Since the actual file loading code remains pretty much the same, let's jump right to reading the contents of the map file, starting with tile entries:</p><div class="informalexample"><pre class="programlisting">if(type == "TILE"){
  int tileId = 0;
  keystream &gt;&gt; tileId;
  if (tileId &lt; 0){ std::cout &lt;&lt; "! Bad tile id: " &lt;&lt; tileId &lt;&lt; std::endl;
    continue;
  }
  auto itr = m_tileSet.find(tileId);
  if (itr == m_tileSet.end()){
    std::cout &lt;&lt; "! Tile id(" &lt;&lt; tileId&lt;&lt; ") was not found in tileset." &lt;&lt; std::endl;
    continue;
  }
  sf::Vector2i tileCoords;
  keystream &gt;&gt; tileCoords.x &gt;&gt; tileCoords.y;
  if (tileCoords.x&gt;m_maxMapSize.x || tileCoords.y&gt;m_maxMapSize.y)
  {
    std::cout &lt;&lt; "! Tile is out of range: " &lt;&lt;tileCoords.x &lt;&lt; " " &lt;&lt; tileCoords.y &lt;&lt; std::endl;
    continue;
  }
  Tile* tile = new Tile();
  // Bind properties of a tile from a set.
  tile-&gt;m_properties = itr-&gt;second;
  if(!m_tileMap.emplace(ConvertCoords(
    tileCoords.x,tileCoords.y),tile).second)
  {
    // Duplicate tile detected!
    std::cout &lt;&lt; "! Duplicate tile! : " &lt;&lt; tileCoords.x &lt;&lt; "" &lt;&lt; tileCoords.y &lt;&lt; std::endl;
    delete tile;
    tile = nullptr;
    continue;
  }
  std::string warp;
  keystream &gt;&gt; warp;
  tile-&gt;m_warp = false;
  if(warp == "WARP"){ tile-&gt;m_warp = true; }
} else if ...</pre></div><p>The first <a id="id231" class="indexterm"/>segment of the <code class="literal">TILE</code> line is loaded in, which is the tile ID. It is checked, as per usual, to be within the boundaries of positive numbers and <span class="emphasis"><em>0</em></span>. If it is, the tile information of that specific tile ID is looked up in the tile set. Because we don't want empty tiles around our map, we only proceed if the tile information of the specific ID is located. Next, the tile coordinates are read in and checked for being within the boundaries of the map size. If they are, the memory for the tile is allocated and its tile information data member is set to point to the one located in the tile set. Lastly, we attempt to read in a string at the end of the <code class="literal">TILE</code> line and check if it says "WARP". That's the indication that touching a specific tile should load the next level.</p><p>Now for the background of the map:</p><div class="informalexample"><pre class="programlisting">} else if(type == "BACKGROUND"){
  if (m_backgroundTexture != ""){ continue; }
  keystream &gt;&gt; m_backgroundTexture;
  if (!m_context-&gt;m_textureManager-&gt;RequireResource(m_backgroundTexture))
  {
    m_backgroundTexture = "";
    continue;
  }
  sf::Texture* texture = m_context-&gt;m_textureManager-&gt;GetResource(m_backgroundTexture);
  m_background.setTexture(*texture);
  sf::Vector2f viewSize = m_currentState-&gt;GetView().getSize();
  sf::Vector2u textureSize = texture-&gt;getSize();
  sf::Vector2f scaleFactors;
  scaleFactors.x = viewSize.x / textureSize.x;
  scaleFactors.y = viewSize.y / textureSize.y;
  m_background.setScale(scaleFactors);
} else if ...</pre></div><p>This one is quite straightforward. A texture handle gets loaded from the <code class="literal">BACKGROUND</code> line. If the handle is valid, the background sprite gets tied to the texture. There is a catch though. Let's say that the view of our window is larger than the texture of the background. That would result in empty areas all around the background, which looks horrendous. Repeating the texture might remedy the empty areas, but the specific backgrounds<a id="id232" class="indexterm"/> we're going to be working with don't tile well, so the best solution is to scale the sprite enough to fit the view space fully, whether it's larger or smaller. The factors of the scaling can be obtained by multiplying the size of the view by the size of the texture. If, for example, we have a view that's 800x600 px large and a texture of a size 400x300 px, the scale factor for both axes would be 2 and the background is scaled up to twice its size.</p><p>Next is the easy part of simply reading in some data members from a file:</p><div class="informalexample"><pre class="programlisting">} else if(type == "SIZE"){
    keystream &gt;&gt; m_maxMapSize.x &gt;&gt; m_maxMapSize.y;
} else if(type == "GRAVITY"){
    keystream &gt;&gt; m_mapGravity;
} else if(type == "DEFAULT_FRICTION"){
    keystream &gt;&gt; m_defaultTile-&gt;m_friction.x &gt;&gt; m_defaultTile-&gt;m_friction.y;
} else if(type == "NEXTMAP"){
    keystream &gt;&gt; m_nextMap;
}</pre></div><p>Let's wrap this class up with a little helper method that will help us keep track of when the next map should be loaded:</p><div class="informalexample"><pre class="programlisting">void Map::LoadNext(){ m_loadNextMap = true; }</pre></div><p>This concludes the map class implementation. The world now exists, but nobody is there to occupy it. Outrageous! Let's not insult our work and create some entities to explore the environments we conjure up.</p></div></div>
<div class="section" title="The parent of all world objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec63"/>The parent of all world objects</h1></div></div></div><p>An entity is <a id="id233" class="indexterm"/>essentially just another word for a game object. It's an abstract class that acts as a parent to all of its derivatives, which include the player, enemies, and perhaps even items, depending on how you want to implement that. Having these entirely different concepts share the same roots allows the programmer to define types of behavior that are common to all of them. Moreover, it lets the game engine act upon them in the same manner, as they all share the same interface. For example, the enemy can be pushed, and so can the player. All enemies, items, and the player have to be affected by gravity as well. Having that common ancestry between these different types allows us to offload a lot of redundant code and focus on the aspects that are unique to each entity, instead of re-writing the same code over and over again.</p><p>Let's begin<a id="id234" class="indexterm"/> by defining what entity types we're going to be dealing with:</p><div class="informalexample"><pre class="programlisting">enum class EntityType{ Base, Enemy, Player };</pre></div><p>The base entity type is just the abstract class, which will not actually be instantiated. That leaves us with enemies and a player. Now to set up all the possible states an entity can have:</p><div class="informalexample"><pre class="programlisting">enum class EntityState{
    Idle, Walking, Jumping, Attacking, Hurt, Dying
};</pre></div><p>You have probably noticed that these states vaguely match the animations from the player sprite sheet. All character entities will be modeled this way.</p><div class="section" title="Creating the base entity class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec28"/>Creating the base entity class</h2></div></div></div><p>In cases<a id="id235" class="indexterm"/> where entities are built using inheritance, writing a basic parent class like this is fairly common. It has to provide any and all functionality that any given entity within the game should have. </p><p>With all of the setting up out of the way, we can finally start shaping it like so:</p><div class="informalexample"><pre class="programlisting">class EntityManager;
class EntityBase{
friend class EntityManager;
public:
  EntityBase(EntityManager* l_entityMgr);
  virtual ~EntityBase();
  ... // Getters and setters.
  void Move(float l_x, float l_y);
  void AddVelocity(float l_x, float l_y);
  void Accelerate(float l_x, float l_y);
  void SetAcceleration(float l_x, float l_y);
  void ApplyFriction(float l_x, float l_y);
  virtual void Update(float l_dT);
  virtual void Draw(sf::RenderWindow* l_wind) = 0;
protected:
  // Methods.
  void UpdateAABB();
  void CheckCollisions();
  void ResolveCollisions();
  // Method for what THIS entity does TO the l_collider entity.
  virtual void OnEntityCollision(EntityBase* l_collider,bool l_attack) = 0;
  // Data members.
  std::string m_name;
  EntityType m_type;
  unsigned int m_id; // Entity id in the entity manager.
  sf::Vector2f m_position; // Current position.
  sf::Vector2f m_positionOld; // Position before entity moved.
  sf::Vector2f m_velocity; // Current velocity.
  sf::Vector2f m_maxVelocity; // Maximum velocity.
  sf::Vector2f m_speed; // Value of acceleration.
  sf::Vector2f m_acceleration; // Current acceleration.
  sf::Vector2f m_friction; // Default friction value.
  TileInfo* m_referenceTile; // Tile underneath entity.
  sf::Vector2f m_size; // Size of the collision box.
  sf::FloatRect m_AABB; // The bounding box for collisions.
  EntityState m_state; // Current entity state.
  // Flags for remembering axis collisions.
  bool m_collidingOnX;
  bool m_collidingOnY;

  Collisions m_collisions;
  EntityManager* m_entityManager;
};</pre></div><p>Right <a id="id236" class="indexterm"/>off the bat, we set up the <code class="literal">EntityManager</code> class that we haven't written yet to be a friend class of the base entities. Because the code might be a little confusing, a barrage of comments was added to explain every data member of the class, so we're not going to touch on those too much until we encounter them during the implementation of the class.</p><p>The three major properties of an entity include its position, velocity, and acceleration. The position of an entity is self explanatory. Its velocity represents how fast an entity is moving. Because all of the update methods in our application take in the delta time in seconds, the velocity is going to represent the number of pixels that an entity moves across per second. The last element of the major three is acceleration, which is responsible for how fast the entity's velocity increases. It, too, is defined as the number of pixels per second that get added to the entity's velocity. The sequence of events here is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The entity is accelerated and its acceleration adjusts its velocity.</li><li class="listitem">The entity's position is re-calculated based on its velocity.</li><li class="listitem">The velocity of an entity is damped by the friction coefficient.</li></ol></div><div class="section" title="Collisions and bounding boxes"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec04"/>Collisions and bounding boxes</h3></div></div></div><p>Before<a id="id237" class="indexterm"/> jumping into <a id="id238" class="indexterm"/>implementations, let's talk about one of the most commonly used elements in all games – collisions. Detecting and resolving a collision is what keeps the player from falling through the map or going outside the screen. It's also what determines if a player gets hurt if they get touched by the enemy. In a round-about way, we used a basic form of collision detection in order to determine which tiles we should render in the map class. How does one detect and resolve collisions? There are many ways to do so, but for our purposes, the most basic form of a bounding box collision will do just fine. Other types of collisions that incorporate different shapes, such as circles, can also be used, but may not be the most efficient or <a id="id239" class="indexterm"/>appropriate depending<a id="id240" class="indexterm"/> on the kind of game that's being built.</p><p>A bounding box, much like it sounds, is a box or a rectangle which represents the solid portion of an entity. Here's a good example of a bounding box:</p><div class="mediaobject"><img src="graphics/B04284_07_03.jpg" alt="Collisions and bounding boxes"/></div><p>It isn't visible like that, unless we create an actual <code class="literal">sf::RectangleShape</code> with the same position and size as the bounding box and render that, which is a useful way to debug your applications. In our base entity class, the bounding box named <code class="literal">m_AABB</code> is simply a <code class="literal">sf::FloatRect</code> type. The name "AABB" represents two pairs of different values it holds: the position and the size. Bounding box collision, also referred to as an AABB collision, is simply a situation where two bounding boxes intersect with one another. The rectangle data types in SFML provide us with a method that checks for intersections:</p><div class="informalexample"><pre class="programlisting">if(m_AABB.intersects(SomeRectangle){...}</pre></div><p>The term collision resolution simply means performing some sequence of actions in order to notify and move the colliding entities. In a case of collision with tiles, for example, the collision<a id="id241" class="indexterm"/> resolution means pushing the entity back just far <a id="id242" class="indexterm"/>enough so it isn't intersecting with the tile any more.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>The code files of this project contain an additional class that allows debug information rendering to take place, as well as all of these bits of information already set up. Hitting the <span class="emphasis"><em>O</em></span> key will toggle its visibility.</p></div></div></div></div><div class="section" title="Implementing the base entity class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec29"/>Implementing the base entity class</h2></div></div></div><p>With all <a id="id243" class="indexterm"/>of that information out of the way, we can finally return to implementing the base entity class. As always, what better place is there to start than the constructor? Let's take a look:</p><div class="informalexample"><pre class="programlisting">EntityBase::EntityBase(EntityManager* l_entityMgr)
  :m_entityManager(l_entityMgr), m_name("BaseEntity"),
  m_type(EntityType::Base), m_referenceTile(nullptr),
  m_state(EntityState::Idle), m_id(0),
  m_collidingOnX(false), m_collidingOnY(false){}</pre></div><p>It simply initializes all of its data members to default values. Notice that out of all the members it sets to zero, the friction actually gets set up for the <span class="emphasis"><em>x</em></span> axis to be 0.8. This is because we don't want the default behavior of the entity to be equal to that of a cow on ice, to put it frankly. Friction defines how much of the entity's velocity is lost to the environment. If it doesn't make too much sense now, don't worry. We're about to cover it in greater detail.</p><p>Here we have all of the methods for modifying data members of the entity base class:</p><div class="informalexample"><pre class="programlisting">void EntityBase::SetPosition(const float&amp; l_x, const float&amp; l_y){
    m_position = sf::Vector2f(l_x,l_y);
    UpdateAABB();
}
void EntityBase::SetPosition(const sf::Vector2f&amp; l_pos){
    m_position = l_pos;
    UpdateAABB();
}
void EntityBase::SetSize(const float&amp; l_x, const float&amp; l_y){
    m_size = sf::Vector2f(l_x,l_y);
    UpdateAABB();
}
void EntityBase::SetState(const EntityState&amp; l_state){
    if(m_state == EntityState::Dying){ return; }
    m_state = l_state;
}</pre></div><p>As you can see, modifying either the position or size of an entity results in a call of the internal method <code class="literal">UpdateAABB</code>. Simply put, it's responsible for updating the position of the bounding box. More information on that is coming soon.</p><p>One<a id="id244" class="indexterm"/> interesting thing to note is in the <code class="literal">SetState</code> method. It does not allow the state to change if the current state is <code class="literal">Dying</code>. This is done in order to prevent some other event in the game to snap an entity out of death magically.</p><p>Now we have a more interesting chunk of code, responsible for moving an entity:</p><div class="informalexample"><pre class="programlisting">void EntityBase::Move(float l_x, float l_y){
  m_positionOld = m_position;
  m_position += sf::Vector2f(l_x,l_y);
  sf::Vector2u mapSize = m_entityManager-&gt;GetContext()-&gt;m_gameMap-&gt;GetMapSize();
  if(m_position.x &lt; 0){
    m_position.x = 0;
  } else if(m_position.x &gt; (mapSize.x + 1) * Sheet::Tile_Size){
    m_position.x = (mapSize.x + 1) * Sheet::Tile_Size;
  }

  if(m_position.y &lt; 0){
    m_position.y = 0;
  } else if(m_position.y &gt; (mapSize.y + 1) * Sheet::Tile_Size){
    m_position.y = (mapSize.y + 1) * Sheet::Tile_Size;
    SetState(EntityState::Dying);
  }

  UpdateAABB();
}</pre></div><p>First, we copy the current position to another data member: <code class="literal">m_positionOld</code>. It's always good to keep track of this information, in case we need it later. Then, the position is adjusted by the offset provided through the arguments. The size of the map is obtained afterwards, in order to check the current position for being outside of the map. If it is on either axis, we simply reset its position to something that's at the very edge of the out-of-bounds area. In the case of the entity being outside of the map on the <span class="emphasis"><em>y</em></span> axis, its state is set to <code class="literal">Dying</code>. After all of that, the bounding box is updated in order to reflect the changes to the position of the entity sprite.</p><p>Now let's work on adding to and managing the entity's velocity:</p><div class="informalexample"><pre class="programlisting">void EntityBase::AddVelocity(float l_x, float l_y){
  m_velocity += sf::Vector2f(l_x,l_y);
  if(abs(m_velocity.x) &gt; m_maxVelocity.x){
    if(m_velocity.x &lt; 0){ m_velocity.x = -m_maxVelocity.x; }
    else { m_velocity.x = m_maxVelocity.x; }
  }

  if(abs(m_velocity.y) &gt; m_maxVelocity.y){
    if(m_velocity.y &lt; 0){ m_velocity.y = -m_maxVelocity.y; }
    else { m_velocity.y = m_maxVelocity.y; }
  }
}</pre></div><p>As you can<a id="id245" class="indexterm"/> see, it's fairly simple stuff. The velocity member is added to and then checked for being outside of the bounds of allowed maximum velocity. In the first check we're using absolute values, because velocity can be both positive and negative, which indicates the direction the entity's moving in. If the velocity is out of bounds, it gets reset to the maximum allowed value it can have.</p><p>Accelerating an entity, you could say, is as simple as adding one vector to another:</p><div class="informalexample"><pre class="programlisting">void EntityBase::Accelerate(float l_x, float l_y){
    m_acceleration += sf::Vector2f(l_x,l_y);
}</pre></div><p>Applying friction is no more complex than managing our velocity:</p><div class="informalexample"><pre class="programlisting">void EntityBase::ApplyFriction(float l_x, float l_y){
  if(m_velocity.x != 0){
    if(abs(m_velocity.x) - abs(l_x) &lt; 0){ m_velocity.x = 0; }
    else {
      if(m_velocity.x &lt; 0){ m_velocity.x += l_x; }
      else { m_velocity.x -= l_x; }
    }
  }

  if(m_velocity.y != 0){
    if (abs(m_velocity.y) - abs(l_y) &lt; 0){ m_velocity.y = 0; }
    else {
      if(m_velocity.y &lt; 0){ m_velocity.y += l_y; }
      else { m_velocity.y -= l_y; }
    }
  }
}</pre></div><p>It needs to check if the difference between the absolute values of both the velocity and the friction coefficient on that axis isn't less than zero, in order to prevent changing the direction of the entity's movement through friction, which would simply be weird. If it is less than zero, the velocity gets set back to zero. If it isn't, the velocity's sign is checked and friction in the proper direction is applied.</p><p>In order for <a id="id246" class="indexterm"/>an entity to not be a static part of the backdrop, it needs to be updated:</p><div class="informalexample"><pre class="programlisting">void EntityBase::Update(float l_dT){
  Map* map = m_entityManager-&gt;GetContext()-&gt;m_gameMap;
  float gravity = map-&gt;GetGravity();
  Accelerate(0,gravity);
  AddVelocity(m_acceleration.x * l_dT, m_acceleration.y * l_dT);
  SetAcceleration(0.0f, 0.0f);
  sf::Vector2f frictionValue;
  if(m_referenceTile){
    frictionValue = m_referenceTile-&gt;m_friction;
    if(m_referenceTile-&gt;m_deadly){ SetState(EntityState::Dying); }
  } else if(map-&gt;GetDefaultTile()){
    frictionValue = map-&gt;GetDefaultTile()-&gt;m_friction;
  } else {
    frictionValue = m_friction;
  }

  float friction_x = (m_speed.x * frictionValue.x) * l_dT;
  float friction_y = (m_speed.y * frictionValue.y) * l_dT;
  ApplyFriction(friction_x, friction_y);
  sf::Vector2f deltaPos = m_velocity * l_dT;
  Move(deltaPos.x, deltaPos.y);
  m_collidingOnX = false;
  m_collidingOnY = false;
  CheckCollisions();
  ResolveCollisions();
}</pre></div><p>Quite a bit is happening here. Let's take it step by step. First, an instance of the game map is obtained through the shared context. It is then used to obtain the gravity of the map, which was loaded from the map file. The entity's acceleration is then increased by the gravity on the <span class="emphasis"><em>y</em></span> axis. By using the <code class="literal">AddVelocity</code> method and passing in the acceleration multiplied by delta time, the velocity is adjusted and the acceleration is set back to zero. Next, we must obtain the friction coefficient that the velocity will be damped by. The <code class="literal">m_referenceTile</code> data member, if it's not set to <code class="literal">nullptr</code>, is used first, in order to obtain the friction from a tile the entity's standing on. If it is set to <code class="literal">nullptr</code>, the entity must be in mid-air, so the default tile from the map is obtained to grab the friction values that were loaded from the map file. If that, for whatever reason, is also not set up, we default to the value set in the <code class="literal">EntityBase</code>'s constructor.</p><p>Before we get to calculating friction, it's important to clarify that the <code class="literal">m_speed</code> data member is not set up or initialized in this class, aside from being set to a default value. The speed is how much an entity is accelerated when it's moving and it will be implemented in one of the derived classes of <code class="literal">EntityBase</code>.</p><p>If you recall<a id="id247" class="indexterm"/> from the constructor of this class, we set up the default friction to be 0.8f. That is not just an incredibly small value. We're using friction as a factor in order to determine how much of the entity's speed should be lost. Having said that, multiplying the speed by a friction coefficient and multiplying that by delta time yields us the velocity that is lost during this frame, which is then passed into the <code class="literal">ApplyFriction</code> method in order to manipulate the velocity.</p><p>Finally, the change in position, called <code class="literal">deltaPos</code> is calculated by multiplying the velocity by delta time, and is passed into the <code class="literal">Move</code> method to adjust the entity's position in the world. The flags for collisions on both axes get reset to false and the entity calls its own private members for first obtaining and then resolving collisions.</p><p>Let's take a look at the method responsible for updating the bounding box:</p><div class="informalexample"><pre class="programlisting">void EntityBase::UpdateAABB(){
  m_AABB = sf::FloatRect(m_position.x - (m_size.x / 2),m_position.y - m_size.y, m_size.x, m_size.y);
}</pre></div><p>Because the origin of the bounding box is left at the top-left corner and the entity's position is set to (width / 2, height), accounting for that is necessary if we want to have accurate collisions. The rectangle that represents the bounding box is reset to match the new position of the sprite.</p></div><div class="section" title="Entity-on-tile collisions"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec30"/>Entity-on-tile collisions</h2></div></div></div><p>Before <a id="id248" class="indexterm"/>jumping into collision detection and resolution, let's<a id="id249" class="indexterm"/> revisit the method SFML provides to check if two rectangles are intersecting:</p><div class="informalexample"><pre class="programlisting">sf::FloatRect r1;
sf::FloatRect r2;
if(r1.intersects(r2)){ ... }</pre></div><p>It doesn't matter which rectangle we check, the intersecting method will still return true if they are intersecting. However, this method does take in an optional second argument, which is a reference of a rectangle class that will be filled with the information about the intersection itself. Consider the following illustration:</p><div class="mediaobject"><img src="graphics/B04284_07_04.jpg" alt="Entity-on-tile collisions"/></div><p>We have <a id="id250" class="indexterm"/>two rectangles that are intersecting. The <a id="id251" class="indexterm"/>diagonal striped area represents the rectangle of intersection, which can be obtained by doing this:</p><div class="informalexample"><pre class="programlisting">...
sf::FloatRect intersection;
if(r1.intersects(r2,intersection)){ ... }</pre></div><p>This is important to us, because an entity could be colliding with more than one tile at a time. Knowing the depth of a collision is also a crucial part of resolving it. With that in mind, let's define a structure to temporarily hold the collision information before it gets resolved:</p><div class="informalexample"><pre class="programlisting">struct CollisionElement{
  CollisionElement(float l_area, TileInfo* l_info,const sf::FloatRect&amp; l_bounds):m_area(l_area), m_tile(l_info), m_tileBounds(l_bounds){}
  float m_area;
  TileInfo* m_tile;
  sf::FloatRect m_tileBounds;
};

using Collisions = std::vector&lt;CollisionElement&gt;;</pre></div><p>First, we're creating a structure that holds a floating point number representing the area of collision, a rectangle that holds the boundary information of a tile the entity's colliding with, and a pointer to a <code class="literal">TileInfo</code> instance. You always want to resolve the biggest collisions first, and this information is going to help us do just that. The collision elements themselves are going to be stored in a vector this time.</p><p>Next, we need a function that can compare two elements of our custom container in order to sort it, the blueprint of which in the header file of the <code class="literal">EntityBase</code> class looks like this:</p><div class="informalexample"><pre class="programlisting">bool SortCollisions(const CollisionElement&amp; l_1,const CollisionElement&amp; l_2);</pre></div><p>Implementing<a id="id252" class="indexterm"/> this function is incredibly easy. The <a id="id253" class="indexterm"/>vector container simply uses a Boolean check to determine which one of the two elements it's comparing is larger. We simply return true or false, based on which element is bigger. Because we're sorting our container by the area size, the comparison is done between the first elements of the first pairs:</p><div class="informalexample"><pre class="programlisting">bool SortCollisions(const CollisionElement&amp; l_1,const CollisionElement&amp; l_2)
{ return l_1.m_area &gt; l_2.m_area; }</pre></div><p>Now onto the interesting part, detecting the collisions:</p><div class="informalexample"><pre class="programlisting">void EntityBase::CheckCollisions(){
  Map* gameMap = m_entityManager-&gt;GetContext()-&gt;m_gameMap;
  unsigned int tileSize = gameMap-&gt;GetTileSize();
  int fromX = floor(m_AABB.left / tileSize);
  int toX = floor((m_AABB.left + m_AABB.width) / tileSize);
  int fromY = floor(m_AABB.top / tileSize);
  int toY = floor((m_AABB.top + m_AABB.height) / tileSize);

  for(int x = fromX; x &lt;= toX; ++x){
    for(int y = fromY; y &lt;= toY; ++y){
      Tile* tile = gameMap-&gt;GetTile(x,y);
      if (!tile){ continue; }
      sf::FloatRect tileBounds(x * tileSize, y * tileSize,
        tileSize,tileSize);
      sf::FloatRect intersection;
      m_AABB.intersects(tileBounds,intersection);
      float area = intersection.width * intersection.height;

      CollisionElement e(area, tile-&gt;m_properties, tileBounds);
      m_collisions.emplace_back(e);
      if(tile-&gt;m_warp &amp;&amp; m_type == EntityType::Player){
        gameMap-&gt;LoadNext();
      }
    }
  }
}</pre></div><p>We begin by using the coordinates and size of the bounding box to obtain the coordinates of tiles it is potentially intersecting. This is illustrated better in the following image:</p><div class="mediaobject"><img src="graphics/B04284_07_05.jpg" alt="Entity-on-tile collisions"/></div><p>The range<a id="id254" class="indexterm"/> of tile coordinates represented by<a id="id255" class="indexterm"/> the four integers is then fed into a double loop which checks if there is a tile occupying the space we're interested in. If a tile is returned from the <code class="literal">GetTile</code> method, the bounding box of the entity is definitely intersecting a tile, so a float rectangle that represents the bounding box of a tile is created. We also prepare another float rectangle to hold the data of the intersection and call the <code class="literal">intersects</code> method in order to obtain this information. The area of the intersection is calculated by multiplying its width and height, and the information about the collision is pushed into the collision container, along with a pointer to the <code class="literal">TileInfo</code> object that represents the type of tile the entity is colliding with.</p><p>The last thing we do before wrapping up this method is check if the current tile the entity is colliding with is a warp tile and if the entity is a player. If both of these conditions are met, the next map is loaded.</p><p>Now that a list of collisions for an entity has been obtained, resolving them is the next step:</p><div class="informalexample"><pre class="programlisting">void EntityBase::ResolveCollisions(){
  if(!m_collisions.empty()){
    std::sort(m_collisions.begin(),m_collisions.end(), SortCollisions);
    Map* gameMap = m_entityManager-&gt;GetContext()-&gt;m_gameMap;
    unsigned int tileSize = gameMap-&gt;GetTileSize();
    for (auto &amp;itr : m_collisions){
      if (!m_AABB.intersects(itr.m_tileBounds)){ continue; }
      float xDiff = (m_AABB.left + (m_AABB.width / 2)) -(itr.m_tileBounds.left + (itr.m_tileBounds.width / 2));
      float yDiff = (m_AABB.top + (m_AABB.height / 2)) -(itr.m_tileBounds.top + (itr.m_tileBounds.height / 2));
      float resolve = 0;
      if(abs(xDiff) &gt; abs(yDiff)){
        if(xDiff &gt; 0){
          resolve = (itr.m_tileBounds.left + tileSize) –m_AABB.left;
        } else {
          resolve = -((m_AABB.left + m_AABB.width) –itr.m_tileBounds.left);
        }
        Move(resolve, 0);
        m_velocity.x = 0;
        m_collidingOnX = true;
      } else {
        if(yDiff &gt; 0){
          resolve = (itr.m_tileBounds.top + tileSize) –
            m_AABB.top;
        } else {
          resolve = - ((m_AABB.top + m_AABB.height) –itr.m_tileBounds.top);
        }
        Move(0,resolve);
        m_velocity.y = 0;
        if (m_collidingOnY){ continue; }
        m_referenceTile = itr.m_tile;
        m_collidingOnY = true;
      }
    }
    m_collisions.clear();
  }
  if(!m_collidingOnY){ m_referenceTile = nullptr; }
}</pre></div><p>First, we<a id="id256" class="indexterm"/> check if there are any collisions in<a id="id257" class="indexterm"/> the container. Sorting of all the elements happens next. The <code class="literal">std::sort</code> function is called and iterators to the beginning and end of the container are passed in, along with the name of the function that will do the comparisons between the elements.</p><p>The code proceeds to loop over all of the collisions stored in the container. There is another intersection check here between the bounding box of the entity and the tile. This is done because resolving a previous collision could have moved an entity in such a way that it is no longer colliding with the next tile in the container. If there still is a collision, distances from the center of the entity's bounding box to the center of the tile's bounding box are calculated. The first purpose these distances serve is illustrated in the next line, where their absolute values get compared. If the distance on the x axis is bigger than on the y axis, the resolution takes place on the x axis. Otherwise, it's resolved on the y axis.</p><p>The second purpose of the distance calculation is determining which side of the tile the entity is on. If the distance is positive, the entity is on the right side of the tile, so it gets moved in the positive x direction. Otherwise, it gets moved in the negative x direction. The <span class="emphasis"><em>resolve</em></span> <a id="id258" class="indexterm"/>variable takes in the amount of penetration<a id="id259" class="indexterm"/> between the tile and the entity, which is different based on the axis and the side of the collision.</p><p>In the case of both axes, the entity is moved by calling its <code class="literal">Move</code> method and passing in the depth of penetration. Killing the entity's velocity on that axis is also important, in order to simulate the entity hitting a solid. Lastly, the flag for a collision on a specific axis is set to true.</p><p>If a collision is resolved on the y axis, in addition to all the same steps that are taken in a case of x axis collision resolution, we also check if the flag is set for a y axis collision. If it hasn't been set yet, we change the <code class="literal">m_referenceTile</code> data member to point to the tile type of the current tile the entity is colliding with, which is followed by that flag getting set to true in order to keep the reference unchanged until the next time collisions are checked. This little snippet of code gives any entity the ability to behave differently based on which tile it's standing on. For example, the entity can slide a lot more on ice tiles than on simple grass tiles, as illustrated here:</p><div class="mediaobject"><img src="graphics/B04284_07_06.jpg" alt="Entity-on-tile collisions"/></div><p>As the arrow points out, the friction coefficient of these tiles is different, which means we are in fact obtaining the information from the tiles directly below.</p></div></div>
<div class="section" title="Entity storage and management"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Entity storage and management</h1></div></div></div><p>Without<a id="id260" class="indexterm"/> proper management, these entities are just random classes scattered about in your memory with no rhyme or reason. In order to produce a robust way to create interactions between entities, they need to be babysat by a manager class. Before we begin designing it, let's define some data types to contain the information we're going to be working with:</p><div class="informalexample"><pre class="programlisting">using EntityContainer = std::unordered_map&lt;unsigned int,EntityBase*&gt;;
using EntityFactory = std::unordered_map&lt;EntityType, std::function&lt;EntityBase*(void)&gt;&gt;;
using EnemyTypes = std::unordered_map&lt;std::string,std::string&gt;;</pre></div><p>The <code class="literal">EntityContainer</code> type is, as the name suggests, a container of entities. It is once again powered by an <code class="literal">unordered_map</code>, which ties instances of entities to unsigned integers that serve as identifiers. The next type is a container of lambda functions that links entity types to code that can allocate memory and return instances of classes that inherit from the base entity class and serves as a factory. This behavior isn't new to us, so let's move on to defining the entity manager class:</p><div class="informalexample"><pre class="programlisting">class EntityManager{
public:
  EntityManager(SharedContext* l_context,unsigned int l_maxEntities);
  ~EntityManager();

  int Add(const EntityType&amp; l_type,const std::string&amp; l_name = "");
  EntityBase* Find(unsigned int l_id);
  EntityBase* Find(const std::string&amp; l_name);
  void Remove(unsigned int l_id);

  void Update(float l_dT);
  void Draw();

  void Purge();

  SharedContext* GetContext();
private:
  template&lt;class T&gt;
  void RegisterEntity(const EntityType&amp; l_type){
    m_entityFactory[l_type] = [this]() -&gt; EntityBase*
    {
      return new T(this);
    };
  }

  void ProcessRemovals();
  void LoadEnemyTypes(const std::string&amp; l_name);
  void EntityCollisionCheck();

  EntityContainer m_entities;
  EnemyTypes m_enemyTypes;
  EntityFactory m_entityFactory;
  SharedContext* m_context;
  unsigned int m_idCounter;
  unsigned int m_maxEntities;

  std::vector&lt;unsigned int&gt; m_entitiesToRemove;
};</pre></div><p>Aside <a id="id261" class="indexterm"/>from the private template method for inserting lambda functions into the entity factory container, this looks like a relatively typical class. We have methods for updating and drawing entities, adding, finding and removing them and purging all of the data, as we tend to do. The presence of the private method called <code class="literal">ProcessRemovals</code> insists that we're using delayed removals of entities, much like we did in our state manager class. Let's take a closer look at how this class will operate by implementing it.</p><div class="section" title="Implementing the entity manager"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec31"/>Implementing the entity manager</h2></div></div></div><p>As <a id="id262" class="indexterm"/>always, a good place to start is the constructor:</p><div class="informalexample"><pre class="programlisting">EntityManager::EntityManager(SharedContext* l_context,unsigned int l_maxEntities):m_context(l_context),m_maxEntities(l_maxEntities), m_idCounter(0)
{
    LoadEnemyTypes("EnemyList.list");
    RegisterEntity&lt;Player&gt;(EntityType::Player);
    RegisterEntity&lt;Enemy&gt;(EntityType::Enemy);
}
EntityManager::~EntityManager(){ Purge(); }</pre></div><p>Some of its data members are initialized through an initializer list. The <code class="literal">m_idCounter</code> variable will be used to keep track of the highest ID that was given to an entity. Next, a private method is invoked for loading pairs of enemy names and their character definition files, which will be explained a little later.</p><p>Lastly, two entity types are registered: player and enemy. We don't have their classes set up yet, but it's coming soon, so we may as well just register them now.</p><p>The destructor of an entity manager simply invokes the <code class="literal">Purge</code> method.</p><p>Adding a new entity to the game is done by passing in an entity type along with its name to the <code class="literal">Add</code> method <a id="id263" class="indexterm"/>of the entity manager:</p><div class="informalexample"><pre class="programlisting">int EntityManager::Add(const EntityType&amp; l_type,const std::string&amp; l_name)
{
  auto itr = m_entityFactory.find(l_type);
  if (itr == m_entityFactory.end()){ return -1; }
  EntityBase* entity = itr-&gt;second();
  entity-&gt;m_id = m_idCounter;
  if (l_name != ""){ entity-&gt;m_name = l_name; }
  m_entities.emplace(m_idCounter,entity);
  if(l_type == EntityType::Enemy){
    auto itr = m_enemyTypes.find(l_name);
    if(itr != m_enemyTypes.end()){
      Enemy* enemy = (Enemy*)entity;
      enemy-&gt;Load(itr-&gt;second);
    }
  }

  ++m_idCounter;
  return m_idCounter - 1;
}</pre></div><p>The entity factory container is searched for the type that was provided as an argument. If that type is registered, the lambda function is invoked to allocate dynamic memory for the entity and the memory address is caught by a pointer variable to the <code class="literal">EntityBase</code> class – <code class="literal">entity</code>. The newly created entity is then inserted into the entity container and its ID is set up by using the <code class="literal">m_idCounter</code> data member. If the user provides an argument for the entity name, it gets set up as well.</p><p>The entity type then gets checked. If it's an enemy, the enemy type container is searched in order to locate the path to a character definition file. If it's found, the entity is type-cast into an enemy instance and a <code class="literal">Load</code> method is called, to which the character file path is passed.</p><p>Lastly, the ID counter is incremented and the entity ID that was just used gets returned to signify success. If the method failed at any point, it will instead return <span class="emphasis"><em>-1</em></span>, signifying a failure.</p><p>Having an entity manager is pointless if you can't obtain the entities. That's where the <code class="literal">Find</code> method comes in:</p><div class="informalexample"><pre class="programlisting">EntityBase* EntityManager::Find(const std::string&amp; l_name){
  for(auto &amp;itr : m_entities){
    if(itr.second-&gt;GetName() == l_name){
      return itr.second;
    }
  }
  return nullptr;
}</pre></div><p>Our entity manager provides two versions of this method. The first version takes in an entity name <a id="id264" class="indexterm"/>and searches the container until an entity is found with that name, at which point it gets returned. The second version looks up entities based on a numerical identifier:</p><div class="informalexample"><pre class="programlisting">EntityBase* EntityManager::Find(unsigned int l_id){
  auto itr = m_entities.find(l_id);
  if (itr == m_entities.end()){ return nullptr; }
  return itr-&gt;second;
}</pre></div><p>Because we map instances of entities to numerical values, this is easier, as we can simply call the <code class="literal">Find</code> method of our container in order to find the element we're looking for.</p><p>Now let's work on removing entities:</p><div class="informalexample"><pre class="programlisting">void EntityManager::Remove(unsigned int l_id){
    m_entitiesToRemove.emplace_back(l_id);
}</pre></div><p>This is the public method that takes in an entity ID and inserts it into a container, which will be used later to remove entities.</p><p>Updating all entities can be achieved as follows:</p><div class="informalexample"><pre class="programlisting">void EntityManager::Update(float l_dT){
  for(auto &amp;itr : m_entities){
    itr.second-&gt;Update(l_dT);
  }
  EntityCollisionCheck();
  ProcessRemovals();
}</pre></div><p>The manager iterates through all of its elements and invokes their respective <code class="literal">Update</code> methods by passing in the delta time it receives as an argument. After all of the entities are updated, a private method <code class="literal">EntityCollisionCheck</code> is invoked in order to check for and resolve collisions between entities. Then, we process the entity removals that were added by the <code class="literal">Remove</code> method implemented previously.</p><p>Let's take a look at how we can draw all of these entities:</p><div class="informalexample"><pre class="programlisting">void EntityManager::Draw(){
  sf::RenderWindow* wnd = m_context-&gt;m_wind-&gt;GetRenderWindow();
  sf::FloatRect viewSpace = m_context-&gt;m_wind-&gt;GetViewSpace();
  
  for(auto &amp;itr : m_entities){
    if (!viewSpace.intersects(itr.second-&gt;m_AABB)){ continue; }
    itr.second-&gt;Draw(wnd);
  }
}</pre></div><p>After <a id="id265" class="indexterm"/>obtaining a pointer to the render window, we also get the view space of it in order to cull entities for efficiency reasons. Because both the view space and the bounding box of an entity are rectangles, we can simply check if they're intersecting in order to determine if an entity is within the view space, and if it is, it gets drawn.</p><p>The entity manager needs to have a way to dispatch of all of its resources. This is where the <code class="literal">Purge</code> method comes in:</p><div class="informalexample"><pre class="programlisting">void EntityManager::Purge(){
  for (auto &amp;itr : m_entities){
    delete itr.second;
  }
  m_entities.clear();
  m_idCounter = 0;
}</pre></div><p>Entities get iterated over and their dynamic memory is de-allocated – regular as clockwork. Now to process the entities that need to be removed:</p><div class="informalexample"><pre class="programlisting">void EntityManager::ProcessRemovals(){
  while(m_entitiesToRemove.begin() != m_entitiesToRemove.end()){
    unsigned int id = m_entitiesToRemove.back();
    auto itr = m_entities.find(id);
    if(itr != m_entities.end()){
      std::cout &lt;&lt; "Discarding entity: "&lt;&lt; itr-&gt;second-&gt;GetId() &lt;&lt; std::endl;
      delete itr-&gt;second;
      m_entities.erase(itr);
    }
    m_entitiesToRemove.pop_back();
  }
}</pre></div><p>As we're iterating over the container that holds the IDs of entities that need to be removed, the entity container is checked for the existence of every ID that was added. If an entity with the ID does in fact exist, its memory is de-allocated and the element is popped from the entity container.</p><p>Now for the interesting part – detecting entity-to-entity collisions:</p><div class="informalexample"><pre class="programlisting">void EntityManager::EntityCollisionCheck(){
  if (m_entities.empty()){ return; }
  for(auto itr = m_entities.begin();
    std::next(itr) != m_entities.end(); ++itr)
  {
    for(auto itr2 = std::next(itr);
      itr2 != m_entities.end(); ++itr2)
    {
      if(itr-&gt;first == itr2-&gt;first){ continue; }

      // Regular AABB bounding box collision.
      if(itr-&gt;second-&gt;m_AABB.intersects(itr2-&gt;second-&gt;m_AABB)){
        itr-&gt;second-&gt;OnEntityCollision(itr2-&gt;second, false);
        itr2-&gt;second-&gt;OnEntityCollision(itr-&gt;second, false);
      }

      EntityType t1 = itr-&gt;second-&gt;GetType();
      EntityType t2 = itr2-&gt;second-&gt;GetType();
      if (t1 == EntityType::Player || t1 == EntityType::Enemy){
        Character* c1 = (Character*)itr-&gt;second;
        if (c1-&gt;m_attackAABB.intersects(itr2-&gt;second-&gt;m_AABB)){
          c1-&gt;OnEntityCollision(itr2-&gt;second, true);
        }
      }

      if (t2 == EntityType::Player || t2 == EntityType::Enemy){
        Character* c2 = (Character*)itr2-&gt;second;
        if (c2-&gt;m_attackAABB.intersects(itr-&gt;second-&gt;m_AABB)){
          c2-&gt;OnEntityCollision(itr-&gt;second, true);
        }
      }
    }
  }
}</pre></div><p>First, the <a id="id266" class="indexterm"/>way we're checking every entity against every other entity needs to be addressed. There are, of course, much better and more efficient ways to determine which entities to check without simply iterating over all of them, such as binary space partitioning. However, given the scope of our project, that would be overkill:</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Premature optimization is the root of all evil (or at least most of it) in programming."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Donald Knuth</em></span></span></td></tr></table></div><p>Having said that, we are going to be a bit smarter and not simply iterate over all of the entities twice. Because checking entity 0 against entity 1 is the same as checking entity 1 against 0, we<a id="id267" class="indexterm"/> can implement a much more efficient algorithm by using <code class="literal">std::next</code>, which creates an iterator that is one space ahead of the one fed to it, and use it in the second loop. This creates a check pattern that looks something like this:</p><div class="mediaobject"><img src="graphics/B04284_07_07.jpg" alt="Implementing the entity manager"/></div><p>That is about as much optimization as we need in the early stages of making a game.</p><p>When iterating over entities, the collision check method first makes sure that both iterators do not share the same entity ID, for some odd reason. Then, it's simply a matter of checking for intersections between the bounding boxes of the two entities we're interested in. If there is a collision, the methods for handling it are called in both instances, passing in the entity being collided with as an argument, along with false as the second argument, to let the entity know it's a simple AABB collision. What does that mean? Well, generally, there are going to be two types of collisions between entities: regular bounding box collisions and attack collisions. Children of the <code class="literal">EntityBase</code> class, mainly the <code class="literal">Character</code> instances, will have to keep another bounding box in order to perform attacks, as illustrated here:</p><div class="mediaobject"><img src="graphics/B04284_07_08.jpg" alt="Implementing the entity manager"/></div><p>Because<a id="id268" class="indexterm"/> this isn't terribly complicated to implement, we can continue implementing the entity manger until we implement the <code class="literal">Character</code> class shortly.</p><p>Since only the <code class="literal">Character</code> class and any class that inherits from it is going to have an attack bounding box, it's necessary to first check if we're dealing with a <code class="literal">Character</code> instance by verifying the entity type. If an entity is of the type <code class="literal">Enemy</code> or <code class="literal">Player</code>, the <code class="literal">OnEntityCollision</code> method of the <code class="literal">Character</code> instance is invoked and receives the entity it's colliding with, as well as a Boolean constant of <code class="literal">true</code> this time, as arguments, to indicate an attack collision.</p><p>We're mostly done. Let's write the method for loading different enemy types that can parse files like this:</p><div class="informalexample"><pre class="programlisting">|Name|CharFile|
Rat Rat.char</pre></div><p>It's quite a simple format. Let's read it in:</p><div class="informalexample"><pre class="programlisting">void EntityManager::LoadEnemyTypes(const std::string&amp; l_name){
  std::ifstream file;
  ... // Opening the file.
  while(std::getline(file,line)){
    if (line[0] == '|'){ continue; }
    std::stringstream keystream(line);
    std::string name;
    std::string charFile;
    keystream &gt;&gt; name &gt;&gt; charFile;
    m_enemyTypes.emplace(name,charFile);
  }
  file.close();
}</pre></div><p>There is<a id="id269" class="indexterm"/> nothing here you haven't seen before. The two string values get read in and stored in the enemy type container. This simple bit of code concludes our interest in the entity manager class.</p></div></div>
<div class="section" title="Using entities to build characters"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Using entities to build characters</h1></div></div></div><p>So far, we <a id="id270" class="indexterm"/>only have entities that define some abstract<a id="id271" class="indexterm"/> methods and provide the means of manipulating them, but nothing that can appear in the game world, be rendered, and walk around. At the same time, we don't want to re-implement all of that functionality all over again in the player or enemy classes, which means we need an intermediate-level abstract class: <code class="literal">Character</code>. This class will provide all of the functionality that is shared between all entities that need to move around the world and be rendered. Let's get on with designing:</p><div class="informalexample"><pre class="programlisting">class Character : public EntityBase{
friend class EntityManager;
public:
  Character(EntityManager* l_entityMgr);
  virtual ~Character();
  void Move(const Direction&amp; l_dir);
  void Jump();
  void Attack();
  void GetHurt(const int&amp; l_damage);
  void Load(const std::string&amp; l_path);
  virtual void OnEntityCollision(
    EntityBase* l_collider, bool l_attack) = 0;
  virtual void Update(float l_dT);
  void Draw(sf::RenderWindow* l_wind);
protected:
  void UpdateAttackAABB();
  void Animate();
  SpriteSheet m_spriteSheet;
  float m_jumpVelocity;
  int m_hitpoints;
  sf::FloatRect m_attackAABB;
  sf::Vector2f m_attackAABBoffset;
};</pre></div><p>First, let's talk<a id="id272" class="indexterm"/> about the public methods. Moving, jumping, attacking, and receiving damage are the common actions of every character-entity<a id="id273" class="indexterm"/> in the game. The character also has to be loaded in order to provide it with the correct graphics and properties that differ between each enemy type and the player. All classes derived from it have to implement their own version of handling collisions with other entities. Also, the <code class="literal">Update</code> method of the character class is made to be virtual, which allows any class inheriting from this one to either define its own update method or extend the existing one.</p><p>All characters will be using the sprite sheet class that we designed previously in order to support animations.</p><div class="section" title="Implementing the character class"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec32"/>Implementing the character class</h2></div></div></div><p>You<a id="id274" class="indexterm"/> know the drill by now. Here's the constructor:</p><div class="informalexample"><pre class="programlisting">Character::Character(EntityManager* l_entityMgr)
  :EntityBase(l_entityMgr), 
  m_spriteSheet(m_entityManager-&gt;GetContext()-&gt;m_textureManager),
  m_jumpVelocity(250), m_hitpoints(5)
{ m_name = "Character"; }</pre></div><p>The sprite sheet is created and set up by passing a pointer to the texture manager in its constructor. We also have a data member called <code class="literal">m_jumpVelocity</code>, which specifies how far the player can jump. Lastly, we set some arbitrary value to the <code class="literal">m_hitpoints</code> variable, which represents how many times an entity can be hit before it dies.</p><p>Let's move on to the <code class="literal">Move</code> method:</p><div class="informalexample"><pre class="programlisting">void Character::Move(const Direction&amp; l_dir){
  if (GetState() == EntityState::Dying){ return; }
  m_spriteSheet.SetDirection(l_dir);
  if (l_dir == Direction::Left){ Accelerate(-m_speed.x, 0); }
  else { Accelerate(m_speed.x, 0); }
  if (GetState() == EntityState::Idle){
    SetState(EntityState::Walking);
  }
}</pre></div><p>Regardless of the entity's direction, the state of the entity is checked in order to make sure the entity isn't dying. If it isn't, the direction of the sprite sheet is set up and the character begins to accelerate on a relevant axis. Lastly, if the entity is currently in an idle state, it gets set to walking simply to play the walking animation:</p><div class="informalexample"><pre class="programlisting">void Character::Jump(){
  if (GetState() == EntityState::Dying || GetState() == EntityState::Jumping || GetState() == EntityState::Hurt)
  {
    return;
  }
  SetState(EntityState::Jumping);
  AddVelocity(0, -m_jumpVelocity);
}</pre></div><p>A character<a id="id275" class="indexterm"/> should only be able to jump if it isn't dying, taking damage, or jumping already. When those conditions are met and the character is instructed to jump, its state is set to <code class="literal">Jumping</code> and it receives negative velocity on the y axis that makes it combat the gravity force and go up. The velocity has to be high enough in order to break the gravitational force of the level.</p><p>Attacking is fairly straightforward. Because the entity manager already does the collision checking for us, all that's left to do is set the state if an entity isn't dying, jumping, taking damage, or already attacking:</p><div class="informalexample"><pre class="programlisting">void Character::Attack(){
  if (GetState() == EntityState::Dying ||
    GetState() == EntityState::Jumping ||
    GetState() == EntityState::Hurt ||
    GetState() == EntityState::Attacking)
  {
    return;
  }
  SetState(EntityState::Attacking);
}</pre></div><p>In order to bestow mortality onto our entities, they need to have a way to be hurt:</p><div class="informalexample"><pre class="programlisting">void Character::GetHurt(const int&amp; l_damage){
  if (GetState() == EntityState::Dying ||
    GetState() == EntityState::Hurt)
  {
    return;
  }
  m_hitpoints = (m_hitpoints - l_damage &gt; 0 ?
    m_hitpoints - l_damage : 0);
  if (m_hitpoints){ SetState(EntityState::Hurt); }
  else { SetState(EntityState::Dying); }
}</pre></div><p>This method inflicts damage to the character if it isn't already taking damage or dying. The damage value is either subtracted from the hit-points or the hitpoints variable is set to <span class="emphasis"><em>0</em></span> in order<a id="id276" class="indexterm"/> to keep it from reaching the negatives. If the entity still has lives after the subtraction, its state is set to <code class="literal">HURT</code> in order to play the proper animation. Otherwise, the entity is sentenced to death by the programmer.</p><p>As previously mentioned, we want to be able to load our characters in from files like this one (<code class="literal">Player.char</code>):</p><div class="informalexample"><pre class="programlisting">Name Player
Spritesheet Player.sheet
Hitpoints 5
BoundingBox 20 26
DamageBox -5 0 26 26
Speed 1024 128
JumpVelocity 250
MaxVelocity 200 1024</pre></div><p>It contains all the basic bits and pieces of what makes up a character, like the sprite sheet handle and all of the other information discussed in earlier sections. The loading method for this type of file will not differ much from the ones we've already implemented:</p><div class="informalexample"><pre class="programlisting">void Character::Load(const std::string&amp; l_path){
  std::ifstream file;
  ...
  while(std::getline(file,line)){
    ...
    std::string type;
    keystream &gt;&gt; type;
    if(type == "Name"){
      keystream &gt;&gt; m_name;
    } else if(type == "Spritesheet"){
      std::string path;
      keystream &gt;&gt; path;
      m_spriteSheet.LoadSheet("media/SpriteSheets/" + path);
    } else if(type == "Hitpoints"){
      keystream &gt;&gt; m_hitpoints;
    } else if(type == "BoundingBox"){
      sf::Vector2f boundingSize;
      keystream &gt;&gt; boundingSize.x &gt;&gt; boundingSize.y;
      SetSize(boundingSize.x, boundingSize.y);
    } else if(type == "DamageBox"){
      keystream &gt;&gt; m_attackAABBoffset.x &gt;&gt; m_attackAABBoffset.y 
        &gt;&gt; m_attackAABB.width &gt;&gt; m_attackAABB.height;
    } else if(type == "Speed"){
      keystream &gt;&gt; m_speed.x &gt;&gt; m_speed.y;
    } else if(type == "JumpVelocity"){
      keystream &gt;&gt; m_jumpVelocity;
    } else if(type == "MaxVelocity"){
      keystream &gt;&gt; m_maxVelocity.x &gt;&gt; m_maxVelocity.y;
    } else {
      std::cout &lt;&lt; "! Unknown type in character file: "
        &lt;&lt; type &lt;&lt; std::endl;
    }
  }
  file.close();
}</pre></div><p>Aside from <a id="id277" class="indexterm"/>the sprite sheet having to call a load method, the rest is simply loading in data members from a string stream.</p><p>Just like the base entity and its bounding box, the character has to have a way to update the position of its attack area:</p><div class="informalexample"><pre class="programlisting">void Character::UpdateAttackAABB(){
  m_attackAABB.left = 
    (m_spriteSheet.GetDirection() == Direction::Left ? 
    (m_AABB.left - m_attackAABB.width) - m_attackAABBoffset.x
    : (m_AABB.left + m_AABB.width) + m_attackAABBoffset.x);
  m_attackAABB.top = m_AABB.top + m_attackAABBoffset.y;
}</pre></div><p>One subtle difference here is that the attack bounding box uses the position of the entity's bounding box, not its sprite position. Also, the way it's positioned is different based on the direction an entity is facing, due to the fact that the bounding box's position represents its top-left corner.</p><p>Now for the method that will make the biggest difference, visually speaking:</p><div class="informalexample"><pre class="programlisting">void Character::Animate(){
  EntityState state = GetState();

  if(state == EntityState::Walking &amp;&amp; m_spriteSheet.
    GetCurrentAnim()-&gt;GetName() != "Walk")
  {
    m_spriteSheet.SetAnimation("Walk",true,true);
  } 
  else if(state == EntityState::Jumping &amp;&amp; m_spriteSheet.
    GetCurrentAnim()-&gt;GetName() != "Jump")
  {
    m_spriteSheet.SetAnimation("Jump",true,false);
  }
  else if(state == EntityState::Attacking &amp;&amp; m_spriteSheet.
    GetCurrentAnim()-&gt;GetName() != "Attack")
  {
    m_spriteSheet.SetAnimation("Attack",true,false);
  } else if(state == EntityState::Hurt &amp;&amp; m_spriteSheet.
    GetCurrentAnim()-&gt;GetName() != "Hurt")
  {
    m_spriteSheet.SetAnimation("Hurt",true,false);
  }
  else if(state == EntityState::Dying &amp;&amp; m_spriteSheet.
    GetCurrentAnim()-&gt;GetName() != "Death")
  {
    m_spriteSheet.SetAnimation("Death",true,false);
  }
  else if(state == EntityState::Idle &amp;&amp; m_spriteSheet.
    GetCurrentAnim()-&gt;GetName() != "Idle")
  {
    m_spriteSheet.SetAnimation("Idle",true,true);
  }
}</pre></div><p>All it does<a id="id278" class="indexterm"/> is simply check the current state and the current animation. If the current animation does not match the current state, it gets set to something else. Note the use of the third argument in the <code class="literal">SetAnimation</code> method, which is a Boolean constant and represents animation looping. Certain animations do not need to loop, like the attack or hurt animation. The fact that they do not loop and are stopped when they reach the end frame gives us a hook to manipulate what happens in the game, simply based on the progress of a certain animation. Case in point – the <code class="literal">Update</code> method:</p><div class="informalexample"><pre class="programlisting">void Character::Update(float l_dT){
  EntityBase::Update(l_dT);
  if(m_attackAABB.width != 0 &amp;&amp; m_attackAABB.height != 0){
    UpdateAttackAABB();
  }
  if(GetState() != EntityState::Dying &amp;&amp; GetState() !=
    EntityState::Attacking &amp;&amp; GetState() != EntityState::Hurt)
  {
    if(abs(m_velocity.y) &gt;= 0.001f){
      SetState(EntityState::Jumping);
    } else if(abs(m_velocity.x) &gt;= 0.1f){
      SetState(EntityState::Walking);
    } else {
      SetState(EntityState::Idle);
    }
  } else if(GetState() == EntityState::Attacking ||
    GetState() == EntityState::Hurt)
  {
    if(!m_spriteSheet.GetCurrentAnim()-&gt;IsPlaying()){
      SetState(EntityState::Idle);
    }
  } else if(GetState() == EntityState::Dying){
    if(!m_spriteSheet.GetCurrentAnim()-&gt;IsPlaying()){
      m_entityManager-&gt;Remove(m_id);
    }
  }
  Animate();
  m_spriteSheet.Update(l_dT);
  m_spriteSheet.SetSpritePosition(m_position);
}</pre></div><p>First, we<a id="id279" class="indexterm"/> invoke the update method of the entity's base class, because the character's state depends on it. Then, we check if the width and height of the attack bounding box aren't still at 0, which are the default values for them. If they aren't, it means the attack bounding box has been set up and can be updated. The rest of the update method pretty much just handles state transitions. If the entity isn't dying, attacking something, or taking damage, its current state is going to be determined by its velocity. In order to accurately depict an entity falling, we have to make the velocity on y axis take precedence over everything else. If the entity has no vertical velocity, it's checked for horizontal velocity instead and sets the state to <code class="literal">Walking</code> if the velocity is higher than the specified minimum. Using small values instead of absolute zero takes care of problems with animations being jittery sometimes.</p><p>Because the attacking and taking damage states are not set to loop, the sprite sheet animation is checked in order to see if it is still playing. If it isn't, the state is switched back to idle. Lastly, if the entity is dying and the dying animation is finished playing, we call the <code class="literal">Remove</code> method of our entity manager in order to remove this entity from the world.</p><p>The <code class="literal">Animate</code> method is called near the end of the update in order to reflect the state changes that may have taken place. Also, this is where the sprite sheet gets updated and has its position set to match the position of the entity.</p><p>After all of that code, let's end on something really simple – the <code class="literal">Draw</code> method:</p><div class="informalexample"><pre class="programlisting">void Character::Draw(sf::RenderWindow* l_wind){
    m_spriteSheet.Draw(l_wind);
}</pre></div><p>Since our sprite-sheet class takes care of drawing, all we need to do is pass a pointer of a render window to its <code class="literal">Draw</code> method.</p></div><div class="section" title="Creating the player"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec33"/>Creating the player</h2></div></div></div><p>Now we <a id="id280" class="indexterm"/>have a solid base for creating entities that are visually represented on screen. Let's put that to good use and finally build our player class by starting with the header:</p><div class="informalexample"><pre class="programlisting">class Player : public Character{
public:
  Player(EntityManager* l_entityMgr);
  ~Player();

  void OnEntityCollision(EntityBase* l_collider, bool l_attack);
  void React(EventDetails* l_details);
};</pre></div><p>This is where things get easy. Because we essentially "outsourced" most of the common functionality to the base classes, all we're left with now is player-specific logic. Notice the <code class="literal">React</code> method. Judging by its argument list, it's obvious that we're going to be using it as a callback for handling player input. Before we do that, however, we must register this method as one:</p><div class="informalexample"><pre class="programlisting">Player::Player(EntityManager* l_entityMgr)
  : Character(l_entityMgr)
{
  Load("Player.char");
  m_type = EntityType::Player;

  EventManager* events = m_entityManager-&gt;
    GetContext()-&gt;m_eventManager;
  events-&gt;AddCallback&lt;Player&gt;(StateType::Game,
    "Player_MoveLeft", &amp;Player::React, this);
  events-&gt;AddCallback&lt;Player&gt;(StateType::Game,
    "Player_MoveRight", &amp;Player::React, this);
  events-&gt;AddCallback&lt;Player&gt;(StateType::Game,
    "Player_Jump", &amp;Player::React, this);
  events-&gt;AddCallback&lt;Player&gt;(StateType::Game,
    "Player_Attack", &amp;Player::React, this);
}</pre></div><p>All we're doing here is calling the <code class="literal">Load</code> method in order to set up the character values for our player and adding multiple callbacks to the same <code class="literal">React</code> method that will be used to process keyboard input. The type of the entity is also set to <code class="literal">Player</code>:</p><div class="informalexample"><pre class="programlisting">Player::~Player(){
    EventManager* events = m_entityManager-&gt;GetContext()-&gt;m_eventManager;
    events-&gt;RemoveCallback(GAME,"Player_MoveLeft");
    events-&gt;RemoveCallback(GAME,"Player_MoveRight");
    events-&gt;RemoveCallback(GAME,"Player_Jump");
    events-&gt;RemoveCallback(GAME,"Player_Attack");
}</pre></div><p>The <a id="id281" class="indexterm"/>destructor, predictably enough, simply removes callbacks that we were using to move the player around.</p><p>The last method we are required to implement by the <code class="literal">Character</code> class is responsible for entity-on-entity collision:</p><div class="informalexample"><pre class="programlisting">void Player::OnEntityCollision(EntityBase* l_collider,
  bool l_attack)
{
  if (m_state == EntityState::Dying){ return; }
  if(l_attack){
    if (m_state != EntityState::Attacking){ return; }
    if (!m_spriteSheet.GetCurrentAnim()-&gt;IsInAction()){ return; }
    if (l_collider-&gt;GetType() != EntityType::Enemy &amp;&amp;
      l_collider-&gt;GetType() != EntityType::Player)
    {
      return;
    }
    Character* opponent = (Character*)l_collider;
    opponent-&gt;GetHurt(1);
    if(m_position.x &gt; opponent-&gt;GetPosition().x){
      opponent-&gt;AddVelocity(-32,0);
    } else {
      opponent-&gt;AddVelocity(32,0);
    }
  } else {
    // Other behavior.
  }
}</pre></div><p>This method, as you remember from the entity manager portion of this chapter, is invoked when something is colliding with this particular entity. In a case of collision, the other colliding entity is passed in as an argument to this method together with a flag to determine if the entity is colliding with your bounding box or your attack region.</p><p>First, we make sure the player entity isn't dying. Afterwards, we check if it's the attack region that is colliding with another entity. If it is and the player is in the attack state, we check if the attack animation in the sprite sheet is currently "in action." If the current frame is within range of the beginning and end frames when the action is supposed to happen, the last check is made to determine if the entity is either a player or an enemy. Finally, if it is one or the other, the opponent gets hit with a pre-determined damage value, and based on its position will have some velocity added to it for a knock-back effect. That's <a id="id282" class="indexterm"/>about as basic a game design as it gets.</p></div></div>
<div class="section" title="Adding enemies"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Adding enemies</h1></div></div></div><p>In order to keep <a id="id283" class="indexterm"/>our player from walking the world lonely and un-attacked, we must add enemies to the game. Once again, let's begin with the header file:</p><div class="informalexample"><pre class="programlisting">#pragma once
#include "Character.h"

class Enemy : public Character{
public:
    Enemy(EntityManager* l_entityMgr);
    ~Enemy();

    void OnEntityCollision(EntityBase* l_collider, bool l_attack);
    void Update(float l_dT);
private:
    sf::Vector2f m_destination;
    bool m_hasDestination;
};</pre></div><p>It's the same basic idea here as it was in the player class. This time, however, the enemy class needs to specify its own version of the <code class="literal">Update</code> method. It also has two private data members, one of which is a destination vector. It is a very simple attempt at adding basic artificial intelligence to the game. All it will do is keep track of a destination position, which the <code class="literal">Update</code> method will randomize every now and then to simulate wandering entities. Let's implement this:</p><div class="informalexample"><pre class="programlisting">Enemy::Enemy(EntityManager* l_entityMgr)
  :Character(l_entityMgr), m_hasDestination(false)
{
  m_type = EntityType::Enemy;
}
Enemy::~Enemy(){}</pre></div><p>The constructor simply initializes a few data members to their default values, while the destructor remains unused. So far, so good!</p><div class="informalexample"><pre class="programlisting">void Enemy::OnEntityCollision(EntityBase* l_collider,
  bool l_attack)
{
  if (m_state == EntityState::Dying){ return; }
  if (l_attack){ return; }
  if (l_collider-&gt;GetType() != EntityType::Player){ return; }
  Character* player = (Character*)l_collider;
  SetState(EntityState::Attacking);
  player-&gt;GetHurt(1);
  if(m_position.x &gt; player-&gt;GetPosition().x){
    player-&gt;AddVelocity(-m_speed.x,0);
    m_spriteSheet.SetDirection(Direction::Left);
  } else {
    player-&gt;AddVelocity(m_speed.y,0);
    m_spriteSheet.SetDirection(Direction::Right);
  }
}</pre></div><p>The entity <a id="id284" class="indexterm"/>collision method is fairly similar as well, except this time we make sure to act if the enemy's bounding box is colliding with another entity, not its attack region. Also, we ignore every single collision, unless it's colliding with a player entity, in which case the enemy's state is set to <code class="literal">Attacking</code> in order to display the attack animation. It inflicts damage of <span class="emphasis"><em>1</em></span> point to the player and knocks them back just a little bit based on where the entity is. The sprite-sheet direction is also set based on the position of the enemy entity relative to what it's attacking.</p><p>Now, to update our enemy:</p><div class="informalexample"><pre class="programlisting">void Enemy::Update(float l_dT){
  Character::Update(l_dT);

  if (m_hasDestination){
    if (abs(m_destination.x - m_position.x) &lt; 16){
      m_hasDestination = false;
      return;
    }
    if (m_destination.x - m_position.x &gt; 0){
      Move(Direction::Right);
    } else { Move(Direction::Left); }
    if (m_collidingOnX){ m_hasDestination = false; }
    return;
  }
  int random = rand() % 1000 + 1;
  if (random != 1000){ return; }
  int newX = rand() % 65 + 0;
  if (rand() % 2){ newX = -newX; }
  m_destination.x = m_position.x + newX;
  if (m_destination.x &lt; 0){ m_destination.x = 0; }
  m_hasDestination = true;
}</pre></div><p>Because this depends on the functionality of the <code class="literal">Character</code> class, we invoke its update method first before doing anything. Then the most basic simulation of A.I. begins by first checking if the entity has a destination. If it does not, a random number is generated between 1 and 1000. It has a 1/1000 chance to have its destination set to be anywhere within 128 <a id="id285" class="indexterm"/>pixels of its current position. The direction is decided by another random number generation, except much smaller this time. The destination finally is set and gets checked for being outside the world boundaries.</p><p>If, on the other hand, the entity does have a destination, the distance between it and its current position is checked. If it is above 16, the appropriate method for moving in a specific direction is called, based on which direction the destination point is in. We must also check for horizontal collisions, because an enemy entity could easily be assigned a destination that's beyond a tile it cannot cross. If that happens, the destination is simply taken away.</p><p>With that done, we now have wandering entities and a player that can be moved around the world! The only thing left to do in order to actually bring these entities into the game now is to load them.</p></div>
<div class="section" title="Loading entities from the map file"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Loading entities from the map file</h1></div></div></div><p>If you<a id="id286" class="indexterm"/> recall from the section of this chapter that dealt <a id="id287" class="indexterm"/>with the issue of creating a map class, we haven't finished implementing the loading method fully, because we had no entities yet. With that no longer being the case, let's take a look at extending it:</p><div class="informalexample"><pre class="programlisting">} else if(type == "PLAYER"){
  if (playerId != -1){ continue; }
  // Set up the player position here.
  playerId = entityMgr-&gt;Add(EntityType::Player);
  if (playerId &lt; 0){ continue; }
  float playerX = 0; float playerY = 0;
  keystream &gt;&gt; playerX &gt;&gt; playerY;
  entityMgr-&gt;Find(playerId)-&gt;SetPosition(playerX,playerY);
  m_playerStart = sf::Vector2f(playerX, playerY);
} else if(type == "ENEMY"){
  std::string enemyName;
  keystream &gt;&gt; enemyName;
  int enemyId = entityMgr-&gt;Add(EntityType::Enemy, enemyName);
  if (enemyId &lt; 0){ continue; }
  float enemyX = 0; float enemyY = 0;
  keystream &gt;&gt; enemyX &gt;&gt; enemyY;
  entityMgr-&gt;Find(enemyId)-&gt;SetPosition(enemyX, enemyY);
} ...</pre></div><p>If the map encounters a <code class="literal">PLAYER</code> line, it simply attempts to add an entity of type <code class="literal">Player</code> and grabs its ID. If it's above or equal to 0, the entity creation was successful, meaning that we can read in the rest of the data from the map file, which happens to be the player position. After obtaining it, we set the player's position and make sure we keep track of the starting position in the map class itself too.</p><p>All of the <a id="id288" class="indexterm"/>above is true for the <code class="literal">ENEMY</code> line as well, except it <a id="id289" class="indexterm"/>also loads in the name of the entity, which is needed in order to load its character information from the file.</p><p>Now our game is capable of loading entities from the map files and thus putting them into the game world like so:</p><div class="mediaobject"><img src="graphics/B04284_07_09.jpg" alt="Loading entities from the map file"/></div></div>
<div class="section" title="Final editions to our code base"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Final editions to our code base</h1></div></div></div><p>In this last <a id="id290" class="indexterm"/>portion of the chapter, we will be covering small changes and additions/editions that have been made all over the code written in the previous chapters in order to make this possible, starting with the shared context, which is now moved into its own header file.</p><div class="section" title="Changes to the shared context"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec34"/>Changes to the shared context</h2></div></div></div><p>Out <a id="id291" class="indexterm"/>of all of the extra classes we defined, some of them need to be accessible to the rest of the code-base. This is what the shared context structure looks like now:</p><div class="informalexample"><pre class="programlisting">class Map;
struct SharedContext{
  SharedContext():
    m_wind(nullptr),
    m_eventManager(nullptr),
    m_textureManager(nullptr),
    m_entityManager(nullptr),
    m_gameMap(nullptr){}

  Window* m_wind;
  EventManager* m_eventManager;
  TextureManager* m_textureManager;
  EntityManager* m_entityManager;
  Map* m_gameMap;
  DebugOverlay m_debugOverlay;
};</pre></div><p>The last object in it is the debug overlay we briefly discussed while working on the base entity class, which helps us see what's going on in our game by providing overlay graphics for tiles that entities collide with, warp tiles, and spike tiles, giving us the visual representations of entity bounding boxes and so on. Because the debug code was not essential to this chapter, snippets of it did not get included here, but they're present in the code that comes with it.</p></div><div class="section" title="Putting all the pieces together"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec35"/>Putting all the pieces together</h2></div></div></div><p>Next, we<a id="id292" class="indexterm"/> need to put instances of the code we worked so hard on in the right places, starting with the entity manager class, which goes straight into the game class as a data member:</p><div class="informalexample"><pre class="programlisting">class Game{
public:
    ...
private:
    ...
    EntityManager m_entityManager;
};</pre></div><p>The map class instance is kept around in the game state class:</p><div class="informalexample"><pre class="programlisting">class State_Game : public BaseState{
public:
    ...
private:
    ...
    Map* m_gameMap;
};</pre></div><p>The main <a id="id293" class="indexterm"/>game state is also responsible for setting up its own view and zooming in just enough to make the game look more appealing and less prone to cause squinting, not to mention initializing and loading the map:</p><div class="informalexample"><pre class="programlisting">void State_Game::OnCreate(){
    ...
    sf::Vector2u size = m_stateMgr-&gt;GetContext()-&gt;m_wind-&gt;GetWindowSize();
    m_view.setSize(size.x,size.y);
    m_view.setCenter(size.x/2,size.y/2);
    m_view.zoom(0.6f);
    m_stateMgr-&gt;GetContext()-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view);

    m_gameMap = new Map(m_stateMgr-&gt;GetContext(), this);
    m_gameMap-&gt;LoadMap("media/Maps/map1.map");
}</pre></div><p>Because the map is dynamically allocated, it must be deleted in the <code class="literal">OnDestroy</code> method of the game state:</p><div class="informalexample"><pre class="programlisting">void State_Game::OnDestroy(){
    ...
    delete m_gameMap;
    m_gameMap = nullptr;
}</pre></div><p>Now onto the final piece of this puzzle – the game state update method:</p><div class="informalexample"><pre class="programlisting">void State_Game::Update(const sf::Time&amp; l_time){
  SharedContext* context = m_stateMgr-&gt;GetContext();
  EntityBase* player = context-&gt;m_entityManager-&gt;Find("Player");
  if(!player){
    std::cout &lt;&lt; "Respawning player..." &lt;&lt; std::endl;
    context-&gt;m_entityManager-&gt;Add(EntityType::Player,"Player");
    player = context-&gt;m_entityManager-&gt;Find("Player");
    player-&gt;SetPosition(m_gameMap-&gt;GetPlayerStart());
  } else {
    m_view.setCenter(player-&gt;GetPosition());
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view);
  }

  sf::FloatRect viewSpace = context-&gt;m_wind-&gt;GetViewSpace();
  if(viewSpace.left &lt;= 0){
    m_view.setCenter(viewSpace.width / 2,m_view.getCenter().y);
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view);
  } else if (viewSpace.left + viewSpace.width &gt;
    (m_gameMap-&gt;GetMapSize().x + 1) * Sheet::Tile_Size)
  {
    m_view.setCenter(((m_gameMap-&gt;GetMapSize().x + 1) *
      Sheet::Tile_Size) - (viewSpace.width / 2),
      m_view.getCenter().y);
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view);
  }

  m_gameMap-&gt;Update(l_time.asSeconds());
  m_stateMgr-&gt;GetContext()-&gt;
    m_entityManager-&gt;Update(l_time.asSeconds());
}</pre></div><p>First, we <a id="id294" class="indexterm"/>determine if the player is still alive in the game by searching for them by name. If the player isn't found, they must've died, so a re-spawn is in order. A new player entity is created and the starting coordinates of the map are passed to its <code class="literal">SetPosition</code> method.</p><p>Now comes the part where we manage how the view is scrolling. If the player entity exists, we set the view's centre to match the exact player position and use the shared context to obtain the render window, which will be using the updated view. Now, we have an issue of the screen leaving the boundaries of the map, which can be resolved by checking the top-left corner of the view space. If it's below or equal to zero, we set the view's centre on the x axis to a position that would put its top-left corner at the very edge of the screen, in order to prevent scrolling infinitely to the left. If, however, the view is outside of the map in the opposite direction, the view centre's x coordinate is set up so that the right side of it is also at the very edge of the map's boundaries.</p><p>Finally, the game map, along with the entity manager, is updated right here, because we don't want the map updating or entities moving around if the current state is different.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Summary</h1></div></div></div><p>Congratulations on making it past the halfway point of this book! All of the code that was written, the design decisions, accounting for efficiency, and trial and error has brought you to this point. While the game we built is fairly basic, its architecture is also quite robust and expandable, and that is no small feat. Although some things in it may not be perfect, you have also followed the golden rule of getting it working first, before refining it, and now you have quite a few game design patterns under your belt to start building more complex game applications, as well as a solid code-base to expand and improve.</p><p>With the conclusion of this chapter, the second project of the book is officially finished. We have solved some quite tricky problems, written thousands of lines of code, and broadened our understanding of the game development process beyond the stages of myopic, callow naïveté, but the real adventure is still ahead of us. We may not know where it will ultimately lead us, but one thing is for sure: now is not a time to stop. See you in the next chapter.</p></div></body></html>