["```cpp\n#pragma once\n// Avatar.h code file\n#include \"GameFramework/Character.h\"\n#include \"Avatar.generated.h\"\nUCLASS()\nclass MYPROJECT_API AAvatar : public ACharacter\n{\n  GENERATED_UCLASS_BODY()\n};\n```", "```cpp\nUCLASS()\nclass GOLDENEGG_API AAvatar : public ACharacter\n{\n  GENERATED_UCLASS_BODY()\n\n  // New! These 3 new member function declarations\n  // they will be used to move our player around!\n  void SetupPlayerInputComponent(class UInputComponent*  InputComponent) override;\n  void MoveForward( float amount );\n  void MoveRight( float amount );\n};\n```", "```cpp\nvoid AAvatar::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n{\n  check(InputComponent);\n  InputComponent->BindAxis(\"Forward\", this,  &AAvatar::MoveForward);\n  InputComponent->BindAxis(\"Strafe\", this, &AAvatar::MoveRight);\n}\n```", "```cpp\nvoid AAvatar::MoveForward( float amount )\n{\n  // Don't enter the body of this function if Controller is\n  // not set up yet, or if the amount to move is equal to 0\n  if( Controller && amount )\n  {\n    FVector fwd = GetActorForwardVector();\n    // we call AddMovementInput to actually move the\n    // player by `amount` in the `fwd` direction\n    AddMovementInput(fwd, amount);\n  }\n}\n\nvoid AAvatar::MoveRight( float amount )\n{\n  if( Controller && amount )\n  {\n    FVector right = GetActorRightVector();\n    AddMovementInput(right, amount);\n  }\n}\n```", "```cpp\nvoid AAvatar::MoveLeft( float amount )\n{\n  if( Controller && amount )\n  {\n    FVector left = -GetActorRightVector();\n    AddMovementInput(left, amount);\n  }\n}\nvoid AAvatar::MoveBack( float amount )\n{\n  if( Controller && amount )\n  {\n    FVector back = -GetActorForwardVector();\n    AddMovementInput(back, amount);\n  }\n}\n```", "```cpp\nvoid Yaw( float amount );\nvoid Pitch( float amount );\n```", "```cpp\nvoid AAvatar::Yaw( float amount )\n{\n  AddControllerYawInput(200.f * amount * GetWorld()- >GetDeltaSeconds());\n}\nvoid AAvatar::Pitch( float amount )\n{\n  AddControllerPitchInput(200.f * amount * GetWorld()- >GetDeltaSeconds());\n}\n```", "```cpp\nvoid AAvatar::SetupPlayerInputComponent(class UInputComponent*  InputComponent)\n{\n  // .. as before, plus:\n  InputComponent->BindAxis(\"Yaw\", this, &AAvatar::Yaw);\n  InputComponent->BindAxis(\"Pitch\", this, &AAvatar::Pitch);\n}\n```", "```cpp\nUCLASS()\nclass GOLDENEGG_API ANPC : public ACharacter\n{\n  GENERATED_UCLASS_BODY()\n  UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =  Collision)\n  TSubobjectPtr<class USphereComponent> ProxSphere;\n  // This is the NPC's message that he has to tell us.\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  NPCMessage)\n  FString NpcMessage;\n  // When you create a blueprint from this class, you want to be \n  // able to edit that message in blueprints,\n  // that's why we have the EditAnywhere and BlueprintReadWrite \n  // properties.\n}\n```", "```cpp\nUCLASS()\nclass GOLDENEGG_API AMyHUD : public AHUD\n{\n  GENERATED_UCLASS_BODY()\n  // The font used to render the text in the HUD.\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = HUDFont)\n  UFont* hudFont;\n  // Add this function to be able to draw to the HUD!\n  virtual void DrawHUD() override;\n};\n```", "```cpp\nvoid AMyHUD::DrawHUD()\n{\n  // call superclass DrawHUD() function first\n  Super::DrawHUD();\n  // then proceed to draw your stuff.\n  // we can draw lines..\n  DrawLine( 200, 300, 400, 500, FLinearColor::Blue );\n  // and we can draw text!\n  DrawText( \"Greetings from Unreal!\", FVector2D( 0, 0 ), hudFont,  FVector2D( 1, 1 ), FColor::White );\n}\n```", "```cpp\nstruct Message\n{\n  FString message;\n  float time;\n  FColor color;\n  Message()\n  {\n    // Set the default time.\n    time = 5.f;\n    color = FColor::White;\n  }\n  Message( FString iMessage, float iTime, FColor iColor )\n  {\n    message = iMessage;\n    time = iTime;\n    color = iColor;\n  }\n};\n```", "```cpp\nUCLASS()\nclass GOLDENEGG_API AMyHUD : public AHUD\n{\n  GENERATED_UCLASS_BODY()\n  // The font used to render the text in the HUD.\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = HUDFont)\n  UFont* hudFont;\n  // New! An array of messages for display\n  TArray<Message> messages;\n  virtual void DrawHUD() override;\n  // New! A function to be able to add a message to display\n  void addMessage( Message msg );\n};\n```", "```cpp\nvoid AMyHUD::DrawHUD()\n{\n  Super::DrawHUD();\n  // iterate from back to front thru the list, so if we remove\n  // an item while iterating, there won't be any problems\n  for( int c = messages.Num() - 1; c >= 0; c-- )\n  {\n    // draw the background box the right size\n    // for the message\n    float outputWidth, outputHeight, pad=10.f;\n    GetTextSize( messages[c].message, outputWidth, outputHeight,  hudFont, 1.f );\n\n    float messageH = outputHeight + 2.f*pad;\n    float x = 0.f, y = c*messageH;\n\n    // black backing\n    DrawRect( FLinearColor::Black, x, y, Canvas->SizeX, messageH  );\n    // draw our message using the hudFont\n    DrawText( messages[c].message, messages[c].color, x + pad, y +  pad, hudFont );\n\n    // reduce lifetime by the time that passed since last \n    // frame.\n    messages[c].time -= GetWorld()->GetDeltaSeconds();\n\n    // if the message's time is up, remove it\n    if( messages[c].time < 0 )\n    {\n      messages.RemoveAt( c );\n    }\n  }\n}\n\nvoid AMyHUD::addMessage( Message msg )\n{\n  messages.Add( msg );\n}\n```", "```cpp\nUCLASS()\nclass GOLDENEGG_API ANPC : public ACharacter\n{\n  GENERATED_UCLASS_BODY()\n  // This is the NPC's message that he has to tell us.\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  NPCMessage)\n  FString NpcMessage;\n  // The sphere that the player can collide with to get item\n  UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =  Collision)\n  TSubobjectPtr<class USphereComponent> ProxSphere;\n  // The corresponding body of this function is \n  // ANPC::Prox_Implementation, __not__ ANPC::Prox()!\n  // This is a bit weird and not what you'd expect,\n  // but it happens because this is a BlueprintNativeEvent\n  UFUNCTION(BlueprintNativeEvent, Category = \"Collision\")\n  void Prox( AActor* OtherActor, UPrimitiveComponent* OtherComp,  int32 OtherBodyIndex, bool bFromSweep, const FHitResult &  SweepResult );\n};\n```", "```cpp\nANPC::ANPC(const class FPostConstructInitializeProperties& PCIP) : Super(PCIP)\n{\n  ProxSphere = PCIP.CreateDefaultSubobject<USphereComponent>(this,  TEXT(\"Proximity Sphere\"));\n  ProxSphere->AttachTo( RootComponent );\n  ProxSphere->SetSphereRadius( 32.f );\n  // Code to make ANPC::Prox() run when this proximity sphere\n  // overlaps another actor.\n  ProxSphere->OnComponentBeginOverlap.AddDynamic( this,  &ANPC::Prox );\n  NpcMessage = \"Hi, I'm Owen\";//default message, can be edited\n  // in blueprints\n}\n// Note! Although this was declared ANPC::Prox() in the header,\n// it is now ANPC::Prox_Implementation here.\nvoid ANPC::Prox_Implementation( AActor* OtherActor,  UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool  bFromSweep, const FHitResult & SweepResult )\n{\n  // This is where our code will go for what happens\n  // when there is an intersection\n}\n```", "```cpp\nvoid ANPC::Prox_Implementation( AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult )\n{\n  // if the overlapped actor is not the player,\n  // you should just simply return from the function\n  if( Cast<AAvatar>( OtherActor ) == nullptr )\n  {\n    return;\n  }\n  APlayerController* PController = GetWorld()- >GetFirstPlayerController();\n  if( PController )\n  {\n    AMyHUD * hud = Cast<AMyHUD>( PController->GetHUD() );\n    hud->addMessage( Message( NpcMessage, 5.f, FColor::White ) );\n  }\n}\n```", "```cpp\n// This is the NPC's name\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = NPCMessage)\nFString name;\n```", "```cpp\nname + FString(\": \") + message\n```", "```cpp\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = NPCMessage)\nUTexture2D* Face;\n```", "```cpp\nUTexture2D* tex;\n```", "```cpp\nDrawTexture( messages[c].tex, x, y, messageH, messageH, 0, 0, 1, 1  );\n```", "```cpp\nvoid AMyHUD::DrawHealthbar()\n{\n  // Draw the healthbar.\n  AAvatar *avatar = Cast<AAvatar>(  UGameplayStatics::GetPlayerPawn(GetWorld(), 0) );\n  float barWidth=200, barHeight=50, barPad=12, barMargin=50;\n  float percHp = avatar->Hp / avatar->MaxHp;\n  DrawRect( FLinearColor( 0, 0, 0, 1 ), Canvas->SizeX - barWidth -  barPad - barMargin, Canvas->SizeY - barHeight - barPad -  barMargin, barWidth + 2*barPad, barHeight + 2*barPad );\n  DrawRect( FLinearColor( 1-percHp, percHp, 0, 1 ), Canvas->SizeX  - barWidth - barMargin, Canvas->SizeY - barHeight - barMargin,  barWidth*percHp, barHeight );\n}\n```"]