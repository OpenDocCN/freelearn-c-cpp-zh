["```cpp\n#pragma once\n#define RUNNING_WINDOWS\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nnamespace Utils{\n  #ifdef RUNNING_WINDOWS\n  #define WIN32_LEAN_AND_MEAN\n  #include <windows.h>\n  #include <Shlwapi.h>\n  inline std::string GetWorkingDirectory(){\n    HMODULE hModule = GetModuleHandle(nullptr);\n    if(hModule){\n      char path[256];\n      GetModuleFileName(hModule,path,sizeof(path));\n      PathRemoveFileSpec(path);\n      strcat_s(path,\"\\\\\"); // new\n      return std::string(path); // new\n    }\n    return \"\";\n  }\n  #elif defined RUNNING_LINUX\n  #include <unistd.h>\n  inline std::string GetWorkingDirectory(){\n    char cwd[1024];\n    if(getcwd(cwd, sizeof(cwd)) != nullptr){\n      return std::string(cwd) + std::string(\"/\");\n    }\n    return \"\";\n  }\n  #endif\n}\n```", "```cpp\n// Top-left corner at 500:500, bottom-right at 1000:1000.\nsf::View first(sf::FloatRect(500,500,1000,1000));\n// Center at 250:250, size is 800:600.\nsf::View second(sf::Vector2f(250,250), sf::Vector2f(800,600));\n```", "```cpp\n// Top-left corner at 0:0, bottom-right at 800:600.\nsf::View view(sf::FloatRect(0,0,800,600));\nview.setCenter(100,100); // Move center to 100:100.\n```", "```cpp\nview.move(100,100); // Move by 100x100 offset.\n```", "```cpp\nview.setSize(640, 480); // Creates a smaller view space.\nview.zoom(0.5f); // Also creates a smaller view space.\n```", "```cpp\nwindow.setView(view); // Applies view to window.\n```", "```cpp\nsf::View view = window.getView();\nsf::View defaultView = window.getDefaultView();\n```", "```cpp\nclass BaseState{\npublic:\n    ...\n    sf::View& GetView(){ return m_view; }\nprotected:\n    ...\n    sf::View m_view;\n};\n```", "```cpp\nvoid StateManager::CreateState(const StateType& l_type){\n  ...\n  BaseState* state = newState->second();\n  state->m_view = m_shared->m_wind->\n GetRenderWindow()->getDefaultView();\n  ...\n}\n```", "```cpp\nvoid StateManager::SwitchTo(const StateType& l_type){\n  ...\n  for(...)\n  {\n    if(itr->first == l_type){\n      ...\n      m_shared->m_wind->GetRenderWindow()->\n setView(tmp_state->GetView());\n      return;\n    }\n  }\n  ...\n  m_states.back().second->Activate();\n  m_shared->m_wind->GetRenderWindow()->setView(    m_states.back().second->GetView());\n}\n```", "```cpp\nvoid StateManager::Draw(){\n  ...\n  for(; itr != m_states.end(); ++itr){\n    m_shared->m_wind->GetRenderWindow()->\n setView(itr->second->GetView());\n    itr->second->Draw();\n  }\n  ...\n}\n```", "```cpp\nsf::FloatRect Window::GetViewSpace(){\n    sf::Vector2f viewCenter = m_window.getView().getCenter();\n    sf::Vector2f viewSize = m_window.getView().getSize();\n    sf::Vector2f viewSizeHalf(viewSize.x / 2, viewSize.y / 2);\n    sf::FloatRect viewSpace(viewCenter - viewSizeHalf, viewSize);\n    return viewSpace;\n}\n```", "```cpp\nIntro media/Textures/intro.png\nPlayerSprite media/Textures/PlayerSheet.png\nRatSprite media/Textures/RatSheet.png\nTileSheet media/Textures/tilesheet.png\nBg1 media/Textures/bg1.png\nBg2 media/Textures/bg2.png\nBg3 media/Textures/bg3.png\n```", "```cpp\ntemplate<typename Derived, typename T>\nclass ResourceManager{\npublic:\n    ResourceManager(const std::string& l_pathsFile){\n        LoadPaths(l_pathsFile);\n    }\n\n    virtual ~ResourceManager(){ PurgeResources(); }\n    ...\nprivate:\n    std::unordered_map<std::string, std::pair<T*, unsigned int>> m_resources;\n    std::unordered_map<std::string, std::string> m_paths;\n};\n```", "```cpp\nT* GetResource(const std::string& l_id){\n    auto res = Find(l_id);\n    return(res ? res->first : nullptr);\n}\n```", "```cpp\nstd::string GetPath(const std::string& l_id){\n    auto path = m_paths.find(l_id);\n    return(path != m_paths.end() ? path->second : \"\");\n}\n```", "```cpp\nbool RequireResource(const std::string& l_id){\n  auto res = Find(l_id);\n  if(res){\n    ++res->second;\n    return true;\n  }\n  auto path = m_paths.find(l_id);\n  if (path == m_paths.end()){ return false; }\n  T* resource = Load(path->second);\n  if (!resource){ return false; }\n  m_resources.emplace(l_id, std::make_pair(resource, 1));\n  return true;\n}\n```", "```cpp\nbool ReleaseResource(const std::string& l_id){\n    auto res = Find(l_id);\n    if (!res){ return false; }\n    --res->second;\n    if (!res->second){ Unload(l_id); }\n    return true;\n}\n```", "```cpp\nvoid PurgeResources(){\n  while(m_resources.begin() != m_resources.end()){\n    delete m_resources.begin()->second.first;\n    m_resources.erase(m_resources.begin());\n  }\n}\n```", "```cpp\nT* Load(const std::string& l_path){\n  return static_cast<Derived*>(this)->Load(l_path);\n}\n```", "```cpp\nstd::pair<T*,unsigned int>* Find(const std::string& l_id){\n  auto itr = m_resources.find(l_id);\n  return (itr != m_resources.end() ? &itr->second : nullptr);\n}\n```", "```cpp\nbool Unload(const std::string& l_id){\n  auto itr = m_resources.find(l_id);\n  if (itr == m_resources.end()){ return false; }\n  delete itr->second.first;\n  m_resources.erase(itr);\n  return true;\n}\n```", "```cpp\nvoid LoadPaths(const std::string& l_pathFile){\n  std::ifstream paths;\n  paths.open(Utils::GetWorkingDirectory() + l_pathFile);\n  if(paths.is_open()){\n    std::string line;\n    while(std::getline(paths,line)){\n      std::stringstream keystream(line);\n      std::string pathName;\n      std::string path;\n      keystream >> pathName;\n      keystream >> path;\n      m_paths.emplace(pathName,path);\n    }\n    paths.close();\n    return;\n  }\n  std::cerr << \n    \"! Failed loading the path file: \" \n    << l_pathFile << std::endl;\n}\n```", "```cpp\nclass TextureManager: \n  public ResourceManager<TextureManager, sf::Texture>\n{\npublic:\n  TextureManager(): ResourceManager(\"textures.cfg\"){}\n\n  sf::Texture* Load(const std::string& l_path){\n    sf::Texture* texture = new sf::Texture();\n    if(!texture->loadFromFile(\n      Utils::GetWorkingDirectory() + l_path))\n    {\n      delete texture;\n      texture = nullptr;\n      std::cerr << \"! Failed to load texture: \"\n        << l_path << std::endl;\n    }\n    return texture;\n  }\n};\n```", "```cpp\nTexture PlayerSprite\nSize 32 32\nScale 1.0 1.0\n|Type|Name|StartFrame|EndFrame|Row|FrameTime|FrameActionStart|End|\nAnimationType Directional\nAnimation Idle 0 7 0 0.2 -1 -1\nAnimation Walk 0 5 2 0.1 -1 -1\nAnimation Jump 0 3 4 0.2 -1 -1\nAnimation Attack 0 4 6 0.08 2 3\nAnimation Hurt 0 2 8 0.2 -1 -1\nAnimation Death 0 8 10 0.15 -1 -1\n```", "```cpp\nusing Animations = std::unordered_map<std::string,Anim_Base*>;\n```", "```cpp\nclass SpriteSheet{\npublic:\n  SpriteSheet(TextureManager* l_textMgr);\n  ~SpriteSheet();\n\n  void CropSprite(const sf::IntRect& l_rect);\n  ... // Basic setters/getters.\n  bool LoadSheet(const std::string& l_file);\n  void ReleaseSheet();\n\n  Anim_Base* GetCurrentAnim();\n  bool SetAnimation(const std::string& l_name,\n    const bool& l_play = false, \n    const bool& l_loop = false);\n\n  void Update(const float& l_dT);\n  void Draw(sf::RenderWindow* l_wnd);\nprivate:\n  std::string m_texture;\n  sf::Sprite m_sprite;\n  sf::Vector2i m_spriteSize;\n  sf::Vector2f m_spriteScale;\n  Direction m_direction;\n  std::string m_animType;\n  Animations m_animations;\n  Anim_Base* m_animationCurrent;\n  TextureManager* m_textureManager;\n};\n```", "```cpp\nenum class Direction{ Right = 0, Left };\n```", "```cpp\nSpriteSheet::SpriteSheet(TextureManager* l_textMgr) \n  :m_textureManager(l_textMgr), m_animationCurrent(nullptr), \n  m_spriteScale(1.f, 1.f), m_direction(Direction::Right){}\n```", "```cpp\nSpriteSheet::~SpriteSheet(){ ReleaseSheet(); }\n\nvoid SpriteSheet::ReleaseSheet(){\n    m_textureManager->ReleaseResource(m_texture);\n    m_animationCurrent = nullptr;\n    while(m_animations.begin() != m_animations.end()){\n        delete m_animations.begin()->second;\n        m_animations.erase(m_animations.begin());\n    }\n}\n```", "```cpp\nvoid SpriteSheet::SetSpriteSize(const sf::Vector2i& l_size){\n    m_spriteSize = l_size;\n    m_sprite.setOrigin(m_spriteSize.x / 2, m_spriteSize.y);\n}\n```", "```cpp\nvoid SpriteSheet::SetSpritePosition(const sf::Vector2f& l_pos){\n    m_sprite.setPosition(l_pos);\n}\n```", "```cpp\nvoid SpriteSheet::SetDirection(const Direction& l_dir){\n  if (l_dir == m_direction){ return; }\n  m_direction = l_dir;\n  m_animationCurrent->CropSprite();\n}\n```", "```cpp\nvoid SpriteSheet::CropSprite(const sf::IntRect& l_rect){\n    m_sprite.setTextureRect(l_rect);\n}\n```", "```cpp\nbool SpriteSheet::SetAnimation(const std::string& l_name, \n  const bool& l_play, const bool& l_loop)\n{\n  auto itr = m_animations.find(l_name);\n  if (itr == m_animations.end()){ return false; }\n  if (itr->second == m_animationCurrent){ return false; }\n  if (m_animationCurrent){ m_animationCurrent->Stop(); }\n  m_animationCurrent = itr->second;\n  m_animationCurrent->SetLooping(l_loop);\n  if(l_play){ m_animationCurrent->Play(); }\n  m_animationCurrent->CropSprite();\n  return true;\n}\n```", "```cpp\nvoid SpriteSheet::Update(const float& l_dT){\n    m_animationCurrent->Update(l_dT);\n}\n\nvoid SpriteSheet::Draw(sf::RenderWindow* l_wnd){\n    l_wnd->draw(m_sprite);\n}\n```", "```cpp\nclass SpriteSheet;\nusing Frame = unsigned int;\n\nclass Anim_Base{\n  friend class SpriteSheet;\npublic:\n  Anim_Base();\n  virtual ~Anim_Base();\n  ... // Setters/getters.\n  void Play();\n  void Pause();\n  void Stop();\n  void Reset();\n\n  virtual void Update(const float& l_dT);\n\n  friend std::stringstream& operator >>(\n    std::stringstream& l_stream, Anim_Base& a)\n  {\n    a.ReadIn(l_stream);\n    return l_stream;\n  }\nprotected:\n  virtual void FrameStep() = 0;\n  virtual void CropSprite() = 0;\n  virtual void ReadIn(std::stringstream& l_stream) = 0;\n\n  Frame m_frameCurrent;\n  Frame m_frameStart;\n  Frame m_frameEnd;\n  Frame m_frameRow;\n  int m_frameActionStart; // Frame when a specific \"action\" begins\n  int m_frameActionEnd; // Frame when a specific \"action\" ends\n  float m_frameTime;\n  float m_elapsedTime;\n  bool m_loop;\n  bool m_playing;\n  std::string m_name;\n  SpriteSheet* m_spriteSheet;\n};\n```", "```cpp\n#include \"Anim_Base.h\"\n#include \"SpriteSheet.h\"\n```", "```cpp\nAnim_Base::Anim_Base(): m_frameCurrent(0), m_frameStart(0), \n  m_frameEnd(0), m_frameRow(0), m_frameTime(0.f), \n  m_elapsedTime(0.f), m_frameActionStart(-1),\n  m_frameActionEnd(-1), m_loop(false), m_playing(false){}\nAnim_Base::~Anim_Base(){}\n```", "```cpp\nvoid Anim_Base::SetSpriteSheet(SpriteSheet* l_sheet){\n    m_spriteSheet = l_sheet;\n}\n```", "```cpp\nvoid Anim_Base::SetFrame(const unsigned int& l_frame){\n    if((l_frame >= m_frameStart && l_frame <= m_frameEnd)||(l_frame >= m_frameEnd && l_frame <= m_frameStart))\n    {\n        m_frameCurrent = l_frame;\n    }\n}\n```", "```cpp\nbool Anim_Base::IsInAction(){\n    if(m_frameActionStart == -1 || m_frameActionEnd == -1){\n        return true;\n    }\n\n    return (m_frameCurrent >= m_frameActionStart && m_frameCurrent <= m_frameActionEnd); \n}\n```", "```cpp\nvoid Anim_Base::Play(){ m_playing = true; }\nvoid Anim_Base::Pause(){ m_playing = false; }\nvoid Anim_Base::Stop(){ m_playing = false; Reset(); }\n```", "```cpp\nvoid Anim_Base::Reset(){\n    m_frameCurrent = m_frameStart;\n    m_elapsedTime = 0.0f;\n    CropSprite();\n}\n```", "```cpp\nvoid Anim_Base::Update(const float& l_dT){\n  if (!m_playing){ return; }\n  m_elapsedTime += l_dT;\n  if (m_elapsedTime < m_frameTime){ return; }\n  FrameStep();\n  CropSprite();\n  m_elapsedTime = 0;\n}\n```", "```cpp\nclass Anim_Directional : public Anim_Base{\nprotected:\n    void FrameStep();\n    void CropSprite();\n    void ReadIn(std::stringstream& l_stream);\n};\n```", "```cpp\n#include \"Anim_Directional.h\"\n#include \"SpriteSheet.h\"\n```", "```cpp\nvoid Anim_Directional::CropSprite(){\n  sf::IntRect rect(m_spriteSheet->GetSpriteSize().x * m_frameCurrent,m_spriteSheet->GetSpriteSize().y * (m_frameRow + (short)m_spriteSheet->GetDirection()),m_spriteSheet->GetSpriteSize().x,m_spriteSheet->GetSpriteSize().y);\n  m_spriteSheet->CropSprite(rect);\n}\n```", "```cpp\nvoid Anim_Directional::FrameStep(){\n  if (m_frameStart < m_frameEnd){ ++m_frameCurrent; }\n  else { --m_frameCurrent; }\n\n  if ((m_frameStart < m_frameEnd && m_frameCurrent > m_frameEnd)||\n    (m_frameStart > m_frameEnd && m_frameCurrent < m_frameEnd))\n  {\n    if (m_loop){ m_frameCurrent = m_frameStart; return; }\n    m_frameCurrent = m_frameEnd;\n    Pause();\n  }\n}\n```", "```cpp\nvoid Anim_Directional::ReadIn(std::stringstream& l_stream){\n  l_stream >> m_frameStart >> m_frameEnd >> m_frameRow\n    >> m_frameTime >> m_frameActionStart >> m_frameActionEnd;\n}\n```", "```cpp\nbool SpriteSheet::LoadSheet(const std::string& l_file){\n  std::ifstream sheet;\n  sheet.open(Utils::GetWorkingDirectory() + l_file);\n  if(sheet.is_open()){\n    ReleaseSheet(); // Release current sheet resources.\n    std::string line;\n    while(std::getline(sheet,line)){\n      if (line[0] == '|'){ continue; }\n      std::stringstream keystream(line);\n      std::string type;\n      keystream >> type;\n      ...\n    }\n    sheet.close();\n    return true;\n  }\n  std::cerr << \"! Failed loading spritesheet: \"\n    << l_file << std::endl;\n  return false;\n}\n```", "```cpp\nif(type == \"Texture\"){\n  if (m_texture != \"\"){\n    std::cerr << \"! Duplicate texture entries in: \"\n      << l_file << std::endl;\n    continue;\n  }\n  std::string texture;\n  keystream >> texture;\n  if (!m_textureManager->RequireResource(texture)){\n    std::cerr << \"! Could not set up the texture: \"\n      << texture << std::endl;\n    continue;\n  }\n  m_texture = texture;\n  m_sprite.setTexture(*m_textureManager->GetResource(m_texture));\n} else if ...\n```", "```cpp\n} else if(type == \"Size\"){\n    keystream >> m_spriteSize.x >> m_spriteSize.y;\n    SetSpriteSize(m_spriteSize);\n} else if(type == \"Scale\"){\n    keystream >> m_spriteScale.x >> m_spriteScale.y;\n    m_sprite.setScale(m_spriteScale);\n} else if(type == \"AnimationType\"){\n    keystream >> m_animType;\n} else if ...\n```", "```cpp\n} else if(type == \"Animation\"){\n  std::string name;\n  keystream >> name;\n  if (m_animations.find(name) != m_animations.end()){\n    std::cerr << \"! Duplicate animation(\" << name \n      << \") in: \" << l_file << std::endl;\n    continue;\n  }\n  Anim_Base* anim  = nullptr;\n  if(m_animType == \"Directional\"){\n    anim = new Anim_Directional();\n  } else {\n    std::cerr << \"! Unknown animation type: \" \n      << m_animType << std::endl;\n    continue;\n  }\n\n  keystream >> *anim;\n  anim->SetSpriteSheet(this);\n  anim->SetName(name);\n  anim->Reset();\n  m_animations.emplace(name,anim);\n\n  if (m_animationCurrent){ continue; }\n  m_animationCurrent = anim;\n  m_animationCurrent->Play();\n}\n```"]