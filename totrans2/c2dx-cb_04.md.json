["```cpp\n    #ifndef __TitleScene_SCENE_H__\n    #define __TitleScene_SCENE_H__\n\n    #include \"cocos2d.h\"\n    class TitleScene : public cocos2d::Layer\n    {\n    public:\n        static cocos2d::Scene* createScene();\n        virtual bool init();\n        CREATE_FUNC(TitleScene);\n    };\n\n    #endif // __TitleScene_SCENE_H__\n    ```", "```cpp\n    #include \"TitleScene.h\"\n\n    USING_NS_CC;\n\n    Scene* TitleScene::createScene()\n    {\n        auto scene = Scene::create();\n        auto layer = TitleScene::create();\n        scene->addChild(layer);\n        return scene;\n    }\n\n    // on \"init\" you need to initialize your instance\n    bool TitleScene::init()\n    {\n        if ( !Layer::init() )\n        {\n            return false;\n        }\n\n        return true;\n    }\n    ```", "```cpp\n    bool TitleScene::init()\n    {\n        if ( !Layer::init() )\n        {\n            return false;\n        }\n\n        auto size = Director::getInstance()->getWinSize();\n        auto label =\n        Label::createWithSystemFont(\"TitleScene\", \"Arial\",\n        40);\n        label->setPosition(size/2);\n        this->addChild(label);\n\n        return true;\n    }\n    ```", "```cpp\n    bool HelloWorld::init()\n    {\n        if ( !Layer::init() )\n        {\n            return false;\n        }\n\n        auto size = Director::getInstance()->getWinSize();\n        auto label = Label::createWithSystemFont(\"HelloWorld\",\n        \"Arial\", 40);\n        label->setPosition(size/2);\n        this->addChild(label);\n\n        return true;\n    }\n    ```", "```cpp\n    #include \"TitleScene.h\"\n\n    bool AppDelegate::applicationDidFinishLaunching() {\n        // initialize director\n        auto director = Director::getInstance();\n        auto glview = director->getOpenGLView();\n        if(!glview) {\n            glview = GLViewImpl::create(\"My Game\");\n            director->setOpenGLView(glview);\n        }\n\n        // turn on display FPS\n        director->setDisplayStats(true);\n\n        // set FPS. the default value is 1.0/60 if you don't\n        call this director->setAnimationInterval(1.0 / 60);\n        glview->setDesignResolutionSize(640, 960,\n        ResolutionPolicy::NO_BORDER); \n        // create a scene. it's an autorelease object\n        auto scene = TitleScene::createScene();\n\n        // run\n        director->runWithScene(scene);\n\n        return true;\n    }\n    ```", "```cpp\nauto scene = TitleScene::createScene();\n// run\ndirector->runWithScene(scene);\n```", "```cpp\n    auto scene = HelloWorld::createScene();\n    Director::getInstance()->replaceScene(scene);\n    ```", "```cpp\n    auto scene = HelloWorld::createScene();\n    Director::getInstance()->pushScene(scene);\n    ```", "```cpp\nauto Director::getInstance()->popScene();\n```", "```cpp\nauto nextScene = HelloWorld::createScene();\nauto transition = TransitionFade::create(1.0f, nextScene);\nDirector::getInstance()->replaceScene(transition);\n```", "```cpp\nauto nextScene = HelloWorld::createScene();\nauto transition = TransitionFade::create(1.0f, nextScene);\nDirector::getInstance()->pushScene(transition);\n```", "```cpp\nclass HelloWorld : public cocos2d::Layer\n{\npublic:\n  static cocos2d::Scene* createScene();\n  virtual bool init();\n  CREATE_FUNC(HelloWorld);\n\n  virtual void onEnterTransitionDidFinish();\n  virtual void onExitTransitionDidStart();\n};\n\nHelloWorldScene.cpp has the following code:\nvoid HelloWorld::onEnterTransitionDidFinish()\n{\n  CCLOG(\"finished enter transition\");\n}\n\nvoid HelloWorld::onExitTransitionDidStart()\n{\n  CCLOG(\"started exit transition\");\n}\n```", "```cpp\n#ifndef __TRANSITIONDOOR_H__\n#define __TRANSITIONDOOR_H__\n\n#include \"cocos2d.h\"\n\nNS_CC_BEGIN\n\nclass CC_DLL TransitionDoor : public TransitionScene , public TransitionEaseScene\n{\npublic:\n  static TransitionDoor* create(float t, Scene* scene);\n\n  virtual ActionInterval* action();\n  virtual void onEnter() override;\n  virtual ActionInterval * easeActionWithAction(ActionInterval * action) override;\n  virtual void onExit() override;\n  virtual void draw(Renderer *renderer, const Mat4 &transform,\n  uint32_t flags) override;\n  CC_CONSTRUCTOR_ACCESS:\n  TransitionDoor();\n  virtual ~TransitionDoor();\n\nprotected:\n  NodeGrid* _gridProxy;\n  private:\n  CC_DISALLOW_COPY_AND_ASSIGN(TransitionDoor);\n};\n\nclass CC_DLL SplitDoor : public TiledGrid3DAction\n{\npublic:\n  /**\n   * creates the action with the number of columns to split and\n   the duration\n   * @param duration in seconds\n   */\n  static SplitDoor* create(float duration, unsigned int cols);\n\n  // Overrides\n  virtual SplitDoor* clone() const override;\n  /**\n   * @param time in seconds\n   */ \n  virtual void update(float time) override;\n  virtual void startWithTarget(Node *target) override;\n\nCC_CONSTRUCTOR_ACCESS:\n  SplitDoor() {}\n  virtual ~SplitDoor() {}\n\n  /** initializes the action with the number of columns to split\nand the duration */\n  bool initWithDuration(float duration, unsigned int cols);\n\nprotected:\n  unsigned int _cols;\n  Size _winSize;\n\nprivate:\n  CC_DISALLOW_COPY_AND_ASSIGN(SplitDoor);\n};\n\nNS_CC_END\n\n#endif /* defined(__TRANSITIONDOOR_H__) */\n```", "```cpp\n#include \"TransitionDoor.h\"\n\nNS_CC_BEGIN\n\nTransitionDoor::TransitionDoor()\n{\n  _gridProxy = NodeGrid::create();\n  _gridProxy->retain();\n}\nTransitionDoor::~TransitionDoor()\n{\n  CC_SAFE_RELEASE(_gridProxy);\n}\n\nTransitionDoor* TransitionDoor::create(float t, Scene* scene)\n{\n  TransitionDoor* newScene = new (std::nothrow) TransitionDoor();\n  if(newScene && newScene->initWithDuration(t, scene))\n  {\n    newScene->autorelease();\n    return newScene;\n  }\n  CC_SAFE_DELETE(newScene); \n  return nullptr;\n}\n\nvoid TransitionDoor::onEnter()\n{\n  TransitionScene::onEnter();\n\n  _inScene->setVisible(true);\n\n  _gridProxy->setTarget(_outScene);\n  _gridProxy->onEnter();\n\n  ActionInterval* split = action();\n  ActionInterval* seq = (ActionInterval*)Sequence::create\n  (\n   split,\n   CallFunc::create(CC_CALLBACK_0(TransitionScene::finish,this)),\n   StopGrid::create(),\n   nullptr\n   );\n\n  _gridProxy->runAction(seq);\n}\n\nvoid TransitionDoor::draw(Renderer *renderer, const Mat4\n&transform, uint32_t flags)\n{\n  Scene::draw(renderer, transform, flags);\n  _inScene->visit();\n  _gridProxy->visit(renderer, transform, flags);\n}\n\nvoid TransitionDoor::onExit()\n{\n  _gridProxy->setTarget(nullptr);\n  _gridProxy->onExit();\n  TransitionScene::onExit();\n}\n\nActionInterval* TransitionDoor:: action()\n{\n  return SplitDoor::create(_duration, 3);\n}\n\nActionInterval*\nTransitionDoor::easeActionWithAction(ActionInterval * action)\n{\n  return EaseInOut::create(action, 3.0f);\n}\n\nSplitDoor* SplitDoor::create(float duration, unsigned int cols)\n{\n  SplitDoor *action = new (std::nothrow) SplitDoor();\n\n  if (action)\n  {\n    if (action->initWithDuration(duration, cols))\n    {\n      action->autorelease();\n    }\n    else\n    {\n      CC_SAFE_RELEASE_NULL(action);\n    }\n  }\n\n  return action;\n}\n\nbool SplitDoor::initWithDuration(float duration, unsigned int cols)\n{\n  _cols = cols;\n  return TiledGrid3DAction::initWithDuration(duration, Size(cols,\n1));\n}\n\nSplitDoor* SplitDoor::clone() const \n{\n  // no copy constructor\n  auto a = new (std::nothrow) SplitDoor();\n  a->initWithDuration(_duration, _cols);\n  a->autorelease();\n  return a;\n}\n\nvoid SplitDoor::startWithTarget(Node *target)\n{\n  TiledGrid3DAction::startWithTarget(target);\n  _winSize = Director::getInstance()->getWinSizeInPixels();\n}\n\nvoid SplitDoor::update(float time)\n{\n  for (unsigned int i = 0; i < _gridSize.width; ++i) \n  {\n    Quad3 coords = getOriginalTile(Vec2(i, 0));\n    float  direction = 1;\n\n    if ( (i % 2 ) == 0 )\n    {\n      direction = -1;\n    }\n\n    coords.bl.x += direction * _winSize.width/2 * time;\n    coords.br.x += direction * _winSize.width/2 * time;\n    coords.tl.x += direction * _winSize.width/2 * time;\n    coords.tr.x += direction * _winSize.width/2 * time;|\n\n    setTile(Vec2(i, 0), coords);\n  }\n}\nNS_CC_END\n```", "```cpp\nauto trans = TransitionDoor::create(1.0f,\nHelloWorld::createScene());\nDirector::getInstance()->replaceScene(trans);\n```", "```cpp\nclass DirectorEx : public Director\n{\npublic:\n  Scene* previousScene(void);\n  void popScene(Scene* trans);\n};\n```", "```cpp\n#include \"DirectorEx.h\"\n\nScene* DirectorEx::previousScene()\n{\n  ssize_t sceneCount = _scenesStack.size();\n  if (sceneCount <= 1) {\n    return nullptr;\n  }\n  return _scenesStack.at(sceneCount-2);\n}\n\nvoid DirectorEx::popScene(Scene* trans)\n{\n  _scenesStack.popBack();\n  ssize_t sceneCount = _scenesStack.size();\n  if (sceneCount==0) {\n    end();\n  } else {\n    _sendCleanupToScene = true;\n    _nextScene = trans;\n  }\n}\n```", "```cpp\nDirectorEx* directorEx = static_cast<DirectorEx*>(Director::getInstance());\nScene* prevScene = directorEx->previousScene();\nScene* pScene = TransitionFlipX::create(duration, prevScene);\ndirectorEx->popScene(pScene);\n```", "```cpp\n    DirectorEx* directorEx = static_cast<DirectorEx*>(Director::getInstance());\n    ```", "```cpp\n    Scene* prevScene = directorEx->previousScene();\n    ```", "```cpp\n    Scene* pScene = TransitionFlipX::create(duration, prevScene);\n    ```", "```cpp\n    directorEx->popScene(pScene);\n    ```", "```cpp\nauto layer = Layer::create();\nthis->addChild(layer);\n```", "```cpp\nauto layer = LayerColor::create(Color4B::WHITE);\nthis->addChild(layer);\n```", "```cpp\n#include \"cocos2d.h\"\n\nUSING_NS_CC;\n\nclass ModalLayer : public Layer\n{\npublic:\n  ModalLayer();\n  ~ModalLayer();\n  bool init();\n  CREATE_FUNC(ModalLayer);\n  void close(Ref* sender=nullptr);\n};\n\nModalLayer.cpp should have the following code:\n#include \"ModalLayer.h\"\nUSING_NS_CC;\n\nModalLayer::ModalLayer()\n{\n}\n\nModalLayer::~ModalLayer()\n{\n}\n\nbool ModalLayer::init()\n{\n  if (!Layer::init())\n  {\n    return false;\n  }\n\n  auto listener = EventListenerTouchOneByOne::create();\n  listener->setSwallowTouches(true);\n  listener->onTouchBegan = [](Touch *touch,Event*event)->bool{\n  return true; };\n  this->getEventDispatcher()->addEventListenerWithSceneGraphPriority(listener, this);\n\n  return true;\n}\n\nvoid ModalLayer::close(Ref* sender)\n{\n  this->removeFromParentAndCleanup(true);\n}\n```", "```cpp\n// add modal layer\nauto modal = ModalLayer::create();\nthis->addChild(modal);\n\n// close modal layer\nmodal->close();\n```", "```cpp\nlistener->onTouchBegan = [](Touch *touch,Event*event)->bool{ return true; };\n```"]