<html><head></head><body><div class="chapter" title="Chapter&#xA0;13.&#xA0;Improving your C Programming and Creating Libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch13"/>Chapter 13. Improving your C Programming and Creating Libraries</h1></div></div></div><p>This is the last chapter of this book and is the most advanced, but not the most complex. You will learn about C code optimization through several typical examples that will bring you a bit further and make you more capable for your future projects using Arduino. I am going to talk about libraries and how they can improve the reusability of your code to save time in the future. I will describe some tips to improve the performance of your code by using bit-shifting instead of the usual operators, and by using some memory management techniques. Then, I will talk about reprogramming the Arduino chip itself and debugging our code using an external hardware programmer.</p><p>Let's go.</p><div class="section" title="Programming libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec88"/>Programming libraries</h1></div></div></div><p>I have already <a id="id1511" class="indexterm"/>spoken about libraries in <a class="link" href="ch02.html" title="Chapter 2. First Contact with C">Chapter 2</a>, <span class="emphasis"><em>First Contact with C</em></span>. We can define it as a set of implementations of behavior already written using a particular language that provides some interfaces by which all the available behaviors can be called.</p><p>Basically, a library is something already written and reusable in our own code by following some specifications. For example, we can quote some libraries included in the Arduino core. Historically, some of those libraries had been written independently, and over time, the Arduino team as well as the whole Arduino community incorporated them into the growing core as natively available libraries.</p><p>Let's take the <a id="id1512" class="indexterm"/>EEPROM library. In order to check files related to it, we have to find the right folder on our computer. On OS X, for instance, we can browse the contents of the <code class="literal">Arduino.app</code> file <a id="id1513" class="indexterm"/>itself. We can go to the <code class="literal">EEPROM</code> folder in <code class="literal">Contents</code>/<code class="literal">Resources</code>/<code class="literal">Java</code>/<code class="literal">libraries</code>/. In this folder, we have three files and a folder named <code class="literal">examples</code> containing all the examples related to the EEPROM library:</p><div class="mediaobject"><img src="graphics/7584_13_001.jpg" alt="Programming libraries"/><div class="caption"><p>The EEPROM library on our computer (an OS X system)</p></div></div><p>We have the <a id="id1514" class="indexterm"/>following files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">EEPROM.h</code>, containing the <a id="id1515" class="indexterm"/>headers of the library</li><li class="listitem" style="list-style-type: disc"><code class="literal">EEPROM.cpp</code>, containing<a id="id1516" class="indexterm"/> the code itself</li><li class="listitem" style="list-style-type: disc"><code class="literal">keywords.txt</code>, containing <a id="id1517" class="indexterm"/>some parameters to color the keywords of the library</li></ul></div><p>Because of the location of these files in the folder hierarchy, they are available as parts of the core EEPROM library. This means we can include this library as soon as we have the Arduino environment installed on our computer without downloading anything else.</p><p>The simple statement <code class="literal">include &lt;EEPROM.h&gt;</code> includes the library in our code and makes all the features of this library available for further use.</p><p>Let's enter code in these files.</p><div class="section" title="The header file"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec192"/>The header file</h2></div></div></div><p>Let's <a id="id1518" class="indexterm"/>open<a id="id1519" class="indexterm"/> <code class="literal">EEPROM.h</code>:</p><div class="mediaobject"><img src="graphics/7584_13_002.jpg" alt="The header file"/><div class="caption"><p>EEPROM.h displayed in Xcode IDE</p></div></div><p>In this file, we <a id="id1520" class="indexterm"/>can see <a id="id1521" class="indexterm"/>some preprocessor directives starting with the <code class="literal">#</code> character. This is the same one that we use to include libraries in our Arduino code. Here, this is a nice way to not include the same header twice. Sometimes, while coding, we include a lot of libraries and at compilation time, we would have to check that we didn't include the same code twice. These directives and especially the <code class="literal">ifndef</code> directive mean: "If the <code class="literal">EEPROM_h</code> constant has not been defined, then do the following statements".</p><p>This is a trick commonly known as <a id="id1522" class="indexterm"/>
<span class="strong"><strong>include guards</strong></span>. The first thing we are doing after this test is defining the <code class="literal">EEPROM_h</code> constant. If in our code we or some other libraries include the EEPROM library, the preprocessor wouldn't reprocess the following statements the second time it sees this directive.</p><p>We have to finish the <code class="literal">#ifndef</code> directive with the <code class="literal">#endif</code> directive. This is a common block in the header files and you'll see it many times if you open other library header files files. What is contained inside this block? We have another inclusion related to C integer types: <code class="literal">#include &lt;inttypes.h&gt;</code>.</p><p>The Arduino IDE <a id="id1523" class="indexterm"/>contains all the required C headers in the library. As we have <a id="id1524" class="indexterm"/>already mentioned, we could use pure C and C++ code in our firmware. We didn't until now because the functions and types we've been using have already been coded into the Arduino core. But please keep in mind that you have the choice to include other pure C code in your firmware and in this last chapter, we will also talk about the fact you can also follow pure AVR processor-type code too.</p><p>Now we have a class definition. This is a C++ feature. Inside this class, we declare two function prototypes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">uint8_t read(int)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">void write(int, uint8_t)</code></li></ul></div><p>There is a function to read something, taking an integer as an argument and returning an unsigned integer that is 8 bits long (which is a byte). Then, there is another function to write something that takes an integer and a byte and returns nothing. These prototypes refer to the definition of these functions in the other <code class="literal">EEPROM.cpp</code> file.</p></div><div class="section" title="The source file"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec193"/>The source file</h2></div></div></div><p>Let's<a id="id1525" class="indexterm"/> open<a id="id1526" class="indexterm"/> <code class="literal">EEPROM.cpp</code>:</p><div class="mediaobject"><img src="graphics/7584_13_003.jpg" alt="The source file"/><div class="caption"><p>The source file of the EEPROM library is displayed in the Xcode IDE</p></div></div><p>The file begins by<a id="id1527" class="indexterm"/> including <a id="id1528" class="indexterm"/>some headers. <code class="literal">avr/eeprom.h</code> refers to the AVR type processor's EEPROM library itself. In this library example, we just have a library referring to and making a better interface for our Arduino programming style than the original pure AVR code. This is why I chose this library example. This is the shortest but the most explicit example, and it teaches us a lot.</p><p>Then we include the <code class="literal">Arduino.h</code> header in order to have access to standard types and constants of the Arduino language itself. At last, of course, we include the header of the EEPROM library itself.</p><p>In the following statements, we <a id="id1529" class="indexterm"/>define both functions. They call other <a id="id1530" class="indexterm"/>functions inside their block definition:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">eeprom_read_byte()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">eeprom_write_byte()</code></li></ul></div><p>Those <a id="id1531" class="indexterm"/>functions <a id="id1532" class="indexterm"/>come from the AVR EEPROM library itself. The EEPROM Arduino library is only an interface to the AVR EEPROM library itself. Why wouldn't we try to create a library ourselves?</p></div></div></div>
<div class="section" title="Creating your own LED-array library"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec89"/>Creating your own LED-array library</h1></div></div></div><p>We are going to create a <a id="id1533" class="indexterm"/>very small library and test it with a basic circuit including six LEDs that are not multiplexed.</p><div class="section" title="Wiring six LEDs to the board"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec194"/>Wiring six LEDs to the board</h2></div></div></div><p>Here is the circuit. It <a id="id1534" class="indexterm"/>basically <a id="id1535" class="indexterm"/>contains<a id="id1536" class="indexterm"/> six LEDs wired to Arduino:</p><div class="mediaobject"><img src="graphics/7584_13_005.jpg" alt="Wiring six LEDs to the board"/><div class="caption"><p>Six LEDs wired to the board</p></div></div><p>The <a id="id1537" class="indexterm"/>circuit<a id="id1538" class="indexterm"/> diagram is <a id="id1539" class="indexterm"/>shown as follows:</p><div class="mediaobject"><img src="graphics/7584_13_006.jpg" alt="Wiring six LEDs to the board"/><div class="caption"><p>Another diagram of the six LEDs wired directly to Arduino</p></div></div><p>I won't <a id="id1540" class="indexterm"/>discuss the circuit itself, except to mention that I put in a 1 kΩ resistor. I took the worst case where all <a id="id1541" class="indexterm"/>LEDs would be switched on at the <a id="id1542" class="indexterm"/>same time. This would drive a lot of current, and so this acts as security for our Arduino. Some authors wouldn't use it. I'd prefer to have some LEDs dimming a bit in order to protect my Arduino.</p></div><div class="section" title="Creating some nice light patterns"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec195"/>Creating some nice light patterns</h2></div></div></div><p>Here is code for<a id="id1543" class="indexterm"/> lighting<a id="id1544" class="indexterm"/> up the LEDs according to some patterns, all hardcoded. A pause is made between each pattern display:</p><div class="informalexample"><pre class="programlisting">void setup() {

  for (int i = 2 ; i &lt;= 7 ; i++)
  {
    pinMode(i, OUTPUT);
  }
}

void loop(){

  // switch on everything progressively
  for (int i = 2 ; i &lt;= 7 ; i++)
  {
    digitalWrite(i, HIGH);
    delay(100);
  }

  delay(3000);

  // switch off everything progressively
  for (int i = 7 ; i &gt;=2 ; i--)
  {
    digitalWrite(i, LOW);
    delay(100);
  }

  delay(3000);

  // switch on even LEDS
  for (int i = 2 ; i &lt;= 7 ; i++)
  {
    if ( i % 2 == 0 ) digitalWrite(i, HIGH);
    else digitalWrite(i, LOW);
  }

  delay(3000);

  // switch on odd LEDS
  for (int i = 2 ; i &lt;= 7 ; i++)
  {
    if ( i % 2 != 0 ) digitalWrite(i, HIGH);
    else digitalWrite(i, LOW);
  }
  
  delay(3000);
}</pre></div><p>This code works correctly. But how could we make it more elegant and, especially, more reusable? We could embed the <code class="literal">for()</code> blocks into functions. But these would only be available in this code. We'd have to copy and paste them by remembering the project in which we designed them in order to reuse them in another project.</p><p>By creating a <a id="id1545" class="indexterm"/>small library that we can use over and over again, we can save time in<a id="id1546" class="indexterm"/> the future in coding as well as processing. With some periodic modifications, we can arrive at the perfect module for its intended task, which will get better and better until there's no need to even touch it anymore because it performs more perfectly than anything else out there. At least that's what we hope for.</p></div><div class="section" title="Designing a small LED-pattern library"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec196"/>Designing a small LED-pattern library</h2></div></div></div><p>At first, we can design our <a id="id1547" class="indexterm"/>function's prototype in a header. Let's call the library <code class="literal">LEDpatterns</code>.</p><div class="section" title="Writing the LEDpatterns.h header"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec152"/>Writing the LEDpatterns.h header</h3></div></div></div><p>Here is how a <a id="id1548" class="indexterm"/>possible header could be:</p><div class="informalexample"><pre class="programlisting">/*
  LEDpatterns - Library for making cute LEDs Pattern.
  Created by Julien Bayle, February 10, 2013.
*/
#ifndef LEDpatterns_h
#define LEDpatterns_h

#include "Arduino.h"

class LEDpatterns
{
  public:
    LEDpatterns(int firstPin, int ledsNumber);
    void switchOnAll();
    void switchOffAll();
    void switchEven();
    void switchOdd();
  private:
    int _firstPin;
    int _ledsNumber;
};
#endif</pre></div><p>We first write our include guards. Then we include the Arduino library. Then, we define a class named <code class="literal">LEDpatterns</code> with the <code class="literal">public</code> functions including a constructor that has the same name as the class itself.</p><p>We also have two internal (<code class="literal">private</code>) variables related to the first pin on which LEDs are wired and related to the total number of LEDs wired. LEDs would have to be contiguously <a id="id1549" class="indexterm"/>wired in that example.</p></div><div class="section" title="Writing the LEDpatterns.cpp source"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec153"/>Writing the LEDpatterns.cpp source</h3></div></div></div><p>Here is the <a id="id1550" class="indexterm"/>source code of the C++ library:</p><div class="informalexample"><pre class="programlisting">/*
  LEDpatterns.cpp - Library for making cute LEDs Pattern.
 Created by Julien Bayle, February 10, 2013.
 */
#include "Arduino.h"
#include "LEDpatterns.h"

LEDpatterns::LEDpatterns(int firstPin, int ledsNumber)
{
  for (int i = firstPin ; i &lt; ledsNumber + firstPin ; i++)
  {
    pinMode(i, OUTPUT);
  }

  _ledsNumber = ledsNumber;
  _firstPin = firstPin;
}

void LEDpatterns::switchOnAll()
{
  for (int i = _firstPin ; i &lt; _ledsNumber + _firstPin ; i++)
  {
    digitalWrite(i, HIGH);
    delay(100);
  }
}

void LEDpatterns::switchOffAll()
{
  for (int i = _ledsNumber + _firstPin -1 ; i &gt;= _firstPin   ; i--)
  {
    digitalWrite(i, LOW);
    delay(100);
  }
}

void LEDpatterns::switchEven()
{
  for (int i = _firstPin ; i &lt; _ledsNumber + _firstPin ; i++)
  {
    if ( i % 2 == 0 ) digitalWrite(i, HIGH);
    else digitalWrite(i, LOW);
  }
}

void LEDpatterns::switchOdd()
{
  for (int i = _firstPin ; i &lt; _ledsNumber + _firstPin ; i++)
  {
    if ( i % 2 != 0 ) digitalWrite(i, HIGH);
    else digitalWrite(i, LOW);
  }
}</pre></div><p>At the beginning, we retrieve all the <code class="literal">include</code> libraries. Then we have the constructor, which is a special method with the same name as the library. This is the important point here. It takes two arguments. Inside its body, we put all the pins from the first one to the last one considering the LED number as a digital output. Then, we store the arguments of the constructor<a id="id1551" class="indexterm"/> inside the <code class="literal">private</code> variables previously defined in the header <code class="literal">LEDpatterns.h</code>.</p><p>We can then declare all our functions related to those created in the first example without the library. Notice the <code class="literal">LEDpatterns::</code> prefix for each function. I won't discuss this pure class-related syntax here, but keep in mind the structure. </p></div><div class="section" title="Writing the keyword.txt file"><div class="titlepage"><div><div><h3 class="title"><a id="ch13lvl3sec154"/>Writing the keyword.txt file</h3></div></div></div><p>When we look at <a id="id1552" class="indexterm"/>our source code, it's very helpful to have things jump out at you, and not blend into the background. In order to correctly color the different keywords related to our new created library, we have to use the <code class="literal">keyword.txt</code> file. Let's check this file out:</p><div class="informalexample"><pre class="programlisting">#######################################
# Syntax Coloring Map For Messenger
#######################################

#######################################
# Datatypes (KEYWORD1)
#######################################

LEDpatterns	KEYWORD1

#######################################
# Methods and Functions (KEYWORD2)
#######################################
switchOnAll	KEYWORD2
switchOffAll	KEYWORD2
switchEven	KEYWORD2
switchOdd	KEYWORD2

#######################################
# Instances (KEYWORD2)
#######################################

#######################################
# Constants (LITERAL1)
#######################################</pre></div><p>In the preceding code we can see the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Everything followed by <code class="literal">KEYWORD1</code> will be colored in orange and is usually for classes</li><li class="listitem" style="list-style-type: disc">Everything followed by <code class="literal">KEYWORD2</code> will be colored in brown and is for functions</li><li class="listitem" style="list-style-type: disc">Everything followed by <code class="literal">LITERAL1</code> will be colored in blue and is for constants</li></ul></div><p>It is very<a id="id1553" class="indexterm"/> useful to use these in order to color your code and make it more readable.</p></div></div><div class="section" title="Using the LEDpatterns library"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec197"/>Using the LEDpatterns library</h2></div></div></div><p>The library is in<a id="id1554" class="indexterm"/> the <code class="literal">LEDpatterns</code> folder in <code class="literal">Chapter13</code> and you have to put it in the correct folder with the other libraries, which we have done. We have to restart the Arduino IDE in order to make the library available. After having done that, you should be able to check if it is in the menu <span class="strong"><strong>Sketch</strong></span> | <span class="strong"><strong>Import Library</strong></span>. <code class="literal">LEDpatterns</code> is now present in the list:</p><div class="mediaobject"><img src="graphics/7584_13_007.jpg" alt="Using the LEDpatterns library"/><div class="caption"><p>The library is a contributed one because it is not part of the Arduino core</p></div></div><p>Let's now <a id="id1555" class="indexterm"/>check the new code using this library. You can find it in the <code class="literal">Chapter13</code>/<code class="literal">LEDLib</code> folder:</p><div class="informalexample"><pre class="programlisting">#include &lt;LEDpatterns.h&gt;
LEDpatterns ledpattern(2,6);

void setup() {
}

void loop(){

  ledpattern.switchOnAll();
  delay(3000);

  ledpattern.switchOffAll();
  delay(3000);

  ledpattern.switchEven();
  delay(3000);

  ledpattern.switchOdd();
  delay(3000);
}</pre></div><p>In the first step, we include the <code class="literal">LEDpatterns</code> library. Then, we create the instance of <code class="literal">LEDpatterns</code> named <code class="literal">ledpattern</code>. We call the constructor that we designed previously with two arguments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first pin of the first LED</li><li class="listitem" style="list-style-type: disc">The total number of LEDs</li></ul></div><p>
<code class="literal">ledpattern</code> is an<a id="id1556" class="indexterm"/> instance of the <code class="literal">LEDpatterns</code> class. It is referenced throughout our code, and without <code class="literal">#include</code>, it would not work. We have also invoked each method of this instance.</p><p>If the code seems to be cleaner, the real benefit of such a design is the fact that we can reuse this library inside any of our projects. If we want to modify and improve the library, we only have to modify things in the header and the source file of our library.</p></div></div>
<div class="section" title="Memory management"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec90"/>Memory management</h1></div></div></div><p>This section is a very <a id="id1557" class="indexterm"/>short one but not a less important one at all. We have to remember we have the following three pools of memory on Arduino:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Flash memory (program space), where the firmware is stored</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Static Random Access Memory</strong></span> (<span class="strong"><strong>SRAM</strong></span>), where the sketch creates and manipulates variables at runtime</li><li class="listitem" style="list-style-type: disc">EEPROM is a memory space to store long-term information</li></ul></div><p>Flash<a id="id1558" class="indexterm"/> and<a id="id1559" class="indexterm"/> EEPROM, compared to <a id="id1560" class="indexterm"/>SRAM, are non-volatile, which means the data persists even after the power is turned off. Each different Arduino board has a different amount of memory:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">ATMega328 (UNO) <a id="id1561" class="indexterm"/>has:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Flash 32k bytes (0.5k bytes used by the bootloader)</li><li class="listitem" style="list-style-type: disc">SRAM 2k bytes</li><li class="listitem" style="list-style-type: disc">EEPROM 1k bytes</li></ul></div></li><li class="listitem" style="list-style-type: disc">ATMega2560 (MEGA)<a id="id1562" class="indexterm"/> has:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Flash 256k bytes (8k bytes used by the bootloader)</li><li class="listitem" style="list-style-type: disc">SRAM 8k bytes</li><li class="listitem" style="list-style-type: disc">EEPROM 4k bytes</li></ul></div></li></ul></div><p>A classic example is to quote a basic declaration of a string:</p><div class="informalexample"><pre class="programlisting">char text[] = "I love Arduino because it rocks.";</pre></div><p>That takes 32 bytes into SRAM. It doesn't seem a lot but with the UNO, you <span class="emphasis"><em>only</em></span> have 2048 bytes available. Imagine you use a big lookup table or a large amount of text. Here are some tips to save <a id="id1563" class="indexterm"/>memory:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If your project uses both Arduino and a computer, you can try to move some calculation steps from Arduino to the computer itself, making Arduino only trigger calculations on the computer and request results, for instance.</li><li class="listitem" style="list-style-type: disc">Always use the smallest data type possible to store values you need. If you need to store something between 0 and 255, for instance, don't use an <code class="literal">int</code> type that takes 2 bytes, but use a <code class="literal">byte</code> type instead</li><li class="listitem" style="list-style-type: disc">If you use some lookup tables or data that won't be changed, you can store them in the Flash memory instead of the SRAM. You have to use the <code class="literal">PROGMEM</code> keyword<a id="id1564" class="indexterm"/> to do that.</li><li class="listitem" style="list-style-type: disc">You can use the native EEPROM of your Arduino board, which would require making two small programs: the first to store that information in the EEPROM, and the second to use it. We did that using the PCM library in the <a class="link" href="ch09.html" title="Chapter 9. Making Things Move and Creating Sounds">Chapter 9</a>, <span class="emphasis"><em>Making Things Move and Creating Sounds</em></span>.</li></ul></div></div>
<div class="section" title="Mastering bit shifting"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec91"/>Mastering bit shifting</h1></div></div></div><p>There are<a id="id1565" class="indexterm"/> two <a id="id1566" class="indexterm"/>bit shift operators in C++:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;&lt;</code> is the left shift operator</li><li class="listitem" style="list-style-type: disc"><code class="literal">&gt;&gt;</code> is the right shift operator</li></ul></div><p>These can be very useful especially in SRAM memory, and can often optimize your code. <code class="literal">&lt;&lt;</code> can be understood as a multiplication of the left operand by 2 raised to the right operand power.</p><p>
<code class="literal">&gt;&gt;</code> is the same but is similar to a division. The ability to manipulate bits is often very useful and can make your code faster in many situations.</p><div class="section" title="Multiplying/dividing by multiples of 2"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec198"/>Multiplying/dividing by multiples of 2</h2></div></div></div><p>Let's multiply a<a id="id1567" class="indexterm"/> variable using <a id="id1568" class="indexterm"/>bit shifting.</p><div class="informalexample"><pre class="programlisting">int a = 4;
int b = a &lt;&lt; 3;</pre></div><p>The second row multiplies the variable <code class="literal">a</code> by <code class="literal">2</code> to the third power, so <code class="literal">b</code> now contains <code class="literal">32</code>. On the same lines, division can be carried out as follows:</p><div class="informalexample"><pre class="programlisting">int a = 12 ;
int b = a &gt;&gt; 2;</pre></div><p>
<code class="literal">b</code> contains <code class="literal">3</code> because <code class="literal">&gt;&gt; 2</code> equals division by 4. The code can be faster using these operators because they are a direct access to binary operations without using any function of the Arduino core like <code class="literal">pow()</code> or even the other operators.</p></div><div class="section" title="Packing multiple data items into bytes"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec199"/>Packing multiple data items into bytes</h2></div></div></div><p>Instead of using a big, two-dimensional <a id="id1569" class="indexterm"/>table to store, for<a id="id1570" class="indexterm"/> instance, a bitmap shown as follows:</p><div class="informalexample"><pre class="programlisting">const prog_uint8_t BitMap[5][7] = {   
// store in program memory to save RAM         
{1,1,0,0,0,1,1},         
{0,0,1,0,1,0,0},         
{0,0,0,1,0,0,0},         
{0,0,1,0,1,0,0},         
{1,1,0,0,0,1,1}     }; </pre></div><p>We can use use the following code:</p><div class="informalexample"><pre class="programlisting">const prog_uint8_t BitMap[5] = {   
// store in program memory to save RAM         
B1100011,         
B0010100,         
B0001000,         
B0010100,         
B1100011     }; </pre></div><p>In the first case, it takes 7 x 5 = 35 bytes per bitmap. In the second one, it takes only 5 bytes. I guess you've just figured out something huge, haven't you?</p></div><div class="section" title="Turning on/off individual bits in a control and port register"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec200"/>Turning on/off individual bits in a control and port register</h2></div></div></div><p>The following is a <a id="id1571" class="indexterm"/>direct <a id="id1572" class="indexterm"/>consequence of the previous tip. If we want to set up pins 8 to 13 as output, we could do it like this:</p><div class="informalexample"><pre class="programlisting">void setup()     {         
  int pin;         
  
  for (pin=8; pin &lt;= 13; ++pin) {             
    pinMode (pin, LOW);         
  } 
}</pre></div><p>But this would be better:</p><div class="informalexample"><pre class="programlisting">void setup()     {         
 DDRB = B00111111 ; // DDRB are pins from 8 to 15
}</pre></div><p>In one pass, we've configured the whole package into one variable directly in memory, and no<a id="id1573" class="indexterm"/> <code class="literal">pinMode</code> function, structure, or variable name needs to be compiled.</p></div></div>
<div class="section" title="Reprogramming the Arduino board"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec92"/>Reprogramming the Arduino board</h1></div></div></div><p>Arduino natively uses<a id="id1574" class="indexterm"/> the famous bootloader. This provides a nice way to upload our firmware using the virtual serial port on the USB. But we might be interested to go ahead without any bootloader. How and why? Firstly, that would save some Flash memory. It also provides a way to avoid the small delay when we power on or reset our board before it becomes active and starts running. It requires an external programmer.</p><p>I can quote the AVR-ISP, the STK500, or even a parallel programmer (a parallel programmer is described at <a class="ulink" href="http://arduino.cc/en/Hacking/ParallelProgrammer">http://arduino.cc/en/Hacking/ParallelProgrammer</a>). You can find an AVR-ISP at Sparkfun Electronics.</p><p>I used this one a couple of times to program an Arduino FIO-type board for specific wireless applications in a project connecting cities named The Village in 2013.</p><div class="mediaobject"><img src="graphics/7584_13_008.jpg" alt="Reprogramming the Arduino board"/><div class="caption"><p>The Pocket AVR programmer by Sparkfun Electronics</p></div></div><p>This programmer <a id="id1575" class="indexterm"/>can be wired using 2 x 5 connectors to the ICSP port on the Arduino board.</p><div class="mediaobject"><img src="graphics/7584_13_009.jpg" alt="Reprogramming the Arduino board"/><div class="caption"><p>The ICSP connector of Arduino</p></div></div><p>In order to reprogram<a id="id1576" class="indexterm"/> the processor of Arduino, we have to first close the Arduino IDE, and then check the preferences file (<code class="literal">preferences.txt</code> on a Mac, located in <code class="literal">Contents</code>/<code class="literal">Resources</code>/<code class="literal">Java</code>/<code class="literal">lib</code> inside the <code class="literal">Arduino.app</code> package itself). On a Windows 7 PC and higher, this file is located at: <code class="literal">c:\Users\&lt;USERNAME&gt;\AppData\Local\Arduino\preferences.txt</code>. In Linux it is located at: <code class="literal">~/arduino/preferences.ard</code>.</p><p>We have to change the <code class="literal">upload.using</code> value that is initially set to bootloader to the correct identifier that fits your programmer. This can be found in the content of the Arduino application package on OS X or inside the Arduino folders on Windows. For instance, if you display the <code class="literal">Arduino.app</code> content, you can find this file: <code class="literal">Arduino.app/Contents/Resources/Java/hardware/arduino/programmers.txt</code>.</p><p>Then we can start the Arduino IDE to upload the sketch using our programmer. To revert back to the normal bootloader behavior, we have to first reupload the bootloader that fits with our hardware. Then, we have to change back the <code class="literal">preferences.txt</code> file, and it will work as the initial board.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec93"/>Summary</h1></div></div></div><p>In this chapter, we learned more about designing libraries, and we are now able to design our projects a bit differently, keeping in mind reusability of the code or part of the code in future projects. This can save time and also improves readability. </p><p>We can also explore existing libraries and enjoy the world of open source by taking them, hacking them, and making them fit our needs. This is a really open world into which we have just made our first steps.</p></div>
<div class="section" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec94"/>Conclusion</h1></div></div></div><p>We are at the end of this book. You have probably read everything and also tested some pieces of code with your own hardware, and I'm sure you are now able to imagine your future and advanced projects with Arduino.</p><p>I wanted to thank you for being so focused and interested. I know you are now almost in the same boat as myself, you want to learn more, test more, and check and use new technologies in order to achieve your craziest project. I'd like to say one last thing: do it, and do it now!</p><p>In most cases, people are afraid of the huge amount of work that they can imagine in the first steps just before they start. But you have to trust me, don't think too much about details or about optimization. Try to make something simple, something that works. Then you'll have ways to optimize and improve it.</p><p>One last piece of advice for you: don't think too much, and make a lot. I have seen too many unfinished projects by people having wanted to think, think, think instead of just starting and making.</p><p>Take care and continue exploring!</p></div></body></html>