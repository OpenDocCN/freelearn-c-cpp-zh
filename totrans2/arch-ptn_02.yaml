- en: Client/Server Multi-Tier Architectural Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端/服务器多级架构模式
- en: This chapter provides a bird's eye view of client-server architectural patterns.
    It starts with the need for the evolution of two-tier client-server patterns and
    highlights how the limitations of two-tier client-server patterns led to the evolution
    of three-tier and consequently *n*-tier client-server patterns. The different
    variants of client-server patterns like the master-slave pattern, peer-to-peer
    patterns, and so on are also explained in-depth with relevant use cases. The second
    part of the chapter focuses on web application frameworks. The requirements of
    web applications are different from that of client-server applications, the key
    differentiating factor being the dynamic updates to the UI based on the changes
    in the underlying data. All the popular patterns used in web application design
    are covered in this part of the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了一个客户端-服务器架构模式的鸟瞰图。它从两层客户端-服务器模式演化的需求开始，并强调了两层客户端-服务器模式的局限性如何导致了三层以及随后的*n*层客户端-服务器模式的演化。本章还深入解释了客户端-服务器模式的不同变体，如主从模式、对等网络模式等，并提供了相关的用例。本章的第二部分专注于Web应用程序框架。Web应用程序的需求与客户端-服务器应用程序不同，关键的区别因素是基于底层数据的更改对UI的动态更新。本章的这一部分涵盖了Web应用程序设计中使用的所有流行模式。
- en: 'The major topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题如下：
- en: Two-tier, three-tier, and *n*-tier client-server patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两层、三层和*n*层客户端-服务器模式
- en: The master-slave pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主从模式
- en: The peer-to-peer pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对等网络模式
- en: The distributed client-server pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式客户端-服务器模式
- en: The model-view-controller pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-控制器模式
- en: The model-view-presenter pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-表示者模式
- en: The model-view-model pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-模型模式
- en: The front controller pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端控制器模式
- en: Some common design patterns used for web application development
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于Web应用程序开发的常见设计模式
- en: 'The client-server pattern is one of the oldest architectural patterns. In simple
    terms, how do we describe a client and a server? It is described as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器模式是其中最古老的架构模式之一。简单来说，我们如何描述客户端和服务器？它被描述如下：
- en: '**Client**: This is the component that is a requestor of a service and sends
    requests for various types of services to the server'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**: 这是请求服务的组件，向服务器发送各种类型服务的请求'
- en: '**Server**: This is the component that is a service provider and continuously
    provides services to the client as per the requests placed by it'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**: 这是提供服务的组件，根据客户端提出的请求，持续不断地向客户端提供服务'
- en: Clients and servers typically comprise of distributed systems, which communicate
    over a network.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器通常由分布式系统组成，它们通过网络进行通信。
- en: 'The following diagram is a simple graphic depicting the client-server architecture:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图是一个简单的图形，描述了客户端-服务器架构：
- en: '![](img/3940b149-f6fb-413e-a076-367eb80b8c8d.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3940b149-f6fb-413e-a076-367eb80b8c8d.png)'
- en: 'There is no upper bound on the number of clients that can be serviced by a
    single server. It is also not mandatory that the client and server should reside
    in separate systems. Both client and server can reside in the same system based
    on the hardware configuration of the system and the type of functionality or service
    provided by the server. The communication between client and server happens by
    exchange of messages using a request-response pattern. The client basically sends
    a request for a service and server returns a response. This request-response pattern
    of communication which happens between a client and a server is a very good example
    of inter-process communication. For this communication to happen efficiently,
    it is necessary to have a well-defined communication protocol which lays down
    the rules of communication such as the format of request messages, response messages,
    error handling, and so on. All communication protocols that are used for client-server
    communication work in the application layer of the protocol stack. To further
    streamline the process of client-server communication, the server sometimes implements
    specific **application programming interfaces** (**APIs**) which could be used
    by the client to access any specific service from the server. This client-server
    pattern depicted in the graphic has two tiers: the client tier and the server
    tier, and hence it is also called the **two-tier client-server pattern**.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单个服务器可以服务的客户端数量没有上限。客户端和服务器是否位于不同的系统中也不是强制性的要求。根据系统的硬件配置和服务器提供的功能或服务类型，客户端和服务器可以位于同一系统中。客户端和服务器之间的通信是通过使用请求-响应模式交换消息来实现的。客户端基本上发送一个服务请求，服务器返回一个响应。客户端和服务器之间发生的这种请求-响应通信模式是进程间通信的一个很好的例子。为了使这种通信高效进行，有必要有一个定义良好的通信协议，该协议规定了通信规则，例如请求消息的格式、响应消息、错误处理等。所有用于客户端-服务器通信的通信协议都在协议栈的应用层工作。为了进一步简化客户端-服务器通信的过程，服务器有时会实现特定的**应用程序编程接口**（**API**），这些接口可以被客户端用来访问服务器上的任何特定服务。图中所示的这个客户端-服务器模式有两个层次：客户端层和服务器层，因此它也被称为**两层客户端-服务器模式**。
- en: The term "service" used in the context of client-server architecture refers
    to the abstraction of a resource. The resource could be of any type, and the server
    is named based on the resource that is provided by the server (service). For example,
    if the server provides web pages, it is called a **web server** and if the server
    provides files, it is called a **file server**, and so on. A server can receive
    requests from *n* number of clients at a specific point in time. But any server
    will have its own limitations about its processing capabilities. So, many times,
    it becomes necessary for a server to prioritize the incoming requests and service
    them as per their priority. The scheduling system present in the server helps
    the server with the assignment of priorities. The common applications of client-server
    patterns for different use cases are as follows.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端-服务器架构的上下文中，“服务”这个术语指的是资源的抽象。资源可以是任何类型，服务器根据服务器提供的资源（服务）来命名。例如，如果服务器提供网页，它被称为**网页服务器**；如果服务器提供文件，它被称为**文件服务器**，等等。服务器可以在特定时间点接收来自*n*个客户端的请求。但任何服务器都会有其处理能力的限制。因此，很多时候，服务器需要优先处理传入的请求，并根据其优先级提供服务。服务器中存在的调度系统帮助服务器分配优先级。针对不同用例的客户端-服务器模式的常见应用如下。
- en: '**Email server** and **email client**: An email server provides emails as per
    the request received from the email client. Some commonly used enterprise email
    solutions are Microsoft Exchange from Microsoft, Lotus notes from IBM, Gmail from
    Google, and so on. Working on an email system is described as follows.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**邮件服务器**和**邮件客户端**：邮件服务器根据从邮件客户端收到的请求提供电子邮件。一些常用的企业级电子邮件解决方案包括来自微软的Microsoft
    Exchange、来自IBM的Lotus notes、来自谷歌的Gmail等。对电子邮件系统的工作描述如下。'
- en: A mail server which is also known as an email server is the server that processes
    and delivers emails over the network, which is typically internet. A mail server
    is also equipped to receive emails from client computers and deliver them to other
    mail servers that are present in the network. An email client is a system in which
    the emails are read. It could be a desktop, laptop or a smartphone which can support
    emails.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件服务器，也称为电子邮件服务器，是处理和通过网络（通常是互联网）传递电子邮件的服务器。邮件服务器还配备了从客户端计算机接收电子邮件并将其传递到网络中其他邮件服务器的功能。电子邮件客户端是一个读取电子邮件的系统。它可以是台式机、笔记本电脑或支持电子邮件的智能手机。
- en: 'The working of an email system is depicted in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了电子邮件系统的工作原理：
- en: '![](img/011a8490-7939-42cd-a536-e4bf51a87ae5.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/011a8490-7939-42cd-a536-e4bf51a87ae5.png)'
- en: When an email is sent from a client, the email software which is present in
    the client system will connect to a server which is present in the network called
    the **simple mail transfer protocol** (**SMTP**) server. SMTP refers to a protocol
    which is used to deliver emails from clients to servers and from one server to
    another.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当从客户端发送电子邮件时，客户端系统中的电子邮件软件将连接到网络中的服务器，该服务器被称为**简单邮件传输协议**（**SMTP**）服务器。SMTP指的是用于将电子邮件从客户端发送到服务器以及从一台服务器发送到另一台服务器的协议。
- en: When emails are downloaded using the email software present on your client machine,
    the email software will connect to another server, which performs a function called
    a **p****ost office protocol version3** (**POP3**) server. POP3 server uses a
    POP3 protocol. This protocol works like a mail delivery system used in a post
    office and hence the name. A detailed discussion of these protocols is beyond
    the scope of this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用客户端机器上现有的电子邮件软件下载电子邮件时，电子邮件软件将连接到另一个服务器，该服务器执行一个称为**邮局协议版本3**（**POP3**）服务器的功能。POP3服务器使用POP3协议。该协议的工作方式类似于邮局中使用的邮件投递系统，因此得名。这些协议的详细讨论超出了本章的范围。
- en: Domain name service (DNS) server and DNS client
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 域名服务（DNS）服务器和DNS客户端
- en: 'DNS is one of the most important services that is present on the internet.
    An internet has thousands of devices that are a part of it and each of these devices
    is referred to as a host. Each host could be a printer, router, computer, or any
    other device. Each host has a unique IP address associated with it. Apart from
    the IP address, each host also has a unique hostname associated with it. For example,
    if the hostname is `LP471` and it is present in a domain `technest.com`, then
    the **fully qualified domain name** (**FQDN**) of the host is `LP471.technest.com`.
    The FQDN is used to identify the host uniquely within the DNS namespace. The DNS
    namespace contains some commonly used name suffixes; they are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: DNS是互联网上最重要的服务之一。互联网上有成千上万的设备都是其一部分，每个设备都被称为主机。每个主机都有一个与其关联的唯一IP地址。除了IP地址之外，每个主机还有一个与其关联的唯一主机名。例如，如果主机名为`LP471`并且位于域名`technest.com`中，那么该主机的**完全限定域名**（**FQDN**）就是`LP471.technest.com`。FQDN用于在DNS命名空间内唯一标识主机。DNS命名空间包含一些常用的名称后缀；它们如下所示：
- en: '`.com`: Commercial organizations'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.com`: 商业组织'
- en: '`.edu`: Educational institutions'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.edu`: 教育机构'
- en: '`.gov`: Government organizations'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.gov`: 政府组织'
- en: '`.org`: Non-profit bodies like IEEE'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.org`: 如IEEE等非营利组织'
- en: '`.net`: Networking organizations'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.net`: 网络组织'
- en: Apart from these commonly used name suffixes, there are several others, too.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些常用的名称后缀之外，还有其他几个。
- en: The workings of a DNS
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS的工作原理
- en: 'A DNS works using the concept of distributed databases based on the client-server
    model. DNS clients are entities that require a name resolution (mapping of host
    names to IP addresses). DNS servers maintain the data that is required for name
    resolution. The high-level schematic of a DNS client-server architecture is given
    in the following diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: DNS使用基于客户端-服务器模型的分布式数据库概念来工作。DNS客户端是需要进行域名解析（将主机名映射到IP地址）的实体。DNS服务器维护用于域名解析所需的数据。以下图示给出了DNS客户端-服务器架构的高级示意图：
- en: '![](img/bc263f97-ec1e-475c-8a4a-491e3b007bc0.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc263f97-ec1e-475c-8a4a-491e3b007bc0.png)'
- en: Suppose the URL `www.xyzworks.com` is typed into the browser of the DNS client.
    The browser gets connected to a DNS server to get the equivalent IP address. The
    DNS server performs this task by first connecting to one of the root DNS servers.
    The root servers will store the IP addresses of all DNS servers that handle top-level
    domains such as `.edu`, `.com`, and so on. In this example, the root server after
    getting the IP address of the top-level domain `.com`, sends it a query asking
    for the IP address of `www.xyzworks.com`. The DNS server that handles the `.com`
    domain will respond with the IP addresses of the name servers that handle the
    `www.xyzworks.com` domain.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设将 URL `www.xyzworks.com` 输入 DNS 客户端的浏览器中。浏览器会连接到 DNS 服务器以获取相应的 IP 地址。DNS 服务器通过首先连接到一个根
    DNS 服务器来执行此任务。根服务器将存储处理顶级域名（如 `.edu`、`.com` 等）的所有 DNS 服务器的 IP 地址。在这个例子中，根服务器在获取顶级域名
    `.com` 的 IP 地址后，向其发送一个查询请求，询问 `www.xyzworks.com` 的 IP 地址。处理 `.com` 域的 DNS 服务器将响应，提供处理
    `www.xyzworks.com` 域的名称服务器的 IP 地址。
- en: The name server then sends the query to the `www.xyzworks.com` DNS server. This
    DNS server responds with the entire IP address to the name server, which in turn
    sends it back to the DNS client which had initiated the DNS request. The DNS client
    machine can then use the IP address to access the required web page.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 名称服务器然后将查询发送到 `www.xyzworks.com` DNS 服务器。该 DNS 服务器向名称服务器响应整个 IP 地址，名称服务器再将它发送回发起
    DNS 请求的 DNS 客户端。DNS 客户端机器可以使用该 IP 地址访问所需的网页。
- en: 'The salient aspects of this client-server architecture are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种客户端-服务器架构的显著特点如下：
- en: '**Redundancy**: There are multiple DNS servers at each level so that even if
    one fails, the other server can take its role.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冗余**：每个级别都有多个 DNS 服务器，这样即使一个服务器失败，另一个服务器可以接替其角色。'
- en: '**Caching**: Once a DNS request is resolved, the DNS server caches the IP address
    received by it. For example, where the IP address of the `.com` domain server
    is cached by the DNS server so that any subsequent requests for a `.com` domain
    can be handled by it without initiating repetitive DNS query mechanisms.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：一旦 DNS 请求被解决，DNS 服务器会缓存它收到的 IP 地址。例如，DNS 服务器缓存 `.com` 域服务器的 IP 地址，以便任何后续对
    `.com` 域的请求都可以由它处理，而无需启动重复的 DNS 查询机制。'
- en: Functional requirements in two-tier client-server patterns
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两层客户端-服务器模式中的功能需求
- en: 'The key functional requirements in two-tier client-server patterns are classified
    in the following table:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在两层客户端-服务器模式中，关键的功能需求被分类如下表：
- en: '| **Functional requirement** | **Description** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **功能需求** | **描述** |'
- en: '| Presentation services | Provides user interface and dialog control |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 展示服务 | 提供用户界面和对话框控制 |'
- en: '| Presentation logic | User interaction and validation of inputs |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 展示逻辑 | 用户交互和输入验证 |'
- en: '| Business logic | Set of business rules that specify how data can be stored,
    created, and changed |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 商业逻辑 | 指定数据如何存储、创建和更改的一组商业规则 |'
- en: '| Distribution service | Management of communication |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 分发服务 | 通信管理 |'
- en: '| Database logic | Data operations and manage integrity of data |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 数据库逻辑 | 数据操作和管理数据完整性 |'
- en: '| Database services | Management of various attributes of a database transaction
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 数据库服务 | 管理数据库事务的各种属性 |'
- en: '| File services | Operations on files and sharing of files |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 文件服务 | 文件操作和文件共享 |'
- en: Distribution of functional requirements in a client-server pattern
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端-服务器模式中功能需求的分配
- en: 'Clients are broadly classified into the following two major categories:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端被广泛分为以下两大类：
- en: '**Fat client**: Most of the functional services are performed by the client
    component. One classic example of a fat client is a file server.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**胖客户端**：大部分功能服务由客户端组件执行。一个经典的胖客户端例子是文件服务器。'
- en: '**Thin client**: If it is a thin client, it relies on the server component
    for most of its computational capability.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瘦客户端**：如果是瘦客户端，它依赖于服务器组件来提供大部分的计算能力。'
- en: The choice of the client is made based on the type of client-server pattern,
    which is planned and implemented in a system. For example, if the pattern involves
    a lot of functionality to be done on the client side, then the choice of client
    is typically fat client, and vice versa. The functional requirements that are
    discussed in this section will give a better idea regarding the choice of client
    and server systems for implementing specific client-server patterns.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的选择基于客户端-服务器模式类型，该模式是在系统中计划并实现的。例如，如果该模式涉及大量需要在客户端完成的功能，那么客户端的选择通常是胖客户端，反之亦然。本节讨论的功能需求将更好地说明选择客户端和服务器系统以实现特定客户端-服务器模式。
- en: 'There are various ways in which functional requirements can be implemented
    in a client-server pattern. The following are some of the prominent ways of implementing
    client-server patterns:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端-服务器模式中，有多种方式可以实现功能需求。以下是一些实现客户端-服务器模式的主要方式：
- en: The remote data access client-server pattern
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程数据访问客户端-服务器模式
- en: The remote presentation client-server pattern
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程表示客户端-服务器模式
- en: The split logic data client-server architecture pattern
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离逻辑数据客户端-服务器架构模式
- en: The remote data access client-server pattern
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程数据访问客户端-服务器模式
- en: In the remote data access client-server pattern, the application resides on
    the client component, whereas the data management is done by the server component.
    The server that performs data management is typically referred to as **database
    management server** (**DBMS**) or data server. Most of the **relational database
    management system** (**RDBMS**) products available in the market are implemented
    using this pattern. These RDBMS products typically provide a layer or component
    of software at the client side, which handles communication with the data server.
    This component of the software is called **data manipulation language** (**DML**).
    Client systems support the presentation and business logic and interact with the
    data server using DML. These patterns typically involve the usage of fat clients
    as a significant amount of processing is done by the client systems as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程数据访问客户端-服务器模式中，应用程序位于客户端组件上，而数据管理则由服务器组件完成。执行数据管理的服务器通常被称为**数据库管理系统**（DBMS）或数据服务器。市场上大多数**关系型数据库管理系统**（RDBMS）产品都是使用这种模式实现的。这些RDBMS产品通常在客户端提供一层或组件的软件，该软件负责与数据服务器进行通信。这个软件组件被称为**数据操纵语言**（DML）。客户端系统支持表示层和业务逻辑，并使用DML与数据服务器进行交互。这些模式通常涉及使用胖客户端，因为客户端系统也执行大量的处理。
- en: 'The implementation of functional requirements in a remote data access client-server
    architecture is depicted in the following diagram:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中展示了在远程数据访问客户端-服务器架构中实现功能需求：
- en: '![](img/366ad14d-5f99-422b-9ea0-c1588f5648a5.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/366ad14d-5f99-422b-9ea0-c1588f5648a5.png)'
- en: The remote presentation client-server pattern
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程表示客户端-服务器模式
- en: 'In the remote presentation client-server pattern, the **graphical user interface**
    (**GUI**) frontend is mapped to an existing application''s text-based screen.
    This process is called Remote mapping or Front ending. The typical mode of operation
    of this pattern involves the use of intelligent workstations, which are equipped
    with the capability to intercept the text screen streams of data that are sent
    from a server system, and display them in a windowed system using a GUI. However,
    in these systems, most of the processing and computation happens on the server
    end only. One ideal example of this implementation is IBM''s 3270 (mainframe)
    application. In this application, data from the application is sent to 3270''s
    screen program on the mainframe to be displayed. The data is then sent to the
    client workstation in the form of a 3270-data stream. The client workstation receives
    the data, interprets it, and converts it to a graphical form to be displayed in
    a window. If the user enters any data through the client workstation in the GUI
    window, the front ware application that runs in the client workstation converts
    the data into a 3270-compatible format and sends it back to the server for the
    next course of action. The split of functions in a remote **presentation** client-server
    pattern is depicted in the following diagram:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程表示客户端-服务器模式中，**图形用户界面**（**GUI**）前端映射到现有应用程序的基于文本的屏幕。这个过程被称为远程映射或前端处理。这种模式的典型操作模式涉及使用智能工作站，这些工作站具备拦截从服务器系统发送的文本屏幕数据流的能力，并使用GUI在窗口系统中显示它们。然而，在这些系统中，大多数处理和计算仅在服务器端进行。这种实现的理想例子是IBM的3270（主机）应用程序。在这个应用程序中，应用程序数据被发送到主机上的3270屏幕程序以进行显示。然后，数据以3270数据流的形式发送到客户端工作站。客户端工作站接收数据，对其进行解释，并将其转换为图形形式以在窗口中显示。如果用户通过客户端工作站的GUI窗口输入任何数据，运行在客户端工作站上的前端应用程序将数据转换为3270兼容格式并发送回服务器以进行下一步操作。远程表示客户端-服务器模式中功能分离的图示如下：
- en: '![](img/1d71d464-1cfb-4d6c-bfe2-55d3e9ab7216.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d71d464-1cfb-4d6c-bfe2-55d3e9ab7216.png)'
- en: The split logic data client-server architecture pattern
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离逻辑数据客户端-服务器架构模式
- en: 'In the split logic data client-server architecture pattern, the application
    functionality is split into two parts: one will be implemented on the client side
    and the other one will be implemented on the server side. This pattern is very
    complex when compared to the other two patterns because both client and server
    need separately compiled application programs for their functioning. Before implementing
    this pattern, it is very important for developers to identify the functions to
    be implemented on the client and the server side and list out the type of communication
    dialogs that must happen between the application programs running on the client
    and the server side.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在分离逻辑数据客户端-服务器架构模式中，应用程序功能被分为两部分：一部分将在客户端实现，另一部分将在服务器端实现。与另外两种模式相比，这种模式非常复杂，因为客户端和服务器都需要为它们的运行分别编译应用程序程序。在实现此模式之前，开发者识别要在客户端和服务器端实现的功能，并列出应用程序程序在客户端和服务器端之间必须发生的通信对话类型非常重要。
- en: The three-tier pattern / multi-tier pattern client-server
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三层模式/多层模式客户端-服务器
- en: 'The following diagram represents a client-server interaction:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了客户端-服务器交互：
- en: '![](img/91118019-e466-4904-8460-5ab1afb9e7f1.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91118019-e466-4904-8460-5ab1afb9e7f1.png)'
- en: 'We will discuss some of the variants of client-server patterns in this section.
    Some of the prominent variants of client-server patterns are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些客户端-服务器模式的变体。客户端-服务器模式的一些显著变体如下：
- en: The master-slave pattern
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主从模式
- en: The peer-to-peer pattern
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对等模式
- en: Let's discuss them in detail.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论它们。
- en: The master-slave pattern
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主从模式
- en: The master-slave pattern is applied for designing a system if the system involves
    similar or identical computations that need to be performed repeatedly with separate
    set of inputs and context. The master-slave pattern offers support for fault tolerance
    and parallel computation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统涉及需要重复执行且具有不同输入和上下文的相似或相同计算，则应用主从模式进行系统设计。主从模式提供了容错和并行计算的支持。
- en: 'The master-slave pattern is depicted in the following diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 主从模式在以下图中展示：
- en: '![](img/b35851ef-fe49-498a-8de9-a79828a7074a.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b35851ef-fe49-498a-8de9-a79828a7074a.png)'
- en: 'The master component distributes the work among all the slave components and
    calculates the ﬁnal result by summing up the results that are returned by each
    slave. The master-slave pattern is used for architecting embedded systems and
    used in the design of systems that perform massive parallel computations. The
    following is a sequence diagram of the master-slave pattern:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 主组件将工作分配给所有奴隶组件，并通过将每个奴隶返回的结果相加来计算最终结果。主从模式用于架构嵌入式系统，并用于设计执行大规模并行计算的系统。以下是主从模式的序列图：
- en: '![](img/0241228f-d7e6-45e6-88d7-7547afa99ea7.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0241228f-d7e6-45e6-88d7-7547afa99ea7.png)'
- en: Issues in the master-slave pattern
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主从模式的问题
- en: The master-slave pattern works based on the divide and conquer principle. In
    the working of this pattern, the coordination concept is separated from the actual
    work as all the slaves work in parallel. Hence, the slaves have not shared state
    and they work in isolation. Another issue in the master slave pattern is its latency.
    This could cause an issue in systems where the response time is very critical,
    for example, real-time systems. Moreover, this pattern can be applied to a specific
    problem only if it is decomposable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 主从模式基于分而治之的原则。在这个模式的工作中，协调概念与实际工作分离，因为所有奴隶都并行工作。因此，奴隶没有共享状态，并且它们独立工作。主从模式中的另一个问题是其延迟。这可能在响应时间非常关键的系统中引起问题，例如实时系统。此外，只有当问题可分解时，此模式才能应用于特定问题。
- en: One of the ways of implementing the master-slave pattern is through a single
    master thread, which creates multiple slave threads. Each of the slave threads
    performs a variant of the required computation and returns the result to the master.
    Once the computation is complete, the master thread accumulates the results and
    terminates the slave threads.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实现主从模式的一种方法是通过单个主线程，该线程创建多个奴隶线程。每个奴隶线程执行所需计算的变体，并将结果返回给主线程。一旦计算完成，主线程累积结果并终止奴隶线程。
- en: Client-queue-client patternsThis is also called passive queue architecture.
    This is a variant of the client-server architecture in which all components, including
    servers, are treated only as client systems. This is because servers were treated
    as passive queues by the clients which are present in the system and are used
    by the clients for transferring messages to other clients present in the network.
    This architecture could be treated as one of the early evolutions of peer-to-peer
    architecture, which is discussed in the next section and is obsolete today.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-队列-客户端模式这也可以称为被动队列架构。这是一种客户端-服务器架构的变体，其中所有组件，包括服务器，都仅被视为客户端系统。这是因为服务器被系统中的客户端视为被动队列，客户端使用它将消息传输到网络中其他客户端。这种架构可以被视为对等网络架构的早期演变之一，这在下一节中讨论，并且现在已过时。
- en: Peer-to-peer patterns
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对等模式
- en: Peer-to-peer architectural patterns belong to the category of symmetric client-server
    patterns. Symmetric in this context refers to the fact that there is no need for
    a strict division in terms of client, server, and so on in the network of systems.
    In a peer-to-peer pattern, a single system acts as both client and server. Each
    system, also called a peer, sends requests to other peers in the network and at
    the same time receives and services requests from other peers, which are part
    of the network. This is a great difference when compared to a traditional client
    server network where a client must only send a request and wait for the server
    to process.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对等架构模式属于对称客户端-服务器模式的范畴。在这里，“对称”指的是在系统网络中不需要对客户端、服务器等进行严格划分。在对等模式中，单个系统既充当客户端也充当服务器。每个系统，也称为对等点，向网络中的其他对等点发送请求，并同时接收并处理来自网络中其他对等点的请求。这与传统客户端-服务器网络有很大的不同，在传统客户端-服务器网络中，客户端必须仅发送请求并等待服务器处理。
- en: 'In general, this pattern is typically used to implement a decentralized network
    of systems using distributed resources that are expected to perform specific function.
    The distributed resources could be either processing power, data, or bandwidth
    which may be used for any distributed computing task like Sharing of content,
    communication, and so on. The generic architecture of a peer-to-peer pattern is
    depicted in the following diagrams (however, some variations are possible, which
    we will discuss later):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，这种模式被用来实现一个使用分布式资源的去中心化系统网络，这些资源被期望执行特定的功能。分布式资源可以是处理能力、数据或带宽，这些资源可以用于任何分布式计算任务，如内容共享、通信等。对等网络模式的通用架构在以下图中展示（然而，可能存在一些变体，我们将在后面讨论）：
- en: '![](img/2f9b2560-2563-417c-b238-5ca1ee4e0691.png)![](img/083a5194-ccea-4ed6-b9a0-5f1d8c8c1f88.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f9b2560-2563-417c-b238-5ca1ee4e0691.png)![图片](img/083a5194-ccea-4ed6-b9a0-5f1d8c8c1f88.png)'
- en: 'Peer-to-peer patterns are basically implemented in two ways:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对等网络模式基本上有两种实现方式：
- en: A pure peer-to-peer pattern
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯对等网络模式
- en: A hybrid peer-to-peer pattern
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合对等网络模式
- en: In a pure peer-to-peer pattern, all the systems that are part of the network
    are peers and they act as both client and server. There is no dependency on a
    centralized server for managing the various operations. The main advantage of
    this architecture is its fault tolerance. Another advantage is the simplicity
    and ease of implementation as this architecture moves away from the concept of
    centralization. The downside of the architecture is that the network bandwidth
    gets overused due to flooding of requests from all the peers that are part of
    the network. Gnutella, a popular file sharing protocol, is implemented using the
    pure peer-to-peer pattern. The preceding diagram is an example of a pure peer-to-peer
    pattern.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯对等网络模式中，网络中的所有系统都是对等节点，它们既充当客户端也充当服务器。没有对集中式服务器进行各种操作管理的依赖。这种架构的主要优势是其容错性。另一个优势是简单易实现，因为这种架构远离了集中化的概念。这种架构的缺点是由于网络中的所有对等节点请求的洪泛，导致网络带宽过度使用。Gnutella，一个流行的文件共享协议，就是使用纯对等网络模式实现的。前面的图示是一个纯对等网络模式的例子。
- en: 'In the hybrid peer-to-peer pattern, there exists a central server to perform
    certain administrative tasks that are required for the smooth functioning of P2P
    services. This can be better explained with the help of a simple example. Napster,
    a file sharing protocol is designed based on hybrid peer-to-peer pattern. In Napster,
    there is a server whose main functionality is to help peer systems which are part
    of the network search for files. Transfer of files between the systems are then
    initiated based on the search results which are returned by the server. In other
    words, only the catalogue of files is maintained in the server whereas the actual
    files which are present in the catalogue are scattered across all the peer systems
    which are part of the network. This pattern is less fault tolerant when compared
    to the pure peer-to-peer pattern because of the dependency on centralized server
    component. However, the main benefit of this pattern is that there is no unnecessary
    consumption of network resources and this architecture is highly scalable. The
    hybrid peer-to-peer pattern is depicted in the following diagram:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在混合对等网络模式中，存在一个中央服务器来执行某些必要的行政任务，以确保P2P服务的顺畅运行。这可以通过一个简单的例子来更好地解释。Napster，一个文件共享协议，就是基于混合对等网络模式设计的。在Napster中，有一个服务器，其主要功能是帮助网络中的对等系统查找文件。文件之间的传输是基于服务器返回的搜索结果来启动的。换句话说，只有文件目录存储在服务器上，而目录中实际存在的文件则分散在网络的各个对等系统中。与纯对等网络模式相比，这种模式由于依赖于集中式服务器组件，其容错性较低。然而，这种模式的主要好处是没有不必要的网络资源消耗，并且这种架构具有高度的扩展性。混合对等网络模式在以下图中展示：
- en: '![](img/083a5194-ccea-4ed6-b9a0-5f1d8c8c1f88.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/083a5194-ccea-4ed6-b9a0-5f1d8c8c1f88.png)'
- en: Though peer-to-peer patterns are very effective for applications like file sharing,
    they also provide options for a lot of security threats and malicious code to
    enter the network and get propagated to other peer systems which are part of the
    network. Hence, the TCP ports which are used by peer-to-peer application should
    be constantly monitored and kept under the surveillance of **intrusion detection
    systems** / **intrusion prevention systems**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对等模式对于文件共享等应用程序非常有效，但它们也提供了许多安全威胁和恶意代码进入网络并传播到网络中其他对等系统的选项。因此，对等应用程序使用的TCP端口应始终受到监控，并置于**入侵检测系统**/**入侵预防系统**的监督之下。
- en: Advantages of two-tier client-server patterns
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双层客户端-服务器模式的优势
- en: 'Some of the key advantages of client server systems are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器系统的一些关键优势如下：
- en: '**Security**: Data is stored centrally in the server. This offers greater control
    over the server and offers higher level of security than protecting the data that
    will be spread across a large number of client machines, which may involve offering
    special security mechanisms for each client machine.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：数据存储在服务器上。这提供了对服务器的更大控制，并且比保护散布在大量客户端机器上的数据提供更高的安全性，这可能涉及为每个客户端机器提供特殊的保护机制。'
- en: '**Centralized access to data**: As most of the data is stored centrally in
    the server, it is much easier to do updates on the data. This is one of the simplest
    architectural styles.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中访问数据**：由于大部分数据都存储在服务器上，因此对数据进行更新要容易得多。这是一种最简单的架构风格之一。'
- en: '**Ease of maintenance**: In this architectural pattern, the client is unaware
    of details of the server and hence server maintenance activities like repair,
    upgrade, and so on do not affect the functioning of the client.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于维护**：在这个架构模式中，客户端不知道服务器的详细信息，因此服务器维护活动（如修复、升级等）不会影响客户端的功能。'
- en: Design considerations - when to use a two-tier client-server pattern?
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计考虑因素 - 何时使用双层客户端-服务器模式？
- en: 'Having read so much about the two-tier client-server pattern, the next question
    which arises in our mind is when to use two-tier client server pattern for a specific
    architectural design. The following points could be used as a guideline to decide
    that:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了大量关于双层客户端-服务器模式的内容之后，我们心中产生的下一个问题是何时在特定的架构设计中使用双层客户端-服务器模式。以下要点可以作为决定该问题的指南：
- en: If the application under consideration is server based and will support numerous
    client, then the two-tier client server pattern is a good choice.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果正在考虑的应用程序是基于服务器的并且将支持众多客户端，那么双层客户端-服务器模式是一个不错的选择。
- en: Some of the applications that work well with a two-tier client server pattern
    are web applications that are accessed through a web browser or for business process
    applications that are likely to be used throughout the organization.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些与双层客户端-服务器模式配合良好的应用程序包括通过网页浏览器访问的Web应用程序，或可能在整个组织中使用的业务流程应用程序。
- en: If you are looking at centralizing data operations like storage, backup, and
    other related administration tasks, even then a two-tier client server pattern
    is an ideal choice.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使您正在考虑集中数据操作，如存储、备份和其他相关管理任务，双层客户端-服务器模式也是一个理想的选择。
- en: Limitations of two-tier client-server patterns
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双层客户端-服务器模式的局限性
- en: 'The following are some of the main limitations of client-server patterns:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些客户端-服务器模式的主要局限性：
- en: '**Limited extensibility, scalability, and reliability**: In most of the implementations,
    application data and business logic reside on the same central server. This aspect
    impacts the system extensibility, scalability, and reliability.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限的扩展性、可伸缩性和可靠性**：在大多数实现中，应用程序数据和业务逻辑都驻留在同一个中央服务器上。这一方面影响了系统的扩展性、可伸缩性和可靠性。'
- en: '**Excessive network bandwidth usage:** communication between and the client
    and the server consumes excessive bandwidth. Request and response data often need
    to be converted to a common format as they might have a different format of representation
    on the client side and the server side. This aspect also contributes to additional
    traffic.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度使用网络带宽**：客户端和服务器之间的通信消耗了过多的带宽。请求和响应数据通常需要转换为通用格式，因为它们在客户端和服务器端可能有不同的表示格式。这一方面也导致了额外的流量。'
- en: To overcome these limitations of the two-tier client server pattern, three-tier/multi-tier
    client-server architecture was developed. Most of the applications of the present
    day, which are developed using the client-server architecture, are based on the
    three-tire/multi-tier architectural model, which is discussed in the next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服两层客户端-服务器模式的这些限制，开发了三层/多层客户端-服务器架构。当今大多数使用客户端-服务器架构开发的应用程序，其基础都是三层/多层架构模型，这在下一节中讨论。
- en: Because of the slight difference in their architecture, three-tier and multi-tiered
    architectures are handled as separate topics in this chapter, though they may
    be referred to interchangeably in many other forums.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们架构上的细微差异，本章将三层架构和多层架构作为单独的主题处理，尽管在许多其他论坛中它们可能被交替使用。
- en: Three-tier client-server architecture
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三层客户端-服务器架构
- en: 'The three tiers that are present in this architecture are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该架构中存在的三层如下：
- en: The presentation tier
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示层
- en: The application or business logic tier
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用或业务逻辑层
- en: Data tier
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据层
- en: 'The diagram depicting the three-tier client-server architecture is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 描述三层客户端-服务器架构的图示如下：
- en: '![](img/43ab3182-df6d-4495-8ce0-c2705abf261f.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43ab3182-df6d-4495-8ce0-c2705abf261f.png)'
- en: 'In a three-tier architecture, the different layers are developed and maintained
    as different modules, sometimes on different platforms as well. The following
    are the functions of each layer:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在三层架构中，不同的层作为不同的模块开发和维护，有时甚至在不同的平台上。以下各层的功能如下：
- en: '**Presentation tier**: This is the first and topmost layer which is present
    in the application. This tier provides presentation services, that is presentation,
    of content to the end user through GUI. This tier can be accessed through any
    type of client device like desktop, laptop, tablet, mobile, thin client, and so
    on. For the content to the displayed to the user, the relevant web pages should
    be fetched by the web browser or other presentation component which is running
    in the client device. To present the content, it is essential for this tier to
    interact with the other tiers that are present preceding it.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：这是应用程序中存在的第一层和最顶层。这一层提供表示服务，即通过图形用户界面向最终用户展示内容。这一层可以通过任何类型的客户端设备访问，如桌面、笔记本电脑、平板电脑、手机、瘦客户端等。为了向用户展示内容，相关的网页应由运行在客户端设备上的网络浏览器或其他表示组件获取。为了展示内容，这一层必须与它之前存在的其他层进行交互。'
- en: '**Application tier**: This is the middle tier of this architecture. This is
    the tier in which the business logic of the application runs. Business logic is
    the set of rules that are required for running the application as per the guidelines
    laid down by the organization. The components of this tier typically run on one
    or more application servers.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：这是该架构的中间层。这是应用程序业务逻辑运行的那一层。业务逻辑是组织制定的指导方针下运行应用程序所需的规则集。这一层的组件通常运行在一个或多个应用服务器上。'
- en: '**Data tier**: This is the lowest tier of this architecture and is mainly concerned
    with the storage and retrieval of application data. The application data is typically
    stored in a database server, file server, or any other device or media that supports
    data access logic and provides the necessary steps to ensure that only the data
    is exposed without providing any access to the data storage and retrieval mechanisms.
    This is done by the data tier by providing an API to the application tier. The
    provision of this API ensures complete transparency to the data operations which
    are done in this tier without affecting the application tier. For example, updates
    or upgrades to the systems in this tier do not affect the application tier of
    this architecture.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据层**：这是该架构中的最低层，主要涉及应用程序数据的存储和检索。应用程序数据通常存储在数据库服务器、文件服务器或任何其他支持数据访问逻辑并提供必要步骤以确保仅暴露数据而不提供对数据存储和检索机制的访问的设备或媒体中。这是通过数据层通过向应用层提供API来实现的。提供此API确保了在此层进行的所有数据操作对应用层完全透明，而不会影响应用层。例如，此层中系统的更新或升级不会影响该架构的应用层。'
- en: 'Benefits of the three-tier architecture are as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 三层架构的好处如下：
- en: '**Scalability** and **flexibility**: The major advantage of this architecture
    is its scalability and flexibility. Each tier of this architecture is a modular
    component, that is, any kind of operations like changes or upgrades done to one
    tier does not affect or cause downtime to the other tiers. Less functionality
    performed by the client and no high-end configuration is required for client systems
    which are present in the presentation tier.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性和灵活性**：这种架构的主要优势是其可扩展性和灵活性。该架构的每一层都是一个模块化组件，也就是说，对某一层进行的任何操作，如更改或升级，都不会影响或导致其他层的中断或停机。客户端执行的功能较少，并且不需要高端配置，对于存在于表示层的客户端系统。'
- en: '**Increased security**: Splitting of tasks among the various tiers provides
    increased security to each tier.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强安全性**：将任务分配给各个层级可以提高每个层级的安全性。'
- en: Though three-tier architectural patterns offer several benefits, there are still
    limits on the scalability of the architecture when it comes to networks like internet
    which require massive scalability.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然三层架构模式提供了许多好处，但当涉及到需要大规模可扩展性的网络，如互联网时，该架构的可扩展性仍然有限。
- en: Design considerations for using three-tier architecture
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用三层架构的设计考虑因素
- en: 'The following are some of the scenarios in which the three-tier architecture
    is a good choice:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些三层架构是不错的选择的场景：
- en: If you are developing an application with limited functionality/configuration
    for client systems. In this case, other components of the architecture like business
    logic and data logic can be distributed to other tiers.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在开发一个具有有限功能/配置的客户端系统的应用程序。在这种情况下，可以将架构的其他组件，如业务逻辑和数据逻辑，分配到其他层级。
- en: If you are in the process of developing an application to be deployed within
    an intranet where all the servers are located within a specific private network.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在开发一个将在内部网络中部署的应用程序，其中所有服务器都位于特定的私有网络中。
- en: If you are developing an internet application where there are no security constraints
    for deploying the business logic on the public networks of web or application
    servers.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在开发一个没有在Web或应用程序服务器公共网络上部署业务逻辑的安全约束的互联网应用程序。
- en: 'A variant of the three-tier architectural pattern which offers massive scalability
    is the *n*-tier architectural pattern. In an *n*-tier architectural pattern, the
    total number of tiers is *n*, where *n* has a value greater than three in order
    to differentiate it from the three-tier architectural pattern. In *n*-tier architecture,
    the application tier (which is the middle tier) is split into many tiers. The
    distribution of application code and functions among the various tiers varies
    from one architectural design to another. The diagram of the *n*-tier architectural
    pattern is depicted as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 提供大规模可扩展性的三层架构模式的变体是*n*层架构模式。在*n*层架构模式中，总层数为*n*，其中*n*的值大于三，以区别于三层架构模式。在*n*层架构中，应用层（即中间层）被分割成多个层级。应用代码和功能在各层级之间的分配因架构设计而异。*n*层架构模式的图示如下：
- en: '![](img/bce7f1a0-002c-4c49-b6bd-0ad51cd2781e.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bce7f1a0-002c-4c49-b6bd-0ad51cd2781e.png)'
- en: Design considerations for n-tier architecture
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用n层架构的设计考虑因素
- en: 'The following are some of the scenarios in which *n*-tier architecture is a
    good choice:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些*n*层架构是不错的选择的场景：
- en: If you are architecting a system in which it is possible to split the application
    logic into smaller components that could be spread across several servers. This
    could lead to the design of multiple tiers in the application tier.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在设计一个系统，可以将应用程序逻辑分割成更小的组件，这些组件可以分布在多个服务器上。这可能导致在应用层设计多个层级。
- en: If the system under consideration requires faster network communications, high
    reliability, and great performance, then *n*-tier has the capability to provide
    that as this architectural pattern is designed to reduce the overhead which is
    caused by network traffic.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果考虑的系统需要更快的网络通信、高可靠性和出色的性能，那么*n*层架构具有提供这些功能的能力，因为这种架构模式旨在减少由网络流量引起的开销。
- en: An example of n-tier architecture (shopping cart web application)
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: n层架构的示例（购物车Web应用程序）
- en: We can illustrate the working of an *n*-tier architecture with the help of an
    example of a shopping cart web application which is present in all e-commerce
    sites. The shopping cart web application is used by the e-commerce site user to
    complete the purchase of items through the e-commerce site.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过电子商务网站上普遍存在的购物车网络应用程序的例子来说明*n*层架构的工作原理。电子商务网站的用户使用购物车网络应用程序通过电子商务网站完成商品购买。
- en: 'Hence, the application should have several features which enable the user to
    do activities like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应用程序应具有一些功能，使用户能够执行以下活动：
- en: Adding selected items to the cart
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将选定的商品添加到购物车
- en: Changing the quantities of items in the cart
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变购物车中物品的数量
- en: Making payments
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行支付
- en: The client tier, which is present in the shopping cart application, interacts
    with the end user through a GUI. The client tier also interacts with the application
    that runs in the application servers present in multiple tiers. Since the shopping
    cart is a web application, the client tier contains the web browser. The presentation
    tier present in the shopping cart application displays information related to
    the services like browsing merchandise, buying them, adding them to the shopping
    cart, and so on. The presentation tier communicates with other tiers by sending
    results to the client tier and all other tiers which are present in the network.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在购物车应用程序中存在的客户端层通过图形用户界面与最终用户交互。客户端层还与运行在多个层中的应用服务器中的应用程序进行交互。由于购物车是一个网络应用程序，客户端层包含网络浏览器。购物车应用程序中存在的表示层显示与浏览商品、购买商品、将商品添加到购物车等相关服务的相关信息。表示层通过向客户端层和所有网络中存在的其他层发送结果与这些层进行通信。
- en: The presentation tier also makes calls to database stored procedures and web
    services. All these activities are done with the objective of providing a quick
    response time to the end user. The presentation tier plays a vital role by acting
    as a glue which binds the entire shopping cart application together by allowing
    the functions present in different tiers to communicate with each other and display
    the outputs to the end user through the web browser.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 表示层还调用数据库存储过程和Web服务。所有这些活动都是为了提供快速响应时间给最终用户。表示层通过充当粘合剂，允许不同层中的功能相互通信，并通过网络浏览器向最终用户显示输出，从而发挥至关重要的作用。
- en: In this *n*-tier architecture, the business logic which is required for processing
    activities like calculation of shipping cost and so on are pulled from the application
    tier to the presentation tier. The application tier also acts as the integration
    layer and allows the applications to communicate seamlessly with both the data
    tier and the presentation tier. The last tier which is the data tier is used to
    maintain data. This layer typically contains database servers. This layer maintains
    data independent from the application server and the business logic. This approach
    provides enhanced scalability and performance to the data tier.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个*n*层架构中，处理如计算运费等活动所需的企业逻辑从应用层拉到表示层。应用层还充当集成层，允许应用程序与数据层和表示层无缝通信。最后一层是数据层，用于维护数据。这一层通常包含数据库服务器。这一层独立于应用服务器和企业逻辑维护数据。这种方法为数据层提供了增强的可扩展性和性能。
- en: The distributed client-server architecture
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式客户端-服务器架构
- en: The *n*-tier client-server architecture used for the shopping cart web application,
    which is discussed in the earlier section, is an ideal example of a distributed
    client-server architecture. Distributed architectures typically have some kind
    of backend host components (such as Mainframe, Database server, and so on), an
    intelligent client in the frontend, and multiple agents in the middle, which takes
    care of all activities pertaining to transactions like transaction processing,
    security, handling messages, and so on, and a network for communication.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分讨论的购物车网络应用程序中使用的*n*层客户端-服务器架构是分布式客户端-服务器架构的理想例子。分布式架构通常有一些后端主机组件（如主机机、数据库服务器等），前端有一个智能客户端，中间有多个代理，负责处理所有与交易相关的活动，如交易处理、安全、消息处理等，以及用于通信的网络。
- en: '![](img/95677737-8b64-44ef-a5fb-4a903482fa83.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95677737-8b64-44ef-a5fb-4a903482fa83.png)'
- en: 'Some of the key concepts associated with distributed architectures are as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与分布式架构相关的关键概念如下：
- en: '**Transaction processing**: Transaction processing is the automated processing
    of transactions in order to update a shared database. A transaction processing
    application in general will have many users who are concurrently interacting with
    the system in order to process business transactions on a shared database.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务处理**：事务处理是指自动处理事务以更新共享数据库的过程。一般而言，事务处理应用程序将拥有许多用户，他们同时与系统交互，以便在共享数据库上处理业务事务。'
- en: '**Transaction processing monitor** (**TP monitor**): The main task of the TP
    monitor is to manage the flow of transactions through a client server system efficiently.
    The TP monitor also works to ensure that simultaneous transactions which are happening
    on a shared database do not cause any inconsistency to the data which is present
    in the database.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务处理监视器**（**TP 监视器**）：TP 监视器的主要任务是高效地管理通过客户端/服务器系统的事务流。TP 监视器还致力于确保在共享数据库上发生的并发事务不会对数据库中现有的数据造成任何不一致性。'
- en: 'TP monitors also provide the following functions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: TP 监视器还提供以下功能：
- en: They help in setting up back and forth connections between client and server
    components
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们帮助在客户端和服务器组件之间建立双向连接。
- en: They provide services that help in transaction-tracking, load balancing, and
    the capability to restart servers and the queues present in them automatically
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供帮助进行事务跟踪、负载均衡以及自动重启服务器及其队列中的队列的服务。
- en: Motivation for development of web application patterns
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发网络应用程序模式的动机
- en: 'Most of the web applications are highly interactive in nature. This means that
    when there is a change to the data, it should be reflected in the UI instantaneously
    without any further delay. To add on to this scenario, different users of the
    application may demand outputs in various formats like excel sheets, bar charts,
    pie charts, dashboards, and so on, as depicted in the following diagram:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络应用程序在本质上都是高度交互式的。这意味着当数据发生变化时，它应该立即在用户界面中反映出来，而不应有任何进一步的延迟。在此基础上，应用程序的不同用户可能要求以各种格式（如电子表格、条形图、饼图、仪表板等）输出结果，如下面的图所示：
- en: '![](img/c09d80af-06d8-49d7-a33d-8587bbed8bb4.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c09d80af-06d8-49d7-a33d-8587bbed8bb4.png)'
- en: 'When there is a change in the functionality of a specific application, the
    user interface of the application should also be able to reflect the changes with
    the addition of new options like menus, dropdowns, and so on. This emphasizes
    the fact that user interfaces of web applications are always subjected to series
    of change requests. These **user interfaces** (**UIs**) change requests can happen
    in various circumstances, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当特定应用程序的功能发生变化时，应用程序的用户界面也应该能够通过添加新选项（如菜单、下拉菜单等）来反映这些变化。这强调了网络应用程序的用户界面始终会受到一系列变更请求的影响。这些**用户界面**（**UIs**）变更请求可能发生在各种情况下，如下所述：
- en: A request from the end user/customer for a change in the UI feature for various
    reasons like ease of use, adaptability, and so on
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终用户/客户出于易用性、适应性等各种原因对 UI 功能变更的请求
- en: Porting of a system from one platform to another
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将系统从一个平台迁移到另一个平台
- en: Upgrades of system to new versions
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统升级到新版本
- en: Changes to database design
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库设计的变更
- en: 'From this, we can infer that user interfaces are always a target for changes.
    Different users of an application place different types of conflicting requirements
    on the user interface in order to make their operations easy. For example, an
    executive who uses a form-based interface for data entry may need more ease of
    use in the form based interface, whereas an administrator who is in charge of
    reporting may require more feature addition to the reporting interface. All this
    warrants a user interface where the design is flexible enough to accommodate all
    types of UI paradigms. It is impossible to build a system with this kind of flexibility
    if the UI is tightly tied to the functional core of the application. In such a
    scenario, it becomes necessary to develop and maintain several types of software
    applications, one for each type of user interface. The following are the main
    aspects that need to be kept in mind for the design of design patterns for web
    applications:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，我们可以推断出用户界面总是变化的目标。应用程序的不同用户对用户界面提出不同类型的冲突要求，以便使他们的操作变得容易。例如，使用基于表单的界面进行数据输入的行政人员可能需要在基于表单的界面中获得更多易用性，而负责报告的行政人员可能需要向报告界面添加更多功能。所有这些都要求有一个设计灵活的用户界面，能够容纳所有类型的UI范式。如果UI与应用程序的功能核心紧密耦合，则无法构建具有这种灵活性的系统。在这种情况下，开发和维护多种类型的软件应用程序成为必要，每种类型的用户界面都需要一个应用程序。以下是设计Web应用程序设计模式时需要考虑的主要方面：
- en: It should be possible to represent the same information in different formats
    in different windows, for example, in one window as a pie chart, in another window
    as an excel sheet, and so on
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该能够在不同的窗口中以不同的格式表示相同的信息，例如，在一个窗口中以饼图的形式，在另一个窗口中以Excel表格的形式，等等。
- en: It should be possible to change the UI easily even at runtime
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该能够在运行时轻松地更改UI。
- en: It should be possible to provide various look and feel standards and changes
    to the user interface should not imply changes to the application code
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该能够提供各种外观和感觉标准，并且用户界面的更改不应意味着应用程序代码的更改。
- en: 'All these factors are the motivation for the design of the **model view controller**
    (**MVC**) pattern, which is predominantly used for the design and development
    of mobile and web applications. The following are the main components of the MVC
    architectural pattern:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些因素都是设计**模型-视图-控制器**（MVC）模式动机，该模式主要用于移动和Web应用程序的设计和开发。以下是MVC架构模式的主要组件：
- en: '**Model**: The function of the model component of MVC is to encapsulate core
    data and functionality. The model component has the capability to function independently,
    irrespective of output representations and input behavior. In design terms, the
    model essentially represents a set of classes which are used to depict the business
    logic.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：MVC模式中模型组件的功能是封装核心数据和功能。模型组件具有独立运行的能力，不受输出表示和输入行为的影响。在设计术语中，模型本质上代表了一组用于表示业务逻辑的类。'
- en: '**View**: The function of the view component is to display information to the
    end user. The view component gets the data to be displayed from the model. A model
    can have any number of views depending on the requirements of the application.
    In design terms, the view essentially depicts the UI components such as HTML,
    jQuery, and so on.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：视图组件的功能是向最终用户显示信息。视图组件从模型获取要显示的数据。一个模型可以有任意数量的视图，具体取决于应用程序的需求。在设计术语中，视图本质上描述了UI组件，如HTML、jQuery等。'
- en: '**Controller**: Each view is associated with a controller. Controllers get
    inputs, usually in the form of events from the user. The events could be received
    in the form of mouse clicks, keystrokes from the keyboard, and so on. These event
    are converted to service requests and are passed on to the model or the view.
    The controller is the only component through which the user interacts with the
    system.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：每个视图都与一个控制器相关联。控制器获取输入，通常是用户事件的形式。这些事件可能是鼠标点击、键盘按键等。这些事件被转换为服务请求并传递给模型或视图。控制器是用户与系统交互的唯一组件。'
- en: The separation of model, view, and controller components provide flexibility
    by allowing multiple views of the same model. In case the user changes, the model
    data using the controller component of one view, all other views which use the
    same data should be updated immediately to reflect the new changes. This is taken
    care of by the model by notifying all the views whenever its data changes. The
    view in turn takes the updated data from the model and updates all relevant views.
    All these sequences of actions necessitate the presence of a change propagation
    mechanism in the MVC model. This change in the propagation mechanism is explained
    in the next section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 模型、视图和控制器的组件分离提供了灵活性，因为它允许对同一模型有多个视图。如果用户更改了使用视图组件的模型数据，那么使用相同数据的所有其他视图应立即更新以反映新的更改。这是通过模型在数据更改时通知所有视图来处理的。视图随后从模型获取更新后的数据并更新所有相关视图。所有这些动作序列都需要MVC模型中存在一个变更传播机制。这种传播机制的变更将在下一节中解释。
- en: Workings of the MVC pattern
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC模式的工作原理
- en: The model component exports procedures for application-specific processing.
    These procedures are called by the controller components in response to inputs
    received from the user. The model component also provides functions that can be
    used by the view component to access its data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 模型组件导出用于应用特定处理的程序。这些程序由控制器组件在接收到用户输入时调用。模型组件还提供视图组件可以用来访问其数据的函数。
- en: View components are used for presenting information to the end user. There may
    be different views for providing information in different ways as per the requirements
    of users. Each view is associated with an update procedure that is activated by
    the change propagation mechanism. The change propagation mechanism works by maintaining
    a registry of all the dependent components that are present within the model.
    All the related views and controllers that will be impacted by changes to these
    components also register their need so that they are kept informed of all the
    changes. Any change in model state in turn triggers the change-propagation mechanism.
    With the help of the update procedure, the view component retrieves the most updated
    data values from the model and displays them on the user interface screens.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 视图组件用于向最终用户展示信息。根据用户的需求，可能会有不同的视图以不同的方式提供信息。每个视图都与一个更新程序相关联，该程序由变更传播机制激活。变更传播机制通过维护模型中所有依赖组件的注册表来工作。所有受这些组件更改影响的关联视图和控制器也会注册他们的需求，以便他们能够了解所有更改。模型状态中的任何更改都会反过来触发变更传播机制。借助更新程序，视图组件从模型检索最新的数据值并在用户界面屏幕上显示它们。
- en: 'The controller component accepts user input in the form of events. The format
    in which this event data is delivered to the controller is dependent on the user
    interface platform. But in general, each controller executes an event-handling
    procedure that is associated with an event. The overall working of the MVC pattern
    is depicted in the graphic which is given here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器组件接受用户输入，形式为事件。这种事件数据传递给控制器的格式取决于用户界面平台。但一般来说，每个控制器执行与事件相关联的事件处理程序。MVC模式的整体工作原理在本节给出的图形中展示：
- en: '![](img/e0a0d5b3-4f96-4a83-8634-f816cf05f980.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e0a0d5b3-4f96-4a83-8634-f816cf05f980.png)'
- en: In the next section, we will discuss a popular programming framework which is
    developed using the MVC pattern.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一个流行的编程框架，该框架是使用MVC模式开发的。
- en: The ASP.Net framework
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.Net框架
- en: In ASP.Net, the patterns for the view component and the controller component
    are well-defined. Only the pattern for the model component is left to be designed
    by the developer as per the specific application requirements.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.Net中，视图组件和控制器组件的模式已经定义良好。只有模型组件的模式需要开发者根据具体的应用需求来设计。
- en: '**View**: The files that handle the responsibilities associated with the view
    component are ASPX and ASCX. In this design, the view object typically inherits
    from the controller object.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**：处理与视图组件相关的责任的文件是ASPX和ASCX。在这个设计中，视图对象通常继承自控制器对象。'
- en: '**Controller**: The responsibilities of the controller component are split
    among two components. The generation and passing of events is done by the framework
    and, to be more speciﬁc, is done by the Page and Control classes. The event handling
    is taken care of by the code-behind class.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器**：控制器组件的责任被分配到两个组件中。事件生成和传递由框架完成，更具体地说，由页面和控制类完成。事件处理由代码后置类负责。'
- en: '**Model**: ASP.NET does not necessarily require a model. It is left to the
    choice of the developer whether to create a model class, or to forgo it. In case
    a model is not used, the event handlers in the controller can be used to perform
    any calculations and also ensure data persistence.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型**：ASP.NET不一定需要模型。是否创建模型类或放弃它由开发者选择。如果不使用模型，控制器中的事件处理程序可以用来执行任何计算并确保数据持久性。'
- en: The model view presenter (MVP) pattern
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-表示者（MVP）模式
- en: 'The MVP pattern is a variant of MVC pattern and is mainly used for the development
    of user interfaces for web applications. It was mainly designed to make it easier
    to perform automated unit testing. The graphic given here depicts the architecture
    of the MVP pattern:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: MVP模式是MVC模式的变体，主要用于开发Web应用的用户界面。它主要是为了使自动化单元测试更容易而设计的。这里给出的图形描述了MVP模式的架构：
- en: '![](img/2010ba93-0258-4e5e-bea1-603711a678c7.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2010ba93-0258-4e5e-bea1-603711a678c7.png)'
- en: 'The various components of the MVP pattern are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: MVP模式的各种组件如下：
- en: '**Model**: This component specifies the data to be displayed/sent from or to
    the user interface.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：该组件指定要显示/从用户界面发送或接收的数据。'
- en: '**View**: The presentation logic lies in the Presenter component. It acts on
    both the model and the view components. It is responsible for fetching data from
    the model, applying appropriate logic, and sending it back for display in the
    view. When compared to the view and controller components in the MVC model, the
    view and presenter components present in the MVP pattern are fully decoupled from
    each other and they communicate by means of an interface.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：表示逻辑位于表示组件中。它作用于模型和视图组件。它负责从模型获取数据，应用适当的逻辑，并将其发送回视图进行显示。与MVC模型中的视图和控制器组件相比，MVP模式中的视图和表示组件是完全解耦的，并且通过接口进行通信。'
- en: '**Presenter**: The view component just acts as a passive interface. It displays
    data from the model and sends user inputs and commands to the presenter component.
    These user inputs and commands will be used to perform operations on the data.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示者**：视图组件仅作为被动接口。它显示模型中的数据，并将用户输入和命令发送到表示组件。这些用户输入和命令将被用来对数据进行操作。'
- en: 'The following are some of the key considerations about the MVP pattern:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于MVP模式的关键考虑因素：
- en: The end user interacts only with the View
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终用户仅与视图交互
- en: One View component is mapped only to one Presenter component
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个视图组件仅映射到一个表示组件
- en: View references Presenter component but it has no reference to Model component
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图引用表示者组件，但没有引用模型组件
- en: The pattern facilitates two way communication between the View component and
    the Presenter component
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该模式促进了视图组件和表示组件之间的双向通信
- en: Some of the common applications that use this pattern are ASP.Net forms and
    Windows forms.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一些使用此模式的一些常见应用包括ASP.Net表单和Windows表单。
- en: The model-view-viewmodel (MVVM) pattern
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-视图模型（MVVM）模式
- en: 'MVVM is a popular pattern used for developing reusable and easily testable
    web applications. MVVM is a modern variant of MVC and the core objective is to
    have true separation between the Model and the View components. The main components
    of the pattern are the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM是一种流行的模式，用于开发可重用且易于测试的Web应用。MVVM是MVC的现代变体，其核心目标是实现模型和视图组件之间的真正分离。模式的主要组件如下：
- en: Model
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Model
- en: View
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: View
- en: ViewModel
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ViewModel
- en: 'The layered architecture of the pattern is depicted in the following diagram:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的分层架构在以下图中描述：
- en: '![](img/b882d4c6-80c9-48a1-ae8b-c7247c0ad3e4.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b882d4c6-80c9-48a1-ae8b-c7247c0ad3e4.png)'
- en: 'The various components of the MVVM pattern are as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM模式的各种组件如下：
- en: '**Model**: This component represents business logic and data. This means that
    the business logic that specifies how the data should be manipulated is present
    in the Model component.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型**：该组件代表业务逻辑和数据。这意味着指定如何操作数据的业务逻辑存在于模型组件中。'
- en: '**View**: This component represents the UI components and will essentially
    contain UI elements such as CSS, HTML, and so on. It is only responsible for representing
    the data and does not perform any manipulations on data. However, unlike MVM,
    the View in MVVM is an active component and contains behaviors, events, and data-bindings
    that require information about the underlying model and viewModel components.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**：此组件代表UI组件，并将本质上包含CSS、HTML等UI元素。它仅负责表示数据，不对数据进行任何操作。然而，与MVM不同，MVVM中的视图是一个活动组件，包含行为、事件和数据绑定，这些需要关于底层模型和viewModel组件的信息。'
- en: '**ViewModel**: The ViewModel is a very important component of the architecture
    as it helps in presentation separation, that is, it helps to keep the view separate
    from the model and, at the same time, acts as a controller that supports interaction
    and coordination between the View and the model components. The ViewModel component
    also contains commands and methods that help maintain the state of the view and
    help to manipulate the Model as per the actions, which are performed on the view.
    The ViewModel component also helps to trigger events in the view component itself.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**ViewModel**：ViewModel是架构中非常重要的组件，因为它有助于展示分离，即它有助于保持视图与模型分离，同时充当支持视图和模型组件之间交互和协调的控制器。ViewModel组件还包含命令和方法，有助于维护视图的状态，并帮助根据在视图中执行的操作操纵模型。ViewModel组件还帮助在视图组件本身中触发事件。'
- en: Key advantages of the MVVM pattern
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVVM模式的关键优势
- en: 'The following are the key advantages of using the MVVM pattern for design:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MVVM模式进行设计的以下关键优势：
- en: '**Maintainability**: In this pattern, the clear separation of the different
    pieces of code makes it easier to maintain the code and also ensures quick releases
    using the code.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：在此模式中，不同代码片段的清晰分离使得维护代码更加容易，同时也确保了使用代码的快速发布。'
- en: '**Testability**: In this pattern, the different pieces of code are very granular
    and are a key away from the core functional logic. This makes unit testing very
    easy.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：在此模式中，不同的代码片段非常细粒度，并且与核心功能逻辑的关键距离。这使得单元测试变得非常容易。'
- en: '**Extensibility**: The granular pieces of code facilitate the reuse of code
    and also allows quick modification of code snippets.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：细粒度的代码片段促进了代码的重用，并允许快速修改代码片段。'
- en: Design considerations for using the MVVM pattern
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MVVM模式的设计考虑因素
- en: 'The MVVM pattern is a right choice for design web applications that require
    the following aspects:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM模式是设计需要以下方面的Web应用程序的正确选择：
- en: Thorough unit testing of various components
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对各个组件进行彻底的单元测试
- en: Development of applications using the concept of reusable code and development
    of applications which can generate reusable snippets of code
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可重用代码的概念开发应用程序，以及开发能够生成可重用代码片段的应用程序
- en: Flexibility to change the user interface without changing the code base
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在不更改代码库的情况下更改用户界面
- en: In the next section, we will discuss a sample framework that is built using
    the MVVM pattern.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一个使用MVVM模式构建的示例框架。
- en: Prism
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Prism
- en: 'Prism is a framework that is built using the MVVM pattern. It helps in the
    design and development of flexible and easy to maintain **Windows presentation
    foundation** (**WPF**) desktop applications. It also helps to build rich internet
    applications using the Microsoft Silverlight Browser plugin. The following are
    the key features of the Prism framework:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Prism是一个使用MVVM模式构建的框架。它有助于设计和开发灵活且易于维护的**Windows演示基础**（**WPF**）桌面应用程序。它还帮助使用Microsoft
    Silverlight浏览器插件构建富互联网应用程序。以下Prism框架的关键特性：
- en: It uses architectural pattern that supports important design concepts such as
    separation of concerns and loosely coupled components.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用支持重要设计概念（如关注点分离和松散耦合组件）的架构模式。
- en: Prism helps in the design of code snippets/components that can be easily integrated
    to form an application. Applications of this type which are formed by integrating
    components are called composite applications.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prism有助于设计可轻松集成以形成应用程序的代码片段/组件。通过集成组件形成的应用程序称为复合应用程序。
- en: 'The following are some of the important features of Prism:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Prism的一些重要特性包括：
- en: Support for the MVVM pattern, which in turn provides a bindable base class.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持MVVM模式，这反过来又提供了一个可绑定基类。
- en: It has a flexible ViewModelLocator, which allows the View and ViewModel component
    to be hooked up in a loosely coupled way. It provides full support for the development
    of modular applications as it has several loosely coupled class libraries. These
    libraries can be brought together at runtime in the form of an application for
    the end user. The code base still remains decoupled.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有灵活的 ViewModelLocator，允许视图和 ViewModel 组件以松耦合的方式连接。因为它有几个松耦合的类库，所以它为模块化应用程序的开发提供了全面的支持。这些库可以在运行时以应用程序的形式组合在一起，供最终用户使用。代码库仍然保持解耦。
- en: Supports a rich set of navigation features that supports features like forward
    navigation, backward navigation, and so on. The navigation stack of prism allows
    ViewModels to be part of the navigation process directly.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持丰富的导航功能，支持如前进导航、后退导航等功能。Prism 的导航堆栈允许 ViewModel 直接参与导航过程。
- en: Prism supports the concept of Pub/Sub events. These refer to a mechanism of
    loosely coupled events where the publisher and subscriber components can communicate
    with the help of events. It is not necessary that the publisher or subscriber
    components should have explicit references or the same lifetimes.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prism 支持发布/订阅事件的概念。这些是指一种松耦合事件机制，其中发布者和订阅者组件可以通过事件进行通信。发布者或订阅者组件不一定需要具有显式的引用或相同的生命周期。
- en: Design patterns for web application development
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用程序开发的设计模式
- en: 'Apart from the MVC, MVP, and MVVM architectural patterns, which were discussed
    in the previous sections, there are several design patterns that are used for
    the design of applications along with these patterns. In this section, we will
    discuss some of the commonly used design patterns for web application design.
    These patterns and their functionalities are described in the following table:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在前几节中讨论的 MVC、MVP 和 MVVM 架构模式之外，还有一些设计模式与这些模式一起用于应用程序的设计。在本节中，我们将讨论一些常用的网络应用程序设计模式。以下表格描述了这些模式和它们的功能：
- en: '| **Pattern name** | **Functionality** |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **模式名称** | **功能** |'
- en: '| **Interpreter design pattern** | This pattern is widely used in the development
    of menus for applications like editors and Integrated Development Environments
    (IDEs). This pattern works by interpreting instructions that are written in the
    form of a language grammar or as notations. This pattern involves the implementation
    of an expression interface, which is used to interpret a given context. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **解释器设计模式** | 这种模式在开发编辑器和集成开发环境（IDE）等应用程序的菜单时广泛使用。这种模式通过解释以语言语法或符号形式编写的指令来工作。这种模式涉及实现一个表达式接口，用于解释给定的上下文。|'
- en: '| **Mediator design pattern** | The key feature of this pattern is that it
    allows objects to interact with each other without knowing their structure. This
    is made possible by defining an object by encapsulating how they interact with
    other objects. This feature also helps in easy maintainability and the reuse of
    code. This pattern is also widely used for developing menus for applications like
    editor and IDE. |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **中介者设计模式** | 这种模式的关键特性是它允许对象在不了解其结构的情况下相互交互。这是通过定义一个对象，通过封装它们与其他对象交互的方式实现的。这个特性也有助于代码的易于维护和重用。这种模式也广泛用于开发编辑器和
    IDE 等应用程序的菜单。|'
- en: '| **Memento design pattern** | The key feature of this pattern is that it helps
    to capture the present state of an object and store it as is so that it can be
    used again at a later point in time when needed without actually breaking the
    rules associated with object encapsulation. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| **备忘录设计模式** | 这种模式的关键特性是它有助于捕获对象当前状态并将其存储为原始状态，以便在需要时可以在稍后的时间点再次使用，而不必实际违反与对象封装相关的规则。|'
- en: '| **Observer design pattern** | This pattern is used in scenarios where there
    exists a one to many relationship between objects. In such scenarios, if an object
    is modified, it becomes necessary to notify its dependent objects about the changes.
    That is the main motivation for the use of observer design pattern. This pattern
    allows a single object called subject to notify its state changes to all other
    observer objects that are dependent on it. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **观察者设计模式** | 这种模式用于存在对象之间一对一关系的场景。在这种情况下，如果对象被修改，就必需通知其依赖对象关于这些变化的信息。这就是使用观察者设计模式的主要动机。这种模式允许一个称为主题的单个对象通知所有依赖它的其他观察者对象其状态的变化。|'
- en: '| **State design pattern** | This pattern is used in scenarios where there
    exists a one to many relationship between objects. In such scenarios, if an object
    is modified, it becomes necessary to notify its dependent objects about the changes.
    This pattern is primarily used in situations where it is necessary to alter the
    behaviour of an object when there is a change in its internal state. This pattern
    works by creating an object to represent various states and an associated context
    object whose behaviour changes as per the state changes of the created object.
    |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| **状态设计模式** | 此模式用于存在对象之间一对一关系的场景。在这种情况下，如果对象被修改，则必须通知其依赖对象关于更改的信息。此模式主要用于在对象内部状态发生变化时需要改变对象行为的情况。此模式通过创建一个对象来表示各种状态，以及一个相关的上下文对象，其行为根据创建对象的州变化而变化。|'
- en: '| **Strategy design pattern** | This pattern provides flexibility to a client
    to choose any specific algorithm from a group of algorithms at runtime. It also
    provides a simple way for the client to access the algorithm. This pattern works
    by removing an algorithm from its host class and placing it in a separate class.
    This will help in the prevention of code-related issues that will arise if the
    algorithm is present in the host class. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| **策略设计模式** | 此模式为客户端提供了在运行时从一组算法中选择任何特定算法的灵活性。它还为客户端提供了一个简单的方式来访问算法。此模式通过将算法从其宿主类中移除并将其放置在单独的类中来实现。这将有助于防止如果算法存在于宿主类中可能出现的代码相关问题。|'
- en: '| **Template method design pattern** | This pattern provides the feature to
    define basic steps of algorithm execution while allowing specific execution steps
    to be changed. This is very similar to the Strategy design pattern; the only difference
    is that it allows modification of certain algorithm steps instead of the entire
    algorithm. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **模板方法设计模式** | 此模式提供了定义算法执行基本步骤的功能，同时允许特定的执行步骤被更改。这与策略设计模式非常相似；唯一的区别是它允许修改某些算法步骤而不是整个算法。|'
- en: '| **Visitor design pattern** | This pattern provides flexibility to create
    and perform new operations on a set of objects without altering the structure
    of the object and its associated classes. This pattern allows the loose coupling
    of components and hence new operations can be done on them without altering the
    existing object structure. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **访问者设计模式** | 此模式提供了在不改变对象及其相关类的结构的情况下创建和执行一组对象上新操作的灵活性。此模式允许组件的松散耦合，因此可以在不改变现有对象结构的情况下对它们执行新操作。|'
- en: '| **Bridge pattern** | This pattern provides the flexibility to separate an
    abstraction from its implementation. This allows both of them to be modified independently.
    The separation of abstraction from implementation is done by means of an interface
    that provides a bridge between the abstraction class and implementer class. This
    separation also makes the implementer class functionality independent of the abstraction
    class functionality. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **桥接模式** | 此模式提供了将抽象与其实现分离的灵活性。这允许它们独立修改。通过提供一个接口来实现抽象类和实现类之间的桥梁，从而实现抽象与实现的分离。这种分离也使得实现类功能独立于抽象类功能。|'
- en: '| **Composite pattern** | This pattern provides the flexibility to treat a
    group of objects and a single object in the same manner. The composite pattern
    arranges objects in the form of a tree structure to represent part as well as
    whole hierarchies. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| **组合模式** | 此模式提供了以相同方式处理一组对象和单个对象的灵活性。组合模式以树结构的形式排列对象，以表示部分以及整体层次结构。|'
- en: '| **Factory method design pattern** | This pattern provides the flexibility
    to create an object without exposing its creation logic. In this pattern, an interface
    is used for creating an object. The subclass decides which class needs to be instantiated.
    The creation of an object is done only as and when it is required. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **工厂方法设计模式** | 此模式提供了在不暴露其创建逻辑的情况下创建对象的灵活性。在此模式中，使用接口来创建对象。子类决定需要实例化哪个类。对象的创建仅在需要时进行。|'
- en: '| **Builder design pattern** | This pattern allows us to build a complex object
    by using a step by step approach. A specialized interface called the Builder interface
    specifies the steps that are required to build the final object. This Builder
    interface is independent of the objects creation process. A class known as Director
    controls the object creation process. Another speciality of this pattern is that
    it specifies a way to separate an object from its construction. The same construction
    method can be used to create multiple representations of the same object. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| **建造者设计模式** | 该模式允许我们通过逐步方法构建一个复杂对象。一个称为建造者接口的专用接口指定了构建最终对象所需的步骤。这个建造者接口与对象的创建过程无关。一个称为导演的类控制着对象的创建过程。该模式的另一个特点是它指定了一种将对象与其构造分离的方法。相同的构造方法可以用来创建同一对象的多个表示形式。|'
- en: '| **Adapter pattern** | This pattern is used when it is required to provide
    a bridge between two incompatible interfaces. This pattern provides a single class
    called adapter that facilitates communication between two independent or incompatible
    interfaces.**For example:** A card reader acts as an adapter for the memory card
    present in the laptop. This is done by plugging in the memory card into the card
    reader. The card reader is then plugged into the laptop so that the memory card
    can be read through the laptop. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **适配器模式** | 当需要提供两个不兼容接口之间的桥梁时，使用此模式。该模式提供了一个名为适配器的单一类，它促进了两个独立或不兼容接口之间的通信。**例如**：读卡器作为笔记本电脑中内存卡的适配器。这是通过将内存卡插入读卡器来完成的。然后，将读卡器插入笔记本电脑，以便可以通过笔记本电脑读取内存卡。|'
- en: The front controller pattern
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端控制器模式
- en: 'Another architectural pattern that is popular in web application development
    is the front controller pattern. This pattern ensures that there is only one point
    of entry for all incoming requests. A single piece of code called the controller
    handles all the incoming requests and then delegates the processing of each request
    to other application objects, which are present in the system. This core feature
    of the pattern helps the web application developers by providing necessary flexibility
    using the reuse of code. The architecture of the front controller pattern is depicted
    in the following graphic:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在Web应用程序开发中流行的架构模式是前端控制器模式。该模式确保所有传入请求只有一个入口点。一个称为控制器的单一代码片段处理所有传入请求，然后将每个请求的处理委托给系统中的其他应用程序对象。该模式的这一核心特性通过代码的重用为Web应用程序开发者提供了必要的灵活性。前端控制器模式的架构在以下图形中展示：
- en: '![](img/797640eb-7f26-4753-9d48-c661ee130fdb.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/797640eb-7f26-4753-9d48-c661ee130fdb.png)'
- en: 'The following are the different components of this pattern:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该模式的不同组件：
- en: '**Front controller**: This component handles all types of incoming requests
    for the application'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端控制器**：该组件处理应用程序所有类型的传入请求'
- en: '**Dispatcher**: This component is used to dispatch a request to a specific
    handler for further processing'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分发器**：该组件用于将请求分发给特定的处理器以进行进一步处理'
- en: '**Views**: These correspond to the objects for which the requests are made'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这些对应于请求的对象'
- en: In the next section, we will discuss a popular framework that is developed using
    the front controller pattern.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一个使用前端控制器模式开发的流行框架。
- en: Spring framework
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring框架
- en: 'Spring, a very popular framework for web application development, follows two
    architectural patterns for its design: the front controller pattern and the MVC
    pattern. The architecture is depicted in the following graphic:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Spring，一个非常流行的Web应用程序开发框架，在其设计中遵循了两种架构模式：前端控制器模式和MVC模式。架构在以下图形中展示：
- en: '![](img/1aa38905-4d60-4952-97ad-1b2c3314ffad.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1aa38905-4d60-4952-97ad-1b2c3314ffad.png)'
- en: The Dispatcher Servlet component is the single servlet that functions as the
    front controller and handles all incoming requests. The Dispatcher Servlet then
    calls Handler Mapping in order to find an object that could service the request.
    The request is then given to the controller object so that the Dispatcher becomes
    free to perform functions associated with the fulfilment of business logic as
    per the user's request. The controller object returns an encapsulated object that
    contains the model object and view object. This is represented by the ModelandView
    class. If the ModelandView contains the logical name of the view, the Dispatcher
    Servlet calls the View Resolver to get details of the actual view object from
    its logical name. The Dispatcher Servlet then gives the model object to the view
    object so that it can be displayed to the end user.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 分发器Servlet组件是作为前端控制器功能并处理所有传入请求的单个Servlet。分发器Servlet随后调用处理器映射以找到可以处理请求的对象。然后将请求交给控制器对象，以便分发器可以自由执行与用户请求的业务逻辑满足相关的功能。控制器对象返回一个封装的对象，其中包含模型对象和视图对象。这由ModelandView类表示。如果ModelandView包含视图的逻辑名称，分发器Servlet将调用视图解析器以获取实际视图对象的详细信息。然后分发器Servlet将模型对象交给视图对象，以便它可以显示给最终用户。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started the discussion with a two-tier client-server pattern.
    This is one of the earliest and oldest client-server patterns. With the growth
    of the information technology industry, this two-tier client server pattern was
    not sufficient to meet the infrastructure requirements. This led to the evolution
    of the three-tier client-server pattern followed by *n*-tier client-server pattern.
    Some other variants of the client-server pattern like the master-slave pattern,
    peer-to-peer pattern, and so on were also discussed in this chapter. The applications
    and the design considerations for each type of pattern was also discussed in this
    chapter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们以两层客户端-服务器模式开始讨论。这是最早和最古老的客户端-服务器模式之一。随着信息技术产业的增长，这种两层客户端服务器模式不足以满足基础设施需求。这导致了三层客户端-服务器模式的演变，随后是*n*层客户端-服务器模式。本章还讨论了客户端-服务器模式的某些其他变体，如主从模式、对等模式等。本章还讨论了每种模式的适用应用程序和设计考虑因素。
- en: Web application development, which caught steam later could not use client-server
    architecture because of its inherent limitations. This led to the evolution of
    some patterns that were custom-made for the development of web applications. These
    patterns needed the basic flexibility to be able to change the UI without altering
    the code base. The second half of this chapter dealt mainly with these patterns.
    The main patterns that were discussed in this part were MVC, MVP, MVVM, and the
    front controller.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序开发，虽然后来才兴起，但由于其固有的局限性，无法使用客户端-服务器架构。这导致了某些专为网络应用程序开发量身定制的模式的演变。这些模式需要基本的灵活性，以便在不更改代码库的情况下更改用户界面。本章的后半部分主要讨论了这些模式。本部分讨论的主要模式是MVC、MVP、MVVM和前端控制器。
- en: Some of the common design patterns that are used along with these patterns were
    also discussed in this chapter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还讨论了一些与这些模式一起使用的常见设计模式。
- en: 'Additional reference for this chapter: [http://www.dotnettricks.com/learn/designpatterns/adapter-design-pattern-dotnet](http://www.dotnettricks.com/learn/designpatterns/adapter-design-pattern-dotnet)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的附加参考资料：[http://www.dotnettricks.com/learn/designpatterns/adapter-design-pattern-dotnet](http://www.dotnettricks.com/learn/designpatterns/adapter-design-pattern-dotnet)
