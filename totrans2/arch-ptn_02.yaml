- en: Client/Server Multi-Tier Architectural Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provides a bird's eye view of client-server architectural patterns.
    It starts with the need for the evolution of two-tier client-server patterns and
    highlights how the limitations of two-tier client-server patterns led to the evolution
    of three-tier and consequently *n*-tier client-server patterns. The different
    variants of client-server patterns like the master-slave pattern, peer-to-peer
    patterns, and so on are also explained in-depth with relevant use cases. The second
    part of the chapter focuses on web application frameworks. The requirements of
    web applications are different from that of client-server applications, the key
    differentiating factor being the dynamic updates to the UI based on the changes
    in the underlying data. All the popular patterns used in web application design
    are covered in this part of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The major topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Two-tier, three-tier, and *n*-tier client-server patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The master-slave pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The peer-to-peer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distributed client-server pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model-view-controller pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model-view-presenter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model-view-model pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The front controller pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some common design patterns used for web application development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The client-server pattern is one of the oldest architectural patterns. In simple
    terms, how do we describe a client and a server? It is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client**: This is the component that is a requestor of a service and sends
    requests for various types of services to the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server**: This is the component that is a service provider and continuously
    provides services to the client as per the requests placed by it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients and servers typically comprise of distributed systems, which communicate
    over a network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a simple graphic depicting the client-server architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3940b149-f6fb-413e-a076-367eb80b8c8d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is no upper bound on the number of clients that can be serviced by a
    single server. It is also not mandatory that the client and server should reside
    in separate systems. Both client and server can reside in the same system based
    on the hardware configuration of the system and the type of functionality or service
    provided by the server. The communication between client and server happens by
    exchange of messages using a request-response pattern. The client basically sends
    a request for a service and server returns a response. This request-response pattern
    of communication which happens between a client and a server is a very good example
    of inter-process communication. For this communication to happen efficiently,
    it is necessary to have a well-defined communication protocol which lays down
    the rules of communication such as the format of request messages, response messages,
    error handling, and so on. All communication protocols that are used for client-server
    communication work in the application layer of the protocol stack. To further
    streamline the process of client-server communication, the server sometimes implements
    specific **application programming interfaces** (**APIs**) which could be used
    by the client to access any specific service from the server. This client-server
    pattern depicted in the graphic has two tiers: the client tier and the server
    tier, and hence it is also called the **two-tier client-server pattern**.'
  prefs: []
  type: TYPE_NORMAL
- en: The term "service" used in the context of client-server architecture refers
    to the abstraction of a resource. The resource could be of any type, and the server
    is named based on the resource that is provided by the server (service). For example,
    if the server provides web pages, it is called a **web server** and if the server
    provides files, it is called a **file server**, and so on. A server can receive
    requests from *n* number of clients at a specific point in time. But any server
    will have its own limitations about its processing capabilities. So, many times,
    it becomes necessary for a server to prioritize the incoming requests and service
    them as per their priority. The scheduling system present in the server helps
    the server with the assignment of priorities. The common applications of client-server
    patterns for different use cases are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Email server** and **email client**: An email server provides emails as per
    the request received from the email client. Some commonly used enterprise email
    solutions are Microsoft Exchange from Microsoft, Lotus notes from IBM, Gmail from
    Google, and so on. Working on an email system is described as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: A mail server which is also known as an email server is the server that processes
    and delivers emails over the network, which is typically internet. A mail server
    is also equipped to receive emails from client computers and deliver them to other
    mail servers that are present in the network. An email client is a system in which
    the emails are read. It could be a desktop, laptop or a smartphone which can support
    emails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The working of an email system is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/011a8490-7939-42cd-a536-e4bf51a87ae5.png)'
  prefs: []
  type: TYPE_IMG
- en: When an email is sent from a client, the email software which is present in
    the client system will connect to a server which is present in the network called
    the **simple mail transfer protocol** (**SMTP**) server. SMTP refers to a protocol
    which is used to deliver emails from clients to servers and from one server to
    another.
  prefs: []
  type: TYPE_NORMAL
- en: When emails are downloaded using the email software present on your client machine,
    the email software will connect to another server, which performs a function called
    a **p****ost office protocol version3** (**POP3**) server. POP3 server uses a
    POP3 protocol. This protocol works like a mail delivery system used in a post
    office and hence the name. A detailed discussion of these protocols is beyond
    the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Domain name service (DNS) server and DNS client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DNS is one of the most important services that is present on the internet.
    An internet has thousands of devices that are a part of it and each of these devices
    is referred to as a host. Each host could be a printer, router, computer, or any
    other device. Each host has a unique IP address associated with it. Apart from
    the IP address, each host also has a unique hostname associated with it. For example,
    if the hostname is `LP471` and it is present in a domain `technest.com`, then
    the **fully qualified domain name** (**FQDN**) of the host is `LP471.technest.com`.
    The FQDN is used to identify the host uniquely within the DNS namespace. The DNS
    namespace contains some commonly used name suffixes; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.com`: Commercial organizations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.edu`: Educational institutions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.gov`: Government organizations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.org`: Non-profit bodies like IEEE'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.net`: Networking organizations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these commonly used name suffixes, there are several others, too.
  prefs: []
  type: TYPE_NORMAL
- en: The workings of a DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A DNS works using the concept of distributed databases based on the client-server
    model. DNS clients are entities that require a name resolution (mapping of host
    names to IP addresses). DNS servers maintain the data that is required for name
    resolution. The high-level schematic of a DNS client-server architecture is given
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc263f97-ec1e-475c-8a4a-491e3b007bc0.png)'
  prefs: []
  type: TYPE_IMG
- en: Suppose the URL `www.xyzworks.com` is typed into the browser of the DNS client.
    The browser gets connected to a DNS server to get the equivalent IP address. The
    DNS server performs this task by first connecting to one of the root DNS servers.
    The root servers will store the IP addresses of all DNS servers that handle top-level
    domains such as `.edu`, `.com`, and so on. In this example, the root server after
    getting the IP address of the top-level domain `.com`, sends it a query asking
    for the IP address of `www.xyzworks.com`. The DNS server that handles the `.com`
    domain will respond with the IP addresses of the name servers that handle the
    `www.xyzworks.com` domain.
  prefs: []
  type: TYPE_NORMAL
- en: The name server then sends the query to the `www.xyzworks.com` DNS server. This
    DNS server responds with the entire IP address to the name server, which in turn
    sends it back to the DNS client which had initiated the DNS request. The DNS client
    machine can then use the IP address to access the required web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The salient aspects of this client-server architecture are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Redundancy**: There are multiple DNS servers at each level so that even if
    one fails, the other server can take its role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: Once a DNS request is resolved, the DNS server caches the IP address
    received by it. For example, where the IP address of the `.com` domain server
    is cached by the DNS server so that any subsequent requests for a `.com` domain
    can be handled by it without initiating repetitive DNS query mechanisms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional requirements in two-tier client-server patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The key functional requirements in two-tier client-server patterns are classified
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functional requirement** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Presentation services | Provides user interface and dialog control |'
  prefs: []
  type: TYPE_TB
- en: '| Presentation logic | User interaction and validation of inputs |'
  prefs: []
  type: TYPE_TB
- en: '| Business logic | Set of business rules that specify how data can be stored,
    created, and changed |'
  prefs: []
  type: TYPE_TB
- en: '| Distribution service | Management of communication |'
  prefs: []
  type: TYPE_TB
- en: '| Database logic | Data operations and manage integrity of data |'
  prefs: []
  type: TYPE_TB
- en: '| Database services | Management of various attributes of a database transaction
    |'
  prefs: []
  type: TYPE_TB
- en: '| File services | Operations on files and sharing of files |'
  prefs: []
  type: TYPE_TB
- en: Distribution of functional requirements in a client-server pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clients are broadly classified into the following two major categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fat client**: Most of the functional services are performed by the client
    component. One classic example of a fat client is a file server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thin client**: If it is a thin client, it relies on the server component
    for most of its computational capability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice of the client is made based on the type of client-server pattern,
    which is planned and implemented in a system. For example, if the pattern involves
    a lot of functionality to be done on the client side, then the choice of client
    is typically fat client, and vice versa. The functional requirements that are
    discussed in this section will give a better idea regarding the choice of client
    and server systems for implementing specific client-server patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various ways in which functional requirements can be implemented
    in a client-server pattern. The following are some of the prominent ways of implementing
    client-server patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: The remote data access client-server pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remote presentation client-server pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The split logic data client-server architecture pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remote data access client-server pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the remote data access client-server pattern, the application resides on
    the client component, whereas the data management is done by the server component.
    The server that performs data management is typically referred to as **database
    management server** (**DBMS**) or data server. Most of the **relational database
    management system** (**RDBMS**) products available in the market are implemented
    using this pattern. These RDBMS products typically provide a layer or component
    of software at the client side, which handles communication with the data server.
    This component of the software is called **data manipulation language** (**DML**).
    Client systems support the presentation and business logic and interact with the
    data server using DML. These patterns typically involve the usage of fat clients
    as a significant amount of processing is done by the client systems as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of functional requirements in a remote data access client-server
    architecture is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/366ad14d-5f99-422b-9ea0-c1588f5648a5.png)'
  prefs: []
  type: TYPE_IMG
- en: The remote presentation client-server pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the remote presentation client-server pattern, the **graphical user interface**
    (**GUI**) frontend is mapped to an existing application''s text-based screen.
    This process is called Remote mapping or Front ending. The typical mode of operation
    of this pattern involves the use of intelligent workstations, which are equipped
    with the capability to intercept the text screen streams of data that are sent
    from a server system, and display them in a windowed system using a GUI. However,
    in these systems, most of the processing and computation happens on the server
    end only. One ideal example of this implementation is IBM''s 3270 (mainframe)
    application. In this application, data from the application is sent to 3270''s
    screen program on the mainframe to be displayed. The data is then sent to the
    client workstation in the form of a 3270-data stream. The client workstation receives
    the data, interprets it, and converts it to a graphical form to be displayed in
    a window. If the user enters any data through the client workstation in the GUI
    window, the front ware application that runs in the client workstation converts
    the data into a 3270-compatible format and sends it back to the server for the
    next course of action. The split of functions in a remote **presentation** client-server
    pattern is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d71d464-1cfb-4d6c-bfe2-55d3e9ab7216.png)'
  prefs: []
  type: TYPE_IMG
- en: The split logic data client-server architecture pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the split logic data client-server architecture pattern, the application
    functionality is split into two parts: one will be implemented on the client side
    and the other one will be implemented on the server side. This pattern is very
    complex when compared to the other two patterns because both client and server
    need separately compiled application programs for their functioning. Before implementing
    this pattern, it is very important for developers to identify the functions to
    be implemented on the client and the server side and list out the type of communication
    dialogs that must happen between the application programs running on the client
    and the server side.'
  prefs: []
  type: TYPE_NORMAL
- en: The three-tier pattern / multi-tier pattern client-server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram represents a client-server interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91118019-e466-4904-8460-5ab1afb9e7f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will discuss some of the variants of client-server patterns in this section.
    Some of the prominent variants of client-server patterns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The master-slave pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The peer-to-peer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The master-slave pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The master-slave pattern is applied for designing a system if the system involves
    similar or identical computations that need to be performed repeatedly with separate
    set of inputs and context. The master-slave pattern offers support for fault tolerance
    and parallel computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The master-slave pattern is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b35851ef-fe49-498a-8de9-a79828a7074a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The master component distributes the work among all the slave components and
    calculates the ﬁnal result by summing up the results that are returned by each
    slave. The master-slave pattern is used for architecting embedded systems and
    used in the design of systems that perform massive parallel computations. The
    following is a sequence diagram of the master-slave pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0241228f-d7e6-45e6-88d7-7547afa99ea7.png)'
  prefs: []
  type: TYPE_IMG
- en: Issues in the master-slave pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The master-slave pattern works based on the divide and conquer principle. In
    the working of this pattern, the coordination concept is separated from the actual
    work as all the slaves work in parallel. Hence, the slaves have not shared state
    and they work in isolation. Another issue in the master slave pattern is its latency.
    This could cause an issue in systems where the response time is very critical,
    for example, real-time systems. Moreover, this pattern can be applied to a specific
    problem only if it is decomposable.
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways of implementing the master-slave pattern is through a single
    master thread, which creates multiple slave threads. Each of the slave threads
    performs a variant of the required computation and returns the result to the master.
    Once the computation is complete, the master thread accumulates the results and
    terminates the slave threads.
  prefs: []
  type: TYPE_NORMAL
- en: Client-queue-client patternsThis is also called passive queue architecture.
    This is a variant of the client-server architecture in which all components, including
    servers, are treated only as client systems. This is because servers were treated
    as passive queues by the clients which are present in the system and are used
    by the clients for transferring messages to other clients present in the network.
    This architecture could be treated as one of the early evolutions of peer-to-peer
    architecture, which is discussed in the next section and is obsolete today.
  prefs: []
  type: TYPE_NORMAL
- en: Peer-to-peer patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Peer-to-peer architectural patterns belong to the category of symmetric client-server
    patterns. Symmetric in this context refers to the fact that there is no need for
    a strict division in terms of client, server, and so on in the network of systems.
    In a peer-to-peer pattern, a single system acts as both client and server. Each
    system, also called a peer, sends requests to other peers in the network and at
    the same time receives and services requests from other peers, which are part
    of the network. This is a great difference when compared to a traditional client
    server network where a client must only send a request and wait for the server
    to process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, this pattern is typically used to implement a decentralized network
    of systems using distributed resources that are expected to perform specific function.
    The distributed resources could be either processing power, data, or bandwidth
    which may be used for any distributed computing task like Sharing of content,
    communication, and so on. The generic architecture of a peer-to-peer pattern is
    depicted in the following diagrams (however, some variations are possible, which
    we will discuss later):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f9b2560-2563-417c-b238-5ca1ee4e0691.png)![](img/083a5194-ccea-4ed6-b9a0-5f1d8c8c1f88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Peer-to-peer patterns are basically implemented in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: A pure peer-to-peer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hybrid peer-to-peer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a pure peer-to-peer pattern, all the systems that are part of the network
    are peers and they act as both client and server. There is no dependency on a
    centralized server for managing the various operations. The main advantage of
    this architecture is its fault tolerance. Another advantage is the simplicity
    and ease of implementation as this architecture moves away from the concept of
    centralization. The downside of the architecture is that the network bandwidth
    gets overused due to flooding of requests from all the peers that are part of
    the network. Gnutella, a popular file sharing protocol, is implemented using the
    pure peer-to-peer pattern. The preceding diagram is an example of a pure peer-to-peer
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the hybrid peer-to-peer pattern, there exists a central server to perform
    certain administrative tasks that are required for the smooth functioning of P2P
    services. This can be better explained with the help of a simple example. Napster,
    a file sharing protocol is designed based on hybrid peer-to-peer pattern. In Napster,
    there is a server whose main functionality is to help peer systems which are part
    of the network search for files. Transfer of files between the systems are then
    initiated based on the search results which are returned by the server. In other
    words, only the catalogue of files is maintained in the server whereas the actual
    files which are present in the catalogue are scattered across all the peer systems
    which are part of the network. This pattern is less fault tolerant when compared
    to the pure peer-to-peer pattern because of the dependency on centralized server
    component. However, the main benefit of this pattern is that there is no unnecessary
    consumption of network resources and this architecture is highly scalable. The
    hybrid peer-to-peer pattern is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/083a5194-ccea-4ed6-b9a0-5f1d8c8c1f88.png)'
  prefs: []
  type: TYPE_IMG
- en: Though peer-to-peer patterns are very effective for applications like file sharing,
    they also provide options for a lot of security threats and malicious code to
    enter the network and get propagated to other peer systems which are part of the
    network. Hence, the TCP ports which are used by peer-to-peer application should
    be constantly monitored and kept under the surveillance of **intrusion detection
    systems** / **intrusion prevention systems**.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of two-tier client-server patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the key advantages of client server systems are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: Data is stored centrally in the server. This offers greater control
    over the server and offers higher level of security than protecting the data that
    will be spread across a large number of client machines, which may involve offering
    special security mechanisms for each client machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Centralized access to data**: As most of the data is stored centrally in
    the server, it is much easier to do updates on the data. This is one of the simplest
    architectural styles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of maintenance**: In this architectural pattern, the client is unaware
    of details of the server and hence server maintenance activities like repair,
    upgrade, and so on do not affect the functioning of the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design considerations - when to use a two-tier client-server pattern?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having read so much about the two-tier client-server pattern, the next question
    which arises in our mind is when to use two-tier client server pattern for a specific
    architectural design. The following points could be used as a guideline to decide
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: If the application under consideration is server based and will support numerous
    client, then the two-tier client server pattern is a good choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the applications that work well with a two-tier client server pattern
    are web applications that are accessed through a web browser or for business process
    applications that are likely to be used throughout the organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are looking at centralizing data operations like storage, backup, and
    other related administration tasks, even then a two-tier client server pattern
    is an ideal choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations of two-tier client-server patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some of the main limitations of client-server patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited extensibility, scalability, and reliability**: In most of the implementations,
    application data and business logic reside on the same central server. This aspect
    impacts the system extensibility, scalability, and reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Excessive network bandwidth usage:** communication between and the client
    and the server consumes excessive bandwidth. Request and response data often need
    to be converted to a common format as they might have a different format of representation
    on the client side and the server side. This aspect also contributes to additional
    traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To overcome these limitations of the two-tier client server pattern, three-tier/multi-tier
    client-server architecture was developed. Most of the applications of the present
    day, which are developed using the client-server architecture, are based on the
    three-tire/multi-tier architectural model, which is discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the slight difference in their architecture, three-tier and multi-tiered
    architectures are handled as separate topics in this chapter, though they may
    be referred to interchangeably in many other forums.
  prefs: []
  type: TYPE_NORMAL
- en: Three-tier client-server architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The three tiers that are present in this architecture are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The presentation tier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application or business logic tier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data tier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The diagram depicting the three-tier client-server architecture is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43ab3182-df6d-4495-8ce0-c2705abf261f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In a three-tier architecture, the different layers are developed and maintained
    as different modules, sometimes on different platforms as well. The following
    are the functions of each layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation tier**: This is the first and topmost layer which is present
    in the application. This tier provides presentation services, that is presentation,
    of content to the end user through GUI. This tier can be accessed through any
    type of client device like desktop, laptop, tablet, mobile, thin client, and so
    on. For the content to the displayed to the user, the relevant web pages should
    be fetched by the web browser or other presentation component which is running
    in the client device. To present the content, it is essential for this tier to
    interact with the other tiers that are present preceding it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application tier**: This is the middle tier of this architecture. This is
    the tier in which the business logic of the application runs. Business logic is
    the set of rules that are required for running the application as per the guidelines
    laid down by the organization. The components of this tier typically run on one
    or more application servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data tier**: This is the lowest tier of this architecture and is mainly concerned
    with the storage and retrieval of application data. The application data is typically
    stored in a database server, file server, or any other device or media that supports
    data access logic and provides the necessary steps to ensure that only the data
    is exposed without providing any access to the data storage and retrieval mechanisms.
    This is done by the data tier by providing an API to the application tier. The
    provision of this API ensures complete transparency to the data operations which
    are done in this tier without affecting the application tier. For example, updates
    or upgrades to the systems in this tier do not affect the application tier of
    this architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Benefits of the three-tier architecture are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability** and **flexibility**: The major advantage of this architecture
    is its scalability and flexibility. Each tier of this architecture is a modular
    component, that is, any kind of operations like changes or upgrades done to one
    tier does not affect or cause downtime to the other tiers. Less functionality
    performed by the client and no high-end configuration is required for client systems
    which are present in the presentation tier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased security**: Splitting of tasks among the various tiers provides
    increased security to each tier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though three-tier architectural patterns offer several benefits, there are still
    limits on the scalability of the architecture when it comes to networks like internet
    which require massive scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations for using three-tier architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some of the scenarios in which the three-tier architecture
    is a good choice:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are developing an application with limited functionality/configuration
    for client systems. In this case, other components of the architecture like business
    logic and data logic can be distributed to other tiers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are in the process of developing an application to be deployed within
    an intranet where all the servers are located within a specific private network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are developing an internet application where there are no security constraints
    for deploying the business logic on the public networks of web or application
    servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A variant of the three-tier architectural pattern which offers massive scalability
    is the *n*-tier architectural pattern. In an *n*-tier architectural pattern, the
    total number of tiers is *n*, where *n* has a value greater than three in order
    to differentiate it from the three-tier architectural pattern. In *n*-tier architecture,
    the application tier (which is the middle tier) is split into many tiers. The
    distribution of application code and functions among the various tiers varies
    from one architectural design to another. The diagram of the *n*-tier architectural
    pattern is depicted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bce7f1a0-002c-4c49-b6bd-0ad51cd2781e.png)'
  prefs: []
  type: TYPE_IMG
- en: Design considerations for n-tier architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some of the scenarios in which *n*-tier architecture is a
    good choice:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are architecting a system in which it is possible to split the application
    logic into smaller components that could be spread across several servers. This
    could lead to the design of multiple tiers in the application tier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the system under consideration requires faster network communications, high
    reliability, and great performance, then *n*-tier has the capability to provide
    that as this architectural pattern is designed to reduce the overhead which is
    caused by network traffic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of n-tier architecture (shopping cart web application)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can illustrate the working of an *n*-tier architecture with the help of an
    example of a shopping cart web application which is present in all e-commerce
    sites. The shopping cart web application is used by the e-commerce site user to
    complete the purchase of items through the e-commerce site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the application should have several features which enable the user to
    do activities like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding selected items to the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the quantities of items in the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making payments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client tier, which is present in the shopping cart application, interacts
    with the end user through a GUI. The client tier also interacts with the application
    that runs in the application servers present in multiple tiers. Since the shopping
    cart is a web application, the client tier contains the web browser. The presentation
    tier present in the shopping cart application displays information related to
    the services like browsing merchandise, buying them, adding them to the shopping
    cart, and so on. The presentation tier communicates with other tiers by sending
    results to the client tier and all other tiers which are present in the network.
  prefs: []
  type: TYPE_NORMAL
- en: The presentation tier also makes calls to database stored procedures and web
    services. All these activities are done with the objective of providing a quick
    response time to the end user. The presentation tier plays a vital role by acting
    as a glue which binds the entire shopping cart application together by allowing
    the functions present in different tiers to communicate with each other and display
    the outputs to the end user through the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: In this *n*-tier architecture, the business logic which is required for processing
    activities like calculation of shipping cost and so on are pulled from the application
    tier to the presentation tier. The application tier also acts as the integration
    layer and allows the applications to communicate seamlessly with both the data
    tier and the presentation tier. The last tier which is the data tier is used to
    maintain data. This layer typically contains database servers. This layer maintains
    data independent from the application server and the business logic. This approach
    provides enhanced scalability and performance to the data tier.
  prefs: []
  type: TYPE_NORMAL
- en: The distributed client-server architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *n*-tier client-server architecture used for the shopping cart web application,
    which is discussed in the earlier section, is an ideal example of a distributed
    client-server architecture. Distributed architectures typically have some kind
    of backend host components (such as Mainframe, Database server, and so on), an
    intelligent client in the frontend, and multiple agents in the middle, which takes
    care of all activities pertaining to transactions like transaction processing,
    security, handling messages, and so on, and a network for communication.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95677737-8b64-44ef-a5fb-4a903482fa83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of the key concepts associated with distributed architectures are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction processing**: Transaction processing is the automated processing
    of transactions in order to update a shared database. A transaction processing
    application in general will have many users who are concurrently interacting with
    the system in order to process business transactions on a shared database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transaction processing monitor** (**TP monitor**): The main task of the TP
    monitor is to manage the flow of transactions through a client server system efficiently.
    The TP monitor also works to ensure that simultaneous transactions which are happening
    on a shared database do not cause any inconsistency to the data which is present
    in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TP monitors also provide the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: They help in setting up back and forth connections between client and server
    components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide services that help in transaction-tracking, load balancing, and
    the capability to restart servers and the queues present in them automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motivation for development of web application patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the web applications are highly interactive in nature. This means that
    when there is a change to the data, it should be reflected in the UI instantaneously
    without any further delay. To add on to this scenario, different users of the
    application may demand outputs in various formats like excel sheets, bar charts,
    pie charts, dashboards, and so on, as depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c09d80af-06d8-49d7-a33d-8587bbed8bb4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When there is a change in the functionality of a specific application, the
    user interface of the application should also be able to reflect the changes with
    the addition of new options like menus, dropdowns, and so on. This emphasizes
    the fact that user interfaces of web applications are always subjected to series
    of change requests. These **user interfaces** (**UIs**) change requests can happen
    in various circumstances, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A request from the end user/customer for a change in the UI feature for various
    reasons like ease of use, adaptability, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting of a system from one platform to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrades of system to new versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to database design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From this, we can infer that user interfaces are always a target for changes.
    Different users of an application place different types of conflicting requirements
    on the user interface in order to make their operations easy. For example, an
    executive who uses a form-based interface for data entry may need more ease of
    use in the form based interface, whereas an administrator who is in charge of
    reporting may require more feature addition to the reporting interface. All this
    warrants a user interface where the design is flexible enough to accommodate all
    types of UI paradigms. It is impossible to build a system with this kind of flexibility
    if the UI is tightly tied to the functional core of the application. In such a
    scenario, it becomes necessary to develop and maintain several types of software
    applications, one for each type of user interface. The following are the main
    aspects that need to be kept in mind for the design of design patterns for web
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: It should be possible to represent the same information in different formats
    in different windows, for example, in one window as a pie chart, in another window
    as an excel sheet, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be possible to change the UI easily even at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be possible to provide various look and feel standards and changes
    to the user interface should not imply changes to the application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these factors are the motivation for the design of the **model view controller**
    (**MVC**) pattern, which is predominantly used for the design and development
    of mobile and web applications. The following are the main components of the MVC
    architectural pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: The function of the model component of MVC is to encapsulate core
    data and functionality. The model component has the capability to function independently,
    irrespective of output representations and input behavior. In design terms, the
    model essentially represents a set of classes which are used to depict the business
    logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: The function of the view component is to display information to the
    end user. The view component gets the data to be displayed from the model. A model
    can have any number of views depending on the requirements of the application.
    In design terms, the view essentially depicts the UI components such as HTML,
    jQuery, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: Each view is associated with a controller. Controllers get
    inputs, usually in the form of events from the user. The events could be received
    in the form of mouse clicks, keystrokes from the keyboard, and so on. These event
    are converted to service requests and are passed on to the model or the view.
    The controller is the only component through which the user interacts with the
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The separation of model, view, and controller components provide flexibility
    by allowing multiple views of the same model. In case the user changes, the model
    data using the controller component of one view, all other views which use the
    same data should be updated immediately to reflect the new changes. This is taken
    care of by the model by notifying all the views whenever its data changes. The
    view in turn takes the updated data from the model and updates all relevant views.
    All these sequences of actions necessitate the presence of a change propagation
    mechanism in the MVC model. This change in the propagation mechanism is explained
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Workings of the MVC pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The model component exports procedures for application-specific processing.
    These procedures are called by the controller components in response to inputs
    received from the user. The model component also provides functions that can be
    used by the view component to access its data.
  prefs: []
  type: TYPE_NORMAL
- en: View components are used for presenting information to the end user. There may
    be different views for providing information in different ways as per the requirements
    of users. Each view is associated with an update procedure that is activated by
    the change propagation mechanism. The change propagation mechanism works by maintaining
    a registry of all the dependent components that are present within the model.
    All the related views and controllers that will be impacted by changes to these
    components also register their need so that they are kept informed of all the
    changes. Any change in model state in turn triggers the change-propagation mechanism.
    With the help of the update procedure, the view component retrieves the most updated
    data values from the model and displays them on the user interface screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The controller component accepts user input in the form of events. The format
    in which this event data is delivered to the controller is dependent on the user
    interface platform. But in general, each controller executes an event-handling
    procedure that is associated with an event. The overall working of the MVC pattern
    is depicted in the graphic which is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0a0d5b3-4f96-4a83-8634-f816cf05f980.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will discuss a popular programming framework which is
    developed using the MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The ASP.Net framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In ASP.Net, the patterns for the view component and the controller component
    are well-defined. Only the pattern for the model component is left to be designed
    by the developer as per the specific application requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '**View**: The files that handle the responsibilities associated with the view
    component are ASPX and ASCX. In this design, the view object typically inherits
    from the controller object.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Controller**: The responsibilities of the controller component are split
    among two components. The generation and passing of events is done by the framework
    and, to be more speciﬁc, is done by the Page and Control classes. The event handling
    is taken care of by the code-behind class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: ASP.NET does not necessarily require a model. It is left to the
    choice of the developer whether to create a model class, or to forgo it. In case
    a model is not used, the event handlers in the controller can be used to perform
    any calculations and also ensure data persistence.'
  prefs: []
  type: TYPE_NORMAL
- en: The model view presenter (MVP) pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MVP pattern is a variant of MVC pattern and is mainly used for the development
    of user interfaces for web applications. It was mainly designed to make it easier
    to perform automated unit testing. The graphic given here depicts the architecture
    of the MVP pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2010ba93-0258-4e5e-bea1-603711a678c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The various components of the MVP pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: This component specifies the data to be displayed/sent from or to
    the user interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: The presentation logic lies in the Presenter component. It acts on
    both the model and the view components. It is responsible for fetching data from
    the model, applying appropriate logic, and sending it back for display in the
    view. When compared to the view and controller components in the MVC model, the
    view and presenter components present in the MVP pattern are fully decoupled from
    each other and they communicate by means of an interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Presenter**: The view component just acts as a passive interface. It displays
    data from the model and sends user inputs and commands to the presenter component.
    These user inputs and commands will be used to perform operations on the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of the key considerations about the MVP pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The end user interacts only with the View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One View component is mapped only to one Presenter component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View references Presenter component but it has no reference to Model component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pattern facilitates two way communication between the View component and
    the Presenter component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the common applications that use this pattern are ASP.Net forms and
    Windows forms.
  prefs: []
  type: TYPE_NORMAL
- en: The model-view-viewmodel (MVVM) pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MVVM is a popular pattern used for developing reusable and easily testable
    web applications. MVVM is a modern variant of MVC and the core objective is to
    have true separation between the Model and the View components. The main components
    of the pattern are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ViewModel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The layered architecture of the pattern is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b882d4c6-80c9-48a1-ae8b-c7247c0ad3e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The various components of the MVVM pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: This component represents business logic and data. This means that
    the business logic that specifies how the data should be manipulated is present
    in the Model component.'
  prefs: []
  type: TYPE_NORMAL
- en: '**View**: This component represents the UI components and will essentially
    contain UI elements such as CSS, HTML, and so on. It is only responsible for representing
    the data and does not perform any manipulations on data. However, unlike MVM,
    the View in MVVM is an active component and contains behaviors, events, and data-bindings
    that require information about the underlying model and viewModel components.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ViewModel**: The ViewModel is a very important component of the architecture
    as it helps in presentation separation, that is, it helps to keep the view separate
    from the model and, at the same time, acts as a controller that supports interaction
    and coordination between the View and the model components. The ViewModel component
    also contains commands and methods that help maintain the state of the view and
    help to manipulate the Model as per the actions, which are performed on the view.
    The ViewModel component also helps to trigger events in the view component itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Key advantages of the MVVM pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the key advantages of using the MVVM pattern for design:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintainability**: In this pattern, the clear separation of the different
    pieces of code makes it easier to maintain the code and also ensures quick releases
    using the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: In this pattern, the different pieces of code are very granular
    and are a key away from the core functional logic. This makes unit testing very
    easy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensibility**: The granular pieces of code facilitate the reuse of code
    and also allows quick modification of code snippets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design considerations for using the MVVM pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MVVM pattern is a right choice for design web applications that require
    the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Thorough unit testing of various components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development of applications using the concept of reusable code and development
    of applications which can generate reusable snippets of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility to change the user interface without changing the code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will discuss a sample framework that is built using
    the MVVM pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Prism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prism is a framework that is built using the MVVM pattern. It helps in the
    design and development of flexible and easy to maintain **Windows presentation
    foundation** (**WPF**) desktop applications. It also helps to build rich internet
    applications using the Microsoft Silverlight Browser plugin. The following are
    the key features of the Prism framework:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses architectural pattern that supports important design concepts such as
    separation of concerns and loosely coupled components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prism helps in the design of code snippets/components that can be easily integrated
    to form an application. Applications of this type which are formed by integrating
    components are called composite applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of the important features of Prism:'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MVVM pattern, which in turn provides a bindable base class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a flexible ViewModelLocator, which allows the View and ViewModel component
    to be hooked up in a loosely coupled way. It provides full support for the development
    of modular applications as it has several loosely coupled class libraries. These
    libraries can be brought together at runtime in the form of an application for
    the end user. The code base still remains decoupled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports a rich set of navigation features that supports features like forward
    navigation, backward navigation, and so on. The navigation stack of prism allows
    ViewModels to be part of the navigation process directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prism supports the concept of Pub/Sub events. These refer to a mechanism of
    loosely coupled events where the publisher and subscriber components can communicate
    with the help of events. It is not necessary that the publisher or subscriber
    components should have explicit references or the same lifetimes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns for web application development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from the MVC, MVP, and MVVM architectural patterns, which were discussed
    in the previous sections, there are several design patterns that are used for
    the design of applications along with these patterns. In this section, we will
    discuss some of the commonly used design patterns for web application design.
    These patterns and their functionalities are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pattern name** | **Functionality** |'
  prefs: []
  type: TYPE_TB
- en: '| **Interpreter design pattern** | This pattern is widely used in the development
    of menus for applications like editors and Integrated Development Environments
    (IDEs). This pattern works by interpreting instructions that are written in the
    form of a language grammar or as notations. This pattern involves the implementation
    of an expression interface, which is used to interpret a given context. |'
  prefs: []
  type: TYPE_TB
- en: '| **Mediator design pattern** | The key feature of this pattern is that it
    allows objects to interact with each other without knowing their structure. This
    is made possible by defining an object by encapsulating how they interact with
    other objects. This feature also helps in easy maintainability and the reuse of
    code. This pattern is also widely used for developing menus for applications like
    editor and IDE. |'
  prefs: []
  type: TYPE_TB
- en: '| **Memento design pattern** | The key feature of this pattern is that it helps
    to capture the present state of an object and store it as is so that it can be
    used again at a later point in time when needed without actually breaking the
    rules associated with object encapsulation. |'
  prefs: []
  type: TYPE_TB
- en: '| **Observer design pattern** | This pattern is used in scenarios where there
    exists a one to many relationship between objects. In such scenarios, if an object
    is modified, it becomes necessary to notify its dependent objects about the changes.
    That is the main motivation for the use of observer design pattern. This pattern
    allows a single object called subject to notify its state changes to all other
    observer objects that are dependent on it. |'
  prefs: []
  type: TYPE_TB
- en: '| **State design pattern** | This pattern is used in scenarios where there
    exists a one to many relationship between objects. In such scenarios, if an object
    is modified, it becomes necessary to notify its dependent objects about the changes.
    This pattern is primarily used in situations where it is necessary to alter the
    behaviour of an object when there is a change in its internal state. This pattern
    works by creating an object to represent various states and an associated context
    object whose behaviour changes as per the state changes of the created object.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Strategy design pattern** | This pattern provides flexibility to a client
    to choose any specific algorithm from a group of algorithms at runtime. It also
    provides a simple way for the client to access the algorithm. This pattern works
    by removing an algorithm from its host class and placing it in a separate class.
    This will help in the prevention of code-related issues that will arise if the
    algorithm is present in the host class. |'
  prefs: []
  type: TYPE_TB
- en: '| **Template method design pattern** | This pattern provides the feature to
    define basic steps of algorithm execution while allowing specific execution steps
    to be changed. This is very similar to the Strategy design pattern; the only difference
    is that it allows modification of certain algorithm steps instead of the entire
    algorithm. |'
  prefs: []
  type: TYPE_TB
- en: '| **Visitor design pattern** | This pattern provides flexibility to create
    and perform new operations on a set of objects without altering the structure
    of the object and its associated classes. This pattern allows the loose coupling
    of components and hence new operations can be done on them without altering the
    existing object structure. |'
  prefs: []
  type: TYPE_TB
- en: '| **Bridge pattern** | This pattern provides the flexibility to separate an
    abstraction from its implementation. This allows both of them to be modified independently.
    The separation of abstraction from implementation is done by means of an interface
    that provides a bridge between the abstraction class and implementer class. This
    separation also makes the implementer class functionality independent of the abstraction
    class functionality. |'
  prefs: []
  type: TYPE_TB
- en: '| **Composite pattern** | This pattern provides the flexibility to treat a
    group of objects and a single object in the same manner. The composite pattern
    arranges objects in the form of a tree structure to represent part as well as
    whole hierarchies. |'
  prefs: []
  type: TYPE_TB
- en: '| **Factory method design pattern** | This pattern provides the flexibility
    to create an object without exposing its creation logic. In this pattern, an interface
    is used for creating an object. The subclass decides which class needs to be instantiated.
    The creation of an object is done only as and when it is required. |'
  prefs: []
  type: TYPE_TB
- en: '| **Builder design pattern** | This pattern allows us to build a complex object
    by using a step by step approach. A specialized interface called the Builder interface
    specifies the steps that are required to build the final object. This Builder
    interface is independent of the objects creation process. A class known as Director
    controls the object creation process. Another speciality of this pattern is that
    it specifies a way to separate an object from its construction. The same construction
    method can be used to create multiple representations of the same object. |'
  prefs: []
  type: TYPE_TB
- en: '| **Adapter pattern** | This pattern is used when it is required to provide
    a bridge between two incompatible interfaces. This pattern provides a single class
    called adapter that facilitates communication between two independent or incompatible
    interfaces.**For example:** A card reader acts as an adapter for the memory card
    present in the laptop. This is done by plugging in the memory card into the card
    reader. The card reader is then plugged into the laptop so that the memory card
    can be read through the laptop. |'
  prefs: []
  type: TYPE_TB
- en: The front controller pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another architectural pattern that is popular in web application development
    is the front controller pattern. This pattern ensures that there is only one point
    of entry for all incoming requests. A single piece of code called the controller
    handles all the incoming requests and then delegates the processing of each request
    to other application objects, which are present in the system. This core feature
    of the pattern helps the web application developers by providing necessary flexibility
    using the reuse of code. The architecture of the front controller pattern is depicted
    in the following graphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/797640eb-7f26-4753-9d48-c661ee130fdb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the different components of this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Front controller**: This component handles all types of incoming requests
    for the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dispatcher**: This component is used to dispatch a request to a specific
    handler for further processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Views**: These correspond to the objects for which the requests are made'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will discuss a popular framework that is developed using
    the front controller pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Spring framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring, a very popular framework for web application development, follows two
    architectural patterns for its design: the front controller pattern and the MVC
    pattern. The architecture is depicted in the following graphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1aa38905-4d60-4952-97ad-1b2c3314ffad.png)'
  prefs: []
  type: TYPE_IMG
- en: The Dispatcher Servlet component is the single servlet that functions as the
    front controller and handles all incoming requests. The Dispatcher Servlet then
    calls Handler Mapping in order to find an object that could service the request.
    The request is then given to the controller object so that the Dispatcher becomes
    free to perform functions associated with the fulfilment of business logic as
    per the user's request. The controller object returns an encapsulated object that
    contains the model object and view object. This is represented by the ModelandView
    class. If the ModelandView contains the logical name of the view, the Dispatcher
    Servlet calls the View Resolver to get details of the actual view object from
    its logical name. The Dispatcher Servlet then gives the model object to the view
    object so that it can be displayed to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started the discussion with a two-tier client-server pattern.
    This is one of the earliest and oldest client-server patterns. With the growth
    of the information technology industry, this two-tier client server pattern was
    not sufficient to meet the infrastructure requirements. This led to the evolution
    of the three-tier client-server pattern followed by *n*-tier client-server pattern.
    Some other variants of the client-server pattern like the master-slave pattern,
    peer-to-peer pattern, and so on were also discussed in this chapter. The applications
    and the design considerations for each type of pattern was also discussed in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Web application development, which caught steam later could not use client-server
    architecture because of its inherent limitations. This led to the evolution of
    some patterns that were custom-made for the development of web applications. These
    patterns needed the basic flexibility to be able to change the UI without altering
    the code base. The second half of this chapter dealt mainly with these patterns.
    The main patterns that were discussed in this part were MVC, MVP, MVVM, and the
    front controller.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the common design patterns that are used along with these patterns were
    also discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional reference for this chapter: [http://www.dotnettricks.com/learn/designpatterns/adapter-design-pattern-dotnet](http://www.dotnettricks.com/learn/designpatterns/adapter-design-pattern-dotnet)'
  prefs: []
  type: TYPE_NORMAL
