- en: Chapter 4. Adding Sound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have undoubtedly noticed, the little game demo we made in the previous
    chapter was a little lifeless without any sound. It goes to show how important
    sound and music really are to create the full experience of a game. Music sets
    the mood for the scene, and sound effects add more depth to the game world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: DirectSound versus XAudio2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of sound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DirectSound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XAudio2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DirectSound versus XAudio2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with user input and graphics rendering, we have a couple of options in the
    sound department as well; they are **DirectSound** and **XAudio2**. So let's take
    a look at these two.
  prefs: []
  type: TYPE_NORMAL
- en: First, there was DirectSound. When DirectSound was developed, game audio was
    still fairly simple. Games would play a single `.wav` sound file when a given
    event happened in the game world, and DirectSound allowed for improved performance
    if your PC had a sound card in it by offloading sound processing from the **CPU**
    (**Central Processing Unit**) to the sound card. This is very similar to how graphic
    cards handle graphics processing, allowing the CPU to do other things.
  prefs: []
  type: TYPE_NORMAL
- en: As time went on, the processing power of both PCs and gaming consoles increased
    greatly, and the simple sound model used by DirectSound was becoming insufficient
    for the increasingly complex sound systems that game developers were starting
    to create.
  prefs: []
  type: TYPE_NORMAL
- en: During development of the Xbox 360 gaming console, Microsoft realized that DirectSound
    just wasn't going to cut it. So, they created XAudio to meet the increasing demands
    of composers and sound designers in the video game industry. Meanwhile, Windows
    Vista (codenamed **Longhorn**) was also in development. The team working on that
    created a new audio API called **Longhorn Extensible Audio Processor**.
  prefs: []
  type: TYPE_NORMAL
- en: It wasn't long before both Xbox 360 and Windows Vista had launched, Microsoft
    turned their attention back to the idea of creating a cross-platform audio API
    to replace DirectSound. They had received positive feedback on their XAudio API
    from Xbox 360 game developers, but at the same time, the Longhorn Extensible Audio
    Processor API had some advantages over XAudio, such as providing a more streamlined
    and more efficient audio engine and a few additional features that XAudio did
    not have. So, Microsoft decided to take the best of both, and XAudio2 was the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this means we would obviously want to use XAudio2, right? The answer is
    yes, but that''s not the whole answer. But this raises another potential question:
    why is DirectSound still included in DirectX when it has been replaced? The answer
    is, of course, for backward compatibility. Removing DirectSound from DirectX would
    have broken all applications that were written using the DirectSound API. They
    left it in so that those applications would still work.'
  prefs: []
  type: TYPE_NORMAL
- en: As I said, XAudio2 is not quite the complete answer to the API we should use
    for the sound needs of our games. You may want to support DirectSound for users
    who may have older systems. However, XAudio2 is, as mentioned previously, a multi-platform
    API. You can use it to handle your sound needs in applications for Xbox 360, Windows
    Phone, and Windows PCs (Windows XP and higher).
  prefs: []
  type: TYPE_NORMAL
- en: For completeness, we'll take a look at both DirectSound and XAudio2 in this
    chapter, but first let's take a look at what sound really is and some of its properties.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of sound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into our sound programming, let's cover the basics of sound. We
    need to have a basic understanding of sound before we start doing our sound programming.
  prefs: []
  type: TYPE_NORMAL
- en: Sound is composed of waves. A **sound wave** is essentially just a pressure
    wave traveling through the air. When it hits your eardrum, a signal is then sent
    to the brain telling it about the sound wave that hit it. The brain converts this
    information into what we think of as a sound.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common attributes we give to sounds is the idea of **volume**.
    So what exactly is volume? Simply put, it is the amplitude of the sound waves.
    If you think of a drawing of a wave, the height of a wave is its amplitude. In
    other words, amplitude is how big the wave is. Look at the following diagram to
    see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The basics of sound](img/7389OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The amplitude or volume of a sound wave
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very important attribute of sound is the idea of **frequency**. So,
    on a drawing of a wave, its wavelength is simply how wide the wave is, and the
    length of the waves determines their frequency. Frequency refers to how often
    the waves hit, rather than to the length of a single wave. The higher the frequency
    of the sound waves, the higher the **pitch** of the sound is. Likewise, lower
    frequency sounds have a lower pitch. The term pitch of course refers to how high
    or low a sound is. The following diagram shows the concept of frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The basics of sound](img/7389OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The wavelength or frequency of a sound wave
  prefs: []
  type: TYPE_NORMAL
- en: Frequency is measured in **Hertz** (**Hz**). The term Hertz generally means
    cycles per second. So if we have a sound that is at 100 Hz, this means that 100
    sound waves hit our eardrums per second. The unit Hertz can be applied to any
    event that happens regularly, such as the ticking of a clock, the beating of a
    heart, or the speed of a computer processor. The speed of a modern computer processor
    is generally given in **Gigahertz** (**GHz**) these days. That's pretty fast if
    you consider that one **Kilohertz** (**KHz**) is 1,000 Hz, one Megahertz is 1,000
    KHz (or 1 million Hertz), and one Gigahertz is 1,000 MHz (or 1 billion Hertz).
    The hearing range for humans is on average from around 20 to 20,000 Hz.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, that's enough of that since your head probably "Hertz" now. Get it? Anyway,
    we know what the frequency of a sound is now. So, let's move on and look at the
    idea of **stereo** sound.
  prefs: []
  type: TYPE_NORMAL
- en: Stereo sound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a sound is played in stereo, it means that the sound has two channels:
    one channel is played by the left speaker while the other is played by the right
    speaker. This gives a bit of a 3D effect to the sound for the listener. In other
    words, the sound is composed of two separate sound tracks, one for each speaker.'
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to the concept of a **phase**. You can think of this as referring
    to how well the channels in a sound are synced with one another. If the channels
    are perfectly in sync, they are said to be *in phase*. Otherwise, they are said
    to be *out of phase*. So if you delay one of the channels by a fraction of a second,
    your sound is out of phase because the sound from the left and right speakers
    is not correctly synced with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last interesting property of sound that we will take a quick look
    at. It is directly linked to the concept of a phase. The following diagram shows
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stereo sound](img/7389OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous figure, we have two sets of sound waves: one is continuous,
    and the other is dotted. As you can see, the dotted one is the continuous wave
    inverted. So the result is that we have two audio tracks, where one has the opposite
    phase of the other. So what happens when we play this sound? Nothing! That''s
    right, absolutely nothing. Why? Because sound waves with opposite phases will
    cancel each other out. In other words, if two sound waves of the same amplitude
    and frequency coincide with each other, but one of them is inverted, then they
    cancel each other out. The second half of the previous diagram shows this. There
    are no sound waves left since they canceled each other out, and thus we have silence.'
  prefs: []
  type: TYPE_NORMAL
- en: DirectSound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add some simple sound to the 2D world we made in the previous chapter.
    So, open Visual Studio and let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we get started, it should be noted that the music track we are using
    in this chapter (`lost_village_128.wav`) is courtesy of [http://wrathgames.com/blog](http://wrathgames.com/blog)
    (*WrathGames Studio*). So, a big thanks goes out to them.
  prefs: []
  type: TYPE_NORMAL
- en: This sound file is, of course, included in the downloadable code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `TileGameWindow.cs` file. First of all, we need to add the following
    `using` statements to the top of the file so that we can use DirectSound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add some new member variables to this class. The first one
    we will add is a Boolean variable named `m_UseDirectSound`. This variable can
    be set to either `true`, or `false`. When it is set to `true`, the program will
    use DirectSound, but if this variable is set to `false`, the program will use
    XAudio2\. The following is the declaration of this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create three more member variables that will hold our `DirectSound`
    objects. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first variable will hold our `DirectSound` object. The second one is the
    primary sound buffer, and the third variable is a secondary sound buffer that
    will store the sound we want to play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add a new method called `InitDirectSound()` to the `TileGameWindow`
    class. The following is the code for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first line in this method creates our `DirectSound` object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a real program, you would have much better error handling than we have in
    our demos in this book. It has been left out to save space.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we would need to handle the situation where the creation of the
    `DirectSound` object fails. This could happen, for example, when the user does
    not have a DirectSound-compatible sound card installed in his/her system. If this
    happens, SlimDX will throw a `DirectSound` exception (or error). We would catch
    the exception by putting a `try` block around the initialization code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `catch` block, we input our code to handle the error condition. In
    this case, we just make the constructor return without finishing initialization.
    This prevents the program from crashing, but it still won't work, right? (It won't
    have sound.) So, basically, if the initialization of the `DirectSound` object
    fails, the code in the `catch` block will run.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling is extremely important in real-world applications, so don't forget
    about it!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the cooperative level. The cooperative level determines the extent
    to which the system allows this program to use the device. This is because Windows
    is a multitasking environment and therefore multiple applications could be using
    the sound device at the same time. Cooperative level is the way the system makes
    sure that we don't have two programs trying to use the device at exactly the same
    time, as this can cause problems. As you can see, we set the cooperative level
    to `CooperativeLevel.Priority` here. This is usually what you'll want to set it
    to if your application is a game.
  prefs: []
  type: TYPE_NORMAL
- en: The next three lines of code create our `PrimarySoundBuffer` object and give
    it the `BufferFlags.PrimaryBuffer` flag.
  prefs: []
  type: TYPE_NORMAL
- en: The next chunk of code sets up our `SecondarySoundBuffer` object. It starts
    with a `using` block that creates a `WaveStream` object that is using our sound
    file. Inside the `using` block, we create a `SoundBufferDescription` object that
    we will use to specify the properties of our `SecondarySoundBuffer` object when
    we create it. We set the `SizeInBytes` property to the size of our wave file.
    Then, we set the `Flags` property to have the `BufferFlags.ControlVolume` flag.
    Having this flag set allows us to control the volume of the sound. There are other
    buffer flags too, of course. Some examples are `ControlPan`, which lets you control
    the left/right balance of the sound, `ControlFrequency`, which lets you control
    the frequency of the sound, and `ControlEffects`, which allows you to apply effects
    to the sound.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we get the wave format from the `WaveStream` object and copy it into the
    `Format` property of the `SoundBufferDescription` object. Then, we create the
    `SecondarySoundBuffer` object using the `DirectSound` object, and the `SoundBufferDescription`
    object we just filled out.
  prefs: []
  type: TYPE_NORMAL
- en: The next block of code loads our sound file. The first line here creates a byte
    array of the same size as our wave file. The next line reads all of the data from
    the wave file into the byte array. The third line copies the data from the byte
    array into our `SecondarySoundBuffer` object. The second parameter here is the
    offset into the buffer that we want to start writing the data at. Since we want
    to start at the beginning of the buffer, we specify `0` for this. If we specified
    `10`, the wave data would be written starting `10` bytes in from the beginning
    of the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: The final line tells the `SecondarySoundBuffer` object to start playing our
    sound by calling its `Play()` method. The first parameter is the priority for
    this sound. The second parameter specifies flags that affect how the sound is
    played. In this case we are using `PlayFlags.Looping` to make our music loop continuously.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need your sound file to be properly set up for looping. A sound file
    that is not meant for looping will probably not sound good when it loops back
    to the start. A sound file that is meant for looping has a smooth transition at
    the end, so that the end transitions nicely into the start so that the sound can
    repeat seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: The `SecondarySoundBuffer` object has other methods as well. The `Pause()` method,
    for example, will pause the sound. When you start playing it again, it will resume
    from where it left off. The `Stop()` method, on the other hand, stops playback
    and also rewinds the sound back to its beginning. So when you start the sound
    playing again, it will start over from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we need to go back and add a line of code into the constructor
    to call this new `InitDirectSound()` method that we have created. For that, we
    simply add the following `if` statement to the end of the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are not quite finished though. We still need to dispose of our `DirectSound`
    objects when we are done with them. So, add the following code into the managed
    section of our `Dispose(bool)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With that, our DirectSound code is done. If you run the program now, you should
    notice music playing in our 2D tile-based world. You may also notice that the
    music will pause if the window loses focus. If you then click on the window again
    to give it the focus, the music will start back up where it left off.
  prefs: []
  type: TYPE_NORMAL
- en: We should also talk about the sound buffer's `Status` property, which you can
    access to find out the current status of your sound buffer. For example, you can
    use this to check if the sound is currently playing or looping, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: Volume control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section of code, we mentioned several of the buffer flags, and we set
    the `BufferFlags.ControlVolume` flag on our `SecondarySoundBuffer` object, which
    tells DirectSound that we want the capability to change the volume of the sound.
    We didn't actually mess with this, but to change the volume, you would simply
    change the value of the sound buffer's `Volume` property. In DirectSound, volume
    is specified in 100th of a **decibel** (**dB**). The valid range for this property
    is `0` to `10,000`. Also, note that the maximum value of `10,000` represents the
    original volume of the sound. As you can see, this means that DirectSound does
    not support amplification, as is stated in their documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Frequency control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is similar to controlling the volume. You can change the frequency of the
    sound by setting the `BufferFlags.ControlFrequency` flag and then changing the
    value of the sound buffer's `Frequency` property. The valid range of values for
    this property is `100` to `100,000`. If you want to use the original frequency
    of the audio track, set this property to a value of `0`. If you wanted to double
    the playback speed of your sound for example, you would need to double its frequency.
  prefs: []
  type: TYPE_NORMAL
- en: Pan control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you set the `BufferFlags.ControlPan` flag on the buffer, you can change the
    left/right balance of the sound by editing the sound buffer's `Pan` property.
    If you shift it right, the sound will come out of the right speaker more than
    the left. The valid range of values for this property is `-10,000` to `10,000`.
    At `-10,000`, the sound will only come out of the left speaker, and at `10,000`
    it will only come out of the right speaker. A value of `0` specifies the center,
    or in other words, the sound will come out of both speakers equally.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, more flags besides these ones too and other effects that
    you can apply to your sound, but we don't have room to cover them here. These
    flags are all defined in the `BufferFlags` enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need to set the proper buffer flags as mentioned previously, before you
    can use these various controls on your sound.
  prefs: []
  type: TYPE_NORMAL
- en: XAudio2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XAudio2 is, of course, newer and more powerful than DirectSound. We will add
    some more code to the same file we've spent the first part of this chapter working
    on (`TileGameWindow.cs`).
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we first need to add some `using` statements at the top of the file,
    so that we can use XAudio2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will create some member variables to hold our `XAudio2` objects. This
    time there are four of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first one, `m_XAudio2`, will hold our `XAudio2` object. The second one will
    hold our **mastering voice** . In XAudio2, the `MasteringVoice` class is used
    to represent the sound output device. The third variable is the buffer that we
    will store our sound in. Lastly, we have a `SourceVoice` object. This is used
    to submit our audio data to the `MasteringVoice` object for processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we should do is edit the `if` statement we added to the bottom
    of the constructor earlier in this chapter. The following code needs to be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following change has to be made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This change makes it such that the program will use XAudio2 instead of DirectSound
    if the `m_UseDirectSound` member variable is set to `false`. So, go to the top
    of the class file, find that variable, and change its value to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that taken care of, we need to create the `InitXAudio2()` method so that
    if the `m_UseDirectSound` variable is set to `false`, the method is called. The
    following is the code for this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This method can be a bit confusing, so I left the comments in the previous code
    listing. As you can see, the first thing we do is create our XAudio2 object. Then,
    we have an `if` statement that checks to see if we have any valid sound devices
    to use. If not, then the `XAudio2` object's `DeviceCount` property will return
    `0`. In this case, if no sound device is available, we simply return and don't
    try to continue initializing XAudio2, since this would probably cause a crash.
    This goes back to the tip in the *DirectSound* section of this chapter; error
    handling is very important in a real game, so don't forget it or put if off! Next,
    we create the `MasteringVoice` object. I know you're probably thinking something
    along the lines of "what the heck is a mastering voice?". Well, it is simply a
    class that represents the audio output device; however, you cannot submit an audio
    buffer directly to the mastering voice object. We will use our `SourceVoice` object
    to do that in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a `using` block similar to the one we have in our `InitDirectSound()`
    method. It opens our sound file so we can get the audio data and put it into our
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the `using` block will automatically dispose of our `WaveStream`
    when program execution reaches the end of the `using` block, and that `using`
    blocks only work like this with types that implement the `IDisposable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The first four lines of code inside the `using` block set up our audio buffer.
    The first one creates the `AudioBuffer` object. The second line sets the buffer's
    `AudioData` property to our `WaveStream` object to get the audio data from the
    `.wav` file and into our audio buffer. The third line sets the buffer's `AudioBytes`
    property to the length of the `.wav` file, so the buffer knows how much data we
    have shoved into it.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code tells XAudio2 that we want to loop this sound. This is
    done by setting the `LoopCount` property to `XAudio2.LoopInfinite`. The `LoopCount`
    property sets how many times we want to loop the sound. You can set the start
    position for the loop and the end position via the `AudioBuffer`'s `BeginLoop`
    and `EndLoop` properties. This is not necessary if your audio file already has
    looping data in it. In this case these properties are already set for us based
    on the data from the file. Note that the `AudioBuffer` class also has the `PlayBegin`
    and `PlayLength` properties that let you set the portion of the sound that you
    wish to play. These properties are set to the beginning and end of the sound file
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `BufferFlags` enumeration we just used is not the same one we used when
    we were working with DirectSound. The DirectSound enumeration for buffer flags
    is `SlimDX.DirectSound.BufferFlags`, while the XAudio2 enumeration for buffer
    flags is `SlimDX.XAudio2.BufferFlags`.
  prefs: []
  type: TYPE_NORMAL
- en: The last three lines of code set up our `SourceVoice` object. This object is
    used to submit our audio data to the `MasteringVoice` object so that we can play
    it. So, the first of these three lines creates the `SourceVoice` object. The second
    line submits the audio data from our `AudioBuffer`, so that we can play it, and
    the last line plays our sound.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still one more little thing we need to take care of before we test
    our XAudio2 code. We need to add some new code into the managed section of our
    `Dispose(bool)` method. We have four objects we need to dispose of, so the code
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to test our new code. If you run the program, the music will
    keep looping until you close the program. You may also notice that unlike the
    DirectSound demo, if the window loses focus, XAudio2 just keeps playing the sound.
  prefs: []
  type: TYPE_NORMAL
- en: As we could in DirectSound, we can of course change the volume of our sound,
    or pan it in XAudio2\. So how do we accomplish this?
  prefs: []
  type: TYPE_NORMAL
- en: Volume control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can change the overall volume of our sound by changing the value of the `SourceVoice`
    object's `Volume` property. The value of this property is a floating point amplitude
    multiplier in the range -`2`^(24) to `2` ^(24). With a value of `1.0f`, there
    is no attenuation and no gain. A value of `0` results in silence. Negative values
    can be used to invert the phase of the audio.
  prefs: []
  type: TYPE_NORMAL
- en: Frequency control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adjusting the frequency of the sound is a bit different in XAudio2 than it is
    in DirectSound. In XAudio2, this is expressed as a frequency ratio. You can change
    it by altering the value of the `SourceVoice` object's `FrequencyRatio` property.
    A ratio of 1:1 means that there is no pitch change. This is the default value
    for this property. The valid range of values is `1/1,024` to `1,024/1`. At a ratio
    of 1:1,024 the sound's pitch is lowered by 10 octaves. On the other hand, a ratio
    of 1,024:1 will raise the pitch of the sound by 10 octaves. This property is of
    the type `float`, so you would have to calculate the ratio and pass it in. So
    if you want to pass in the ratio 1:1, this property would be set to a value of
    `1` since one divided by one is one.
  prefs: []
  type: TYPE_NORMAL
- en: To put this in context, the default ratio has a value of `1` as we just said.
    A value of `2` will double the frequency of the sound and will increase its pitch
    by one octave. A ratio of `0.5` will cut the frequency in half, making the track
    take twice as long to play and lowering its pitch by one octave. So for example,
    if you want to make a sound play at three times its normal speed, you would set
    the `FrequencyRatio` property to a value of `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each time you halve the frequency of the sound, you lower its pitch by one octave,
    and likewise, each time you double the frequency, you increase the pitch by one
    octave.
  prefs: []
  type: TYPE_NORMAL
- en: Pan control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Panning is a bit more complicated in XAudio2 than it is in DirectSound. There
    are a number of steps we must take to pan in XAudio2\. The first step is to create
    an output **matrix**. A matrix is simply a two-dimensional table of numbers. This
    simply contains the calculated panning values for each channel. We create the
    array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We created this array with eight elements, so that it can support speaker configurations
    up to 7.1\. For simplicity, our sample code here will simply be for stereo output.
    Next, we need to calculate or set the values for the left- and right-side speakers.
    So, in this case, we will create two more variables to hold these values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have both values set to `0.5`, which means the sound will play evenly from
    both speakers. If we set left to `1.0` and right to `0.0`, the sound will only
    play from the left speaker. And of course, if we set left to `0.0` and right to
    `1.0`, then the sound will only play from the right speaker. So as you can see,
    these values are in essence volume levels for the left and right channels of the
    sound.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to set these values into the correct indices in the `outputMatrix`
    array that we created previously. We need to get the **channel mask** first, so
    we know what speaker configuration we are dealing with. How you do this differs
    depending on whether you are developing for Windows 7 and earlier versions, or
    Windows 8\. For Windows 7 and earlier versions, we get the channel mask by using
    the `GetDeviceDetails()` method of the `XAudio2` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the parameter to the `GetDeviceDetails()` method is simply the index
    of the device to query, and `0` is the default device. On the Windows 8 version
    of XAudio2, we get the channel mask from the `MasteringVoice` object''s `ChannelMask`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this code is a bit shorter in the Windows 8 version of XAudio2
    compared to the DirectX SDK version (Windows 7 and earlier versions).
  prefs: []
  type: TYPE_NORMAL
- en: 'So what is this channel mask value? Well, it is simply a flag variable with
    various flags set in it to specify the speaker configuration of the PC. There
    is a flag for each different speaker type. These flags are defined by the `Speakers`
    enumeration (which is in the `SlimDX.Multimedia` namespace), and here they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BackCenter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BackLeft`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BackRight`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FrontCenter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FrontLeft`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FrontLeftOfCenter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FrontRight`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FrontRightOfCenter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SideLeft`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SideRight`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LowFrequency`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TopBackCenter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TopBackLeft`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TopBackRight`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TopCenter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TopFrontCenter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TopFrontLeft`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TopFrontRight`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, basically, these flags are used to indicate which types of speaker(s) are
    being used. You probably won''t need to use most of these flags, but I have included
    them in the previous list for reference purposes. However, the `Speakers` enumeration
    actually has a few more flags in it that make life a little simpler for us programmers.
    These flags differ from the previous list in that they do not specify a single
    speaker; instead, each of these flags is a combination of the flags listed previously.
    They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`All`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FourPointOne`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FivePointOne`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FivePointOneSurround`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mono`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Quadraphonic`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SevenPointOne`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SevenPointOneSurround`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stereo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Surround`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TwoPointOne`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use these simpler flags in our example code. Now that we know about
    these flags, we can use them to write the code that tests to see what the speaker
    configuration is. We will not use any of the flags from the first list, but rather
    we will just check for certain speaker configurations using some of the flags
    from the second set of flags listed previously. For example, an `if` statement
    checking to see if we have a configuration with two output channels would look
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If this code is checking for a configuration using two speakers, why are we
    setting four values here? The reason is because we have two channels of input.
    So for the left speaker, we set a volume level for both channels. The index `0`
    in the array is set to the value of our `left` variable. The index `1` of the
    array represents the volume level of the right channel. Since we don't want the
    right channel to play out of the left speaker at all, we set this to `0.0f`. Likewise,
    the elements `2` and `3` are setting the volume levels for the right speaker.
    We set element `2` to a value of `0.0f`, since we don't want the left channel
    sound to play out of the right speaker. And lastly, element `3` is set to our
    `right` variable. So, as you can see, for each speaker that will be outputting
    sound, we must set the volume levels for all of the channels that our sound has.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this sample code in the downloadable code for this chapter. This
    panning code is commented out though. Just uncomment it and play around with it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that better sound configurations, such as 5.1 or 7.1, will use more elements
    of this array, since they have more channels to set the volume levels for.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The XAudio2 object has many utility methods and constants that you will need
    in some cases. This is also true of many of the other major DirectX objects we've
    covered so far in this book, such as the `DirectSound` object earlier in this
    chapter, or the `Direct2D` object discussed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use the `.ogg` or `.mp3` files instead of the `.wav` files like
    we did in this chapter, you will need to write a method to load in each file type,
    since you will have to decode it before you can play it. Alternatively, you could
    of course convert your files to the `.wav` format and just use them like that.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we got into the world of sound programming. First we looked
    at what sound is and some of its basic properties. Then, we looked at the differences
    between DirectSound and XAudio2\. We added music to our 2D tile world demo using
    DirectSound. Next, we added some code to do the same thing but using XAudio2,
    and we created a member variable to control whether the program will use DirectSound
    or XAudio2 to play its sound. We also looked at how to control volume, frequency,
    and panning for a sound in both DirectSound and XAudio2\. In the next chapter,
    we will take a look at Direct3D and how to render simple 3D graphics.
  prefs: []
  type: TYPE_NORMAL
