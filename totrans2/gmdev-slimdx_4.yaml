- en: Chapter 4. Adding Sound
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章：添加声音
- en: As you have undoubtedly noticed, the little game demo we made in the previous
    chapter was a little lifeless without any sound. It goes to show how important
    sound and music really are to create the full experience of a game. Music sets
    the mood for the scene, and sound effects add more depth to the game world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如您无疑已经注意到的，我们在上一章中制作的那个小游戏演示在没有声音的情况下显得有些死气沉沉。这说明了声音和音乐对于创造游戏完整体验的重要性。音乐为场景设定了基调，而音效则为游戏世界增添了更多深度。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: DirectSound versus XAudio2
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DirectSound 与 XAudio2 的比较
- en: The basics of sound
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音的基本原理
- en: DirectSound
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DirectSound
- en: XAudio2
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAudio2
- en: DirectSound versus XAudio2
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DirectSound 与 XAudio2 的比较
- en: As with user input and graphics rendering, we have a couple of options in the
    sound department as well; they are **DirectSound** and **XAudio2**. So let's take
    a look at these two.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户输入和图形渲染一样，在声音方面我们也有一些选择；它们是 **DirectSound** 和 **XAudio2**。所以，让我们来看看这两个。
- en: First, there was DirectSound. When DirectSound was developed, game audio was
    still fairly simple. Games would play a single `.wav` sound file when a given
    event happened in the game world, and DirectSound allowed for improved performance
    if your PC had a sound card in it by offloading sound processing from the **CPU**
    (**Central Processing Unit**) to the sound card. This is very similar to how graphic
    cards handle graphics processing, allowing the CPU to do other things.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是 DirectSound。当 DirectSound 开发时，游戏音频仍然相当简单。当游戏世界中发生特定事件时，游戏会播放一个单一的 `.wav`
    音频文件，DirectSound 允许如果你的 PC 中有声音卡，通过将声音处理从 **CPU**（中央处理单元）卸载到声音卡来提高性能。这与图形卡处理图形的方式非常相似，允许
    CPU 做其他事情。
- en: As time went on, the processing power of both PCs and gaming consoles increased
    greatly, and the simple sound model used by DirectSound was becoming insufficient
    for the increasingly complex sound systems that game developers were starting
    to create.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，PC 和游戏机的处理能力都大幅提升，DirectSound 所使用的简单声音模型对于游戏开发者开始创建的日益复杂的音效系统来说已经不够用了。
- en: During development of the Xbox 360 gaming console, Microsoft realized that DirectSound
    just wasn't going to cut it. So, they created XAudio to meet the increasing demands
    of composers and sound designers in the video game industry. Meanwhile, Windows
    Vista (codenamed **Longhorn**) was also in development. The team working on that
    created a new audio API called **Longhorn Extensible Audio Processor**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 Xbox 360 游戏机的过程中，微软意识到 DirectSound 简直无法满足需求。因此，他们创建了 XAudio 来满足视频游戏行业中作曲家和音效设计师日益增长的需求。同时，Windows
    Vista（代号 **Longhorn**）也在开发中。负责该项目的团队创建了一个新的音频 API，称为 **Longhorn 可扩展音频处理器**。
- en: It wasn't long before both Xbox 360 and Windows Vista had launched, Microsoft
    turned their attention back to the idea of creating a cross-platform audio API
    to replace DirectSound. They had received positive feedback on their XAudio API
    from Xbox 360 game developers, but at the same time, the Longhorn Extensible Audio
    Processor API had some advantages over XAudio, such as providing a more streamlined
    and more efficient audio engine and a few additional features that XAudio did
    not have. So, Microsoft decided to take the best of both, and XAudio2 was the
    result.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Xbox 360 和 Windows Vista 推出不久后，微软将注意力重新转向创建一个跨平台音频 API 以取代 DirectSound 的想法。他们从
    Xbox 360 游戏开发者那里收到了对 XAudio API 的积极反馈，但与此同时，Longhorn 可扩展音频处理器 API 在 XAudio 上有一些优势，例如提供更流畅、更高效的音频引擎以及
    XAudio 所不具备的一些附加功能。因此，微软决定取两者之长，XAudio2 就是结果。
- en: 'So, this means we would obviously want to use XAudio2, right? The answer is
    yes, but that''s not the whole answer. But this raises another potential question:
    why is DirectSound still included in DirectX when it has been replaced? The answer
    is, of course, for backward compatibility. Removing DirectSound from DirectX would
    have broken all applications that were written using the DirectSound API. They
    left it in so that those applications would still work.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这显然意味着我们肯定想使用 XAudio2，对吧？答案是肯定的，但这并不是全部答案。但这又引出了另一个潜在的问题：为什么 DirectSound
    仍然包含在 DirectX 中，尽管它已经被取代了？答案是，当然是为了向后兼容。如果从 DirectX 中移除 DirectSound，将破坏所有使用 DirectSound
    API 编写的应用程序。他们保留它，以便这些应用程序仍然可以工作。
- en: As I said, XAudio2 is not quite the complete answer to the API we should use
    for the sound needs of our games. You may want to support DirectSound for users
    who may have older systems. However, XAudio2 is, as mentioned previously, a multi-platform
    API. You can use it to handle your sound needs in applications for Xbox 360, Windows
    Phone, and Windows PCs (Windows XP and higher).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说的，XAudio2并不是我们为游戏音效需求应该使用的API的完整解决方案。你可能希望支持DirectSound，以适应可能拥有较老系统的用户。然而，正如之前提到的，XAudio2是一个多平台API。你可以使用它来处理Xbox
    360、Windows Phone和Windows PC（Windows XP及以上版本）应用程序的音效需求。
- en: For completeness, we'll take a look at both DirectSound and XAudio2 in this
    chapter, but first let's take a look at what sound really is and some of its properties.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们将在本章中查看DirectSound和XAudio2，但首先让我们看看声音究竟是什么以及它的某些属性。
- en: The basics of sound
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音的基本原理
- en: Before we get into our sound programming, let's cover the basics of sound. We
    need to have a basic understanding of sound before we start doing our sound programming.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始进行声音编程之前，让我们先了解声音的基本原理。在我们开始声音编程之前，我们需要对声音有一个基本了解。
- en: Sound is composed of waves. A **sound wave** is essentially just a pressure
    wave traveling through the air. When it hits your eardrum, a signal is then sent
    to the brain telling it about the sound wave that hit it. The brain converts this
    information into what we think of as a sound.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 声音由波组成。**声波**本质上就是通过空气传播的压力波。当它撞击你的耳膜时，大脑就会接收到一个信号，告诉它有关撞击它的声波。大脑将这个信息转换成我们认为是声音的东西。
- en: 'One of the most common attributes we give to sounds is the idea of **volume**.
    So what exactly is volume? Simply put, it is the amplitude of the sound waves.
    If you think of a drawing of a wave, the height of a wave is its amplitude. In
    other words, amplitude is how big the wave is. Look at the following diagram to
    see this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们赋予声音的最常见属性之一是**音量**的概念。那么，音量究竟是什么呢？简单来说，它就是声波的振幅。如果你想象一下声波的图示，波的高度就是它的振幅。换句话说，振幅就是波的大小。查看以下图表以了解这一点：
- en: '![The basics of sound](img/7389OS_04_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![声音的基本原理](img/7389OS_04_01.jpg)'
- en: The amplitude or volume of a sound wave
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 声波的振幅或音量
- en: 'Another very important attribute of sound is the idea of **frequency**. So,
    on a drawing of a wave, its wavelength is simply how wide the wave is, and the
    length of the waves determines their frequency. Frequency refers to how often
    the waves hit, rather than to the length of a single wave. The higher the frequency
    of the sound waves, the higher the **pitch** of the sound is. Likewise, lower
    frequency sounds have a lower pitch. The term pitch of course refers to how high
    or low a sound is. The following diagram shows the concept of frequency:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 声音的另一个非常重要的属性是**频率**的概念。因此，在波的图示中，波长就是波有多宽，波的长度决定了它们的频率。频率指的是波撞击的频率，而不是单个波的长度。声波的频率越高，声音的**音调**就越高。同样，低频声音的音调较低。音调这个术语当然指的是声音的高低。以下图表展示了频率的概念：
- en: '![The basics of sound](img/7389OS_04_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![声音的基本原理](img/7389OS_04_02.jpg)'
- en: The wavelength or frequency of a sound wave
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 声波的波长或频率
- en: Frequency is measured in **Hertz** (**Hz**). The term Hertz generally means
    cycles per second. So if we have a sound that is at 100 Hz, this means that 100
    sound waves hit our eardrums per second. The unit Hertz can be applied to any
    event that happens regularly, such as the ticking of a clock, the beating of a
    heart, or the speed of a computer processor. The speed of a modern computer processor
    is generally given in **Gigahertz** (**GHz**) these days. That's pretty fast if
    you consider that one **Kilohertz** (**KHz**) is 1,000 Hz, one Megahertz is 1,000
    KHz (or 1 million Hertz), and one Gigahertz is 1,000 MHz (or 1 billion Hertz).
    The hearing range for humans is on average from around 20 to 20,000 Hz.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 频率以**赫兹**（**Hz**）为单位测量。赫兹这个术语通常意味着每秒的周期数。所以，如果一个声音的频率是100 Hz，这意味着每秒有100个声波撞击我们的耳膜。赫兹这个单位可以应用于任何发生规律的事件，比如时钟的滴答声、心脏的跳动或计算机处理器的速度。现代计算机处理器的速度通常以**千兆赫兹**（**GHz**）表示。如果你考虑到1千赫兹（**KHz**）是1,000
    Hz，1兆赫兹是1,000千赫兹（或1百万赫兹），1千兆赫兹是1,000兆赫兹（或10亿赫兹），那么这相当快。人类的听觉范围平均在20到20,000 Hz之间。
- en: Ok, that's enough of that since your head probably "Hertz" now. Get it? Anyway,
    we know what the frequency of a sound is now. So, let's move on and look at the
    idea of **stereo** sound.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，既然你的脑袋可能已经“赫兹”了，那就足够了。明白了吗？无论如何，我们现在知道声音的频率是什么了。那么，让我们继续前进，看看**立体声**的概念。
- en: Stereo sound
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 立体声音
- en: 'When a sound is played in stereo, it means that the sound has two channels:
    one channel is played by the left speaker while the other is played by the right
    speaker. This gives a bit of a 3D effect to the sound for the listener. In other
    words, the sound is composed of two separate sound tracks, one for each speaker.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当立体声播放声音时，这意味着声音有两个通道：一个通道由左扬声器播放，另一个通道由右扬声器播放。这给听众带来了一定的3D效果。换句话说，声音由两个独立的声音轨道组成，每个扬声器一个。
- en: This leads us to the concept of a **phase**. You can think of this as referring
    to how well the channels in a sound are synced with one another. If the channels
    are perfectly in sync, they are said to be *in phase*. Otherwise, they are said
    to be *out of phase*. So if you delay one of the channels by a fraction of a second,
    your sound is out of phase because the sound from the left and right speakers
    is not correctly synced with each other.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了**相位**的概念。你可以将其视为指声音中的通道彼此同步的程度。如果通道完全同步，则称它们为**同相**。否则，它们被称为**异相**。所以如果你将其中一个通道延迟一秒钟的几分之一，你的声音就处于异相，因为左右扬声器中的声音没有正确同步。
- en: 'There is one last interesting property of sound that we will take a quick look
    at. It is directly linked to the concept of a phase. The following diagram shows
    this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 声音还有一个有趣的特性，我们将简要探讨。它与相位的概念直接相关。以下图表展示了这一点：
- en: '![Stereo sound](img/7389OS_04_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![立体声声音](img/7389OS_04_03.jpg)'
- en: 'In the previous figure, we have two sets of sound waves: one is continuous,
    and the other is dotted. As you can see, the dotted one is the continuous wave
    inverted. So the result is that we have two audio tracks, where one has the opposite
    phase of the other. So what happens when we play this sound? Nothing! That''s
    right, absolutely nothing. Why? Because sound waves with opposite phases will
    cancel each other out. In other words, if two sound waves of the same amplitude
    and frequency coincide with each other, but one of them is inverted, then they
    cancel each other out. The second half of the previous diagram shows this. There
    are no sound waves left since they canceled each other out, and thus we have silence.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们有两套声波：一个是连续的，另一个是点划线的。正如你所见，点划线的是连续波的倒置。所以结果是，我们有两个音频轨道，其中一个与另一个具有相反的相位。那么当我们播放这个声音时会发生什么？什么也没有！没错，绝对什么也没有。为什么？因为相反相位的声波会相互抵消。换句话说，如果两个相同幅度和频率的声波相遇，但其中一个被倒置，那么它们会相互抵消。前面图表的后半部分展示了这一点。由于它们相互抵消，所以没有声波留下，因此我们得到了静音。
- en: DirectSound
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DirectSound
- en: We will add some simple sound to the 2D world we made in the previous chapter.
    So, open Visual Studio and let's get started!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向上一章创建的2D世界中添加一些简单的声音。所以，打开 Visual Studio，让我们开始吧！
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before we get started, it should be noted that the music track we are using
    in this chapter (`lost_village_128.wav`) is courtesy of [http://wrathgames.com/blog](http://wrathgames.com/blog)
    (*WrathGames Studio*). So, a big thanks goes out to them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，应该注意的是，我们在这章使用的音乐轨道（`lost_village_128.wav`）由 [http://wrathgames.com/blog](http://wrathgames.com/blog)
    (*WrathGames Studio*) 提供。所以，非常感谢他们。
- en: This sound file is, of course, included in the downloadable code for this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个声音文件包含在本章可下载的代码中。
- en: 'Open the `TileGameWindow.cs` file. First of all, we need to add the following
    `using` statements to the top of the file so that we can use DirectSound:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `TileGameWindow.cs` 文件。首先，我们需要在文件顶部添加以下 `using` 语句，以便我们可以使用 DirectSound：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we need to add some new member variables to this class. The first one
    we will add is a Boolean variable named `m_UseDirectSound`. This variable can
    be set to either `true`, or `false`. When it is set to `true`, the program will
    use DirectSound, but if this variable is set to `false`, the program will use
    XAudio2\. The following is the declaration of this variable:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要向这个类添加一些新的成员变量。我们将首先添加一个名为 `m_UseDirectSound` 的布尔变量。这个变量可以设置为 `true`
    或 `false`。当它设置为 `true` 时，程序将使用 DirectSound；如果这个变量设置为 `false`，程序将使用 XAudio2。以下是这个变量的声明：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we need to create three more member variables that will hold our `DirectSound`
    objects. They are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建三个额外的成员变量来存储我们的 `DirectSound` 对象。具体如下：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first variable will hold our `DirectSound` object. The second one is the
    primary sound buffer, and the third variable is a secondary sound buffer that
    will store the sound we want to play.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量将存储我们的 `DirectSound` 对象。第二个是主要声音缓冲区，第三个变量是一个次要声音缓冲区，它将存储我们想要播放的声音。
- en: 'Now, we will add a new method called `InitDirectSound()` to the `TileGameWindow`
    class. The following is the code for it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向`TileGameWindow`类添加一个名为`InitDirectSound()`的新方法。以下是它的代码：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line in this method creates our `DirectSound` object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的第一行创建了我们的`DirectSound`对象。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In a real program, you would have much better error handling than we have in
    our demos in this book. It has been left out to save space.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真正的程序中，您将会有比我们在这本书中的演示中更好的错误处理。为了节省空间，这部分内容已被省略。
- en: 'In this case, we would need to handle the situation where the creation of the
    `DirectSound` object fails. This could happen, for example, when the user does
    not have a DirectSound-compatible sound card installed in his/her system. If this
    happens, SlimDX will throw a `DirectSound` exception (or error). We would catch
    the exception by putting a `try` block around the initialization code as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要处理创建`DirectSound`对象失败的情况。例如，当用户在其系统中未安装DirectSound兼容的声音卡时，这可能会发生。如果发生这种情况，SlimDX将抛出一个`DirectSound`异常（或错误）。我们可以通过在初始化代码周围放置一个`try`块来捕获异常，如下所示：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Inside the `catch` block, we input our code to handle the error condition. In
    this case, we just make the constructor return without finishing initialization.
    This prevents the program from crashing, but it still won't work, right? (It won't
    have sound.) So, basically, if the initialization of the `DirectSound` object
    fails, the code in the `catch` block will run.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`catch`块内部，我们输入我们的代码来处理错误条件。在这种情况下，我们只是让构造函数返回而不完成初始化。这可以防止程序崩溃，但它仍然不会工作，对吧？（它不会有声音。）所以，基本上，如果`DirectSound`对象的初始化失败，`catch`块中的代码将会运行。
- en: Error handling is extremely important in real-world applications, so don't forget
    about it!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用程序中，错误处理非常重要，所以不要忘记它！
- en: Next, we set the cooperative level. The cooperative level determines the extent
    to which the system allows this program to use the device. This is because Windows
    is a multitasking environment and therefore multiple applications could be using
    the sound device at the same time. Cooperative level is the way the system makes
    sure that we don't have two programs trying to use the device at exactly the same
    time, as this can cause problems. As you can see, we set the cooperative level
    to `CooperativeLevel.Priority` here. This is usually what you'll want to set it
    to if your application is a game.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置协作级别。协作级别决定了系统允许此程序使用设备的程度。这是因为Windows是一个多任务环境，因此可能有多个应用程序同时使用声音设备。协作级别是系统确保我们不会有两个程序试图在完全相同的时间使用设备的方式，因为这可能会引起问题。如您所见，我们在这里将协作级别设置为`CooperativeLevel.Priority`。如果您应用程序是一个游戏，通常您会希望将其设置为这个值。
- en: The next three lines of code create our `PrimarySoundBuffer` object and give
    it the `BufferFlags.PrimaryBuffer` flag.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下三行代码创建我们的`PrimarySoundBuffer`对象，并给它赋予`BufferFlags.PrimaryBuffer`标志。
- en: The next chunk of code sets up our `SecondarySoundBuffer` object. It starts
    with a `using` block that creates a `WaveStream` object that is using our sound
    file. Inside the `using` block, we create a `SoundBufferDescription` object that
    we will use to specify the properties of our `SecondarySoundBuffer` object when
    we create it. We set the `SizeInBytes` property to the size of our wave file.
    Then, we set the `Flags` property to have the `BufferFlags.ControlVolume` flag.
    Having this flag set allows us to control the volume of the sound. There are other
    buffer flags too, of course. Some examples are `ControlPan`, which lets you control
    the left/right balance of the sound, `ControlFrequency`, which lets you control
    the frequency of the sound, and `ControlEffects`, which allows you to apply effects
    to the sound.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码设置了我们的`SecondarySoundBuffer`对象。它从一个`using`块开始，该块创建了一个使用我们的声音文件的`WaveStream`对象。在`using`块内部，我们创建了一个`SoundBufferDescription`对象，我们将使用它来指定创建`SecondarySoundBuffer`对象时的属性。我们将`SizeInBytes`属性设置为我们的波形文件的大小。然后，我们将`Flags`属性设置为具有`BufferFlags.ControlVolume`标志。设置此标志允许我们控制声音的音量。当然，还有其他缓冲区标志。一些例子包括`ControlPan`，它允许您控制声音的左右平衡，`ControlFrequency`，它允许您控制声音的频率，以及`ControlEffects`，它允许您对声音应用效果。
- en: Next, we get the wave format from the `WaveStream` object and copy it into the
    `Format` property of the `SoundBufferDescription` object. Then, we create the
    `SecondarySoundBuffer` object using the `DirectSound` object, and the `SoundBufferDescription`
    object we just filled out.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从`WaveStream`对象获取波形格式，并将其复制到`SoundBufferDescription`对象的`Format`属性中。然后，我们使用`DirectSound`对象和刚刚填写好的`SoundBufferDescription`对象创建`SecondarySoundBuffer`对象。
- en: The next block of code loads our sound file. The first line here creates a byte
    array of the same size as our wave file. The next line reads all of the data from
    the wave file into the byte array. The third line copies the data from the byte
    array into our `SecondarySoundBuffer` object. The second parameter here is the
    offset into the buffer that we want to start writing the data at. Since we want
    to start at the beginning of the buffer, we specify `0` for this. If we specified
    `10`, the wave data would be written starting `10` bytes in from the beginning
    of the buffer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码加载我们的声音文件。这里的第一行创建了一个与波形文件大小相同的字节数组。下一行将波形文件中的所有数据读取到字节数组中。第三行将数据从字节数组复制到我们的`SecondarySoundBuffer`对象中。这里的第二个参数是我们想要开始写入数据的缓冲区偏移量。由于我们想要从缓冲区的开始处开始，我们指定`0`。如果我们指定`10`，波形数据将从缓冲区开始处的`10`个字节处写入。
- en: The final line tells the `SecondarySoundBuffer` object to start playing our
    sound by calling its `Play()` method. The first parameter is the priority for
    this sound. The second parameter specifies flags that affect how the sound is
    played. In this case we are using `PlayFlags.Looping` to make our music loop continuously.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的行通过调用其`Play()`方法来告诉`SecondarySoundBuffer`对象开始播放我们的声音。第一个参数是此声音的优先级。第二个参数指定了影响声音播放方式的标志。在这种情况下，我们使用`PlayFlags.Looping`来使我们的音乐连续循环。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will need your sound file to be properly set up for looping. A sound file
    that is not meant for looping will probably not sound good when it loops back
    to the start. A sound file that is meant for looping has a smooth transition at
    the end, so that the end transitions nicely into the start so that the sound can
    repeat seamlessly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保你的声音文件正确设置了循环。如果一个声音文件不是为循环设计的，那么当它循环回起点时可能听起来不太好。一个为循环设计的声音文件在结尾处有一个平滑的过渡，这样结尾可以很好地过渡到开始，从而使声音可以无缝重复。
- en: The `SecondarySoundBuffer` object has other methods as well. The `Pause()` method,
    for example, will pause the sound. When you start playing it again, it will resume
    from where it left off. The `Stop()` method, on the other hand, stops playback
    and also rewinds the sound back to its beginning. So when you start the sound
    playing again, it will start over from the beginning.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecondarySoundBuffer`对象还有其他方法。例如，`Pause()`方法将暂停声音。当你再次开始播放时，它将从上次停止的地方继续播放。另一方面，`Stop()`方法停止播放并将声音回滚到其开始处。所以当你再次开始播放声音时，它将从开始处重新开始。'
- en: 'At this point, we need to go back and add a line of code into the constructor
    to call this new `InitDirectSound()` method that we have created. For that, we
    simply add the following `if` statement to the end of the constructor:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要回到构造函数中添加一行代码来调用我们刚刚创建的`InitDirectSound()`方法。为此，我们只需在构造函数的末尾添加以下`if`语句：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are not quite finished though. We still need to dispose of our `DirectSound`
    objects when we are done with them. So, add the following code into the managed
    section of our `Dispose(bool)` method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们还没有完全完成。我们仍然需要在完成使用`DirectSound`对象后将其释放。因此，将以下代码添加到我们的`Dispose(bool)`方法的托管部分：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With that, our DirectSound code is done. If you run the program now, you should
    notice music playing in our 2D tile-based world. You may also notice that the
    music will pause if the window loses focus. If you then click on the window again
    to give it the focus, the music will start back up where it left off.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们的DirectSound代码就完成了。如果你现在运行程序，你应该会注意到在我们的2D基于瓦片的世界上正在播放音乐。你也可能注意到，如果窗口失去焦点，音乐将会暂停。如果你再次点击窗口以将其聚焦，音乐将从上次停止的地方重新开始播放。
- en: We should also talk about the sound buffer's `Status` property, which you can
    access to find out the current status of your sound buffer. For example, you can
    use this to check if the sound is currently playing or looping, among other things.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该讨论声音缓冲区的`Status`属性，你可以通过它来获取声音缓冲区的当前状态。例如，你可以使用它来检查声音是否正在播放或循环，以及其他事项。
- en: Volume control
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音量控制
- en: In this section of code, we mentioned several of the buffer flags, and we set
    the `BufferFlags.ControlVolume` flag on our `SecondarySoundBuffer` object, which
    tells DirectSound that we want the capability to change the volume of the sound.
    We didn't actually mess with this, but to change the volume, you would simply
    change the value of the sound buffer's `Volume` property. In DirectSound, volume
    is specified in 100th of a **decibel** (**dB**). The valid range for this property
    is `0` to `10,000`. Also, note that the maximum value of `10,000` represents the
    original volume of the sound. As you can see, this means that DirectSound does
    not support amplification, as is stated in their documentation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节代码中，我们提到了几个缓冲区标志，并在我们的 `SecondarySoundBuffer` 对象上设置了 `BufferFlags.ControlVolume`
    标志，这告诉 DirectSound 我们想要改变声音音量的能力。我们实际上并没有修改这个设置，但要改变音量，您只需更改声音缓冲区的 `Volume` 属性的值。在
    DirectSound 中，音量以分贝（dB）的百分之一来指定。此属性的合法范围是 `0` 到 `10,000`。请注意，`10,000` 的最大值代表声音的原始音量。如您所见，这意味着
    DirectSound 不支持放大，正如他们的文档中所述。
- en: Frequency control
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 频率控制
- en: This is similar to controlling the volume. You can change the frequency of the
    sound by setting the `BufferFlags.ControlFrequency` flag and then changing the
    value of the sound buffer's `Frequency` property. The valid range of values for
    this property is `100` to `100,000`. If you want to use the original frequency
    of the audio track, set this property to a value of `0`. If you wanted to double
    the playback speed of your sound for example, you would need to double its frequency.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这与控制音量类似。您可以通过设置 `BufferFlags.ControlFrequency` 标志并更改声音缓冲区的 `Frequency` 属性的值来改变声音的频率。此属性的值的有效范围是
    `100` 到 `100,000`。如果您想使用音频轨道的原始频率，请将此属性设置为 `0`。如果您想将声音的播放速度加倍，例如，您需要将其频率加倍。
- en: Pan control
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平衡控制
- en: If you set the `BufferFlags.ControlPan` flag on the buffer, you can change the
    left/right balance of the sound by editing the sound buffer's `Pan` property.
    If you shift it right, the sound will come out of the right speaker more than
    the left. The valid range of values for this property is `-10,000` to `10,000`.
    At `-10,000`, the sound will only come out of the left speaker, and at `10,000`
    it will only come out of the right speaker. A value of `0` specifies the center,
    or in other words, the sound will come out of both speakers equally.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在缓冲区上设置了 `BufferFlags.ControlPan` 标志，您可以通过编辑声音缓冲区的 `Pan` 属性来改变声音的左右平衡。如果您将其向右移动，声音将比左扬声器更多地从右扬声器输出。此属性的值的有效范围是
    `-10,000` 到 `10,000`。在 `-10,000` 时，声音将只从左扬声器输出，在 `10,000` 时将只从右扬声器输出。`0` 的值指定中心，换句话说，声音将从两个扬声器中均匀输出。
- en: There are, of course, more flags besides these ones too and other effects that
    you can apply to your sound, but we don't have room to cover them here. These
    flags are all defined in the `BufferFlags` enumeration.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了这些之外，还有更多标志和其他可以应用于您声音的效果，但我们没有足够的空间在这里介绍它们。这些标志都在 `BufferFlags` 枚举中定义。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You need to set the proper buffer flags as mentioned previously, before you
    can use these various controls on your sound.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以使用这些各种控制来调整声音之前，需要设置之前提到的适当缓冲区标志。
- en: XAudio2
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XAudio2
- en: XAudio2 is, of course, newer and more powerful than DirectSound. We will add
    some more code to the same file we've spent the first part of this chapter working
    on (`TileGameWindow.cs`).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: XAudio2 当然比 DirectSound 更新且功能更强大。我们将向我们在本章第一部分工作的同一文件（`TileGameWindow.cs`）中添加一些代码。
- en: As usual, we first need to add some `using` statements at the top of the file,
    so that we can use XAudio2.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们首先需要在文件顶部添加一些 `using` 语句，以便我们可以使用 XAudio2。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we will create some member variables to hold our `XAudio2` objects. This
    time there are four of them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一些成员变量来保存我们的 `XAudio2` 对象。这次有四个。
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first one, `m_XAudio2`, will hold our `XAudio2` object. The second one will
    hold our **mastering voice** . In XAudio2, the `MasteringVoice` class is used
    to represent the sound output device. The third variable is the buffer that we
    will store our sound in. Lastly, we have a `SourceVoice` object. This is used
    to submit our audio data to the `MasteringVoice` object for processing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，`m_XAudio2`，将保存我们的 `XAudio2` 对象。第二个将保存我们的**主音**。在 XAudio2 中，`MasteringVoice`
    类用于表示声音输出设备。第三个变量是我们将存储声音的缓冲区。最后，我们有一个 `SourceVoice` 对象。这是用于将音频数据提交给 `MasteringVoice`
    对象进行处理的。
- en: 'The next thing we should do is edit the `if` statement we added to the bottom
    of the constructor earlier in this chapter. The following code needs to be changed:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们应该做的是编辑我们在本章早期构造函数底部添加的`if`语句。以下代码需要更改：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following change has to be made:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 必须进行以下更改：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This change makes it such that the program will use XAudio2 instead of DirectSound
    if the `m_UseDirectSound` member variable is set to `false`. So, go to the top
    of the class file, find that variable, and change its value to `false`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改使得当`m_UseDirectSound`成员变量设置为`false`时，程序将使用XAudio2而不是DirectSound。所以，去到类文件的顶部，找到那个变量，并将其值更改为`false`。
- en: 'With that taken care of, we need to create the `InitXAudio2()` method so that
    if the `m_UseDirectSound` variable is set to `false`, the method is called. The
    following is the code for this method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完这些后，我们需要创建`InitXAudio2()`方法，以便如果`m_UseDirectSound`变量设置为`false`，该方法将被调用。以下是这个方法的代码：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method can be a bit confusing, so I left the comments in the previous code
    listing. As you can see, the first thing we do is create our XAudio2 object. Then,
    we have an `if` statement that checks to see if we have any valid sound devices
    to use. If not, then the `XAudio2` object's `DeviceCount` property will return
    `0`. In this case, if no sound device is available, we simply return and don't
    try to continue initializing XAudio2, since this would probably cause a crash.
    This goes back to the tip in the *DirectSound* section of this chapter; error
    handling is very important in a real game, so don't forget it or put if off! Next,
    we create the `MasteringVoice` object. I know you're probably thinking something
    along the lines of "what the heck is a mastering voice?". Well, it is simply a
    class that represents the audio output device; however, you cannot submit an audio
    buffer directly to the mastering voice object. We will use our `SourceVoice` object
    to do that in a minute.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可能有点令人困惑，所以我保留了之前代码列表中的注释。正如你所见，我们首先创建我们的XAudio2对象。然后，我们有一个`if`语句，检查是否有任何有效的声音设备可以使用。如果没有，那么`XAudio2`对象的`DeviceCount`属性将返回`0`。在这种情况下，如果没有声音设备可用，我们只需返回，并不要尝试继续初始化XAudio2，因为这可能会引起崩溃。这回到了本章*DirectSound*部分中的提示；在实际游戏中，错误处理非常重要，所以不要忘记它或推迟它！接下来，我们创建`MasteringVoice`对象。我知道你可能可能在想“到底什么是主声音？”好吧，它是一个表示音频输出设备的类；然而，你不能直接将音频缓冲区提交给主声音对象。我们将使用我们的`SourceVoice`对象在稍后完成。
- en: Now, we have a `using` block similar to the one we have in our `InitDirectSound()`
    method. It opens our sound file so we can get the audio data and put it into our
    buffer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个与我们在`InitDirectSound()`方法中使用的`using`块相似的块。它打开我们的声音文件，以便我们可以获取音频数据并将其放入缓冲区。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the `using` block will automatically dispose of our `WaveStream`
    when program execution reaches the end of the `using` block, and that `using`
    blocks only work like this with types that implement the `IDisposable` interface.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当程序执行到达`using`块的末尾时，`using`块将自动释放我们的`WaveStream`，并且只有实现了`IDisposable`接口的类型才能这样工作。
- en: The first four lines of code inside the `using` block set up our audio buffer.
    The first one creates the `AudioBuffer` object. The second line sets the buffer's
    `AudioData` property to our `WaveStream` object to get the audio data from the
    `.wav` file and into our audio buffer. The third line sets the buffer's `AudioBytes`
    property to the length of the `.wav` file, so the buffer knows how much data we
    have shoved into it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`using`块内部的代码的前四行设置了我们的音频缓冲区。第一行创建了`AudioBuffer`对象。第二行将缓冲区的`AudioData`属性设置为我们的`WaveStream`对象，以便从`.wav`文件获取音频数据并将其放入音频缓冲区。第三行将缓冲区的`AudioBytes`属性设置为`.wav`文件的长度，这样缓冲区就知道我们已将其中的多少数据放入其中。
- en: The next line of code tells XAudio2 that we want to loop this sound. This is
    done by setting the `LoopCount` property to `XAudio2.LoopInfinite`. The `LoopCount`
    property sets how many times we want to loop the sound. You can set the start
    position for the loop and the end position via the `AudioBuffer`'s `BeginLoop`
    and `EndLoop` properties. This is not necessary if your audio file already has
    looping data in it. In this case these properties are already set for us based
    on the data from the file. Note that the `AudioBuffer` class also has the `PlayBegin`
    and `PlayLength` properties that let you set the portion of the sound that you
    wish to play. These properties are set to the beginning and end of the sound file
    by default.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码告诉 XAudio2 我们想要循环播放这个声音。这是通过将 `LoopCount` 属性设置为 `XAudio2.LoopInfinite`
    来实现的。`LoopCount` 属性设置我们想要循环播放声音的次数。你可以通过 `AudioBuffer` 的 `BeginLoop` 和 `EndLoop`
    属性设置循环的开始位置和结束位置。如果你的音频文件已经包含循环数据，则这不是必需的。在这种情况下，这些属性已经根据文件中的数据为我们设置好了。请注意，`AudioBuffer`
    类还有一个 `PlayBegin` 和 `PlayLength` 属性，允许你设置你希望播放的声音部分。这些属性默认设置为声音文件的开始和结束。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `BufferFlags` enumeration we just used is not the same one we used when
    we were working with DirectSound. The DirectSound enumeration for buffer flags
    is `SlimDX.DirectSound.BufferFlags`, while the XAudio2 enumeration for buffer
    flags is `SlimDX.XAudio2.BufferFlags`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才使用的 `BufferFlags` 枚举与我们之前在处理 DirectSound 时不相同。DirectSound 的缓冲区标志枚举是 `SlimDX.DirectSound.BufferFlags`，而
    XAudio2 的缓冲区标志枚举是 `SlimDX.XAudio2.BufferFlags`。
- en: The last three lines of code set up our `SourceVoice` object. This object is
    used to submit our audio data to the `MasteringVoice` object so that we can play
    it. So, the first of these three lines creates the `SourceVoice` object. The second
    line submits the audio data from our `AudioBuffer`, so that we can play it, and
    the last line plays our sound.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后三行设置了我们的 `SourceVoice` 对象。这个对象用于将我们的音频数据提交给 `MasteringVoice` 对象，以便我们可以播放它。因此，这三行中的第一行创建了
    `SourceVoice` 对象。第二行提交了来自我们的 `AudioBuffer` 的音频数据，以便我们可以播放它，最后一行播放了我们的声音。
- en: 'There is still one more little thing we need to take care of before we test
    our XAudio2 code. We need to add some new code into the managed section of our
    `Dispose(bool)` method. We have four objects we need to dispose of, so the code
    looks like the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试 XAudio2 代码之前，还需要注意一个小细节。我们需要在我们的 `Dispose(bool)` 方法的托管部分添加一些新的代码。我们需要处理四个对象，所以代码看起来如下所示：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We are now ready to test our new code. If you run the program, the music will
    keep looping until you close the program. You may also notice that unlike the
    DirectSound demo, if the window loses focus, XAudio2 just keeps playing the sound.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以测试我们的新代码了。如果你运行程序，音乐将持续循环播放，直到你关闭程序。你可能还会注意到，与 DirectSound 示例不同，如果窗口失去焦点，XAudio2
    仍然会继续播放声音。
- en: As we could in DirectSound, we can of course change the volume of our sound,
    or pan it in XAudio2\. So how do we accomplish this?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 DirectSound 中一样，我们当然可以在 XAudio2 中改变声音的音量，或者将其平移。那么我们如何实现这一点呢？
- en: Volume control
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音量控制
- en: We can change the overall volume of our sound by changing the value of the `SourceVoice`
    object's `Volume` property. The value of this property is a floating point amplitude
    multiplier in the range -`2`^(24) to `2` ^(24). With a value of `1.0f`, there
    is no attenuation and no gain. A value of `0` results in silence. Negative values
    can be used to invert the phase of the audio.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过改变 `SourceVoice` 对象的 `Volume` 属性的值来改变我们声音的整体音量。这个属性的值是一个范围在 -`2`^(24)
    到 `2`^(24) 的浮点幅值乘数。当值为 `1.0f` 时，没有衰减也没有增益。值为 `0` 时结果是静音。负值可以用来反转音频的相位。
- en: Frequency control
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 频率控制
- en: Adjusting the frequency of the sound is a bit different in XAudio2 than it is
    in DirectSound. In XAudio2, this is expressed as a frequency ratio. You can change
    it by altering the value of the `SourceVoice` object's `FrequencyRatio` property.
    A ratio of 1:1 means that there is no pitch change. This is the default value
    for this property. The valid range of values is `1/1,024` to `1,024/1`. At a ratio
    of 1:1,024 the sound's pitch is lowered by 10 octaves. On the other hand, a ratio
    of 1,024:1 will raise the pitch of the sound by 10 octaves. This property is of
    the type `float`, so you would have to calculate the ratio and pass it in. So
    if you want to pass in the ratio 1:1, this property would be set to a value of
    `1` since one divided by one is one.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在XAudio2中调整声音频率与在DirectSound中有所不同。在XAudio2中，这表示为频率比率。你可以通过改变`SourceVoice`对象`FrequencyRatio`属性的值来更改它。1:1的比率意味着没有音调变化。这是此属性的默认值。值的有效范围是`1/1,024`到`1,024/1`。在1:1,024的比率下，声音的音调会降低10个八度。另一方面，1,024:1的比率会将声音的音调提高10个八度。此属性是`float`类型，因此你必须计算比率并将其传递。所以如果你想传递1:1的比率，这个属性将被设置为`1`，因为一除以一是等于一的。
- en: To put this in context, the default ratio has a value of `1` as we just said.
    A value of `2` will double the frequency of the sound and will increase its pitch
    by one octave. A ratio of `0.5` will cut the frequency in half, making the track
    take twice as long to play and lowering its pitch by one octave. So for example,
    if you want to make a sound play at three times its normal speed, you would set
    the `FrequencyRatio` property to a value of `3`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个更具体，默认比率具有我们刚才所说的`1`的值。`2`的值将使声音频率加倍，并将音调提高一个八度。`0.5`的比率将频率减半，使音轨播放时间加倍，并将音调降低一个八度。所以例如，如果你想使声音以三倍正常速度播放，你将把`FrequencyRatio`属性设置为`3`。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Each time you halve the frequency of the sound, you lower its pitch by one octave,
    and likewise, each time you double the frequency, you increase the pitch by one
    octave.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每次将声音频率减半，其音调就会降低一个八度，同样地，每次将频率加倍，音调就会提高一个八度。
- en: Pan control
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扬声器控制
- en: 'Panning is a bit more complicated in XAudio2 than it is in DirectSound. There
    are a number of steps we must take to pan in XAudio2\. The first step is to create
    an output **matrix**. A matrix is simply a two-dimensional table of numbers. This
    simply contains the calculated panning values for each channel. We create the
    array as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在XAudio2中，声像比在DirectSound中要复杂一些。我们必须采取一系列步骤来在XAudio2中进行声像处理。第一步是创建一个输出**矩阵**。矩阵只是一个数字的二维表。它仅包含每个通道的计算声像值。我们创建数组的步骤如下：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We created this array with eight elements, so that it can support speaker configurations
    up to 7.1\. For simplicity, our sample code here will simply be for stereo output.
    Next, we need to calculate or set the values for the left- and right-side speakers.
    So, in this case, we will create two more variables to hold these values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用八个元素创建了这个数组，以便它可以支持高达7.1的扬声器配置。为了简化，我们这里的示例代码将仅用于立体声输出。接下来，我们需要计算或设置左右扬声器的值。因此，在这种情况下，我们将创建两个额外的变量来存储这些值。
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have both values set to `0.5`, which means the sound will play evenly from
    both speakers. If we set left to `1.0` and right to `0.0`, the sound will only
    play from the left speaker. And of course, if we set left to `0.0` and right to
    `1.0`, then the sound will only play from the right speaker. So as you can see,
    these values are in essence volume levels for the left and right channels of the
    sound.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这两个值都设置为`0.5`，这意味着声音将均匀地从两个扬声器播放。如果我们把左边的值设置为`1.0`，右边的值设置为`0.0`，声音将只从左扬声器播放。当然，如果我们把左边的值设置为`0.0`，右边的值设置为`1.0`，那么声音将只从右扬声器播放。所以正如你所看到的，这些值本质上就是声音左右通道的音量级别。
- en: 'Now, we need to set these values into the correct indices in the `outputMatrix`
    array that we created previously. We need to get the **channel mask** first, so
    we know what speaker configuration we are dealing with. How you do this differs
    depending on whether you are developing for Windows 7 and earlier versions, or
    Windows 8\. For Windows 7 and earlier versions, we get the channel mask by using
    the `GetDeviceDetails()` method of the `XAudio2` object:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将这些值设置到我们之前创建的`outputMatrix`数组中的正确索引。我们首先需要获取**通道掩码**，这样我们才知道我们正在处理哪种扬声器配置。具体如何操作取决于你是为Windows
    7及更早版本还是Windows 8开发。对于Windows 7及更早版本，我们通过使用`XAudio2`对象的`GetDeviceDetails()`方法来获取通道掩码：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that the parameter to the `GetDeviceDetails()` method is simply the index
    of the device to query, and `0` is the default device. On the Windows 8 version
    of XAudio2, we get the channel mask from the `MasteringVoice` object''s `ChannelMask`
    property:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`GetDeviceDetails()`方法的参数只是要查询的设备的索引，`0`是默认设备。在XAudio2的Windows 8版本中，我们从`MasteringVoice`对象的`ChannelMask`属性获取通道掩码：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, this code is a bit shorter in the Windows 8 version of XAudio2
    compared to the DirectX SDK version (Windows 7 and earlier versions).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，与DirectX SDK版本（Windows 7及更早版本）相比，XAudio2的Windows 8版本中的此代码要短一些。
- en: 'So what is this channel mask value? Well, it is simply a flag variable with
    various flags set in it to specify the speaker configuration of the PC. There
    is a flag for each different speaker type. These flags are defined by the `Speakers`
    enumeration (which is in the `SlimDX.Multimedia` namespace), and here they are:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个通道掩码值是什么意思呢？嗯，它只是一个带有各种标志的标志变量，用于指定PC的扬声器配置。每个不同的扬声器类型都有一个标志。这些标志由`Speakers`枚举（位于`SlimDX.Multimedia`命名空间中）定义，如下所示：
- en: '`BackCenter`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackCenter`'
- en: '`BackLeft`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackLeft`'
- en: '`BackRight`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackRight`'
- en: '`FrontCenter`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrontCenter`'
- en: '`FrontLeft`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrontLeft`'
- en: '`FrontLeftOfCenter`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrontLeftOfCenter`'
- en: '`FrontRight`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrontRight`'
- en: '`FrontRightOfCenter`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrontRightOfCenter`'
- en: '`SideLeft`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SideLeft`'
- en: '`SideRight`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SideRight`'
- en: '`LowFrequency`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LowFrequency`'
- en: '`TopBackCenter`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TopBackCenter`'
- en: '`TopBackLeft`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TopBackLeft`'
- en: '`TopBackRight`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TopBackRight`'
- en: '`TopCenter`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TopCenter`'
- en: '`TopFrontCenter`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TopFrontCenter`'
- en: '`TopFrontLeft`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TopFrontLeft`'
- en: '`TopFrontRight`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TopFrontRight`'
- en: 'So, basically, these flags are used to indicate which types of speaker(s) are
    being used. You probably won''t need to use most of these flags, but I have included
    them in the previous list for reference purposes. However, the `Speakers` enumeration
    actually has a few more flags in it that make life a little simpler for us programmers.
    These flags differ from the previous list in that they do not specify a single
    speaker; instead, each of these flags is a combination of the flags listed previously.
    They are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，这些标志用于指示正在使用哪些类型的扬声器。你可能不需要使用这些标志中的大多数，但我将它们包含在之前的列表中供参考。然而，`Speakers`枚举实际上还有一些额外的标志，使我们的编程生活变得简单一些。这些标志与之前的列表不同，因为它们不指定单个扬声器；相反，这些标志中的每一个都是之前列出的标志的组合。它们如下所示：
- en: '`All`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`All`'
- en: '`FourPointOne`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FourPointOne`'
- en: '`FivePointOne`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FivePointOne`'
- en: '`FivePointOneSurround`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FivePointOneSurround`'
- en: '`None`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`'
- en: '`Mono`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mono`'
- en: '`Quadraphonic`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Quadraphonic`'
- en: '`SevenPointOne`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SevenPointOne`'
- en: '`SevenPointOneSurround`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SevenPointOneSurround`'
- en: '`Stereo`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stereo`'
- en: '`Surround`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Surround`'
- en: '`TwoPointOne`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TwoPointOne`'
- en: 'We will use these simpler flags in our example code. Now that we know about
    these flags, we can use them to write the code that tests to see what the speaker
    configuration is. We will not use any of the flags from the first list, but rather
    we will just check for certain speaker configurations using some of the flags
    from the second set of flags listed previously. For example, an `if` statement
    checking to see if we have a configuration with two output channels would look
    something like the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在示例代码中使用这些简单的标志。现在我们了解了这些标志，我们可以使用它们来编写测试扬声器配置的代码。我们不会使用第一个列表中的任何标志，而是将检查某些扬声器配置，使用之前列出的第二组标志中的某些标志。例如，一个检查是否有两个输出通道的`if`语句可能如下所示：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If this code is checking for a configuration using two speakers, why are we
    setting four values here? The reason is because we have two channels of input.
    So for the left speaker, we set a volume level for both channels. The index `0`
    in the array is set to the value of our `left` variable. The index `1` of the
    array represents the volume level of the right channel. Since we don't want the
    right channel to play out of the left speaker at all, we set this to `0.0f`. Likewise,
    the elements `2` and `3` are setting the volume levels for the right speaker.
    We set element `2` to a value of `0.0f`, since we don't want the left channel
    sound to play out of the right speaker. And lastly, element `3` is set to our
    `right` variable. So, as you can see, for each speaker that will be outputting
    sound, we must set the volume levels for all of the channels that our sound has.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码正在检查使用两个扬声器的配置，为什么在这里设置四个值？原因是因为我们有两个输入通道。因此，对于左扬声器，我们为两个通道设置音量级别。数组中的索引`0`被设置为我们的`left`变量的值。数组的索引`1`代表右通道的音量级别。由于我们不希望右通道的声音从左扬声器播放，我们将此设置为`0.0f`。同样，元素`2`和`3`正在设置右扬声器的音量级别。我们将元素`2`设置为`0.0f`，因为我们不希望左通道的声音从右扬声器播放。最后，元素`3`被设置为我们的`right`变量。所以，如您所见，对于每个将输出声音的扬声器，我们必须为声音的所有通道设置音量级别。
- en: You can find this sample code in the downloadable code for this chapter. This
    panning code is commented out though. Just uncomment it and play around with it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章的可下载代码中找到此示例代码。不过，这段声像代码已被注释掉。只需取消注释并尝试使用它。
- en: Note that better sound configurations, such as 5.1 or 7.1, will use more elements
    of this array, since they have more channels to set the volume levels for.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，更好的声音配置，如5.1或7.1，将使用此数组的更多元素，因为它们有更多的通道需要设置音量级别。
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The XAudio2 object has many utility methods and constants that you will need
    in some cases. This is also true of many of the other major DirectX objects we've
    covered so far in this book, such as the `DirectSound` object earlier in this
    chapter, or the `Direct2D` object discussed in the previous chapter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: XAudio2对象具有许多在特定情况下需要的实用方法和常量。这一点也适用于本书中我们迄今为止讨论的许多其他主要DirectX对象，例如本章早些时候提到的`DirectSound`对象，或者前一章中讨论的`Direct2D`对象。
- en: If you want to use the `.ogg` or `.mp3` files instead of the `.wav` files like
    we did in this chapter, you will need to write a method to load in each file type,
    since you will have to decode it before you can play it. Alternatively, you could
    of course convert your files to the `.wav` format and just use them like that.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用`.ogg`或`.mp3`文件而不是本章中使用的`.wav`文件，您将需要编写一个方法来加载每种文件类型，因为您必须在播放之前对其进行解码。当然，您也可以将文件转换为`.wav`格式，然后直接使用它们。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we got into the world of sound programming. First we looked
    at what sound is and some of its basic properties. Then, we looked at the differences
    between DirectSound and XAudio2\. We added music to our 2D tile world demo using
    DirectSound. Next, we added some code to do the same thing but using XAudio2,
    and we created a member variable to control whether the program will use DirectSound
    or XAudio2 to play its sound. We also looked at how to control volume, frequency,
    and panning for a sound in both DirectSound and XAudio2\. In the next chapter,
    we will take a look at Direct3D and how to render simple 3D graphics.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们进入了声音编程的世界。首先，我们探讨了声音是什么以及它的一些基本属性。然后，我们比较了DirectSound和XAudio2之间的区别。我们使用DirectSound将音乐添加到我们的2D瓦片世界演示中。接下来，我们添加了一些代码来完成相同的功能，但使用XAudio2，并创建了一个成员变量来控制程序是否使用DirectSound或XAudio2来播放声音。我们还探讨了如何在DirectSound和XAudio2中控制声音的音量、频率和声像。在下一章中，我们将探讨Direct3D以及如何渲染简单的3D图形。
