- en: Chapter 8. Building a Spreadsheet Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start developing the last application of this book–a
    spreadsheet program capable of calculating numerical expressions as well as cutting
    and pasting cells with relative references. Similar to the word processor in the
    previous chapters, the spreadsheet program cuts and pastes ASCII and Unicode text
    as well as application-specific information. Moreover, it is possible to change
    the font and color of the cells and their horizontal and vertical alignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mouse and keyboard input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a spreadsheet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading the spreadsheet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cutting, copying, and pasting cell blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fonts, colors, and alignments of cell blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MainWindow class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MainWindow` definition in this chapter looks very much like the previous
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: '**MainWindow.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The CalcDocument class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CalcDocument` class is the main class of the application. It catches mouse
    and keyboard events, handles scrolling and painting, and processes menu actions.
    However, the cell-level operations are handled by the `Cell` class, which we will
    cover in [Chapter 9](ch09.html "Chapter 9. Formula Interpretation"), *Formula
    Interpretation*.
  prefs: []
  type: TYPE_NORMAL
- en: The user can mark one or several cells, in which case, the private field `calcMode`
    is set to `Mark`. The user can also edit the text in one cell, in which case the
    `calcMode` field is set to `Edit`. Similar to the word processor in the previous
    chapters, we refer to the current value of the `calcMode` field in expressions
    such as **in mark mode** and **in edit mode**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `OnMouseDown`, `OnMouseMove`, and `OnDoubleClick` methods catch the mouse
    actions in the same way as in the previous applications. Note that we do not override
    the `OnMouseUp` method. Contrary to the word processor of [Chapter 7](ch07.html
    "Chapter 7. Keyboard Input and Character Calculation"), *Keyboard Input and Character
    Calaculation*, this application remains in the `mark` mode until the user actually
    inputs a character, even if they mark only one cell. The user can also mark several
    cells by dragging the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `OnHorizontalScroll` and `OnVerticalScroll` methods are called when the
    user changes the scroll bars. In the previous applications, we did not override
    these functions, but in this application, we want each scroll movement to result
    in a movement of an exact number of cells. Besides, in the `StandardDocument`
    constructor call, we use the `LogicalWithoutScroll` coordinate system in order
    to be able to handle the row and column headers of the spreadsheet, which are
    always located at the top and to the left of the client area regardless of the
    scroll bar settings. This implies that we have to handle scroll bar movements
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The user can mark all cells by clicking on the **all** box in the top-left corner
    (`ClickAll`), all cells in a column by clicking on the column header (`ClickCol`),
    all cells in a row by clicking on the row header (`ClickRow`), or just one of
    the cells (`ClickCell`) by clicking on the cell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `GetMouseLocation` method analyzes a mouse click and returns one of the
    `ClickArea` values. If the user clicks on the right of the spreadsheet, the rightmost
    cell on the row is selected, and if they click below the spreadsheet, the cell
    at the bottom of the column is selected. The `Reference` class is defined in [Chapter
    12](ch12.html "Chapter 12. The Auxiliary Classes"), *The Auxiliary Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `MarkBlock` method marks the blocks in the click area depending on the marks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `OnDraw` method draws the row and column header as well as the cells themselves.
    In the `edit` mode, the `UpdateCaret` method sets the caret in the cell being
    edited.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the user marks cells with the keyboard, the latest marked cell will always
    be visible. The `IsCellVisible` method returns `true` if it is visible, while
    the `MakeCellVisible` method makes sure it is visible by scrolling, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The `MakeCellVisible` method without parameters calls the `MakeCellVisible`
    method with the parameter with the edited cell, or the last marked cell, depending
    on whether the application holds the `edit` or `mark` mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user finishes input text in a cell, the `ToMarkMode` method is called,
    which tries to change the application mode from `edit` to `mark`. It returns `false`
    if the input fails (if a formula with syntax error has been input):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Remark` method is called when the user has marked one or several cells.
    In order to avoid dazzle, it does not mark already marked cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnChar` method is called when the user inputs a character in `mark` mode;
    the application is changed to `edit` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnKeyDown` method calls one of the specific key handling methods, which
    changes the caret position in the `edit` mode and changes the cell markings in
    the `mark` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnReturnKey` and `OnTabulatorKey` methods finish the input in the `edit`
    mode (unless a syntax error occurs) and moves the mark position one step down
    (*Return*), to the left (*Shift* + *Tab*) or to the right (*Tab*). However, in
    case of an error, an error message box is displayed and the `edit` mode remains.
    The only way for the user to finish the input of a formula with a syntax error
    is to press the *Esc* key, in which case the `OnEscapeKey` method is called and
    the cell''s value is reset to the value which it held at the beginning of the
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnDeleteKey` and `OnBackspaceKey` methods remove the current character
    from the `edit` mode and clear the marked cells in the `mark` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the previous applications, the `ClearDocument` method is called
    when the user selects the **New** menu item, the `ReadDocumentFromStream` method
    is called when they select the **Open** menu item, and the `WriteDocumentToStream`
    method is called when they select the **Save** or S**ave As** menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A text that begins with an equal sign (**=**) followed by a numerical expression
    with cell references is regarded as a **formula**. Technically, an equal sign
    followed by something other than a numerical expression is also considered a formula.
    However, in that case, it is a formula with a syntax error. When the user inputs
    a formula, the cells referred to in the formula constitute the cell''s **source
    set**. The **target set** of a cell is made up by the cells that have it at a
    source (the sets are more exactly defined at the end of this chapter). The `WriteSetMapToStream`
    and `ReadSetMapFromStream` methods write and read the source and target set maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this application, we overwrite the methods `IsCopyAsciiReady`, `IsCopyUnicodeReady`,
    and `IsCopyGenericReady` from the `StandardDocument` class. They are called by
    the `OnCopy`  method in the `StandardDocument` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It may seem strange that both the `CopyEnable` method and the three more specific
    enable methods are overridden. However, the `CopyEnable` method returns `true`
    if the application is ready for copying (which it is in the `mark` mode), while
    the other methods are called by the `OnCopy` method in the `StandardDocument`
    class to decide whether the application is ready to copy in the given format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Their default implementation is to return `false`, but we need to override
    them, as it is always possible to copy the marked cells in `mark` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We could override the `PasteEnable` method from the `StandardDocument` class
    in the same way we override the `CopyEnable` method. However, in this application,
    we need some finer testing. Therefore, we override the `IsPasteAsciiReady`, `IsPasteUnicodeReady`,
    and `IsPasteGenericReady` methods instead. In the word processor of the previous
    chapters, we could always paste text, irrespective of the number of characters
    or paragraphs. In this application, however, we need to check whether the block
    to be pasted fits in the spreadsheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the word processor, we override the `PasteAscii`, `PasteUnicode`,
    and `PasteGeneric` methods. Remember that these methods are called in the order
    in which the formats are given in the list in the `CalcDocument` constructor call.
    When the corresponding enable method `IsPasteAsciiReady`, `IsPasteUnicodeReady`,
    or `IsPasteGenericReady` returns `true`, the `PasteAscii`, `PasteUnicode`, or
    `PasteGeneric` method is called. Only the first paste method is called. If none
    of the enable methods returns `true`, none of the paste methods is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DeleteEnable` method always returns `true` in the `mark` mode, since there
    is always at least one cell marked and ready to be deleted. It returns `true`
    in the `edit` mode if the caret is not located at the end of the text of the edited
    cell.  The `OnDelete` method simply calls the `OnDeleteKey` method, because the
    **Delete** menu item has the same effect as that of a user pressing the *Delete*
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnFont` and `OnBackgroundColor` methods are called when the user selects
    the **Font** or **Background Color** menu item. They display the standard **Font**
    or **Color** dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Horizontally, the text of a cell can be aligned to left, center, right, or
    justified. Vertically, it can be aligned to top, center, or bottom. All the radio
    methods call the `IsHorizontalAlignment` or `IsVerticalAlignment` methods, and
    all the selection methods call the `SetHorizontalAlignment` or `SetVerticalAlignment`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `InterpretEditCell` method interprets the cell after the user has finished
    the input and creates a **syntax tree** (described in [Chapter 9](ch09.html "Chapter 9. Formula
    Interpretation"), *Formula Interpretation*) in the case of a formula (or throws
    an exception in the case of syntax error). The `IsCircular` method returns `true`
    if the cell is part of a circular reference (the cell formula refers to itself,
    directly or indirectly). The `RemoveTargetSetMap` method removes the targets of
    the cell, and the `AddTargetSetMap` method adds targets to the cell. The `EvaluateCell`
    method evaluates the value of one cell, while the `EvaluateRecursive` method recursively
    evaluates the values of all its target cells. Finally, the `InvalidateCell` method
    invalidates the cell so that it can be redrawn later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned at the beginning of this section, the `calcMode` method is set
    to `Mark` or `Edit`, and we refer to its current value as **in mark mode** and
    **in edit mode**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `markOk` field is set by the `OnMouseDown` method to signal the `OnMouseMove`
    method that it is clear to mark cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `firstMarkRef` and `lastMarkRef` fields refer to the first and last marked
    cell in the spreadsheet in the `mark` mode. Note that they refer to their chronological
    order rather than their physical order, which means that the first marked reference
    can be larger than the last marked reference. When necessary, in some methods,
    the minimum and maximum references are calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `edit` mode, `editRef` refers to the cell currently edited and `editIndex`
    to the index of the next input position in the cell text (and the caret position):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `cellMatrix` field holds the spreadsheet of the application. `Rows` and
    `Cols` are constant values and `Cell` is the class holding the information of
    each cell. `Matrix` is defined in [Chapter 9](ch09.html "Chapter 9. Formula Interpretation"),
    *Formula Interpretation*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user inputs a formula in a cell, each reference in the formula becomes
    a source. In the same way, each of the source cells is given a cell as a target.
    The source and target sets of the cells are stored in the `sourceSetMap` and `targetSetMap`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the `CalcFormat` method used when identifying cut, copy, and paste
    format is arbitrarily chosen to be 1003:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user finishes the input of a cell with the *Esc* key, the previous
    content of the cell (what was stored in the cell before the input began) gets
    stored in the `prevCell` variable and is copied back to the cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**CalcDocument.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor calls the `StandardDocument` constructor in the same way as
    in the word processor of the previous chapters. However, note that we choose the
    `LogicalWithoutScroll` coordinate system (in the word processor, we chose `LogicalWithScroll`).
    This implies that the coordinates of the client area are not updated when the
    user changes the scroll bar settings. Instead, we have to catch the scroll bar
    movements with the `OnHorizontalScroll` and `OnVerticalScroll` methods. This is
    because the row and column headers are always placed at the top and to the left
    of the client area, regardless of the current scroll bar settings. Besides, we
    also want the scrolling to result in exact row and column movements. We also give
    `false` as the seventh parameter, indicating that we omit the **Print** and **Print
    Preview** file items in the **File** menu in this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this application, we only add the **Format** menu besides the **File**, **Edit**,
    and **Help** standard menus to the standard menu bar. The **Format** menu holds
    the **Font** and **Background Color** items as well as the sub menus **Horizontal
    Alignment** and **Vertical Alignment**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GenerateCaretList` method is called for each cell in the spreadsheet,
    even though every cell is empty to start with. However, there is an extra caret
    rectangle generated for the position to the right of the text, which we need in
    case the user double-clicks on an empty cell. If they do, we use the caret list
    to find the index of the character clicked on (which naturally is zero for an
    empty cell):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Mouse input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OnMouseDown` and `OnMouseMove` methods look up the part of the spreadsheet
    with the mouse position and mark the appropriate set of cells. If the user inputs
    a formula with a syntax error, it is not possible to change the mode from `edit`
    to `mark`, so an error message is displayed in a message box, and the `edit` mode
    remains as it is. In that case, the `markOk` method is set to `false`, indicating
    that the `OnMouseMove` and `OnDoubleClick` methods will take no actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `OnMouseMove` method only takes action if the `markOk` method
    is set to `true` in the `OnMouseDown` method. Since the `OnMouseDown` method is
    always called before the `OnMouseMove` method, the `markOk` method is always properly
    set. One difference between the `OnMouseDown` and `OnMouseMove` methods is that
    the `OnMouseDown` method sets the first and last marked cell reference, while
    the `OnMouseMove` method only sets the last marked cell reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user double-clicks, the input position (and caret) is set to the character
    clicked on. We look up the clicked area in the same way as in the `OnMouseDown`
    and `OnMouseMove` methods. However, the double-click only takes effect if the
    user clicks on a cell, not the all-box or one of the row or column headers. We
    mark the clicked cell, set the application to the `edit` mode, and extract the
    edit index from the cell by calling the `MouseToIndex` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Scrolling and marking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OnHorizontalScroll` and `OnVerticalScroll` methods are called when the
    user changes the scroll bar settings. We adjust the position to the nearest column
    or row and set the scroll position. These methods (together with `GetMouseLocation`)
    are the reason we chose the `LogicalWithoutScroll` coordinate system in the `CalcDocument`
    constructor call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetMouseLocation` method takes the position of a mouse click and returns
    one of the four areas of the client window: the all-box in the top-left corner
    (`ClickAll`), one of the column headers (`ClickCol`), one of the row headers (`ClickRow`),
    or one of the cells in the spreadsheet (`ClickCell`). In order for these methods
    to work properly, we have to choose the `LogicalWithoutScroll` coordinate system
    in the `CalcDocument` constructor call. We must be able to find the mouse position
    without any regard to the current scroll settings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user clicks on the all-box (where both the horizontal and vertical positions
    are within the header dimension), we return the `ClickAll` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If the mouse click is not located within the all-box but within the header
    width, we return the `ClickRow` method and set the cell reference to the row clicked
    on. If the mouse click is below the bottom row, the bottom row is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If the mouse click is not located within the all-box or in a row header but
    within the header height, we return the `ClickCol` method and set the cell reference
    to the column clicked on. If the mouse click is to the right of the rightmost
    column, the rightmost column is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If the mouse click is not located within the all-box or at a row or column
    header, we return the `ClickCell` method and set the cell reference to the cell
    clicked on. If the mouse click is below the bottom row, the bottom row is selected,
    and if the mouse click is to the right of the rightmost column, the rightmost
    column selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an outline of the different parts of the spreadsheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scrolling and marking](img/B05475_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `MarkBlock` method marks a part of the spreadsheet due to the `clickArea`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user clicks on the all-box, all cells in the spreadsheet are marked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If they click on a row, all cells in that row are marked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If they click on a column, all cells in that column are marked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If they click on a cell, only that cell gets marked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Painting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OnDraw` method is called when the window client area needs to be repainted
    partly or completely. The client area can be divided into five parts as outlined
    earlier: the top-left corner, the row header, the column header, the cell space,
    and the area outside the spreadsheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the scroll bar settings to find the top and leftmost row and column.
    We cannot simply draw all cells (unless the scroll bar settings are zero) since
    it would  overwrite the row or column headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The all-box is simply a rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'When drawing the column headers, we calculate the horizontal position of the
    cell''s left border by multiplying the column index by the column width. We also
    need to subtract the current setting of the horizontal scroll bar and add the
    width of the header. The first column has index zero and will be named `A`, so
    we add the column index to the character `A` in order to find its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, when drawing the row headers, we calculate the vertical position
    of the cell''s top border by multiplying the row index by the row height. We also
    need to subtract the current setting of the vertical scroll bar and add the height
    of the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the marked cells will be inverted and the `firstMarkRef` and `lastMarkRef`
    methods refer to the chronological order of the marking, we calculate the minimal
    and maximal markings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we draw the cells. For the cells marked or being edited, the third
    `DrawCell` parameter is `true` and the cell is inversed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `IsCellVisible` method returns `true` if the cell is visible in the window''s
    client area. The index of the first and last visible row and column is calculated
    from the current scroll bar settings. The given cell reference is then compared
    to the references of the visible cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MakeCellVisible` method makes the cell being edited visible in `edit`
    mode and the last marked cell visible in the `mark` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MakeCellVisible` method makes the cell visible by comparing it to the
    current scroll bar settings. If necessary, it changes the scroll bar settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we check whether the width of the spreadsheet is larger than the width
    of the client area, in which case it may be necessary to change the setting of
    the horizontal scroll bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If the cell''s left border is located to the left of the client area''s left
    border or if the cell''s right border is located to the right of the client area''s
    right border, we change the scroll bar setting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If the height of the spreadsheet is more than the height of the client area,
    it may be necessary to change the setting of the horizontal scroll bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If the cell''s top border is located above the client area''s top border or
    if the cell''s bottom border is located below the client area''s bottom border,
    we change the scroll bar settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Marking and updating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UpdateCaret` method sets the caret in `edit` mode if the edited cell is
    visible. Otherwise, it clears the caret. We have to check whether the cell is
    visible. Otherwise, the caret may be shown in one of the header areas. In the
    keyboard `insert` mode, the caret is a vertical bar, and in the `overwrite` mode,
    it is a rectangle the size of the current character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ToMarkMode` method is called when the user ends the input of the text
    in the cell by pressing the *Return* or *Tab* key or by clicking the mouse. Its
    first task is to check whether the input is valid by calling the `InterpretEditCell`
    method, which returns `false` if the text contains a formula with a syntax error.
    In that case, the `edit` mode remains unchanged and `false` is returned. However,
    if the cell interpretation goes well, the application is set to the `mark` mode
    and we get `true` in return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Remark` method unmarks the marked cells and marks the new block given
    by the parameters without any unnecessary updating. That is, cells already marked
    shall not be invalidated. Note that the first and last marked cells refer to their
    chronological order rather than their locations on the spreadsheet. The last row
    or column may be less reflective than the first one. Therefore, we introduce the
    minimal and maximal variables to reflect their actual locations in the spreadsheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous marked block, all cells that are not located in the new marked
    block are invalidated in order for them to be redrawn as unmarked cells. No old
    cells within the new marked blocks become invalidated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the new marked block, all cells that are not located in the old marked block
    are invalidated in order for them to be redrawn as unmarked cells. No already
    marked cells become invalidated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The first and last marked reference is set and the invalidated cells are updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Keyboard input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OnCharDown` method is called every time the user presses a graphical key
    on the keyboard. In the `mark` mode, the application is changed to the `edit`
    mode, where the edit reference is set to the first marked reference, the edit
    index is set to zero since the start of the input resets the cell, and the `prevCell`
    variable is set as backup in case the user finishes the input by pressing the
    *Esc* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The cell to be edited is made visible, the character is added to the text,
    and the caret rectangle is regenerated. Finally, the caret and window are updated,
    since the cell has been altered and the edit index has been updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnKeyDown` method is called every time the user presses a key. The appropriate
    method is called in the case of the arrow keys, *Page Up*, *Page Down*, *Home*,
    *End*, *Return*, *Tab*, *Insert*, *Delete*, or *Backspace*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnLeftArrowKey` method is called when the user presses the left arrow
    key. We have three different cases to consider depending on the `edit` or `mark`
    mode and on whether the user presses the *Shift* key. In the `edit` mode, we make
    the edit cell visible, move the edit index one step to the left if it is not already
    at the leftmost position, and update the caret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `mark` mode, we have to take into consideration whether the *Shift*
    key is pressed. If it is not, we place the marked block (both the first and last
    marked cells) one step to the left of the last marked cell unless it is already
    at the leftmost column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'If the *Shift* key is pressed, we move the last marked cell one step to the
    left unless it is already at the leftmost position. The first marked cell is not
    affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnRightArrowKey` method is called when the user presses the right arrow
    key. It works similarly to the `OnLeftArrowKey` method. In the `edit` mode, we
    make the edit cell visible, move the edit index one step to the right if it is
    not already at the rightmost position, and update the caret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `mark` mode, we have to take into consideration whether the *Shift*
    key is pressed. If it is not pressed, we place the marked block one step to the
    right of the first marked cell, unless it already is at the rightmost column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'If the *Shift* key is pressed, we move the last marked cell one step to the
    right unless it is already at the rightmost position. The first marked cell is
    not affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnUpArrowKey` method is called when the user presses the up arrow key.
    In the `edit` mode, no action is taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'If the *Shift* key is not pressed in the `mark` mode, we place the marked cell
    one step up relative to the first marked cell if it is not already in the top
    row. In that case, we place the marked block in the first marked cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If the *Shift* key is pressed, we move the last marked cell one step up unless
    it is already in the top row. The first marked cell is not affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnDownArrowKey` method is called when the user presses the down arrow
    key. It works in a way similar to the `OnUpArrowKey` method. In the `edit` mode,
    no action is taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'If the *Shift* key is not pressed in the `mark` mode, we place the marked block
    one step relatively under the first marked cell, unless it already is in the bottom
    row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'If the *Shift* key is pressed, we move the last marked cell one step down unless
    it is already in the bottom row. The first marked cell is not affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnHomeKey` method is called when the user presses the *Home* key. In the
    `edit` mode, we make the edit cell visible, move the edit index to the leftmost
    index, and update the caret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'If neither the *Shift* or *Ctrl* keys is pressed in the `mark` mode, we move
    the marked block to the leftmost column of the first marked row. If the *Shift*
    key is pressed, we move the last marked cell to the leftmost column of the last
    marked row. The first marked cell is not affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'If the *Ctrl* key is pressed, but not the *Shift* key, we move the marked block
    to the top-left cell. If the *Ctrl* key is not pressed, we move the last marked
    cell to the leftmost position in the row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnEndKey` method is called when the user presses the *End* key, and it
    works in a way similar to the `OnHomeKey` method. In the `edit` mode, we make
    the edit cell visible, move the edit index to the rightmost index, and update
    the caret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'If neither the *Shift* nor the *Ctrl* key is pressed in the `mark` mode, we
    move the marked block to the rightmost column of the first marked row. If the
    *Shift* key is pressed, we move the last marked cell to the rightmost column of
    the last marked row. The first marked cell is not affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'If the *Ctrl* key is pressed, but not the *Shift* key, we move the marked block
    to the bottom-right cell. If the *Ctrl* key is not pressed, we move the last marked
    cell to the rightmost position in the row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The *Return* key finishes the editing session unless the user has input a formula
    with a syntax error, in which case an error message box is displayed. The user
    can also finish by pressing the *Tab* key or by clicking the mouse; in either
    case, the `Remark` method takes care of finishing the editing process. When the
    editing is finished, we try to mark the cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The *Tab* key does almost the same thing as the *Return* key. The only difference
    is that the next marked cell is, if possible, the cell to right or the cell to
    the left (if the user pressed the *Shift* key):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnEscapeKey` method is called when the user presses the *Esc* key and
    resets the cell to the value of the `prevCell` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnDeleteKey` method is called when the user presses the *Delete* key or
    selects the **Delete** menu item to delete a character in the `edit` mode or the
    contents of the marked block in the `mark` mode. In the `edit` mode, we delete
    the character of the edit index unless it is at the end of the text. In the `mark`
    mode, we just reset the marked cell. When the cells are reset, we need to re-evaluate
    their target cells recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnBackspaceKey` method is called when the user presses the *Backspace*
    key to delete a character in a cell in the `edit` mode or the contents of the
    marked block in the `mark` mode. In the `edit` mode, we decrement the edit index
    and remove the character by calling the `OnDeleteKey` method at the new index,
    unless the edit position is already at the beginning of text. In the `mark` mode,
    we just call the `OnDeleteKey` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: File management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the previous applications, the `ClearDocument` method is called by
    the `StandardDocument` class when the user selects the **New** menu item, the
    `WriteDocumentToStream` method is called when the user selects **Save** or **Save
    As**, and the `ReadDocumentFromStream` method is called when the user selects
    **Open** menu item.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ClearDocument` method, every cell is cleared along with their source
    and target sets. When a cell is reset, its text is cleared. When it is cleared,
    its font and color are also cleared. Finally, the application is set to the `mark`
    mode, where the top-left cell is marked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WriteCellToStream` method is a callback function that, given a cell and
    an output stream, writes the cell to the stream. In the same way, the `ReadCellFromStream`
    method reads a cell from an input stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WriteDocumentToStream` and `ReadDocumentFromStream` methods write and
    read the spreadsheet. More specifically, they read and write the `application`
    mode, the edit index and reference, the mark references, the source and target
    sets, and the cells in the cell matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we call the `MakeCellVisible` method at the end of the `ReadDocumentFromStream`
    method. The idea is that the user should be able to pick up the spreadsheet where
    they left it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WriteSetMapToStream` and `ReadSetMapFromStream` methods write and read
    the source and target sets. They are static, since they are called for both `sourceSetMap`
    and `targetSetMap`. For each cell in the spreadsheet, the size of the set as well
    as the references of the sets are written and read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Cut, copy, and paste
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Copy** menu item is enabled in the `mark` mode. Note that we do not override
    the `PasteEnable` method, since the `StandardDocument` class enables the **Paste**
    menu item if there is a clipboard buffer with one of the application formats–the
    `AsciiFormat`, `UnicodeFormat`, or `CalcFormat` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CopyAscii` method simply calls `CopyUnicode`, which in turn fills the
    `textList` list with the copied text. Each text in the `textList` list holds one
    row, and the columns are divided by semicolons ('';''):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CopyGeneric` method stores the top-left position and size of the marked
    block and calls the `WriteCellToClipboard` method for each marked cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsPasteAsciiReady` method simply calls the `IsPasteUnicodeReady` method,
    which returns `true` if there is only one cell currently marked and the block
    to be pasted fits in the spreadsheet, or if the currently marked block has the
    same size as the block to be pasted. Note that in the first case, if only one
    cell is marked, the block to be pasted does not have to have an equal number of
    columns for each row, as long as they fit in the spreadsheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the `IsPasteUnicodeReady` method, the `IsPasteGenericReady` method
    returns `true` if there is only cell marked at the moment and the block to be
    pasted fits in the spreadsheet or if the currently marked block and the block
    to be pasted have the same size. However, unlike the Unicode case we saw earlier,
    the rows of the generic block to be pasted all have the same size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PasteAscii` method simply calls the `PasteUnicode` method that first takes
    a backup of the cell matrix as well as the source and target set maps, since the
    cells to be pasted may contain a formula with syntax errors, in which case the
    pasting process will be aborted. Then, it iterates through the text to be pasted
    and splits each row in to columns. The text of each column is copied to the pasted
    cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The text of the column is interpreted, and if it holds a formula with a syntax
    error, an exception is thrown, stopping the iteration and restoring the backup
    matrix together with the source and target set maps. This is actually the reason
    why the `EvaluateRecursive` method fills the set of references to be invalidated
    instead of just invalidating them. If the pasting process fails due to a formula
    with a syntax error, we would not want any cells to become invalidated and updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'When the text has been interpreted, we need to update the references, in case
    it holds a formula, by comparing the location of the marked block with the original
    location (from where it was copied) of the pasted block in order for the reference
    to be relative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we set the source and target sets of the cell, evaluate its value,
    and generate its caret rectangle list. The evaluation may result in an error (missing
    value, reference out of range, circular reference, or division by zero), in which
    case an error message is stored in the cell text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The pasted cells are not invalidated until we have iterated through them and
    none of them has been found to hold a formula with a syntax error. Note that there
    may be more than just the pasted cells to be invalidated, the other cells outside
    the pasted block that are targets of the pasted cells, and thereby evaluated,
    need to be invalidated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'If one of the pasted cells holds a formula with a syntax error, we simply restore
    the backup and display a message box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PasteGeneric` method is simpler than the `PasteUnicode` method: since
    there is no need for cell interpretation (as the cell has been copied from the
    spreadsheet and thereby holds valid formulas), there in no need for backup and
    no exception is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Each pasted cell is read from the buffer and then the source cell is assigned
    to it. The target set is removed and then added by the pasted cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Delete** menu item is enabled in the `edit` mode unless the edit index
    is at the end of the cell''s text. The item is always enabled in the `mark` mode,
    since there is always at least one marked cell marked to be deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnDelete` method (the menu item) just calls `OnDeleteKey` (the key pressed),
    since they perform the same action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Font and color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OnFont` and `OnBackgroundColor` methods work in the same manner–they are
    called when the user selects the **Font** or **Background Color** items in the
    **Format** menu. They apply the change on the edited or marked cells, and the
    window and (in the edit case) the caret is updated. If at least one cell has been
    modified, the dirty flag is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `edit` mode, the font of the edited cell is changed if the `FontDialog`
    method returns `true` (the user has pressed the **Ok** button) and has chosen
    a different font. Note that the `FontDialog` method also sets the color of the
    font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `mark` mode, the font of each marked cell is set to the new font if
    the `FontDialog` method returns `true`. If the font of at least one cell is set
    (which we do not know from the start), the dirty flag is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnBackgroundColor` method is similar to the `OnFont` method. The only
    difference is that the `OnBackgroundColor` method calls the `ColorDialog` method
    instead of the `FontDialog` method, and that `BackgroundColor` is called for each
    cell instead of `Font`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Alignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The horizontal and vertical alignments follow the same pattern. The radio methods
    call the `IsHorizontalAlignment` or `IsVerticalAlignment` method, which return
    `true` if the edited cells or all the marked cells hold the alignment in question.
    The selection methods call the `SetHorizontalAlignment` or `SetVerticalAlignment`
    method, which set the alignment of the edited cell or every marked cell. If at
    least one cell has been modified, the dirty flag is set. Finally, the window and
    (in the edit case) caret are updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HorizontalLeftRadio`, `HorizontalCenterRadio`, `HorizontalRightRadio`,
    and `HorizontalJustifiedRadio` methods call the `IsHorizontalAlignment` method,
    as you''ll see next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsHorizontalAlignment` method returns `true` if the alignment of the edited
    cell or at least one of the marked cells holds the alignment in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnHorizontalLeft`,  `OnHorizontalCenter`,  `OnHorizontalRight`, and `OnHorizontalJustified`
    methods call the `SetHorizontalAlignment` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetHorizontalAlignment` method sets the alignment of the edited cell or
    all marked cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'For each cell whose alignment is changed, its caret rectangle list is regenerated
    and the cell becomes invalidated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The dirty flag is set, since at least one cell has been modified. Otherwise,
    the alignment menu item would not be enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The vertical alignment methods are similar to the horizontal alignment methods,
    as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Source and target sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each cell in the spreadsheet holds a numerical value, a formula, or a (possibly
    empty) plain text. As mentioned at the beginning of the chapter, a formula is
    a text beginning with the equal sign (=) followed by a numerical expression with
    cell references. If the cell holds a value, it may affect the values in other
    cells (if it does not hold a value, it might cause evaluation errors in target
    cells). If the cell contains a formula, its value may depend on the values in
    other cells. This implies that each cell needs a set of cells that it depends
    on, that is, its source set, and a set of cells that depend on it, that is, its
    target set.
  prefs: []
  type: TYPE_NORMAL
- en: Only a formula has a non-empty source set, which is the set of all references
    of the formula. The target set, on the other hand, is more complicated–a cell
    does not decide its own target set; it is decided indirectly by the formulas that
    have it as its source cell.
  prefs: []
  type: TYPE_NORMAL
- en: In mathematical terms, the cells with its source and target sets constitute
    a **directed graph**. Technically, they constitute two different directed graphs,
    one each for the source and target sets. However, the graphs are just inverses
    of each other, so in all practical ways, they can be regarded as the same graph.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in the screenshot that follows the source set of `a3` holds `a1`
    and `c1` because its formula includes `a1` and `c1`. In the same way, the source
    set of `c3` holds `c1` because its formula includes `c1`. The source set of `a1`
    and `c1` are empty, because they do not hold formulas.
  prefs: []
  type: TYPE_NORMAL
- en: As `c1` is included in both the formulas of `a3` and `c3`, the value of `c1`
    affects the values of `a3` and `c3`. This implies that the target set of `c1`
    holds `a3` and `c3`. In the same way, as `a1` is included in the formula of `a3`,
    the target set of `a1` holds `a3`. As the values of `a3` and `c3` do not affect
    the values of any other cells, their target sets are empty.
  prefs: []
  type: TYPE_NORMAL
- en: '![Source and target sets](img/B05475_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is a screenshot of the same spreadsheet with the `c3` cell being
    edited instead of the `a3` cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Source and target sets](img/B05475_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first of the following diagrams shows the acyclic graph of the source sets
    of the preceding spreadsheet, the second diagram shows the acyclic graph of the
    target sets. As mentioned previously (and shown by the graphs), the source and
    targets sets are the inverse of each other. Technically, we can manage with only
    one of the sets. However, as the sets are needed on different occasions, the code
    is clearer with both of them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Source and target sets](img/B05475_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the value of a cell is changed, its target set is traversed and the values
    of those cells are updated. Then the target sets of these cells are traversed,
    and so on. The search terminates when there are no more cells to evaluate or when
    we detect a circular reference. The circular reference is detected by a deep-search
    algorithm, which is described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Graph searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the user changes the value of a cell, we need to find the cells that need
    to be re-evaluated. Again, note the difference between source and target sets.
    While only formula cells can have non-empty source sets, all kinds of cells (also
    empty cells) can have non-empty target sets. Another difference between the two
    sets is that the target sets are defined indirectly by formulas in other cells.
    If a formula of another cell holds a reference to a particular cell, the reference
    to the formula cell is added to the target set of the particular cell. In the
    same way, when a formula is altered or cleared, the reference to that cell is
    removed from the target sets of all its source cells. When a cell is updated,
    all its targets are evaluated recursively–the targets cells are re-evaluated,
    then their target cells are re-evaluated, and so on. The evaluation always terminates
    when there are no more targets left, or when a circular reference is encountered.
    We always run out of targets or encounter a circular reference, since there is
    a finite number of cells in the spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InterpretEditCell` method is called when the user finishes the input of
    a cell. It interprets the cell by calling the `InterpretCell` method, which fills
    the `sourceSet` method but throws an exception in the case of a formula with a
    syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the parsing goes well, the previous source set is removed and the
    new source set is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the cell is recursively evaluated and all its direct or indirect target
    cells are updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, all evaluated cells are invalidated, the dirty flag is set, and `true`
    is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'If a syntax error is detected and an exception is thrown, an error message
    is displayed and `false` is returned. In that case, the application remains in
    `edit` mode if the user has finished the input. If the `InterpretEditCell` method
    has been called due to pasting, the pasting process is aborted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The `InvalidateCell` method invalidates the area occupied by the cell with
    the given reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The sources and targets sets can be searched and evaluated in two ways: **depth-first**
    and **breadth-first**. As the names implies, depth-first tries to search as deep
    as possible. When it reaches a dead end, it backtracks and tries another way,
    if there is one. Breadth-first, on the other hand, evaluates all cells at the
    same distance from the start cell. Not until every cell at a distance has been
    evaluated, are the cells at the next distance examined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user adds or alters a formula, it is essential that we detect potential
    circular references in the graph. The `IsCircular` method decides whether the
    cell is part of a circular reference, that is, a direct reference to its own cell
    or a chain of references leading to its own cell. We perform a depth-first search,
    which is easier than the breadth-first search, since we can take advantage of
    recursive calls. The breadth-first method is, on the other hand, necessary in
    order to evaluate the targets of a modified cell in the `EvaluateRecursive` method,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: When the value of a cell is modified, it is essential that the formulas having
    references to the cell are notified and that their values are re-evaluated. The
    `EvaluateRecursive` method performs a breadth-first search by following the target
    sets forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the check for circular references, which we saw earlier, we cannot perform
    a depth-first search, since it would introduce the risk of the cells being evaluated
    in the wrong order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'When a cell is being evaluated, it needs the values of the cells in its source
    set; the `valueMap` parameter holds the values of the source cells that holds
    some value. Every source cell not holding a value is omitted from the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'If this cell is not a part of a circular reference, we add the values of the
    referred cells with values to the `valueMap` parameter. Refereed cells without
    values are simply omitted from the `valueMap` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless of whether the cell was properly evaluated or was found to be part
    of a circular reference, we need to regenerate its caret rectangle list. It is
    either given a proper value or an error message, and in both cases, the text is
    changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RemoveTargetSetMap` method traverses the source set of the cell in the
    cell matrix and, for each source cell, removes the cell as a target. In the same
    way, the `AddTargetSetMap` method traverses the source set of the cell in the
    cell matrix and, for each source cell, adds the cell as a target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The evaluation errors are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Missing value**: This error occurs when the cell referred in a formula does
    not hold a value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference out of range**: This error occurs when a reference is outside the
    scope of the spreadsheet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circular reference**: This error occurs when a cell is referring to itself,
    directly or indirectly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Division by zero**: This error occurs when the denominator in a division
    expression is zero'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also the syntax error that occurs when the user inputs a syntactically
    incorrect formula.
  prefs: []
  type: TYPE_NORMAL
- en: '**Error.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '**Error.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked into how a spreadsheet program is implemented: the
    mouse and keyboard input; cut, copy, and paste; file management; and font, color,
    and alignment. [Chapter 9](ch09.html "Chapter 9. Formula Interpretation"), *Formula
    Interpretation*, will introduce cell handling and formula interpretation, including
    parsing, scanning, and caret rectangle list generation.'
  prefs: []
  type: TYPE_NORMAL
