- en: Chapter 7. Creating and Displaying Tile Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most 2D games that you have played in the past made use of **tile maps**. It
    is an extremely efficient and fast way to develop complex 2D levels or scenes.
    Even if a game has more complex graphical content, it is likely that it will still
    make use of tiles in some way. Throughout this chapter we will be using the **tiled
    map editor**, an open source and cross-platform tool created by Thorbjørn Lindeijer
    and a large open source community. It is available at [http://www.mapeditor.org/](http://www.mapeditor.org/).
    We will essentially make this tool our level editor and use it for creating maps
    and placing our objects within those maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: What a tile map is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a tile sheet looks like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the tiled map editor to create our maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing a state from a tiled map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and displaying a tile-based map in SDL 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a tile map?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have played a lot of 2D games then you will be very familiar with tile
    maps. We will start by looking at an example in the form of the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a tile map?](img/6821OT_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This 20 x 15 tile map was made using the following screenshot called a **tileset**.
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a tile map?](img/6821OT_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, one huge advantage to a tile system like this is that you can
    create large maps from relatively small image files. Tile maps are essentially
    a multidimensional array of IDs that tell us which part of the tileset we want
    to draw at each location. It will help to look at the images again with their
    IDs in place as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a tile map?](img/6821OT_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here is the tileset with its IDs in place as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a tile map?](img/6821OT_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To draw the map we loop through the number of columns and the number of rows,
    grab the correct tile using its ID, and draw it to the screen. Any tile with an
    ID of zero will not be drawn (a blank tile). This can be seen in the preceding
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with the Tiled application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tiled is a very user-friendly application that can greatly speed up our development
    time. Once you have downloaded and installed the application, open it up and you
    will be presented with the user interface as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting familiar with the Tiled application](img/6821OT_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the right-hand side we have the **Layers** and **Tilesets** views; the left-hand
    side will contain our tile map. First we must create a new map, this can be done
    by navigating to **File** | **New…** or *Ctrl* + *N*. This brings up the new map
    dialog as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting familiar with the Tiled application](img/6821OT_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we can define the size and type of our map. We are only going to use orthogonal
    tile maps (as opposed to isometric), so go ahead and create an orthogonal tile
    map that is 20 tiles wide and 15 tiles high, with tile width and height both set
    to 32 px. We can now see our tile map in the left-hand side of the UI (*Ctrl*
    + *G* will show the grid). Tiled will also automatically create a layer for us
    called **Tile Layer 1** (Visible in the **Layers** view on the right-hand side)
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting familiar with the Tiled application](img/6821OT_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are not going to deal with any terrain so we can turn off that tab by navigating
    to **View** | **Terrains** and unchecking. Save this map as `map1.tmx` in the
    same location as the rest of our game assets. If you open this file you will see
    that it is actually just an XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This should all look very familiar. Tiled has a few different compression algorithms
    that can be used to store the tile IDs of our maps. The preceding file uses the
    **zlib compression algorithm** along with **base64 encoding** which, as you can
    see, gives great results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compare the same map with base64 encoding and no compression, we can
    see that the extra work needed to decompress and parse the zlib compression is
    definitely worth it. Here is the uncompressed map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will cover this in more depth once we start parsing the tile maps, but for
    now let''s look at adding a tileset. Navigate to **Map** | **New Tileset…** and
    it will bring up a new **Tileset** dialog as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting familiar with the Tiled application](img/6821OT_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The tileset we will start with is `blocks1.png` as shown in the following screenshot,
    available in the source downloads.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting familiar with the Tiled application](img/6821OT_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Copy the image to the game assets location and then we can browse to it in
    the **New Tileset** dialog. This tileset has a 2 pixel wide margin around the
    outside and 2 pixel spacing between each tile; each tile is 32 x 32 pixels. Once
    these values are set, click on **OK** and the tileset will appear in the **Tilesets**
    view to the right-hand side. We can now start to build our map using the provided
    tools as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting familiar with the Tiled application](img/6821OT_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The red highlights are our bread-and-butter tools. The stamp tool adds the
    selected tile from the tileset to the given location, the paint bucket fills an
    area with a selected tile from the tileset, and the eraser tool, of course, erases.
    We can select tiles from the tileset one at a time or many at a time, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting familiar with the Tiled application](img/6821OT_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go ahead and get acquainted with these tools by building a simple map. Once
    the map is saved we will see that the tileset has been added to the map file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `firstgid` attribute is the first tile ID that uses this tileset. If we
    were to have more than one tileset, it would come with its own `firstgid` attribute
    so that we knew which tile IDs to start associating with that tileset; again,
    we will cover this in greater detail when we come to parse our maps. Add another
    tileset, `blocks2.png` (also available in the source code downloads), to our map
    and we shall move into drawing it in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing and drawing a tile map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are relatively familiar with creating tile maps in the Tiled application
    we will move on to parsing them and drawing them in our game. We are going to
    create quite a few new classes starting with a class called `Level` that will
    hold our tilesets and also draw and update our separate layers. Let''s go ahead
    and create `Level.h` in our project and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also define a `struct` at the top of this file called `Tileset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This `struct` holds any information we need to know about our tilesets. Our
    `Level` class will now also hold a vector of `Tileset` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will create a public getter function that returns a pointer to this
    `Tileset` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will pass this into our parser when we come to load the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next class we will create is an abstract base class called `Layer`. All
    of our layer types will derive from this class. Create `Layer.h` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the `Layer` class we will store a vector of the `Layer*` objects
    in the `Level` class. Back in `Level.h` add our vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And a getter function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a basic `Level` class in place; its purpose is to store, draw,
    and update our layers. We will define the functions for `Level` in a `Level.cpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating the TileLayer class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first layer type is going to be a `TileLayer`. This type of layer is made
    up entirely of tiles and does not contain anything else. We have already created
    a layer like this in the Tiled application. Create `TileLayer.h` and we can start
    to write up this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing too complicated about this class; it holds data for our tile
    layer. The `Vector2D` variables are used when we start to scroll our maps. We
    will not define this class' functions properly right now, but you will need to
    create empty definitions along with defining the vector constants in a `TileLayer.cpp`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the LevelParser class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the basic level and layer classes in place, we can move onto
    creating a parser for our `.tmx` files and creating levels from them. Create `LevelParser.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `parseLevel` function is what we will call whenever we want to create a
    level. To ensure that this function must be used to create a `Level` object, we
    will make the `Level` class'' constructor private and make it a friend class of
    `LevelParser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `LevelParser` has access to the private constructor of `Level` and can
    return new instances. We can now define the `parseLevel` function and then go
    through it step-by-step. Create `LevelParser.cpp` and define the `parseLevel`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We covered XML files and TinyXML in the previous chapter so I won''t go into
    detail again here. The first part of the function grabs the root node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see from the map file that this node has several attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We grab these values using the `Attribute` function from TinyXML and set the
    member variables of `LevelParser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we must check for any tileset nodes and parse them, using the `getTilesets`
    function of our newly created `Level` instance to pass in the `Tileset` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally we can check for any tile layers and then parse them, again using the
    getter functions from our `pLevel` object, which we then return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this function is very similar to our `parseState` function
    from the previous chapter. Now we must define the `parseTilesets` and `parseTileLayer`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing tilesets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Parsing tilesets is actually quite simple due to our `TextureManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the tileset to the `TextureManager` class using its attributes and then
    create a `Tileset` object and push it into the `pTilesets` array. The `pTilesets`
    array is actually a pointer to the array from our `pLevel` object which we previously
    created in the `parseLevel` function. Here is our first tileset so that you can
    look at it alongside the preceding function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Parsing a tile layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to the compression and encoding of our tile IDs, this function is actually
    quite complicated. We are going to make use of a few different libraries that
    will help us to decode and decompress our data, the first of which is a **Base64**
    decoder. We will be using a decoder created by René Nyffenegger, available from
    the source code downloads and also from [https://github.com/ReneNyffenegger/development_misc/tree/master/base64](https://github.com/ReneNyffenegger/development_misc/tree/master/base64).
    The `base64.h` and `base64.cpp` files can be added directly to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second library we will need is the `zlib` library, a compiled version is
    available at [http://www.zlib.net](http://www.zlib.net) and can be easily added
    to your project like any other library. Once these libraries are available to
    the project we can start parsing our tiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through this function step-by-step. First we create a new `TileLayer`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we declare some needed variables; a multidimensional array of `int` values
    to hold our final decoded and uncompressed tile data, a `std::string` that will
    be our base64 decoded information and finally a place to store our XML node once
    we find it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can search for the node we need in the same way we have previously done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have found the correct node we can then get the text from within it
    (our encoded/compressed data) and use the base64 decoder to decode it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `decodedIDs` variable is now a `base64` decoded `string`. The next step
    is to use the `zlib` library to decompress our data, this is done using the `uncompress`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `uncompress` function takes an array of `Bytef*` (defined in zlib''s `zconf.h`)
    as the destination buffer; we are using an `std::vector` of `int` values and casting
    it to a `Bytef*` array. The second parameter is the total size of the destination
    buffer, in our case we are using a `vector` of `int` values making the total size
    the number of rows x the number of columns x the size of an `int`; or `m_width
    * m_height * sizeof(int)`. We then pass in our decoded string and its size as
    the final two parameters. Our `ids` vector now contains all of our tile IDs and
    the function moves on to set the size of our data vector for us to fill with our
    tile IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now fill our data array with the correct values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: And finally we set this layer's tile data and then push the layer into the layers
    array of our `Level`.
  prefs: []
  type: TYPE_NORMAL
- en: We must now define the functions in our `Level.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are finally at a stage where we can start drawing our tiles to the screen.
    Inside the earlier created `TileLayer.cpp` file we will now need to define our
    functions for the layer. Starting with the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `Game::getGameWidth` and `Game::getGameHeight` functions are just simple
    getter functions that return variables set in the `Game::init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TileLayer` `update` function uses `velocity` to set the map''s position;
    we will cover this in more detail when we come to scroll our map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` function is where all the magic happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that there is a new function in the `TextureManager`, `drawTile`.
    This function is specifically for drawing tiles and includes margin and spacing
    values. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look closer at the `render` function; we will ignore the positioning
    code for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We loop through the number of columns and the number of rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not the number of rows and columns in the full tile ID array, it is
    actually the number of columns and rows needed to fill the size of our game. We
    do not want to be drawing anything that we do not have to. We obtained these values
    earlier in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we get the current tile ID from the array (ignore the `+ x` for now):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We check if the tile ID is 0\. If it is, then we do not want to draw anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise we grab the correct tileset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the tileset uses a very simple function, `getTilesetByID`, which compares
    each tileset''s `firstgid` value and returns the correct tileset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we move on to drawing the tiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'First we decrement the ID so that we can draw the correct tile from the tilesheet,
    even if it is at position `0,0`. We then use the `drawTile` function to copy across
    the correct tile using the tileset we grabbed earlier, to set the first parameter
    of the function, which is the `name` of the texture. Again, we can use the tileset
    for the next two parameters, `margin` and `spacing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The next two parameters set the position we want to draw our tiles at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Ignoring the `x2` and `y2` values for now (they are 0 anyway), we can set the
    current `x` position as the current column multiplied by the width of a tile and
    the `y` value as the current row multiplied by the height of a tile. We then set
    the width and height of the tile we are copying across:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally we work out the location of the tile on the tilesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We subtract the `firstGridID - 1` to allow us to treat each tilesheet the same
    and obtain the correct location. For example, the `firstGridID` of a tileset could
    be 50 and the current tile ID could be 70\. We know that this is actually going
    to be tile 19 (after we decrement the ID) on the tilesheet itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we must create a level in our `PlayState` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, draw it in the `render` function, and also do the same with the `update`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We will also have to comment out any functions that use objects (such as `collisionChecks`)
    as we don't have any yet and this will cause a runtime error. Run our game and
    you will see our tile map being drawn to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling a tile map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we have created so far is fine for a game that takes place in one area
    that is the size of our window, but what about if we want to have large maps that
    are open to exploration. This is where scrolling comes into play. We have actually
    implemented this already but have not yet gone through it step-by-step or seen
    it in action. Let's do this now.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we must resize our map in the Tiled application. Navigating to
    **Map** | **Resize Map…** will allow us to do this. Leave the height of our map
    at 15 and change the width to 60\. Fill up the remaining squares with whatever
    tiles you like. The map would then look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scrolling a tile map](img/6821OT_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Save the map and we can look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When scrolling the map we don't actually move it more than a tile width; we
    use the position value to work out where we should begin drawing our map from
    within the tile ID array. To get the `x` value we can use the position we have
    moved to divided by the tile width. For example, let's say that we have moved
    the map to `x position = 100` and the tile width is 32; this would give us a value
    of 3.125, but since we are using `int` values, this will simply be 3\. We now
    know that we are to start drawing from the third tile across on the map. The `y`
    position works in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that our tile drawing does not jump between tiles, but smoothly scrolls,
    we use a modulo calculation to get the remaining tile amount that we need to move
    by and use that to position our map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We then subtract these values in the `draw` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this by setting a velocity in our layers `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And then in `PlayState` we can call this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Run the game and you will see the map scrolling. At the moment we have not put
    any kind of handling in for looping the map or stopping at the end. We will cover
    this when we begin to create a game in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing object layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final topic we will cover in this chapter is loading objects from our Tiled
    map file. This is extremely useful and takes the guesswork out of placing objects
    within a level. Open up the Tiled application and we can create our first **Object
    Layer** by clicking **Layer** | **Add Object Layer**. This will create a new layer
    called **Object Layer 1** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing object layers](img/6821OT_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can create objects and assign any values and properties we want on these
    layers. First we will create a rectangle. Press *R* and click anywhere on your
    tile map, you will see a small square appear, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing object layers](img/6821OT_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Right-click on this square and click on **Object Properties…**. This will bring
    up the object properties dialog as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing object layers](img/6821OT_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can set the values we want our object to have, just like our previous
    state XML files. Go ahead and fill in the dialog box as shown in the preceding
    screenshot. The positions and sizes of this dialog box deal in tiles, not pixels,
    so `x = 1` is actually `x = tile width` and so on. Saving this map will add our
    new object layer to the map file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also going to use another property list to load in our textures for
    this map. **Map** | **Map Properties** will bring up the map properties dialog
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing object layers](img/6821OT_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we can add the textures we need for this map''s objects. The saved file
    will now have an additional property list for us to parse through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Developing the ObjectLayer class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in our project we will now create a new layer type called `ObjectLayer`.
    Create `ObjectLayer.h` and we can add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also define these functions in `ObjectLayer.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `ObjectLayer` class is very simple. It only needs to draw and update the
    objects for that layer. Now let''s parse our `ObjectLayer`. We will need two new
    functions in the `LevelParser` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `parseLevel` function must now include these functions and pass in the
    correct XML node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We will alter the way we were searching for tile layers to also search for
    object layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to define the new functions; `parseTextures` is a very small and
    simple function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'It gets the texture values and adds them to the `TextureManager`. The `parseObjects`
    function is a little longer but not particularly complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We load the object in a very similar way to the state parser, yet this time
    we must check for the `name` of the property rather than grabbing the `attribute`
    directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create the object just like the state parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'And add it to this layer''s game object array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have loaded all of the objects for this layer, we can push it into
    our `Level` layer array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Run the game and you will see our helicopter in the `PlayState` again.
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing the ObjectLayer class](img/6821OT_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are getting closer to a fully-fledged game all the time. This chapter covered
    a quick way to create 2D maps through the use of tiles and also looked at using
    an external application to place objects within our levels. The next two chapters
    will tie up all of the remaining loose ends and we will create some actual games.
  prefs: []
  type: TYPE_NORMAL
