- en: Chapter 7. Creating and Displaying Tile Maps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。创建和显示瓦片地图
- en: Most 2D games that you have played in the past made use of **tile maps**. It
    is an extremely efficient and fast way to develop complex 2D levels or scenes.
    Even if a game has more complex graphical content, it is likely that it will still
    make use of tiles in some way. Throughout this chapter we will be using the **tiled
    map editor**, an open source and cross-platform tool created by Thorbjørn Lindeijer
    and a large open source community. It is available at [http://www.mapeditor.org/](http://www.mapeditor.org/).
    We will essentially make this tool our level editor and use it for creating maps
    and placing our objects within those maps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数你过去玩过的二维游戏都使用了**瓦片地图**。这是一种极其高效且快速的方式来开发复杂的二维关卡或场景。即使一个游戏有更复杂的图形内容，它也可能会以某种方式使用瓦片。在本章中，我们将使用**tiled
    地图编辑器**，这是一个由 Thorbjørn Lindeijer 和一个大型开源社区创建的开源和跨平台工具。它可在[http://www.mapeditor.org/](http://www.mapeditor.org/)找到。我们将把这个工具作为我们的关卡编辑器，并使用它来创建地图以及在这些地图中放置我们的对象。
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: What a tile map is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是瓦片地图
- en: What a tile sheet looks like
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瓦片图看起来像什么
- en: Using the tiled map editor to create our maps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 tiled 地图编辑器创建我们的地图
- en: Parsing a state from a tiled map
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 tiled 地图中解析状态
- en: Loading and displaying a tile-based map in SDL 2.0
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SDL 2.0 中加载和显示基于瓦片的地图
- en: What is a tile map?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是瓦片地图？
- en: 'If you have played a lot of 2D games then you will be very familiar with tile
    maps. We will start by looking at an example in the form of the following screenshot:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩过很多二维游戏，那么你对瓦片地图会非常熟悉。我们将从以下屏幕截图中的示例开始：
- en: '![What is a tile map?](img/6821OT_07_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![什么是瓦片地图？](img/6821OT_07_01.jpg)'
- en: This 20 x 15 tile map was made using the following screenshot called a **tileset**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 20 x 15 的瓦片地图是使用以下屏幕截图所示的**瓦片集**制作的。
- en: '![What is a tile map?](img/6821OT_07_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![什么是瓦片地图？](img/6821OT_07_02.jpg)'
- en: 'As you can see, one huge advantage to a tile system like this is that you can
    create large maps from relatively small image files. Tile maps are essentially
    a multidimensional array of IDs that tell us which part of the tileset we want
    to draw at each location. It will help to look at the images again with their
    IDs in place as shown in the following screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种瓦片系统的一个巨大优势是，你可以从相对较小的图像文件中创建大型地图。瓦片地图本质上是一个多维数组，其中的 ID 告诉我们想要在每个位置绘制瓦片集中的哪个部分。再次查看带有
    ID 的图像将有所帮助，如下面的屏幕截图所示：
- en: '![What is a tile map?](img/6821OT_07_03.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![什么是瓦片地图？](img/6821OT_07_03.jpg)'
- en: Here is the tileset with its IDs in place as shown in the preceding screenshot.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是带有其 ID 的瓦片集，如前面的屏幕截图所示。
- en: '![What is a tile map?](img/6821OT_07_04.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![什么是瓦片地图？](img/6821OT_07_04.jpg)'
- en: To draw the map we loop through the number of columns and the number of rows,
    grab the correct tile using its ID, and draw it to the screen. Any tile with an
    ID of zero will not be drawn (a blank tile). This can be seen in the preceding
    screenshot.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制地图，我们遍历列数和行数，使用其 ID 获取正确的瓦片，并将其绘制到屏幕上。任何 ID 为零的瓦片将不会绘制（一个空白瓦片）。这可以在前面的屏幕截图中看到。
- en: Getting familiar with the Tiled application
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉 Tiled 应用程序
- en: 'Tiled is a very user-friendly application that can greatly speed up our development
    time. Once you have downloaded and installed the application, open it up and you
    will be presented with the user interface as shown in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Tiled 是一个非常用户友好的应用程序，可以大大加快我们的开发时间。一旦你下载并安装了应用程序，打开它，你将看到如下所示的用户界面：
- en: '![Getting familiar with the Tiled application](img/6821OT_07_05.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![熟悉 Tiled 应用程序](img/6821OT_07_05.jpg)'
- en: 'On the right-hand side we have the **Layers** and **Tilesets** views; the left-hand
    side will contain our tile map. First we must create a new map, this can be done
    by navigating to **File** | **New…** or *Ctrl* + *N*. This brings up the new map
    dialog as shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，我们有**层**和**瓦片集**视图；左侧将包含我们的瓦片地图。首先，我们必须创建一个新的地图，这可以通过导航到**文件** | **新建…**或*Ctrl*
    + *N*来完成。这将打开新的地图对话框，如下面的屏幕截图所示：
- en: '![Getting familiar with the Tiled application](img/6821OT_07_06.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![熟悉 Tiled 应用程序](img/6821OT_07_06.jpg)'
- en: 'Here we can define the size and type of our map. We are only going to use orthogonal
    tile maps (as opposed to isometric), so go ahead and create an orthogonal tile
    map that is 20 tiles wide and 15 tiles high, with tile width and height both set
    to 32 px. We can now see our tile map in the left-hand side of the UI (*Ctrl*
    + *G* will show the grid). Tiled will also automatically create a layer for us
    called **Tile Layer 1** (Visible in the **Layers** view on the right-hand side)
    as shown in the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以定义我们地图的大小和类型。我们只将使用正交瓦片地图（与等距地图相对），因此请创建一个宽度为 20 个瓦片、高度为 15 个瓦片的正交瓦片地图，瓦片宽度和高度都设置为
    32 像素。现在我们可以在 UI 的左侧看到我们的瓦片地图（*Ctrl* + *G* 将显示网格）。Tiled 还会自动为我们创建一个名为 **Tile Layer
    1** 的图层（在右侧的 **图层** 视图中可见），如下面的截图所示：
- en: '![Getting familiar with the Tiled application](img/6821OT_07_07.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![熟悉 Tiled 应用程序](img/6821OT_07_07.jpg)'
- en: 'We are not going to deal with any terrain so we can turn off that tab by navigating
    to **View** | **Terrains** and unchecking. Save this map as `map1.tmx` in the
    same location as the rest of our game assets. If you open this file you will see
    that it is actually just an XML file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会处理任何地形，因此我们可以通过导航到 **视图** | **地形** 并取消选中来关闭该选项卡。将此地图保存为 `map1.tmx`，与我们的其他游戏资源在同一位置。如果您打开此文件，您会看到它实际上只是一个
    XML 文件：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should all look very familiar. Tiled has a few different compression algorithms
    that can be used to store the tile IDs of our maps. The preceding file uses the
    **zlib compression algorithm** along with **base64 encoding** which, as you can
    see, gives great results:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切看起来都应该非常熟悉。Tiled 有几种不同的压缩算法，可以用来存储我们地图的瓦片 ID。前面的文件使用了 **zlib 压缩算法** 以及 **base64
    编码**，正如您所看到的，这给出了非常好的结果：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we compare the same map with base64 encoding and no compression, we can
    see that the extra work needed to decompress and parse the zlib compression is
    definitely worth it. Here is the uncompressed map:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将使用 base64 编码且没有压缩的相同地图进行比较，我们可以看到，为了解压和解析 zlib 压缩所需的额外工作绝对物有所值。以下是未压缩的地图：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will cover this in more depth once we start parsing the tile maps, but for
    now let''s look at adding a tileset. Navigate to **Map** | **New Tileset…** and
    it will bring up a new **Tileset** dialog as shown in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始解析瓦片地图，我们将更深入地介绍这一点，但到目前为止，让我们看看如何添加一个瓦片集。导航到 **地图** | **新建瓦片集…**，它将弹出一个新的
    **瓦片集** 对话框，如下面的截图所示：
- en: '![Getting familiar with the Tiled application](img/6821OT_07_08.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![熟悉 Tiled 应用程序](img/6821OT_07_08.jpg)'
- en: The tileset we will start with is `blocks1.png` as shown in the following screenshot,
    available in the source downloads.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始的瓦片集是 `blocks1.png`，如下面的截图所示，可在源代码下载中找到。
- en: '![Getting familiar with the Tiled application](img/6821OT_07_09.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![熟悉 Tiled 应用程序](img/6821OT_07_09.jpg)'
- en: 'Copy the image to the game assets location and then we can browse to it in
    the **New Tileset** dialog. This tileset has a 2 pixel wide margin around the
    outside and 2 pixel spacing between each tile; each tile is 32 x 32 pixels. Once
    these values are set, click on **OK** and the tileset will appear in the **Tilesets**
    view to the right-hand side. We can now start to build our map using the provided
    tools as shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像复制到游戏资源位置，然后我们可以在 **新建瓦片集** 对话框中浏览到它。这个瓦片集在外围有 2 像素宽的边框，每个瓦片之间有 2 像素的间距；每个瓦片是
    32 x 32 像素。一旦设置了这些值，点击 **确定**，瓦片集将出现在右侧的 **瓦片集** 视图中。现在我们可以开始使用提供的工具构建我们的地图，如下面的截图所示：
- en: '![Getting familiar with the Tiled application](img/6821OT_07_10.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![熟悉 Tiled 应用程序](img/6821OT_07_10.jpg)'
- en: 'The red highlights are our bread-and-butter tools. The stamp tool adds the
    selected tile from the tileset to the given location, the paint bucket fills an
    area with a selected tile from the tileset, and the eraser tool, of course, erases.
    We can select tiles from the tileset one at a time or many at a time, as shown
    in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 红色突出显示的是我们的基本工具。印章工具将瓦片集中的所选瓦片添加到指定位置，油漆桶工具用瓦片集中的所选瓦片填充一个区域，而橡皮擦工具当然用于擦除。我们可以一次选择一个或多个瓦片，如下面的截图所示：
- en: '![Getting familiar with the Tiled application](img/6821OT_07_11.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![熟悉 Tiled 应用程序](img/6821OT_07_11.jpg)'
- en: 'Go ahead and get acquainted with these tools by building a simple map. Once
    the map is saved we will see that the tileset has been added to the map file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建一个简单的地图来熟悉这些工具。一旦地图保存，我们将看到瓦片集已被添加到地图文件中：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `firstgid` attribute is the first tile ID that uses this tileset. If we
    were to have more than one tileset, it would come with its own `firstgid` attribute
    so that we knew which tile IDs to start associating with that tileset; again,
    we will cover this in greater detail when we come to parse our maps. Add another
    tileset, `blocks2.png` (also available in the source code downloads), to our map
    and we shall move into drawing it in our game.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstgid`属性是使用此瓦片集的第一个瓦片ID。如果我们有多个瓦片集，它们将各自带有自己的`firstgid`属性，这样我们就可以知道哪些瓦片ID应该与哪个瓦片集关联；我们将在解析我们的地图时更详细地介绍这一点。向我们的地图添加另一个瓦片集`blocks2.png`（也包含在源代码下载中），然后我们将进入在游戏中绘制它的步骤。'
- en: Parsing and drawing a tile map
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析和绘制瓦片地图
- en: 'Now that we are relatively familiar with creating tile maps in the Tiled application
    we will move on to parsing them and drawing them in our game. We are going to
    create quite a few new classes starting with a class called `Level` that will
    hold our tilesets and also draw and update our separate layers. Let''s go ahead
    and create `Level.h` in our project and add the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们相对熟悉了在Tiled应用程序中创建瓦片地图，我们将继续解析它们并在我们的游戏中绘制它们。我们将创建许多新的类，从名为`Level`的类开始，这个类将存储我们的瓦片集，并绘制和更新我们的单独层。让我们继续在我们的项目中创建`Level.h`并添加以下代码：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will also define a `struct` at the top of this file called `Tileset`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在文件顶部定义一个名为`Tileset`的`struct`：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This `struct` holds any information we need to know about our tilesets. Our
    `Level` class will now also hold a vector of `Tileset` objects:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`struct`包含了我们需要了解的关于我们的瓦片集的任何信息。现在，我们的`Level`类也将包含一个`Tileset`对象的向量：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next we will create a public getter function that returns a pointer to this
    `Tileset` vector:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个公共的获取函数，该函数返回指向这个`Tileset`向量的指针：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will pass this into our parser when we come to load the map.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达加载地图时，我们将把这个传递给我们的解析器。
- en: 'The next class we will create is an abstract base class called `Layer`. All
    of our layer types will derive from this class. Create `Layer.h` and add the following
    code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要创建的类是一个名为`Layer`的抽象基类。我们所有的层类型都将从这个类派生。创建`Layer.h`并添加以下代码：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have the `Layer` class we will store a vector of the `Layer*` objects
    in the `Level` class. Back in `Level.h` add our vector:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Layer`类，我们将在`Level`类中存储一个`Layer*`对象的向量。回到`Level.h`，添加我们的向量：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And a getter function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个获取函数：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we have a basic `Level` class in place; its purpose is to store, draw,
    and update our layers. We will define the functions for `Level` in a `Level.cpp`
    file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了基本的`Level`类；它的目的是存储、绘制和更新我们的层。我们将在`Level.cpp`文件中定义`Level`的函数：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating the TileLayer class
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建TileLayer类
- en: 'Our first layer type is going to be a `TileLayer`. This type of layer is made
    up entirely of tiles and does not contain anything else. We have already created
    a layer like this in the Tiled application. Create `TileLayer.h` and we can start
    to write up this class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一层类型将是一个`TileLayer`。这种类型的层完全由瓦片组成，不包含其他任何内容。我们已经在Tiled应用程序中创建了一个类似的层。创建`TileLayer.h`，然后我们可以开始编写这个类：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is nothing too complicated about this class; it holds data for our tile
    layer. The `Vector2D` variables are used when we start to scroll our maps. We
    will not define this class' functions properly right now, but you will need to
    create empty definitions along with defining the vector constants in a `TileLayer.cpp`
    file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这节课并没有什么太复杂的；它为我们的瓦片层存储数据。当开始滚动地图时，会使用`Vector2D`变量。我们现在不会正确地定义这个类的函数，但你需要创建空的定义，并在`TileLayer.cpp`文件中定义向量常量。
- en: Creating the LevelParser class
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建LevelParser类
- en: 'Now that we have the basic level and layer classes in place, we can move onto
    creating a parser for our `.tmx` files and creating levels from them. Create `LevelParser.h`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了基本的等级和层类，我们可以继续创建解析我们的`.tmx`文件的解析器，并从它们中创建等级。创建`LevelParser.h`：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `parseLevel` function is what we will call whenever we want to create a
    level. To ensure that this function must be used to create a `Level` object, we
    will make the `Level` class'' constructor private and make it a friend class of
    `LevelParser`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseLevel`函数是我们每次想要创建一个等级时都会调用的函数。为了确保必须使用此函数来创建`Level`对象，我们将`Level`类的构造函数设为私有，并使其成为`LevelParser`的友元类：'
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now `LevelParser` has access to the private constructor of `Level` and can
    return new instances. We can now define the `parseLevel` function and then go
    through it step-by-step. Create `LevelParser.cpp` and define the `parseLevel`
    function as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`LevelParser`可以访问`Level`的私有构造函数，并可以返回新的实例。我们现在可以定义`parseLevel`函数，然后逐步进行。创建`LevelParser.cpp`并定义`parseLevel`函数如下：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We covered XML files and TinyXML in the previous chapter so I won''t go into
    detail again here. The first part of the function grabs the root node:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中已经介绍了XML文件和TinyXML，所以在这里我不会再详细说明。函数的第一部分获取根节点：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can see from the map file that this node has several attributes:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从地图文件中看到这个节点有几个属性：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We grab these values using the `Attribute` function from TinyXML and set the
    member variables of `LevelParser`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用TinyXML的`Attribute`函数获取这些值，并设置`LevelParser`的成员变量：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next we must check for any tileset nodes and parse them, using the `getTilesets`
    function of our newly created `Level` instance to pass in the `Tileset` vector:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们必须检查任何瓦片集节点，并解析它们，使用我们新创建的`Level`实例的`getTilesets`函数将`Tileset`向量传递进去：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally we can check for any tile layers and then parse them, again using the
    getter functions from our `pLevel` object, which we then return:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以检查任何瓦片层，然后解析它们，再次使用我们的`pLevel`对象中的getter函数，然后将其返回：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see that this function is very similar to our `parseState` function
    from the previous chapter. Now we must define the `parseTilesets` and `parseTileLayer`
    functions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这个函数与我们上一章中的`parseState`函数非常相似。现在我们必须定义`parseTilesets`和`parseTileLayer`函数。
- en: Parsing tilesets
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析瓦片集
- en: 'Parsing tilesets is actually quite simple due to our `TextureManager` class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`TextureManager`类，解析瓦片集实际上非常简单：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We add the tileset to the `TextureManager` class using its attributes and then
    create a `Tileset` object and push it into the `pTilesets` array. The `pTilesets`
    array is actually a pointer to the array from our `pLevel` object which we previously
    created in the `parseLevel` function. Here is our first tileset so that you can
    look at it alongside the preceding function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用其属性将瓦片集添加到`TextureManager`类中，然后创建一个`Tileset`对象并将其推入`pTilesets`数组。`pTilesets`数组实际上是我们之前在`parseLevel`函数中创建的`pLevel`对象数组的指针。以下是我们的第一个瓦片集，以便您可以与前面的函数一起查看：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Parsing a tile layer
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析瓦片层
- en: Due to the compression and encoding of our tile IDs, this function is actually
    quite complicated. We are going to make use of a few different libraries that
    will help us to decode and decompress our data, the first of which is a **Base64**
    decoder. We will be using a decoder created by René Nyffenegger, available from
    the source code downloads and also from [https://github.com/ReneNyffenegger/development_misc/tree/master/base64](https://github.com/ReneNyffenegger/development_misc/tree/master/base64).
    The `base64.h` and `base64.cpp` files can be added directly to the project.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的瓦片ID经过了压缩和编码，这个函数实际上相当复杂。我们将利用几个不同的库来帮助我们解码和解压缩我们的数据，其中第一个是一个**Base64**解码器。我们将使用由René
    Nyffenegger创建的解码器，可以从源代码下载中获取，也可以从[https://github.com/ReneNyffenegger/development_misc/tree/master/base64](https://github.com/ReneNyffenegger/development_misc/tree/master/base64)获取。`base64.h`和`base64.cpp`文件可以直接添加到项目中。
- en: 'The second library we will need is the `zlib` library, a compiled version is
    available at [http://www.zlib.net](http://www.zlib.net) and can be easily added
    to your project like any other library. Once these libraries are available to
    the project we can start parsing our tiles:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的第二个库是`zlib`库，编译版本可在[http://www.zlib.net](http://www.zlib.net)找到，可以像添加其他库一样轻松地将其添加到项目中。一旦这些库可用，我们就可以开始解析我们的瓦片了：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s go through this function step-by-step. First we create a new `TileLayer`
    instance:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这个函数。首先我们创建一个新的`TileLayer`实例：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next we declare some needed variables; a multidimensional array of `int` values
    to hold our final decoded and uncompressed tile data, a `std::string` that will
    be our base64 decoded information and finally a place to store our XML node once
    we find it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们声明一些需要的变量；一个多维数组，用于存储我们最终解码和未压缩的瓦片数据，一个`std::string`，它将是我们base64解码后的信息，以及一旦找到XML节点后存储该节点的地方：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can search for the node we need in the same way we have previously done:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像之前做的那样搜索我们需要的节点：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once we have found the correct node we can then get the text from within it
    (our encoded/compressed data) and use the base64 decoder to decode it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了正确的节点，我们就可以从其中获取文本（我们的编码/压缩数据），并使用base64解码器对其进行解码：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our `decodedIDs` variable is now a `base64` decoded `string`. The next step
    is to use the `zlib` library to decompress our data, this is done using the `uncompress`
    function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `decodedIDs` 变量现在是一个 `base64` 解码后的 `string`。下一步是使用 `zlib` 库来解压缩我们的数据，这是通过
    `uncompress` 函数完成的：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `uncompress` function takes an array of `Bytef*` (defined in zlib''s `zconf.h`)
    as the destination buffer; we are using an `std::vector` of `int` values and casting
    it to a `Bytef*` array. The second parameter is the total size of the destination
    buffer, in our case we are using a `vector` of `int` values making the total size
    the number of rows x the number of columns x the size of an `int`; or `m_width
    * m_height * sizeof(int)`. We then pass in our decoded string and its size as
    the final two parameters. Our `ids` vector now contains all of our tile IDs and
    the function moves on to set the size of our data vector for us to fill with our
    tile IDs:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`uncompress` 函数接受一个 `Bytef*` 数组（在 zlib 的 `zconf.h` 中定义）作为目标缓冲区；我们使用一个 `int`
    值的 `std::vector` 并将其转换为 `Bytef*` 数组。第二个参数是目标缓冲区的总大小，在我们的例子中，我们使用一个 `int` 值的 `vector`，使得总大小为行数乘以列数乘以
    `int` 的大小；或者 `m_width * m_height * sizeof(int)`。然后，我们将解码后的字符串及其大小作为最后两个参数传递。现在，我们的
    `ids` 向量包含了所有的瓦片 ID，函数继续设置我们用于填充瓦片 ID 的数据向量的大小：'
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now fill our data array with the correct values:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以用正确的值填充我们的数据数组：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: And finally we set this layer's tile data and then push the layer into the layers
    array of our `Level`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置这个层的瓦片数据，然后将层推入 `Level` 的层数组中。
- en: We must now define the functions in our `Level.cpp` file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须在 `Level.cpp` 文件中定义函数。
- en: Drawing the map
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制地图
- en: 'We are finally at a stage where we can start drawing our tiles to the screen.
    Inside the earlier created `TileLayer.cpp` file we will now need to define our
    functions for the layer. Starting with the constructor:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到了可以开始将我们的瓦片绘制到屏幕上的阶段。在之前创建的 `TileLayer.cpp` 文件中，我们现在需要定义层的函数。从构造函数开始：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The new `Game::getGameWidth` and `Game::getGameHeight` functions are just simple
    getter functions that return variables set in the `Game::init` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `Game::getGameWidth` 和 `Game::getGameHeight` 函数只是简单的获取器函数，返回在 `Game::init`
    函数中设置的变量：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `TileLayer` `update` function uses `velocity` to set the map''s position;
    we will cover this in more detail when we come to scroll our map:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`TileLayer` 的 `update` 函数使用 `velocity` 来设置地图的位置；当我们开始滚动地图时，我们将更详细地介绍这一点：'
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `render` function is where all the magic happens:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 函数是所有魔法发生的地方：'
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You will notice that there is a new function in the `TextureManager`, `drawTile`.
    This function is specifically for drawing tiles and includes margin and spacing
    values. Here it is:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在 `TextureManager` 中有一个新的函数，`drawTile`。这个函数专门用于绘制瓦片，并包括边距和间距值。下面是它的样子：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s look closer at the `render` function; we will ignore the positioning
    code for now:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 `render` 函数；现在我们将忽略定位代码：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We loop through the number of columns and the number of rows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历列数和行数：
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is not the number of rows and columns in the full tile ID array, it is
    actually the number of columns and rows needed to fill the size of our game. We
    do not want to be drawing anything that we do not have to. We obtained these values
    earlier in the constructor:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是完整瓦片 ID 数组中的行数和列数，实际上是我们需要填充游戏大小的列数和行数。我们不希望绘制任何不必要的图形。我们之前在构造函数中获得了这些值：
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next we get the current tile ID from the array (ignore the `+ x` for now):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从数组中获取当前的瓦片 ID（现在忽略 `+ x`）：
- en: '[PRE39]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We check if the tile ID is 0\. If it is, then we do not want to draw anything:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查瓦片 ID 是否为 0。如果是，那么我们不想绘制任何东西：
- en: '[PRE40]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Otherwise we grab the correct tileset:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们获取正确的 tileset：
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Getting the tileset uses a very simple function, `getTilesetByID`, which compares
    each tileset''s `firstgid` value and returns the correct tileset:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 tileset 使用一个非常简单的函数，`getTilesetByID`，它比较每个 tileset 的 `firstgid` 值并返回正确的 tileset：
- en: '[PRE42]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next we move on to drawing the tiles:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们继续绘制瓦片：
- en: '[PRE43]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'First we decrement the ID so that we can draw the correct tile from the tilesheet,
    even if it is at position `0,0`. We then use the `drawTile` function to copy across
    the correct tile using the tileset we grabbed earlier, to set the first parameter
    of the function, which is the `name` of the texture. Again, we can use the tileset
    for the next two parameters, `margin` and `spacing`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 ID 减小，以便我们可以从 tilesheet 中绘制正确的瓦片，即使它位于位置 `0,0`。然后，我们使用 `drawTile` 函数，通过我们之前获取的
    tileset 来复制正确的瓦片，设置函数的第一个参数，即纹理的 `name`。同样，我们可以使用 tileset 来设置接下来的两个参数，`margin`
    和 `spacing`：
- en: '[PRE44]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The next two parameters set the position we want to draw our tiles at:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个参数设置我们要绘制瓦片的起始位置：
- en: '[PRE45]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Ignoring the `x2` and `y2` values for now (they are 0 anyway), we can set the
    current `x` position as the current column multiplied by the width of a tile and
    the `y` value as the current row multiplied by the height of a tile. We then set
    the width and height of the tile we are copying across:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在忽略`x2`和`y2`值（它们无论如何都是0），我们可以将当前`x`位置设置为当前列乘以瓦片的宽度，将`y`值设置为当前行乘以瓦片的高度。然后我们设置我们要复制的瓦片的宽度和高度：
- en: '[PRE46]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And finally we work out the location of the tile on the tilesheet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算出瓦片在瓦片集中的位置：
- en: '[PRE47]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We subtract the `firstGridID - 1` to allow us to treat each tilesheet the same
    and obtain the correct location. For example, the `firstGridID` of a tileset could
    be 50 and the current tile ID could be 70\. We know that this is actually going
    to be tile 19 (after we decrement the ID) on the tilesheet itself.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们减去`firstGridID - 1`以允许我们对待每个瓦片集相同，并获得正确的位置。例如，瓦片集的`firstGridID`可能是50，当前瓦片ID可能是70。我们知道这实际上将是瓦片集中的第19个瓦片（在我们递减ID之后）。
- en: 'Finally, we must create a level in our `PlayState` class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在我们的`PlayState`类中创建一个级别：
- en: '[PRE48]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, draw it in the `render` function, and also do the same with the `update`
    function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`render`函数中绘制它，并在`update`函数中也做同样的操作：
- en: '[PRE49]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We will also have to comment out any functions that use objects (such as `collisionChecks`)
    as we don't have any yet and this will cause a runtime error. Run our game and
    you will see our tile map being drawn to the screen.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须注释掉任何使用对象（如`collisionChecks`）的函数，因为我们还没有任何对象，这将导致运行时错误。运行我们的游戏，你会看到我们的瓦片地图被绘制到屏幕上。
- en: Scrolling a tile map
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动瓦片地图
- en: What we have created so far is fine for a game that takes place in one area
    that is the size of our window, but what about if we want to have large maps that
    are open to exploration. This is where scrolling comes into play. We have actually
    implemented this already but have not yet gone through it step-by-step or seen
    it in action. Let's do this now.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前创建的内容对于在一个区域发生游戏（该区域的大小与我们的窗口大小相同）是不错的，但如果我们想要有大型地图，这些地图是开放的，可以探索的，那会怎样呢？这就是滚动发挥作用的地方。我们实际上已经实现了这个功能，但还没有一步一步地介绍它，也没有看到它的实际效果。现在让我们来做这件事。
- en: 'First of all, we must resize our map in the Tiled application. Navigating to
    **Map** | **Resize Map…** will allow us to do this. Leave the height of our map
    at 15 and change the width to 60\. Fill up the remaining squares with whatever
    tiles you like. The map would then look like the following screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在Tiled应用程序中调整我们的地图大小。导航到**地图** | **调整地图大小…**将允许我们这样做。保持地图的高度为15，将宽度更改为60。用你喜欢的瓦片填满剩余的方块。地图将看起来像以下截图：
- en: '![Scrolling a tile map](img/6821OT_07_12.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![滚动瓦片地图](img/6821OT_07_12.jpg)'
- en: 'Save the map and we can look at the code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 保存地图，我们就可以查看代码：
- en: '[PRE50]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When scrolling the map we don't actually move it more than a tile width; we
    use the position value to work out where we should begin drawing our map from
    within the tile ID array. To get the `x` value we can use the position we have
    moved to divided by the tile width. For example, let's say that we have moved
    the map to `x position = 100` and the tile width is 32; this would give us a value
    of 3.125, but since we are using `int` values, this will simply be 3\. We now
    know that we are to start drawing from the third tile across on the map. The `y`
    position works in the same way.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当滚动地图时，我们实际上不会移动它超过一个瓦片的宽度；我们使用位置值来确定我们应该从瓦片ID数组中开始绘制地图的位置。要获取`x`值，我们可以使用移动到的位置除以瓦片的宽度。例如，假设我们将地图移动到`x位置
    = 100`，瓦片宽度为32；这将给出3.125的值，但由于我们使用的是`int`值，这将简单地是3。我们现在知道我们应该从地图上的第三个瓦片开始绘制。`y`位置的工作方式相同。
- en: 'To ensure that our tile drawing does not jump between tiles, but smoothly scrolls,
    we use a modulo calculation to get the remaining tile amount that we need to move
    by and use that to position our map:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的瓦片绘制不会在瓦片之间跳跃，而是平滑滚动，我们使用模运算来获取我们需要移动的剩余瓦片数量，并使用这个值来定位我们的地图：
- en: '[PRE51]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We then subtract these values in the `draw` function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后在`draw`函数中减去这些值：
- en: '[PRE52]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can test this by setting a velocity in our layers `update` function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在我们的层的`update`函数中设置速度来测试这一点：
- en: '[PRE53]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And then in `PlayState` we can call this function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`PlayState`中我们可以调用这个函数：
- en: '[PRE54]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Run the game and you will see the map scrolling. At the moment we have not put
    any kind of handling in for looping the map or stopping at the end. We will cover
    this when we begin to create a game in later chapters.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，你会看到地图滚动。目前我们还没有为循环地图或停止在末尾添加任何处理。我们将在后面的章节中创建游戏时讨论这个问题。
- en: Parsing object layers
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析对象层
- en: 'The final topic we will cover in this chapter is loading objects from our Tiled
    map file. This is extremely useful and takes the guesswork out of placing objects
    within a level. Open up the Tiled application and we can create our first **Object
    Layer** by clicking **Layer** | **Add Object Layer**. This will create a new layer
    called **Object Layer 1** as shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的最后一个主题是从我们的Tiled地图文件中加载对象。这非常实用，并消除了在级别内放置对象的猜测工作。打开Tiled应用程序，我们可以通过点击**层**
    | **添加对象层**来创建我们的第一个**对象层**。这将创建一个新的层，称为**对象层1**，如下面的截图所示：
- en: '![Parsing object layers](img/6821OT_07_13.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![解析对象层](img/6821OT_07_13.jpg)'
- en: 'We can create objects and assign any values and properties we want on these
    layers. First we will create a rectangle. Press *R* and click anywhere on your
    tile map, you will see a small square appear, as shown in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这些层上创建对象并分配我们想要的任何值和属性。首先我们将创建一个矩形。按*R*键并在你的瓦片地图上点击任何地方，你会看到一个小的正方形出现，如下面的截图所示：
- en: '![Parsing object layers](img/6821OT_07_14.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![解析对象层](img/6821OT_07_14.jpg)'
- en: 'Right-click on this square and click on **Object Properties…**. This will bring
    up the object properties dialog as shown in the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击这个正方形，然后点击**对象属性…**。这将弹出对象属性对话框，如下面的截图所示：
- en: '![Parsing object layers](img/6821OT_07_15.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![解析对象层](img/6821OT_07_15.jpg)'
- en: 'Here, we can set the values we want our object to have, just like our previous
    state XML files. Go ahead and fill in the dialog box as shown in the preceding
    screenshot. The positions and sizes of this dialog box deal in tiles, not pixels,
    so `x = 1` is actually `x = tile width` and so on. Saving this map will add our
    new object layer to the map file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以设置我们想要我们的对象拥有的值，就像我们之前的州XML文件一样。按照前面的截图填写对话框。这个对话框的位置和大小是以瓦片为单位的，而不是像素，所以`x
    = 1`实际上是`x = 瓦片宽度`等等。保存这个地图将把我们的新对象层添加到地图文件中：
- en: '[PRE55]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We are also going to use another property list to load in our textures for
    this map. **Map** | **Map Properties** will bring up the map properties dialog
    as shown in the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用另一个属性列表来加载这个地图的纹理。**地图** | **地图属性**将弹出地图属性对话框，如下面的截图所示：
- en: '![Parsing object layers](img/6821OT_07_16.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![解析对象层](img/6821OT_07_16.jpg)'
- en: 'Here we can add the textures we need for this map''s objects. The saved file
    will now have an additional property list for us to parse through:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以添加这个地图对象的所需纹理。保存的文件现在将有一个额外的属性列表供我们解析：
- en: '[PRE56]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Developing the ObjectLayer class
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发ObjectLayer类
- en: 'Back in our project we will now create a new layer type called `ObjectLayer`.
    Create `ObjectLayer.h` and we can add the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们现在将创建一个新的层类型，称为`ObjectLayer`。创建`ObjectLayer.h`，我们可以添加以下代码：
- en: '[PRE57]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We will also define these functions in `ObjectLayer.cpp`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义这些函数在`ObjectLayer.cpp`中：
- en: '[PRE58]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Our `ObjectLayer` class is very simple. It only needs to draw and update the
    objects for that layer. Now let''s parse our `ObjectLayer`. We will need two new
    functions in the `LevelParser` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ObjectLayer`类非常简单。它只需要绘制和更新该层的对象。现在让我们解析我们的`ObjectLayer`。我们将在`LevelParser`类中需要两个新函数：
- en: '[PRE59]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `parseLevel` function must now include these functions and pass in the
    correct XML node:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseLevel`函数现在必须包含这些函数并传入正确的XML节点：'
- en: '[PRE60]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will alter the way we were searching for tile layers to also search for
    object layers:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将改变我们寻找瓦片层的方式，以也寻找对象层：
- en: '[PRE61]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we need to define the new functions; `parseTextures` is a very small and
    simple function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要定义新的函数；`parseTextures`是一个非常小且简单的函数：
- en: '[PRE62]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It gets the texture values and adds them to the `TextureManager`. The `parseObjects`
    function is a little longer but not particularly complicated:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 它获取纹理值并将它们添加到`TextureManager`。`parseObjects`函数稍微长一些，但并不特别复杂：
- en: '[PRE63]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We load the object in a very similar way to the state parser, yet this time
    we must check for the `name` of the property rather than grabbing the `attribute`
    directly:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与状态解析器非常相似的方式加载对象，但这次我们必须检查属性的`name`而不是直接获取`attribute`：
- en: '[PRE64]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can then create the object just like the state parser:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像状态解析器一样创建对象：
- en: '[PRE65]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And add it to this layer''s game object array:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其添加到这一层的游戏对象数组中：
- en: '[PRE66]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once we have loaded all of the objects for this layer, we can push it into
    our `Level` layer array:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们加载了这一层的所有对象，我们就可以将其推入我们的 `Level` 层数组中：
- en: '[PRE67]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Run the game and you will see our helicopter in the `PlayState` again.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，你将再次看到我们的直升机在 `PlayState` 中。
- en: '![Developing the ObjectLayer class](img/6821OT_07_17.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![开发 ObjectLayer 类](img/6821OT_07_17.jpg)'
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We are getting closer to a fully-fledged game all the time. This chapter covered
    a quick way to create 2D maps through the use of tiles and also looked at using
    an external application to place objects within our levels. The next two chapters
    will tie up all of the remaining loose ends and we will create some actual games.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在向一个完整的游戏迈进。本章介绍了通过使用瓦片快速创建2D地图的方法，还探讨了使用外部应用程序在我们的关卡中放置对象。接下来的两章将解决所有剩余的悬而未决的问题，我们将创建一些实际的游戏。
