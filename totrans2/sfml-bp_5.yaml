- en: Chapter 5. Playing with User Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 与用户界面玩耍
- en: 'In the previous chapters, we have learned how to build some simple games. This
    chapter will show you how to improve those games by adding a user interface to
    them. This chapter will cover two different possibilities of user interface:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何构建一些简单的游戏。本章将向您展示如何通过添加用户界面来改进这些游戏。本章将涵盖两种不同的用户界面可能性：
- en: Creating your own objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的对象
- en: Using a library that already exists–**Simple and Fast Graphical User Interface**
    (**SFGUI**)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现有的库–**简单快速图形用户界面**（**SFGUI**）
- en: By the end of this chapter, you should be able to create simple to complex interfaces
    to communicate with the player.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够创建从简单到复杂的界面与玩家进行通信。
- en: What is a GUI?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是GUI？
- en: A **Graphical User Interface** (**GUI**) is a mechanism that allows the user
    to visually interact with a software through graphical objects such as icons,
    text, buttons, and so on. Internally, a GUI handles some events and binds them
    to functions, mostly called callbacks. These functions define the reaction of
    the program.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形用户界面**（**GUI**）是一种机制，允许用户通过图标、文本、按钮等图形对象直观地与软件进行交互。内部，GUI处理一些事件并将它们绑定到函数，这些函数通常被称为回调。这些函数定义了程序的反应。'
- en: There are a lot of different common objects that are always present in a GUI,
    such as buttons, windows, labels, and layouts. I don't think I need to explain
    to you what a button, window, or label is, but I will explain to you in short
    what a layout is.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI中始终存在许多不同的常见对象，例如按钮、窗口、标签和布局。我认为我不需要向你解释按钮、窗口或标签是什么，但我将简要解释布局是什么。
- en: A layout is an invisible object that manages the arrangements of the graphical
    objects on the screen. Simply put, its goal is to take care of the size and the
    position of the objects by managing a part of them. It's like a table that makes
    sure none of these objects are on top of the others, and which adapts their size
    to fill the screen as proportionately as possible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 布局是一个不可见对象，它管理屏幕上图形对象的排列。简单来说，它的目标是通过管理它们的一部分来关注对象的大小和位置。它就像一张桌子，确保这些对象中没有一个是位于另一个之上的，并且尽可能地调整它们的大小以填充屏幕。
- en: Creating a GUI from scratch
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从头开始创建GUI
- en: 'Now that the GUI terms have been introduced, we will think about how to build
    it one by one using SFML. This GUI will be added to the Gravitris project, and
    the result will be similar to the following two screenshots:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经介绍了GUI术语，我们将考虑如何使用SFML逐个构建它。这个GUI将被添加到Gravitris项目中，结果将与以下两个截图类似：
- en: '![Creating a GUI from scratch](img/8477OS_05_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![从头开始创建GUI](img/8477OS_05_01.jpg)'
- en: These show you the starting menu of the game and the pause menu during the game.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些显示了游戏的开局菜单和游戏中的暂停菜单。
- en: 'To build this GUI, only four different objects have been used: `TextButton`,
    `Label`, `Frame`, and `VLayout`. We will now see how to structure our code to
    be as flexible as possible to be able to extend this GUI in future if needed.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这个GUI，只使用了四个不同的对象：`TextButton`、`Label`、`Frame`和`VLayout`。我们现在将看看如何构建我们的代码，使其尽可能灵活，以便在需要时扩展这个GUI。
- en: Class hierarchy
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类层次结构
- en: 'As already said, we will need to build different components for the GUI. Each
    one has its own characteristics and features that can be slightly different from
    the others. Following are some characteristics of these components:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要为GUI构建不同的组件。每个组件都有其独特的特性和功能，可能与其他组件略有不同。以下是这些组件的一些特性：
- en: '`TextButton`: This class will represent a button that can trigger an "on click"
    event when clicked on. Graphically, it''s a box with text inside it.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextButton`：这个类将代表一个按钮，当点击时可以触发“点击”事件。从图形上看，它是一个包含文本的框。'
- en: '`Label`: This accepts simple text that can be displayed on the screen.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Label`：这个类可以接受可以在屏幕上显示的简单文本。'
- en: '`Frame`: This class is an invisible container that will contain some object
    through a layout. This object will also be attached to an SFML window and will
    fill the entire window. This class can also process events (like catching the
    resize of the window, the click of the *Esc* key, and so on).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Frame`：这个类是一个不可见的容器，将通过布局包含一些对象。这个对象也将附加到SFML窗口上，并填充整个窗口。这个类还可以处理事件（例如捕获窗口的调整大小、*Esc*键的点击等）。'
- en: '`Vlayout`: This class''s functionality has already been explained–it displays
    objects vertically. This class has to be able to adjust the positions of all the
    objects attached to it.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vlayout`：这个类的功能已经解释过了——它垂直显示对象。这个类必须能够调整它所附加的所有对象的位置。'
- en: 'Because we want to build a GUI reusable and it needs to be as flexible as possible,
    we need to think bigger than our 4 classes to build it. For example, we should
    be able to easily add a container, switch to a horizontal layout or grid layout,
    make use of sprite buttons and so on. Basically, we need a hierarchy that allows
    the addition of new components easily. Here is a possible solution:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想要构建一个可重用的GUI并且它需要尽可能灵活，所以我们需要比我们的4个类更大的视野来构建它。例如，我们应该能够轻松地添加一个容器，切换到水平布局或网格布局，使用精灵按钮等等。基本上，我们需要一个允许轻松添加新组件的层次结构。以下是一个可能的解决方案：
- en: '![Class hierarchy](img/8477OS_05_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![类层次结构](img/8477OS_05_02.jpg)'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this hierarchy, each green box represents an external class of the GUI.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层次结构中，每个绿色框代表GUI的外部类。
- en: In the GUI system, each component is a `Widget`. This class is the base of all
    the other components and defines the common methods to interact with them. We
    also define some virtual classes, such as `Button`, `Container`, and `Layout`.
    Each of these classes adapts the `Widget` class and adds the possibility of growing
    our system without too much effort. For example, adding an `HLayout` class will
    be made possible by extending it from `Layout`. Other examples include some specific
    buttons such as `RadioButton` and `CheckBox`, which use the `Button` class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI系统中，每个组件都是一个`Widget`。这个类是所有其他组件的基础，并定义了与它们交互的通用方法。我们还定义了一些虚拟类，例如`Button`、`Container`和`Layout`。每个这些类都适配了`Widget`类，并增加了在不费太多力气的情况下扩展我们系统的可能性。例如，通过从`Layout`扩展，可以添加一个`HLayout`类。其他例子包括一些特定的按钮，如`RadioButton`和`CheckBox`，它们使用`Button`类。
- en: In this hierarchy, the `Frame` class extends the `ActionTarget` class. The idea
    is to be able to use the bind methods of `ActionTarget` to catch some events such
    as when working in some window and the *Esc* key is pressed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层次结构中，`Frame`类扩展了`ActionTarget`类。目的是能够使用`ActionTarget`的绑定方法来捕获一些事件，例如在某个窗口中工作时按下*Esc*键。
- en: 'Now that the hierarchy has been shown to you, we will continue with the implementation
    of the different classes. Let''s start from the base: the `Widget` class.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经向你展示了这个层次结构，我们将继续实现不同的类。让我们从基础开始：`Widget`类。
- en: The Widget class
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Widget`类'
- en: 'As already explained, this class is the common trunk of all the other GUI components.
    It provides some common methods with default behaviors that can be customized
    or improved on. A `Widget` class not only has a position and can be moved, but
    also has the ability to be displayed on screen. Take a look at its header source:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个类是所有其他GUI组件的共同主干。它提供了一些具有默认行为的通用方法，这些方法可以被自定义或改进。`Widget`类不仅有一个位置并且可以被移动，而且还有在屏幕上显示的能力。看看它的头文件源码：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This first class is simple. We define a construct and a virtual destructor.
    The virtual destructor is very important because of the polymorphism usage inside
    the GUI logic. Then we define some getters and setters on the internal variables.
    A widget can also be attached to another one that is contained in it so we keep
    a reference to it for updating purposes. Now take a look at the implementation
    for a better understanding:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个类很简单。我们定义了一个构造函数和一个虚拟析构函数。虚拟析构函数非常重要，因为GUI逻辑中使用了多态。然后我们在内部变量上定义了一些getter和setter。小部件也可以附加到它所包含的另一个小部件上，因此我们保留了对它的引用以供更新之用。现在让我们看看实现以更好地理解：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Up to this point, nothing should surprise you. We only defined some getters/setters
    and coded the default behavior for event handling.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有什么应该让你感到惊讶的。我们只定义了一些getter/setter和为事件处理编写了默认行为。
- en: 'Now have a look at the following function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看下面的函数：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function, unlike the others we saw, is important. Its goal is to propagate
    the update request through the GUI tree. For example, from a button with a change
    in its size due to a text change, to its layout, to the container. By doing this,
    we are sure that each component will be updated without further efforts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数，与我们所看到的其他函数不同，非常重要。它的目标是通过GUI树传播更新请求。例如，从一个由于文本更改而改变大小的按钮，到其布局，再到容器。通过这样做，我们确保每个组件都会被更新，而无需进一步的努力。
- en: The Label class
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Label`类'
- en: 'Now that the `Widget` class has been introduced, let''s build our first widget,
    a label. This is the simplest widget that we can build. So we will learn the logic
    of GUI through it. The result will be as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经介绍了`Widget`类，让我们构建我们的第一个小部件，一个标签。这是我们能够构建的最简单的小部件。因此，我们将通过它学习GUI的逻辑。结果将如下所示：
- en: '![The Label class](img/8477OS_05_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![标签类](img/8477OS_05_03.jpg)'
- en: 'For doing this we will run the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将运行以下代码：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see this class is nothing other than a box around `sf::Text`. It
    defines some methods taken from the `sf::Text` API with the exact same behavior.
    It also implements the requirements of `Widget` class such as the `getSize()`
    and `draw()` methods. Now let''s have a look at the implementation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个类不过是一个围绕`sf::Text`的盒子。它定义了一些从`sf::Text` API中提取的方法，具有完全相同的行为。它还实现了`Widget`类的要求，例如`getSize()`和`draw()`方法。现在让我们看看实现：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The constructor initializes the text from a parameter, sets the default font
    taken from the `Configuration` class, and sets a color.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数从参数初始化文本，设置从`Configuration`类中获取的默认字体，并设置颜色。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These two functions forward their jobs to `sf::Text` and request for an update
    because of the possible change of size.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数将任务转发给`sf::Text`，并请求更新，因为可能发生大小的变化。
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'SFML already provides a function to get the size of a `sf::Text` parameter,
    so we use it and convert the result into the excepted one as shown by the following
    code snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SFML已经提供了一个函数来获取`sf::Text`参数的大小，所以我们使用它并将结果转换为预期的值，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function is simple, but we need to understand it. Each widget has its own
    position, but is relative to the parent. So when we display the object, we need
    to update the `sf::RenderStates` parameter by translating the transform matrix
    by the relative position, and then draw all the stuff needed. It's simple, but
    important.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数很简单，但我们需要理解它。每个小部件都有自己的位置，但相对于父元素。因此，当我们显示对象时，我们需要通过平移变换矩阵的相对位置来更新`sf::RenderStates`参数，然后绘制所有需要的元素。这很简单，但很重要。
- en: The Button class
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按钮类
- en: 'Now, we will build another `Widget` class that is very useful: the `Button`
    class. This class will be a virtual one because we want to be able to build several
    button classes. But there are common functions shared by all the button classes,
    such as the "on click" event. So, the goal of this class is to group them. Take
    a look to the header of this class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将构建另一个非常有用的`Widget`类：`Button`类。这个类将是一个虚拟类，因为我们希望能够构建多个按钮类。但是，所有按钮类都有一些共享的函数，例如“点击”事件。因此，这个类的目标是分组它们。看看这个类的头文件：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As usual, we declare the constructor and the destructor. We also declare an
    `onClick` attribute, which is an `std::function` that will be triggered when the
    button is pushed. This is our callback. The callback type is kept as `typedef`
    and we also declare a default empty function for convenience. Now, take a look
    at the implementation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们声明构造函数和析构函数。我们还声明了一个`onClick`属性，它是一个`std::function`，当按钮被按下时会触发。这是我们的回调。回调类型被保留为`typedef`，我们还声明了一个默认的空函数以方便使用。现在，让我们看看实现：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the help of the following code snippet, we declare an empty function that
    will be used as the default for the `onClick` attribute. This function does nothing:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段的帮助下，我们声明了一个空函数，该函数将用作`onClick`属性的默认值。此函数不执行任何操作：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We build the constructor that forwards its parameter to its parent class and
    also sets the `onClick` value to the default empty function previously defined
    to avoid undefined performance when the callback is not initialized by the user,
    as shown in the following code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个构造函数，它将其参数转发给其父类，并将`onClick`值设置为之前定义的默认空函数，以避免当用户未初始化回调时出现未定义的性能，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This function is the heart of our class. It manages the events by triggering
    some callbacks when some criteria are satisfied. Let''s take a look at it step
    by step:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是我们类的心脏。它通过在满足某些标准时触发一些回调来管理事件。让我们一步一步地看看它：
- en: If the event received as the parameter is a click, we have to check whether
    it happens in the button area. If so, we trigger our `onClick` function.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果作为参数接收的事件是点击，我们必须检查它是否发生在按钮区域内。如果是这样，我们将触发我们的`onClick`函数。
- en: 'On the other hand, if the event is caused by moving the pointer, we verify
    if the mouse pointer is hovering over the button. If so, we set the status value
    to `Hover`, and here is the trick:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，如果事件是由指针移动引起的，我们验证鼠标指针是否悬停在按钮上。如果是这样，我们将状态值设置为`Hover`，这里有一个技巧：
- en: If this flag was newly defined to `Hover`, then we call the `onMouseEntered()`
    method, which can be customized.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个标志刚刚被定义为`Hover`，那么我们将调用`onMouseEntered()`方法，这个方法是可以定制的。
- en: 'If the flag was previously defined to `Hover` but is not set to it anymore,
    it''s because the mouse left the area of the button, so we call another method:
    `onMouseLeft()`.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果标志之前被定义为`Hover`但现在不再设置为它，那是因为鼠标离开了按钮的区域，所以我们调用另一个方法：`onMouseLeft()`。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The value returned by the `processEvent()` method will stop the propagation
    of the event on the GUI if it's set to `true`. Returning false will continue the
    propagation of the event, so it's also possible to use an event without stopping
    its propagation; on the mouse moving away, for example. But in this case, we simply
    can't click on multiple widget objects at the same time, so we stop if needed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`processEvent()`方法返回的值设置为`true`，它将停止在GUI上事件的传播。返回`false`将继续事件的传播；例如，在鼠标移动时，也可以使用不停止事件传播的事件；但在这个情况下，我们简单地不能同时点击多个小部件对象，所以如果需要，我们将停止。
- en: I hope the logic of the `processEvent()` function is clear, because our GUI
    logic is based on it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望`processEvent()`函数的逻辑是清晰的，因为我们的GUI逻辑基于它。
- en: 'Following two functions are the default empty behavior of the button with a
    mouse move event. Of course, we will customize them in the specialized `Button`
    classes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个函数是带有鼠标移动事件的按钮的默认空行为。当然，我们将在专门的`Button`类中自定义它们：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The TextButton class
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本按钮类
- en: 'This class will extend our previously defined `Button` class. The result will
    be a rectangle on the screen with text inside it, just as shown in the following
    screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将扩展我们之前定义的`Button`类。结果将在屏幕上显示一个带有文本的矩形，就像以下截图所示：
- en: '![The TextButton class](img/8477OS_05_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![TextButton类](img/8477OS_05_04.jpg)'
- en: 'Now take a look at the implementation. Remember that our `Button` class extends
    from `sf::Drawable`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看实现。记住，我们的`Button`类是从`sf::Drawable`扩展而来的：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This class extends the `Button` class and adds a rectangle shape and a label
    to it. It also implements the `onMouseEntered()` and `onMouseLeft()` functions.
    These two functions will change the color of the button, making them a bit lighter:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了`Button`类，并为其添加了一个矩形形状和标签。它还实现了`onMouseEntered()`和`onMouseLeft()`函数。这两个函数将改变按钮的颜色，使其稍微亮一些：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The constructor initializes the different colors and the initial text:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化不同的颜色和初始文本：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'All these functions set the different attributes by forwarding the job. It
    also calls the `updateShape()` method to update the container:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数通过转发任务来设置不同的属性。它还调用`updateShape()`方法来更新容器：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following function updates the shape by resizing it using the size from
    the internal label and adding some padding to it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数通过使用内部标签的大小来调整形状，并添加一些填充来更新形状：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This method has the same logic as Label. It moves `sf::RenderStates` to the
    position of the button and draws all the different `sf::Drawable` parameters:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法与标签的逻辑相同。它将`sf::RenderStates`移动到按钮的位置，并绘制所有不同的`sf::Drawable`参数：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These two functions change the color of the button when the cursor is hovering
    over it and reset the initial color when the cursor leaves it. This is useful
    for the user, because he knows which button will be clicked easily.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数在鼠标悬停在按钮上时改变按钮的颜色，并在鼠标离开时重置初始颜色。这对用户来说很有用，因为他可以很容易地知道哪个按钮将被点击。
- en: As you can see, implementation of a `TextButton` is pretty short, all thanks
    to the changes made in the parent classes, `Button` and `Widget`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`TextButton`的实现相当简短，这都要归功于父类`Button`和`Widget`所做的更改。
- en: The Container class
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器类
- en: This class is another type of `Widget` and will be abstract. A `Container` class
    is a `Widget` class that will store other widgets through a `Layout` class. The
    purpose of this class is to group all the common operations between the different
    possible `Container` classes, even as in our case, we only implement a `Frame`
    container.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是另一种类型的`Widget`，将是抽象的。`Container`类是一个`Widget`类，将通过`Layout`类存储其他小部件。这个类的目的是将不同可能的`Container`类之间的所有常见操作分组，即使在我们只实现了`Frame`容器的情况下。
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As usual, we define the constructor and destructor. We also add accessors to
    the internal `Layout` class. We will also implement the `draw()` method and the
    event processing. Now take a look at the implementation in the following code
    snippet:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们定义了构造函数和析构函数。我们还添加了对内部`Layout`类的访问器。我们还将实现`draw()`方法和事件处理。现在看看以下代码片段中的实现：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The destructor deletes the internal `Layout` class, but only if the parent
    of the `Layout` class is the current container. This avoids double free corruption
    and respects the RAII idiom:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数会删除内部的`Layout`类，但仅当`Layout`类的父类是当前容器时才会这样做。这避免了双重释放的损坏，并尊重了RAII习语：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The previous function sets the layout of the container and deletes it from the
    memory if needed. Then it takes ownership of the new layout and updates the internal
    pointer to it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数设置容器的布局，并在需要时将其从内存中删除。然后它接管新的布局的所有权，并更新对它的内部指针。
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The three previous functions do the usual job, just as with the other `Widgets`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个函数执行通常的工作，就像其他`Widgets`一样：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These two previous functions process for the events. Because a `Layout` class
    doesn't have any event to deal with, it forwards the job to all the internal `Widget`
    classes. If an event is processed by a `Widget` class, we stop the propagation,
    because logically no other widget should be able to deal with it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个之前的函数处理事件。因为`Layout`类没有要处理的事件，它将任务转发给所有内部的`Widget`类。如果一个`Widget`类处理了事件，我们就停止传播，因为从逻辑上讲，没有其他控件应该能够处理它。
- en: The Frame class
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Frame`类'
- en: 'Now that the basic container has been constructed, let''s extend it with a
    special one. The following `Widget` class will be attached to `sf::RenderWindow`
    and will be the main widget. It will manage the render target and the events by
    itself. Take a look at its header:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本容器已经构建完成，让我们用特殊的一个来扩展它。下面的`Widget`类将附加到`sf::RenderWindow`上，并成为主要的控件。它将自行管理渲染目标和事件。看看它的头文件：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, this class is a bit more complex than the previous `Widget`.
    It extends the `Container` class to be able to attach a `Layout` class to it.
    Moreover, it also extends the `ActionTarget` class, but as protected. This is
    an important point. In fact, we want to allow the user to bind/unbind events,
    but we don't want to allow them to cast the `Frame` to an `ActionTarget`, so we
    hide it to the user and rewrite all the methods of the `ActionTarget` class. This
    is why there is a protected keyword.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这个类比之前的`Widget`类要复杂一些。它扩展了`Container`类，以便能够将其附加到`Layout`类上。此外，它还扩展了`ActionTarget`类，但作为受保护的。这是一个重要的点。实际上，我们希望允许用户绑定/解绑事件，但不想允许他们将`Frame`强制转换为`ActionTarget`，所以我们将其隐藏给用户，并重写`ActionTarget`类的所有方法。这就是为什么有受保护关键字的原因。
- en: 'The class will also be able to extract events from its parent windows; this
    explains why we need to keep a reference to it, as seen here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类还将能够从其父窗口中提取事件；这解释了为什么我们需要保留对其的引用，如下所示：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'All these methods are simple and don''t require a lot of explanation. You simply
    initialize all the attributes with the constructor and forward the job to the
    attributes stored inside the class for the others, as done here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都很简单，不需要很多解释。你只需使用构造函数初始化所有属性，并将任务转发给存储在类内部的属性，就像这里所做的那样：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These two overload functions are exposed to the user. It forwards the job to
    the override functions inherited from `Widget` by constructing the missing ones
    or the already known arguments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个重载函数暴露给用户。它通过构造缺失的或已知的参数将任务转发给从`Widget`继承的覆盖函数。
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: On the other hand, these two functions process to the event management of the
    `ActionTarget` and `Container` bases of the class, but also take in charge the
    polling event from its parent window. In this case, all event management will
    be automatic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这两个函数处理类的`ActionTarget`和`Container`基类的事件管理，同时也负责从父窗口轮询事件。在这种情况下，所有事件管理都将自动进行。
- en: The `Frame` class is now over. As you can see, it's not a complex task, thanks
    to our hierarchical tree and because we reused code here.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frame`类现在已经结束。正如你所见，这并不是一个复杂的任务，多亏了我们的分层树和代码的重用。'
- en: The Layout class
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Layout`类'
- en: 'Now that all the widgets that will be rendered on the screen are building,
    let''s build the class that will be in charge of their arrangement:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有将在屏幕上渲染的控件都正在构建，让我们构建一个负责它们排列的类：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the abstract class is very simple. The only new feature is the
    ability to set spacing. We don't have any `add(Widget*)` method, for example.
    The reason is that the argument will be slightly different depending on the kind
    of `Layout` used. For example, we just need a `Widget` class as argument for the
    layout with a single column or line, but the situation is completely different
    for a grid. We need two other integers that represent the cell in which the widget
    can be placed. So, no common API is designed here. As you will see, the implementation
    of this class is also very simple and doesn't require any explanation. It follows
    the logic of the `Widget` class we previously created.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，抽象类非常简单。唯一的新特性是能够设置间距。我们没有 `add(Widget*)` 方法，例如。原因是根据使用的 `Layout` 类型，参数会有所不同。例如，对于只有单列或单行的布局，我们只需要一个
    `Widget` 类作为参数，但对于网格来说，情况完全不同。我们需要两个其他整数来表示小部件可以放置的单元格。因此，这里没有设计通用的 API。您将看到，这个类的实现也非常简单，不需要任何解释。它遵循我们之前创建的
    `Widget` 类的逻辑。
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The VLayout class
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: VLayout 类
- en: 'This `Layout` class will be more complex than the previous ones. This one contains
    the full implementation of a vertical layout, which automatically adjusts its
    size and the alignment of all its internal objects:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Layout` 类将比之前的类更复杂。这个类包含了垂直布局的完整实现，它自动调整其大小和所有内部对象的对齐方式：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The class will implement all the requirements from the widget and will also
    add the features to add widgets in it. So there are some functions to implement.
    To keep a trace of the widgets attached to the `Layout` class, we will internally
    store them in a container. The choice of the `std::vector` class makes sense here
    because of the random access of the elements for the `at()` method and the great
    number access through the container. So the only reason for the choice is performance,
    since an `std::list` will also be able to do the same job. Now, let''s have a
    look at the implementation:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将实现所有来自小部件的要求，并添加在其中添加小部件的功能。因此，有一些函数需要实现。为了跟踪附加到 `Layout` 类的小部件，我们将在内部将它们存储在一个容器中。选择
    `std::vector` 类在这里是有意义的，因为元素可以通过 `at()` 方法进行随机访问，并且通过容器进行大量访问。所以选择的原因仅仅是性能，因为
    `std::list` 也能完成同样的工作。现在，让我们看看实现：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The destructor will free the memory from the objects attached to the `Layout`
    class, with the same criteria as the ones explained in the `Container` class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数将释放与 `Layout` 类关联的对象的内存，其标准与在 `Container` 类中解释的标准相同：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'These two previous functions add the possibility to add and get access to the
    widget stored by the class instance. The `add()` method additionally takes ownership
    of the added object:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个之前的功能添加了添加和获取由类实例存储的小部件的可能性。`add()` 方法还额外承担了添加对象的拥有权：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This method calculates the total size of the layout, taking into account the
    spacing. Because our class will display all the objects in a single column, the
    height will be their total size and the width the maximal of all the objects.
    The spacing has to be taken into account each time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法计算布局的总大小，考虑到间距。因为我们的类将在单列中显示所有对象，所以高度将是它们的总大小，宽度是所有对象的最大值。每次都必须考虑间距。
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: These two previous methods forward the job to all the stored widget , but we
    stop the propagation when it's needed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个之前的方法将任务转发给所有存储的小部件，但在需要时我们会停止传播。
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This method is the most important for this class. It resets the different positions
    of all the objects by calculating it based on all the other widgets. The final
    result will be a column of widgets centered vertically and horizontally.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法对这个类来说是最重要的。它通过基于所有其他小部件来计算，重置所有对象的不同位置。最终结果将是一个垂直和水平居中的小部件列。
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This last function asks each `Widget` to render itself by forwarding the parameter.
    This time, we don't need to translate states because the position of the layout
    is the same as its parent.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的函数要求每个 `Widget` 通过传递参数来渲染自己。这次，我们不需要翻译状态，因为布局的位置与其父级相同。
- en: The entire class has now been built and explained. It's now time for the user
    to use them and add a menu to our game.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 整个类现在已经构建并解释完毕。现在是用户使用它们并为我们的游戏添加菜单的时候了。
- en: Adding a menu to the game
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为游戏添加菜单
- en: Now that we have all the pieces in place to build a basic menu, let's do it
    with our fresh GUI. We will build two of them. The main, game-opening one and
    the pause menu. This will show you the different usage possibilities of our actual
    GUI.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好所有构建基本菜单的组件，让我们用我们的新GUI来实现它。我们将构建两个菜单。一个是主要的游戏开启菜单，另一个是暂停菜单。这将展示我们实际GUI的不同使用可能性。
- en: 'If you have understood what we have done until now well, you would have noticed
    that the base component of our GUI is `Frame`. All the other widgets will be displayed
    on the top of it. Here is a schema that summarizes the GUI tree hierarchy:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经很好地理解了我们到目前为止所做的一切，你会注意到我们GUI的基础组件是`Frame`。所有其他小部件都将显示在其顶部。以下是一个总结GUI树结构的图示：
- en: '![Adding a menu to the game](img/8477OS_05_05.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![向游戏中添加菜单](img/8477OS_05_05.jpg)'
- en: Each color represents a different type of component. The trunk is **sf::RenderWindow**
    and then we have a **Frame** attached to it with its **Layout**. And finally we
    have some different **Widget**. Now that the usage has been explained, let's create
    our main menu.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每种颜色代表不同类型的组件。树干是**sf::RenderWindow**，然后我们有一个附加到其上的**Frame**及其**Layout**。最后，我们有一些不同的**Widget**。现在使用方法已经解释清楚，让我们创建我们的主菜单。
- en: Building the main menu
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建主菜单
- en: To build the main menu, we will need to add an attribute to the `Game` class.
    Let's call it `_mainMenu`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建主菜单，我们需要向`Game`类添加一个属性。让我们称它为`_mainMenu`。
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then create an `enum` function with different possibilities of values in
    order to know the currently displayed status:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后创建一个`enum`函数，其中包含不同的值可能性，以便知道当前显示的状态：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now let''s create a function to initialize the menu:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个初始化菜单的函数：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This function will store the entire GUI construction, except from the constructor
    that is calling. Now that we have all that we need in the header file, let's move
    on to the implementation of all this stuff.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将存储整个GUI构建过程，除了调用构造函数之外。现在我们已经将所有需要的内容放入头文件中，让我们继续实现所有这些功能。
- en: 'First of all, we need to update the constructor by adding in the initialization
    of `_mainMenu` and `_status`. It should look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过添加`_mainMenu`和`_status`的初始化来更新构造函数。它应该看起来像这样：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we need to implement the `initGui()` function as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要按照以下方式实现`initGui()`函数：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s discuss this function step by step:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地讨论这个函数：
- en: We create a `Vlayout` class and set its spacing.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`Vlayout`类并设置了其间距。
- en: We create a button with `New Game` as its label.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个按钮，其标签为`New Game`。
- en: We set the `onClick` callback function that initializes the game.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了初始化游戏的`onClick`回调函数。
- en: We add the button to the layout.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将按钮添加到布局中。
- en: With the same logic, we create two other buttons with different callbacks.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的逻辑，我们创建了两个其他按钮，具有不同的回调函数。
- en: Then we set the layout to the `_mainMenu` parameter.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将布局设置到`_mainMenu`参数。
- en: And we finally add an event directly to the frame that will handle the *Esc*
    key. This key is defined in the `GuiInputs enum` contained in the `Configuration`
    class, which was constructed as `PlayerInputs`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们向框架中添加一个事件，该事件将处理*Esc*键。这个键在`Configuration`类中定义的`GuiInputs enum`中，该类是作为`PlayerInputs`构建的。
- en: 'Now that our menu is created, we need to make some little changes in the existing
    `run()`, `processEvents()`, and `render()` methods. Let''s start with `run()`.
    The modification is negligible. In fact, we just have to add a condition for the
    call of the update methods, adding verification on the `_status` variable. The
    new line is now as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了菜单，我们需要对现有的`run()`、`processEvents()`和`render()`方法进行一些小的修改。让我们从`run()`开始。这次修改微乎其微。实际上，我们只需要添加一个调用更新方法的条件，对`_status`变量进行验证。新的一行如下：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The next function is `processEvents()`, which will require a little more modification,
    but not too much. In fact, we need to call `_mainMenu::processEvent(const f::Event&)`
    and `_mainMenu::processEvents()`, but only when the game is in `StatusMainMenu`
    mode. The new method is now as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是`processEvents()`，它需要一些更多的修改，但并不多。实际上，我们需要在游戏处于`StatusMainMenu`模式时调用`_mainMenu::processEvent(const
    f::Event&)`和`_mainMenu::processEvents()`。新的方法如下：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, the modification is not too complicated, and easily understandable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，修改并不复杂，易于理解。
- en: And now, the last change in the `render()` method. The logic is the same, a
    switch on the `_status` value.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`render()`方法的最后一个修改。逻辑相同，根据`_status`值进行切换。
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can see, we have been able to add a menu to our game without too much
    effort. The result should be like the figure shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们能够轻松地为我们游戏添加一个菜单。结果应该像这里显示的图示一样：
- en: '![Building the main menu](img/8477OS_05_06.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![构建主菜单](img/8477OS_05_06.jpg)'
- en: Now, let's build the second menu.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建第二个菜单。
- en: Building the pause menu
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建暂停菜单
- en: 'The pause menu will be constructed just like the previous one, so I will skip
    the constructor part and directly move on to the `initGui()` function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停菜单将像之前的一个一样构建，所以我将跳过构造函数部分，直接进入 `initGui()` 函数：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The logic is exactly the same as the one used for the previous menu, but here
    we use a `Label` and a `TextButton` class. The callback of the button will also
    change the `_status` value. Here, again, we catch the *Esc* key. The result is
    to leave this menu. In the `processEvents()`, we only need to add one line to
    the first switch:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与之前菜单使用的逻辑完全相同，但这里我们使用了一个 `Label` 和 `TextButton` 类。按钮的回调也将更改 `_status` 值。在这里，我们再次捕获
    *Esc* 键。结果是离开这个菜单。在 `processEvents()` 中，我们只需要在第一个 switch 语句中添加一行：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And add another line to the second switch:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 并在第二个 switch 语句中添加另一行：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: And that's it. We are done with this function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们完成了这个函数。
- en: 'The next step is the `render()` function. Here again it will be very quick.
    We add a case in the switch statement as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是 `render()` 函数。在这里，它也将非常快。我们在 switch 语句中添加一个 case，如下所示：
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The request to draw `_world` means to set the current game state in the background
    on the menu. This is useless, but pretty cool, so why not?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请求绘制 `_world` 意味着在菜单的背景上设置当前游戏状态。这没什么用，但很酷，为什么不试试呢？
- en: 'The final result is the second screenshot shown at the beginning of this chapter.
    Have a look at what appears on my screen:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是本章开头显示的第二张截图。看看我屏幕上显示的内容：
- en: '![Building the pause menu](img/8477OS_05_07.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![构建暂停菜单](img/8477OS_05_07.jpg)'
- en: Building the configuration menu
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建配置菜单
- en: 'This menu will in fact be implemented in the second part (by using SFGUI),
    but we need a way to exit the configuration menu. So we simply have to create
    a `_configurationMenu` as the two others and bind the `Escape` event to set the
    status to the main menu. The code in the `initGui()` to add is shown as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个菜单将在第二部分（使用 SFGUI）中实现，但我们需要一个退出配置菜单的方法。因此，我们只需创建一个 `_configurationMenu`
    作为另外两个一样，并将 `Escape` 事件绑定到设置为主菜单的状态。下面是 `initGui()` 中需要添加的代码：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: I'm sure you are now able to update the `processEvents()` and `render()` functions
    by yourself using your new skills.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您现在能够使用您的新技能自己更新 `processEvents()` 和 `render()` 函数。
- en: That's all concerning our home-made GUI. Of course, you can improve it as you
    wish. That's one of its advantages.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们自制的 GUI 的内容就到这里。当然，您可以按需改进它。这是它的一个优点。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are interested in making improvements, take a look to the external library
    made regrouping all our custom game framework at [http://github.com/Krozark/SFML-utils/](http://github.com/Krozark/SFML-utils/).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对改进感兴趣，请查看外部库 [http://github.com/Krozark/SFML-utils/](http://github.com/Krozark/SFML-utils/)，它将所有自定义游戏框架重新组合。
- en: The next step is to use an already made GUI with more complex widgets. But keep
    in mind that if you only need to show menus like those presented here, this GUI
    is enough.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用一个已经制作好的具有更复杂控件的 GUI。但请记住，如果您只需要显示像这里展示的菜单，这个 GUI 就足够了。
- en: Using SFGUI
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SFGUI
- en: SFGUI is an open source library that implements a complete GUI system based
    on the top of SFML. Its goal is to provide a rich set of widgets and to be easily
    customizable and extensible. It also uses modern C++, so it's easy to use in any
    SFML project without too much effort.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: SFGUI 是一个开源库，它基于 SFML 实现了一个完整的 GUI 系统。其目标是提供丰富的控件，并且易于自定义和扩展。它还使用了现代 C++，因此在任何
    SFML 项目中使用它都很容易，无需太多努力。
- en: 'The following screenshot shows the SFGUI in action with the test example provided
    with the source:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 SFGUI 与提供的源代码中的测试示例一起运行的情况：
- en: '![Using SFGUI](img/8477OS_05_08.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![使用 SFGUI](img/8477OS_05_08.jpg)'
- en: Installing SFGUI
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 SFGUI
- en: 'The first step is to download the source code. You will find it on the official
    website of the library: [http://sfgui.sfml-dev.de/](http://sfgui.sfml-dev.de/).
    The current version is 0.2.3 (Feb 20, 2014). You will need to build SFGUI by yourself,
    but as usual, it comes with the `cmake` file to help with the build. That is perfect,
    because we already know how to use it.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是下载源代码。你可以在库的官方网站上找到它：[http://sfgui.sfml-dev.de/](http://sfgui.sfml-dev.de/)。当前版本是
    0.2.3（2014 年 2 月 20 日）。你需要自己构建 SFGUI，但像往常一样，它附带 `cmake` 文件来帮助构建。这很完美，因为我们已经知道如何使用它。
- en: 'Sometimes, you could have a problem like the one shown in the following screenshot
    during the build step:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建步骤中，有时你可能会遇到如下截图所示的问题：
- en: '![Installing SFGUI](img/8477OS_05_09.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![安装 SFGUI](img/8477OS_05_09.jpg)'
- en: In this case, you have to set the `CMAKE_MODULE_PATH` variable to `/path/to/SFML/cmake/Modules`
    using the `add entry` parameter. This should fix the problem.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你必须使用 `add entry` 参数将 `CMAKE_MODULE_PATH` 变量设置为 `/path/to/SFML/cmake/Modules`。这应该可以解决问题。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For other similar problems, take a look at this page: [http://sfgui.sfml-dev.de/p/faq#findsfml](http://sfgui.sfml-dev.de/p/faq#findsfml).
    It should be helpful.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他类似的问题，请查看这个页面：[http://sfgui.sfml-dev.de/p/faq#findsfml](http://sfgui.sfml-dev.de/p/faq#findsfml)。这应该会有所帮助。
- en: Now that SFGUI is configured, you need to build it and finally install it exactly
    as SFML and Box2D. You should now be pretty familiar with this.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 SFGUI 已经配置好了，你需要构建它，并最终像 SFML 和 Box2D 一样安装它。你现在应该已经很熟悉这个过程了。
- en: Using the features of SFGUI
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SFGUI 的特性
- en: I will not go too deep into the usage of SFGUI in this book. The goal is to
    show you that you don't always need to reinvent the wheel when a good one already
    exists.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我不会深入探讨 SFGUI 的使用。目标是向你展示，当已经有现成的好方案时，你不必总是需要重新发明轮子。
- en: SFGUI use a lot of C++11 features, such as `shared_pointers`, `std::functions`,
    and some others that have already been covered in this book, and uses the RAII
    idiom as well. As you already know how to work with these features, you will not
    be lost when it comes to using SFGUI optimally.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: SFGUI 使用了许多 C++11 特性，例如 `shared_pointers`、`std::functions` 以及本书中已经介绍的一些其他特性，并且还使用了
    RAII 习惯用法。既然你已经知道如何使用这些特性，那么在使用 SFGUI 时，你不会感到迷茫。
- en: 'First of all, to use SFGUI objects, you must instantiate one object before
    all the others: `sfg::SFGUI`. This class holds all the information needed for
    the rendering. Except from this point, the library can be used pretty much like
    ours. So let''s try it.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要使用 SFGUI 对象，你必须先实例化一个对象，然后再实例化其他所有对象：`sfg::SFGUI`。这个类包含了渲染所需的所有信息。除了这个点之外，库可以像我们的一样使用。所以让我们试试吧。
- en: Building the starting level
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建起始级别
- en: 'We will add a menu to our game that will allow us to choose the starting level.
    The goal of this section is to add a simple form that takes a number as parameter
    and sets it as the starting level of the game. The final result will look like
    this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在游戏中添加一个菜单，允许我们选择起始级别。本节的目标是添加一个简单的表单，它接受一个数字作为参数并将其设置为游戏的起始级别。最终结果将如下所示：
- en: '![Building the starting level](img/8477OS_05_10.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![构建起始级别](img/8477OS_05_10.jpg)'
- en: 'Before starting with SFGUI, we need to make an update to our `Stats` class.
    In fact, this class doesn''t allow us to start at a specific level, so we need
    to add that functionality. This will be done by adding a new attribute to it as
    follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 SFGUI 之前，我们需要更新我们的 `Stats` 类。实际上，这个类不允许我们从特定级别开始，所以我们需要添加这个功能。这可以通过向其中添加一个新属性来完成，如下所示：
- en: '[PRE50]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We will also need a new method:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个新的方法：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'That''s it for the header. Now we need to initialize `_initialLvl` to `0` by
    default. And then change the calculation of the current level in the `addLines()`
    function. To do this, go to the following line:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 标题部分就到这里。现在我们需要将 `_initialLvl` 初始化为默认的 `0`。然后更改 `addLines()` 函数中当前级别的计算。为此，请转到以下行：
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Change the preceding line to the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的行更改为以下行：
- en: '[PRE53]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And finally, we will need to update or implement the assessors on the current
    level as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新或实现当前级别的评估器，如下所示：
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: And that's it for the update on this class. Now let's go back to SFGUI.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类更新的内容就到这里。现在让我们回到 SFGUI。
- en: 'We will use only three different visual objects to build the needed form: label,
    text input, and button. But we will also use a layout and a desktop, which is
    the equivalent of our `Frame` class. All the initialization will be done in the
    `initGui()` function, just as before.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只使用三个不同的视觉对象来构建所需表单：标签、文本输入和按钮。但我们也会使用布局和桌面，这相当于我们的 `Frame` 类。所有初始化都将像之前一样在
    `initGui()` 函数中完成。
- en: 'We also need to add two new attributes to our game:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为我们的游戏添加两个新的属性：
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The reason for adding `_sfgui` was previously explained. We add `_sfDesktop`
    for the exact same reason we add `Frame` to contain the objects.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `_sfgui` 的原因之前已经解释过了。我们添加 `_sfDesktop` 的原因与添加 `Frame` 来包含对象的原因完全相同。
- en: 'Now take a look at the code needed to create the form:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看创建表单所需的代码：
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Okay, a lot of new features here, so I will explain them step by step:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里有很多新功能，所以我将一步一步地解释它们：
- en: First of all, we create the different components needed for this form.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建这个表单所需的不同组件。
- en: 'Then we set the callback of the button on a press event. This callback does
    a lot of things:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将按钮的回调设置为按下事件。这个回调执行了很多事情：
- en: We get back the text entered by the user
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们获取用户输入的文本。
- en: We convert this text to an integer using `std::stringstream`
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `std::stringstream` 将此文本转换为整数。
- en: We check the validity of the input
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查输入的有效性。
- en: If the input is not valid, we display an error message
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入无效，我们将显示错误信息。
- en: On the other hand, if it is valid, we reset the game, set the starting level,
    and start the game
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，如果它是有效的，我们将重置游戏，设置起始关卡，并开始游戏。
- en: Until all the objects are created, we add them into a layout one by one.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有对象创建完成之前，我们将它们逐个添加到布局中。
- en: We change the size of the layout and center it on the window.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们更改了布局的大小并将其居中显示在窗口中。
- en: Finally, we attach the layout to the desktop.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将布局附加到桌面上。
- en: As all the object are created and stored into `std::shared_` we don't need to
    keep a trace of them. SFGUI does it for us.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有对象都已创建并存储到 `std::shared_` 中，我们不需要跟踪它们。SFGUI 会为我们做这件事。
- en: 'Now that the form is created, we have the same challenges as with our GUI:
    events and rendering. Good news, the logic is the same! However, we do have to
    code the `processEvents()` and `render()` functions again.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表单已经创建，我们面临与GUI相同的挑战：事件和渲染。好消息是，逻辑是相同的！然而，我们确实需要再次编写 `processEvents()` 和 `render()`
    函数。
- en: 'In the `processEvents()` method, we only need to complete the first switch
    as shown in the following code snippet:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `processEvents()` 方法中，我们只需要完成以下代码片段中显示的第一个switch即可：
- en: '[PRE57]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, the logic is the same as our GUI, so the reasoning is clear.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，逻辑与我们的GUI相同，所以推理是清晰的。
- en: 'And finally, the rendering. Here, again, the switch has to be completed by
    using the following code snippet:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是渲染。在这里，同样，我们需要使用以下代码片段来完成switch：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The new thing is the `Update()` call. This is for animations. Since in our case,
    we don't have any animation, we can put `0` as the parameter. It would be good
    practice to add this in the `Game::update()` function, but it's okay for our needs–and
    it also avoids changes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 新的是 `Update()` 调用。这是用于动画的。由于在我们的案例中我们没有动画，我们可以将参数设置为 `0`。这是一个好的实践，将其添加到 `Game::update()`
    函数中，但对于我们的需求来说是可以的——它也避免了变化。
- en: You should now be able to use this new form in the configuration menu.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够使用这个新的表单在配置菜单中使用了。
- en: Of course, in this example, I have just shown you a little piece of SFGUI. It
    packs in many more features, and if you are interested, I would suggest you to
    take a look at the documentation and the examples given with the library. It's
    very interesting.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这个例子中，我只是向你展示了一小部分SFGUI。它包含了许多更多功能，如果你感兴趣，我建议你查看库的文档和示例。这非常有趣。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations, you have now finished this chapter and have gained the ability
    to communicate with your player in a good way. You are now able to create some
    buttons, use labels, and add callbacks to some event triggers set off by the user.
    You also know the basics to create your own GUI and how to use SFGUI.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你现在已经完成了这一章节，并且获得了以良好的方式与玩家沟通的能力。你现在能够创建一些按钮，使用标签，并为用户设置的事件触发器添加回调函数。你还了解了创建自己的GUI和使用SFGUI的基本知识。
- en: In the next chapter, we will learn how to use the full power of the CPU by using
    more than one thread, and see its implications in game programming.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过使用多个线程来充分利用CPU的强大功能，并了解它在游戏编程中的影响。
