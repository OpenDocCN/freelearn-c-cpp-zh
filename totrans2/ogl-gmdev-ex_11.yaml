- en: Chapter 11. Heads Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。抬头
- en: 'In this chapter, we will put some finishing touches on Space Racer 3D by adding
    some features that you would see in almost any game. Many of these features are
    similar to the finishing touches that we put on our Robo Racer 2D game, though
    there are some special considerations now that we are working in 3D. The topics
    that we will cover include the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过添加几乎任何游戏中都会看到的一些功能来对Space Racer 3D进行一些收尾工作。其中许多功能与我们在Robo Racer 2D游戏中添加的收尾工作类似，尽管现在我们在3D中工作有一些特殊考虑。我们将涵盖的主题包括以下内容：
- en: '**2D in a 3D world**: So far, we learned how to render in 2D and how to render
    in 3D. However, there are special considerations to create 2D in a 3D world. As
    our user interface is typically created in 2D, we will learn how to mix the two
    types of rendering.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在3D世界中实现2D**：到目前为止，我们学习了如何在2D中渲染，以及如何在3D中渲染。然而，在3D世界中创建2D内容有一些特殊考虑。由于我们的用户界面通常是2D创建的，我们将学习如何混合这两种类型的渲染。'
- en: '**Creating a heads-up-display (HUD)**: It is very typical for first-person
    3D games to have a continuous status showing information that is relevant to the
    game. We will learn how to create a basic heads-up-display or HUD.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建抬头显示（HUD）**：对于第一人称3D游戏来说，有一个持续显示与游戏相关的信息的状态是非常典型的。我们将学习如何创建一个基本的抬头显示或HUD。'
- en: '**More game state**: Just as we did in Robo Racer 2D, we will create a basic
    state manager to handle the various modes in our completed game.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更多游戏状态**：正如我们在Robo Racer 2D中所做的那样，我们将创建一个基本的状态管理器来处理我们完成的游戏中的各种模式。'
- en: '**Scoring**: We need a way to keep score in our game, and we need to set up
    the basic win and lose conditions.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计分**：我们需要一种方法来在我们的游戏中计分，并需要设置基本的胜负条件。'
- en: '**Game over**: When the game is over, we''ll give some credit with a 3D twist.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏结束**：当游戏结束时，我们将通过3D的转折点给予一些信用。'
- en: Mixing things up
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合事物
- en: Now that we are rendering in 3D, it isn't immediately obvious how we will render
    things in 2D. This is especially true of our user interface, which must be rendered
    on top of the 3D-scene and does not move or rotate with the rest of the world.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在3D中渲染，如何渲染2D内容并不立即明显。这尤其适用于我们的用户界面，它必须渲染在3D场景之上，并且不会随着世界其他部分移动或旋转。
- en: 'The trick to creating a 2D interface in a 3D world is to first render the 3D
    world, then switch modes in OpenGL, and then render the 2D content. The following
    image represents the 3D content that we need to render:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D世界中创建2D界面的技巧是首先渲染3D世界，然后在OpenGL中切换模式，然后渲染2D内容。以下图像表示我们需要渲染的3D内容：
- en: '![Mixing things up](img/8199OS_11_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![混合事物](img/8199OS_11_01.jpg)'
- en: 'The next image represents the 2D text that we want to render:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图像表示我们想要渲染的2D文本：
- en: '![Mixing things up](img/8199OS_11_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![混合事物](img/8199OS_11_02.jpg)'
- en: 'We want the final result to be the combination of the 3D and 2D content, as
    shown in the following figure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望最终结果是3D和2D内容的组合，如图所示：
- en: '![Mixing things up](img/8199OS_11_03.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![混合事物](img/8199OS_11_03.jpg)'
- en: The saving state
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存状态
- en: State is a term that is used in many different ways in game programming. For
    example, we will create a state manager later in the chapter that will manage
    different states, or modes, in the game. Another way to define state is a set
    of conditions. For example, when we set things up to render in 3D, this is one
    set of conditions or state. When we set up things to render in 2D, this is another
    set of conditions or state.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是游戏编程中用于许多不同方式的一个术语。例如，我们将在本章后面创建一个状态管理器来管理游戏中的不同状态或模式。定义状态的另一种方式是一组条件。例如，当我们设置渲染为3D时，这是一组条件或状态。当我们设置渲染为2D时，这是另一组条件或状态。
- en: The trick to being able to render in both 2D and 3D is to be able to set up
    one state, and then change to another state. OpenGL saves state in matrices. In
    order to change from one state to another, we need a way to save the current matrix,
    set up another matrix, and then return to the previous matrix once we are done.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在2D和3D中渲染的技巧是能够设置一个状态，然后切换到另一个状态。OpenGL通过矩阵保存状态。为了从一个状态切换到另一个状态，我们需要一种方法来保存当前矩阵，设置另一个矩阵，然后在我们完成时返回到先前的矩阵。
- en: Push and pop
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送和弹出
- en: 'OpenGL provides two methods to save the current state and then retrieve it
    later:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL提供了两种方法来保存当前状态并在稍后检索它：
- en: '`glPushMarix()`: This command saves the current state by placing it on the
    stack.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glPushMarix()`：此命令通过将其放置在堆栈上保存当前状态。'
- en: '`glPopMatrix()`: This command retrieves the previous state by pulling it off
    the stack.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glPopMatrix()`：此命令通过从堆栈中取出它来检索先前状态。'
- en: A **stack** is a structure that allows you to put data on the top of it (a **push**),
    and then later retrieve the item from the top of it (a **pop**). A stack is useful
    when you want to save data in order, then later retrieve it in reverse order.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈**是一种结构，允许你将其数据放在顶部（一个**推入**），然后稍后从顶部检索该数据（一个**弹出**）。当你想要按顺序保存数据，然后稍后以相反的顺序检索它时，栈非常有用。'
- en: 'Let''s say that we start with an initial set of conditions called **State A**:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从一个称为**状态A**的初始条件集开始：
- en: '![Push and pop](img/8199OS_11_04.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![推入和弹出](img/8199OS_11_04.jpg)'
- en: 'A call to `glPushMatrix()` will put **State A** on the stack:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`glPushMatrix()`会将**状态A**压入栈中：
- en: '![Push and pop](img/8199OS_11_05.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![推入和弹出](img/8199OS_11_05.jpg)'
- en: 'Next, we set up the conditions for **State B**. If we want to save this state,
    we issue another `glPushMatrix()` call:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置**状态B**的条件。如果我们想保存这个状态，我们将发出另一个`glPushMatrix()`调用：
- en: '![Push and pop](img/8199OS_11_06.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![推入和弹出](img/8199OS_11_06.jpg)'
- en: 'Now we have two items on the stack, and it should also be very clear why it
    is called a stack! We could then define **State C**. This sequence of steps can
    continue on as needed, creating a render state and then pushing it to the stack.
    In general, we want to unload the stack in the reverse order that we loaded it
    in. This is known as a **FILO** stack: first in, last out.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们栈中有两个项目，这也应该非常清楚地说明为什么它被称为栈！然后我们可以定义**状态C**。这个步骤序列可以按需继续，创建一个渲染状态并将其推入栈中。一般来说，我们希望以我们加载的相反顺序卸载栈。这被称为**FILO**栈：先进先出。
- en: 'We take things off of the stack with the `glPopMatrix()` command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`glPopMatrix()`命令从栈中移除项目：
- en: '![Push and pop](img/8199OS_11_07.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![推入和弹出](img/8199OS_11_07.jpg)'
- en: 'The result replaces **State C**, restoring the rendering settings to **State
    B**:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 结果替换了**状态C**，将渲染设置恢复到**状态B**：
- en: '![Push and pop](img/8199OS_11_08.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![推入和弹出](img/8199OS_11_08.jpg)'
- en: 'Another call to `glPopMatrix()` empties the stack and restores the rendering
    settings to **State A**:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个`glPopMatrix()`调用会清空栈并将渲染设置恢复到**状态A**：
- en: '![Push and pop](img/8199OS_11_09.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![推入和弹出](img/8199OS_11_09.jpg)'
- en: The model view allows 32 matrices to be put onto the stack. Each view has its
    own stack, so the projection view has a separate stack from the model view. Also,
    if you issue `glPopMatrix` and there is no matrix on the stack, you will receive
    an error. In other words, don't try to pop more than you have pushed!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 模型视图允许将32个矩阵放入栈中。每个视图都有自己的栈，因此投影视图有一个与模型视图分开的栈。此外，如果你发出`glPopMatrix`，而栈中没有矩阵，你会收到一个错误。换句话说，不要尝试弹出比你推入的更多的东西！
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In order to best manage memory, you should always pop the states that you have
    pushed, even if you don't need to do anything with them. This frees up the memory
    that was being used to hold the data that was part of the state that you were
    saving.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最佳地管理内存，你应该始终弹出你已推入的状态，即使你不需要对它们进行任何操作。这会释放出用于保存你正在保存的状态中数据所占用的内存。
- en: Two state rendering
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双状态渲染
- en: 'We are now going to set up our code to be able to render in both 3D and 2D.
    Open `SpaceRacer3D.cpp`. We are going to split up the rendering into two functions:
    `Render3D`, and `Render2D`. Then, we are going to call these from the main `Render`
    function. Let''s start with `Render3D`. Add the following code just above the
    `Render` function (you can just cut it from the `Render` function):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将设置我们的代码，使其能够在3D和2D中渲染。打开`SpaceRacer3D.cpp`。我们将把渲染分成两个函数：`Render3D`和`Render2D`。然后，我们将从主`Render`函数中调用这些函数。让我们从`Render3D`开始。在`Render`函数上方添加以下代码（你可以直接从`Render`函数中剪切它）：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we will create two support functions to turn 2D rendering on and off.
    The first will be `Enable2D`. Add the following function above the `Render3D`
    function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建两个支持函数来打开和关闭2D渲染。第一个将是`Enable2D`。在`Render3D`函数上方添加以下函数：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Enable2D` performs the tasks that are necessary to change the rendering mode
    to 2D:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enable2D`执行将渲染模式更改为2D所必需的任务：'
- en: The call to `glColor3f` sets the current drawing color to white. This takes
    some explanation. We will always render 3D first, then switch to 2D. If we didn't
    set the color to white, then all of the colors in the 2D content would be blended
    with the last color that was used by the 3D rendering. Setting the render color
    to white essentially clears the render color so that the 2D content will be rendered
    accurately. Setting the color to white doesn't actually mean everything will be
    drawn in white. It means that no additional coloring will be added to the objects
    that we render in 2D.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glColor3f`调用设置当前绘图颜色为白色。这需要一些解释。我们总是先渲染3D，然后切换到2D。如果我们没有将颜色设置为白色，那么2D内容中的所有颜色都会与3D渲染最后使用的颜色混合。将渲染颜色设置为白色实际上意味着清除渲染颜色，以便2D内容可以准确渲染。将颜色设置为白色并不意味着所有内容都会以白色绘制。这意味着不会向我们在2D中渲染的对象添加额外的颜色。'
- en: The `glEnable(GL_TEXTURE_2D)` call is essential if you want to render 2D textures.
    If this were left out, then any 2D textures would not render correctly.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想渲染2D纹理，`glEnable(GL_TEXTURE_2D)`调用是必需的。如果省略了这个调用，那么任何2D纹理都不会正确渲染。
- en: The next four lines save the 3D projection matrix and set up the projection
    matrix to render in 2D. `glPushMatrix` pushes the current projection matrix to
    the stack. We then initialize the projection matrix with `glLoadIdentity`. Finally,
    we set up an orthographic projection with the call to `glOrtho`. Take a look at
    RoboRacer2D, and you will notice that it uses the same `glOrtho` call to set up
    2D rendering!
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的四行代码保存了3D投影矩阵，并设置投影矩阵以2D模式渲染。`glPushMatrix`将当前投影矩阵推入栈中。然后我们使用`glLoadIdentity`初始化投影矩阵。最后，通过调用`glOrtho`设置正交投影。看看RoboRacer2D，你会注意到它使用相同的`glOrtho`调用设置2D渲染！
- en: The next three lines save the 3D model view matrix and initialize it for our
    2D drawing. `glPushMatrix` pushes the current model view matrix to the stack.
    We then initialize the model view matrix with the call to `glLoadIdentity`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的三行代码保存了3D模型视图矩阵，并为其2D绘制初始化。`glPushMatrix`将当前模型视图矩阵推入栈中。然后我们通过调用`glLoadIdentity`初始化模型视图矩阵。
- en: Finally, we need to turn off checking on the depth buffer. The depth buffer
    check is only required for 3D rendering, and interferes with 2D rendering. `glPushAttrib`
    works just like `glPushMatrix`, except that it only pushes a single OpenGL attribute
    to the stack. In this case, we are pushing the current `GL_DEPTH_BUFFER_BIT` to
    the attribute stack, thus saving the current state of this bit from the previous
    3D rendering. Next, we turn off depth checking with the `glDisable` call.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们需要关闭深度缓冲区的检查。深度缓冲区检查仅适用于3D渲染，并干扰2D渲染。`glPushAttrib`与`glPushMatrix`的工作方式类似，但它只将单个OpenGL属性推入栈中。在这种情况下，我们将当前的`GL_DEPTH_BUFFER_BIT`推入属性栈，从而保存之前3D渲染的当前状态。接下来，我们使用`glDisable`调用关闭深度检查。
- en: 'So, setting things up for 2D rendering involves four steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，设置2D渲染环境涉及四个步骤：
- en: Reset the render color and enable 2D textures.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置渲染颜色并启用2D纹理。
- en: Save the 3D project matrix and set up the 2D projection matrix.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存3D投影矩阵并设置2D投影矩阵。
- en: Save the 3D model view matrix and initialize the 2D model view matrix.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存3D模型视图矩阵并初始化2D模型视图矩阵。
- en: Save the 3D depth bit and turn off depth checking in 2D.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存3D深度位并关闭2D中的深度检查。
- en: 'Now, we are ready to code the `Disable2D` function. Create this new function
    just below the `Enable2D` function that we just created:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好编写`Disable2D`函数。在刚刚创建的`Enable2D`函数下方创建这个新函数：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It shouldn''t be too surprising that `Disable2D` performs actions in the reverse
    order that we performed them in `Enable2D`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 并不令人意外的是，`Disable2D`执行的动作顺序与我们执行`Enable2D`时的顺序相反：
- en: First, we restore depth checking by calling `glPopAttrib()`, which takes the
    last attribute that was pushed to the attribute stack off the stack and restores
    that attribute in the current render state. This will restore depth checking to
    the state that it was in just before we started our 2D rendering.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们通过调用`glPopAttrib()`恢复深度检查，该调用从属性栈中移除最后推入的属性并将其恢复到当前渲染状态。这将恢复到我们开始2D渲染之前的深度检查状态。
- en: The next two lines restore the projection matrix to the 3D state it was in.
    Again, the call to `glPopMatrix` takes the item on the top of the stack and applies
    it to the current render state.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两行代码将投影矩阵恢复到3D状态。同样，`glPopMatrix`调用从栈顶取出项目并将其应用于当前渲染状态。
- en: The next two lines pop the model view matrix.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两行代码弹出模型视图矩阵。
- en: The final line disables 2D textures.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一行禁用了2D纹理。
- en: 'Now, it is time to create our `Render2D` function. Add the following code just
    above the `Render3D` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建我们的`Render2D`函数了。在`Render3D`函数上方添加以下代码：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The funny thing is that we don't have any 2D content to render yet! Later in
    the chapter, we will fill in the rest of the content of this function. The important
    thing to note here is that this function will take care of enabling 2D rendering
    with the call to `Enable2D`. Then the code will be added to render our 2D content.
    Finally, we will turn off 2D rendering with the call to `Disable2D`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好玩的是，我们目前还没有任何2D内容要渲染！在本章的后面部分，我们将填充这个函数的其余内容。这里需要注意的重要事情是，这个函数将负责通过调用`Enable2D`启用2D渲染。然后代码将被添加来渲染我们的2D内容。最后，我们将通过调用`Disable2D`关闭2D渲染。
- en: 'Now that we have all of the necessary supporting code to render in 2D and 3D,
    we will modify the `Render` function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了渲染2D和3D所需的所有必要支持代码，我们将修改`Render`函数：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will notice how simple this is now:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到现在这有多简单：
- en: First, we clear the color buffer and reset the matrix. We always do this once
    before each frame of rendering.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们清除颜色缓冲区并重置矩阵。我们在每次渲染每一帧之前都会这样做。
- en: Next, we render the 3D content.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们渲染3D内容。
- en: Then we render the 2D content.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们渲染2D内容。
- en: Finally, we swap the buffers, which renders all of our content to the screen.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们交换缓冲区，这将渲染我们所有的内容到屏幕上。
- en: If you run the game now, you should notice that nothing has changed. As we haven't
    created any 2D content to render, the 3D content will display just as it did before.
    Now we are ready add our 2D content. Along the way we will flesh out some additional
    features to make a more complete game.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你应该会注意到没有任何变化。因为我们还没有创建任何2D内容来渲染，3D内容将显示得和之前一样。现在我们准备添加我们的2D内容。在这个过程中，我们将完善一些额外的功能，以制作一个更完整的游戏。
- en: A matter of state
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态问题
- en: 'Before we move on to actually rendering 2D items, we need to add a state machine
    to our game. Just as we did in RoboRacer2D, we need to be able to handle several
    different game states: displaying the splash screen, loading resources, displaying
    the main menu, running the game, pausing the game, and game over.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际渲染2D项目之前，我们需要在我们的游戏中添加一个状态机。就像我们在RoboRacer2D中所做的那样，我们需要能够处理几个不同的游戏状态：显示启动屏幕、加载资源、显示主菜单、运行游戏、暂停游戏和游戏结束。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't let the word **state** confuse you as it is used in several different
    ways in computer programming. We just finished a section on render state, learning
    how to push and pop this state from the OpenGL stacks. Now, we are talking about
    game state, which you can think of as the different modes that our game is in.
    A framework that handles different game states is known as a **state machine**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让“状态”这个词让你困惑，因为它在计算机编程中有多种用法。我们刚刚完成了一个关于渲染状态的章节，学习了如何从OpenGL堆栈中推送和弹出这个状态。现在，我们正在谈论游戏状态，你可以将其视为我们的游戏处于的不同模式。处理不同游戏状态的框架被称为**状态机**。
- en: Adding the state machine
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加状态机
- en: Fortunately, we will be able to take some of the code directly from RoboRacer2D.
    Open up `RoboRacer2D.cpp`. You can do this from inside the SpaceRacer3D project
    by clicking **File**, then **Open**, and then browsing to `RoboRacer2D.cpp`. This
    will allow you to copy information from `RoboRacer2D.cpp` and paste it into SpaceRacer3D.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们将能够直接从RoboRacer2D中获取一些代码。通过在SpaceRacer3D项目中点击**文件**，然后**打开**，并浏览到`RoboRacer2D.cpp`，你可以这样做。这将允许你从`RoboRacer2D.cpp`中复制信息并将其粘贴到SpaceRacer3D中。
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Opening a file loads it into the current project, but it does not add the file
    to the current project. However, you want to be careful because if you make changes
    to the file and save them, the original source file will be modified.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件会将它加载到当前项目中，但不会将文件添加到当前项目中。然而，你需要小心，因为如果你修改了文件并保存，原始源文件将被修改。
- en: 'Copy the `GameState` enum and then paste it at the top of `SpaceRacer3D.cpp`
    just after the header files:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 复制`GameState`枚举，然后将其粘贴到`SpaceRacer3D.cpp`的顶部，紧随头文件之后：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will be copying more code from `RoboRacer2D.cpp`, so go ahead and leave it
    open.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复制更多代码来自 `RoboRacer2D.cpp`，所以请继续打开它。
- en: 'Next, we need to create a global game state variable. Add the following definition
    in the global variables section of `SpaceRacer3D.cpp`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个全局游戏状态变量。在`SpaceRacer3D.cpp`的全局变量部分添加以下定义：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `gameState` variable will store the current game state.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`gameState`变量将存储当前游戏状态。'
- en: Getting ready for a splash
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备启动
- en: Just as we did in RoboRacer2D, we are going to start our game with a splash
    screen. The splash screen will be quickly loaded before any other resources, and
    it will be displayed for a few seconds before moving on to loading the game assets
    and starting the game.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在RoboRacer2D中所做的那样，我们将以启动屏幕开始我们的游戏。启动屏幕将在加载其他资源之前快速加载，并在移动到加载游戏资源和开始游戏之前显示几秒钟。
- en: 'Just under the definition for `gameState`, add the following lines:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gameState`定义下方，添加以下几行：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These two variables will handle the splash screen timing. Our splash screen
    is going to be one of the many 2D assets that we load into the game. Let''s go
    ahead and define some variables for our 2D assets. Add the following lines of
    code to the global variables section of `SpaceRacer3D.cpp`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个变量将处理启动屏幕的时间。我们的启动屏幕将是游戏加载的众多2D资源之一。让我们继续定义一些用于我们的2D资源的变量。将以下代码行添加到`SpaceRacer3D.cpp`的全局变量部分：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You will notice that all of our 2D assets are being handled as Sprites, a class
    that we borrowed from RoboRacer2D.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们所有的2D资源都被处理为精灵（Sprites），这是一个我们从RoboRacer2D借用的类。
- en: 'While we are here, let''s add the following two lines as well:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里时，让我们也添加以下两行：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These two variables will be used to add a timing buffer to mouse clicks. Now,
    let''s create a function to load the splash screen. Add the following function
    to `SpaceRacer3D.cpp` somewhere before the `StartGame` function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个变量将用于为鼠标点击添加时间缓冲。现在，让我们创建一个加载启动屏幕的函数。将以下函数添加到`SpaceRacer3D.cpp`中，位置在`StartGame`函数之前：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code is exactly the same as the code from RoboRacer2D. In fact, feel free
    to copy and paste it directly from `RoboRacer2D.cpp`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与RoboRacer2D中的代码完全相同。实际上，你可以直接从`RoboRacer2D.cpp`中复制并粘贴它。
- en: 'Remember: we set up our 2D orthographic viewport to exactly replicate the settings
    that we had in RoboRacer2D. This allows us to use the same exact code and positions
    for our 2D objects. Even better, it allows us to use the `Sprite` class from RoboRacer2D
    without changing any of the code.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：我们设置了2D正交视口，以精确复制我们在RoboRacer2D中设置的设置。这允许我们使用完全相同的代码和位置来处理我们的2D对象。甚至更好，它允许我们使用RoboRacer2D中的`Sprite`类，而无需更改任何代码。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `LoadSplash` function loads a file from the game resource folder called
    `splash.png`. You can download this file and all of the other 2D resources that
    are used in this chapter, from the book website. You should place all of them
    in a folder named `resources` under the same folder as the game source code. You
    also have to remember to add these resources to the **Resource Files** folder
    in the solution by right-clicking on **Resource Files**, then choosing **Add Existing
    Item**, then browsing to the `resources` folder and adding all of the items in
    that folder.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadSplash`函数从游戏资源文件夹中加载一个名为`splash.png`的文件。你可以从本书的网站下载这个文件以及本章中使用的所有其他2D资源。你应该将它们全部放在与游戏源代码相同的文件夹下的`resources`文件夹中。你还得记得通过右键点击**资源文件**，然后选择**添加现有项**，浏览到`resources`文件夹，并将该文件夹中的所有项目添加到**资源文件**文件夹中。'
- en: 'Next, we need to modify the `StartGame` function to load the splash screen.
    Move to the `StartGame` function add the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改`StartGame`函数以加载启动屏幕。移动到`StartGame`函数，并添加以下代码：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first thing that we do is call the `LoadSplash` function, which sets the
    game state to `GS_Splash`, and then loads the splash page. Next, we have to update
    and render the splash page. Move to the `Update` function and modify it so that
    it looks like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用`LoadSplash`函数，将游戏状态设置为`GS_Splash`，然后加载启动页面。接下来，我们必须更新并渲染启动页面。移动到`Update`函数，并修改它，使其看起来像这样：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The only real change is that we implemented part of the state machine. You will
    notice how we moved all of the code to run the game under the `GS_Running` game
    state case. Next, we added an update for the splash screen game state. We will
    eventually modify the `Update` function to handle all of the game states, but
    we have some more work to do yet.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一真正的变化是我们实现了一部分状态机。你会注意到我们将所有运行游戏的代码移动到了`GS_Running`游戏状态案例下。接下来，我们添加了对启动屏幕游戏状态的更新。我们最终将修改`Update`函数以处理所有游戏状态，但我们还有一些工作要做。
- en: 'Now, we are ready to render the splash screen. Move to the `Render2D` function
    and add the following line of code between the `Enable2D` and `Disable2D` calls:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好渲染启动屏幕了。移动到`Render2D`函数，并在`Enable2D`和`Disable2D`调用之间添加以下代码行：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this point, if you run the game, you will see a splash screen render. The
    game will not move beyond the splash screen because we haven't added the code
    to move on yet.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果你运行游戏，你会看到一个启动屏幕被渲染。游戏不会超出启动屏幕，因为我们还没有添加前进的代码。
- en: Creating the user interface
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: We are now ready to define our user interface, which will consist of 2D screens,
    text, and buttons. These will all work exactly as they did in RoboRacer2D. Look
    at the tip in the *Getting ready for a splash* section earlier in this chapter
    for a reminder of how to include prebuilt 2D resources in your project.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好定义我们的用户界面，它将包括2D屏幕、文本和按钮。这些都将与RoboRacer2D中的工作方式完全相同。查看本章前面“准备启动”部分中的提示，以提醒如何将预构建的2D资源包含到你的项目中。
- en: Defining the text system
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义文本系统
- en: 'The 2D text system is built by first creating a font framework, then creating
    functions to display text on the screen. Open `RoboRacer2D.cpp` and copy the following
    functions. Then paste them into `SpaceRacer3D.cpp`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 2D文本系统是通过首先创建一个字体框架，然后创建在屏幕上显示文本的函数来构建的。打开`RoboRacer2D.cpp`并复制以下函数。然后将其粘贴到`SpaceRacer3D.cpp`中：
- en: '`BuildFont`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BuildFont`'
- en: '`KillFont`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KillFont`'
- en: '`DrawText`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DrawText`'
- en: 'We are going to add some new variables to handle the data that we want to display.
    Add the following lines of code to the global variables section of `SpaceRacer3D.cpp`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一些新变量来处理我们想要显示的数据。将以下代码行添加到`SpaceRacer3D.cpp`的全局变量部分：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These variables will hold the stats and scoring used by the game:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量将保存游戏使用的统计数据和得分：
- en: '`score`: This is the current game score'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`score`: 这是当前游戏得分'
- en: '`speed`: This is the current speed of the ship'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`speed`: 这是飞船的当前速度'
- en: '`missionTime`: This is the number of seconds that have elapsed since starting
    the mission'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`missionTime`: 这是自开始任务以来经过的秒数'
- en: '`asteroidsHit`: This is the number of asteroids hit by the player'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asteroidsHit`: 这是玩家击中的陨石数量'
- en: '`maximumSpeed`: This is the maximum speed obtained by the player'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maximumSpeed`: 这是玩家获得的最大速度'
- en: '`Score`, `speed`, and `missionTime` will all be displayed on the heads-up-display
    (HUD) while the player is piloting the ship. `Score`, `asteroidsHit`, `missionTime`,
    and `maximumSpeed` will be displayed as stats at the end of the game.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Score`, `speed`, 和 `missionTime` 都将在玩家驾驶飞船时显示在抬头显示（HUD）上。`Score`, `asteroidsHit`,
    `missionTime`, 和 `maximumSpeed` 将在游戏结束时显示为统计数据。'
- en: 'Let''s go to `StartGame` and initialize these variables:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到`StartGame`并初始化这些变量：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s create the functions to render these items on the screen. Add the
    following two functions to the game somewhere above the `Render2D` function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建在屏幕上渲染这些项目的函数。将以下两个函数添加到游戏中的某个位置，在`Render2D`函数之上：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These functions work exactly like their corresponding functions in RoboRacer2D.
    First, we use `sprintf_s` to create a character string with the text that we want
    to display. Next, we use `glRasterPos2f` to set the render position in 2D. Then,
    we use `glCallLists` to actually render the font. In the `DrawCredits` function,
    we use the `DrawText` helper function to render the text.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与RoboRacer2D中相应的函数工作方式完全相同。首先，我们使用`sprintf_s`创建一个包含我们想要显示的文本的字符字符串。接下来，我们使用`glRasterPos2f`设置2D的渲染位置。然后，我们使用`glCallLists`实际渲染字体。在`DrawCredits`函数中，我们使用`DrawText`辅助函数来渲染文本。
- en: 'Change `CheckCollisions` to look like the code below:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将`CheckCollisions`修改为以下代码：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code updates the score and asteroid stats.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码更新得分和陨石统计数据。
- en: Defining textures
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义纹理
- en: 'Now, it''s time to load all of our textures. Add the following function to
    the game:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候加载我们所有的纹理了。将以下函数添加到游戏中：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There is nothing new here! We are simply loading all of our 2D assets into
    the game as sprites. Here are a few reminders as to how this works:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的！我们只是将所有的2D资产作为精灵加载到游戏中。以下是一些关于如何工作的提醒：
- en: Each sprite is loaded from a PNG file, specifying the number of frames. As none
    of these sprites are animated they all have one frame.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个精灵都是从PNG文件加载的，指定了帧数。由于这些精灵都没有动画，它们都只有一个帧。
- en: We position each sprite with a 2D coordinate.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用2D坐标定位每个精灵。
- en: We set the properties—visible means that it can be seen, and active means that
    it can be clicked on.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们设置属性——可见意味着它可以被看到，而激活意味着它可以被点击。
- en: If the object is intended to be a button, we add it to the UI system.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象打算是一个按钮，我们将其添加到UI系统中。
- en: Wiring in render, update, and the game loop
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接渲染、更新和游戏循环
- en: 'Now that we have finally loaded all of our 2D assets, we are ready to finish
    the `Render2D` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于加载了所有的 2D 资产，我们准备完成 `Render2D` 函数：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Again, there is nothing here that you haven't seen already. We are simply implementing
    the full state engine.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这里没有什么是你之前没有见过的。我们只是在实现完整的状态引擎。
- en: 'We can also implement the full `ProcessInput` function now that we have buttons
    to click. Add the following lines to the `switch` statement:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可点击的按钮，我们可以实现完整的 `ProcessInput` 函数。将以下行添加到 `switch` 语句中：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Yep, we've seen all this before. If you recall, the `Input` class assigns a
    command enum to each button that can be clicked. This code simply processes the
    command, if there was any, and sets the state based on which button was just clicked.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们之前已经见过这些了。如果你还记得，`Input` 类为每个可点击的按钮分配了一个命令枚举。这段代码只是简单地处理命令，如果有任何命令，并根据刚刚点击的按钮设置状态。
- en: 'We now implement the full `Update` function to handle our new state machine:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在实现完整的 `Update` 函数来处理我们新的状态机：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we need to modify the game loop so that it supports all of our new
    features. Move to the `GameLoop` function and modify it so that it looks like
    the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改游戏循环，使其支持我们所有的新特性。移动到 `GameLoop` 函数并修改它，使其看起来像以下代码：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As always, the game loop calls the `Update` and `Render` functions. We add a
    special case to handle the splash screen. If we are in the `GS_Splash` game state,
    we then load the rest of the resources for the game and change the game state
    to `GS_Loading`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，游戏循环调用 `Update` 和 `Render` 函数。我们添加了一个特殊案例来处理启动画面。如果我们处于 `GS_Splash` 游戏状态，那么我们就加载游戏的其他资源，并将游戏状态更改为
    `GS_Loading`。
- en: Note that several of the functions referenced previously haven't been created
    yet! We will add support for sound, fonts, and textures as we continue.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前提到的几个函数还没有创建！随着我们的继续，我们将添加对声音、字体和纹理的支持。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot of code in this chapter. The main lesson in this chapter was
    learning how to render 2D and 3D at the same time. We then added code to load
    all of our 2D resources as sprites. We also added the ability to render text,
    and now we can see our score, stats, and credits.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了大量的代码。本章的主要课程是学习如何同时渲染 2D 和 3D。然后我们添加了代码来加载所有 2D 资源作为精灵。我们还添加了渲染文本的能力，现在我们可以看到我们的得分、统计数据和信用。
- en: We implemented that state machine for the game and wired that into the input,
    update, render, and game loop systems. This included creating states for a splash
    screen, loading resources, playing the game, and displaying various game screens.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为游戏实现了那个状态机，并将其连接到输入、更新、渲染和游戏循环系统中。这包括创建启动画面、加载资源、玩游戏和显示各种游戏屏幕的状态。
- en: You now have a complete 3D game. Sure, there is more that you can do with it.
    In the next and final chapter, we will learn a few new tricks, then the rest is
    up to you!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了一个完整的 3D 游戏。当然，你还可以用它做更多的事情。在下一章和最后一章中，我们将学习一些新技巧，其余的则由你决定！
