["```cpp\n#include <Windows.h> \n#include <Assert.h> \n#include <String.h> \n#include <TChar.h> \n\nLRESULT CALLBACK WindowProc(HWND windowHandle, UINT message, \n                            WPARAM wordParam, LPARAM longParam); \n\n```", "```cpp\nint WINAPI WinMain(HINSTANCE instanceHandle, \n                   HINSTANCE prevInstanceHandle, \n                   char* commandLine, int commandShow) { \n\n```", "```cpp\n  WNDCLASS windowClass; \n  memset(&windowClass, 0, sizeof windowClass); \n  windowClass.hInstance = instanceHandle; \n\n```", "```cpp\n  windowClass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS; \n\n```", "```cpp\n  windowClass.hIcon = LoadIcon(NULL, IDI_APPLICATION); \n  windowClass.hCursor = LoadCursor(NULL, IDC_ARROW); \n  windowClass.hbrBackground = \n    (HBRUSH) GetStockObject(WHITE_BRUSH); \n\n```", "```cpp\n  windowClass.lpfnWndProc = WindowProc; \n\n```", "```cpp\n  windowClass.lpszClassName = TEXT(\"window\"); \n  RegisterClass(&windowClass); \n\n```", "```cpp\n  HWND windowHandle = \n    CreateWindowEx(0, TEXT(\"window\"), NULL, WS_OVERLAPPEDWINDOW, \n                   CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, \n                   CW_USEDEFAULT, NULL, CreateMenu(), \n                   instanceHandle, NULL); \n  assert(windowHandle != NULL); \n  ShowWindow(windowHandle, commandShow); \n  RegisterTouchWindow(windowHandle, 0); \n  SetWindowText(windowHandle, TEXT(\"Hello Window\")); \n\n```", "```cpp\n  MSG message; \n  while (GetMessage(&message, NULL, 0, 0)) { \n    TranslateMessage(&message); \n    DispatchMessage(&message); \n  }  \n  return ((int) message.wParam); \n}  \n\nLRESULT CALLBACK WindowProc(HWND windowHandle, UINT message, \n                            WPARAM wordParam, LPARAM longParam){ \n\n  switch (message) { \n    case WM_PAINT: { \n\n```", "```cpp\n        PAINTSTRUCT paintStruct; \n        HDC deviceContextHandle = \n          BeginPaint(windowHandle, &paintStruct); \n        SetMapMode(deviceContextHandle, MM_ISOTROPIC); \n\n```", "```cpp\n        int horizontalSize = \n              100 * GetDeviceCaps(deviceContextHandle, HORZSIZE), \n            verticalSize = \n              100 * GetDeviceCaps(deviceContextHandle,VERTSIZE); \n\n        SetWindowExtEx(deviceContextHandle, horizontalSize, \n                       verticalSize, NULL);  \n        int horizontalResolution = \n              (int) GetDeviceCaps(deviceContextHandle,HORZRES), \n            verticalResolution = \n              (int) GetDeviceCaps(deviceContextHandle,VERTRES); \n        SetViewportExtEx(deviceContextHandle,horizontalResolution, \n                         verticalResolution, NULL); \n\n```", "```cpp\n        int horizontalScroll = \n          GetScrollPos(windowHandle, SB_HORZ), \n            verticalScroll = GetScrollPos(windowHandle, SB_VERT); \n        SetWindowOrgEx(deviceContextHandle, horizontalScroll, \n                       verticalScroll, NULL); \n\n```", "```cpp\n        RECT clientRect; \n        GetClientRect(windowHandle, &clientRect); \n        POINT bottomRight = {clientRect.right, clientRect.bottom}; \n        DPtoLP(deviceContextHandle, &bottomRight, 1); \n        clientRect.right = bottomRight.x; \n        clientRect.top = bottomRight.y; \n\n```", "```cpp\n        LOGFONT logFont; \n        memset(&logFont, 0, sizeof logFont); \n        _tcscpy_s(logFont.lfFaceName, LF_FACESIZE, \n                  TEXT(\"Times New Roman\")); \n        int fontSize = 12; \n\n```", "```cpp\n        logFont.lfHeight = (int) ((2540.0 * fontSize) / 72); \n        logFont.lfWeight = FW_BOLD; \n        logFont.lfItalic = FALSE; \n\n```", "```cpp\n        HFONT fontHandle = CreateFontIndirect(&logFont); \n        HFONT oldFontHandle = \n          (HFONT) SelectObject(deviceContextHandle, fontHandle); \n\n```", "```cpp\n        COLORREF black = RGB(0, 0, 0), white = RGB(255, 255, 255); \n        SetTextColor(deviceContextHandle, black); \n        SetBkColor(deviceContextHandle, white); \n\n```", "```cpp\n        TCHAR* textPtr = TEXT(\"Hello, Small Windows!\"); \n        DrawText(deviceContextHandle, textPtr, _tcslen(textPtr), \n                 &clientRect, DT_SINGLELINE|DT_CENTER|DT_VCENTER); \n\n```", "```cpp\n        SelectObject(deviceContextHandle, oldFontHandle); \n        DeleteObject(fontHandle); \n        EndPaint(windowHandle, &paintStruct); \n      } \n\n```", "```cpp\n      break; \n  } \n\n```", "```cpp\n  return DefWindowProc(windowHandle, message, \n                       wordParam, longParam); \n} \n\n```", "```cpp\nvoid MainWindow(vector<String> argumentList, \n                SmallWindows::WindowShow windowShow); \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\nint WINAPI WinMain(HINSTANCE instanceHandle, \n                   HINSTANCE /* prevInstanceHandle */, \n                   char* commandLine, int commandShow) { \n\n```", "```cpp\n  Application::RegisterWindowClasses(instanceHandle); \n  vector<String> argumentList = \n    Split(CharPtrToGenericString(commandLine)); \n  MainWindow(argumentList, (WindowShow) commandShow); \n  return Application::RunMessageLoop(); \n} \n\n```", "```cpp\nnamespace SmallWindows { \n  class Application { \n    public: \n\n```", "```cpp\n      static void RegisterWindowClasses(HINSTANCE instanceHandle); \n      static int RunMessageLoop(); \n\n```", "```cpp\n      static HINSTANCE& InstanceHandle() {return instanceHandle;} \n\n```", "```cpp\n      static String& ApplicationName() {return applicationName;} \n\n```", "```cpp\n      static Window*& MainWindowPtr() {return mainWindowPtr;} \n\n  private: \n      static HINSTANCE instanceHandle; \n      static String applicationName; \n      static Window* mainWindowPtr; \n  }; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\nnamespace SmallWindows { \n  HINSTANCE Application::instanceHandle; \n  String Application::applicationName; \n  Window* Application::mainWindowPtr; \n\n```", "```cpp\n  void Application::RegisterWindowClasses(HINSTANCE \n                                          instanceHandle) { \n    Application::instanceHandle = instanceHandle; \n    assert(instanceHandle != nullptr); \n\n    WNDCLASS windowClass; \n    memset(&windowClass, 0, sizeof windowClass); \n    windowClass.hInstance = instanceHandle; \n    windowClass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS; \n    windowClass.hIcon = LoadIcon(nullptr, IDI_APPLICATION); \n    windowClass.hCursor = LoadCursor(nullptr, IDC_ARROW); \n    windowClass.hbrBackground = \n      (HBRUSH) GetStockObject(WHITE_BRUSH); \n\n    windowClass.lpfnWndProc = WindowProc; \n    windowClass.lpszClassName = TEXT(\"window\"); \n    ::RegisterClass(&windowClass); \n\n    windowClass.lpfnWndProc = DocumentProc; \n    windowClass.lpszClassName = TEXT(\"document\"); \n    ::RegisterClass(&windowClass); \n\n    windowClass.lpfnWndProc = DocumentProc; \n    windowClass.lpszClassName = TEXT(\"standarddocument\"); \n    ::RegisterClass(&windowClass); \n  } \n\n```", "```cpp\n  int Application::RunMessageLoop() { \n    assert(!applicationName.empty()); \n    assert(mainWindowPtr != nullptr); \n\n    MSG message; \n\n    if (dynamic_cast<Document*>(mainWindowPtr) == nullptr) { \n      while (::GetMessage(&message, nullptr, 0, 0)) { \n        ::TranslateMessage(&message); \n        ::DispatchMessage(&message); \n      } \n    } \n\n```", "```cpp\n    else { \n      Document* documentPtr = (Document*) mainWindowPtr; \n      int size = documentPtr->AcceleratorSet().size(), index = 0; \n\n```", "```cpp\n      ACCEL* acceleratorTablePtr = new ACCEL[size]; \n      assert(acceleratorTablePtr != nullptr); \n\n      for (ACCEL accelerator : documentPtr->AcceleratorSet()) { \n        acceleratorTablePtr[index++] = accelerator; \n      } \n\n      HACCEL acceleratorTable = \n              ::CreateAcceleratorTable(acceleratorTablePtr, size); \n\n      while (::GetMessage(&message, nullptr, 0, 0)) { \n        if (!::TranslateAccelerator(mainWindowPtr->WindowHandle(), \n                                    acceleratorTable, &message)) { \n          ::TranslateMessage(&message); \n          ::DispatchMessage(&message); \n        } \n      } \n\n```", "```cpp\n      delete [] acceleratorTablePtr; \n    } \n\n```", "```cpp\n    return ((int) message.wParam); \n  } \n\n```", "```cpp\nnamespace SmallWindows { \n  extern map<HWND,Window*> WindowMap; \n\n```", "```cpp\n  enum WindowStyle {NoStyle = 0, Border = WS_BORDER, \n                    ThickFrame = WS_THICKFRAME, \n                    Caption = WS_CAPTION, Child = WS_CHILD, \n                    ClipChildren = WS_CLIPCHILDREN, \n                    ClipSibling = WS_CLIPSIBLINGS, \n                    Disabled = WS_DISABLED, \n                    DialogFrame = WS_DLGFRAME, Group = WS_GROUP, \n                    HScroll = WS_HSCROLL, Minimize = WS_MINIMIZE, \n                    Maximize = WS_MAXIMIZE, \n                    MaximizeBox = WS_MAXIMIZEBOX, \n                    MinimizeBox = WS_MINIMIZEBOX, \n                    Overlapped = WS_OVERLAPPED, \n                    OverlappedWindow = WS_OVERLAPPEDWINDOW, \n                    Popup = WS_POPUP,PopupWindow = WS_POPUPWINDOW, \n                    SystemMenu = WS_SYSMENU, \n                    Tabulatorstop = WS_TABSTOP, \n                    Thickframe = WS_THICKFRAME, \n                    Tiled = WS_TILED, Visible = WS_VISIBLE, \n                    VScroll = WS_VSCROLL}; \n\n```", "```cpp\n  enum WindowShow {Restore = SW_RESTORE, Default = SW_SHOWDEFAULT, \n                   Maximized = SW_SHOWMAXIMIZED, \n                   Minimized = SW_SHOWMINIMIZED, \n                   MinNoActive = SW_SHOWMINNOACTIVE, \n                   NoActive = SW_SHOWNA, \n                   NoActivate = SW_SHOWNOACTIVATE, \n                   Normal = SW_SHOWNORMAL, \n                   Show = SW_SHOW, Hide = SW_HIDE}; \n\n```", "```cpp\n  enum MouseButton {NoButton = 0x00, LeftButton = 0x01, \n                    MiddleButton = 0x02, RightButton = 0x04}; \n  enum WheelDirection {WheelUp, WheelDown}; \n\n```", "```cpp\n  enum CoordinateSystem {LogicalWithScroll, LogicalWithoutScroll, \n                         PreviewCoordinate}; \n\n```", "```cpp\n  enum ButtonGroup {Ok = MB_OK, OkCancel = MB_OKCANCEL, \n                    YesNo = MB_YESNO, \n                    YesNoCancel = MB_YESNOCANCEL, \n                    RetryCancel = MB_RETRYCANCEL, \n                    CancelTryContinue = MB_CANCELTRYCONTINUE, \n                    AbortRetryIgnore = MB_ABORTRETRYIGNORE}; \n\n  enum Icon {NoIcon = 0, Information = MB_ICONINFORMATION, \n             Stop = MB_ICONSTOP, Warning = MB_ICONWARNING, \n             Question = MB_ICONQUESTION}; \n\n  enum Answer {OkAnswer = IDOK, Cancel = IDCANCEL, Yes = IDYES, \n               No = IDNO, Retry = IDRETRY, Continue = IDCONTINUE, \n               Abort = IDABORT, Ignore = IDIGNORE} const; \n\n```", "```cpp\n  enum DrawMode {Paint, Print}; \n\n```", "```cpp\n  class Application; \n\n  class Window { \n    public: \n      Window(CoordinateSystem system, Size pageSize = ZeroSize, \n             Window* parentPtr = nullptr, \n             WindowStyle style = OverlappedWindow, \n             WindowStyle extendedStyle = NoStyle, \n             WindowShow windowShow = Normal, \n             Point topLeft = ZeroPoint, Size windowSize=ZeroSize); \n\n```", "```cpp\n    protected: \n      Window(Window* parentPtr = nullptr); \n      Window(String className, CoordinateSystem system, \n             Size pageSize = ZeroSize, \n             Window* parentPtr = nullptr, \n             WindowStyle style = OverlappedWindow, \n             WindowStyle extendedStyle = NoStyle, \n             WindowShow windowShow = Normal, \n             Point windowTopLeft = ZeroPoint, \n             Size windowSize = ZeroSize); \n\n```", "```cpp\n      void PrepareDeviceContext(HDC deviceContextHandle) const; \n\n```", "```cpp\n    public: \n      virtual ~Window(); \n\n```", "```cpp\n      void ShowWindow(bool visible); \n      void EnableWindow(bool enable); \n\n```", "```cpp\n      virtual void OnSize(Size windowSize) {/* Empty. */} \n      virtual void OnMove(Point topLeft) {/* Empty. */} \n      virtual void OnHelp() {/* Empty. */} \n\n```", "```cpp\n      HWND WindowHandle() const {return windowHandle;} \n      HWND& WindowHandle() {return windowHandle;} \n      Window* ParentWindowPtr() const {return parentPtr;} \n      Window*& ParentWindowPtr() {return parentPtr;} \n      void SetHeader(String headerText); \n\n```", "```cpp\n      double GetZoom() const {return zoom;} \n      void SetZoom(double z) {zoom = z;} \n\n```", "```cpp\n      void SetTimer(int timerId, unsigned int interval); \n      void DropTimer(int timerId); \n      virtual void OnTimer(int timerId) {/* Empty. */} \n\n```", "```cpp\n      void SetFocus() const; \n      bool HasFocus() const; \n\n```", "```cpp\n      virtual void OnGainFocus() {/* Empty. */} \n      virtual void OnLoseFocus() {/* Empty. */} \n\n```", "```cpp\n      virtual void OnMouseDown(MouseButton mouseButtons,\n                               Point mousePoint,\n                               bool shiftPressed,\n                               bool controlPressed) {/* Empty. */}\n      virtual void OnMouseUp(MouseButton mouseButtons,\n                             Point mousePoint,\n                             bool shiftPressed,\n                             bool controlPressed) {/* Empty. */}\n      virtual void OnMouseMove(MouseButton mouseButtons,\n                               Point mousePoint,\n                               bool shiftPressed,\n                               bool controlPressed) {/* Empty. */}\n\n```", "```cpp\n      virtual void OnDoubleClick(MouseButton mouseButtons,\n                           Point mousePoint, bool shiftPressed,\n                           bool controlPressed) {/* Empty. */}\n\n```", "```cpp\n      virtual void OnMouseWheel(WheelDirection direction,\n                                bool shiftPressed,\n                                bool controlPressed){/* Empty. */}\n\n```", "```cpp\n      virtual void OnTouchDown(vector<Point> pointList); \n      virtual void OnTouchMove(vector<Point> pointList); \n      virtual void OnTouchUp(vector<Point> pointList); \n\n```", "```cpp\n      virtual bool OnKeyDown(WORD key, bool shiftPressed, \n                             bool controlPressed) {return false;} \n      virtual void OnChar(TCHAR tChar) {/* Empty. */} \n      virtual bool OnKeyUp(WORD key, bool shiftPressed, \n                           bool controlPressed) {return false;} \n\n```", "```cpp\n      virtual void OnPaint(Graphics& graphics) const\n                          {OnDraw(graphics, Paint);} \n      virtual void OnPrint(Graphics& graphics, int page, \n                           int copy, int totalPages) const\n                           {OnDraw(graphics, Print);} \n      virtual void OnDraw(Graphics& graphics, \n                          DrawMode drawMode) const {/* Empty. */} \n\n```", "```cpp\n      void Invalidate(bool clear = true) const; \n      void Invalidate(Rect areaRect, bool clear = true) const; \n      void UpdateWindow(); \n\n```", "```cpp\n      virtual bool TryClose() {return true;} \n      virtual void OnClose(); \n      virtual void OnDestroy() {/* Empty. */} \n\n```", "```cpp\n    protected: \n      Point DeviceToLogical(Point point) const; \n      Rect DeviceToLogical(Rect rect) const; \n      Size DeviceToLogical(Size size) const; \n      Point LogicalToDevice(Point point) const; \n      Rect LogicalToDevice(Rect rect) const; \n      Size LogicalToDevice(Size size) const; \n\n```", "```cpp\n    public: \n      Point GetWindowDevicePosition() const; \n      void SetWindowDevicePosition(Point topLeft); \n      Size GetWindowDeviceSize() const; \n      void SetWindowDeviceSize(Size windowSize); \n      Size GetClientDeviceSize() const; \n      Rect GetWindowDeviceRect() const; \n      void SetWindowDeviceRect(Rect windowRect); \n\n```", "```cpp\n      Point GetWindowPosition() const; \n      void SetWindowPosition(Point topLeft); \n      Size GetWindowSize() const; \n      void SetWindowSize(Size windowSize); \n      Size GetClientSize() const; \n      Rect GetWindowRect() const; \n      void SetWindowRect(Rect windowRect) ; \n\n```", "```cpp\n    private: \n      TEXTMETRIC CreateTextMetric(Font font); \n\n```", "```cpp\n    public: \n      int GetCharacterAverageWidth(Font font) const; \n      int GetCharacterHeight(Font font) const; \n      int GetCharacterAscent(Font font) const; \n      int GetCharacterWidth(Font font, TCHAR tChar) const; \n\n```", "```cpp\n      Answer MessageBox(String message, \n                    String caption = TEXT(\"Error\"), \n                    ButtonGroup buttonGroup = Ok, \n                    Icon icon = NoIcon, bool help = false) const; \n\n```", "```cpp\n    protected: \n      const Size pageSize; \n\n```", "```cpp\n      HWND windowHandle; \n      Window* parentPtr; \n\n```", "```cpp\n    private: \n      CoordinateSystem system; \n      double zoom = 1.0; \n\n```", "```cpp\n      friend LRESULT CALLBACK WindowProc(HWND windowHandle, \n                                 UINT message, WPARAM wordParam, \n                                 LPARAM longParam); \n  }; \n\n```", "```cpp\n  extern map<HWND,Window*> WindowMap; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\nnamespace SmallWindows { \n  map<HWND,Window*> WindowMap; \n\n```", "```cpp\n  Window::Window(CoordinateSystem system, Size pageSize \n                 /* = ZeroSize */, Window* parentPtr /*=nullptr*/, \n                 WindowStyle style /* = OverlappedWindow */, \n                 WindowStyle extendedStyle /* = NoStyle */, \n                 WindowShow windowShow /* = Normal */, \n                 Point windowTopLeft /* = ZeroPoint */, \n                 Size windowSize /* = ZeroSize */) \n   :Window(TEXT(\"window\"), system, pageSize, parentPtr, style, \n           extendedStyle, windowShow, windowTopLeft, windowSize) { \n    // Empty. \n  } \n\n```", "```cpp\n  Window::Window(String className, CoordinateSystem system, \n                 Size pageSize /* = ZeroSize */, \n                 Window* parentPtr /* = nullptr */, \n                 WindowStyle style /* = OverlappedWindow */, \n                 WindowStyle extendedStyle /* = NoStyle */, \n                 WindowShow windowShow /* = Normal */, \n                 Point windowTopLeft /* = ZeroPoint */, \n                 Size windowSize /* = ZeroSize */) \n   :parentPtr(parentPtr), \n    system(system), \n    pageSize(pageSize) { \n\n```", "```cpp\n    if (parentPtr != nullptr) { \n      windowTopLeft = parentPtr->LogicalToDevice(windowTopLeft); \n      windowSize = parentPtr->LogicalToDevice(windowSize); \n    } \n\n```", "```cpp\n    int left, top, width, height; \n\n    if (windowTopLeft != ZeroPoint) { \n      left = windowTopLeft.X(); \n      top = windowTopLeft.Y(); \n    } \n    else { \n      left = CW_USEDEFAULT; \n      top = CW_USEDEFAULT; \n    } \n\n    if (windowSize != ZeroSize) { \n      width = windowSize.Width(); \n      height = windowSize.Height(); \n    } \n\n    else { \n      width = CW_USEDEFAULT; \n      height = CW_USEDEFAULT; \n    } \n\n    HWND parentHandle = (parentPtr != nullptr) ? \n                        parentPtr->windowHandle : nullptr; \n\n    windowHandle = \n      CreateWindowEx(extendedStyle, className.c_str(), \n                     nullptr, style, left, top, width, height, \n                     parentHandle,::CreateMenu(), \n                     Application::InstanceHandle(), this); \n\n    assert(windowHandle != nullptr); \n\n```", "```cpp\n    WindowMap[windowHandle] = this; \n\n```", "```cpp\n    ::ShowWindow(windowHandle, windowShow); \n    ::RegisterTouchWindow(windowHandle, 0); \n  } \n\n```", "```cpp\n  Window::~Window() { \n    OnDestroy(); \n    WindowMap.erase(windowHandle); \n\n    if (parentPtr != nullptr) { \n      parentPtr->SetFocus(); \n    } \n\n```", "```cpp\n    if (this == Application::MainWindowPtr()) { \n      ::PostQuitMessage(0); \n    } \n\n    WindowMap.erase(windowHandle); \n    ::DestroyWindow(windowHandle); \n  } \n\n```", "```cpp\n  void Window::ShowWindow(bool visible) { \n    ::ShowWindow(windowHandle, visible ? SW_SHOW : SW_HIDE); \n  } \n\n```", "```cpp\n  void Window::EnableWindow(bool enable) { \n    ::EnableWindow(windowHandle, enable ? TRUE : FALSE); \n  } \n\n```", "```cpp\n  void Window::SetHeader(String headerText) { \n    ::SetWindowText(windowHandle, headerText.c_str()); \n  } \n\n```", "```cpp\n  void Window::SetTimer(int timerId, unsigned int interval) { \n    ::SetTimer(windowHandle, timerId, interval, nullptr); \n  } \n\n  void Window::DropTimer(int timerId) { \n    ::KillTimer(windowHandle, timerId); \n  } \n\n```", "```cpp\n  void Window::SetFocus() const { \n    ::SetFocus(windowHandle); \n  } \n\n  bool Window::HasFocus() const { \n    return (::GetFocus() == windowHandle); \n  } \n\n```", "```cpp\n  void Window::OnTouchDown(vector<Point> pointList) { \n    for (Point touchPoint : pointList) { \n      OnMouseDown(NoButton, touchPoint, false, false); \n    } \n  } \n\n  void Window::OnTouchMove(vector<Point> pointList) { \n    for (Point touchPoint : pointList) { \n      OnMouseMove(NoButton, touchPoint, false, false); \n    } \n  } \n\n  void Window::OnTouchUp(vector<Point> pointList) { \n    for (Point touchPoint : pointList) { \n      OnMouseUp(NoButton, touchPoint, false, false); \n    } \n  } \n\n```", "```cpp\n  void OnTouch(Window* windowPtr, WPARAM wordParam, \n               LPARAM longParam, Point windowTopLeft) { \n    UINT inputs = LOWORD(wordParam); \n    HTOUCHINPUT touchInputHandle = (HTOUCHINPUT) longParam; \n\n    TOUCHINPUT* inputArray = new TOUCHINPUT[inputs]; \n    assert(inputArray != nullptr); \n\n    if (::GetTouchInputInfo(touchInputHandle, inputs, \n                            inputArray, sizeof(TOUCHINPUT))){ \n      vector<Point> pointList; \n\n      for (UINT index = 0; index < inputs; ++index) { \n        Point touchPoint \n          ((inputArray[index].x / 100) - windowTopLeft.X(), \n           (inputArray[index].y / 100) - windowTopLeft.Y()); \n        pointList.push_back(touchPoint); \n      } \n\n```", "```cpp\n      static DWORD touchId = -1; \n      if (touchId != inputArray[0].dwID) { \n        touchId = inputArray[0].dwID; \n        windowPtr->OnTouchDown(pointList); \n      } \n      else { \n        windowPtr->OnTouchMove(pointList); \n      } \n\n      ::CloseTouchInputHandle(touchInputHandle); \n    } \n\n    delete [] inputArray; \n  } \n\n```", "```cpp\n  void Window::Invalidate(bool clear /* = true */) const { \n    ::InvalidateRect(windowHandle, nullptr, clear ? TRUE : FALSE); \n  } \n\n```", "```cpp\n  void Window::Invalidate(Rect areaRect, bool clear /* = true */) \n                          const { \n    RECT rect = (RECT) LogicalToDevice(areaRect); \n    ::InvalidateRect(windowHandle, &rect, clear ? TRUE : FALSE); \n  } \n\n```", "```cpp\n  void Window::UpdateWindow() { \n    ::UpdateWindow(windowHandle); \n  } \n\n```", "```cpp\n  void Window::PrepareDeviceContext(HDC deviceContextHandle)const{ \n    switch (system) { \n      case PreviewCoordinate: { \n        RECT clientDeviceRect; \n        ::GetClientRect(windowHandle, &clientDeviceRect); \n\n        ::SetMapMode(deviceContextHandle, MM_ANISOTROPIC); \n        ::SetWindowExtEx(deviceContextHandle, pageSize.Width(), \n                         pageSize.Height(), nullptr); \n\n        ::SetViewportExtEx(deviceContextHandle, \n                           clientDeviceRect.right, \n                           clientDeviceRect.bottom, nullptr); \n      } \n      break; \n\n```", "```cpp\n      case LogicalWithScroll: \n      case LogicalWithoutScroll: \n        ::SetMapMode(deviceContextHandle, MM_ISOTROPIC); \n\n        { int horizontalSize = \n                100 * GetDeviceCaps(deviceContextHandle,HORZSIZE), \n              verticalSize = \n                100 * GetDeviceCaps(deviceContextHandle,VERTSIZE); \n          ::SetWindowExtEx(deviceContextHandle, horizontalSize, \n                           verticalSize, nullptr); \n        } \n\n        { int horizontalResolution = (int)  \n               (zoom*GetDeviceCaps(deviceContextHandle, HORZRES)), \n             verticalResolution = (int)  \n               (zoom*GetDeviceCaps(deviceContextHandle, VERTRES)); \n          ::SetViewportExtEx(deviceContextHandle, \n               horizontalResolution, verticalResolution, nullptr); \n        } \n\n```", "```cpp\n        if (system == LogicalWithScroll) { \n          int horizontalScroll = \n                ::GetScrollPos(windowHandle, SB_HORZ), \n              verticalScroll = \n                ::GetScrollPos(windowHandle, SB_VERT); \n          ::SetWindowOrgEx(deviceContextHandle, horizontalScroll, \n                           verticalScroll, nullptr); \n        } \n        break; \n  } \n} \n\n```", "```cpp\n  Point Window::DeviceToLogical(Point point) const { \n    HDC deviceContextHandle = ::GetDC(windowHandle); \n    PrepareDeviceContext(deviceContextHandle); \n    POINT pointStruct = (POINT) point; \n    ::DPtoLP(deviceContextHandle, &pointStruct, 1); \n    ::ReleaseDC(windowHandle, deviceContextHandle); \n    return Point(pointStruct); \n  } \n\n```", "```cpp\n  Rect Window::DeviceToLogical(Rect rect) const { \n    return Rect(DeviceToLogical(rect.TopLeft()), \n                DeviceToLogical(rect.BottomRight())); \n  } \n\n  Size Window::DeviceToLogical(Size size) const { \n    return ((Size) DeviceToLogical(Rect(ZeroPoint, size))); \n  } \n\n```", "```cpp\n  Point Window::LogicalToDevice(Point point) const { \n    HDC deviceContextHandle = ::GetDC(windowHandle); \n    PrepareDeviceContext(deviceContextHandle); \n    POINT pointStruct = (POINT) point; \n    ::LPtoDP(deviceContextHandle, &pointStruct, 1); \n    ::ReleaseDC(windowHandle, deviceContextHandle); \n    return Point(pointStruct); \n  } \n\n  Rect Window::LogicalToDevice(Rect rect) const { \n    return Rect(LogicalToDevice(rect.TopLeft()), \n                LogicalToDevice(rect.BottomRight())); \n  } \n\n  Size Window::LogicalToDevice(Size size) const { \n    return ((Size) LogicalToDevice(Rect(ZeroPoint, size))); \n  } \n\n```", "```cpp\n  Point Window::GetWindowDevicePosition() const { \n    return GetWindowDeviceRect().TopLeft(); \n  } \n\n  void Window::SetWindowDevicePosition(Point topLeft) { \n    ::SetWindowPos(windowHandle, nullptr, topLeft.X(), \n                   topLeft.Y(), 0, 0, SWP_NOSIZE); \n  } \n\n  Size Window::GetWindowDeviceSize() const { \n    return GetWindowDeviceRect().GetSize(); \n  } \n\n  void Window::SetWindowDeviceSize(Size windowSize) { \n    ::SetWindowPos(windowHandle, nullptr, 0, 0, \n               windowSize.Width(),windowSize.Height(),SWP_NOMOVE); \n  } \n\n  Size Window::GetClientDeviceSize() const { \n    RECT rectStruct; \n    ::GetClientRect(windowHandle, &rectStruct); \n    return Size(rectStruct.right, rectStruct.bottom); \n  } \n\n  Rect Window::GetWindowDeviceRect() const { \n    RECT windowRect; \n    ::GetWindowRect(windowHandle, &windowRect); \n    POINT topLeft = {windowRect.left, windowRect.top}, \n          bottomRight = {windowRect.right, windowRect.bottom}; \n\n    if (parentPtr != nullptr) { \n      ::ScreenToClient(parentPtr->windowHandle, &topLeft); \n      ::ScreenToClient(parentPtr->windowHandle, &bottomRight); \n    } \n\n    return Rect(Point(topLeft), Point(bottomRight)); \n  } \n\n  void Window::SetWindowDeviceRect(Rect windowRect) { \n    SetWindowDevicePosition(windowRect.TopLeft()); \n    SetWindowDeviceSize(windowRect.GetSize()); \n  } \n\n```", "```cpp\n  Point Window::GetWindowPosition() const { \n    return DeviceToLogical(GetWindowDevicePosition()); \n  } \n\n  void Window::SetWindowPosition(Point topLeft) { \n    SetWindowDevicePosition(LogicalToDevice(topLeft)); \n  } \n\n  Size Window::GetWindowSize() const { \n    return DeviceToLogical(GetWindowDeviceSize()); \n  } \n\n  void Window::SetWindowSize(Size windowSize) { \n    SetWindowDeviceSize(LogicalToDevice(windowSize)); \n  } \n\n  Size Window::GetClientSize() const { \n    return DeviceToLogical(GetClientDeviceSize()); \n  } \n\n  Rect Window::GetWindowRect() const { \n    return DeviceToLogical(GetWindowDeviceRect()); \n  } \n\n  void Window::SetWindowRect(Rect windowRect) { \n    SetWindowDeviceRect(LogicalToDevice(windowRect)); \n  } \n\n```", "```cpp\n  TEXTMETRIC Window::CreateTextMetric(Font font) const { \n    font.PointsToLogical(); \n\n    HDC deviceContextHandle = ::GetDC(windowHandle); \n    PrepareDeviceContext(deviceContextHandle); \n\n    HFONT fontHandle = ::CreateFontIndirect(&font.LogFont()); \n    HFONT oldFontHandle = \n      (HFONT) ::SelectObject(deviceContextHandle, fontHandle); \n\n    TEXTMETRIC textMetric; \n    ::GetTextMetrics(deviceContextHandle, &textMetric); \n\n```", "```cpp\n    ::SelectObject(deviceContextHandle, oldFontHandle); \n    ::DeleteObject(fontHandle); \n\n```", "```cpp\n    ::ReleaseDC(windowHandle, deviceContextHandle); \n    return textMetric; \n  } \n\n```", "```cpp\n  int Window::GetCharacterHeight(Font font) const { \n    return CreateTextMetric(font).tmHeight; \n  } \n\n  int Window::GetCharacterAscent(Font font) const { \n    return CreateTextMetric(font).tmAscent; \n  } \n\n  int Window::GetCharacterAverageWidth(Font font) const { \n    return CreateTextMetric(font).tmAveCharWidth; \n  } \n\n```", "```cpp\n  int Window::GetCharacterWidth(Font font, TCHAR tChar) const { \n    font.PointsToLogical(); \n\n    HDC deviceContextHandle = ::GetDC(windowHandle); \n    PrepareDeviceContext(deviceContextHandle); \n\n    HFONT fontHandle = ::CreateFontIndirect(&font.LogFont()); \n    HFONT oldFontHandle = \n      (HFONT) ::SelectObject(deviceContextHandle, fontHandle); \n\n    SIZE szChar; \n    ::GetTextExtentPoint(deviceContextHandle, &tChar, 1, &szChar); \n\n    ::SelectObject(deviceContextHandle, oldFontHandle); \n    ::DeleteObject(fontHandle); \n    ::ReleaseDC(windowHandle, deviceContextHandle); \n\n    return szChar.cx; \n  } \n\n```", "```cpp\n  void Window::OnClose() { \n    if (TryClose()) { \n      delete this; \n    } \n  } \n\n```", "```cpp\n  Answer Window::MessageBox(String message, \n                            String caption /*=TEXT(\"Error\")*/, \n                            ButtonGroup buttonGroup /* = Ok */, \n                            Icon icon /* = NoIcon */, \n                            bool help /* = false */) const { \n    return (Answer) ::MessageBox(windowHandle, message.c_str(), \n                                 caption.c_str(), buttonGroup | \n                                 icon | (help ? MB_HELP : 0)); \n  } \n\n```", "```cpp\n  LRESULT CALLBACK WindowProc(HWND windowHandle, UINT message, \n                              WPARAM wordParam, LPARAM longParam){ \n\n```", "```cpp\n    if (WindowMap.count(windowHandle) == 1) { \n      Window* windowPtr = WindowMap[windowHandle]; \n\n```", "```cpp\n      switch (message) { \n        case WM_SETFOCUS: \n          windowPtr->OnGainFocus(); \n          return 0; \n\n        case WM_KILLFOCUS: \n          windowPtr->OnLoseFocus(); \n          return 0; \n\n```", "```cpp\n        case WM_TIMER: \n          windowPtr->OnTimer((int) wordParam); \n          return 0; \n\n```", "```cpp\n        case WM_MOVE: { \n            Point windowTopLeft = \n              {LOWORD(longParam), HIWORD(longParam)}; \n            windowPtr->OnMove \n                     (windowPtr->DeviceToLogical(windowTopLeft)); \n          } \n          return 0; \n\n        case WM_SIZE: { \n            Size clientSize = \n              {LOWORD(longParam), HIWORD(longParam)}; \n            windowPtr-> \n              OnSize(windowPtr->DeviceToLogical(clientSize)); \n          } \n          return 0; \n\n```", "```cpp\n        case WM_HELP: \n          windowPtr->OnHelp(); \n          break; \n\n```", "```cpp\n        case WM_KEYDOWN: { \n            WORD key = wordParam; \n            bool shiftPressed = (::GetKeyState(VK_SHIFT) < 0); \n            bool controlPressed = (::GetKeyState(VK_CONTROL) < 0); \n\n```", "```cpp\n            if (windowPtr->OnKeyDown(wordParam, shiftPressed, \n                                     controlPressed)) { \n              return 0; \n            } \n          } \n          break; \n\n```", "```cpp\n        case WM_CHAR: { \n            int asciiCode = (int) wordParam; \n\n            if ((asciiCode >= 32) && (asciiCode <= 127)) { \n              windowPtr->OnChar((TCHAR) asciiCode); \n              return 0; \n            } \n          } \n          break; \n\n        case WM_KEYUP: { \n            bool shiftPressed = (::GetKeyState(VK_SHIFT) < 0); \n            bool controlPressed = (::GetKeyState(VK_CONTROL) < 0); \n\n            if (windowPtr->OnKeyUp(wordParam, shiftPressed, \n                                   controlPressed)) { \n              return 0; \n            } \n          } \n          break; \n\n```", "```cpp\n        case WM_LBUTTONDOWN: { \n            bool shiftPressed = (::GetKeyState(VK_SHIFT) < 0); \n            bool controlPressed = (::GetKeyState(VK_CONTROL) < 0); \n            ::SetCapture(windowPtr->windowHandle); \n            Point mousePoint = \n              Point({LOWORD(longParam), HIWORD(longParam)}); \n            windowPtr->OnMouseDown(LeftButton, \n                         windowPtr->DeviceToLogical(mousePoint), \n                         shiftPressed, controlPressed); \n          } \n          return 0; \n\n        case WM_MBUTTONDOWN: { \n            bool shiftPressed = (::GetKeyState(VK_SHIFT) < 0); \n            bool controlPressed = (::GetKeyState(VK_CONTROL) < 0); \n            ::SetCapture(windowPtr->windowHandle); \n            Point mousePoint = \n              Point({LOWORD(longParam), HIWORD(longParam)}); \n            windowPtr->OnMouseDown(MiddleButton, \n                         windowPtr->DeviceToLogical(mousePoint), \n                         shiftPressed, controlPressed); \n          } \n          return 0; \n\n        case WM_RBUTTONDOWN: { \n            bool shiftPressed = (::GetKeyState(VK_SHIFT) < 0); \n            bool controlPressed = (::GetKeyState(VK_CONTROL) < 0); \n            ::SetCapture(windowPtr->windowHandle); \n            Point mousePoint = \n              Point({LOWORD(longParam), HIWORD(longParam)}); \n            windowPtr->OnMouseDown(RightButton, \n                         windowPtr->DeviceToLogical(mousePoint), \n                         shiftPressed, controlPressed); \n          } \n          return 0; \n\n```", "```cpp\n        case WM_MOUSEMOVE: { \n            MouseButton buttonMask = (MouseButton) \n              (((wordParam & MK_LBUTTON) ? LeftButton : 0) | \n               ((wordParam & MK_MBUTTON) ? MiddleButton : 0) | \n               ((wordParam & MK_RBUTTON) ? RightButton : 0)); \n\n            if (buttonMask != NoButton) { \n              bool shiftPressed = (::GetKeyState(VK_SHIFT) < 0); \n              bool controlPressed = (::GetKeyState(VK_CONTROL)<0); \n              Point mousePoint = \n                Point({LOWORD(longParam), HIWORD(longParam)}); \n              windowPtr->OnMouseMove(buttonMask, \n                           windowPtr->DeviceToLogical(mousePoint), \n                           shiftPressed, controlPressed); \n            } \n          } \n          return 0; \n\n```", "```cpp\n        case WM_LBUTTONUP: { \n            bool shiftPressed = (::GetKeyState(VK_SHIFT) < 0); \n            bool controlPressed = (::GetKeyState(VK_CONTROL) < 0); \n            Point mousePoint = \n              Point({LOWORD(longParam), HIWORD(longParam)}); \n            windowPtr->OnMouseUp(LeftButton, \n                         windowPtr->DeviceToLogical(mousePoint), \n                         shiftPressed, controlPressed); \n            ::ReleaseCapture(); \n          } \n          return 0;  \n\n        case WM_MBUTTONUP: { \n            bool shiftPressed = (::GetKeyState(VK_SHIFT) < 0); \n            bool controlPressed = (::GetKeyState(VK_CONTROL) < 0); \n            Point mousePoint = \n              Point({LOWORD(longParam), HIWORD(longParam)}); \n            windowPtr->OnMouseUp(MiddleButton, \n                         windowPtr->DeviceToLogical(mousePoint), \n                         shiftPressed, controlPressed); \n            ::ReleaseCapture(); \n          } \n          return 0; \n\n        case WM_RBUTTONUP: { \n            bool shiftPressed = (::GetKeyState(VK_SHIFT) < 0); \n            bool controlPressed = (::GetKeyState(VK_CONTROL) < 0); \n            Point mousePoint = \n              Point({LOWORD(longParam), HIWORD(longParam)}); \n            windowPtr->OnMouseUp(RightButton, \n                         windowPtr->DeviceToLogical(mousePoint), \n                         shiftPressed, controlPressed); \n            ::ReleaseCapture(); \n          } \n          return 0;  \n\n        case WM_LBUTTONDBLCLK: { \n            bool shiftPressed = (::GetKeyState(VK_SHIFT) < 0); \n            bool controlPressed = (::GetKeyState(VK_CONTROL) < 0); \n            Point mousePoint = \n              Point({LOWORD(longParam), HIWORD(longParam)}); \n            windowPtr->OnDoubleClick(LeftButton, \n                         windowPtr->DeviceToLogical(mousePoint), \n                         shiftPressed, controlPressed); \n          } \n          return 0;  \n\n        case WM_MBUTTONDBLCLK: { \n            bool shiftPressed = (::GetKeyState(VK_SHIFT) < 0); \n            bool controlPressed = (::GetKeyState(VK_CONTROL) < 0); \n            Point mousePoint = \n              Point({LOWORD(longParam), HIWORD(longParam)}); \n            windowPtr->OnDoubleClick(MiddleButton, \n                         windowPtr->DeviceToLogical(mousePoint), \n                         shiftPressed, controlPressed); \n          } \n          return 0;  \n\n        case WM_RBUTTONDBLCLK: { \n            bool shiftPressed = (::GetKeyState(VK_SHIFT) < 0); \n            bool controlPressed = (::GetKeyState(VK_CONTROL) < 0); \n            Point mousePoint = \n              Point({LOWORD(longParam), HIWORD(longParam)}); \n            windowPtr->OnDoubleClick(RightButton, \n                         windowPtr->DeviceToLogical(mousePoint), \n                         shiftPressed, controlPressed); \n          } \n          return 0; \n\n```", "```cpp\n        case WM_TOUCH: \n          OnTouch(windowPtr, wordParam, longParam, \n                  windowPtr->GetWindowDevicePosition()); \n          return 0; \n\n```", "```cpp\n        case WM_PAINT: { \n            PAINTSTRUCT paintStruct; \n            HDC deviceContextHandle = \n              ::BeginPaint(windowHandle,&paintStruct); \n            windowPtr->PrepareDeviceContext(deviceContextHandle); \n            Graphics graphics(windowPtr, deviceContextHandle); \n            windowPtr->OnPaint(graphics); \n            ::EndPaint(windowHandle, &paintStruct); \n          } \n          return 0; \n\n```", "```cpp\n        case WM_CLOSE: \n          windowPtr->OnClose(); \n          return 0; \n      } \n    } \n\n```", "```cpp\n    return DefWindowProc(windowHandle, message, wordParam, longParam); \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n\n```", "```cpp\n  class Window; \n  enum PenStyle {Solid = PS_SOLID, Dash = PS_DASH, Dot = PS_DOT, \n                 DashDot = PS_DASHDOT, DashDotDot =PS_DASHDOTDOT};\n  class Graphics { \n    private: \n      Graphics(Window* windowPtr, HDC deviceContextHandle); \n\n```", "```cpp\n    public: \n      int Save(); \n      void Restore(int saveId); \n\n```", "```cpp\n      void SetOrigin(Point centerPoint); \n      void IntersectClip(Rect clipRect); \n\n```", "```cpp\n      void DrawLine(Point startPoint, Point endPoint, \n                    Color penColor, PenStyle penStyle = Solid); \n      void DrawRectangle(Rect rect, Color penColor, \n                         PenStyle = Solid); \n      void FillRectangle(Rect rect, Color penColor, \n                       Color brushColor, PenStyle penStyle=Solid); \n      void DrawEllipse(Rect rect, Color penColor, \n                       PenStyle = Solid); \n      void FillEllipse(Rect rect, Color penColor, \n                       Color brushColor, PenStyle penStyle=Solid); \n      void DrawText(Rect areaRect, String text, Font font, \n                    Color textColor, Color backColor, \n                    bool pointsToMeters = true); \n\n```", "```cpp\n      HDC GetDeviceContextHandle() const \n                                   {return deviceContextHandle;} \n\n```", "```cpp\n    private: \n      Window* windowPtr; \n      HDC deviceContextHandle; \n\n```", "```cpp\n      friend LRESULT CALLBACK \n        WindowProc(HWND windowHandle, UINT message, \n                   WPARAM wordParam, LPARAM longParam); \n      friend Graphics* StandardDialog::PrintDialog \n                               (Window*parentPtr,int totalPages, \n                                int& firstPage, int& lastPage, \n                                int& copies, bool& sorted); \n  }; \n};\n```", "```cpp\n#include \"SmallWindows.h\"\n```", "```cpp\nnamespace SmallWindows { \n  Graphics::Graphics(Window* windowPtr, HDC deviceContextHandle) \n   :windowPtr(windowPtr), \n    deviceContextHandle(deviceContextHandle) { \n    // Empty. \n  } \n\n```", "```cpp\n  int Graphics::Save() { \n    return ::SaveDC(deviceContextHandle); \n  } \n\n  void Graphics::Restore(int saveId) { \n    ::RestoreDC(deviceContextHandle, saveId); \n  } \n\n```", "```cpp\n  void Graphics::SetOrigin(Point centerPoint) { \n    ::SetWindowOrgEx(deviceContextHandle, centerPoint.X(), \n                     centerPoint.Y(), nullptr); \n  } \n\n```", "```cpp\n  void Graphics::IntersectClip(Rect clipRect) { \n    ::IntersectClipRect(deviceContextHandle, clipRect.Left(), \n               clipRect.Top(),clipRect.Right(),clipRect.Bottom()); \n  } \n\n```", "```cpp\n  void Graphics::DrawLine(Point startPoint, Point endPoint, \n                     Color color, PenStyle penStyle/* = Solid */){ \n    HPEN penHandle = ::CreatePen(penStyle, 0, color.ColorRef()); \n    HPEN oldPenHandle = \n      (HPEN) ::SelectObject(deviceContextHandle,penHandle); \n\n```", "```cpp\n    ::MoveToEx(deviceContextHandle, startPoint.X(), \n               startPoint.Y(), nullptr); \n    ::LineTo(deviceContextHandle, endPoint.X(), endPoint.Y()); \n\n```", "```cpp\n    ::SelectObject(deviceContextHandle, oldPenHandle); \n    ::DeleteObject(penHandle); \n  } \n\n```", "```cpp\n  void Graphics::DrawRectangle(Rect rect, Color penColor, \n                               PenStyle penStyle /* = Solid */) { \n\n    HPEN penHandle = \n      ::CreatePen(penStyle, 0, penColor.ColorRef()); \n\n    LOGBRUSH lbBrush; \n    lbBrush.lbStyle = BS_HOLLOW; \n    HBRUSH brushHandle = ::CreateBrushIndirect(&lbBrush); \n\n    HPEN oldPenHandle = \n      (HPEN) ::SelectObject(deviceContextHandle,penHandle); \n    HBRUSH oldBrushHandle = \n      (HBRUSH)  ::SelectObject(deviceContextHandle, brushHandle); \n\n    ::Rectangle(deviceContextHandle, rect.Left(), rect.Top(), \n                rect.Right(), rect.Bottom()); \n\n    ::SelectObject(deviceContextHandle, oldBrushHandle); \n    ::DeleteObject(brushHandle); \n\n    ::SelectObject(deviceContextHandle, oldPenHandle); \n    ::DeleteObject(penHandle); \n  } \n\n```", "```cpp\n  void Graphics::FillRectangle(Rect rect, Color penColor, \n               Color brushColor, PenStyle penStyle /* = Solid */){ \n\n    HPEN penHandle = \n      ::CreatePen(penStyle, 0, penColor.ColorRef()); \n    HBRUSH brushHandle = \n      ::CreateSolidBrush(brushColor.ColorRef()); \n\n    HPEN oldPenHandle = \n      (HPEN)::SelectObject(deviceContextHandle,penHandle); \n    HBRUSH oldBrushHandle = \n      (HBRUSH) ::SelectObject(deviceContextHandle, brushHandle); \n\n    ::Rectangle(deviceContextHandle, rect.Left(), rect.Top(), \n                rect.Right(), rect.Bottom()); \n\n    ::SelectObject(deviceContextHandle, oldBrushHandle); \n    ::DeleteObject(brushHandle); \n\n    ::SelectObject(deviceContextHandle, oldPenHandle); \n    ::DeleteObject(penHandle); \n  } \n\n```", "```cpp\n  void Graphics::DrawEllipse(Rect rect, Color penColor, \n                             PenStyle penStyle /* = Solid */) { \n\n   HPEN penHandle = \n      ::CreatePen(penStyle, 0, penColor.ColorRef()); \n\n    LOGBRUSH lbBrush; \n    lbBrush.lbStyle = BS_HOLLOW; \n    HBRUSH brushHandle = ::CreateBrushIndirect(&lbBrush); \n\n    HPEN oldPenHandle = \n      (HPEN)::SelectObject(deviceContextHandle,penHandle); \n    HBRUSH oldBrushHandle = \n      (HBRUSH) ::SelectObject(deviceContextHandle, brushHandle); \n\n    ::Ellipse(deviceContextHandle, rect.Left(), rect.Top(), \n              rect.Right(), rect.Bottom()); \n\n    ::SelectObject(deviceContextHandle, oldBrushHandle); \n    ::DeleteObject(brushHandle); \n\n    ::SelectObject(deviceContextHandle, oldPenHandle); \n    ::DeleteObject(penHandle); \n  } \n\n  void Graphics::FillEllipse(Rect rect, Color penColor, \n               Color brushColor, PenStyle penStyle /* = Solid */){ \n    HPEN penHandle = \n      ::CreatePen(penStyle, 0, penColor.ColorRef()); \n    HBRUSH brushHandle = \n      ::CreateSolidBrush(brushColor.ColorRef()); \n\n    HPEN oldPenHandle = \n      (HPEN) ::SelectObject(deviceContextHandle,penHandle); \n    HBRUSH oldBrushHandle = \n      (HBRUSH) ::SelectObject(deviceContextHandle, brushHandle); \n\n    ::Ellipse(deviceContextHandle, rect.Left(), rect.Top(), \n              rect.Right(), rect.Bottom()); \n\n    ::SelectObject(deviceContextHandle, oldBrushHandle); \n    ::DeleteObject(brushHandle); \n\n    ::SelectObject(deviceContextHandle, oldPenHandle); \n    ::DeleteObject(penHandle); \n  } \n\n```", "```cpp\n  void Graphics::DrawText(Rect areaRect, String text, Font font, \n                          Color textColor, Color backColor, \n                          bool pointsToMeters /* = true */) { \n    if (pointsToMeters) { \n      font.PointsToLogical(); \n    } \n\n    HFONT fontHandle = ::CreateFontIndirect(&font.LogFont()); \n    HFONT oldFontHandle = \n      (HFONT) ::SelectObject(deviceContextHandle, fontHandle); \n\n    ::SetTextColor(deviceContextHandle, textColor.ColorRef()); \n    ::SetBkColor(deviceContextHandle, backColor.ColorRef()); \n\n    RECT rectStruct = (RECT) areaRect; \n    ::DrawText(deviceContextHandle, text.c_str(), text.length(), \n               &rectStruct, DT_SINGLELINE |DT_CENTER |DT_VCENTER); \n\n    ::SelectObject(deviceContextHandle, oldFontHandle); \n    ::DeleteObject(fontHandle); \n  } \n}; \n\n```"]