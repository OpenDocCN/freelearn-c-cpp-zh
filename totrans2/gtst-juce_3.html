<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Essential Data Structures</h1></div></div></div><p>JUCE includes a range of important <a id="id145" class="indexterm"/>data structures<a id="id146" class="indexterm"/>, many of which could be seen as replacements for some of the standard library classes. This chapter introduces the essential classes for JUCE development. In this chapter we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding the numerical types</li><li class="listitem" style="list-style-type: disc">Specifying and manipulating strings of text using the <code class="literal">String</code> class</li><li class="listitem" style="list-style-type: disc">Measuring and displaying time</li><li class="listitem" style="list-style-type: disc">Specifying file paths in a cross-platform manner using the <code class="literal">File</code> class (including access to the user's home space, the <code class="literal">Desktop</code> and <code class="literal">Documents</code> locations)</li><li class="listitem" style="list-style-type: disc">Using dynamically allocated arrays: the <code class="literal">Array</code> class</li><li class="listitem" style="list-style-type: disc">Employing smart pointer classes</li></ul></div><p>By the end of this chapter, you will be able to create and manipulate data in a range of JUCE's essential classes.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Understanding the numerical types</h1></div></div></div><p>The word size<a id="id147" class="indexterm"/> of some the <a id="id148" class="indexterm"/>basic data types (<code class="literal">char</code>, <code class="literal">int</code>, <code class="literal">long</code>, and so on) varies across platforms, compilers, and CPU architectures. A good example is the type <code class="literal">long</code>. In Xcode on Mac OS X, <code class="literal">long</code> is 32 bits wide when compiling 32-bit code and 64 bits wide when compiling 64-bit code. In Microsoft Visual Studio on Windows, <code class="literal">long</code> is always 32 bits wide. (The same applies to the unsigned versions too.) JUCE defines a handful of primitive types to assist the writing of platform-independent code. Many of these have familiar names and may be the same names used in other libraries and frameworks in use by your code. These types are defined in the <code class="literal">juce</code> namespace; therefore, can be disambiguated using the <code class="literal">juce::</code> prefix if necessary. These primitive types are: <code class="literal">int8</code> (8-bit signed integer), <code class="literal">uint8</code> (8-bit unsigned integer), <code class="literal">int16</code> (16-bit signed integer), <code class="literal">uint16</code> (16-bit unsigned integer), <code class="literal">int32</code> (32-bit signed integer), <code class="literal">uint32</code> (32-bit unsigned integer), <code class="literal">int64</code> (64-bit signed integer), <code class="literal">uint64</code> (64-bit unsigned integer), <code class="literal">pointer_sized_int</code> (a signed integer that is the same word size as a pointer on the platform), <code class="literal">pointer_sized_uint</code> (an unsigned integer that is the same word size as a pointer on the platform), and <code class="literal">juce_wchar</code> (a 32-bit Unicode character type).</p><p>In many <a id="id149" class="indexterm"/>cases the built-in types are sufficient. For example, JUCE internally makes use of the <code class="literal">int</code> data type for a number of purposes, but the preceding types are available where the word size is critical. In addition to this, JUCE does not define special data types for <code class="literal">char</code>, <code class="literal">float</code>, or <code class="literal">double</code>. Both floating-point types are assumed to be compliant with IEEE 754, and the <code class="literal">float</code> data type is assumed to be 32 bits wide and the <code class="literal">double</code> data type 64 bits wide.</p><p>One final utility in this regard addresses the issue that writing 64-bit literals in code differs across compilers. The <code class="literal">literal64bit()</code> macro can be used to write such literals if needed:</p><div><pre class="programlisting">int64 big = literal64bit (0x1234567890);</pre></div><p>JUCE also declares some basic template types for defining certain geometry; the <code class="literal">Component</code> class uses these in particular. Some useful examples are <code class="literal">Point&lt;ValueType&gt;</code>, <code class="literal">Line&lt;ValueType&gt;</code>, and <code class="literal">Rectangle&lt;ValueType&gt;</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Specifying and manipulating text strings</h1></div></div></div><p>In JUCE,<a id="id150" class="indexterm"/> text is generally manipulated using the <code class="literal">String</code> class. In many <a id="id151" class="indexterm"/>ways, this class may be seen as an alternative to the C++ Standard Library <code class="literal">std::string</code> class. We have already used the <code class="literal">String</code> class for the basic operations in earlier chapters. For example, in <a class="link" href="ch02.html" title="Chapter 2. Building User Interfaces">Chapter 2</a>, <em>Building User Interfaces</em>, strings were used to set the text appearing on a <code class="literal">TextButton</code> object and used to store a dynamically changing string to display in response to mouse activity. Even though these examples were quite simple, they harnessed the power of the <code class="literal">String</code> class to make setting and manipulating the strings straightforward for the user.</p><p>The first way this is achieved is through storing strings using <strong>reference counted</strong> objects<a id="id152" class="indexterm"/>. That is to say, when a string is created, behind the scenes JUCE allocates some memory for the string, stores the string, and returns a <code class="literal">String</code> object that refers to this allocated memory in the background. Straight copies of this string (that is, without any modifications) are simply new <code class="literal">String</code> objects that refer to this same shared memory. This helps keep code efficient by allowing <code class="literal">String</code> objects to be passed by value between functions, without the potential overhead of copying large chunks of memory in the process.</p><p>To illustrate some of these features, we will use a console, rather than a Graphical User Interface (GUI), application in the first instance. Create a new Introjucer project named <code class="literal">Chapter03_01</code>; changing the <strong>Project Type</strong> to <strong>Console Application,</strong> and only selecting <strong>Create a Main.cpp file</strong> in<a id="id153" class="indexterm"/> the <strong>Files to Auto-Generate</strong> menu. Save the project and open it into your Integrated Development Environment (IDE).</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Posting log messages to the console</h2></div></div></div><p>To post messages<a id="id154" class="indexterm"/> to the console window, it is best to use JUCE's <code class="literal">Logger</code> class. Logging can be set to log a text file, but the default behavior is to send the logging messages to the console. A simple "Hello world!" project using a JUCE <code class="literal">String</code> object and the <code class="literal">Logger</code> class is shown as follows:</p><div><pre class="programlisting">#include "../JuceLibraryCode/JuceHeader.h"

int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  String message ("Hello world!");     
  log-&gt;writeToLog (message);

  return 0;
}</pre></div><p>The first line of code in the <code class="literal">main()</code> function<a id="id155" class="indexterm"/> stores a pointer to the current logger such that we can reuse it a number of times in later examples. The second line creates a JUCE <code class="literal">String</code> object from the literal C string <code class="literal">"Hello world!"</code>, and the third line sends this string to the logger using its <code class="literal">writeToLog()</code> function<a id="id156" class="indexterm"/>. Build and run this application, and the console window should look something like the following:</p><div><pre class="programlisting">
<strong>JUCE v2.1.2</strong>
<strong>Hello world!</strong>
</pre></div><p>JUCE reports the first line automatically; this may be different if you have a later version of JUCE from the GIT repository. This is followed by any logging messages from your application.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec21"/>String manipulation</h2></div></div></div><p>While this<a id="id157" class="indexterm"/> example is more complex than an equivalent using standard C strings, the power of JUCE's <code class="literal">String</code> class is delivered through the storage and manipulation of strings. For example, to concatenate strings, the <code class="literal">+</code> operator is overloaded for this purpose:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  String hello ("Hello");
  String space (" ");
  String world ("world!");
  String message = hello + space + world;
  
  log-&gt;writeToLog (message);
  
  return 0;
}</pre></div><p>Here, separate <a id="id158" class="indexterm"/>strings are constructed from literals for <code class="literal">"Hello"</code>, the space in between, and <code class="literal">"world!"</code>, then the final <code class="literal">message</code> string is constructed by concatenating all three. The stream operator <code class="literal">&lt;&lt;</code> may also be used for this purpose for a similar result:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  String hello ("Hello");
  String space (" ");
  String world ("world!");
  String message;
  
  message &lt;&lt; hello;
  message &lt;&lt; space;
  message &lt;&lt; world;
  
  log-&gt;writeToLog (message);
  
  return 0;
}</pre></div><p>The stream operator concatenates the right-hand side of the expression onto the left-hand side of the expression, in-place. In fact, using this simple case, the <code class="literal">&lt;&lt;</code> operator is equivalent to the <code class="literal">+=</code> operator when applied to strings. To illustrate this, replace all the instances of <code class="literal">&lt;&lt;</code> with <code class="literal">+=</code> in the code.</p><p>The main difference is that the <code class="literal">&lt;&lt;</code> operator may be more conveniently chained into longer expressions without additional parentheses (due to the difference between the precedence in C++ of the <code class="literal">&lt;&lt;</code> and <code class="literal">+=</code> operators). Therefore, the concatenation can be done all on one line, as with the <code class="literal">+</code> operator, if needed:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  String message;
  
  message &lt;&lt; "Hello" &lt;&lt; " " &lt;&lt; "world!";

  log-&gt;writeToLog (message);
  
  return 0;
}</pre></div><p>To achieve the same results with <code class="literal">+=</code> would require cumbersome parentheses for each part of the expression: <code class="literal">(((message += "Hello") += " ") += "world!")</code>.</p><p>The way the <a id="id159" class="indexterm"/>internal reference counting of strings works in JUCE means that you rarely need to be concerned about unintended side effects. For example, the following listing works as you might expect from reading the code:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  String string1 ("Hello");
  String string2 = string1;
  
  string1 &lt;&lt; " world!";

  log-&gt;writeToLog ("string1: " + string1);
  log-&gt;writeToLog ("string2: " + string2);
  
  return 0;
}</pre></div><p>This produces the following output:</p><div><pre class="programlisting">
<strong>string1: Hello world!</strong>
<strong>string2: Hello</strong>
</pre></div><p>Breaking this down into steps, we can see what happens:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">String string1 ("Hello");</code>: The <code class="literal">string1</code> variable is initialized with a literal string.</li><li class="listitem" style="list-style-type: disc"><code class="literal">String string2 = string1;</code>: The<code class="literal"> string2</code> variable is initialized with <code class="literal">string1</code>; they now refer to exactly the same data behind the scenes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">string1 &lt;&lt; " world!";</code>: The<code class="literal"> string1</code> variable has another literal string appended. At this point <code class="literal">string1</code> refers to a completely new block of memory containing the concatenated string.</li><li class="listitem" style="list-style-type: disc"><code class="literal">log-&gt;writeToLog ("string1: " + string1);</code>: This logs<code class="literal"> string1</code>, showing the concatenated string <code class="literal">Hello world!</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">log-&gt;writeToLog ("string2: " + string2);</code>: This logs <code class="literal">string2</code>; this shows that <code class="literal">string1</code> still refers to the initial string <code class="literal">Hello</code>.</li></ul></div><p>One really useful feature of the <code class="literal">String</code> class is its numerical conversion capabilities. Generally, <a id="id160" class="indexterm"/>you can pass a numerical type to a <code class="literal">String</code> constructor, and the resulting <code class="literal">String</code> object will represent that numerical value. For example:</p><div><pre class="programlisting">String intString (1234);    // string will be "1234"
String floatString (1.25f); // string will be "1.25"
String doubleString (2.5);  // string will be "2.5" </pre></div><p>Other useful features are conversions to uppercase and lowercase. Strings may also be compared using the <code class="literal">==</code> operator.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Measuring and displaying time</h1></div></div></div><p>The JUCE <code class="literal">Time</code> class<a id="id161" class="indexterm"/> provides a cross-platform way to specify, measure, and format date and time information in a human-readable fashion. Internally, the <a id="id162" class="indexterm"/>
<code class="literal">Time</code> class stores a value in milliseconds relative to midnight on 1st January 1970. To create a <code class="literal">Time</code> object that represents the current time, use <code class="literal">Time::getCurrentTime()</code>
<a id="id163" class="indexterm"/> like the following:</p><div><pre class="programlisting">Time now = Time::getCurrentTime();</pre></div><p>To bypass the creation of the <code class="literal">Time</code> object, you can access the millisecond counter as a 64-bit value directly:</p><div><pre class="programlisting">int64 now = Time::currentTimeMillis();</pre></div><p>The <code class="literal">Time</code> class also provides access to a 32-bit millisecond counter that measures time since system startup:</p><div><pre class="programlisting">uint32 now = Time::getMillisecondCounter();</pre></div><p>The important point to note about<a id="id164" class="indexterm"/>
<code class="literal">Time::getMillisecondCounter()</code> is that it is independent of the system time, and would be unaffected by changes to the system time either by the user changing the time, changes due to national daylight saving, and so on.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Displaying and formatting time information</h2></div></div></div><p>Displaying <a id="id165" class="indexterm"/>time information is straightforward; the following<a id="id166" class="indexterm"/> example gets the current time from the operating<a id="id167" class="indexterm"/> system, <a id="id168" class="indexterm"/>formats it as a string, and sends it to the console output:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();

  Time time (Time::getCurrentTime());
  
  bool includeDate = true;
  bool includeTime = true;
  bool includeSeconds = true;
  bool use24HourClock = true;
  
  String timeStr (time.toString (includeDate, includeTime,
                                 includeSeconds, use24HourClock));
  
  log-&gt;writeToLog ("the time is: " + timeStr);
  
  return 0;
}</pre></div><p>This <a id="id169" class="indexterm"/>illustrates the <a id="id170" class="indexterm"/>four option flags available to the<a id="id171" class="indexterm"/>
<code class="literal">Time::toString()</code> function. The output on the console will be something like:</p><div><pre class="programlisting">
<strong>the time is: 7 Jul 2013 15:05:55</strong>
</pre></div><p>For more comprehensive options, the <code class="literal">Time::formatted()</code> function<a id="id172" class="indexterm"/> allows the user to specify a format using a special format string (using a system equivalent to the standard C <code class="literal">strftime()</code> function). Alternatively, you can obtain the various parts of the date and time information (day, month, hour, minute, time zone, and so on), and combine them into a string yourself. For example, the same preceding format can be achieved as follows:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  
  Time time (Time::getCurrentTime());
    
  String timeStr;
  
  bool threeLetterMonthName = true;
  
  timeStr &lt;&lt; time.getDayOfMonth() &lt;&lt; " ";
  timeStr &lt;&lt; time.getMonthName (threeLetterMonthName) &lt;&lt; " ";
  timeStr &lt;&lt; time.getYear() &lt;&lt; " ";
  timeStr &lt;&lt; time.getHours() &lt;&lt; ":";
  timeStr &lt;&lt; time.getMinutes() &lt;&lt; ":";
  timeStr &lt;&lt; time.getSeconds();
  
  log-&gt;writeToLog ("the time is: " + timeStr);
  
  return 0;
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Manipulating time data</h2></div></div></div><p>
<code class="literal">Time</code> objects<a id="id173" class="indexterm"/> may also be manipulated (with the help from the <code class="literal">RelativeTime</code> class) and compared with other <code class="literal">Time</code> objects. The following example shows the creation of three time values, based on the current time, using a one-hour offset:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  
  Time time (Time::getCurrentTime());
  RelativeTime oneHour (RelativeTime::hours (1));
  
  Time oneHourAgo (time - oneHour);
  Time inOneHour (time + oneHour);
  Time inTwoHours (inOneHour + oneHour);
  
  log-&gt;writeToLog ("the time is:" +
                   time.toString (true, true, true, true));
  log-&gt;writeToLog ("one hour ago was:" +
                   oneHourAgo.toString (true, true, true, true));
  log-&gt;writeToLog ("in one hour it will be:" +
                   inOneHour.toString (true, true, true, true));
  log-&gt;writeToLog ("in two hours it will be:" +
                   inTwoHours.toString (true, true, true, true));
  
  return 0;
}</pre></div><p>The output of this should be something like this:</p><div><pre class="programlisting">
<strong>the time is:             7 Jul 2013 15:42:27</strong>
<strong>one hour ago was:        7 Jul 2013 14:42:27</strong>
<strong>in one hour it will be:  7 Jul 2013 16:42:27</strong>
<strong>in two hours it will be: 7 Jul 2013 17:42:27</strong>
</pre></div><p>To compare two <code class="literal">Time</code> objects, the standard comparison operators may be used. For example, you could wait for a specific time, like the following:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  
  Time now (Time::getCurrentTime());
  Time trigger (now + RelativeTime (5.0));
  
  log-&gt;writeToLog ("the time is now:      " +
                   now.toString (true, true, true, true));
  
  while (Time::getCurrentTime() &lt; trigger) {
    Thread::sleep (10);
    log-&gt;writeToLog ("waiting...");
  }
  
  log-&gt;writeToLog ("the time has reached: " +
                   trigger.toString (true, true, true, true));

  return 0;
}</pre></div><p>Two things to <a id="id174" class="indexterm"/>note here are that:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The value passed to the <code class="literal">RelativeTime</code> constructor is in seconds (all the other time values need to use one of the static functions as shown earlier for hours, minutes, and so on).</li><li class="listitem" style="list-style-type: disc">The call to <code class="literal">Thread::sleep()</code> uses values in milliseconds and this sleeps the calling thread. The <code class="literal">Thread</code> class will be examined further in <a class="link" href="ch05.html" title="Chapter 5. Helpful Utilities">Chapter 5</a>, <em>Helpful Utilities</em>.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Measuring time</h2></div></div></div><p>The time<a id="id175" class="indexterm"/> values returned from the <code class="literal">Time::getCurrentTime()</code> function<a id="id176" class="indexterm"/> should be accurate for most purposes, but as pointed out earlier, the <em>current time</em> could be changed by the user modifying the system time. An equivalent to the preceding example, using <code class="literal">Time::getMillisecondCounter()</code> that<a id="id177" class="indexterm"/> is not susceptible to such changes, is shown as follows:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  
  uint32 now = Time::getMillisecondCounter();
  uint32 trigger = now + 5000;
  
  log-&gt;writeToLog ("the time is now: " +
                   String (now) + "ms");
  
  while (Time::getMillisecondCounter() &lt; trigger) {
    Thread::sleep (10);
    log-&gt;writeToLog ("waiting...");
  }
  
  log-&gt;writeToLog ("the time has reached: " +
                   String (trigger) + "ms");

  return 0;
}</pre></div><p>Both <a id="id178" class="indexterm"/>the <code class="literal">Time::getCurrentTime()</code> and <code class="literal">Time::getMillisecondCounter()</code> functions have a similar accuracy, which is within a few milliseconds on most platforms. However, the <code class="literal">Time</code> class also provides access to a higher resolution counter that returns values as a double precision (64-bit) floating-point value. This function is <code class="literal">Time::getMillisecondCounterHiRes()</code>, and is also relative to the system start-up as is the value returned from the <code class="literal">Time::getMillisecondCounter()</code> function. One application of this is to measure the time that certain pieces of code have taken to execute, as shown in the following example:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  
  double start = Time::getMillisecondCounterHiRes();
  
  log-&gt;writeToLog ("the time is now: " +
                   String (start) + "ms");
  
  float value = 0.f;
  const int N = 10000;
  
  for (int i = 0; i &lt; N; ++i)
    value += 0.1f;
  
  double duration = Time::getMillisecondCounterHiRes() - start;
  
  log-&gt;writeToLog ("the time taken to perform " + String (N) +
                   " additions was: " + String (duration) + "ms");
  
  return 0;
}</pre></div><p>This records the current time by polling the higher resolution counter, performing a large number of floating point additions, and polling the higher resolution counter again to determine the duration between these two points in time. The output should be something like this:</p><div><pre class="programlisting">
<strong>the time is now: 267150354ms</strong>
<strong>the time taken to perform 10000 additions was: 0.0649539828ms</strong>
</pre></div><p>Of course, the results here are dependent on the optimization settings in the compiler and the runtime system.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Specifying file paths</h2></div></div></div><p>JUCE provides a<a id="id179" class="indexterm"/> relatively cross-platform way of specifying and manipulating file paths using the <code class="literal">File</code> class. In particular, this provides a means of <a id="id180" class="indexterm"/>accessing various special directories on the user's system, such as the <code class="literal">Desktop</code> directory, their user <code class="literal">Documents</code> directory, application preferences directories, and so on. The <code class="literal">File</code> class also provides functions for accessing information about a file (for example, creation date, modification date, file size) and basic mechanisms for reading and writing file contents (although other techniques may be more appropriate for large or complex files). In the following example, a string is written to a text file on disk (using the <code class="literal">File::replaceWithText()</code> function), then read back into a second string (using the <code class="literal">File::loadFileAsString()</code> function), and displayed in the console:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  
  String text ("The quick brown fox jumps over the lazy dog.");
  File file ("./chapter03_01_test.txt");
  file.replaceWithText (text);
  String fileText = file.loadFileAsString();
  
  log-&gt;writeToLog ("fileText: " + fileText);

  return 0;
}</pre></div><p>The <code class="literal">File</code> object in this case is initialized with the path <code class="literal">./chapter03_01_test.txt</code>. It should be noted that this file may not exist at this point, and on first run it will not exist until the call to the <code class="literal">File::replaceWithText()</code> function (and on subsequent runs this file will exist, but will be overwritten at that point). The <code class="literal">./</code> character sequence at the front of this path is a common idiom specifying that the remainder of the path should be relative to the current directory (or current working directory). In this simple case, the current working directory is likely to be the directory where the executable file is located. The following screenshot shows this location relative to the Introjucer project on the Mac platform:</p><div><img src="img/3316_03_01.jpg" alt="Specifying file paths"/></div><p>This is <a id="id181" class="indexterm"/>not a reliable method; however, it will work if the working directory is specifically where you want to save a file.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Accessing various special directory locations</h2></div></div></div><p>It is more<a id="id182" class="indexterm"/> precise to use one of the <code class="literal">File</code> class's special locations, as shown as follows:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  
  String text ("The quick brown fox jumps over the lazy dog.");
  File exe (File::getSpecialLocation(
            File::currentExecutableFile));
  File exeDir (exe.getParentDirectory());
  File file (exeDir.getChildFile ("chapter03_01_test.txt"));
  file.replaceWithText (text);
  String fileText = file.loadFileAsString();
  
  log-&gt;writeToLog ("fileText: " + fileText);
  
  return 0;
}</pre></div><p>The steps for accessing the file location in this directory are split across several lines for clarity in this code. Here, you can see the code to obtain the location of the current executable file, then its parent directory, and then create a file reference for our text file that is relative to this directory. Much of this code may be compacted on a single logical line using a chain of function calls:</p><div><pre class="programlisting">...
  File file (File::getSpecialLocation(
             File::currentExecutableFile)
             .getParentDirectory()
             .getChildFile ("chapter03_01_test.txt"));
...</pre></div><p>Due to the length of some of the identifiers in this code and the page width in this book, this code still occupies four physical lines of code. Nevertheless, this illustrates how you can employ this function calls to suit your needs and preferences for code layout.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Obtaining various information about files</h2></div></div></div><p>The <code class="literal">File</code> class <a id="id183" class="indexterm"/>can provide useful information about files. One important test is whether a file exists; this can be determined using <code class="literal">File::exists()</code>. If a file does exist, then more information may be obtained, such as its creation date, modification date, and size. These are illustrated in the following example:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();

  File file (File::getSpecialLocation(File::currentExecutableFile)
             .getParentDirectory()
             .getChildFile("chapter03_01_test.txt"));
  
  bool fileExists = file.exists();
  
  if (!fileExists) {
    log-&gt;writeToLog ("file " +
                     file.getFileName() +
                     " does not exist");
    return -1;
  }
  
  Time creationTime = file.getCreationTime();
  Time modTime = file.getLastModificationTime();
  int64 size = file.getSize();
  
  log-&gt;writeToLog ("file " +
                   file.getFileName() + " info:");
  log-&gt;writeToLog ("created: " +
                   creationTime.toString(true, true, true, true));
  log-&gt;writeToLog ("modified:" +
                   modTime.toString(true, true, true, true));
  log-&gt;writeToLog ("size:" +
                   String(size) + " bytes");
  
  return 0;
}</pre></div><p>Assuming you ran all of the preceding examples, the file should exist on your system and the information will be reported in the console something like as follows:</p><div><pre class="programlisting">
<strong>file chapter03_01_test.txt info:</strong>
<strong>created: 8 Jul 2013 17:08:25</strong>
<strong>modified: 8 Jul 2013 17:08:25</strong>
<strong>size: 44 bytes</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Other special locations</h2></div></div></div><p>In <a id="id184" class="indexterm"/>addition to <code class="literal">File::currentExecutableFile</code>, other special locations known to JUCE are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">File::userHomeDirectory</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">File::userDocumentsDirectory</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">File::userDesktopDirectory</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">File::userApplicationDataDirectory</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">File::commonApplicationDataDirectory</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">File::tempDirectory</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">File::currentExecutableFile</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">File::currentApplicationFile</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">File::invokedExecutableFile</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">File::hostApplicationPath</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">File::globalApplicationsDirectory</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">File::userMusicDirectory</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">File::userMoviesDirectory</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">File::userPicturesDirectory</code></li></ul></div><p>Each of these names is fairly self-explanatory. In some cases, these special locations are not applicable on some platforms. For example, there is no such thing as the <code class="literal">Desktop</code> on the iOS platform.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Navigating directory structures</h2></div></div></div><p>Ultimately, a <code class="literal">File</code> object <a id="id185" class="indexterm"/>resolves to an absolute path on the user's system. This can be obtained using the <code class="literal">File::getFullPathName()</code> function if needed:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  
  File file (File::getSpecialLocation(
              File::currentExecutableFile)
                .getParentDirectory()
                .getChildFile ("chapter03_01_test.txt"));
  log-&gt;writeToLog ("file path: " + file.getFullPathName());
  
  return 0;
}</pre></div><p>In addition to this, the relative path passed to <code class="literal">File::getChildFile()</code> can contain one or more references<a id="id186" class="indexterm"/> to parent directories using the double period  notation (that is, the "<code class="literal">..</code>" character sequence). In this next example, we create a simple directory structure as shown in the screenshot following this code listing:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  
  File root (File::getSpecialLocation (File::userDesktopDirectory)
             .getChildFile ("Chapter03_01_tests"));
  File dir1 (root.getChildFile ("1"));
  File dir2 (root.getChildFile ("2"));
  File dir1a (dir1.getChildFile ("a"));
  File dir2b (dir2.getChildFile ("b"));
  
  Result result (Result::ok());
  
  result = dir1a.createDirectory();
  
  if (!result.wasOk()) {
    log-&gt;writeToLog ("Creating dir 1/a failed");
    return -1;
  }
  
  result = dir2b.createDirectory();
  
  if (!result.wasOk()) {
    log-&gt;writeToLog ("Creating dir 2/b failed");
    return -1;
  }
  
  File rel = dir1a.getChildFile ("../../2/b");
  
  log-&gt;writeToLog ("root: " + root.getFullPathName());
  log-&gt;writeToLog ("dir1: " + dir1.getRelativePathFrom (root));
  log-&gt;writeToLog ("dir2: " + dir2.getRelativePathFrom (root));
  log-&gt;writeToLog ("dir1a: " + dir1a.getRelativePathFrom (root));
  log-&gt;writeToLog ("dir2b: " + dir2b.getRelativePathFrom (root));
  log-&gt;writeToLog ("rel: " + rel.getRelativePathFrom (root));

  return 0;
}</pre></div><div><img src="img/3316_03_02.jpg" alt="Navigating directory structures"/></div><p>This creates<a id="id187" class="indexterm"/> five directories in total, using only two calls to the <code class="literal">File::createDirectory()</code>function. Since this is dependent on the user's permissions to create files in this directory, the function returns a <code class="literal">Result</code> object. This contains a state to indicate if the function succeeded or not (which we check with the <code class="literal">Result::wasOk()</code> function), and more information can be gained about any errors if needed. Each call to the <code class="literal">File::createDirectory()</code> function ensures that it creates any intermediate directories if required. Therefore, on the first call, it creates the root directory, directory <code class="literal">1</code>, and directory <code class="literal">1/a</code>. On the second call, the root already exists, so it needs only to create directories <code class="literal">2</code> and <code class="literal">2/a</code>.</p><p>The console output for this should be something like this:</p><div><pre class="programlisting">
<strong>root: /Users/martinrobinson/Desktop/Chapter03_01_tests</strong>
<strong>dir1: 1</strong>
<strong>dir2: 2</strong>
<strong>dir1a: 1/a</strong>
<strong>dir2b: 2/b</strong>
<strong>rel: 2/b</strong>
</pre></div><p>Of course, the first line will be different, depending on your system, but the remaining five lines should be the same. These paths are displayed relative to the root of the directory structure we have created using the <code class="literal">File::getRelativePathFrom()</code> function. Notice that the final line shows that the <code class="literal">rel</code> object refers to the same directory as the <code class="literal">dir2b</code> object, but we created this <code class="literal">rel</code> object relative to the <code class="literal">dir1a</code> object by using the function call <code class="literal">dir1a.getChildFile("../../2/b")</code>. That is, we navigate two levels up the directory structure then access the directories below.</p><p>The <code class="literal">File</code> class also includes features to check for a file's existence, to move and copy files within the filesystem (including moving the file to the <strong>Trash</strong> or <strong>Recycle Bin</strong>), and to create legal filenames on particular platforms (for example, avoiding colon and slash characters).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Using dynamically allocated arrays</h1></div></div></div><p>While most instances of JUCE objects can be stored in regular C++ arrays, JUCE offers a handful of arrays that are more powerful, somewhat comparable to the C++ Standard Library classes, such as <code class="literal">std::vector</code>. The JUCE <code class="literal">Array</code> class offers many features; these arrays can be:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Dynamically sized; items can be added, removed, and inserted at any index</li><li class="listitem" style="list-style-type: disc">Sorted using custom comparators</li><li class="listitem" style="list-style-type: disc">Searched for particular content</li></ul></div><p>The <a id="id188" class="indexterm"/>
<code class="literal">Array</code> class is <a id="id189" class="indexterm"/>a template class; its main template argument, <code class="literal">ElementType</code>, must meet certain criteria. The <code class="literal">Array</code> class moves its contents around by copying memory during resizing and inserting elements, this could cause problems with certain kinds of objects. The class passed as the <code class="literal">ElementType</code> template argument must also have both a copy constructor and an assignment operator. The <code class="literal">Array</code> class, in particular, works well with primitive types and some commonly used JUCE classes, for example, the <code class="literal">File</code> and <code class="literal">Time</code> classes. In the following example, we create an array of integers, add five items to it, and iterate over the array, sending the contents to the console:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  
  Array&lt;int&gt; array;
  
  for (int i = 0; i &lt; 5; ++i)
    array.add (i * 1000);
  
  for (int i = 0; i &lt; array.size(); ++i) {
    int value = array[i];
    log-&gt;writeToLog ("array[" + String (i) + "]= " + String (value));
  }
  
  return 0;
}</pre></div><p>This should produce the output:</p><div><pre class="programlisting">
<strong>array[0]= 0</strong>
<strong>array[1]= 1000</strong>
<strong>array[2]= 2000</strong>
<strong>array[3]= 3000</strong>
<strong>array[4]= 4000</strong>
</pre></div><p>Notice that the JUCE <code class="literal">Array</code> class supports the C++ indexing subscript operator <code class="literal">[]</code>. This will always return a valid value even if the array index is out of bounds (unlike a built-in array). There is a small <a id="id190" class="indexterm"/>overhead involved in making this check; therefore, you can avoid the bounds checking by using the <code class="literal">Array::getUnchecked()</code> function, but you must be certain that the index is within bounds, otherwise your application may crash. The second <code class="literal">for()</code> loop can be rewritten as follows to use this alternative function, because we have already checked that out indices will be in-range:</p><div><pre class="programlisting">...
  for (int i = 0; i &lt; array.size(); ++i) {
<strong>    int value = array.getUnchecked (i);</strong>
    log-&gt;writeToLog("array[" + String (i) + "] = " + 
                    String (value));
  }
...</pre></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Finding the files in a directory</h2></div></div></div><p>The <a id="id191" class="indexterm"/>JUCE library uses the <code class="literal">Array</code> objects for many purposes. For example, the <code class="literal">File</code> class can fill an array of <code class="literal">File</code> objects with a list of child files and directories it contains using the <code class="literal">File::findChildFiles()</code> function<a id="id192" class="indexterm"/>. The following example should post a list of files and directories in your user <code class="literal">Documents</code> directory to the console:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();

  File file =
    File::getSpecialLocation (File::userDocumentsDirectory);
  
  Array&lt;File&gt; childFiles;
  
  bool searchRecursively = false;
  file.findChildFiles (childFiles,
                       File::findFilesAndDirectories,
                       searchRecursively);
  
  for (int i = 0; i &lt; childFiles.size(); ++i)
    log-&gt;writeToLog (childFiles[i].getFullPathName());
  
  return 0;
}</pre></div><p>Here, the <code class="literal">File::findChildFiles()</code> function is passed the array of <code class="literal">File</code> objects, to which it should add the result of the search. It is<a id="id193" class="indexterm"/> also told to find both files and directories using the value <code class="literal">File::findFilesAndDirectories</code> (other options are the <code class="literal">File::findDirectories</code> and <code class="literal">File::findFiles</code> values). Finally, it is told not to search recursively.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Tokenizing strings</h2></div></div></div><p>Although it<a id="id194" class="indexterm"/> is possible to use <code class="literal">Array&lt;String&gt;</code> to hold an array of JUCE <code class="literal">String</code> objects, there is a dedicated <code class="literal">StringArray</code> class to offers additional functionality when applying array operations to string data. For example, a string can be <strong>tokenized</strong> (that is, broken up into smaller strings based on whitespace in the original string) using the <code class="literal">String::addTokens()</code> function, or divided into strings representing lines of text (based on newline character sequences found within the original string) using the <code class="literal">String::addLines()</code> function. The following example tokenizes a string, then iterates over the resulting <code class="literal">StringArray</code> object, posting its contents to the console:</p><div><pre class="programlisting">int main (int argc, char* argv[])
{
  Logger *log = Logger::getCurrentLogger();
  
  StringArray strings;
  bool preserveQuoted = true;
  strings.addTokens("one two three four five six",
                     preserveQuoted);
  
  for (int i = 0; i &lt; strings.size(); ++i) {
    log-&gt;writeToLog ("strings[" + String (i) + "]=" +
                     strings[i]);
  }
  
  return 0;
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Arrays of components</h2></div></div></div><p>User interfaces<a id="id195" class="indexterm"/> comprising banks of similar controls, such as buttons and sliders, can be managed effectively using arrays. However, the JUCE <code class="literal">Component</code> class and its subclasses do not meet the criteria for storage as an object (that is, by value) in a JUCE <code class="literal">Array</code> object. These must be stored as arrays of pointers to these objects instead. To illustrate this, we need a new Introjucer project with a basic window as used throughout <a class="link" href="ch02.html" title="Chapter 2. Building User Interfaces">Chapter 2</a>, <em>Building User Interfaces</em>. Create a new Introjucer project, such as this, name it <code class="literal">Chapter03_02</code>, and open it into your IDE. To the end of the <code class="literal">MainWindow</code> constructor in <code class="literal">Main.cpp</code>, add the following line:</p><div><pre class="programlisting">setResizable (true, true);</pre></div><p>In the <code class="literal">MainComponent.h</code> file change the code to:</p><div><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent : public Component
{
public:
  MainContentComponent();
  ~MainContentComponent();
  
  void resized();
  
private:
  Array&lt;TextButton*&gt; buttons;
};

#endif</pre></div><p>Notice <a id="id196" class="indexterm"/>that the <code class="literal">Array</code> object here is an array of pointers to <code class="literal">TextButton</code> objects (that is, <code class="literal">TextButton*)</code>. In the <code class="literal">MainComponent.cpp</code> file change the code to:</p><div><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
{
  for (int i = 0; i &lt; 10; ++i)
  {
    String buttonName;
    buttonName &lt;&lt; "Button " &lt;&lt; String (i);
    TextButton* button = new TextButton (buttonName);
    buttons.add (button);
    addAndMakeVisible (button);
  }
  
  setSize (500, 400);
}

MainContentComponent::~MainContentComponent()
{
}

void MainContentComponent::resized()
{
  Rectangle&lt;int&gt; rect (10, 10, getWidth() - 20, getHeight() - 20);
  
  int buttonHeight = rect.getHeight() / buttons.size();
  
  for (int i = 0; i &lt; buttons.size(); ++i) {
    buttons[i]-&gt;setBounds (rect.getX(),
                           i * buttonHeight + rect.getY(),
                           rect.getWidth(),
                           buttonHeight);
  }
}</pre></div><p>Here, <a id="id197" class="indexterm"/>we create 10 buttons and using a <code class="literal">for()</code> loop, adding these buttons to an array, and basing the name of the button on the loop counter. The buttons are allocated using the <code class="literal">new</code> operator (rather than the static allocation used in <a class="link" href="ch02.html" title="Chapter 2. Building User Interfaces">Chapter 2</a>, <em>Building User Interfaces</em>), and it is these pointers that are stored in the array. (Notice also, that there is no need for the <code class="literal">&amp;</code> operator in the function call to <code class="literal">Component::addAndMakeVisible()</code> because the value is already a pointer.) In the <code class="literal">resized()</code> function, we use a <code class="literal">Rectangle&lt;int&gt;</code> object to create a rectangle that is inset from the <code class="literal">MainContentComponent</code> object's bounds rectangle by 10 pixels all the way around. The buttons are positioned within this smaller rectangle. The height for each button is calculated by dividing the height of our rectangle by the number of buttons in the button array. The <code class="literal">for()</code> loop then positions each button, based on its index within the array. Build and run the application; its window should present 10 buttons arranged in a single column.</p><p>There is one major flaw with the preceding code. The buttons allocated with the <code class="literal">new</code> operator are never deleted. The code should run fine, although you will get an assertion failure when the application is exited. The message into the console will be something like:</p><div><pre class="programlisting">
<strong>*** Leaked objects detected: 10 instance(s) of class TextButton</strong>
<strong>JUCE Assertion failure in juce_LeakedObjectDetector.h:95</strong>
</pre></div><p>To solve this, we could delete the buttons in the <code class="literal">MainComponent</code> destructor like so:</p><div><pre class="programlisting">MainContentComponent::~MainContentComponent()
{
  for (int i = 0; i &lt; buttons.size(); ++i)
    delete buttons[i];
}</pre></div><p>However, it is very easy to forget to do this kind of operation when writing complex code.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Using the OwnedArray class</h2></div></div></div><p>JUCE <a id="id198" class="indexterm"/>provides a useful alternative to the <code class="literal">Array</code> class that is <a id="id199" class="indexterm"/>dedicated to pointer types: the <code class="literal">OwnedArray</code> class. The <code class="literal">OwnedArray</code> class always stores pointers, therefore should not include the <code class="literal">*</code> character in the template parameter. Once a pointer is added to an <code class="literal">OwnedArray</code> object, it takes ownership of the pointer and will take care of deleting it when necessary (for example, when the <code class="literal">OwnedArray</code> object itself is destroyed). Change the declaration in the <code class="literal">MainComponent.h</code> file, as highlighted in the following:</p><div><pre class="programlisting">...
private:
<strong>  OwnedArray&lt;TextButton&gt; buttons;</strong>
};</pre></div><p>You should also remove the code from the destructor in the <code class="literal">MainComponent.cpp</code> file, because deleting objects more than once is equally problematic:</p><div><pre class="programlisting">...
MainContentComponent::~MainContentComponent()
{
}
... </pre></div><p>Build and run the application, noticing that the application will now exit without problems.</p><p>This technique can be extended to using broadcasters and listeners. Create a new GUI-based Introjucer project as before, and name it <code class="literal">Chapter03_03</code>. Change the <code class="literal">MainComponent.h</code> file to:</p><div><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent :  public Component,
                              public Button::Listener
{
public:
MainContentComponent();
    
void resized();
void buttonClicked (Button* button);
    
private:
OwnedArray&lt;Button&gt; buttons;
Label label;
};

#endif</pre></div><p>This time we<a id="id200" class="indexterm"/> use an <code class="literal">OwnedArray&lt;Button&gt;</code> object rather than an <code class="literal">OwnedArray&lt;TextButton&gt;</code> object. This simply avoids the need to typecast our button pointers to different types when searching for the pointers in the array, as we do in the following <a id="id201" class="indexterm"/>code. Also, notice here that we added a <code class="literal">Label</code> object to our component, made our component a button listener, and that we do not need a destructor. Change the <code class="literal">MainComponent.cpp</code> file to:</p><div><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
{
  for (int i = 0; i &lt; 10; ++i) {
    String buttonName;
    buttonName &lt;&lt; "Button " &lt;&lt; String (i);
    TextButton* button = new TextButton (buttonName);
    button-&gt;addListener (this);
    buttons.add (button);
    addAndMakeVisible (button);
  }
  
  addAndMakeVisible (&amp;label);
  label.setJustificationType (Justification::centred);
  label.setText ("no buttons clicked", dontSendNotification);
  
  setSize (500, 400);
}

void MainContentComponent::resized()
{
  Rectangle&lt;int&gt; rect (10, 10, 
                       getWidth() / 2 - 20, getHeight() - 20);

  int buttonHeight = rect.getHeight() / buttons.size();

  for (int i = 0; i &lt; buttons.size(); ++i) {
    buttons[i]-&gt;setBounds (rect.getX(),
                           i * buttonHeight + rect.getY(),
                           rect.getWidth(),
                           buttonHeight);
  }

  label.setBounds (rect.getRight(),
                   rect.getY(),
                   getWidth() - rect.getWidth() - 10,
                   20);
}

void MainContentComponent::buttonClicked (Button* button)
{
  String labelText;
  nt buttonIndex = buttons.indexOf (button);
  labelText &lt;&lt; "Button clicked: " &lt;&lt; String (buttonIndex);
  label.setText (labelText, dontSendNotification);
}</pre></div><p>Here, we add the <a id="id202" class="indexterm"/>label in the constructor, reduce the <a id="id203" class="indexterm"/>width of the bank of buttons to occupy only the left half of the component, and position the label at the top in the right-half. In the button listener callback, we can obtain the index of the button using the <code class="literal">OwnedArray::indexOf()</code> function to search for the pointer (incidentally, the <code class="literal">Array</code> class also has an <code class="literal">indexOf()</code> function for searching the items). Build and run the application and notice that our label reports which button was clicked. Of course, the elegant thing about this code is that we need only change the value in the <code class="literal">for()</code> loop when the buttons are created in our constructor to change the number of buttons that are created; everything else works automatically.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Other banks of controls</h2></div></div></div><p>This <a id="id204" class="indexterm"/>approach may be applied to other banks of controls. The following example creates a bank of sliders and labels, keeping each corresponding component updated with the appropriate value. Create a new GUI-based Introjucer project, and name it <code class="literal">Chapter03_04</code>. Change the <code class="literal">MainComponent.h</code> file to:</p><div><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent :  public Component,
                              public Slider::Listener,
                              public Label::Listener
{
public:
  MainContentComponent();
  
  void resized();
  void sliderValueChanged (Slider* slider);
  void labelTextChanged (Label* label);
  
private:
  OwnedArray&lt;Slider&gt; sliders;
  OwnedArray&lt;Label&gt; labels;
};

#endif</pre></div><p>Here, we have arrays of sliders and labels and our component is both a label listener and a slider listener. <a id="id205" class="indexterm"/>Now, update the <code class="literal">MainComponent.cpp</code> file to contain the include directive, the constructor, and the <code class="literal">resized()</code> function:</p><div><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
{
  for (int i = 0; i &lt; 10; ++i) {
    String indexString (i);
    String sliderName ("slider" + indexString);
    Slider* slider = new Slider (sliderName);
    slider-&gt;setTextBoxStyle (Slider::NoTextBox, false, 0, 0);
    slider-&gt;addListener (this);
    sliders.add (slider);
    addAndMakeVisible (slider);
    
    String labelName ("label" + indexString);
    Label* label = new Label (labelName,
                              String (slider-&gt;getValue()));
    label-&gt;setEditable (true);
    label-&gt;addListener (this);
    labels.add (label);
    addAndMakeVisible (label);
  }
  
  setSize (500, 400);
}

void MainContentComponent::resized()
{
  Rectangle&lt;int&gt; slidersRect (10, 10,
                              getWidth() / 2 - 20, 
                              getHeight() - 20);
  Rectangle&lt;int&gt; labelsRect (slidersRect.getRight(), 10,
                             getWidth() / 2 - 20, 
                             getHeight() - 20);
  
  int cellHeight = slidersRect.getHeight() / sliders.size();
  
  for (int i = 0; i &lt; sliders.size(); ++i) {
    sliders[i]-&gt;setBounds (slidersRect.getX(),
                           i * cellHeight + slidersRect.getY(),
                           slidersRect.getWidth(),
                           cellHeight);
    labels[i]-&gt;setBounds (labelsRect.getX(),
                          i * cellHeight + labelsRect.getY(),
                          labelsRect.getWidth(),
                          cellHeight);
  }
}</pre></div><p>Here, we use a <code class="literal">for()</code> loop to create the components and add them to the corresponding arrays. In the <code class="literal">resized()</code> function, we create two helper rectangles, one for the bank of sliders and one for the bank of labels. These are positioned to occupy the left half and right half of the main component respectively.</p><p>In the listener <a id="id206" class="indexterm"/>callback functions, the index of the broadcasting component is looked up in its array, and this index is used to set the value of the other corresponding component. Add these listener callback functions to the <code class="literal">MainComponent.cpp</code> file:</p><div><pre class="programlisting">void MainContentComponent::sliderValueChanged (Slider* slider)
{
  int index = sliders.indexOf (slider);
  labels[index]-&gt;setText (String (slider-&gt;getValue()), 
                          sendNotification);
}

void MainContentComponent::labelTextChanged (Label* label)
{
  int index = labels.indexOf (label);
  sliders[index]-&gt;setValue (label-&gt;getText().getDoubleValue());
}</pre></div><p>Here, we use the <code class="literal">String</code> class to perform the numerical conversions. After moving some of the sliders, the application window should look similar to the following screenshot:</p><div><img src="img/3316_03_03.jpg" alt="Other banks of controls"/></div><p>Hopefully, <a id="id207" class="indexterm"/>these examples illustrate the power of combining JUCE array classes with other JUCE classes to write elegant, readable, and powerful code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Employing smart pointer classes</h1></div></div></div><p>The <code class="literal">OwnedArray</code> class may be considered a manager of smart pointers, in the sense that it manages the lifetime of the object to which it points. JUCE includes a range of other smart pointer types<a id="id208" class="indexterm"/> to help solve a number of common issues when writing code using pointers. In particular, these help avoid mismanagement of memory and other resources.</p><p>Perhaps the simplest smart pointer is implemented by the <code class="literal">ScopedPointer</code> class. This manages a single pointer and deletes the object to which it points when no longer needed. This may happen in two ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When the <code class="literal">ScopedPointer</code> object itself is destroyed</li><li class="listitem" style="list-style-type: disc">When a new pointer is assigned to the <code class="literal">ScopedPointer</code> object</li></ul></div><p>One use of the <code class="literal">ScopedPointer</code> class is as an alternative means of storing a <code class="literal">Component</code> objects (or one of its subclasses). In fact, adding subcomponents in the Introjucer applications graphical editor adds the components to the code as <code class="literal">ScopedPointer</code> objects in a similar way to the example that follows. Create a new Introjucer project named <code class="literal">Chapter03_05</code>. The following example achieves an identical result to the <code class="literal">Chapter02_02</code> project, but uses <code class="literal">ScopedPointer</code> objects to manage the components rather than statically allocating them. Change the <code class="literal">MainComponent.h</code> file to:</p><div><pre class="programlisting">#ifndef __MAINCOMPONENT_H__
#define __MAINCOMPONENT_H__

#include "../JuceLibraryCode/JuceHeader.h"

class MainContentComponent :  public Component,
                              public Button::Listener,
                              public Slider::Listener
{
public:
  MainContentComponent();
  void resized();

  void buttonClicked (Button* button);
  void sliderValueChanged (Slider* slider);

private:
<strong>  ScopedPointer&lt;Button&gt; button1;</strong>
<strong>  ScopedPointer&lt;Slider&gt; slider1;</strong>
<strong>  ScopedPointer&lt;Label&gt; label1;</strong>
};

#endif</pre></div><p>Notice<a id="id209" class="indexterm"/> that we use a <code class="literal">ScopedPointer&lt;Button&gt;</code> object rather than a <code class="literal">ScopedPointer&lt;TextButton&gt;</code> object for the same reasons we used an <code class="literal">OwnedArray&lt;Button&gt;</code> object in preference to an <code class="literal">OwnedArray&lt;TextButton&gt;</code> object previously. Change the <code class="literal">MainComponent.cpp</code> file as follows:</p><div><pre class="programlisting">#include "MainComponent.h"

MainContentComponent::MainContentComponent()
<strong>{</strong>
<strong>  button1 = new TextButton ("Zero Slider");</strong>
<strong>  slider1 = new Slider (Slider::LinearHorizontal, </strong>
<strong>                        Slider::NoTextBox);</strong>
<strong>  label1 = new Label();</strong>
  slider1-&gt;setRange (0.0, 100.0);
  slider1-&gt;addListener (this);
  button1-&gt;addListener (this);
  slider1-&gt;setValue (100.0, sendNotification);
  
  <strong>addAndMakeVisible (button1);</strong>
  <strong>addAndMakeVisible (slider1);</strong>
  <strong>addAndMakeVisible (label1);</strong>
  setSize (200, 100);
}

void MainContentComponent::resized()
{
  button1-&gt;setBoundsRelative (0.05, 0.05, 0.90, 0.25);
  slider1-&gt;setBoundsRelative (0.05, 0.35, 0.90, 0.25);
  label1-&gt;setBoundsRelative (0.05, 0.65, 0.90, 0.25);
}

void MainContentComponent::buttonClicked (Button* button)
{
<strong>  if (button1 == button)</strong>
    slider1-&gt;setValue (0.0, sendNotification);
}

void MainContentComponent::sliderValueChanged (Slider* slider)
{
<strong>  if (slider1 == slider)</strong>
    label1-&gt;setText (String (slider1-&gt;getValue()), 
                     sendNotification);
}</pre></div><p>The main <a id="id210" class="indexterm"/>changes here are to use the <code class="literal">-&gt;</code> operator (which the <code class="literal">ScopedPointer</code> class overloads to return the pointer it contains) rather than the <code class="literal">.</code> operator. The components are all explicitly allocated use the <code class="literal">new</code> operator, but other than that, the code is almost identical to the <code class="literal">Chapter02_02</code> project.</p><p>Other useful <a id="id211" class="indexterm"/>memory management classes in JUCE are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ReferenceCountedObjectPtr&lt;ReferenceCountedObjectClass&gt;</code>: This allows you to write classes such that instances can be passed around in a similar way to the <code class="literal">String</code> objects. The lifetime is managed by the object maintaining its own counter that counts the number of references that exists to the object in the code. This is particularly useful in multi-threaded applications and for producing graph or tree structures. The <code class="literal">ReferenceCountedObjectClass</code> template argument needs to inherit from the <code class="literal">ReferenceCountedObject</code> class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">MemoryBlock</code>: This manages a block of resizable memory and is the recommended method <a id="id212" class="indexterm"/>of managing raw memory (rather than using the standard <code class="literal">malloc()</code> and <code class="literal">free()</code> functions, for example).</li><li class="listitem" style="list-style-type: disc"><code class="literal">HeapBlock&lt;ElementType&gt;</code>: Similar to the <code class="literal">MemoryBlock</code> class (in fact a <code class="literal">MemoryBlock</code> object contains a <code class="literal">HeapBlock&lt;char&gt;</code> object), but this is a smart pointer type and supports the <code class="literal">-&gt;</code> operator. As it is a template class, it also points to an object or objects of a particular type.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Summary</h1></div></div></div><p>This chapter has outlined some of the core classes in JUCE that provide a foundation for building JUCE applications and provide a framework for building applications that are idiomatic to the JUCE style. These classes provide further foundations for the remainder of this book. Each of these classes contains far more functionality than outlined here. Again, it is essential that you review the JUCE class documentation for each of the classes introduced in this chapter. Many of these classes are used heavily in the JUCE Demo application and the code for the Introjucer application. These should also serve as useful for further reading. The next chapter introduces classes for handling files, especially media files, such as image and sound files.</p></div></body></html>