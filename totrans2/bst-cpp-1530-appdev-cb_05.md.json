["```cpp\n#include <algorithm>\n#include <fstream>\n#include <iterator>\n\nvoid set_not_first_run();\nbool is_first_run();\n\n// Function, that executes for a long time\nvoid fill_file_with_data(char fill_char, std::size_t size, const char* filename){\n  std::ofstream ofs(filename);\n  std::fill_n(std::ostreambuf_iterator<char>(ofs), size, fill_char);\n  set_not_first_run();\n}\n\n// ...\n// Somewhere in thread that draws a user interface\nif (is_first_run()) {\n  // This will be executing for a long time during which\n  // users interface will freeze..\n  fill_file_with_data(0, 8 * 1024 * 1024, \"save_file.txt\");\n}\n```", "```cpp\n#include <boost/thread.hpp>\n\n// ...\n// Somewhere in thread that draws a user interface\nif (is_first_run()) {\n  boost::thread(boost::bind(\n      &fill_file_with_data,\n      0,\n      8 * 1024 * 1024,\n      \"save_file.txt\"\n  )).detach();\n}\n```", "```cpp\n// ...\n// Somewhere in thread that draws a user interface\nif (is_first_run()) {\n  boost::thread t(boost::bind(\n      &fill_file_with_data,\n      0,\n      8 * 1024 * 1024,\n      \"save_file.txt\"\n  ));\n  // Do some work\n  // ...\n  // Waiting for thread to finish\n  t.join();\n}\n```", "```cpp\n#include <boost/thread/scoped_thread.hpp>\nvoid some_func();\nvoid example_with_raii() {\n  boost::scoped_thread<boost::join_if_joinable> t(\n    (boost::thread(&some_func))\n  );\n  // 't' will be joined at scope exit\n}\n```", "```cpp\n#include <cassert>\n#include <cstddef>\n\n// In previous recipe we included\n// <boost/thread.hpp>, which includes all\n// the classes of Boost.Thread\n#include <boost/thread/thread.hpp>\n\nint shared_i = 0;\n\nvoid do_inc() {\n  for (std::size_t i = 0; i < 30000; ++i) {\n    // do some work\n    // ...\n\n    const int i_snapshot = ++ shared_i;\n\n    // do some work with i_snapshot\n    // ...\n  }\n}\n\nvoid do_dec() {\n  for (std::size_t i = 0; i < 30000; ++i) {\n    // do some work\n    // ...\n\n    const int i_snapshot = -- shared_i;\n\n    // do some work with i_snapshot\n    // ...\n  }\n}\n\nvoid run() {\n  boost::thread t1(&do_inc);\n  boost::thread t2(&do_dec);\n\n  t1.join();\n  t2.join();\n\n  // assert(shared_i == 0); // Oops!\n  std::cout << \"shared_i == \" << shared_i;\n}\n```", "```cpp\nshared_i == 19567\n```", "```cpp\n    #include <boost/thread/mutex.hpp>\n    #include <boost/thread/locks.hpp>\n\n    int shared_i = 0;\n    boost::mutex i_mutex;\n    ```", "```cpp\n    { // Critical section begin\n      boost::lock_guard<boost::mutex> lock(i_mutex);\n    ```", "```cpp\n    } // Critical section end\n    ```", "```cpp\nvoid do_inc() {\n  for (std::size_t i = 0; i < 30000; ++i) {\n\n    // do some work\n    // â€¦\n\n    int i_snapshot;\n    { // Critical section begin\n      boost::lock_guard<boost::mutex> lock(i_mutex);\n      i_snapshot = ++ shared_i;\n    } // Critical section end\n\n    // do some work with i_snapshot\n    // ...\n  }\n}\n\nvoid do_dec() {\n  for (std::size_t i = 0; i < 30000; ++i) {\n    // do some work\n    // ...\n\n    int i_snapshot;\n    { // Critical section begin\n      boost::lock_guard<boost::mutex> lock(i_mutex);\n      i_snapshot = -- shared_i;\n    } // Critical section end\n\n    // do some work with i_snapshot\n    // ...\n  }\n}\n```", "```cpp\n{ // Critical section begin\n  boost::lock_guard<boost::mutex> lock(i_mutex);\n  i_snapshot = ++ shared_i;\n} // Critical section end\n```", "```cpp\n    #include <cassert>\n    #include <cstddef>\n\n    #include <boost/thread/thread.hpp>\n    #include <boost/atomic.hpp>\n    ```", "```cpp\n    boost::atomic<int> shared_i(0);\n    ```", "```cpp\n    void do_inc() {\n      for (std::size_t i = 0; i < 30000; ++i) {\n        // do some work\n        // ...\n        const int i_snapshot = ++ shared_i;\n        // do some work with i_snapshot\n        // ...\n      }\n    }\n\n    void do_dec() {\n      for (std::size_t i = 0; i < 30000; ++i) {\n        // do some work\n        // ...\n        const int i_snapshot = -- shared_i;\n        // do some work with i_snapshot\n        // ...\n      }\n    }\n    ```", "```cpp\n    int main() {\n      boost::thread t1(&do_inc);\n      boost::thread t2(&do_dec);\n      t1.join();\n      t2.join();\n      assert(shared_i == 0);\n      std::cout << \"shared_i == \" << shared_i << std::endl;\n    }\n    ```", "```cpp\n-- shared_i; // Transaction #1\n// Some other thread may work here with shared_i and change its value\n++shared_i; // Transaction #2\n```", "```cpp\n#include <boost/static_assert.hpp>\nBOOST_STATIC_ASSERT(BOOST_ATOMIC_INT_LOCK_FREE == 2);\n```", "```cpp\nassert(shared_i.is_lock_free());\n```", "```cpp\ntypedef boost::function<void()> task_t;\n```", "```cpp\n    #include <deque>\n    #include <boost/function.hpp>\n    #include <boost/thread/mutex.hpp>\n    #include <boost/thread/locks.hpp>\n    #include <boost/thread/condition_variable.hpp>\n\n    class work_queue {\n    public:\n      typedef boost::function<void()> task_type;\n\n    private:\n      std::deque<task_type>   tasks_;\n      boost::mutex            tasks_mutex_;\n      boost::condition_variable cond_;\n    ```", "```cpp\n    public:\n      void push_task(const task_type& task) {\n        boost::unique_lock<boost::mutex> lock(tasks_mutex_);\n        tasks_.push_back(task);\n        lock.unlock();\n        cond_.notify_one();\n      }\n    ```", "```cpp\n      task_type try_pop_task() {\n        task_type ret;\n        boost::lock_guard<boost::mutex> lock(tasks_mutex_);\n        if (!tasks_.empty()) {\n          ret = tasks_.front();\n          tasks_.pop_front();\n        }\n        return ret;\n      }\n    ```", "```cpp\n      task_type pop_task() {\n        boost::unique_lock<boost::mutex> lock(tasks_mutex_);\n        while (tasks_.empty()) {\n          cond_.wait(lock);\n        }\n        task_type ret = tasks_.front();\n        tasks_.pop_front();\n        return ret;\n      }\n    };\n    ```", "```cpp\n    #include <boost/thread/thread.hpp>\n\n    work_queue g_queue;\n\n    void do_nothing(){}\n\n    const std::size_t tests_tasks_count = 3000;\n\n    void pusher() {\n      for (std::size_t i = 0; i < tests_tasks_count; ++i) {\n        // Adding task to do nothing\n        g_queue.push_task(&do_nothing);\n      }\n    }\n\n    void popper_sync() {\n      for (std::size_t i = 0; i < tests_tasks_count; ++i) {\n        g_queue.pop_task() // Getting task\n        (); // Executing task\n      }\n    }\n\n    int main() {\n      boost::thread pop_sync1(&popper_sync);\n      boost::thread pop_sync2(&popper_sync);\n      boost::thread pop_sync3(&popper_sync);\n\n      boost::thread push1(&pusher);\n      boost::thread push2(&pusher);\n      boost::thread push3(&pusher);\n\n      // Waiting for all the tasks to pop\n      pop_sync1.join();\n      pop_sync2.join();\n      pop_sync3.join();\n\n      push1.join();\n      push2.join();\n      push3.join();\n\n      // Asserting that no tasks remained,\n      // and falling though without blocking\n      assert(!g_queue.try_pop_task());\n\n      g_queue.push_task(&do_nothing);\n      // Asserting that there is a task,\n      // and falling though without blocking\n      assert(g_queue.try_pop_task());\n    }\n    ```", "```cpp\n$time -f E ./work_queue\n\n0:07.38\n\n```", "```cpp\n$ time -f E ./work_queue \n\n0:05.39\n\n```", "```cpp\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <boost/thread/locks.hpp>\n\nstruct user_info {\n  std::string address;\n  unsigned short age;\n\n  // Other parameters\n  // ...\n};\n\nclass users_online {\n  typedef boost::mutex                      mutex_t;\n  mutable mutex_t                           users_mutex_;\n  std::map<std::string, user_info>          users_;\n\npublic:\n  bool is_online(const std::string& username) const {\n    boost::lock_guard<mutex_t> lock(mutex_);\n    return users_.find(username) != users_.end();\n  }\n\n  unsigned short get_age(const std::string& username) const {\n    boost::lock_guard<mutex_t> lock(mutex_);\n    return users_.at(username).age;\n  }\n\n  void set_online(const std::string& username, const user_info& data) {\n    boost::lock_guard<mutex_t> lock(mutex_);\n    users_.insert(std::make_pair(username, data));\n  }\n\n  // Other methods\n  // ...\n};\n```", "```cpp\n#include <boost/thread/shared_mutex.hpp>\n\nclass users_online {\n  typedef boost::shared_mutex         mutex_t;\n  mutable mutex_t                     users_mutex_;\n  std::map<std::string, user_info>    users_;\n\npublic:\n  bool is_online(const std::string& username) const {\n    boost::shared_lock<mutex_t> lock(users_mutex_);\n    return users_.find(username) != users_.end();\n  }\n\n  unsigned short get_age(const std::string& username) const {\n    boost::shared_lock<mutex_t> lock(users_mutex_);\n    return users_.at(username).age;\n  }\n\n  void set_online(const std::string& username, const user_info& data) {\n    boost::lock_guard<mutex_t> lock(users_mutex_);\n    users_.insert(std::make_pair(username, data));\n  }\n\n  // Other methods\n  // ...\n};\n```", "```cpp\n#include <boost/noncopyable.hpp>\n\nclass connection: boost::noncopyable {\npublic:\n  // Opening a connection is a slow operation\n  void open();\n\n  void send_result(int result);\n\n  // Other methods\n  // ...\n};\n```", "```cpp\n// In header file\n#include <boost/thread/tss.hpp>\n\nconnection& get_connection();\n\n// In source file\nboost::thread_specific_ptr<connection> connection_ptr;\n\nconnection& get_connection() {\n  connection* p = connection_ptr.get();\n  if (!p) {\n    connection_ptr.reset(new connection);\n    p = connection_ptr.get();\n    p->open();\n  }\n  return *p;\n}\n```", "```cpp\nvoid task() {\n  int result;\n  // Some computations go there\n  // ...\n\n  // Sending result\n  get_connection().send_result(result);\n}\n```", "```cpp\nboost::thread parser_thread(&do_parse);\n  // Some code goes here\n  // ...\n  if (stop_parsing) {\n    // no more parsing required\n    // TODO: stop parser\n  }\n```", "```cpp\nif (stop_parsing) {\n  // no more parsing required\n  parser_thread.interrupt();\n}\n```", "```cpp\nvoid do_parse() {\n  while (not_end_of_parsing) {\n    boost::this_thread::interruption_point();\n    // Some parsing goes here\n  }\n}\n```", "```cpp\nboost::thread t1(&some_function);\nboost::thread t2(&some_function);\nboost::thread t3(&some_function);\n// ...\nt1.join();\nt2.join();\nt3.join();\n```", "```cpp\n    boost::thread_group threads;\n    ```", "```cpp\n    // Launching 10 threads\n    for (unsigned i = 0; i < 10; ++i) {\n      threads.create_thread(&some_function);\n    }\n    ```", "```cpp\n    // Joining all threads\n    threads.join_all();\n\n    // We can also interrupt all of them\n    // by calling threads.interrupt_all();\n    ```"]