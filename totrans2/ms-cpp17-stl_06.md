# Smart Pointers

C++ holds its grip on large swaths of the software industry by virtue of its performance--well-written C++ code runs faster than anything else out there, *almost* by definition, because C++ gives the programmer almost complete control over the code that is ultimately generated by the compiler.

One of the classic features of low-level, performant code is the use of *raw pointers* (`Foo*`). However, raw pointers come with many pitfalls, such as memory leaks and dangling pointers. The C++11 library's "smart pointer" types can help you avoid these pitfalls at little to no expense.

In this chapter we'll learn the following:

*   The definition of "smart pointer" and how you might write your own
*   The usefulness of `std::unique_ptr<T>` in preventing resource leaks of all types (not just memory leaks)
*   How `std::shared_ptr<T>` is implemented, and its implications for memory usage
*   The meaning and uses of the Curiously Recurring Template Pattern

# The origins of smart pointers

Raw pointers have many uses in C:

*   As a cheap, non-copying view of an object owned by the caller
*   As a way for the callee to modify an object owned by the caller
*   As one-half of a pointer/length pair, used for arrays
*   As an optional argument (either a valid pointer *or* null)
*   As a way to manage memory on the heap

In C++, we have native references (`const Foo&` and `Foo&`) to handle the first two bullets; plus, move semantics makes it cheap for a callee to take and pass back a complex object by value in most cases, thus completely avoiding aliasing. In C++17 we can use `std::string_view` to address some of the first and third bullet. And we've just seen in [Chapter 5](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d), *Vocabulary Types*, that passing an `optional<T>`--or perhaps getting fancy with an `optional<reference_wrapper<T>>`--is sufficient to handle the fourth bullet.

This chapter will be concerned with the fifth bullet.

Heap allocation comes with a host of problems in C, and all those problems (and more!) applied to C++ prior to 2011\. As of C++11, though, almost all of those problems have disappeared. Let's enumerate them:

*   **Memory leaks**: You might allocate a piece of memory or an object on the heap, and accidentally forget to write the code that frees it.
*   **Memory leaks**: You might have written that code, but due to an early return or an exception being thrown, the code never runs and the memory remains unfreed!
*   **Use-after-free**: You take a copy of a pointer to an object on the heap, and then free that object through the original pointer. The holder of the copied pointer doesn't realize that their pointer is no longer valid.
*   **Heap corruption via pointer arithmetic**: You allocate an array on the heap at address *A*. Having a raw pointer to an array tempts you to do pointer arithmetic, and in the end you accidentally free a pointer to address *A*+*k*. When *k*=0 (as Murphy's Law ensures it will be, in testing) there is no problem; when *k*=1 you corrupt your heap and cause a crash.

The first two problems are compounded by the fact that heap allocation is semantically allowed to fail--`malloc` can return null, `operator new` can throw `std::bad_alloc`--which means that if you're writing pre-C++11 code that allocates memory, you are probably writing a lot of cleanup code to deal with allocation failure. (In C++, you're "writing" that code whether you know it or not, because the control flow paths due to exception handling are there even if you're not consciously thinking about them.) The upshot of all this is that managing heap-allocated memory in C++ is *hard*.

Unless you use smart pointers!

# Smart pointers never forget

The idea of a "smart pointer" type (not to be confused with a "fancy pointer" type, which we'll cover in [Chapter 8](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d), *Allocators*) is that it's a class--typically a class template--which behaves syntactically just like a pointer, but whose special member functions (construction, destruction, and copying/moving) have additional bookkeeping to ensure certain invariants. For example, we might ensure the following:

*   The pointer's destructor also frees its pointee--helping to solve memory leaks
*   Maybe the pointer cannot be copied--helping to solve use-after-free
*   Or maybe the pointer *can* be copied, but it knows how many copies exist and won't free the pointee until the last pointer to it has been destroyed
*   Or maybe the pointer can be copied, and you can free the pointee, but if you do, all other pointers to it magically become null
*   Or maybe the pointer has no built-in `operator+`--helping
    to solve corruption due to pointer arithmetic
*   Or maybe you're allowed to adjust the pointer's value arithmetically, but the arithmetic "what object is pointed-to" is managed separately from the identity of "what object is to be freed"

The standard smart pointer types are `std::unique_ptr<T>`, `std::shared_ptr<T>`, and (not really a pointer type, but we'll lump it in with them) `std::weak_ptr<T>`. In this chapter we'll cover all three of those types, plus one non-standard smart pointer that you might find useful--and which might become a standard smart pointer type in a future C++ standard!

# Automatically managing memory with std::unique_ptr<T>

The fundamental properties of a smart pointer type are simple: it should support `operator*`, and it should overload the special member functions to preserve its class invariants, whatever those are.

`std::unique_ptr<T>` supports the same interface as `T*`, but with the class invariant that, once you construct a `unique_ptr` pointing to a given heap-allocated object, that object *will* be freed when the destructor `unique_ptr` is called. Let's write some code supporting that `T*` interface:

[PRE0]

If we stopped here--with just a way to construct a pointer object from a `T*` and a way to get the pointer out again--we'd have the `observer_ptr<T>` discussed at the end of this chapter. But we'll keep going. We'll add methods `release` and `reset`:

[PRE1]

`p.release()` is just like `p.get()`, but in addition to returning a copy of the original raw pointer, it nulls out the contents of `p` (without freeing the original pointer, of course, because presumably our caller wants to take ownership of it).

`p.reset(q)` *does* free the current contents of `p`, and then puts the raw pointer `q` in its place.

Notice that we have implemented both of these member functions in terms of the standard algorithm `std::exchange`, which we didn't cover in [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d), *The Iterator-Pair Algorithms*. It's sort of a value-returning version of `std::swap`: pass in a new value, get out the former value.

Finally, with these two primitive operations, we can implement the special member functions of `std::unique_ptr<T>` so as to preserve our invariant--which, again, is this: once a raw pointer has been acquired by a `unique_ptr` object, it will remain valid as long as the `unique_ptr` object has the same value, and when that's no longer true--when the `unique_ptr` is adjusted to point elsewhere, or destroyed--the raw pointer will be freed correctly. Here are the special member functions:

[PRE2]

In memory, our `std::unique_ptr<T>` will look like this:

![](img/00017.jpeg)

There is one more little helper function we need, so as never to touch raw pointers with our hands:

[PRE3]

With `unique_ptr` in our toolbox, we can replace old-style code such as this:

[PRE4]

It can be replaced with modern C++17 code like this:

[PRE5]

Notice that `unique_ptr<T>` is yet another application of **RAII**--in this case, quite literally. Although the "interesting" action (the freeing of the underlying raw pointer) still happens during destruction (of the `unique_ptr`), the only way you'll get the full benefit of `unique_ptr` is if you make sure that whenever you *allocate* a *resource*, you also *initialize* a `unique_ptr` to manage it. The `std::make_unique<T>()` function shown in the previous section (and introduced to the standard library in C++14) is the key to safe memory management in modern C++.

While it is *possible* to use `unique_ptr` without using `make_unique`, you should not do it:

[PRE6]

# Why C++ doesn't have the finally keyword

Consider again this snippet of code from the preceding section's "pre-modern" code sample:

[PRE7]

In other languages such as Java and Python, these semantics might be expressed more compactly using the `finally` keyword:

[PRE8]

C++ doesn't have the `finally` keyword, and shows no signs that it will ever enter the language. This is simply due to a philosophical difference between C++ and those other languages: the C++ philosophy is that if you're concerned with *enforcing some invariant*--such as "this pointer shall always be freed at the end of this block, no matter how we get there"--then you shouldn't ever be writing *explicit code*, because then there's always a chance for you to write it wrong, and then you'll have bugs.

If you have some *invariant* that you want to enforce, then the right place to enforce it is *in the type system*, using constructors, destructors, and other special member functions--the tools of RAII. Then, you can ensure that *any possible* use of your new type preserves its invariants--such as "the underlying pointer shall be freed whenever it's no longer held by an object of this type"--and when you go to write your business logic, you won't have to write anything explicitly; the code will look simple and yet always--provably--have correct behavior.

So if you find yourself writing code that looks like the preceding example, or if you find yourself wishing you could just write `finally`, stop and think: "Should I be using `unique_ptr` for this?" or "Should I write an RAII class type for this?"

# Customizing the deletion callback

Speaking of custom RAII types, you might be wondering whether it's possible to use `std::unique_ptr` with a customized deletion callback: for example, instead of passing the underlying pointer to `delete`, you might want to pass it to `free()`. Yes you can!

`std::unique_ptr<T,D>` has a second template type parameter: a *deletion callback type*. The parameter `D` defaults to `std::default_delete<T>`, which just calls `operator delete`, but you can pass in any type you want--typically a user-defined class type with an overloaded `operator()`:

[PRE9]

Incidentally, notice that the destructor of `std::unique_ptr` is carefully written so that it guarantees never to call your callback with a null pointer. This is absolutely critical in the preceding example, because `fclose(NULL)` is a special case that means "close all open file handles in the current process"--which is never what you wanted to do!

Observe also that `std::make_unique<T>()` only ever takes one template type parameter; there is no `std::make_unique<T,D>()`. But the rule to avoid touching raw pointers with your hands is still a good one; that's why our preceding example wraps the `fopen` and `unique_ptr` construction into a small reusable helper function `fcloser::open`, rather than inlining the call to `fopen` into the body of `test`.

The space for your custom deleter will be allocated in the body of the `std::unique_ptr<T,D>` object itself, which means `sizeof(unique_ptr<T,D>)` may be bigger than `sizeof(unique_ptr<T>)` if `D` has any member data:

![](img/00018.jpeg)

# Managing arrays with std::unique_ptr<T[]>

Another case where `delete p` is not the appropriate way to free a raw pointer is if `p` is a pointer to the first element of an array; in that case, `delete [] p` should be used instead. Fortunately, as of C++14, `std::unique_ptr<T[]>` exists and does the right thing in this case (by virtue of the fact that `std::default_delete<T[]>` also exists and does the right thing, which is to call `operator delete[]`).

An overload of `std::make_unique` for array types does exist, although be careful--it assigns a different meaning to its argument! `std::make_unique<T[]>(n)` essentially calls `new T[n]()`, where the parentheses on the end signify that it's going to value-initialize all the elements; that is, it will zero out primitive types. In the rare case that you don't want this behavior, you'll have to call `new` yourself and wrap the return value in a `std::unique_ptr<T[]>`, preferably using a helper function as we did in the example in the preceding section (where we used `fcloser::open`).

# Reference counting with std::shared_ptr<T>

Having completely solved the problem of memory leaks, we now tackle the problem of use-after-free bugs. The essential problem to be solved here is *unclear ownership*--or rather `shared ownership`--of a given resource or chunk of memory. This chunk of memory might have several people looking at it at different times, maybe from different data structures or from different threads, and we want to make sure that all these stakeholders are involved in the decision about when to free it. The ownership of the underlying chunk of memory should be *shared*.

For this, the standard has provided `std::shared_ptr<T>`. Its interface appears very similar to `std::unique_ptr<T>`; all of the differences are hidden under the hood, in the implementations of the special member functions.

`std::shared_ptr<T>` provides an approach to memory management that is often known as *reference counting*. Each object managed by a `shared_ptr` keeps count of how many references to it are in the system--that is, how many stakeholders care about it right now--and as soon as that number drops to zero, the object knows it's time to clean itself up. Of course, it's not really "the object" that cleans itself up; the entity that knows how to count references and clean things up is a small wrapper, or "control block," which is created on the heap whenever you transfer ownership of an object to `shared_ptr`. The control block is handled invisibly by the library, but if we were to view its layout in memory, it might look something like this:

![](img/00019.jpeg)

Just as `unique_ptr` has `make_unique`, the standard library provides `shared_ptr` with `make_shared` so that you never have to touch raw pointers with your hands. The other advantage of using `std::make_shared<T>(args)` to allocate shared objects is that transferring ownership into a `shared_ptr` requires allocating additional memory for the control block. When you call `make_shared`, the library is permitted to allocate a single chunk of memory that's big enough for both the control block *and* your `T` object, in one allocation. (This is illustrated by the physical placement of the rectangles for `control_block_impl` and `Super` in the preceding diagram.)

Copying a `shared_ptr` increments the "use-count" of its associated control block; destroying a `shared_ptr` decrements its use-count. Assigning over the value of a `shared_ptr` will decrement the use-count of its old value (if any), and increment the use-count of its new value. Here are some examples of playing with `shared_ptr`:

[PRE10]

The following diagram illustrates an interesting and occasionally useful aspect of `shared_ptr`: the ability for two instances of `shared_ptr` to refer to the same control block and yet point to different pieces of the memory being managed by that control block:

![](img/00020.jpeg)

The constructor being used in the preceding diagram, which is also used in the `get_second()` function, is often called the "aliasing constructor" of `shared_ptr`. It takes an existing non-null `shared_ptr` object of any type, whose control block will be shared by the newly constructed object. In the following code sample, the message "destroying `Super`" will not be printed until *after* the message "accessing `Super::second`":

[PRE11]

As you can see, once ownership has been transferred into the `shared_ptr` system, the responsibility for remembering how to free a managed resource rests entirely on the shoulders of the control block. It isn't necessary for your code to deal in `shared_ptr<T>` just because the underlying managed object happens to be of type `T`.

# Don't double-manage!

While `shared_ptr<T>` has the potential to eliminate nasty double-free bugs from your pointer code, it is sadly all too common for inexperienced programmers to write the same bugs using `shared_ptr` simply by over-using the constructors that take raw pointer arguments. Here's an example:

[PRE12]

Remember that your goal should be never to touch raw pointers with your hands! The place where this code goes wrong is the very first time it calls `pb.get()` to fetch the raw pointer out of `shared_ptr`.

It would have been correct to call the aliasing constructor here, `pc = std::shared_ptr<X>(pb, pb.get())`, but that would have had the same effect as a simple assignment `pc = pb`. So another general rule we can state is: if you have to use the word `shared_ptr` explicitly in your code, you're doing something out of the ordinary--and perhaps dangerous. *Without* naming `shared_ptr` in your code, you can already allocate and manage heap objects (using `std::make_shared`) and manipulate a managed object's use-count by creating and destroying copies of the pointer (using `auto` to declare variables as you need them). The one place this rule definitely breaks down is when you sometimes need to declare a class data member of type `shared_ptr<T>`; you generally can't do that without writing the name of the type!

# Holding nullable handles with weak_ptr

You may have noticed in the previous diagrams, an unexplained data member of the control block marked "weak count". It's time to explain what that is.

Sometimes--it's rare, but sometimes--we have a situation where we're using `shared_ptr` to manage the ownership of shared objects, and we'd like to keep a pointer to an object without actually expressing ownership of that object. Of course we could use a raw pointer, reference, or `observer_ptr<T>` to express the idea of "non-owning reference," but the danger then would be that the actual owners of the referenced object could decide to free it, and then when we went to dereference our non-owning pointer, we'd visit a freed object and get undefined behavior. `DangerousWatcher` in the following code sample illustrates this dangerous behavior:

[PRE13]

We could alternatively use a `shared_ptr` to express the idea of "reference," but of course that would give us an owning reference, making us less of a `Watcher` and more of a `Participant`:

[PRE14]

What we really want is a non-owning reference that is nevertheless aware of the `shared_ptr` system for managing memory, and is able to query the control block and find out whether the referenced object still exists. But by the time we found out that the object existed and went to access it, it might have been deallocated by some other thread! So the primitive operation we need is "atomically get an owning reference (a `shared_ptr`) to the referenced object if it exists, or otherwise indicate failure." That is, we don't want a *non-owning reference*; what we want is a *ticket that we can exchange at some future date for an owning reference*.

The standard library provides this "ticket for a `shared_ptr`" under the name `std::weak_ptr<T>`. (It's called "weak" in opposition to the "strong" owning references of `shared_ptr`.) Here's an example of how to use `weak_ptr` to solve our `Watcher` problem:

[PRE15]

The only two operations you need to know with `weak_ptr` are that you can construct a `weak_ptr<T>` from a `shared_ptr<T>` (by calling the constructor, as shown in the `watch()` function), and you can attempt to construct a `shared_ptr<T>` from a `weak_ptr<T>` by calling `wptr.lock()`. If the `weak_ptr` has expired, you'll get back a null `shared_ptr`.

There's also the member function `wptr.expired()`, which can tell you if the `weak_ptr` in question has already expired; but notice that it's essentially useless, since even if it returns `false` right now, it might return `true` a few microseconds later.

The following diagram continues the narrative started in the previous diagram by creating `weak_ptr` from `q` and then nulling out the `shared_ptr` it came from:

![](img/00021.jpeg)

Copying a `weak_ptr` increments the weak-count associated with the referenced object's control block, and destroying a `weak_ptr` decrements the weak-count. When the use-count hits zero, the system knows it's safe to deallocate the controlled object; but the control block itself will not be deallocated until the weak-count hits zero, at which point we know that there are no more `weak_ptr` objects pointing at this control block:

![](img/00022.jpeg)

You might have noticed that `shared_ptr` is using the same trick on its `Deleter` that we saw in the context of `std::any` and `std::function` in [Chapter 5](part0074.html#26I9K0-2fdac365b8984feebddfbb9250eaf20d), *Vocabulary Types*--it is using *type erasure*. And, like `std::any` and `std::function`, `std::shared_ptr` provides a "go fish" function--`std::get_deleter<Deleter>(p)`--to retrieve the original deleter object. This tidbit will be entirely useless to you in your work; I mention it only to call attention to the importance of type erasure in modern C++. Even `shared_ptr`, whose ostensible purpose has nothing to do with erasing types, relies on type erasure in one little corner of its functionality.

# Talking about oneself with std::enable_shared_from_this

There's just one more piece of the `shared_ptr` ecosystem that we should discuss. We've mentioned the danger of "double-managing" a pointer by creating multiple control blocks. So we might want a way to ask, given a pointer to a heap-allocated object, just who exactly is managing it right now.

The most common use-case for this feature is in object-oriented programming, where a method `A::foo()` wants to invoke some external function `bar()`, and `bar()` needs a pointer back to the `A` object. If we weren't worrying about lifetime management, this would be easy; `A::foo()` would simply invoke `bar(this)`. But let's say our `A` is being managed by `shared_ptr`, and let's say that `bar()` is likely to stash a copy of the `this` pointer somewhere internally--maybe we're registering a callback for later, or maybe we're spawning a new thread that will run concurrently while `A::foo()` finishes up and returns to its caller. So we need some way to keep `A` alive while `bar()` is still running.

Clearly `bar()` should take a parameter of type `std::shared_ptr<A>`; this will keep our `A` alive. But within `A::foo()`, where do we get that `shared_ptr` from? We could give `A` a member variable of type `std::shared_ptr<A>`, but then `A` would be keeping *itself* alive--it would never die! That's certainly not what we!

A preliminary solution is that `A` should keep a member variable of type `std::weak_ptr<A>` pointing to itself, and when it invokes `bar`, it should do so with `bar(this->m_wptr.lock())`. This has quite a bit of syntactic overhead, though, and besides it's unclear how the pointer `m_wptr` ought to get initialized. So, C++ took this idea and built it right into the standard library!

[PRE16]

The `std::enable_shared_from_this<A>` class holds our member variable of type `std::weak_ptr<A>`, and exposes the operation "get a `shared_ptr` to myself" under the name `x.shared_from_this()`. There are a couple of interesting details to notice in the preceding code: First, if you try to call `x.shared_from_this()` on an object that isn't currently being managed by the `shared_ptr` system, you'll get an exception of type `std::bad_weak_ptr`. Second, notice the empty copy constructor and copy assignment operator. Empty braces in this case is *not* the same thing as `=default`! If we had used `=default` to make the copy operations defaulted, they would have performed memberwise copying. Every time you made a copy of a managed object, the new object would receive a copy of the original's `m_weak`; which isn't what we want here at all. The "identity" of the `enable_shared_from_this` portion of a C++ object is tied to its *location in memory*, and therefore it does not (and should not) follow the rules of copying and value semantics for which we typically strive.

The last question to answer is: how does the member `m_weak` (which remember is a *private* member; we're using the name `m_weak` purely for exposition) get initialized in the first place? The answer is that the constructor of `shared_ptr` includes some lines of code to detect whether `T` publicly inherits from `enable_shared_from_this<T>`, and, if so, to set its `m_weak` member through some hidden back door. Notice that the inheritance must be *public* and *unambiguous*, since the constructor of `shared_ptr` is just another user-defined function as far as the rules of C++ are concerned; it can't crack open your class to find its private base classes, or to disambiguate between multiple copies of `enable_shared_from_this`.

These restrictions imply that you should only ever inherit from `enable_shared_from_this` publicly; that once a class derives from `enable_shared_from_this` you should only ever inherit from *it* publicly; and to keep things simple you probably ought to inherit from `enable_shared_from_this` only at the very leaves of your inheritance hierarchy. Of course, if you do not make deep inheritance hierarchies in the first place, following these rules will be fairly easy!

Let's put everything we know about `enable_shared_from_this` together into a single example:

[PRE17]

# The Curiously Recurring Template Pattern

You may already have noticed, but especially after seeing the preceding code sample it should be apparent, that whenever you inherit from `enable_shared_from_this` the name of *your class* always appears in the template parameter list of its own base class! This pattern of "`X` inherits from `A<X>`" is known as the **Curiously Recurring Template Pattern**, or **CRTP** for short. It's common whenever some aspect of the base class depends on its derived class. For example, in our case the name of the derived class is incorporated into the return type of the `shared_from_this` method.

Another common case where the CRTP is warranted is when some *behavior* of the derived class is incorporated into the behavior provided by the base class. For example, using the CRTP we can write a base class template that provides a value-returning `operator+` for any derived class that implements `operator+=` and copy-construction. Notice the required `static_cast` from `addable<Derived>` to `Derived`, so that we call the copy constructor of `Derived` instead of the copy constructor of the base class `addable<Derived>`:

[PRE18]

In fact, this is almost exactly the service provided by `boost::addable` in the Boost Operators library; except that `boost::addable` uses the so-called "Barton-Nackman trick" to make its `operator+` a friend free function instead of a member function:

[PRE19]

Even if you never use `enable_shared_from_this` in your codebase, you should be aware of the Curiously Recurring Template Pattern and be able to pull it out of your toolbox whenever you need to "inject" some derived-class behavior into a method of your base class.

# A final warning

The mini-ecosystem of `shared_ptr`, `weak_ptr`, and `enable_shared_from_this` is one of the coolest parts of modern C++; it can give your code the safety of a garbage-collected language while preserving the speed and deterministic destruction that have always characterized C++. However, be careful not to abuse `shared_ptr`! Most of your C++ code shouldn't be using `shared_ptr` at all, because you shouldn't be *sharing* the ownership of heap-allocated objects. Your first preference should always be to avoid heap-allocation altogether (by using value semantics); your second preference should be to make sure each heap-allocated object has a unique owner (by using `std::unique_ptr<T>`); and only if both of those are really impossible should you consider use of shared ownership and `std::shared_ptr<T>`.

# Denoting un-special-ness with observer_ptr<T>

We've now seen two or three different smart pointer types (depending on whether you count `weak_ptr` as a pointer type in its own right, or more like a ticket for a `shared_ptr`). Each of these types carries with it some useful source-level information about lifetime management. For example, just from the function signatures of these two C++ functions, what can we say about their semantics?

[PRE20]

We see that `remusnoc` takes a `unique_ptr` by value, which means that ownership of the controlled object is transferred to `remusnoc`. When we call this function, we must have *unique ownership* of a `Widget`, and after we call this function, we will no longer be able to access that `Widget`. We don't know whether `remusnoc` is going to destroy the `Widget`, keep it around, or attach it to some other object or thread; but it's explicitly *no longer our concern*. The `remusnoc` function is a *consumer* of widgets.

More subtly, we can also say that when we call `remusnoc`, we must have unique ownership of a `Widget` that was allocated with `new`, and which it is safe to `delete`!

And vice versa: when I call `recudorp`, I know that whatever `Widget` we receive will be *uniquely owned* by me. It isn't a reference to someone else's `Widget`; it isn't a pointer to some static data. It's explicitly a heap-allocated `Widget` owned by me and me alone. Even if the first thing I do with the return value is to call `.release()` on it and stuff the raw pointer into some "pre-modern" struct, I can be sure that it is *safe* to do so, because I am definitely the *unique owner* of the return value.

What can we say about the semantics of this C++ function?

[PRE21]

It's ambiguous. Maybe this function will take ownership of the passed pointer; maybe it won't. We can tell (we hope) from the documentation of `suougibma`, or from certain stylistic conventions in our codebase (such as "a raw pointer shall never denote ownership," which is a reasonable convention), but we can't tell from the signature alone. Another way to express this distinction is to say that `unique_ptr<T>` is a *vocabulary type* for expressing ownership transfer, whereas `T*` is not a vocabulary type for anything at all; it's the C++ equivalent of a nonsense word or a Rorschach blot, in that no two people will necessarily agree on what it means.

So, if you find yourself passing around a lot of non-owning pointers in your codebase, you might want a *vocabulary type* to represent the idea of a non-owning pointer. (Your first step should be to pass references instead of pointers whenever possible, but let's say that you've already exhausted that avenue.) Such a vocabulary type does exist, although it is not (yet) in the C++ standard library: due to Walter Brown, it's called "the world's dumbest smart pointer," and is merely a class-shaped wrapper around a raw non-owning pointer:

[PRE22]

With `observer_ptr` in our toolbox, it becomes crystal clear that `revresbo` merely *observes* its argument; it definitely doesn't take ownership of it. In fact, we can assume that it doesn't even keep a copy of the passed-in pointer, because the validity of that pointer would depend on the lifetime of the controlled object, and `revresbo` is explicitly claiming not to have any stake in the lifetime of that object. If it wanted a stake in the lifetime of the controlled object, it would ask for that stake explicitly, by requesting `unique_ptr` or `shared_ptr` from its caller. By requesting `observer_ptr`, `revresbo` is "opting out" of the whole ownership debate.

As I said, `observer_ptr` is not part of the C++17 standard. One of the main objections keeping it out is its terrible name (being as it has nothing to do with the "observer pattern"). There are also many knowledgeable people who would say that `T*` *should* be the vocabulary type for "non-owning pointer," and that all old code using `T*` for ownership transfer should be rewritten or at least re-annotated with constructs such as `owner<T*>`. This is the approach currently recommended by the editors of the C++ Core Guidelines, including C++ inventor Bjarne Stroustrup. One thing is certain, though: *never use raw pointers for ownership transfer!*

# Summary

In this chapter, we have learned a few things about smart pointers.

`std::unique_ptr<T>` is a vocabulary type for ownership, and for ownership transfer; prefer it over raw `T*`. Consider the use of `observer_ptr` in situations where ownership is explicitly *not* being transferred, or where raw `T*` might be ambiguous to the reader.

`std::shared_ptr<T>` is a good (and standard) tool for dealing with shared ownership, where many different entities are all stakeholders in the lifetime of a single controlled object. `std::weak_ptr<T>` is a "ticket for `shared_ptr`"; it provides `.lock()` instead of `operator*`. If your class needs the ability to get `shared_ptr` to itself, inherit from `std::enable_shared_from_this<T>`. Remember to inherit publicly, and generally speaking, only at the leaves of your inheritance graph. And don't overuse these features in situations that do not absolutely require shared ownership!

Never touch raw pointers with your hands: use `make_unique` and `make_shared` to create heap-allocated objects and manage them in a single swoop. And remember the Curiously Recurring Template Pattern whenever you need to "inject" derived-class behaviors back into a function provided by your base class.

In the next chapter, we'll talk about a different kind of "sharing": the kind that arises in multi-threaded programming.