["```cpp\nclass GL_Transform { \npublic: \n  ... \n  const glm::mat4& GetModelMatrix(); \nprivate: \n  ... \n  bool m_needsUpdate; \n  glm::mat4 m_matPos; \n  glm::mat4 m_matScale; \n  glm::mat4 m_matRotX; \n  glm::mat4 m_matRotY; \n  glm::mat4 m_matRotZ; \n  glm::mat4 m_matRotCombined; \n  glm::mat4 m_modelMatrix; // Final matrix. \n}; \n\n```", "```cpp\nvoid GL_Transform::SetPosition(const glm::vec3& l_pos) { \n  if (l_pos == m_position) { return; } \n  m_position = l_pos; \n  m_matPos = glm::translate(m_position); \n  m_needsUpdate = true; \n} \n\n```", "```cpp\nvoid GL_Transform::SetRotation(const glm::vec3& l_rot) { \n  if (l_rot == m_rotation) { return; } \n  if (l_rot.x != m_rotation.x) { \n    m_matRotX = glm::rotate(m_rotation.x, glm::vec3(1, 0, 0)); \n  } \n  if (l_rot.y != m_rotation.y) { \n    m_matRotY = glm::rotate(m_rotation.y, glm::vec3(0, 1, 0)); \n  } \n  if (l_rot.z != m_rotation.z) { \n    m_matRotZ = glm::rotate(m_rotation.z, glm::vec3(0, 0, 1)); \n  } \n  m_matRotCombined = m_matRotZ * m_matRotY * m_matRotX; \n  m_rotation = l_rot; \n  m_needsUpdate = true; \n} \n\n```", "```cpp\nvoid GL_Transform::SetScale(const glm::vec3& l_scale) { \n  if (l_scale == m_scale) { return; } \n  m_scale = l_scale; \n  m_matScale = glm::scale(m_scale); \n  m_needsUpdate = true; \n} \n\n```", "```cpp\nconst glm::mat4& GL_Transform::GetModelMatrix() { \n  if (m_needsUpdate) { \n    m_modelMatrix = m_matPos * m_matRotCombined * m_matScale; \n    m_needsUpdate = false; \n  } \n  return m_modelMatrix; \n} \n\n```", "```cpp\nvoid ParticleSystem::Draw(MaterialMapContainer& l_materials, ...) { \n  ... \n  if (renderer->UseShader(\"MaterialValuePass\")) { \n    auto shader = renderer->GetCurrentShader(); \n    // Normal pass. \n    auto texture = l_materials[MaterialMapType::Normal].get(); \n    shader->setUniform(\"material\", \n      sf::Glsl::Vec3(0.5f, 0.5f, 1.f)); \n    for (size_t i = 0; i < container->m_countAlive; ++i) { \n      ... \n      renderer->Draw(drawables[i], texture); \n    } \n\n    // Specular pass. \n    texture = l_materials[MaterialMapType::Specular].get(); \n    shader->setUniform(\"material\", sf::Glsl::Vec3(0.f, 0.f, 0.f)); \n    for (size_t i = 0; i < container->m_countAlive; ++i) { \n      ... \n      renderer->Draw(drawables[i], texture); \n    } \n  } \n  ... \n} \n\n```", "```cpp\ninline float GetDistance(const sf::Vector2f& l_1, \n  const sf::Vector2f& l_2) \n{ \n  return std::sqrt(std::pow(l_1.x - l_2.x, 2) + \n    std::pow(l_1.y - l_2.y, 2)); \n} \n\ninline bool CircleInView(const sf::View& l_view, \n  const sf::Vector2f& l_circleCenter, float l_circleRad) \n{ \n  auto HalfSize = l_view.getSize() / 2.f; \n  float OuterRadius = std::sqrt((HalfSize.x * HalfSize.x) + \n    (HalfSize.y * HalfSize.y)); \n  float AbsoluteDistance = GetDistance(l_view.getCenter(), \n    l_circleCenter); \n  if (AbsoluteDistance > OuterRadius + l_circleRad) { \n    return false; \n  } \n  float InnerRadius = std::min(l_view.getSize().x, \n    l_view.getSize().y) / 2.f; \n  if (AbsoluteDistance < InnerRadius + l_circleRad){return true;} \n  glm::vec2 dir = { \n    l_circleCenter.x - l_view.getCenter().x, \n    l_circleCenter.y - l_view.getCenter().y \n  }; \n  dir = glm::normalize(dir); \n  sf::Vector2f point = l_circleCenter + \n    sf::Vector2f(l_circleRad * dir.x, l_circleRad * dir.y); \n  auto rect = sf::FloatRect( \n    l_view.getCenter() - HalfSize, \n    l_view.getSize()); \n  return rect.contains(point); \n} \n\n```", "```cpp\nvoid LightManager::RenderScene() { \n  ... \n  std::vector<LightBase*> unculled; \n  for (auto& light : m_lights) { \n    if (!Utils::CircleInView(currentView, \n      { light.m_lightPos.x, light.m_lightPos.y }, \n      light.m_radius)) \n    { continue; } \n    unculled.emplace_back(&light); \n  } \n  auto& beginning = unculled.begin(); \n  auto passes = static_cast<int>(std::ceil( \n    static_cast<float>(unculled.size()) / LightsPerPass)); \n  if (passes == 0) { passes = 1; } \n\n  for (int pass = 0; pass < passes; ++pass) { \n    ... \n    for (int lightID = 0; lightID < LightsPerPass; ++lightID) { \n      ... \n      DrawShadowMap(ShadowPassShaderHandle, **light, lightID); \n      ... \n    } \n    ... \n    for (int lightID = 0; lightID < LightCount; ++lightID) { \n      ... \n      SubmitLightUniforms(LightPassShaderHandle,lightID, **light); \n      ... \n    } \n    ... \n    renderer->SwapTextures(); \n  } \n  ... \n} \n\n```"]