["```cpp\n$ cat testcode.ll\ndeclare i32 @strlen(i8*) readonly nounwind\ndefine void @test() {\n call i32 @strlen( i8* null )\n ret void\n}\n\n```", "```cpp\nnamespace llvm {\n…\n…\nvoid initializeMYADCEPass(PassRegistry&);    // Add this line\n```", "```cpp\nvoid LLVMAddMYAggressiveDCEPass(LLVMPassManagerRef PM);\n```", "```cpp\nFunctionPass *createMYAggressiveDCEPass();\n```", "```cpp\ninitializeMergedLoadStoreMotionPass(Registry);  // already present in the file\ninitializeMYADCEPass(Registry);    // add this line\ninitializeNaryReassociatePass(Registry);  // already present in the file\n…\n…\nvoid LLVMAddMemCpyOptPass(LLVMPassManagerRef PM) {\n  unwrap(PM)->add(createMemCpyOptPass());\n}\n\n// add the following three lines\nvoid LLVMAddMYAggressiveDCEPass(LLVMPassManagerRef PM) {\n  unwrap(PM)->add(createMYAggressiveDCEPass());\n}\n\nvoid LLVMAddPartiallyInlineLibCallsPass(LLVMPassManagerRef PM) {\n  unwrap(PM)->add(createPartiallyInlineLibCallsPass());\n}\n…\n```", "```cpp\n    #include \"llvm/Transforms/Scalar.h\"\n    #include \"llvm/ADT/DepthFirstIterator.h\"\n    #include \"llvm/ADT/SmallPtrSet.h\"\n    #include \"llvm/ADT/SmallVector.h\"\n    #include \"llvm/ADT/Statistic.h\"\n    #include \"llvm/IR/BasicBlock.h\"\n    #include \"llvm/IR/CFG.h\"\n    #include \"llvm/IR/InstIterator.h\"\n    #include \"llvm/IR/Instructions.h\"\n    #include \"llvm/IR/IntrinsicInst.h\"\n    #include \"llvm/Pass.h\"\n    using namespace llvm;\n    ```", "```cpp\n    namespace {\n    struct MYADCE : public FunctionPass {\n      static char ID; // Pass identification, replacement for typeid\n      MYADCE() : FunctionPass(ID) {\n        initializeMYADCEPass(*PassRegistry::getPassRegistry());\n      }\n\n      bool runOnFunction(Function& F) override;\n\n      void getAnalysisUsage(AnalysisUsage& AU) const override {\n        AU.setPreservesCFG();\n      }\n    };\n    }\n    ```", "```cpp\n    char MYADCE::ID = 0;\n    INITIALIZE_PASS(MYADCE, \"myadce\", \"My Aggressive Dead Code Elimination\", false, false)\n    ```", "```cpp\n    bool MYADCE::runOnFunction(Function& F) {\n      if (skipOptnoneFunction(F))\n        return false;\n\n      SmallPtrSet<Instruction*, 128> Alive;\n      SmallVector<Instruction*, 128> Worklist;\n\n      // Collect the set of \"root\" instructions that are known live.\n      for (Instruction &I : inst_range(F)) {\n        if (isa<TerminatorInst>(I) || isa<DbgInfoIntrinsic>(I) || isa<LandingPadInst>(I) || I.mayHaveSideEffects()) {\n          Alive.insert(&I);\n          Worklist.push_back(&I);\n        }\n      }\n\n      // Propagate liveness backwards to operands.\n      while (!Worklist.empty()) {\n        Instruction *Curr = Worklist.pop_back_val();\n        for (Use &OI : Curr->operands()) {\n          if (Instruction *Inst = dyn_cast<Instruction>(OI))\n            if (Alive.insert(Inst).second)\n              Worklist.push_back(Inst);\n        }\n      }\n\n    // the instructions which are not in live set are considered dead in this pass. The instructions which do not effect the control flow, return value and do not have any side effects are hence deleted.\n      for (Instruction &I : inst_range(F)) {\n        if (!Alive.count(&I)) {\n          Worklist.push_back(&I);\n          I.dropAllReferences();\n        }\n      }\n\n      for (Instruction *&I : Worklist) {\n        I->eraseFromParent();\n      }\n\n      return !Worklist.empty();\n    }\n    }\n\n    FunctionPass *llvm::createMYAggressiveDCEPass() {\n      return new MYADCE();\n    }\n    ```", "```cpp\n    $ opt -myadce -S testcode.ll\n\n    ; ModuleID = 'testcode.ll'\n\n    ; Function Attrs: nounwind readonly\n    declare i32 @strlen(i8*) #0\n\n    define void @test() {\n     ret void\n    }\n\n    ```", "```cpp\n$ cat testcode.c\ndefine i32 @inner1() alwaysinline {\n ret i32 1\n}\ndefine i32 @outer1() {\n %r = call i32 @inner1()\n ret i32 %r\n}\n\n```", "```cpp\n    #include \"llvm/Transforms/IPO.h\"\n    #include \"llvm/ADT/SmallPtrSet.h\"\n    #include \"llvm/Analysis/AliasAnalysis.h\"\n    #include \"llvm/Analysis/AssumptionCache.h\"\n    #include \"llvm/Analysis/CallGraph.h\"\n    #include \"llvm/Analysis/InlineCost.h\"\n    #include \"llvm/IR/CallSite.h\"\n    #include \"llvm/IR/CallingConv.h\"\n    #include \"llvm/IR/DataLayout.h\"\n    #include \"llvm/IR/Instructions.h\"\n    #include \"llvm/IR/IntrinsicInst.h\"\n    #include \"llvm/IR/Module.h\"\n    #include \"llvm/IR/Type.h\"\n    #include \"llvm/Transforms/IPO/InlinerPass.h\"\n\n    using namespace llvm;\n\n    ```", "```cpp\n    namespace {\n\n    class MyInliner : public Inliner {\n     InlineCostAnalysis *ICA;\n\n    public:\n     MyInliner() : Inliner(ID, -2000000000,\n    /*InsertLifetime*/ true),\n     ICA(nullptr) {\n     initializeMyInlinerPass(*PassRegistry::getPassRegistry());\n     }\n\n     MyInliner(bool InsertLifetime)\n     : Inliner(ID, -2000000000, InsertLifetime), ICA(nullptr) {\n     initializeMyInlinerPass(*PassRegistry::getPassRegistry());\n     }\n\n     static char ID;\n\n     InlineCost getInlineCost(CallSite CS) override;\n\n     void getAnalysisUsage(AnalysisUsage &AU) const override;\n     bool runOnSCC(CallGraphSCC &SCC) override;\n\n     using llvm::Pass::doFinalization;\n     bool doFinalization(CallGraph &CG) override {\n     return removeDeadFunctions(CG, /*AlwaysInlineOnly=*/ true);\n     }\n    };\n    }\n\n    ```", "```cpp\n    char MyInliner::ID = 0;\n    INITIALIZE_PASS_BEGIN(MyInliner, \"my-inline\",\n     \"Inliner for always_inline functions\", false, false)\n    INITIALIZE_AG_DEPENDENCY(AliasAnalysis)\n    INITIALIZE_PASS_DEPENDENCY(AssumptionTracker)\n    INITIALIZE_PASS_DEPENDENCY(CallGraphWrapperPass)\n    INITIALIZE_PASS_DEPENDENCY(InlineCostAnalysis)\n    INITIALIZE_PASS_END(MyInliner, \"my-inline\",\n     \"Inliner for always_inline functions\", false, false)\n\n    Pass *llvm::createMyInlinerPass() { return new MyInliner(); }\n\n    Pass *llvm::createMynlinerPass(bool InsertLifetime) {\n     return new MyInliner(InsertLifetime);\n    }\n\n    ```", "```cpp\n    InlineCost MyInliner::getInlineCost(CallSite CS) {\n     Function *Callee = CS.getCalledFunction();\n    if (Callee && !Callee->isDeclaration() &&\n     CS.hasFnAttr(Attribute::AlwaysInline) &&\n     ICA->isInlineViable(*Callee))\n     return InlineCost::getAlways();\n\n     return InlineCost::getNever();\n    }\n\n    ```", "```cpp\n    bool MyInliner::runOnSCC(CallGraphSCC &SCC) {\n     ICA = &getAnalysis<InlineCostAnalysis>();\n     return Inliner::runOnSCC(SCC);\n    }\n\n    void MyInliner::getAnalysisUsage(AnalysisUsage &AU) const {\n     AU.addRequired<InlineCostAnalysis>();\n     Inliner::getAnalysisUsage(AU);\n    }\n\n    ```", "```cpp\n    $ opt -inline-threshold=0 -always-inline -S test.ll\n\n    ; ModuleID = 'test.ll'\n\n    ; Function Attrs: alwaysinline\n    define i32 @inner1() #0 {\n     ret i32 1\n    }\n    define i32 @outer1() {\n     ret i32 1\n    }\n\n    ```", "```cpp\n    $ cat memcopytest.ll\n    @cst = internal constant [3 x i32] [i32 -1, i32 -1, i32 -1], align 4\n\n    declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) nounwind\n    declare void @foo(i32*) nounwind\n\n    define void @test1() nounwind {\n     %arr = alloca [3 x i32], align 4\n     %arr_i8 = bitcast [3 x i32]* %arr to i8*\n     call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arr_i8, i8* bitcast ([3 x i32]* @cst to i8*), i64 12, i32 4, i1 false)\n     %arraydecay = getelementptr inbounds [3 x i32], [3 x i32]* %arr, i64 0, i64 0\n     call void @foo(i32* %arraydecay) nounwind\n     ret void\n    }\n\n    ```", "```cpp\n    $ opt -memcpyopt -S memcopytest.ll\n    ; ModuleID = ' memcopytest.ll'\n\n    @cst = internal constant [3 x i32] [i32 -1, i32 -1, i32 -1], align 4\n\n    ; Function Attrs: nounwind\n    declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #0\n\n    ; Function Attrs: nounwind\n    declare void @foo(i32*) #0\n\n    ; Function Attrs: nounwind\n    define void @test1() #0 {\n     %arr = alloca [3 x i32], align 4\n     %arr_i8 = bitcast [3 x i32]* %arr to i8*\n     call void @llvm.memset.p0i8.i64(i8* %arr_i8, i8 -1, i64 12, i32 4, i1 false)\n     %arraydecay = getelementptr inbounds [3 x i32]* %arr, i64 0, i64 0\n     call void @foo(i32* %arraydecay) #0\n     ret void\n    }\n\n    ; Function Attrs: nounwind\n    declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #0\n\n    attributes #0 = { nounwind }\n\n    ```", "```cpp\ndefine i32 @test19(i32 %x, i32 %y, i32 %z) {\n %xor1 = xor i32 %y, %z\n %or = or i32 %x, %xor1\n %xor2 = xor i32 %x, %z\n %xor3 = xor i32 %xor2, %y\n %res = xor i32 %or, %xor3\n ret i32 %res\n}\n```", "```cpp\n    if (match(Op0I, m_Or(m_Xor(m_Value(B), m_Value(C)), m_Value(A))) &&\n            match(Op1I, m_Xor( m_Xor(m_Specific(A), m_Specific(C)), m_Specific(B)))) {\n          return BinaryOperator::CreateAnd(A, Builder->CreateXor(B,C)); }\n    ```", "```cpp\n    Opt –instcombine –S testcode.ll\n    define i32 @test19(i32 %x, i32 %y, i32 %z) {\n    %1 = xor i32 %y, %z\n     %res = and i32 %1, %x\n     ret i32 %res\n    }\n\n    ```", "```cpp\n    $ cat testlicm.ll\n    define void @testfunc(i32 %i) {\n    ; <label>:0\n     br label %Loop\n    Loop:        ; preds = %Loop, %0\n     %j = phi i32 [ 0, %0 ], [ %Next, %Loop ]        ; <i32> [#uses=1]\n     %i2 = mul i32 %i, 17        ; <i32> [#uses=1]\n     %Next = add i32 %j, %i2        ; <i32> [#uses=2]\n     %cond = icmp eq i32 %Next, 0        ; <i1> [#uses=1]\n     br i1 %cond, label %Out, label %Loop\n    Out:        ; preds = %Loop\n     ret void\n    }\n\n    ```", "```cpp\n    $ opt licmtest.ll -licm -S\n    ; ModuleID = 'licmtest.ll'\n\n    define void @testfunc(i32 %i) {\n     %i2 = mul i32 %i, 17\n     br label %Loop\n\n    Loop:                                             ; preds = %Loop, %0\n     %j = phi i32 [ 0, %0 ], [ %Next, %Loop ]\n     %Next = add i32 %j, %i2\n     %cond = icmp eq i32 %Next, 0\n     br i1 %cond, label %Out, label %Loop\n\n    Out:                                              ; preds = %Loop\n     ret void\n    }\n\n    ```", "```cpp\n    $ cat deletetest.ll\n    define void @foo(i64 %n, i64 %m) nounwind {\n    entry:\n     br label %bb\n\n    bb:\n     %x.0 = phi i64 [ 0, %entry ], [ %t0, %bb2 ]\n     %t0 = add i64 %x.0, 1\n     %t1 = icmp slt i64 %x.0, %n\n     br i1 %t1, label %bb2, label %return\n    bb2:\n     %t2 = icmp slt i64 %x.0, %m\n     br i1 %t1, label %bb, label %return\n\n    return:\n     ret void\n    }\n\n    ```", "```cpp\n    $ opt deletetest.ll -loop-deletion -S\n    ; ModuleID = \"deletetest.ll'\n\n    ; Function Attrs: nounwind\n    define void @foo(i64 %n, i64 %m) #0 {\n    entry:\n     br label %return\n\n    return:                                           ; preds = %entry\n     ret void\n    }\n\n    attributes #0 = { nounwind }\n\n    ```", "```cpp\n    $ cat testreassociate.ll\n    define i32 @test(i32 %b, i32 %a) {\n     %tmp.1 = add i32 %a, 1234\n     %tmp.2 = add i32 %b, %tmp.1\n     %tmp.4 = xor i32 %a, -1\n     ; (b+(a+1234))+~a -> b+1233\n     %tmp.5 = add i32 %tmp.2, %tmp.4\n     ret i32 %tmp.5\n    }\n\n    ```", "```cpp\n    $ opt testreassociate.ll  –reassociate –die –S\n    define i32 @test(i32 %b, i32 %a) {\n    %tmp.5 = add i32 %b, 1233\n    ret i32 %tmp.5\n    }\n\n    ```", "```cpp\nif (!BinaryOperator::isNeg(TheOp) && !BinaryOperator::isNot(TheOp))\n      continue;\n\n    Value *X = nullptr;\n    …\n    …\n    else if (BinaryOperator::isNot(TheOp))\n      X = BinaryOperator::getNotArgument(TheOp);\n\nunsigned FoundX = FindInOperandList(Ops, i, X);\n```", "```cpp\nif (BinaryOperator::isNot(TheOp)) {\n      Value *V = Constant::getAllOnesValue(X->getType());\n      Ops.insert(Ops.end(), ValueEntry(getRank(V), V));\n      e += 1;\n    }\n```", "```cpp\ndefine i32 @hadd(i32* %a) {\nentry:\n    %0 = load i32* %a, align 4\n    %arrayidx1 = getelementptr inbounds i32* %a, i32 1\n    %1 = load i32* %arrayidx1, align 4\n    %add = add nsw i32 %0, %1\n    %arrayidx2 = getelementptr inbounds i32* %a, i32 2\n    %2 = load i32* %arrayidx2, align 4\n    %add3 = add nsw i32 %add, %2\n    %arrayidx4 = getelementptr inbounds i32* %a, i32 3\n    %3 = load i32* %arrayidx4, align 4\n    %add5 = add nsw i32 %add3, %3\n    ret i32 %add5\n}\n```", "```cpp\n    bool matchFlatReduction(PHINode *Phi, BinaryOperator *B, const DataLayout *DL) {\n\n      if (!B)\n        return false;\n\n      if (B->getType()->isVectorTy() ||\n        !B->getType()->isIntegerTy())\n        return false;\n\n    ReductionOpcode = B->getOpcode();\n    ReducedValueOpcode = 0;\n    ReduxWidth = MinVecRegSize / DL->getTypeAllocSizeInBits(B->getType());\n    ReductionRoot = B;\n    ReductionPHI = Phi;\n\n    if (ReduxWidth < 4)\n      return false;\n    if (ReductionOpcode != Instruction::Add)\n      return false;\n\n    SmallVector<BinaryOperator *, 32> Stack;\n    ReductionOps.push_back(B);\n    ReductionOpcode = B->getOpcode();\n    Stack.push_back(B);\n\n    // Traversal of the tree.\n    while (!Stack.empty()) {\n      BinaryOperator *Bin = Stack.back();\n      if (Bin->getParent() != B->getParent())\n        return false;\n      Value *Op0 = Bin->getOperand(0);\n      Value *Op1 = Bin->getOperand(1);\n      if (!Op0->hasOneUse() || !Op1->hasOneUse())\n        return false;\n      BinaryOperator *Op0Bin = dyn_cast<BinaryOperator>(Op0); BinaryOperator *Op1Bin = dyn_cast<BinaryOperator>(Op1); Stack.pop_back();\n\n      // Do not handle case where both the operands are binary\n    //operators\n      if (Op0Bin && Op1Bin)\n        return false;\n      // Both the operands are not binary operator.\n      if (!Op0Bin && !Op1Bin) {\n        ReducedVals.push_back(Op1);\n        ReducedVals.push_back(Op0);\n\n        ReductionOps.push_back(Bin);\n        continue;\n    }\n\n    // One of the Operand is binary operand, push that into stack\n    // for further processing. Push the other non-binary operand //into ReducedVals.\n      if (Op0Bin) {\n        if (Op0Bin->getOpcode() != ReductionOpcode)\n          return false;\n        Stack.push_back(Op0Bin);\n        ReducedVals.push_back(Op1);\n\n        ReductionOps.push_back(Op0Bin);\n      }\n\n      if (Op1Bin) {\n\n        if (Op1Bin->getOpcode() != ReductionOpcode)\n          return false;\n        Stack.push_back(Op1Bin);\n        ReducedVals.push_back(Op0);\n        ReductionOps.push_back(Op1Bin);\n      }\n    }\n    SmallVector<Value *, 16> Temp;\n    // Reverse the loads from a[3], a[2], a[1], a[0]\n\n    // to a[0], a[1], a[2], a[3] for checking incremental\n    // consecutiveness further ahead.\n    while (!ReducedVals.empty())\n      Temp.push_back(ReducedVals.pop_back_val());\n    ReducedVals.clear();\n    for (unsigned i = 0, e = Temp.size(); i < e; ++i)\n      ReducedVals.push_back(Temp[i]);\n      return true;\n    }\n    ```", "```cpp\n    int HAddCost = INT_MAX;\n    // If horizontal addition pattern is identified, calculate cost.\n\n    // Such horizontal additions can be modeled into combination of\n\n    // shuffle sub-vectors and vector adds and one single extract element\n\n    // from last resultant vector.\n\n    // e.g. a[0]+a[1]+a[2]+a[3] can be modeled as // %1 = load <4 x> %0\n    // %2 = shuffle %1 <2, 3, undef, undef>\n    // %3 = add <4 x> %1, %2\n    // %4 = shuffle %3 <1, undef, undef, undef>\n\n    // %5 = add <4 x> %3, %4\n\n    // %6 = extractelement %5 <0>\n    if (IsHAdd) {\n      unsigned VecElem = VecTy->getVectorNumElements();\n      unsigned NumRedxLevel = Log2_32(VecElem);\n      HAddCost = NumRedxLevel *\n       (TTI->getArithmeticInstrCost(ReductionOpcode, VecTy) + TTI->getShuffleCost(TargetTransformInfo::SK_ExtractSubvector, VecTy, VecElem / 2, VecTy)) + TTI->getVectorInstrCost(Instruction::ExtractElement, VecTy, 0);\n      }\n    ```", "```cpp\n    VecReduxCost = HAddCost < VecReduxCost ? HAddCost : VecReduxCost;\n    ```", "```cpp\n    // Try to vectorize horizontal reductions feeding into a return.\n    if (ReturnInst *RI = dyn_cast<ReturnInst>(it))\n\n    if (RI->getNumOperands() != 0)\n    if (BinaryOperator *BinOp =\n       dyn_cast<BinaryOperator>(RI->getOperand(0))) {\n\n      DEBUG(dbgs() << \"SLP: Found a return to vectorize.\\n\");\n\n      HorizontalReduction HorRdx;\n      IsReturn = true;\n\n      if ((HorRdx.matchFlatReduction(nullptr, BinOp, DL) && HorRdx.tryToReduce(R, TTI)) || tryToVectorizePair(BinOp->getOperand(0), BinOp->getOperand(1), R)) {\n      Changed = true;\n\n      it = BB->begin();\n      e = BB->end();\n      continue;\n\n    }\n    }\n    ```", "```cpp\n    static bool IsReturn = false;\n    static bool IsHAdd = false;\n    ```", "```cpp\n    if (VectorizableTree.size() == 1 && IsReturn && IsHAdd)return true;\n    ```", "```cpp\n    define i32 @hadd(i32* %a) {\n    entry:\n     %0 = load i32* %a, align 4\n     %arrayidx1 = getelementptr inbounds i32* %a, i32 1\n     %1 = load i32* %arrayidx1, align 4\n     %add = add nsw i32 %0, %1\n     %arrayidx2 = getelementptr inbounds i32* %a, i32 2\n     %2 = load i32* %arrayidx2, align 4\n     %add3 = add nsw i32 %add, %2\n     %arrayidx4 = getelementptr inbounds i32* %a, i32 3\n     %3 = load i32* %arrayidx4, align 4\n     %add5 = add nsw i32 %add3, %3\n     ret i32 %add5\n    }\n\n    ```", "```cpp\n    $ opt -basicaa -slp-vectorizer -mtriple=aarch64-unknown-linux-gnu -mcpu=cortex-a57\n\n    ```", "```cpp\n    define i32 @hadd(i32* %a) {\n\n    entry:\n\n    %0 = bitcast i32* %a to <4 x i32>*\n    %1 = load <4 x i32>* %0, align 4 %rdx.shuf = shufflevector <4 x i32> %1, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>\n\n    %bin.rdx = add <4 x i32> %1,\n\n    %rdx.shuf %rdx.shuf1 = shufflevector <4 x i32>\n\n    %bin.rdx, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef> %bin.rdx2 = add <4 x i32> %bin.rdx, %rdx.shuf1\n\n    %2 = extractelement <4 x i32> %bin.rdx2, i32 0\n\n    ret i32 %2\n\n    }\n\n    ```", "```cpp\n    $ cat teststripdebug.ll\n    @x = common global i32 0                          ; <i32*> [#uses=0]\n\n    define void @foo() nounwind readnone optsize ssp {\n    entry:\n     tail call void @llvm.dbg.value(metadata i32 0, i64 0, metadata !5, metadata !{}), !dbg !10\n     ret void, !dbg !11\n    }\n\n    declare void @llvm.dbg.value(metadata, i64, metadata, metadata) nounwind readnone\n\n    !llvm.dbg.cu = !{!2}\n    !llvm.module.flags = !{!13}\n    !llvm.dbg.sp = !{!0}\n    !llvm.dbg.lv.foo = !{!5}\n    !llvm.dbg.gv = !{!8}\n\n    !0 = !MDSubprogram(name: \"foo\", linkageName: \"foo\", line: 2, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: true, file: !12, scope: !1, type: !3, function: void ()* @foo)\n    !1 = !MDFile(filename: \"b.c\", directory: \"/tmp\")\n    !2 = !MDCompileUnit(language: DW_LANG_C89, producer: \"4.2.1 (Based on Apple Inc. build 5658) (LLVM build)\", isOptimized: true, emissionKind: 0, file: !12, enums: !4, retainedTypes: !4)\n    !3 = !MDSubroutineType(types: !4)\n    !4 = !{null}\n    !5 = !MDLocalVariable(tag: DW_TAG_auto_variable, name: \"y\", line: 3, scope: !6, file: !1, type: !7)\n    !6 = distinct !MDLexicalBlock(line: 2, column: 0, file: !12, scope: !0)\n    !7 = !MDBasicType(tag: DW_TAG_base_type, name: \"int\", size: 32, align: 32, encoding: DW_ATE_signed)\n    !8 = !MDGlobalVariable(name: \"x\", line: 1, isLocal: false, isDefinition: true, scope: !1, file: !1, type: !7, variable: i32* @x)\n    !9 = !{i32 0}\n    !10 = !MDLocation(line: 3, scope: !6)\n    !11 = !MDLocation(line: 4, scope: !6)\n    !12 = !MDFile(filename: \"b.c\", directory: \"/tmp\")\n    !13 = !{i32 1, !\"Debug Info Version\", i32 3}\n\n    ```", "```cpp\n    $ opt -strip-debug teststripdebug.ll  -S\n    ; ModuleID = ' teststripdebug.ll'\n\n    @x = common global i32 0\n\n    ; Function Attrs: nounwind optsize readnone ssp\n    define void @foo() #0 {\n    entry:\n     ret void\n    }\n\n    attributes #0 = { nounwind optsize readnone ssp }\n\n    !llvm.module.flags = !{!0}\n\n    !0 = metadata !{i32 1, metadata !\"Debug Info Version\", i32 2}\n\n    ```", "```cpp\n    $ cat simpletest.ll\n    declare void @nounwind() nounwind\n\n    define internal void @foo() {\n     call void @nounwind()\n     ret void\n    }\n\n    define i32 @caller() {\n     invoke void @foo( )\n     to label %Normal unwind label %Except\n\n    Normal:        ; preds = %0\n     ret i32 0\n\n    Except:        ; preds = %0\n     landingpad { i8*, i32 } personality i32 (...)* @__gxx_personality_v0\n     catch i8* null\n     ret i32 1\n    }\n    declare i32 @__gxx_personality_v0(...)\n\n    ```", "```cpp\n    $ opt -prune-eh -S simpletest.ll\n    ; ModuleID = 'simpletest.ll'\n\n    ; Function Attrs: nounwind\n    declare void @nounwind() #0\n\n    ; Function Attrs: nounwind\n    define internal void @foo() #0 {\n     call void @nounwind()\n     ret void\n    }\n    ; Function Attrs: nounwind\n    define i32 @caller() #0 {\n     call void @foo()\n     br label %Normal\n\n    Normal:                                           ; preds = %0\n     ret i32 0\n    }\n\n    declare i32 @__gxx_personality_v0(...)\n\n    attributes #0 = { nounwind }\n\n    ```"]