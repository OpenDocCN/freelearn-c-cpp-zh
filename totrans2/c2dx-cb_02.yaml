- en: Chapter 2. Creating Sprites
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we''re going to create sprites, animations, and actions. The
    following topics will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Creating sprites
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the sprite's position and size
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating sprites
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating animations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling actions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling functions with actions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easing actions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a texture atlas
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a batch node
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using 3D models
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting collisions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a shape
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sprites are a 2D image. We can animate and transform them by changing their
    properties. Sprites are basically, items and your game is not complete without
    them. Sprites are not only displayed, but also transformed or moved. In this chapter,
    you will learn how to create sprites using 3D models in Cocos2d-x, and then, we
    will go through the advantages of sprites.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Creating sprites
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sprites are the most important things in games. They are images that are displayed
    on the screen. In this recipe, you will learn how to create a sprite and display
    it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can add the image that you made in the previous chapter into your project,
    by performing the following steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Copy the image into the `Resource` folder `MyGame/Resources/res`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your project in Xcode.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Product** | **Clean** from the Xcode menu.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have to clean and build when you add new images into the `resource` folder.
    If you did not clean after adding new images, then Xcode will not recognize them.
    Finally, after you add the `run_01.png` to your project, your project will be
    seen looking like the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B00561_02_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We begin with modifying the `HelloWorld::init` method in the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And then, after we build & run the project, we can see the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B00561_02_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can get the screen size from the `Director::getWinSize` method. The `Director`
    class is a singleton class. You can get the instance using the `getInstance` method.
    So you can get the screen size by `Director::getInstance->getWinSize()`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that you can get an instance of a singleton class in Cocos2d-x using
    the `getInstance` method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Sprites are made from images. You can create a sprite by specifying the image.
    In this case, you create the sprite by `run_01.png` in the `res` folder.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to specify the coordinates of the sprite. In this case, you set
    the sprite in the center of the screen. The `Size` class has the width and height
    property. You can specify the location of the sprite using the `setPosition` method.
    The argument of the `setPosition` method is `Vec2`. `Vec2` has two properties
    as floating point vector, `x` axis coordinate and `y` axis coordinate.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to add the sprite on the layer. A layer is like a transparent
    sheet on the screen. You will learn about layers in [Chapter 4](ch04.html "Chapter 4. Building
    Scenes and Layers"), *Building Scenes and Layers*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: All objects that are displayed on the screen are **node**. Sprite and Layer
    are types of node. If you haven't added it in the other nodes, the node does not
    appear on the screen. You can add a node in the other nodes by the `addChild`
    method.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上显示的所有对象都是**节点**。精灵和层是节点的类型。如果您在其他节点中没有添加它，该节点将不会显示在屏幕上。您可以通过`addChild`方法在其他节点中添加节点。
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: You can set the sprite using the static coordinate. In the following case we
    see that the Sprite position is `(100, 200)`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用静态坐标设置精灵。在以下情况下，我们看到精灵位置是`(100, 200)`。
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Also, you can set the sprite in the center of the screen using C++ operator
    overloading.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用C++运算符重载将精灵设置在屏幕中心。
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you want to remove the sprite from the layer, you can remove it by the following
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从层中移除精灵，可以使用以下代码移除它：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See also
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The `Sprite` class has a lot of properties. You can manipulate them and change
    the sprite's appearance. You will also learn more about layer and the scene, which
    will be explained in [Chapter 4](ch04.html "Chapter 4. Building Scenes and Layers"),
    *Building Scenes and Layers*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sprite`类有很多属性。您可以操作它们并更改精灵的外观。您还将了解更多关于层和场景的内容，这些内容将在[第4章](ch04.html "第4章.
    构建场景和层") *构建场景和层* 中解释。'
- en: Getting the sprite's position and size
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取精灵的位置和大小
- en: There is a certain size and position of the sprite. In this recipe, we explain
    how to view the size and position of the sprite.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵有一个特定的尺寸和位置。在本菜谱中，我们解释了如何查看精灵的尺寸和位置。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To get the sprite position, use the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取精灵位置，请使用以下代码：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To get the sprite size, use the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取精灵大小，请使用以下代码：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: By default, the sprite position is (`0,0`). You can change the sprite position
    using the `setPosition` method and get it using the `getPosition` method. You
    can get the sprite size using the `getContentSize` method. However, you cannot
    change the sprite size by the `setContentSize` method. The `contentsize` is a
    constant value. If you want to change the sprite size, you have to change the
    scale of the sprite. You will learn about the scale in the next recipe.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，精灵位置是(`0,0`)。您可以使用`setPosition`方法更改精灵位置，并使用`getPosition`方法获取它。您可以使用`getContentSize`方法获取精灵大小。但是，您不能通过`setContentSize`方法更改精灵大小。`contentsize`是一个常量值。如果您想更改精灵大小，您必须更改精灵的缩放。您将在下一个菜谱中了解缩放。
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Setting anchor points
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置锚点
- en: '**Anchor point** is a point that you set as a way to specify what part of the
    sprite will be used when setting its position. The anchor point uses a bottom-left
    coordinate system. By default, the anchor point of all Node objects is `(0.5,
    0.5)`. This means that the default anchor point is the center.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**锚点**是一个您设置的点，用作指定在设置位置时将使用精灵的哪个部分。锚点使用左下角坐标系。默认情况下，所有Node对象的锚点为`(0.5, 0.5)`。这意味着默认锚点是中心。'
- en: 'To get the anchor point at the center of the sprite, we use the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取精灵中心的锚点，我们使用以下代码：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To get the anchor point at the bottom-left of the sprite, we use the following
    code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取精灵左下角的锚点，我们使用以下代码：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To get the anchor point at the top-left of the sprite, we use the following
    code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取精灵左上角的锚点，我们使用以下代码：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To get the anchor point at the bottom-right of the sprite, we use the following
    code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取精灵右下角的锚点，我们使用以下代码：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To get the anchor point at the top-right of the sprite, we use the following
    code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取精灵右上角的锚点，我们使用以下代码：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following image shows the various positions of the anchor point:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了锚点的各种位置：
- en: '![Setting anchor points](img/B00561_02_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![设置锚点](img/B00561_02_03.jpg)'
- en: Rectangle
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩形
- en: 'To get the sprite rectangle, use the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取精灵矩形，请使用以下代码：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Rect` is the sprite rectangle that has properties such as `Size` and `Vec2`.
    If the scale is not equal to one, then `Size` in `Rect` will not be equal to the
    `size`, using `getContentSize` method. `Size` of `getContentSize` is the original
    image size. On the other side, `Size` in `Rect` using `getBoundingBox` is the
    size of appearance. For example, when you set the sprite to half scale, the `Size`
    in `Rect` using `getBoundingBox` is half the size, and the `Size` using `getContentSize`
    is the original size. The position and size of a sprite is a very important point
    when you need to specify the sprites on the screen.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rect`是具有`Size`和`Vec2`等属性的精灵矩形。如果缩放不等于一，则`Rect`中的`Size`将不等于`size`，使用`getContentSize`方法。`getContentSize`的`Size`是原始图像大小。另一方面，`Rect`中使用`getBoundingBox`的`Size`是外观的大小。例如，当您将精灵设置为半缩放时，`Rect`中使用`getBoundingBox`的`Size`是大小的一半，而使用`getContentSize`的`Size`是原始大小。精灵的位置和大小在您需要指定屏幕上的精灵时是一个非常重要的点。'
- en: See also
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Detecting collisions* recipe, where you can detect collision using `rect`.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检测碰撞*配方，您可以使用`rect`检测碰撞。'
- en: Manipulating sprites
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作精灵
- en: A Sprite is a 2D image that can be animated or transformed by changing its properties,
    including its rotation, position, scale, color, and so on. After creating a sprite
    you can obtain access to the variety of properties it has, which can be manipulated.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵是一个可以通过改变其属性（包括旋转、位置、缩放、颜色等）进行动画或变换的2D图像。创建精灵后，您可以访问其各种属性，并进行操作。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Rotate
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旋转
- en: You can change the sprite's rotation to positive or negative degrees.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将精灵的旋转更改为正或负度数。
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can get the rotation value using `getRotation` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`getRotation`方法获取旋转值。
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The positive value rotates it clockwise, and the negative value rotates it
    counter clockwise. The default value is zero. The preceding code rotates the sprite
    30 degrees clockwise, as shown in the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正值将其顺时针旋转，负值将其逆时针旋转。默认值是零。以下代码将精灵旋转30度顺时针，如下截图所示：
- en: '![Rotate](img/B00561_02_04.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![旋转](img/B00561_02_04.jpg)'
- en: Scale
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩放
- en: You can change the sprite's scale. The default value is `1.0f`, the original
    size. The following code will scale to half size.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以更改精灵的缩放。默认值是`1.0f`，原始大小。以下代码将缩放到一半大小。
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can also change the width and height separately. The following code will
    scale to half the width only.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以分别更改宽度和高度。以下代码只会将宽度缩放到一半。
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The following will scale to half the height only.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码只会将高度缩放到一半。
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The following code will scale that width to double and the height to half.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将宽度缩放到两倍，高度缩放到一半。
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Scale](img/B00561_02_05.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![缩放](img/B00561_02_05.jpg)'
- en: Skew
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 倾斜
- en: You can change the sprite's skew, either by `X`, `Y` or uniformly for both `X`
    and `Y`. The default value is zero for both `X` and `Y`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`X`、`Y`或同时针对`X`和`Y`均匀地更改精灵的倾斜。对于`X`和`Y`，默认值都是零。
- en: 'The following code adjusts the `X` skew by `20.0`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将`X`倾斜调整为`20.0`：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following code adjusts the `Y` skew by `20.0`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将`Y`倾斜调整为`20.0`：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Skew](img/B00561_02_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![倾斜](img/B00561_02_06.jpg)'
- en: Color
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色
- en: You can change the sprite's color by passing in a `Color3B` object. `Color3B`
    has an RGB value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传递`Color3B`对象来更改精灵的颜色。`Color3B`具有RGB值。
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Color](img/B00561_02_07.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![颜色](img/B00561_02_07.jpg)'
- en: Opacity
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 透明度
- en: You can change the sprite's opacity. The opacity property is set between a value
    from 0 to 255.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以更改精灵的不透明度。不透明度属性设置为0到255之间的值。
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The sprite is fully opaque when it is set to 255, and fully transparent when
    it is set to zero. The default value is always 255.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当精灵设置为255时，它是完全不透明的，当设置为零时，它是完全透明的。默认值始终是255。
- en: '![Opacity](img/B00561_02_08.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![透明度](img/B00561_02_08.jpg)'
- en: Visibility
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可见性
- en: You can change the sprite's visibility by passing in a Boolean value. If it
    is `false`, then the sprite is invisible; if it is `true`, then the sprite is
    visible. The default value is always `true`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传递布尔值来更改精灵的可见性。如果它是`false`，则精灵不可见；如果它是`true`，则精灵可见。默认值始终是`true`。
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to check the sprite's visibility, use the `isVisible` method rather
    than the `getVisible` method. The sprite class does not have the `getVisible`
    method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检查精灵的可见性，请使用`isVisible`方法而不是`getVisible`方法。精灵类没有`getVisible`方法。
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A Sprite has a lot of properties. You can manipulate a sprite using the `setter`
    and `getter` methods.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵有许多属性。您可以使用`setter`和`getter`方法操作精灵。
- en: RGB color is a 3 byte value from zero to 255\. Cocos2d-x provides predefined
    colors.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: RGB颜色是从0到255的3字节值。Cocos2d-x提供了预定义的颜色。
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can find them by looking at the `ccType.h` file in Cocos2d-x.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看Cocos2d-x中的`ccType.h`文件来找到它们。
- en: Creating animations
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动画
- en: When the characters in a game start to move, the game will come alive. There
    are many ways to make animated characters. In this recipe, we will animate a character
    by using multiple images.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏中的角色开始移动时，游戏将变得生动。有许多方法可以制作动画角色。在这个菜谱中，我们将通过使用多个图像来动画化一个角色。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You can create an animation from a series of the following image files:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下一系列图像文件创建动画：
- en: '![Getting ready](img/B00561_02_09.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/B00561_02_09.jpg)'
- en: You need to add the running girl's animation image files to your project and
    clean your project.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将跑步女孩的动画图像文件添加到您的项目中，并清理您的项目。
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Please check the recipe *Creating sprites*, which is the first recipe in this
    chapter, on how to add images to your project.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看本章节的第一个菜谱*创建精灵*，了解如何将图像添加到您的项目中。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: You can create an animation using a series of images. The following code creates
    the running girl's animation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用一系列图像创建动画。以下代码创建了跑步女孩的动画。
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: You can create an animation using the `Animation` class and the `Animate` class.
    They change multiple images at regular intervals. The names of the series image
    files have the serial number, we have added a file name to the `Animation` class
    in the for loop. We can create the formatted string using the `StringUtils` class
    in Cocos2d-x.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Animation`类和`Animate`类创建动画。它们以固定的时间间隔更改多个图像。系列图像文件的名称有序列号，我们在for循环中为`Animation`类添加了文件名。我们可以使用Cocos2d-x中的`StringUtils`类创建格式化的字符串。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`StringUtils` is a very useful class. The `StringUtils::toString` method can
    generate the `std::string` value from a variety of values.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringUtils`是一个非常有用的类。`StringUtils::toString`方法可以从各种值生成`std::string`值。'
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`StringUtils::format` method can generate the `std::string` value using the
    `printf` format.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringUtils::format`方法可以使用`printf`格式生成`std::string`值。'
- en: You can view the log by using CCLOG macro. CCLOG is very useful. You can check
    the value of the variable in the log during the execution of your game. CCLOG
    has the same parameters as a `sprintf` function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用CCLOG宏来查看日志。CCLOG非常有用。您可以在游戏执行期间检查日志中的变量值。CCLOG具有与`sprintf`函数相同的参数。
- en: We will add the file name into the `Animation` instance using the `addSpriteFrameWithFile`
    method. It sets the units of time which the frame takes using `setDelayPerunit`
    method. It is set to restore the original frame when the animation finishes using
    the `setRestoreOriginalFrame` method. True value is to restore the original frame.
    It is set to the number of times the animation is going to loop. Then, create
    the `Animate` instance by passing it with the `Animation` instance that you created
    earlier. Finally, run the `runAction` method by passing in the `Animate` instance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`addSpriteFrameWithFile`方法将文件名添加到`Animation`实例中。它使用`setDelayPerunit`方法设置帧所占用的时间单位。使用`setRestoreOriginalFrame`方法设置为动画结束时恢复原始帧。真值是恢复原始帧。它设置为动画将要循环的次数。然后，通过传递您之前创建的`Animation`实例来创建`Animate`实例。最后，通过传递`Animate`实例来运行`runAction`方法。
- en: If you want to run the animation forever, set `-1` using the `setLoops` method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想永远运行动画，请使用`setLoops`方法设置`-1`。
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the preceding code, you cannot control each animation frame. In such cases,
    you can use the `AnimationFrame` class. This class can control each animation
    frame. You can set the units of time the frame takes using the second argument
    of the `AnimationFrame::create` method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您无法控制每个动画帧。在这种情况下，您可以使用`AnimationFrame`类。这个类可以控制每个动画帧。您可以使用`AnimationFrame::create`方法的第二个参数设置帧所占用的时间单位。
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: See also
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Using a texture atlas* recipe to create an animation using texture atlas
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用纹理图集创建动画*的菜谱'
- en: Creating actions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动作
- en: Cocos2d-x has a lot of actions, for example, move, jump, rotate, and so on.
    We often use these actions in our games. This is similar to an animation, when
    the characters in a game start their action, the game will come alive. In this
    recipe you will learn how to use a lot of actions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x有很多动作，例如移动、跳跃、旋转等。我们在游戏中经常使用这些动作。这类似于动画，当游戏中的角色开始动作时，游戏将变得生动。在这个菜谱中，您将学习如何使用许多动作。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Actions are very important effects in a game. Cocos2d-x allows you to use various
    actions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是游戏中非常重要的效果。Cocos2d-x 允许你使用各种动作。
- en: Move
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动
- en: 'To move a sprite by a specified point over two seconds, you can use the following
    command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两秒内通过指定点移动精灵，你可以使用以下命令：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To move a sprite to a specified point over two seconds, you can use the following
    command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两秒内将精灵移动到指定点，你可以使用以下命令：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Scale
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩放
- en: 'To uniformly scale a sprite by 3x over two seconds, use the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两秒内以 3x 的比例均匀缩放精灵，请使用以下命令：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To scale the `X` axis by 5x, and `Y` axis by 3x over two seconds, use the following
    command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两秒内将 `X` 轴缩放 5x 和 `Y` 轴缩放 3x，请使用以下命令：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To uniformly scale a sprite to 3x over two seconds, use the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两秒内以 3x 的比例均匀缩放精灵，请使用以下命令：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To scale `X` axis to 5x, and `Y` axis to 3x over two seconds, use the following
    command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两秒内将 `X` 轴缩放 5x 和 `Y` 轴缩放 3x，请使用以下命令：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Jump
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳跃
- en: 'To make a sprite jump by a specified point three times over two seconds, use
    the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要使精灵在两秒内跳过指定点三次，请使用以下命令：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To make a sprite jump to a specified point three times over two seconds, use
    the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要使精灵在两秒内跳到指定点三次，请使用以下命令：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Rotate
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旋转
- en: 'To rotate a sprite clockwise by 40 degrees over two seconds, use the following
    command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两秒内顺时针旋转精灵 40 度，请使用以下命令：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To rotate a sprite counterclockwise by 40 degrees over two seconds, use the
    following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两秒内逆时针旋转精灵 40 度，请使用以下命令：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Blink
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闪烁
- en: 'To make a sprite blink five times in two seconds, use the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要使精灵在两秒内闪烁五次，请使用以下命令：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Fade
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 淡入
- en: 'To fade in a sprite in two seconds, use the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两秒内淡入精灵，请使用以下命令：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To fade out a sprite in two seconds, use the following command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两秒内淡出精灵，请使用以下命令：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Skew
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扭曲
- en: 'The following code skews a sprite''s `X` axis by 45 degrees and `Y` axis by
    30 degrees over two seconds:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在两秒内将精灵的 `X` 轴扭曲 45 度和 `Y` 轴扭曲 30 度：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The following code skews a sprite's `X` axis to 45 degrees and `Y` axis to 30
    degrees over two seconds.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在两秒内将精灵的 `X` 轴扭曲到 45 度和 `Y` 轴扭曲到 30 度。
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Tint
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 着色
- en: 'The following code tints a sprite by the specified RGB values:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码通过指定的 RGB 值着色精灵：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following code tints a sprite to the specified RGB values:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将精灵着色到指定的 RGB 值：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`Action` objects make a sprite perform a change to its properties. `MoveTo`,
    `MoveBy`, `ScaleTo`, `ScaleBy` and others, are `Action` objects. You can move
    a sprite from one position to another position using `MoveTo` or `MoveBy`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action` 对象使精灵改变其属性。`MoveTo`、`MoveBy`、`ScaleTo`、`ScaleBy` 等都是 `Action` 对象。你可以使用
    `MoveTo` 或 `MoveBy` 将精灵从一个位置移动到另一个位置。'
- en: You will notice that each `Action` has a `By` and `To` suffix. That's why they
    have different behaviors. The method with the `By` suffix is relative to the current
    state of sprites. The method with the `To` suffix is absolute to the current state
    of sprites. You know that all actions in Cocos2d-x have `By` and `To` suffix,
    and all actions have the same rule as its suffix.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到每个 `Action` 都有一个 `By` 和 `To` 后缀。这就是它们有不同的行为的原因。带有 `By` 后缀的方法是相对于精灵的当前状态。带有
    `To` 后缀的方法是相对于精灵的绝对状态。你知道 Cocos2d-x 中的所有动作都有 `By` 和 `To` 后缀，并且所有动作都有与其后缀相同的规则。
- en: There's more...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When you want to execute a sprite action, you make an action and execute the
    `runAction` method by passing in the `action` instance. If you want to stop the
    action while sprites are running actions, execute the `stopAllActions` method
    or `stopAction` by passing in the `action` instance that you got as the return
    value of the `runAction` method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想执行精灵动作时，你创建一个动作并通过传递 `action` 实例来执行 `runAction` 方法。如果你想在精灵运行动作时停止动作，请执行 `stopAllActions`
    方法或通过传递 `runAction` 方法的返回值作为 `action` 实例的 `stopAction`。
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you run `stopAllActions`, all of the actions that sprite is running will
    be stopped. If you run `stopAction` by passing the `action` instance, that specific
    action will be stopped.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `stopAllActions`，精灵正在运行的所有动作都将停止。如果你通过传递 `action` 实例来运行 `stopAction`，则将停止该特定动作。
- en: Controlling actions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制动作
- en: In the previous recipe, you learned some of the basic actions. However, you
    may want to use more complex actions; for example, rotating a character while
    moving, or moving a character after jumping. In this recipe, you will learn how
    to control actions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，你学习了一些基本动作。然而，你可能想要使用更复杂的行为；例如，在移动时旋转角色，或者在跳跃后移动角色。在这个菜谱中，你将学习如何控制动作。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Sequencing actions
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按顺序执行动作
- en: '`Sequence` is a series of actions to be executed sequentially. This can be
    any number of actions.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sequence` 是一系列要按顺序执行的动作。这可以是一系列任意数量的动作。'
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The preceding command will execute the following actions sequentially:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将按顺序执行以下动作：
- en: Move a sprite 100px to the right over two seconds
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两秒内将精灵向右移动100像素
- en: Rotate a sprite clockwise by 360 degree over two seconds
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两秒内顺时针旋转精灵360度
- en: It takes a total of four seconds to execute these commands.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些命令总共需要四秒。
- en: Spawning actions
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成动作
- en: '`Spawn` is very similar to `Sequence`, except that all actions will run at
    the same time. You can specify any number of actions at the same time.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spawn` 与 `Sequence` 非常相似，不同之处在于所有动作将同时运行。你可以同时指定任意数量的动作。'
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It will execute the following actions at the same time:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它将同时执行以下动作：
- en: Moved a sprite 100px to the right over two seconds
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两秒内将精灵向右移动100像素
- en: Rotated a sprite clockwise by 360 degree over two seconds
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺时针旋转精灵360度
- en: It takes a total of two seconds to execute them.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 执行它们总共需要两秒。
- en: Repeating actions
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复动作
- en: '`Repeat` object is to repeat an action the number of specified times.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Repeat` 对象是为了重复指定次数的动作。'
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding command will execute a `rotate` action five times.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将执行一个 `rotate` 动作五次。
- en: If you want to repeat forever, you can use the `RepeatForever` action.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要无限重复，可以使用 `RepeatForever` 动作。
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Reversing actions
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反转动作
- en: If you generate an `action` instance, you can call a `reverse` method to run
    it in the `reverse` action.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你生成一个 `action` 实例，你可以调用一个 `reverse` 方法以相反的动作运行。
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The preceding code will execute the following actions sequentially:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将按顺序执行以下动作：
- en: Move a sprite 100px to the right over two seconds.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两秒内将精灵向右移动100像素。
- en: Move a sprite 100px to the left over two seconds.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两秒内将精灵向左移动100像素。
- en: In addition, if you generate a sequence action, you can call a `reverse` method
    to run it in the opposite order.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你生成一个序列动作，你可以调用一个 `reverse` 方法以相反的顺序运行它。
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The preceding code will execute the following actions sequentially:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将按顺序执行以下动作：
- en: Move a sprite 100px to the right over two seconds.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两秒内将精灵向右移动100像素。
- en: Rotate a sprite clockwise by 360 degree over two seconds
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两秒内顺时针旋转精灵360度
- en: Rotate a sprite counterclockwise by 360 degree over two seconds
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两秒内逆时针旋转精灵360度
- en: Move a sprite 100px to the left over two seconds.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两秒内将精灵向左移动100像素。
- en: DelayTime
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DelayTime
- en: '`DelayTime` is a delayed action within the specified number of seconds.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`DelayTime` 是在指定秒数内延迟的动作。'
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The preceding command will execute the following actions sequentially:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将按顺序执行以下动作：
- en: Move a sprite 100px to the right over two seconds
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两秒内将精灵向右移动100像素
- en: Delay the next action by two seconds
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟下一个动作两秒
- en: Rotate a sprite clockwise by 360 degree over two seconds
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两秒内顺时针旋转精灵360度
- en: It takes a total of six seconds to execute it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 执行它总共需要六秒。
- en: How it works...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`Sequence` action runs actions sequentially. You can generate a `Sequence`
    instance with actions sequentially. Also, you need to specify `nullptr` last.
    If you did not specify `nullptr`, your game will crash.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sequence` 动作按顺序执行动作。你可以通过按顺序添加动作来生成一个 `Sequence` 实例。此外，你还需要指定 `nullptr` 作为最后一个参数。如果你没有指定
    `nullptr`，你的游戏将会崩溃。'
- en: '![How it works...](img/B00561_02_10.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B00561_02_10.jpg)'
- en: '`Spawn` action runs actions at the same time. You can generate a `Spawn` instance
    with actions and `nullptr` like `Sequence` action.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spawn` 动作同时运行动作。你可以像 `Sequence` 动作一样，通过添加动作和 `nullptr` 来生成一个 `Spawn` 实例。'
- en: '![How it works...](img/B00561_02_11.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B00561_02_11.jpg)'
- en: '`Repeat` and `RepeatForever` actions can run, repeating the same action. `Repeat`
    action has two parameters, the repeating action and the number of repeating actions.
    `RepeatForever` action has one parameter, the repeating action, which is why it
    will run forever.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`Repeat` 和 `RepeatForever` 动作可以运行，重复执行相同的动作。`Repeat` 动作有两个参数，即重复的动作和重复的次数。`RepeatForever`
    动作有一个参数，即重复的动作，这就是为什么它会无限运行。'
- en: Most actions, including `Sequence`, `Spawn` and `Repeat,` have the `reverse`
    method. But like the `MoveTo` method that has the suffix `To`, it does not have
    the `reverse` method; that's why it cannot run the reverse action. `Reverse` method
    generates its reverse action. The following code uses the `MoveBy::reverse` method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数动作，包括 `Sequence`、`Spawn` 和 `Repeat`，都有 `reverse` 方法。但像带有后缀 `To` 的 `MoveTo`
    方法一样，它没有 `reverse` 方法；这就是为什么它不能运行反向动作。`Reverse` 方法生成其反向动作。以下代码使用了 `MoveBy::reverse`
    方法。
- en: '[PRE54]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`DelayTime` action can delay an action after this. The benefit of the `DelayTime`
    action is that you can put it in the `Sequence` action. Combining `DelayTime`
    and `Sequence` is a very powerful feature.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`DelayTime` 动作可以在此之后延迟一个动作。`DelayTime` 动作的好处是您可以将其放入 `Sequence` 动作中。结合 `DelayTime`
    和 `Sequence` 是一个非常强大的功能。'
- en: There's more...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: '`Spawn` produces the same results as running multiple consecutive `runAction`
    statements.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spawn` 产生的结果与运行多个连续的 `runAction` 语句相同。'
- en: '[PRE55]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: However, the benefit of `Spawn` is that you can put it in the `Sequence` action.
    Combining `Spawn` and `Sequence` is a very powerful feature.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Spawn` 的好处是您可以将其放入 `Sequence` 动作中。结合 `Spawn` 和 `Sequence` 是一个非常强大的功能。
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![There''s more...](img/B00561_02_12.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/B00561_02_12.jpg)'
- en: Calling functions with actions
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动作调用函数
- en: You may want to call a function by triggering some actions. For example, you
    are controlling the sequence action, jump, and move, and you want to use a sound
    for the jumping action. In this case, you can call a function by triggering this
    jump action. In this recipe, you will learn how to call a function with actions.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望通过触发某些动作来调用一个函数。例如，您正在控制序列动作、跳跃和移动，并且想要为跳跃动作使用一个声音。在这种情况下，您可以通过触发这个跳跃动作来调用一个函数。在这个菜谱中，您将学习如何通过动作调用一个函数。
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Cocos2d-x has the `CallFunc` object that allows you to create a function and
    pass it to be run in your `Sequence`. This allows you to add your own functionality
    to your `Sequence` action.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x 有一个 `CallFunc` 对象，允许您创建一个函数并将其传递到您的 `Sequence` 中运行。这允许您向您的 `Sequence`
    动作添加自己的功能。
- en: '[PRE57]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding command will execute the following actions sequentially:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将按顺序执行以下动作：
- en: Move a sprite 100px to the right over two seconds
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将精灵向右移动 100 像素，持续两秒
- en: Rotate a sprite clockwise by 360 degrees over two seconds
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将精灵顺时针旋转 360 度，持续两秒
- en: Execute CCLOG
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 CCLOG
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `CallFunc` action is usually used as a callback function. For example, if
    you want to perform a different process after finishing the `move` action. Using
    `CallFunc`, you can call the method at any time. You can use a lambda expression
    as a callback function.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallFunc` 动作通常用作回调函数。例如，如果您想在 `move` 动作完成后执行不同的过程。使用 `CallFunc`，您可以在任何时间调用方法。您可以使用
    lambda 表达式作为回调函数。'
- en: 'If you get a callback with parameters, its code is the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到带有参数的回调，其代码如下：
- en: '[PRE58]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The instance of this parameter is the sprite that is running the action. You
    can get the sprite instance by casting to `Sprite` class.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数的实例是运行动作的精灵。您可以通过将其转换为 `Sprite` 类来获取精灵实例。
- en: Then, you can also specify a callback method. `CallFunc` has `CC_CALLBACK_0`
    macro as an argument. `CC_CALLBACK_0` is a macro for calling a method without
    parameters. If you want to call a method with one parameter, you need to use the
    `CallFuncN` action and `CC_CALLBACK_1` macro. `CC_CALLBACK_1` is a macro for calling
    a method with one argument. A parameter of a method that is called by `CallFuncN`
    is the `Ref` class.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您还可以指定一个回调方法。`CallFunc` 有 `CC_CALLBACK_0` 宏作为参数。`CC_CALLBACK_0` 是一个用于调用不带参数的方法的宏。如果您想调用一个带有一个参数的方法，您需要使用
    `CallFuncN` 动作和 `CC_CALLBACK_1` 宏。`CC_CALLBACK_1` 是一个用于调用一个参数的方法的宏。由 `CallFuncN`
    调用的方法的参数是 `Ref` 类。
- en: 'You can call a method using the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码调用一个方法：
- en: '[PRE59]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To call a method with an argument, you can use the following code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用参数调用一个方法，您可以使用以下代码：
- en: '[PRE60]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: There's more...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'To combine the `CallFuncN` and the `Reverse` action, use the following code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要组合 `CallFuncN` 和 `Reverse` 动作，请使用以下代码：
- en: '[PRE61]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The preceding command will execute the following actions sequentially:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将按顺序执行以下动作：
- en: Move a sprite 100px to the right over two seconds
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将精灵向右移动 100 像素，持续两秒
- en: Rotate a sprite clockwise by 360 degree over two seconds
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将精灵顺时针旋转 360 度，持续两秒
- en: Move a sprite 100px to the left over two seconds
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将精灵向左移动 100 像素，持续两秒
- en: Easing actions
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓动动作
- en: '**Easing** is animating with a specified acceleration to make the animations
    smooth. Ease actions are a good way to fake physics in your game. If you use easing
    actions with your animations, your game looks more natural with smoother animations.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓动**是通过指定加速度来动画化，以使动画平滑。缓动动作是模拟游戏中的物理效果的好方法。如果您在动画中使用缓动动作，您的游戏看起来将更加自然，动画也更加平滑。'
- en: How to do it...
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Let's move a `Sprite` object from `(200,200)` to `(500,200)` with acceleration
    and deceleration.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用加速度和减速度将一个`Sprite`对象从`(200,200)`移动到`(500,200)`。
- en: '[PRE62]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Next, let's drop a `Sprite` object from the top of the screen and make it bounce.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从屏幕顶部掉下一个`Sprite`对象，并使其弹跳。
- en: '[PRE63]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The animation's duration time is the same time regardless of whether you use
    easing. `EaseIn`, `EaseOut` and `EaseInOut` have two parameters—the first parameter
    is the action by easing, the second parameter is rate of easing. If you specified
    this parameter to `1.0f`, this easing action is the same without easing. Anything
    over `1.0f`, means easing is fast, under `1.0f`, and easing will be slow.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 动画的持续时间与您是否使用缓动无关。`EaseIn`、`EaseOut`和`EaseInOut`有两个参数——第一个参数是缓动动作，第二个参数是缓动速率。如果您将此参数指定为`1.0f`，则此缓动动作与不使用缓动相同。任何大于`1.0f`的值，表示缓动速度快，小于`1.0f`，缓动速度将变慢。
- en: The following table are typical easing types.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了典型的缓动类型。
- en: '| Class Name | Description |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 类名 | 描述 |'
- en: '| --- | --- |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `EaseIn` | Moves while accelerating. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `EaseIn` | 在加速的同时移动。|'
- en: '| `EaseOut` | Moves while decelerating. |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `EaseOut` | 在减速的同时移动。|'
- en: '| `EaseInOut` | Start moving while accelerating, stop while decelerating. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `EaseInOut` | 在加速的同时开始移动，在减速时停止。|'
- en: '| `EaseExponentialIn` | It''s similar to `EaseIn`, but meant to accelerate
    at a rate of exponential curve. It is also used with `Out` and `InOut` like `EaseIn`.
    |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `EaseExponentialIn` | 它与`EaseIn`类似，但意味着以指数曲线的速度加速。它也像`EaseIn`一样与`Out`和`InOut`一起使用。|'
- en: '| `EaseSineIn` | It''s similar to `EaseIn`, but meant to accelerate at a rate
    of sin curve. It is also used with `Out` and `InOut` like `EaseIn`. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `EaseSineIn` | 它与`EaseIn`类似，但意味着以正弦曲线的速度加速。它也像`EaseIn`一样与`Out`和`InOut`一起使用。|'
- en: '| `EaseElasticIn` | Moves after shaking slowly, little by little. It is also
    used with `Out` and `InOut` like `EaseIn`. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `EaseElasticIn` | 在慢慢摇动后移动，逐渐移动。它也像`EaseIn`一样与`Out`和`InOut`一起使用。|'
- en: '| `EaseBounceIn` | Moves after bouncing. It is also used with `Out` and `InOut`
    like `EaseIn`. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `EaseBounceIn` | 在弹跳后移动。它也像`EaseIn`一样与`Out`和`InOut`一起使用。|'
- en: '| `EaseBackIn` | Moves after moving in the opposite direction. It is also used
    with `Out` and `InOut` like `EaseIn` |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `EaseBackIn` | 在相反方向移动后开始移动。它也像`EaseIn`一样与`Out`和`InOut`一起使用。|'
- en: 'This is a graph that displays typical easing functions:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个显示典型缓动函数的图表：
- en: '![How it works...](img/B00561_02_13.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/B00561_02_13.jpg)'
- en: Using a texture atlas
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理图集
- en: A **texture atlas** is a large image containing a collection of each sprite.
    We often use a texture atlas rather than individual images. In this recipe, you
    will learn how to use a texture atlas.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**纹理图集**是一个包含每个精灵集合的大图像。我们通常使用纹理图集而不是单个图像。在本教程中，您将学习如何使用纹理图集。'
- en: Getting ready
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You have to add the texture atlas files into your project and clean your project.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须将纹理图集文件添加到您的项目中，并清理您的项目。
- en: '`running.plist`'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`running.plist`'
- en: '`running.png`'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`running.png`'
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Let's try to read the texture altas file and make a sprite from it.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试读取纹理图集文件，并从中创建一个精灵。
- en: '[PRE64]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works...
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Firstly, we loaded the texture atlas file, when the `SpritFrameCache` class
    cached all the images that are included in it. Secondly, you generated a sprite.
    Do not use the `Sprite::create` method to generate it, use the `Sprite::createWithSpriteFrameName`
    method instead. Then, you can handle the sprite as a normal sprite.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载了纹理图集文件，当`SpritFrameCache`类缓存了其中包含的所有图像。其次，您生成了一个精灵。不要使用`Sprite::create`方法来生成它，而是使用`Sprite::createWithSpriteFrameName`方法。然后，您可以像处理普通精灵一样处理该精灵。
- en: A texture atlas is a large image containing a collection of images. It is composed
    of a `plist` file and a `texture` file. You can create a texture atlas by using
    tools. You will learn how to make a texture atlas using tools in [Chapter 10](ch10.html
    "Chapter 10. Improving Games with Extra Features"), *Improving Games with Extra
    Features*. A `plist` file is defined as the original file name of the image and
    it is located within the `texture` file. It also defines the image that will be
    used by the texture atlas. The `plist` file for the texture atlas is xml format
    as follows.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理图集是一个包含多个图像的大图像。它由一个 `plist` 文件和一个 `texture` 文件组成。您可以使用工具创建纹理图集。您将在第 10 章
    [使用额外功能改进游戏](ch10.html "第 10 章。使用额外功能改进游戏") 中学习如何使用工具创建纹理图集，*使用额外功能改进游戏*。`plist`
    文件定义为图像的原始文件名，它位于 `texture` 文件中。它还定义了纹理图集将使用的图像。纹理图集的 `plist` 文件是 xml 格式，如下所示。
- en: '[PRE65]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![How it works...](img/B00561_02_14.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B00561_02_14.jpg)'
- en: Why would we use the texture atlas? Because using the memory efficiently is
    good. Double the memory size is required when the computer loads the image into
    the memory. For example, there are ten images that are 100x100 size. We will use
    nine images, but one image requires memories for 128x128 size. On the other hand,
    texture atlas is one image containing a collection of nine images, where the image
    size is 1000x1000\. It requires a memory size of 1024x1024\. This is why texture
    atlas is used to save wasting unnecessary memory usage.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们会使用纹理图集？因为高效使用内存是好的。当计算机将图像加载到内存中时，需要双倍的内存大小。例如，有十个大小为 100x100 的图像。我们将使用九个图像，但一个图像需要
    128x128 大小的内存。另一方面，纹理图集是一个包含九个图像的图像，其大小为 1000x1000。它需要 1024x1024 的内存大小。这就是为什么使用纹理图集来节省不必要的内存使用。
- en: There's more...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The size of the texture altas can vary in usage depending on the devices. You
    can check the maximum texture size of the device in the following codes:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理图集的大小在使用中会根据设备而变化。您可以在以下代码中检查设备的最大纹理大小：
- en: '[PRE66]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You can generate an animation using a texture atlas and a `plist` file. Firstly,
    you have to add `run_animation.plist` file into your project. The file is shown
    in the following screenshot:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用纹理图集和 `plist` 文件生成动画。首先，您需要将 `run_animation.plist` 文件添加到您的项目中。该文件如下截图所示：
- en: '![There''s more...](img/B00561_02_15.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/B00561_02_15.jpg)'
- en: This `plist` defines a frame animation. In this case, we defined an animation
    called `run` using images from `run_01.png` to `run_08.png`. And the animation
    will loop forever if you specify `-1` to `loop` key's value. The texture atlas
    was specified `running.plist`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `plist` 定义了一个帧动画。在这种情况下，我们使用从 `run_01.png` 到 `run_08.png` 的图像定义了一个名为 `run`
    的动画。如果您将 `-1` 指定给 `loop` 键的值，动画将无限循环。纹理图集指定为 `running.plist`。
- en: Secondly, you need to generate an animation using the `plist` file.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您需要使用 `plist` 文件生成动画。
- en: '[PRE67]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You also need to cache animation data using the `AnimationCache::addAnimationWithFile`
    method with the animation `plist`. Next, you will generate an `Animation` instance
    by specifying `run` that was defined as an animation name in the `plist`. And
    then, you generate an action from the animation. After that, you can animate using
    `runAction` method with the action instance.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要使用 `AnimationCache::addAnimationWithFile` 方法缓存动画数据，使用动画 `plist`。接下来，您将通过指定在
    `plist` 中定义为动画名称的 `run` 来生成一个 `Animation` 实例。然后，您从动画中生成一个动作。之后，您可以使用动作实例通过 `runAction`
    方法进行动画处理。
- en: See also
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: It is very difficult to create a texture atlas manually. You had better use
    a tool such as the `TexturePacker`, which you will learn about in [Chapter 11](ch11.html
    "Chapter 11. Taking Advantages"), *Taking Advantages*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建纹理图集非常困难。您最好使用像 `TexturePacker` 这样的工具，您将在第 11 章 [利用优势](ch11.html "第 11 章。利用优势")
    中了解它。
- en: Using a batch node
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用批处理节点
- en: Renderer speed will be slow if there are a lot of sprites on the screen. However,
    a shooting game needs a lot of images such as bullets, and so on. In this time,
    if renderer speed is slow, the game earns a bad review. In this chapter, you will
    learn how to control a lot of sprites.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果屏幕上有许多精灵，渲染速度会变慢。然而，射击游戏需要很多图像，如子弹等。在这种情况下，如果渲染速度慢，游戏会得到不好的评价。在本章中，您将学习如何控制许多精灵。
- en: How to do it...
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's try to display a lot of sprites using `SpriteBatchNode`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用 `SpriteBatchNode` 显示许多精灵。
- en: '[PRE68]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works...
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `SpriteBatchNode` instance can be used to do the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpriteBatchNode` 实例可用于以下操作：'
- en: Generate a `SpriteBatchNode` instance using a texture
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纹理生成 `SpriteBatchNode` 实例
- en: Add the instance on the layer
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在层上添加实例
- en: Generate sprites using the texture in the `SpriteBatchNode` instance
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SpriteBatchNode` 实例中的纹理生成精灵
- en: Add these sprites on the `SpriteBatchNode` instance
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `SpriteBatchNode` 实例上添加这些精灵
- en: '`SpriteBatchNode` can reference only one texture (one image file or one texture
    atlas). Only the sprites that are contained in that texture can be added to the
    `SpriteBatchNode`. All sprites added to a `SpriteBatchNode` are drawn in one OpenGL
    ES draw call. If the sprites are not added to a `SpriteBatchNode` then an OpenGL
    ES draw call will be needed for each one, which is less efficient.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpriteBatchNode` 只能引用一个纹理（一个图像文件或一个纹理图集）。只有包含在该纹理中的精灵可以添加到 `SpriteBatchNode`
    中。所有添加到 `SpriteBatchNode` 的精灵都会在一个 OpenGL ES 绘制调用中绘制。如果精灵没有添加到 `SpriteBatchNode`，则需要为每个精灵进行一个
    OpenGL ES 绘制调用，这效率较低。'
- en: There's more...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The following screenshot is an executing screen image. You can see three lines
    of information for Cocos2d-x on the left bottom corner. The top line is the number
    of polygon vertices. The middle line is the number of OpenGL ES draw call. You
    understand that a lot of sprites are drawn by one OpenGL ES draw call. The bottom
    line is FPS and seconds per frame.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是执行屏幕图像。您可以在左下角看到关于 Cocos2d-x 的三条信息。最上面一行是多边形的顶点数。中间一行是 OpenGL ES 绘制调用的次数。您理解到许多精灵可以通过一个
    OpenGL ES 绘制调用来绘制。最下面一行是每帧帧数和每帧秒数。
- en: '![There''s more...](img/B00561_02_16.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![更多...](img/B00561_02_16.jpg)'
- en: Tip
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to hide this debug information, you should set a `false` value to
    the `Director::setDisplayStats` method. You will find it in the `AppDelegate.cpp`
    in your project.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想隐藏此调试信息，应将 `Director::setDisplayStats` 方法的值设置为 `false`。您可以在项目的 `AppDelegate.cpp`
    中找到它。
- en: '[PRE69]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Since Cocos2d-x version 3, the `auto batch` function of draw calls has been
    added, Cocos2d-x can draw a lot of sprites with one OpenGL ES draw call, without
    `SpriteBatchNode`. However, it has the following conditions:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Cocos2d-x 版本 3 以来，绘制调用的 `auto batch` 功能已被添加，Cocos2d-x 可以通过一个 OpenGL ES 绘制调用绘制许多精灵，无需
    `SpriteBatchNode`。然而，它有以下条件：
- en: Same texture
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的纹理
- en: Same `BlendFunc`
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的 `BlendFunc`
- en: Using 3D modals
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 3D 模态
- en: Cocos2d-x version 3 supports an exciting new function called **3D modals**.
    We can use and display 3D modals in Cocos2d-x. In this recipe, you will learn
    how to use 3D modals.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x 版本 3 支持一个令人兴奋的新功能，称为 **3D 模态**。我们可以在 Cocos2d-x 中使用和显示 3D 模态。在本教程中，您将学习如何使用
    3D 模态。
- en: Getting ready
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You have to add the 3D object data into your project and clean your project.
    The resource files present in the `COCOS_ROOT/test/cpp-tests/Resources/Sprite3DTest`
    folder are—`body.png` and `girl.c3b`
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须将 3D 对象数据添加到您的项目中，并清理您的项目。在 `COCOS_ROOT/test/cpp-tests/Resources/Sprite3DTest`
    文件夹中存在的资源文件是—`body.png` 和 `girl.c3b`
- en: How to do it...
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's try to display a 3D model and move it.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试显示一个 3D 模型并移动它。
- en: '[PRE70]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '![How to do it...](img/B00561_02_17.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B00561_02_17.jpg)'
- en: How it works...
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can create the 3D sprite from a 3D model in the same way as we made a 2D
    sprite and displayed it. The `Placement` method and the `action` method is exactly
    the same as seen in a 2D sprite. You can create the `Animation3D` instance from
    the animation data that is defined in the 3D model.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像创建 2D 精灵并显示它一样，从 3D 模型创建 3D 精灵。`Placement` 方法和 `action` 方法与 2D 精灵中看到的方法完全相同。您可以从
    3D 模型中定义的动画数据创建 `Animation3D` 实例。
- en: There's more...
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'Finally you will try to move the 3D sprite to the left or right. You will notice
    that 3D sprites differ in appearance depending on their position on the screen
    when you run the following code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将尝试将 3D 精灵向左或向右移动。当您运行以下代码时，您会注意到 3D 精灵的外观取决于它们在屏幕上的位置：
- en: '[PRE71]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: See also
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: You can use 3D data formats such as obj, c3b, and c3t. “c3t” stands for Cocos
    3d binary. You can get this formatted data by converting `fbx` files.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 obj、c3b 和 c3t 等三维数据格式。其中“c3t”代表 Cocos 3d 二进制。您可以通过转换 `fbx` 文件来获取这种格式的数据。
- en: Detecting collisions
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: In an action game, a very important technique is to detect collisions between
    each sprite. However, it is pretty complicated to detect collisions between `rect`
    and `rect` or `rect` and `point`. In this recipe, you will learn how to detect
    collisions easily.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在动作游戏中，一个非常重要的技术是检测每个精灵之间的碰撞。然而，检测 `rect` 和 `rect` 或 `rect` 和 `point` 之间的碰撞相当复杂。在本教程中，您将学习如何轻松地检测碰撞。
- en: How to do it...
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: There are two ways to detect collisions. The first method checks whether a point
    is contained within the rectangle of the sprite.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The second method checks whether two sprite's rectangles have overlapped.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How it works...
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Rect` class has two properties—`size` and `origin`. The `size` property
    is the sprite's size. The origin property is the sprite's left-bottom coordinate.
    Firstly, you get the sprite's `rect` using the `getBoundingBox` method.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B00561_02_18.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
- en: Using the `Rect::containsPoint` method by specifying the coordinate, it is possible
    to detect whether it contains the rectangle. If it contains it, the method returns
    `true`. Using `Rect::intersectsRect` method by specifying another rectangle, it
    is possible to detect whether they overlap. If they overlap, the method returns
    `true`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows a collision between `rect` and `point` or `rect`
    and `rect`:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B00561_02_19.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
- en: There's more...
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Rect` class has more methods including `getMinX`, `getMidX`, `getMaxX`,
    `getMinY`, `getMidY`, `getMaxY` and `unionWithRect`. You can obtain the value
    in the following figure using each of these methods.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/B00561_02_20.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
- en: See also
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you used the physics engine, you can detect collision in a different way.
    Take a look at [Chapter 9](ch09.html "Chapter 9. Controlling Physics"), *Controlling
    Physics*.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to detect collision with consideration of the transparent parts
    of an image, take a look at [Chapter 11](ch11.html "Chapter 11. Taking Advantages"),
    *Taking Advantages*.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a shape
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drawing a shape in Cocos2d-x can be easy using the `DrawNode` class. If you
    can draw various shapes using `DrawNode`, you will to need to prepare textures
    for such shapes. In this section, you will learn how to draw shapes without textures.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, you made a `DrawNode` instance as shown in the following codes. You
    got a window size as well.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Drawing a dot
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can draw a dot by specifying the point, the radius and the color.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '![Drawing a dot](img/B00561_02_21.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
- en: Drawing lines
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can draw lines by specifying the starting point, the destination point,
    and the color. A `1px` thick line will be drawn when you use the `drawLine` method.
    If you want to draw thicker lines, use the `drawSegment` method with a given radius.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '![Drawing lines](img/B00561_02_22.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
- en: Drawing circles
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can draw circles as shown in the following codes. The specification of
    the arguments is as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: center position
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: radius
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: angle
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: segments
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: draw a line to center or not
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: scale x axis
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: scale y axis
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: color
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![Drawing circles](img/B00561_02_23.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
- en: Segment is the number of vertices of the polygon. As you know, the circle is
    a polygon that has a lot of vertices. Increasing the number of vertices is close
    to a smooth circle, but the process load goes up. Incidentally, you should use
    `drawSolidCircle` method if you want to get a solid circle.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a triangle
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can draw a triangle as in the following code with three vertices and the
    color.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码，通过三个顶点和颜色绘制一个三角形。
- en: '[PRE78]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '![Drawing a triangle](img/B00561_02_24.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![绘制三角形](img/B00561_02_24.jpg)'
- en: Drawing rectangles
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制矩形
- en: You can draw rectangles using the following code with the left-bottom point,
    the right-top point, and the color. You can draw fill color if you use the `drawSolidRect`
    method.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码，通过左下角点、右上角点和颜色绘制矩形。如果你使用`drawSolidRect`方法，你可以绘制填充颜色。
- en: '[PRE79]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![Drawing rectangles](img/B00561_02_25.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![绘制矩形](img/B00561_02_25.jpg)'
- en: Drawing a polygon
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制多边形
- en: You can draw a polygon using the following code with the given vertices, the
    number of vertices, filling color, border's width, and border's color.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码，通过给定的顶点、顶点数量、填充颜色、边框宽度和边框颜色绘制一个多边形。
- en: '[PRE80]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '![Drawing a polygon](img/B00561_02_26.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![绘制多边形](img/B00561_02_26.jpg)'
- en: Drawing a Bezier curve
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制贝塞尔曲线
- en: You can draw a Bezier curve as shown in the following code. Using `drawQuadBezier`
    method, you can draw a quadratic Bezier curve, and using `drawCubicBezier` method
    you can draw a cubic Bezier curve. The third argument of the `drawQuadBezier`
    method and the fourth argument of the `drawCubicBezier` method is the number of
    vertices in the same way as the circle.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码绘制一个贝塞尔曲线，如所示。使用`drawQuadBezier`方法，你可以绘制一个二次贝塞尔曲线，使用`drawCubicBezier`方法你可以绘制一个三次贝塞尔曲线。`drawQuadBezier`方法的第三个参数和`drawCubicBezier`方法的第四个参数与圆一样，表示顶点数量。
- en: '[PRE81]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '![Drawing a Bezier curve](img/B00561_02_27.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![绘制贝塞尔曲线](img/B00561_02_27.jpg)'
- en: How it works...
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`DrawNode` is like a mechanism that enables Cocos2d-x to process at a high
    speed, by making drawing shapes all at once and not separately, or one by one.
    When you draw multiple shapes, you should use one `DrawNode` instance, instead
    of multiple `DrawNode` instances and then add multiple shapes in it. Also `DrawNode`
    does not have the concept of depth. Cocos2d-x will draw to the order of the added
    shapes in `DrawNode`.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawNode`就像一个机制，使得Cocos2d-x能够以高速处理，通过一次性绘制所有形状而不是分别或逐个绘制。当你绘制多个形状时，你应该使用一个`DrawNode`实例，而不是多个`DrawNode`实例并在其中添加多个形状。此外，`DrawNode`没有深度概念。Cocos2d-x将按照添加到`DrawNode`中的形状顺序进行绘制。'
