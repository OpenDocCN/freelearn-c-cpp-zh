- en: Chapter 8. Writing an LLVM Backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining registers and register sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the calling convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the instruction set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing frame lowering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing an instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting an instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding instruction encoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting a subtarget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lowering to multiple instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering a target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ultimate goal of a compiler is to produce a target code, or an assembly
    code that can be converted into object code and executed on the actual hardware.
    To generate the assembly code, the compiler needs to know the various aspects
    of the architecture of the target machine—the registers, instruction set, calling
    convention, pipeline, and so on. There are lots of optimizations that can be done
    in this phase as well.
  prefs: []
  type: TYPE_NORMAL
- en: LLVM has its own way of defining the target machine. It uses `tablegen` to specify
    the target registers, instructions, calling convention, and so on. The `tablegen`
    function eases the way we describe a large set of architecture properties in a
    programmatic way.
  prefs: []
  type: TYPE_NORMAL
- en: LLVM has a pipeline structure for the backend, where instructions travel through
    phases like this; from the LLVM IR to `SelectionDAG`, then to `MachineDAG`, then
    to `MachineInstr`, and finally to `MCInst`.
  prefs: []
  type: TYPE_NORMAL
- en: The IR is converted into SelectionDAG (**DAG** stands for **Directed Acyclic
    Graph**). Then SelectionDAG legalization occurs where illegal instructions are
    mapped on the legal operations permitted by the target machine. After this stage,
    SelectionDAG is converted to MachineDAG, which is basically an instruction selection
    supported by the backend.
  prefs: []
  type: TYPE_NORMAL
- en: CPUs execute a linear sequence of instructions. The goal of the scheduling step
    is to linearize the DAG by assigning an order to its operations. LLVM's code generator
    employs clever heuristics (such as register pressure reduction) to try and produce
    a schedule that will result in faster code. Register allocation policies also
    play an important role in producing better LLVM code.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes how to build an LLVM toy backend from scratch. By the
    end of this chapter, we will be able to generate assembly code for a sample toy
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: A sample backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sample backend considered in this chapter is a simple RISC-type architecture,
    with a few registers (say r0-r3), a stack pointer (sp), and a link register (lr),
    for storing the return address.
  prefs: []
  type: TYPE_NORMAL
- en: The calling convention of this toy backend is similar to the ARM architecture—arguments
    passed to the function will be stored in register sets r0-r1, and the return value
    will be stored in r0.
  prefs: []
  type: TYPE_NORMAL
- en: Defining registers and registers sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to define registers and register sets in `.td` files.
    The `tablegen` function will convert this `.td` file into `.inc` files, which
    will be the `#include` declarative in our `.cpp` files and refer to registers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have defined our toy target machine to have four registers (r0-r3), a stack
    register (sp), and a link register (lr). These can be specified in the `TOYRegisterInfo.td`
    file. The `tablegen` function provides the `Register` class, which can be extended
    to specify the registers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To define the backend architecture using target descriptor files, proceed with
    the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder in `lib/Target` named `TOY`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `TOYRegisterInfo.td file` in the new `TOY` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the hardware encoding, namespace, registers, and the register class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `tablegen` function processes this `.td` file to generate the `.inc` file,
    which generally has enums generated for these registers. These enums can be used
    in the`.cpp` files, in which the registers can be referenced as `TOY::R0`. These
    `.inc` files will be generated when we build the LLVM project.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get more details about how registers are defined for more advanced architecture,
    such as ARM, refer to the `lib/Target/ARM/ARMRegisterInfo.td` file in the source
    code of LLVM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the calling convention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The calling convention specifies how values are passed to and from a function
    call. Our TOY architecture specifies that two arguments are passed in two registers,
    r0 and r1, while the remaining ones are passed to the stack. This recipe shows
    you how to define the calling convention, which will be used in `ISelLowering`
    (the instruction selection lowering phase discussed in [Chapter 6](part0065.xhtml#aid-1TVKI1
    "Chapter 6. Target-independent Code Generator"), *Target Independent Code Generator*)
    via function pointers.
  prefs: []
  type: TYPE_NORMAL
- en: The calling convention will be defined in the `TOYCallingConv.td` file, which
    will have primarily two sections—one for defining the return value convention,
    and the other for defining the argument passing convention. The return value convention
    specifies how the return values will reside and in which registers. The argument
    passing convention will specify how the arguments passed will reside and in which
    registers. The `CallingConv` class is inherited while defining the calling convention
    of the toy architecture.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement the calling convention, proceed with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `TOYCallingConv.td` file in the `lib/Target/TOY` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In that file, define the return value convention, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, define the argument passing convention, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the callee saved register set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `.td` file you just read about, it has been specified that the return
    values of the integer type of 32 bits are stored in the r0 register. Whenever
    arguments are passed to a function, the first two arguments will be stored in
    the r0 and r1 registers. It is also specified that whenever any data type, such
    as an integer of 8 bits or 16 bits, will be encountered, it will be promoted to
    the 32-bit integer type.
  prefs: []
  type: TYPE_NORMAL
- en: The `tablegen` function generates a `TOYCallingConv.inc` file, which will be
    referred to in the `TOYISelLowering.cpp` file. The two target `hook` functions
    used to define argument handling are `LowerFormalArguments()` and `LowerReturn()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see a detailed implementation of advanced architectures, such as ARM, look
    into the `lib/Target/ARM/ARMCallingConv.td` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the instruction set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The instruction set of an architecture varies according to various features
    present in the architecture. This recipe demonstrates how instruction sets are
    defined for target architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three things are defined in the instruction target description file: operands,
    the assembly string and the instruction pattern. The specification contains a
    list of definitions or outputs, and a list of uses or inputs. There can be different
    operand classes, such as the `Register` class, and the immediate and more complex
    `register + imm` operands.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, a simple add instruction definition that takes two registers as operands
    is demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To define an instruction set using target descriptor files, proceed with the
    following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `TOYInstrInfo.td` in the `lib/Target/TOY` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specify the operands, assembly string, and instruction pattern for the `add`
    instruction between two register operands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `add` register to the register instruction specifies `$dst` as the result
    operand, which belongs to the `General Register` type class; inputs `$src1` and
    `$src2` as two input operands, which also belong to the `General Register` type
    class; and the instruction assembly string as `"add $dst, $src1, $src2"` of the
    32-bit integer type.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, an assembly will be generated for `add` between two registers, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code indicates to add the r0 and r1 register contents and store
    the result in the r0 register.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many instructions will have the same type of instruction pattern—ALU instructions
    such as `add`, `sub`, and so on. In cases such as this multiclass can be used
    to define the common properties. For more detailed information about the various
    types of instruction sets for advanced architecture, such as ARM, refer to the
    `lib/Target/ARM/ARMInstrInfo.td file`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing frame lowering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe talks about frame lowering for target architecture. Frame lowering
    involves emitting the prologue and epilogue of the function call.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two functions need to be defined for frame lowering, namely `TOYFrameLowering::emitPrologue()`
    and `TOYFrameLowering::emitEpilogue()`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following functions are defined in the `TOYFrameLowering.cpp` file in the
    `lib/Target/TOY` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `emitPrologue` function can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `emitEpilogue` function can be defined like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here are some helper functions used to determine the offset for the `ADD` stack
    operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following are some more helper functions used to compute the stack size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `emitPrologue` function first computes the stack size to determine whether
    the prologue is required at all. Then it adjusts the stack pointer by calculating
    the offset. For the epilogue, it first checks whether the epilogue is required
    or not. Then it restores the stack pointer to what it was at the beginning of
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this input IR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The TOY assembly generated will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For advanced architecture frame lowering, such as in ARM, refer to the `lib/Target/ARM/ARMFrameLowering.cpp`
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing an instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Printing an assembly instruction is an important step in generating target code.
    Various classes are defined that work as a gateway to the streamers. The instruction
    string is provided by the `.td` file defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first and foremost step for printing instructions is to define the instruction
    string in the `.td` file, which was done in the *Defining the instruction set*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `InstPrinter` inside the `TOY` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a new file, called `TOYInstrFormats.td`, define the `AsmString` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file called `TOYInstPrinter.cpp`, and define the `printOperand`
    function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, define a function to print the register names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function to print the instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It also requires `MCASMinfo` to be specified to print the instruction. This
    can be done by defining the `TOYMCAsmInfo.h` and `TOYMCAsmInfo.cpp` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `TOYMCAsmInfo.h` file can be defined as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `TOYMCAsmInfo.cpp` file can be defined like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `LLVMBuild.txt` file for the instruction printer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define `CMakeLists.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the final compilation takes place, the **llc** tool—a static compiler—will
    generate the assembly of the TOY architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following IR, when given to the llc tool, will generate an
    assembly as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Selecting an instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An IR instruction in DAG needs to be lowered to a target-specific instruction.
    The SDAG node contains IR, which needs to be mapped on machine-specific DAG nodes.
    The outcome of the selection phase is ready for scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For selecting a machine-specific instruction, a separate class, `TOYDAGToDAGISel`,
    needs to be defined. To compile the file containing this class definition, add
    the filename to the `CMakeLists.txt` file in the `TOY` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A pass entry needs to be added in the `TOYTargetMachine.h` and `TOYTargetMachine.cpp`
    files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code in `TOYTargetMachine.cpp` will create a pass in the instruction
    selection stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define an instruction selection function, proceed with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `TOYISelDAGToDAG.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include the following files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new class called `TOYDAGToDAGISel` as follows, which will inherit
    from the `SelectionDAGISel` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The most important function to define in this class is `Select()`, which will
    return an `SDNode` object specific to the machine instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare it in the class:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define it further as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Another important function is used to define the address selection function,
    which will calculate the base and offset of the address for load and store operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare it as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define it further, like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `createTOYISelDag` pass converts a legalized DAG into a toy-specific DAG,
    ready for instruction scheduling in the same file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TOYDAGToDAGISel::Select()` function of `TOYISelDAGToDAG.cpp` is used for
    the selection of the OP code DAG node, while `TOYDAGToDAGISel::SelectAddr()` is
    used for the selection of the DATA DAG node with the `addr` type. Note that if
    the address is global or external, we return false for the address, since its
    address is calculated in the global context.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For details on the selection of DAG for machine instructions of complex architectures,
    such as ARM, look into the `lib/Target/ARM/ARMISelDAGToDAG.cpp` file in the LLVM
    source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding instruction encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the instructions need to be specific for how they are encoded with respect
    to bit fields, this can be done by specifying the bit field in the `.td` file
    when defining an instruction.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To include instruction encoding while defining instructions, proceed with the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A register operand that will be used to register the `add` instruction will
    have some defined encoding for its instruction. The size of the instruction is
    32 bits, and the encoding for it is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This can be achieved by specifying the preceding bit pattern in the `.td` files
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `TOYInstrFormats.td` file, define a new variable, called `Inst`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `TOYInstrInfo.td` file, define an instruction encoding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `TOY/MCTargetDesc` folder, in the `TOYMCCodeEmitter.cpp` file, the encoding
    function will be called if the machine instruction operand is a register:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, in the same file, a function used to encode the instruction is specified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `.td` files, the encoding of an instruction has been specified—the bits
    for the operands, the destination, flag conditions, and opcode of the instruction.
    The machine code emitter gets these encodings from the `.inc` file generated by
    `tablegen` from the `.td` files through function calls. It encodes these instructions
    and emits the same for instruction printing.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For complex architecture such as ARM, see the `ARMInstrInfo.td` and `ARMInstrInfo.td`
    files in the `lib/Target/ARM` directory of the LLVM trunk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting a subtarget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A target may have a subtarget—typically, a variant with instructions—way of
    handling operands, among others. This subtarget feature can be supported in the
    LLVM backend. A subtarget may contain some additional instructions, registers,
    scheduling models, and so on. ARM has subtargets such as NEON and THUMB, while
    x86 has subtarget features such as SSE, AVX, and so on. The instruction set differs
    for the subtarget feature, for example, NEON for ARM and SSE/AVX for subtarget
    features that support vector instructions. SSE and AVX also support the vector
    instruction set, but their instructions differ from each other.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe will demonstrate how to add a support subtarget feature in the
    backend. A new class that will inherit the `TargetSubtargetInfo` class has to
    be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `TOYSubtarget.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include the following files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new class, called `TOYSubtarget`, with some private members that have
    information on the data layout, target lowering, target selection DAG, target
    frame lowering, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare its constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This constructor initializes the data members to match that of the specified
    triplet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define some helper functions to return the class-specific data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file called `TOYSubtarget.cpp`, and define the constructor as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The subtarget has its own data layout defined, with other information such as
    frame lowering, instruction information, subtarget information, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To dive into the details of subtarget implementation, refer to the `lib/Target/ARM/ARMSubtarget.cpp`
    file in the LLVM source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lowering to multiple instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take an example of implementing a 32-bit immediate load with high/low
    pairs, where MOVW implies moving a 16-bit low immediate and a clear 16 high bit,
    and MOVT implies moving a 16-bit high immediate.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There can be various ways to implement this multiple instruction lowering. We
    can do this by using pseudo-instructions or in the selection DAG-to-DAG phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do it without pseudo-instructions, define some constraints. The two instructions
    must be ordered. MOVW clears the high 16 bits. Its output is read by MOVT to fill
    the high 16 bits. This can be done by specifying the constraints in tablegen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second way is to define a pseudo-instruction in the `.td` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The pseudo-instruction is then lowered by a target function in the `TOYInstrInfo.cpp`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the entire LLVM project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, an `ex.ll` file with IR will look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The assembly generated will look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first instruction, `movw`, will move 1 in the lower 16 bits and clear the
    high 16 bits. So in r1, `0x00000001` will be written by the first instruction.
    In the next instruction, `movt`, the higher 16 bits will be written. So in r1,
    `0x0001XXXX` will be written, without disturbing the lower bits. Finally, the
    r1 register will have `0x00010001` in it. Whenever a pseudo-instruction is encountered
    as specified in the `.td` file, its expand function is called to specify what
    the pseudo-instruction will expand to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding case, the `mov32` immediate was to be implemented by two instructions:
    `movw` (the lower 16 bits) and `movt` (the higher 16 bits). It was marked as a
    pseudo-instruction in the `.td` file. When this pseudo-instruction needs to be
    emitted, its expand function is called, which builds two machine instructions:
    `MOVLOi16` and `MOVHIi16`. These map to the `movw` and `movt` instructions of
    the target architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To dive deep into implementing such lowering of multiple instructions, look
    at the ARM target implementation in the LLVM source code in the `lib/Target/ARM/ARMInstrInfo.td`
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering a target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For running the llc tool in the TOY target architecture, it has to be registered
    with the llc tool. This recipe demonstrates which configuration files need to
    be modified to register a target. The build files are modified in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To register a target with a static compiler, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the entry of the TOY backend to `llvm_root_dir/CMakeLists.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then add the toy entry to `llvm_root_dir/include/llvm/ADT/Triple.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the toy entry to `llvm_root_dir/include/llvm/ MC/MCExpr.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the toy entry to `llvm_root_dir/include/llvm/ Support/ELF.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the toy entry to `lib/MC/MCExpr.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the toy entry to `lib/Support/Triple.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the toy directory entry to `lib/Target/LLVMBuild.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file called `TOY.h` in the `lib/Target/TOY` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new folder called `TargetInfo` in the `lib/Target/TOY` folder. Inside
    that folder, create a new file called `TOYTargetInfo.cpp`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same folder, create the `CMakeLists.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `LLVMBuild.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `lib/Target/TOY` folder, create a file called `TOYTargetMachine.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new folder called `MCTargetDesc` and a new file called `TOYMCTargetDesc.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create one more file, called `TOYMCTargetDesc.cpp`, in the same folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same folder, create an `LLVMBuild.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `CMakeLists.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Build the enitre LLVM project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have specified that we are building the LLVM compiler for the toy
    target. After the build completes, check whether the TOY target appears with the
    `llc` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a more detailed description about complex targets that involve pipelining
    and scheduling, follow the chapters in *Tutorial: Creating an LLVM Backend for
    the Cpu0 Architecture* by Chen Chung-Shu and Anoushe Jamshidi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
