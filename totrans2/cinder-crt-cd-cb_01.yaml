- en: Chapter 1. Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project for a basic application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a project for a screensaver application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a project for an iOS touch application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basic structure of an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to mouse input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to key input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to touch input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the files dropped onto the application window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting a scene after resizing the window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using resources on Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using resources on OSX and iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we'll learn the fundamentals of creating applications using
    Cinder.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by creating different types of applications on the different platforms
    that Cinder supports using a powerful tool called TinderBox.
  prefs: []
  type: TYPE_NORMAL
- en: We'll cover the basic structure of an application and see how to respond to
    user input events.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will learn how to use resources on Windows and Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project for a basic application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to create a project for a basic desktop application
    for Windows and Mac OSX.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Projects can be created using a powerful tool called TinderBox. TinderBox comes
    bundled in your Cinder download and contains templates for creating projects for
    different applications for both Microsoft Visual C++ 2010 and OSX Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: To find Tinderbox, go to your Cinder folder, inside which you will find a folder
    named `tools` with, TinderBox application in it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/8703OS_1_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first time you open TinderBox, you'll be asked to specify the folder where
    you installed Cinder. You'll need to do this only the first time you open TinderBox.
    If you need to redefine the location of Cinder installation, you can do so by
    selecting the **File** menu and then **Preferences** on Windows or selecting the
    **TinderBox** menu and then **Preferences** on OS X.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll use TinderBox, a utility tool that comes bundled with Cinder that allows
    for the easy creation of projects. Perform the following steps to create a project
    for a basic application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open TinderBox and choose your project's location. In the main **TinderBox**
    window select **BasicApp** as **Target** and **OpenGL** as **Template**, as shown
    in the following screenshot:![How to do it…](img/8703OS_1_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose your project's location. The **Naming Prefix** and **Project Name** fields
    will default to the project's name, as shown in the following screenshot:![How
    to do it…](img/8703OS_1_3.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the compilers you want to use for your project, either Microsoft Visual
    C++ 2010 and/or OS X Xcode.![How to do it…](img/8703OS_1_4.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create** button and TinderBox will show you the folder where
    your new project is located. TinderBox will remain open; you can close it now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TinderBox will create the selected projects for the chosen platforms (Visual
    C++ 2010 and OS X Xcode) and create references to the compiled Cinder library.
    It will also create the application's class as a subclass of `ci::app::AppBasic`.
    It will also create some sample code with a basic example to help you get started.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your project name and naming prefix will be, by default, the name of the folder
    in which the project is being created. You can edit this if you want, but always
    make sure both **Project Name** and **Naming Prefix** fields do not have spaces
    as you might get errors.
  prefs: []
  type: TYPE_NORMAL
- en: The naming prefix will be used to name your application's class by adding the
    `App` suffix. For example, if you set your **Naming Prefix** field as `MyCinderTest`,
    your application's class will be `MyCinderTestApp`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project for a screensaver application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a project for a desktop screensaver
    for both Windows and Mac OS X.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get ready with TinderBox, please refer to the *Getting ready* section of
    the previous *Creating a project for a basic application* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll use TinderBox, a utility tool that comes bundled with Cinder that allows
    easy creation of projects. Perform the following steps to create a project for
    a screensaver application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open TinderBox and choose your project's location. In the main **TinderBox**
    window select **Screensaver** as **Target** and **OpenGL** as **Template**, as
    shown in the following screenshot:![How to do it…](img/8703OS_1_5.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the compilers you want to create a project to, either Microsoft Visual
    C++ 2010 and/or OS X Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Create** and TinderBox will direct you to the folder where your project
    was created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TinderBox will create both a project for you and link it against the compiled
    Cinder library. It will also create the application's class and make it a subclass
    of `ci::app::AppScreenSaver`, which is the class with all the basic functionality
    for a screensaver application. It will also create some sample code with a basic
    example to help you get started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project for an iOS touch application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to create a project for an application that
    runs on iOS devices such as iPhone and iPad.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get ready with TinderBox, please refer to the *Getting ready* section of
    the *Creating a project for a basic application* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the iOS touch application will only work on iOS devices such
    as iPhones and iPads, and that the projects created with TinderBox will be for
    OSX Xcode only.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll use TinderBox, a utility tool that comes bundled with Cinder that allows
    easy creation of projects. Perform the following steps to create a project for
    an iOS touch application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open TinderBox and choose your project's location. In the main **TinderBox**
    window select **Cocoa Touch** as **Target** and **Simple** as **Template**, as
    shown in the following screenshot:![How to do it…](img/8703OS_1_6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the compilers you want to create a project to, either Microsoft Visual
    C++ 2010 and/or OS X Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Create** and TinderBox will direct you to the folder where your project
    was created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TinderBox will create an OS X Xcode project and create the references to link
    against the compiled Cinder library. It will also create the application's class
    as a subclass of `ci::app::AppCocoaTouch`, which is the class with all the basic
    functionality for a screensaver application. It will also create some sample code
    with a basic example to help you get started.
  prefs: []
  type: TYPE_NORMAL
- en: This application is built on top of Apple's Cocoa Touch framework to create
    iOS applications.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basic structure of an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your application''s class can have several methods that will be called at different
    points during the execution of the program. The following table lists these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `prepareSettings` | This method is called once at the very beginning of the
    application, before creating the renderer. Here, we may define several parameters
    of the application before the application gets initialized, such as the frame
    rate or the size of the window. If none are specified, the application will initialize
    with default values. |'
  prefs: []
  type: TYPE_TB
- en: '| `setup` | This method is called once at the beginning of the application
    lifecycle. Here, you initialize all members and prepare the application for running.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `update` | This method is called in a loop during the application''s runtime
    before the `draw` method. It is used to animate and update the states of the application''s
    components. Even though you may update them during the `draw` method, it is recommended
    you keep the update and drawing routines separate as a matter of organization.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `draw` | This method is called in a loop during the application''s runtime
    after the update. All drawing code should be placed here. |'
  prefs: []
  type: TYPE_TB
- en: '| `shutdown` | This method is called just before the application exits. Use
    it to do any necessary cleanup such as freeing memory and allocated resources
    or shutting down hardware devices. |'
  prefs: []
  type: TYPE_TB
- en: To execute our code, we must overwrite these methods with our own code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not mandatory to override all of the preceding methods; you can use the
    ones that your application requires specifically. For example, if you do not want
    to do any drawing, you may omit the `draw` method.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe and for the sake of learning, we will implement all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the following methods in your class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement several methods that make up the basic structure of an application.
    Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `prepareSettings` method. Here we can define, for example, the
    size of the window, its title, and the frame rate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `setup` method. Here we should initialize all members of the
    application''s class. For example, to initialize capturing from a webcam we would
    declare the following members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `update` method. As an example, we will print the current frame
    count to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `draw` method with all the drawing commands. Here we clear the
    background with black and draw a red circle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement the `shutdown` method. This method should take code for doing cleanup,
    for example, to shut down threads or save the state of your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s a sample code for saving some parameters in an XML format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our application's superclass implements the preceding methods as virtual empty
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: When the application runs, these methods are called, calling our own code we
    implemented or the parent class' empty method if we didn't.
  prefs: []
  type: TYPE_NORMAL
- en: In step 1 we defined several application parameters in the `prepareSettings`
    method. It is not recommended to use the `setup` method to initialize these parameters,
    as it means that the renderer has to be initialized with the default values and
    then readjusted during the setup. The result is extra initialization time.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are other callbacks that respond to user input such as mouse and keyboard
    events, resizing of the window, and dragging files onto the application window.
    These are described in more detail in the *Responding to mouse input*, *Responding
    to key input*, *Responding to touch input*, *Accessing files dragged on the application
    window*, and *Adjusting a scene after resizing the window* recipes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn how to create a basic app with TinderBox, read the *Creating a project
    for a basic application* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to mouse input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application can respond to mouse interaction through several event handlers
    that are called depending on the action being performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The existing handlers that respond to mouse interaction are listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `mouseDown` | This is called when the user presses a mouse button |'
  prefs: []
  type: TYPE_TB
- en: '| `mouseUp` | This is called when the user releases a mouse button |'
  prefs: []
  type: TYPE_TB
- en: '| `mouseWheel` | This is called when the user rotates the mouse wheel |'
  prefs: []
  type: TYPE_TB
- en: '| `mouseMove` | This is called when the mouse is moved without any button pressed
    |'
  prefs: []
  type: TYPE_TB
- en: '| `mouseDrag` | This is called when the mouse is moved with any button pressed
    |'
  prefs: []
  type: TYPE_TB
- en: It is not mandatory to implement all of the preceding methods; you can implement
    only the ones required by your application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implement the necessary event handlers according to the mouse events you need
    to respond to. For example, to create an application that responds to all available
    mouse events, you must implement the following code inside your main class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `MouseEvent` object passed as a parameter contains information about the
    mouse event.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will learn how to work with the `ci::app::MouseEvent` class to respond to
    mouse events. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the position where the event has happened, in terms of screen coordinates,
    we can type in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or we can get the separate x and y coordinates by calling the `getX` and `getY`
    methods:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `MouseEvent` object also lets us know which mouse button triggered the event
    by calling the `isLeft`, `isMiddle`, or `isRight` methods. They return a `bool`
    value indicating if it was the left, middle, or right button, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To know if the event was triggered by pressing a mouse button, we can call the
    `isLeftDown`, `isRightDown`, and `isMiddleDown` methods that return `true` depending
    on whether the left, right, or middle buttons of the mouse were pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `getWheelIncrement` method returns a `float` value with the movement increment
    of the mouse wheel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is also possible to know if a special key was being pressed during the event.
    The `isShiftDown` method returns `true` if the *Shift* key was pressed, the `isAltDown`
    method returns `true` if the *Alt* key was pressed, `isControlDown` returns `true`
    if the *control* key was pressed, and `isMetaDown` returns `true` if the Windows
    key was pressed on Windows or the *option* key was pressed on OS X, `isAccelDown`
    returns `true` if the *Ctrl* key was pressed on Windows or the *command* key was
    pressed on OS X.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Cinder application responds internally to the system's native mouse events.
    It then creates a `ci::app::MouseEvent` object using the native information and
    calls the necessary mouse event handlers of our application's class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also possible to access the native modifier mask by calling the `getNativeModifiers`
    method. These are platform-specific values that Cinder uses internally and may
    be of use for advanced uses.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to key input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Cinder application can respond to key events through several callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The available callbacks that get called by keyboard interaction are listed
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `keyDown` | This is called when the user first presses a key and called repeatedly
    if a key is kept pressed. |'
  prefs: []
  type: TYPE_TB
- en: '| `keyUp` | This is called when a key is released. |'
  prefs: []
  type: TYPE_TB
- en: Both these methods receive a `ci::app::KeyEvent` object as a parameter with
    information about the event such as the key code being pressed or if any special
    key (such as *Shift* or *control*) is being pressed.
  prefs: []
  type: TYPE_NORMAL
- en: It is not mandatory to implement all of the preceding key event handlers; you
    can implement only the ones that your application requires.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implement the necessary event handlers according to what key events you need
    to respond to. For example, to create an application that responds to both key
    down and key up events, you must declare the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `ci::app::KeyEvent` parameter contains information about the key event.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will learn how to work with the `ci::app::KeyEvent` class to learn how to
    understand key events. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the ASCII code of the character that triggered the key event, you can
    type in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To respond to special keys that do not map to the ASCII character table, we
    must call the `getCode` method that retrieves an `int` value that can be mapped
    to a character table in the `ci::app::KeyEvent` class. To test, for example, if
    the key event was triggered by the *Esc* key you can type in the following line
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`escPressed` will be `true` if the escape key triggered the event, or `false`
    otherwise.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `ci::app::KeyEvent` parameter also has information about modifier keys that
    were pressed during the event. The `isShiftDown` method returns `true` if the
    *Shift* key was pressed, `isAltDown` returns `true` if the *Alt* key was pressed,
    `isControlDown` returns `true` if the *control* key was pressed, `isMetaDown`
    returns `true` if the Windows key was pressed on Windows or the *command* key
    was pressed on OS X, and `isAccelDown` returns `true` if the *Ctrl* key was pressed
    on Windows or the *command* key was pressed on OS X.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Cinder application responds internally to the system's native key events.
    When receiving a native key event, it creates a `ci::app::KeyEvent` object based
    on the native information and calls the correspondent callback on our application's
    class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also possible to access the native key code by calling the `getNativeKeyCode`
    method. This method returns an `int` value with the native, platform-specific
    code of the key. It can be important for advanced uses.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to touch input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Cinder application can receive several touch events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The available touch event handlers that get called by touch interaction are
    listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `touchesBegan` | This is called when new touches are detected |'
  prefs: []
  type: TYPE_TB
- en: '| `touchesMoved` | This is called when existing touches move |'
  prefs: []
  type: TYPE_TB
- en: '| `touchesEnded` | This is called when existing touches are removed |'
  prefs: []
  type: TYPE_TB
- en: All of the preceding methods receive a `ci::app::TouchEvent` object as a parameter
    with a `std::vector` of `ci::app::TouchEvent::Touch` objects with information
    about each touch detected. Since many devices can detect and respond to several
    touches simultaneously, it is possible and common for a touch event to contain
    several touches.
  prefs: []
  type: TYPE_NORMAL
- en: It is not mandatory to implement all of the preceding event handlers; you can
    use the ones your application requires specifically.
  prefs: []
  type: TYPE_NORMAL
- en: Cinder applications can respond to touch events on any touch-enabled device
    running Windows 7, OS X, or iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implement the necessary touch event handlers according to the touch events
    you want to respond to. For example, to respond to all available touch events
    (touches added, touches moved, and touches removed), you would need to declare
    and implement the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will learn how to work with the `ci::app::TouchEvent` class to understand
    touch events. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the list of touches, you can type in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Iterate through the container to access each individual element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can get the position of a touch by calling the `getPos` method that returns
    a `Vec2f` value with its position or using the `getX` and `getY` methods to receive
    the x and y coordinates separately, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `getId` method returns a `uint32_t` value with a unique ID for the `touch`
    object. This ID is persistent throughout the lifecycle of the touch, which means
    you can use it to keep track of a specific touch as you access it on the different
    touch events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, to make an application where we draw lines using our fingers, we
    can create `std::map` that associates each line, in the form of a `ci::PolyLine<Vec2f>`
    object, with a `uint32_t` key with the unique ID of a touch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to include the file with `std::map` and `PolyLine` to our project by
    adding the following code snippet to the beginning of the source file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now declare the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `touchesBegan` method we create a new line for each detected touch and
    map it to the unique ID of each touch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `touchesMoved` method, we add the position of each touch to its corresponding
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `touchesEnded` method, we remove the line that corresponds to a touch
    being removed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the lines can be drawn. Here we clear the background with black and
    draw the lines with in white. The following is the implementation of the `draw`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is a screenshot of our app running after drawing some lines:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/8703OS_1_7.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Cinder application responds internally to the system calls for any touch event.
    It will then create a `ci::app::TouchEvent` object with information about the
    event and call the corresponding event handler in our application's class. The
    way to respond to touch events becomes uniform across the Windows and Mac platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The `ci::app::TouchEvent` class contains only one accessor method that returns
    a `const` reference to a `std::vector<TouchEvent::Touch>` container. This container
    has one `ci::app::TouchEvent::Touch` object for each detected touch and contains
    information about the touch.
  prefs: []
  type: TYPE_NORMAL
- en: The `ci::app::TouchEvent::Touch` object contains information about the touch
    including position and previous position, unique ID, the time stamp, and a pointer
    to the native event object which maps to `UITouch` on Cocoa Touch and `TOUCHPOINT`
    on Windows 7.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At any time, it is also possible to get a container with all active touches
    by calling the `getActiveTouches` method. It returns a `const` reference to a
    `std::vector<TouchEvent::Touch>` container. It offers flexibility when working
    with touch applications as it can be accessed outside the touch event methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to draw a solid red circle around each active touch,
    you can add the following code snippet to your `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Accessing files dropped onto the application window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cinder applications can respond to files dropped onto the application window
    through the callback, `fileDrop` . This method takes a `ci::app::FileDropEvent`
    object as a parameter with information about the event.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your application must implement a `fileDrop` method which takes a `ci::app::FileDropEvent`
    object as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to the application''s class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will learn how to work with the `ci::app::FileDropEvent` object to work
    with file drop events. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the method implementation you can use the `ci::app::FileDropEvent` parameter
    to access the list of files dropped onto the application by calling the `getFiles`
    method. This method returns a `conststd::vector` container with `fs::path` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The position where the files were dropped onto the window can be accessed through
    the following callback methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To get a `ci::Vec2i` object with the position of the files dropped, type in
    the following line of code:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the x and y coordinates separately, you can use the `getX` and `getY`
    methods, for example:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'You can find the number of dropped files by using the `getNumFiles` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To access a specific file, if you already know its index, you can use the `getFile`
    method and pass the index as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, to access the file with an index of `2`, you can use the following
    line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Cinder application will respond to the system's native event for file drops.
    It will then create a `ci::app::FileDropEvent` object with information about the
    event and call the `fileDrop` callback in our application. This way Cinder creates
    a uniform way of responding to file drop events across the Windows and OS X platforms.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cinder uses `ci::fs::path` objects to define paths. These are `typedef` instances
    of `boost::filesystem::path` objects and allow for much greater flexibility when
    working with paths. To learn more about the `fs::path` objects, please refer to
    the `boost::filesystem` library reference, available at [http://www.boost.org/doc/libs/1_50_0/libs/filesystem/doc/index.htm](http://www.boost.org/doc/libs/1_50_0/libs/filesystem/doc/index.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting a scene after resizing the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cinder applications can respond to resizing the window by implementing the resize
    event. This method takes a `ci::app::ResizeEvent` parameter with information about
    the event.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your application doesn''t have a `resize` method, implement one. In the
    application''s class declaration, add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the method's implementation, you can use the `ResizeEvent` parameter to find
    information about the window's new size and format.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will learn how to work with the `ci::app::ResizeEvent` parameter to respond
    to window resize events. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: To find the new size of the window, you can use the `getSize` method which returns
    a `ci::Vec2iwith` object, the window's width as the x component, and the height
    as the y component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `getWidth and getHeight` methods both return `int` values with the window''s
    width and height respectively, for example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `getAspectRatio` method returns a `float` value with the aspect ratio of
    the window, which is the ratio between its width and height:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Any element on screen that needs adjusting must use the new window size to
    recalculate its properties. For example, to have a rectangle that is drawn at
    the center of the window with a 20 pixel margin on all sides, we must first declare
    a `ci::Rectf` object in the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the setup we set its properties so that it has a 20 pixel margin on all
    sides from the window:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To draw the rectangle with a red color, add the following code snippet to the
    `draw` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `resize` method, we must recalculate the rectangle properties so that
    it resizes itself to maintain the 20 pixel margin on all sides of the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application and resize the window. The rectangle will maintain its relative
    size and position according to the window size.![How to do it…](img/8703OS_1_8.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Cinder application responds internally to the system's window resize events.
    It will then create the `ci::app::ResizeEvent` object and call the `resize` method
    on our application's class. This way Cinder creates a uniform way of dealing with
    resize events across the Windows and Mac platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Using resources on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common for Windows applications to use external files either to load images,
    play audio or video, or to load or save settings on XML files.
  prefs: []
  type: TYPE_NORMAL
- en: Resources are external files to your application that are embedded in the application's
    executable file. Resource files are hidden from the user to avoid alterations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Resources should be stored in a folder named `resources` in your project folder.
    If this folder does not exist, create it.
  prefs: []
  type: TYPE_NORMAL
- en: Resources on Windows must be referenced in a file called `Resources.rc`. This
    file should be placed next to the Visual C++ solution in the `vc10` folder. If
    this file does not exist, you must create it as an empty file. If the `resources.rs`
    file is not included already in your project solution, you must add it by right-clicking
    on the **Resources** filter and choosing **Add** and then **ExistingItem**. Navigate
    to the file and select it. As a convention, this file should be kept in the same
    folder as the project solution.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use Visual C++ 2010 to add resources to our applications on Windows.
    Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Visual C++ solution and open the `resources.h` file inside the **Header
    Files** filter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `#pragma once` macro to your file to prevent it from being included
    more than once in your project and include the `CinderResources.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On Windows, each resource must have a unique ID number. As a convention, the
    IDs are defined as sequential numbers starting from 128, but you can use other
    IDs if it suits you better. Make sure to never use the same ID twice. You must
    also define a type string. The type string is used to identify resources of the
    same type, for example, the string `IMAGE` may be used when declaring image resources,
    `VIDEO` for declaring video resources, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To simplify writing multiplatform code, Cinder has a macro for declaring resources
    that can be used on both Windows and Mac.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, to declare the resource of an image file named `image.png`, we
    would type in the following line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first parameter of the `CINDER_RESOURCE` macro is the relative path to the
    folder where the resource file is, in this case the default `resources` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second parameter is the name of the file, and after that comes the unique
    ID of this resource, and finally its type string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we need to add our `resources` macro to the `resources.rs` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This resource is now ready to be used in our application. To load this image
    into `ci::gl::Texture` we simply include the `Texture.h` file in our application''s
    source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now declare the texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the setup, we create the texture by loading the resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The texture is now ready to be drawn on screen. To draw the image at position
    (20, 20), we will type in the following line of code inside the `draw` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `resources.rc` file is used by a resource compiler to embed resources into
    the executable file as binary data.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cinder allows writing code to use resources that is coherent across all supported
    platforms, but the way resources are handled on Windows and OS X/iOS is slightly
    different. To learn how to use resources on a Mac, please read the *Using resources
    on iOS and OS X* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using resources on iOS and OS X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common for Windows applications to use external files either to load images,
    play audio or video, or to load or save settings on XML files.
  prefs: []
  type: TYPE_NORMAL
- en: Resources are external files to your application that are included in the applications
    bundle. Resource files are hidden from the user to avoid alterations.
  prefs: []
  type: TYPE_NORMAL
- en: Cinder allows writing code to use resources that is equal when writing Windows
    or Mac applications, but the way resources are handled is slightly different.
    To learn how to use resources on Windows, please read the *Using resources on
    Windows* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Resources should be stored in a folder named `resources` in your `project` folder.
    If this folder does not exist, create it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use Xcode to add resources to our application on iOS and OS X. Perform
    the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Place any resource file you wish to use in the `resources` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add these files to your project by right-clicking on the **Resources** filter
    in your Xcode project and selecting **Add** and then **ExistingFiles**, navigate
    to the `resources` folder, and select the resource files you wish to add.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To load a resource in your code, you use the `loadResource` method and pass
    the name of the resource file. For example, to load an image named `image.png`,
    you should first create the `gl::Texture` member in the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `setup` method, we initialize the texture with the following resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The texture is now ready to be drawn in the window. To draw it at position
    (20, 20), type in the following line of code inside the `draw` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On iOS and OS X, applications are actually folders that contain all the necessary
    files to run the application, such as the Unix executable file, the frameworks
    used, and the resources. You can access the content of these folders by clicking
    on any Mac application and selecting **Show Package Contents**.
  prefs: []
  type: TYPE_NORMAL
- en: When you add resources to the `resources` folder in your Xcode project, these
    files are copied during the build stage to the `resources` folder of your application
    bundle.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also load resources using the same `loadResource` method that is used
    in Windows applications. This is very useful when writing cross-platform applications
    so that no changes are necessary in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should create the `resource` macro in the `Resources.h` file, and add the
    unique resource ID and its type string. For example, to load the image `image.png`,
    you can type in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is what the `Resources.rc` file should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding example to load an image, the only difference is that we
    would load the texture with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The resource unique ID and type string will be ignored in Mac applications,
    but adding them allows creating code that is cross-platform.
  prefs: []
  type: TYPE_NORMAL
- en: Using assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how we can load and use assets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an example for this recipe, we will load and display an asset image.
  prefs: []
  type: TYPE_NORMAL
- en: Place an image file inside the `assets` folder in your project directory and
    name it `image.png`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the following files at the top of your source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Also add the following useful `using` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example, we will learn how we can load and display an image asset. Perform
    the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a `ci::gl::Texture` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `setup` method let's load the image asset. We will use a `try/catch`
    block in if it is not possible to load the asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `draw` method we will draw the texture. We will use an `if` statement
    to check if the texture has been successfully initialized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first application uses an asset Cinder, which will try to find its default
    `assets` folder. It will begin by searching the executable or application bundle
    folder, depending on the platform, and continue searching its parent's folder
    up to five levels. This is done to accommodate for different project setups.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can add an additional `assets` folder using the `addAssetDirectory` method,
    which takes a `ci::fs::path` object as a parameter. Every time Cinder searches
    for an asset, it will first look in its default `asset` folder and then in every
    folder the user may have added.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create subfolders inside the `assets` folder, for example, if
    our image was inside a subfolder named `My Images`, we would type in the following
    code snippet in the `setup` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to know the path where a specific folder lies. To do this,
    use the `getAssetPath` method, which takes a `ci::fs::path` object as a parameter
    with the name of the file.
  prefs: []
  type: TYPE_NORMAL
