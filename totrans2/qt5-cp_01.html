<html><head></head><body><div><div><div><div><div><h1 class="title"><a id="ch01" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Chapter 1. Creating Your First Qt Application</h1></div></div></div><p class="calibre9">GUI programming is not as difficult as you think. At least it's not when you come to the world of Qt. This book will take you through this world and give you an insight into this incredibly amazing toolkit. It doesn't matter whether you've heard of it or not, as long as you have essential knowledge of C++ programming.</p><p class="calibre9">In this chapter, we will get you comfortable with the development of Qt applications. Simple applications are used as a demonstration for you to cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Creating a new project</li><li class="listitem">Changing the layout of widgets</li><li class="listitem">Understanding the mechanism of signals and slots</li><li class="listitem">Connecting two signals</li><li class="listitem">Creating a Qt Quick application</li><li class="listitem">Connecting C++ slots to QML signals</li></ul></div><div><div><div><div><h1 class="title2"><a id="ch01lvl1sec08" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Creating a new project</h1></div></div></div><p class="calibre9">If you haven't<a id="id0" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> installed Qt 5, refer to <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.qt.io/download">http://www.qt.io/download</a> to install the latest version of it. It's recommended that you install the Community version, which is totally free and compliant with GPL/LGPL. Typically, the installer will install both <strong class="calibre10">Qt Library</strong> <a id="id1" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>and <strong class="calibre10">Qt Creator</strong> <a id="id2" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>for you. In this book, we will use Qt 5.4.0 and Qt Creator 3.3.0. Later versions may have slight differences but the concept remains the same. It's highly recommended that you install Qt Creator if you don't have it on your computer, because all the<a id="id3" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> tutorials in this book are based on it. It is also the official IDE for the development of Qt applications. Although you may be able to develop Qt applications with other IDEs, it tends to be much more complex. So if you're ready, let's go for it by performing the following steps:</p><div><ol class="orderedlist"><li class="listitem1">Open Qt Creator.</li><li class="listitem1">Navigate to <strong class="calibre10">File</strong> | <strong class="calibre10">New File</strong> or <strong class="calibre10">Project</strong>.</li><li class="listitem1">Select <strong class="calibre10">Qt Widgets Application</strong>.</li><li class="listitem1">Enter the project's name and location. In this case, the project's name is <code class="literal">layout_demo</code>.</li></ol></div><p class="calibre9">You may wish to follow the wizard and keep the default values. After this process, Qt Creator will generate the skeleton of the project based on your choices. The UI files are under the <code class="literal">Forms</code> directory. When you double-click on a UI file, Qt Creator will redirect you to the integrated designer. The mode selector should have <strong class="calibre10">Design</strong> highlighted, and the main window<a id="id4" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> should contain several sub-windows to let you design the user interface. This is<a id="id5" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> exactly what we are going to do. For more details about Qt Creator UI, refer to <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://doc.qt.io/qtcreator/creator-quick-tour.html">http://doc.qt.io/qtcreator/creator-quick-tour.html</a>.</p><p class="calibre9">Drag three push buttons from the widget box (widget palette) into the frame of <strong class="calibre10">MainWindow</strong> in the center. The default text displayed on these buttons is <strong class="calibre10">PushButton</strong>, but you can change the text if you want by double-clicking on the button. In this case, I changed the buttons to <code class="literal">Hello</code>, <code class="literal">Hola</code>, and <code class="literal">Bonjour</code>, accordingly. Note that this operation won't affect the <code class="literal">objectName</code> property. In order to keep it neat and easy to find, we need to change the <code class="literal">objectName</code> property. The right-hand side of the UI contains two windows. The upper-right section includes <strong class="calibre10">Object Inspector</strong> and the lower-right side includes <strong class="calibre10">Property Editor</strong>. Just select a push button; you can easily change <code class="literal">objectName</code> in <strong class="calibre10">Property Editor</strong>. For the sake of convenience, I changed these buttons' <code class="literal">objectName</code> properties to <code class="literal">helloButton</code>, <code class="literal">holaButton</code>, and <code class="literal">bonjourButton</code> respectively.</p><div><div><h3 class="title4"><a id="tip02" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Tip</h3><p class="calibre15">It's a good habit to use lowercase for the first letter of <code class="literal">objectName</code> and an uppercase letter for <strong class="calibre10">Class name</strong>. This helps your code to be more readable by people who are familiar with this convention.</p></div></div><p class="calibre9">Okay, it's time to see what you have done to the user interface of your first Qt application. Click on <strong class="calibre10">Run</strong> on the left-hand side panel. It will build the project automatically and then run it. It's amazing to see that the application has the exact same interface as the design, isn't it? If everything is alright, the application should appear similar to what is shown in the following screenshot:</p><div><img src="img/4615OS_01_01.jpg" alt="Creating a new project" class="calibre16"/></div><p class="calibre9">You may want to look at the source code and see what happened there. So, let's go back to the source code by returning to the <strong class="calibre10">Edit</strong> mode. Click on the<a id="id6" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <strong class="calibre10">Edit</strong> button in the mode selector. Then, double-click on <code class="literal">main.cpp</code> in the <code class="literal">Sources</code> folder of the <strong class="calibre10">Projects</strong> tree view. The code for <code class="literal">main.cpp</code> is shown as follows:</p><div><pre class="programlisting">#include "mainwindow.h"
#include &lt;QApplication&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();

    return a.exec();
}</pre></div><div><div><h3 class="title4"><a id="note02" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">The <code class="literal">QApplication</code> class manages<a id="id7" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the GUI application's control flow and the main settings.</p></div></div><p class="calibre9">Actually, you don't need to and you probably won't change too much in this file. The first line of the main scope just initializes the applications on a user's desktop and handles some events. Then there is also an object, <code class="literal">w</code>, which belongs to the <code class="literal">MainWindow</code> class. As for the last line, it ensures that the application won't terminate after execution but will keep in an event loop, so that it is able to respond to external events such as mouse clicks and window state changes.</p><p class="calibre9">Last but not least, let's see what happens during the initialization of the <code class="literal">MainWindow</code> object, <code class="literal">w</code>. It is the content of <code class="literal">mainwindow.h</code>, shown as follows:</p><div><pre class="programlisting">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;

namespace Ui {
    class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();

private:
    Ui::MainWindow *ui;
};

#endif // MAINWINDOW_H</pre></div><p class="calibre9">You may feel a bit<a id="id8" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> surprised seeing a <code class="literal">Q_OBJECT</code> macro if this is your first time writing a Qt application. In the QObject documentation, it says:</p><div><blockquote class="blockquote"><p class="calibre17"><em class="calibre14">The <code class="literal">Q_OBJECT</code> macro must appear in the private section of a class definition that declares its own signals and slots or that uses other services provided by Qt's meta-object system.</em></p></blockquote></div><p class="calibre9">Well, this means that <code class="literal">QObject</code> has to be declared if you're going to use Qt's meta-object system and (or) its signals and slots mechanism. The signals and slots, which are almost the core of Qt, will be included later in this chapter.</p><p class="calibre9">There is a private member named <code class="literal">ui</code>, which is a pointer of the <code class="literal">MainWindow</code> class of the <code class="literal">Ui</code> namespace. Do you remember the UI file we edited before? What the magic of Qt does is that it links the UI file and the parental source code. We can manipulate the UI through code lines as well as design it in Qt Creator's integrated designer. Finally, let's look into the construction function of <code class="literal">MainWindow</code> in <code class="literal">mainwindow.cpp</code>:</p><div><pre class="programlisting">#include "mainwindow.h"
#include "ui_mainwindow.h"

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
}

MainWindow::~MainWindow()
{
    delete ui;
}</pre></div><p class="calibre9">Did you see where the user interface comes from? It's the member <code class="literal">setupUi</code> function of <code class="literal">Ui::MainWindow</code> that initializes it <a id="id9" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>and sets it up for us. You may want to check what happens if we change the member function to something like this:</p><div><pre class="programlisting">MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
    ui-&gt;holaButton-&gt;setEnabled(false);
}</pre></div><p class="calibre9">What happened here? The <code class="literal">Hola</code> button can't be clicked on because we disabled it! It has the same effect if the <strong class="calibre10">enabled</strong> box is unchecked in the designer instead of writing a statement here. Please apply this change before heading to the next topic, because we don't need a disabled push button to do any demonstrations in this chapter.</p></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch01lvl1sec09" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Changing the layout of widgets</h1></div></div></div><p class="calibre9">You already know how to add and move widgets in the <strong class="calibre10">Design</strong> mode. Now, we need to make the UI neat and tidy. I'll show you how to do this step by step.</p><p class="calibre9">A quick way to delete<a id="id10" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> a widget is to select it and press the <strong class="calibre10">Delete</strong> button. Meanwhile, some widgets, such as the menu bar, status bar, and<a id="id11" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> toolbar can't be selected, so we have to right-click on them in <strong class="calibre10">Object Inspector</strong> and delete them. Since they are useless in this example, it's safe to remove them and we can do this for good.</p><p class="calibre9">Okay, let's understand what needs to be done after the removal. You may want to keep all these push buttons on the same horizontal axis. To do this, perform the following steps:</p><div><ol class="orderedlist"><li class="listitem1">Select all the push buttons either by clicking on them one by one while keeping the <em class="calibre14">Ctrl</em> key pressed or just drawing an enclosing rectangle containing all the buttons.</li><li class="listitem1">Right-click and select <strong class="calibre10">Layout</strong> | <strong class="calibre10">LayOut Horizontally</strong>, The keyboard shortcut for this is <em class="calibre14">Ctrl</em> + <em class="calibre14">H</em>.</li><li class="listitem1">Resize the horizontal layout and adjust its <code class="literal">layoutSpacing</code> by selecting it and dragging any of the points around the selection box until it fits best.</li></ol></div><p class="calibre9">Hmm…! You may have noticed that the text of the <strong class="calibre10">Bonjour</strong> button is longer than the other two buttons, and it should be wider than the others. How do you do this? You can change the property of the horizontal layout object's <code class="literal">layoutStretch</code> property in <strong class="calibre10">Property Editor</strong>. This value indicates the stretch factors of the widgets inside the horizontal layout. They would be laid out in proportion. Change it to <code class="literal">3,3,4</code>, and there you are. The stretched size definitely won't be smaller than the minimum size hint. This is how the zero factor <a id="id12" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>works when there is a nonzero natural number, which means that you need to keep the minimum size instead of getting an error with a zero divisor.</p><p class="calibre9">Now, drag <strong class="calibre10">Plain Text Edit</strong> just below, and not inside, the horizontal layout. Obviously, it would be neater if we could extend the plain text edit's width. However, we don't have to do this manually. In fact, we could change the layout of the parent, <strong class="calibre10">MainWindow</strong>. That's it! Right-click on <strong class="calibre10">MainWindow</strong>, and then navigate to <strong class="calibre10">Lay out</strong> | <strong class="calibre10">Lay Out Vertically</strong>. Wow! All the children widgets are automatically extended to the inner boundary of <strong class="calibre10">MainWindow</strong>; they are kept in a vertical order. You'll also find <strong class="calibre10">Layout</strong> settings in the <code class="literal">centralWidget</code> property, which is exactly the same thing as the previous horizontal layout.</p><p class="calibre9">The last thing to make this application halfway decent is to change the title of the window. <code class="literal">MainWindow</code> is not the title you want, right? Click on <strong class="calibre10">MainWindow</strong> in the object tree. Then, scroll down its properties to find <strong class="calibre10">windowTitle</strong>. Name it whatever you want. In this example, I changed it to <code class="literal">Greeting</code>. Now, run the application again and you will see it looks like what is shown in the following screenshot:</p><div><img src="img/4615OS_01_02.jpg" alt="Changing the layout of widgets" class="calibre18"/></div></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch01lvl1sec10" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Understanding the mechanism of signals and slots</h1></div></div></div><p class="calibre9">It is really important to<a id="id13" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> keep your curiosity and to explore what on earth these properties do. However, please remember to revert the changes you made to<a id="id14" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the app, as we are about to enter the core part of Qt, that is, signals and slots.</p><div><div><h3 class="title4"><a id="note03" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">Signals and slots are<a id="id15" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> used for communication between objects. The signals and slots <a id="id16" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>mechanism is a central feature of Qt and probably the part that differs the most from the features provided by other frameworks.</p></div></div><p class="calibre9">Have you ever wondered why a<a id="id17" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> window closes after the <strong class="calibre10">Close</strong> button is clicked on? Developers who are familiar with other toolkits would say that the <strong class="calibre10">Close</strong> button being clicked on is an event, and this event is bound with a callback function that is responsible for closing the window. Well, it's not quite the same in the world of Qt. Since Qt uses a mechanism called signals and slots, it makes the callback function weakly coupled to the event. Also, we usually use the terms signal and slot in Qt. A signal is emitted when a particular event occurs. A slot is a<a id="id18" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> function that is called in response to a particular signal. The following simple<a id="id19" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> and schematic diagram helps you understand the relation between signals, events, and slots:</p><div><img src="img/4615OS_01_03.jpg" alt="Understanding the mechanism of signals and slots" class="calibre19"/></div><p class="calibre9">Qt has tons of predefined signals and slots, which cover its general purposes. However, it's indeed commonplace to add your own slots to handle the target signals. You may also be interested in subclassing widgets and writing your own signals, which will be covered later. The mechanism of <a id="id20" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>signals and slots was designed to be type-safe because of its requirement of the list of the same arguments. In fact, the slot may have a shorter arguments<a id="id21" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> list than the signal since it can ignore the extras. You can have as many arguments as you want. This enables you to forget about the wildcard <code class="literal">void*</code> type in C and other toolkits.</p><p class="calibre9">Since Qt 5, this mechanism is even safer because we can use a new syntax of signals and slots to deal with the connections. A conversion of a piece of code is demonstrated here. Let's see what a typical connect statement in old style is:</p><div><pre class="programlisting">connect(sender, SIGNAL(textChanged(QString)), receiver, SLOT(updateText(QString)));</pre></div><p class="calibre9">This can be rewritten in a new syntax style:</p><div><pre class="programlisting">connect(sender, &amp;Sender::textChanged, receiver, &amp;Receiver::updateText);</pre></div><p class="calibre9">In the traditional way of writing code, the verification of signals and slots only happens at runtime. In the new style, the compiler can detect the mismatches in the types of arguments and the existence of signals and slots at compile time.</p><div><div><h3 class="title4"><a id="note04" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">As long as it is possible, all <code class="literal">connect</code> statements are written in the new syntax style in this book.</p></div></div><p class="calibre9">Now, let's get back to our application. I'll show you how to display some words in a plain text edit when the <strong class="calibre10">Hello</strong> button is clicked on. First of all, we need to create a slot since Qt has already<a id="id22" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> predefined the clicked signal for the <code class="literal">QPushButton</code> class. Edit <code class="literal">mainwindow.h</code> and add a slot<a id="id23" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> declaration:</p><div><pre class="programlisting">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;

namespace Ui {
    class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();

private slots:
    void displayHello();

private:
    Ui::MainWindow *ui;
};

#endif // MAINWINDOW_H</pre></div><p class="calibre9">As you can see, it's the <code class="literal">slots</code> keyword that distinguishes slots from ordinary functions. I declared it private to restrict access permission. You have to declare it a <code class="literal">public</code> slot if you need to invoke it in an object from other classes. After this declaration, we have to implement it in the <code class="literal">mainwindow.cpp</code> file. The implementation of the <code class="literal">displayHello</code> slot is written as follows:</p><div><pre class="programlisting">void MainWindow::displayHello()
{
    ui-&gt;plainTextEdit-&gt;appendPlainText(QString("Hello"));
}</pre></div><p class="calibre9">It simply calls a member function of the plain text edit in order to add a <code class="literal">Hello</code> QString to it. <code class="literal">QString</code> is a core class that Qt has introduced. It provides a Unicode character string, which efficiently solves the internationalization issue. It's also convenient to convert a <code class="literal">QString</code> class to <code class="literal">std::string</code> and vice versa. Besides, just like the other <code class="literal">QObject</code> classes, <code class="literal">QString</code> uses an implicit sharing mechanism to reduce memory usage and avoid needless copying. If you<a id="id24" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> don't want to get concerned about the scenes shown in the following code, just take <code class="literal">QString</code> as an improved version of <code class="literal">std::string</code>. Now, we need to<a id="id25" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> connect this slot to the signal that the <strong class="calibre10">Hello</strong> push button will emit:</p><div><pre class="programlisting">MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);

    connect(ui-&gt;helloButton, &amp;QPushButton::clicked, this, &amp;MainWindow::displayHello);
}</pre></div><p class="calibre9">What I did is add a <code class="literal">connect</code> statement to the constructor of <code class="literal">MainWindow</code>. In fact, we can connect signals and slots anywhere and at any time. However, the connection only exists after this line gets executed. So, it's a common practice to have lots of <code class="literal">connect</code> statements in the construction functions instead of spreading them out. For a better understanding, run your application and see what happens when you click on the <strong class="calibre10">Hello</strong> button. Every time you click, a <strong class="calibre10">Hello</strong> text will be appended to the plain text edit. The following screenshot is what happened after we clicked on the <strong class="calibre10">Hello</strong> button three times:</p><div><img src="img/4615OS_01_04.jpg" alt="Understanding the mechanism of signals and slots" class="calibre18"/></div><p class="calibre9">Getting confused? Let me walk you through this. When you clicked on the <strong class="calibre10">Hello</strong> button, it emitted a clicked signal. Then, the code inside the <code class="literal">displayHello</code> slot got executed, because we connected the clicked signal of the <strong class="calibre10">Hello</strong> button to the <code class="literal">displayHello</code> slot of <code class="literal">MainWindow</code>. What the <code class="literal">displayHello</code> slot did is that it simply appended <code class="literal">Hello</code> to the plain text edit.</p><p class="calibre9">It may take you some time<a id="id26" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> to fully understand the mechanism of signals and slots. Just take your time. I'll show you another example of how to disconnect such a connection after we clicked on the <strong class="calibre10">Hola</strong> button. Similarly, add a declaration of the slot to the header file<a id="id27" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> and define it in the source file. I pasted the content of the <code class="literal">mainwindow.h</code> header file, as follows:</p><div><pre class="programlisting">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;

namespace Ui {
    class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();

private slots:
    void displayHello();
    void onHolaClicked();

private:
    Ui::MainWindow *ui;
};

#endif // MAINWINDOW_H</pre></div><p class="calibre9">It's only declaring a<a id="id28" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">onHolaClicked</code> slot that differed from the original. Here's the content of the source<a id="id29" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> file:</p><div><pre class="programlisting">#include "mainwindow.h"
#include "ui_mainwindow.h"

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);

    connect(ui-&gt;helloButton, &amp;QPushButton::clicked, this, &amp;MainWindow::displayHello);
    connect(ui-&gt;holaButton, &amp;QPushButton::clicked, this, &amp;MainWindow::onHolaClicked);
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::displayHello()
{
    ui-&gt;plainTextEdit-&gt;appendPlainText(QString("Hello"));
}

void MainWindow::onHolaClicked()
{
    ui-&gt;plainTextEdit-&gt;appendPlainText(QString("Hola"));
    disconnect(ui-&gt;helloButton, &amp;QPushButton::clicked, this, &amp;MainWindow::displayHello);
}</pre></div><p class="calibre9">You'll find that the <strong class="calibre10">Hello</strong> button no longer works after you clicked on the <strong class="calibre10">Hola</strong> button. This is because in the <code class="literal">onHolaClicked</code> slot, we just disconnected the binding between the clicked signal of <code class="literal">helloButton</code> and the <code class="literal">displayHello</code> slot of <code class="literal">MainWindow</code>. Actually, <code class="literal">disconnect</code> has some overloaded functions and can be used in a more destructive way. For example, you may <a id="id30" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>want to disconnect all connections between a specific signal sender and a specific receiver:</p><div><pre class="programlisting">disconnect(ui-&gt;helloButton, 0, this, 0);</pre></div><p class="calibre9">If you want to disconnect all the slots associated with a signal, since a signal can be connected to as many slots <a id="id31" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>as you wish, the code can be written like this:</p><div><pre class="programlisting">disconnect(ui-&gt;helloButton, &amp;QPushButton::clicked, 0, 0);</pre></div><p class="calibre9">We can also disconnect all the signals in an object, whatever slots they might be connected to. The following code will disconnect all the signals in <code class="literal">helloButton</code>, which of course includes the clicked signal:</p><div><pre class="programlisting">disconnect(ui-&gt;helloButton, 0, 0, 0);</pre></div><p class="calibre9">Just like a signal, a slot can be connected to as many signals as you want. However, there's no such function to disconnect a specific slot from all the signals.</p><div><div><h3 class="title4"><a id="tip03" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Tip</h3><p class="calibre15">Always remember the signals and slots that you have connected.</p></div></div><p class="calibre9">Apart from the new syntax for traditional connections of signals and slots, Qt 5 has offered a new way to simplify such a binding process with C++11 lambda expressions. As you may have noticed, it's kind of tedious to declare a slot in the header file, define it in the source code file, and then connect it to a signal. It's worthwhile if the slot has a lot of statements, otherwise it becomes time consuming and increases the complexity. Before we go any further, we need to turn on C++11 support on Qt. Edit the pro file (<code class="literal">layout_demo.pro</code> in my example) and add the following line to it:</p><div><pre class="programlisting">CONFIG += c++11</pre></div><div><div><h3 class="title4"><a id="note05" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">Note that some old compilers don't support C++11. If this happens, upgrade your compiler.</p></div></div><p class="calibre9">Now, you need to navigate to <strong class="calibre10">Build</strong> | <strong class="calibre10">Run qmake</strong> to reconfigure the project properly. If everything is okay, we can go back to editing the <code class="literal">mainwindow.cpp</code> file. This way, there is no need to declare a slot and define and connect it. Just add a <code class="literal">connect</code> statement to the construction function of <code class="literal">MainWindow</code>:</p><div><pre class="programlisting">connect(ui-&gt;bonjourButton, &amp;QPushButton::clicked, [this](){
    ui-&gt;plainTextEdit-&gt;appendPlainText(QString("Bonjour"));
});</pre></div><p class="calibre9">It's very <a id="id32" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>straightforward, isn't it? The third argument is a lambda expression, which was added to C++ since C++11.</p><div><div><h3 class="title4"><a id="note06" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">For more details<a id="id33" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> about lambda expression, visit <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://en.cppreference.com/w/cpp/language/lambda">http://en.cppreference.com/w/cpp/language/lambda</a>.</p></div></div><p class="calibre9">This pair of signal and slot connection is done if you don't do need to to<a id="id34" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> disconnect such a connection. However, if you need, you have to save this connection, which is a <code class="literal">QMetaObject::Connection</code> type. In order to disconnect this connection elsewhere, it would be better to declare it as a variable of <code class="literal">MainWindow</code>. So the header file becomes as follows:</p><div><pre class="programlisting">#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;

namespace Ui {
    class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();

private slots:
    void displayHello();
    void onHolaClicked();

private:
    Ui::MainWindow *ui;
    QMetaObject::Connection bonjourConnection;
};

#endif // MAINWINDOW_H</pre></div><p class="calibre9">Here, I declared <code class="literal">bonjourConnection</code> as an object of <code class="literal">QMetaObject::Connection</code> so that we can save the connection dealing with an unnamed slot. Similarly, the disconnection<a id="id35" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> happens in <code class="literal">onHolaClicked</code>, so there won't be any new <code class="literal">Bonjour</code> text on screen after we click on<a id="id36" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the <strong class="calibre10">Hola</strong> button. Here is the content of <code class="literal">mainwindow.cpp</code>:</p><div><pre class="programlisting">#include "mainwindow.h"
#include "ui_mainwindow.h"

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);

    connect(ui-&gt;helloButton, &amp;QPushButton::clicked, this, &amp;MainWindow::displayHello);
    connect(ui-&gt;holaButton, &amp;QPushButton::clicked, this, &amp;MainWindow::onHolaClicked);
    bonjourConnection = connect(ui-&gt;bonjourButton, &amp;QPushButton::clicked, [this](){
        ui-&gt;plainTextEdit-&gt;appendPlainText(QString("Bonjour"));
    });
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::displayHello()
{
    ui-&gt;plainTextEdit-&gt;appendPlainText(QString("Hello"));
}

void MainWindow::onHolaClicked()
{
    ui-&gt;plainTextEdit-&gt;appendPlainText(QString("Hola"));
    disconnect(ui-&gt;helloButton, &amp;QPushButton::clicked, this, &amp;MainWindow::displayHello);
    disconnect(bonjourConnection);
}</pre></div><div><div><h3 class="title4"><a id="tip04" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Tip</h3><p class="calibre15">
<strong class="calibre10">Downloading the example code</strong>
</p><p class="calibre15">You can download the example code files from your account at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p class="calibre9">This is indeed another new usage of <code class="literal">disconnect</code>. It takes in a <code class="literal">QMetaObject::Connection</code> object as the only<a id="id37" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> argument. You'll thank this new overloaded function if<a id="id38" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> you're going to use the lambda expression as a slot.</p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch01lvl1sec11" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Connecting two signals</h1></div></div></div><p class="calibre9">Due to the weak<a id="id39" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> couplings of the Qt signals and slot mechanisms, it is viable to bind signals to each other. It may sound confusing, so let me draw a diagram to <a id="id40" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>make it clear:</p><div><img src="img/4615OS_01_05.jpg" alt="Connecting two signals" class="calibre20"/></div><p class="calibre9">When an event triggers a specific signal, this emitted signal could be another event, which will emit another specific signal. It is not a very common practice, but it tends to be useful when you deal with some complex signals and slot connection networks, especially when tons of events lead to the emission of only a few signals. Although it definitely increases the complexity of the project, binding these signals could simplify the code a lot. Append the following statement to the construction function of <code class="literal">MainWindow</code>:</p><div><pre class="programlisting">connect(ui-&gt;bonjourButton, &amp;QPushButton::clicked, ui-&gt;helloButton, &amp;QPushButton::clicked);</pre></div><p class="calibre9">You'll get two lines in a plain text edit after you click on the <strong class="calibre10">Bonjour</strong> button. The first line is <strong class="calibre10">Bonjour</strong> and the second one is <strong class="calibre10">Hello</strong>. Apparently, this is because we coupled the clicked signal of the <strong class="calibre10">Bonjour</strong> button with the clicked signal of the <strong class="calibre10">Hello</strong> button. The clicked signal of the latter has already been coupled with a slot, which results in the new text line, <strong class="calibre10">Hello</strong>. In fact, it has the same effect as the following statement:</p><div><pre class="programlisting">connect(ui-&gt;bonjourButton, &amp;QPushButton::clicked, [this](){
    emit ui-&gt;helloButton-&gt;clicked();
});</pre></div><p class="calibre9">Basically, connecting two signals is a simplified version of connecting a signal and a slot, while the slot is meant to emit another signal. As for priority, the slot(s) of the latter signal will be handled when the event loop is returned to the object.</p><p class="calibre9">However, it is impossible to<a id="id41" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> connect two slots because the mechanism requires a signal while a slot is considered a receiver instead of a sender. Therefore, if you want to simplify the connection, just wrap these slots as one slot, which can be used for connections. </p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch01lvl1sec12" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Creating a Qt Quick application</h1></div></div></div><p class="calibre9">We already covered how to create a Qt (C++) application. How about giving the newly introduced Qt Quick application development a try? Qt Quick was<a id="id42" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> introduced in Qt 4.8 and it is now becoming mature in Qt 5. Because the QML file is usually platform-independent, it enables you to develop an application for multiple targets, including mobile operating systems with the same code.</p><p class="calibre9">In this chapter, I'll show you how to create a simple Qt Quick application based on Qt Quick Controls 1.2, as follows:</p><div><ol class="orderedlist"><li class="listitem1">Create a new project named <code class="literal">HelloQML</code>.</li><li class="listitem1">Select <strong class="calibre10">Qt Quick Application</strong> instead of <strong class="calibre10">Qt Widgets Application</strong>, which we chose previously.</li><li class="listitem1">Select <strong class="calibre10">Qt Quick Controls 1.2</strong> when the wizard navigates you to <strong class="calibre10">Select Qt Quick Components Set</strong>.</li></ol></div><p class="calibre9">Qt Quick Controls has been introduced since Qt 5.1 and is highly recommended because it enables you to build a complete and native user interface. You can also control the top-level window properties from QML. Getting confused by QML and Qt Quick?</p><div><div><h3 class="title4"><a id="note07" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Note</h3><p class="calibre15">QML is a user interface specification and programming language. It allows developers and designers alike to create highly performant, fluidly animated, and visually appealing applications. QML offers a highly readable, declarative, JSON-like syntax with support for imperative JavaScript expressions combined with dynamic property bindings.</p></div></div><p class="calibre9">While Qt Quick is the standard library for QML, it sounds like the relation between STL and C++. The difference is that QML is dedicated to user interface design and Qt Quick includes a lot of visual types, animations, and so on. Before we go any further, I want to inform you that QML is different from C++ but similar to JavaScript and JSON.</p><p class="calibre9">Edit the <code class="literal">main.qml</code> file under the root of the <code class="literal">Resources</code> file, <code class="literal">qml.qrc</code>, which Qt Creator has generated for our new Qt Quick project. Let's see how the code should be:</p><div><pre class="programlisting">import QtQuick 2.3
import QtQuick.Controls 1.2

ApplicationWindow {
    visible: true
    width: 640
    height: 480
    title: qsTr("Hello QML")

    menuBar: MenuBar {
        Menu {
            title: qsTr("File")
            MenuItem {
                text: qsTr("Exit")
                shortcut: "Ctrl+Q"
                onTriggered: Qt.quit()
            }
        }
    }

    Text {
        id: hw
        text: qsTr("Hello World")
        font.capitalization: Font.AllUppercase
        anchors.centerIn: parent
    }

    Label {
        anchors { bottom: hw.top; bottomMargin: 5; horizontalCenter: hw.horizontalCenter }
        text: qsTr("Hello Qt Quick")
    }
}</pre></div><p class="calibre9">If you have ever touched Java or Python, the first two lines won't be too unfamiliar to you. It simply imports Qt Quick and Qt Quick Controls, and the number following is the version of the library. You may need to change the version if there is a newer library. Importing other libraries is a common practice when developing Qt Quick applications.</p><p class="calibre9">The body of this QML source file is actually in the JSON style, which enables you to understand the hierarchy <a id="id43" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>of the user interface through the code. Here, the root item is <code class="literal">ApplicationWindow</code>, which is basically the same thing as <code class="literal">MainWindow</code> in the previous topics, and we use braces to enclose the statements just like in a JSON file. Although you could use a semicolon to mark an ending of a statement just like we do in C++, there is no need to do this. As you can see, the property definition needs a colon if it's a single-line statement and enclosing braces if it contains more than one subproperty.</p><p class="calibre9">The statements are kind of self explanatory and they are similar to the properties that we saw in the Qt Widgets application. A <code class="literal">qsTr</code> function is<a id="id44" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> used for internationalization and localization. Strings marked by <code class="literal">qsTr</code> could be translated by Qt Linguist. In addition to this, you don't need to care about QString and <code class="literal">std::string</code> any more. All the strings in QML are encoded in the same coding as the QML file and the QML file is created in UTF-8 by default.</p><p class="calibre9">As for the signals and slots mechanism in Qt Quick, it's easy if you only use QML to write the callback function to the corresponding slot. Here, we execute <code class="literal">Qt.quit()</code> inside the <code class="literal">onTriggered</code> slot of <code class="literal">MenuItem</code>. It's viable to connect the signal of a QML item to a C++ object's slot, which I'll introduce later.</p><p class="calibre9">When you run this application in Windows, you can barely find the difference between the <code class="literal">Text</code> item and the<a id="id45" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> <code class="literal">Label</code> item. However, on some platforms, or when you change the system font and/or its color, you'll find that <code class="literal">Label</code> follows the font and the color scheme of the system, while <code class="literal">Text</code> doesn't. Although you can use the properties of <code class="literal">Text</code> to customize the appearance of <code class="literal">Label</code>, it would be better to use the system settings to keep the looks of the application native. Well, if you run this application right now, it will appear similar to what is shown in the following screenshot:</p><div><img src="img/4615OS_01_06.jpg" alt="Creating a Qt Quick application" class="calibre21"/></div><p class="calibre9">Because there is no separate UI file for the Qt Quick applications, only a QML file, we use the <code class="literal">anchors</code> property to position the items, and <code class="literal">anchors.centerIn</code> will position the item in the center of the parent. There is an integrated Qt Quick <a id="id46" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>Designer in Qt Creator, which could help you design the user interface of a Qt Quick application. If you need it, just navigate to <strong class="calibre10">Design</strong> mode when you're editing a QML file. However, I suggest you stay in <strong class="calibre10">Edit</strong> mode to understand the meaning of each statement.</p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch01lvl1sec13" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Connecting C++ slots to QML signals</h1></div></div></div><p class="calibre9">The<a id="id47" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> separation<a id="id48" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> of the user interface and backend <a id="id49" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>allows us to connect C++ slots to the QML signals. Although it's possible to write processing functions in QML and manipulate interface items in C++, it violates the principle of the separation. Therefore, you may want to know how to connect a C++ slot to a QML signal at first. As for connecting a QML slot to a C++ signal, I'll introduce that later in this book.</p><p class="calibre9">In order to demonstrate this, we need to create a C++ class in the first place by right-clicking on the project in the <strong class="calibre10">Projects</strong> panel and selecting <strong class="calibre10">Add New…</strong>. Then, click on <strong class="calibre10">C++ Class</strong> in the pop-up window. The newly created class should at least inherit from <code class="literal">QObject</code> by choosing <code class="literal">QObject</code> as its base class. This is because a plain C++ class can't include Qt's slots or<a id="id50" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> signals. The header file's content is displayed as follows:</p><div><pre class="programlisting">#ifndef PROCESSOR_H
#define PROCESSOR_H

#include &lt;QObject&gt;

class Processor : public QObject
{
    Q_OBJECT
public:
    explicit Processor(QObject *parent = 0);

public slots:
    void onMenuClicked(const QString &amp;);
};

#endif // PROCESSOR_H</pre></div><p class="calibre9">Here's the content of the source file:</p><div><pre class="programlisting">#include &lt;QDebug&gt;
#include "processor.h"

Processor::Processor(QObject *parent) :
    QObject(parent)
{
}

void Processor::onMenuClicked(const QString &amp;str)
{
    qDebug() &lt;&lt; str;
}</pre></div><p class="calibre9">The C++ file is the same as <a id="id51" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>the one we dealt with in the previous topics. The <code class="literal">onMenuClicked</code> slot I defined is simply to output the string that passes through the signal. Note that you have to include <code class="literal">QDebug</code> if you want to use the<a id="id52" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> built-in functions of <code class="literal">qDebug</code>, <code class="literal">qWarning</code>, <code class="literal">qCritical</code>, and so on.</p><p class="calibre9">The slot is prepared, so we need to add a signal to the QML file. The QML file is changed to the <a id="id53" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/>following code:</p><div><pre class="programlisting">import QtQuick 2.3
import QtQuick.Controls 1.2

ApplicationWindow {
    id: window
    visible: true
    width: 640
    height: 480
    title: qsTr("Hello QML")
    signal menuClicked(string str)

    menuBar: MenuBar {
        Menu {
            title: qsTr("File")
            MenuItem {
                text: qsTr("Exit")
                shortcut: "Ctrl+Q"
                onTriggered: Qt.quit()
            }
            MenuItem {
                text: qsTr("Click Me")
                onTriggered: window.menuClicked(text)
            }
        }
    }

    Text {
        id: hw
        text: qsTr("Hello World")
        font.capitalization: Font.AllUppercase
        anchors.centerIn: parent
    }

    Label {
        anchors { bottom: hw.top; bottomMargin: 5; horizontalCenter: hw.horizontalCenter }
        text: qsTr("Hello Qt Quick")
    }
}</pre></div><p class="calibre9">As you can see, I specified the ID of the root <code class="literal">ApplicationWindow</code> item to window and declared a signal named <code class="literal">menuClicked</code>. In addition to this, there is another <code class="literal">MenuItem</code> in the menu file. It emits the <code class="literal">menuClicked</code> signal of window, using its text as the parameter.</p><p class="calibre9">Now, let's connect<a id="id54" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> the slot in the C++ file to this newly created QML signal. Edit the <code class="literal">main.cpp</code> file.</p><div><pre class="programlisting">#include &lt;QApplication&gt;
#include &lt;QQmlApplicationEngine&gt;
#include "processor.h"

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    QQmlApplicationEngine engine;
    engine.load(QUrl(QStringLiteral("qrc:///main.qml")));

    QObject *firstRootItem = engine.rootObjects().first();
    Processor myProcessor;
    QObject::connect(firstRootItem, SIGNAL(menuClicked(QString)), &amp;myProcessor, SLOT(onMenuClicked(QString)));

    return app.exec();
}</pre></div><p class="calibre9">The item in the QML file is accessed as <code class="literal">QObject</code> in C++ and it could be cast to <code class="literal">QQuickItem</code>. For now, we only need to connect its signal, so <code class="literal">QObject</code> will do.</p><p class="calibre9">You may notice that<a id="id55" class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2"/> I used the old-style syntax of the <code class="literal">connect</code> statement. This is because QML is dynamic and the C++ compiler can't detect the existence of the signal in the QML file. Since things in QML are checked at runtime, it doesn't make sense to use the old syntax here.</p><p class="calibre9">When you run this application and navigate to <strong class="calibre10">File</strong> | <strong class="calibre10">Click Me</strong> in the menu bar, you'll see <strong class="calibre10">Application Output</strong> in Qt Creator:</p><div><pre class="programlisting">"Click Me"</pre></div><p class="calibre9">Let's review this process again. Triggering the <code class="literal">Click Me</code> menu item resulted in the emission of the window's signal <code class="literal">menuClicked</code>. This signal passed the text of <code class="literal">MenuItem</code>, which is <code class="literal">Click Me</code>, to the slot in C++ class <code class="literal">Processor</code>, and the processor <code class="literal">myProcessor</code> slot <code class="literal">onMenuClicked</code> printed the string to the <strong class="calibre10">Application Output</strong> panel.</p></div></div>



  
<div><div><div><div><div><h1 class="title2"><a id="ch01lvl1sec14" class="calibre7 pcalibre pcalibre3 pcalibre2 pcalibre1"/>Summary</h1></div></div></div><p class="calibre9">In this chapter, we learned the fundamentals of Qt, which included steps for how to create a Qt application. Then, we had a walk-through of both Qt Widgets and Qt Quick, and how to change the layout. Finally, we rounded off by covering an important concept about the mechanism of signals and slots.</p><p class="calibre9">In the next chapter, we will have a chance to put this knowledge into practice and get started on building a real-world, and of course cross-platform, Qt application.</p></div></div>



  </body></html>