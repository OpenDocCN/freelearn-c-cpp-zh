<html><head></head><body>
<div class="book" title="Chapter&#xA0;6.&#xA0;Objects, Classes, and Inheritance"><div class="book" id="190862-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Objects, Classes, and Inheritance</h1></div></div></div><p class="calibre9">In the previous chapter, we discussed functions as a way to bundle up a bunch of lines of related code. We talked about how functions abstracted away implementation details and how the <code class="email">sqrt()</code> function does not require you to understand how it works internally to use it to find roots. This was a good thing, primarily because it saved the programmer time and effort, while making the actual work of finding square roots easier. This principle of <span class="strong"><em class="calibre10">abstraction</em></span> will come up again here when we discuss objects.</p><p class="calibre9">In a nutshell, objects tie together methods and their related data into a single structure. This structure is called a <span class="strong"><em class="calibre10">class</em></span>. The main idea of using objects is to create a code representation for every thing inside your game. Every object represented in the code will have data and associated functions that operate on that data. So you'd have an <span class="strong"><em class="calibre10">object</em></span> to represent your player instance and related functions that make the player <code class="email">jump()</code>, <code class="email">shoot()</code>, and <code class="email">pickupItem()</code> functions. You'd also have an object to represent every monster instance and related functions such as <code class="email">growl()</code>, <code class="email">attack()</code>, and possibly <code class="email">follow()</code>.</p><p class="calibre9">Objects are types of variables, though, and objects will stay in memory as long as you keep them there. You create an object instance once when the thing in your game it represents is created, and you destroy the object instance when the thing in your game it represents dies.</p><p class="calibre9">Objects can be used to represent in-game things, but they can also be used to represent any other type of thing. For example, you can store an image as an object. The data fields will be the image's width of the image, its height, and the collection of pixels inside it. C++ strings are also objects.</p><div class="note" title="Note"><h3 class="title2"><a id="tip40" class="calibre1"/>Tip</h3><p class="calibre9">This chapter contains a lot of keywords that might be difficult to grasp at first, including <code class="email">virtual</code> and <code class="email">abstract</code>.</p><p class="calibre9">Don't let the more difficult sections of this chapter bog you down. I included descriptions of many advanced concepts for completeness. However, bear in mind that you don't need to completely understand everything in this chapter to write working C++ code in UE4. It helps to understand it, but if something doesn't make sense, don't get stuck. Give it a read and then move on. Probably what will happen is you will not get it at first, but remember a reference to the concept in question when you're coding. Then, when you open this book up again, "voilà!" It will make sense.</p></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Objects, Classes, and Inheritance">
<div class="book" title="struct objects"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec40" class="calibre1"/>struct objects</h1></div></div></div><p class="calibre9">An <a id="id226" class="calibre1"/>object in C++ is basically any variable type that is made up of a conglomerate of simpler types. The most basic object in C++ is <code class="email">struct</code>. We use the <code class="email">struct</code> keyword to glue together a bunch of smaller variables into one big variable. If you recall, we did introduce <code class="email">struct</code> briefly in <a class="calibre1" title="Chapter 2. Variables and Memory" href="part0022_split_000.html#KVCC2-dd4a3f777fc247568443d5ffb917736d">Chapter 2</a>, <span class="strong"><em class="calibre10">Variables and Memory</em></span>. Let's revise that simple example:</p><div class="note"><pre class="programlisting">struct Player
{
  string name;
  int hp;
};</pre></div><p class="calibre9">This is the structure definition for what makes a <code class="email">Player</code> object. The player has a <code class="email">string</code> for his <code class="email">name</code> and an integer for his <code class="email">hp</code> value.</p><p class="calibre9">If you'll recall from <a class="calibre1" title="Chapter 2. Variables and Memory" href="part0022_split_000.html#KVCC2-dd4a3f777fc247568443d5ffb917736d">Chapter 2</a>, <span class="strong"><em class="calibre10">Variables and Memory</em></span>, the way we make an instance of the <code class="email">Player</code> object is like this:</p><div class="note"><pre class="programlisting">Player me;    // create an instance of Player, called me</pre></div><p class="calibre9">From here, we can access the fields of the <code class="email">me</code> object like so:</p><div class="note"><pre class="programlisting">me.name = "Tom";
me.hp = 100;</pre></div></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Objects, Classes, and Inheritance">
<div class="book" title="struct objects">
<div class="book" title="Member functions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec64" class="calibre1"/>Member functions</h2></div></div></div><p class="calibre9">Now, here's<a id="id227" class="calibre1"/> the exciting part. We can attach member functions to the <code class="email">struct</code> definition simply by writing these functions inside the <code class="email">struct Player</code> definition.</p><div class="note"><pre class="programlisting">struct Player
{
  string name;
  int hp;
  // A member function that reduces player hp by some amount
  void damage( int amount )	
  {
    hp -= amount;
  }
  void recover( int amount )
  {
    hp += amount;
}
};</pre></div><p class="calibre9">A member function<a id="id228" class="calibre1"/> is just a C++ function that is declared inside a <code class="email">struct</code> or <code class="email">class</code> definition. Isn't that a great idea?</p><p class="calibre9">There is a bit of a funny idea here, so I'll just come out and say it. The variables of <code class="email">struct Player</code> are accessible to all the functions inside <code class="email">struct Player</code>. Inside each of the member functions of <code class="email">struct Player</code>, we can actually access the <code class="email">name</code> and <code class="email">hp</code> variables as if they were local to the function. In other words, the <code class="email">name</code> and <code class="email">hp</code> variables of <code class="email">struct Player</code> are shared between all the member functions of <code class="email">struct Player</code>.</p><div class="book" title="The this keyword"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec15" class="calibre1"/>The this keyword</h3></div></div></div><p class="calibre9">In some C++ code (in later chapters), you will<a id="id229" class="calibre1"/> see more references to the <code class="email">this</code> keyword. The <code class="email">this</code> keyword is a pointer that refers to the current object. Inside the <code class="email">Player::damage()</code> function, for example, we can write our reference to <code class="email">this</code> explicitly:</p><div class="note"><pre class="programlisting">void damage( int amount )
{
  this-&gt;hp -= amount;
}</pre></div><p class="calibre9">The <code class="email">this</code> keyword only makes sense inside a member function. We could explicitly include use of keyword <code class="email">this</code> inside member functions, but without writing <code class="email">this</code>, it is implied that we are talking about the <code class="email">hp</code> of the current object.</p></div></div></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Objects, Classes, and Inheritance">
<div class="book" title="struct objects">
<div class="book" title="Strings are objects?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec65" class="calibre1"/>Strings are objects?</h2></div></div></div><p class="calibre9">Yes! Every time<a id="id230" class="calibre1"/> you've used a string variable in the past, you were using an object. Let's try out some of the member functions of the <code class="email">string</code> class.</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main()
{
  string s = "strings are objects";
  s.append( "!!" ); // add on "!!" to end of the string!
  cout &lt;&lt; s &lt;&lt; endl;
}</pre></div><p class="calibre9">What we've done here is use the <code class="email">append()</code> member function to add on two extra characters to the end of the string (<code class="email">!!</code>). Member functions always apply to the object that calls the member function (the object to the left of the dot).</p><div class="note" title="Note"><h3 class="title2"><a id="tip41" class="calibre1"/>Tip</h3><p class="calibre9">To see the listing of members and member functions available on an object, type the object's variable name in Visual Studio, then a dot (<code class="email">.</code>), then press <span class="strong"><em class="calibre10">Ctrl</em></span> and spacebar. A member listing will pop up.</p></div><div class="mediaobject"><img src="../images/00060.jpeg" alt="Strings are objects?" class="calibre11"/><div class="caption"><p class="calibre16">Pressing <span class="strong"><em class="calibre10">Ctrl</em></span> and spacebar will make the member listing appear</p></div></div><p class="calibre12"> </p></div></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Objects, Classes, and Inheritance">
<div class="book" title="struct objects">
<div class="book" title="Invoking a member function"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec66" class="calibre1"/>Invoking a member function</h2></div></div></div><p class="calibre9">Member functions <a id="id231" class="calibre1"/>can be invoked with the following syntax:</p><div class="note"><pre class="programlisting">objectName.memberFunction();</pre></div><p class="calibre9">The object invoking the member function is on the left of the dot. The member function to call is on the right of the dot. A member function invocation is always followed by round brackets <code class="email">()</code>, even when no arguments are passed to the brackets.</p><p class="calibre9">So, in the part of the program where the monster attacks, we can reduce the player's <code class="email">hp</code> value like so:</p><div class="note"><pre class="programlisting">player.damage( 15 );  // player takes 15 damage</pre></div><p class="calibre9">Which isn't that more readable than the following:</p><div class="note"><pre class="programlisting">player.hp -= 15;      // player takes 15 damage</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip42" class="calibre1"/>Tip</h3><p class="calibre9">When member functions and objects are used effectively, your code will read more like prose or poetry than a bunch of operator symbols slammed together.</p></div><p class="calibre9">Besides beauty and readability, what is the point of writing member functions? Outside the <code class="email">Player</code> object, we can now do more with a single line of code than just reduce the <code class="email">hp</code> member by <code class="email">15</code>. We can also do other things as we're reducing the player's <code class="email">hp</code>, such as take into account the player's armor, check whether the player is invulnerable, or have other effects occur when the player is damaged. What happens when the player is damaged should be abstracted away by the <code class="email">damage()</code> function.</p><p class="calibre9">Now think if the player had an armor class. Let's add a field to <code class="email">struct Player</code> for armor class:</p><div class="note"><pre class="programlisting">struct Player
{
  string name;
  int hp;
  int armorClass;
};</pre></div><p class="calibre9">We'd need to reduce the damage received by the player by the armor class of the player. So we'd type a formula now to reduce <code class="email">hp</code>. We can do it the non-object-oriented way by accessing the data fields of the <code class="email">player</code> object directly:</p><div class="note"><pre class="programlisting">player.hp -= 15 – player.armorClass; // non OOP</pre></div><p class="calibre9">Otherwise, we can <a id="id232" class="calibre1"/>do it the object-oriented way by writing a member function that changes the data members of the <code class="email">player</code> object as needed. Inside the <code class="email">Player</code> object, we can write a member function <code class="email">damage()</code>:</p><div class="note"><pre class="programlisting">struct Player
{
  string name;
  int hp;
  int armorClass; 
void damage( int dmgAmount )	
  {
    hp -= dmgAmount - armorClass;
  }
};</pre></div><div class="book" title="Exercises"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec16" class="calibre1"/>Exercises</h3></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">There is a <a id="id233" class="calibre1"/>subtle bug in the player's <code class="email">damage</code> function in the preceding code. Can you find and fix it? Hint: What happens if the damage dealt is less than <code class="email">armorClass</code> of the player?</li><li class="listitem" value="2">Having only a number for armor class doesn't give enough information about the armor! What is the armor's name? What does it look like? Devise a <code class="email">struct</code> function for the Player's armor with fields for name, armor class, and durability rating.</li></ol><div class="calibre14"/></div></div><div class="book" title="Solutions"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec17" class="calibre1"/>Solutions</h3></div></div></div><p class="calibre9">The <a id="id234" class="calibre1"/>solution is in the <code class="email">struct</code> player code listed in the next section, <span class="strong"><em class="calibre10">Privates and encapsulation</em></span>.</p><p class="calibre9">How about using the following code:</p><div class="note"><pre class="programlisting">struct Armor
{
  string name;
  int armorClass;
  double durability;
};</pre></div><p class="calibre9">An instance of <code class="email">Armor</code> will then be placed inside <code class="email">struct Player</code>:</p><div class="note"><pre class="programlisting">struct Player
{
  string name;
  int hp;
  Armor armor; // Player has-an Armor
};</pre></div><p class="calibre9">This means<a id="id235" class="calibre1"/> the player has an armor. Keep this in mind—we'll explore <code class="email">has-a</code> versus <code class="email">is-a</code> relationships later.</p></div></div></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Objects, Classes, and Inheritance">
<div class="book" title="struct objects">
<div class="book" title="Privates and encapsulation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch06lvl2sec67" class="calibre1"/>Privates and encapsulation</h2></div></div></div><p class="calibre9">So now we've defined a couple of member functions, whose purpose it is to modify and maintain the data members of our <code class="email">Player</code> object, but some people have come up with an argument.</p><p class="calibre9">The argument is as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">An object's data members should only ever be accessed only through its member functions, never directly.</li></ul></div><p class="calibre9">This means that you should never access an object's data members from outside the object directly, in other words, modify the player's <code class="email">hp</code> directly:</p><div class="note"><pre class="programlisting">player.hp -= 15 – player.armorClass; // bad: direct member access</pre></div><p class="calibre9">This should be forbidden, and users of the class should be forced to use the proper member functions instead to change the values of data members:</p><div class="note"><pre class="programlisting">player.damage( 15 );	// right: access thru member function</pre></div><p class="calibre9">This principle is <a id="id236" class="calibre1"/>called <a id="id237" class="calibre1"/>
<span class="strong"><em class="calibre10">encapsulation</em></span>. Encapsulation is the concept that every object should be interacted via its member functions only. Encapsulation says that raw data members should never be accessed directly.</p><p class="calibre9">The reasons<a id="id238" class="calibre1"/> behind encapsulation are:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">To make the class self contained</strong></span>: The primary idea behind encapsulation is that objects work best when they are programmed such that they manage and maintain their own internal state variables without a need for code outside the class to examine that class' private data. When objects are coded this way, it makes the object much easier to work with, that is, easier to read and maintain. To make the player object jump, you should just have to call <code class="email">player.jump()</code>; let the player object manage state changes to its <code class="email">y-height</code> position (making the player jump!). When an object's internal members are not exposed, interacting <a id="id239" class="calibre1"/>with that object is much easier and more efficient. Interact only with an object's public member functions; let the object manage its internal state (we will explain the keywords <code class="email">private</code> and <code class="email">public</code> in a moment).</li><li class="listitem"><span class="strong"><strong class="calibre2">To avoid breaking code</strong></span>: When code outside of a class interacts with that class' public member functions only (the class' public interface), then an object's internal state management is free to change, without breaking any of the calling code. This way, if an object's internal data members change for any reason, all code using the object still remains valid as long as the member functions remain the same.</li></ul></div><p class="calibre9">So how can we prevent the programmer from doing the wrong thing and accessing data members directly? C++ introduces the concept of <span class="strong"><em class="calibre10">access modifiers</em></span> to prevent access of an object's internal data.</p><p class="calibre9">Here is how we'd use access modifiers to forbid access to certain sections of <code class="email">struct Player</code> from outside of <code class="email">struct Player</code>.</p><p class="calibre9">The first thing you'd do is decide which sections of the <code class="email">struct</code> definition you want to be accessible outside of the class. These section will be labelled <code class="email">public</code>. All other regions that will not be accessible outside of <code class="email">struct</code> will be labelled <code class="email">private</code>, as follows:</p><div class="note"><pre class="programlisting">struct Player
{
private:        // begins private section.. cannot be accessed 
                // outside the class until
  string name;
  int hp; 
  int armorClass;
public:         //  until HERE. This begins the public section
  // This member function is accessible outside the struct
  // because it is in the section marked public:
  void damage( int amount )
  {
    int reduction = amount – armorClass;
    if( reduction &lt; 0 ) // make sure non-negative!
      reduction = 0;
    hp -= reduction;
  }
};</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Objects, Classes, and Inheritance">
<div class="book" title="struct objects">
<div class="book" title="Some people like it public"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch06lvl2sec68" class="calibre1"/>Some people like it public</h2></div></div></div><p class="calibre9">Some people<a id="id240" class="calibre1"/> do unabashedly use <code class="email">public</code> data members and do not encapsulate their objects. This is a matter of preference, though considered as bad object-oriented programming practice.</p><p class="calibre9">However, classes in UE4 do use <code class="email">public</code> members sometimes. It's a judgment call; whether a data member should be <code class="email">public</code> or <code class="email">private</code> is really up to the programmer.</p><p class="calibre9">With experience, you will find that sometimes you get into a situation that requires quite a bit of refactoring when you make a data member <code class="email">public</code> that should have been <code class="email">private</code>.</p></div></div></div>
<div class="book" title="class versus struct" id="19UOO1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec41" class="calibre1"/>class versus struct</h1></div></div></div><p class="calibre9">You might <a id="id241" class="calibre1"/>have seen a different way of declaring an object, using the <code class="email">class</code> keyword, instead of <code class="email">struct</code>, as shown in the following code:</p><div class="note"><pre class="programlisting">class Player // we used class here instead of struct!
{
  string name;
  //
};</pre></div><p class="calibre9">The<a id="id242" class="calibre1"/> <code class="email">class</code> and <code class="email">struct</code>
<a id="id243" class="calibre1"/> keywords in C++ are almost identical. There is only one difference between <code class="email">class</code> and <code class="email">struct</code>, and it is that the data members inside a <code class="email">struct</code> keyword will be declared <code class="email">public</code> by default, while in a <code class="email">class</code> keyword the data members inside the class will be declared <code class="email">private</code> by default. (This is why I introduced objects using <code class="email">struct</code>; I didn't want to put <code class="email">public</code> inexplicably as the first line of <code class="email">class</code>.)</p><p class="calibre9">In general, <code class="email">struct</code> is preferred for simple types that don't use encapsulation, don't have many member functions, and must be backward compatible with C. Classes are used almost everywhere else.</p><p class="calibre9">From now on, let's use the <code class="email">class</code> keyword instead of <code class="email">struct</code>.</p></div>

<div class="book" title="Getters and setters" id="1AT9A1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec42" class="calibre1"/>Getters and setters</h1></div></div></div><p class="calibre9">You might <a id="id244" class="calibre1"/>have noticed that once we slap <code class="email">private</code> onto the <code class="email">Player</code> class definition, we can no longer read or write the name of the player from outside the <code class="email">Player</code> class.</p><p class="calibre9">If we try and read the name with the following code:</p><div class="note"><pre class="programlisting">Player me;
cout &lt;&lt; me.name &lt;&lt; endl;</pre></div><p class="calibre9">Or write to the name, as follows:</p><div class="note"><pre class="programlisting">me.name = "William";</pre></div><p class="calibre9">Using the <code class="email">struct Player</code> definition with <code class="email">private</code> members, we will get the following error:</p><div class="note"><pre class="programlisting">
<span class="strong"><strong class="calibre2">main.cpp(24) : error C2248: 'Player::name' : cannot access private member declared in class 'Player'</strong></span>
</pre></div><p class="calibre9">This is just what we asked for when we labeled the <code class="email">name</code> field <code class="email">private</code>. We made it completely inaccessible outside the <code class="email">Player</code> class.</p></div>

<div class="book" title="Getters and setters" id="1AT9A1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Getters"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec69" class="calibre1"/>Getters</h2></div></div></div><p class="calibre9">A<a id="id245" class="calibre1"/> getter (also known as an accessor function) is used to pass back copies of internal data members to the caller. To read the player's name, we'd deck out the <code class="email">Player</code> class with a member function specifically to retrieve a copy of that <code class="email">private</code> data member:</p><div class="note"><pre class="programlisting">class Player
{
private:
  string name;  // inaccessible outside this class!
                //  rest of class as before
public:
  // A getter function retrieves a copy of a variable for you
  string getName()
{
  return name;
}
};</pre></div><p class="calibre9">So now it is possible to read the player's name information. We can do this by using the following code statement:</p><div class="note"><pre class="programlisting">cout &lt;&lt; player.getName() &lt;&lt; endl;</pre></div><p class="calibre9">Getters are used to retrieve <code class="email">private</code> members that would otherwise be inaccessible to you from outside the class.</p><div class="note" title="Note"><h3 class="title2"><a id="tip43" class="calibre1"/>Tip</h3><p class="calibre9">
<span class="strong"><strong class="calibre2">Real world tip–Keyword const</strong></span>
</p><p class="calibre9">Inside a class, you can add the <code class="email">const</code> keyword to a member function declaration. What the <code class="email">const</code> keyword does is promises to the compiler that the internal state of the object will not change as a result of running this function. Attaching the <code class="email">const</code> keyword will look something like this:</p><div class="note"><pre class="programlisting">string getName() const
{
  return name;
}</pre></div><p class="calibre9">No assignments to data members can happen inside a member function that is marked <code class="email">const</code>. As the internal state of the object is guaranteed not to change as a result of running a <code class="email">const</code> function, the compiler can make some optimizations around function calls to <code class="email">const</code> member functions.</p></div></div></div>

<div class="book" title="Getters and setters" id="1AT9A1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="Setters"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec70" class="calibre1"/>Setters</h2></div></div></div><p class="calibre9">A <a id="id246" class="calibre1"/>setter (also known as a modifier function or mutator function) is a member function whose sole purpose is to change the value of an internal variable inside the class, as shown in the following code:</p><div class="note"><pre class="programlisting">class Player
{
private:
  string name;  // inaccessible outside this class!
                //  rest of class as before
public:
  // A getter function retrieves a copy of a variable for you
  string getName()
{
  return name;
}
void setName( string newName )
{
  name = newName;
}
};</pre></div><p class="calibre9">So we can still change the <code class="email">private</code> function of a <code class="email">class</code> from outside the <code class="email">class</code> function, but only if we do so through a setter function.</p></div></div>

<div class="book" title="Getters and setters" id="1AT9A1-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="But what's the point of get/set operations?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec71" class="calibre1"/>But what's the point of get/set operations?</h2></div></div></div><p class="calibre9">So the first question <a id="id247" class="calibre1"/>that crosses a newbie programmer's mind when he first encounters get/set operations on <code class="email">private</code> members is, isn't get/set self-defeating? I mean, what's the point in hiding access to data members when we're just going to expose that same data again in another way? It's like saying, "You can't have any chocolates because they are private, unless you say please <code class="email">getMeTheChocolate()</code>. Then, you can have the chocolates."</p><p class="calibre9">Some expert programmers even shorten the get/set functions to one liners, like this:</p><div class="note"><pre class="programlisting">string getName(){ return name; }
void setName( string newName ){ name = newName; }</pre></div><p class="calibre9">Let's answer the question. Doesn't a get/set pair break encapsulation by exposing the data completely?</p><p class="calibre9">The answer is twofold. First, get member functions typically only return a copy of the data member being accessed. This means that the original data member's value remains protected and is not modifiable through a <a id="id248" class="calibre1"/>
<code class="email">get()</code> operation.</p><p class="calibre9">
<code class="email">Set()</code> (mutator method) operations are a little bit counterintuitive though. If the setter is a <code class="email">passthru</code> operation, such as <code class="email">void setName( string newName ) { name=newName; }</code>, then having the setter might seem pointless. What is the advantage of using a mutator method instead of overwriting the variable directly?</p><p class="calibre9">The argument for using mutator methods is to write additional code before the assignment of a variable to guard the variable from taking on incorrect values. Say, for example, we have a setter for the <code class="email">hp</code> data member, which will look like this:</p><div class="note"><pre class="programlisting">void setHp( int newHp )
{
  // guard the hp variable from taking on negative values
  if( newHp &lt; 0 )
  {
    cout &lt;&lt; "Error, player hp cannot be less than 0" &lt;&lt; endl;
    newHp = 0;
  }
  hp = newHp;
}</pre></div><p class="calibre9">The mutator method is supposed to prevent the internal <code class="email">hp</code> data member from taking on negative values. You might consider mutator methods a bit retroactive. Should the responsibility lie with the calling code to check the value it is setting before calling <code class="email">setHp( -2 )</code>, and not let that only get caught in the mutator method? Can't you use a <code class="email">public</code> member variable and put the responsibility for making sure the variable doesn't take on invalid values in the calling code, instead of in the setter? You can.</p><p class="calibre9">However, this <a id="id249" class="calibre1"/>is the core of the reason behind using mutator methods. The <a id="id250" class="calibre1"/>idea behind mutator methods is so that the calling code can pass any value it wants to the <code class="email">setHp</code> function (for example, <code class="email">setHp( -2 )</code>), without having to worry whether the value it is passing to the function is valid or not. The <code class="email">setHp</code> function then takes the responsibility of ensuring that the value is valid for the <code class="email">hp</code> variable.</p><p class="calibre9">Some programmers consider direct mutator functions such as <code class="email">getHp()</code>/<code class="email">setHp()</code> a code smell. A code smell is in general a bad programming practice that people don't overtly take notice of, except for a niggling feeling that something is being done suboptimally. They argue that higher-level member functions can be written instead of mutators. For example, instead of a <code class="email">setHp()</code> member function, we should have <code class="email">public</code> member functions such as <code class="email">heal()</code> and <code class="email">damage()</code> instead. An article on this topic is available at <a class="calibre1" href="http://c2.com/cgi/wiki?AccessorsAreEvil">http://c2.com/cgi/wiki?AccessorsAreEvil</a>.</p></div></div>
<div class="book" title="Constructors and destructors" id="1BRPS1-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec43" class="calibre1"/>Constructors and destructors</h1></div></div></div><p class="calibre9">The <a id="id251" class="calibre1"/>constructor in your C++ code is a simple little function that runs once when the C++ object is first created. The destructor <a id="id252" class="calibre1"/>runs once when the C++ object is destroyed. Say we have the following program:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Player
{
private:
  string name;  // inaccessible outside this class!
public:
  string getName(){ return name; }
// The constructor!
  Player()
  {
    cout &lt;&lt; "Player object constructed" &lt;&lt; endl;
    name = "Diplo";
  }
  // ~Destructor (~ is not a typo!)
  ~Player()
  {
    cout &lt;&lt; "Player object destroyed" &lt;&lt; endl;
  }
};

int main()
  {
    Player player;
    cout &lt;&lt; "Player named '" &lt;&lt; player.getName() &lt;&lt; "'" &lt;&lt; endl;
  }
  // player object destroyed here</pre></div><p class="calibre9">So here we have <a id="id253" class="calibre1"/>created a <code class="email">Player</code> object. The output of this code will be as follows:</p><div class="note"><pre class="programlisting">Player object constructed
Player named 'Diplo'
Player object destroyed</pre></div><p class="calibre9">The first thing that <a id="id254" class="calibre1"/>happens during object construction is that the constructor actually runs. This prints the line <code class="email">Player object constructed</code>. Following this, the line with the player's name gets printed: <code class="email">Player named 'Diplo'</code>. Why is the player named <span class="strong"><em class="calibre10">Diplo</em></span>? Because that is the name assigned in the <code class="email">Player()</code> constructor.</p><p class="calibre9">Finally, at the end of the program, the player destructor gets called, and we see <code class="email">Player object destroyed</code>. The player object gets destroyed when it goes out of scope at the end of <code class="email">main()</code> (at <code class="email">}</code> of <code class="email">main</code>).</p><p class="calibre9">So what are constructors and destructors good for? Exactly what they appear to be for: setting up and tearing down of an object. The constructor can be used for initialization of data fields and the destructor to call delete on any dynamically allocated resources (we haven't covered dynamically allocated resources yet, so don't worry about this last point yet).</p></div>

<div class="book" title="Class inheritance"><div class="book" id="1CQAE2-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec44" class="calibre1"/>Class inheritance</h1></div></div></div><p class="calibre9">You <a id="id255" class="calibre1"/>use inheritance when you want to create a new, more functional class of code, based on some existing class of code. Inheritance is a tricky topic to cover. Let's start with the concept of a <span class="strong"><em class="calibre10">derived class</em></span> (or subclass).</p></div>

<div class="book" title="Class inheritance">
<div class="book" title="Derived classes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec72" class="calibre1"/>Derived classes</h2></div></div></div><p class="calibre9">The<a id="id256" class="calibre1"/> most natural way to consider inheritance is by analogy with the animal kingdom. The classification of living things is shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00061.jpeg" alt="Derived classes" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">What this diagram means is that <span class="strong"><strong class="calibre2">Dog</strong></span>, <span class="strong"><strong class="calibre2">Cat</strong></span>, <span class="strong"><strong class="calibre2">Horse</strong></span>
<span class="strong"><strong class="calibre2">,</strong></span> and <span class="strong"><strong class="calibre2">Human</strong></span> are all <span class="strong"><strong class="calibre2">Mammals</strong></span>. What that means is that dog, cat, horse, and human all share some common characteristics, such as having common organs (brain with neocortex, lungs, liver, and uterus in females), while being completely different in other regard. How each walks is different. How each talks is also different.</p><p class="calibre9">What does that mean if you were coding creatures? You would only have to program the common functionality once. Then, you would implement the code for the different parts specifically for each of the dog, cat, horse and human classes.</p><p class="calibre9">A concrete example of the preceding figure is as follows:</p><div class="note"><pre class="programlisting">#include &lt;iostream&gt;
using namespace std;
class Mammal
{
protected:
  // protected variables are like privates: they are
  // accessible in this class but not outside the class.
  // the difference between protected and private is
  // protected means accessible in derived subclasses also
int hp;
  double speed;

public:
  // Mammal constructor – runs FIRST before derived class ctors!
Mammal()
{
  hp = 100;
  speed = 1.0;
  cout &lt;&lt; "A mammal is created!" &lt;&lt; endl;
}
~Mammal()
{
  cout &lt;&lt; "A mammal has fallen!" &lt;&lt; endl;
}
// Common function to all Mammals and derivatives
  void breathe()
  {
    cout &lt;&lt; "Breathe in.. breathe out" &lt;&lt; endl;
  }
  virtual void talk()
  {
    cout &lt;&lt; "Mammal talk.. override this function!" &lt;&lt; endl;
  }
  // pure virtual function, (explained below)
  virtual void walk() = 0;
};

// This next line says "class Dog inherits from class Mammal"
class Dog : public Mammal // : is used for inheritance
{
public:
  Dog()
  {
cout &lt;&lt; "A dog is born!" &lt;&lt; endl;
}
~Dog()
{
  cout &lt;&lt; "The dog died" &lt;&lt; endl;
}
  virtual void talk() override
  {
    cout &lt;&lt; "Woof!" &lt;&lt; endl; // dogs only say woof!
  }
  // implements walking for a dog
  virtual void walk() override
  {
    cout &lt;&lt; "Left front paw &amp; back right paw, right front paw &amp;  back left paw.. at the speed of " &lt;&lt; speed &lt;&lt; endl;
  }
};

class Cat : public Mammal
{
public:
  Cat()
  {
    cout &lt;&lt; "A cat is born" &lt;&lt; endl;
  }
  ~Cat()
  {
    cout &lt;&lt; "The cat has died" &lt;&lt; endl;
  }
virtual void talk() override
  {
    cout &lt;&lt; "Meow!" &lt;&lt; endl;
  }
// implements walking for a cat.. same as dog!
  virtual void walk() override
  {
    cout &lt;&lt; "Left front paw &amp; back right paw, right front paw &amp;  back left paw.. at the speed of " &lt;&lt; speed &lt;&lt; endl;
  }
};

class Human : public Mammal
{
// Data member unique to Human (not found in other Mammals)
  bool civilized;
public:
  Human()
  {
    cout &lt;&lt; "A new human is born" &lt;&lt; endl;
    speed = 2.0; // change speed. Since derived class ctor
    // (ctor is short for constructor!) runs after base 
    // class ctor, initialization sticks initialize member 
    // variables specific to this class
    civilized = true;
  }
  ~Human()
  {
    cout &lt;&lt; "The human has died" &lt;&lt; endl;
  }
  virtual void talk() override
  {
    cout &lt;&lt; "I'm good looking for a .. human" &lt;&lt; endl;
  }
// implements walking for a human..
  virtual void walk() override
  {
    cout &lt;&lt; "Left, right, left, right at the speed of " &lt;&lt; speed  &lt;&lt; endl;
  }
  // member function unique to human derivative
  void attack( Human &amp; other )
  {
    // Human refuses to attack if civilized
    if( civilized )
      cout &lt;&lt; "Why would a human attack another? Je refuse" &lt;&lt;  endl;
    else
      cout &lt;&lt; "A human attacks another!" &lt;&lt; endl;
  }
};

int main()
{
  Human human;
  human.breathe(); // breathe using Mammal base class  functionality
  human.talk();
  human.walk();

  Cat cat;
  cat.breathe(); // breathe using Mammal base class functionality
  cat.talk();
  cat.walk();

  Dog dog;
  dog.breathe();
  dog.talk();
  dog.walk();
}</pre></div><p class="calibre9">All of <code class="email">Dog</code>, <code class="email">Cat</code>, and <code class="email">Human</code> inherit <a id="id257" class="calibre1"/>from <code class="email">class Mammal</code>. This means that dog, cat, and human are mammals, and many more.</p><div class="book" title="Syntax of inheritance"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec18" class="calibre1"/>Syntax of inheritance</h3></div></div></div><p class="calibre9">The<a id="id258" class="calibre1"/> syntax of inheritance is quite simple. Let's take the <code class="email">Human</code> class definition as an example. The following screenshot is a typical inheritance statement:</p><div class="mediaobject"><img src="../images/00062.jpeg" alt="Syntax of inheritance" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">The class on the left of the colon (<span class="strong"><strong class="calibre2">:</strong></span>) is the new, derived class, and the class on the right of the colon is the base class.</p></div><div class="book" title="What does inheritance do?"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec19" class="calibre1"/>What does inheritance do?</h3></div></div></div><p class="calibre9">The <a id="id259" class="calibre1"/>point of inheritance is for the derived class to take on all the characteristics (data members, member functions) of the base class, and then to extend it with even more functionality. For instance, all mammals have a <code class="email">breathe()</code> function. By inheriting from the <code class="email">Mammal</code> class, the <code class="email">Dog</code>, <code class="email">Cat</code>, and <code class="email">Human</code> classes all automatically gain the ability to <code class="email">breathe()</code>.</p><p class="calibre9">Inheritance reduces replication of code since we don't have to re-implement common functionalities (such as <code class="email">.breathe()</code>) for <code class="email">Dog</code>, <code class="email">Cat</code>, and <code class="email">Human</code>. Instead, each of these derived classes enjoys the reuse of the <code class="email">breathe()</code> function defined in <code class="email">class Mammal</code>.</p><p class="calibre9">However, only the <code class="email">Human</code> class has the <code class="email">attack()</code>member function. This would mean that, in our code, only the <code class="email">Human</code> class attacks. The <code class="email">cat.attack()</code> function will introduce a compiler error, unless you write a member function <code class="email">attack()</code> inside <code class="email">class Cat</code> (or in <code class="email">class Mammal</code>).</p></div></div></div>

<div class="book" title="Class inheritance">
<div class="book" title="is-a relationship"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec73" class="calibre1"/>is-a relationship</h2></div></div></div><p class="calibre9">Inheritance<a id="id260" class="calibre1"/> is often said to be<a id="id261" class="calibre1"/> an <code class="email">is-a</code> relationship. When a <code class="email">Human</code> class inherits from <code class="email">Mammal</code> class, then we say that human <span class="strong"><em class="calibre10">is-a</em></span> mammal.</p><div class="mediaobject"><img src="../images/00063.jpeg" alt="is-a relationship" class="calibre11"/><div class="caption"><p class="calibre16">The Human inherits all the traits a Mammal has</p></div></div><p class="calibre12"> </p><p class="calibre9">For example, a <code class="email">Human</code> object contains a <code class="email">Mammal</code> function inside it, as follows:</p><div class="note"><pre class="programlisting">class Human
{
  Mammal mammal;
};</pre></div><p class="calibre9">In this example, we would say <a id="id262" class="calibre1"/>the human <span class="strong"><em class="calibre10">has-a</em></span> <code class="email">Mammal</code> on it somewhere (which would make sense if the human were pregnant, or somehow carrying a mammal).</p><div class="mediaobject"><img src="../images/00064.jpeg" alt="is-a relationship" class="calibre11"/><div class="caption"><p class="calibre16">This Human class instance has some kind of mammal attached in it</p></div></div><p class="calibre12"> </p><p class="calibre9">Remember that we previously gave <code class="email">Player</code> an <code class="email">Armor</code> object inside it. It wouldn't make sense for the <code class="email">Player</code> object to inherit from the <code class="email">Armor</code> class, because it wouldn't make sense to say <span class="strong"><em class="calibre10">the Player is-an Armor</em></span>. When deciding whether one class inherits from another or not in code design (for example, the Human class inherits from the Mammal class), you must always be able to comfortably say something like the Human class <span class="strong"><em class="calibre10">is-a</em></span> Mammal. If the <span class="strong"><em class="calibre10">is-a</em></span> statement sounds wrong, then it is likely that inheritance is the wrong relationship for that pair of objects. </p><p class="calibre9">In the preceding example, we're introducing a few new C++ keywords here. The first is <code class="email">protected</code>.</p></div></div>

<div class="book" title="Class inheritance">
<div class="book" title="protected variables"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec74" class="calibre1"/>protected variables</h2></div></div></div><p class="calibre9">A<a id="id263" class="calibre1"/> <code class="email">protected</code> member variable is different from a <code class="email">public</code> or <code class="email">private</code> variable. All three classes of variables are accessible inside the class in which they are defined. The difference between them is in regard to accessibility outside the class. A <code class="email">public</code> variable is accessible anywhere inside the class and outside the class. A <code class="email">private</code> variable is accessible inside the class but not outside the class. A <code class="email">protected</code> variable is accessible inside the class, and inside of derived subclasses, but is not accessible outside the class. So, the <code class="email">hp</code> and <code class="email">speed</code> members of <code class="email">class Mammal</code> will be accessible in the derived classes Dog, Cat, Horse, and Human, but not outside of these classes (in <code class="email">main()</code> for instance).</p></div></div>

<div class="book" title="Class inheritance">
<div class="book" title="Virtual functions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec75" class="calibre1"/>Virtual functions</h2></div></div></div><p class="calibre9">A virtual function<a id="id264" class="calibre1"/> is a member function whose implementation can be overridden in a derived class. In this example, the <code class="email">talk()</code> member function (defined in <code class="email">class Mammal</code>) is marked <code class="email">virtual</code>. This means that the derived classes might or might not choose to implement their own version of what the <code class="email">talk()</code> member function means.</p></div></div>

<div class="book" title="Class inheritance">
<div class="book" title="Purely virtual functions (and abstract classes)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch06lvl2sec76" class="calibre1"/>Purely virtual functions (and abstract classes)</h2></div></div></div><p class="calibre9">A <a id="id265" class="calibre1"/>purely virtual function is one whose implementation you are required to override in the derived class. The <code class="email">walk()</code> function in <code class="email">class Mammal</code> is purely virtual; it was declared like this:</p><div class="note"><pre class="programlisting">virtual void walk() = 0;</pre></div><p class="calibre9">The <code class="email">= 0</code> part at the end of the preceding code is what makes the function purely <code class="email">virtual</code>.</p><p class="calibre9">The <code class="email">walk()</code> function in <code class="email">class Mammal</code> is purely <code class="email">virtual</code> and this makes the Mammal class abstract. An abstract class in C++ is any class that has at least one purely virtual function.</p><p class="calibre9">If a class contains a purely virtual function and is abstract, then that class cannot be instantiated directly. That is, you cannot create a <code class="email">Mammal</code> object now, on account of the purely virtual function <code class="email">walk()</code>. If you tried to do the following code, you would get an error:</p><div class="note"><pre class="programlisting">int main()
{
  Mammal mammal;
}</pre></div><p class="calibre9">If you try to create a<code class="email"> Mammal</code> object, you will get the following error:</p><div class="note"><pre class="programlisting">error C2259: 'Mammal' : cannot instantiate abstract class</pre></div><p class="calibre9">You can, however, create<a id="id266" class="calibre1"/> instances of derivatives of <code class="email">class Mammal</code>, as long as the derived classes have all of the purely virtual member functions implemented.</p></div></div>

<div class="book" title="Multiple inheritance" id="1DOR01-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec45" class="calibre1"/>Multiple inheritance</h1></div></div></div><p class="calibre9">Not everything<a id="id267" class="calibre1"/> multiple is as good as it sounds. Multiple inheritance is when a derived class inherits from more than one base class. Usually, this works without a hitch if the multiple base classes we are inheriting from are completely unrelated.</p><p class="calibre9">For example, we can have a class <code class="email">Window</code> that inherits from the <code class="email">SoundManager</code> and <code class="email">GraphicsManager</code> base classes. If <code class="email">SoundManager</code> provides a member function <code class="email">playSound()</code> and <code class="email">GraphicsManager</code> provides a member function <code class="email">drawSprite()</code>, then the <code class="email">Window</code> class will be able to use those additional capabilities without a hitch.</p><div class="mediaobject"><img src="../images/00065.jpeg" alt="Multiple inheritance" class="calibre11"/><div class="caption"><p class="calibre16">Game Window inheriting from Sound Man and Graphics Man means Game Window will have both sets of capabilities</p></div></div><p class="calibre12"> </p><p class="calibre9">However, multiple inheritance can have negative consequences. Say we want to create a class <code class="email">Mule</code> that derives from both the <code class="email">Donkey</code> and <code class="email">Horse</code> classes. The <code class="email">Donkey</code> and <code class="email">Horse</code> classes, however, both inherit from the base class <code class="email">Mammal</code>. We instantly have an issue! If we were to call <code class="email">mule.talk()</code>, but <code class="email">mule</code> does not override the <code class="email">talk()</code> function, which member function <a id="id268" class="calibre1"/>should be invoked, that of <code class="email">Horse</code> or <code class="email">Donkey</code>? It's ambiguous.</p></div>

<div class="book" title="Multiple inheritance" id="1DOR01-dd4a3f777fc247568443d5ffb917736d">
<div class="book" title="private inheritance"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec77" class="calibre1"/>private inheritance</h2></div></div></div><p class="calibre9">A less<a id="id269" class="calibre1"/> talked about feature of C++ is <code class="email">private</code> inheritance. Whenever a class inherits from another class publicly, it is known to all code whose parent class it belongs to. For example:</p><div class="note"><pre class="programlisting">class Cat : public Mammal</pre></div><p class="calibre9">This means that all code will know that <code class="email">Cat</code> is an object of <code class="email">Mammal</code>, and it will be possible to point to a <code class="email">Cat*</code> instance using a base class <code class="email">Mammal*</code> pointer. For example, the following code will be valid:</p><div class="note"><pre class="programlisting">Cat cat;
Mammal* mammalPtr = &amp;cat; // Point to the Cat as if it were a 
                          // Mammal</pre></div><p class="calibre9">The preceding code is fine if <code class="email">Cat</code> inherits from <code class="email">Mammal</code> publicly. Private inheritance is where code outside the <code class="email">Cat</code> class is not allowed to know the parent class:</p><div class="note"><pre class="programlisting">class Cat : private Mammal</pre></div><p class="calibre9">Here, externally calling code will not "know" that the <code class="email">Cat</code> class derives from the <code class="email">Mammal</code> class. Casting a <code class="email">Cat</code> instance to the <code class="email">Mammal</code> base class is not allowed by the compiler when inheritance is <code class="email">private</code>. Use <code class="email">private</code> inheritance when you need to hide the fact that a certain class derives from a certain parent class.</p><p class="calibre9">However, private inheritance is rarely used in practice. Most classes just use <code class="email">public</code> inheritance. If you want to know more about private inheritance, see <a class="calibre1" href="http://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c">http://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c</a>.</p></div></div>

<div class="book" title="Putting your classes into headers"><div class="book" id="1ENBI2-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec46" class="calibre1"/>Putting your classes into headers</h1></div></div></div><p class="calibre9">So far, our <a id="id270" class="calibre1"/>classes have just been pasted before <code class="email">main()</code>. If you continue to program that way, your code will all be in one file and appear as one big disorganized mess.</p><p class="calibre9">Therefore, it is a good programming practice to organize your classes into separate files. This makes editing each class's code individually much easier when there are multiple classes inside the project.</p><p class="calibre9">Take <code class="email">class Mammal</code> and its derived classes from earlier. We will properly organize that example into separate files. Let's do it in steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a new file in your C++ project called <code class="email">Mammal.h</code>. Cut and paste the entire <code class="email">Mammal</code> class into that file. Notice that since the <code class="email">Mammal</code> class included the use of <code class="email">cout</code>, we write a <code class="email">#include &lt;iostream&gt;</code> statement in that file as well.</li><li class="listitem" value="2">Write a " <code class="email">#include</code> <code class="email">Mammal.h</code>" statement at the top of your <code class="email">Source.cpp</code> file.</li></ol><div class="calibre14"/></div><p class="calibre9">An example of <a id="id271" class="calibre1"/>what this looks like is shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00066.jpeg" alt="Putting your classes into headers" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">What's happening here when the code is compiled is that the entire <code class="email">Mammal</code> class is copied and pasted (#include) into the <code class="email">Source.cpp</code> file, which contains the <code class="email">main()</code> function, and the rest of the classes are derived from <code class="email">Mammal</code>. Since <code class="email">#include</code> is a copy and paste function, the code will function exactly the same as it did before; the only difference is that it will be much better organized and easier to look at. Compile and run your code at this step to make sure it still works.</p><div class="note" title="Note"><h3 class="title2"><a id="tip45" class="calibre1"/>Tip</h3><p class="calibre9">Check that your code compiles and runs often, especially when refactoring. When you don't know the rules, you're bound to make a lot of mistakes. This is why you should do your refactoring only in small steps. Refactoring is the name for the activity we are doing now—we are reorganizing the source to make better sense to other readers of our codebase. Refactoring usually does not involve rewriting too much of it.</p></div><p class="calibre9">The next thing you need to do is isolate the Dog, Cat, and Human classes into their own files. To do so, create the <code class="email">Dog.h</code>, <code class="email">Cat.h</code>, and <code class="email">Human.h</code> files and add them to your project.</p><p class="calibre9">Let's start with the <a id="id272" class="calibre1"/>Dog class, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00067.jpeg" alt="Putting your classes into headers" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">If you use exactly this setup and try to compile and run your project, you will see the <span class="strong"><strong class="calibre2">'Mammal' : 'class' type redefinition</strong></span> error, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00068.jpeg" alt="Putting your classes into headers" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">What this error means is that <code class="email">Mammal.h</code> has been included twice in your project, once in <code class="email">Source.cpp</code> and then again in <code class="email">Dog.h</code>. This means effectively two versions of the Mammal class got added to the compiling code, and C++ is unsure which version to use.</p><p class="calibre9">There are a few ways to fix this issue, but the easiest (and the one that Unreal Engine uses) is the <code class="email">#pragma once</code> macro, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00069.jpeg" alt="Putting your classes into headers" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">We write <code class="email">#pragma once</code> at the top of each header file. This way, the second time <code class="email">Mammal.h</code> is included, the <a id="id273" class="calibre1"/>compiler doesn't copy and paste its contents again, since it already has been included before, and its content is actually already in the compiling group of files.</p><p class="calibre9">Do the same thing for <code class="email">Cat.h</code> and <code class="email">Human.h</code>, then <code class="email">include</code> them both into your <code class="email">Source.cpp</code> file where your <code class="email">main()</code> function resides.</p><div class="mediaobject"><img src="../images/00070.jpeg" alt="Putting your classes into headers" class="calibre11"/><div class="caption"><p class="calibre16">Diagram with all classes included</p></div></div><p class="calibre12"> </p><p class="calibre9">Now that we've included all classes into your project, the code should compile and run.</p></div>

<div class="book" title="Putting your classes into headers">
<div class="book" title=".h and .cpp"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec78" class="calibre1"/>.h and .cpp</h2></div></div></div><p class="calibre9">The<a id="id274" class="calibre1"/> next level of organization is to leave the class declarations in the header files (<code class="email">.h</code>) and put the actual <a id="id275" class="calibre1"/>function implementation bodies inside some new <code class="email">.cpp</code> files. Also, leave existing members inside the <code class="email">class Mammal</code> declaration.</p><p class="calibre9">For each class, perform the following operations:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Delete all function bodies (code between <code class="email">{</code> and <code class="email">}</code>) and replace them with just a semicolon. For the <code class="email">Mammal</code> class, this would look as follows:<div class="note"><pre class="programlisting">// Mammal.h
#pragma once
class Mammal
{
protected:
  int hp;
  double speed;

public:
  Mammal();
  ~Mammal();
  void breathe();
  virtual void talk();
  // pure virtual function, 
  virtual void walk() = 0;
};</pre></div></li><li class="listitem" value="2">Create a <a id="id276" class="calibre1"/>new <code class="email">.cpp</code> file called <code class="email">Mammal.cpp</code>. Then simply put the <a id="id277" class="calibre1"/>member function bodies inside this file:<div class="note"><pre class="programlisting">// Mammal.cpp
#include &lt;iostream&gt;
using namespace std;

#include "Mammal.h"
Mammal::Mammal() // Notice use of :: (scope resolution operator)
{
  hp = 100;
  speed = 1.0;
  cout &lt;&lt; "A mammal is created!" &lt;&lt; endl;
}
Mammal::~Mammal()
{
  cout &lt;&lt; "A mammal has fallen!" &lt;&lt; endl;
}
void Mammal::breathe()
{
  cout &lt;&lt; "Breathe in.. breathe out" &lt;&lt; endl;
}
void Mammal::talk()
{
  cout &lt;&lt; "Mammal talk.. override this function!" &lt;&lt; endl;
}</pre></div></li></ol><div class="calibre14"/></div><p class="calibre9">It is <a id="id278" class="calibre1"/>important <a id="id279" class="calibre1"/>to note the use of the class name and scope resolution operator (double colon) when declaring the member function bodies. We prefix all member functions belonging to the <code class="email">Mammal</code> class with <code class="email">Mammal::</code>.</p><p class="calibre9">Notice how the purely virtual function does not have a body; it's not supposed to! Purely virtual functions are simply declared (and initialized to 0) in the base class, but implemented later in derived classes.</p></div></div>

<div class="book" title="Putting your classes into headers">
<div class="book" title="Exercise"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec79" class="calibre1"/>Exercise</h2></div></div></div><p class="calibre9">Complete the separation of the different creature classes above into class header (<code class="email">.h</code>) and class definition files (<code class="email">.cpp</code>)</p></div></div>
<div class="book" title="Summary" id="1FLS41-dd4a3f777fc247568443d5ffb917736d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec47" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">You learned about objects in C++; they are pieces of code that tie data members and member functions together into a bundle of code called <code class="email">class</code> or <code class="email">struct</code>. Object-oriented programming means that your code will be filled with things instead of just <code class="email">int</code>, <code class="email">float</code>, and <code class="email">char</code> variables. You will have a variable that represents <code class="email">Barrel</code>, another variable that represents <code class="email">Player</code>, and so on, that is, a variable to represent every entity in your game. You will be able to reuse code by using inheritance; if you had to code implementations of <code class="email">Cat</code> and <code class="email">Dog</code>, you can code a common functionality in the base class <code class="email">Mammal</code>. We also discussed encapsulation and how it is easier and more efficient to program objects such that they maintain their own internal state.</p></div></body></html>