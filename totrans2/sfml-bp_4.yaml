- en: Chapter 4. Playing with Physics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 玩转物理
- en: 'In the previous chapter, we built several games, including a Tetris clone.
    In this chapter, we will add physics into this game and turn it into a new one.
    By doing this, we will learn:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了几个游戏，包括一个俄罗斯方块克隆版。在本章中，我们将向这个游戏添加物理效果，使其变成一个新的游戏。通过这样做，我们将学习：
- en: What is a physics engine
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是物理引擎
- en: How to install and use the Box2D library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装和使用Box2D库
- en: How to pair the physics engine with SFML for the display
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将物理引擎与SFML配合进行显示
- en: How to add physics in the game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在游戏中添加物理效果
- en: In this chapter, we will learn the magic of physics. We will also do some mathematics
    but relax, it's for conversion only. Now, let's go!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习物理的魔法。我们还将做一些数学，但请放心，这只是转换。现在，让我们开始吧！
- en: A physics engine – késako?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理引擎——késako？
- en: In this chapter, we will speak about physics engine, but the first question
    is "what is a physics engine?" so let's explain it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论物理引擎，但首先的问题是“什么是物理引擎？”让我们来解释一下。
- en: A physics engine is a software or library that is able to simulate Physics,
    for example, the Newton-Euler equation that describes the movement of a rigid
    body. A physics engine is also able to manage collisions, and some of them can
    deal with soft bodies and even fluids.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 物理引擎是一种能够模拟物理的软件或库，例如描述刚体运动的牛顿-欧拉方程。物理引擎还能够处理碰撞，其中一些甚至可以处理软体和流体。
- en: There are different kinds of physics engines, mainly categorized into real-time
    engine and non-real-time engine. The first one is mostly used in video games or
    simulators and the second one is used in high performance scientific simulation,
    in the conception of special effects in cinema and animations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的物理引擎，主要分为实时引擎和非实时引擎。第一种主要用于视频游戏或模拟器，第二种用于高性能科学模拟、电影特效和动画的概念设计。
- en: As our goal is to use the engine in a video game, let's focus on real-time-based
    engine. Here again, there are two important types of engines. The first one is
    for 2D and the other for 3D. Of course you can use a 3D engine in a 2D world,
    but it's preferable to use a 2D engine for an optimization purpose. There are
    plenty of engines, but not all of them are open source.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标是将在视频游戏中使用引擎，因此让我们专注于基于实时的引擎。在这里，同样有两种重要的引擎类型。第一种是用于2D的，另一种是用于3D的。当然，你可以在2D世界中使用3D引擎，但出于优化的目的，最好使用2D引擎。有很多引擎，但并非所有都是开源的。
- en: 3D physics engines
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D物理引擎
- en: For 3D games, I advise you to use the `Bullet` physics library. This was integrated
    in the Blender software, and was used in the creation of some commercial games
    and also in the making of films. This is a really good engine written in C/C++
    that can deal with rigid and soft bodies, fluids, collisions, forces… and all
    that you need.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于3D游戏，我建议你使用`Bullet`物理库。它被集成到Blender软件中，并被用于一些商业游戏和电影制作。这是一个用C/C++编写的真正优秀的引擎，可以处理刚体和软体、流体、碰撞、力……以及你需要的一切。
- en: 2D physics engines
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2D物理引擎
- en: As previously said, in a 2D environment, you can use a 3D physics engine; you
    just have to ignore the depth (Z axes). However, the most interesting thing is
    to use an engine optimized for the 2D environment. There are several engines like
    this one and the most famous ones are Box2D and Chipmunk. Both of them are really
    good and none of them are better than the other, but I had to make a choice, which
    was Box2D. I've made this choice not only because of its C++ API that allows you
    to use overload, but also because of the big community involved in the project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在2D环境中，你可以使用3D物理引擎；你只需忽略深度（Z轴）。然而，最有趣的事情是使用针对2D环境优化的引擎。有几种这样的引擎，其中最著名的是Box2D和Chipmunk。它们都非常出色，没有一个比另一个更好，但我不得不做出选择，那就是Box2D。我之所以做出这个选择，不仅是因为它的C++
    API允许你使用重载，还因为该项目拥有庞大的社区。
- en: Physics engine comparing game engine
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理引擎与游戏引擎比较
- en: Do not mistake a physics engine for a game engine. A physics engine only simulates
    a physical world without anything else. There are no graphics, no logics, only
    physics simulation. On the contrary, a game engine, most of the time includes
    a physics engine paired with a render technology (such as OpenGL or DirectX).
    Some predefined logics depend on the goal of the engine (RPG, FPS, and so on)
    and sometimes artificial intelligence. So as you can see, a game engine is more
    complete than a physics engine. The two mostly known engines are Unity and Unreal
    engine, which are both very complete. Moreover, they are free for non-commercial
    usage.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将物理引擎和游戏引擎混淆。物理引擎只模拟物理世界，没有其他任何东西。没有图形，没有逻辑，只有物理模拟。相反，游戏引擎，大多数情况下包括物理引擎和渲染技术（如OpenGL或DirectX）的配套。一些预定义的逻辑取决于引擎的目标（RPG、FPS等），有时还包括人工智能。所以正如你所见，游戏引擎比物理引擎更完整。最知名的两种引擎是Unity和Unreal引擎，它们都非常完整。此外，它们对非商业用途是免费的。
- en: 'So why don''t we directly use a game engine? This is a good question. Sometimes,
    it''s better to use something that is already made, instead of reinventing it.
    However, do we really need all the functionalities of a game engine for this project?
    More importantly, what do we need it for? Let''s see the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们为什么不直接使用游戏引擎呢？这是一个很好的问题。有时候，使用现成的东西，而不是重新发明轮子，会更好。然而，我们真的需要游戏引擎的所有功能来完成这个项目吗？更重要的是，我们需要它来做什么？让我们看看以下内容：
- en: A graphic output
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形输出
- en: Physics engine that can manage collision
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够处理碰撞的物理引擎
- en: Nothing else is required. So as you can see, using a game engine for this project
    would be like killing a fly with a bazooka. I hope that you have understood the
    aim of a physics engine, the differences between a game and physics engine, and
    the reason for the choices made for the project described in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他需要的东西。所以正如你所见，为这个项目使用游戏引擎就像是杀蚊子用火箭筒。我希望你已经理解了物理引擎的目的，游戏引擎和物理引擎之间的区别，以及本章所述项目中做出的选择的原因。
- en: Using Box2D
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Box2D
- en: 'As previously said, Box2D is a physics engine. It has a lot of features, but
    the most important for the project are the following (taken from the Box2D documentation):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Box2D是一个物理引擎。它有很多功能，但对我们项目来说最重要的如下（摘自Box2D文档）：
- en: '**Collision**: This functionality is very interesting as it allows our tetrimino
    to interact with each other'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞**：这个功能非常有趣，因为它允许我们的俄罗斯方块相互交互'
- en: Continuous collision detection
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续碰撞检测
- en: Rigid bodies (convex polygons and circles)
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刚体（凸多边形和圆形）
- en: Multiple shapes per body
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个物体可以有多个形状
- en: '**Physics**: This functionality will allow a piece to fall down and more'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理**：这个功能将允许一个物体落下，等等'
- en: Continuous physics with the time of impact solver
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于碰撞时间解算器的连续物理
- en: Joint limits, motors, and friction
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关节限制、电机和摩擦
- en: Fairly accurate reaction forces/impulses
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对准确的反应力/冲量
- en: As you can see, Box2D provides all that we need in order to build our game.
    There are a lot of other features usable with this engine, but they don't interest
    us right now so I will not describe them in detail. However, if you are interested,
    you can take a look at the official website for more details on the Box2D features
    ([http://box2d.org/about/](http://box2d.org/about/)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Box2D为我们提供了构建游戏所需的一切。这个引擎还有很多其他可用功能，但它们目前对我们来说并不重要，所以不会详细描述。然而，如果你感兴趣，可以查看Box2D官方网站了解更多关于其功能的信息([http://box2d.org/about/](http://box2d.org/about/))。
- en: It's important to note that Box2D uses meters, kilograms, seconds, and radians
    for the angle as units; SFML uses pixels, seconds, and degrees. So we will need
    to make some conversions. I will come back to this later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Box2D使用米、千克、秒和弧度作为角度的单位；SFML使用像素、秒和度。因此，我们需要进行一些转换。我稍后会回到这个问题。
- en: Preparing Box2D
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备Box2D
- en: Now that Box2D is introduced, let's install it. You will find the list of available
    versions on the Google code project page at [https://code.google.com/p/box2d/downloads/list](https://code.google.com/p/box2d/downloads/list).
    Currently, the latest stable version is 2.3\. Once you have downloaded the source
    code (from compressed file or using SVN), you will need to build it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经介绍了Box2D，让我们来安装它。你可以在Google代码项目页面上找到可用的版本列表[https://code.google.com/p/box2d/downloads/list](https://code.google.com/p/box2d/downloads/list)。目前，最新的稳定版本是2.3。一旦你下载了源代码（从压缩文件或使用SVN），你将需要构建它。
- en: Build
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建
- en: 'Here is the good news, Box2D uses CMake as build process so you just have to
    follow the exact same steps as the SFML build described in the first chapter of
    this book and you will successfully build Box2D. If everything is fine, you will
    find the example project at this place: `path/to/Box2D/build/Testbed/Testbed`.
    Now, let''s install it.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是好消息，Box2D 使用 CMake 作为构建过程，所以你只需遵循本书第一章中描述的 SFML 构建步骤，你就能成功构建 Box2D。如果一切顺利，你将在以下位置找到示例项目：`path/to/Box2D/build/Testbed/Testbed`。现在，让我们来安装它。
- en: Install
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装
- en: Once you have successfully built your Box2D library, you will need to configure
    your system or IDE to find the Box2D library and headers. The newly built library
    can be found in the `/path/to/Box2D/build/Box2D/` directory and is named `libBox2D.a`.
    On the other hand, the headers are located in the `path/to/Box2D/Box2D/` directory.
    If everything is okay, you will find a `Box2D.h` file in the folder.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你成功构建了你的 Box2D 库，你需要配置你的系统或 IDE 以找到 Box2D 库和头文件。新构建的库可以在 `/path/to/Box2D/build/Box2D/`
    目录下找到，命名为 `libBox2D.a`。另一方面，头文件位于 `path/to/Box2D/Box2D/` 目录中。如果一切正常，你将在文件夹中找到一个
    `Box2D.h` 文件。
- en: 'On Linux, the following command adds Box2D to your system without requiring
    any configuration:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，以下命令将 Box2D 添加到你的系统，无需任何配置：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Pairing Box2D and SFML
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配对 Box2D 和 SFML
- en: 'Now that Box2D is installed and your system is configured to find it, let''s
    build the physics "hello world": a falling square.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Box2D已经安装，并且你的系统已经配置好以找到它，让我们构建物理“hello world”：一个下落的正方形。
- en: It's important to note that Box2D uses meters, kilograms, seconds, and radian
    for angle as units; SFML uses pixels, seconds, and degrees. So we will need to
    make some conversions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Box2D 使用米、千克、秒和弧度作为单位；SFML 使用像素、秒和度。因此，我们需要进行一些转换。
- en: Converting radians to degrees or vice versa is not difficult, but pixels to
    meters… this is another story. In fact, there is no way to convert a pixel to
    meter, unless if the number of pixels per meter is fixed. This is the technique
    that we will use.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 弧度转换为度或反之亦然并不困难，但像素转换为米……这又是另一回事。事实上，没有方法可以将像素转换为米，除非每米的像素数是固定的。这就是我们将使用的技术。
- en: 'So let''s start by creating some utility functions. We should be able to convert
    radians to degrees, degrees to radians, meters to pixels, and finally pixels to
    meters. We will also need to fix the pixel per meter value. As we don''t need
    any class for these functions, we will define them in a namespace converter. This
    will result as the following code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们先创建一些实用函数。我们应该能够将弧度转换为度，度转换为弧度，米转换为像素，最后像素转换为米。我们还需要设置每米像素值。由于我们不需要任何类来为这些函数，我们将它们定义在命名空间
    converter 中。这将导致以下代码片段：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, there is no difficulty here. We start to define some constants
    and then the convert functions. I've chosen to make the function template to allow
    the use of any number type. In practice, it will mostly be `double` or `int`.
    The conversion functions are also declared as `constexpr` to allow the compiler
    to calculate the value at compile time if it's possible (for example, with constant
    as a parameter). It's interesting because we will use this primitive a lot.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里没有困难。我们开始定义一些常量，然后是转换函数。我选择使函数模板允许使用任何数字类型。在实践中，它将主要是 `double` 或 `int`。转换函数也被声明为
    `constexpr`，以便编译器在可能的情况下在编译时计算值（例如，使用常量作为参数）。这很有趣，因为我们将会大量使用这个原始函数。
- en: Box2D, how does it work?
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Box2D，它是如何工作的？
- en: Now that we can convert SFML unit to Box2D unit and vice versa, we can pair
    Box2D with SFML. But first, how exactly does Box2D work?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将 SFML 单位转换为 Box2D 单位，反之亦然，我们可以将 Box2D 与 SFML 配对。但首先，Box2D 究竟是如何工作的？
- en: 'Box2D works a lot like a physics engine:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 工作方式与物理引擎非常相似：
- en: You start by creating an empty world with some gravity.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先创建一个带有一些重力的空世界。
- en: Then, you create some object patterns. Each pattern contains the shape of the
    object position, its type (static or dynamic), and some other characteristics
    such as its density, friction, and energy restitution.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你创建一些对象模式。每个模式包含对象的形状、位置、类型（静态或动态），以及一些其他特性，如密度、摩擦和能量恢复。
- en: You ask the world to create a new object defined by the pattern.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你要求世界创建一个由模式定义的新对象。
- en: In each game loop, you have to update the physical world with a small step such
    as our world in the games we've already made.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个游戏循环中，你必须用一个小步骤更新物理世界，就像我们在已经制作的游戏中的世界一样。
- en: Because the physics engine does not display anything on the screen, we will
    need to loop all the objects and display them by ourselves.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为物理引擎不会在屏幕上显示任何内容，所以我们需要遍历所有对象并自行显示它们。
- en: 'Let''s start by creating a simple scene with two kinds of objects: a ground
    and square. The ground will be fixed and the squares will not. The square will
    be generated by a user event: mouse click.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单的场景开始，其中包含两种对象：地面和正方形。地面将是固定的，而正方形则不是。正方形将通过用户事件生成：鼠标点击。
- en: This project is very simple, but the goal is to show you how to use Box2D and
    SFML together with a simple case study. A more complex one will come later.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目非常简单，但目标是展示如何使用 Box2D 和 SFML 结合一个简单的案例研究。更复杂的一个将会稍后出现。
- en: 'We will need three functionalities for this small project to:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这个小型项目三个功能：
- en: Create a shape
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个形状
- en: Display the world
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示世界
- en: Update/fill the world
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新/填充世界
- en: 'Of course there is also the initialization of the world and window. Let''s
    start with the main function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有世界和窗口的初始化。让我们从主函数开始：
- en: As always, we create a window for the display and we limit the FPS number to
    60\. I will come back to this point with the `displayWorld` function.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们创建一个用于显示的窗口，并将 FPS 数量限制为 60。我将在 `displayWorld` 函数中回到这一点。
- en: We create the physical world from Box2D, with gravity as a parameter.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从 Box2D 创建物理世界，并将重力作为参数。
- en: We create a container that will store all the physical objects for the memory
    clean purpose.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个容器，用于存储所有物理对象以进行内存清理。
- en: We create the ground by calling the `createBox` function (explained just after).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过调用 `createBox` 函数（稍后解释）创建地面。
- en: 'Now it is time for the minimalist `game` loop:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候进行极简的 `game` 循环了：
- en: Close event managements
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭事件管理
- en: Create a box by detecting that the right button of the mouse is pressed
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过检测鼠标右键被按下创建一个框
- en: 'Finally, we clean the memory before exiting the program:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在退出程序之前，我们清理内存：
- en: '[PRE2]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For the moment, except the Box2D world, nothing should surprise you so let's
    continue with the box creation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，除了 Box2D 世界外，不应该有任何令人惊讶的内容，让我们继续创建框。
- en: This function is under the `book` namespace.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数位于 `book` 命名空间下。
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function contains a lot of new functionalities. Its goal is to create
    a rectangle of a specific size at a predefined position. The type of this rectangle
    is also set by the user (dynamic or static). Here again, let''s explain the function
    step-by-step:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数包含许多新功能。其目标是创建一个在预定义位置特定大小的矩形。此矩形的类型也是由用户设置的（动态或静态）。在这里，让我们一步一步解释这个函数：
- en: We create `b2BodyDef`. This object contains the definition of the body to create.
    So we set the position and its type. This position will be in relation to the
    gravity center of the object.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建 `b2BodyDef`。此对象包含要创建的身体的定义。因此，我们设置位置和类型。此位置将与物体的重力中心相关。
- en: Then, we create `b2Shape`. This is the physical shape of the object, in our
    case, a box. Note that the `SetAsBox()` method doesn't take the same parameter
    as `sf::RectangleShape`. The parameters are half the size of the box. This is
    why we need to divide the values by two.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建 `b2Shape`。这是对象的物理形状，在我们的例子中，是一个框。请注意，`SetAsBox()` 方法不使用与 `sf::RectangleShape`
    相同的参数。参数是框大小的一半。这就是为什么我们需要将值除以二的原因。
- en: We create `b2FixtureDef` and initialize it. This object holds all the physical
    characteristics of the object such as its density, friction, restitution, and
    shape.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建 `b2FixtureDef` 并初始化它。此对象包含对象的全部物理特性，如密度、摩擦、恢复力和形状。
- en: Then, we properly create the object in the physical world.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们正确地在物理世界中创建对象。
- en: Now, we create the display of the object. This will be more familiar because
    we will only use SFML. We create a rectangle and set its position, origin, and
    color.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建对象的显示。这将更加熟悉，因为我们只使用 SFML。我们创建一个矩形并设置其位置、原点和颜色。
- en: 'As we need to associate and display SFML object to the physical object, we
    use a functionality of Box2D: the `SetUserData()` function. This function takes
    `void*` as a parameter and internally holds it. So we use it to keep track of
    our SFML shape.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要将 SFML 对象与物理对象关联并显示，我们使用 Box2D 的一个功能：`SetUserData()` 函数。此函数接受 `void*`
    作为参数并在内部持有它。因此，我们使用它来跟踪我们的 SFML 形状。
- en: Finally, the body is returned by the function. This pointer has to be stored
    to clean the memory later. This is the reason for the body's container in `main()`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，函数通过返回身体。此指针必须存储起来以便稍后清理内存。这就是 `main()` 中身体容器的原因。
- en: 'Now, we have the capability to simply create a box and add it to the world.
    Now, let''s render it to the screen. This is the goal of the `displayWorld` function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了简单地创建一个盒子并将其添加到世界中的能力。现在，让我们将其渲染到屏幕上。这是`displayWorld`函数的目标：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function takes the physics world and window as a parameter. Here again,
    let''s explain this function step-by-step:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将物理世界和窗口作为参数。在这里，让我们一步一步地解释这个函数：
- en: 'We update the physical world. If you remember, we have set the frame rate to
    60\. This is why we use 1,0/60 as a parameter here. The two others are for precision
    only. In a good code, the time step should not be hardcoded as here. We have to
    use a clock to be sure that the value will always be the same. Here, it has not
    been the case to focus on the important part: physics. And more importantly, the
    physics loop should be different from the display loop as already said in [Chapter
    2](ch02.html "Chapter 2. General Game Architecture, User Inputs, and Resource
    Management"), *General Game Architecture, User Inputs, and Resource Management*.
    I will come back to this point in the next section.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们更新物理世界。如果你记得，我们已将帧率设置为60。这就是为什么我们在这里使用1,0/60作为参数。其他两个参数仅用于精度。在好的代码中，时间步长不应该像这里那样硬编码。我们必须使用时钟以确保值始终相同。在这里，这并没有发生，因为我们专注于重要的部分：物理。更重要的是，物理循环应该与显示循环不同，正如在[第2章](ch02.html
    "第2章. 一般游戏架构、用户输入和资源管理")中已经说过的，*一般游戏架构、用户输入和资源管理*。我将在下一节回到这个点。
- en: We reset the screen, as usual.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们像往常一样重置屏幕。
- en: 'Here is the new part: we loop the body stored by the world and get back the
    SFML shape. We update the SFML shape with the information taken from the physical
    body and then render it on the screen.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是新的部分：我们循环世界存储的物体，并获取SFML形状。我们使用从物理体获取的信息更新SFML形状，然后在屏幕上渲染它。
- en: Finally, we render the result on the screen.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在屏幕上渲染结果。
- en: 'That''s it. The final result should look like the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。最终结果应该看起来像以下截图：
- en: '![Box2D, how does it work?](img/8477OS_04_01.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![Box2D，它是如何工作的？](img/8477OS_04_01.jpg)'
- en: As you can see, it's not really difficult to pair SFML with Box2D. It's not
    a pain to add it. However, we have to take care of the data conversion. This is
    the real trap. Pay attention to the precision required (`int`, `float`, `double`)
    and everything should be fine.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，将SFML与Box2D配对并不困难。添加它并不痛苦。然而，我们必须注意数据转换。这是真正的陷阱。注意所需的精度（`int`、`float`、`double`），然后一切都会顺利。
- en: Now that you have all the keys in hand, let's build a real game with physics.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了所有的键，让我们用物理来构建一个真正的游戏。
- en: Adding physics to a game
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将物理添加到游戏中
- en: Now that Box2D is introduced with a basic project, let's focus on the real one.
    We will modify our basic Tetris to get Gravity-Tetris alias Gravitris. The game
    control will be the same as in Tetris, but the game engine will not be. We will
    replace the board with a real physical engine.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Box2D已经通过一个基本项目引入，让我们专注于真正的项目。我们将修改我们的基本俄罗斯方块，得到重力俄罗斯方块，即Gravitris。游戏控制将与俄罗斯方块相同，但游戏引擎将不同。我们将用真实的物理引擎替换板。
- en: With this project, we will reuse a lot of work previously done. As already said,
    the goal of some of our classes is to be reusable in any game using SFML. Here,
    this will be made without any difficulties as you will see. The classes concerned
    are those you deal with user event `Action`, `ActionMap`, `ActionTarget`—but also
    `Configuration` and `ResourceManager`. Because all these classes have already
    been explained in detail in the previous chapters, I will not waste time to explain
    them again in this one.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将重用之前做的大量工作。正如之前所说，我们一些类的目标是可重用在任何使用SFML的游戏中。在这里，这将没有困难，正如你将看到的。相关的类是你处理用户事件`Action`、`ActionMap`、`ActionTarget`——以及`Configuration`和`ResourceManager`。因为这些类已经在之前的章节中详细解释过，所以我在这里不再浪费时间重复解释它们。
- en: There are still some changes that will occur in the `Configuration` class, more
    precisely, in the enums and `initialization` methods of this class because we
    don't use the exact same sounds and events that were used in the Asteroid game.
    So we need to adjust them to our needs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Configuration`类中还有一些变化会发生，更确切地说，是在这个类的枚举和`initialization`方法中，因为我们没有使用在Asteroid游戏中使用的确切相同的音效和事件。因此，我们需要调整它们以满足我们的需求。
- en: 'Enough with explanations, let''s do it with the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的解释了，让我们用以下代码来做：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, the changes are in the `enum`, more precisely in `Sounds` and
    `PlayerInputs`. We change the values into more adapted ones to this project. We
    still have the font and music theme. Now, take a look at the initialization methods
    that have changed:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，更改发生在`enum`中，更确切地说是在`Sounds`和`PlayerInputs`中。我们将值更改为更适合此项目的值。我们仍然有字体和音乐主题。现在，让我们看看已经更改的初始化方法：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'No real surprises here. We simply adjust the resources to our needs for the
    project. As you can see, the changes are really minimalistic and easily done.
    This is the aim of all reusable modules or classes. Here is a piece of advice,
    however: keep your code as modular as possible, this will allow you to change
    a part very easily and also to import any generic part of your project to another
    one easily.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有真正的惊喜。我们只是调整资源以满足项目的需求。如您所见，更改非常简约且易于完成。这就是所有可重用模块或类的目标。然而，这里有一些建议：尽可能使您的代码模块化，这将使您能够非常容易地更改一部分，并且可以轻松地将项目中的任何通用部分导入另一个项目中。
- en: The Piece class
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Piece`类'
- en: Now that we have the configuration class done, the next step is the `Piece`
    class. This class will be the most modified one. Actually, as there is too much
    change involved, let's build it from scratch. A piece has to be considered as
    an ensemble of four squares that are independent from one another. This will allow
    us to split a piece at runtime. Each of these squares will be a different fixture
    attached to the same body, the piece.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了配置类，下一步是`Piece`类。这个类将是修改最多的一个。实际上，由于涉及的变化太多，让我们从头开始构建它。一个部件必须被视为由四个相互独立的方块组成的集合。这将允许我们在运行时拆分部件。这些方块中的每一个都将是一个不同的固定装置，附加到相同的体——部件上。
- en: We will also need to add some force to a piece, especially to the current piece,
    which is controlled by the player. These forces can move the piece horizontally
    or can rotate it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要给一个部件施加一些力，特别是给当前由玩家控制的部件施加力。这些力可以使部件水平移动或旋转。
- en: Finally, we will need to draw the piece on the screen.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在屏幕上绘制这个部件。
- en: 'The result will show the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将显示以下代码片段：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Some parts of the class don't change such as the `TetriminoTypes` and `TetriminoColors`
    enums. This is normal because we don't change any piece's shape or colors. The
    rest is still the same.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的一些部分没有变化，例如`TetriminoTypes`和`TetriminoColors`枚举。这是正常的，因为我们没有更改任何部件的形状或颜色。其余部分仍然相同。
- en: 'The implementation of the class, on the other side, is very different from
    the precedent version. Let''s see it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 类的实现，另一方面，与先前的版本非常不同。让我们看看：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The constructor is the most important method of this class. It initializes
    the physical body and adds each square to it by calling `createPart()`. Then,
    we set the user data to the piece itself. This will allow us to navigate through
    the physics to SFML and vice versa. Finally, we synchronize the physical object
    to the drawable by calling the `update()` function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是这个类最重要的方法。它初始化物理体，并通过调用`createPart()`将每个方块添加到其中。然后，我们将用户数据设置为部件本身。这将允许我们通过物理导航到SFML，反之亦然。最后，通过调用`update()`函数将物理对象同步到可绘制对象：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The destructor loop on all the fixtures attached to the body, destroys all
    the SFML shapes and then removes the body from the world:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数遍历附加到体上的所有固定装置，销毁所有SFML形状，然后从世界中移除体：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method adds a square to the body at a specific place. It starts by creating
    a physical shape as the desired box and then adds this to the body. It also creates
    the SFML square that will be used for the display, and it will attach this as
    user data to the fixture. We don't set the initial position because the constructor
    will do it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在特定位置将一个方块添加到体中。它首先创建一个物理形状作为所需的盒子，并将其添加到体中。它还创建一个用于显示的SFML方块，并将其作为用户数据附加到固定装置上。我们不设置初始位置，因为构造函数会做这件事。
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method synchronizes the position and rotation of all the SFML shapes from
    the physical position and rotation calculated by Box2D. Because each piece is
    composed of several parts—fixture—we need to iterate through them and update them
    one by one.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将所有SFML形状的位置和旋转与Box2D计算出的物理位置和旋转同步。因为每个部件由几个部分——固定装置组成——我们需要遍历它们并逐个更新。
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These two methods add some force to the object to move or rotate it. We forward
    the job to the Box2D library.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法给物体施加一些力以使其移动或旋转。我们将这项工作委托给Box2D库。
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function draws the entire piece. However, because the piece is composed
    of several parts, we need to iterate on them and draw them one by one in order
    to display the entire piece. This is done by using the user data saved in the
    fixtures.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数绘制整个部件。然而，因为部件由几个部分组成，我们需要遍历它们，并逐个绘制它们，以便显示整个部件。这是通过使用存储在固定件中的用户数据来完成的。
- en: The World class
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: World类
- en: Now that we have built our pieces, let's make a world that will be populated
    by them. This class will be very similar to the one previously made in the Tetris
    clone. But now, the game is based on physics. So we need to separate the physics
    and the display updates. To do this, two `update` methods will be used.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了我们的部件，让我们创建一个将由它们填充的世界。这个类将与之前在俄罗斯方块克隆中制作的类非常相似。但现在，游戏基于物理。因此，我们需要将物理和显示更新分开。为此，将使用两个`update`方法。
- en: 'The big change is that the board is no longer a grid, but a physical world.
    Because of this, a lot of internal logic will be changed. Now, let''s see it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的变化是板子不再是一个网格，而是一个物理世界。因此，许多内部逻辑将发生变化。现在，让我们看看它：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We make the class non-replicable, with size as a parameter. As you can see,
    there are now two `update` methods. One for the physics and another one for the
    SFML objects. We still have some methods specific for the game such as `newPiece()`,
    `clearLines()`, `isGameOver()`, a new one relative to the `updateGravity()` physic,
    and a method to add sounds to our world. This method directly comes from the Meteor
    game by copying and pasting it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使类不可复制，以大小作为参数。正如你所见，现在有两个`update`方法。一个用于物理，另一个用于SFML对象。我们仍然有一些针对游戏的特定方法，例如`newPiece()`、`clearLines()`、`isGameOver()`，还有一个与`updateGravity()`物理相关的新方法，以及一个向我们的世界添加声音的方法。此方法直接来自Meteor游戏，通过复制粘贴得到。
- en: 'Now that the class is introduced, take a look at its implementation. The following
    constructor initializes the physical world with a default gravity and adds some
    walls to it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在类已经介绍，让我们看看它的实现。以下构造函数使用默认重力初始化物理世界，并向其中添加了一些墙壁：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The destructor removes all the SFML shapes attached to the bodies still present
    in the world:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数移除世界中所有附加到身体的SFML形状：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following method synchronizes the physical bodies with the SFML objects
    that display it. It also removes all the sounds effects that are finished, as
    already explained in the previous chapter:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法同步物理体与显示它的SFML对象。它还移除了所有已经结束的声音效果，正如前一章中已经解释过的：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we construct a class inside the `World.cpp` file because we don''t need
    the class anywhere else. This class will be used to query the physical world by
    getting all the fixtures inside an area. This will be used more, especially to
    detect the completed lines:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在`World.cpp`文件中构建一个类，因为我们不需要这个类在其他任何地方。这个类将用于通过获取一个区域内的所有固定件来查询物理世界。这将被更频繁地使用，特别是用于检测完成的行：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following method clears the completed lines by querying the world, especially
    with the made class. Then, we count the number of fixtures (squares) on each line;
    if this number satisfies our criteria, we delete all the fixtures and the line.
    However, by doing this, we could have some bodies with no fixture. So, if we remove
    the last fixture attached to a body, we also remove the body. Of course, we also
    remove all the SFML shapes corresponding to those deleted objects. Finally, for
    more fun, we add some sounds to the world if needed:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法通过查询世界（特别是通过制作的类）清除完成的行。然后，我们计算每行上的固定件（方块）数量；如果这个数量满足我们的标准，我们就删除所有固定件和行。然而，通过这样做，我们可能会有一些没有固定件的身体。所以，如果我们移除附加到身体上的最后一个固定件，我们也会移除身体。当然，我们也会移除所有对应于这些已删除对象的SFML形状。最后，为了增加趣味性，如果需要，我们向世界添加一些声音：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following function sets the gravity depending on the current level. Bigger
    the level, stronger is the gravity:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数根据当前级别设置重力。级别越大，重力越强：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following function is directly taken from the Asteroid clone, and was already
    explained. It just adds sound to our world:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数直接取自小行星克隆，并且已经解释过。它只是向我们的世界添加声音：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This method checks if the game is over with a simple criterion, "are there
    any bodies out of the board?":'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法通过一个简单的标准检查游戏是否结束：“是否有任何身体超出板面？”
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This function updates only the physical world by forwarding the job to Box2D:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仅通过将任务转发给Box2D来更新物理世界：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we create a piece and set its initial position to the top of our board.
    We also add a sound to alert the player about this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个部件，并将其初始位置设置为板子的顶部。我们还添加了一个声音来提醒玩家：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `draw()` function is pretty simple. We iterate on all the bodies still
    alive in the world and display the SFML object attached to them:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()` 函数相当简单。我们遍历世界中仍然存活的所有物体，并显示附着在其上的 SFML 对象：'
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following functions are helpful. Its aim is to create a static body that
    will represent a wall. All the functionalities used were already explained in
    the first part of this chapter, so nothing should surprise you:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数很有用。其目的是创建一个静态体，将代表墙壁。所有在章节第一部分中使用的功能都已经解释过了，所以不应该有什么让您感到惊讶的：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Game class
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Game` 类'
- en: Now, we have a world that can be populated by some pieces, let's build the last
    important class—the `Game` class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个可以由一些块填充的世界，让我们构建最后一个重要的类——`Game` 类。
- en: There is a big change in this class. If you remember, in [Chapter 2](ch02.html
    "Chapter 2. General Game Architecture, User Inputs, and Resource Management"),
    *General Game Architecture, User Inputs, and Resource Management*, I said that
    a game with physics should use two game loops instead of one. The reason for this
    is that most of the physical engine works well with a fixed time step. Moreover,
    this can avoid a really bad thing. Imagine that your physical engine takes 0.01
    second to compute the new position of all the bodies in your world, but the delta
    time passed as argument to your `update` function is fewer. The result will be
    that your game will enter in a death state and will finally freeze.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中有一个很大的变化。如果您还记得，在[第二章](ch02.html "第二章。通用游戏架构、用户输入和资源管理")中，我提到具有物理特性的游戏应该使用两个游戏循环而不是一个。这样做的原因是大多数物理引擎都很好地与固定时间步长一起工作。此外，这可以避免一件真正糟糕的事情。想象一下，您的物理引擎需要
    0.01 秒来计算您世界中所有物体的新位置，但传递给您的 `update` 函数的 delta time 更少。结果将是您的游戏将进入死亡状态，并最终冻结。
- en: The solution is to separate the physics from the rendering. Here, the physics
    will run at 60 FPS and the game at a minimum of 30 FPS. The solution presented
    here is not perfect because we don't separate the computation in different threads,
    but this will be done later, in the sixth chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将物理与渲染分离。在这里，物理将以 60 FPS 运行，而游戏至少以 30 FPS 运行。这里提出的解决方案并不完美，因为我们没有在不同线程中分离计算，但这一点将在第六章中完成。
- en: 'Take a look at the `Game` header file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 `Game` 头文件：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: No surprises here. The usual methods are present. We just duplicate the `update`
    function, one for logic and the other for physics.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 没有惊喜。这里存在通常的方法。我们只是复制了 `update` 函数，一个用于逻辑，另一个用于物理。
- en: 'Now, let''s see the implementation. The constructor initializes `World` and
    binds the player inputs. It also creates the initial piece that will fall on the
    board:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看实现。构造函数初始化 `World` 并绑定玩家输入。它还创建了将落在板上的初始块：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following function has nothing new except that the two `update()` functions
    are called instead of one:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数没有新内容，只是将两个 `update()` 函数调用代替了一个：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following function updates the logic of our game:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数更新了我们游戏中的逻辑：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is the step-by-step evaluation of the preceding code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面代码的逐步评估：
- en: We start by updating some time value by adding the `deltaTime` parameter to
    them.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过添加 `deltaTime` 参数来更新一些时间值。
- en: Then, we apply some forces to the current piece if needed.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果需要，我们对当前块施加一些力。
- en: We update the world by cleaning all the complete lines and also update the score.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过清理所有完成的行来更新世界，并更新分数。
- en: If needed, we create a new piece that will replace the current one.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，我们创建一个新的块来替换当前的块。
- en: 'Now, take a look at the physics:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看物理部分：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function updates all the physics, including the gravity that changes with
    the current level. Here again, nothing is too complicated.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数更新了所有物理，包括随当前级别变化的引力。在这里，也没有什么太复杂的。
- en: The `processEvents()` and `render()` functions don't change at all, and are
    exactly the same as in the first Tetris.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`processEvents()` 和 `render()` 函数完全没有变化，与第一版 Tetris 完全相同。'
- en: As you can see, the `Game` class doesn't change a lot and is very similar to
    the one previously made. The two loops—logics and physics—are the only real changes
    that occur.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Game` 类变化不大，与之前制作的非常相似。两个循环——逻辑和物理——是唯一真正发生的变化。
- en: The Stats class
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Stats` 类'
- en: Now, the last thing to build is the `Stats` class. However, we have already
    made it in the previous version of Tetris, so just copy and paste it. A little
    change has been made for the game over, by adding a getter and setter. That's
    it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后要构建的是`Stats`类。然而，我们在之前的俄罗斯方块版本中已经创建好了它，所以只需复制粘贴即可。为了游戏结束，我们进行了一些小的改动，通过添加getter和setter方法。就这样了。
- en: 'Now, you have all the keys in hand to build your new Tetris with sounds and
    gravity. The final result should look like the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经拥有了所有构建带有声音和重力的新俄罗斯方块所需的钥匙。最终结果应该看起来像以下截图：
- en: '![The Stats class](img/8477OS_04_02.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![The Stats class](img/8477OS_04_02.jpg)'
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Since the usage of a physics engine has its own particularities such as the
    units and game loop, we have learned how to deal with them. Finally, we learned
    how to pair Box2D with SFML, integrate our fresh knowledge to our existing Tetris
    project, and build a new funny game.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用物理引擎有其特定的特性，如单位和游戏循环，我们已经学会了如何处理它们。最后，我们学习了如何将Box2D与SFML配对，将我们的新知识整合到现有的俄罗斯方块项目中，并创建一个新有趣的游戏。
- en: In the next chapter, we will learn how to add a user interface to our game in
    order to interact with the user easily, by creating our own game user interface
    or by using an existing one.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过创建自己的游戏用户界面或使用现有的用户界面，轻松地向我们的游戏添加用户界面，以便与用户进行交互。
