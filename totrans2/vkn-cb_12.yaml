- en: Advanced Rendering Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级渲染技术
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Drawing a skybox
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制天空盒
- en: Drawing billboards using geometry shaders
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用几何着色器绘制广告牌
- en: Drawing particles using compute and graphics pipelines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算和图形管线绘制粒子
- en: Rendering a tessellated terrain
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染细分地形
- en: Rendering a full-screen quad for post-processing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染全屏四边形进行后处理
- en: Using input attachments for a color correction post-process effect
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输入附件进行颜色校正后处理效果
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Creating 3D applications, such as games, benchmarks or CAD tools, usually requires,
    from a rendering perspective, the preparation of various resources, including
    meshes or textures, drawing multiple objects on the scene, and implementing algorithms
    for object transformations, lighting calculations, and image processing. They
    all can be developed in any way we want, in a way that is most suitable for our
    purpose. But there are also many useful techniques that are commonly used in the
    3D graphics industry. Descriptions for these can be found in books and tutorials
    with examples implemented using various 3D graphics APIs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建3D应用程序，如游戏、基准测试或CAD工具，从渲染的角度来看，通常需要准备各种资源，包括网格或纹理、在场景中绘制多个对象，以及实现对象变换、光照计算和图像处理的算法。它们都可以以任何我们想要的方式开发，以最符合我们目的的方式开发。但3D图形行业中也有许多常用的技术。这些技术的描述可以在书籍和教程中找到，其中包含使用各种3D图形API实现的示例。
- en: Vulkan is still a relatively new graphics API, so there aren't too many resources
    that present common rendering algorithms implemented with the Vulkan API. In this
    chapter, we will learn how to use Vulkan to prepare various graphics techniques.
    We will learn about important concepts from a collection of popular, advanced
    rendering algorithms found in games and benchmarks and how they match with the
    Vulkan resources.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan仍然是一个相对较新的图形API，因此没有太多资源介绍使用Vulkan API实现的常见渲染算法。在本章中，我们将学习如何使用Vulkan准备各种图形技术。我们将了解从游戏和基准测试中找到的流行、高级渲染算法的重要概念，以及它们如何与Vulkan资源相匹配。
- en: In this chapter, we will focus only on the code parts that are important from
    the perspective of a given recipe. Resources that are not described (for example,
    command pool or render pass creation) are created as usual (refer to the *Rendering
    a geometry with a vertex diffuse lighting* recipe from [Chapter 11](45108a92-6d49-4759-9495-3f1166e69128.xhtml),
    *Lighting*).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将仅关注从给定配方角度重要的代码部分。未描述的资源（例如，命令池或渲染通道创建）将按常规创建（参考第11章的*使用顶点漫反射光照渲染几何体*配方，*光照*）。
- en: Drawing a skybox
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制天空盒
- en: Rendering 3D scenes, especially open world ones with vast viewing distances,
    requires many objects to be drawn. However, the processing power of current graphics
    hardware is still too limited to render as many objects as we see around us every
    day. So, to lower the number of drawn objects and to draw the background for our
    scene, we usually prepare an image (or a photo) of distant objects and draw just
    the image instead.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染3D场景，特别是具有广阔视距的开世界场景，需要绘制许多对象。然而，当前图形硬件的处理能力仍然过于有限，无法渲染我们每天所见到的那么多对象。因此，为了降低绘制对象的数量并绘制场景的背景，我们通常准备一张远距离对象的图像（或照片），并只绘制该图像。
- en: In games where players can freely move and look around, we can't draw a single
    image. We must draw images in all directions. Such images form a cube, and an
    object on which background images are placed is called a skybox. We render it
    in such a way that it is always in the background, at the furthest depth value
    available.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家可以自由移动和环顾四周的游戏中，我们不能只绘制一张图像。我们必须绘制所有方向的图像。这些图像形成一个立方体，放置背景图像的对象称为天空盒。我们以这种方式渲染，使其始终位于背景，在可用的最远深度值处。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Drawing a skybox requires the preparation of a cubemap. It contains six square
    images containing a view in all world directions (right, left, up, down, backward,
    forward), as in the following image:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制天空盒需要准备一个立方体贴图。它包含六个方形图像，包含所有世界方向的视图（右、左、上、下、后、前），如下面的图像所示：
- en: '![](img/image_12_001.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_12_001.png)'
- en: Images courtesy of Emil Persson ([h t t p ://w w w . h u m u s . n a m e](http://www.humus.name))
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由Emil Persson提供([h t t p ://w w w . h u m u s . n a m e](http://www.humus.name))
- en: In Vulkan, cubemaps are special image views created for images with six array
    layers (or a multiple of six). Layers must contain images in the *+X*, -*X*, *+Y*,
    -*Y*, *+Z*, -*Z* order.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，立方体贴图是为具有六个数组层（或六的倍数）的图像创建的特殊图像视图。层必须按照*+X*，-*X*，*+Y*，-*Y*，*+Z*，-*Z*的顺序包含图像。
- en: Cubemaps can be used not only for drawing skyboxes. We can use them to draw
    reflections or transparent objects. They can be used for lighting calculations
    as well (refer to the *Drawing a reflective and refractive geometry using cubemaps*
    recipe in Chapter 11, *Lighting*).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图不仅可以用于绘制天空盒。我们还可以使用它们来绘制反射或透明物体。它们还可以用于光照计算（参考第11章中“使用立方体贴图绘制反射和折射几何体”的配方，*光照*）。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Load a 3D model of a cube from a file and store vertex data in a vertex buffer.
    Only vertex positions are required (refer to the *Loading a 3D model from an OBJ
    file* recipe in [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper
    Recipes*).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中加载一个立方体的3D模型，并将顶点数据存储在顶点缓冲区中。只需要顶点位置（参考第10章中“从OBJ文件加载3D模型”的配方[Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml)，*辅助配方*）。
- en: Create a combined image sampler with a square `VK_IMAGE_TYPE_2D` image that
    has six array layers (or a multiple of six), a sampler that uses a `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE`
    addressing mode for all coordinates and a `VK_IMAGE_VIEW_TYPE_CUBE` image view
    (refer to the *Creating a combined image sampler* recipe in [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有正方形`VK_IMAGE_TYPE_2D`图像的组合图像采样器，该图像具有六个数组层（或六的倍数），一个对所有坐标使用`VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE`寻址模式的采样器，以及一个`VK_IMAGE_VIEW_TYPE_CUBE`图像视图（参考第5章中“创建组合图像采样器”的配方[Chapter
    5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*）。
- en: 'Load image data for all six sides of a cube and upload it to the image''s memory
    using a staging buffer. Image data must be uploaded to six array layers in the
    following order: *+X*, -*X*, *+Y*, -*Y*, *+Z*, -*Z* (refer to the *Loading texture
    data from a file* recipe in [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml),
    Helper Recipes, and to the *Using a staging buffer to update an image with a device-local
    memory bound* recipe in [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载立方体的所有六个面的图像数据，并使用阶段缓冲区将其上传到图像的内存中。图像数据必须按照以下顺序上传到六个数组层：*+X*，-*X*，*+Y*，-*Y*，*+Z*，-*Z*（参考第10章中“从文件加载纹理数据”的配方[Chapter
    10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml)，辅助配方，以及第4章中“使用阶段缓冲区更新绑定到设备本地内存的图像”的配方[Chapter
    4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*）。
- en: Create a uniform buffer in which transformation matrices will be stored (refer
    to the *Creating a uniform buffer* recipe in [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个统一缓冲区中创建一个用于存储变换矩阵的缓冲区（参考第5章中“创建统一缓冲区”的配方[Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*）。
- en: Create a descriptor set layout with the uniform buffer accessed by a vertex
    stage and a combined image sampler accessed by a fragment stage. Allocate a descriptor
    set using the preceding layout. Update the descriptor set with the uniform buffer
    and the cubemap/combined image sampler (refer to the *Creating a descriptor set
    layout, Allocating descriptor sets* and *Updating descriptor sets* recipes in [Chapter
    5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个描述符集布局，其中统一缓冲区由顶点阶段访问，组合图像采样器由片段阶段访问。使用前面的布局分配一个描述符集。使用统一缓冲区和立方体贴图/组合图像采样器更新描述符集（参考第5章中“创建描述符集布局，分配描述符集”和“更新描述符集”的配方[Chapter
    5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*）。
- en: 'Create a shader module with a vertex shader created from the following GLSL
    code (refer to the *Creating a shader module recipe* in [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*):'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个着色器模块，其中顶点着色器由以下GLSL代码创建（参考第8章中“创建着色器模块配方”的配方[Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*）。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a shader module with a fragment shader created from the following GLSL
    code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个着色器模块，其中片段着色器由以下GLSL代码创建：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create a graphics pipeline from the preceding modules with vertex and fragment
    shaders. The pipeline should use one vertex attribute with three components (vertex
    positions) and a `VK_CULL_MODE_FRONT_BIT` value for the rasterization state's
    culling mode. Blending should be disabled. The pipeline's layout should allow
    access to the uniform buffer and the cubemap/combined image sampler (refer to
    the *Specifying pipeline shader stages*, *Specifying pipeline vertex input state*,
    *Specifying pipeline rasterization state*, *Specifying pipeline blend state*,
    *Creating a pipeline layout*, *Specifying graphics pipeline creation parameters*
    and *Creating a graphics pipeline* recipes from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的模块创建一个图形管线，使用顶点和片段着色器。该管线应使用一个具有三个组件（顶点位置）的顶点属性，并为光栅化状态的剔除模式使用`VK_CULL_MODE_FRONT_BIT`值。混合应被禁用。管线布局应允许访问统一缓冲区和立方体贴图/复合图像采样器（参考第8章中的*指定管线着色器阶段*、*指定管线顶点输入状态*、*指定管线光栅化状态*、*指定管线混合状态*、*创建管线布局*、*指定图形管线创建参数*和*创建图形管线*配方，[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*）。
- en: Draw the cube with the rest of a rendered geometry (refer to the *Binding descriptor
    sets* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*, to the *Binding a pipeline object* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines* and to the *Binding vertex buffers* and *Drawing
    a geometry* recipes from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing*).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用渲染几何体的其余部分绘制立方体（参考第5章中的*绑定描述符集*配方，[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*，以及第8章中的*绑定管线对象*配方，[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*，以及第9章中的*绑定顶点缓冲区*和*绘制几何体*配方，[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*）。
- en: Update a model view matrix in the uniform buffer each time a user (a camera)
    moves in the scene. Update a projection matrix in the uniform buffer each time
    the application window is resized.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当用户（摄像机）在场景中移动时，在统一缓冲区中更新模型视图矩阵。每当应用程序窗口大小调整时，在统一缓冲区中更新投影矩阵。
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To render a skybox we need to load or prepare a geometry forming a cube. Only
    positions are required as they can also be used for texture coordinates.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染天空盒，我们需要加载或准备一个形成立方体的几何体。只需要位置，因为它们也可以用作纹理坐标。
- en: 'Next, we load six cubemap images and create a combined image sampler with a
    cube image view:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们加载六个立方体贴图图像并创建一个包含立方体贴图视图的复合图像采样器：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The created cube image view, along with a sampler, is then provided to the
    shaders through a descriptor set. We also need a uniform buffer in which transformation
    matrices will be stored and accessed in the shaders:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的立方体贴图视图以及采样器随后通过描述符集提供给着色器。我们还需要一个统一缓冲区，其中将存储和访问着色器中的变换矩阵：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To draw a skybox we don''t need a separate, dedicated *render pass*, as we
    can render it along the normal geometry. What''s more, to save processing power
    (image fill rate), we usually draw a skybox after the (opaque) geometry and before
    the transparent objects. It is rendered in such a way so that its vertices are
    always at the far clipping plane. This way it doesn''t cover geometry that had
    been already drawn and doesn''t get clipped away either. This effect is achieved
    with a special vertex shader. Its most important part is the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制天空盒，我们不需要单独的、专门的*渲染通道*，因为我们可以在正常几何体上渲染它。更重要的是，为了节省处理能力（图像填充率），我们通常在（不透明的）几何体之后和透明物体之前绘制天空盒。它以这种方式渲染，使其顶点始终位于远裁剪平面。这样，它不会覆盖已经绘制的几何体，也不会被裁剪掉。这种效果是通过一个特殊的顶点着色器实现的。其最重要的部分是以下代码：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, we multiply the position by a modelview matrix. We take only the rotation
    part of the matrix. A player should always be in the center of the skybox, or
    the illusion will be broken. That's why we don't want to move the skybox, we need
    only to rotate it as a response to the player looking around.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将位置乘以一个模型视图矩阵。我们只取矩阵的旋转部分。玩家应该始终位于天空盒的中心，否则幻觉将被打破。这就是我们不希望移动天空盒的原因，我们只需要将其旋转作为玩家环顾四周的响应。
- en: Next, we multiply the viewspace position of a vertex by a projection matrix.
    The result is stored in a 4-element vector, with the last two components being
    the same and equal to the z component of the result. In modern graphics hardware,
    a perspective projection is performed by dividing the position vector by its `w`
    component. After that, all vertices, whose `x` and `y` components fit into the
    <`-1, 1`> range (inclusive) and `z` component fits into the <`0, 1`> range (inclusive),
    are inside the clipping volume and are visible (unless they are obscured by something
    else). So, calculating the vertex position in a way that makes its last two components
    equal, guarantees that the vertex will lie on the far clipping plane.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将顶点的视图空间位置乘以一个投影矩阵。结果存储在一个4元素向量中，最后两个分量相同，等于结果的z分量。在现代图形硬件中，透视投影是通过将位置向量除以其`w`分量来执行的。之后，所有`x`和`y`分量适合于`<-1,
    1>`范围（包含）且`z`分量适合于`<0, 1>`范围（包含）的顶点都在裁剪体积内且是可见的（除非它们被其他东西遮挡）。因此，以使最后两个分量相等的方式来计算顶点位置，可以保证顶点将位于远裁剪平面。
- en: 'Apart from the vertex shader and a cube image view, skybox needs only one additional
    special treatment. We need to remember polygon facingness. Usually, we draw geometry
    with backface culling, as we want to see its external surface. For the skybox,
    we want to render its internal surface, because we look at it from the inside.
    That''s why, if we don''t have a mesh prepared especially for the skybox, we probably
    want to cull front faces during skybox rendering. We can prepare the pipeline
    rasterization info like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了顶点着色器和立方体贴图视图之外，天空盒只需要一种额外的特殊处理。我们需要记住多边形的朝向。通常，我们使用背面剔除来绘制几何体，因为我们想看到它的外部表面。对于天空盒，我们想要渲染其内部表面，因为我们是从内部看它的。这就是为什么，如果我们没有为天空盒特别准备网格，我们可能希望在天空盒渲染期间剔除前表面。我们可以这样准备管线光栅化信息：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Apart from that, the graphics pipeline is created in the usual way. To use
    it for drawing, we need to bind the descriptor set, the vertex buffer, and the
    pipeline itself:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，图形管线是以通常的方式创建的。为了用它来绘制，我们需要绑定描述符集、顶点缓冲区和管线本身：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following images have been generated using this recipe:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像是使用此配方生成的：
- en: '![](img/image_12_002.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_002.png)'
- en: See also
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipes:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中，查看以下配方：
- en: '*Creating a combined image sampler*'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建组合图像采样器*'
- en: '*Creating a descriptor set layout*'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建描述符集布局*'
- en: '*Allocating descriptor sets*'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配描述符集*'
- en: '*Updating descriptor sets*'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新描述符集*'
- en: '*Binding descriptor sets*'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定描述符集*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下配方：
- en: '*Creating a shader module*'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Specifying pipeline shader stages*'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线着色器阶段*'
- en: '*Creating a graphics pipeline*'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: '*Binding a pipeline object*'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定管线对象*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipes:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*中，查看以下配方：
- en: '*Binding vertex buffers*'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定顶点缓冲区*'
- en: '*Drawing a geometry*'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制几何体*'
- en: 'In [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*,
    see the following recipes:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第10章](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml)，*辅助配方*中，查看以下配方：
- en: '*Loading texture data from a file*'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从文件加载纹理数据*'
- en: '*Loading a 3D model from an OBJ file*'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从OBJ文件加载3D模型*'
- en: 'In [Chapter 11](45108a92-6d49-4759-9495-3f1166e69128.xhtml), *Lighting*, see
    the following recipe:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第11章](45108a92-6d49-4759-9495-3f1166e69128.xhtml)，*光照*中，查看以下配方：
- en: '*Drawing a reflective and refractive geometry using cubemaps*'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用立方体贴图绘制反射和折射几何体*'
- en: Drawing billboards using geometry shaders
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用几何着色器绘制广告牌
- en: 'Simplifying geometry drawn in a distance is a common technique for lowering
    the processing power needed to render the whole scene. The simplest geometry that
    can be drawn is a flat quad (or a triangle) with an image depicting the look of
    an object. For the effect to be convincing, the quad must always be facing camera:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在远处简化绘制的几何体是降低渲染整个场景所需处理能力的一种常见技术。可以绘制的最简单几何体是一个带有描绘物体外观的图像的平面四边形（或三角形）。为了使效果令人信服，四边形必须始终朝向相机：
- en: '![](img/image_12_003.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_003.png)'
- en: Flat objects that are always facing camera are called billboards. They are used
    not only for distant objects as the lowest level of detail of a geometry, but
    also for particle effects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 始终面向摄像机的平面物体被称为billboard。它们不仅用于作为几何体最低细节级别远距离物体，还用于粒子效果。
- en: One straightforward technique for drawing billboards is to use geometry shaders.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制billboard的一个直接技术是使用几何着色器。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a logical device with the `geometryShader` feature enabled (refer to
    the *Getting features and properties of a physical device* and *Creating a logical
    device* recipes from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml),
    *Instance and Devices*).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用启用`geometryShader`功能的逻辑设备（参考[第1章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml)，*实例和设备*中的*获取物理设备的特性和属性*和*创建逻辑设备*配方）。
- en: Prepare positions for all billboards with one vertex per single billboard. Store
    them in a vertex buffer (refer to the *Creating a buffer* recipe from [Chapter
    4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*).
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用每个billboard一个顶点的方式为所有billboard准备位置。将它们存储在顶点缓冲区中（参考[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*创建缓冲区*配方）。
- en: Create a uniform buffer for at least two 4x4 transformation matrices (refer
    to the *Creating a uniform buffer* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为至少两个4x4变换矩阵创建一个统一缓冲区（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中的*创建统一缓冲区*配方）。
- en: If billboards should use a texture, create a combined image sampler and upload
    the texture data loaded from a file to the image's memory (refer to the *Creating
    a combined image sampler* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets* and to the *Loading texture data from a file* recipe from [Chapter
    10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果billboard应该使用纹理，创建一个联合图像采样器并将从文件加载的纹理数据上传到图像内存中（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中的*创建联合图像采样器*配方，以及[第10章](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml)，*辅助配方*中的*从文件加载纹理数据*配方）。
- en: Prepare a descriptor set layout for a uniform buffer accessed by vertex and
    geometry stages and, if billboards need a texture, a combined image sampler accessed
    by a fragment shader stage. Create a descriptor set and update it with the created
    uniform buffer and the combined image sampler (refer to the *Creating a descriptor
    set layout*, *Allocating descriptor sets,* and *Updating descriptor sets* recipes
    from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为由顶点和几何阶段访问的统一缓冲区以及如果需要纹理的billboard，由片段着色器阶段访问的联合图像采样器准备描述符集布局。创建一个描述符集，并使用创建的统一缓冲区和联合图像采样器更新它（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中的*创建描述符集布局*、*分配描述符集*和*更新描述符集*配方）。
- en: 'Create a shader module with a vertex shader created from the following GLSL
    code (refer to the *Creating a shader module* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*):'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用以下GLSL代码创建的顶点着色器的着色器模块（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中的*创建着色器模块*配方）：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a shader module containing a geometry shader created from the following
    GLSL code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下GLSL代码生成的几何着色器的着色器模块：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a shader module with a fragment shader that uses a SPIR-V assembly generated
    from the following GLSL code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用以下GLSL代码生成的SPIR-V汇编的片段着色器的着色器模块：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create a graphics pipeline. It must use shader modules with the preceding vertex,
    geometry and fragment shaders. Only one vertex attribute (a position) is needed.
    It will be used to draw geometry using a `VK_PRIMITIVE_TOPOLOGY_POINT_LIST` primitive.
    The pipeline should have access to the uniform buffer with transformation matrices
    and (if needed) a combined image texture (refer to the *Specifying pipeline shader
    stages*, *Specifying pipeline vertex input state*, *Specifying pipeline input
    assembly state*, *Creating a pipeline layout*, *Specifying graphics pipeline creation
    parameters*, and *Creating a graphics pipeline* recipes from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个图形管线。它必须使用前面的顶点、几何和片段着色器模块。只需要一个顶点属性（一个位置）。它将用于使用`VK_PRIMITIVE_TOPOLOGY_POINT_LIST`原语绘制几何图形。管线应该能够访问包含变换矩阵的统一缓冲区以及（如果需要）一个组合图像纹理（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中的*指定管线着色器阶段*、*指定管线顶点输入状态*、*指定管线输入装配状态*、*创建管线布局*、*指定图形管线创建参数*和*创建图形管线*配方）。
- en: Draw the geometry inside a render pass (refer to the *Binding descriptor sets*
    recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*, to the *Binding a pipeline object* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*, and to the *Binding vertex buffers* and *Drawing
    a geometry recipes* from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing)*.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染通道内绘制几何图形（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中的*绑定描述符集*配方，到[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中的*绑定管线对象*配方，以及到[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*中的*绑定顶点缓冲区和绘制几何图形*配方）。
- en: Update a modelview matrix in the uniform buffer each time the user (a camera)
    moves in the scene. Update a projection matrix in the uniform buffer each time
    the application window is resized.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当用户（一个摄像机）在场景中移动时，在统一缓冲区中更新模型视图矩阵。每当应用程序窗口大小调整时，在统一缓冲区中更新投影矩阵。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we start by preparing the positions for billboards. Billboards are drawn
    as point primitives, so one vertex corresponds to a one billboard. How we prepare
    the geometry is up to us and we don't need other attributes. A geometry shader
    converts a single vertex into a camera-facing quad and calculates texture coordinates.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始准备广告牌的位置。广告牌作为点原语绘制，因此一个顶点对应一个广告牌。我们如何准备几何图形由我们自己决定，我们不需要其他属性。一个几何着色器将单个顶点转换为一个面向摄像机的四边形并计算纹理坐标。
- en: 'In this example we don''t use a texture, but we will use texture coordinates
    to draw circles. All we need to access are transformation matrices stored in a
    uniform buffer generated like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不使用纹理，但我们将使用纹理坐标来绘制圆形。我们只需要访问存储在如下生成的统一缓冲区中的变换矩阵：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next step is to create a graphics pipeline. It uses a single vertex attribute
    (a position) defined in the following way:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个图形管线。它使用以下方式定义的单个顶点属性（一个位置）：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We draw vertices as points, so we need to specify an appropriate primitive
    type during the pipeline creation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以点绘制顶点，因此在创建管线时需要指定一个合适的原语类型：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The rest of the pipeline parameters are fairly typical. The most important parts
    are the shaders.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 管线参数的其余部分相当典型。最重要的部分是着色器。
- en: A vertex shader transforms the vertex from the local space to the view space.
    Billboards must always face the camera, so it is easier to perform calculations
    directly in the view space.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器将顶点从局部空间转换到视图空间。广告牌必须始终面向摄像机，因此在视图空间中直接进行计算更容易。
- en: 'A geometry shader does almost all the work. It takes one vertex (a point) and
    emits a triangle strip with four vertices (a quad). Each new vertex is offset
    a bit to the left/right and up/down to form a quad:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 几何着色器几乎完成所有工作。它取一个顶点（一个点）并发出一个由四个顶点组成的三角形带（一个四边形）。每个新顶点稍微向左/右和上/下偏移，以形成一个四边形：
- en: '![](img/image_12_004.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_12_004.png)'
- en: 'Additionally, a texture coordinate is assigned to the generated vertex based
    on the direction/offset. In our example, the first vertex is prepared like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，根据方向/偏移量，为生成的顶点分配一个纹理坐标。在我们的例子中，第一个顶点准备如下：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The remaining vertices are emitted in a similar way. As we transformed vertices
    to the view space in the vertex shader, the generated quad is always facing the
    screen plane. All we need to do is to multiply generated vertices by a projection
    matrix to transform them to the clip space.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'A fragment shader is used to discard some fragments to form a circle from the
    quad:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the following example, we can see billboards rendered in the positions of
    a mesh''s vertices. The circles seen in the image are flat; they are not spheres:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_12_005.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: See also
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml), *Instances and
    Devices*, see the following recipes:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting features and properties of a physical device*'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a logical device*'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipes:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a uniform buffer*'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a descriptor set layout*'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allocating descriptor sets*'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Updating descriptor sets*'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding descriptor sets*'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see the
    *Writing geometry shaders* recipe
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a shader module*'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying pipeline shader stages*'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying a pipeline vertex binding description, attribute description, and
    input state*'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying a pipeline input assembly state*'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a pipeline layout*'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specifying graphics pipeline creation parameters*'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating a graphics pipeline*'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding a pipeline object*'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipes:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binding vertex buffers*'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Drawing geometry recipes*'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing particles using compute and graphics pipelines
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the nature of graphics hardware and the way objects are processed by
    the graphics pipeline, it is quite hard to display phenomena such as clouds, smoke,
    sparks, fire, falling rain, and snow. Such effects are usually simulated with
    particle systems, which are a large number of small sprites that behave according
    to the algorithms implemented for the system.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Because of the very large number of independent entities, it is convenient to
    implement the behavior and mutual interactions of particles using compute shaders.
    Sprites mimicking the look of each particle are usually displayed as billboards
    with geometry shaders.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we can see an image generated with this recipe:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_12_006.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a logical device with the `geometryShader` feature enabled. Request a
    queue that supports graphics operations and a queue that supports compute operations
    (refer to the *Getting features and properties of a physical device* and *Creating
    a logical device* recipes from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml),
    *Instance and Devices*).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the initial data (attributes) for a particle system.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a buffer that will serve both as a vertex buffer and a storage texel
    buffer. Copy the generated particle data to the buffer (refer to the *Creating
    a storage texel buffer* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*, and to the *Using staging buffer to update buffer with a device-local
    memory bound* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个既作为顶点缓冲区也作为存储纹理缓冲区的缓冲区。将生成的粒子数据复制到缓冲区中（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中的*创建存储纹理缓冲区*做法，以及[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*使用阶段缓冲区更新设备本地内存绑定的缓冲区*做法）。
- en: Create a uniform buffer for two transformation matrices. Update it each time
    the camera is moved or the window is resized (refer to the *Creating a uniform
    buffer* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于两个变换矩阵的统一缓冲区。每次相机移动或窗口调整大小时更新它（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*创建统一缓冲区*的做法）。
- en: 'Create two descriptor set layouts: one with a uniform buffer accessed by vertex
    and geometry stages; and the second with a storage texel buffer accessed by a
    compute stage. Create a descriptor pool and allocate two descriptor sets using
    the above layouts. Update them with the uniform buffer and the storage texel buffer
    (refer to the *Creating a descriptor set layout, Creating a descriptor pool*,
    *Allocating descriptor sets* and *Updating descriptor sets*, recipes from [Chapter
    5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个描述符集布局：一个由顶点和几何阶段访问的统一缓冲区；另一个由计算阶段访问的存储纹理缓冲区。创建一个描述符池，并使用上述布局分配两个描述符集。使用统一缓冲区和存储纹理缓冲区更新它们（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*创建描述符集布局*，*创建描述符池*，*分配描述符集*和*更新描述符集*，这些做法）。
- en: 'Create a shader module with a compute shader created from the following GLSL
    code (refer to the *Creating a shader module* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*):'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下GLSL代码的计算着色器的着色器模块（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*创建着色器模块*的做法）。
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create a compute pipeline that uses the shader module with the compute shader
    and has access to the storage texel buffer and a push constant range with one
    floating point value (refer to the *Specifying pipeline shader stages*, *Creating
    a pipeline layout recipe*, and *Creating a compute pipeline* recipes from [Chapter
    8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute Pipelines*).
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用包含计算着色器的着色器模块的计算管线，它具有访问存储纹理缓冲区和包含一个浮点值的推送常量范围的权限（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中的*指定管线着色器阶段*，*创建管线布局做法*和*创建计算管线*的做法）。
- en: Create a graphics pipeline with vertex, geometry, and fragment shaders as described
    in the *Drawing billboards using geometry shaders* recipe. The graphics pipeline
    must fetch two vertex attributes, draw vertices as `VK_PRIMITIVE_TOPOLOGY_POINT_LIST`
    primitives and must have blending enabled (refer to the *Specifying pipeline vertex
    input state*, *Specifying pipeline input assembly state*, *Specifying pipeline
    blend state*, and *Creating a graphics pipeline* recipes from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个图形管线，其中包含顶点、几何和片段着色器，如*使用几何着色器绘制广告牌*的做法所述。图形管线必须获取两个顶点属性，以`VK_PRIMITIVE_TOPOLOGY_POINT_LIST`原语绘制顶点，并且必须启用混合（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中的*指定管线顶点输入状态*，*指定管线输入装配状态*，*指定管线混合状态*和*创建图形管线*的做法）。
- en: To render a frame, record a command buffer that dispatches compute work and
    submit it to a queue that supports compute operations. Provide a semaphore to
    be signaled when the queue finishes processing the submitted command buffer (refer
    to the *Providing data to shaders through push* *constants* and *Dispatching a
    compute work recipes* from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording*, and the *Submitting command buffers to the queue* recipe
    from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization*).
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要渲染一帧，记录一个命令缓冲区，该缓冲区调度计算工作并将其提交到支持计算操作的队列中。提供一个信号量，当队列完成处理提交的命令缓冲区时触发该信号量（参考[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录*中的*通过推送*常量向着色器提供数据*和*调度计算工作*配方，以及[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中的*将命令缓冲区提交到队列*配方）。
- en: Also, in each frame record a command buffer that draws billboards as described
    in the *Drawing billboards using geometry shaders* recipe. Submit it to the queue
    that supports graphics operations. During submission, provide a semaphore, which
    is signaled by the compute queue. Provide it as a wait semaphore (refer to the
    *Synchronizing two command buffers* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在每一帧中记录一个命令缓冲区，该缓冲区按照*使用几何着色器绘制广告牌*配方绘制广告牌。将其提交到支持图形操作的队列中。在提交过程中，提供一个信号量，该信号量由计算队列触发。将其作为等待信号量提供（参考[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中的*同步两个命令缓冲区*配方）。
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Drawing particle systems can be divided in two steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制粒子系统可以分为两个步骤：
- en: We calculate and update positions of all particles with compute shaders
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用计算着色器计算并更新所有粒子的位置。
- en: We draw particles in updated positions using graphics pipeline with vertex,
    geometry, and fragment shaders
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用顶点、几何和片段着色器通过图形管线在更新后的位置绘制粒子。
- en: 'To prepare a particle system, we need to think about the data needed to calculate
    positions and draw all particles. In this example we will use three parameters:
    position, speed and color. Each set of these parameters will be accessed by a
    vertex shader through a vertex buffer, and the same data will be read in a compute
    shader. A simple and convenient way to access a very large number of entries in
    stages other than the vertex shader is to use a texel buffer. As we want to both
    read and store data, we will need a storage texel buffer. It allows us to fetch
    data from a buffer treated as a 1-dimensional image (refer to the *Creating a
    storage texel buffer* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备粒子系统，我们需要考虑计算位置和绘制所有粒子所需的数据。在这个例子中，我们将使用三个参数：位置、速度和颜色。这些参数的每一组都将通过顶点缓冲区由顶点着色器访问，并且相同的数据将在计算着色器中被读取。在除了顶点着色器之外的其他阶段访问大量条目的简单方便的方法是使用texel缓冲区。由于我们既要读取又要存储数据，因此我们需要一个存储texel缓冲区。它允许我们从被视为一维图像的缓冲区中获取数据（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中的*创建存储texel缓冲区*配方）。
- en: First, we need to generate initial data for our particle system. For the data
    available in a storage texel buffer to be properly read, it must be stored according
    to a selected format. Storage texel buffers have a limited set of formats that
    are mandatory, so we need to pack the parameters of our particles to one of them.
    Positions and colors require at least three values each. In our example, particles
    will move around the center of the whole system, so the velocity can be easily
    calculated based on the particle's current position. We just need to differentiate
    the speed of particles. For this purpose one value for scaling our velocity vector
    is enough.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的粒子系统生成初始数据。为了正确读取存储在存储texel缓冲区中的数据，它必须按照选定的格式存储。存储texel缓冲区有一组有限的强制格式，因此我们需要将我们的粒子参数打包到其中之一。位置和颜色每个至少需要三个值。在我们的例子中，粒子将在整个系统的中心周围移动，因此速度可以根据粒子的当前位置轻松计算。我们只需要区分粒子的速度。为此，一个用于缩放速度向量的值就足够了。
- en: 'So we end up with seven values. We will pack them into two RGBA vectors of
    floating-point values. First we have three `X`, `Y`, `Z` components of a position
    attribute. The next value is unused in our particle system, but for the data to
    be correctly read, it needs to be included. We will store a `1.0f` value as a
    fourth component of the position attribute. After that there are `R`, `G`, `B`
    values for a color, and a value scaling the speed vector of a particle. We randomly
    generate all values and store them in a vector:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们最终得到七个值。我们将它们打包成两个RGBA浮点向量。首先有三个`X`、`Y`、`Z`分量表示位置属性。下一个值在我们的粒子系统中未使用，但为了正确读取数据，它需要被包含。我们将一个`1.0f`值存储为位置属性的第四个分量。之后是颜色属性的`R`、`G`、`B`值，以及一个缩放粒子速度向量的值。我们随机生成所有值并将它们存储在一个向量中：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The generated data is copied to the buffer. We create a buffer that will serve
    both as a vertex buffer during rendering and as a storage texel buffer during
    position calculations:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的数据被复制到缓冲区中。我们创建一个缓冲区，它将作为渲染期间的顶点缓冲区，以及在位置计算期间的存储纹理缓冲区：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Additionally, we need a uniform buffer, through which we will provide transformation
    matrices. A uniform buffer along the storage texel buffer will be provided to
    shaders through descriptor sets. Here we will have two separate sets. In the first
    set, we will have only a uniform buffer accessed by vertex and geometry shaders.
    The second descriptor set is used in a compute shader to access storage texel
    buffer. For this purpose we need two separate descriptor set layouts:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要一个统一缓冲区，通过它我们将提供变换矩阵。存储纹理缓冲区旁边的统一缓冲区将通过描述符集提供给着色器。在这里，我们将有两个独立的集。在第一个集中，我们将只有一个由顶点和几何着色器访问的统一缓冲区。第二个描述符集用于计算着色器访问存储纹理缓冲区。为此，我们需要两个独立的描述符集布局：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we need a pool from which we can allocate two descriptor sets:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个池，我们可以从中分配两个描述符集：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After that, we can allocate two descriptors sets and update them with the created
    buffer and buffer view:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以分配两个描述符集，并使用创建的缓冲区和缓冲区视图来更新它们：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next important step is the creation of graphics and compute pipelines.
    When a movement is involved, calculations must be performed based on real-time
    values, as we usually cannot rely on fixed time intervals. So the compute shader
    must have access to a value of time that has elapsed since the last frame. Such
    a value may be provided through a push constant range. We can see the code required
    to create the compute pipeline here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要步骤是创建图形和计算管线。当涉及到移动时，计算必须基于实时值进行，因为我们通常不能依赖于固定的时间间隔。因此，计算着色器必须能够访问自上一帧以来经过的时间值。这样的值可以通过推送常量范围提供。我们可以在这里看到创建计算管线所需的代码：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Compute shaders read data from the storage texel buffer defined as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器从如下定义的存储纹理缓冲区读取数据：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Data from the storage texel buffer is read using the `imageLoad()` function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`imageLoad()`函数从存储纹理缓冲区读取数据：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We read two values so we need two `imageLoad()` calls, because each such operation
    returns one element of a format defined for the buffer (in this case, a 4-component
    vector of floats). We access the buffer based on a unique value of a current compute
    shader instance.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取两个值，因此需要两个`imageLoad()`调用，因为每个这样的操作都返回缓冲区（在这种情况下，一个4分量浮点向量）定义的格式的一个元素。我们根据当前计算着色器实例的唯一值访问缓冲区。
- en: 'Next, we perform calculations and update the positions of the vertices. Calculations
    are performed so the particles move around the center of the scene based on the
    position and an up vector. A new vector (speed) is calculated using the `cross()`
    function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进行计算并更新顶点的位置。计算是为了让粒子根据位置和向上向量围绕场景中心移动。使用`cross()`函数计算一个新的向量（速度）：
- en: '![](img/image_12_007.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_12_007.png)'
- en: 'This calculated speed vector is added to the fetched position and the result
    is stored in the same buffer using the `imageStore()` function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算出的速度向量被添加到获取的位置上，结果使用`imageStore()`函数存储在同一个缓冲区中：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We don't update a color or speed, so we store only one value.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有更新颜色或速度，所以我们只存储一个值。
- en: Because we access the data of only one particle, we can read values from and
    store values in the same buffer. In more complicated scenarios, such as when there
    are interactions between particles, we can't use the same buffer. The order in
    which compute shader invocations are executed is unknown, so we would end up with
    some invocations accessing unmodified values, but others would read data that
    has already been updated. This would impact the accuracy of performed calculations
    and probably result in an unpredictable system.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只访问一个粒子的数据，我们可以从同一缓冲区读取值并将值存储在同一个缓冲区中。在更复杂的场景中，例如当粒子之间存在交互时，我们不能使用同一个缓冲区。计算着色器调用的执行顺序是未知的，因此一些调用将访问未修改的值，而其他调用将读取已经更新的数据。这将影响计算结果的准确性，并可能导致系统不可预测。
- en: 'Graphics pipeline creation is very similar to the one presented in the *Drawing
    billboards using geometry shaders* recipe. The difference is that it fetches two
    attributes instead of one:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图形管线创建与“使用几何着色器绘制广告牌”方法中展示的非常相似。不同之处在于它获取两个属性而不是一个：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also render vertices as point primitives:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还以点原语的形式渲染顶点：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One last difference is that here we enable additive blending, so the particles
    look like they are glowing:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个区别是，在这里我们启用了加法混合，因此粒子看起来像是在发光：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The drawing process is also divided into two steps. First, we record a command
    buffer that dispatches compute work. Some hardware platforms may have a queue
    family that is dedicated to math calculations, so it may be preferable to submit
    command buffers with compute shaders to that queue:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制过程也被分为两个步骤。首先，我们记录一个命令缓冲区，用于调度计算工作。某些硬件平台可能有一个专门用于数学计算的队列家族，因此将带有计算着色器的命令缓冲区提交到该队列可能更可取：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Drawing is performed in the normal way. We just need to synchronize the graphics
    queue with a compute queue. We do this by providing an additional wait semaphore
    when we submit a command buffer to the graphics queue. This semaphore must be
    signaled by a compute queue when it finishes processing the submitted command
    buffer in which the
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制以正常方式进行。我们只需要将图形队列与计算队列同步。我们通过在提交命令缓冲区到图形队列时提供一个额外的等待信号量来实现这一点。当计算队列完成处理提交的命令缓冲区时，它必须发出信号：
- en: compute shaders are dispatched.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器被调度。
- en: 'The following sample images show the same particle system rendered with different
    numbers of particles:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例图像展示了使用不同数量的粒子渲染的相同粒子系统：
- en: '![](img/image_12_008.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_008.png)'
- en: See also
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: In [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml), *Instances and Devices*,
    see the Getting features and properties of a physical device recipe
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml)，“实例和设备”，查看获取物理设备特性和属性的方法
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipes:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，“描述符集”，查看以下方法：
- en: '*Creating a storage texel buffer*'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建存储纹理缓冲区*'
- en: '*Creating a descriptor set layout*'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建描述符集布局*'
- en: '*Creating a descriptor pool*'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建描述符池*'
- en: '*Allocating descriptor sets*'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配描述符集*'
- en: '*Updating descriptor sets*'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新描述符集*'
- en: In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see the
    Writing compute shaders recipe
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，“着色器”，查看编写计算着色器的方法
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，“图形和计算管线”，查看以下方法：
- en: '*Creating a shader module*'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Creating a compute pipeline*'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建计算管线*'
- en: '*Creating a graphics pipeline*'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipes:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，“命令录制和绘制”，查看以下方法：
- en: '*Providing data to shaders through push constants*'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过推送常量向着色器提供数据*'
- en: '*Drawing a geometry*'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制几何体*'
- en: '*Dispatching a compute work*'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调度计算工作*'
- en: Rendering a tessellated terrain
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染细分地形
- en: 3D scenes with open worlds and long rendering distances usually also contain
    vast terrains. Drawing ground is a very complex topic and can be performed in
    many different ways. Terrain in a distance cannot be too complex, as it will take
    up too much memory and processing power to display it. On the other hand, the
    area near the player must be detailed enough to look convincing and natural. That's
    why we need a way to lower the number of details with increasing distance or to
    increase the terrain's fidelity near the camera.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 具有开放世界和长渲染距离的3D场景通常也包含广阔的地形。绘制地面是一个非常复杂的话题，可以以许多不同的方式执行。远处的地形不能太复杂，因为它将占用太多的内存和计算能力来显示。另一方面，靠近玩家的区域必须足够详细，以看起来令人信服和自然。这就是为什么我们需要一种方法来随着距离的增加降低细节数量，或者在摄像机附近增加地形的保真度。
- en: This is an example of how the tessellation shaders can be used to achieve high quality
    rendered images. For a terrain, we can use a flat plane with low number of vertices.
    Using tessellation shaders, we can increase the number of primitives of the ground
    near the camera. We can then offset generated vertices by the desired amount to
    increase or decrease the height of a terrain.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用细分着色器实现高质量渲染图像的示例。对于地形，我们可以使用具有少量顶点的平面。使用细分着色器，我们可以增加靠近摄像机的地面原素的数量。然后我们可以通过所需的量偏移生成的顶点，以增加或减少地形的高度。
- en: 'The following screenshot is an example of an image generated using this recipe:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是使用此配方生成的图像示例：
- en: '![](img/image_12_009.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/image_12_009.png)'
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Drawing a terrain usually requires the preparation of height data. This can
    be generated on the fly, procedurally, according to some desired formulae. However,
    it can also be prepared earlier in the form of a texture called a height map.
    It contains information about the terrain''s height above (or below) a specified
    altitude, in which a lighter color indicates a greater height and a darker color
    indicates a lower height. An example of such a height map can be seen in the following
    image:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制地形通常需要准备高度数据。这可以即时、根据某些期望的公式进行生成。然而，它也可以以高度图这种纹理的形式提前准备。它包含有关地形相对于指定海拔高度的高度信息，其中较浅的颜色表示较高的高度，较深的颜色表示较低的高度。以下图像显示了此类高度图的一个示例：
- en: '![](img/image_12_010.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/image_12_010.png)'
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Load or generate a model of a flat, horizontally-aligned plane. Two attributes--position
    and texture coordinate--will be needed. Upload the vertex data to a vertex buffer
    (refer to the *Loading a 3D model from an OBJ file* recipe from [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml),
    *Helper Recipes* and to the *Creating a buffer* and *Using staging buffer to update
    buffer with a device-local memory bound* recipes from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载或生成一个水平对齐的平面模型。需要两个属性——位置和纹理坐标。将顶点数据上传到顶点缓冲区（参考第10章的*从OBJ文件加载3D模型*配方，*辅助配方*，以及第4章的*创建缓冲区*和*使用阶段缓冲区更新设备本地内存绑定缓冲区*配方，*资源和内存*）。
- en: Create a uniform buffer for two transformation matrices (refer to the *Creating
    a uniform buffer* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为两个变换矩阵创建一个统一缓冲区（参考第5章的*创建统一缓冲区*配方，*描述符集*）。
- en: Load height information from an image file (refer to the *Loading texture data
    from a file* recipe from [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml),
    *Helper Recipes*). Create a combined image sampler and copy the loaded height
    data to image's memory (refer to the *Creating a combined image sampler* recipe
    from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*
    and to the *Using the staging buffer to update an image with a device-local memory
    bound* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources
    and Memory*).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从图像文件加载高度信息（参考第10章的*从文件加载纹理数据*配方，*辅助配方*）。创建一个组合图像采样器并将加载的高度数据复制到图像的内存中（参考第5章的*创建组合图像采样器*配方，*描述符集*，以及第4章的*使用阶段缓冲区更新具有设备本地内存绑定图像*配方，*资源和内存*）。
- en: Create a descriptor set layout with one uniform buffer accessed by tessellation
    control and geometry stages and one combined image sampler accessed by tessellation
    control and evaluation stages (refer to the *Creating a descriptor set layout*
    recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*). Allocate a descriptor set using the prepared layout. Update it with the
    created uniform buffer and sampler and image view handles (refer to the *Allocating
    descriptor sets* and *Updating descriptor sets* recipes from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个描述符集布局，其中包含一个由细分控制和几何阶段访问的统一缓冲区和一个由细分控制和评估阶段访问的联合图像采样器（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中的*创建描述符集布局*配方）。使用准备好的布局分配描述符集。使用创建的统一缓冲区和采样器以及图像视图句柄更新它（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中的*分配描述符集*和*更新描述符集*配方）。
- en: 'Create a shader module with a SPIR-V assembly for a vertex shader created from
    the following GLSL code (refer to the *Creating a shader module* recipe from [Chapter
    8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute Pipelines*):'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下GLSL代码创建一个顶点着色器，并为其创建一个SPIR-V汇编（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中的*创建着色器模块*配方）：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a shader module for a tessellation control stage. Use the following
    GLSL code to generate a SPIR-V assembly from:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为一个细分控制阶段创建一个着色器模块。使用以下GLSL代码从以下内容生成SPIR-V汇编：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a shader module for a tessellation evaluation shader created from the
    following GLSL code:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下GLSL代码创建一个细分评估着色器，创建一个着色器模块：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a shader module for a geometry shader and use the following GLSL code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为几何着色器创建一个着色器模块，并使用以下GLSL代码：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a shader module that contains a source code of a fragment shader. Generate
    a SPIR-V assembly from the following GLSL code:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含片段着色器源代码的着色器模块。从以下GLSL代码生成SPIR-V汇编：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a graphics pipeline using the above five shader modules. The pipeline
    should fetch two vertex attributes: a 3-component position and a 2-component texture
    coordinate. It must use `VK_PRIMITIVE_TOPOLOGY_PATCH_LIST` primitives. A patch
    should consist of three control points (refer to the *Specifying pipeline input
    assembly state*, *Specifying pipeline tessellation state*, *Specifying graphics
    pipeline creation parameters*, and *Creating a graphics pipeline* recipes from
    [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*).'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上述五个着色器模块创建一个图形管线。该管线应检索两个顶点属性：一个3分量位置和一个2分量纹理坐标。它必须使用`VK_PRIMITIVE_TOPOLOGY_PATCH_LIST`原语。一个补丁应包含三个控制点（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中的*指定管线输入装配状态*、*指定管线细分状态*、*指定图形管线创建参数*和*创建图形管线*配方）。
- en: Create the remaining resources and draw the geometry (refer to the *Rendering
    a geometry with a vertex diffuse lighting* recipe from [Chapter 11](45108a92-6d49-4759-9495-3f1166e69128.xhtml),
    *Lighting*).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建剩余的资源并绘制几何图形（参考[第11章](45108a92-6d49-4759-9495-3f1166e69128.xhtml)，*光照*中的*使用顶点漫反射光照渲染几何图形*配方）。
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start the process of drawing a terrain by loading a model of a flat plane.
    It may be a simple quad with a little bit more than four vertices. Generating
    too many vertices in a tessellation stage may be too expensive performance-wise,
    so we need to find a balance between the complexity of a base geometry and the
    tessellation factors. We can see a plane used as a base for the tessellated terrain
    in the following image:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过加载一个平坦平面的模型开始绘制地形的绘制过程。它可能是一个带有超过四个顶点的简单四边形。在细分阶段生成过多的顶点可能在性能上过于昂贵，因此我们需要在基本几何的复杂性和细分因子之间找到平衡。我们可以在以下图像中看到用作细分地形基础的平面：
- en: '![](img/image_12_011.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_12_011.png)'
- en: 'In this example, we will load height information from a texture. We do this
    in the same way as we load data from files. Then we create a combined image sampler
    and upload loaded data to its memory:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将从纹理中加载高度信息。我们以与从文件加载数据相同的方式进行此操作。然后我们创建一个联合图像采样器并将加载的数据上传到其内存中：
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A uniform buffer with transformation matrices is also required, so the vertices
    can be transformed from local space to a view space and to the clip space:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要一个包含变换矩阵的统一缓冲区，以便将顶点从局部空间变换到视图空间和裁剪空间：
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The next step is to create a descriptor set for the uniform buffer and the
    combined image sampler. A uniform buffer is accessed in the tessellation control
    and geometry stages. Height information is read in the tessellation control and
    evaluation stages:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为统一缓冲区和组合图像采样器创建描述符集。统一缓冲区在镶嵌控制和几何阶段被访问。高度信息在镶嵌控制和评估阶段读取：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next, we can update the descriptor set with the uniform buffer handle and with
    sampler and image view handles as they don't change during the lifetime of our
    application (that is, we don't need to recreate them when the window size is modified).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用统一缓冲区句柄以及采样器和图像视图句柄更新描述符集，因为它们在我们的应用程序生命周期内不会改变（也就是说，当窗口大小修改时，我们不需要重新创建它们）。
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next step is to create a graphics pipeline. This time we have a very complex
    pipeline with all five programmable graphics stages enabled:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建图形管线。这次我们有一个非常复杂的管线，所有五个可编程图形阶段都被启用：
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Why do we need all five stages? A vertex shader is always required. This time
    it only reads two input attributes (position and texcoord) and passes it further
    down the pipeline.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要所有五个阶段？顶点着色器始终是必需的。这次它只读取两个输入属性（位置和texcoord）并将其传递到管线中。
- en: 'When tessellation is enabled, we need both the control and evaluation shader
    stages. The tessellation control shader, as the name suggests, controls the tessellation
    level of processed patches (the amount of generated vertices). In this recipe,
    we generate vertices based on the distance from the camera: the closer the vertices
    of a patch are to the camera, the more vertices are generated by the tessellator.
    This way, the terrain in the distance is simple and doesn''t take much processing
    power to be rendered; but, the closer to the camera, the more complex the terrain
    becomes.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用镶嵌时，我们需要控制和评估着色器阶段。镶嵌控制着色器，正如其名称所暗示的，控制处理补丁的镶嵌级别（生成的顶点数量）。在这个菜谱中，我们根据从摄像机到距离生成顶点：补丁的顶点越靠近摄像机，镶嵌器生成的顶点就越多。这样，远处的地形简单，不需要太多处理能力来渲染；但是，越靠近摄像机，地形就越复杂。
- en: 'We can''t choose one tessellation level for the whole patch (in this case a
    triangle). When two neighboring triangles are tessellated with different factors,
    different number of vertices will be generated on their common edge. Vertices
    from each triangle will be placed in different locations and they will be offset
    by different values. This will create holes in our ground:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能为整个补丁（在这种情况下是一个三角形）选择一个镶嵌级别。当两个相邻的三角形以不同的因子进行镶嵌时，它们在公共边上的顶点数量将不同。每个三角形的顶点将放置在不同的位置，并且它们将以不同的值偏移。这将在我们的大地上造成空洞：
- en: '![](img/image_12_012.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_12_012.png)'
- en: 'In the preceding image we see two triangles: the left formed from vertices
    L0-L1-L7, and right formed from vertices R0-R1-R4\. The other vertices are generated
    by the tessellator. Triangles share an edge: L1-L7 or R1-R4 (points L1 and R4
    indicate the same vertex; similarly points L7 and R1 indicate the same vertex);
    but the edge is tessellated with different factors. This causes discontinuities
    (indicated by stripes) in the surface formed by the two triangles.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，我们看到两个三角形：左边由顶点L0-L1-L7组成，右边由顶点R0-R1-R4组成。其他顶点由镶嵌器生成。三角形共享一条边：L1-L7或R1-R4（点L1和R4表示同一个顶点；同样，点L7和R1表示同一个顶点）；但是，边以不同的因子进行镶嵌。这会在由两个三角形形成的表面上造成不连续性（由条纹表示）。
- en: 'To avoid this problem, we need to calculate a tessellation factor for each
    triangle edge in such a way that it is fixed across triangles that share the same
    edge. In this example, we will calculate tessellation factors based on the distance
    of a vertex from the camera. We will do this for all vertices in a triangle. Then,
    for a given triangle edge, we will choose a greater tessellation factor that was
    calculated from one of the edge''s vertices:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们需要为每个三角形边计算一个镶嵌因子，使其在共享相同边的三角形之间保持固定。在这个例子中，我们将根据顶点到摄像机的距离来计算镶嵌因子。我们将对三角形中的所有顶点都这样做。然后，对于给定的三角形边，我们将选择一个更大的镶嵌因子，该因子是从边的某个顶点计算出来的：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding tessellation control shader code, we calculate a distance (squared)
    from all vertices to the camera. We need to offset positions by the amount read
    from the height map, so the whole patch is in the correct place and the distance
    is properly calculated.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的镶嵌控制着色器代码中，我们计算了所有顶点到摄像机的距离（平方）。我们需要通过从高度图中读取的值来偏移位置，以确保整个补丁位于正确的位置，并且距离被正确计算。
- en: Next, for all triangle edges, we take the smaller distance of edge's two vertices.
    As we want a tessellation factor to increase with decreasing distance, we need
    to invert the calculated factor. Here we take a hardcoded value of `20` and subtract
    a chosen distance value. As we don't want the tessellation factor to be smaller
    than `1.0`, we perform additional clamping.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于所有三角形边，我们取两个顶点之间的较小距离。因为我们希望细分因子随着距离的减小而增加，所以我们需要反转计算出的因子。在这里，我们取一个硬编码的值`20`并减去一个选定的距离值。因为我们不希望细分因子小于`1.0`，所以我们执行额外的钳位。
- en: The tessellation factor calculated like this exaggerates the effect of decreasing
    the number of generated vertices with increasing distance. This is done on purpose
    so that we can see how triangles are tessellated and how the number of details
    increases near the camera. However, in real-life examples we should prepare such
    a formula so that the effect is barely visible.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这样计算的细分因子会随着生成顶点数量的增加而减小，这是故意为之，以便我们可以看到三角形是如何细分的，以及细节数量在相机附近的增加情况。然而，在实际示例中，我们应该准备这样的公式，以便效果几乎不可见。
- en: 'Next, a tessellation evaluation shader takes the weights of generated vertices
    to calculate a valid position of the new vertices. We do the same for texture
    coordinates, as we need to load height information from the height map:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一个细分评估着色器根据生成的顶点的权重来计算新顶点的有效位置。我们同样对纹理坐标进行相同的处理，因为我们需要从高度图中加载高度信息：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After the position of a new vertex is calculated, we need to offset it, so
    the vertex is placed at an appropriate height:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算出新顶点的位置后，我们需要对其进行偏移，以便顶点位于适当的高度：
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The tessellation evaluation shader stage is followed by the geometry shader
    stage. We can omit it but here we use it to calculate the normal vector of the
    generated triangle. We take one normal vector for all the triangle's vertices,
    so we will perform a flat shading in this sample.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 细分评估着色器阶段之后是几何着色器阶段。我们可以省略它，但在这里我们使用它来计算生成三角形的法向量。我们为三角形的所有顶点取一个法向量，因此在这个示例中我们将执行平面着色。
- en: 'The normal vector is calculated with the `cross()` function, which takes two
    vectors and returns a vector that is perpendicular to those provided. We provide
    vectors forming two edges of a triangle:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 法向量是通过`cross()`函数计算的，该函数接受两个向量并返回一个垂直于所提供向量的向量。我们提供形成三角形两条边的向量：
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, the geometry shader calculates the clip space positions of all vertices
    and emits them:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，几何着色器计算所有顶点的裁剪空间位置并将它们发出：
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To simplify the recipe, a fragment shader is also simple. It mixes three colors
    based on the height above ground: green for grass in the lower parts, grey/brown
    for rocks in the middle, and white for snow in mountain tops. It also performs
    simple lighting calculations using the diffuse/Lambert light model.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化配方，片段着色器也很简单。它根据地面以上的高度混合三种颜色：下部的草地为绿色，中间的岩石为灰色/棕色，山顶的雪为白色。它还使用漫射/朗伯光照模型进行简单的光照计算。
- en: 'The preceding shaders form a graphics pipeline used to draw a tessellated terrain.
    During pipeline creation we must remember to think about primitive topology. Because
    of the enabled tessellation stages, we need to use a `VK_PRIMITIVE_TOPOLOGY_PATCH_LIST`
    topology. We also need to provide a tessellation state during pipeline creation.
    As we want to operate on triangles, we specify that a patch contains three control
    points:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的着色器形成了一个用于绘制细分地形的图形管道。在创建管道期间，我们必须记住要考虑原语拓扑。由于启用了细分阶段，我们需要使用`VK_PRIMITIVE_TOPOLOGY_PATCH_LIST`拓扑。我们还需要在创建管道期间提供细分状态。因为我们想对三角形进行操作，所以我们指定一个补丁包含三个控制点：
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The remaining parameters used for pipeline creation are defined in the usual
    way. We also don''t need to do anything special during rendering. We just draw
    a plane with the preceding graphics pipeline bound, and we should see a geometry
    resembling a terrain. We can see examples of results generated with this recipe
    in the following images:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 用于管道创建的其余参数以通常的方式定义。我们也不需要在渲染期间做任何特殊的事情。我们只需使用先前绑定的图形管道绘制一个平面，我们应该看到一个类似地形的几何形状。我们可以在以下图像中看到使用此配方生成的结果示例：
- en: '![](img/image_12_013.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_013.png)'
- en: See also
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and Memory*,
    see the *Creating a buffer* recipe
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*，查看*创建缓冲区*配方
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipes:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中，查看以下配方：
- en: '*Creating a combined image sampler*'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建组合图像采样器*'
- en: '*Creating a uniform buffer*'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建统一缓冲区*'
- en: '*Creating a descriptor set layout*'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建描述符集布局*'
- en: '*Allocating descriptor sets*'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配描述符集*'
- en: '*Updating descriptor sets*'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新描述符集*'
- en: 'In [Chapter 7](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml), *Shaders*, see
    the following recipes:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](97217f0d-bed7-4ae1-a543-b4d599f299cf.xhtml)，*着色器*中，查看以下配方：
- en: '*Writing tessellation control shaders*'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写细分控制着色器*'
- en: '*Writing tessellation evaluation shaders*'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写细分评估着色器*'
- en: '*Writing geometry shaders*'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写几何着色器*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*中，查看以下配方：
- en: '*Creating a shader module*'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Specifying the pipeline input assembly state*'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线输入装配状态*'
- en: '*Specifying the pipeline tessellation state*'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线细分状态*'
- en: '*Creating a graphics pipeline*'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: 'In [Chapter 10](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml), *Helper Recipes*,
    see the following recipes:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第10章](1b6b28e0-2101-47a4-8551-c30eb9bfb573.xhtml)，*辅助配方*中，查看以下配方：
- en: '*Loading texture data from a file*'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从文件中加载纹理数据*'
- en: '*Loading a 3D model from an OBJ file*'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从OBJ文件加载3D模型*'
- en: In [Chapter 11](45108a92-6d49-4759-9495-3f1166e69128.xhtml), *Lighting*, see
    the *Rendering a geometry with a vertex diffuse lighting recipe*
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第11章](45108a92-6d49-4759-9495-3f1166e69128.xhtml)，*光照*中，查看*使用顶点漫反射光照配方渲染几何体*
- en: Rendering a full-screen quad for post-processing
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染全屏四边形进行后期处理
- en: Image processing is another class of techniques commonly used in 3D graphics.
    Human eyes perceive the world around us in a way that is almost impossible to
    simulate directly. There are many effects which cannot be displayed by just drawing
    a geometry. For example, bright areas seem larger than dark areas (this is usually
    referred to as bloom); objects seen at our focus point are sharp, but the further
    from the focus distance, these objects become more fuzzy or blurred (we call this
    effect a depth of field); color can be perceived differently during the day and
    at night, when with very little lighting, everything seems more blueish.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理是3D图形中常用的一类技术。人眼感知周围世界的方式几乎无法直接模拟。有许多效果仅通过绘制几何形状是无法显示的。例如，亮区似乎比暗区大（这通常被称为光晕）；在我们焦点处的物体看起来很清晰，但距离焦点越远，这些物体变得越模糊或模糊（我们称这种效果为景深）；颜色在白天和夜晚的感知可能不同，当光线非常微弱时，一切似乎都带有更多的蓝色。
- en: These phenomena are easily implemented as post-processing effects. We render
    the scene normally into an image. After that, we perform another rendering, this
    time taking the data stored in an image and processing it according to a chosen
    algorithm. To render an image, we need to place it on a quad that covers the whole
    scene. Such a geometry is usually called a fullscreen quad.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这些现象很容易作为后期处理效果实现。我们通常将场景渲染到图像中。之后，我们进行另一次渲染，这次是使用存储在图像中的数据，并按照选择的算法进行处理。要渲染图像，我们需要将其放置在一个覆盖整个场景的四边形上。这种几何形状通常被称为全屏四边形。
- en: How to do it...
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Prepare vertex data for the quad''s geometry. Use the following values for
    four vertices (add texture coordinates if needed):'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备四边形的几何顶点数据。使用以下值（如有需要，请添加纹理坐标）：
- en: '`{ -1.0f, -1.0f, 0.0f }` for top left vertex'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ -1.0f, -1.0f, 0.0f }` 为左上角顶点'
- en: '`{ -1.0f, 1.0f, 0.0f }` for bottom left vertex'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ -1.0f, 1.0f, 0.0f }` 为左下角顶点'
- en: '`{ 1.0f, -1.0f, 0.0f }` for top right vertex'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ 1.0f, -1.0f, 0.0f }` 为右上角顶点'
- en: '`{ 1.0f, 1.0f, 0.0f }` for bottom right vertex'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ 1.0f, 1.0f, 0.0f }` 为右下角顶点'
- en: Create a buffer that will serve as a vertex buffer. Allocate a memory object
    and bind it to the buffer. Upload vertex data to the buffer using a staging resource
    (refer to the *Creating a buffer*, *Allocating and binding memory object to a
    buffer*, and *Using staging buffer to update buffer with a device-local memory
    bound* recipes from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources
    and Memory*).
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个作为顶点缓冲区的缓冲区。分配一个内存对象并将其绑定到缓冲区。使用阶段资源（参考[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*中的*创建缓冲区*、*分配和绑定内存对象到缓冲区*和*使用阶段缓冲区更新绑定设备本地内存的缓冲区*）将顶点数据上传到缓冲区。
- en: 'Create a combined image sampler. Remember to provide valid uses that depend
    on the way the image will be accessed during rendering and post-processing: rendering
    a scene into an image requires a `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`; sampling
    an image (reading data using a sampler) requires a `VK_IMAGE_USAGE_SAMPLED_BIT`;
    for image load/stores we must provide a `VK_IMAGE_USAGE_STORAGE_BIT`; other uses
    may also be necessary (refer to the *Creating a combined image sampler* recipe
    from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个组合图像采样器。请记住，根据图像在渲染和后期处理期间将被访问的方式提供有效的用途：将场景渲染到图像中需要一个`VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`；采样图像（使用采样器读取数据）需要一个`VK_IMAGE_USAGE_SAMPLED_BIT`；对于图像加载/存储，我们必须提供一个`VK_IMAGE_USAGE_STORAGE_BIT`；可能还需要其他用途（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中*创建组合图像采样器*的配方）。
- en: Create a descriptor set layout with one combined image sampler. Create a descriptor
    pool and allocate a descriptor set from it using the created layout. Update the
    descriptor set with the image view's and sampler handles. Do it each time an application
    window is resized and an image is recreated (refer to the *Creating a descriptor
    set layout*, *Creating a descriptor pool*, *Allocating descriptor sets*, and *Updating
    descriptor sets* recipes from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含一个组合图像采样器的描述符集布局。创建一个描述符池，并使用创建的布局从其中分配一个描述符集。使用图像视图的句柄和采样器更新描述符集。每次应用程序窗口大小调整且图像被重新创建时都要这样做（参考[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中的*创建描述符集布局*、*创建描述符池*、*分配描述符集*和*更新描述符集*的配方）。
- en: If we want to access many different image coordinates, create a separate, dedicated
    render pass with one color attachment and at least one subpass (refer to the *Specifying
    attachments descriptions*, *Specifying subpass descriptions*, *Specifying dependencies
    between subpasses*, and *Creating a render pass* recipes from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*).
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要访问许多不同的图像坐标，创建一个单独的、专用的渲染通道，其中包含一个颜色附件和至少一个子通道（参考[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*中的*指定附件描述*、*指定子通道描述*、*指定子通道之间的依赖关系*和*创建渲染通道*的配方）。
- en: 'Create a shader module with a SPIR-V assembly for a vertex shader created from
    the following GLSL code (refer to the *Creating a shader module* recipe from [Chapter
    8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute Pipelines*):'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下GLSL代码创建一个顶点着色器，并为其创建一个SPIR-V汇编模块（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*创建着色器模块*）：
- en: '[PRE45]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a shader module for a fragment shader created from the following GLSL
    code:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下GLSL代码创建一个片段着色器：
- en: '[PRE46]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Create a graphics pipeline using the preceding shader modules. It must read
    one vertex attribute with vertex positions (and potentially a second attribute
    with texture coordinates). Use a `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP` topology
    and disable face culling (refer to the *Specifying pipeline vertex input state*,
    *Specifying pipeline input assembly state*, *Specifying pipeline rasterization
    state*, and *Creating a graphics pipeline* recipes from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*).
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面的着色器模块创建一个图形管线。它必须读取一个顶点属性，包含顶点位置（以及可能的一个包含纹理坐标的第二个属性）。使用`VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP`拓扑，并禁用面剔除（参考[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*指定管线顶点输入状态*、*指定管线输入装配状态*、*指定管线光栅化状态*和*创建图形管线*的配方）。
- en: Render a scene into the created image. Next, start another render pass and draw
    the full-screen quad using the prepared graphics pipeline (refer to the Beginning
    a render pass and Ending a render pass recipes from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml),
    *Render Passes and Framebuffers*, to the *Binding descriptor sets* recipe from
    [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*, and
    to the *Binding vertex buffers* and *Drawing a geometry recipes* from [Chapter
    9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording and Drawing*).
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将场景渲染到创建的图像中。接下来，开始另一个渲染通道，并使用准备好的图形管线绘制全屏四边形（参考[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染通道和帧缓冲区*中的*开始渲染通道*和*结束渲染通道*配方，[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*中的*绑定描述符集*配方，以及[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令记录和绘制*中的*绑定顶点缓冲区*和*绘制几何体*配方）。
- en: How it works...
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Image post-processing can be performed using compute shaders. However, when
    we want to display an image on screen, we must use a swapchain. Storing data in
    an image from within shaders requires images to be created with the storage image
    use. Unfortunately, such usage may not be supported on swapchain images, so it
    would require the creation of additional, intermediate resources, which further
    increase the complexity of a code.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用计算着色器执行图像后处理。然而，当我们想在屏幕上显示图像时，我们必须使用交换链。从着色器内部存储数据到图像中要求创建具有存储图像用法的图像。不幸的是，这种用法可能不支持交换链图像，因此需要创建额外的中间资源，这进一步增加了代码的复杂性。
- en: Using a graphics pipeline allows us to process image data inside fragment shaders
    and store the results in color attachments. Such usage is mandatory for swapchain
    images, so this way feels more natural for image processing implemented with the
    Vulkan API. On the other hand, the graphics pipeline requires us to draw a geometry,
    so we need not only vertex data, and vertex and fragment shaders, but also a render
    pass and a framebuffer as well. That's why using compute shaders may be more efficient.
    So, everything depends on the features supported by the graphics hardware (available
    swapchain image usages) and the given situation.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图形管线允许我们在片段着色器内部处理图像数据并将结果存储在颜色附件中。这种用法对于交换链图像是强制性的，因此使用 Vulkan API 实现的图像处理感觉更自然。另一方面，图形管线要求我们绘制几何体，因此我们不仅需要顶点数据、顶点和片段着色器，还需要一个渲染通道和一个帧缓冲区。这就是为什么使用计算着色器可能更高效。所以，一切取决于图形硬件（可用的交换链图像用法）和给定情况支持的功能。
- en: 'In this recipe, we will present the method to draw a full-screen quad during
    an image postprocessing phase. First, we need the vertex data itself. It can be
    prepared directly in the clip space. This way we can create a much simpler vertex
    shader and avoid multiplying the vertex position by a projection matrix. After
    the perspective division, for the vertices to fit into a view, values stored in
    `x` and `y` components of their positions must fit into a <`-1, 1`> range (inclusive)
    and a value in a `z` component must be inside a <`0, 1`> range. So, if we want
    to cover the whole screen, we need the following set of vertices:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将介绍在图像后处理阶段绘制全屏四边形的方法。首先，我们需要顶点数据本身。它可以直接在裁剪空间中准备。这样我们可以创建一个更简单的顶点着色器，并避免将顶点位置乘以投影矩阵。在透视除法之后，为了使顶点适合视图，它们位置中的
    `x` 和 `y` 分量存储的值必须适合 `<-1, 1>` 范围（包含）内，而 `z` 分量中的值必须在 `<0, 1>` 范围内。因此，如果我们想覆盖整个屏幕，我们需要以下顶点集：
- en: '[PRE47]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We can add normalized texture coordinates if needed or we can rely on the built-in
    `gl_FragCoord` value (when writing GLSL shaders), which contain screen coordinates
    of a currently processed shader. When we use input attachments, we even don't
    need texture coordinates, as we can access only the sample associated with the
    currently processed fragment.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们可以添加归一化纹理坐标，或者我们可以依赖内置的 `gl_FragCoord` 值（当编写 GLSL 着色器时），它包含当前正在处理的着色器的屏幕坐标。当我们使用输入附件时，甚至不需要纹理坐标，因为我们只能访问与当前正在处理的片段关联的样本。
- en: 'Vertex data needs to be stored in a buffer serving as a vertex buffer. So we
    need to create it, allocate a memory object and bind it to the buffer and upload
    vertex data to the buffer:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点数据需要存储在一个作为顶点缓冲区的缓冲区中。因此，我们需要创建它，分配一个内存对象并将其绑定到缓冲区，然后将顶点数据上传到缓冲区：
- en: '[PRE48]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we need a way to access texel data inside the fragment shader. We can
    use an input attachment if we want to access data stored in a color attachment
    from any of the previous subpasses in the same render pass. We can use a storage
    image, separate the sampler and the sampled image or a combined image sampler.
    The latter is used in this recipe. To simplify this recipe and the code, we read
    texture data from a file. But usually we will have an image into which the scene
    will be rendered:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法来访问片段着色器内部的光栅数据。如果我们想从同一渲染通道的先前子通道中访问存储在颜色附件中的数据，我们可以使用一个输入附件。我们可以使用一个存储图像，分离采样器和采样图像，或者使用一个组合图像采样器。后一种在本食谱中使用。为了简化这个食谱和代码，我们从文件中读取纹理数据。但通常我们会有一个图像，场景将被渲染到这个图像中：
- en: '[PRE49]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding code, we create a combined image sampler and specify that we
    will access it with unnormalized texture coordinates. Usually we provide coordinates
    in the <0.0, 1.0> range (inclusive). This way we don't need to worry about the
    image's size. On the other hand, for post-processing we usually want to address
    the texture image using screen space coordinates, and that's when unnormalized
    texture coordinates are used--they correspond to the image's dimensions.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个组合图像采样器，并指定我们将使用非归一化纹理坐标来访问它。通常我们提供坐标在<0.0, 1.0>范围内（包含）。这样我们就不必担心图像的大小。另一方面，对于后期处理，我们通常希望使用屏幕空间坐标来引用纹理图像，这就是使用非归一化纹理坐标的时候——它们对应于图像的尺寸。
- en: 'To access an image, we also need a descriptor set. We don''t need a uniform
    buffer as we don''t transform the geometry-drawn vertices are already in the correct
    space (the clip space). Before we can allocate a descriptor set, we create a layout
    with one combined image sampler accessed in a fragment shader stage. After that,
    a pool is created and one descriptor set is allocated from the pool:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一个图像，我们还需要一个描述符集。我们不需要统一缓冲区，因为我们没有变换几何图形，绘制出的顶点已经处于正确的空间（裁剪空间）。在我们能够分配描述符集之前，我们创建一个布局，其中包含一个在片段着色器阶段访问的组合图像采样器。之后，创建一个池，并从池中分配一个描述符集：
- en: '[PRE50]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code we also update the descriptor set with the handles of
    created sampler and image view. Unfortunately, the image into which we render
    a scene will usually fit into a screen. This means that we must recreate it when
    the size of an application's window is changed and, to do that, we must destroy
    the old image and create a new one with new dimensions. After such an operation
    we must update the descriptor set again with the handle of the new image (the
    sampler doesn't need to be recreated). So we must remember to update the descriptor
    set each time the application window size is changed.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们还使用创建的采样器和图像视图的句柄更新了描述符集。不幸的是，我们将场景渲染到其中的图像通常适合屏幕。这意味着当应用程序窗口的大小改变时，我们必须重新创建它。为此，我们必须销毁旧图像并创建一个具有新尺寸的新图像。在这样操作之后，我们必须再次使用新图像的句柄（采样器不需要重新创建）来更新描述符集。因此，我们必须记住每次应用程序窗口大小改变时都要更新描述符集。
- en: 'One last thing is the creation of a graphics pipeline. It uses only two shader
    stages: vertex and fragment. The number of attributes fetched by the vertex shader
    depend on whether we need texture coordinates (and other dedicated attributes)
    or not. The full-screen quad''s geometry should be drawn using a `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP`
    topology. We also don''t need any blending.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情是创建一个图形管线。它只使用两个着色器阶段：顶点和片段。顶点着色器获取的属性数量取决于我们是否需要纹理坐标（以及其他专用属性）。全屏四边形的几何形状应该使用`VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP`拓扑来绘制。我们也不需要任何混合。
- en: 'The most important part of the post-processing is performed inside the fragment
    shader. The work to be done depends on the technique we want to implement. In
    this recipe, we present an edge detection algorithm:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 后期处理最重要的部分是在片段着色器中执行的。要完成的工作取决于我们想要实现的技术。在这个菜谱中，我们展示了一个边缘检测算法：
- en: '[PRE51]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding fragment shader code, we sample four values around the fragment
    being processed. We take a negated value from one sample to the left and add a
    value read from one sample to the right. This way we know the difference between
    samples in a horizontal direction. When the difference is big, we know there is
    an edge.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段着色器代码中，我们采样处理中的片段周围的四个值。我们从左侧的一个样本中取一个负值，并添加从右侧的一个样本中读取的值。这样我们就知道水平方向上样本之间的差异。当差异很大时，我们知道存在一个边缘。
- en: We do the same operation for a vertical direction to detect horizontal lines
    too (the vertical difference, or a gradient, is used to detect horizontal edges;
    the horizontal gradient allows us to detect vertical edges). After that we store
    a value in the output variable. We additionally take the `abs()` value, but this
    is done only for visualization purposes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对垂直方向进行相同的操作，以便检测水平线（使用垂直差分或梯度来检测水平边缘；水平梯度使我们能够检测垂直边缘）。之后，我们在输出变量中存储一个值。我们还会取`abs()`值，但这只是为了可视化目的。
- en: In the preceding fragment shader, we access multiple texture coordinates. This
    can be done on combined image samplers (input attachments allow us to access only
    a single coordinate associated with a fragment being processed). However, to bind
    an image to a descriptor set as a resource other than an input attachment, we
    must end the current render pass and start another one. In a given render pass,
    images cannot be used for attachments and for any other non-attachment purpose
    at the same time.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段着色器中，我们访问多个纹理坐标。这可以在组合图像采样器（输入附件使我们能够访问与正在处理的片段相关联的单个坐标）。然而，要将图像绑定到描述符集作为资源而不是输入附件，我们必须结束当前的渲染过程并开始另一个。在给定的渲染过程中，图像不能同时用于附件和任何其他非附件目的。
- en: 'Using the preceding setup, we should see the following result (on the right)
    with the original image seen on the left:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的设置，我们应该看到以下结果（在右侧），左侧是原始图像：
- en: '![](img/image_12_014.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_014.png)'
- en: See also
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory*, see the following recipes:'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml)，*资源和内存*，查看以下食谱：
- en: '*Creating a buffer*'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建缓冲区*'
- en: '*Allocating and binding a memory object to a buffer*'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配和绑定内存对象到缓冲区*'
- en: '*Using the staging buffer to update a buffer with a device-local memory bound*'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用阶段缓冲区更新绑定到设备本地内存的缓冲区*'
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipes:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)，*描述符集*，查看以下食谱：
- en: '*Creating a combined image sampler*'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建组合图像采样器*'
- en: '*Creating a descriptor set layout*'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建描述符集布局*'
- en: '*Allocating descriptor sets*'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配描述符集*'
- en: '*Binding descriptor sets*'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定描述符集*'
- en: '*Updating descriptor sets*'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新描述符集*'
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)，*渲染过程和帧缓冲区*，查看以下食谱：
- en: '*Beginning a render pass*'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始渲染过程*'
- en: '*Ending a render pass*'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结束渲染过程*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)，*图形和计算管线*，查看以下食谱：
- en: '*Creating a shader module*'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Specifying the pipeline vertex input state*'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线顶点输入状态*'
- en: '*Specifying the pipeline input assembly state*'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线输入装配状态*'
- en: '*Specifying the pipeline rasterization state*'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定管线光栅化状态*'
- en: '*Creating a graphics pipeline*'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建图形管线*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipes:'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)，*命令录制和绘制*，查看以下食谱：
- en: '*Binding vertex buffers*'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定顶点缓冲区*'
- en: '*Drawing a geometry*'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制几何体*'
- en: Using input attachments for a color correction post-process effect
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用输入附件进行颜色校正后处理效果
- en: There are many various post-process techniques used in 3D applications. Color
    correction is one of them. This is relatively simple, but it can give impressive
    results and greatly improve the look and feel of a rendered scene. Color correction
    can change the mood of the scene and induce the desired feelings for the users.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D应用程序中使用了许多不同的后处理技术。颜色校正就是其中之一。这相对简单，但可以产生令人印象深刻的成果，并大大提升渲染场景的外观和感觉。颜色校正可以改变场景的氛围，并诱导用户产生预期的感受。
- en: Usually, a color correction effect requires us to read data of a single, currently
    processed sample. Thanks to this property, we can implement this effect using
    input attachments. This allows us to perform post-processing inside the same render
    pass in which the whole scene is rendered, thus improving the performance of our
    application.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，颜色校正效果需要我们读取单个当前处理样本的数据。得益于这一特性，我们可以使用输入附件来实现此效果。这允许我们在渲染整个场景的同一渲染过程中执行后处理，从而提高我们应用程序的性能。
- en: 'The following is an example of an image generated with this recipe:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用此食谱生成的图像示例：
- en: '![](img/image_12_015.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_015.png)'
- en: How to do it...
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Create a fullscreen quad with additional resources required during postprocessing
    phase (refer to the *Rendering a full-screen quad for post processing* recipe).
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个全屏四边形，并在后处理阶段需要额外的资源（参考*渲染全屏四边形进行后处理*食谱）。
- en: Create a descriptor set layout with one input attachment accessed in a fragment
    shader stage. Allocate a descriptor set using the prepared layout (refer to the
    *Creating a descriptor set layout* and *Allocating descriptor sets* recipes from
    [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*).
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个描述符集布局，其中包含一个在片段着色器阶段访问的输入附件。使用准备好的布局分配一个描述符集（参考第5章“描述符集”中的*创建描述符集布局*和*分配描述符集*配方）。
- en: Create a 2D image (along with a memory object and an image view) into which
    the scene will be drawn. Specify not only a `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`
    usage, but also a `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT` usage during image creation.
    Recreate the image each time the application's window is resized (refer to the
    *Creating an input attachment* recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml),
    *Descriptor Sets*).
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个2D图像（包括内存对象和图像视图），场景将绘制到其中。在创建图像时，不仅要指定`VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`使用，还要指定`VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`使用。每次应用程序窗口大小调整时都要重新创建图像（参考第5章“描述符集”中的*创建输入附件*配方）。
- en: Update the descriptor set with input attachment using the handle of the created
    image. Do it each time an application window is resized and an image is recreated
    (refer to the *Updating descriptor sets* recipe from Chapter 5, *Descriptor Sets*).
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用创建的图像句柄通过输入附件更新描述符集。每次应用程序窗口大小调整和图像重新创建时都要这样做（参考第5章“描述符集”中的*更新描述符集*配方）。
- en: Prepare all the resource required to normally render the scene. When creating
    a render pass used for rendering the scene, add one additional subpass at the
    end of the render pass. Specify the attachment used in previous subpasses as a
    color attachment to be an input attachment in the additional subpass. A swapchain
    image should be used as a color attachment in the additional subpass (refer to
    the *Specifying subpass descriptions* and *Creating a render pass* recipes from
    [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes and Framebuffers*).
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备所有正常渲染场景所需的资源。在创建用于渲染场景的渲染传递时，在渲染传递的末尾添加一个额外的子传递。指定先前子传递中使用的附件作为颜色附件，在额外子传递中作为输入附件。在额外子传递中应使用swapchain图像作为颜色附件（参考第6章“渲染传递和帧缓冲区”中的*指定子传递描述*和*创建渲染传递*配方）。
- en: 'Create a shader module with a vertex shader created from the following GLSL
    code (refer to the *Creating a shader module* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*):'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下GLSL代码创建一个顶点着色器模块（参考第8章“图形和计算管线”中的*创建着色器模块*配方）。
- en: '[PRE52]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create a shader module with a fragment shader created from the following GLSL
    code:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下GLSL代码创建一个片段着色器模块：
- en: '[PRE53]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Create a graphics pipeline used for drawing a post-process phase. Use the preceding vertex
    and fragment shader modules. Prepare the rest of the pipeline parameters according
    to the *Rendering a fullscreen quad for postprocessing* recipe.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于绘制后处理阶段的图形管线。使用前面的顶点和片段着色器模块。根据*渲染全屏四边形进行后处理*配方准备其余的管线参数。
- en: In each frame of animation, draw the scene normally into a created image, then
    progress to the next subpass (refer to the *Progressing to the next subpass* recipe
    from [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes and
    Framebuffers*). Bind the created graphics pipeline used for post-processing, bind
    the descriptor set with the input attachment, bind the vertex buffer with full-screen
    quad data, and draw the full-screen quad (refer to the *Binding descriptor sets*
    recipe from [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor
    Sets*, to the *Binding a pipeline object* recipe from [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml),
    *Graphics and Compute Pipelines*, and to the *Binding vertex buffers* and *Drawing
    a geometry* recipes from [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml),
    *Command Recording and Drawing*).
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动画的每一帧中，将场景正常渲染到创建的图像中，然后进入下一个子通道（参考第6章的*进入下一个子通道*配方，*渲染通道和帧缓冲区*）。绑定用于后处理的创建的图形管线，绑定带有输入附加的描述符集，绑定包含全屏四边形数据的顶点缓冲区，并绘制全屏四边形（参考第5章的*绑定描述符集*配方，*描述符集*，以及第8章的*绑定管线对象*配方，*图形和计算管线*，以及第9章的*绑定顶点缓冲区和绘制几何体*配方，*命令记录和绘制*）。
- en: How it works...
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Creating a postprocessing effect that is rendered inside the same render pass
    as the scene is performed in two steps.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个在场景渲染的同一渲染通道内渲染的后处理效果分为两个步骤。
- en: 'In the first step, we need to prepare resources for the base scene: its geometry,
    textures, descriptor sets, and pipeline objects, among others. In the second step,
    we do the same for the full-screen quad, as described in the *Rendering a fullscreen
    quad for postprocessing* recipe.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们需要为基本场景准备资源：其几何形状、纹理、描述符集和管线对象等。在第二步中，我们按照*渲染全屏四边形用于后处理*配方进行全屏四边形的相同操作。
- en: 'The two most important resources prepared solely for the post-processing phase
    are an image and a graphics pipeline. The image will serve as a color attachment
    when we are rendering the scene in a normal way. We just render the scene into
    the image instead of rendering it into a swapchain image. The image must serve
    both as a color attachment during scene rendering, but also as an input attachment
    during post-processing. We must also remember to recreate it when the size of
    the application''s window is changed:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了后处理阶段准备的两个最重要的资源是一个图像和一个图形管线。当以正常方式渲染场景时，图像将作为颜色附加使用。我们只需将场景渲染到图像中，而不是渲染到交换链图像中。图像必须在场景渲染期间作为颜色附加使用，同时在后处理期间作为输入附加使用。我们还必须记住在应用程序窗口大小改变时重新创建它：
- en: '[PRE54]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Accessing an image as an input attachment requires us to use a descriptor set.
    It must contain at least our input attachment, so we need to create a proper layout.
    Input attachments can be accessed only inside fragment shaders, so the creation
    of a descriptor set layout, a descriptor pool, and an allocation of a descriptor
    set may look like this:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像作为输入附加访问需要我们使用描述符集。它必须包含至少我们的输入附加，因此我们需要创建一个适当的布局。输入附加只能在片段着色器中访问，因此创建描述符集布局、描述符池和分配描述符集可能看起来像这样：
- en: '[PRE55]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We must also update the descriptor set with the handle of our color attachment/input
    attachment image. As the image gets recreated when the size of the application''s
    window is changed, we must update the descriptor too:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须使用我们的颜色附加/输入附加图像句柄更新描述符集。由于图像在应用程序窗口大小改变时会被重新创建，我们必须更新描述符：
- en: '[PRE56]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The next thing we need to describe is the preparation of a render pass. In this
    recipe the render pass is common for both the scene rendering and the post-processing
    phase. The scene is rendered in its own, dedicated subpass (or subpasses). The
    post-processing phase adds an additional subpass for rendering a full-screen quad.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要描述的是渲染通道的准备。在这个配方中，渲染通道对场景渲染和后处理阶段都是通用的。场景将在自己的、专用的子通道（或子通道）中渲染。后处理阶段为渲染全屏四边形添加了一个额外的子通道。
- en: 'Usually, we define two render pass attachments: a color attachment (a swapchain
    image) and a depth attachment (an image with a depth format). This time we need
    three attachments: the first one is a color attachment for which the created image
    will be used; the depth attachment is the same as usual; and the third attachment
    is also a color attachment, for which a swapchain image will be used. This way,
    the scene is rendered normally into two (color and depth attachments). Then, the
    first attachment is used as an input attachment during post-processing; and the
    full-screen quad is rendered into the second color attachment (a swapchain image)
    so the final image appears on screen.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们定义两个渲染通道附件：一个颜色附件（一个交换链图像）和一个深度附件（一个具有深度格式的图像）。这次我们需要三个附件：第一个是一个颜色附件，创建的图像将用于此；深度附件与通常相同；第三个附件也是一个颜色附件，将使用交换链图像。这样，场景就正常渲染到两个（颜色和深度附件）中。然后，第一个附件在后期处理期间用作输入附件；全屏四边形渲染到第二个颜色附件（交换链图像）中，这样最终的图像就会显示在屏幕上。
- en: 'The following code sets up the render pass attachment:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码设置了渲染通道附件：
- en: '[PRE57]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The render pass has two subpasses defined as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染通道定义了两个子通道，如下所示：
- en: '[PRE58]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We also can''t forget about the render pass subpass dependencies. They are
    very important here as they synchronize the two subpasses. We can''t read data
    from a texture until the data is written into it, so we need dependencies between
    the 0 and the 1 subpass (for the image serving as color and input attachment.
    Similarly, dependencies are needed for a swapchain image:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不能忘记渲染通道子通道依赖关系。在这里它们非常重要，因为它们同步了两个子通道。我们无法从纹理中读取数据，直到数据被写入，因此我们需要在0和1子通道（用于作为颜色和输入附件的图像）之间建立依赖关系。同样，对于交换链图像也需要依赖关系：
- en: '[PRE59]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The graphics pipeline used during post-processing phase is a standard one.
    Only two things are different: the graphics pipeline is used inside the subpass
    with index `1` (not `0` as in other recipes--the scene is rendered in the subpass
    `0`); and the fragment shader loads color data, not from the combined image sampler,
    but from the input attachment. The input attachment inside the fragment shader
    is defined as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 后期处理阶段使用的图形管线是标准的。只有两件事不同：图形管线在索引为`1`的子通道中使用（而不是其他食谱中的`0`——场景在子通道`0`中渲染）；片段着色器加载颜色数据，不是从组合图像采样器，而是从输入附件。片段着色器中的输入附件定义如下：
- en: '[PRE60]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We read data from it using the `subpassLoad()` function. It takes only the uniform
    variable. Texture coordinates are unnecessary, because through an input attachment
    we can read data only from the coordinate associated with the fragment being processed.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`subpassLoad()`函数从中读取数据。它只接受统一变量。纹理坐标是不必要的，因为通过输入附件，我们只能从正在处理的片段关联的坐标读取数据。
- en: '[PRE61]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The fragment shader then takes the loaded color, calculates a sepia color from
    it, and stores it in an output variable (a color attachment). All this combined
    should lead us to create the following results. On the left we see the scene rendered
    normally. On the right we see a post-processing effect applied:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器随后从加载的颜色中计算出一个棕褐色，并将其存储在一个输出变量（颜色附件）中。所有这些组合应该引导我们创建以下结果。在左边我们看到场景正常渲染。在右边我们看到应用了后期处理效果：
- en: '![](img/image_12_016.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_016.png)'
- en: See also
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 5](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml), *Descriptor Sets*,
    see the following recipes:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml)“描述符集”中，查看以下食谱：
- en: '*Creating an input attachment*'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建输入附件*'
- en: '*Creating a descriptor set layout*'
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建描述符集布局*'
- en: '*Allocating descriptor sets*'
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分配描述符集*'
- en: '*Updating descriptor sets*'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新描述符集*'
- en: '*Binding descriptor sets*'
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定描述符集*'
- en: 'In [Chapter 6](2de4339d-8912-440a-89a6-fd1f84961448.xhtml), *Render Passes
    and Framebuffers*, see the following recipes:'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](2de4339d-8912-440a-89a6-fd1f84961448.xhtml)“渲染通道和帧缓冲区”中，查看以下食谱：
- en: '*Specifying subpass descriptions*'
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定子通道描述*'
- en: '*Creating a render pass*'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建渲染通道*'
- en: '*Progressing to the next subpass*'
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进入下一个子通道*'
- en: 'In [Chapter 8](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml), *Graphics and Compute
    Pipelines*, see the following recipes:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](5744ea05-b18a-4f84-a1df-250b549dfea5.xhtml)“图形和计算管线”中，查看以下食谱：
- en: '*Creating a shader module*'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建着色器模块*'
- en: '*Binding a pipeline object*'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绑定管线对象*'
- en: 'In [Chapter 9](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml), *Command Recording
    and Drawing*, see the following recipes:'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](0a69f5b5-142e-422b-aa66-5cb09a6467b3.xhtml)“命令录制和绘制”中，查看以下食谱：
- en: Binding vertex buffers
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定顶点缓冲区
- en: Drawing a geometry
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制几何体
- en: The recipe *Rendering a full-screen quad for post-processing*, in this chapter
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的食谱 *渲染全屏四边形进行后处理*
