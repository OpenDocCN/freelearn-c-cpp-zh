<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Sensing the World – Feeling with Analog Inputs</h1></div></div></div><p>The real world isn't digital. My digital-art-based vision shows me <em>The Matrix</em> behind things and huge digital waterfalls between things. In this chapter, however, I need to convey to you the relationship between digital and analog, and we need to understand it well.</p><p>This chapter is a good one but a huge one. Don't be afraid. We'll also discuss new concepts a lot while writing and designing pure C++ code.</p><p>We are going to describe together what analog inputs are. I'm also going to introduce you to a new and powerful friend worthy of respect, Max 6 framework. Indeed, it will help us a bit like Processing did—to communicate with the Arduino board. You'll realize how important this is for computers, especially when they have to sense the world. A computer with the Max 6 framework is very powerful, but a computer with the Max 6 framework and the Arduino plugin can feel much characteristics of the physical world, such as pressure, temperature, light, color, and many more. Arduino, as we have already seen, behaves a bit like a very powerful organ able to…<em>feel</em>.</p><p>If you like this concept of feeling things, and especially that of making other things react to these feelings, you'll love this chapter.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Sensing analog inputs and continuous values </h1></div></div></div><p>There's no <a id="id607" class="indexterm"/>better <a id="id608" class="indexterm"/>way to define analog than by comparing it to digital. We just talked about digital inputs in the previous chapter, and you now know well about the only two values those kind of inputs can read. It is a bit exhausting to write it, and I apologize because this is indeed more a processor constraint than a pure input limitation. By the way, the result is that a digital input can only provide 0 or 1 to our executed binary firmware.</p><p>Analog works totally differently. Indeed, analog inputs can continuously provide variable values by measuring voltage from 0 V to 5 V. It means a value of 1.4 V and another value of 4.9 V would be interpreted as totally different values. This is very different from a digital input that could interpret them as…1. Indeed, as we already saw, a voltage value greater than 0 is usually understood as 1 by digital inputs. 0 is understood as 0, but 1.4 would be understood as 1; this we can understand as HIGH, the ON value, as opposed to the OFF, which comes from the 0 V measure.</p><p>Here, in <a id="id609" class="indexterm"/>the continuous world of analog inputs, we can sense a flow between<a id="id610" class="indexterm"/> the different values, where digital inputs can provide only steps. This is one of the reasons why I'm always using the term "feeling". Yes, when you can measure a lot of values, this is near to sensing and feeling. This is a bit of humanization of the electronic hardware, and I totally assume that.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec89"/>How many values can we distinguish?</h2></div></div></div><p>The term "a lot" isn't<a id="id611" class="indexterm"/> precise. Even if we are in a new continuous field of measure, we are still in the digital world, the one of the computers. So how many values can be distinguished by Arduino's analog inputs? 1024.</p><p>Why 1024? The reason is easy to understand if you understand how Arduino can feel continuous values.</p><p>Because Arduino's chip works in the digital domain for all calculations, we have to convert analog values from 0 V to 5 V to a digital one. The purpose of the <strong>analog-to-digital converter</strong>
<a id="id612" class="indexterm"/>, housed within the chipset itself, is exactly this. This device is also referred to using the acronym <a id="id613" class="indexterm"/>ADC.</p><p>Arduino's ADCs have a 10-bit resolution. This means that every analog value is encoded and mapped to a 10-bit, encoded integer value. The maximum number encodable using this encoding system is 1111111111 in the binary system, which means 1023 in the decimal system. If I consider the first number to be 0, we have a total of 1024 values represented. A 1024-value resolution provides a very comfortable field of sensing as we are going to see in the next few pages.</p><p>Let's see how we can use these precious inputs with Arduino.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec90"/>Reading analog inputs</h2></div></div></div><p>Because we are <a id="id614" class="indexterm"/>now more familiar with circuits and code, we can work with a small project while still explaining concepts. I'm going to describe a simple example of circuits and code using a <strong>potentiometer</strong>
<a id="id615" class="indexterm"/> only.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec66"/>The real purpose of the potentiometer</h3></div></div></div><p>First, let's grab a potentiometer. A <a id="id616" class="indexterm"/>potentiometer is, if you remember correctly from the first chapter of this book, a variable resistor.</p><p>Considering <a id="id617" class="indexterm"/>Ohm's law, <a id="id618" class="indexterm"/>which links voltage, current, and resistance value, we can understand that, for a constant current, we can make the voltage vary by changing the value of the resistance of the potentiometer. Indeed, because some of us haven't dusted off our elementary electronics course textbook in many years, how about a refresher? Here's Ohm's law: </p><p>V = R * I</p><p>Here, V is the voltage in Volts, R the resistance in Ohms, and I the current in Amperes.</p><p>So now, to define the purpose of a potentiometer:</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>The potentiometer is your way to change continuously a variable in your running code from the physical world.</p></div></div><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>
<strong>Always remember:</strong>
</p><p>Use 10-bit resolution, and you'll be the master of analog inputs!</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec67"/>Changing the blinking delay of an LED with a potentiometer</h3></div></div></div><p>The following figure is the <a id="id619" class="indexterm"/>most basic circuit to<a id="id620" class="indexterm"/> illustrate the concept of analog inputs with the Arduino board:</p><div><img src="img/7584_06_01.jpg" alt="Changing the blinking delay of an LED with a potentiometer"/><div><p>A potentiometer connected to the Arduino board</p></div></div><p>Check<a id="id621" class="indexterm"/> the <a id="id622" class="indexterm"/>corresponding electrical diagram for connections:</p><div><img src="img/7584_06_02.jpg" alt="Changing the blinking delay of an LED with a potentiometer"/><div><p>Analog input 0 is measuring the voltage</p></div></div><p>Now let's see the<a id="id623" class="indexterm"/> code we have to <a id="id624" class="indexterm"/>use.</p><p>Like the function<a id="id625" class="indexterm"/> <code class="literal">digitalRead()</code>, which can read the value of digital inputs on the Arduino, there is <code class="literal">analogRead()</code> <a id="id626" class="indexterm"/>for doing the same with analog inputs.</p><p>The intention here is to read the value as a pause value in our program for the purpose of controlling the blink rate of an LED. In code, we'll be using the<a id="id627" class="indexterm"/> <code class="literal">delay()</code> function.</p><p>Here's an example:</p><div><pre class="programlisting">int potPin = 0;     // pin number where the potentiometer is connected
int ledPin = 13 ;   // pin number of the on-board LED
int potValue = 0 ;  // variable storing the voltage value measured at potPin pin

void setup() {
  pinMode(ledPin, OUTPUT);  // define ledPin pin as an output
}

void loop(){
  potValue = analogRead(potPin); // read and store the read value at potPin pin 
  
  digitalWrite(ledPin, HIGH);    // turn on the LED
  delay(potValue);               // pause the program during potValue millisecond
  digitalWrite(ledPin, LOW);     // turn off the LED
  delay(potValue);               // pause the program during potValue millisecond
}</pre></div><p>Upload<a id="id628" class="indexterm"/> the code. Then turn the<a id="id629" class="indexterm"/> pot a bit, and observe the output.</p><p>After the variable definition, I'm defining the <code class="literal">ledPin</code> pin as output in the <code class="literal">setup()</code> function<a id="id630" class="indexterm"/> in order to be able to drive current to this pin. Actually, I'm using pin 13 in order to simplify our tests. Don't forget pin 13 is the surface-mounted LED on the Arduino board.</p><p>Then, the magic happens in the<a id="id631" class="indexterm"/> <code class="literal">loop()</code> function.</p><p>I'm first reading the value at the <code class="literal">potPin</code> pin. As we discussed before, the value returned by this function is an integer between 0 and 1023. I'm storing it in the <code class="literal">potValue</code> variable<a id="id632" class="indexterm"/> to keep the LED ON, but also to keep it OFF.</p><p>Then, I'm turning OFF and ON the LED with some delay between status changes. The smart thing here is to use <code class="literal">potValue</code> as the delay. Turned on one side completely, the potentiometer provides a value of 0. Turned on the other side completely, it provides 1023, which is a reasonable and user-friendly delay value in milliseconds.</p><p>The higher the value is, the longer the delay.</p><p>In order to be sure you understood the physical part of this, I'd like to explain a bit more about voltage.</p><p>The +5 V and ground pins of the Arduino supply the potentiometer the voltage. Its third leg provides a way to vary the voltage by varying the resistance. The Arduino's analog inputs are able to read this voltage. Please notice that analog pins on the Arduino are inputs only. This is also why, with analog pins, we don't have to worry about precision in the code like we have for digital pins.</p><p>So let's modify the code a bit in order to read a voltage value.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec68"/>How to turn the Arduino into a low voltage voltmeter?</h3></div></div></div><p>Measuring voltage<a id="id633" class="indexterm"/> requires two different points on a<a id="id634" class="indexterm"/> circuit. Indeed, a voltage is an electrical potential. Here, we have (only) that analog pin involved in our circuit to measure voltage. What's that ?!</p><p>Simple! We're using the +5 V supply from Vcc as a reference. We control the resistance provided by the potentiometer and supply the voltage from the Vcc pin to have something to demonstrate.</p><p>If we want to use it as a real potentiometer, we have to supply another part of a circuit with Vcc too, and then connect our A0 pin to another point of the circuit.</p><p>As we saw, the <code class="literal">analogRead()</code> function<a id="id635" class="indexterm"/> only provides integers from 0 to 1023. How can we have real electrical measures displayed somewhere?</p><p>Here's how it works:</p><p>The range 0 to 1023 is mapped to 0 to 5V. That comes built into the Arduino. We can then calculate the voltage as follows:</p><p>V = 5 * (analogRead() value / 1023)</p><p>Let's implement it and display it on our computer by using the serial monitor of the Arduino IDE:</p><div><pre class="programlisting">int potPin = 0;     // pin number where the potentiometer is connected
int ledPin = 13 ;   // pin number of the on-board LED
int potValue = 0 ;  // variable storing the voltage value measured at potPin pin
float voltageValue = 0.; // variable storing the voltage calculated

void setup() {
  Serial.begin(9600);
  pinMode(ledPin, OUTPUT);  // define ledPin pin as an output
}

void loop(){
  potValue = analogRead(potPin); // read and store the read value at potPin pin

  digitalWrite(ledPin, HIGH);    // turn on the LED
  delay(potValue);               // pause the program during potValue millisecond
  digitalWrite(ledPin, LOW);     // turn off the LED
  delay(potValue);               // pause the program during potValue millisecond

  voltageValue = 5. * (potValue / 1023.) ;  // calculate the voltage

  Serial.println(voltageValue); // write the voltage value an a carriage return
}</pre></div><p>The code<a id="id636" class="indexterm"/> is almost the same as the previous code.</p><p>I added a <a id="id637" class="indexterm"/>variable to store the calculated voltage. I also added the serial communication stuff, which you see all the time: <code class="literal">Serial.begin(9600)</code> to instantiate the serial communication and <code class="literal">Serial.println()</code> to write the current calculated voltage value to the serial communication port, followed by a carriage return.</p><p>In order to see a result on your computer, you have to turn on the serial monitor, of course. Then, you can read the voltage values.</p><div><div><div><div><h4 class="title"><a id="ch06lvl4sec32"/>Calculating the precision</h4></div></div></div><p>Please note that we <a id="id638" class="indexterm"/>are using an ADC here in order to convert an analog value to digital; then, we are making a small calculation on that digital value in order to have a voltage value. This is a very expensive method compared to a basic analog voltage controller.</p><p>It means our precision depends on the ADC itself, which has a resolution of 10 bits. It means we can only have 1024 values between 0 V and 5 V. 5 divided by 1024 equals 0.00488, which is approximated.</p><p>It basically means we won't be able to distinguish between values such as 2.01 V and 2.01487 V, for instance. However, it should be precise enough for the purposes of our learning.</p><p>Again, it was an example because I wanted to point out to you the precision/resolution concept. You have to know and consider it. It will prove very important and could deliver strange results in some cases. At least, you have been warned.</p><p>Let's discover another neat way of interacting with the Arduino board.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Introducing Max 6, the graphical programming framework </h1></div></div></div><p>Now, let me introduce you to the framework known as Max 6. This is a whole universe in itself, but I wanted to write some pages about it in this book because you'll probably come across it in your future projects; maybe you'll be a Max 6<a id="id639" class="indexterm"/> developer one day, like me, or perhaps you'll have to interface your smart physical objects with Max 6-based systems.</p><p>The following is one of the patches of my 3D universe project<a id="id640" class="indexterm"/> with Max 6:</p><div><img src="img/7584_06_03.jpg" alt="Introducing Max 6, the graphical programming framework"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec91"/>A brief history of Max/MSP</h2></div></div></div><p>Max<a id="id641" class="indexterm"/> is a visual programming language for multimedia purposes. It is actually developed and maintained by <a id="id642" class="indexterm"/>Cycling '74. Why call it Max? It was named after Max Matthews (<a class="ulink" href="http://en.wikipedia.org/wiki/Max_Mathews">http://en.wikipedia.org/wiki/Max_Mathews</a>), one of the great pioneers of computer music.</p><p>The original version of <a id="id643" class="indexterm"/>Max was written by Miller Puckette; it was initially an editor named Patcher for Macintosh. He wrote it at <strong>The European Institut de Recherche et Coordination Acoustique/Musique</strong> (<strong>IRCAM</strong>), <a id="id644" class="indexterm"/>an avant-garde science institute based near the Centre Pompidou in Paris, France.</p><p>In 1989, the software was licensed by IRCAM to Opcode Systems<a id="id645" class="indexterm"/>, a private company, and ever since then, has been developed and extended by David Zicarelli. In the mid-'90s, Opcode Systems ceased all development for it.</p><p>Puckette released a totally free and open source version of Max named Pure Data (often seen as Pd). This version is actually used a lot and maintained by the community that uses it.</p><p>Around 1997, a whole module dedicated to sound processing and generation has been added, named <strong>MSP</strong>
<a id="id646" class="indexterm"/>, for <strong>Max Signal Processing</strong> and, apparently, for the initials of Miller S. Puckette.</p><p>Since 1999, the framework commonly known as Max/MSP has been developed and distributed by Cycling '74, Mr. Zicarelli's company.</p><p>Because the framework architecture was very flexible, some extensions have progressively been added, such as Jitter (a huge and efficient visual synthesis), Processing, real-time matrix calculations modules, and 3D engine too. This happened around 2003. At that time, Jitter was released and could be acquired separately but required Max, of course.</p><p>In 2008, a major update was released under the name Max 5<a id="id647" class="indexterm"/>. This version too did not include Jitter natively but as an add-on module.</p><p>And the most giant upgrade, in my humble opinion, released in November 2011 as Max 6, included Jitter <a id="id648" class="indexterm"/>natively and provided huge improvements such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A redesigned user interface</li><li class="listitem" style="list-style-type: disc">A new audio engine compatible with 64-bit OSs</li><li class="listitem" style="list-style-type: disc">High-quality sound filter design features</li><li class="listitem" style="list-style-type: disc">A new data structure</li><li class="listitem" style="list-style-type: disc">New movement handling for 3D models</li><li class="listitem" style="list-style-type: disc">New 3D material handling</li><li class="listitem" style="list-style-type: disc">The Gen extension</li></ul></div><p>Max 4<a id="id649" class="indexterm"/> was already totally usable and efficient, but I have to give my opinion about Max 6 here. Whatever you have to <a id="id650" class="indexterm"/>build, interfaces, complex, or easy communication protocols including <a id="id651" class="indexterm"/>HID-based (<strong>HID</strong>=<strong>human interface device</strong>) USB devices such as <a id="id652" class="indexterm"/>Kinect, <a id="id653" class="indexterm"/>MIDI, <a id="id654" class="indexterm"/>OSC, serial, HTTP<a id="id655" class="indexterm"/>, and anything else, 3D-based sound engine or basic standalone applications for Windows or OS X platform, you can make it with Max 6, and it is a safe way to build.</p><p>Here is my own short history with Max: I personally began to play with Max 4. I specially built some macro MIDI interfaces for my first hardware MIDI controllers in order to control my software tools in very specific ways. It has taught me much, and it opened my mind to new concepts. I use it all the time, for almost every part of my artistic creation.</p><p>Now, let's understand a little bit more about what Max is.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec92"/>Global concepts</h2></div></div></div><p>Of course, I hesitated to begin the part about Max 6 in the preceding section. But I guess the little story was a good starting point to describing the framework itself.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec69"/>What is a graphical programming framework?</h3></div></div></div><p>A <strong>graphical programming framework</strong>
<a id="id656" class="indexterm"/> is a programming language that provides a way for users to create programs by manipulating elements graphically instead of by typing text.</p><p>Usually, graphical programming languages are also called <strong>visual programming languages</strong>
<a id="id657" class="indexterm"/>, but I'll use "graphical" because, to many, "visual" is used for the product rendered by frameworks; I mean, the 3D scene for instance. Graphical is more related to <strong>GUI</strong>
<a id="id658" class="indexterm"/>, that is, <strong>graphical user interface</strong>, which is, from the developer point of view, our editor interface (I mean, the IDE part).</p><p>Frameworks using this strong graphical paradigm include many ways of programming in which we can find data, data types, operator and functions, input and output, and a way of connecting hardware too.</p><p>Instead of typing long source codes, you add objects and connect them together in order to build software architectures. Think Tinker Toys or Legos.</p><p>A global software architecture, which is a system of objects connected and related on our 2D screen, is called <strong>Patch</strong>
<a id="id659" class="indexterm"/> in the Max world. By the way, other graphical programming frameworks use this term too.</p><p>If this paradigm can be understood at first as a way of simplification, it is not the first purpose, I mean that not only is it easier, but it also provides a totally new approach for programmers and non-programmers alike. It also provides a new type of support task. Indeed, if we don't program in the same way we patch, we don't troubleshoot problems in the same way too.</p><p>I can quote some other major graphical programming software in our fields:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Quartz Composer</strong>: This<a id="id660" class="indexterm"/> is a graphical rendering framework for <a id="id661" class="indexterm"/>OS X and is<a id="id662" class="indexterm"/> available at <a class="ulink" href="https://developer.apple.com/technologies/mac/graphics-and-animation.html">https://developer.apple.com/technologies/mac/graphics-and-animation.html</a></li><li class="listitem" style="list-style-type: disc"><strong>Reaktor</strong>: This is a <a id="id663" class="indexterm"/>DSP and MIDI-processing framework by <a id="id664" class="indexterm"/>Native Instruments and is <a id="id665" class="indexterm"/>available at <a class="ulink" href="http://www.native-instruments.com/#/en/products/producer/reaktor-5">http://www.native-instruments.com/#/en/products/producer/reaktor-5</a></li><li class="listitem" style="list-style-type: disc"><strong>Usine</strong>: This is a <a id="id666" class="indexterm"/>universal audio software for live and studio recording and <a id="id667" class="indexterm"/>is <a id="id668" class="indexterm"/>available at <a class="ulink" href="http://www.sensomusic.com/usine">http://www.sensomusic.com/usine</a></li><li class="listitem" style="list-style-type: disc"><strong>vvvv</strong>: This is a <a id="id669" class="indexterm"/>real-time video<a id="id670" class="indexterm"/> synthesis tool for Windows and is <a id="id671" class="indexterm"/>available at <a class="ulink" href="http://vvvv.org">http://vvvv.org</a></li><li class="listitem" style="list-style-type: disc"><strong>SynthMa</strong><strong>ker</strong>: This<a id="id672" class="indexterm"/> is a <a id="id673" class="indexterm"/>VST <a id="id674" class="indexterm"/>device design for Windows and is available at <a class="ulink" href="http://synthmaker.co.uk">http://synthmaker.co.uk</a></li></ul></div><p>I'd like to make a special mention of Usine. It is a very interesting and powerful framework that provides graphical programming to design patches usable inside Usine software itself or even as standalone binaries. But one of the particularly powerful features is the fact you can export your patch as a fully-functional and optimized VST plugin. <a id="id675" class="indexterm"/>
<strong>VST</strong> (<strong>Virtual Studio Technology</strong>) is a powerful standard created by the Steinberg company. It provides a huge list of specifications and is implemented in almost all digital audio workstations. Usine provides a one-click-only export feature that packs your graphically programmed patch into a standard VST plugin for people who haven't even heard about Usine or patching styles. The unique multitouch feature of Usine makes it a very powerful framework too. Then, you can even code your own modules using their C++ <a id="id676" class="indexterm"/>
<strong>SDKs</strong> (<strong>software development kits</strong>).</p><div><img src="img/7584_06_04.jpg" alt="What is a graphical programming framework?"/><div><p>Usine big patch connecting the real world to many virtual objects</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec70"/>Max, for the playground</h3></div></div></div><p>Max<a id="id677" class="indexterm"/> is the playground and the core structure in which everything will be placed, debugged, and shown. This is the place where you put objects, connect them together, create a user interface (UI), and project some visual rendering too.</p><p>Here is a screenshot with a very basic patch designed to help you understand where things go:</p><div><img src="img/7584_06_05.jpg" alt="Max, for the playground"/><div><p>A small and easy calculation system patch with Max 6</p></div></div><p>As I described, with a <a id="id678" class="indexterm"/>graphical programming framework, we don't need to type code to make things happen. Here, I'm just triggering a calculation.</p><p>The box with the number <strong>17</strong> inside is a numbox. It holds an integer and it is also a UI object, providing a neat way to change the value by dragging and dropping with a mouse. You then connect the output of one object to the input of another. Now when you change the value, it is sent through the wire to the object connected to the numboxes. Magic!</p><p>You see two other objects. One with a:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>+</strong> sign inside followed by the number <strong>5</strong></li><li class="listitem" style="list-style-type: disc"><strong>-</strong> sign inside followed by the number <strong>3</strong></li></ul></div><p>Each one takes the number sent to them and makes the calculation of + 5 and - 3 respectively.</p><p>You can see two other numboxes displaying basically the resulting numbers sent by the objects with the <strong>+</strong> and <strong>–</strong> signs.</p><p>Are you still with me? I guess so. Max 6 provides a very well documented help system with all references to each object and is directly available in the playground. It is good to tell that to students when you teach them this framework, because it really helps the students teach themselves. Indeed, they can be almost autonomous in seeking answers to small questions and about stuff they have forgotten but don't dare to ask.</p><p>Max part <a id="id679" class="indexterm"/>provides quite an advanced task scheduler, and some objects can even modify priority to, say, <code class="literal">defer</code> and <code class="literal">deferlow</code> for a neat granularity of priorities inside your patch, for instance, for the UI aspect and the calculation core aspect that each require very different scheduling.</p><p>Max gives us a nifty debugging system too with a console-like window called the <a id="id680" class="indexterm"/>
<strong>Max window</strong>.</p><div><img src="img/7584_06_06.jpg" alt="Max, for the playground"/><div><p>The Max window showing debugging information about the expr object's error in the patch</p></div></div><p>Max drives many things. Indeed, it is Max that owns and leads the access to all modules, activated or not, provides autocompletion when you create new objects, and also gives access to many things that can extend the power of <a id="id681" class="indexterm"/>Max, such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JavaScript API to Max itself and specific parts, such as Jitter, too</li><li class="listitem" style="list-style-type: disc">Java through the mxj object that instantiates directly inside Max 6 Java classes</li><li class="listitem" style="list-style-type: disc">MSP core engine for everything related to signal rate stuff, including audio</li><li class="listitem" style="list-style-type: disc">Jitter core engine for everything related to matrix processing and much more, such as visuals and video</li><li class="listitem" style="list-style-type: disc">Gen engine for efficient and on-the-fly code compilation directly from the patch</li></ul></div><p>This is not an exhaustive list, but it gives you an insight of what Max provides.</p><p>Let's check the other modules.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec71"/>MSP, for sound</h3></div></div></div><p>Where Max objects<a id="id682" class="indexterm"/> communicate by sending messages triggered by user or by the scheduler itself, MSP is the core engine that calculates signals at any particular instant, as written in the documentation.</p><p>Even if we can patch (or connect) MSP objects in the same way as pure Max objects, the concept underneath is different. At each moment, a signal element is calculated, making an almost continuous data flow through what we call a signal network. The signal network is easy to identify in the patcher window; the wires are different.</p><p>Here is an image of a very simple patch producing a cosine-based audio wave in your ears:</p><div><img src="img/7584_06_07.jpg" alt="MSP, for sound"/></div><p>Indeed, even the patch cords have a different look, showing cool, striped yellow-and-black, bee-like colors, and the names of the MSP objects contain a tilde <code class="literal">~</code> as a suffix, symbolizing…a wave of course!</p><p>The signal <a id="id683" class="indexterm"/>rate is driven by the audio sampling rate and some dark parameters in the MSP core settings window. I won't describe that, but you have to know that Max usually provides, by default, parameters related to your soundcard, which include the sampling rate (44110 Hz, the standard sampling rate for audio CDs, means a fast processing rate of 44100 times per second for each audio channel).</p><div><img src="img/7584_06_08.jpg" alt="MSP, for sound"/><div><p>The Audio Status window is the place where you set up some important MSP parameters</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec72"/>Jitter, for visuals</h3></div></div></div><p>Jitter<a id="id684" class="indexterm"/> is the core engine for everything related to visual processing and synthesis in Max 6.</p><p>It provides a very efficient framework of matrix processing initially designed for fast pixel value calculations to display pictures, animated or not.</p><p>We are talking about <a id="id685" class="indexterm"/>matrix calculation for everything related with Jitter processing matrices. And indeed, if you need to trigger very fast calculations of huge arrays in Max 6, you can use Jitter for that, even if you don't need to display any visuals.</p><p>Jitter provides much more than only matrix calculation. It gives full access to an OpenGL<a id="id686" class="indexterm"/> (<a class="ulink" href="http://en.wikipedia.org/wiki/OpenGL">http://en.wikipedia.org/wiki/OpenGL</a>) implementation that works at the speed of the light. It also provides a way for designing and handling particle systems, 3D worlds, OpenGL materials, and physics-based animation. Pixel processing is also one of the powerful features provided with many objects designed and optimized for pixel processing<a id="id687" class="indexterm"/> itself.</p><div><img src="img/7584_06_09.jpg" alt="Jitter, for visuals"/><div><p>A basic Jitter-core-based patch generating a good resolution 400x400 noise pixel map</p></div></div><p>In order to <a id="id688" class="indexterm"/>summarize this massive load of information, Max schedules events or waits for the user to trigger something, MSP (for audio signal processing)—as soon as it is activated—calculates signal elements at each instant in its signal networks, and Jitter processes calculations when Jitter objects are triggered by <a id="id689" class="indexterm"/>
<strong>bangs</strong>.</p><p>Indeed, Jitter objects need to be triggered in order to do their jobs, which can be very different, such as popping out a matrix that contains pixel color values, matrix processing for each cell of a matrix, and popping out the resulting matrix, for instance.</p><p>Bangs are special messages used to kinda say "<em>Hey, let's start your job!</em>" to objects. Objects in Max can behave differently, but almost every one can understand the bang message.</p><p>In <strong>Patch003</strong> (pictured in the previous screenshot), the Max object <code class="literal">qmetro</code> provides a bang every 20 ms from a low priority scheduler queue to a Jitter object named <code class="literal">jit.noise</code>. This latter object calculates a matrix filled with a random value in each cell. Then, the result goes through a new green-and-black-striped patch cord to a UI object in which we can see a name, the <code class="literal">jit.pwindow</code>, a kind of display we can include in our patchers.</p><p>Jitter can be controlled via powerful Java and JavaScript APIs for some tasks that require typing big loops in code , which are easy to design using code.</p><p>Still here?</p><p>For the bravest <a id="id690" class="indexterm"/>among the brave, some other rows about Gen, the latest and most efficient module of Max 6.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec73"/>Gen, for a new approach to code generation</h3></div></div></div><p>If you understood that there was a kind of compilation/execution behind our patches, I'd disappoint you by saying it doesn't really work like that. Even if everything works real time, there isn't a real compilation.</p><p>By the way, there are many ways to design patch bits using code, with JavaScript for instance. Directly inside Max patcher, you can create a <code class="literal">.js</code> object and put your JavaScript code inside; it is indeed compiled on the fly (it is called <strong>JS JIT</strong> compiler<a id="id691" class="indexterm"/>, for JavaScript just-in-time compiler). It is really fast. Believe me, I tested it a lot and compared it to many other frameworks. So, as the documentation said, "we are not confined to writing Max externals in C" even if it is totally possible using the Max 6 SDK (<a class="ulink" href="http://cycling74.com/products/sdk">http://cycling74.com/products/sdk</a>).</p><p>Gen<a id="id692" class="indexterm"/> is a totally new concept.</p><p>Gen provides a way of patching patch bits that are compiled on the fly, and this is a real compilation from your patch. It provides a new type of patcher with specific objects, quite similar to Max objects.</p><p>It works for MSP, with the <code class="literal">gen~</code> Max object, providing a neat way to design signal-rate related to audio patches architecture. You can design DSP and sound generators like that. The <code class="literal">gen~</code> patches are like a zoom in time; you have to consider them as sample processors. Each sample is processed by those patches inside the <code class="literal">gen~</code> patchers. There are smart objects to accumulate things over time, of course, in order to have signal processing windows of time.</p><p>It works also for Jitter with three main Max objects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">jit.gen</code> is the fast <a id="id693" class="indexterm"/>matrix processor, processing each cell of a matrix at each turn</li><li class="listitem" style="list-style-type: disc"><code class="literal">jit.pix</code> is the <a id="id694" class="indexterm"/>CPU-based pixel processor, processing each pixel of a pixel map</li><li class="listitem" style="list-style-type: disc"><code class="literal">jit.gl.pix</code> is the GPU-based <a id="id695" class="indexterm"/>version of <code class="literal">jit.pix</code></li></ul></div><p>A GPU<a id="id696" class="indexterm"/> (graphics processor unit), and is basically a dedicated graphics processor on your video card. Usually, and this is a whole different universe, OpenGL pipeline provides an easy way to modify pixels from the software definitions to the screen just before they are displayed on the screen. It is called <a id="id697" class="indexterm"/>
<strong>shader process</strong>.</p><p>You may already <a id="id698" class="indexterm"/>know that term in relation with the world of gaming. These are those shaders that are some of the last steps to improving graphics and visual renders in our games too.</p><p>Shaders<a id="id699" class="indexterm"/> are basically small programs that can be modified on the fly by passing arguments processed by the GPU itself. These small programs use specific languages and run vary fast on dedicated processors on our graphic cards.</p><p>Max 6 + Gen provides direct access to this part of the pipeline by patching only; if we don't want to write shaders based on <strong>OpenGL GLSL</strong>
<a id="id700" class="indexterm"/> (<a class="ulink" href="http://www.opengl.org/documentation/glsl">http://www.opengl.org/documentation/glsl</a>), <strong>Microsoft DirectX HLSL</strong>
<a id="id701" class="indexterm"/> (<a class="ulink" href="http://msdn.microsoft.com/en-us/library/bb509635(v=VS.).aspx">85).aspx"&gt;http://msdn.microsoft.com/en-us/library/bb509635(v=VS.).aspx"&gt;85).aspx</a>), or <strong>Nvidia Cg</strong>
<a id="id702" class="indexterm"/> (<a class="ulink" href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter01.html">http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter01.html</a>), Gen is your friend.</p><p>All patches based on <code class="literal">jit.gl.pix</code> are specifically compiled and sent for GPU-based execution.</p><p>You can then design your own fragment shaders (or pixel shaders) by patching and you can even grab the source code in GLSL or WebGL language in order to use it in another framework, for instance.</p><p>Geometry shaders aren't available using Gen, but with other Jitter objects they already exists.</p><p>I guess I lost some of you. Relax I won't ask you questions about Gen in Arduino exams!</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec74"/>Summarizing everything in one table</h3></div></div></div><p>Everything related to Max 6 is on the Cycling 74's website at <a class="ulink" href="http://cycling74.com">http://cycling74.com</a>. Also, almost 99 percent of the documentation is online too, at <a class="ulink" href="http://cycling74.com/docs/max6/dynamic/c74_docs.html#docintro">http://cycling74.com/docs/max6/dynamic/c74_docs.html#docintro</a>.</p><p>The following table summarizes everything we did until now:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Parts</p>
</th><th style="text-align: left" valign="bottom">
<p>What?</p>
</th><th style="text-align: left" valign="bottom">
<p>Cable color</p>
</th><th style="text-align: left" valign="bottom">
<p>Distinctive sign</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Max<a id="id703" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The playground</p>
</td><td style="text-align: left" valign="top">
<p>Gray by default and no stripes</p>
</td><td style="text-align: left" valign="top">
<p>Basic names</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>MSP<a id="id704" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Everything related to audio and signal rate</p>
</td><td style="text-align: left" valign="top">
<p>Yellow-and-black stripes</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">~</code> suffixed to the name</p>
<p>signal-rate processing</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Jitter<a id="id705" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Everything related to visuals and matrices</p>
</td><td style="text-align: left" valign="top">
<p>Green-and-black stripes for matrix cables</p>
<p>Blue-and-black stripes for pixel map cables</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">jit.</code> prefixed to the name</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Gen<a id="id706" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Specific patchers (DSP-related and matrix and texture processing) compiled on the fly</p>
</td><td style="text-align: left" valign="top">
<p>Like MSP for <code class="literal">gen~</code> and Jitter for <code class="literal">jit.gen</code>, <code class="literal">jit.pix</code>, and <code class="literal">jit.gl.pix</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Very very fast!</p>
</td></tr></tbody></table></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec93"/>Installing Max 6</h2></div></div></div><p>Max 6 <a id="id707" class="indexterm"/>is available as a 30-day trial. Installing Max 6 is quite easy as it comes with an installer for <a id="id708" class="indexterm"/>both <a id="id709" class="indexterm"/>platforms, Windows and OS X, downloadable at <a class="ulink" href="http://cycling74.com/downloads">http://cycling74.com/downloads</a>. Download and install it. Then, launch it. That's all. (The following examples will only work when you have installed Max.)</p><p>You should see a blank playground</p><div><img src="img/7584_06_10.jpg" alt="Installing Max 6"/><div><p>Max 6 blank-page anxiety can occur right now, can't it?</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec94"/>The very first patch</h2></div></div></div><p>Here is a basic patch<a id="id710" class="indexterm"/> you can find also in the <code class="literal">Chapter06/</code> folder under the name <code class="literal">Patcher004_Arduino.maxpat</code>. Usually, if you double-click on it, it is opened directly by Max 6.</p><p>This patch is a very basic one, but not that basic actually!</p><p>It is a basic noise-based sequencer modifying an oscillator's frequency regularly in real time. This produces a sequence of strange sounds, more or less pretty, the modifications of the frequency being controlled by chance. So, turn on your speakers and the patch will produce sounds.</p><div><img src="img/7584_06_11.jpg" alt="The very first patch"/><div><p>The noise-based sequencer</p></div></div><p>Basically, <a id="id711" class="indexterm"/>patches are stored in files. You can share patches with other friends quite easily. Of course, bigger projects would involve some dependency issues; if you added some libraries to your Max 6 framework, if you use them in a patch, or if you basically send your patch files to a friend who doesn't have those libraries installed, your friend will have some errors in the Max Window. I won't describe these kinds of issues here, but I wanted to warn you.</p><p>Other neat ways to share patches in the Max 6 world are the copy/paste and copy compressed features. Indeed, if you select objects in your patcher (whatever the layer, including a subpatcher, inside a subpatcher, and so on) and go to <strong>Edit</strong> | <strong>Copy</strong>, text-based content is put in your clipboard. This can then be repasted into another patcher or inside a text file. </p><p>The smartest way is the use of copy compress, which as the well-chosen name means, copies and compresses the JSON code to something much more compact and easy to copy into the text area on forums, for instance.</p><p>Wait, let me show you what it looks like.</p><p>I just selected all objects in <a id="id712" class="indexterm"/>my patch and went to <strong>Edit</strong> | <strong>Copy Compressed</strong>.</p><div><img src="img/7584_06_12.jpg" alt="The very first patch"/><div><p>The copy compressed feature</p></div></div><p>And the following figure is the result of pasting directly into a text file.</p><p>Those familiar with <a id="id713" class="indexterm"/>HTML would notice something funny; Cycling '74 developers include two HTML tags (<code class="literal">pre</code> and <code class="literal">code</code>) in order to directly provide code that is pastable inside a text field on (any) forums on the Web.</p><div><img src="img/7584_06_41.jpg" alt="The very first patch"/><div><p>Copy-compressed code</p></div></div><p>So you can also copy that code into your clipboard and paste it into a new patch. You create a new empty patch by by going to <strong>File</strong> | <strong>New</strong> (or hitting <em>Ctrl</em> + <em>N</em> on Windows and <em>command</em> + <em>N</em> on OS X).</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec75"/>Playing sounds with the patch</h3></div></div></div><p>As you can see, I put<a id="id714" class="indexterm"/> some comments in the patcher. You can follow<a id="id715" class="indexterm"/> them in order to produce some electronic sounds from your computer.</p><p>Before you begin, be sure to lock the patch by clicking on the padlock icon in the lower-left corner. To hear the results of the patch, you'll also need to click on the speaker icon. To zoom out, go to the <strong>View</strong> menu and click on <strong>Zoom Out</strong>.</p><p>First, note and check the toggle at the top. It will send the value <code class="literal">1</code> to the connected object metro.</p><p>A metro is a pure Max object that sends a bang every <em>n</em> milliseconds. Here, I hardcoded an argument: <code class="literal">100</code>. As soon as the metro receives the message <code class="literal">1</code> from the toggle, it begins to be active and, following the Max timing scheduler, it will send its bangs every 100 ms to the next connected object.</p><p>When the <code class="literal">random</code> object receives a bang, it pops out a random integer from within a range. Here, I put <code class="literal">128</code>, which means <code class="literal">random</code> will send values from <code class="literal">0</code> to <code class="literal">127</code>. Directly after <code class="literal">random</code>, I put a <code class="literal">zmap</code> object that works like a scaler. I harcoded four arguments, minimum and maximum values for inputs and minimum and maximum values for output.</p><p>Basically, here, <code class="literal">zmap</code> maps my values <code class="literal">0</code> to <code class="literal">127</code> sent by <code class="literal">random</code> to another values from <code class="literal">20</code> to <code class="literal">100</code>. It produces an implicit stretch and loss of resolution that I like.</p><p>Then, this resulting<a id="id716" class="indexterm"/> number is sent to the famous and important <code class="literal">mtof</code> object. This <a id="id717" class="indexterm"/>converts a MIDI note pitch standard to a frequency according to the MIDI standard. It is often used to go from the MIDI world into the real sound world. You can also read the frequency in the UI object <code class="literal">flonum</code> displaying the frequency as a float number in Hz (hertz, a measure of frequency).</p><p>Then, at last, this frequency is sent to the <code class="literal">cycle~</code> object, producing a signal (check the yellow-and-black striped cord). Sending numbers to this object makes it to change the frequency of the signal produced. This one is multiplied by a signal multiply operator <code class="literal">*~</code>, producing another signal but with a lower amplitude to protect our precious ears.</p><p>The last destination of that signal is the big gray box on which you have to click once in order to hear or not hear the sounds produced by the upper signal network.</p><p>Now you're ready to check the toggle box. Activate the speaker icon by clicking on the gray box, and then you can dance. Actually, electronic sounds produced are a bit shuffly about the frequency (that is, the note) but it can be interesting.</p><p>Of course, controlling this cheap patch with the Arduino in order to not use the mouse/cursor would be very great.</p><p>Let's do that with the same circuit that we designed previously.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Controlling software using hardware</h1></div></div></div><p>Coming from <a id="id718" class="indexterm"/>pure digital realms where everything can be <a id="id719" class="indexterm"/>wrapped into software and virtual worlds, we often need physical interfaces. This can sound like a paradox; we want everything in one place, but that place is so small and user-unfriendly for everything related to pure creation and feelings that we need more or less big external (physical) interfaces. I love this paradox.</p><p>But, why do we need such interfaces? Sometimes, the old mouse and QWERTY keyboard don't cut it. Our computers are fast, but these interfaces to control our programs are slow and clunky.</p><p>We need interfaces between the real world and the virtual world. Whatever they are, we need them to focus on our final purpose, which is usually not the interface or even the software itself.</p><p>Personally, I write books and teach art-related technology courses, but as a live performer, I need to focus on the final rendering. While performing, I want to black-box as much as possible the technology under the hood. I want to feel more than I want to calculate. I want a controller interface to help me operate at the speed and level of flexibility to make the types of changes I want.</p><p>As I already said in this book, I needed a huge MIDI controller, heavy, solid, and complex, in order to control only one software on my computer. So, I built Protodeck (<a class="ulink" href="http://julienbayle.net/protodeck)">http://julienbayle.net/protodeck</a>). This was my interface.</p><p>So, how can we use Arduino to control software? I guess you have just a part of your answer because we already sent data to our computer by turning a potentiometer.</p><p>Let's improve our Max 6 patch to make it receive our Arduino's data while we turn the potentiometer.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec95"/>Improving the sequencer and connecting the Arduino</h2></div></div></div><p>We are going to create a very cheap and basic project that will involve our Arduino board as a small sound controller. Indeed, we'll directly use the firmware we just designed with the potentiometer, and then we'll modify our patch. This is a very useful base for you to continue to build things and even create bigger controller machines.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec76"/>Let's connect the Arduino to Max 6</h3></div></div></div><p>Arduino can<a id="id720" class="indexterm"/> communicate <a id="id721" class="indexterm"/>using the serial protocol. We already did that. Our latest firmware already does that, sending the voltage value.</p><p>Let's modify it a bit and make it send only the analog value read, within the range <code class="literal">0</code> to <code class="literal">1023</code>. Here is the code, available in <code class="literal">Chapter06/maxController</code>:</p><div><pre class="programlisting">int potPin = 0;     // pin number where the potentiometer is connected
int potValue = 0 ;  // variable storing the voltage value measured at potPin pin

void setup() {
  Serial.begin(9600);
}

void loop(){
  potValue = analogRead(potPin); // read and store the read value at potPin pin
  Serial.println(potValue); // write the voltage value an a carriage return

  delay(2);    // this small break waits for the ADC to stabilize is often used
}</pre></div><p>I removed everything unnecessary and added a delay of 2 ms at the end of the loop (before the loop restarts) This is often used with analog input and especially ADC. It provides a break to let it stabilize a bit. I didn't do that in previous code involving analog read because there were already two <code class="literal">delay()</code> methods involved in the LED blinking.</p><p>This basic <a id="id722" class="indexterm"/>one sends the value read at the analog input pin where the potentiometer is connected. No more, but no less.</p><p>Now, let's learn how to receive that <a id="id723" class="indexterm"/>somewhere other than the Serial Monitor of our precious IDE, especially in Max 6.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec77"/>The serial object in Max 6</h3></div></div></div><p>There is a Max <a id="id724" class="indexterm"/>object named <code class="literal">serial</code>. It provides a way to communicate using a serial port with any other type of device using serial communication.</p><p>The next figure describes the new Max 6 patch including the part necessary to communicate with our small hardware controller.</p><p>Now, let's plug the Arduino in, if this has not been done already, and upload the <code class="literal">maxController</code> firmware.</p><div><div><h3 class="title"><a id="note35"/>Note</h3><p>Be careful to switch off serial monitoring for the IDE.</p><p>Otherwise, there would be a conflict on your computer; only one serial communication can be instantiated on one port.</p></div></div><p>Then here is another <a id="id725" class="indexterm"/>patch you can find, also in the <code class="literal">Chapter06/</code> folder, with the name <code class="literal">Patcher005_Arduino.maxpat</code>.</p><div><img src="img/7584_06_13.jpg" alt="The serial object in Max 6"/><div><p>The Max patch including the Arduino communication module</p></div></div><p>Double-click on the file, and you'll see this patch.</p><p>Let's describe it a bit. I added everything in green and orange.</p><p>Everything necessary to understand the Arduino messages and to convert them in terms understandable easily by our sequencer patch is in green. Some very useful helpers that are able to write to the Max window at every step of the data flow, from raw to converted data, are in orange.</p><p>Let's describe both parts, beginning with the helpers.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec78"/>Tracing and Debugging easily in Max 6</h3></div></div></div><p>Max 6 provides <a id="id726" class="indexterm"/>many ways to<a id="id727" class="indexterm"/> debug and trace things. I won't describe them all in this Arduino book, but some need a few words.</p><p>Check your patch, especially the orange-colored objects.</p><p>
<code class="literal">print</code> objects<a id="id728" class="indexterm"/> are the way to send messages directly to the Max window. Everything sent to them is written to the Max window as soon it has been received. The argument you can pass to these objects is very useful too; it helps to discern which <code class="literal">print</code> object sends what in cases where you use more than one <code class="literal">print</code> object. This is the case here and check: I name all my <code class="literal">print</code> objects considering the object from which comes the message:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">fromSerial</code>: This is for all messages coming from the <code class="literal">serial</code> object itself</li><li class="listitem" style="list-style-type: disc"><code class="literal">fromZl</code>: This is for all messages coming from the <code class="literal">zl</code> object</li><li class="listitem" style="list-style-type: disc"><code class="literal">fromitoa</code>: This is for all messages coming from the <code class="literal">itoa</code> object</li><li class="listitem" style="list-style-type: disc"><code class="literal">fromLastStep</code>: This is for all messages coming from the <code class="literal">fromsymbol</code> object</li></ul></div><p>The <code class="literal">gate</code> objects<a id="id729" class="indexterm"/> are just small doors, gates that we can enable or disable by sending <code class="literal">1</code> or <code class="literal">0</code> to the leftmost input. The <code class="literal">toggle</code> objects<a id="id730" class="indexterm"/> are nice UI objects to do that by clicking. As soon as you check the toggle, the related <code class="literal">gate</code> object will let any message sent to the right input pass through them to the only one output.</p><p>We are going to use this trace system in several minutes.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec79"/>Understanding Arduino messages in Max 6</h3></div></div></div><p>What is required to be <a id="id731" class="indexterm"/>understood is that the previous toggle is now <a id="id732" class="indexterm"/>connected to a new <code class="literal">qmetro</code> object too. This is the low priority <code class="literal">metro</code> equivalent. Indeed, this one will poll the <code class="literal">serial</code> object every 20 ms, and considering how our Arduino's firmware currently works by sending the analog value read at every turn in the loop, even if this polling lags a bit, it won't matter; the next turn, the update will occur.</p><p>The <code class="literal">serial</code> object is the important one here.</p><p>I hardcoded some parameters related to serial communication with the Arduino:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">9600</code> sets the clock to 9600 bauds</li><li class="listitem" style="list-style-type: disc"><code class="literal">8</code> sets the word length at 8 bit</li><li class="listitem" style="list-style-type: disc"><code class="literal">1</code> means there is a stop bit</li><li class="listitem" style="list-style-type: disc"><code class="literal">0</code> means there is no parity (parity is sometimes useful in error checking)</li></ul></div><p>This object needs to be banged in order to provide the current content of the serial port buffer. This is the reason why I feed it by the <code class="literal">qmetro</code> object.</p><p>The <code class="literal">serial</code> object <a id="id733" class="indexterm"/>pops out a raw list of values. Those values need to be a bit parsed and organized before reading the analog value sent. This is what the <code class="literal">select</code>, <code class="literal">zl</code>, <code class="literal">itoa</code>, and <code class="literal">fromsymbol</code> objects stand for.</p><div><div><h3 class="title"><a id="note36"/>Note</h3><p>Directly read the help information for any object in Max 6 by pushing the <em>Alt</em> key on your keyboard and then clicking on the object.</p></div></div><div><img src="img/7584_06_14.jpg" alt="Understanding Arduino messages in Max 6"/><div><p>The serial object's help patch</p></div></div><p>Every 20 ms, if the<a id="id734" class="indexterm"/> serial communication has been instantiated, the <code class="literal">serial</code> object will provide what will be sent by the Arduino, the current and most recently read analog value of the pin where the potentiometer is connected. This value going from 0 to 1023, I'm using a <code class="literal">scale</code> object as I did with the <code class="literal">zmap</code> object for the sequencer/sound part of the patch. This <code class="literal">scale</code> object recasts the scale of values from 0 to 1023 at input to an inverted range of 300 down to 20, letting the range to go opposite direction (be careful, current and future Max patchers, <code class="literal">zmap</code> doesn't behave like that). I did that in order to define the maximum range of the note-per-minute rate. The <code class="literal">expr</code> object calculates this. <code class="literal">qmetro</code> needs the interval between two bangs. I'm making this vary between 400 ms and 20 ms while turning my potentiometer. Then, I calculate the note-per-minute rate and display it in another <code class="literal">flonum</code> UI object.</p><p>Then, I also added this strange <code class="literal">loadbang</code> object and the <code class="literal">print</code> one. <code class="literal">loadbang</code> is the specific object that sends a bang as soon as the patcher is opened by Max 6. It is often used to initialize some variable inside our patcher, a bit like we are doing with the declarations in the first rows of our Arduino sketches.</p><p>
<code class="literal">print</code> is <a id="id735" class="indexterm"/>only text inside an object named <code class="literal">message</code>. Usually, each Max 6 object can understand specific messages. You can create a new empty message by typing <code class="literal">m</code> anywhere in a patcher. Then, with the autocomplete feature, you can fill it with text by selecting it and clicking on it again.</p><p>Here, as soon as the patch is loaded and begins to run, the <code class="literal">serial</code> object receives the print message triggered by <code class="literal">loadbang</code>. The <code class="literal">serial</code> object is able to send the list of all serial port messages to the computer that runs the patch to the console (that is, the Max window). This happens when we send the print message to it. Check the Max window of the figure showing the <code class="literal">Patcher005_Arduino.maxpat</code> patch.</p><p>We can see a list of…things. <code class="literal">serial</code> pops out a list of serial port letter abbreviations with the corresponding serial ports often representing the hardware name. Here, as we already saw in the Arduino IDE, the one corresponding to the Arduino is <code class="literal">usbmodemfa131</code>.</p><p>The corresponding<a id="id736" class="indexterm"/> reference in Max is the letter <code class="literal">c</code> on my computer. This is only an internal reference.</p><div><img src="img/7584_06_15.jpg" alt="Understanding Arduino messages in Max 6"/><div><p>Result of the print message sent to the serial object: the list of port letters / names of serial ports </p></div></div><p>Let's change the hardcoded letter put as argument for the <code class="literal">serial</code> object in the patch.</p><p>Select the <code class="literal">serial</code> object. Then, re-click inside and swap <code class="literal">a</code> with the letter corresponding to the Arduino serial port on your computer. As soon as you hit <em>Enter</em>, the object is instantiated again with new parameters.</p><div><img src="img/7584_06_16.jpg" alt="Understanding Arduino messages in Max 6"/><div><p>Changing the reference letter in the serial object to match the one corresponding to the serial port of the Arduino</p></div></div><p>Now, <a id="id737" class="indexterm"/>everything is ready. Check the toggle, enable the gray box with the speaker, and <a id="id738" class="indexterm"/>turn your potentiometer. You are going to hear your strange noises from the sequencer, and you can now change the note rate (I mean the interval between each sound) because I abusively used the term note to fit better to the sequencer's usual definition.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec80"/>What is really sent on the wire?</h3></div></div></div><p>You will have noticed that, as usual, I mentioned the series of objects: <code class="literal">select</code>, <code class="literal">zl</code>, <code class="literal">itoa</code>, and <code class="literal">fromsymbol</code>. The time has come to explain them.</p><p>When you use the <code class="literal">Serial.println()</code> function<a id="id739" class="indexterm"/> in your Arduino's firmware source code, the Arduino doesn't send only the value passed as argument to the function. Check the first orange toggle at the top of the series of toggle/gate systems.</p><div><img src="img/7584_06_17.jpg" alt="What is really sent on the wire?"/><div><p>The serial object pops out strange series of numbers</p></div></div><p>You can see the name of the printing object in the first column named <strong>Object</strong>, and in the <strong>Message</strong> column, the message sent by the related object. And we can see the <code class="literal">serial</code> object popping out strange series of numbers in a repetitive way: <strong>51</strong>, <strong>53</strong>, <strong>48</strong>, <strong>13</strong>, <strong>10</strong>, and so on.</p><div><div><h3 class="title"><a id="note37"/>Note</h3><p>Arduino transmits its values as <a id="id740" class="indexterm"/>ASCII, exactly as if we were typing them on our computer.</p></div></div><p>This is very important. Let's check the <em>Appendix E, ASCII Table</em>, in order to find the corresponding characters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">51 means the character 3</li><li class="listitem" style="list-style-type: disc">53 means 5</li><li class="listitem" style="list-style-type: disc">48 means 0</li><li class="listitem" style="list-style-type: disc">13 means a carriage return</li><li class="listitem" style="list-style-type: disc">10 means line feed, which itself means new line</li></ul></div><p>Of course, I cheated a bit by sorting the series as I did. I knew about the <code class="literal">10 13</code> couple of numbers. It is a usual marker meaning <em>a carriage return followed by a new line</em>.</p><p>So it seems that my Arduino sent a message a bit like this:</p><div><pre class="programlisting">350&lt;CR&gt;&lt;LF&gt;</pre></div><p>Here, <code class="literal">&lt;CR&gt;</code> and <code class="literal">&lt;LF&gt;</code> are carriage return and new line characters.</p><p>If I had used the <code class="literal">Serial.print()</code> function instead of <code class="literal">Serial.println()</code>, I wouldn't have had the same result. Indeed, the <code class="literal">Serial.print()</code> version doesn't add the <code class="literal">&lt;CR&gt;</code> and <code class="literal">&lt;NL&gt;</code> characters at the end of a message. How could I have known whether <code class="literal">3</code>, <code class="literal">5</code>, or <code class="literal">0</code> would be the first character if I didn't have an end marker?</p><p>The design pattern to keep in mind is as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Build the message</li><li class="listitem" style="list-style-type: disc">Send the message after it is completely built (using the <code class="literal">Serial.println()</code> function.)</li></ul></div><p>If you want to send it while building it, here's what you can use:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Send the first byte using <code class="literal">Serial.print()</code></li><li class="listitem" style="list-style-type: disc">Send the second byte using <code class="literal">Serial.print()</code></li><li class="listitem" style="list-style-type: disc">Continue to send until the end</li><li class="listitem" style="list-style-type: disc">Send the <code class="literal">&lt;CR&gt;&lt;LF&gt;</code> at the end by using <code class="literal">Serial.println()</code> with no argument</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec81"/>Extracting only the payload?</h3></div></div></div><p>In many fields related to communication, we talk about payload<a id="id741" class="indexterm"/>. This is the message, the purpose of the communication itself. Everything else is very important but can be understood as a carrier; without these signals and semaphores, the message couldn't travel. However, we are interested in the message itself.</p><p>We need to parse the message coming from the serial object.</p><p>We have to accumulate each ASCII code into the same message, and when we detect the <code class="literal">&lt;CR&gt;&lt;LF&gt;</code> sequence, we have to pop out the message block and then restart the process.</p><p>This is done with the <code class="literal">select</code> and <code class="literal">zl</code> objects.</p><p>
<code class="literal">select</code> is able to detect messages equaling one of its arguments. When <code class="literal">select 10 13</code> receives a 10, it will send a bang to the first output. If it is a 13, it will send a bang to the second output. Then, if anything else comes, it will just pass the message from the last output to the right.</p><p>
<code class="literal">zl</code> is such a powerful list processor with so many usage scenarios that it would make up a book by itself! Using argument operator, we can even use it to parse the data, cut lists into pieces, and much more. Here, with the group 4 argument, <code class="literal">zl</code> receives an initial message and stores it; when it receives a second message, it stores the message, and so on, until the fourth message. At the precise moment that this is received, it will send a bigger message composed of the four messages received and stored. Then, it clears its memory.</p><p>Here, if we check the <a id="id742" class="indexterm"/>corresponding toggle and watch the Max window, we can see <strong>51 53 48</strong> repeated several times and sent by the <code class="literal">zl</code> object.</p><p>The <code class="literal">zl</code> object does a great job; it passes all ASCII characters except <code class="literal">&lt;CR&gt;</code> and <code class="literal">&lt;LF&gt;</code>, and as soon as it receives <code class="literal">&lt;LF&gt;</code>, <code class="literal">zl</code> sends a bang. We have just built a message processor that <em>resets</em> the <code class="literal">zl</code> buffer each time it receives <code class="literal">&lt;LF&gt;</code>, that is, when a new message is going to be sent.</p><div><img src="img/7584_06_18.jpg" alt="Extracting only the payload?"/><div><p>The zl list processor pops out a series of integers</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec82"/>ASCII conversions and symbols</h3></div></div></div><p>We have now a <a id="id743" class="indexterm"/>series of three integers directly equaling the ASCII message sent by the <a id="id744" class="indexterm"/>Arduino, in my case, <code class="literal">51 53 48</code>.</p><p>If you turn the potentiometer, you'll change this series, of course.</p><p>But look at this, where is the value between 0 and 1023 we so expected? We have to convert the ASCII integer message into a real character one. This can be done using the <code class="literal">itoa</code> object (which means integer to ASCII).</p><p>Check the related toggle, and watch the Max window.</p><div><img src="img/7584_06_19.jpg" alt="ASCII conversions and symbols"/><div><p>Here is our important value</p></div></div><p>This value is the <a id="id745" class="indexterm"/>important one; it is the message sent by the Arduino over the wire and is <a id="id746" class="indexterm"/>transmitted as a symbol. You cannot distinguish a symbol from another type of message, such as an integer or a float in the Max window.</p><p>I placed two empty messages in the patch. Those are really useful for debugging purposes too. I connect them to the <code class="literal">itoa</code> and <code class="literal">fromsymbol</code> objects to their right input. Each time you send a message to another message on its right input, the value of the destination message is changed by the content of the other one. We can then display what message is really sent by <code class="literal">itoa</code> and <code class="literal">fromsymbol</code>.</p><div><img src="img/7584_06_20.jpg" alt="ASCII conversions and symbols"/><div><p> "350" doesn't equal exactly 350</p></div></div><p>
<code class="literal">fromsymbol</code> transforms each symbol into its component parts, which here make up an integer, <code class="literal">350</code>.</p><p>This <a id="id747" class="indexterm"/>final value is the one we can use with every object able to understand and process numbers. This value is scaled by the scale object and sent, at last, to the metro object. Turning<a id="id748" class="indexterm"/> the potentiometer changes the value sent, and depending upon the value, the metro sends bangs faster or slower.</p><p>This long example taught you two main things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You have to carefully know what is sent and received</li><li class="listitem" style="list-style-type: disc">How an Arduino communicates</li></ul></div><p>Now, let's move on to some other examples relating to analog inputs.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec83"/>Playing with sensors</h3></div></div></div><p>What I don't want to <a id="id749" class="indexterm"/>write in this book is a big catalog. Instead of that, I want to give you keys and the feel of all the concepts. Of course, we have to be precise and learn about particular techniques you didn't invent yourself, but I especially want you to learn best practices, to think about huge projects by yourself, and to be able to have a global vision.</p><p>I'll give you some examples here, but I won't cover every type of sensor for the previously mentioned reason.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec84"/>Measuring distances</h3></div></div></div><p>When I design <a id="id750" class="indexterm"/>installations for others or myself, I often have the idea of measuring distance between moving things and a fixed point. Imagine you want to create a system with a variable light intensity depending on the proximity of some visitors.</p><p>I used to play with a Sharp GP2Y0A02YK infrared long range sensor.</p><div><img src="img/7584_06_21.jpg" alt="Measuring distances"/><div><p>The infrared Sharp GP2Y0A-family sensor</p></div></div><p>This cool analog sensor provides good results for distances from 20 to 150 cm. There are other types of sensors on the market, but I like this one for its stability.</p><p>As with any <a id="id751" class="indexterm"/>distance sensors<a id="id752" class="indexterm"/>, the subject/target has to theoretically be perpendicular to the infrared beam's direction for maximum accuracy, but in the real world, it works fine even otherwise.</p><p>The datasheet is a first object to take care about.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec85"/>Reading a datasheet?</h3></div></div></div><p>First, you have to find the <a id="id753" class="indexterm"/>datasheet. A search engine can help a lot. This sensor's datasheet is at <a class="ulink" href="http://sharp-world.com/products/devvice/lineup/data/pdf/datasheet/gp2y0a02_e.pdf">http://sharp-world.com/products/devvice/lineup/data/pdf/datasheet/gp2y0a02_e.pdf</a>.</p><p>You don't have to understand everything. I know some fellows would blame me here for not explaining the datasheet, but I want my students to be relaxed about that. You have to filter information.</p><p>Ready? Let's go!</p><p>Generally, on the first page, you have all the features summarized.</p><p>Here, we can see this sensor seems to be quite independent considering the color of the target. Ok, good. The distance output type is very important here. Indeed, it means it outputs the distance directly and needs no additional circuitry to utilize its analog data output.</p><p>There are often some schematics of all dimensions of the outline of the sensor. This can be very useful if you want to be sure the sensor fits your box or installation before ordering it.</p><p>In the next figure, <a id="id754" class="indexterm"/>we can see a graph. This is a curve illustrating how the output voltage varies according to the distance of the target.</p><div><img src="img/7584_06_22.jpg" alt="Reading a datasheet?"/><div><p>Mathematical relation between distance and analog output voltage from the sensor</p></div></div><p>This information is precious. Indeed, as we discussed in the previous chapter, a sensor converts a physical parameter into something measurable by Arduino (or any other type of equipment). Here, a distance is converted into a voltage.</p><p>Because we measure the voltage with the analog input of our Arduino board, we need to know how the conversion works. And I'm going to use a shortcut here because I made the calculation for you.</p><p>Basically, I used another graph similar to the one we saw but mathematically generated. We need a formula to code our firmware.</p><p>If the output voltage increases, the distance decreases following <em>a kind of</em> exponential function. I had been in touch with some Sharp engineers at some point and they confirmed my thoughts about the type of formula, providing me with this:</p><div><img src="img/7584_06_42.jpg" alt="Reading a datasheet?"/></div><p>Here, D is the <a id="id755" class="indexterm"/>distance in centimeters and V the voltage measured; and a = 0.008271, b = 939.65, c = -3.398, and d = 17.339</p><p>This formula will be included in Arduino's logic in order to make it directly provide the distance to anyone who would like to know it. We could also make this calculation on the other side of the communication chain, in a Max 6 patch for instance, or even in Processing. Either way, you want to make sure your distance parameter data scales well when comparing the output from the sensor to the input where that data will be used.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec86"/>Let's wire things</h3></div></div></div><p>This next circuit <a id="id756" class="indexterm"/>will remind you very much of the previous one. Indeed, the range sensor replaces the potentiometer, but it is wired in exactly the same way:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Vcc and ground of the Arduino board connected respectively to +5 V and ground</li><li class="listitem" style="list-style-type: disc">The signal legs connected to the analog input 0</li></ul></div><div><img src="img/7584_06_23.jpg" alt="Let's wire things"/><div><p>The Sharp sensor connected to the Arduino board</p></div></div><p>The circuit <a id="id757" class="indexterm"/>diagram is as follows:</p><div><img src="img/7584_06_24.jpg" alt="Let's wire things"/><div><p>The sensor range supplied by the Arduino itself and sending voltage to the Analog Input 0</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec87"/>Coding the firmware</h3></div></div></div><p>The following code is the firmware I designed:</p><div><pre class="programlisting">int sensorPin = 0; // pin number where the SHARP GP2Y0A02YK is connected
int sensorValue = 0
int distanceCalculated = 0;   // variable storing the distance calculated
int v = 0;          // variable storing the calculated voltage

// our formula's constants
const int a = 0.008271;
const int b = 939.65;
const int c = -3.398;
const int d = 17.339;


void setup() {
  Serial.begin(9600);
}

void loop(){
  sensorValue = analogRead(sensorPin); 
  v = 5. * (sensorValue / 1023.) ;  // calculate the voltage 
  distanceCalculated = ((a + b * v) / (1. + c * v + d * v * v) );
 
  Serial.println(distanceCalculated); 
 
  delay(2);
}</pre></div><p>Is it not gratifying to know you understood every line of this code? Just in case though, I will provide a brief explanation.</p><p>I need some <a id="id758" class="indexterm"/>variables to store the sensor value (that is, the values from <code class="literal">0</code> to <code class="literal">1023</code>) coming from the ADC. Then, I need to store the voltage calculated from the sensor value, and of course, the distance calculated from the voltage value.</p><p>I only initiate serial communication in the <code class="literal">setup()</code> function. Then, I make every calculation in the <code class="literal">loop()</code> method.</p><p>I started by reading the current ADC value measured and encoded from the sensor pin. I use this value to calculate the voltage using the formula we already used in a previous firmware. Then, I inject this voltage value into the formula for the Sharp sensor and I have the distance.</p><p>At last, I send the distance calculated through serial communication with the <code class="literal">Serial.println()</code> function.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec88"/>Reading the distance in Max 6</h3></div></div></div><p>
<code class="literal">Patcher006_Arduino.maxpat</code> is the <a id="id759" class="indexterm"/>patch related to this distance measurement <a id="id760" class="indexterm"/>project. Here it is:</p><div><img src="img/7584_06_25.jpg" alt="Reading the distance in Max 6"/><div><p>The distance reading patch</p></div></div><p>As we learnt <a id="id761" class="indexterm"/>previously, this patcher contains the whole design <a id="id762" class="indexterm"/>pattern to read messages coming from the Arduino board.</p><p>The only new thing here is the strange UI element at the bottom. It is called a <strong>slider</strong>
<a id="id763" class="indexterm"/>. Usually, sliders are used to control things. Indeed, when you click and drag a slider object, it pops out values. It looks like sliders on mixing boards or lighting dimmers, which provide control over some parameters.</p><p>Obviously, because I want to transmit a lot of data myself here, I'm using this slider object as a display device and not as a control device. Indeed, the slider object also owns an input port. If you send a number to a slider, the slider takes it and updates its internal current value; it also transmits the value received. I'm only using it here as a display.</p><p>Each object in Max 6 has its own parameters. Of course a lot of parameters are common to all objects, but some aren't. In order to check those parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Select the object</li><li class="listitem" style="list-style-type: disc">Check the<a id="id764" class="indexterm"/> inspector by choosing the <strong>Inspector</strong> tab or <a id="id765" class="indexterm"/>typing <em>Ctrl</em> + <em>I</em> on Windows or <em>command</em> + <em>I</em> on OS X<div><img src="img/7584_06_26.jpg" alt="Reading the distance in Max 6"/><div><p>The inspector window showing the attributes and properties of the selected slider object</p></div></div></li></ul></div><p>I won't describe all parameters, only the two at the bottom. In order to produce a relevant result, I had to scale the value coming from the <code class="literal">fromsymbol</code> object. I know the range of values transmitted by the Arduino (though this could require some personal verification), having calculated them from the Sharp datasheet. I considered this range as 20 to 150 cm. I mean a number between 20 and 150.</p><p>I took this range <a id="id766" class="indexterm"/>and compressed and translated it a bit, using the <code class="literal">scale</code> object, into<a id="id767" class="indexterm"/> a <code class="literal">0-to-100 </code>range of float numbers. I chose the same range for my slider object. Doing that, the result displayed by the slider is coherent and represents the real value.</p><p>I didn't write any increment marks on the slider but only made two comments: <code class="literal">near</code> and <code class="literal">far</code>. It is a bit poetic in this world of numbers.</p><p>Let's check some other examples of sensors able to pop out continuous voltage variations.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec96"/>Measuring flexion</h2></div></div></div><p>Flexi sensors<a id="id768" class="indexterm"/> are also very much in use. Where the distance sensor is able to convert a measured distance into voltage, the flexi sensor measures flexion and provides a voltage.</p><p>Basically, the device flexion <a id="id769" class="indexterm"/>is related to a variable resistance able to make a voltage vary according to the amount of flexion.</p><div><img src="img/7584_06_27.jpg" alt="Measuring flexion"/><div><p>A standard flexi sensor with two connectors only</p></div></div><p>A flexi sensor can be used for many purposes.</p><p>I like to use it to<a id="id770" class="indexterm"/> inform computer through Arduino about door position in digital installations I design. People wanted initially to know only about whether doors are open or closed, but I proposed to use a flexi and got very good information about the angle of openness.</p><p>The following figure illustrates how <a id="id771" class="indexterm"/>the sensor works:</p><div><img src="img/7584_06_28.jpg" alt="Measuring flexion"/></div><p>Now, I'm directly giving you the wiring schematic made again with Fritzing:</p><div><img src="img/7584_06_29.jpg" alt="Measuring flexion"/><div><p>Flexi sensor connected to Arduino board with the pull-down resistor</p></div></div><p>I put a pull-down<a id="id772" class="indexterm"/> resistor. If you didn't read <a class="link" href="ch05.html" title="Chapter 5. Sensing with Digital Inputs">Chapter 5</a>, <em>Sensing with Digital Inputs</em>, about pull-up and pull-down resistors, I suggest you to do that now.</p><p>Usually, I use resistors about 10K Ω and they work fine.</p><p>The circuit diagram is shown in the following figure:</p><div><img src="img/7584_06_30.jpg" alt="Measuring flexion"/><div><p>The flexi sensor and its pull-down resistor wired to the Arduino</p></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec89"/>Resistance calculations</h3></div></div></div><p>For this project, I won't <a id="id773" class="indexterm"/>give you the code because it is very similar to the previous one, except for the calculation formulas. It is these resistance calculation formulas I'd like to discuss here.</p><p>What do we do if we don't have the graph the Sharp Co. was kind enough to include with their infrared sensor? We have to resort to some calculations.</p><p>Usually, the flexi sensor documentation provides resistance values for it when it is not bent and when it is bent at 90 degrees. Let's say some usual values of 10K Ω and 20K Ω, respectively.</p><p>What are the voltage values we can expect for these resistances values, including the pull-down one too?</p><p>Considering the electrical schematic, the voltage at the analog pin 0 is:</p><div><img src="img/7584_06_45.jpg" alt="Resistance calculations"/></div><p>If we choose the same resistance for the pull-down as the one for the flexi when it is not flexed, we can expect the voltage to behave according to this formula:</p><div><img src="img/7584_06_43.jpg" alt="Resistance calculations"/></div><p>Obviously, by using the same formula when it isn't bent, we can expect:</p><div><img src="img/7584_06_44.jpg" alt="Resistance calculations"/></div><p>This means we<a id="id774" class="indexterm"/> found our range of voltage values.</p><p>We can now convert that into digital 10-bit, encoded values, I mean the famous 0-to-1023 range of Arduino's ADC.</p><p>A small, easy calculation provides us with the values:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">511</code> when the voltage is 2.5 (when the flexi isn't bent)</li><li class="listitem" style="list-style-type: disc"><code class="literal">347</code> when the voltage is 1.7 (when the flexi is bent at around a 90-degree angle)</li></ul></div><p>Because the voltage at Arduino's pin depends on the inverse of the resistance, we don't have a perfectly linear variation.</p><p>Experience tells me I can almost approximate this to a linear variation, and I used a scale function in Arduino firmware in order to map <code class="literal">[347,511]</code> to a simplerange of <code class="literal">[0,90]</code>. <code class="literal">map(value, fromLow, fromHigh, toLow, toHigh)</code> is the function to use here.</p><p>Do you remember the <code class="literal">scale</code> object in Max 6? <code class="literal">map()</code> works basically the same way, but for the Arduino. The statement here would be <code class="literal">map(347,511,90,0)</code>. This would give a fairly approximated value for the physical angle of bend.</p><p>The <code class="literal">map</code> function works in both directions and can map number segments going in the opposite direction. I guess you begin to see what steps to follow when you have to work with analog inputs on the Arduino.</p><p>Now, we are going to meet some other sensors.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec97"/>Sensing almost everything</h2></div></div></div><p>Whatever the physical parameter you want to measure, there's a sensor<a id="id775" class="indexterm"/> for it.</p><p>Here is a small list:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Light color and light intensity</li><li class="listitem" style="list-style-type: disc">Sound volume</li><li class="listitem" style="list-style-type: disc">Radioactivity intensity</li><li class="listitem" style="list-style-type: disc">Humidity</li><li class="listitem" style="list-style-type: disc">Pressure</li><li class="listitem" style="list-style-type: disc">Flexion</li><li class="listitem" style="list-style-type: disc">Liquid level</li><li class="listitem" style="list-style-type: disc">Compass and direction related to magnetic north</li><li class="listitem" style="list-style-type: disc">Gas-specific detection</li><li class="listitem" style="list-style-type: disc">Vibration intensity</li><li class="listitem" style="list-style-type: disc">Acceleration on three axes (x, y, z)</li><li class="listitem" style="list-style-type: disc">Temperature</li><li class="listitem" style="list-style-type: disc">Distance</li><li class="listitem" style="list-style-type: disc">Weight (different for a pure flexion sensor)</li></ul></div><p>It isn't an exhaustive list, but it is quite complete.</p><p>Prices are really variable from a few dollars to $50 or $60. I found one of the cheaper Geiger counters for around $100. You can find a huge list of companies available on the Internet to buy sensors from in <em>Appendix G, List of Components' Distributors</em>.</p><p>Now, let's move further. How can we handle multiple analog sensors? The first answer is by wiring everything to many analog inputs of the Arduino. Let's check if we can be smarter than that.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Multiplexing with a CD4051 multiplexer/demultiplexer</h1></div></div></div><p>We are going to explore a technique called <strong>multiplexing</strong>
<a id="id776" class="indexterm"/>. This is a major subchapter because we are going to learn how to make our real-life project more concrete, more real.</p><p>We often have many constraints in the real world. One can be the number of Arduinos available. This constraint can also come from having a computer that has only one USB port. Yes, this happens in real life, and I would be lying if I said you can have every connector you want, whenever you want, within the budget you want.</p><p>Imagine that you have to plug more than eight sensors to you Arduino's analog input. How would you do it?</p><p>We will learn to multiplex signals.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec98"/>Multiplexing concepts</h2></div></div></div><p>Multiplexing <a id="id777" class="indexterm"/>is quite common in the telecommunications world. Multiplexing defines techniques providing efficient ways to make multiple signals share a single medium.</p><div><img src="img/7584_06_31.jpg" alt="Multiplexing concepts"/><div><p>Basic multiplexing concept showing the shared medium</p></div></div><p>This technique provides a very helpful concept in which you only need one shared medium to bring many channels of information as we can see in the previous figure.</p><p>Of course, it involves multiplexing (named mux in the figure) and demultiplexing (demux) processes.</p><p>Let's dig into those processes a bit.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec99"/>Multiple multiplexing/demultiplexing techniques</h2></div></div></div><p>When we have to multiplex/demultiplex signals, we <a id="id778" class="indexterm"/>basically have to find a way to separate them using physical quantities that we can control.</p><p>I can list at least three types of <a id="id779" class="indexterm"/>multiplexing techniques:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">space-division multiplexing</li><li class="listitem" style="list-style-type: disc">frequency-division multiplexing</li><li class="listitem" style="list-style-type: disc">time-division multiplexing</li></ul></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec90"/>Space-division multiplexing</h3></div></div></div><p>This is<a id="id780" class="indexterm"/> the<a id="id781" class="indexterm"/> easiest to grasp.</p><div><img src="img/7584_06_32.jpg" alt="Space-division multiplexing"/><div><p>Space-division multiplexing physically agglomerates all wires into the same place</p></div></div><p>This concept is the basic phone network multiplexing in your flat, for instance.</p><p>Your phone wires go out, as those from your neighbors, and all those wires are joined into one shielded, big multipair cable containing, for instance, all phone wires for the whole building in which you live. This huge multipair cable goes into the street, and it is easier to catch it as a single global cable than if you had to catch each cable coming from your neighbors plus yours.</p><p>This concept is <a id="id782" class="indexterm"/>easily transposable to Wi-Fi <a id="id783" class="indexterm"/>communications. Indeed, some Wi-Fi routers today provide more than one Wi-Fi antenna. Each antenna would be able, for instance, to handle one Wi-Fi link. Every communication would be transmitted using the same medium: air transporting electromagnetic waves.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec91"/>Frequency-division multiplexing</h3></div></div></div><p>This type of <a id="id784" class="indexterm"/>multiplexing is very common in everything <a id="id785" class="indexterm"/>related to DSL and cable TV connections.</p><p>Service providers can (and do) provide more than one service on the same cable using this technique.</p><div><img src="img/7584_06_33.jpg" alt="Frequency-division multiplexing"/><div><p>Frequency-division multiplexing plays with frequencies of transmission and bandwidths</p></div></div><p>Imagine the <strong>1</strong>, <strong>2</strong>, and <strong>3</strong> frequency bands on the figure would be three different services. 1 could be voice, 2 could be internet, and 3 TV. The reality isn't too far from this.</p><p>Of course, what we multiplex at one end, we have to demultiplex at the other in order to address our signals correctly. I wouldn't try to convert a TV modulated signal into voice, but I'm guessing it wouldn't be a very fruitful experience.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec92"/>Time-division multiplexing</h3></div></div></div><p>This is the case we are going to <a id="id786" class="indexterm"/>dig into the deepest because this is the <a id="id787" class="indexterm"/>one we are going to use with the Arduino to multiplex many signals.</p><div><img src="img/7584_06_34.jpg" alt="Time-division multiplexing"/><div><p>Time-division multiplexing illustrated with an example of one cycle of four steps</p></div></div><p>Sequentially, only <a id="id788" class="indexterm"/>one channel between the multiplexer and the <a id="id789" class="indexterm"/>demultiplexer is fully used for the first signal, then the second, and so on, until the last one.</p><p>This kind of system often involves a clock. This helps in setting the right cycle for each participant so they know at which step of communication we are. It is critical that we preserve the safety and integrity of communications.</p><p>Serial <a id="id790" class="indexterm"/>communications work like that, and for <a id="id791" class="indexterm"/>many reasons—even if you think you know them a lot after previous chapters—we'll dig a bit deeper into them in the next chapter.</p><p>Let's check how we can deal with eight sensors and only one analog input for our Arduino board.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec100"/>The CD4051B analog multiplexer</h2></div></div></div><p>The CD4051B analog multiplexer<a id="id792" class="indexterm"/> is a very cheap one and is very useful. It is basically an analog and digital multiplexer and demultiplexer. This doesn't mean you can use it as a multiplexer and a demultiplexer at the same time. You have to identify in what case you are and wire and design the code for this proper case. But it is always useful to have a couple of CD4051B devices.</p><p>Used as a multiplexer, you can connect, say eight potentiometers to the CD4051B and only one Arduino analog input, and you'll be able, by code, to read all 8 values.</p><p>Used as a demultiplexer, you could write to eight analog outputs by writing from only one Arduino pin. We'll talk about that a bit later in this book, when we approach the output pin and especially the <a id="id793" class="indexterm"/>
<strong>pulse-width modulation</strong> (<strong>PWM</strong>) trick with LEDs.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec93"/>What is an integrated circuit?</h3></div></div></div><p>An <strong>integrated circuit</strong> (<strong>IC</strong>)<a id="id794" class="indexterm"/> is an electronic circuit miniaturized and all included in a small box of plastic. This is the simplest definition.</p><p>Basically, we cannot talk about integrated circuits without bringing to mind their small size. It is one of the more interesting features of IC.</p><p>The other one is what I am naming the <strong>black box abstraction</strong>
<a id="id795" class="indexterm"/>. I also define it like the programming-like classes of the hardware world. Why? Because you don't have to know exactly how it works but only how you can use it. It means all the circuits inside don't really matter if the legs outside make sense for your own purpose.</p><p>Here are two among several type of IC packages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Dual in-line package</strong> <a id="id796" class="indexterm"/>(<strong>DIP</strong>, also named <strong>DIL</strong>)</li><li class="listitem" style="list-style-type: disc"><strong>Small</strong><a id="id797" class="indexterm"/><strong> outline</strong> (<strong>SO</strong>)</li></ul></div><p>You can find a useful guide at <a class="ulink" href="http://how-to.wikia.com/wiki/Guide_to_IC_packages">http://how-to.wikia.com/wiki/Guide_to_IC_packages</a>.</p><p>The more commonly used of the two ICs are definitely DIPs. They are also called through-holes. We can easily manipulate and plug them into a breadboard or <strong>printed </strong>
<a id="id798" class="indexterm"/>
<strong>circuit board</strong> (<strong>PCB</strong>).</p><p>SO requires more dexterity and finer tools.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec94"/>Wiring the CD4051B IC?</h3></div></div></div><p>The first question <a id="id799" class="indexterm"/>is about <em>what</em> it looks like? In this case, the answer is that it looks like a DIP package.</p><div><img src="img/7584_06_35.jpg" alt="Wiring the CD4051B IC?"/><div><p>The CD4051B DIP case version</p></div></div><p>Here is the face of this nice little integrated circuit. The datasheet is easy to find on the Internet. Here is one by Texas Instruments:</p><p><a class="ulink" href="http://www.ti.com/lit/ds/symlink/cd4051b.pdf">http://www.ti.com/lit/ds/symlink/cd4051b.pdf</a>
</p><p>I redrew the global package in the next figure.</p><div><img src="img/7584_06_36.jpg" alt="Wiring the CD4051B IC?"/><div><p>A schematic of the CD4051B with all pin descriptions</p></div></div><div><div><div><div><h4 class="title"><a id="ch06lvl4sec33"/>Identifying pin number 1</h4></div></div></div><p>It is easy easy to find out <a id="id800" class="indexterm"/>which pin is pin number 1. As standard, there is a small circle engraved in front of one of the corner pins. This is the pin number 1.</p><p>There is also a small hole shaped as a half circle. When you place the IC with this half circle at the top (as shown on the previous figure), you know which pin number 1 is; the first pin next to pin number 1 is pin number 2, and so on, until the last pin of the left column which, in our case, is pin number 8. Then, continue with the pin opposite to the last one in the left column; this is pin number 9, and the next pin is pin number 10, and so on, until the top of the right column.</p><div><img src="img/7584_06_37.jpg" alt="Identifying pin number 1"/><div><p>Numbering the pins of an IC</p></div></div><p>Of course, it would <a id="id801" class="indexterm"/>be much too simple if the first input was pin 1. The only real way you can know for sure is to check the specs.</p></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec95"/>Supplying the IC</h3></div></div></div><p>The IC itself has to be<a id="id802" class="indexterm"/> supplied. This is to make it active but also, in some cases, to drive the current too.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Vdd is the positive supply voltage pin. It has to be wired to the 5 V supply.</li><li class="listitem" style="list-style-type: disc">Vee is the negative supply voltage pin. Here, we'll wire it to Ground.</li><li class="listitem" style="list-style-type: disc">Vss is the ground pin, connected to Ground too.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec96"/>Analog I/O series and the common O/I</h3></div></div></div><p>Check the order of the <a id="id803" class="indexterm"/>I and the O in this title.</p><p>If you choose to use the CD4051B as a multiplexer, you'll have multiple analog inputs and one common output.</p><p>On the other hand, if you choose to use it as a demultiplexer, you'll have one common input and multiple analog outputs.</p><p>How does the selection/commutation work? Let's check the selector's digital pins, A, B, and C.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec97"/>Selecting the digital pin</h3></div></div></div><p>Now comes the<a id="id804" class="indexterm"/> most important part.</p><p>There are three pins, named A (pin 11), B (pin10), and C (pin 9), that have to be driven by digital pins of the Arduino. What? Aren't we in the analog inputs part? We totally are, but we'll introduce a new method of control using these three selected pins.</p><p>The multiplexing engine under the hood isn't that hard to understand.</p><p>Basically, we send some signal to make the CD4051B commute the inputs to the common output. If we wanted to use it as a demultiplexer, the three selected pins would have to be controlled exactly in the same way.</p><p>In the datasheet, I found a table of truth. What is that? It is just a table where we can check which A, B, and C combinations commute the inputs to the common output.</p><p>The following table describes the combination:</p><div><img src="img/7584_06_38.jpg" alt="Selecting the digital pin"/><div><p>The truth table for the CD4051B</p></div></div><p>In other words, it means that, if we write 1 to the digital output on Arduino corresponding to A, 1 to that corresponding to B and 0 to that corresponding to C, the commuted input would be the third channel.</p><p>Of course, there is something good in this. If you <em>read</em> the binary number corresponding to the inputs on C, B, and A (in that order), you'll have a nice surprise; it will be equivalent to the decimal number of the input pin commuted by the common output.</p><p>Indeed, 0 0 0 in<a id="id805" class="indexterm"/> binary equals 0 in decimal. Refer the table for the binary values of decimal numbers:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>0 0 0</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>0 0 1</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>0 1 0</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>0 1 1</p>
</td><td style="text-align: left" valign="top">
<p>3</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1 0 0</p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1 0 1</p>
</td><td style="text-align: left" valign="top">
<p>5</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1 1 0</p>
</td><td style="text-align: left" valign="top">
<p>6</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1 1 1 </p>
</td><td style="text-align: left" valign="top">
<p>7</p>
</td></tr></tbody></table></div><p>Here is how we could wire things:</p><div><img src="img/7584_06_39.jpg" alt="Selecting the digital pin"/><div><p>The circuit including the CD4051B  multiplexer with its common output wired to the analog pin 0</p></div></div><p>And the following <a id="id806" class="indexterm"/>figure is the electrical diagram:</p><div><img src="img/7584_06_40.jpg" alt="Selecting the digital pin"/><div><p>The electrical diagram</p></div></div><p>All devices we'd like to read with this system should be wired to I/O 0, 1, 2, and so on, on the CD4051B.</p><p>Considering what<a id="id807" class="indexterm"/> we know about table of truth and how the device works, if we want to read sequentially all pins from 0 to 7, we will have to make a loop containing both types of statements: </p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One for commuting the multiplexer</li><li class="listitem" style="list-style-type: disc">One for reading the Arduino analog input 0</li></ul></div><p>The source code would look like this (you can find it in the <code class="literal">Chapter6/analogMuxReader</code> folder):</p><div><pre class="programlisting">int muxOutputPin = 0 ;  // pin connected to the common output of the CD4051B
int devicesNumber = 8 ; // number of device // BE CAREFUL, plug them from 0

int controlPinA = 2 ;   // pin connected to the select pin A of the CD4051B 
int controlPinB = 3 ;   // pin connected to the select pin B of the CD4051B 
int controlPinC = 4 ;   // pin connected to the select pin C of the CD4051B 

int currentInput = 0 ;  // hold the current analog input commuted o the common output of the CD4051B

void setup() {
  Serial.begin(9600);

  // setting up all 3 digital pins related to selectors A, B and C as outputs
  pinMode(controlPinA, OUTPUT);
  pinMode(controlPinB, OUTPUT);
  pinMode(controlPinC, OUTPUT);
}

void loop(){
  for (currentInput = 0 ; currentInput &lt; devicesNumber - 1 ; currentInput++)
  {
    // selecting the inputs that is commuted to the common output of the CD4051B
    digitalWrite(controlPinA, bitRead(currentInput,0));
    digitalWrite(controlPinB, bitRead(currentInput,1));
    digitalWrite(controlPinC, bitRead(currentInput,2));
    
    // reading and storing the value of the currentInput
    Serial.println(analogRead(muxOutputPin)) ;
  }
}</pre></div><p>After you've<a id="id808" class="indexterm"/> defined all the variables, we set up the serial port in <code class="literal">setup()</code> and also the three pins related to the selector pin of the CD4051B as outputs. Then, in each cycle, I first select the commuted input by either driving the current or not to pins A, B, and C of the CD4051B. I'm using a nested function in my statement in order to save some rows.</p><p>
<code class="literal">bitRead(number,n)</code> <a id="id809" class="indexterm"/>is a new function able to return the <em>nth</em> bit of a number. It is the perfect function for us in our case.</p><p>We make a loop over the input commuted from 0 to 7, more precisely to <code class="literal">devicesNumber - 1</code>.</p><p>By writing those bits to pins A, B, and C of the CD4051B device, it selects the analog input at each turn and pops the value read at the serial port for further processing in Processing or Max 6 or whatever software you want to use.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Summary</h1></div></div></div><p>In this chapter, we learnt at least how to approach a very powerful graphical framework environment named Max 6. We'll use it in several further examples in this book as we continue to use Processing too.</p><p>We learnt some reflexes for when we want to handle sensors providing continuous voltage variations to our Arduino analog inputs.</p><p>Then, we also discovered a very important technique, the multiplexing/demultiplexing.</p><p>We are going to talk about it in the next chapter about serial communication. We'll dig deeper into this type of communication now that we have used a lot of time already.</p></div></body></html>