<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Graphics View</h1></div></div></div><div><blockquote class="blockquote"><p><em>Widgets are great for designing graphical user interfaces. However, you will run into problems if you wish to animate multiple widgets at the same time by constantly moving them around in the application. For these situations, or in general for frequently transforming 2D graphics, Qt offers you Graphics View. In this chapter, you will learn the basics of the Graphics View architecture and its items. You also will learn how to combine widgets with Graphics View items. Once you have acquired a basic understanding, we are next going to develop a simple jump-and-run game illustrating how to animate the items. Finally, we'll look into some possibilities for optimizing Graphics View's performance.</em></p></blockquote></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec67"/>Graphics View architecture</h1></div></div></div><p>Three components form the core of Graphics View: an instance of <code class="literal">QGraphicsView</code>, which is referred to as <a id="id362" class="indexterm"/>
<strong>view</strong>; an instance of <code class="literal">QGraphicsScene</code>, which is referred to as <strong>scene</strong>; and <a id="id363" class="indexterm"/>usually multiple instances of <code class="literal">QGraphicsItem</code>, which are <a id="id364" class="indexterm"/>referred to as <strong>items</strong>. The usual workflow is to first <a id="id365" class="indexterm"/>create a couple of items, then add them to a scene, and finally set that scene on a view.</p><p>In the following section, we will be discussing all three parts of the Graphics View architecture one after the other, beginning with the items, followed by the scene, and concluding with the view.</p><div><img src="img/8874OS_06_01.jpg" alt="Graphics View architecture"/><div><p>An illustration of Graphics View components</p></div></div><p>However, because it is not possible to deal with one component as entirely separate from the others, you need to get the big picture up front. This will help you to better understand the description of the three single parts. And do not worry if you do not understand all the details on their first occurrence. Be patient, work through the three parts, and all issues will hopefully become clear in the end.</p><p>Think of the items as Post-it notes. You take a note and write a message on it, paint an image on it, both write and paint on it or, quite possibly, just leave it blank. This is equivalent to creating an item with a defined paint function, whether it is a default one or you have customized it. Since the items do not have a predetermined size, you define a bounding rectangle inside which all the painting of the item is done. As with a note, which does not care where it is positioned or from which angle it is being looked at, the item always draws its content as if it were in an untransformed state, where a length unit corresponds to 1 pixel. The item exists in its own coordinate system. Although you can apply various transformations to the item, such as rotating and scaling, it's not the job of the item's paint function to take that into account; that's the scene's job.</p><p>What is the scene, then? Well, think of it as a larger sheet of paper onto which you attach your smaller Post-its, that is, the notes. On the scene, you can freely move the items around while applying funny transformations to them. It is the scene's responsibility to correctly display the items' position and any transformations applied to them. The scene further informs the items about any events that affect them and it has—as with the items—a bounding rectangle within which the items can be positioned.</p><p>Last but not least, let's turn our attention to the view. Think of the view as an inspection window or a person who holds the paper with the notes in their hands. You can watch the paper as a whole or you can only look at specific parts. And as a person can rotate and shear the paper with their hands, so the view can rotate and shear the scene and do a lot more transformations with it.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>You may look at the preceding diagram and be worried about all the items being outside the view. Aren't they wasting GPU render time? Don't you need to take care of them by adding a so-called "view frustum culling" mechanism (to detect which item not to draw/render because it is not visible)? Well, the short answer is "no" because Qt is already taking care of this.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec86"/>Items</h2></div></div></div><p>So, let's look at the <a id="id366" class="indexterm"/>items. The most fundamental characteristic of items in Graphics View is their object-oriented approach. All items in the scene must inherit <code class="literal">QGraphicsItem</code>, which is an abstract class with—amongst numerous other public functions—two pure <a id="id367" class="indexterm"/>virtual functions called <code class="literal">boundingRect()</code> and <code class="literal">paint()</code>. Because of this simple and clear fact, there are principles which apply to each item.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec32"/>Parent child relationship</h3></div></div></div><p>The <a id="id368" class="indexterm"/>constructor of <code class="literal">QGraphicsItem</code> takes a pointer to another item that is set as the item's parent. If the pointer is <code class="literal">0</code>, the item has no parent. This gives you the opportunity to organize items in a tree structure similar to the <code class="literal">QObject</code> object even though the <code class="literal">QGraphicsItem</code> element does not inherit from the <code class="literal">QObject</code> object. You can change the relationship of items at any given time by calling the <code class="literal">setParentItem()</code> function. It takes the new parent as an argument. If you want to remove a child item from its parent, simply call the <code class="literal">setParentItem(0)</code> function on the child. The following code illustrates both possibilities for creating a relationship between items. (Please note that this code will not compile since <code class="literal">QGraphicsItem</code> is an abstract class. Here, it is just for the purpose of illustration, but it will work with a real item class.)</p><div><pre class="programlisting">QGraphicsItem *parentItem = new QGraphicsItem();
QGraphicsItem *firstChildItem = new QGraphicsItem(parentItem);
QGraphicsItem *secondChildItem = new QGraphicsItem();
secondChildItem-&gt;setParentItem(parentItem);
<strong>delete parentItem;</strong>
</pre></div><p>First we create an item called <code class="literal">parentItem</code>, and since we do not use the constructor's argument, the item has no parent or child. Next, we create another item called <code class="literal">firstChildItem</code> and pass a pointer to the <code class="literal">parentItem</code> item as an argument. Thus, it has the <code class="literal">parentItem</code> item as its parent, and the <code class="literal">parentItem</code> item now has the <code class="literal">firstChildItem</code> item as its child. Next we create a third item called <code class="literal">secondChildItem</code>, but since we do not pass anything to its constructor, it has no parent at this point. In the next line, however, we change that by calling the <code class="literal">setParentItem()</code> function. Now it is also a child of the <code class="literal">parentItem</code> item.</p><div><div><h3 class="title"><a id="tip44"/>Tip</h3><p>You can always check whether an item has a parent using the <code class="literal">parentItem()</code> function and <a id="id369" class="indexterm"/>check the returned <code class="literal">QGraphicsItem</code> pointer against <code class="literal">0</code>, which means that the item does not have a parent. To figure out if there are any children, call the <code class="literal">childItems()</code> function on the item. A <code class="literal">QList</code> method with the <code class="literal">QGraphicsItem</code> pointers to all child items is returned.</p></div></div><div><img src="img/8874OS_06_21.jpg" alt="Parent child relationship"/><div><p>The parent-child relationship</p></div></div><p>The benefit of this parent-child relationship is that specific actions performed on a parent item also affect associated child items. For example, when you delete a parent item, all child items will also be deleted. For that reason, it is sufficient to delete the <code class="literal">parentItem</code> item in the preceding code. The destructors of the <code class="literal">firstChildItem</code> and <code class="literal">secondChildItem</code> items are called implicitly. The same applies when you add or remove a parent item from a scene. All child items will then get added or removed as well. The same applies when you hide a parent item or when you move a parent item. In both cases, the child items will behave the same way the parent does. Think of the earlier example of Post-it notes; they would behave the same. If you have a note with other notes attached to it, they will also move when you move the parent note.</p><div><div><h3 class="title"><a id="tip45"/>Tip</h3><p>If you are not sure whether a function call on the parent item is propagated to its child items, you can always have a look at the sources. You will find them in your Qt installation if you checked the option to also install the sources at the time of installation. You can also find them online at <a class="ulink" href="https://github.com/qtproject/qtbase">https://github.com/qtproject/qtbase</a>.</p><p>Even if <a id="id370" class="indexterm"/>there isn't a meaningful comment, you can spot the relevant code easily. Just look for a <code class="literal">children</code> variable addressed through the d-pointer. Inside the destructor of the <code class="literal">QGraphicsItem</code> item, the relevant code fragment is as follows:</p><div><pre class="programlisting">if (!d_ptr-&gt;children.isEmpty()) {
  while (!d_ptr-&gt;children.isEmpty())
    delete d_ptr-&gt;children.first();
  Q_ASSERT(d_ptr-&gt;children.isEmpty());
}</pre></div></div></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec33"/>Appearance</h3></div></div></div><p>You are probably <a id="id371" class="indexterm"/>wondering what a <code class="literal">QGraphicsItem</code> item looks like. Well, since it is an abstract class (and unfortunately the paint function is a pure virtual one), it does not look like anything. You will have to do all the painting yourself. Luckily, since the paint function of the <code class="literal">QGraphicsItem</code> item offers you a technique you already know, the <code class="literal">QPainter</code> pointer, this is not very difficult.</p><p>Don't panic! You don't have to draw all items yourself though. Qt offers a lot of standard shaped items you can use just out-of-the-box. You'll find them discussed in an upcoming section titled <em>Standard items</em>. However, since we need to draw a custom item once in a while, we go through this process.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec68"/>Time for action – creating a black, rectangular item</h1></div></div></div><p>As a <a id="id372" class="indexterm"/>first approach, let's create an item that paints a black rectangle:</p><div><pre class="programlisting">class BlackRectangle : public QGraphicsItem {
public:
  explicit BlackRectangle(QGraphicsItem *parent = 0)
    : QGraphicsItem(parent) {}
  virtual ~BlackRectangle() {}

  QRectF boundingRect() const {
    return QRectF(0, 0, 75, 25);
  }

  void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) {
    Q_UNUSED(option)
    Q_UNUSED(widget)
    painter-&gt;fillRect(boundingRect(), Qt::black);
  }
};</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec87"/>
<em>What just happened?</em>
</h2></div></div></div><p>First, we subclass <code class="literal">QGraphicItem</code> and call the new class <code class="literal">BlackRectangle</code>. The class' constructor <a id="id373" class="indexterm"/>accepts a pointer to a <code class="literal">QGraphicItem</code> item. This pointer is then passed to the constructor of the <code class="literal">QGraphicItem</code> item. We do not have to worry about it; <code class="literal">QGraphicItem</code> will take care of it and establish the parent-child relationship for our item, among other things. Next, the virtual destructor makes sure that it gets called even if the class is getting deleted through a base class pointer. This is a crucial point, as you will learn later when we talk about the scene.</p><p>Next, we define the <code class="literal">boundingRect()</code> function of our item, where we return a rectangle 75 pixels wide and 25 pixels high. This returned rectangle is the canvas for the <code class="literal">paint</code> method and simultaneously the promise to the scene that the item will only paint in this area. The scene relies on the correctness of that information, so you should strictly obey that promise. Otherwise, the scene will become cluttered up with relics of your drawing!</p><p>Lastly, we do the actual painting from <code class="literal">QPainter</code> in conjunction with a <code class="literal">QWidget</code> item. There is nothing different here except that the painter is already initialized with the appropriate values given to us through the first argument. Even if it is not needed, I would suggest that the painter be kept in the same state at the end of the function as it was in the beginning. If you follow that advice, and if you only use custom items in the scene, you can later optimize the render speed enormously. This especially applies to scenes with many items. But let us go back to what we were actually doing. We have taken the painter and called the <code class="literal">fillRect()</code> function, which does not touch the painter's internal state. As arguments, we used the <code class="literal">boundingRect()</code> function, which defines the area to fill, and the <code class="literal">Qt::black</code> parameter, which defines the fill color. Thus, by only filling the bounding rectangle of the item, we obeyed the bounding rectangle promise.</p><p>In our example, we have not used the two other arguments of the <code class="literal">paint</code> function. To suppress the compiler warnings about unused variables, we used Qt's <code class="literal">Q_UNUSED</code> macro.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec69"/>Time for action – reacting to an item's selection state</h1></div></div></div><p>The <a id="id374" class="indexterm"/>assigned pointer to a <code class="literal">QStyleOptionGraphicsItem</code> item might become handy if you want to alter the appearance of the item related to its state. For example, say you want to fill the rectangle with red when it gets selected. To do so, you only have to type this:</p><div><pre class="programlisting">void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) {
  Q_UNUSED(widget)
  if (<strong>option-&gt;state &amp; QStyle::State_Selected</strong>)
    painter-&gt;fillRect(boundingRect(), Qt::red);
  else
    painter-&gt;fillRect(boundingRect(), Qt::black);
}</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec88"/>
<em>What just happened?</em>
</h2></div></div></div><p>The <code class="literal">state</code> variable is a bitmask holding the possible states of the item. You can check its value against the values of the <code class="literal">QStyle::StateFlag</code> parameter by using bitwise operators. In the preceding case, the <code class="literal">state</code> variable is checked against the <code class="literal">State_Selected</code> parameter. If this flag is set, the rectangle is painted red.</p><div><div><h3 class="title"><a id="tip46"/>Tip</h3><p>The type of <a id="id375" class="indexterm"/>state is <code class="literal">QFlags&lt;StateFlag&gt;</code>. So, instead of using the bitwise operator to test if a flag is set, you can use the convenient function <code class="literal">testFlag()</code>. Used with the preceding example it would be as follows:</p><div><pre class="programlisting">if (option-&gt;state.testFlag(QStyle::State_Selected))</pre></div></div></div><p>The most important states you can use with items are described in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>State</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">State_Enabled</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Indicates that the item is enabled. If the item is disabled, you may want to draw it as grayed out.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">State_HasFocus</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Indicates that the item has the input focus. To receive this state, the item needs to have the <code class="literal">ItemIsFocusable</code> flag set.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">State_MouseOver</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Indicates that the cursor is currently hovering over the item. To receive this state the item needs to have the <code class="literal">acceptHoverEvents</code> variable set to <code class="literal">true</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">State_Selected</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Indicates that the item is selected. To receive this state, the item needs to have the <code class="literal">ItemIsSelectable</code> flag set. The normal behavior would be to draw a dashed line around the item as a selection marker.</p>
</td></tr></tbody></table></div><p>Besides the state, <code class="literal">QStyleOptionGraphicsItem</code> offers much more information about the currently used style, such as the palette and the font used, accessible through the <code class="literal">QStyleOptionGraphicsItem::palette</code> and <code class="literal">QStyleOptionGraphicsItem::fontMetrics</code> parameters, respectively. If you aim for style-aware items, have a deeper look at this class in the documentation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec70"/>Time for action – making the item's size definable</h1></div></div></div><p>Let's push <a id="id376" class="indexterm"/>the example of the black rectangle a step further. So far, <code class="literal">BlackRectangle</code> draws a fixed rectangle of size 75 x 25 pixels. It would be nice if one could define this size, so let us add the ability to define the size of the rectangle. Remember, only painting the rectangle larger does not help here because then you would break the promise regarding the bounding rectangle. So we need also to change the bounding rectangle as follows:</p><div><pre class="programlisting">class BlackRectangle : public QGraphicsItem {
public:
  BlackRectangle(QGraphicsItem *parent = 0)
    : QGraphicsItem(parent), m_rect(0, 0, 75, 25) {}
//...
  QRectF boundingRect() const {
    return m_rect;
  }
//...
  QRectF rect() const {
    return m_rect;
  }
  void setRect(const QRectF&amp; rect) {
    if (rect == m_rect)
      return;
    prepareGeometryChange();
    m_rect = rect;
}
private:
  QRectF m_rect;
};</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec89"/>
<em>What just happened?</em>
</h2></div></div></div><p>Since the destructor and the <code class="literal">paint</code> function are unchanged, they are omitted. What exactly have we done here? First, we introduced a private member called <code class="literal">m_rect</code> to save the current rectangle's value. In the initialization list, we set <code class="literal">m_rect</code> to a default value of <code class="literal">QRectF(0, 0, 75, 25)</code> like we hard-coded it in the first example. Since the bounding rectangle should be the same as <code class="literal">m_rect</code>, we altered <code class="literal">boundingRect()</code> to return <code class="literal">m_rect</code>. The same value is returned by the getter function <code class="literal">rect()</code>. For now it seems redundant to have two functions returning the same value, but as soon as you draw a border around the rectangle, you need to return a different bounding rectangle. It needs to be increased by the used pen's width. Therefore, we leave this redundancy in place in order to make further improvements easier. The last new part is the setter function, which is pretty standard. We check if the value has changed, and if not we exit the function. Otherwise, we set a new value, but this has to happen after the <code class="literal">prepareGeometryChange()</code> call. This call is important to inform the scene about the coming geometry change. Then, the scene will ask the item to <a id="id377" class="indexterm"/>redraw itself. We do not need to handle that part.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec90"/>Have a go hero – customizing the item</h2></div></div></div><p>As an exercise, you <a id="id378" class="indexterm"/>can try to add an option to change the background color. You can also create a new item that allows you to set an image. If doing so, keep in mind that you have to change the item's bounding rectangle according to the size of the image.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl3sec34"/>Standard items</h2></div></div></div><p>As you have <a id="id379" class="indexterm"/>seen, creating your own item involves some work, but overall it is not that difficult. A big advantage is that you can use <code class="literal">QPainter</code> to draw the item, the same technique you use to paint widgets. So there is nothing new you need to learn. Indeed, even if it is easy to draw filled rectangles or any other shape, it is a lot of work to subclass <code class="literal">QGraphicsItem</code> each time you need to create an item that does such basic tasks. And that's the reason why Qt comes with the following standard items that make your life as a developer much easier:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Standard item</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QGraphicsLineItem</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Draws a simple line. You can define the line with <code class="literal">setLine(const QLineF&amp;)</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QGraphicsRectItem</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Draws a rectangle. You can define the rectangle's geometry with <code class="literal">setRect(const QRectF&amp;)</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QGraphicsEllipseItem</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Draws an ellipse. You can define the rectangle within which the ellipse is being drawn with <code class="literal">setRect(const QRectF&amp;)</code>. Additionally, you can define whether only a segment of the ellipse should be drawn by calling <code class="literal">setStartAngle(int)</code> and <code class="literal">setSpanAngle(int)</code>. The arguments of both functions are in 16ths of a degree.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QGraphicsPolygonItem</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Draws a polygon. You can define the polygon with <code class="literal">setPolygon(const QPolygonF&amp;)</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QGraphicsPathItem</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Draws a path. You can define the path with <code class="literal">setPath(const QPainterPath&amp;)</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QGraphicsSimpleTextItem</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Draws a simple text path. You can define the text with <code class="literal">setText(const QString&amp;)</code> and the font with <code class="literal">setFont(const QFont&amp;)</code>. This item is only for drawing <em>plain</em> text without any modification.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QGraphicsTextItem</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Draws text. Unlike <code class="literal">QGraphicsSimpleTextItem</code>, this item can display HTML or render a <code class="literal">QTextDocument</code> element. You can set HTML with <code class="literal">setHtml(const QString&amp;)</code> and the document with <code class="literal">setDocument(QTextDocument*)</code>. <code class="literal">QGraphicsTextItem</code> can even interact with the displayed text so that text editing or URL opening is possible.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QGraphicsPixmapItem</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Draws a pixmap. You can define the pixmap with <code class="literal">setPixmap(const QPixmap&amp;)</code>.</p>
</td></tr></tbody></table></div><p>Since the <a id="id380" class="indexterm"/>drawing of these items is done by a <code class="literal">QPainter</code> pointer you can also define which pen and which brush should be used. The pen is set with <code class="literal">setPen(const QPen&amp;)</code> and the brush with <code class="literal">setBrush(const QBrush&amp;)</code>. These two functions, however, do not exist for <code class="literal">QGraphicsTextItem</code> and <code class="literal">QGraphicsPixmapItem</code>. To define the appearance of a <code class="literal">QGraphicsTextItem</code> item you have to use <code class="literal">setDefaultTextColor()</code> or HTML tags supported by Qt. Note that pixmaps usually do not have a pen or a brush.</p><div><div><h3 class="title"><a id="tip47"/>Tip</h3><p>Use <code class="literal">QGraphicsSimpleTextItem</code> wherever possible and try to avoid <code class="literal">QGraphicsTextItem</code> if it is not absolutely necessary. The reason is that <code class="literal">QGraphicsTextItem</code> lugs a <code class="literal">QTextDocument</code> object around and it is, besides being a subclass of <code class="literal">QGraphicsItem</code>, also a subclass of <code class="literal">QObject</code>. This is definitely too much overhead and has too high a performance cost for displaying simple text.</p></div></div><p>A word on how you set up items. Instead of writing two expressions, one for the initialization of the item and one for setting up its key information such as the rectangle for a <code class="literal">QGraphicsRextItem</code> item or the pixmap for a <code class="literal">QGraphicsPixmapItem</code>, almost all standard items offer you the option to pass that key information as a first argument to their constructors—besides the optional last argument for setting the item's parent. Say you would have written the following code:</p><div><pre class="programlisting">QGraphicsRectItem *item = new QGraphicsRectItem();
item-&gt;setRect(QRectF(0, 0, 25, 25));</pre></div><p>You can now simply write this:</p><div><pre class="programlisting">QGraphicsRectItem *item = new QGraphicsRectItem(QRectF(0, 0, 25, 25));</pre></div><p>You can even just write this:</p><div><pre class="programlisting">QGraphicsRectItem *item = new QGraphicsRectItem(0, 0, 25, 25);</pre></div><p>This is very convenient, but keep in mind that compact code may be harder to maintain than code that sets all variables through setter methods.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl3sec35"/>Coordinate system of the items</h2></div></div></div><p>A last but <a id="id381" class="indexterm"/>very important note on the used coordinate system. Altogether, Graphics View deals with three different but connected coordinate systems. There is the item's coordinate system, the scene's coordinate system, and the view's coordinate system. All three coordinate systems differ from the Cartesian coordinate systems regarding the <em>y</em> axis: in Graphics View, like in <code class="literal">QPainter</code> pointer's coordinate system, the <em>y</em> axis is orientated and measured from the origin to the bottom. This means that a point below the origin has a positive <em>y</em> value. For now, we only care about the item's coordinate system. Since Graphics View is for 2D graphics, we have an <em>x</em> coordinate and a <em>y</em> coordinate with the origin at (0, 0). All points, lines, rectangles, and so on are specified in the item's own coordinate system. This applies to almost all occasions where you deal with values representing coordinates within the <code class="literal">QGraphicsItem</code> class or its derived classes. If you define, for example, the rectangle of a <code class="literal">QGraphicsRectItem</code> item, you use item coordinates. If an item receives a mouse press event, <code class="literal">QGraphicsSceneMouseEvent::pos()</code> is expressed in item coordinates. But there are some easy-to-identify exceptions to this statement. The return value of <code class="literal">scenePos()</code> and <code class="literal">sceneBoundingRect()</code> is expressed in scene coordinates. Pretty obvious, isn't it? The one thing that is a little bit tricky to identify is the returned <code class="literal">QPointF</code> pointer of <code class="literal">pos()</code>. The coordinates of this point are expressed in the item's parent coordinate system. This can be either the parent item's coordinate system or, more likely, the scene's coordinate system when the item does not have a parent item.</p><p>For a better understanding of <code class="literal">pos()</code> and the involved coordinate systems, think of Post-it notes again. If you put a note on a larger sheet of paper and then had to determine its exact position, how would you do it? Probably somewhat like this: "The note's upper left corner is positioned 3 cm to the right and 5 cm to the bottom from the paper's top left edge". In the Graphics View world, this would correspond to a parentless item whose <code class="literal">pos()</code> function returns a position in scene coordinates since the item's origin is directly pinned to the scene. On the other hand, say you put a note A on top of a (larger) note B, which is already pinned on a paper, and you have to determine A's position; how would you describe it this time? Probably by saying that note A is placed on top of note B or "2 cm to the right and 1 cm to the bottom from the top-left edge of note B". You most likely wouldn't use the underlying paper as a reference since it is not the next point of reference. This is because, if you move note B, A's position regarding the paper will change whereas A's relative position to B still remains unchanged. To switch back to Graphics View, the equivalent situation is an item that has a parent item. In this case, the <code class="literal">pos()</code> function's returned value is expressed in the coordinate system of its parent. So <code class="literal">setPos()</code> and <code class="literal">pos()</code> specify the position of the item's origin in relation to the next (higher) point of reference. This could be the scene or the item's parent item.</p><p>Keep in mind, however, that changing an item's position does not affect the item's internal coordinate system.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec71"/>Time for action – creating items with different origins</h1></div></div></div><p>Let's have a <a id="id382" class="indexterm"/>closer look at these three items defined by the following code snippet:</p><div><pre class="programlisting">QGraphicsRectItem *itemA = QGraphicsRectItem(-10, -10, 20, 20);
QGraphicsRectItem *itemB = QGraphicsRectItem(0, 0, 20, 20);
QGraphicsRectItem *itemC = QGraphicsRectItem(10, 10, 20, 20);</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec91"/>
<em>What just happened?</em>
</h2></div></div></div><p>All three items are rectangles with a side length of 20 pixels. The difference between them is the position of their coordinate origin points. <code class="literal">itemA</code> has its origin in the center of the rectangle, <code class="literal">itemB</code> has its origin in the top-left corner of the rectangle, and <code class="literal">itemC</code> has its origin outside the drawn rectangle. In the following diagram, you see the origin points marked as red dots.</p><div><img src="img/8874OS_06_11.jpg" alt="What just happened?"/></div><p>So what's the deal with these origin points? On the one hand, the origin point is used to create a relation between the item's coordinate system and the scene's coordinate system. As you will see later in more detail, if you set the position of the item on the scene, the position on the scene is the origin of the item. You can say scene <em>(x, y) = item(0, 0)</em>. On the other hand, the origin point is used as a center point for all transformations you can use with items, such as scaling, rotating, or adding a freely definable transformation matrix of <code class="literal">QTransform</code> type. As an additional feature, you always have the option to combine a new transformation with the already applied ones or to replace the old transformation(s) with a new one.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec72"/>Time for action – rotating an item</h1></div></div></div><p>As an <a id="id383" class="indexterm"/>example, let's rotate <code class="literal">itemB</code> and <code class="literal">itemC</code> by 45 degrees counter-clockwise. For <code class="literal">itemB</code>, the function call would look like this:</p><div><pre class="programlisting">itemB-&gt;setRotation(-45);</pre></div><p>The <code class="literal">setRotation()</code> function accepts <code class="literal">qreal</code> as the argument value, so you can set very precise values. The function interprets the number as degrees for a clockwise rotation around the <em>z</em> coordinate. If you set a negative value, a counter-clockwise rotation is performed. Even if it does not make much sense, you can rotate an item by 450 degrees, which would result in a rotation of 90 degrees. Here is what the two items would look like after the rotation by 45 degrees counter-clockwise:</p><div><img src="img/8874OS_06_14.jpg" alt="Time for action – rotating an item"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec92"/>
<em>What just happened?</em>
</h2></div></div></div><p>As you can see, the rotation has its center in the item's origin point. Now you could run into the problem that you want to rotate the rectangle of <code class="literal">itemC</code> around its center point. In such a situation, you can use <code class="literal">setTransformOriginPoint()</code>. For the described problem, the relevant code would look like this:</p><div><pre class="programlisting">QGraphicsRectItem *itemC = QGraphicsRectItem(10, 10, 20, 20);
itemC-&gt;setTransformOriginPoint(20, 20);
itemC-&gt;rotate(-45);</pre></div><p>Let us take this opportunity to recapitulate the item's coordinate system. The item's origin point is in (0, 0). In the constructor of <code class="literal">QGraphicsRectItem</code>, you define that the rectangle should have its top-left corner at (10, 10). And since you gave the rectangle a width and a height of 20 pixels, its <a id="id384" class="indexterm"/>bottom-right corner is at (30, 30). This makes (20, 20) the center of the rectangle. After setting the transformation's origin point to (20, 20), you rotate the item around that point 45 degrees counter-clockwise. You will see the result in the following image, where the transformation's origin point is marked with a cross.</p><div><img src="img/8874OS_06_15.jpg" alt="What just happened?"/></div><p>Even if you "change" the item's origin point by such a transformation, this does not affect the item's position on the scene. First, the scene positions the untransformed item with respect to its origin point and only then are all transformations applied to the item.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec93"/>Have a go hero – applying multiple transformations</h2></div></div></div><p>To understand the <a id="id385" class="indexterm"/>concept of transformations and their origin point, go ahead and try it yourself. Apply <code class="literal">rotate()</code> and <code class="literal">scale()</code> sequentially to an item. Also, change the point of origin and see how the item will react. As a second <a id="id386" class="indexterm"/>step, use <code class="literal">QTransform</code> in conjunction with <code class="literal">setTransform()</code> to add a custom transformation to an item.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec94"/>Scenes</h2></div></div></div><p>Let us take a <a id="id387" class="indexterm"/>look at how we can improvise the scene.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec36"/>Adding items to the scene</h3></div></div></div><p>At this point, you <a id="id388" class="indexterm"/>should have a basic understanding of items. The next <a id="id389" class="indexterm"/>question is what to do with them. As described earlier, you put <a id="id390" class="indexterm"/>the items on a <code class="literal">QGraphicsScene</code> method. This is done by calling <code class="literal">addItem(QGraphicsItem *item)</code>. Did you notice the type of the argument? It's a pointer to a <code class="literal">QGraphicsItem</code> method. Since all items on the scene must inherit <code class="literal">QGraphicsItem</code>, you can use this function with any item, be it a <code class="literal">QGraphicsRectItem</code> item or any custom item. If you have a look at the documentation of <code class="literal">QGraphicsScene</code>, you will notice that all functions returning items or dealing with them expect pointers to a <code class="literal">QGraphicsItem</code> item. This universal usability is a huge advantage of the object-orientated approach in Graphics View.</p><div><div><h3 class="title"><a id="tip48"/>Tip</h3><p>If you have a pointer of the type <code class="literal">QGraphicsItem</code> pointing to an instance of a <code class="literal">QGraphicsRectItem</code> and you want to use a function of <code class="literal">QGraphicsRectItem</code>, use <code class="literal">qgraphicsitem_cast&lt;&gt;()</code> to cast the pointer. This is because it is safer and faster than using <code class="literal">static_cast&lt;&gt;()</code> or <code class="literal">dynamic_cast&lt;&gt;()</code>.</p><div><pre class="programlisting">QGraphicsItem *item = new QGraphicsRectItem(0, 0, 5, 5);
QGraphicsRectItem *rectItem = qgraphicsitem_cast&lt;QGraphicsRectItem*&gt;(item);
if (rectItem)
  rectItem-&gt;setRect(0, 0, 10, 15);</pre></div><p>Please note that if you want to use <code class="literal">qgraphicsitem_cast&lt;&gt;()</code> with your own custom item, you have to make sure that <code class="literal">QGraphicsItem::type()</code> is reimplemented and that it returns a unique type for a particular item. To ensure a unique type, use <code class="literal">QGraphicsItem::UserType + x</code> as a return value where you count up <code class="literal">x</code> for every custom item you create.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec73"/>Time for action – adding an item to a scene</h1></div></div></div><p>Let's have a <a id="id391" class="indexterm"/>first try and add an item to the scene:</p><div><pre class="programlisting">QGraphicsScene scene;
QGraphicsRectItem *rectItem = new QGraphicsRectItem(0,0,50,50);
scene.addItem(rectItem);</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec95"/>
<em>What just happened?</em>
</h2></div></div></div><p>Nothing complicated here. You create a scene, create an item of type <code class="literal">QGraphicsRectItem</code>, define the geometry of the item's rectangle, and then set the item to the scene by calling <code class="literal">addItem()</code>. Pretty straightforward. But what you do not see here is what this implies for the scene. The scene is now responsible for the added item! First of all, the ownership of the item is transferred to the scene. For you, this means that you do not have to worry about freeing the item's memory because deleting the scene also deletes all items associated with the scene. Now remember what we said about the destructor of a custom item: it must be virtual! <code class="literal">QGraphicsScene</code> operates with pointers to <code class="literal">QGraphicsItem</code>. Thus, when it deletes the assigned items, it does that by calling <code class="literal">delete</code> on the base class pointer. If you have not declared the destructor of the derived class virtual, it will not be executed, which may cause memory leaks. Therefore, form habit of declaring the destructor virtual.</p><p>Transferring the <a id="id392" class="indexterm"/>ownership of the item to the scene also means that an item can only be added to one single scene. If the item was previously already added to another scene, it gets removed from there before it will be added to the new scene. The following code will demonstrate that:</p><div><pre class="programlisting">QGraphicsScene firstScene;
QGraphicsScene secondScene;
QGraphicsRectItem *item = new QGraphicsRectItem;
firstScene.addItem(item);
<strong>qDebug() &lt;&lt; firstScene.items().count();</strong> // 1
secondScene.addItem(item);
qDebug() &lt;&lt; firstScene.items().count(); // 0</pre></div><p>After creating two scenes and one item, we add the item <code class="literal">item</code> to the scene <code class="literal">firstScene</code>. Then, with the debug message, we print out the number of associated items with that <code class="literal">firstScene</code> scene. For this, we call <code class="literal">items()</code> on the scene, which returns a <code class="literal">QList</code> list with pointers to all items of the scene. Calling <code class="literal">count()</code> on that list tells us the size of the list, which is equivalent to the number of added items. As you can see after adding the item on <code class="literal">secondScene</code>, the <code class="literal">firstScene</code> item count returns <code class="literal">0</code>. Before <code class="literal">item</code> was added to <code class="literal">secondScene</code>, it was first removed from <code class="literal">firstScene</code>.</p><div><div><h3 class="title"><a id="tip50"/>Tip</h3><p>If you want to remove an item from a scene without setting it directly to another scene or without deleting it, you can call <code class="literal">removeItem()</code>, which takes a pointer for the item that should be removed. Be aware, however, that now it is your responsibility to delete the item in order to free the allocated memory!</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl3sec37"/>Interacting with items on the scene</h2></div></div></div><p>When it takes <a id="id393" class="indexterm"/>ownership of an item, the scene also has to take care of a lot of other stuff. The scene has to make sure that events get delivered to the right items. If you click on a scene (to be precise, you click on a view that propagates the event to the scene), the scene receives the mouse press event and it then becomes the scene's responsibility to determine which item was meant by the click. In order to be able to do that, the scene always needs to know where all the items are. Therefore, the scene keeps track of the items in a Binary Space Partitioning tree.</p><p>You can benefit from this knowledge too! If you want to know which item is shown at a certain position, call <code class="literal">itemAt()</code> with <code class="literal">QPointF</code> as an argument. You will receive the topmost item at that position. If you want all items that are located at this position, say in cases where multiple items are on top of each other, call an overloaded function of <code class="literal">items()</code> (which takes a <code class="literal">QPointF</code> pointer as an argument). It will return a list of all items that the bounding rectangle contains that point. The <code class="literal">items()</code> function also accepts <code class="literal">QRectF</code>, <code class="literal">QPolygonF</code>, and <code class="literal">QPainterPath</code> as arguments if you need all visible items of an area. With the second argument of the type <code class="literal">Qt::ItemSelectionMode</code>, you can alter the mode for how the items in the area will be determined. The following table shows the different modes:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Mode</p>
</th><th style="text-align: left" valign="bottom">
<p>Meaning</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Qt::ContainsItemShape</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The item's shape must be completely inside the selection area.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Qt::IntersectsItemShape</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Similar to <code class="literal">Qt::ContainsItemShape</code> but also returns items whose shapes intersect with the selection area.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Qt::ContainsItemBoundingRect</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The item's bounding rectangle must be completely inside the selection area.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Qt::IntersectsItemBoundingRect</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Similar to <code class="literal">Qt::ContainsItemBoundingRect</code> but also returns items whose bounding rectangles intersect with the selection area.</p>
</td></tr></tbody></table></div><p>The scene's responsibility for delivering events does not only apply to mouse events; it also applies to key events and all other sorts of events. The events that are passed to the items are subclasses of <code class="literal">QGraphicsSceneEvent</code>. Thus, an item does not get a <code class="literal">QMouseEvent</code> event like widgets; it gets a <code class="literal">QGraphicsSceneMouseEvent</code> event. In general, these scene events behave like normal events, but instead of say a <code class="literal">globalPos()</code> function you have <code class="literal">scenePos()</code>.</p><p>The scene also handles the selection of items. To be selectable, an item must have the <code class="literal">QGraphicsItem::ItemIsSelectable</code> flag turned on. You can do that by calling <code class="literal">QGraphicsItem::setFlag()</code> with the flag and <code class="literal">true</code> as arguments. Besides that, there are different ways to select items. There is the item's <code class="literal">QGraphicsItem::setSelected()</code> function, which takes a <code class="literal">bool</code> value to toggle the selection state on or off, or you can call <code class="literal">QGraphicsScene::setSelectionArea()</code> on the scene, which takes a <code class="literal">QPainterPath</code> parameter as argument, in which case all items get selected. With the mouse, you can click on an item to select or deselect it or—if the view's rubber-band selection mode is enabled—you can select multiple items with that rubber band.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>For activating the rubber band selection for the view, call <code class="literal">setDragMode</code> <code class="literal">(QGraphicsView::RubberBandDrag)</code> on the view. Then you can press the left mouse button and, while holding it down, move the mouse to define the selection area. The selection rectangle is then defined by the point of the first mouse press and the current mouse position.</p></div></div><p>With the scene's <code class="literal">QGraphicsScene::selectedItems()</code> function, you can query the actual selected items. The function returns a <code class="literal">QList</code> list holding <code class="literal">QGraphicsItem</code> pointers to selected items. For example, calling <code class="literal">QList::count()</code> on that list would give you the number of selected <a id="id394" class="indexterm"/>items. To clear the selection, call <code class="literal">QGraphicsScene::clearSelection()</code>. To query the selection state of an item, use <code class="literal">QGraphicsItem::isSelected()</code>, which returns <code class="literal">true</code> if the item is selected and <code class="literal">false</code> otherwise. If you write a customized <code class="literal">paint</code> function, do not forget to alter the item's appearance to indicate that it is selected. Otherwise, the user cannot know this. The determination inside the paint function is done by <code class="literal">QStyle::State_Selected</code>, as shown earlier.</p><div><img src="img/8874OS_06_10.jpg" alt="Interacting with items on the scene"/><div><p>The standard items show a dashed rectangle around a selected item.</p></div></div><p>The item's handling of focus is done in a similar way. To be focusable an item must have the <code class="literal">QGraphicsItem::ItemIsFocusable</code> flag enabled. Then, the item can be focused by a mouse click, through the item's <code class="literal">QGraphicsItem::setFocus()</code> function, or through the scene's <code class="literal">QGraphicsScene::setFocusItem()</code> function, which expects a pointer to the item you like to focus as a parameter. To determine if an item has focus, you again have two possibilities. One is that you can call <code class="literal">QGraphicsItem::hasFocus()</code> on an item, which returns <code class="literal">true</code> if the item has focus or <code class="literal">false</code> otherwise. Alternatively, you can get the actual focused item by calling the scene's <code class="literal">QGraphicsScene::focusItem()</code> method. On the other hand, if you call the item's <code class="literal">QGraphicsItem::focusItem()</code> function, the focused item is returned if the item itself or any descendant item has focus; otherwise, <code class="literal">0</code> is returned. To remove focus, call <code class="literal">clearFocus()</code> on the focused item or click somewhere in the scene's <a id="id395" class="indexterm"/>background or on an item that cannot get focus.</p><div><div><h3 class="title"><a id="tip51"/>Tip</h3><p>If you want a click on the scene's background not to cause the focused item to lose its focus, set the scene's <code class="literal">stickyFocus</code> property to <code class="literal">true</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl3sec38"/>Rendering</h2></div></div></div><p>It is also the scene's <a id="id396" class="indexterm"/>responsibility to render itself with all the assigned items.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec74"/>Time for action – rendering the scene's content to an image</h1></div></div></div><p>Let's try to <a id="id397" class="indexterm"/>render a scene to an image. In order to do that, we take the following code snippet from our first example where we tried to put items on a scene:</p><div><pre class="programlisting">QGraphicsScene scene;
QGraphicsRectItem *rectItem = new QGraphicsRectItem();
rectItem-&gt;setRect(0,0,50,50);
<strong>rectItem-&gt;setBrush(Qt::green);</strong>
<strong>rectItem-&gt;setPen(QColor(255,0,0));</strong>
scene.addItem(rectItem);</pre></div><p>The only change we make here is that we set a brush resulting in a green-filled rectangle with a red border, which was defined through <code class="literal">setBrush()</code> and <code class="literal">setPen()</code>. You can also define the thickness of the stroke by passing a <code class="literal">QPen</code> object with the corresponding arguments. To render the scene, you only need to call <code class="literal">render()</code>, which takes a pointer to a <code class="literal">QPainter</code> pointer. This way, the scene can render its contents to any paint device the painter is pointing to. For us, a simple PNG file will do the job.</p><div><pre class="programlisting">QRect rect = scene.sceneRect().toAlignedRect();
QImage image(rect.size(), QImage::Format_ARGB32);
image.fill(Qt::transparent);
QPainter painter(&amp;image);
scene.render(&amp;painter);
image.save("scene.png", "PNG");</pre></div><div><img src="img/8874OS_06_13.jpg" alt="Time for action – rendering the scene's content to an image"/><div><p>Result of the rendering</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec96"/>
<em>What just happened?</em>
</h2></div></div></div><p>First you determined the rectangle of the scene with <code class="literal">sceneRect()</code>. Since this returns a <code class="literal">QRectF</code> parameter and <code class="literal">QImage</code> can only handle <code class="literal">QRect</code>, you transformed it on-the-fly by calling <code class="literal">toAlignedRect()</code>. The difference between the <code class="literal">toRect()</code> function and <code class="literal">toAlignedRect()</code> is that the former rounds to the nearest integer, which may result in a smaller rectangle whereas the latter expands to the smallest possible rectangle containing the original <code class="literal">QRectF</code> parameter. Then, you created a <code class="literal">QImage</code> file with the size of the aligned scene's rectangle. Because the image is created with uninitialized data, you need to call <code class="literal">fill()</code> with <code class="literal">Qt::transparent</code> to receive a transparent image. You can assign any color you like as <a id="id398" class="indexterm"/>an argument both a value of <code class="literal">Qt::GlobalColor</code> enumeration and an ordinary <code class="literal">QColor</code> object; <code class="literal">QColor(0, 0, 255)</code> would result in a blue background. Next, you create a <code class="literal">QPainter</code> object which points to the image. This painter object is now used in the scene's <code class="literal">render()</code> function to draw the scene. After that, all you have to do is to save the image to a place of your choice. The file name (which can also contain an absolute path such as <code class="literal">/path/to/image.png</code>) is given by the first argument whereas the second argument determines the format of the image. Here, we set the file name to <code class="literal">scene.png</code> and choose the PNG format. Since we haven't specified a path, the image will be saved in the application's current directory.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec97"/>Have a go hero – rendering only specific parts of a scene</h2></div></div></div><p>This example <a id="id399" class="indexterm"/>draws the whole scene. Of course, you can also render only specific parts of the scene by using the other arguments of <code class="literal">render()</code>. We will not go into this here but you may want to try it as an exercise.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl3sec39"/>Coordinate system of the scene</h2></div></div></div><p>What is left is a <a id="id400" class="indexterm"/>look at the coordinate system of the scene. Like the items, the scene lives in its own coordinate system with the origin at (0, 0). Now when you add an item via <code class="literal">addItem()</code>, the item is positioned at the scene's (0, 0) coordinate. If you want to move the item to another position on the scene, call <code class="literal">setPos()</code> on the item.</p><div><pre class="programlisting">QGraphicsScene scene;
QGraphicsRectItem *item = QGraphicsRectItem(0, 0, 10, 10);
scene.addItem(item);
item.setPos(50,50);</pre></div><p>After creating the scene and the item, you add the item to the scene by calling <code class="literal">addItem()</code>. At this stage, the scene's origin and the item's origin are stacked on top of each other at (0, 0). By calling <code class="literal">setPos()</code>, you move the item 50 pixels right and down. Now the item's origin is at (50, 50) in scene coordinates. If you need to know the position of the bottom-right corner of the item's rectangle in scene coordinates, you have to do a quick calculation. In the item's coordinate system, the bottom right corner is at (10, 10). The item's origin point is (0, 0) in the item's coordinate system, which corresponds to the point (50, 50) in the scene's coordinate system. So you just have to take (50, 50) and add (10,10) to get (60, 60) as <a id="id401" class="indexterm"/>the scene's coordinates for the bottom-right corner of the item. This is an easy calculation, but it quickly gets complicated when you rotate, scale, and/or shear the item. Because of this, you should use one of the convenience functions provided by <code class="literal">QGraphicsItem</code>:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Function</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">mapToScene(const QPoint &amp;point)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Maps the point <code class="literal">point</code> that is in the item's coordinate system to the corresponding point in the scene's coordinate system.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">mapFromScene(const QPoint &amp;point)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Maps the point <code class="literal">point</code> that is in the scene's coordinate system to the corresponding point in the item's coordinate system. This function is the reverse function to <code class="literal">mapToScene()</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">mapToParent(const QPoint &amp;point)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Maps the point <code class="literal">point</code> that is in the item's coordinate system to the corresponding point in the coordinate system of the item's parent. If the item does not have a parent, this function behaves like <code class="literal">mapToScene()</code>; thus, it returns the corresponding point in the scene's coordinate system.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">mapFromParent(const QPoint &amp;point)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Maps the point <code class="literal">point</code> that is in the coordinate system of the item's parent to the corresponding point in the item's own coordinate system. This function is the reverse function to <code class="literal">mapToParent()</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">mapToItem(const QGraphicsItem *item, const QPointF &amp;point)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Maps the point <code class="literal">point</code> that is in the item's own coordinate system to the corresponding point in the coordinate system of the item <code class="literal">item</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">mapFromItem(const QGraphicsItem *item, const QPointF &amp;point)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Maps the point <code class="literal">point</code> which is in the coordinate system of the item <code class="literal">item</code> to the corresponding point in the item's own coordinate system. This function is the reverse function to <code class="literal">mapToItem()</code>.</p>
</td></tr></tbody></table></div><p>What is great about these functions is that they are not only available for <code class="literal">QPointF</code>. The same functions are also available for <code class="literal">QRectF</code>, <code class="literal">QPolygonF</code>, and <code class="literal">QPainterPath</code>. Not to mention that these are of course convenience functions: If you call these functions with two numbers of the type <code class="literal">qreal</code>, the numbers get interpreted as the <em>x</em> and <em>y</em> coordinates of a <code class="literal">QPointF</code> pointer; if you call the functions with four numbers, the numbers get interpreted as the <em>x</em> and <em>y</em> coordinates and the width and the height of a <code class="literal">QRectF</code> parameter.</p><p>Since the positioning <a id="id402" class="indexterm"/>of the items is done by the items themselves, it is possible that an item independently moves around. Do not worry; the scene will get notified about any item position change. And not only the scene! Remember the parent-child relationship of items and that parents delete their child items when they get destroyed themselves? It's the same with <code class="literal">setPos()</code>. If you move a parent, all child items get moved as well. This can be very useful if you have a bunch of items that should stay together. Instead of moving all items by themselves, you only have to move one item. Since transformations that you apply on a parent also affect the children, this might not be the best solution for grouping together equal items that should be independently transformable but also transformable altogether. The solution for such a case is <code class="literal">QGraphicsItemGroup</code>. It behaves like a parent in a parent-child relationship. The <code class="literal">QGraphicsItemGroup</code> is an invisible parent item so that you can alter the child items separately through their transformation functions or all together by invoking the transformation functions of <code class="literal">QGraphicsItemGroup</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec75"/>Time for action – transforming parent items and child items</h1></div></div></div><p>Have <a id="id403" class="indexterm"/>a <a id="id404" class="indexterm"/>look at the following code:</p><div><pre class="programlisting">QGraphicsScene scene;
QGraphicsRectItem *rectA = new QGraphicsRectItem(0,0,45,45);
QGraphicsRectItem *rectB = new QGraphicsRectItem(0,0,45,45);
QGraphicsRectItem *rectC = new QGraphicsRectItem(0,0,45,45);
QGraphicsRectItem *rectD = new QGraphicsRectItem(0,0,45,45);
rectB-&gt;moveBy(50,0);
rectC-&gt;moveBy(0,50);
rectD-&gt;moveBy(50,50);
<strong>QGraphicsItemGroup *group = new QGraphicsItemGroup;</strong>
<strong>group-&gt;addToGroup(rectA);</strong>
group-&gt;addToGroup(rectB);
group-&gt;addToGroup(rectC);
<strong>rectD-&gt;setGroup(group);</strong>
<strong>group-&gt;setRotation(70);</strong>
<strong>rectA-&gt;setRotation(-25);</strong>
<strong>rectB-&gt;setRotation(-25);</strong>
<strong>rectC-&gt;setRotation(-25);</strong>
<strong>rectD-&gt;setRotation(-25);</strong>
scene.addItem(group);</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec98"/>
<em>What just happened?</em>
</h2></div></div></div><p>After creating a scene, we create four rectangle items that are arranged in a 2 x 2 matrix. This is done with the calls of the <code class="literal">moveBy()</code> function, which interprets the first argument as a shift to the right or left when negative and the second argument as a shift to the bottom or top when negative. Then we create a new <code class="literal">QGraphicsItemGroup</code> item which, since it subclasses <code class="literal">QGraphicsItem</code>, is a regular item and can be used as such. By calling <code class="literal">addToGroup()</code>, we add the items that we want to position inside that group. If you'd like to remove an item from the group later on, simply call <code class="literal">removeFromGroup()</code> and pass the respective item. The <a id="id405" class="indexterm"/>
<code class="literal">rectD</code> parameter is added to the group in a <a id="id406" class="indexterm"/>different way. By calling <code class="literal">setGroup()</code> on <code class="literal">rectD</code>, it gets assigned to <code class="literal">group</code>; this behavior is comparable to <code class="literal">setParent()</code>. If you want to check whether an item is assigned to a group, just call <code class="literal">group()</code> on it. It will return a pointer to the group or <code class="literal">0</code> if the item is not in a group. After adding the group to the scene, and thus also the items, we rotate the whole group by 70 degrees clockwise. Afterward, all items are separately rotated 25 degrees counter-clockwise around their top left corner. This will result in the following appearance:</p><div><img src="img/8874OS_06_09.jpg" alt="What just happened?"/><div><p>Here you see the initial state after moving the items, then after rotating the group by 70 degrees, and then after rotating each item by -25 degrees</p></div></div><p>If we were to rotate the items more, they would overlap each other. But which item would overlap which? This is defined by the item's <em>z</em> value; you can define the value by using <code class="literal">QGraphicsItem::setZValue()</code> otherwise it is <code class="literal">0</code>. Based on that, the items get stacked. Items with a higher <em>z</em> value are displayed on top of items with lower <em>z</em> values. If items have the same <em>z</em> value, the order of insertion decides the placement: items added later overlap those added earlier. Also, negative values are possible.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec99"/>Have a go hero – playing with the z value</h2></div></div></div><p>Take the <a id="id407" class="indexterm"/>item group from the example as a starting point and apply various transformations to it as well as different <em>z</em> values for the item. You will be astonished at what crazy geometrical figures you can create with these four items. Coding really is fun!</p><p>For the sake of completeness, a word on the scene's bounding rectangle is required (set through <code class="literal">setSceneRect()</code>). Just as the offset of an item's bounding rectangle affects its position on the scene, the offset of the scene's bounding rectangle affects the scene's position on the view. More importantly, however, the bounding rectangle is used for various internal computations, such as the calculation of the view's scroll bar value and position. Even if you do not have to set the scene's bounding rectangle, it is recommended that you do. This applies especially when your scene holds a lot of items. If you do not set a bounding rectangle, the scene calculates this itself by going through all the items, retrieving their positions and their bounding rectangles as well as their transformations to figure out the maximum occupied space. This calculation is done by the function <code class="literal">itemsBoundingRect()</code>. As you may imagine, this becomes increasingly resource-intensive the more items a scene has. Furthermore, if you do not set the scene's rectangle, the scene checks on each item's update if the item is still in the scene's rectangle. Otherwise, it enlarges the rectangle to hold the item inside the bounding rectangle. The downside to is that it will never adjust by shirking; it will only enlarge. Thus, when you move an item to the outside and then to the inside again, you will mess up the scroll bars.</p><div><div><h3 class="title"><a id="tip52"/>Tip</h3><p>If you do not want to calculate the size of your scene yourself, you can add all items to the scene and then call <code class="literal">setSceneRect()</code> with <code class="literal">itemsBoundingRect()</code> as an argument. With this, you stop the scene from checking and updating the maximum bounding rectangle on item updates.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec100"/>View</h2></div></div></div><p>With <a id="id408" class="indexterm"/>
<code class="literal">QGraphicsView</code>, we are back in the world of widgets. Since <code class="literal">QGraphicsView</code> inherits <code class="literal">QWidget</code>, you can use the view like any other widget and place it into layouts for creating neat graphical user interfaces. For the Graphics View architecture, <code class="literal">QGraphicsView</code> provides an inspection window on a scene. With the view, you can display the <a id="id409" class="indexterm"/>whole scene or only part of it, and by using a transformation matrix you can manipulate the scene's coordinate system. Internally, the view uses <code class="literal">QGraphicsScene::render()</code> to visualize the scene. By default, the view uses a <code class="literal">QWidget</code> element as a painting device. Since <code class="literal">QGraphicsView</code> inherits <code class="literal">QAbstractScrollArea</code>, the widget is set as its viewport. Therefore, when the rendered scene exceeds the view's geometry, scroll bars are automatically shown.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Instead of using the default <code class="literal">QWidget</code> element as the viewport widget, you can set your own widget by calling <code class="literal">setViewport()</code> with the custom one as an argument. The <a id="id410" class="indexterm"/>view will then take ownership of the assigned widget, which is accessible by <code class="literal">viewport()</code>. This also gives you the opportunity to use OpenGL for rendering. Simply call <code class="literal">setViewport(new QGLWidget)</code>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec76"/>Time for action – putting it all together!</h1></div></div></div><p>Before we go on, however, and after talking a lot about items and scenes, let's see how the view, the scene, and the <a id="id411" class="indexterm"/>items all work together:</p><div><pre class="programlisting">#include &lt;QApplication&gt;
#include &lt;QGraphicsView&gt;
#include &lt;QGraphicsRectItem&gt;
int main(int argc, char *argv[]) {
  QApplication app(argc, argv);
  QGraphicsScene scene;
  scene.addEllipse(QRectF(0, 0, 100, 100), QColor(0, 0, 0));
  scene.addLine(0, 50, 100, 50, QColor(0, 0, 255));
  QGraphicsRectItem *item = scene.addRect(0, 0, 25, 25, Qt::NoPen, Qt::red);
  item-&gt;setPos(scene.sceneRect().center() - item-&gt;rect().center());
  QGraphicsView view;
  view.setScene(&amp;scene);
  view.show();
  return app.exec();
}</pre></div><p>Build and run this example and you will see following image in the middle of the view:</p><div><img src="img/8874OS_06_06.jpg" alt="Time for action – putting it all together!"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec101"/>
<em>What just happened?</em>
</h2></div></div></div><p>What have we done here? On top, we included the needed headers and then wrote a normal main function and created a <code class="literal">QApplication</code> elment. Its event loop is started in the return statement on the bottom. In between, we created a scene and added the first item to it by calling <code class="literal">addEllipse()</code>. This function is one of the many convenience functions of Qt and is, in our case, equivalent to the following code:</p><div><pre class="programlisting">QGraphicsEllipseItem *item = new QGraphicsEllipseItem;
item-&gt;setRect(0, 0, 100, 100);
item-&gt;setPen(QColor(0, 0, 0));
scene.addItem(item);</pre></div><p>We thus have put a circle with a radius of 50 pixels in the scene. The origins of the circle and of the scene are stacked on top of each other. Next, by calling <code class="literal">addLine()</code>, we add a blue line that goes through the center point of the circle, parallel to the scene's bottom line. The first two arguments are the <em>x</em> and <em>y</em> coordinates of the line's starting point and the second two arguments the <em>x</em> and <em>y</em> coordinates of the end point. With <code class="literal">addRect()</code>, we add a square with a 25-pixel side at the top-left corner of the scene. This time, however, we fetch the pointer, which is then returned by these functions. This is because we want to move the rectangle to the <a id="id412" class="indexterm"/>center of the scene. In order to do that, we use <code class="literal">setPos()</code> and need to do some arithmetic. Why? Because of the relationship between the scene's and the item's coordinate systems. By simply calling <code class="literal">item-&gt;setPos(scene.sceneRect().center())</code>, the origin of the item (which is (0, 0) in the item's coordinates and thus the rectangle's top left corner) would be in the middle of the scene, not the red square itself. Thus we need to shift the rectangle back by half of its width and height. This is done by subtracting its center point from the scene's center point. As you probably have already guessed, <code class="literal">QRectF::center()</code> returns the center point of a rectangle as a <code class="literal">QPointF</code> pointer. Lastly, we create a view and declare that it should display the scene by calling <code class="literal">setScene()</code> with the scene as an argument. Then we show the view. That's all you need to do to show a scene with items.</p><p>Two things you will probably notice if you have a look at the result are that the drawing looks pixelated and that it stays in the center of the view when you resize the view. The solution for the first problem you should already know from what you learned in the previous chapter. You have to turn on antialiasing. For the view, you do that with this line of code </p><div><pre class="programlisting">view.setRenderHint(QPainter::Antialiasing);</pre></div><p>With <code class="literal">setRenderHint()</code>, you can set all hints you know from <code class="literal">QPainter</code> to the view. Before the view renders the scene on its viewport widget, it initializes the internally used <code class="literal">QPainter</code> element with these hints. With the antialiasing flag turned on, the painting is done much more smoothly. Unfortunately, the line is also painted antialiased (even though we do not want this since now the line looks washy). To prevent the line from getting drawn antialiased, you have to override the <code class="literal">paint()</code> function of the item and explicitly turn off antialiasing. However, you might want to have a line with aliasing somewhere, so there is another small and easy solution for that problem without the need for reimplementing the <code class="literal">paint</code> function. All you have to do is to shift the position by half of the pen's width. For that, write the following code:</p><div><pre class="programlisting">QGraphicsLineItem *line = scene.addLine(0, 50, 100, 50, QColor (0, 0, 255));
const qreal shift = line-&gt;pen().widthF() / 2.0;
line-&gt;moveBy(-shift, -shift);</pre></div><p>By calling <code class="literal">pen()</code>, you get the pen that is used to draw the line. Then you determine its width by calling <code class="literal">widthF()</code> and dividing it by 2. Then just move the line whereby the <code class="literal">moveBy()</code> function behaves as if we had called the following:</p><div><pre class="programlisting">line-&gt;setPosition(item.pos() - QPointF(shift, shift))</pre></div><p>To be pixel-perfect, you might need to alter the length of the line.</p><p>The second "problem" was that the scene is always visualized in the center of the view, which is the default <a id="id413" class="indexterm"/>behavior of the view. You can change this setting with <code class="literal">setAlignment()</code>, which accepts <code class="literal">Qt::Alignment</code> flags as arguments. So, calling <code class="literal">view.setAlignment(Qt::AlignBottom | Qt::AlignRight)</code>; would result in the scene staying in the lower-right corner of the view.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl3sec40"/>Showing specific areas of the scene</h2></div></div></div><p>As soon as the <a id="id414" class="indexterm"/>scene's bounding rectangle exceeds the viewport's size, the view will show scroll bars. Besides using them with the mouse to navigate to a specific item or point on the scene, you can also access them by code. Since the view inherits <code class="literal">QAbstractScrollArea</code>, you can use all its functions for accessing the scroll bars. <code class="literal">horizontalScrollBar()</code> and <code class="literal">verticalScrollBar()</code> return a pointer to <code class="literal">QScrollBar</code>, and thus you can query their range with <code class="literal">minimum()</code> and <code class="literal">maximum()</code>. By invoking <code class="literal">value()</code> and <code class="literal">setValue()</code>, you get and can set the current value, which results in scrolling the scene.</p><p>But normally, you do not need to control free scrolling inside the view from your source code. The normal task would be to scroll to a specific item. In order to do that, you do not need to do any calculations yourself; the view offers a pretty simple way to do that for you: <code class="literal">centerOn()</code>. With <code class="literal">centerOn()</code>, the view ensures that the item, which you have passed as an argument, is centered on the view unless it is too close to the scene's border or even outside. Then, the view tries to move it as far as possible on the center. The <code class="literal">centerOn()</code> function does not only take a <code class="literal">QGraphicsItem</code> item as argument; you can also center on a <code class="literal">QPointF</code> pointer or as a convenience on an <em>x</em> and <em>y</em> coordinate.</p><p>If you do not care where an item is shown, you can simply call <code class="literal">ensureVisible()</code> with the item as an argument. Then the view scrolls the scene as little as possible so that the item's center remains or becomes visible. As a second and third argument, you can define a horizontal and vertical margin, which are both the minimum space between the item's bounding rectangle and the view's border. Both values have 50 pixels as their default value. Beside a <code class="literal">QGraphicsItem</code> item, you can also ensure the visibility of a <code class="literal">QRectF</code> element (of course, there is also the convenience function taking four <code class="literal">qreal</code> elements).</p><div><div><h3 class="title"><a id="tip53"/>Tip</h3><p>If you like to ensure the entire visibility of an item (since <code class="literal">ensureVisible(item)</code> only takes the item's center into account) use <code class="literal">ensureVisible(item-&gt;boundingRect())</code>. Alternatively, you can use <code class="literal">ensureVisible(item)</code>, but then you have to set the margins at least to the item's half width or half height respectively.</p></div></div><p>
<code class="literal">centerOn()</code> and <code class="literal">ensureVisible()</code> only scroll the scene but do not change its transformation state. If you absolutely want to ensure the visibility of an item or a rectangle that exceeds the size of the view, you have to transform the scene as well. With this task, again the view will help you. By calling <code class="literal">fitInView()</code> with <code class="literal">QGraphicsItem</code> or a <a id="id415" class="indexterm"/>
<code class="literal">QRectF</code> element as argument, the view will scroll and scale the scene so that it fits in the viewport size. As a second argument, you can control how the scaling is done. You have the following options:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Value</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Qt::IgnoreAspectRatio</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The scaling is done absolutely freely regardless of the item's or rectangle's aspect ratio.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Qt::KeepAspectRatio</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The item's or rectangle's aspect ratio is taken into account while trying to expand as far as possible while respecting the viewport's size.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Qt::KeepAspectRatioByExpanding</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The item's or rectangle's aspect ratio is taken into account, but the view tries to fill the whole viewport's size with the smallest overlap.</p>
</td></tr></tbody></table></div><p>The <code class="literal">fitInView()</code> function does not only scale larger items down to fit the viewport, it also enlarges items to fill the whole viewport. The following picture illustrates the different scaling options for an item that is enlarged:</p><div><img src="img/8874OS_06_02.jpg" alt="Showing specific areas of the scene"/></div><p>The circle on the left is the original item. Then, from left to right it is <code class="literal">Qt::IgnoreAspectRatio</code>, <code class="literal">Qt::KeepAspectRatio</code>, and <code class="literal">Qt::KeepAspectRatioByExpanding</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl3sec41"/>Transforming the scene</h2></div></div></div><p>In the view, you <a id="id416" class="indexterm"/>can transform the scene as you like. Besides the normal convenience functions, such as <code class="literal">rotate()</code>, <code class="literal">scale()</code>, <code class="literal">shear()</code>, and <code class="literal">translate()</code>, you can also apply a free definable <code class="literal">QTransform</code> parameter via <code class="literal">setTransform()</code>, where you also can decide if the transformation should be combined with existing ones or if it should replace them. As an example of probably the most used transformation on a view, let us have a look how you can scale and move the scene inside the view.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec77"/>Time for action – creating an item where transformations can easily be seen</h1></div></div></div><p>First we <a id="id417" class="indexterm"/>set up a playground. To do this, we subclass a <code class="literal">QGraphicsRectItem</code> item and customize its paint function as follows:</p><div><pre class="programlisting">void ScaleItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) {
  Q_UNUSED(option)
  Q_UNUSED(widget)
  const QPen oldPen = painter-&gt;pen();

  const QRectF r = rect();
  const QColor fillColor = Qt::red;
  const qreal square = r.width() / 10.0;
  painter-&gt;fillRect(QRectF(0, 0, square, square), fillColor);
  painter-&gt;fillRect(QRectF(r.width() - square, 0, square, square), fillColor);
  painter-&gt;fillRect(QRectF(0,r.height() - square, square, square), fillColor);
  painter-&gt;fillRect(QRectF(r.width() - square, r.height() - square,square, square), fillColor);

  painter-&gt;setPen(Qt::black);
  painter-&gt;drawRect(r);
  painter-&gt;drawLine(r.topLeft(), r.bottomRight());
  painter-&gt;drawLine(r.topRight(), r.bottomLeft());
  const qreal padding = r.width() / 4;
  painter-&gt;drawRect(r.adjusted(padding, padding, -padding, - padding));

  painter-&gt;setPen(oldPen);
}</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec102"/>
<em>What just happened?</em>
</h2></div></div></div><p>By using the <code class="literal">Q_UNUSED</code> macro, we simply suppress compiler warnings about unused variables. The macro expands to <code class="literal">(void)x;</code>, which does nothing. Then we cache the current pen for putting it back at the end of the function. This gives <code class="literal">painter</code> back unchanged. Of course, we could have called <code class="literal">save()</code> and <code class="literal">restore()</code> on the painter, but these functions save a lot of other properties we do not want to change, so simply saving and restoring the pen is much faster. Next, we draw four red rectangles at the corners of the bounding rectangle (<code class="literal">r</code>) by calling <code class="literal">fillRect()</code>, which does not change the painter state. Then we <a id="id418" class="indexterm"/>set a 1-pixel thick and solid black pen—because this changes the pen's state, we have saved the old pen—and draw the bounding rectangle, the diagonals, and a centered rectangle, which is a quarter of the size of the bounding rectangle. This will give us the following item, which shows the transformations better than with a black-filled rectangle:</p><div><img src="img/8874OS_06_16.jpg" alt="What just happened?"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec78"/>Time for action – implementing the ability to scale the scene</h1></div></div></div><p>Let's do the <a id="id419" class="indexterm"/>scaling first. We add the item to a scene and put that scene on a custom view we have subclassed from <code class="literal">QGraphicsView</code>. In our customized view, we only need to reimplement <code class="literal">wheelEvent()</code> as we want to scale the view by using the mouse's scroll wheel.</p><div><pre class="programlisting">void MyView::wheelEvent(QWheelEvent *event) {
  const qreal factor = 1.1;
  if (event-&gt;angleDelta().y() &gt; 0)
    scale(factor, factor);
  else
    scale(1/factor, 1/factor);
}</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec103"/>
<em>What just happened?</em>
</h2></div></div></div><p>The <code class="literal">factor</code> parameter for the zooming can be freely defined. You can also create a getter and setter method for it. For us, 1.1 will do the work. With <code class="literal">event-&gt;angleDelta()</code>, you get the distance of the mouse's wheel rotation as a <code class="literal">QPoint</code> pointer. Since we only care about vertical scrolling, just the <em>y</em> axis is relevant for us. In our example, we also do not care about how far the wheel was turned because, normally, every step is delivered separately to <code class="literal">wheelEvent()</code>. But if you should need it, it's in eighths of a degree, and since a mouse works in general steps of 15 degrees, the value should be 120 or -120, depending on whether you move the wheel forward or backward. On a forward wheel move, if <code class="literal">y()</code> is greater than zero, we zoom in by using the built-in <code class="literal">scale()</code> function. It takes the scale factor for the <em>x</em> and the <em>y</em> coordinates. Otherwise, if the wheel was moved backwards, we zoom out. That's all there is to it. When you try this example, you will notice that, while <a id="id420" class="indexterm"/>zooming, the view zooms in and out on the center of the view, which is the default behavior for the view. You can change this behavior with <code class="literal">setTransformationAnchor()</code>. <code class="literal">QGraphicsView::AnchorViewCenter</code> is, as described, the default behavior. With <code class="literal">QGraphicsView::NoAnchor</code>, the zoom center is in the top-left corner of the view, and the value you probably want to use is <code class="literal">QGraphicsView::AnchorUnderMouse</code>. With that option, the point under the mouse builds the center of the zooming and thus stays at the same position inside the view.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec79"/>Time for action – implementing the ability to move the scene</h1></div></div></div><p>Next it <a id="id421" class="indexterm"/>would be good to move the scene around without the need of using the scroll bars. Let us add the functionality for pressing and holding the left mouse button. First, we add two private members to the view: the <code class="literal">m_pressed</code> parameter of type <code class="literal">bool</code> and the <code class="literal">m_lastMousePos</code> element of type <code class="literal">QPoint</code>. Then, we reimplement the <code class="literal">mousePressEvent()</code> and <code class="literal">mouseReleaseEvent()</code> functions as follows:</p><div><pre class="programlisting">void MyView::mousePressEvent(QMouseEvent *event) {
  if (Qt::LeftButton == event-&gt;button()) {
    m_pressed = true;
    m_lastMousePos = event-&gt;pos();
  }
  QGraphicsView::mousePressEvent(event);
}

void MyView::mouseReleaseEvent(QMouseEvent *event) {
  if (Qt::LeftButton == event-&gt;button())
    m_pressed = false;
  QGraphicsView::mouseReleaseEvent(event);
}</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec104"/>
<em>What just happened?</em>
</h2></div></div></div><p>Within <code class="literal">mousePressEvent()</code>, we check whether the left mouse button was pressed. If it was <code class="literal">true</code>, we then set <code class="literal">m_pressed</code> to <code class="literal">true</code> and save the current mouse position in <code class="literal">m_lastMousePos</code>. Then we pass the event to the base class event handler. Within <code class="literal">mouseReleaseEvent()</code>, we set <code class="literal">m_pressed</code> to <code class="literal">false</code> if it was the left button; then we pass the event to the base class implementation. We do not need to alter <code class="literal">m_pressPoint</code> here. With <code class="literal">mouseMoveEvent()</code>, we can then react on the value of those two variables:</p><div><pre class="programlisting">void MyView::mouseMoveEvent(QMouseEvent *event) {
  if (!m_pressed)
    return QGraphicsView::mouseMoveEvent(event);

  QPoint diff = m_lastMousePos - event-&gt;pos();
  if (QScrollBar *hbar = horizontalScrollBar())
    hbar-&gt;setValue(hbar-&gt;value() + diff.x());
  if (QScrollBar *vbar = verticalScrollBar())
    vbar-&gt;setValue(vbar-&gt;value() + diff.y());
  m_lastMousePos = event-&gt;pos();
  return QGraphicsView::mouseMoveEvent(event);
}</pre></div><p>If <code class="literal">m_pressed</code> is <code class="literal">false</code>—this means the left button wasn't pressed and held—we will be exiting the function while passing the event to the base class implementation. This is, by the way, important for <a id="id422" class="indexterm"/>getting unhandled events propagated to the scene correctly. If the button has been pressed, we first calculate the difference (<code class="literal">diff</code>) between the point where the mouse was pressed and the current position. Thus we know how far the mouse was moved. Now we simply move the scroll bars by that value. For the horizontal scroll bar, the pointer to it is received by calling <code class="literal">horizontalScrollBar()</code>. The encapsulation in an <code class="literal">if</code> clause is just a paranoid safety check to ensure that the pointer is not null. Normally, this should never happen. Through that pointer, we set a new value by adding the old value, received by <code class="literal">value()</code>, to the moved distance, <code class="literal">diff.x()</code>. We then do the same for the vertical scroll bar. Last, we save the current mouse position to <code class="literal">m_lastMousePos</code>. That's all. Now you can move the scene around while holding the left mouse button down. The downside of this method is that the left mouse click does not reach the scene and, therefore, features such as item selection do not work. If you need that or a similar functionality on the scene, check for a keyboard modifier too. For example, if the <em>Shift</em> key must also be pressed to move the scene, additionally check the events <code class="literal">modifiers()</code> for whether <code class="literal">Qt::ShiftModifier</code> is set to activate the mouse-moving functionality:</p><div><pre class="programlisting">void MyView::mousePressEvent(QMouseEvent *event) {
  if (Qt::LeftButton == event-&gt;button()
    &amp;&amp; (event-&gt;modifiers() &amp; Qt::ShiftModifier)) {
    m_pressed = true;
      //...</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec80"/>Time for action – taking the zoom level into account</h1></div></div></div><p>As a last <a id="id423" class="indexterm"/>detail, I would like to mention that you can draw an item differently depending on its scale. To do that, the level of detail can be used. You use the passed pointer to <code class="literal">QStyleOptionGraphicsItem</code> of the item's <code class="literal">paint</code> function and call <code class="literal">levelOfDetailFromTransform()</code> with the painter's world transformation. We change the paint function of the <code class="literal">ScaleItem</code> item to the following:</p><div><pre class="programlisting">const qreal detail = option-&gt;levelOfDetailFromTransform(painter-&gt;worldTransform());
const QColor fillColor = (detail &gt;= 5) ? Qt::yellow : Qt::red;</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec105"/>
<em>What just happened?</em>
</h2></div></div></div><p>The <code class="literal">detail</code> parameter now contains the maximum width of unity square, which was mapped to the painter coordinate system via the painter's world transformation matrix. Based on that value, we set the fill color of the border rectangles to yellow or red. The expression <code class="literal">detail &gt;= 5</code> will become <code class="literal">true</code> if the rectangle is displayed at least five times as large as in a normal state. The level of detail is helpful when you want to draw more detail on an item only if it is visible. By using the level of detail, you can control when a possibly resource-intensive drawing should be performed. It makes sense, for example, to make difficult drawings only when you can see them.</p><p>When you zoom into the scene, the diagonal lines as well as the rectangle lines get zoomed. But you may want to leave the stroke the same regardless of the zoom level. Here Qt also has an easy approach to offer. In the paint function of the item we used earlier for exemplifying the zoom functionality, locate the following line of code:</p><div><pre class="programlisting">painter-&gt;setPen(Qt::black);</pre></div><p>Replace it with the following lines:</p><div><pre class="programlisting">QPen p(Qt::black);
<strong>p.setCosmetic(true);</strong>
painter-&gt;setPen(p);</pre></div><p>The important part is to make the painter cosmetic. Now, regardless of the zoom or any other transformation, the pen's width stays the same. This can be very helpful for drawing outlined shapes.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl3sec42"/>Questions you should keep in mind</h2></div></div></div><p>Whenever you are going to use the Graphics View architecture, ask yourself these questions: Which standard items are suited for my specific needs? Am I reinventing the wheel over and over again? Do I need <code class="literal">QGraphicsTextItem</code> or is <code class="literal">QGraphicsSimpleTextItem</code> good enough? Do I need the items to inherit <code class="literal">QObject</code> or will plain items not suffice? (We will cover this topic in the next section.) Could I group items together for the sake of cleaner and leaner code? Is the parent-child relationship sufficient or do I need to use a <code class="literal">QGraphicsItemGroup</code> element?</p><p>Now you really know most of the functions of the Graphics View framework. With this knowledge, you can already do a lot of cool stuff. But for a game, it is still too static. We will change that next!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec81"/>The jumping elephant or how to animate the scene</h1></div></div></div><p>By now, you <a id="id424" class="indexterm"/>should have a good understanding about the items, the scene, and the view. With your knowledge of how to create items, standard and custom ones, of how to position them on the scene, and of how to set up the view to show the scene, you can make pretty awesome things. You even can zoom and move the scene with the mouse. That's surely good, but for a game, one crucial point is still missing: you have to animate the items. Instead of going through all possibilities for how to animate a scene, let us develop a simple jump-and-run game where we recap parts of the previous topics and learn how to animate items on a screen. So let's meet Benjamin, the elephant:</p><div><img src="img/8874OS_06_03.jpg" alt="The jumping elephant or how to animate the scene"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec106"/>The game play</h2></div></div></div><p>The goal of the <a id="id425" class="indexterm"/>game is for Benjamin to collect the coins that are placed all over the game field. Besides walking right and left, Benjamin can, of course, also jump. In the following screenshot, you see what this minimalistic game should look like in the end:</p><div><img src="img/8874OS_06_12.jpg" alt="The game play"/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec107"/>The player item</h2></div></div></div><p>Let's now <a id="id426" class="indexterm"/>look at how we can mobilize Benjamin.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec82"/>Time for action – creating an item for Benjamin</h1></div></div></div><p>First we <a id="id427" class="indexterm"/>need a custom item class for Benjamin. We call the class <code class="literal">Player</code> and choose <code class="literal">QGraphicsPixmapItem</code> as the base class because Benjamin is a PNG image. In the item's <code class="literal">Player</code> class, we further create a property of integer type and call it <code class="literal">m_direction</code>. Its value signifies in which direction Benjamin walks—left or right—or if he stands still. Of course, we use a getter and setter function for this property. Since the header file is simple, let's have a look at the implementation right away (you will find the whole source code at the end of this book):</p><div><pre class="programlisting">Player::Player(QGraphicsItem *parent)
  : QGraphicsPixmapItem(parent), m_direction(0) {
    setPixmap(QPixmap(":/elephant"));
    setTransformOriginPoint(boundingRect().center());
}</pre></div><p>In the constructor, we set <code class="literal">m_direction</code> to <code class="literal">0</code>, which means that Benjamin isn't moving at all. If <code class="literal">m_direction</code> is <code class="literal">1</code>, Benjamin moves right, and if the value is <code class="literal">-1</code>, he moves left. In the body of the constructor, we set the image for the item by calling <code class="literal">setPixmap()</code>. The image of Benjamin is stored in the Qt Resource System; thus, we access it through <code class="literal">QPixmap(":/elephant")</code> with <code class="literal">elephant</code> as the given alias for the actual image of Benjamin. Last, we set the point of origin for all transformations we are going to apply to the center of the item. This equals the center of the image.</p><div><pre class="programlisting">int Player::direction() const {
  return m_direction;
}</pre></div><p>The <code class="literal">direction()</code> function is a standard getter function for <code class="literal">m_direction</code> returning its value. The next <a id="id428" class="indexterm"/>function of this class is much more important:</p><div><pre class="programlisting">void Player::addDirection(int direction) {
  direction = qBound(-1, direction, 1);
  m_direction += direction;
  if (0 == m_direction)
    return;

  if (-1 == m_direction)
    setTransform(QTransform(-1, 0, 0, 1, boundingRect().width(), 0));
  else
    setTransform(QTransform());
}</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec108"/>
<em>What just happened?</em>
</h2></div></div></div><p>With <code class="literal">addDirection()</code>, one "sets" the direction of Benjamin's movement. "Set" is put in quotes because you do not set <code class="literal">m_direction</code> to the passed value; instead, you add the passed value to <code class="literal">m_direction</code>. This is done in the second line after we have ensured the correctness of <code class="literal">m_direction</code>. For that, we use <code class="literal">qBound()</code>, which returns a value that is bound by the first and last argument. The argument in the middle is the actual value that we want to get bound. So the possible values for <code class="literal">m_direction</code> are restricted to -1, 0, and 1. If the property <code class="literal">direction</code> is 0, the player item does not move and the function exits.</p><p>If you haven't already done so earlier, you might wonder by now why not simply set the value? Why that addition? Well, it is because of how we will use this function: Benjamin is moved by the left and right arrow key. If the right key is pressed, 1 is added; if it gets released, -1 is added. Think of it as an impulse to the right (1) and to the left (-1). The first accelerates the player and the second slows him down. The same applies for the left key, but only the other way around. As we do not allow multiple acceleration, we limit the value of <code class="literal">m_direction</code> to 1 and -1. The addition of the value rather than setting it is now necessary because of the following situation: A user presses and holds the right key, and the value of <code class="literal">m_direction</code> is therefore 1. Now, without releasing the right key, he also presses and holds the left key. Therefore, the value of <code class="literal">m_direction</code> is getting decreased by one; the value is now 0 and Benjamin stops. But remember, both keys are still being pressed. What happens when the left key is released? How would you know in this situation in which direction Benjamin should move? To achieve that, you would have to find out an additional bit of information: whether the right key is still pressed down or not. That seems too much trouble and overhead. In our implementation, when the left key is released, 1 is added and the value of <code class="literal">m_direction</code> becomes 1, making Benjamin move right. Voilà! All without any concern about what the state of the other button might be.</p><p>Lastly, we check in which direction Benjamin is moving. If he is moving left, we need to flip his image so that Benjamin looks to the left, the direction in which he is moving. Therefore, we apply a <code class="literal">QTransform</code> matrix, which flips the image vertically. If he is moving towards the right, we restore the normal state by assigning an empty <code class="literal">QTransform</code> object, which is an identity matrix.</p><p>So we now have our item of class <code class="literal">Player</code> for the game's character, which shows the image of Benjamin. The <a id="id429" class="indexterm"/>item also stores the current moving direction, and based on that information, the image is flipped vertically if needed.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec109"/>The playing field</h2></div></div></div><p>To understand the <a id="id430" class="indexterm"/>following code, it might be good to know the composition of the environment in which our elephant will be walking and jumping. Overall, we have a view fixed in size holding a scene which is exactly as big as the view. We do not take size changes into account since they would complicate the example too much, and when you develop a game for a mobile device, you know the available size up front.</p><p>All animations inside the playing field are done by moving the items, not the scene. So we have to distinguish between the view's, or rather the scene's width and the width of the elephant's virtual "world" in which he can move. The width of this virtual world is defined by <code class="literal">m_fieldWidth</code> and has no (direct) correlation with the scene. Within the range of <code class="literal">m_fieldWidth</code>, which is 500 pixels in the example, Benjamin or the graphics item can be moved from the minimum <em>x</em> coordinate, defined by <code class="literal">m_minX</code>, to the maximum <em>x</em> coordinate, defined by <code class="literal">m_maxX</code>. We keep track of his actual <em>x</em> position with the variable <code class="literal">m_realPos</code>. Next, the minimum <em>y</em> coordinate the item is allowed to have is defined by <code class="literal">m_groundLevel</code>. For <code class="literal">m_maxX</code> and <code class="literal">m_groundLevel</code>, we have to take into account that the position of the item is determined by its top-left corner. Lastly, what is left is the view, which has a fixed size defined by the scene's bounding rectangle size, which is not as wide as <code class="literal">m_fieldWidth</code>. So the scene (and the view) follows the elephant while he walks through his virtual world of the length <code class="literal">m_fieldWidth</code>. Have a look at the picture to see the variables in their graphical representation:</p><div><img src="img/8874OS_06_04.jpg" alt="The playing field"/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec110"/>The scene</h2></div></div></div><p>Since we will have to do <a id="id431" class="indexterm"/>some work on the scene, we subclass <code class="literal">QGraphicsScene</code> and name the new class <code class="literal">MyScene</code>. There we implement one part of the game logic. This is convenient since <code class="literal">QGraphicsScene</code> inherits <code class="literal">QObject</code> and thus we can use Qt's signal and slot mechanism. Also, for the next code of the scene, we only go through the implementation of the functions. For more information on the header, have a look at the sources bundled with this book.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec83"/>Time for action – making Benjamin move</h1></div></div></div><p>The first thing we want <a id="id432" class="indexterm"/>to do is to make our elephant movable. In order to achieve that, we use a <code class="literal">QTimer</code> parameter called <code class="literal">m_timer</code>, which is a private member of <code class="literal">MyScene</code>. In the constructor we set up the timer with the following code:</p><div><pre class="programlisting">m_timer.setInterval(30);
connect(&amp;m_timer, &amp;QTimer::timeout, this, &amp;MyScene::movePlayer);</pre></div><p>First we define that the timer emits a timeout signal every 30 milliseconds. Then we connect that signal to the scene's slot called <code class="literal">movePlayer()</code>, but we do not start the timer yet. This is done by the arrow keys in a way we have already discussed when the <code class="literal">m_direction</code> variable of the class <code class="literal">Player</code> was introduced. Here is the implementation of what was described there:</p><div><pre class="programlisting">void MyScene::keyPressEvent(QKeyEvent *event) {
  if (event-&gt;isAutoRepeat())
    return;

  switch (event-&gt;key()) {
    case Qt::Key_Right:
      m_player-&gt;addDirection(1);
      checkTimer();
      break;
    case Qt::Key_Left:
      m_player-&gt;addDirection(-1);
      checkTimer();
      break;
    //...
    default:
      break;
  }
}</pre></div><div><div><h3 class="title"><a id="note08"/>Note</h3><p>As a small side note, whenever code snippets in the following code passages are irrelevant for the <a id="id433" class="indexterm"/>actual detail, I am going to skip the code but will indicate missing code with <code class="literal">//...</code> so that you know it is not the entire code. We will cover the skipped parts later when it is more appropriate.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec111"/>
<em>What just happened?</em>
</h2></div></div></div><p>In the key press event handler, we first check if the key event was triggered because of an auto repeat. If this is the case, we exit the function because we only want to react on the first real key press event. We also do not call the base class implementation of that event handler since no item on the scene needs to get a key press event. If you do have items that could and should receive events, do not forget to forward them while reimplementing event handlers at the scene.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>If you press and hold a key down, Qt will continuously deliver the key press event. To determine if it was the first real key press or an auto-generated event, use <code class="literal">QKeyEvent::isAutoRepeat()</code>. It returns <code class="literal">true</code> if the event was automatically generated. There is no easy way to turn off the auto repeat since it is platform-dependent and you have to use the platform API for that.</p></div></div><p>As soon as we know that the event was not delivered by an auto repeat, we react to the different key presses. If the left key was pressed, we decrease the direction property of the player item by one; if the right key was pressed, we increase it by one. The <code class="literal">m_player</code> element is our instance of the player item. After calling <code class="literal">addDirection()</code>, we call <code class="literal">checkTimer()</code> in both cases:</p><div><pre class="programlisting">void MyScene::checkTimer() {
  if (0 == m_player-&gt;direction())
    m_timer.stop();
  else if (!m_timer.isActive())
    m_timer.start();
}</pre></div><p>This function first checks whether the player moves. If not, the timer is stopped because nothing has to be updated when our elephant stands still. Otherwise, the timer gets started, but only if it isn't already running. This we check by calling <code class="literal">isActive()</code> on the timer.</p><p>When the user presses the right key, for example at the beginning of the game, <code class="literal">checkTimer()</code> will start <code class="literal">m_timer</code>. Since its time out signal was connected to <code class="literal">movePlayer()</code>, the slot will be called every 30 milliseconds till the key is released. Since the <code class="literal">move()</code> function is a bit longer, let's go through it step-by-step:</p><div><pre class="programlisting">void MyScene::movePlayer() {
  const int direction = m_player-&gt;direction();
  if (0 == direction)
    return;</pre></div><p>First, we cache the player's current direction in a local variable to avoid multiple calls of <code class="literal">direction()</code>. Then we check whether the player is moving at all. If they aren't, we exit the function because there is nothing to animate.</p><div><pre class="programlisting">  const int dx = direction * m_velocity;
  qreal newPos = m_realPos + dx;
  newPos = qBound(m_minX, newPos, m_maxX);
  if (newPos == m_realPos)
    return;
  m_realPos = newPos;</pre></div><p>Next we calculate the shift the player item should get and store it in <code class="literal">dx</code>. The distance the player should move every 30 milliseconds is defined by the member variable <code class="literal">m_velocity</code>, expressed in <a id="id434" class="indexterm"/>pixels. You can create setter and getter functions for that variable if you like. For us, the default value of 4 pixels will do the job. Multiplied by the direction (which could only be 1 or -1 at this point), we get a shift of the player by 4 pixels to the right or to the left. Based on this shift, we calculate the new <em>x</em> position of the player and store it in <code class="literal">newPos</code>. Next, we check whether that new position is inside the range of <code class="literal">m_minX</code> and <code class="literal">m_maxX</code>, two member variables that are already calculated and set up properly at this point. Next, if the new position is not equal to the actual position, which is stored in <code class="literal">m_realPos</code>, we proceed by assigning the new position as the current one. Otherwise, we exit the function since there is nothing to move.</p><div><pre class="programlisting">  const int leftBorder = 150;
  const int rightBorder = 350 - m_player-&gt;boundingRect().width();</pre></div><p>The next question to tackle is whether the view should always move when the elephant is moving, which means that the elephant would always stay say in the middle of the view. No, he shouldn't stay at a specific point inside the view. Rather, the view should be fixed when the elephant is moving. Only if he reaches the borders should the view follow. The "non-movable" center is defined by <code class="literal">leftBorder</code> and <code class="literal">rightBorder</code>, which are related to the item's position; thus we must subtract the item's width from the <code class="literal">rightBorder</code> element. If we don't take the item's width into account, the right side of a player with a width of more than 150 pixels will disappear before the scrolling takes place. Please note that the values for <code class="literal">leftBorder</code> and <code class="literal">rightBorder</code> are randomly chosen. You can alter them as you like. Here we decided to set the border at 150 pixels. Of course, you can create a setter and getter for these parameters too:</p><div><pre class="programlisting">  if (direction &gt; 0) {
    if (m_realPos &gt; m_fieldWidth - (width() - rightBorder)) {
      m_player-&gt;moveBy(dx, 0);
    } else {
      if (m_realPos - m_skippedMoving &lt; rightBorder) {
        m_player-&gt;moveBy(dx, 0);
      } else {
        m_skippedMoving += dx;
      }
    }
  } else {
    if (m_realPos &lt; leftBorder &amp;&amp; m_realPos &gt;= m_minX) {
      m_player-&gt;moveBy(dx, 0);
    } else {
      if (m_realPos - m_skippedMoving &gt; leftBorder) {
        m_player-&gt;moveBy(dx, 0);
      } else {
        m_skippedMoving = qMax(0, m_skippedMoving + dx);
      }
    }
  }
  //...
}</pre></div><p>Ok, so what have we done here? Here we have calculated whether only the elephant moves or the view as well so that the elephant does not walk out of the screen. The <code class="literal">if</code> clause applies when the elephant is moving towards the right. For a better understanding, let's begin at the end of this scope. There is a situation where we do not move the elephant but simply <a id="id435" class="indexterm"/>add the shift <code class="literal">dx</code> to a variable named <code class="literal">m_skippedMoving</code>. What does that mean? It means that the virtual "world" is moving but the elephant inside the view is not. This is the case when the elephant moves too far to the borders. In other words, you move the view with the elephant above the virtual world by <code class="literal">dx</code> to the left. Let's take a look at the following figure:</p><div><img src="img/8874OS_06_05.jpg" alt="What just happened?"/></div><p>The <code class="literal">m_skippedMoving</code> element is the difference between the view's <em>x</em> coordinate and the virtual world's <em>x</em> coordinate. So the <code class="literal">if</code> clause <code class="literal">m_realPos - m_skippedMoving &lt; rightBorder</code> reads: <em>If the position of the elephant in "view coordinates", calculated by </em>
<code class="literal">m_realPos – m_skippedMoving</code>
<em>, is smaller than </em>
<code class="literal">rightBorder</code>
<em>, then move the elephant by calling </em>
<code class="literal">moveBy()</code>
<em> since he is allowed to walk till </em>
<code class="literal">rightBorder</code>
<em>. </em>
<code class="literal">m_realPos - m_skippedMoving</code>
<em> is the same as </em>
<code class="literal">m_player-&gt;pos().x() + dx</code>
<em>.</em>
</p><p>Lastly, let's turn to the first clause: <code class="literal">m_realPos &gt; m_fieldWidth - (width() - rightBorder)</code>. This returns <code class="literal">true</code> when the actual position is behind the <code class="literal">rightBorder</code> element but the fictional world is moved to its maximum left. Then we also have to move the elephant so that he can reach <code class="literal">m_maxX</code>. The expression <code class="literal">width() - rightBorder</code> calculates the width between <code class="literal">rightBorder</code> and the scene's right border.</p><p>The same considerations and calculations apply for moving to the left, the other branch.</p><p>So far, we have <a id="id436" class="indexterm"/>accomplished two things. First, with a <code class="literal">QTimer</code> object, we trigger a slot that moves an item; thus, we have animated the scene. Second, we have determined the elephant's position in the virtual world. You might wonder why we have done this. To be able to do parallax scrolling!</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec112"/>Parallax scrolling</h2></div></div></div><p>Parallax scrolling is a <a id="id437" class="indexterm"/>trick to add an illusion of <a id="id438" class="indexterm"/>depth to the background of the game. This illusion occurs when the background has different layers which move at different speeds. The nearest background must move faster than the ones farther away. In our case, we have these four backgrounds ordered from the most distant to the nearest:</p><div><img src="img/8874OS_06_17.jpg" alt="Parallax scrolling"/><div><p>The sky</p></div></div><div><img src="img/8874OS_06_18.jpg" alt="Parallax scrolling"/><div><p>The trees</p></div></div><div><img src="img/8874OS_06_07.jpg" alt="Parallax scrolling"/><div><p>The grass</p></div></div><div><img src="img/8874OS_06_08.jpg" alt="Parallax scrolling"/><div><p>The ground</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec84"/>Time for action – moving the background</h1></div></div></div><p>Now the <a id="id439" class="indexterm"/>question is how to move them at different speeds. The solution is quite simple: the slowest one, the sky, is the smallest image. The fastest background, the ground and the grass, are the largest images. Now when we <a id="id440" class="indexterm"/>have a look at the end of the <code class="literal">movePlayer()</code> function's slot we see this:</p><div><pre class="programlisting">qreal ff = qMin(1.0, m_skippedMoving/(m_fieldWidth - width()));
<strong>m_sky-&gt;setPos(-(m_sky-&gt;boundingRect().width() - width()) * ff, 0);</strong>
m_grass-&gt;setPos(-(m_grass-&gt;boundingRect().width() - width()) * ff, m_grass-&gt;y());
m_trees-&gt;setPos(-(m_trees-&gt;boundingRect().width() - width()) * ff, m_trees-&gt;y());
m_ground-&gt;setPos(-(m_ground-&gt;boundingRect().width() - width()) * ff, m_ground-&gt;y());</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec113"/>
<em>What just happened?</em>
</h2></div></div></div><p>What are we doing here? At the beginning, the sky's left border is the same as the view's left border, both at point (0, 0). At the end, when Benjamin has walked to the maximum right, the sky's right border should be the same as the view's right border. So the distance we have to move the sky over time is the sky's width (<code class="literal">m_sky-&gt;boundingRect().width()</code>) minus the width of the view (<code class="literal">width()</code>). The shift of the sky depends on the position of the player: If he is far to the left, the sky isn't shifted, if the player is far to the right, the sky is maximally shifted. We thus have to multiply the sky's maximum shift value with a factor based on the current position of the player. The relation to the player's position is the reason why this is handled in the <code class="literal">movePlayer()</code> function. The factor we have to calculate has to be between 0 and 1. So we get the minimum shift (0 * shift, which equals 0) and the maximum shift (1 * shift, which equals shift). This factor we name <code class="literal">ff</code>. The calculation reads: <em>If we subtract the width of the view (</em>
<code class="literal">width()</code>
<em>) from the virtual field's width </em>
<code class="literal">m_fieldWidth</code>
<em>, we have the area where the player isn't moved by (</em>
<code class="literal">m_player-&gt;moveBy()</code>
<em>) because in that range only the background should move.</em>
</p><p>How often the moving of the player was skipped is saved in <code class="literal">m_skippedMoving</code>. So by dividing <code class="literal">m_skippedMoving</code> through <code class="literal">m_fieldWidth – width()</code>, we get the needed factor. It is 0 when the player is to the far left and 1 if they are to the far right. Then we simply have to multiply <code class="literal">ff</code> with the maximum shift of the sky. To avoid the backgrounds from being moved too far, we ensure through <code class="literal">qMin()</code> that the factor is always lesser than, or equal to, 1.0.</p><p>The same calculation is used for the other background items. The calculation also explains why a smaller image is moving slower. It's because the overlap of the smaller image is less than that of the larger one. And since the backgrounds are moved in the same time period, the larger has to move faster.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec114"/>Have a go hero – adding new background layers</h2></div></div></div><p>Try to <a id="id441" class="indexterm"/>add additional background layers to the game following the preceding example. As an idea, you can add a barn behind the trees or let an airplane fly through the sky.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec115"/>QObject and items</h2></div></div></div><p>The <a id="id442" class="indexterm"/>
<code class="literal">QGraphicsItem</code> item and all standard items introduced so <a id="id443" class="indexterm"/>far don't inherit <code class="literal">QObject</code> and thus can't have slots or emit signals; they also don't benefit from the <code class="literal">QObject</code> property system. But we can make them use <code class="literal">QObject</code>!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec85"/>Time for action – using properties, signals, and slots with items</h1></div></div></div><p>So let's alter the <code class="literal">Player</code> class to use <code class="literal">QObject</code>:</p><div><pre class="programlisting">class Player : public QObject, public QGraphicsPixmapItem {
  Q_OBJECT</pre></div><p>All you have to do is to add <code class="literal">QObject</code> as a base class and add the <code class="literal">Q_OBJECT</code> macro. Now you can use signals and slots with items too. Be aware that <code class="literal">QObject</code> must be the first base class of an item.</p><div><div><h3 class="title"><a id="tip54"/>Tip</h3><p>If you want an item that inherits from <code class="literal">QObject</code> and <code class="literal">QGraphicsItem</code>, you can directly inherit <code class="literal">QGraphicsObject</code>. Moreover, this class defines and emits some useful signals such as <code class="literal">xChanged()</code> when the <em>x</em> coordinate of the item has changed or <code class="literal">scaleChanged()</code> when the item is scaled.</p></div></div><div><div><h3 class="title"><a id="note10"/>Note</h3><p>A word of warning: Only use <code class="literal">QObject</code> with items if you really need its capabilities. <code class="literal">QObject</code> adds a lot of overhead to the item, which will have a noticeable impact on performance when you have many items. So use it wisely and not only because you can.</p></div></div><p>Let us go back to our player item. After adding <code class="literal">QObject</code>, we define a property called <code class="literal">m_jumpFactor</code> with a getter, a setter, and a change signal. We need that property to make Benjamin jump, as we will see later on. In the header file, we define the property as follows:</p><div><pre class="programlisting">Q_PROPERTY(qreal jumpFactor READ jumpFactor WRITE setjumpFactor NOTIFY jumpFactorChanged)</pre></div><p>The getter function <code class="literal">jumpFactor()</code> simply returns the private member <code class="literal">m_jumpFactor</code>, which is used to store the actual position. The implementation of the setter looks like this:</p><div><pre class="programlisting">void Player::setjumpFactor(const qreal pos) {
  if (pos == m_jumpFactor)
    return;
  m_jumpFactor = pos;
  emit jumpFactorChanged(m_jumpFactor);
}</pre></div><p>It is important to check if <code class="literal">pos</code> would change the current value of <code class="literal">m_jumpFactor</code>. If this is not the case, exit the <a id="id444" class="indexterm"/>function because, otherwise, a change signal will be emitted even if nothing has changed. Otherwise, we set <code class="literal">m_jumpFactor</code> to <code class="literal">pos</code> and emit the signal that informs about the chance.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec116"/>Property animations</h2></div></div></div><p>The new <a id="id445" class="indexterm"/>
<code class="literal">jumpFactor</code> property we use immediately with a <code class="literal">QPropertyAnimation</code> element, a second way to animate items.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec86"/>Time for action – using animations to move items smoothly</h1></div></div></div><p>In <a id="id446" class="indexterm"/>order to use it, we add a new private member called <code class="literal">m_animation</code> of type <code class="literal">QPropertyAnimation</code> and initialize it in the constructor of <code class="literal">Player</code>:</p><div><pre class="programlisting">m_animation = new QPropertyAnimation(this);
m_animation-&gt;setTargetObject(this);
m_animation-&gt;setPropertyName("jumpFactor");
m_animation-&gt;setStartValue(0);
m_animation-&gt;setKeyValueAt(0.5, 1);
m_animation-&gt;setEndValue(0);
m_animation-&gt;setDuration(800);
m_animation-&gt;setEasingCurve(QEasingCurve::OutInQuad);</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec117"/>
<em>What just happened?</em>
</h2></div></div></div><p>For the instance of <code class="literal">QPropertyAnimation</code> created here, we define the item as parent; thus, the animation will get deleted when the scene deletes the item and we don't have to worry about freeing the used memory. Then we define the target of the animation—our <code class="literal">Player</code> class—and the property that should be animated—<code class="literal">jumpFactor</code>, in this case. Then we define the start and the end value of that property, and in addition to that we also define a value in between by setting <code class="literal">setKeyValueAt()</code>. The first argument of type <code class="literal">qreal</code> defines time inside the animation, where 0 is the beginning and 1 the end, and the second argument defines the value that the animation should have at this time. So your <code class="literal">jumpFactor</code> element will get animated from 0 to 1 and back to 0 in 800 milliseconds. This was defined by <code class="literal">setDuration()</code>. Finally, we define how the interpolation between the start and end value should be done and call <code class="literal">setEasingCurve()</code> with <code class="literal">QEasingCurve::OutInQuad</code> as an argument. Qt defines up to 41 different easing curves for linear, quadratic, cubic, quartic, quintic, sinusoidal, exponential, circular, elastic, back easing, and bounce functions. These are too many to describe here. Instead, have a look at the documentation. Simply search for <code class="literal">QEasingCurve::Type</code>. In our case, <code class="literal">QEasingCurve::OutInQuad</code> makes sure that the jump speed of Benjamin looks like an actual jump: fast in the beginning, slow at the top, and fast at the end again. We start this animation with the jump function:</p><div><pre class="programlisting">void Player::jump() {
  if (QAbstractAnimation::Stopped == m_animation-&gt;state())
    m_animation-&gt;start();
}</pre></div><p>We only start the animation by calling <code class="literal">start()</code> when the animation isn't running. Therefore, we check the animation's state to see if it is stopped. Other states could be <code class="literal">Paused</code> or <code class="literal">Running</code>. We want this jump action to be activated whenever the player presses the Space key on their keyboard. Therefore, we expand the switch statement inside the key <a id="id447" class="indexterm"/>press event handler by using this code:</p><div><pre class="programlisting">case Qt::Key_Space:
  m_player-&gt;jump();
  break;</pre></div><p>Now the property gets animated but Benjamin will still not jump yet. Therefore, we connect the <code class="literal">jumpFactorChange()</code> signal to a slot of the scene that handles the jump:</p><div><pre class="programlisting">void MyScene::jumpPlayer(qreal factor) {
  const qreal y = (m_groundLevel - m_player-&gt;boundingRect().height()) - factor * m_jumpHeight;
  m_player-&gt;setPos(m_player-&gt;pos().x(), y);
  //...
}</pre></div><p>Inside that function, we calculate the <em>y</em> coordinate of the player item to respect the ground level defined by <code class="literal">m_groundLevel</code>. This is done by subtracting the item's height from the ground level's value since the item's origin point is the top-left corner. Then we subtract the maximum jump height, defined by <code class="literal">m_jumpHeight</code>, which is multiplied by the actual jump factor. Since the factor is in range from 0 to 1, the new <em>y</em> coordinate stays inside the allowed jump height. Then we alter the player item's <em>y</em> position by calling <code class="literal">setPos()</code>, leaving the <em>x</em> coordinate the same. Et voilà, Benjamin is jumping!</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec118"/>Have a go hero – letting the scene handle Benjamin's jump</h2></div></div></div><p>Of <a id="id448" class="indexterm"/>course, we could have done the property animation inside the scene's class without the need to extend <code class="literal">Player</code> by <code class="literal">QObject</code>. But this should be an example of how to do it. So try to put the logic of making Benjamin jump to the scene's class. This is, however, more consistent as we already move Benjamin left and right there. Or, also consistent, do it the other way around; move Benjamin's movement to the left and right also to the <code class="literal">Player</code> class.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec87"/>Time for action – keeping multiple animations in sync</h1></div></div></div><p>If you have a look at how the coins (their class being called <code class="literal">Coin</code>) are created, you see similar structures. They inherit from <code class="literal">QObject</code> and <code class="literal">QGraphicsEllipseItem</code> and define two properties: opacity of type <code class="literal">qreal</code> and <code class="literal">rect</code> of type <code class="literal">QRect</code>. This is done only by the following code:</p><div><pre class="programlisting">Q_PROPERTY(qreal opacity READ opacity WRITE setOpacity)
Q_PROPERTY(QRectF rect READ rect WRITE setRect)</pre></div><p>No function or slot was added because we simply used built-in functions of <code class="literal">QGraphicsItem</code> and "redeclared" them as properties. Then, these two properties are animated by two <code class="literal">QPropertyAnimation</code> objects. One fades the coin out, while the other scales the coin in. To ensure that both animations get started at the same time, we use <code class="literal">QParallelAnimationGroup</code> as follows:</p><div><pre class="programlisting">QPropertyAnimation *fadeAnimation = /* set up */
QPropertyAnimation *scaleAnimation = /* set up */
QParallelAnimationGroup *group = new QParallelAnimationGroup(this);
group-&gt;addAnimation(fadeAnimation);
group-&gt;addAnimation(scaleAnimation);
group-&gt;start();</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec119"/>
<em>What just happened?</em>
</h2></div></div></div><p>After setting up each <a id="id449" class="indexterm"/>property animation, we add them to the group animation by calling <code class="literal">addAnimation()</code> on the group while passing a pointer to the animation we would like to add. Then, when we start the group, <code class="literal">QParallelAnimationGroup</code> makes sure that all assigned animations start at the same time.</p><p>The animations are set up for when the coin explodes. You may want to have a look at the <code class="literal">explode()</code> function of Coin in the sources. A coin should explode when Benjamin touches the coin.</p><div><div><h3 class="title"><a id="tip55"/>Tip</h3><p>If you want to play animations one after the other you can use <code class="literal">QSequentialAnimationGroup</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec120"/>Item collision detection</h2></div></div></div><p>Whether the <a id="id450" class="indexterm"/>player item collides with a coin is checked by the scene's <code class="literal">checkColliding()</code> function, which is called after the player item has moved (<code class="literal">movePlayer()</code>) or after Benjamin jumped (<code class="literal">jumpPlayer()</code>).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec88"/>Time for action – making the coins explode</h1></div></div></div><p>The <a id="id451" class="indexterm"/>implementation of <code class="literal">checkColliding()</code> looks like this:</p><div><pre class="programlisting">QList&lt;QGraphicsItem*&gt; items =  collidingItems(m_player);
for (int i = 0, total = items.count(); i &lt; total; ++i) {
  if (Coin *c = qgraphicsitem_cast&lt;Coin*&gt;(items.at(i)))
    c-&gt;explode();
}</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec121"/>
<em>What just happened?</em>
</h2></div></div></div><p>First we call the scene's <code class="literal">QGraphicsScene::collidingItems()</code> function, which takes the item for which colliding items should be detected as a first argument. With the second, optional argument, you could define how the collision should be detected. The type of that argument is <code class="literal">Qt::ItemSelectionMode</code>, which was explained earlier. In our case, a list of all the items that collide with <code class="literal">m_player</code> will be returned. So we loop through that list and check whether the current item is a <code class="literal">Coin</code> object. This is done by trying to cast the pointer to <code class="literal">Coin.</code> If it is successful, we explode the coin by calling <code class="literal">explode()</code>. Calling the <code class="literal">explode()</code> function multiple times is no problem since it will not allow more than one explosion. This is important since <code class="literal">checkColliding()</code> will be called after each movement of the player. So the first time the player hits a coin, the coin will explode, but this takes time. During this explosion, the player will most likely be moved again and thus collides with the coin once more. In such a case, <code class="literal">explode()</code> may be called for a second, third, xth time.</p><p>The <code class="literal">collidingItems()</code> function will always return the background items as well since the player item is above all of them most of the time. To avoid the continuous check if they actually are coins, we use a trick. In the used <code class="literal">BackgroundItem</code> class for the background items, implement the <code class="literal">QGraphicsItem</code> item's virtual <code class="literal">shape()</code> function as follows:</p><div><pre class="programlisting">QPainterPath BackgroundItem::shape() const {
  return QPainterPath();
}</pre></div><p>Since the collision detection is done with the item's shape, the background items can't collide with any other item since their shape is permanently empty. <code class="literal">QPainterPath</code> itself is a class holding information about graphical shapes. For more information—since we do not need anything special for our game—have a look at the documentation. The class is pretty straightforward.</p><p>Had we done the jumping logic inside <code class="literal">Player</code>, we could have implemented the item collision detection from within the item itself. <code class="literal">QGraphicsItem</code> also offers a <code class="literal">collidingItems()</code> function that checks against colliding items with itself. So <code class="literal">scene-&gt;collidingItems(item)</code> is equivalent to <code class="literal">item-&gt;collidingItems()</code>.</p><p>If you are only interested in whether a item collides with another item, you can call <code class="literal">collidesWithItem()</code> on <a id="id452" class="indexterm"/>the item passing the other item as an argument.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec122"/>Setting up the playing field</h2></div></div></div><p>The last <a id="id453" class="indexterm"/>function we have to discuss is the scene's <code class="literal">initPlayField()</code> function where all is set up. Here we initialize the sky, trees, ground, and player item. Since there is nothing special, we skip that and look directly at how the coins get initialized:</p><div><pre class="programlisting">const int xrange = (m_maxX - m_minX) * 0.94;
m_coins = new QGraphicsRectItem(0,0,m_fieldWidth, m_jumpHeight);
m_coins-&gt;setPen(Qt::NoPen);
for (int i = 0; i &lt; 25; ++i) {
  Coin *c = new Coin(m_coins);
  c-&gt;setPos(m_minX + qrand()%xrange, qrand()%m_jumpHeight);
}
addItem(m_coins);
m_coins-&gt;setPos(0, m_groundLevel - m_jumpHeight);</pre></div><p>In total, we are adding 25 coins. First we calculate the width between <code class="literal">m_minX</code> and <code class="literal">m_maxX</code>. That is the space where Benjamin can move. To make it a little bit smaller, we only take 94 percent of that width. Then we set up an invisible item with the size of the virtual world called <code class="literal">m_coins</code>. This item should be the parent to all coins. Then, in the <code class="literal">for</code> loop we create a coin and randomly set its <em>x</em> and <em>y</em> position, ensuring that Benjamin can reach them by calculating the modulo of the available width and of the maximal jump height. After all 25 coins are added, we place the parent item holding all coins on the scene. Since most coins are outside the actual view's rectangle, we also need to move the coins while Benjamin is moving. Therefore, <code class="literal">m_coins</code> must behave like any other background. For this, we simply add the following code:</p><div><pre class="programlisting">m_coins-&gt;setPos(-(m_coins-&gt;boundingRect().width() - width()) * ff,m_coins-&gt;y());</pre></div><p>We add the preceding code to the <code class="literal">movePlayer()</code> function where we also move the sky by the same pattern.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec123"/>Have a go hero – extending the game</h2></div></div></div><p>That is it. This <a id="id454" class="indexterm"/>is our little game. Of course, there is much room to improve and extend it. For example, you can add some barricades Benjamin has to jump over. Then, you would have to check if the player item collides with such a barricade item when moving forward, and if so, refuse movement. You have learned all the necessary techniques you need for that task, so try to implement some additional features to deepen your knowledge.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec124"/>A third way of animation</h2></div></div></div><p>Besides <code class="literal">QTimer</code> <a id="id455" class="indexterm"/>and <code class="literal">QPropertyAnimation</code>, there is a third way to animate the scene. The scene provides a slot called <code class="literal">advance()</code>. If you call that slot, the scene will forward that call to all items it holds by calling <code class="literal">advance()</code> on each one. The scene does that twice. First, all item <code class="literal">advance()</code> functions are called with <code class="literal">0</code> as an argument. This means that the items are about to advance. Then in the second round, all items are called passing 1 to the item's <code class="literal">advance()</code> function. In that phase each item should advance, whatever that means; maybe moving, maybe a color change, and so on. The scene's slot advance is typically called by a <code class="literal">QTimeLine</code> element; with this, you can define how many times during a specific period of time the timeline should be triggered.</p><div><pre class="programlisting">QTimeLine *timeLine = new QTimeLine(5000, this);
timeLine-&gt;setFrameRange(0, 10);</pre></div><p>This timeline will emit the signal <code class="literal">frameChanged()</code> every 5 seconds for 10 times. All you have to do is to connect that signal to the scene's <code class="literal">advance()</code> slot and the scene will advance 10 times during 50 seconds. However, since all items receive two calls for each advance, this may not be the best animation solution for scenes with a lot of items where only a few should advance.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec89"/>Widgets inside Graphics View</h1></div></div></div><p>In order to <a id="id456" class="indexterm"/>show a neat feature of Graphics View, have a look at the following code snippet, which adds a widget to the scene:</p><div><pre class="programlisting">QSpinBox *box = new QSpinBox;
QGraphicsProxyWidget *proxyItem = new QGraphicsProxyWidget;
proxyItem-&gt;setWidget(box);
QGraphicsScene scene;
scene.addItem(proxyItem);
proxyItem-&gt;setScale(2);
proxyItem-&gt;setRotation(45);</pre></div><p>First we create a <code class="literal">QSpinBox</code> and a <code class="literal">QGraphicsProxyWidget</code> element, which act as containers for widgets and indirectly inherit <code class="literal">QGraphicsItem.</code> Then we add the spin box to the the proxy widget by calling <code class="literal">addWidget()</code>. The ownership of the spin box isn't transferred, but when <code class="literal">QGraphicsProxyWidget</code> gets deleted, it calls <code class="literal">delete</code> on all assigned widgets. We thus do not have to worry about that ourselves. The widget you add should be parentless and must not be shown elsewhere. After setting the widget to the proxy, you can treat the proxy widget like any other item. Next, we add it to the scene and apply a transformation for demonstration. As a result we get this:</p><div><img src="img/8874OS_06_19.jpg" alt="Widgets inside Graphics View"/><div><p>A rotated and scaled spin box on a scene</p></div></div><p>Since it is a regular item, you can even animate it, for example, with a property animation. Nevertheless, be aware that, originally, Graphics View wasn't designed for holding widgets. So when you add a lot of widgets to the scene, you will quickly notice performance issues, but in most situations it should be fast enough.</p><p>If you want to <a id="id457" class="indexterm"/>arrange some widgets in a layout, you can use <code class="literal">QGraphicsAnchorLayout</code>, <code class="literal">QGraphicsGridLayout</code>, or <code class="literal">QGraphicsLinearLayout</code>. Create all widgets, create a layout of your choice, add the widgets to that layout, and set the layout to a <code class="literal">QGraphicsWidget</code> element, which is the base class for all widgets and is easily spoken the <code class="literal">QWidget</code> equivalent for Graphics View by calling <code class="literal">setLayout()</code>:</p><div><pre class="programlisting">QGraphicsScene scene;
QGraphicsProxyWidget *edit = scene.addWidget(
  new QLineEdit("Some Text"));
QGraphicsProxyWidget *button = scene.addWidget(
  new QPushButton("Click me!"));
QGraphicsLinearLayout *layout = new QGraphicsLinearLayout;
layout-&gt;addItem(edit);
layout-&gt;addItem(button);
QGraphicsWidget *graphicsWidget = new QGraphicsWidget;
graphicsWidget-&gt;setLayout(layout);
scene.addItem(graphicsWidget);</pre></div><p>The scene's <code class="literal">addWidget()</code> function is a convenience function and behaves in the first usage for <code class="literal">QLineEdit</code>, as shown in the following code snippet:</p><div><pre class="programlisting">QGraphicsProxyWidget *proxy = new QGraphicsProxyWidget(0);
proxy-&gt;setWidget(new QLineEdit("Some Text"));
scene.addItem(proxy);</pre></div><p>The item with the layout will look like this:</p><div><img src="img/8874OS_06_20.jpg" alt="Widgets inside Graphics View"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec90"/>Optimization</h1></div></div></div><p>Let us now take a <a id="id458" class="indexterm"/>look at some of the optimizations we can perform to speed up the scene.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec125"/>A binary space partition tree</h2></div></div></div><p>The scene <a id="id459" class="indexterm"/>constantly keeps record of the position of the item in its internal binary space partition tree. Thus, on every move of an item, the scene has to update the tree, an operation that can become quite time-and memory-consuming. This is especially true of scenes with a large number of animated items. On the other hand, the tree enables you to find an item (for example, with <code class="literal">items()</code> or <code class="literal">itemAt()</code>) incredibly fast even if you have thousands of items.</p><p>So when you do not need any positional information about the items—this also includes collision detection—you can disable the index function by calling <code class="literal">setItemIndexMethod(QGraphicsScene::NoIndex)</code>. Be aware, however, that a call to <code class="literal">items()</code> or <code class="literal">itemAt()</code> results in a loop through all items in order to do the collision detection, which can cause performance problems for scenes with many items. If you cannot relinquish the tree in total, you still can adjust the depth of the tree with <code class="literal">setBspTreeDepth()</code>, taking the depth as an argument. By default, the scene will guess a reasonable value after it takes several parameters, such as the size and the number of items, into account.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec126"/>Caching the item's paint function</h2></div></div></div><p>If you <a id="id460" class="indexterm"/>have items with a time-consuming paint function, you can change the item's cache mode. By default, no rendering is cached. With <code class="literal">setCacheMode()</code>, you can set the mode to either <code class="literal">ItemCoordinateCache</code> or to <code class="literal">DeviceCoordinateCache</code>. The former renders the the item in a cache of a given <code class="literal">QSize</code> element. The size of that cache can be controlled with the second argument of <code class="literal">setCacheMode()</code>. So the quality depends on how much space you assign. The cache is then used for every subsequent paint call. The cache is even used for applying transformations. If the quality deteriorates too much, just adjust the resolution by calling <code class="literal">setCacheMode()</code> again, but with a larger <code class="literal">QSize</code> element. <code class="literal">DeviceCoordinateCache</code>, on the other hand, does not cache the item on an item base but rather on a device <a id="id461" class="indexterm"/>level. This is therefore optimal for items that do not get transformed all the time, because every new transformation will cause a new caching. Moving the item, however, does not end in a new cache. If you use this cache mode, you do not have to define a resolution with the second argument. The caching is always performed at maximum quality.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec127"/>Optimizing the view</h2></div></div></div><p>Since we <a id="id462" class="indexterm"/>are talking about the item's paint function, let's touch on something related. At the beginning, when we discussed the item's appearance and made a black rectangle item, I told you to return the painter as you get. If you have followed this advice, you can call <code class="literal">setOptimizationFlag(DontSavePainterState, true)</code> on the view. By default, the view ensures that the painter state is saved before calling the item's paint function and that the state gets restored afterward. This will end up saving and restoring the painter state say 50 times if you have a scene with 50 items. If you prevent automatic saving and restoring, keep in mind that now the standard items will alter the painter state. So if you use both standard and custom items, either stay with the default behavior or set <code class="literal">DontSavePainterState</code>, but then set up the pen and brush with a default value in each item's paint function.</p><p>Another flag that can be used with <code class="literal">setOptimizationFlag()</code> is <code class="literal">DontAdjustForAntialiasing</code>. By default, the view adjusts the painting area of each item by 2 pixels in all directions. This is useful because when one paints antialiased, one easily draws outside the bounding rectangle. Enable that optimization if you do not paint antialiased or if you are sure your painting will stay inside the bounding rectangle. If you enable this flag and spot painting artifacts on the view, you haven't respected the item's bounding rectangle!</p><p>As a further optimization, you can define how the view should update its viewport when the scene changes. You can set the different modes with <code class="literal">setViewportUpdateMode()</code>. By default (<code class="literal">QGraphicsView::MinimalViewportUpdate</code>), the view tries to determinate only those areas which need an update and repaints only these. However, sometimes it is more time-consuming to find all the areas that need a redraw than to just paint the entire viewport. This applies if you have many small updates. Then, <code class="literal">QGraphicsView::FullViewportUpdate</code> is the better choice since it simply repaints the whole viewport. A kind of combination of the last two modes is <code class="literal">QGraphicsView::BoundingRectViewportUpdate</code>. In this mode, Qt detects all areas that need a redraw and then it redraws a rectangle of the viewport that covers all areas affected by the change. If the optimal update mode changes over time, you can tell Qt to determine the best mode by using <code class="literal">QGraphicsView::SmartViewportUpdate</code>. The view then tries to find the best update mode.</p><p>As a last optimization, you can take advantage of OpenGL. Instead of using the default viewport based on <code class="literal">QWidget</code>, advise Graphics View to use an OpenGL widget. This way, you can use all the power that comes with OpenGL.</p><div><pre class="programlisting">GraphicsView view;
view.setViewport(new QGLWidget(&amp;view));</pre></div><p>Unfortunately, you <a id="id463" class="indexterm"/>have to do a little more than just putting in this line, but that goes beyond the topic and scope of this chapter. You can, however, find more information about OpenGL and Graphics View in Qt's documentation example under "Boxes" as well as in Rødal's Qt Quarterly article–issue 26–which can be found online at <a class="ulink" href="http://doc.qt.digia.com/qq/qq26-openglcanvas.html">http://doc.qt.digia.com/qq/qq26-openglcanvas.html</a>.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>A general note on optimization: Unfortunately I can't say that you have to do this or that to optimize Graphics View as it highly depends on your system and view/scene. What I can tell you, however, is how to proceed. Once you have finished your game based on Graphics View, measure the performance of your game using a profiler. Make an optimization you think may pay or simply guess and then profile your game again. If the results are better, keep the change; otherwise, reject it. This sounds simple and is the only way optimization can be done. There are no hidden tricks or deeper knowledge. With time, however, your forecasting will get better.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec128"/>Pop quiz – mastering Graphics View</h2></div></div></div><p>After studying this chapter, you should be able to answer these questions as they are important when it comes to designing the components of a game based on Graphics View:</p><p>Q1. What standard items does Qt offer?</p><p>Q2. How is the coordinate system of an item related to the coordinate system of the scene? Next, how is the coordinate system of the scene related to the coordinate system of the view?</p><p>Q3. How can one extend items to use properties as well as signals and slots?</p><p>Q4. How can one create realistic movements with the help of animations?</p><p>Q5. How can Graphics View's performance be improved?</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec91"/>Summary</h1></div></div></div><p>In the first part of this chapter, you have learned how the Graphics View architecture works. First, we had a look at the items. There you learned how to create your own items by using <code class="literal">QPainter</code> and which kinds of standard item Qt has to offer. Later on, we also discussed how to transform these items and what the point of origin for that transformation has to do with it. Next we went through the coordinate system of the items, the scene, and the view. We also saw how these three parts work together, for example. how to put items on a scene. Lastly, we learned how to scale and move the scene inside the view. At the same time, you read about advanced topics, such as taking the zoom level into account when painting an item.</p><p>In the second part you, deepened your knowledge about items, about the scene, and about the view. While developing the game, you became familiar with different approaches on how to animate items, and you were taught how to detect collisions. As an advanced topic, you were introduced to parallax scrolling.</p><p>After having completed the entire chapter, you should now know almost everything about Graphics View. You are able to create complete custom items, you can alter or extend standard items, and with the information about the level of detail you even have the power to alter an item's appearance, depending on its zoom level. You can transform items and the scene, and you can animate items and, thus, the entire scene.</p><p>Furthermore, as you have seen while developing the game, your skills are good enough to develop a jump-and-run game with parallax scrolling as it is used in highly professional games. To keep your game fluid and highly responsive, finally we saw some tricks on how to get the most out of Graphics View.</p><p>In order to build a bridge to the world of widgets, you also learned how to incorporate items based on <code class="literal">QWidget</code> into Graphics View. With that knowledge, you can create modern, widget-based user interfaces.</p></div></body></html>