- en: Chapter 1. Starting to Write Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 开始编写你的应用程序
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Getting configuration options
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取配置选项
- en: Storing any value in a container/variable
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器/变量中存储任何值
- en: Storing multiple chosen types in a container/variable
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器/变量中存储多个选定的类型
- en: Using a safer way to work with a container that stores multiple chosen types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一种更安全的方式来处理存储多个选定类型的数据容器
- en: Returning a value or flag where there is no value
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有值的情况下返回一个值或标志
- en: Returning an array from a function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从函数中返回一个数组
- en: Combining multiple values into one
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个值合并为一个
- en: Reordering the parameters of a function
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新排序函数的参数
- en: Binding a value as a function parameter
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值绑定为一个函数参数
- en: Using the C++11 move emulation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C++11 移动模拟
- en: Making a noncopyable class
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个不可复制的类
- en: Making a noncopyable but movable class
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个不可复制但可移动的类
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Boost is a collection of C++ libraries. Each library has been reviewed by many
    professional programmers before being accepted to Boost. Libraries are tested
    on multiple platforms using many compilers and the C++ standard library implementations.
    While using Boost, you can be sure that you are using one of the most portable,
    fast, and reliable solutions that is distributed under a license suitable for
    commercial and open source projects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 是一组 C++ 库。每个库在被接受到 Boost 之前都经过了众多专业程序员的审查。库在多个平台上使用多个编译器和 C++ 标准库实现进行测试。在使用
    Boost 时，你可以确信你正在使用一个最可移植、快速和可靠的解决方案，该解决方案适用于商业和开源项目。
- en: Many parts of Boost have been included in C++11, and even more parts are going
    to be included in the next standard of C++. You will find C++11-specific notes
    in each recipe of this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 的许多部分已经被包含在 C++11 中，甚至更多部分将被包含在下一个 C++ 标准中。你将在本书的每个菜谱中找到 C++11 特定的说明。
- en: Without a long introduction, let's get started!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不进行长篇大论，让我们开始吧！
- en: In this chapter we will see some recipes for everyday use. We'll see how to
    get configuration options from different sources and what can be cooked up using
    some of the datatypes introduced by Boost library authors.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到一些日常使用的菜谱。我们将了解如何从不同的来源获取配置选项，以及可以使用 Boost 库作者引入的一些数据类型制作什么。
- en: Getting configuration options
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取配置选项
- en: 'Take a look at some of the console programs, such as `cp` in Linux. They all
    have a fancy help, their input parameters do not depend on any position, and have
    a human readable syntax, for example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看一看一些控制台程序，例如 Linux 中的 `cp`。它们都有花哨的帮助，它们的输入参数不依赖于任何位置，并且具有人类可读的语法，例如：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can implement the same functionality for your program in 10 minutes. And
    all you need is the `Boost.ProgramOptions` library.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在10分钟内为你的程序实现相同的功能。你所需要的只是 `Boost.ProgramOptions` 库。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ is all you need for this recipe. Remember that this library
    is not a header-only, so your program will need to link against the `libboost_program_options`
    library.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你需要具备基本的 C++ 知识。记住，这个库不是仅头文件，所以你的程序需要链接到 `libboost_program_options` 库。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s start with a simple program that accepts the number of apples and oranges
    as input and counts the total number of fruits. We want to achieve the following
    result:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个小程序开始，该程序接受苹果和橙子的数量作为输入并计算水果的总数。我们希望达到以下结果：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Perform the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'First of all, we need to include the `program_options` header and make an alias
    for the `boost::program_options` namespace (it is too long to type it!). We would
    also need an `<iostream>` header:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要包含 `program_options` 头文件并为 `boost::program_options` 命名空间创建一个别名（它太长了，难以输入！）我们还需要一个
    `<iostream>` 头文件：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we are ready to describe our options:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好描述我们的选项：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We''ll see how to use a third parameter a little bit later, after which we''ll
    deal with parsing the command line and outputting the result:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在稍后一点时间看到如何使用第三个参数，之后我们将处理解析命令行和输出结果：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That was simple, wasn't it?
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这很简单，不是吗？
- en: 'Let''s add the `--help` parameter to our option''s description:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们向我们的选项描述中添加 `--help` 参数：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now add the following lines after `opt::notify(vm);`, and you''ll get a fully
    functional help for your program:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在 `opt::notify(vm);` 之后添加以下行，你将为你的程序获得一个完全功能性的帮助：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, if we call our program with the `--help` parameter, we''ll get the following
    output:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果我们用 `--help` 参数调用我们的程序，我们将得到以下输出：
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we do not provide a type for the option's value, because we
    do not expect any values to be passed to it.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们没有为选项的值提供类型，因为我们不期望任何值传递给它。
- en: 'Once we have got through all the basics, let''s add short names for some of
    the options, set the default value for apples, add some string input, and get
    the missing options from the configuration file:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们掌握了所有基础知识，让我们为一些选项添加简短名称，为苹果设置默认值，添加一些字符串输入，并从配置文件中获取缺失的选项：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When using a configuration file, we need to remember that its syntax differs
    from the command-line syntax. We do not need to place minuses before the options.
    So our `apples_oranges.cfg` option must look like this:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用配置文件时，我们需要记住，其语法与命令行语法不同。我们不需要在选项前放置减号。因此，我们的`apples_oranges.cfg`选项必须看起来像这样：
- en: '`oranges=20`'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`oranges=20`'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This example is pretty trivial to understand from code and comments. Much more
    interesting is what output we get on execution:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码和注释中理解这个例子非常简单。更有趣的是我们在执行时得到的结果：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There's more...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The C++11 standard adopted many Boost libraries; however, you won't find `Boost.ProgramOptions`
    in it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准采用了许多Boost库；然而，你不会在其中找到`Boost.ProgramOptions`。
- en: See also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Boost''s official documentation contains many more examples and shows more
    advanced features of `Boost.ProgramOptions`, such as position-dependent options,
    nonconventional syntax, and more. This is available at the following link:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的官方文档包含更多示例，并展示了`Boost.ProgramOptions`的更多高级特性，如位置相关的选项、非常规语法等。这可以在以下链接中找到：
- en: '[http://www.boost.org/doc/libs/1_53_0/doc/html/program_options.html](http://www.boost.org/doc/libs/1_53_0/doc/html/program_options.html)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/doc/html/program_options.html](http://www.boost.org/doc/libs/1_53_0/doc/html/program_options.html)'
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books that you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt书籍的账户中下载示例代码文件。[http://www.PacktPub.com](http://www.PacktPub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.PacktPub.com/support](http://www.PacktPub.com/support)并注册以直接将文件通过电子邮件发送给你。
- en: Storing any value in a container/variable
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器/变量中存储任何值
- en: 'If you have been programming in Java, C#, or Delphi, you will definitely miss
    the ability to create containers with the `Object` value type in C++. The `Object`
    class in those languages is a basic class for almost all types, so you are able
    to assign (almost) any value to it at any time. Just imagine how great it would
    be to have such a feature in C++:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在使用Java、C#或Delphi编程，你肯定会怀念在C++中创建具有`Object`值类型的容器的能力。在这些语言中，`Object`类是几乎所有类型的基本类，因此你可以在任何时候将其分配给（几乎）任何值。想象一下，如果C++有这样一个特性会多么好：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be working with the header-only library. Basic knowledge of C++ is all
    you need for this recipe.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用仅包含头文件的库。对于这个配方，你只需要具备基本的C++知识。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In such cases, Boost offers a solution, the `Boost.Any` library, which has
    an even better syntax:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Boost提供了一个解决方案，即`Boost.Any`库，它具有更好的语法：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Great, isn't it? By the way, it has an empty state, which could be checked using
    the `empty()` member function (just as in STL containers).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，不是吗？顺便说一下，它有一个空状态，可以使用`empty()`成员函数进行检查（就像在STL容器中一样）。
- en: 'You can get the value from `boost::any` using two approaches:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用两种方法从`boost::any`获取值：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::any` class just stores any value in it. To achieve this it uses
    the **type erasure** technique (close to what Java or C# does with all of its
    types). To use this library, you do not really need to know its internal implementation,
    so let's just have a quick glance at the type erasure technique. `Boost.Any`,
    on assignment of some variable of type `T`, constructs a type (let's call it `holder<T>`)
    that may store a value of the specified type `T`, and is derived from some internal
    base-type placeholder. A placeholder has virtual functions for getting `std::type_info`
    of a stored type and for cloning a stored type. When `any_cast<T>()` is used,
    `boost::any` checks that `std::type_info` of a stored value is equal to `typeid(T)`
    (the overloaded placeholder's function is used for getting `std::type_info`).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::any`类只是存储任何值。为了实现这一点，它使用**类型擦除**技术（类似于Java或C#对其所有类型所做的那样）。要使用这个库，您实际上并不需要了解其内部实现，所以我们只需快速浏览一下类型擦除技术。当对类型为`T`的某个变量进行赋值时，`Boost.Any`构造一个类型（让我们称它为`holder<T>`），它可以存储指定类型`T`的值，并且是从某个内部基类型占位符派生出来的。占位符有用于获取存储类型的`std::type_info`的虚拟函数和用于克隆存储类型的虚拟函数。当使用`any_cast<T>()`时，`boost::any`检查存储值的`std::type_info`是否等于`typeid(T)`（使用重载的占位符函数来获取`std::type_info`）。'
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Such flexibility never comes without a cost. Copy constructing, value constructing,
    copy assigning, and assigning values to instances of `boost::any` will call a
    dynamic memory allocation function; all of the type casts need to get **runtime
    type information** (**RTTI**); `boost::any` uses virtual functions a lot. If you
    are keen on performance, see the next recipe, which will give you an idea of how
    to achieve almost the same results without dynamic allocations and RTTI usage.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的灵活性从来都不是没有代价的。复制构造、值构造、复制赋值以及将值赋给`boost::any`的实例将调用动态内存分配函数；所有的类型转换都需要获取**运行时类型信息**（**RTTI**）；`boost::any`大量使用虚拟函数。如果您对性能很感兴趣，请看下一个菜谱，它将给您一个在没有动态分配和RTTI使用的情况下实现几乎相同结果的想法。
- en: Another disadvantage of `Boost.Any` is that it cannot be used with RTTI disabled.
    There is a possibility to make this library usable even with RTTI disabled, but
    it is not currently implemented.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Any`的另一个缺点是它不能与禁用RTTI一起使用。有可能使这个库即使在禁用RTTI的情况下也能使用，但目前还没有实现。'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Almost all exceptions in Boost derive from the `std::exception` class or from
    its derivatives, for example, `boost::bad_any_cast` is derived from `std::bad_cast`.
    It means that you can catch almost all Boost exceptions using `catch (const std::exception&
    e)`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的Boost异常都源自`std::exception`类或其派生类，例如，`boost::bad_any_cast`是从`std::bad_cast`派生出来的。这意味着您可以使用`catch
    (const std::exception& e)`捕获几乎所有的Boost异常。
- en: See also
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Boost's official documentation may give you some more examples, and it can be
    found at [http://www.boost.org/doc/libs/1_53_0/doc/html/any.html](http://www.boost.org/doc/libs/1_53_0/doc/html/any.html)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的官方文档可能给您一些更多的例子，您可以在[http://www.boost.org/doc/libs/1_53_0/doc/html/any.html](http://www.boost.org/doc/libs/1_53_0/doc/html/any.html)找到它。
- en: The *Using a safer way to work with a container that stores multiple chosen
    types* recipe for more info on the topic
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看有关“使用更安全的方式来处理存储多个选定类型的容器”菜谱以获取更多关于该主题的信息
- en: Storing multiple chosen types in a variable/container
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在变量/容器中存储多个选定的类型
- en: Are you aware of the concept of unrestricted unions in C++11? Let me tell you
    about it in short. **C++03 unions** can only hold extremely simple types of data
    called POD (plain old data). So in C++03, you cannot, for example, store `std::string`
    or `std::vector` in a union. C++11 relaxes this requirement, but you'll have to
    manage the construction and destruction of such types by yourself, call in-place
    construction/destruction, and remember what type is stored in a union. A huge
    amount of work, isn't it?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否了解C++11中无限制联合的概念？让我简要地告诉您。**C++03联合**只能存储称为POD（普通旧数据）的非常简单的数据类型。因此，在C++03中，您不能在联合中存储`std::string`或`std::vector`。C++11放宽了这一要求，但您必须自己管理这些类型的构造和析构，调用就地构造/析构，并记住存储在联合中的类型。这是一项巨大的工作，不是吗？
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be working with the header-only library, which is simple to use. Basic
    knowledge of C++ is all you need for this recipe.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用仅包含头文件的库进行工作，这个库使用起来很简单。您只需要具备基本的C++知识就可以使用这个菜谱。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Let me introduce the `Boost.Variant` library to you.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我来向您介绍`Boost.Variant`库。
- en: 'The `Boost.Variant` library can store any of the types specified at compile
    time; it also manages in-place construction/destruction and doesn''t even require
    the C++11 standard:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Boost.Variant` 库可以存储编译时指定的任何类型；它还管理就地构造/销毁，甚至不需要 C++11 标准：'
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Great, isn't it?
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太棒了，不是吗？
- en: '`Boost.Variant` has no empty state, but has an `empty()` function, which always
    returns `false`. If you do need to represent an empty state, just add some trivial
    type at the first position of the types supported by the `Boost.Variant` library.
    When `Boost.Variant` contains that type, interpret it as an empty state. Here
    is an example in which we will use a `boost::blank` type to represent an empty
    state:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Boost.Variant` 没有空状态，但它有一个 `empty()` 函数，该函数始终返回 `false`。如果你确实需要表示一个空状态，只需在
    `Boost.Variant` 库支持的类型中的第一个位置添加一些平凡类型。当 `Boost.Variant` 包含该类型时，将其解释为空状态。以下是一个示例，我们将使用
    `boost::blank` 类型来表示空状态：'
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can get a value from a variant using two approaches:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用两种方法从变体中获取值：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::variant` class holds an array of characters and stores values in
    that array. Size of the array is determined at compile time using `sizeof()` and
    functions to get alignment. On assignment or construction of `boost::variant`,
    the previous values are in-place destroyed, and new values are constructed on
    top of the character array using the new placement.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::variant` 类持有一个字符数组，并在该数组中存储值。数组的大小在编译时使用 `sizeof()` 和获取对齐的函数确定。在赋值或构造
    `boost::variant` 时，之前的值就地销毁，并在字符数组上使用新的放置构造新值。'
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Boost.Variant` variables usually do not allocate memory in a heap, and
    they do not require RTTI to be enabled. `Boost.Variant` is extremely fast and
    used widely by other Boost libraries. To achieve maximum performance, make sure
    that there is a trivial type in the list of supported types, and that this type
    is at the first position.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Variant` 变量通常不会在堆上分配内存，并且它们不需要启用 RTTI。`Boost.Variant` 非常快，并且被其他 Boost
    库广泛使用。为了达到最佳性能，请确保支持类型列表中有一个平凡类型，并且该类型位于第一个位置。'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Boost.Variant` is not a part of the C++11 standard.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Variant` 不是 C++11 标准的一部分。'
- en: See also
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using a safer way to work with a container that stores multiple chosen
    types* recipe
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用更安全的方式来处理存储多个选定类型的容器* 菜谱'
- en: 'Boost''s official documentation contains more examples and descriptions of
    some other features of `Boost.Variant`, and can be found at:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost 的官方文档包含了更多关于 `Boost.Variant` 的示例和一些其他特性的描述，可以在以下位置找到：
- en: '[http://www.boost.org/doc/libs/1_53_0/doc/html/variant.html](http://www.boost.org/doc/libs/1_53_0/doc/html/variant.html)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/doc/html/variant.html](http://www.boost.org/doc/libs/1_53_0/doc/html/variant.html)'
- en: Using a safer way to work with a container that stores multiple chosen types
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更安全的方式来处理存储多个选定类型的容器
- en: Imagine that you are creating a wrapper around some SQL database interface.
    You decided that `boost::any` will perfectly match the requirements for a single
    cell of the database table. Some other programmer will be using your classes,
    and his task would be to get a row from the database and count the sum of the
    arithmetic types in a row.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在创建一个围绕某些 SQL 数据库接口的包装器。你决定 `boost::any` 将完美地满足数据库表单单元格的要求。其他程序员将使用你的类，他的任务是从数据库中获取一行并计算行中算术类型的总和。
- en: 'Here''s how the code would look:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的样貌：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you compile and run this example, it will output a correct answer:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并运行这个示例，它将输出正确的结果：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Do you remember what your thoughts were when reading the implementation of `operator()`?
    I guess they were, "And what about double, long, short, unsigned, and other types?".
    The same thoughts will come to the mind of a programmer who will use your interface.
    So you'll need to carefully document values stored by your `cell_t`, or read the
    more elegant solution described in the following sections.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得阅读 `operator()` 的实现时你的想法吗？我猜它们是，“那么 double、long、short、unsigned 以及其他类型怎么办？”。同样的想法也会出现在使用你的接口的程序员心中。所以你需要仔细记录你的
    `cell_t` 存储的值，或者阅读以下章节中描述的更优雅的解决方案。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Reading the previous two recipes is highly recommended if you are not already
    familiar with the `Boost.Variant` and `Boost.Any` libraries.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉 `Boost.Variant` 和 `Boost.Any` 库，强烈建议你阅读前面的两个菜谱。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: The `Boost.Variant` library implements a visitor programming pattern for accessing
    the stored data, which is much safer than getting values via `boost::get<>`. This
    pattern forces the programmer to take care of each variant type, otherwise the
    code will fail to compile. You can use this pattern via the `boost::apply_visitor`
    function, which takes a visitor functional object as the first parameter and a
    variant as the second parameter. Visitor functional objects must derive from the
    `boost::static_visitor<T>` class, where `T` is a type being returned by a visitor.
    A visitor object must have overloads of `operator()` for each type stored by a
    variant.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Variant` 库实现了一种访问存储数据的访问者编程模式，这比通过 `boost::get<>` 获取值要安全得多。这种模式迫使程序员注意每个变体类型，否则代码将无法编译。您可以通过
    `boost::apply_visitor` 函数使用此模式，该函数将访问者功能对象作为第一个参数，将变体作为第二个参数。访问者功能对象必须从 `boost::static_visitor<T>`
    类派生，其中 `T` 是访问者返回的类型。访问者对象必须为变体存储的每个类型重载 `operator()`。'
- en: 'Let''s change the `cell_t` type to `boost::variant<int, float, string>` and
    modify our example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `cell_t` 类型更改为 `boost::variant<int, float, string>` 并修改我们的示例：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `Boost.Variant` library will generate a big `switch` statement at compile
    time, each case of `which` will call a visitor for a single type from the variant''s
    list of types. At runtime, the index of the stored type can be retrieved using
    `which()`, and a jump to the correct case in the switch will be made. Something
    like this will be generated for `boost::variant<int, float, std::string>`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Variant` 库将在编译时生成一个大的 `switch` 语句，每个 `case` 都将调用变体类型列表中的单个类型的访问者。在运行时，可以使用
    `which()` 获取存储类型的索引，并跳转到 `switch` 语句中的正确 `case`。对于 `boost::variant<int, float,
    std::string>`，将生成类似以下的内容：'
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the `address()` function returns a pointer to the internal storage of
    `boost::variant<int, float, std::string>`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`address()` 函数返回 `boost::variant<int, float, std::string>` 的内部存储指针。
- en: There's more...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we compare this example with the first example in this recipe, we''ll see
    the following advantages of `boost::variant`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此示例与配方中的第一个示例进行比较，我们将看到 `boost::variant` 的以下优点：
- en: We know what types a variable can store
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道一个变量可以存储哪些类型
- en: If a library writer of the SQL interface adds or modifies a type held by a variant,
    we'll get a compile-time error instead of incorrect behavior
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 SQL 接口库的编写者向变体中添加或修改类型，我们将得到编译时错误而不是不正确的行为。
- en: See also
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: After reading some recipes from [Chapter 4](ch04.html "Chapter 4. Compile-time
    Tricks"), *Compile-time Tricks*, you'll be able to make the visitor object so
    generic that it will be able to work correctly even if the underlying types change
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在阅读了 [第 4 章](ch04.html "第 4 章。编译时技巧") 中的部分内容后，*编译时技巧*，您将能够使访问者对象如此通用，即使底层类型发生变化，它也能正确工作。
- en: 'Boost''s official documentation contains more examples and a description of
    some other features of `Boost.Variant`, and is available at the following link:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost 的官方文档包含了更多示例和 `Boost.Variant` 的某些其他特性的描述，可在以下链接找到：
- en: '[http://www.boost.org/doc/libs/1_53_0/doc/html/variant.html](http://www.boost.org/doc/libs/1_53_0/doc/html/variant.html)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/doc/html/variant.html](http://www.boost.org/doc/libs/1_53_0/doc/html/variant.html)'
- en: Returning a value or flag where there is no value
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在没有值的情况下返回值或标志
- en: Imagine that we have a function that does not throw an exception and returns
    a value or indicates that an error has occurred. In Java or C# programming languages,
    such cases are handled by comparing a return value from a function value with
    a null pointer; if it is null then an error has occurred. In C++, returning a
    pointer from a function confuses library users and usually requires dynamic memory
    allocation (which is slow).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个不抛出异常并返回值或指示发生错误的函数。在 Java 或 C# 编程语言中，这些情况通过比较函数返回值与空指针来处理；如果是空指针，则表示发生了错误。在
    C++ 中，从函数返回指针会混淆库用户，并且通常需要动态内存分配（这很慢）。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ is required for this recipe.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方只需要基本的 C++ 知识。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Ladies and gentlemen, let me introduce you to the `Boost.Optional` library
    using the following example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 女士们，先生们，让我通过以下示例向您介绍 `Boost.Optional` 库：
- en: 'The `try_lock_device()` function tries to acquire a lock for a device, and
    may succeed or not depending on different conditions (in our example it depends
    on the `rand()` function call). The function returns an optional variable that
    can be converted to a Boolean variable. If the returned value is equal to Boolean
    `true`, then the lock is acquired, and an instance of a class to work with the
    device can be obtained by dereferencing the returned optional variable:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_lock_device()`函数尝试为设备获取锁，可能成功也可能不成功，这取决于不同的条件（在我们的例子中取决于`rand()`函数调用）。该函数返回一个可选变量，可以转换为布尔变量。如果返回值等于布尔`true`，则已获取锁，可以通过解引用返回的可选变量来获取用于处理设备的类的实例：'
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This program will output the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将输出以下内容：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default constructed `optional` variable is convertible to a Boolean variable
    holding `false` and must not be dereferenced, because it does not have an underlying
    type constructed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造的`optional`变量可以转换为持有`false`的布尔变量，并且不得解引用，因为它没有构造的底层类型。
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Boost.Optional` class is very close to the `boost::variant` class but for
    only one type, `boost::optional<T>` has an array of `chars`, where the object
    of type `T` can be an in-place constructor. It also has a Boolean variable to
    remember the state of the object (is it constructed or not).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Optional`类与`boost::variant`类非常相似，但只针对一种类型，`boost::optional<T>`有一个`chars`数组，其中类型为`T`的对象可以是一个就地构造器。它还有一个布尔变量来记住对象的状态（是否已构造）。'
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Boost.Optional` class does not use dynamic allocation, and it does not
    require a default constructor for the underlying type. It is fast and considered
    for inclusion in the next standard of C++. The current `boost::optional` implementation
    cannot work with C++11 **rvalue** references; however, there are some patches
    proposed to fix that.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Optional`类不使用动态分配，并且不需要底层类型的默认构造函数。它速度快，被认为将被纳入C++的下一个标准。当前的`boost::optional`实现不能与C++11
    **右值引用**一起工作；然而，已经提出了一些补丁来修复这个问题。'
- en: The C++11 standard does not include the `Boost.Optional` class; however, it
    is currently being reviewed for inclusion in the next C++ standard or in C++14.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准不包括`Boost.Optional`类；然而，它目前正在被审查，以纳入下一个C++标准或C++14。
- en: See also
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Boost''s official documentation contains more examples and describes advanced
    features of `Boost.Optional` (like in-place construction using the factory functions).
    The documentation is available at the following link:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的官方文档包含更多示例，并描述了`Boost.Optional`的先进特性（如使用工厂函数的就地构造）。文档可在以下链接找到：
- en: '[http://www.boost.org/doc/libs/1_53_0/libs/optional/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/optional/doc/html/index.html)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/libs/optional/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/optional/doc/html/index.html)'
- en: Returning an array from a function
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从函数返回数组
- en: Let's play a guessing game! What can you tell about the following function?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩一个猜谜游戏！你能从以下函数中了解到什么？
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Should return values be deallocated by the programmer or not? Does the function
    attempt to deallocate the input parameter? Should the input parameter be zero-terminated,
    or should the function assume that the input parameter has a specified width?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 应该由程序员来释放返回值吗？函数是否尝试释放输入参数？输入参数应该是以零结尾，还是函数应该假设输入参数具有指定的宽度？
- en: 'And now, let''s make the task harder! Take a look at the following line:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使任务更难！看看以下行：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Please do not worry; I've also been scratching my head for half an hour before
    getting an idea of what is happening here. `vector_advance` is a function that
    accepts and returns an array of four elements. Is there a way to write such a
    function clearly?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要担心；在得到这里发生的事情的想法之前，我也一直在挠头半小时。`vector_advance`是一个接受并返回四个元素数组的函数。有没有办法清楚地写出这样的函数？
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ is required for this recipe.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱只需要基本的C++知识。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We can rewrite the function like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样重写函数：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, `boost::array<char, 4>` is just a simple wrapper around an array of four
    char elements.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`boost::array<char, 4>`只是围绕四个字符元素的数组的一个简单包装器。
- en: This code answers all of the questions from our first example and is much more
    readable than the second example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码回答了我们第一个示例中的所有问题，并且比第二个示例更易于阅读。
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first template parameter of `boost::array` is the element type, and the
    second one is the size of an array. `boost::array` is a fixed-size array; if you
    need to change the array size at runtime, use `std::vector` or `boost::container::vector`
    instead.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::array` 的第一个模板参数是元素类型，第二个是数组的大小。`boost::array` 是一个固定大小的数组；如果需要在运行时更改数组大小，请使用
    `std::vector` 或 `boost::container::vector`。'
- en: The `Boost.Array` library just contains an array in it. That is all. Simple
    and efficient. The `boost::array<>` class has no handwritten constructors and
    all of its members are public, so the compiler will think of it as a POD type.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Array` 库只包含一个数组。仅此而已。简单且高效。`boost::array<>` 类没有手写的构造函数，并且所有成员都是公共的，因此编译器会将其视为
    POD 类型。'
- en: '![How it works...](img/4880OS_01_new.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/4880OS_01_new.jpg)'
- en: There's more...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let''s see some more examples of the usage of `boost::array`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `boost::array` 的一些更多使用示例：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: One of the biggest advantages of `boost::array` is that it provides exactly
    the same performance as a normal C array. People from the C++ standard committee
    also liked it, so it was accepted to the C++11 standard. There is a chance that
    your STL library already has it (you may try to include the `<array>` header and
    check for the availability of `std::array<>`).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::array` 的最大优点之一是它提供了与普通 C 数组完全相同的性能。C++ 标准委员会的人也喜欢它，所以它被纳入了 C++11 标准。有可能你的
    STL 库已经包含了它（你可以尝试包含 `<array>` 头文件并检查 `std::array<>` 的可用性）。'
- en: See also
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Boost''s official documentation gives a complete list of the `Boost.Array`
    methods with a description of the method''s complexity and throw behavior, and
    is available at the following link:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost 的官方文档提供了 `Boost.Array` 方法的完整列表，包括方法的复杂性和抛出行为描述，并可在以下链接找到：
- en: '[http://www.boost.org/doc/libs/1_53_0/doc/html/boost/array.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost/array.html)'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/doc/html/boost/array.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost/array.html)'
- en: The `boost::array` function is widely used across recipes; for example, refer
    to the *Binding a value as a function parameter* recipe
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::array` 函数在各个食谱中广泛使用；例如，可以参考 *将值作为函数参数绑定* 的食谱。'
- en: Combining multiple values into one
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多个值组合成一个
- en: There is a very nice present for those who like `std::pair`. Boost has a library
    called `Boost.Tuple`, and it is just like `std::pair`, but it can also work with
    triples, quads, and even bigger collections of types.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于喜欢 `std::pair` 的人来说，有一个非常好的礼物。Boost 有一个名为 `Boost.Tuple` 的库，它就像 `std::pair`
    一样，但它还可以与三元组、四元组以及更大的类型集合一起工作。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ and STL is required for this recipe.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱只需要对 C++ 和 STL 有基本了解。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to combine multiple values in to one:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以将多个值组合成一个：
- en: 'To start working with tuples, you need to include a proper header and declare
    a variable:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始使用元组，你需要包含适当的头文件并声明一个变量：
- en: '[PRE26]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Getting a specific value is implemented via the `boost::get<N>()` function,
    where `N` is a zero-based index of a required value:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `boost::get<N>()` 函数实现获取特定值，其中 `N` 是所需值的零基于索引：
- en: '[PRE27]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `boost::get<>` function has many overloads and is used widely across Boost.
    We have already seen how it can be used with other libraries in the *Storing multiple
    chosen types in a container/variable* recipe.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`boost::get<>` 函数有许多重载，并在 Boost 中广泛使用。我们已经在 *在容器/变量中存储多个选择类型* 的食谱中看到了它是如何与其他库一起使用的。'
- en: 'You can construct tuples using the `boost::make_tuple()` function, which is
    shorter to write, because you do not need to fully qualify the tuple type:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 `boost::make_tuple()` 函数来构造元组，这比完全限定元组类型要短，因为你不需要完全限定元组类型：
- en: '[PRE28]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Another function that makes life easy is `boost::tie()`. It works almost as
    `make_tuple`, but adds a nonconst reference for each of the passed types. Such
    a tuple can be used to get values to a variable from another tuple. It can be
    better understood from the following example:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个让生活变得容易的函数是 `boost::tie()`。它几乎与 `make_tuple` 一样工作，但为每个传递的类型添加了一个非const引用。这样的元组可以用来从另一个元组获取值。以下示例可以更好地理解它：
- en: '[PRE29]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Some readers may wonder why we need a tuple when we can always write our own
    structures with better names, for example, instead of writing `boost::tuple<int,
    std::string>`, we can create a structure:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能会 wonder 为什么我们需要元组，因为我们总是可以编写自己的结构体，例如，而不是编写 `boost::tuple<int, std::string>`，我们可以创建一个结构体：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Well, this structure is definitely more clear than `boost::tuple<int, std::string>`.
    But what if this structure is used only twice in the code?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这个结构肯定比 `boost::tuple<int, std::string>` 更清晰。但假设这个结构在代码中只使用两次呢？
- en: The main idea behind the tuple's library is to simplify template programming.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 元组库背后的主要思想是简化模板编程。
- en: '![How it works...](img/4880OS_01_new.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4880OS_01_new.jpg)'
- en: There's more...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A tuple works as fast as `std::pair` (it does not allocate memory on a heap
    and has no virtual functions). The C++ committee found this class to be very useful
    and it was included in STL; you can find it in a C++11-compatible STL implementation
    in the header file `<tuple>` (don't forget to replace all the `boost::` namespaces
    with `std::`).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个元组的工作速度与 `std::pair` 相当（它不在堆上分配内存，也没有虚拟函数）。C++ 委员会认为这个类非常有用，并将其包含在 STL 中；你可以在
    C++11 兼容的 STL 实现的 `<tuple>` 头文件中找到它（别忘了将所有 `boost::` 命名空间替换为 `std::`）。
- en: The current Boost implementation of a tuple does not use variadic templates;
    it is just a set of classes generated by a script. There is an experimental version
    that uses C++11 rvalues and an emulation of them on C++03 compilers, so there
    is a chance that Boost 1.54 will be shipped with faster implementation of tuples.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 Boost 的元组实现不使用变长模板；它只是由脚本生成的一组类。有一个实验版本使用 C++11 的右值和 C++03 编译器的它们仿真，所以有可能
    Boost 1.54 将包含更快的元组实现。
- en: See also
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The experimental version of tuples can be found at the following link:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在以下链接找到元组的实验版本：
- en: '[http://svn.boost.org/svn/boost/sandbox/tuple-move/](http://svn.boost.org/svn/boost/sandbox/tuple-move/)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://svn.boost.org/svn/boost/sandbox/tuple-move/](http://svn.boost.org/svn/boost/sandbox/tuple-move/)'
- en: 'Boost''s official documentation contains more examples, information about performance,
    and abilities of `Boost.Tuple`. It is available at the following link:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost 的官方文档包含了更多示例、关于性能和 `Boost.Tuple` 能力的信息。它可在以下链接找到：
- en: '[http://www.boost.org/doc/libs/1_53_0/libs/tuple/doc/tuple_users_guide.html](http://www.boost.org/doc/libs/1_53_0/libs/tuple/doc/tuple_users_guide.html)'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/libs/tuple/doc/tuple_users_guide.html](http://www.boost.org/doc/libs/1_53_0/libs/tuple/doc/tuple_users_guide.html)'
- en: The *Converting all tuple elements to strings* recipe in [Chapter 8](ch08.html
    "Chapter 8. Metaprogramming"), *Metaprogramming,* shows some advanced usages of
    tuples
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 8 章](ch08.html "第 8 章。元编程") 的 *元编程* 中，*将所有元组元素转换为字符串* 的菜谱展示了元组的某些高级用法
- en: Reordering the parameters of function
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新排序函数的参数
- en: This recipe and the next one are devoted to a very interesting library, whose
    functionality at first glance looks like some kind of magic. This library is called
    `Boost.Bind` and it allows you to easily create new functional objects from functions,
    member functions, and functional objects, also allowing the reordering of the
    initial function's input parameters and binding some values or references as function
    parameters.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱和下一菜谱致力于一个非常有趣的库，其功能乍一看像某种魔法。这个库被称为 `Boost.Bind`，它允许您轻松地从函数、成员函数和功能对象创建新的功能对象，同时也允许重新排序初始函数的输入参数，并将某些值或引用绑定为函数参数。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Knowledge of C++, STL algorithms, and functional objects is required for this
    recipe.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱需要具备 C++、STL 算法和功能对象的了解。
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s start with an example. You are working with a vector of integral types
    provided by some other programmer. That integral type has only one operator, `+`,
    but your task is to multiply a value by two. Without `bind` this can be achieved
    with the use of a functional object:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从一个例子开始。你正在使用某个程序员提供的整数类型向量。这个整数类型只有一个操作符 `+`，但你的任务是乘以一个值。没有 `bind`，这可以通过使用功能对象来实现：
- en: '[PRE31]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With `Boost.Bind`, it would be as follows:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `Boost.Bind`，可以这样：
- en: '[PRE32]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'By the way, we can easily make this function more generic:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顺便说一下，我们可以轻松地使这个函数更通用：
- en: '[PRE33]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: Let's take a closer look at the `mul_2` function. We provide a vector of values
    to it, and for each value it applies a functional object returned by the `bind()`
    function. The `bind()` function takes in three parameters; the first parameter
    is an instance of the `std::plus<Number>` class (which is a functional object).
    The second and third parameters are placeholders. The placeholder `_1` substitutes
    the argument with the first input argument of the resulting functional object.
    As you might guess, there are many placeholders; placeholder `_2` means substituting
    the argument with the second input argument of the resulting functional object,
    and the same also applies to placeholder `_3`. Well, seems you've got the idea.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 `mul_2` 函数。我们向它提供一个值的向量，并为每个值应用 `bind()` 函数返回的函数对象。`bind()` 函数接受三个参数；第一个参数是
    `std::plus<Number>` 类的实例（它是一个函数对象）。第二个和第三个参数是占位符。占位符 `_1` 用结果函数对象的第一个输入参数替换参数。正如你可能猜到的，有许多占位符；占位符
    `_2` 表示用结果函数对象的第二个输入参数替换参数，同样也适用于占位符 `_3`。嗯，看来你已经明白了这个概念。
- en: There's more...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Just to make sure that you've got the whole idea and know where bind can be
    used, let's take a look at another example.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你完全理解并知道 bind 可以在哪里使用，让我们看看另一个例子。
- en: 'We have two classes, which work with some sensor devices. The devices and classes
    are from different vendors, so they provide different APIs. Both classes have
    only one public method `watch`, which accepts a functional object:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个类，它们与一些传感器设备一起工作。这些设备和类来自不同的供应商，因此它们提供了不同的 API。这两个类只有一个公共方法 `watch`，它接受一个函数对象：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `Device1::watch` and `Device2::watch` functions pass values to a functional
    object in a different order.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Device1::watch` 和 `Device2::watch` 函数以不同的顺序将值传递给函数对象。'
- en: 'Some other libraries provide a function, which is used to detect storms, and
    throws an exception when the risk of a storm is high enough:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他库提供了一个用于检测风暴的函数，当风暴风险足够高时，它会抛出一个异常：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Your task is to provide a storm-detecting function to both of the devices.
    Here is how it can be achieved using the `bind` function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是为这两个设备提供一个风暴检测函数。以下是使用 `bind` 函数实现的方法：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `Boost.Bind` library provides good performance because it does not use
    dynamic allocations and virtual functions. It is useful even when the C++11 lambda
    functions are not usable:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Bind` 库提供了良好的性能，因为它不使用动态分配和虚函数。即使 C++11 的 lambda 函数不可用，它也非常有用：'
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Bind is a part of the C++11 standard. It is defined in the `<functional>` header
    and may slightly differ from the `Boost.Bind` implementation (however, it will
    be at least as effective as Boost's implementation).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Bind 是 C++11 标准的一部分。它在 `<functional>` 头文件中定义，并且可能与 `Boost.Bind` 实现略有不同（然而，它至少与
    Boost 的实现一样有效）。
- en: See also
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The *Binding a value as a function parameter* recipe says more about the features
    of `Boost.Bind`
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “将值绑定为函数参数”食谱对 `Boost.Bind` 的特性有更多介绍
- en: 'Boost''s official documentation contains many more examples and descriptions
    of advanced features. It is available at the following link:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost 的官方文档包含更多示例和高级特性的描述。它可在以下链接找到：
- en: '[http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html](http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html)'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html](http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html)'
- en: Binding a value as a function parameter
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将值绑定为函数参数
- en: 'If you work with the STL library a lot and use the `<algorithm>` header, you
    will definitely write a lot of functional objects. You can construct them using
    a set of STL adapter functions such as `bind1st`, `bind2nd`, `ptr_fun`, `mem_fun`,
    and `mem_fun_ref`, or you can write them by hand (because adapter functions look
    scary). Here is some good news: `Boost.Bind` can be used instead of all of those
    functions and it provides a more human-readable syntax.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常与 STL 库一起工作并使用 `<algorithm>` 头文件，你肯定会写很多函数对象。你可以使用一组 STL 适配器函数（如 `bind1st`、`bind2nd`、`ptr_fun`、`mem_fun`
    和 `mem_fun_ref`）来构建它们，或者你可以手动编写它们（因为适配器函数看起来很吓人）。这里有一些好消息：`Boost.Bind` 可以替代所有这些函数，并提供更易读的语法。
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Read the previous recipe to get an idea of placeholders, or just make sure that
    you are familiar with C++11 placeholders. Knowledge of STL functions and algorithms
    is welcomed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读前面的食谱以了解占位符的概念，或者确保你熟悉 C++11 占位符。了解 STL 函数和算法知识将受到欢迎。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see some examples of the usage of `Boost.Bind` along with traditional
    STL classes:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Boost.Bind` 与传统 STL 类一起使用的示例：
- en: 'Count values greater than or equal to 5 as shown in the following code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码计算大于或等于 5 的值：
- en: '[PRE38]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is how we could count empty strings:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们如何计算空字符串的方法：
- en: '[PRE39]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now let''s count strings with a length less than `5`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们计算长度小于 `5` 的字符串：
- en: '[PRE40]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Compare the strings:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较字符串：
- en: '[PRE41]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::bind` function returns a functional object that stores a copy of
    the bound values and a copy of the original functional object. When the actual
    call to `operator()` is performed, the stored parameters are passed to the original
    functional object along with the parameters passed at the time of call.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::bind` 函数返回一个功能对象，该对象存储了绑定值的副本和原始功能对象的副本。当实际执行 `operator()` 调用时，存储的参数会传递给原始功能对象，同时也会传递调用时传递的参数。'
- en: There's more...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Take a look at the previous examples. When we are binding values, we copy a
    value into a functional object. For some classes this operation is expensive.
    Is there a way to bypass copying?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面的例子。当我们绑定值时，我们会将一个值复制到一个功能对象中。对于某些类，这个操作可能很昂贵。有没有一种方法可以绕过复制？
- en: 'Yes, there is! And the `Boost.Ref` library will help us here! It contains two
    functions, `boost::ref()` and `boost::cref()`, the first of which allows us to
    pass a parameter as a reference, and the second one passes the parameter as a
    constant reference. The `ref()` and `cref()` functions just construct an object
    of type `reference_wrapper<T>` or `reference_wrapper<const T>`, which is implicitly
    convertible to a reference type. Let''s change our previous examples:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！而且 `Boost.Ref` 库将帮助我们！它包含两个函数，`boost::ref()` 和 `boost::cref()`，前者允许我们将参数作为引用传递，后者将参数作为常量引用传递。`ref()`
    和 `cref()` 函数只是构造了一个类型为 `reference_wrapper<T>` 或 `reference_wrapper<const T>`
    的对象，它可以隐式转换为引用类型。让我们修改我们之前的例子：
- en: '[PRE42]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Just one more example to show you how `boost::ref` can be used to concatenate
    strings:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个例子，展示如何使用 `boost::ref` 来连接字符串：
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The functions `ref` and `cref` (and `bind`) are accepted to the C++11 standard
    and defined in the `<functional>` header in the `std::` namespace. None of these
    functions dynamically allocate memory in the heap and they do not use virtual
    functions. The objects returned by them are easy to optimize and they do not apply
    any optimization barriers for good compilers.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `ref`、`cref`（以及 `bind`）被接受到 C++11 标准中，并在 `std::` 命名空间中的 `<functional>` 头文件中定义。这些函数都不在堆上动态分配内存，也不使用虚函数。它们返回的对象易于优化，并且不会为好的编译器应用任何优化屏障。
- en: STL implementations of those functions may have additional optimizations to
    reduce compilation time or just compiler-specific optimizations, but unfortunately,
    some STL implementations miss the functionality of Boost versions. You may use
    the STL version of those functions with any Boost library, or even mix Boost and
    STL versions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的 STL 实现可能有一些额外的优化，以减少编译时间或只是针对特定编译器的优化，但遗憾的是，一些 STL 实现缺少 Boost 版本的某些功能。你可以使用任何
    Boost 库中的 STL 版本，甚至混合 Boost 和 STL 版本。
- en: See also
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `Boost.Bind` library is used widely across this book; see [Chapter 6](ch06.html
    "Chapter 6. Manipulating Tasks"), *Manipulating Tasks*, and [Chapter 5](ch05.html
    "Chapter 5. Multithreading"), *Multithreading*, for more examples
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Bind` 库在这本书中得到了广泛的应用；请参阅第 6 章 [“处理任务”](ch06.html "第 6 章。处理任务") 和第 5
    章 [“多线程”](ch05.html "第 5 章。多线程")，以获取更多示例'
- en: The official documentation contains many more examples and a description of
    advanced features at [http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html](http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档包含更多示例和高级特性的描述，请参阅 [http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html](http://www.boost.org/doc/libs/1_53_0/libs/bind/bind.html)
- en: Using the C++11 move emulation
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C++11 移动模拟
- en: One of the greatest features of the C++11 standard is rvalue references. This
    feature allows us to modify temporary objects, "stealing" resources from them.
    As you can guess, the C++03 standard has no rvalue references, but using the `Boost.Move`
    library you can write some portable code that uses them, and even more, you actually
    get started with the emulation of move semantics.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 标准最伟大的特性之一是右值引用。这个特性允许我们修改临时对象，从它们那里“窃取”资源。正如你所猜到的，C++03 标准没有右值引用，但使用
    `Boost.Move` 库，你可以编写一些可移植的代码来使用它们，甚至更多，你实际上可以开始模拟移动语义。
- en: Getting ready
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is highly recommended to at least know the basics of C++11 rvalue references.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议至少了解 C++11 rvalue references 的基础知识。
- en: How to do it...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Now, let''s take a look at the following examples:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看以下示例：
- en: Imagine that you have a class with multiple fields, some of which are STL containers.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一下，你有一个具有多个字段（其中一些是 STL 容器）的类。
- en: '[PRE44]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It is time to add the move assignment and move constructors to it! Just remember
    that in C++03, STL containers have neither move operators nor move constructors.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候给它添加移动赋值和移动构造函数了！只需记住，在 C++03 中，STL 容器既没有移动操作符也没有移动构造函数。
- en: 'The correct implementation of the move assignment is the same as `swap` and
    `clear` (if an empty state is allowed). The correct implementation of the move
    constructor is close to the default construct and `swap`. So, let''s start with
    the `swap` member function:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确的移动赋值实现与 `swap` 和 `clear`（如果允许空状态）相同。正确的移动构造函数实现接近默认构造和 `swap`。所以，让我们从 `swap`
    成员函数开始：
- en: '[PRE45]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now put the following macro in the `private` section:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下宏放在 `private` 部分：
- en: '[PRE46]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Write a copy constructor.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个拷贝构造函数。
- en: Write a copy assignment, taking the parameter as `BOOST_COPY_ASSIGN_REF(classname)`.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个拷贝赋值，参数为 `BOOST_COPY_ASSIGN_REF(classname)`。
- en: 'Write a move constructor and a move assignment, taking the parameter as `BOOST_RV_REF(classname)`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个移动构造函数和一个移动赋值，参数为 `BOOST_RV_REF(classname)`：
- en: '[PRE47]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now we have a portable, fast implementation of the move assignment and move
    construction operators of the `person_info` class.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有了 `person_info` 类的移动赋值和移动构造函数的可移植、快速实现。
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Here is an example of how the move assignment can be used:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用移动赋值的例子：
- en: '[PRE48]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `Boost.Move` library is implemented in a very efficient way. When the C++11
    compiler is used, all the macros for rvalues emulation will be expanded to C++11-specific
    features, otherwise (on C++03 compilers) rvalues will be emulated using specific
    datatypes and functions that never copy passed values nor called any dynamic memory
    allocations or virtual functions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Move` 库以非常高效的方式实现。当使用 C++11 编译器时，所有用于 rvalue 模拟的宏都将扩展为 C++11 特定功能，否则（在
    C++03 编译器上）rvalue 将使用特定的数据类型和函数进行模拟，这些函数永远不会复制传递的值，也不会调用任何动态内存分配或虚拟函数。'
- en: There's more...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Have you noticed the `boost::swap` call? It is a really helpful utility function,
    which will first search for a `swap` function in the namespace of a variable (the
    namespace `other::`), and if there is no swap function for the `characteristics`
    class, it will use the STL implementation of swap.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到 `boost::swap` 调用了吗？这是一个非常有用的实用函数，它将首先在变量的命名空间中（命名空间 `other::`）搜索 `swap`
    函数，如果没有为 `characteristics` 类提供 `swap` 函数，它将使用 STL 的 `swap` 实现。
- en: See also
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: More information about emulation implementation can be found on the Boost website
    and in the sources of the `Boost.Move` library at [http://www.boost.org/doc/libs/1_53_0/doc/html/move.html](http://www.boost.org/doc/libs/1_53_0/doc/html/move.html).
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于模拟实现的信息可以在 Boost 网站上找到，也可以在 `Boost.Move` 库的源代码中找到，链接为 [http://www.boost.org/doc/libs/1_53_0/doc/html/move.html](http://www.boost.org/doc/libs/1_53_0/doc/html/move.html)。
- en: The `Boost.Utility` library is the one that contains `boost::utility`, and it
    has many useful functions and classes. Refer to its documentation at [http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm](http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm).
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Utility` 库是包含 `boost::utility` 的库，它有许多有用的函数和类。请参阅其文档，链接为 [http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm](http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm)。'
- en: The *Initializing the base class by the member of the derived* recipe in [Chapter
    3](ch03.html "Chapter 3. Managing Resources"), *Managing Resources*.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 3 章，*管理资源*中，*通过派生类的成员初始化基类*的配方。
- en: The *Making a noncopyable class* recipe.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建不可拷贝的类*配方。'
- en: In the *Making a noncopyable but movable class* recipe, there is more info about
    `Boost.Move` and some examples on how we can use the movable objects in containers
    in a portable and efficient way.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*创建不可拷贝但可移动的类*配方中，有更多关于 `Boost.Move` 的信息，以及一些关于如何在容器中以可移植和高效的方式使用可移动对象的示例。
- en: Making a noncopyable class
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建不可拷贝的类
- en: 'You must have almost certainly encountered situations where providing a copy
    constructor and move assignment operator for a class will require too much work,
    or where a class owns some resources that must not be copied for technical reasons:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎肯定遇到过这样的情况，为类提供拷贝构造函数和移动赋值操作符需要做太多工作，或者类拥有一些由于技术原因不能复制的资源：
- en: '[PRE49]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The C++ compiler, in the case of the previous example, will generate a copy
    constructor and an assignment operator, so the potential user of the `descriptor_owner`
    class will be able to create the following awful things:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，C++ 编译器将生成一个复制构造函数和赋值运算符，因此 `descriptor_owner` 类的潜在用户将能够创建以下糟糕的东西：
- en: '[PRE50]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Getting ready
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only very basic knowledge of C++ is required for this recipe.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，只需要非常基础的 C++ 知识。
- en: How to do it...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To avoid such situations, the `boost::noncopyable` class was invented. If you
    derive your own class from it, the copy constructor and assignment operator won''t
    be generated by the C++ compiler:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，发明了 `boost::noncopyable` 类。如果你从它派生自己的类，C++ 编译器将不会生成复制构造函数和赋值运算符：
- en: '[PRE51]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now the user won''t be able to do bad things:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户将无法做坏事：
- en: '[PRE52]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A sophisticated reader will tell me that we can achieve exactly the same result
    by making a copy constructor and an assignment operator of `descriptor_owning_fixed`
    private, or just by defining them without actual implementation. Yes, you are
    correct. Moreover, this is the current implementation of the `boost::noncopyable`
    class. But `boost::noncopyable` also serves as good documentation for your class.
    It never raises questions such as "Is the copy constructor body defined elsewhere?"
    or "Does it have a nonstandard copy constructor (with a nonconst referenced parameter)?".
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 精通读者会告诉我，我们可以通过将 `descriptor_owning_fixed` 的复制构造函数和赋值运算符设为私有，或者只是定义它们而不实现它们来达到完全相同的结果。是的，你是正确的。此外，这是
    `boost::noncopyable` 类的当前实现。但 `boost::noncopyable` 也为你的类提供了良好的文档。它永远不会提出诸如“复制构造函数体是否在其他地方定义？”或“它是否有非标准的复制构造函数（带有非
    const 引用的参数）？”等问题。
- en: See also
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Making a noncopyable but movable class* recipe will give you ideas on how
    to allow unique ownership of a resource in C++03 by moving it
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个不可复制但可移动的类* 配方将给你一些想法，如何在 C++03 中通过移动来允许资源的唯一所有权。'
- en: You may find a lot of helpful functions and classes in the `Boost.Utility` library's
    official documentation at [http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm](http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm)
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm](http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm)
    的 `Boost.Utility` 库的官方文档中找到很多有用的函数和类。
- en: The *Initializing the base class by the member of the derived* recipe in [Chapter
    3](ch03.html "Chapter 3. Managing Resources"), *Managing Resources*
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.html "第 3 章。管理资源") *管理资源* 中，*通过派生类的成员初始化基类* 的配方。
- en: The *Using the C++11 move emulation* recipe
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 C++11 移动仿真的配方*'
- en: Making a noncopyable but movable class
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个不可复制但可移动的类
- en: 'Now imagine the following situation: we have a resource that cannot be copied,
    which should be correctly freed in a destructor, and we want to return it from
    a function:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象以下情况：我们有一个不能复制的资源，它应该在析构函数中正确释放，并且我们希望从函数中返回它：
- en: '[PRE53]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Actually, you can work around such situations using the `swap` method:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以使用 `swap` 方法来规避这种情况：
- en: '[PRE54]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: But such a workaround won't allow us to use `descriptor_owner` in STL or Boost
    containers. And by the way, it looks awful!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样的规避方法不会允许我们在 STL 或 Boost 容器中使用 `descriptor_owner`。顺便说一下，这看起来很糟糕！
- en: Getting ready
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is highly recommended to know at least the basics of C++11 rvalue references.
    Reading the *Using the C++11 move emulation* recipe is also recommended.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议至少了解 C++11 右值引用的基础知识。阅读 *使用 C++11 移动仿真的配方* 也是推荐的。
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Those readers who use C++11 already know about the move-only classes (like
    `std::unique_ptr` or `std::thread`). Using such an approach, we can make a move-only
    `descriptor_owner` class:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 那些已经使用 C++11 的读者已经知道关于只移动类（如 `std::unique_ptr` 或 `std::thread`）。使用这种方法，我们可以创建一个只移动的
    `descriptor_owner` 类：
- en: '[PRE55]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This will work only on C++11 compatible compilers. That is the right moment
    for `Boost.Move`! Let's modify our example so it can be used on C++03 compilers.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会在与 C++11 兼容的编译器上工作。这正是使用 `Boost.Move` 的正确时机！让我们修改我们的示例，使其可以在 C++03 编译器上使用。
- en: 'According to the documentation, to write a movable but noncopyable type in
    portable syntax, we need to follow these simple steps:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，为了用可移植语法编写一个可移动但不可复制的类型，我们需要遵循以下简单的步骤：
- en: 'Put the `BOOST_MOVABLE_BUT_NOT_COPYABLE(classname)` macro in the `private`
    section:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `private` 部分 put `BOOST_MOVABLE_BUT_NOT_COPYABLE(classname)` 宏：
- en: '[PRE56]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Write a move constructor and a move assignment, taking the parameter as `BOOST_RV_REF(classname)`:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个移动构造函数和移动赋值运算符，参数为 `BOOST_RV_REF(classname)`：
- en: '[PRE57]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now we have a movable but noncopyable class that can be used even on C++03
    compilers and in `Boost.Containers`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可移动但不可复制的类，它甚至可以在 C++03 编译器和 `Boost.Containers` 中使用：
- en: '[PRE58]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: But unfortunately, C++03 STL containers still won't be able to use it (that
    is why we used a vector from `Boost.Containers` in the previous example).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 但遗憾的是，C++03 STL 容器仍然无法使用它（这就是为什么我们在上一个示例中使用了 `Boost.Containers` 中的向量）。
- en: There's more...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you want to use `Boost.Containers` on C++03 compilers and STL containers,
    on C++11 compilers you can use the following simple trick. Add the header file
    to your project with the following content:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 C++03 编译器和 STL 容器中使用 `Boost.Containers`，在 C++11 编译器上，你可以使用以下简单的技巧。将以下内容的头文件添加到你的项目中：
- en: '[PRE59]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now you can include `<your_project/vector.hpp>` and use a vector from the namespace
    `your_project_namespace`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以包含 `<your_project/vector.hpp>` 并使用 `your_project_namespace` 命名空间中的向量：
- en: '[PRE60]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: But beware of compiler- and STL-implementation-specific issues! For example,
    this code will compile on GCC 4.7 in C++11 mode only if you mark the move constructor,
    destructor, and move assignment operators with `noexcept`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意编译器和 STL 实现特定的问题！例如，只有当你将移动构造函数、析构函数和移动赋值运算符标记为 `noexcept` 时，这段代码才会在 GCC
    4.7 的 C++11 模式下编译。
- en: See also
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Reducing code size and increasing performance of user-defined types (UDTs)
    in C++11* recipe in [Chapter 10](ch10.html "Chapter 10. Gathering Platform and
    Compiler Information"), *Gathering Platform and Compiler Information*, for more
    info on `noexcept`
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 10 章 [Chapter 10. Gathering Platform and Compiler Information](ch10.html
    "第 10 章. 收集平台和编译器信息") 的 *Reducing code size and increasing performance of user-defined
    types (UDTs) in C++11* 节中，可以找到更多关于 `noexcept` 的信息。
- en: More information about `Boost.Move` can be found on Boost's website [http://www.boost.org/doc/libs/1_53_0/doc/html/move.html](http://www.boost.org/doc/libs/1_53_0/doc/html/move.html)
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `Boost.Move` 的更多信息可以在 Boost 网站上找到 [http://www.boost.org/doc/libs/1_53_0/doc/html/move.html](http://www.boost.org/doc/libs/1_53_0/doc/html/move.html)
