- en: Chapter 4. Rendering 2D Images and Videos with Texture Mapping
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：使用纹理映射渲染2D图像和视频
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting started with modern OpenGL (3.2 or higher)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用现代OpenGL（3.2或更高版本）
- en: Setting up the GLEW, GLM, SOIL, and OpenCV libraries in Windows
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows中设置GLEW、GLM、SOIL和OpenCV库
- en: Setting up the GLEW, GLM, SOIL, and OpenCV libraries in Mac OS X/Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mac OS X/Linux中设置GLEW、GLM、SOIL和OpenCV库
- en: Creating your first vertex and fragment shader using GLSL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GLSL创建你的第一个顶点和片段着色器
- en: Rendering 2D images with texture mapping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纹理映射渲染2D图像
- en: Real-time video rendering with filters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过滤器进行实时视频渲染
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In this chapter, we will introduce OpenGL techniques to visualize another important
    class of datasets: those involving images or videos. Such datasets are commonly
    encountered in many fields, including medical imaging applications. To enable
    the rendering of images, we will discuss fundamental OpenGL concepts for texture
    mapping and transition to more advanced techniques that require newer versions
    of OpenGL (OpenGL 3.2 or higher). To simplify our tasks, we will also employ several
    additional libraries, including **OpenGL Extension Wrangler Library** (**GLEW**)
    for runtime OpenGL extension support, **Simple OpenGL Image Loader** (**SOIL**)
    to load different image formats, **OpenGL Mathematics** (**GLM**) for vector and
    matrix manipulation, as well as **OpenCV** for image/video processing. To get
    started, we will first introduce the features of modern OpenGL 3.2 and higher.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍OpenGL技术来可视化另一类重要的数据集：涉及图像或视频的数据集。这类数据集在许多领域都很常见，包括医学成像应用。为了启用图像的渲染，我们将讨论纹理映射的基本OpenGL概念，并过渡到需要更新版本的OpenGL（OpenGL
    3.2或更高版本）的更高级技术。为了简化我们的任务，我们还将使用几个额外的库，包括**OpenGL扩展包装库**（**GLEW**）用于运行时OpenGL扩展支持，**简单OpenGL图像加载器**（**SOIL**）用于加载不同的图像格式，**OpenGL数学**（**GLM**）用于向量和矩阵操作，以及**OpenCV**用于图像/视频处理。为了开始，我们将首先介绍现代OpenGL
    3.2和更高版本的特性。
- en: Getting started with modern OpenGL (3.2 or higher)
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用现代OpenGL（3.2或更高版本）
- en: Continuous evolution of OpenGL APIs has led to the emergence of a modern standard.
    One of the biggest changes happened in 2008 with OpenGL version 3.0, in which
    a new context creation mechanism was introduced and most of the older functions,
    such as Begin/End primitive specifications, were marked as deprecated. The removal
    of these older standard features also implies a more flexible yet more powerful
    way of handling the graphics pipeline. In OpenGL 3.2 or higher, a core and a compatible
    profile were defined to differentiate the deprecated APIs from the current features.
    These profiles provide clear definitions for various features (core profile) while
    enabling backward compatibility (compatibility profile). In OpenGL 4.x, support
    for the latest graphics hardware that runs Direct3D 11 is provided, and a detailed
    comparison between OpenGL 3.x and OpenGL 4.x is available at [http://www.g-truc.net/post-0269.html](http://www.g-truc.net/post-0269.html).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL API的持续进化导致了现代标准的出现。其中最大的变化发生在2008年，OpenGL 3.0版本中引入了新的上下文创建机制，并将大多数较老的功能，如Begin/End原语规范，标记为已弃用。移除这些较老的标准特性也意味着以更灵活且更强大的方式处理图形管道。在OpenGL
    3.2或更高版本中，定义了核心和兼容配置文件来区分已弃用的API和当前功能。这些配置文件为各种功能提供了清晰的定义（核心配置文件），同时支持向后兼容（兼容配置文件）。在OpenGL
    4.x版本中，提供了对运行Direct3D 11的最新图形硬件的支持，OpenGL 3.x和OpenGL 4.x之间的详细比较可以在[http://www.g-truc.net/post-0269.html](http://www.g-truc.net/post-0269.html)找到。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Starting from this chapter, we need compatible graphics cards with OpenGL 3.2
    (or higher) support. Most graphics cards released before 2008 will most likely
    not be supported. For example, NVIDIA GeForce 100, 200, 300 series and higher
    support the OpenGL 3 standard. You are encouraged to consult the technical specifications
    of your graphics cards to confirm the compatibility (refer to [https://developer.nvidia.com/opengl-driver](https://developer.nvidia.com/opengl-driver)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们需要具有OpenGL 3.2（或更高版本）支持的兼容图形卡。2008年之前发布的绝大多数图形卡可能不会得到支持。例如，NVIDIA GeForce
    100、200、300系列及更高版本支持OpenGL 3标准。我们鼓励您查阅您图形卡的技术规格以确认兼容性（参考[https://developer.nvidia.com/opengl-driver](https://developer.nvidia.com/opengl-driver)）。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To enable OpenGL 3.2 support, we need to incorporate the following lines of
    code at the beginning of every program for initialization:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用OpenGL 3.2支持，我们需要在每个程序的初始化部分包含以下代码行：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `glfwWindowHint` function defines a set of constraints for the creation
    of the GLFW windows context (refer to [Chapter 1](ch01.html "Chapter 1. Getting
    Started with OpenGL"), *Getting Started with OpenGL*). The first two lines of
    code here define the current version of OpenGL that will be used (3.2 in this
    case). The third line enables forward compatibility, while the last line specifies
    that the core profile will be used.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Detailed explanation of the differences between various OpenGL versions can
    be found at [http://www.opengl.org/wiki/History_of_OpenGL](http://www.opengl.org/wiki/History_of_OpenGL).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the GLEW, GLM, SOIL, and OpenCV libraries in Windows
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will provide step-by-step instructions to set up several
    popular libraries that will be used extensively in this chapter (and in subsequent
    chapters), including the GLEW, GLM, SOIL, and OpenCV libraries:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The GLEW library is an open-source OpenGL extension library.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GLM library is a header-only C++ library that provides an easy-to-use set
    of common mathematical operations. It is built on the GLSL specifications and
    as it is a header-only library, it does not require tedious compilation steps.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SOIL library is a simple C library that is used to load images in a variety
    of common formats (such as BMP, PNG, JPG, TGA, TIFF, and HDR) in OpenGL textures.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenCV library is a very powerful open source computer vision library that
    we will use to simplify image and video processing in this chapter.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will first need to download the prerequisite libraries from the following
    websites:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '**GLEW** (glew-1.10.0): [http://sourceforge.net/projects/glew/files/glew/1.10.0/glew-1.10.0-win32.zip](http://sourceforge.net/projects/glew/files/glew/1.10.0/glew-1.10.0-win32.zip)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GLM** (glm-0.9.5.4): [http://sourceforge.net/projects/ogl-math/files/glm-0.9.5.4/glm-0.9.5.4.zip](http://sourceforge.net/projects/ogl-math/files/glm-0.9.5.4/glm-0.9.5.4.zip)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SOIL**: [http://www.lonesock.net/files/soil.zip](http://www.lonesock.net/files/soil.zip)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenCV** (opencv-2.4.9): [http://sourceforge.net/projects/opencvlibrary/files/opencv-win/2.4.9/opencv-2.4.9.exe](http://sourceforge.net/projects/opencvlibrary/files/opencv-win/2.4.9/opencv-2.4.9.exe)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the precompiled package from GLEW, follow these steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the package.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the directory to `C:/Program Files (x86)`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the `glew32.dll` file (`C:\Program Files (x86)\glew-1.10.0\bin\Release\Win32`)
    can be found at runtime by placing it either in the same folder as the executable
    or including the directory in the Windows system `PATH` environment variable (Navigate
    to **Control Panel** | **System and Security** | **System** | **Advanced Systems
    Settings** | **Environment Variables**).
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use the header-only GLM library, follow these steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the package.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the directory to `C:/Program Files (x86)`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the desired header files in your source code. Here is an example:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To use the SOIL library, follow these steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the package.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the directory to `C:/Program Files (x86)`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the `SOIL.lib` file by opening the Visual Studio solution file (`C:\Program
    Files (x86)\Simple OpenGL Image Library\projects\VC9\SOIL.sln`) and compiling
    the project files. Copy this file from `C:\Program Files (x86)\Simple OpenGL Image
    Library\projects\VC9\Debug to C:\Program Files (x86)\Simple OpenGL Image Library\lib`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the header file in your source code:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, to install OpenCV, we recommend that you use prebuilt binaries to
    simplify the process:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Download the prebuilt binaries from [http://sourceforge.net/projects/opencvlibrary/files/opencv-win/2.4.9/opencv-2.4.9.exe](http://sourceforge.net/projects/opencvlibrary/files/opencv-win/2.4.9/opencv-2.4.9.exe)
    and extract the package.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the directory (the `opencv` folder) to `C:\Program Files (x86)`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add this to the system `PATH` environment variable (Navigate to **Control Panel**
    | **System and Security** | **System** | **Advanced Systems Settings** | **Environment
    Variables**) – `C:\Program Files (x86)\opencv\build\x86\vc12\bin`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the desired header files in your source code:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we generate our Microsoft Visual Studio Solution files (the build environment)
    using `CMake`. We create the `CMakeList.txt` file within each project directory,
    which lists all the libraries and dependencies for the project. The following
    is a sample `CMakeList.txt` file for our first demo application:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in the `CMakeList.txt` file, the various dependencies, including
    the OpenCV, SOIL, GLFW, and GLEW libraries, are all included.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we run the `CMake` program to generate the Microsoft Visual Studio
    Solution for the project (refer to [Chapter 1](ch01.html "Chapter 1. Getting Started
    with OpenGL"), *Getting Started with OpenGL* for details). Note that the output
    path for the binary must match the project folder due to dependencies of the shader
    programs. The following is a screenshot of the `CMake` window after generating
    the first sample project called `code_simple`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/9727OS_04_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'We will repeat this step for each project we create, and the corresponding
    Microsoft Visual Studio Solution file will be generated accordingly (for example,
    `code_simple.sln` in this case). To compile the code, open `code_simple.sln` with
    Microsoft Visual Studio 2013 and build the project using the Build (press *F7*)
    function as usual. Make sure that you set main as the start up project (by right-clicking
    on the *main* project in the **Solution Explorer** and left-clicking on the **Set
    as StartUp Project** option) before running the program, as shown follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/9727OS_04_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: See also
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Further documentation on each of the libraries installed can be found here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '**GLEW**: [http://glew.sourceforge.net/](http://glew.sourceforge.net/)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GLM**: [http://glm.g-truc.net/0.9.5/index.html](http://glm.g-truc.net/0.9.5/index.html)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SOIL**: [http://www.lonesock.net/soil.html](http://www.lonesock.net/soil.html)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenCV**: [http://opencv.org/](http://opencv.org/)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the GLEW, GLM, SOIL, and OpenCV libraries in Mac OS X/Linux
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will outline the steps required to set up the same libraries
    in Mac OS X and Linux.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will first need to download the prerequisite libraries from the following
    websites:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '**GLEW** (glew-1.10.0): [https://sourceforge.net/projects/glew/files/glew/1.10.0/glew-1.10.0.tgz](https://sourceforge.net/projects/glew/files/glew/1.10.0/glew-1.10.0.tgz)'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**GLM** (glm-0.9.5.4): [http://sourceforge.net/projects/ogl-math/files/glm-0.9.5.4/glm-0.9.5.4.zip](http://sourceforge.net/projects/ogl-math/files/glm-0.9.5.4/glm-0.9.5.4.zip)'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SOIL**: [http://www.lonesock.net/files/soil.zip](http://www.lonesock.net/files/soil.zip)'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**OpenCV** (opencv-2.4.9): [http://sourceforge.net/projects/opencvlibrary/files/opencv-unix/2.4.9/opencv-2.4.9.zip](http://sourceforge.net/projects/opencvlibrary/files/opencv-unix/2.4.9/opencv-2.4.9.zip)'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To simplify the installation process for Mac OS X or Ubuntu users, the use of
    MacPorts in Mac OS X or the `apt-get` command in Linux (as described in [Chapter
    1](ch01.html "Chapter 1. Getting Started with OpenGL"), *Getting Started with
    OpenGL*) is highly recommended.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The following section assumes that the download directory is `~/opengl_dev`
    (refer to [Chapter 1](ch01.html "Chapter 1. Getting Started with OpenGL"), *Getting
    Started with OpenGL*).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two methods to install the prerequisite libraries. The first method
    uses precompiled binaries. These binary files are fetched from remote repository
    servers and the version updates of the library are controlled externally. An important
    advantage of this method is that it simplifies the installation, especially in
    terms of resolving dependencies. However, in a release environment, it is recommended
    that you disable the automatic updates and thus protect the binary from version
    skewing. The second method requires users to download and compile the source code
    directly with various customizations. This method is recommended for users who
    would like to control the installation process (such as the paths), and it also
    provides more flexibility in terms of tracking and fixing bugs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'For beginners or developers who are looking for rapid prototyping, we recommend
    that you use the first method as it will simplify the workflow and have short-term
    maintenance. On an Ubuntu or Debian system, we can install the various libraries
    using the `apt-get` command. To install all the prerequisite libraries and dependencies
    on Ubuntu, simply run the following commands in the terminal:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Similarly, on Mac OS X, we can install GLEW, OpenCV, and GLM with MacPorts
    through command lines in the terminal:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, the SOIL library is not currently supported by MacPorts, and thus,
    the installation has to be completed manually, as described in the following section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，SOIL库目前不支持MacPorts，因此，安装必须按照以下章节手动完成。
- en: For advanced users, we can install the latest packages by directly compiling
    from the source, and the upcoming steps are common among Mac OS as well as other
    Linux OS.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级用户，我们可以通过直接从源代码编译来安装最新包，并且这些步骤在Mac OS以及其他Linux OS中都是通用的。
- en: 'To compile the GLEW package, follow these steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译GLEW包，请按照以下步骤操作：
- en: 'Extract the `glew-1.10.0.tgz` package:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压`glew-1.10.0.tgz`包：
- en: '[PRE7]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Install GLEW in `/usr/include/GL` and `/usr/lib`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/usr/include/GL`和`/usr/lib`中安装GLEW：
- en: '[PRE8]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To set up the header-only GLM library, follow these steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置仅包含头文件的GLM库，请按照以下步骤操作：
- en: 'Extract the unzip `glm-0.9.5.4.zip` package:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压`glm-0.9.5.4.zip`包：
- en: '[PRE9]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Copy the header-only GLM library directory (`~/opengl_dev/glm/glm`) to `/usr/include/glm`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将仅包含头文件的GLM库目录（`~/opengl_dev/glm/glm`）复制到`/usr/include/glm`：
- en: '[PRE10]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To set up the SOIL library, follow these steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置SOIL库，请按照以下步骤操作：
- en: 'Extract the unzip `soil.zip` package:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压`soil.zip`包：
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Edit `makefile` (inside the `projects/makefile` directory) and add `-arch x86_64`
    and `-arch i386` to `CXXFLAGS` to ensure proper support:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`makefile`（位于`projects/makefile`目录中）并将`-arch x86_64`和`-arch i386`添加到`CXXFLAGS`以确保适当的支持：
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Compile the source code library:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译源代码库：
- en: '[PRE13]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To set up the OpenCV library, follow these steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置OpenCV库，请按照以下步骤操作：
- en: 'Extract the `opencv-2.4.9.zip` package:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压`opencv-2.4.9.zip`包：
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Build the OpenCV library using `CMake`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CMake`构建OpenCV库：
- en: '[PRE15]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Configure the library path:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置库路径：
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With the development environment fully configured, we can now create the compilation
    script (`Makefile`) within each project folder:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发环境完全配置后，我们现在可以在每个项目文件夹中创建编译脚本（`Makefile`）：
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To compile the code, we simply run the `make` command in the project directory
    and it generates the executable (`main`) automatically.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译代码，我们只需在项目目录中运行`make`命令，它将自动生成可执行文件（`main`）。
- en: See also
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Further documentation on each of the libraries installed can be found here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于已安装的每个库的进一步文档可以在此找到：
- en: '**GLEW**: [http://glew.sourceforge.net/](http://glew.sourceforge.net/)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GLEW**: [http://glew.sourceforge.net/](http://glew.sourceforge.net/)'
- en: '**GLM**: [http://glm.g-truc.net/0.9.5/index.html](http://glm.g-truc.net/0.9.5/index.html)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GLM**: [http://glm.g-truc.net/0.9.5/index.html](http://glm.g-truc.net/0.9.5/index.html)'
- en: '**SOIL**: [http://www.lonesock.net/soil.html](http://www.lonesock.net/soil.html)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SOIL**: [http://www.lonesock.net/soil.html](http://www.lonesock.net/soil.html)'
- en: '**OpenCV**: [http://opencv.org/](http://opencv.org/)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenCV**: [http://opencv.org/](http://opencv.org/)'
- en: '**MacPorts**: [http://www.macports.org/](http://www.macports.org/)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MacPorts**: [http://www.macports.org/](http://www.macports.org/)'
- en: Creating your first vertex and fragment shader using GLSL
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GLSL创建你的第一个顶点和片段着色器
- en: 'Before we can render images using OpenGL, we need to first understand the basics
    of the GLSL. In particular, the concept of shader programs is essential in GLSL.
    Shaders are simply programs that run on graphics processors (GPUs), and a set
    of shaders is compiled and linked to form a program. This concept emerges as a
    result of the increasing complexity of various common processing tasks in modern
    graphics hardware, such as vertex and fragment processing, which necessitates
    greater programmability of specialized processors. Accordingly, the vertex and
    fragment shader are two important types of shaders that we will cover here, and
    they run on the vertex processor and fragment processor, respectively. A simplified
    diagram illustrating the overall processing pipeline is shown as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用OpenGL渲染图像之前，我们首先需要了解GLSL的基本知识。特别是，着色程序的概念在GLSL中至关重要。着色器是简单地运行在图形处理器（GPU）上的程序，一组着色器被编译并链接形成一个程序。这一概念是由于现代图形硬件中各种常见处理任务的日益复杂而产生的，例如顶点和片段处理，这需要专用处理器的更大可编程性。因此，顶点着色器和片段着色器是我们在这里将涵盖的两种重要类型的着色器，它们分别运行在顶点处理器和片段处理器上。以下是一个简化的整体处理流程图：
- en: '![Creating your first vertex and fragment shader using GLSL](img/9727OS_04_02.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![使用GLSL创建你的第一个顶点和片段着色器](img/9727OS_04_02.jpg)'
- en: The main purpose of the vertex shader is to perform the processing of a stream
    of vertex data. An important processing task involves the transformation of the
    position of each vertex from the 3D virtual space to a 2D coordinate for display
    on the screen. Vertex shaders can also manipulate the color and texture coordinates.
    Therefore, vertex shaders serve as an important component of the OpenGL pipeline
    to control movement, lighting, and color.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: A fragment shader is primarily designed to compute the final color of an individual
    pixel (fragment). Oftentimes, we implement various image post-processing techniques,
    such as blurring or sharpening, at this stage; the end results are stored in the
    framebuffer, which will be displayed on screen.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: For readers interested in understanding the rest of the pipeline, a detailed
    summary of these stages, such as the clipping, rasterization, and tessellation,
    can be found at [https://www.opengl.org/wiki/Rendering_Pipeline_Overview](https://www.opengl.org/wiki/Rendering_Pipeline_Overview).
    Additionally, a detailed documentation of GLSL can be found at [https://www.opengl.org/registry/doc/GLSLangSpec.4.40.pdf](https://www.opengl.org/registry/doc/GLSLangSpec.4.40.pdf).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we should have all the prerequisite libraries, such as GLEW,
    GLM, and SOIL. With GLFW configured for the OpenGL core profile, we are now ready
    to implement the first simple example code, which takes advantage of the modern
    OpenGL pipeline.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To keep the code simple, we will divide the program into two components: the
    main program (`main.cpp`) and shader programs (`shader.cpp`, `shader.hpp`, `simple.vert`,
    and `simple.frag`). The main program performs the essential tasks to set up the
    simple demo, while the shader programs perform the specialized processing in the
    modern OpenGL pipeline. The complete sample code can be found in the `code_simple`
    folder.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: First, let's take a look at the shader programs. We will create two extremely
    simple vertex and fragment shader programs (specified inside the `simple.vert`
    and `simple.frag` files) that are compiled and loaded by the program at runtime.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `simple.vert` file, enter the following lines of code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For the `simple.frag` file, enter the following lines of code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First, let''s define a function to compile and load the shader programs (`simple.frag`
    and `simple.vert`) called `LoadShaders` inside `shader.hpp`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we will create the `shader.cpp` file to implement the `LoadShaders` function
    and two helper functions to handle file I/O (`readSourceFile`) and the compilation
    of the shaders (`CompileShader`):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Include prerequisite libraries and the `shader.hpp` header file:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement the `readSourceFile` function as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Implement the `CompileShader` function as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s implement the `LoadShaders` function. First, create the shader
    ID and read the shader code from two files specified by `vertex_file_path` and
    `fragment_file_path`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Compile the vertex shader and fragment shader programs:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译顶点着色器和片段着色器程序：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Link the programs together, check for errors, and clean up:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将程序链接在一起，检查错误，并清理：
- en: '[PRE26]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, let''s put everything together with the `main.cpp` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用`main.cpp`文件将所有内容组合在一起：
- en: 'Include prerequisite libraries and the shader program header file inside the
    common folder:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公共文件夹中包含先决库和着色器程序头文件：
- en: '[PRE27]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a global variable for the GLFW window:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于GLFW窗口的全局变量：
- en: '[PRE28]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Start the main program with the initialization of the GLFW library:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用GLFW库的初始化启动主程序：
- en: '[PRE29]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Set up the GLFW window:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置GLFW窗口：
- en: '[PRE30]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create the GLFW window object and make the context of the specified window
    current on the calling thread:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建GLFW窗口对象并在调用线程中将指定窗口的上下文设置为当前：
- en: '[PRE31]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Initialize the GLEW library and include support for experimental drivers:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化GLEW库并包含对实验性驱动程序的支持：
- en: '[PRE32]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Set up the shader programs:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置着色器程序：
- en: '[PRE33]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Set up Vertex Buffer Object (and color buffer) and copy the vertex data to
    it:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置顶点缓冲对象（和颜色缓冲区）并将顶点数据复制到其中：
- en: '[PRE34]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Specify the layout of the vertex data:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定顶点数据的布局：
- en: '[PRE35]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the drawing program:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行绘图程序：
- en: '[PRE36]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Clean up and exit the program:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理并退出程序：
- en: '[PRE37]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we have created the first GLSL program by defining custom shaders:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过定义自定义着色器创建了第一个GLSL程序：
- en: '![How to do it...](img/9727OS_04_04.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9727OS_04_04.jpg)'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As there are multiple components in this implementation, we will highlight the
    key features inside each component separately, organized in the same order as
    the previous section using the same file name for simplicity.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个实现中有多个组件，我们将分别突出每个组件的关键特性，按照与上一节相同的顺序组织，为了简单起见，使用相同的文件名。
- en: 'Inside `simple.vert`, we defined a simple vertex shader. In the first simple
    implementation, the vertex shader simply passes information forward to the rest
    of the rendering pipeline. First, we need to define the GLSL version that corresponds
    to the OpenGL 3.2 support, which is 1.50 (`#version 150`). The vertex shader takes
    two parameters: the position of the vertex (`in vec3 position`) and the color
    (`in vec3 color_in`). Note that only the color is defined explicitly in an output
    variable (`out vec3 color`) as `gl_Position` is a built-in variable. In general,
    variable names with the prefix `gl` should not be used inside shader programs
    in OpenGL as these are reserved for built-in variables. Notice that the final
    position, `gl_Position`, is expressed in homogeneous coordinates.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`simple.vert`中，我们定义了一个简单的顶点着色器。在第一个简单实现中，顶点着色器只是将信息传递给渲染管道的其余部分。首先，我们需要定义与OpenGL
    3.2支持相对应的GLSL版本，即1.50 (`#version 150`)。顶点着色器接受两个参数：顶点的位置（`in vec3 position`）和颜色（`in
    vec3 color_in`）。请注意，只有颜色在输出变量中明确定义（`out vec3 color`），因为`gl_Position`是一个内置变量。通常，在OpenGL的着色器程序中不应使用以`gl`为前缀的变量名，因为这些是为内置变量保留的。注意，最终的位置`gl_Position`是以齐次坐标表示的。
- en: Inside `simple.frag`, we defined the fragment shader, which again passes the
    color information forward to the output framebuffer. Notice that the final output
    (`color_out`) is expressed in the RGBA format, where A is the alpha value (transparency).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`simple.frag`中，我们定义了片段着色器，它再次将颜色信息传递到输出帧缓冲区。请注意，最终输出（`color_out`）是以RGBA格式表示的，其中A是alpha值（透明度）。
- en: 'Next, in `shader.cpp`, we created a framework to compile and link shader programs.
    The workflow shares some similarity with conventional code compilation in C/C++.
    Briefly, there are six major steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`shader.cpp`中，我们创建了一个框架来编译和链接着色器程序。工作流程与C/C++的传统代码编译有一些相似之处。简要来说，有六个主要步骤：
- en: Create a shader object (`glCreateShader`).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个着色器对象（`glCreateShader`）。
- en: Read and set the shader source code (`glShaderSource`).
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取并设置着色器源代码（`glShaderSource`）。
- en: Compile (`glCompileShader`).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译（`glCompileShader`）。
- en: Create the final program ID (`glCreateProgram`).
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建最终的程序ID（`glCreateProgram`）。
- en: Attach a shader to the program ID (`glAttachShader`).
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将着色器附加到程序ID（`glAttachShader`）。
- en: Link everything together (`glLinkProgram`).
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有内容链接在一起（`glLinkProgram`）。
- en: Finally, in `main.cpp`, we set up a demo to illustrate the use of the compiled
    shader program. As described in the *Getting Started with Modern OpenGL* section
    of this chapter, we need to use the `glfwWindowHint` function to properly create
    the GLFW window context in OpenGL 3.2\. An interesting aspect to point out about
    this demo is that even though we defined only six vertices (three vertices for
    each of the two triangles drawn using the `glDrawArrays` function) and their corresponding
    colors, the final result is an interpolated color gradient.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`main.cpp`中，我们设置了一个演示来展示编译后的着色器程序的使用。正如本章“现代OpenGL入门”部分所述，我们需要使用`glfwWindowHint`函数在OpenGL
    3.2中正确创建GLFW窗口上下文。这个演示的一个有趣之处在于，尽管我们只定义了六个顶点（使用`glDrawArrays`函数绘制的两个三角形各三个顶点）及其相应的颜色，但最终结果是插值的颜色渐变。
- en: Rendering 2D images with texture mapping
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理映射渲染2D图像
- en: Now that we have introduced the basics of GLSL using a simple example, we will
    incorporate further complexity to provide a complete framework that enables users
    to modify any part of the rendering pipeline in the future.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过一个简单的示例介绍了GLSL的基础知识，我们将引入更多的复杂性，以提供一个完整的框架，使用户能够在未来修改渲染管道的任何部分。
- en: The code in this framework is divided into smaller modules to handle the shader
    programs (`shader.cpp` and `shader.hpp`), texture mapping (`texture.cpp` and `texture.hpp`),
    and user inputs (`controls.hpp` and `controls.hpp`). First, we will reuse the
    mechanism to load shader programs in OpenGL introduced previously and incorporate
    new shader programs for our purpose. Next, we will introduce the steps required
    for texture mapping. Finally, we will describe the main program, which integrates
    all the logical pieces and prepares the final demo. In this section, we will show
    how we can load an image and convert it into a texture object to be rendered in
    OpenGL. With this framework in mind, we will further demonstrate how to render
    a video in the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本框架中的代码被划分为更小的模块，以处理着色器程序（`shader.cpp`和`shader.hpp`）、纹理映射（`texture.cpp`和`texture.hpp`）以及用户输入（`controls.hpp`和`controls.hpp`）。首先，我们将重用之前在OpenGL中引入的加载着色器程序的机制，并纳入新的着色器程序以供我们的目的使用。接下来，我们将介绍纹理映射所需的步骤。最后，我们将描述主程序，它整合了所有逻辑部分并准备最终的演示。在本节中，我们将展示如何加载图像并将其转换为OpenGL中渲染的纹理对象。考虑到这个框架，我们将在下一节进一步演示如何渲染视频。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To avoid redundancy here, we will refer readers to the previous section for
    part of this demo (in particular, `shader.cpp` and `shader.hpp`).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复，我们将引导读者参考前文中的部分内容（特别是`shader.cpp`和`shader.hpp`）。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'First, we aggregate all the common libraries used in our program into the `common.h`
    header file. The `common.h` file is then included in `shader.hpp`, `controls.hpp`,
    `texture.hpp`, and `main.cpp`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将程序中使用的所有常用库聚合到`common.h`头文件中。然后，`common.h`文件被包含在`shader.hpp`、`controls.hpp`、`texture.hpp`和`main.cpp`中：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We previously implemented a mechanism to load a fragment and vertex shader program
    from files, and we will reuse the code here (`shader.cpp` and `shader.hpp`). However,
    we will modify the actual vertex and shader programs as follows.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前实现了一个从文件中加载片段和顶点着色器程序的机制，并将在此处重用代码（`shader.cpp`和`shader.hpp`）。然而，我们将修改实际的顶点和着色器程序如下。
- en: 'For the vertex shader (`transform.vert`), we will implement the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于顶点着色器（`transform.vert`），我们将实现以下内容：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For the fragment shader (`texture.frag`), we will implement the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于片段着色器（`texture.frag`），我们将实现以下内容：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: For the texture objects, in `texture.cpp`, we provide a mechanism to load images
    or video stream into the texture memory. We also take advantage of the SOIL library
    for simple image loading and the OpenCV library for more advanced video stream
    handling and filtering (refer to the next section).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于纹理对象，在`texture.cpp`中，我们提供了一个机制来将图像或视频流加载到纹理内存中。我们还利用了SOIL库进行简单的图像加载，以及OpenCV库进行更高级的视频流处理和过滤（参考下一节）。
- en: 'In `texture.cpp`, we will implement the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`texture.cpp`中，我们将实现以下内容：
- en: 'Include the `texture.hpp` header and SOIL library header for simple image loading:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含`texture.hpp`头文件和SOIL库头文件以进行简单的图像加载：
- en: '[PRE41]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define the initialization of texture objects and set up all parameters:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义纹理对象的初始化并设置所有参数：
- en: '[PRE42]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define the routine to update the texture memory:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义更新纹理内存的例程：
- en: '[PRE43]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, implement the texture-loading mechanism for images. The function takes
    the image path and automatically converts the image into various compatible formats
    for the texture object:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现图像的纹理加载机制。该函数接受图像路径并自动将图像转换为纹理对象兼容的各种格式：
- en: '[PRE44]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'On the controller front, we capture the arrow keys and modify the camera model
    parameter in real time. This allows us to change the position and orientation
    of the camera as well as the angle of view. In `controls.cpp`, we implement the
    following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器方面，我们捕获箭头键并在实时中修改相机模型参数。这允许我们改变相机的位置和方向以及视场角度。在 `controls.cpp` 中，我们实现以下内容：
- en: 'Include the GLM library header and the `controls.hpp` header for the projection
    matrix and view matrix computations:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 GLM 库头文件和 `controls.hpp` 头文件以进行投影矩阵和视图矩阵的计算：
- en: '[PRE45]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Define global variables (camera parameters as well as view and projection matrices)
    to be updated after each frame:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义全局变量（相机参数以及视图和投影矩阵）以在每一帧之后更新：
- en: '[PRE46]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create helper functions to return the most updated view matrix and projection
    matrix:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建辅助函数以返回最新的视图矩阵和投影矩阵：
- en: '[PRE47]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Compute the view matrix and projection matrix based on the user input:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据用户输入计算视图矩阵和投影矩阵：
- en: '[PRE48]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In `main.cpp`, we will use the various previously defined functions to complete
    the implementation:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 中，我们将使用之前定义的各种函数来完成实现：
- en: 'Include the GLFW and GLM libraries as well as our helper functions, which are
    stored in separate files inside a folder called the `common` folder:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 GLFW 和 GLM 库以及我们存储在名为 `common` 文件夹中的辅助函数包含在内：
- en: '[PRE49]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Define all global variables for the setup:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义所有用于设置的全局变量：
- en: '[PRE50]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Define the keyboard `callback` function:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义键盘 `callback` 函数：
- en: '[PRE51]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Initialize the GLFW library with the OpenGL core profile enabled:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用启用 OpenGL 核心配置文件的 GLFW 库初始化：
- en: '[PRE52]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Set up the GLFW windows and keyboard input handlers:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 GLFW 窗口和键盘输入处理程序：
- en: '[PRE53]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Set a black background and enable alpha blending for various visual effects:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置黑色背景并启用 alpha 混合以实现各种视觉效果：
- en: '[PRE54]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Load the vertex shader and fragment shader:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载顶点着色器和片段着色器：
- en: '[PRE55]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Load an image file into the texture object using the SOIL library:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 SOIL 库将图像文件加载到纹理对象中：
- en: '[PRE56]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Get the locations of the specific variables in the shader programs:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取着色器程序中特定变量的位置：
- en: '[PRE57]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Define our **Vertex Array Objects** (**VAO**):'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的 **顶点数组对象**（**VAO**）：
- en: '[PRE58]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Define our VAO for vertices and UV mapping:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的顶点数组对象（VAO）和 UV 映射：
- en: '[PRE59]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Use the shader program and bind all texture units and attribute buffers:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用着色器程序并绑定所有纹理单元和属性缓冲区：
- en: '[PRE60]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the main loop, clear the screen and depth buffers:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主循环中，清除屏幕和深度缓冲区：
- en: '[PRE61]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Compute the transforms and store the information in the shader variables:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算变换并将信息存储在着色器变量中：
- en: '[PRE62]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Draw the elements and flush the screen:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制元素并刷新屏幕：
- en: '[PRE63]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, define the conditions to exit the `main` loop and clear all the memory
    to exit the program gracefully:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义退出 `main` 循环的条件并清除所有内存以优雅地退出程序：
- en: '[PRE64]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To demonstrate the use of the framework for data visualization, we will apply
    it to the visualization of a histology slide (an H&E cross-section of a skin sample),
    as shown in the following screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示框架在数据可视化中的应用，我们将将其应用于组织学切片（皮肤样本的 H&E 横切面）的可视化，如下面的截图所示：
- en: '![How it works...](img/9727OS_04_05.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9727OS_04_05.jpg)'
- en: An important difference between this demo and the previous one is that here,
    we actually load an image into the texture memory (`texture.cpp`). To facilitate
    this task, we use the SOIL library call (`SOIL_load_image`) to load the histology
    image in the RGBA format (`GL_RGBA`) and the `glTexImage2D` function call to generate
    a texture image that can be read by shaders.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的演示相比，一个重要的区别是这里，我们实际上将图像加载到纹理内存中（`texture.cpp`）。为了完成这项任务，我们使用 SOIL 库调用（`SOIL_load_image`）以
    RGBA 格式（`GL_RGBA`）加载组织学图像，并使用 `glTexImage2D` 函数调用生成可以由着色器读取的纹理图像。
- en: 'Another important difference is that we can now dynamically recompute the view
    (`g_view_matrix`) and projection (`g_projection_matrix`) matrices to enable an
    interactive and interesting visualization of an image in the 3D space. Note that
    the GLM library header is included to facilitate the matrix computations. Using
    the keyboard inputs (up, down, left, and right) defined in `controls.cpp` with
    the GLFW library calls, we can zoom in and out of the slide as well as adjust
    the view angle, which gives an interesting perspective of the histology image
    in the 3D virtual space. Here is a screenshot of the image viewed with a different
    perspective:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的区别是，我们现在可以动态地重新计算视图(`g_view_matrix`)和投影(`g_projection_matrix`)矩阵，以实现交互式且有趣的3D空间中图像的可视化。请注意，包含GLM库头文件是为了方便矩阵计算。使用在`controls.cpp`中定义的键盘输入（上、下、左和右）以及GLFW库调用，我们可以放大和缩小幻灯片，以及调整视图角度，这为3D虚拟空间中的组织学图像提供了一个有趣的视角。以下是使用不同视角查看图像的屏幕截图：
- en: '![How it works...](img/9727OS_04_06.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/9727OS_04_06.jpg)'
- en: Yet another unique feature of the current OpenGL-based framework is illustrated
    by the following screenshot, which is generated with a new image filter implemented
    into the fragment shader that highlights the edges in the image. This shows the
    endless possibilities for the real-time interactive visualization and processing
    of 2D images using OpenGL rendering pipeline without compromising on CPU performance.
    The filter implemented here will be discussed in the next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当前基于OpenGL的框架的另一个独特功能通过以下屏幕截图展示，该截图是通过将新的图像过滤器实现到片段着色器中生成的，该过滤器突出显示图像中的边缘。这展示了使用OpenGL渲染管线实时交互式可视化和处理2D图像的无限可能性，同时不牺牲CPU性能。这里实现的过滤器将在下一节中讨论。
- en: '![How it works...](img/9727OS_04_07.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/9727OS_04_07.jpg)'
- en: Real-time video rendering with filters
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带过滤器的实时视频渲染
- en: The GLSL shader provides a simple way to perform highly parallelized processing.
    On top of the texture mapping shown previously, we will demonstrate how to implement
    a simple video filter that postprocesses the end results of the buffer frame using
    the fragment shader. To illustrate this technique, we implement the Sobel Filter
    along with a heat map rendered using the OpenGL pipeline. The heat map function
    that was previously implemented in [Chapter 3](ch03.html "Chapter 3. Interactive
    3D Data Visualization"), *Interactive 3D Data Visualization*, will now be directly
    ported to GLSL with very minor changes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL着色器提供了一种简单的方法来执行高度并行的处理。在之前展示的纹理映射之上，我们将演示如何通过片段着色器实现一个简单的视频过滤器，该过滤器对缓冲帧的最终结果进行后处理。为了说明这项技术，我们实现了Sobel滤波器，并使用OpenGL管线渲染热图。之前在[第3章](ch03.html
    "第3章。交互式3D数据可视化")中实现的，*交互式3D数据可视化*的热图函数现在将直接移植到GLSL，仅做非常小的修改。
- en: 'The Sobel operator is a simple image processing technique frequently used in
    computer vision algorithms such as edge detection. This operator can be defined
    as a convolution operation with a 3 x 3 kernel, shown as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Sobel算子是一种简单的图像处理技术，常用于计算机视觉算法，如边缘检测。这个算子可以定义为具有3 x 3核的卷积操作，如下所示：
- en: '![Real-time video rendering with filters](img/9727OS_04_14.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![带过滤器的实时视频渲染](img/9727OS_04_14.jpg)'
- en: '![Real-time video rendering with filters](img/9727OS_04_16.jpg) and ![Real-time
    video rendering with filters](img/9727OS_04_17.jpg) are results of the horizontal
    and vertical derivatives of an image, respectively, from the convolution operation
    of image *I* at the pixel location *(x, y)*.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![带过滤器的实时视频渲染](img/9727OS_04_16.jpg)和![带过滤器的实时视频渲染](img/9727OS_04_17.jpg)分别是图像*I*在像素位置*(x,
    y)*的卷积操作得到的水平和垂直导数的结果。'
- en: 'We can also perform a sum of squares operation to approximate the gradient
    magnitude of the image:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以执行平方和操作来近似图像的梯度幅度：
- en: '![Real-time video rendering with filters](img/9727OS_04_18.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![带过滤器的实时视频渲染](img/9727OS_04_18.jpg)'
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This demo builds on top of the previous section, where an image was rendered.
    In this section, we will demonstrate the rendering of an image sequence or a video
    with the use of OpenCV library calls to handle videos. Inside `common.h`, we will
    add the following lines to include the OpenCV libraries:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示基于之前的章节，其中渲染了一个图像。在本节中，我们将演示使用OpenCV库调用处理视频的图像序列或视频的渲染。在`common.h`中，我们将添加以下行以包含OpenCV库：
- en: '[PRE65]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now, let''s complete the implementation as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤完成实现：
- en: 'First, modify `main.cpp` to enable video processing using OpenCV. Essentially,
    instead of loading an image, feed the individual frames of a video into the same
    pipeline:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，修改 `main.cpp` 以启用 OpenCV 的视频处理。本质上，不是加载图像，而是将视频的单独帧输入到相同的管道中：
- en: '[PRE66]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, add the `update` function in the `main` loop to update the texture in
    every frame:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `main` 循环中添加 `update` 函数以在每一帧中更新纹理：
- en: '[PRE67]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, modify the fragment shader and rename it `texture_sobel.frag` (from `texture.frag`).
    In the `main` function, we will outline the overall processing (process the texture
    buffers with the Sobel filter and heat map renderer):'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改片段着色器并将其重命名为 `texture_sobel.frag`（从 `texture.frag`）。在 `main` 函数中，我们将概述整体处理过程（使用
    Sobel 滤波器和热图渲染器处理纹理缓冲区）：
- en: '[PRE68]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, implement the Sobel filter algorithm that takes the neighboring pixels
    to compute the result:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现 Sobel 滤波器算法，该算法通过计算相邻像素来得到结果：
- en: '[PRE69]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Define the helper function that computes the brightness value:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义计算亮度值的辅助函数：
- en: '[PRE70]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Create a helper function for the per-pixel operator operations:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为像素操作操作创建辅助函数：
- en: '[PRE71]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Lastly, define the heat map renderer prototype and implement the algorithm
    for better visualization of the range of values:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义热图渲染器原型并实现算法以更好地可视化值范围：
- en: '[PRE72]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'This demo effectively opens up the possibility of rendering any image sequence
    with real-time processing using the OpenGL pipeline at the fragment shading stage.
    The following screenshot is an example that illustrates the use of this powerful
    OpenGL framework to display one frame of a video (showing the authors of the book)
    without the Sobel filter enabled:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示有效地打开了使用 OpenGL 管道在片段着色阶段进行实时处理以渲染任何图像序列的可能性。以下截图是一个示例，说明了如何使用这个强大的 OpenGL
    框架显示视频的一帧（显示书籍的作者），而不启用 Sobel 滤波器：
- en: '![How it works...](img/9727OS_04_08.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/9727OS_04_08.jpg)'
- en: 'Now, with the Sobel filter and heat map rendering enabled, we see an interesting
    way to visualize the world using real-time OpenGL texture mapping and processing
    using custom shaders:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启用 Sobel 滤波器和热图渲染后，我们看到一种使用实时 OpenGL 纹理映射和自定义着色器处理来可视化世界的方法：
- en: '![How it works...](img/9727OS_04_09.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/9727OS_04_09.jpg)'
- en: 'Further fine-tuning of the threshold parameters and converting the result into
    grayscale (in the `texture_sobel.frag` file) leads to an aesthetically interesting
    output:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步微调阈值参数并将结果转换为灰度（在 `texture_sobel.frag` 文件中）将导致美观的输出：
- en: '[PRE73]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '![How it works...](img/9727OS_04_10.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/9727OS_04_10.jpg)'
- en: 'In addition, we can blend these results with the original video feed to create
    filtered effects in real time by modifying the main function in the shader program
    (`texture_sobel.frag`):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过修改着色器程序中的主函数（`texture_sobel.frag`）将这些结果与原始视频输入混合，以实时创建过滤效果：
- en: '[PRE74]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '![How it works...](img/9727OS_04_11.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/9727OS_04_11.jpg)'
- en: 'To illustrate the use of the exact same program to visualize imaging datasets,
    here is an example that shows a volumetric dataset of a human finger imaged with
    **Optical Coherence Tomography** (**OCT**), simply by changing the input video''s
    filename:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明使用完全相同的程序来可视化成像数据集，这里有一个示例，展示了使用 **光学相干断层扫描**（**OCT**）成像的人指的体素数据集，只需更改输入视频的文件名：
- en: '![How it works...](img/9727OS_04_12.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/9727OS_04_12.jpg)'
- en: This screenshot represents one of 256 cross-sectional images of the nail bed
    in this volumetric OCT dataset (which is exported in a movie file format).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图代表了这个体素 OCT 数据集中指甲床的 256 个横截面图像之一（以电影文件格式导出）。
- en: 'Here is another example that shows a volumetric dataset of a scar specimen
    imaged with **Polarization-Sensitive Optical Coherence Tomography** (**PS-OCT**),
    which provides label-free, intrinsic contrast to the scar region:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个示例，展示了使用 **偏振敏感光学相干断层扫描**（**PS-OCT**）成像的疤痕样本的体素数据集，它为疤痕区域提供了无标记的内在对比度：
- en: '![How it works...](img/9727OS_04_13.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/9727OS_04_13.jpg)'
- en: In this case, the volumetric PS-OCT dataset was rendered with the ImageJ 3D
    Viewer and converted into a movie file. The colors denote the **Degree of Polarization**
    (**DOP**), which is a measure of the randomness of the polarization states of
    light (a low DOP in yellow/green and a high DOP in blue), in the skin. The scar
    region is characterized by a high DOP compared to the normal skin.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，体素PS-OCT数据集是用ImageJ 3D Viewer渲染的，并转换成了电影文件。颜色表示**偏振度**（**DOP**），这是衡量光偏振状态随机性的一个指标（低DOP在黄色/绿色，高DOP在蓝色），在皮肤中。疤痕区域与正常皮肤相比，具有高DOP的特征。
- en: As we have demonstrated here, this program can be easily adopted (by changing
    the input video source) to display many types of datasets, such as endoscopy videos
    or other volumetric imaging datasets. The utility of OpenGL becomes apparent in
    demanding applications that require real-time processing of very large datasets.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这里所展示的，这个程序可以很容易地采用（通过更改输入视频源）来显示许多类型的数据集，例如内窥镜视频或其他体素成像数据集。在需要实时处理非常大的数据集的严格要求应用中，OpenGL的实用性变得明显。
