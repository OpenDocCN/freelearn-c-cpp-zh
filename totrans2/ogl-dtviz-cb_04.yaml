- en: Chapter 4. Rendering 2D Images and Videos with Texture Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with modern OpenGL (3.2 or higher)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the GLEW, GLM, SOIL, and OpenCV libraries in Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the GLEW, GLM, SOIL, and OpenCV libraries in Mac OS X/Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first vertex and fragment shader using GLSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering 2D images with texture mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time video rendering with filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce OpenGL techniques to visualize another important
    class of datasets: those involving images or videos. Such datasets are commonly
    encountered in many fields, including medical imaging applications. To enable
    the rendering of images, we will discuss fundamental OpenGL concepts for texture
    mapping and transition to more advanced techniques that require newer versions
    of OpenGL (OpenGL 3.2 or higher). To simplify our tasks, we will also employ several
    additional libraries, including **OpenGL Extension Wrangler Library** (**GLEW**)
    for runtime OpenGL extension support, **Simple OpenGL Image Loader** (**SOIL**)
    to load different image formats, **OpenGL Mathematics** (**GLM**) for vector and
    matrix manipulation, as well as **OpenCV** for image/video processing. To get
    started, we will first introduce the features of modern OpenGL 3.2 and higher.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with modern OpenGL (3.2 or higher)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous evolution of OpenGL APIs has led to the emergence of a modern standard.
    One of the biggest changes happened in 2008 with OpenGL version 3.0, in which
    a new context creation mechanism was introduced and most of the older functions,
    such as Begin/End primitive specifications, were marked as deprecated. The removal
    of these older standard features also implies a more flexible yet more powerful
    way of handling the graphics pipeline. In OpenGL 3.2 or higher, a core and a compatible
    profile were defined to differentiate the deprecated APIs from the current features.
    These profiles provide clear definitions for various features (core profile) while
    enabling backward compatibility (compatibility profile). In OpenGL 4.x, support
    for the latest graphics hardware that runs Direct3D 11 is provided, and a detailed
    comparison between OpenGL 3.x and OpenGL 4.x is available at [http://www.g-truc.net/post-0269.html](http://www.g-truc.net/post-0269.html).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting from this chapter, we need compatible graphics cards with OpenGL 3.2
    (or higher) support. Most graphics cards released before 2008 will most likely
    not be supported. For example, NVIDIA GeForce 100, 200, 300 series and higher
    support the OpenGL 3 standard. You are encouraged to consult the technical specifications
    of your graphics cards to confirm the compatibility (refer to [https://developer.nvidia.com/opengl-driver](https://developer.nvidia.com/opengl-driver)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable OpenGL 3.2 support, we need to incorporate the following lines of
    code at the beginning of every program for initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `glfwWindowHint` function defines a set of constraints for the creation
    of the GLFW windows context (refer to [Chapter 1](ch01.html "Chapter 1. Getting
    Started with OpenGL"), *Getting Started with OpenGL*). The first two lines of
    code here define the current version of OpenGL that will be used (3.2 in this
    case). The third line enables forward compatibility, while the last line specifies
    that the core profile will be used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Detailed explanation of the differences between various OpenGL versions can
    be found at [http://www.opengl.org/wiki/History_of_OpenGL](http://www.opengl.org/wiki/History_of_OpenGL).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the GLEW, GLM, SOIL, and OpenCV libraries in Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will provide step-by-step instructions to set up several
    popular libraries that will be used extensively in this chapter (and in subsequent
    chapters), including the GLEW, GLM, SOIL, and OpenCV libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: The GLEW library is an open-source OpenGL extension library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GLM library is a header-only C++ library that provides an easy-to-use set
    of common mathematical operations. It is built on the GLSL specifications and
    as it is a header-only library, it does not require tedious compilation steps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SOIL library is a simple C library that is used to load images in a variety
    of common formats (such as BMP, PNG, JPG, TGA, TIFF, and HDR) in OpenGL textures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenCV library is a very powerful open source computer vision library that
    we will use to simplify image and video processing in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will first need to download the prerequisite libraries from the following
    websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GLEW** (glew-1.10.0): [http://sourceforge.net/projects/glew/files/glew/1.10.0/glew-1.10.0-win32.zip](http://sourceforge.net/projects/glew/files/glew/1.10.0/glew-1.10.0-win32.zip)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GLM** (glm-0.9.5.4): [http://sourceforge.net/projects/ogl-math/files/glm-0.9.5.4/glm-0.9.5.4.zip](http://sourceforge.net/projects/ogl-math/files/glm-0.9.5.4/glm-0.9.5.4.zip)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SOIL**: [http://www.lonesock.net/files/soil.zip](http://www.lonesock.net/files/soil.zip)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenCV** (opencv-2.4.9): [http://sourceforge.net/projects/opencvlibrary/files/opencv-win/2.4.9/opencv-2.4.9.exe](http://sourceforge.net/projects/opencvlibrary/files/opencv-win/2.4.9/opencv-2.4.9.exe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the precompiled package from GLEW, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the directory to `C:/Program Files (x86)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the `glew32.dll` file (`C:\Program Files (x86)\glew-1.10.0\bin\Release\Win32`)
    can be found at runtime by placing it either in the same folder as the executable
    or including the directory in the Windows system `PATH` environment variable (Navigate
    to **Control Panel** | **System and Security** | **System** | **Advanced Systems
    Settings** | **Environment Variables**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use the header-only GLM library, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the directory to `C:/Program Files (x86)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the desired header files in your source code. Here is an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the SOIL library, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the directory to `C:/Program Files (x86)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the `SOIL.lib` file by opening the Visual Studio solution file (`C:\Program
    Files (x86)\Simple OpenGL Image Library\projects\VC9\SOIL.sln`) and compiling
    the project files. Copy this file from `C:\Program Files (x86)\Simple OpenGL Image
    Library\projects\VC9\Debug to C:\Program Files (x86)\Simple OpenGL Image Library\lib`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the header file in your source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, to install OpenCV, we recommend that you use prebuilt binaries to
    simplify the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the prebuilt binaries from [http://sourceforge.net/projects/opencvlibrary/files/opencv-win/2.4.9/opencv-2.4.9.exe](http://sourceforge.net/projects/opencvlibrary/files/opencv-win/2.4.9/opencv-2.4.9.exe)
    and extract the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the directory (the `opencv` folder) to `C:\Program Files (x86)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add this to the system `PATH` environment variable (Navigate to **Control Panel**
    | **System and Security** | **System** | **Advanced Systems Settings** | **Environment
    Variables**) – `C:\Program Files (x86)\opencv\build\x86\vc12\bin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the desired header files in your source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we generate our Microsoft Visual Studio Solution files (the build environment)
    using `CMake`. We create the `CMakeList.txt` file within each project directory,
    which lists all the libraries and dependencies for the project. The following
    is a sample `CMakeList.txt` file for our first demo application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the `CMakeList.txt` file, the various dependencies, including
    the OpenCV, SOIL, GLFW, and GLEW libraries, are all included.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we run the `CMake` program to generate the Microsoft Visual Studio
    Solution for the project (refer to [Chapter 1](ch01.html "Chapter 1. Getting Started
    with OpenGL"), *Getting Started with OpenGL* for details). Note that the output
    path for the binary must match the project folder due to dependencies of the shader
    programs. The following is a screenshot of the `CMake` window after generating
    the first sample project called `code_simple`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/9727OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will repeat this step for each project we create, and the corresponding
    Microsoft Visual Studio Solution file will be generated accordingly (for example,
    `code_simple.sln` in this case). To compile the code, open `code_simple.sln` with
    Microsoft Visual Studio 2013 and build the project using the Build (press *F7*)
    function as usual. Make sure that you set main as the start up project (by right-clicking
    on the *main* project in the **Solution Explorer** and left-clicking on the **Set
    as StartUp Project** option) before running the program, as shown follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/9727OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Further documentation on each of the libraries installed can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GLEW**: [http://glew.sourceforge.net/](http://glew.sourceforge.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GLM**: [http://glm.g-truc.net/0.9.5/index.html](http://glm.g-truc.net/0.9.5/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SOIL**: [http://www.lonesock.net/soil.html](http://www.lonesock.net/soil.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenCV**: [http://opencv.org/](http://opencv.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the GLEW, GLM, SOIL, and OpenCV libraries in Mac OS X/Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will outline the steps required to set up the same libraries
    in Mac OS X and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will first need to download the prerequisite libraries from the following
    websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GLEW** (glew-1.10.0): [https://sourceforge.net/projects/glew/files/glew/1.10.0/glew-1.10.0.tgz](https://sourceforge.net/projects/glew/files/glew/1.10.0/glew-1.10.0.tgz)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**GLM** (glm-0.9.5.4): [http://sourceforge.net/projects/ogl-math/files/glm-0.9.5.4/glm-0.9.5.4.zip](http://sourceforge.net/projects/ogl-math/files/glm-0.9.5.4/glm-0.9.5.4.zip)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SOIL**: [http://www.lonesock.net/files/soil.zip](http://www.lonesock.net/files/soil.zip)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**OpenCV** (opencv-2.4.9): [http://sourceforge.net/projects/opencvlibrary/files/opencv-unix/2.4.9/opencv-2.4.9.zip](http://sourceforge.net/projects/opencvlibrary/files/opencv-unix/2.4.9/opencv-2.4.9.zip)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To simplify the installation process for Mac OS X or Ubuntu users, the use of
    MacPorts in Mac OS X or the `apt-get` command in Linux (as described in [Chapter
    1](ch01.html "Chapter 1. Getting Started with OpenGL"), *Getting Started with
    OpenGL*) is highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: The following section assumes that the download directory is `~/opengl_dev`
    (refer to [Chapter 1](ch01.html "Chapter 1. Getting Started with OpenGL"), *Getting
    Started with OpenGL*).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two methods to install the prerequisite libraries. The first method
    uses precompiled binaries. These binary files are fetched from remote repository
    servers and the version updates of the library are controlled externally. An important
    advantage of this method is that it simplifies the installation, especially in
    terms of resolving dependencies. However, in a release environment, it is recommended
    that you disable the automatic updates and thus protect the binary from version
    skewing. The second method requires users to download and compile the source code
    directly with various customizations. This method is recommended for users who
    would like to control the installation process (such as the paths), and it also
    provides more flexibility in terms of tracking and fixing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For beginners or developers who are looking for rapid prototyping, we recommend
    that you use the first method as it will simplify the workflow and have short-term
    maintenance. On an Ubuntu or Debian system, we can install the various libraries
    using the `apt-get` command. To install all the prerequisite libraries and dependencies
    on Ubuntu, simply run the following commands in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, on Mac OS X, we can install GLEW, OpenCV, and GLM with MacPorts
    through command lines in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, the SOIL library is not currently supported by MacPorts, and thus,
    the installation has to be completed manually, as described in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: For advanced users, we can install the latest packages by directly compiling
    from the source, and the upcoming steps are common among Mac OS as well as other
    Linux OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile the GLEW package, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the `glew-1.10.0.tgz` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install GLEW in `/usr/include/GL` and `/usr/lib`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To set up the header-only GLM library, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the unzip `glm-0.9.5.4.zip` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the header-only GLM library directory (`~/opengl_dev/glm/glm`) to `/usr/include/glm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To set up the SOIL library, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the unzip `soil.zip` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `makefile` (inside the `projects/makefile` directory) and add `-arch x86_64`
    and `-arch i386` to `CXXFLAGS` to ensure proper support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the source code library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To set up the OpenCV library, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the `opencv-2.4.9.zip` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the OpenCV library using `CMake`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the library path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the development environment fully configured, we can now create the compilation
    script (`Makefile`) within each project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To compile the code, we simply run the `make` command in the project directory
    and it generates the executable (`main`) automatically.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Further documentation on each of the libraries installed can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GLEW**: [http://glew.sourceforge.net/](http://glew.sourceforge.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GLM**: [http://glm.g-truc.net/0.9.5/index.html](http://glm.g-truc.net/0.9.5/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SOIL**: [http://www.lonesock.net/soil.html](http://www.lonesock.net/soil.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenCV**: [http://opencv.org/](http://opencv.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MacPorts**: [http://www.macports.org/](http://www.macports.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first vertex and fragment shader using GLSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can render images using OpenGL, we need to first understand the basics
    of the GLSL. In particular, the concept of shader programs is essential in GLSL.
    Shaders are simply programs that run on graphics processors (GPUs), and a set
    of shaders is compiled and linked to form a program. This concept emerges as a
    result of the increasing complexity of various common processing tasks in modern
    graphics hardware, such as vertex and fragment processing, which necessitates
    greater programmability of specialized processors. Accordingly, the vertex and
    fragment shader are two important types of shaders that we will cover here, and
    they run on the vertex processor and fragment processor, respectively. A simplified
    diagram illustrating the overall processing pipeline is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your first vertex and fragment shader using GLSL](img/9727OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The main purpose of the vertex shader is to perform the processing of a stream
    of vertex data. An important processing task involves the transformation of the
    position of each vertex from the 3D virtual space to a 2D coordinate for display
    on the screen. Vertex shaders can also manipulate the color and texture coordinates.
    Therefore, vertex shaders serve as an important component of the OpenGL pipeline
    to control movement, lighting, and color.
  prefs: []
  type: TYPE_NORMAL
- en: A fragment shader is primarily designed to compute the final color of an individual
    pixel (fragment). Oftentimes, we implement various image post-processing techniques,
    such as blurring or sharpening, at this stage; the end results are stored in the
    framebuffer, which will be displayed on screen.
  prefs: []
  type: TYPE_NORMAL
- en: For readers interested in understanding the rest of the pipeline, a detailed
    summary of these stages, such as the clipping, rasterization, and tessellation,
    can be found at [https://www.opengl.org/wiki/Rendering_Pipeline_Overview](https://www.opengl.org/wiki/Rendering_Pipeline_Overview).
    Additionally, a detailed documentation of GLSL can be found at [https://www.opengl.org/registry/doc/GLSLangSpec.4.40.pdf](https://www.opengl.org/registry/doc/GLSLangSpec.4.40.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we should have all the prerequisite libraries, such as GLEW,
    GLM, and SOIL. With GLFW configured for the OpenGL core profile, we are now ready
    to implement the first simple example code, which takes advantage of the modern
    OpenGL pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To keep the code simple, we will divide the program into two components: the
    main program (`main.cpp`) and shader programs (`shader.cpp`, `shader.hpp`, `simple.vert`,
    and `simple.frag`). The main program performs the essential tasks to set up the
    simple demo, while the shader programs perform the specialized processing in the
    modern OpenGL pipeline. The complete sample code can be found in the `code_simple`
    folder.'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's take a look at the shader programs. We will create two extremely
    simple vertex and fragment shader programs (specified inside the `simple.vert`
    and `simple.frag` files) that are compiled and loaded by the program at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `simple.vert` file, enter the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `simple.frag` file, enter the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s define a function to compile and load the shader programs (`simple.frag`
    and `simple.vert`) called `LoadShaders` inside `shader.hpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create the `shader.cpp` file to implement the `LoadShaders` function
    and two helper functions to handle file I/O (`readSourceFile`) and the compilation
    of the shaders (`CompileShader`):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include prerequisite libraries and the `shader.hpp` header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `readSourceFile` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `CompileShader` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s implement the `LoadShaders` function. First, create the shader
    ID and read the shader code from two files specified by `vertex_file_path` and
    `fragment_file_path`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the vertex shader and fragment shader programs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Link the programs together, check for errors, and clean up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s put everything together with the `main.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include prerequisite libraries and the shader program header file inside the
    common folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a global variable for the GLFW window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the main program with the initialization of the GLFW library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the GLFW window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the GLFW window object and make the context of the specified window
    current on the calling thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the GLEW library and include support for experimental drivers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the shader programs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up Vertex Buffer Object (and color buffer) and copy the vertex data to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specify the layout of the vertex data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the drawing program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clean up and exit the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have created the first GLSL program by defining custom shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/9727OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As there are multiple components in this implementation, we will highlight the
    key features inside each component separately, organized in the same order as
    the previous section using the same file name for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `simple.vert`, we defined a simple vertex shader. In the first simple
    implementation, the vertex shader simply passes information forward to the rest
    of the rendering pipeline. First, we need to define the GLSL version that corresponds
    to the OpenGL 3.2 support, which is 1.50 (`#version 150`). The vertex shader takes
    two parameters: the position of the vertex (`in vec3 position`) and the color
    (`in vec3 color_in`). Note that only the color is defined explicitly in an output
    variable (`out vec3 color`) as `gl_Position` is a built-in variable. In general,
    variable names with the prefix `gl` should not be used inside shader programs
    in OpenGL as these are reserved for built-in variables. Notice that the final
    position, `gl_Position`, is expressed in homogeneous coordinates.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside `simple.frag`, we defined the fragment shader, which again passes the
    color information forward to the output framebuffer. Notice that the final output
    (`color_out`) is expressed in the RGBA format, where A is the alpha value (transparency).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in `shader.cpp`, we created a framework to compile and link shader programs.
    The workflow shares some similarity with conventional code compilation in C/C++.
    Briefly, there are six major steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a shader object (`glCreateShader`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read and set the shader source code (`glShaderSource`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile (`glCompileShader`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the final program ID (`glCreateProgram`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach a shader to the program ID (`glAttachShader`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link everything together (`glLinkProgram`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in `main.cpp`, we set up a demo to illustrate the use of the compiled
    shader program. As described in the *Getting Started with Modern OpenGL* section
    of this chapter, we need to use the `glfwWindowHint` function to properly create
    the GLFW window context in OpenGL 3.2\. An interesting aspect to point out about
    this demo is that even though we defined only six vertices (three vertices for
    each of the two triangles drawn using the `glDrawArrays` function) and their corresponding
    colors, the final result is an interpolated color gradient.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering 2D images with texture mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have introduced the basics of GLSL using a simple example, we will
    incorporate further complexity to provide a complete framework that enables users
    to modify any part of the rendering pipeline in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The code in this framework is divided into smaller modules to handle the shader
    programs (`shader.cpp` and `shader.hpp`), texture mapping (`texture.cpp` and `texture.hpp`),
    and user inputs (`controls.hpp` and `controls.hpp`). First, we will reuse the
    mechanism to load shader programs in OpenGL introduced previously and incorporate
    new shader programs for our purpose. Next, we will introduce the steps required
    for texture mapping. Finally, we will describe the main program, which integrates
    all the logical pieces and prepares the final demo. In this section, we will show
    how we can load an image and convert it into a texture object to be rendered in
    OpenGL. With this framework in mind, we will further demonstrate how to render
    a video in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To avoid redundancy here, we will refer readers to the previous section for
    part of this demo (in particular, `shader.cpp` and `shader.hpp`).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we aggregate all the common libraries used in our program into the `common.h`
    header file. The `common.h` file is then included in `shader.hpp`, `controls.hpp`,
    `texture.hpp`, and `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We previously implemented a mechanism to load a fragment and vertex shader program
    from files, and we will reuse the code here (`shader.cpp` and `shader.hpp`). However,
    we will modify the actual vertex and shader programs as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the vertex shader (`transform.vert`), we will implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For the fragment shader (`texture.frag`), we will implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: For the texture objects, in `texture.cpp`, we provide a mechanism to load images
    or video stream into the texture memory. We also take advantage of the SOIL library
    for simple image loading and the OpenCV library for more advanced video stream
    handling and filtering (refer to the next section).
  prefs: []
  type: TYPE_NORMAL
- en: 'In `texture.cpp`, we will implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the `texture.hpp` header and SOIL library header for simple image loading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the initialization of texture objects and set up all parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the routine to update the texture memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, implement the texture-loading mechanism for images. The function takes
    the image path and automatically converts the image into various compatible formats
    for the texture object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the controller front, we capture the arrow keys and modify the camera model
    parameter in real time. This allows us to change the position and orientation
    of the camera as well as the angle of view. In `controls.cpp`, we implement the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the GLM library header and the `controls.hpp` header for the projection
    matrix and view matrix computations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define global variables (camera parameters as well as view and projection matrices)
    to be updated after each frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create helper functions to return the most updated view matrix and projection
    matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compute the view matrix and projection matrix based on the user input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `main.cpp`, we will use the various previously defined functions to complete
    the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the GLFW and GLM libraries as well as our helper functions, which are
    stored in separate files inside a folder called the `common` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define all global variables for the setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the keyboard `callback` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the GLFW library with the OpenGL core profile enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the GLFW windows and keyboard input handlers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set a black background and enable alpha blending for various visual effects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the vertex shader and fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load an image file into the texture object using the SOIL library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the locations of the specific variables in the shader programs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define our **Vertex Array Objects** (**VAO**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define our VAO for vertices and UV mapping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the shader program and bind all texture units and attribute buffers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the main loop, clear the screen and depth buffers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compute the transforms and store the information in the shader variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Draw the elements and flush the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, define the conditions to exit the `main` loop and clear all the memory
    to exit the program gracefully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate the use of the framework for data visualization, we will apply
    it to the visualization of a histology slide (an H&E cross-section of a skin sample),
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9727OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An important difference between this demo and the previous one is that here,
    we actually load an image into the texture memory (`texture.cpp`). To facilitate
    this task, we use the SOIL library call (`SOIL_load_image`) to load the histology
    image in the RGBA format (`GL_RGBA`) and the `glTexImage2D` function call to generate
    a texture image that can be read by shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important difference is that we can now dynamically recompute the view
    (`g_view_matrix`) and projection (`g_projection_matrix`) matrices to enable an
    interactive and interesting visualization of an image in the 3D space. Note that
    the GLM library header is included to facilitate the matrix computations. Using
    the keyboard inputs (up, down, left, and right) defined in `controls.cpp` with
    the GLFW library calls, we can zoom in and out of the slide as well as adjust
    the view angle, which gives an interesting perspective of the histology image
    in the 3D virtual space. Here is a screenshot of the image viewed with a different
    perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9727OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yet another unique feature of the current OpenGL-based framework is illustrated
    by the following screenshot, which is generated with a new image filter implemented
    into the fragment shader that highlights the edges in the image. This shows the
    endless possibilities for the real-time interactive visualization and processing
    of 2D images using OpenGL rendering pipeline without compromising on CPU performance.
    The filter implemented here will be discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9727OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Real-time video rendering with filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GLSL shader provides a simple way to perform highly parallelized processing.
    On top of the texture mapping shown previously, we will demonstrate how to implement
    a simple video filter that postprocesses the end results of the buffer frame using
    the fragment shader. To illustrate this technique, we implement the Sobel Filter
    along with a heat map rendered using the OpenGL pipeline. The heat map function
    that was previously implemented in [Chapter 3](ch03.html "Chapter 3. Interactive
    3D Data Visualization"), *Interactive 3D Data Visualization*, will now be directly
    ported to GLSL with very minor changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sobel operator is a simple image processing technique frequently used in
    computer vision algorithms such as edge detection. This operator can be defined
    as a convolution operation with a 3 x 3 kernel, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Real-time video rendering with filters](img/9727OS_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Real-time video rendering with filters](img/9727OS_04_16.jpg) and ![Real-time
    video rendering with filters](img/9727OS_04_17.jpg) are results of the horizontal
    and vertical derivatives of an image, respectively, from the convolution operation
    of image *I* at the pixel location *(x, y)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also perform a sum of squares operation to approximate the gradient
    magnitude of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Real-time video rendering with filters](img/9727OS_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This demo builds on top of the previous section, where an image was rendered.
    In this section, we will demonstrate the rendering of an image sequence or a video
    with the use of OpenCV library calls to handle videos. Inside `common.h`, we will
    add the following lines to include the OpenCV libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s complete the implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, modify `main.cpp` to enable video processing using OpenCV. Essentially,
    instead of loading an image, feed the individual frames of a video into the same
    pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the `update` function in the `main` loop to update the texture in
    every frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, modify the fragment shader and rename it `texture_sobel.frag` (from `texture.frag`).
    In the `main` function, we will outline the overall processing (process the texture
    buffers with the Sobel filter and heat map renderer):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, implement the Sobel filter algorithm that takes the neighboring pixels
    to compute the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the helper function that computes the brightness value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a helper function for the per-pixel operator operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, define the heat map renderer prototype and implement the algorithm
    for better visualization of the range of values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This demo effectively opens up the possibility of rendering any image sequence
    with real-time processing using the OpenGL pipeline at the fragment shading stage.
    The following screenshot is an example that illustrates the use of this powerful
    OpenGL framework to display one frame of a video (showing the authors of the book)
    without the Sobel filter enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9727OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, with the Sobel filter and heat map rendering enabled, we see an interesting
    way to visualize the world using real-time OpenGL texture mapping and processing
    using custom shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9727OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Further fine-tuning of the threshold parameters and converting the result into
    grayscale (in the `texture_sobel.frag` file) leads to an aesthetically interesting
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/9727OS_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition, we can blend these results with the original video feed to create
    filtered effects in real time by modifying the main function in the shader program
    (`texture_sobel.frag`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/9727OS_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To illustrate the use of the exact same program to visualize imaging datasets,
    here is an example that shows a volumetric dataset of a human finger imaged with
    **Optical Coherence Tomography** (**OCT**), simply by changing the input video''s
    filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9727OS_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This screenshot represents one of 256 cross-sectional images of the nail bed
    in this volumetric OCT dataset (which is exported in a movie file format).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example that shows a volumetric dataset of a scar specimen
    imaged with **Polarization-Sensitive Optical Coherence Tomography** (**PS-OCT**),
    which provides label-free, intrinsic contrast to the scar region:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9727OS_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the volumetric PS-OCT dataset was rendered with the ImageJ 3D
    Viewer and converted into a movie file. The colors denote the **Degree of Polarization**
    (**DOP**), which is a measure of the randomness of the polarization states of
    light (a low DOP in yellow/green and a high DOP in blue), in the skin. The scar
    region is characterized by a high DOP compared to the normal skin.
  prefs: []
  type: TYPE_NORMAL
- en: As we have demonstrated here, this program can be easily adopted (by changing
    the input video source) to display many types of datasets, such as endoscopy videos
    or other volumetric imaging datasets. The utility of OpenGL becomes apparent in
    demanding applications that require real-time processing of very large datasets.
  prefs: []
  type: TYPE_NORMAL
