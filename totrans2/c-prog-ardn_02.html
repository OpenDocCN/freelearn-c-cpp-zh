<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. First Contact with C</h1></div></div></div><p>In my life as a programmer, I encountered a lot of compiler-based as well as scripting languages. One of the lowest common denominators has always been the C language.</p><p>In our case, this is <a id="id119" class="indexterm"/>
<strong>embedded system programming</strong>, which is another name for<a id="id120" class="indexterm"/> <strong>hardware programming</strong>; this first statement is also true.</p><p>Let's check what C programming really is and let's enter into a new world, that is, the realm of Arduino programming. We'll also use a very necessary feature called <a id="id121" class="indexterm"/>
<strong>serial monitoring</strong>. This will help us a lot in our C learning, and you'll understand that this feature is also used in real-life projects.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>An introduction to programming</h1></div></div></div><p>The first question is, <strong>what is a program?</strong>
</p><p>A <strong>program</strong>
<a id="id122" class="indexterm"/> is text that you write using a programming language that contains behaviors that you need a processor to acquire. It basically creates a way of handling inputs and producing outputs according to these behaviors.</p><p>According to Wikipedia (<a class="ulink" href="http://en.wikipedia.org/wiki/Computer_programming">http://en.wikipedia.org/wiki/Computer_programming</a>):</p><div><blockquote class="blockquote"><p>Programming<a id="id123" class="indexterm"/> is the process of designing, writing, testing, debugging and maintaining the source code of computer programs.</p></blockquote></div><p>Of course, this definition is very simple and it also applies to microcontrollers, as we already know that the latter are basically a type of computers.</p><p>
<em>Designing a program</em> is<a id="id124" class="indexterm"/> the fact you have to think about first, before you begin coding it. It generally involves writing, drawing, and making schematics of all the actions you want your processor to make for you. Sometimes, it also implies to write what we call <a id="id125" class="indexterm"/>
<strong>pseudocode</strong>. I hope you remember that this is what we created in the previous chapter when we wanted to define precisely all the steps of our desired LED behavior.</p><p>I don't agree with a lot of people calling it <em>pseudocode</em> because it is actually more of a <em>real code</em>.</p><p>What we call <em>pseudocode</em> is something that helps a lot because it is human-readable, made of clear sentences, and is used to think and illustrate better our purpose, which is the key to success.</p><p>An example of my<a id="id126" class="indexterm"/> firmware <em>pseudocode</em>'s definition could be as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Measure the current thermic sensor value.</li><li class="listitem">Check if the temperature is greater than 30° C and make a sound if it is.</li><li class="listitem">If not, light the blue LED.</li><li class="listitem">And make those previous steps permanent in a loop.</li></ol></div><p>
<em>Writing a program</em> is <a id="id127" class="indexterm"/>typically what converts the pseudocode into real and well-formed code. It involves having knowledge of programming languages because it is the step when you really write the program. This is what we'll learn in a moment.</p><p>
<em>Testing</em> is<a id="id128" class="indexterm"/> the obvious step when you run the program after you made some modifications to the code. It is an exciting moment when you also are a bit afraid of bugs, those annoying things that make running your program absolutely different from what you expected at first.</p><p>
<em>Debugging</em> is a<a id="id129" class="indexterm"/> very important step when you are trying to find out why that program doesn't work well as expected. You are tracking typo errors, logic discrepancies, and global program architecture problems. You'll need to monitor things and often modify your program a bit in order to precisely trace how it works.</p><p>
<em>Maintaining the source code</em> is the <a id="id130" class="indexterm"/>part of the program's life that helps to avoid obsolescence.</p><p>The program is working and you improve it progressively; you make it up-to-date considering hardware evolutions, and sometimes, you debug it because the user has this still undiscovered bug. This step increases the life duration of your program.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Different programming paradigms</h2></div></div></div><p>A <strong>paradigm</strong> <a id="id131" class="indexterm"/> is a manner of describing something. It can either be a representation or a theoretical model of something.</p><p>Applied to programming, a programming paradigm is <em>a fundamental style of computer programming</em>.</p><p>The following are four main<a id="id132" class="indexterm"/> programming paradigms:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Object-oriented<a id="id133" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Imperative<a id="id134" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Functional<a id="id135" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Logic programming<a id="id136" class="indexterm"/></li></ul></div><p>Some languages follow not one but multiple paradigms.</p><p>It is not the purpose of this book to have a debate around those, but I would add one, which can be a combination of these and which also describes a particular concept: <a id="id137" class="indexterm"/>
<strong>visual programming</strong>. We'll discover one of the most powerful frameworks in <a class="link" href="ch06.html" title="Chapter 6. Sensing the World – Feeling with Analog Inputs">Chapter 6</a>, <em>Sensing the World — Feeling with Analog Inputs</em>, namely the <strong>Max 6</strong> <a id="id138" class="indexterm"/>framework (formerly named <strong>Max/MSP</strong>).</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Programming style</h2></div></div></div><p>There is no scientific or universal way to define what is the absolute best style of programming. However, I can quote six items that can help to understand what we'll try to do together all along this <a id="id139" class="indexterm"/>book in order to make good programs. We'll aim for the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Reliability</strong>: This enables a code to handle its own generated errors while running</li><li class="listitem" style="list-style-type: disc"><strong>Solidity</strong>: This provides a frame to anticipate problems on the user side (wrong inputs)</li><li class="listitem" style="list-style-type: disc"><strong>Ergonomics</strong>: This helps to intuitively be able to use it with ease</li><li class="listitem" style="list-style-type: disc"><strong>Portability</strong>: This is the designing of a program for a wide range of platforms</li><li class="listitem" style="list-style-type: disc"><strong>Maintainability</strong>: This is the ease of modifying it even if you didn't code it yourself</li><li class="listitem" style="list-style-type: disc"><strong>Efficiency</strong>: This indicates that a program runs very smoothly without consuming a lot of resources</li></ul></div><p>Of course, we'll come back to them in the examples of this book, and I'm sure you'll improve your style progressively.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>C and C++?</h1></div></div></div><p>
<strong>Dennis Ritchie</strong> <a class="ulink" href="http://en.wikipedia.org/wiki/Dennis_Ritchie">http://en.wikipedia.org/wiki/Dennis_Ritchie</a>) at Bell Labs developed the<a id="id140" class="indexterm"/> C programming language from 1969 to 1973. It is often defined as a general-purpose programming language and is indeed one of the most used languages of all times. It had been used initially to design the Unix operating system (<a class="ulink" href="http://en.wikipedia.org/wiki/Unix">http://en.wikipedia.org/wiki/Unix</a>) that had numerous requirements, especially high performance.</p><p>It has influenced a lot of very well known and used languages such as <a id="id141" class="indexterm"/>C++, <a id="id142" class="indexterm"/>Objective-C, <a id="id143" class="indexterm"/>Java, <a id="id144" class="indexterm"/>JavaScript, <a id="id145" class="indexterm"/>Perl, <a id="id146" class="indexterm"/>PHP, and many others.</p><p>C is <a id="id147" class="indexterm"/>to both <strong>imperative</strong> and <strong>structured</strong>. It is very appropriate for both 8-bit and 64-bit processors, for systems having not only several bytes of memory but also terabytes too, and also for huge projects involving huge teams, to the smallest of projects with a single developer.</p><p>Yes, we are going to learn a language that will open your mind to global and universal programming concepts!</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>C is used everywhere</h2></div></div></div><p>Indeed, the C<a id="id148" class="indexterm"/> language provides a lot of advantages. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>It is small and easy to learn.</em></li><li class="listitem" style="list-style-type: disc"><em>It is processor-independent</em> because <em>compilers</em> exist for almost all processors in the world. This independence provides something very useful to programmers: they can focus on algorithms and the application levels of their job instead of thinking about the hardware level at each row of code.</li><li class="listitem" style="list-style-type: disc"><em>It is a very "low-level" high-level language</em>.<p>This is its main strength. Dennis M. Ritchie, in his book <em>The C Programming Language</em> written with Brian W. Kernighan commented on C as:</p></li></ul></div><div><blockquote class="blockquote"><p>C is a relatively "low level" language. This characterization is not pejorative; it simply means that C deals with the same sort of objects that most computers do. These may be combined and moved about with the arithmetic and logical operators implemented by real machines.</p></blockquote></div><p>Today, this is the only language that allows interacting with the underlying hardware engine so easily and this is the reason why the Arduino toolchain is based on C.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Arduino is programmed with C and C++</h2></div></div></div><p>C++ can be <a id="id149" class="indexterm"/>considered as a<a id="id150" class="indexterm"/> superset of C. It means C++ brings new concepts and elements to C. Basically, C++ can be defined as C with object-oriented implementation (<a class="ulink" href="http://en.wikipedia.org/wiki/Object-oriented_programming">http://en.wikipedia.org/wiki/Object-oriented_programming</a>), which is a higher-level feature. This is a very nice feature that brings and provides new ways of design.</p><p>We'll enter<a id="id151" class="indexterm"/> together into this concept a bit later in this book but basically, in object-oriented programs, you define structures called <strong>classes</strong> <a id="id152" class="indexterm"/>that are a kind of a model, and you create objects called <strong>instances</strong>
<a id="id153" class="indexterm"/> of those classes, which<a id="id154" class="indexterm"/> have their own life at runtime and which respect and inherit the structure of the class from which they came.</p><p>
<strong>Object-oriented programming</strong> (<strong>OOP</strong>)<a id="id155" class="indexterm"/> provides four properties that are very useful and interesting:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inheritance (classes can inherit attributes and behaviors from their parent classes)</li><li class="listitem" style="list-style-type: disc">Data encapsulation (each instance retains its data and functions)</li><li class="listitem" style="list-style-type: disc">Object identity (each instance is an individual)</li><li class="listitem" style="list-style-type: disc">Polymorphism (each behavior can depend on the context)</li></ul></div><p>In OOP, we define classes first and then we use specific functions called <a id="id156" class="indexterm"/>
<strong>constructors</strong> to create instances of those classes. Imagine that a class is a map of a type of house, and the instances are all the houses built according to the map.</p><p>Almost all Arduino libraries are made using C++ in order to be easily reusable, which is one of the most important qualities in programming.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>The Arduino native library and other libraries</h1></div></div></div><p>A <strong>programming library</strong>
<a id="id157" class="indexterm"/> is a collection of resources that are available for use by programs.</p><p>They can include different types of things, such as the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuration data</li><li class="listitem" style="list-style-type: disc">Help and documentation resources</li><li class="listitem" style="list-style-type: disc">Subroutines and reusable part of code</li><li class="listitem" style="list-style-type: disc">Classes</li><li class="listitem" style="list-style-type: disc">Type definitions</li></ul></div><p>I like to say that libraries provide a <a id="id158" class="indexterm"/>
<strong>behavior encapsulation</strong>; you don't have to know how the behavior is made for using it but you just use it.</p><p>Libraries can be very specific, or can have a global purpose.</p><p>For instance, if you intend to design firmware that connects the Arduino to the Internet in order to grab some information from a mail server, and react by making an LED matrix blink in one way or another according to the content of the mail server's response, you have the <a id="id159" class="indexterm"/>following two solutions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Code the whole firmware from scratch</li><li class="listitem" style="list-style-type: disc">Use libraries</li></ul></div><p>Even if we like to code things, we are happier if we can focus on the global purpose of our designs, aren't we?</p><p>In that case, we'll try to find libraries already designed specifically for the behaviors we need. For instance, there is probably a library specifically designed for LED matrix control, and another one with a server-connection purpose.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Discovering the Arduino native library</h2></div></div></div><p>The native library is <a id="id160" class="indexterm"/>designed for a very elementary and global purpose. It means it may not be enough, but it also means you'll use it every time in all your firmware design.</p><p>You can find it at <a class="ulink" href="http://arduino.cc/en/Reference/HomePage">http://arduino.cc/en/Reference/HomePage</a>. This page will be familiar to you by now!</p><p>It is divided in<a id="id161" class="indexterm"/> the <a id="id162" class="indexterm"/>following three<a id="id163" class="indexterm"/> parts: </p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Structure</strong> (from global conditional control structures to more specific ones)</li><li class="listitem" style="list-style-type: disc"><strong>Variables</strong> (related to types and conversions between types)</li><li class="listitem" style="list-style-type: disc"><strong>Functions</strong> (from I/O functions to math calculation ones and more)</li></ul></div><p>The following steps can be used to find help directly in IDE:</p><div><ol class="orderedlist arabic"><li class="listitem">Open your IDE.</li><li class="listitem">Go to <strong>File</strong> | <strong>Examples</strong>; you'll see the following screenshot:<div><img src="img/7584_02_001.jpg" alt="Discovering the Arduino native library"/></div><p>In the first part of the menu (in the preceding screenshot), you have lots of examples related to the native library only.</p></li><li class="listitem">Select the<a id="id164" class="indexterm"/> <strong>02.Digital</strong> button.</li><li class="listitem">A new window is displayed. Right-click on a colored keyword in the code as shown in the next screenshot:<div><img src="img/7584_02_002.jpg" alt="Discovering the Arduino native library"/><div><p>Finding information in reference for all reserved keywords directly in the Arduino IDE</p></div></div></li><li class="listitem">You<a id="id165" class="indexterm"/> can see at the bottom of this contextual menu <strong>Find in Reference</strong><em>.</em> This is a really useful tool that you are going to understand right now; click on it!</li></ol></div><p>Your IDE directly called your default browser with an HTML page corresponding to the help page of the keyword on which you clicked. You can stay focused inside your IDE and go to help.</p><div><img src="img/7584_02_003.jpg" alt="Discovering the Arduino native library"/><div><p>The useful local help files that are available</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Other libraries included and not directly provided</h2></div></div></div><p>The Arduino library has progressively included both necessary and useful other libraries. We have seen in the earlier chapter that the used libraries are now integrated into the <em>core</em> of the Arduino distribution, which is a bit abusive, but summarizes well the fact that they are available when you install only the Arduino IDE package.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Some very useful included libraries</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>EEPROM</strong> <a id="id166" class="indexterm"/>provides functions and classes to read/write in hardware storage components. It is very useful to store something beyond the power state of the Arduino, that is, even when the power is off.</li><li class="listitem" style="list-style-type: disc"><strong>Ethernet</strong> helps to make <a id="id167" class="indexterm"/>layer 2 and layer 3 communications over an Ethernet network.</li><li class="listitem" style="list-style-type: disc"><strong>Firmata</strong> <a id="id168" class="indexterm"/>is used for serial communication.</li><li class="listitem" style="list-style-type: disc"><strong>SD</strong> <a id="id169" class="indexterm"/>provides an easy way to read/write SD Cards; it is a more user-friendly alternative to the EEPROM solution.</li><li class="listitem" style="list-style-type: disc"><strong>Servo</strong> <a id="id170" class="indexterm"/>helps to control servo motors.</li></ul></div><p>There are a couple more libraries in the core distribution. Sometimes, new ones are included.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Some external libraries</h3></div></div></div><p>I suggest that you check other libraries quoted and referenced on the same page at the link <a class="ulink" href="http://arduino.cc/en/Reference/Libraries">http://arduino.cc/en/Reference/Libraries</a>.
</p><p>I especially used a lot of the following libraries:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>TLC5940</strong>: Used<a id="id171" class="indexterm"/> to <a id="id172" class="indexterm"/>control a 16-channel, 12-bit LED controller smoothly</li><li class="listitem" style="list-style-type: disc"><strong>MsTimer2</strong>: Used <a id="id173" class="indexterm"/>to trigger <a id="id174" class="indexterm"/>an action that has to be very fast and even each 1 ms (this library is also a nice hack of one of the hardware timers included in the chipset)</li><li class="listitem" style="list-style-type: disc"><strong>Tone</strong><em>:</em> Used<a id="id175" class="indexterm"/> to generate <a id="id176" class="indexterm"/>audible square waves</li></ul></div><p>You can use <em>Google</em> to find more libraries. You will find a lot of them, but not all are equally documented and maintained. We'll see in the last chapter of this book how to create our own library, and of course how to document it nicely for both other users and ourselves.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Checking all basic development steps</h1></div></div></div><p>We are not here together to <a id="id177" class="indexterm"/>understand the entire details of code compilation. But I want to give you a global explanation that will help you to understand better how it works under the hood. It will also help you to understand how to debug your source code and why something wouldn't work in any random case.</p><p>Let's begin by a flowchart showing the entire process.</p><div><img src="img/7584_02_004.jpg" alt="Checking all basic development steps"/><div><p>From the source code to the binary executable code</p></div></div><p>The following steps are<a id="id178" class="indexterm"/> executed to take the code from the source to the executable production stage:</p><div><ol class="orderedlist arabic"><li class="listitem">The <strong>C and C++ source code</strong> is just the type of code you already wrote for the <code class="literal">Blink250ms</code> project in <a class="link" href="ch01.html" title="Chapter 1. Let's Plug Things">Chapter 1</a>, <em>Let's Plug Things</em>.</li><li class="listitem"><strong>Headers</strong> <a id="id179" class="indexterm"/>are usually included at the beginning of your code, and they refer to other files with the extension<code class="literal"> .h</code> in which there are some definitions and class declarations. This kind of design, in which you have separate files for the source code (the program you are currently writing) and the headers (already made elements), provides a nice way to re-use your already written code.</li><li class="listitem">The <strong>Preprocessor</strong><a id="id180" class="indexterm"/> is a routine that basically substitutes text elements in your code, considering the <em>headers</em> and <em>other constants'</em> definitions.</li><li class="listitem">The <strong>Parser</strong> <a id="id181" class="indexterm"/>prepares a file that will be translated, and that file will be assembled to produce multiple <em>object</em> files.</li><li class="listitem">An <strong>object</strong> file<a id="id182" class="indexterm"/> contains machine code that is not directly executable by any hardware processor.</li><li class="listitem">The last important step is the <strong>linkage</strong> <a id="id183" class="indexterm"/>made by the <a id="id184" class="indexterm"/><strong>linker</strong> program. The linker takes all objects produced by the previous compilation steps and combines them into a single executable file called <a id="id185" class="indexterm"/><strong>program</strong>.</li><li class="listitem">From the source code to the object file, all processes are summarized under the name <code class="literal">compilation</code>.</li><li class="listitem">Usually, libraries <a id="id186" class="indexterm"/>provide object files, ready to be linked by the linker. Sometimes, especially in the open source world, libraries come with source code too. This makes any changes in the library easier. In that case, the library itself would have to be compiled to produce the required object files that would be used in your global code compilation.</li><li class="listitem">Hence, we'll define <em>compilation</em> as the whole process from the source code to the program.</li></ol></div><p>I should even use and introduce another term: <a id="id187" class="indexterm"/>
<strong>cross-compilation</strong>. Indeed, we are compiling the source code on our computer, but the final targeted processor of our resulting program (firmware) is the Arduino's processor.</p><p>Generally, we define cross-compilation as the process of compiling source code using a processor in order to make a program for another processor.</p><p>Now, let's move further and learn how we are going to test our initial pieces of C code precisely using the IDE console.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Using the serial monitor</h1></div></div></div><p>The Arduino board itself can <a id="id188" class="indexterm"/>communicate easily using basic protocols for serial communication.</p><p>Basically, <strong>serial communication</strong> <a id="id189" class="indexterm"/>is the process of sending data elements over a channel, often named a<a id="id190" class="indexterm"/> <strong>bus</strong>. Usually, data elements are bytes, but it all depends on the implementation of the serial communication.</p><p>In serial communication, data is sent <em>sequentially</em>, one after the previous one. This is the opposite of <a id="id191" class="indexterm"/>
<strong>parallel communication</strong>, where data are sent over more than one <a id="id192" class="indexterm"/>channel, all at the same time.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Baud rate</h2></div></div></div><p>Because the two entities that want to communicate using serial communications have to be okay about the answer to the question "Hey, what is a word?", we have to use the same speed of transmission on both sides. Indeed, if I send <code class="literal">001010101010</code>, is it a whole word or are there many words? We have to define, for instance, that a word is four-digits long. Then, we can understand that the previous example contains three words: <code class="literal">0010</code>, <code class="literal">1010</code>, and <code class="literal">1010</code>. This involves a clock.</p><p>That clock definition is made by initializing serial communication at a particular <em>speed</em> in <a id="id193" class="indexterm"/>
<strong>baud</strong>, also called<a id="id194" class="indexterm"/> <strong>baud rate</strong>.</p><p>1 baud means 1 symbol transmitted per second. A symbol can be more than one bit.</p><p>This is why we don't have to create confusion between bps, bit per second, and baud!</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Serial communication with Arduino</h2></div></div></div><p>Each Arduino board has at <a id="id195" class="indexterm"/>least one serial port. It can be used by using digital pins 0 and 1, or directly using the USB connection when you want to use serial communication with your computer.</p><p>You can check <a class="ulink" href="http://arduino.cc/en/Reference/serial">http://arduino.cc/en/Reference/serial</a>.</p><p>On the Arduino board, you can read RX and TX on both digital pins 0 and 1 respectively. <strong>TX</strong> means transmit and <strong>RX means</strong> receive; indeed, the most basic serial communication requires two wires.</p><p>There are many other kinds of serial communication buses we'll describe a bit later in <a class="link" href="ch10.html" title="Chapter 10. Some Advanced Techniques">Chapter 10</a>, <em>Some Advanced Techniques</em>, in the <em>Using I2C and SPI for LCD, LED, and other funny games </em>section.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>If you use serial communication on your Arduino board, you cannot use the digital pins 0 and 1.</p></div></div><div><img src="img/7584_02_005.jpg" alt="Serial communication with Arduino"/><div><p>Check TX and RX on digital pins 1 and 0</p></div></div><p>Arduino IDE provides a nice serial monitor that displays all symbols sent by the board to the computer via the USB interface. It provides a lot of baud rates from 300 baud to 115,200 baud. We are going to check how to use it in the following sections.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Serial monitoring</h2></div></div></div><p>Serial monitoring is the way of <a id="id196" class="indexterm"/>creating very basic and easy communication with our board! It means we can program it to speak to us, via the serial monitor.</p><p>If you have to debug something and the board's behavior differs from what you are expecting from it, and you want to "verify whether the problem stems from the firmware or not, you can create some routines that will write messages to you. These messages are called <a id="id197" class="indexterm"/>
<strong>traces</strong>. Traces can be totally necessary for debugging source code.</p><p>Traces will be described in detail in the next chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Making the Arduino talk to us</h1></div></div></div><p>Imagine that you have<a id="id198" class="indexterm"/> followed carefully the <code class="literal">Blink250ms</code> project, everything is wired correctly, you double-checked that, and the code seems okay too, but it doesn't work.</p><p>Our LED isn't blinking at all. How to be sure that the <code class="literal">loop()</code> structure of your code is correctly running? We'll modify the code a bit in order to trace its steps.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Adding serial communication to Blink250ms</h2></div></div></div><p>Here, in the following code, <a id="id199" class="indexterm"/>we'll add serial communication for the <a id="id200" class="indexterm"/>LED to blink every 250 ms:</p><div><ol class="orderedlist arabic"><li class="listitem">Open your previous code.</li><li class="listitem">Use <strong>Save As</strong> to create another project under the name <code class="literal">TalkingAndBlink250ms</code>.<div><div><h3 class="title"><a id="note03"/>Note</h3><p>It is good practice to start from an already existing code, to save it under another name, and to modify it according to your needs.</p></div></div></li><li class="listitem">Modify the current code by adding all rows beginning with <code class="literal">Serial</code><em> </em>as follows:<div><pre class="programlisting">/*
  TalkingAndBlink250ms Program
  Turns a LED connected to digital pin 8 on for 250ms, then off for 1s, infinitely.
  In both steps, the Arduino Board send data to the console of the IDE for information purpose.
  Written by Julien Bayle, this example code is under Creative Commons CC-BY-SA
 */
 
// Pin 8 is the one connected to our pretty LED
int ledPin = 8; // ledPin is an integer variable initialized at 8

// --------- setup routine
void setup() {                
  pinMode(ledPin, OUTPUT); // initialize the digital pin as an output
  Serial.begin(9600);     // Serial communication setup at 9600 baud
}// --------- loop routine
void loop() {
  digitalWrite(ledPin, HIGH);   // turn the LED on
  Serial.print("the pin ");     // print "the pin "
  Serial.print(ledPin);         // print ledPin's value (currently 8)
  Serial.println(" is on");     // print " is on" 
  
  delay(250);                   // wait for 250ms in the current state
  
  digitalWrite(ledPin, LOW);    // turn the LED off 
  
  Serial.print("the pin ");     // print "the pin "
  Serial.print(ledPin);         // print ledPin's value (still 8)
  Serial.println(" is off");    // print " is off
  
  delay(1000);                  // wait for 1s in the current state
}</pre></div><div><div><h3 class="title"><a id="note04"/>Note</h3><p>Please notice that I highlight the comment code a bit each time in order to make things more readable. In the following steps, for instance, I won't write the following comment:</p><p>// ---------- loop routine</p><p>You can also find the whole code in the zip file in the folder <code class="literal">Chapter02/TalkingAndBlink250ms/</code>.</p></div></div></li><li class="listitem">Click on the<a id="id201" class="indexterm"/> Serial Monitor button <a id="id202" class="indexterm"/>in the Arduino IDE:<div><img src="img/7584_02_006.jpg" alt="Adding serial communication to Blink250ms"/><div><p>Click on the little glass symbol in the top-right corner to activate the Serial Monitor</p></div></div></li><li class="listitem">Choose the same baud rate you wrote in the code, which is in the menu at the bottom-right of the Serial Monitoring window, and observe what is happening.<div><img src="img/7584_02_007.jpg" alt="Adding serial communication to Blink250ms"/><div><p>Your Arduino board seems to be speaking to you!</p></div></div></li></ol></div><p>You will notice <a id="id203" class="indexterm"/>some messages appearing in the Serial <a id="id204" class="indexterm"/>Monitor window, synchronized with the blinking LED states.</p><p>Now, we can be sure that our code is fine because each message is sent and because all rows are processed sequentially; it means the <code class="literal">digitalWrite()</code> functions are also called correctly (nothing is blocked). This information can be a clue, for instance, to check our circuit once more to try to find the <a id="id205" class="indexterm"/>error there instead of in the code.</p><p>Of course this is a<a id="id206" class="indexterm"/> trivial example, but I'm sure you understand the target and the power of tracing your code!</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Serial functions in more detail</h2></div></div></div><p>Let's check what we added in the code.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Serial.begin()</h3></div></div></div><p>Everything begins with<a id="id207" class="indexterm"/> the <code class="literal">Serial.begin()</code> function. This function in the <code class="literal">setup()</code> routine is executed only once, that is, when the Arduino is starting.</p><p>In the code, I set up the board to initiate a serial communication at 9,600 baud.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec08"/>Serial.print() and Serial.println()</h3></div></div></div><p>
<code class="literal">Serial.print()</code> <a id="id208" class="indexterm"/>and <code class="literal">Serial.println()</code> <a id="id209" class="indexterm"/>behave almost identically: they write something to the serial output, but the <code class="literal">ln</code> version also adds a carriage return and a newline.</p><p>The syntax of this function is <code class="literal">Serial.print(val)</code> or <code class="literal">Serial.print(val,format)</code>.</p><p>You can pass one or two arguments.</p><p>Basically, if <code class="literal">Serial.print(5)</code> prints the number <code class="literal">5</code> as an ASCII-encoded decimal symbol, <code class="literal">Serial.print(5,OCT)</code> prints the number <code class="literal">5</code> as an ASCII-encoded octal one.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Digging a bit…</h2></div></div></div><p>If you checked the code carefully (and I'm sure you did), you noticed we put two groups of three rows: one group just after the digitalWrite(ledPin,HIGH) function that lights on the LED, and the other group after the row that lights it off.</p><p>Got it?</p><p>We have asked the Arduino board to send a message according to the last order passed to the digital pin numbered 8, where the LED is still connected. And the board sends a message when we asked the pin to deliver current (when the LED is on), and another message when the pin doesn't deliver current (when the LED is off).</p><p>You just wrote your first trace routine.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Talking to the board from the computer</h2></div></div></div><p>You probably noticed a text field and a <strong>Send</strong> button in the Serial Monitor window:</p><div><img src="img/7584_02_008.jpg" alt="Talking to the board from the computer"/><div><p>We can send symbol to our Arduino board using Serial Communication</p></div></div><p>This means we can also use that tool to send data to the board from our computer. The firmware's board, however, has to implement some other functions in order to be able to understand what we'd like to send.</p><p>Later in this book we'll see how to use the Serial Monitor window, the genius Processing framework, and the Max 6 framework to send messages easily to the Arduino board.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, we learned about programming using C language. We also learned how to use the serial monitoring feature of our Arduino IDE in order to know a bit more about what is happening in real time in our Arduino processor using traces.</p><p>I spoke about serial communication because it is very useful and is also used in many real-life projects in which you need a computer and an Arduino board to communicate among themselves. It can also be used between two Arduino boards or between Arduino boards and other circuits.</p><p>In the next chapter, we'll enter C code by using the serial monitoring window in order to make things a bit less abstract.</p></div></body></html>