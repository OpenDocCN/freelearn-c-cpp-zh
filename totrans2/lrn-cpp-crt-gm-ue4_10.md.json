["```cpp\nclass APickupItem; //  forward declare the APickupItem class,\n                   // since it will be \"mentioned\" in a member  function decl below\nUCLASS()\nclass GOLDENEGG_API AAvatar : public ACharacter\n{\n  GENERATED_UCLASS_BODY()\n\n  // A map for the player's backpack\n  TMap<FString, int> Backpack;\n\n  // The icons for the items in the backpack, lookup by string\n  TMap<FString, UTexture2D*> Icons;\n\n  // A flag alerting us the UI is showing\n  bool inventoryShowing;\n  // member function for letting the avatar have an item\n  void Pickup( APickupItem *item );\n  // ... rest of Avatar.h same as before\n};\n```", "```cpp\nstruct Item\n{\n  FString name;\n  int qty;\n  UTexture2D* tex;\n};\n```", "```cpp\nvoid ToggleInventory();\n```", "```cpp\nvoid AAvatar::ToggleInventory()\n{\n  if( GEngine )\n  {\n    GEngine->AddOnScreenDebugMessage( 0, 5.f, FColor::Red,  \"Showing inventory...\" );\n  }\n}\n```", "```cpp\nvoid AAvatar::SetupPlayerInputComponent(class UInputComponent*  InputComponent)\n{\n  InputComponent->BindAction( \"Inventory\", IE_Pressed, this,  &AAvatar::ToggleInventory );\n  // rest of SetupPlayerInputComponent same as before\n}\n```", "```cpp\nUCLASS()\nclass GOLDENEGG_API APickupItem : public AActor\n{\n  GENERATED_UCLASS_BODY()\n\n  // The name of the item you are getting\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)\n  FString Name;\n\n  // How much you are getting\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)\n  int32 Quantity;\n\n  // the sphere you collide with to pick item up\n  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  Item)\n  TSubobjectPtr<USphereComponent> ProxSphere;\n\n  // The mesh of the item\n  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  Item)\n  TSubobjectPtr<UStaticMeshComponent> Mesh;\n\n  // The icon that represents the object in UI/canvas\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)\n  UTexture2D* Icon;\n\n  // When something comes inside ProxSphere, this function runs\n  UFUNCTION(BlueprintNativeEvent, Category = Collision)\n  void Prox( AActor* OtherActor, UPrimitiveComponent* OtherComp,  int32 OtherBodyIndex, bool bFromSweep, const FHitResult &  SweepResult );\n};\n```", "```cpp\nAPickupItem::APickupItem(const class FPostConstructInitializeProperties& PCIP) : Super(PCIP)\n{\n  Name = \"UNKNOWN ITEM\";\n  Quantity = 0;\n\n  // initialize the unreal objects\n  ProxSphere = PCIP.CreateDefaultSubobject<USphereComponent>(this,  TEXT(\"ProxSphere\"));\n  Mesh = PCIP.CreateDefaultSubobject<UStaticMeshComponent>(this,  TEXT(\"Mesh\"));\n\n  // make the root object the Mesh\n  RootComponent = Mesh;\n  Mesh->SetSimulatePhysics(true);\n\n  // Code to make APickupItem::Prox() run when this\n  // object's proximity sphere overlaps another actor.\n  ProxSphere->OnComponentBeginOverlap.AddDynamic(this,  &APickupItem::Prox);\n  ProxSphere->AttachTo( Mesh ); // very important!\t\n}\n```", "```cpp\n/**\n * Collision primitive that defines the transform (location,  rotation, scale) of this Actor.\n */\nUPROPERTY()\nclass USceneComponent* RootComponent;\n```", "```cpp\nvoid APickupItem::Prox_Implementation( AActor* OtherActor,  UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool  bFromSweep, const FHitResult & SweepResult )\n{\n  // if the overlapped actor is NOT the player,\n  // you simply should return\n  if( Cast<AAvatar>( OtherActor ) == nullptr )\n  {\n    return;\n  }\n\n  // Get a reference to the player avatar, to give him\n  // the item\n  AAvatar *avatar = Cast<AAvatar>(  UGameplayStatics::GetPlayerPawn( GetWorld(), 0 ) );\n\n  // Let the player pick up item\n  // Notice use of keyword this!\n  // That is how _this_ Pickup can refer to itself.\n  avatar->Pickup( this );\n\n  // Get a reference to the controller\n  APlayerController* PController = GetWorld()- >GetFirstPlayerController();\n\n  // Get a reference to the HUD from the controller\n  AMyHUD* hud = Cast<AMyHUD>( PController->GetHUD() );\n  hud->addMessage( Message( Icon, FString(\"Picked up \") + FString::FromInt(Quantity) + FString(\" \") + Name, 5.f, FColor::White, FColor::Black ) );\n\n  Destroy();\n}\n```", "```cpp\nAAvatar *avatar = Cast<AAvatar>(\n  UGameplayStatics::GetPlayerPawn( GetWorld(), 0 ) );\n```", "```cpp\nAPlayerController* PController =\n  GetWorld()->GetFirstPlayerController();\n```", "```cpp\nAMyHUD* hud = Cast<AMyHUD>( PController->GetHUD() );\n```", "```cpp\nvoid AAvatar::Pickup( APickupItem *item )\n{\n  if( Backpack.Find( item->Name ) )\n  {\n    // the item was already in the pack.. increase qty of it\n    Backpack[ item->Name ] += item->Quantity;\n  }\n  else\n  {\n    // the item wasn't in the pack before, add it in now\n    Backpack.Add(item->Name, item->Quantity);\n    // record ref to the tex the first time it is picked up\n    Icons.Add(item->Name, item->Icon);\n  }\n}\n```", "```cpp\navatar->Pickup( this );\n```", "```cpp\nstruct Icon\n{\n  FString name;\n  UTexture2D* tex;\n  Icon(){ name = \"UNKNOWN ICON\"; tex = 0; }\n  Icon( FString& iName, UTexture2D* iTex )\n  {\n    name = iName;\n    tex = iTex;\n  }\n};\n\nstruct Widget\n{\n  Icon icon;\n  FVector2D pos, size;\n  Widget(Icon iicon)\n  {\n    icon = iicon;\n  }\n  float left(){ return pos.X; }\n  float right(){ return pos.X + size.X; }\n  float top(){ return pos.Y; }\n  float bottom(){ return pos.Y + size.Y; }\n};\n```", "```cpp\nvoid AMyHUD::DrawWidgets()\n{\n  for( int c = 0; c < widgets.Num(); c++ )\n  {\n    DrawTexture( widgets[c].icon.tex, widgets[c].pos.X,  widgets[c].pos.Y, widgets[c].size.X, widgets[c].size.Y, 0, 0,  1, 1 );\n    DrawText( widgets[c].icon.name, FLinearColor::Yellow,  widgets[c].pos.X, widgets[c].pos.Y, hudFont, .6f, false );\n  }\n}\n```", "```cpp\nvoid AMyHUD::DrawHUD()\n{\n  Super::DrawHUD();\n  // dims only exist here in stock variable Canvas\n  // Update them so use in addWidget()\n  dims.X = Canvas->SizeX;\n  dims.Y = Canvas->SizeY;\n  DrawMessages();\n  DrawWidgets();\n}\n```", "```cpp\nvoid AAvatar::ToggleInventory()\n{\n  // Get the controller & hud\n  APlayerController* PController = GetWorld()- >GetFirstPlayerController();\n  AMyHUD* hud = Cast<AMyHUD>( PController->GetHUD() );\n\n  // If inventory is displayed, undisplay it.\n  if( inventoryShowing )\n  {\n    hud->clearWidgets();\n    inventoryShowing = false;\n    PController->bShowMouseCursor = false;\n    return;\n  }\n\n  // Otherwise, display the player's inventory\n  inventoryShowing = true;\n  PController->bShowMouseCursor = true;\n  for( TMap<FString,int>::TIterator it =  Backpack.CreateIterator(); it; ++it )\n  {\n    // Combine string name of the item, with qty eg Cow x 5\n    FString fs = it->Key + FString::Printf( TEXT(\" x %d\"), it- >Value );\n    UTexture2D* tex;\n    if( Icons.Find( it->Key ) )\n      tex = Icons[it->Key];\n    hud->addWidget( Widget( Icon( fs, tex ) ) );\n  }\n}\n```", "```cpp\nvoid AMyHUD::addWidget( Widget widget )\n{\n  // find the pos of the widget based on the grid.\n  // draw the icons..\n  FVector2D start( 200, 200 ), pad( 12, 12 );\n  widget.size = FVector2D( 100, 100 );\n  widget.pos = start;\n  // compute the position here\n  for( int c = 0; c < widgets.Num(); c++ )\n  {\n    // Move the position to the right a bit.\n    widget.pos.X += widget.size.X + pad.X;\n    // If there is no more room to the right then\n    // jump to the next line\n    if( widget.pos.X + widget.size.X > dims.X )\n    {\n      widget.pos.X = start.X;\n      widget.pos.Y += widget.size.Y + pad.Y;\n    }\n  }\n  widgets.Add( widget );\n}\n```", "```cpp\nvoid AAvatar::Yaw( float amount )\n{\n  if( inventoryShowing )\n  {\n    return; // when my inventory is showing,\n    // player can't move\n  }\n  AddControllerYawInput(200.f*amount * GetWorld()- >GetDeltaSeconds());\n}\n```", "```cpp\nstruct Widget\n{\n  // .. rest of struct same as before ..\n  bool hit( FVector2D p )\n  {\n    // +---+ top (0)\n    // |   |\n    // +---+ bottom (2) (bottom > top)\n    // L   R\n    return p.X > left() && p.X < right() && p.Y > top() && p.Y <  bottom();\n  }\n};\n```", "```cpp\nvoid MouseClicked();\n```", "```cpp\nvoid AAvatar::MouseClicked()\n{\n  APlayerController* PController = GetWorld()- >GetFirstPlayerController();\n  AMyHUD* hud = Cast<AMyHUD>( PController->GetHUD() );\n  hud->MouseClicked();\n}\n```", "```cpp\nInputComponent->BindAction( \"MouseClickedLMB\", IE_Pressed, this,  &AAvatar::MouseClicked );\n```", "```cpp\nWidget* heldWidget;  // hold the last touched Widget in memory\n```", "```cpp\nvoid AMyHUD::MouseClicked()\n{\n  FVector2D mouse;\n  PController->GetMousePosition( mouse.X, mouse.Y );\n  heldWidget = NULL; // clear handle on last held widget\n  // go and see if mouse xy click pos hits any widgets\n  for( int c = 0; c < widgets.Num(); c++ )\n  {\n    if( widgets[c].hit( mouse ) )\n    {\n      heldWidget = &widgets[c];// save widget\n      return;                  // stop checking\n    }\n  }\n}\n```", "```cpp\nvoid AMyHUD::MouseMoved()\n{\n  static FVector2D lastMouse;\n  FVector2D thisMouse, dMouse;\n  PController->GetMousePosition( thisMouse.X, thisMouse.Y );\n  dMouse = thisMouse - lastMouse;\n  // See if the left mouse has been held down for\n  // more than 0 seconds. if it has been held down,\n  // then the drag can commence.\n  float time = PController->GetInputKeyTimeDown(  EKeys::LeftMouseButton );\n  if( time > 0.f && heldWidget )\n  {\n    // the mouse is being held down.\n    // move the widget by displacement amt\n    heldWidget->pos.X += dMouse.X;\n    heldWidget->pos.Y += dMouse.Y; // y inverted\n  }\n  lastMouse = thisMouse;\n}\n```", "```cpp\nvoid AAvatar::Yaw( float amount )\n{\n  //x axis\n  if( inventoryShowing )\n  {\n    // When the inventory is showing,\n    // pass the input to the HUD\n    APlayerController* PController = GetWorld()- >GetFirstPlayerController();\n    AMyHUD* hud = Cast<AMyHUD>( PController->GetHUD() );\n    hud->MouseMoved();\n    return;\n  }\n  else\n  {\n    AddControllerYawInput(200.f*amount * GetWorld()- >GetDeltaSeconds());\n  }\n}\n```"]