<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;OpenGL Primitives and 2D Data Visualization"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. OpenGL Primitives and 2D Data Visualization</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">OpenGL primitives</li><li class="listitem" style="list-style-type: disc">Creating a 2D plot using primitives</li><li class="listitem" style="list-style-type: disc">Real-time visualization of time series</li><li class="listitem" style="list-style-type: disc">2D visualization of 3D/4D datasets</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Introduction</h1></div></div></div><p>In the previous chapter, we provided a sample code to render a triangle on the screen using OpenGL and the GLFW library. In this chapter, we will focus on the use of OpenGL primitives, such as points, lines, and triangles, to enable the basic 2D visualization of data, including time series such as an <a id="id0" class="indexterm"/>
<span class="strong"><strong>electrocardiogram</strong></span> (<span class="strong"><strong>ECG</strong></span>). We will begin with an introduction to each primitive, along with sample code to allow readers to experiment with the OpenGL primitives with a minimal learning curve.</p><p>One can think of primitives as the fundamental building blocks to create graphics using OpenGL. These building blocks can be easily reused in many applications and are highly portable among different platforms. Frequently, programmers struggle with displaying their results in a visually appealing manner, and an enormous amount of time may be spent on performing simple drawing tasks on screen. In this chapter, we will introduce a rapid prototyping approach to 2D data visualization using OpenGL so that impressive graphics can be created with minimal efforts. Most importantly, the proposed framework is highly intuitive and reusable, and it can be extended to be used in more sophisticated applications. Once you have mastered the basics of the OpenGL language, you will be equipped with the skills to create impressive applications that harness the true potential of OpenGL for data visualization using modern graphics hardware.</p></div></div>
<div class="section" title="OpenGL primitives"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>OpenGL primitives</h1></div></div></div><p>In the simplest terms, primitives<a id="id1" class="indexterm"/> are just basic shapes that are drawn in OpenGL. In this section, we will provide a brief overview of the main geometric primitives that are supported by OpenGL and focus specifically on three commonly used primitives (which will also appear in our demo applications): points, lines, and triangles.</p><div class="section" title="Drawing points"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec42"/>Drawing points</h2></div></div></div><p>We begin with a <a id="id2" class="indexterm"/>simple, yet very <a id="id3" class="indexterm"/>useful, building block for many visualization problems: a point primitive. A point can be in the form of ordered pairs in 2D, or it can be visualized in the 3D space.</p></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec43"/>Getting ready</h2></div></div></div><p>To simplify the workflow and improve the readability of the code, we first define a structure called <code class="literal">Vertex</code>, which encapsulates the fundamental elements such as the position and color of a vertex.</p><div class="informalexample"><pre class="programlisting">typedef struct
{
  GLfloat x, y, z; //position
  GLfloat r, g, b, a; //color and alpha channels
} Vertex;</pre></div><p>Now, we can treat every object and shape in terms of a set of vertices (with a specific color) in space. In this chapter, as our focus is on 2D visualization, the <span class="emphasis"><em>z</em></span> positions of vertices are often manually set to <code class="literal">0.0f</code>.</p><p>We can create a vertex at the center of the screen (0, 0, 0) with a white color as an example:</p><div class="informalexample"><pre class="programlisting">Vertex v = {0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};</pre></div><p>Note that the color element consists of the red, green, blue, and alpha channels. These values range from 0.0 to 1.0. The alpha channel allows us to create transparency (0: fully transparent; 1: fully opaque) so that objects can be blended together.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec44"/>How to do it…</h2></div></div></div><p>We can first define a function called <code class="literal">drawPoint</code> to encapsulate the complexity of OpenGL primitive functions, illustrated as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a function called <code class="literal">drawPoint</code> to draw points which takes in two parameters (the vertex and size of the point):<div class="informalexample"><pre class="programlisting">void drawPoint(Vertex v1, GLfloat size){</pre></div></li><li class="listitem">Specify the size of the point:<div class="informalexample"><pre class="programlisting">  glPointSize(size);</pre></div></li><li class="listitem">Set the beginning of the list of vertices to be specified and indicate the primitive type associated with the vertices (<code class="literal">GL_POINTS</code> in this case):<div class="informalexample"><pre class="programlisting">  glBegin(GL_POINTS);</pre></div></li><li class="listitem">Set the color and the vertex position using the fields from the <code class="literal">Vertex</code> structure:<div class="informalexample"><pre class="programlisting">  glColor4f(v1.r, v1.g, v1.b, v1.a);
  glVertex3f(v1.x, v1.y, v1.z);</pre></div></li><li class="listitem">Set the end of the list:<div class="informalexample"><pre class="programlisting">  glEnd();
}</pre></div></li><li class="listitem">In<a id="id4" class="indexterm"/> addition, we<a id="id5" class="indexterm"/> can define a function called <code class="literal">drawPointsDemo</code> to encapsulate the complexity further. This function draws a series of points with an increasing size:<div class="informalexample"><pre class="programlisting">void drawPointsDemo(int width, int height){
  GLfloat size=5.0f;
  for(GLfloat x = 0.0f; x&lt;=1.0f; x+=0.2f, size+=5)
  {
    Vertex v1 = {x, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};
    drawPoint(v1, size);
  }
}</pre></div></li></ol></div><p>Finally, let's integrate these two functions into a complete OpenGL demo program (refer to identical steps in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with OpenGL">Chapter 1</a>, <span class="emphasis"><em>Getting Started withOpenGL</em></span>):</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a source file called <code class="literal">main_point.cpp</code>, and then include the header file for the GLFW library and standard C++ libraries:<div class="informalexample"><pre class="programlisting">#include &lt;GLFW/glfw3.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;</pre></div></li><li class="listitem">Define the size of the window for display:<div class="informalexample"><pre class="programlisting">const int WINDOWS_WIDTH = 640*2;
const int WINDOWS_HEIGHT = 480;</pre></div></li><li class="listitem">Define the <code class="literal">Vertex</code> structure and function prototypes:<div class="informalexample"><pre class="programlisting">typedef struct
{
  GLfloat x, y, z;
  GLfloat r, g, b, a;
} Vertex;
void drawPoint(Vertex v1, GLfloat size);
void drawPointsDemo(int width, int height);</pre></div></li><li class="listitem">Implement the <code class="literal">drawPoint</code> and <code class="literal">drawPointsDemo</code> functions, as shown previously.</li><li class="listitem">Initialize<a id="id6" class="indexterm"/> GLFW and<a id="id7" class="indexterm"/> create a GLFW window object:<div class="informalexample"><pre class="programlisting">int main(void)
{
  GLFWwindow* window;
  if (!glfwInit())
    exit(EXIT_FAILURE);
  window = glfwCreateWindow(WINDOWS_WIDTH, WINDOWS_HEIGHT, "Chapter 2: Primitive drawings", NULL, NULL);
  if (!window){
    glfwTerminate();
    exit(EXIT_FAILURE);
  }
  glfwMakeContextCurrent(window);</pre></div></li><li class="listitem">Enable anti-aliasing and smoothing:<div class="informalexample"><pre class="programlisting">  glEnable(GL_POINT_SMOOTH);
  glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</pre></div></li><li class="listitem">Define a loop that terminates when the window is closed. Set up the viewport (using the size of the window) and clear the color buffer at the beginning of each iteration to update with new content:<div class="informalexample"><pre class="programlisting">  while (!glfwWindowShouldClose(window))
  {
    float ratio;
    int width, height;
    glfwGetFramebufferSize(window, &amp;width, &amp;height);
    ratio = (float) width / (float)height;
    glViewport(0, 0, width, height);
    glClear(GL_COLOR_BUFFER_BIT);</pre></div></li><li class="listitem">Set up the camera matrix for orthographic projection:<div class="informalexample"><pre class="programlisting">    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    //Orthographic Projection
    glOrtho(-ratio, ratio, -1.f, 1.f, 1.f, -1.f);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</pre></div></li><li class="listitem">Call the <code class="literal">drawPointsDemo</code> function:<div class="informalexample"><pre class="programlisting">    drawPointsDemo(width, height);</pre></div></li><li class="listitem">Swap the front and back buffers of the window and process the event queue (such as keyboard inputs) to avoid lock-up:<div class="informalexample"><pre class="programlisting">    glfwSwapBuffers(window);
    glfwPollEvents();
  }</pre></div></li><li class="listitem">Release<a id="id8" class="indexterm"/> the memory <a id="id9" class="indexterm"/>and terminate the GLFW library. Then, exit the application:<div class="informalexample"><pre class="programlisting">  glfwDestroyWindow(window);
  glfwTerminate();
  exit(EXIT_SUCCESS);
}</pre></div></li></ol></div><p>Here is the result (with anti-aliasing disabled) showing a series of points with an increasing size (that is, the diameter of each point as specified by <code class="literal">glPointSize</code>):</p><div class="mediaobject"><img src="graphics/9727OS_02_01.jpg" alt="How to do it…"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec45"/>How it works…</h2></div></div></div><p>The <code class="literal">glBegin</code> <a id="id10" class="indexterm"/>and <code class="literal">glEnd</code> functions <a id="id11" class="indexterm"/>delimit the list of vertices corresponding to a desired primitive (<code class="literal">GL_POINTS</code> in this demo). The <code class="literal">glBegin</code> function accepts a set of symbolic constants that represent different drawing methods, including <code class="literal">GL_POINTS</code>, <code class="literal">GL_LINES</code>, and <code class="literal">GL_TRIANGLES</code>, as discussed in this chapter.</p><p>There are several ways to control the process of drawing points. First, we can set the diameter of each point (in pixels) with the <code class="literal">glPointSize</code> function. By default, a point has a diameter of 1 without anti-aliasing (a method to smooth sampling artifacts) enabled. Also, we can define the color of each point as well as the alpha channel (transparency) using the <code class="literal">glColor4f</code> function. The alpha channel allows us to overlay points and blend graphics elements. This is a powerful, yet very simple, technique used in graphics design and user interface design. Lastly, we define the position of the point in space with the <code class="literal">glVertex3f</code> function.</p><p>In OpenGL, we <a id="id12" class="indexterm"/>can define the <a id="id13" class="indexterm"/>projection transformation in two different ways: orthographic projection or perspective projection. In 2D drawing, we often use orthographic projection which involves no perspective correction (for example, the object on screen will remain the same size regardless of its distance from the camera). In 3D drawing, we use perspective projection to create more realistic-looking scenes similar to how the human eye sees. In the code, we set up an orthographic projection <a id="id14" class="indexterm"/>with the <code class="literal">glOrtho</code> function. The <code class="literal">glOrtho</code> function takes these parameters: the coordinates of the vertical clipping plane, the coordinates of the horizontal clipping plane, and the distance of the nearer and farther depth clipping planes. These parameters determine the projection matrix, and the detailed documentation can be<a id="id15" class="indexterm"/> found in <a class="ulink" href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/glOrtho.3.html">https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/glOrtho.3.html</a>.</p><p>Anti-aliasing and smoothing are necessary to produce the polished look seen in modern graphics. Most graphics cards support native smoothing and in OpenGL, it can be enabled as follows:</p><div class="informalexample"><pre class="programlisting">glEnable(GL_POINT_SMOOTH);
glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</pre></div><p>Here is the final result with anti-aliasing enabled, showing a series of circular points with an increasing size:</p><div class="mediaobject"><img src="graphics/9727OS_02_02.jpg" alt="How it works…"/></div><p>Note that in the preceding diagram, the points are now rendered as circles instead of squares with the anti-aliasing feature enabled. Readers are encouraged to disable and enable the features of the preceding diagram to see the effects of the operation.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec46"/>See also</h2></div></div></div><p>In this tutorial, we have focused on the C programming style due to its simplicity. In the upcoming chapters, we will migrate to an object-oriented programming style using C++. In addition, in this chapter, we focus on three basic primitives (and discuss the derivatives of these primitives where appropriate): <code class="literal">GL_POINTS</code>, <code class="literal">GL_LINES</code>, and <code class="literal">GL_TRIANGLES</code>. Here is a more extensive list of <a id="id16" class="indexterm"/>primitives supported by OpenGL (refer to <a class="ulink" href="https://www.opengl.org/wiki/Primitive">https://www.opengl.org/wiki/Primitive</a> for more information):</p><div class="informalexample"><pre class="programlisting">GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP, and GL_POLYGON</pre></div></div><div class="section" title="Drawing line segments"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec47"/>Drawing line segments</h2></div></div></div><p>One natural extension<a id="id17" class="indexterm"/> now is to connect a line between data points and then to <a id="id18" class="indexterm"/>connect the lines together to form a grid for plotting. In fact, OpenGL natively supports drawing line segments, and the process is very similar to that of drawing a point.</p></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec48"/>Getting ready</h2></div></div></div><p>In OpenGL, we can simply define a line segment with a set of 2 vertices, and a line will be automatically formed between them by choosing <code class="literal">GL_LINES</code> as the symbolic constant in the <code class="literal">glBegin</code> statement.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec49"/>How to do it…</h2></div></div></div><p>Here, we define a new line drawing function called <code class="literal">drawLineSegment</code> which users can test by simply replacing the <code class="literal">drawPointsDemo</code> function in the previous section:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the <code class="literal">drawLineSegment</code> function which takes in two vertices and the width of the line as inputs:<div class="informalexample"><pre class="programlisting">void drawLineSegment(Vertex v1, Vertex v2, GLfloat width) {</pre></div></li><li class="listitem">Set the width of the line:<div class="informalexample"><pre class="programlisting">  glLineWidth(width);</pre></div></li><li class="listitem">Set the primitive type for line drawing:<div class="informalexample"><pre class="programlisting">  glBegin(GL_LINES);</pre></div></li><li class="listitem">Set the vertices and the color of the line:<div class="informalexample"><pre class="programlisting">  glColor4f(v1.r, v1.g, v1.b, v1.a);
  glVertex3f(v1.x, v1.y, v1.z);
  glColor4f(v2.r, v2.g, v2.b, v2.a);
  glVertex3f(v2.x, v2.y, v2.z);
  glEnd();
}</pre></div></li></ol></div><p>In addition, we define a new grid drawing function called <code class="literal">drawGrid</code>, built on top of the <code class="literal">drawLineSegment</code> function as follows:</p><div class="informalexample"><pre class="programlisting">void drawGrid(GLfloat width, GLfloat height, GLfloat grid_width){
  //horizontal lines
  for(float i=-height; i&lt;height; i+=grid_width){
    Vertex v1 = {-width, i, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};
    Vertex v2 = {width, i, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};
    drawLineSegment(v1, v2);
  }
  //vertical lines
  for(float i=-width; i&lt;width; i+=grid_width){
    Vertex v1 = {i, -height, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};
    Vertex v2 = {i, height, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};
    drawLineSegment(v1, v2);
  }
}</pre></div><p>Finally, we can<a id="id19" class="indexterm"/> execute the full demo by replacing the call for the <code class="literal">drawPointsDemo</code> function<a id="id20" class="indexterm"/> in the previous section with the following <code class="literal">drawLineDemo</code> function:</p><div class="informalexample"><pre class="programlisting">void drawLineDemo(){
  //draw a simple grid
  drawGrid(5.0f, 1.0f, 0.1f);
  //define the vertices and colors of the line segments
  Vertex v1 = {-5.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.7f};
  Vertex v2 = {5.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.7f};
  Vertex v3 = {0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.7f};
  Vertex v4 = {0.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.7f};
  //draw the line segments
  drawLineSegment(v1, v2, 10.0f);
  drawLineSegment(v3, v4, 10.0f);
}</pre></div><p>Here is a screenshot of the demo showing a grid with equal spacing and the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axes drawn with the line primitives:</p><div class="mediaobject"><img src="graphics/9727OS_02_03.jpg" alt="How to do it…"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec50"/>How it works…</h2></div></div></div><p>There are <a id="id21" class="indexterm"/>multiple ways of drawing line segments in OpenGL. We have<a id="id22" class="indexterm"/> demonstrated the use of <code class="literal">GL_LINES</code> which takes every consecutive pair of vertices in the list to form an independent line segment for each pair. On the other hand, if you would like to draw a line without gaps, you can use the <code class="literal">GL_LINE_STRIP</code> option, which connects all the vertices in a consecutive fashion. Finally, to form a closed loop sequence in which the endpoints of the lines are connected, you would use the <code class="literal">GL_LINE_LOOP</code> option.</p><p>In addition, we can modify the width and the color of a line with the <code class="literal">glLineWidth</code> and <code class="literal">glColor4f</code> functions for each vertex, respectively.</p></div><div class="section" title="Drawing triangles"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec51"/>Drawing triangles</h2></div></div></div><p>We will now move on to <a id="id23" class="indexterm"/>another very commonly used primitive, namely a triangle, which<a id="id24" class="indexterm"/> forms the basis for drawing all possible polygons.</p></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec52"/>Getting ready</h2></div></div></div><p>Similar to drawing a line segment, we can simply define a triangle with a set of 3 vertices, and line segments will be automatically formed by choosing <code class="literal">GL_TRIANGLES</code> as the symbolic constant in the <code class="literal">glBegin</code> statement.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec53"/>How to do it…</h2></div></div></div><p>Finally, we define a new function called <code class="literal">drawTriangle</code>, which users can test by simply replacing the <code class="literal">drawPointsDemo</code> function. We will also reuse the <code class="literal">drawGrid</code> function from the previous section:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the <code class="literal">drawTriangle</code> function, which takes in three vertices as the input:<div class="informalexample"><pre class="programlisting">void drawTriangle(Vertex v1, Vertex v2, Vertex v3){</pre></div></li><li class="listitem">Set the primitive type to draw triangles:<div class="informalexample"><pre class="programlisting">  glBegin(GL_TRIANGLES);</pre></div></li><li class="listitem">Set the vertices and the color of the triangle:<div class="informalexample"><pre class="programlisting">  glColor4f(v1.r, v1.g, v1.b, v1.a);
  glVertex3f(v1.x, v1.y, v1.z);
  glColor4f(v2.r, v2.g, v2.b, v2.a);
  glVertex3f(v2.x, v2.y, v2.z);
  glColor4f(v3.r, v3.g, v3.b, v3.a);
  glVertex3f(v3.x, v3.y, v3.z);
  glEnd(),
}</pre></div></li><li class="listitem">Execute the demo<a id="id25" class="indexterm"/> by replacing the call for the <code class="literal">drawPointsDemo</code> function<a id="id26" class="indexterm"/> in the full demo code with the following <code class="literal">drawTriangleDemo</code> function:<div class="informalexample"><pre class="programlisting">void drawTriangleDemo(){
  //Triangle Demo
  Vertex v1 = {0.0f, 0.8f, 0.0f, 1.0f, 0.0f, 0.0f, 0.6f};
  Vertex v2 = {-1.0f, -0.8f, 0.0f, 0.0f, 1.0f, 0.0f, 0.6f};
  Vertex v3 = {1.0f, -0.8f, 0.0f, 0.0f, 0.0f, 1.0f, 0.6f};
  drawTriangle(v1, v2, v3);
}</pre></div></li></ol></div><p>Here is the final result with a triangle rendered with 60 percent transparency overlaid on top of the grid lines:</p><div class="mediaobject"><img src="graphics/9727OS_02_04.jpg" alt="How to do it…"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec54"/>How it works…</h2></div></div></div><p>While the process <a id="id27" class="indexterm"/>of drawing a triangle in OpenGL appears similar to previous examples, there <a id="id28" class="indexterm"/>are some subtle differences and further complexities that can be incorporated. There are three different modes in this primitive (<code class="literal">GL_TRIANGLES</code>, <code class="literal">GL_TRIANGLE_STRIP</code>, and <code class="literal">GL_TRIANGLE_FAN</code>), and each handles the vertices in a different manner. First, <code class="literal">GL_TRIANGLES</code> takes three vertices from a given list to create a triangle. The triangles are independently formed from each triplet of the vertices (that is, every three vertices are turned into a different triangle). On the other hand, <code class="literal">GL_TRIANGLE_STRIP</code> forms a triangle with the first three vertices, and each subsequent vertex forms a new triangle using the previous two vertices. Lastly, <code class="literal">GL_TRIANGLE_FAN</code> creates an arbitrarily complex convex polygon by creating triangles that have a common vertex in the center specified by the first vertex v_1, which forms a fan-shaped structure consisting of triangles. In other words, triangles will be generated in the grouping order specified as follows:</p><div class="informalexample"><pre class="programlisting">(v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>), (v<sub>1</sub>, v<sub>3</sub>, v<sub>4</sub>),...,(v<sub>1</sub>, v<sub>n-1</sub>, v<sub>n</sub>)
for n vertices</pre></div><p>Although a different color is set for each vertex, OpenGL handles color transition (linear interpolation) automatically, as shown in the triangle drawing in the previous example. The vertices are set to red, green, and blue, but the spectrum of colors can be clearly seen. Additionally, transparency can be set using the alpha channel, which enables us to clearly see the grid behind the triangle. With OpenGL, we can also add other elements, such as the advanced handling of color and shading, which will be discussed in the upcoming chapters.</p></div></div>
<div class="section" title="Creating a 2D plot using primitives"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Creating a 2D plot using primitives</h1></div></div></div><p>Creating a 2D plot<a id="id29" class="indexterm"/> is a common way of visualizing trends in <a id="id30" class="indexterm"/>datasets in many applications. With OpenGL, we can render such plots in a much more dynamic way compared to conventional approaches (such as basic MATLAB plots) as we can gain full control over the graphics shader for color manipulation and we can also provide real-time feedback to the system. These unique features allow users to create highly interactive systems, so that, for example, time series such as an electrocardiogram can be visualized with minimal effort.</p><p>Here, we first demonstrate the visualization of a simple 2D dataset, namely a sinusoidal function in discrete time.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec55"/>Getting ready</h2></div></div></div><p>This demo requires a number of functions (including the <code class="literal">drawPoint</code>, <code class="literal">drawLineSegment</code>, and <code class="literal">drawGrid</code> functions) implemented earlier. In addition, we will reuse the code structure introduced in the <a class="link" href="ch01.html" title="Chapter 1. Getting Started with OpenGL">Chapter 1</a>, <span class="emphasis"><em>Getting Started with OpenGL</em></span> to execute the demo.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec56"/>How to do it…</h2></div></div></div><p>We begin by generating a<a id="id31" class="indexterm"/> simulated data stream for a sinusoidal <a id="id32" class="indexterm"/>function over a time interval. In fact, the data stream can be any arbitrary signal or relationship:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's define an additional structure called <code class="literal">Data</code> to simplify the interface:<div class="informalexample"><pre class="programlisting">typedef struct
{
  GLfloat x, y, z;
} Data;</pre></div></li><li class="listitem">Define a generic 2D data plotting function called <code class="literal">draw2DscatterPlot</code> with the input data stream and number of points as the input:<div class="informalexample"><pre class="programlisting">void draw2DscatterPlot (const Data *data, int num_points){</pre></div></li><li class="listitem">Draw the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axes using the <code class="literal">drawLineSegment</code> function described earlier:<div class="informalexample"><pre class="programlisting">  Vertex v1 = {-10.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};
  Vertex v2 = {10.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};
  drawLineSegment(v1, v2, 2.0f);
  v1.x = 0.0f;
  v2.x = 0.0f;
  v1.y = -1.0f;
  v2.y = 1.0f;
  drawLineSegment(v1, v2, 2.0f);</pre></div></li><li class="listitem">Draw the data points one by one with the <code class="literal">drawPoint</code> function:<div class="informalexample"><pre class="programlisting">  for(int i=0; i&lt;num_points; i++){
    GLfloat x=data[i].x;
    GLfloat y=data[i].y;
    Vertex v={x, y, 0.0f, 1.0f, 1.0f, 1.0f, 0.5f};
    drawPoint(v, 8.0f);
  }
}</pre></div></li><li class="listitem">Create a similar function called <code class="literal">draw2DlineSegments</code> to connect the dots together with the line segments so that both the curve and the data points can be shown simultaneously:<div class="informalexample"><pre class="programlisting">void draw2DlineSegments(const Data *data, int num_points){
  for(int i=0; i&lt;num_points-1; i++){
    GLfloat x1=data[i].x;
    GLfloat y1=data[i].y;
    GLfloat x2=data[i+1].x;
    GLfloat y2=data[i+1].y;
    Vertex v1={x1, y1, 0.0f, 0.0f, 1.0f, 1.0f, 0.5f};
    Vertex v2={x2, y2, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f};
    drawLineSegment(v1, v2, 4.0f);
  }
}</pre></div></li><li class="listitem">Integrate<a id="id33" class="indexterm"/> everything into a full demo by<a id="id34" class="indexterm"/> creating the grid, generating the simulated data points using a cosine function and plotting the data points:<div class="informalexample"><pre class="programlisting">void linePlotDemo(float phase_shift){
  drawGrid(5.0f, 1.0f, 0.1f);
  GLfloat range = 10.0f;
  const int num_points = 200;
  Data *data=(Data*)malloc(sizeof(Data)*num_points);
  for(int i=0; i&lt;num_points; i++){
    data[i].x=((GLfloat)i/num_points)*range-range/2.0f;
    data[i].y= 0.8f*cosf(data[i].x*3.14f+phase_shift);
  }
  draw2DScatterPlot(data, num_points);
  draw2DLineSegments(data, num_points);
  free(data);
}</pre></div></li><li class="listitem">Finally, in the main program, include the <code class="literal">math.h</code> header file for the cosine function and add a new variable called <code class="literal">phase_shift</code> outside the loop to execute this demo. You can download the code package from Packt Publishing website for the complete demo code:<div class="informalexample"><pre class="programlisting">#include &lt;math.h&gt;
...
int main(void){
  ...
  float phase_shift=0.0f;
  while (!glfwWindowShouldClose(window)){
    ...
    phase_shift+=0.02f;
    linePlotDemo(phase_shift);
    ...

    //finished all demo calls
    glfwSwapBuffers(window);
    glfwPollEvents();
  }
  ...
}</pre></div></li></ol></div><p>The final result simulating a real-time input data stream with a sinusoidal shape is plotted on top of grid lines using a combination of basic primitives discussed in previous sections.</p><div class="mediaobject"><img src="graphics/9727OS_02_05.jpg" alt="How to do it…"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec57"/>How it works…</h2></div></div></div><p>Using the simple<a id="id35" class="indexterm"/> toolkit we created earlier using basic OpenGL<a id="id36" class="indexterm"/> primitives, we plotted a sinusoidal function with the data points (sampled at a constant time interval) overlaid on top of the curve. The smooth curve consists of many individual line segments drawn using the <code class="literal">draw2DlineSegments</code> function, while the samples were plotted using the <code class="literal">drawPoint</code> function. This intuitive interface serves as the basis for the visualization of more interesting time series for real-world applications in the next section.</p></div></div>
<div class="section" title="Real-time visualization of time series"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Real-time visualization of time series</h1></div></div></div><p>In this section, we further<a id="id37" class="indexterm"/> demonstrate the versatility of our framework <a id="id38" class="indexterm"/>to plot general time series data for biomedical applications. In particular, we will display an ECG in real time. As a brief introduction, an ECG is a very commonly used diagnostic and monitoring tool to detect abnormalities in the heart. ECG surface recording essentially probes the electrical activities of the heart. For example, the biggest spike (called a QRS complex) typically corresponds to the depolarization of the ventricles of the heart (the highly muscular chambers of the heart that pump blood). A careful analysis of the ECG<span class="strong"><strong> </strong></span>can be a very powerful, noninvasive method for distinguishing many heart diseases clinically, including many forms of arrhythmia and heart attacks.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec58"/>Getting ready</h2></div></div></div><p>We begin by<a id="id39" class="indexterm"/> importing a computer-generated ECG<a id="id40" class="indexterm"/> data stream. The ECG data stream is stored in <code class="literal">data_ecg.h</code> (only a small portion of the data stream is provided here):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>float data_ecg[]={0.396568808f, 0.372911844f, 0.311059085f, 0.220346775f, 0.113525529f, 0.002200333f, -0.103284775f, -0.194218528f, -0.266285973f, -0.318075979f, -0.349670132f, -0.362640042f, -0.360047348f, -0.346207663f, -0.325440887f, -0.302062532f, -0.279400804f, -0.259695686f … };</strong></span>
</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec59"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Use the following code to plot the ECG data by drawing line segments:<div class="informalexample"><pre class="programlisting">void plotECGData(int offset, int size, float offset_y, float scale){
  //space between samples
  const float space = 2.0f/size*ratio;
  //initial position of the first vertex to render
  float pos = -size*space/2.0f;
  //set the width of the line
  glLineWidth(5.0f);
  glBegin(GL_LINE_STRIP);
  //set the color of the line to green
  glColor4f(0.1f, 1.0f, 0.1f, 0.8f);
  for (int i=offset; i&lt;size+offset; i++){
    const float data = scale*data_ecg[i]+offset_y;
    glVertex3f(pos, data, 0.0f);
    pos += space;
  }
  glEnd();
}</pre></div></li><li class="listitem">Display multiple ECG data streams (simulating recording from different leads):<div class="informalexample"><pre class="programlisting">void ecg_demo(int counter){
  const int data_size=ECG_DATA_BUFFER_SIZE;
  //Emulate the presence of multiple ECG leads (just for demo/ display purposes)
  plotECGData(counter, data_size*0.5, -0.5f, 0.1f);
  plotECGData(counter+data_size, data_size*0.5, 0.0f, 0.5f);
  plotECGData(counter+data_size*2, data_size*0.5, 0.5f, -0.25f);
}</pre></div></li><li class="listitem">Finally, in the <a id="id41" class="indexterm"/>main program, include <a id="id42" class="indexterm"/>the <code class="literal">data_ecg.h</code> header file and add the following lines of code to the loop. You can download the code package from the Packt Publishing website for the complete demo code:<div class="informalexample"><pre class="programlisting">#include "data_ecg.h"
...
int main(void){
  ...
  while (!glfwWindowShouldClose(window)){
    ...
    drawGrid(5.0f, 1.0f, 0.1f);
    //reset counter to 0 after reaching the end of the sample data
    if(counter&gt;5000){
      counter=0;
    }
    counter+=5;
    //run the demo visualizer
    ecg_demo(counter);
    ...
  }
}</pre></div></li></ol></div><p>Here are two snapshots of the real-time display across multiple ECG leads simulated at two different time points. If you execute the demo, you will see the ECG recording from multiple leads move across the screen as the data stream is processed for display.</p><div class="mediaobject"><img src="graphics/9727OS_02_06.jpg" alt="How to do it…"/></div><p>Here is the second<a id="id43" class="indexterm"/> snapshot at a later time <a id="id44" class="indexterm"/>point:</p><div class="mediaobject"><img src="graphics/9727OS_02_07.jpg" alt="How to do it…"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec60"/>How it works…</h2></div></div></div><p>This demo shows<a id="id45" class="indexterm"/> the use of the <code class="literal">GL_LINE_STRIP</code> <a id="id46" class="indexterm"/>option, described previously, to plot an ECG time series. Instead of drawing individual and independent line segments (using the <code class="literal">GL_LINE</code> option), we draw a continuous stream of data by calling the <code class="literal">glVertex3f</code> function for each data point. Additionally, the time series animates through the screen and provides dynamic updates on an interactive frame with minimal impact on the CPU computation cycles.</p></div></div>
<div class="section" title="2D visualization of 3D/4D datasets"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>2D visualization of 3D/4D datasets</h1></div></div></div><p>We have now learned multiple<a id="id47" class="indexterm"/> methods to generate plots on screen using points and lines. In the last section, we will demonstrate how to visualize a million data points in a 3D dataset using OpenGL in real time. A common strategy to visualize a complex 3D dataset is to encode the third dimension (for example, the <span class="emphasis"><em>z</em></span> dimension) in the form of a heat map with a desirable color scheme. As an example, we show a heat map of a 2D Gaussian function with its height <span class="emphasis"><em>z</em></span>, encoded using a simple color scheme. In general, a 2-D Gaussian function, <span class="inlinemediaobject"><img src="graphics/9727OS_02_10.jpg" alt="2D visualization of 3D/4D datasets"/></span>, is defined as follows:</p><div class="mediaobject"><img src="graphics/9727OS_02_09.jpg" alt="2D visualization of 3D/4D datasets"/></div><p>Here, <span class="emphasis"><em>A</em></span> is the amplitude (<span class="inlinemediaobject"><img src="graphics/9727OS_02_9a.jpg" alt="2D visualization of 3D/4D datasets"/></span>) of the distribution centered at <span class="inlinemediaobject"><img src="graphics/9727OS_02_11.jpg" alt="2D visualization of 3D/4D datasets"/></span> and <span class="inlinemediaobject"><img src="graphics/9727OS_02_12.jpg" alt="2D visualization of 3D/4D datasets"/></span> are the standard deviations (spread) of the distribution in the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> directions. To make this demo more interesting and more visually appealing, we vary the standard deviation or sigma term (equally in the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> directions) over time. Indeed, we can apply the same method to visualize very complex 3D datasets.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec61"/>Getting ready</h2></div></div></div><p>By now, you should be very familiar with the basic primitives described in previous sections. Here, we employ the <code class="literal">GL_POINTS</code> option to generate a dense grid of data points with different colors encoding the <span class="emphasis"><em>z</em></span> dimension.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec62"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Generate a<a id="id48" class="indexterm"/> million data points (1,000 x 1,000 grid) with a 2-D Gaussian function:<div class="informalexample"><pre class="programlisting">void gaussianDemo(float sigma){
  //construct a 1000x1000 grid
  const int grid_x = 1000;
  const int grid_y = 1000;
  const int num_points = grid_x*grid_y;
  Data *data=(Data*)malloc(sizeof(Data)*num_points);
  int data_counter=0;
  for(int x = -grid_x/2; x&lt;grid_x/2; x+=1){
    for(int y = -grid_y/2; y&lt;grid_y/2; y+=1){
      float x_data = 2.0f*x/grid_x;
      float y_data = 2.0f*y/grid_y;
      //compute the height z based on a
      //2D Gaussian function.
      float z_data = exp(-0.5f*(x_data*x_data)/(sigma*sigma) -0.5f*(y_data*y_data)/(sigma*sigma))/(sigma*sigma*2.0f*M_PI);
      data[data_counter].x = x_data;
      data[data_counter].y = y_data;
      data[data_counter].z = z_data;
      data_counter++;
    }
  }
  //visualize the result using a 2D heat map
  draw2DHeatMap(data, num_points);
  free(data);
}</pre></div></li><li class="listitem">Draw the data points using a heat map function for color visualization:<div class="informalexample"><pre class="programlisting">void draw2DHeatMap(const Data *data, int num_points){
  //locate the maximum and minimum values in the dataset
  float max_value=-999.9f;
  float min_value=999.9f;
  for(int i=0; i&lt;num_points; i++){
    const Data d = data[i];
    if(d.z &gt; max_value){
      max_value = d.z;
    }
    if(d.z &lt; min_value){
      min_value = d.z;
    }
  }
  const float halfmax = (max_value + min_value) / 2;

  //display the result
  glPointSize(2.0f);
  glBegin(GL_POINTS);
  for(int i = 0; i&lt;num_points; i++){
    const Data d = data[i];
    float value = d.z;
    float b = 1.0f - value/halfmax;
    float r = value/halfmax - 1.0f;
    if(b &lt; 0){
      b=0;
    }
    if(r &lt; 0){
      r=0;
    }
    float g = 1.0f - b - r;
    glColor4f(r, g, b, 0.5f);
    glVertex3f(d.x, d.y, 0.0f);
  }
  glEnd();
}</pre></div></li><li class="listitem">Finally, in the <a id="id49" class="indexterm"/>main program, include the <code class="literal">math.h</code> header file and add the following lines of code to the loop to vary the sigma term over time. You can download the example code from the Packt Publishing website for the complete demo code:<div class="informalexample"><pre class="programlisting">#define _USE_MATH_DEFINES // M_PI constant
#include &lt;math.h&gt;
...
int main(void){
  ...
  float sigma = 0.01f;
  while (!glfwWindowShouldClose(window)){
    ...
    drawGrid(5.0f, 1.0f, 0.1f);
    sigma+=0.01f;
    if(sigma&gt;1.0f)
      sigma=0.01;
    gaussianDemo(sigma);
    ...
  }
}</pre></div></li></ol></div><p>Here are four figures illustrating the effect of varying the sigma term of the 2-D Gaussian function over time (from 0.01 to 1):</p><div class="mediaobject"><img src="graphics/9727OS_02_08.jpg" alt="How to do it…"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec63"/>How it works…</h2></div></div></div><p>We have demonstrated<a id="id50" class="indexterm"/> how to visualize a Gaussian function using a simple heat map in which the maximum value is represented by red, while the minimum value is represented by blue. In total, a million data points (1,000 x 1,000) were plotted using vertices for each Gaussian function with a specific sigma term. This sigma term was varied from 0.01 to 1 to show a time-varying Gaussian distribution. To reduce the overhead, vertex buffers can be implemented in the future (we can perform the memory copy operation all at once and remove the <code class="literal">glVertex3f</code> calls). Similar techniques can be applied to the color channel as well.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec64"/>There's more…</h2></div></div></div><p>The heat map we <a id="id51" class="indexterm"/>have described here provides a powerful visualization tool for complex 3D datasets seen in many scientific and biomedical applications. Indeed, we have actually extended our demo to the visualization of a 4D dataset, to be precise, since a time-varying 3D function; with the height encoded using a color map was displayed. This demo shows the many possibilities for displaying data in an interesting, dynamic way using just 2D techniques based on OpenGL primitives. In the next chapter, we will demonstrate the potential of OpenGL further by incorporating 3D rendering and adding user inputs to enable the 3D, interactive visualization of more complex datasets.</p></div></div></body></html>