<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Resources and Memory</h1>
            </header>

            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating a buffer</li>
<li>Allocating and binding a memory object for a buffer</li>
<li>Setting a buffer memory barrier</li>
<li>Creating a buffer view</li>
<li>Creating an image</li>
<li>Allocating and binding a memory object to an image</li>
<li>Setting an image memory barrier</li>
<li>Creating an image view</li>
<li>Creating a 2D image and view</li>
<li>Creating a layered 2D image with a CUBEMAP view</li>
<li>Mapping, updating, and unmapping host-visible memory</li>
<li>Copying data between buffers</li>
<li>Copying data from a buffer to an image</li>
<li>Copying data from an image to a buffer</li>
<li>Using a staging buffer to update a buffer with a device-local memory bound</li>
<li>Using a staging buffer to update an image with a device-local memory bound</li>
<li>Destroying an image view</li>
<li>Destroying an image</li>
<li>Destroying a buffer view</li>
<li>Freeing a memory object</li>
<li>Destroying a buffer</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Introduction</h1>
            </header>

            <article>
                
<p>In Vulkan, there are two very important types of resources in which data can be stored--buffers and images. Buffers represent linear arrays of data. Images, similarly to OpenGL's textures, represent one-, two-, or three-dimensional data organized in a way that is (generally) specific for a given hardware (so we don't know the internal memory structure). Buffers and images can be used for various purposes: in shaders, we can read or sample data from them, or store data in them. Images can be used as color or depth/stencil attachments (render targets), which means that we can render into them. Buffers can also store vertex attributes, indices, or parameters used during indirect drawing.</p>
<p>What is very important is that each of the mentioned usages must be specified during resource creation (we can provide many of them at once). We also need to inform the driver when we change the way in which a given resource is used in our application.</p>
<p>As opposed to high-level APIs such as OpenGL, buffers and images in Vulkan don't have their own storage. They require us to specifically create and bind appropriate memory objects.</p>
<p>In this chapter, we will learn how to use these resources and how to allocate memory for them and bind it to them. We will also learn how to upload data from the CPU to the GPU, and how to copy data between resources.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a buffer</h1>
            </header>

            <article>
                
<p>Buffers are the <span>simplest </span> resources because they represent data which can be laid out in memory <span>only </span> linearly, just like in typical C/C++ arrays:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="69" src="assets/image_04_01.png" width="492"/></div>
<p>Buffers can be used for various purposes. They can be used in pipelines via descriptor sets to back data stores for uniform buffers, storage buffers, or texel buffers, among others. They can be a source of data for vertex indices or attributes, or can be used as <strong>staging resources</strong>--intermediate resources for data transfer from the CPU to the GPU. For all these purposes, we just need to create a buffer and specify its usage.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a created logical device stored in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Create a variable of type <kbd>VkDeviceSize</kbd> named <kbd>size</kbd>, in which store a value that will represent the size of data (in bytes) which a buffer will be able to store.</li>
<li>Think of desired scenarios a buffer will be used for. Create a variable of a bitfield type <kbd>VkBufferUsageFlags</kbd> named <kbd>usage</kbd>. Assign a value that is a logical sum (<kbd>OR</kbd>) of all desired buffer usages.</li>
<li>Create a variable of type <kbd>VkBufferCreateInfo</kbd> named <kbd>buffer_create_info</kbd>. Assign the following values to its members: 
<ul>
<li><kbd>VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li><kbd>0</kbd> value for <kbd>flags</kbd></li>
<li><kbd>size</kbd> variable for <kbd>size</kbd></li>
<li><kbd>usage</kbd> variable for <kbd>usage</kbd></li>
<li><kbd>VK_SHARING_MODE_EXCLUSIVE</kbd> value for <kbd>sharingMode</kbd></li>
<li><kbd>0</kbd> value for <kbd>queueFamilyIndexCount</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pQueueFamilyIndices</kbd></li>
</ul>
</li>
<li>Create a variable of type <kbd>VkBuffer</kbd> named <kbd>buffer</kbd>, in which a handle of a created buffer will be stored.</li>
<li>Call <kbd>vkCreateBuffer( logical_device, &amp;buffer_create_info, nullptr, &amp;buffer )</kbd>, and provide a handle of the logical device in the first parameter, a pointer to the <kbd>buffer_create_info</kbd> variable in the second parameter, a <kbd>nullptr</kbd> value in the third parameter, and a pointer to the <kbd>buffer</kbd> variable in the last parameter.</li>
<li>Make sure the function call was successful by checking whether the returned valued is equal to <kbd>VK_SUCCESS</kbd>.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Before we can create a buffer, we need to know how big the buffer should be and how we want to use it. A buffer's size is determined by the amount of data we would like to store in it. All the ways in which buffer will be used in our application are specified by the buffer's usage. We can't use a buffer in a way that wasn't defined during buffer creation.</p>
<div class="packt_tip">Buffers can only be used for purposes (usages) specified during their creation.</div>
<p>Here is a list of supported ways in which buffers can be used:</p>
<ul>
<li><kbd>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</kbd> specifies that the buffer can be a source of data for copy operations</li>
<li><kbd>VK_BUFFER_USAGE_TRANSFER_DST_BIT</kbd> specifies that we can copy data to the buffer</li>
<li><kbd>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT</kbd> indicates that the buffer can be used in shaders as a uniform texel buffer</li>
<li><kbd>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT</kbd> specifies that the buffer can be used in shaders as a storage texel buffer</li>
<li><kbd>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</kbd> indicates that the buffer can be used in shaders as a source of values for uniform variables</li>
<li><kbd>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</kbd> indicates that we can store data in the buffer from within shaders</li>
<li><kbd>VK_BUFFER_USAGE_INDEX_BUFFER_BIT</kbd> specifies that the buffer can be used as a source of vertex indices during drawing</li>
<li><kbd>VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</kbd> indicates that the buffer can be a source of data for vertex attributes specified during drawing</li>
<li><kbd>VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT</kbd> indicates that the buffer can contain data that will be used during indirect drawing</li>
</ul>
<p>To create a buffer, we need to prepare a variable of type <kbd>VkBufferCreateInfo</kbd> in which we provide the following data:</p>
<pre>
VkBufferCreateInfo buffer_create_info = { 
  VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, 
  nullptr, 
  0, 
  size, 
  usage, 
  VK_SHARING_MODE_EXCLUSIVE, 
  0, 
  nullptr 
};
</pre>
<p>The <kbd>size</kbd> and <kbd>usage</kbd> variables define the amount of data the buffer can hold and the ways in which we can use the buffer in our application, respectively.</p>
<p>The preceding <kbd>VK_SHARING_MODE_EXCLUSIVE</kbd> value provided for the <kbd>sharingMode</kbd> member is another very important parameter. Through it, we specify whether queues from multiple families can access the buffer at the same time. <strong>Exclusive sharing mode</strong> tells the driver that the buffer can be referenced only by queues from one family at a single time. If we want to use the buffer in commands submitted to queues from another family, we must explicitly tell the driver when the ownership has changed (when we transferred ownership from one family to another). This option gives us a better performance, but with a cost of more work.</p>
<p>We can also specify a <kbd>VK_SHARING_MODE_CONCURRENT</kbd> sharing mode. With it, multiple queues from multiple families can access a buffer at the same time and we don't need to perform an ownership transfer. But, the trade-off is that a <strong>concurrent access</strong> may have lower performance.</p>
<p>After we have prepared the creation data, we can create a buffer like this:</p>
<pre>
VkResult result = vkCreateBuffer( logical_device, &amp;buffer_create_info, nullptr, &amp;buffer ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Could not create a buffer." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Allocating and binding a memory object for a buffer</em></li>
<li><em>Setting a buffer memory barrier</em></li>
<li><em>Creating a buffer view</em></li>
<li><em>Using a staging buffer to update a buffer with a device-local memory bound</em></li>
<li><em>Destroying a buffer</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Allocating and binding a memory object for a buffer</h1>
            </header>

            <article>
                
<p>In Vulkan, buffers don't have their own memory. To be able to use buffers in our application and to store any data inside them, we need to allocate a memory object and bind it to a buffer.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a physical device from which the logical device was created. Store it in a variable of type <kbd>VkPhysicalDevice</kbd> named <kbd>physical_device</kbd>.</li>
<li>Create a variable of type <kbd>VkPhysicalDeviceMemoryProperties</kbd> named <kbd>physical_device_memory_properties</kbd>.</li>
<li>Call <kbd>vkGetPhysicalDeviceMemoryProperties( physical_device, &amp;physical_device_memory_properties )</kbd>, for which provide the handle of a physical device and a pointer to the <kbd>physical_device_memory_properties</kbd> variable. This call will store memory parameters (number of heaps, their size, and types) of the physical device used for processing.</li>
<li>Take the handle of a logical device created from the physical device, represented by the <kbd>physical_device</kbd> variable. Store the handle in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Take the handle of a created buffer represented by a variable of type <kbd>VkBuffer</kbd> named <kbd>buffer</kbd>.</li>
<li>Create a variable of type <kbd>VkMemoryRequirements</kbd> named <kbd>memory_requirements</kbd>.</li>
<li>Acquire parameters of a memory that needs to be used for the buffer. Do this by calling <kbd>vkGetBufferMemoryRequirements( logical_device, buffer, &amp;memory_requirements )</kbd>, and providing the handle of the logical device in the first parameter, the handle of the created buffer in the second parameter, and a pointer to the <kbd>memory_requirements</kbd> variable in the third parameter.</li>
<li>Create a variable of type <kbd>VkDeviceMemory</kbd> named <kbd>memory_object</kbd> that will represent the created buffer's memory object, and assign a <kbd>VK_NULL_HANDLE</kbd> value to it.</li>
<li>Create a variable of type <kbd>VkMemoryPropertyFlagBits</kbd> named <kbd>memory_properties</kbd>. Store additional (chosen) memory properties in the variable.</li>
</ol>
<ol start="10">
<li>Iterate over the available physical device's memory types represented by the <kbd>memoryTypeCount</kbd> member of a <kbd>physical_device_memory_properties</kbd> variable. Do this by using the variable of type <kbd>uint32_t</kbd> named <kbd>type</kbd>. For each loop iteration, perform the following steps:
<ol>
<li>Make sure that the bit of the <kbd>memoryTypeBits</kbd> member of the <kbd>memory_requirements</kbd> variable on the position represented by the <kbd>type</kbd> variable is set.</li>
<li>Make sure that the <kbd>memory_properties</kbd> variable has the same bits set as a <kbd>propertyFlags</kbd> member of the memory type, at index <kbd>type</kbd> of the <kbd>memoryTypes</kbd> array in the <kbd>physical_device_memory_properties</kbd> variable.</li>
<li>If points 1 and 2 are not true, continue iterating the loop.</li>
<li>Create a variable of type <kbd>VkMemoryAllocateInfo</kbd> named <kbd>buffer_memory_allocate_info</kbd>, and assign the following values for its members:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li><kbd>memory_requirements.size</kbd> variable for <kbd>allocationSize</kbd></li>
<li><kbd>type</kbd> variable for <kbd>memoryTypeIndex</kbd></li>
</ul>
</li>
<li>Call <kbd>vkAllocateMemory( logical_device, &amp;buffer_memory_allocate_info, nullptr, &amp;memory_object )</kbd>, for which provide the handle of the logical device, a pointer to the <kbd>buffer_memory_allocate_info</kbd> variable, a <kbd>nullptr</kbd> value, and a pointer to the <kbd>memory_object</kbd> variable.</li>
<li>Make sure the call was successful by checking if the value returned by the call was equal to <kbd>VK_SUCCESS</kbd>, and stop iterating the loop.</li>
</ol>
</li>
<li>Make sure that memory object allocation inside the loop was successful by checking whether the <kbd>memory_object</kbd> variable is not equal to <kbd>VK_NULL_HANDLE</kbd>.</li>
<li>Bind the memory object to the buffer by calling <kbd>vkBindBufferMemory( logical_device, buffer, memory_object, 0 )</kbd>, for which provide the <kbd>logical_device</kbd>, <kbd>buffer</kbd>, and <kbd>memory_object</kbd> variables and a <kbd>0</kbd> value.</li>
<li>Make sure the call was successful and the returned value was equal to <kbd>VK_SUCCESS</kbd>.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>To allocate a memory object for a buffer (or memory object in general), we need to know what memory types are available on a given physical device, and how many of them there are. This is done by calling the <kbd>vkGetPhysicalDeviceMemoryProperties()</kbd> function, like this:</p>
<pre>
VkPhysicalDeviceMemoryProperties physical_device_memory_properties; 
vkGetPhysicalDeviceMemoryProperties( physical_device, &amp;physical_device_memory_properties );
</pre>
<p>Next, we need to know how much storage a given buffer requires (the buffer's memory may need to be bigger than the buffer's size) and what memory type is compatible with it. All this is stored in a variable of type <kbd>VkMemoryRequirements</kbd>:</p>
<pre>
VkMemoryRequirements memory_requirements; 
vkGetBufferMemoryRequirements( logical_device, buffer, &amp;memory_requirements );
</pre>
<p>Next, we need to check which memory type corresponds to the buffer's memory requirements:</p>
<pre>
memory_object = VK_NULL_HANDLE; 
for( uint32_t type = 0; type &lt; physical_device_memory_properties.memoryTypeCount; ++type ) { 
  if( (memory_requirements.memoryTypeBits &amp; (1 &lt;&lt; type)) &amp;&amp; 
      ((physical_device_memory_properties.memoryTypes[type].propertyFlags &amp; memory_properties) == memory_properties) ) { 

    VkMemoryAllocateInfo buffer_memory_allocate_info = { 
      VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, 
      nullptr, 
      memory_requirements.size, 
      type 
    }; 

    VkResult result = vkAllocateMemory( logical_device, &amp;buffer_memory_allocate_info, nullptr, &amp;memory_object ); 
    if( VK_SUCCESS == result ) { 
      break; 
    } 
  } 
}
</pre>
<p>Here, we iterate over all available memory types and check whether a given type can be used for our buffer. We can also request some additional memory properties that need to be fulfilled. For example, if we want to upload data directly from our application (from the CPU), memory mapping must be supported. In this case, we need to use a memory type that is <strong>host-visible</strong>.</p>
<p>When we have found a proper memory type, we can use it to allocate a memory object and we can stop the loop. After that, we make sure that the memory was allocated properly (if we didn't leave the loop without allocating the object) and next, we bind it to our buffer:</p>
<pre>
if( VK_NULL_HANDLE == memory_object ) { 
  std::cout &lt;&lt; "Could not allocate memory for a buffer." &lt;&lt; std::endl; 
  return false; 
} 

VkResult result = vkBindBufferMemory( logical_device, buffer, memory_object, 0 ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Could not bind memory object to a buffer." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>
<p>During binding, we specify a memory offset, among other parameters. This allows us to bind a part of the memory that's not at the beginning of the memory object. We can (and should) use the <kbd>offset</kbd> parameter to bind multiple, separate parts of a memory object to multiple buffers.</p>
<p>From now on, the buffer can be used in our application.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>This recipe shows how to allocate and bind a memory object to a buffer. But in general, we shouldn't use a separate memory object for each buffer. We should allocate bigger memory objects and use parts of them for multiple buffers.</p>
<p>In this recipe, we also acquired the parameters of a physical device's available memory types by calling a <kbd>vkGetPhysicalDeviceMemoryProperties()</kbd> function. But in general, to improve the performance of our application, we don't need to call it every time we want to allocate a memory object. We can call this function only once, after we choose a physical device that will be used for a logical device (refer to the <em>Creating a logical device</em> recipe from <a href="d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Instance and Devices</em>) and use the variable in which the parameters were stored.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a buffer</em></li>
<li><em>Setting a buffer memory barrier</em></li>
<li><em>Mapping, updating, and unmapping host-visible memory</em></li>
<li><em>Using a staging buffer to update a buffer with a device-local memory bound</em></li>
<li><em>Freeing a memory object</em></li>
<li><em>Destroying a buffer</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Setting a buffer memory barrier</h1>
            </header>

            <article>
                
<p>Buffers can be used for various purposes. For each buffer, we can upload data to it or copy data from it; we can bind a buffer to a pipeline via descriptor sets and use it inside shaders as a source of data, or we can store data in the buffer from within the shaders.</p>
<p>We must inform a driver about each such usage, not only during buffer creation, but also before the intended usage. When we have been using a buffer for one purpose and from now on we want to use it differently, we must tell the driver about a change in the buffer's usage. This is done through buffer memory barriers. They are set as part of the pipeline barriers during command buffer recording (refer to the <em>Beginning a command buffer recording operation</em> recipe from <a href="fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Command Buffers and Synchronization</em>).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>For the purpose of this recipe, we will use a custom structure type named <kbd>BufferTransition</kbd> with the following definition:</p>
<pre>
struct BufferTransition { 
    VkBuffer        Buffer; 
    VkAccessFlags   CurrentAccess; 
    VkAccessFlags   NewAccess; 
    uint32_t        CurrentQueueFamily; 
    uint32_t        NewQueueFamily; 
  };
</pre>
<p>Through this structure, we will define the parameters we want to use for the buffer memory barrier. In <kbd>CurrentAccess</kbd> and <kbd>NewAccess</kbd>, we store information about how the buffer has been used so far and how it will be used from now on, respectively (in this case, usage is defined as types of memory operations that will involve a given buffer). The <kbd>CurrentQueueFamily</kbd> and <kbd>NewQueueFamily</kbd> members are used when we want to transfer ownership from queues from one family to another. We need to do this when we have specified <strong>exclusive sharing mode</strong> during buffer creation.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol start="1">
<li>Prepare parameters for each buffer you want to set up a barrier for. Store them in a vector of type <kbd>std::vector&lt;BufferTransition&gt;</kbd> named <kbd>buffer_transitions</kbd>. For each buffer, store the following parameters:
<ol>
<li>Buffer's handle in the <kbd>Buffer</kbd> member</li>
<li>Type of memory operations that have involved the buffer so far in the <kbd>CurrentAccess</kbd> member</li>
<li>Type of memory operations that will be performed on the buffer from now on (after the barrier) in the <kbd>NewAccess</kbd> member</li>
<li>Index of a queue family that has been referencing the buffer so far (or a <kbd>VK_QUEUE_FAMILY_IGNORED</kbd> value if we don't want to transfer queue ownership) in the <kbd>CurrentQueueFamily</kbd> member</li>
<li>Index of a queue family that will be referencing the buffer from now on (or a <kbd>VK_QUEUE_FAMILY_IGNORED</kbd> value if we don't want to transfer queue ownership) in the <kbd>NewQueueFamily</kbd> member</li>
</ol>
</li>
<li>Create a vector variable of type <kbd>std::vector&lt;VkBufferMemoryBarrier&gt;</kbd> named <kbd>buffer_memory_barriers</kbd>.</li>
<li>For each element of the <kbd>buffer_transitions</kbd> variable, add a new element to the <kbd>buffer_memory_barriers</kbd> vector. Use the following values for members of the new element:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER</kbd> value for <kbd>sType</kbd> member</li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li><kbd>CurrentAccess</kbd> value of the current element for <kbd>srcAccessMask</kbd></li>
<li><kbd>NewAccess</kbd> value of the current element for <kbd>dstAccessMask</kbd></li>
<li><kbd>CurrentQueueFamily</kbd> value of the current element for <kbd>srcQueueFamilyIndex</kbd></li>
<li><kbd>NewQueueFamily</kbd> value of the current element for <kbd>dstQueueFamilyIndex</kbd></li>
<li>Buffer's handle for <kbd>buffer</kbd></li>
<li><kbd>0</kbd> value for <kbd>offset</kbd></li>
<li><kbd>VK_WHOLE_SIZE</kbd> value for <kbd>size</kbd></li>
</ul>
</li>
</ol>
<ol start="4">
<li>Take the handle of the command buffer and store it in a variable of type <kbd>VkCommandBuffer</kbd> named <kbd>command_buffer</kbd>.</li>
<li>Make sure the command buffer represented by the <kbd>command_buffer</kbd> handle is in the recording state (that the recording operation was started for the command buffer).</li>
<li>Create a variable of a bit field type <kbd>VkPipelineStageFlags</kbd> named <kbd>generating_stages</kbd>. In this variable, store values representing pipeline stages that have been using the buffer so far.</li>
<li>Create a variable of a bit field type <kbd>VkPipelineStageFlags</kbd> named <kbd>consuming_stages</kbd>. In this variable, store values representing pipeline stages in which the buffer will be used after the barrier.</li>
<li>Call <kbd>vkCmdPipelineBarrier( command_buffer, generating_stages, consuming_stages, 0, 0, nullptr, static_cast&lt;uint32_t&gt;(buffer_memory_barriers.size()), &amp;buffer_memory_barriers[0], 0, nullptr )</kbd>, and provide the handle of the command buffer in the first parameter, and <kbd>generating_stages</kbd> and <kbd>consuming_stages</kbd> variables in the second and third parameters respectively. The number of elements of the <kbd>buffer_memory_barriers</kbd> vector should be provided in the seventh parameter, and the eighth parameter should point to the first element of the <kbd>buffer_memory_barriers</kbd> vector.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>In Vulkan, operations that are submitted to queues are executed in order, but they are independent. Sometimes, it is possible for some operations to start before the previous operations have finished. This parallel execution is one of the most important performance factors of current graphics hardware. But sometimes, it is crucial that some operations should wait for the results of earlier operations: this is when memory barriers come in handy.</p>
<div class="packt_tip">Memory barriers are used to define moments in command buffers' executions, in which later commands should wait for the earlier commands to finish their job. They also cause the results of these operations to become visible for other operations.</div>
<p>In the case of buffers, through memory barriers, we specify how the buffer was used and which pipeline stages were using it up to the moment in which we placed a barrier. Next we need to define which pipeline stages will be using it and how, after the barrier. With this information, the driver can pause operations that need to wait for the results of earlier operations to become available, but execute operations that won't reference the buffer at all.</p>
<p>Buffers can be used only for purposes defined during creation. Each such usage corresponds with the type of memory operation through which the buffer's contents can be accessed. Here is a list of supported memory access types:</p>
<ul>
<li><kbd>VK_ACCESS_INDIRECT_COMMAND_READ_BIT</kbd> is used when the buffer's contents are a source of data for indirect drawing</li>
<li><kbd>VK_ACCESS_INDEX_READ_BIT</kbd> indicates the buffer's contents are used for indices during drawing operations</li>
<li><kbd>VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT</kbd> specifies that the buffer is a source of vertex attributes that are read during drawing</li>
<li><kbd>VK_ACCESS_UNIFORM_READ_BIT</kbd> is used when the buffer will be accessed through shaders as an uniform buffer</li>
<li><kbd>VK_ACCESS_SHADER_READ_BIT</kbd> indicates that the buffer can be read inside shaders (but not as a uniform buffer)</li>
<li><kbd>VK_ACCESS_SHADER_WRITE_BIT</kbd> specifies that shaders will write data to the buffer</li>
<li><kbd>VK_ACCESS_TRANSFER_READ_BIT</kbd> is used when we want to copy data from the buffer</li>
<li><kbd>VK_ACCESS_TRANSFER_WRITE_BIT</kbd> is used when we want to copy data to the buffer</li>
<li><kbd>VK_ACCESS_HOST_READ_BIT</kbd> specifies that the application will read the buffer's contents (via memory mapping)</li>
<li><kbd>VK_ACCESS_HOST_WRITE_BIT</kbd> is used when the application will write data to the buffer (via memory mapping)</li>
<li><kbd>VK_ACCESS_MEMORY_READ_BIT</kbd> is used when the buffer's memory will be read in any other way not specified above</li>
<li><kbd>VK_ACCESS_MEMORY_WRITE_BIT</kbd> is used when the buffer's memory will be written through any other way not described above</li>
</ul>
<p>Barriers are needed for memory operations to become visible for later commands. Without them, commands that read the buffer's contents may start reading them before the contents were even properly written by the previous operations. But, such a break in the command buffer's execution causes stalls in the graphics hardware's processing pipeline. And this, unfortunately, may impact the performance of our application:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_04_002.png"/></div>
<div class="packt_tip">We should aggregate usage and ownership transitions for as many buffers as possible in as few barriers as possible.</div>
<p>To set up a memory barrier for a buffer, we need to prepare a variable of type <kbd>VkBufferMemoryBarrier</kbd>. If possible, we should aggregate data for multiple buffers in one memory barrier. That's why a vector with elements of type <kbd>VkBufferMemoryBarrier</kbd> seems very useful for this reason, and can be filled like this:</p>
<pre>
std::vector&lt;VkBufferMemoryBarrier&gt; buffer_memory_barriers; 

for( auto &amp; buffer_transition : buffer_transitions ) { 
  buffer_memory_barriers.push_back( { 
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER, 
    nullptr, 
    buffer_transition.CurrentAccess, 
    buffer_transition.NewAccess, 
    buffer_transition.CurrentQueueFamily, 
    buffer_transition.NewQueueFamily, 
    buffer_transition.Buffer, 
    0, 
    VK_WHOLE_SIZE 
  } ); 
}
</pre>
<p>Next, we set up a memory barrier in the command buffer. This is done during the command buffer's recording operation:</p>
<pre>
if( buffer_memory_barriers.size() &gt; 0 ) { 
  vkCmdPipelineBarrier( command_buffer, generating_stages, consuming_stages, 0, 0, nullptr, static_cast&lt;uint32_t&gt;(buffer_memory_barriers.size()), &amp;buffer_memory_barriers[0], 0, nullptr ); 
}
</pre>
<p>In the barrier we specify which pipeline stages of the commands, executed after the barrier, should wait for the results of which pipeline stages of commands executed before the barrier.</p>
<p>Remember that we need to set a barrier only when the usage is changed. We don't need to do it if the buffer is used for the same purpose multiple times. Imagine a situation in which we want to copy data to a buffer two times, from two different resources. First, we need to set one barrier that will inform the driver that we will perform operations involving memory access of a <kbd>VK_ACCESS_TRANSFER_WRITE_BIT</kbd> type. After that, we can copy data to the buffer as many times as we want. Next, if we want to use a buffer, for example, as a vertex buffer (source of vertex attributes during rendering), we need to set another barrier indicating that we will read vertex attribute data from the buffer--these operations are represented by a <kbd>VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT</kbd> memory access. When we are done drawing and a buffer will be used for yet another purpose, even if once again we want to copy data to the buffer, we yet again need to set a memory barrier with proper parameters.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>We don't need to set up a barrier for the whole buffer. We can do it only for part of the buffer's memory. To do this, we just need to specify proper values for the <kbd>offset</kbd> and <kbd>size</kbd> members of a variable of type <kbd>VkBufferMemoryBarrier</kbd>, defined for a given buffer. Through these members, we define where the contents of the memory start, and what the size of the memory is for which we want to define a barrier. These values are specified in machine units (bytes).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Beginning a command buffer recording operation</em></li>
<li><em>Creating a buffer</em></li>
<li><em>Allocating and binding a memory object to a buffer</em></li>
<li><em>Setting an image memory barrier</em></li>
<li><em>Using a staging buffer to update a buffer with a device-local memory bound</em></li>
<li><em>Using a staging buffer to update an image with a device-local memory bound</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a buffer view</h1>
            </header>

            <article>
                
<p>When we want to use a given buffer as a uniform texel buffer or as a storage texel buffer, we need to create a buffer view for it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol start="1">
<li>Take the handle of a logical device from which a given buffer was created. Store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Take the handle of a created buffer and store it in a variable of type <kbd>VkBuffer</kbd> named <kbd>buffer</kbd>.</li>
<li>Choose a format for a buffer view (how the buffer's contents should be interpreted) and use it to initialize a variable of type <kbd>VkFormat</kbd> named <kbd>format</kbd>.</li>
<li>Select the part of a buffer's memory for which a view should be created. Set the starting point of this memory (offset from the beginning of the buffer's memory) in a variable of type <kbd>VkDeviceSize</kbd> named <kbd>memory_offset</kbd>. Define the size of this memory through a variable of type <kbd>VkDeviceSize</kbd> named <kbd>memory_range</kbd>.</li>
<li>Create a variable of type <kbd>VkBufferViewCreateInfo</kbd> named <kbd>buffer_view_create_info</kbd>. Use the following values to initialize its members:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li><kbd>0</kbd> value for <kbd>flags</kbd></li>
<li><kbd>buffer</kbd> variable for <kbd>buffer</kbd></li>
<li><kbd>format</kbd> variable for <kbd>format</kbd></li>
<li><kbd>memory_offset</kbd> variable for <kbd>offset</kbd></li>
<li><kbd>memory_range</kbd> variable for <kbd>range</kbd></li>
</ul>
</li>
</ol>
<ol start="6">
<li>Create a variable of type <kbd>VkBufferView</kbd> named <kbd>buffer_view</kbd>. It will be used to store the handle of a created buffer view.</li>
<li>Call <kbd>vkCreateBufferView( logical_device, &amp;buffer_view_create_info, nullptr, &amp;buffer_view )</kbd>, for which provide the handle of the logical device in the first parameter, a pointer to the <kbd>buffer_view_create_info</kbd> variable in the second parameter, a <kbd>nullptr</kbd> value as the third parameter, and a pointer to the <kbd>buffer_view</kbd> variable in the last parameter.</li>
<li>Make sure the call was successful by checking whether the value returned by the call was equal to <kbd>VK_SUCCESS</kbd>.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>To create a buffer view, the most important things we need to think about are the view's format and the memory parts for which the view will be created. This way, inside shaders, a buffer's contents can be interpreted similarly to images (textures). We define these parameters as follows:</p>
<pre>
VkBufferViewCreateInfo buffer_view_create_info = { 
  VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO, 
  nullptr, 
  0, 
  buffer, 
  format, 
  memory_offset, 
  memory_range 
};
</pre>
<p>Next, we create the buffer itself using the specified parameters:</p>
<pre>
VkResult result = vkCreateBufferView( logical_device, &amp;buffer_view_create_info, nullptr, &amp;buffer_view ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Could not creat buffer view." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a buffer</em></li>
<li><em>Allocating and binding a memory object to a buffer</em></li>
<li><em>Destroying an image view</em></li>
</ul>
<p>In <a href="fe2cb528-9d22-49db-a05b-372bce2f87ee.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Descriptor Sets</em>, see the following recipes:</p>
<ul>
<li><em>Creating a descriptor set layout</em></li>
<li><em>Updating descriptor sets</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating an image</h1>
            </header>

            <article>
                
<p>Images represent data that can have one, two, or three dimensions, and can have additional mipmap levels and layers. Each element of an image's data (a texel) can also have one or more samples.</p>
<p>Images can be used for many different purposes. We can use them as a source of data for copy operations. We can bind images to pipelines via descriptor sets and use them as textures (similarly to OpenGL). We can render into images, in which case we use images as color or depth attachments (render targets).</p>
<p>We specify image parameters such as size, format, and its intended usages during image creation.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a logical device on which we want to create an image. Store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Choose an image type (if an image should have one, two, or three dimensions) and use a proper value to initialize a variable of type <kbd>VkImageType</kbd> named <kbd>type</kbd>.</li>
<li>Select the image's format--the number of components and number of bits each image's element should contain. Store the format in a variable of type <kbd>VkFormat</kbd> named <kbd>format</kbd>.</li>
<li>Select the image's size (dimensions) and use it to initialize a variable of type <kbd>VkExtent3D</kbd> named <kbd>size</kbd>.</li>
</ol>
<ol start="5">
<li>Choose the number of mipmap levels that should be defined for the image. Store the number of mipmap levels in a variable of type <kbd>uint32_t</kbd> named <kbd>num_mipmaps</kbd>.</li>
<li>Choose the number of layers that should be defined for the image and store it in a variable of type <kbd>uint32_t</kbd> named <kbd>num_layers</kbd>. If an image will be used as a cubemap, the number of layers must be a multiple of six.</li>
<li>Create a variable of type <kbd>VkSampleCountFlagBits</kbd> named <kbd>samples</kbd>, and initialize it with a value representing the number of samples.</li>
<li>Select the intended image usages. Define them in a variable of type <kbd>VkImageUsageFlags</kbd> named <kbd>usage_scenarios</kbd>.</li>
<li>Create a variable of type <kbd>VkImageCreateInfo</kbd> named <kbd>image_create_info</kbd>. Use the following values for its members:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li>For <kbd>flags</kbd>, use the <kbd>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</kbd> value if the image should be used as a cubemap, otherwise use a <kbd>0</kbd> value</li>
<li><kbd>type</kbd> variable for <kbd>imageType</kbd></li>
<li><kbd>format</kbd> variable for <kbd>format</kbd></li>
<li><kbd>size</kbd> variable for <kbd>extent</kbd></li>
<li><kbd>num_mipmaps</kbd> variable for <kbd>mipLevels</kbd></li>
<li><kbd>num_layers</kbd> variable for <kbd>arrayLayers</kbd></li>
<li><kbd>samples</kbd> variable for <kbd>samples</kbd></li>
<li><kbd>VK_IMAGE_TILING_OPTIMAL</kbd> value for <kbd>tiling</kbd></li>
<li><kbd>usage_scenarios</kbd> variable for <kbd>usage</kbd></li>
<li><kbd>VK_SHARING_MODE_EXCLUSIVE</kbd> value for <kbd>sharingMode</kbd></li>
<li><kbd>0</kbd> value for <kbd>queueFamilyIndexCount</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pQueueFamilyIndices</kbd></li>
<li><kbd>VK_IMAGE_LAYOUT_UNDEFINED</kbd> value for <kbd>initialLayout</kbd></li>
</ul>
</li>
<li>Create a variable of type <kbd>VkImage</kbd> named <kbd>image</kbd>. In it, a handle of a created image will be stored.</li>
<li>Call <kbd>vkCreateImage( logical_device, &amp;image_create_info, nullptr, &amp;image )</kbd>, for which provide the handle of the logical device, a pointer to the <kbd>image_create_info</kbd> variable, a <kbd>nullptr</kbd> value, and a pointer to the <kbd>image</kbd> variable.</li>
<li>Make sure the value return by the <kbd>vkCreateImage()</kbd> call was equal to <kbd>VK_SUCCESS</kbd>.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>When we want to create an image, we need to prepare multiple parameters: the image's type, dimensions (size), number of components, and the number of bits for each component (format). We also need to know whether the image will contain mipmaps or whether it will have multiple layers (a normal image must contain at least one, and a cubemap image must contain at least six). We should also think about the intended usage scenarios, which are also defined during image creation. We can't use an image in a way that wasn't defined during its creation.</p>
<div class="packt_tip">Images can only be used for purposes (usages) specified during their creation.</div>
<p>Here is a list of purposes for which images can be used:</p>
<ul>
<li><kbd>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</kbd> specifies that the image can be used as a source of data for copy operations</li>
<li><kbd>VK_IMAGE_USAGE_TRANSFER_DST_BIT</kbd> specifies that we can copy data to the image</li>
<li><kbd>VK_IMAGE_USAGE_SAMPLED_BIT</kbd> indicates that we can sample data from the image inside shaders</li>
<li><kbd>VK_IMAGE_USAGE_STORAGE_BIT</kbd> specifies that the image can be used as a storage image inside shaders</li>
<li><kbd>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</kbd> specifies that we can render into an image (use it as a color render target/attachment in a framebuffer)</li>
<li><kbd>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</kbd> indicates that the image can be used as a depth and/or stencil buffer (as a depth render target/attachment in a framebuffer)</li>
<li><kbd>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</kbd> indicates that the memory bound to the image will be allocated lazily (on demand)</li>
<li><kbd>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT</kbd> specifies that the image can be used as an input attachment inside shaders</li>
</ul>
<p>Different usage scenarios require different image layouts to be used. These are changed (transitioned) using image memory barriers. But during creation, we can specify only <kbd>VK_IMAGE_LAYOUT_UNDEFINED</kbd> (if we don't care about the initial contents) or <kbd>VK_IMAGE_LAYOUT_PREINITIALIZED</kbd> (if we want to upload data by mapping the <strong>host-visible</strong> memory), and we always need to transition to another layout before the actual use.</p>
<p>All the image parameters are specified through a variable of type <kbd>VkImageCreateInfo</kbd>, like this:</p>
<pre>
VkImageCreateInfo image_create_info = { 
  VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, 
  nullptr, 
  cubemap ? VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT : 0u, 
  type, 
  format, 
  size, 
  num_mipmaps, 
  cubemap ? 6 * num_layers : num_layers, 
  samples, 
  VK_IMAGE_TILING_OPTIMAL, 
  usage_scenarios, 
  VK_SHARING_MODE_EXCLUSIVE, 
  0, 
  nullptr, 
  VK_IMAGE_LAYOUT_UNDEFINED 
};
</pre>
<p>When we create an image, we also need to specify the tiling. It defines the image's memory structure. There are two available types of image tiling: linear and optimal.</p>
<p>When using <strong>linear tiling</strong>, as the name suggests, an image's data is laid out in memory linearly, similarly to buffers or C/C++ arrays. This allows us to map an image's memory and read it or initialize it directly from our application, because we know how the memory is organized. Unfortunately, it restricts us from using an image for many purposes; for example, we can't use an image as a depth texture or as a cubemap (some drivers may support it, but it is not required by the specification and, in general, we shouldn't rely on it). Linear tiling can also lower the performance of our application.</p>
<div class="packt_tip">For the best performance, it is recommended to create images with optimal tiling.</div>
<p>Images with <strong>optimal tiling</strong> can be used for all purposes; they also have much better performance. But this comes with a trade-off--we don't know how the image's memory is organized. In the following diagram we can see an example of image's data and it's internal structure:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1677 image-border" height="197" src="assets/image_04_03-1.png" width="459"/></div>
<p>Each type of graphics hardware can store image data in a different way that is optimal for it. Because of that, we can't map an image's memory and initialize or read it directly from our application. In this situation, we are required to use <strong>staging resources</strong>.<br/>
When we are ready, we can create an image with the following code:</p>
<pre>
VkResult result = vkCreateImage( logical_device, &amp;image_create_info, nullptr, &amp;image ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Could not create an image." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Allocating and binding a memory object to an image</em></li>
<li><em>Setting an image memory barrier</em></li>
<li><em>Creating an image view</em></li>
<li><em>Creating a 2D image and view</em></li>
<li><em>Using a staging buffer to update an image with a device-local memory bound</em></li>
<li><em>Destroying an image</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Allocating and binding a memory object to an image</h1>
            </header>

            <article>
                
<p>Images, similarly to buffers, are not created with a bound memory storage. We need to implicitly create a memory object and bind it to the image. We can also use an existing memory object for this purpose.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a physical device from which a <span class="KeyPACKT">logical device</span> was created. Store it in a variable of type <kbd>VkPhysicalDevice</kbd> named <kbd>physical_device</kbd>.</li>
<li>Create a variable of type <kbd>VkPhysicalDeviceMemoryProperties</kbd> named <kbd>physical_device_memory_properties</kbd>.</li>
<li>Call <kbd>vkGetPhysicalDeviceMemoryProperties( physical_device, &amp;physical_device_memory_properties )</kbd>, for which provide the handle of the physical device and a pointer to the <kbd>physical_device_memory_properties</kbd> variable. This call will store memory parameters (number of heaps, their size, and types) of the physical device used for processing submitted operations.</li>
<li>Take the handle of a <span class="KeyPACKT">logical device</span> created from the physical device, represented by the <kbd>physical_device</kbd> variable. Store the handle in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Take the handle of a created image represented by a variable of type <kbd>VkImage</kbd> named <kbd>image</kbd>.</li>
<li>Create a variable of type <kbd>VkMemoryRequirements</kbd> named <kbd>memory_requirements</kbd>.</li>
<li>Acquire the parameters of the memory that needs to be used for the image. Do this by calling <kbd>vkGetImageMemoryRequirements( logical_device, image, &amp;memory_requirements )</kbd> and providing the handle of the <span class="KeyPACKT">logical device</span> in the first parameter, the handle of the created image in the second parameter, and a pointer to the <kbd>memory_requirements</kbd> variable in the third parameter.</li>
<li>Create a variable of type <kbd>VkDeviceMemory</kbd> named <kbd>memory_object</kbd>, that will represent the memory object created for the image and assign a <kbd>VK_NULL_HANDLE</kbd> value to it.</li>
</ol>
<ol start="9">
<li>Create a variable of type <kbd>VkMemoryPropertyFlagBits</kbd> named <kbd>memory_properties</kbd>. Store additional (chosen) memory properties in the variable, or a <kbd>0</kbd> value if no additional properties are required.</li>
</ol>
<ol start="10">
<li>Iterate over the available physical device's memory types, represented by the <kbd>memoryTypeCount</kbd> member of a <kbd>physical_device_memory_properties</kbd> variable. Do this by using a variable of type <kbd>uint32_t</kbd> named <kbd>type</kbd>. For each loop iteration:
<ol>
<li>Make sure that the bit on the position, represented by the <kbd>type</kbd> variable in the <kbd>memoryTypeBits</kbd> member of the <kbd>memory_requirements</kbd> variable, is set.</li>
<li>Make sure that the <kbd>memory_properties</kbd> variable has the same bits set as a <kbd>propertyFlags</kbd> member of the memory type <kbd>memoryTypes</kbd>, at index <kbd>type</kbd> in the <kbd>physical_device_memory_properties</kbd> variable.</li>
<li>If points 1 and 2 are not true, continue iterating the loop.</li>
<li>Create a variable of type <kbd>VkMemoryAllocateInfo</kbd> named <kbd>image_memory_allocate_info</kbd> and assign the following values for its members:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li><kbd>memory_requirements.size</kbd> variable for <kbd>allocationSize</kbd></li>
<li><kbd>type</kbd> variable for <kbd>memoryTypeIndex</kbd></li>
</ul>
</li>
<li>Call <kbd>vkAllocateMemory( logical_device, &amp;image_memory_allocate_info, nullptr, &amp;memory_object )</kbd>, for which provide the handle of the <span class="KeyPACKT">logical device</span>, a pointer to the <kbd>image_memory_allocate_info</kbd> variable, a <kbd>nullptr</kbd> value, and a pointer to the <kbd>memory_object</kbd> variable.</li>
<li>Make sure the call was successful by checking whether the value returned by the call was equal to <kbd>VK_SUCCESS</kbd>, and stop iterating the loop.</li>
</ol>
</li>
</ol>
<ol start="11">
<li>Make sure that memory object allocation inside the loop was successful by checking whether the <kbd>memory_object</kbd> variable is not equal to <kbd>VK_NULL_HANDLE</kbd>.</li>
</ol>
<ol start="12">
<li>Bind the memory object to the image by calling <kbd>vkBindImageMemory( logical_device, image, memory_object, 0 )</kbd> , for which provide the <kbd>logical_device</kbd>, <kbd>image</kbd> and <kbd>memory_object</kbd> variables and a <kbd>0</kbd> value.</li>
<li>Make sure the call was successful and the returned value was equal to <kbd>VK_SUCCESS</kbd>.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Similarly to the memory object created for a buffer, we start by checking what memory types are available on a given physical device and what their properties are. We can, of course, omit these steps and gather this information once at the initialization stage of our application:</p>
<pre>
VkPhysicalDeviceMemoryProperties physical_device_memory_properties; 
vkGetPhysicalDeviceMemoryProperties( physical_device, &amp;physical_device_memory_properties );
</pre>
<p>Next, we acquire the specific memory requirements of a given image. These can (and probably will) be different for each image, as they depend on the format, size, number of mipmaps and layers, and other properties of the image:</p>
<pre>
VkMemoryRequirements memory_requirements; 
vkGetImageMemoryRequirements( logical_device, image, &amp;memory_requirements );
</pre>
<p>The next step is to find a memory type that has proper parameters and is compatible with the image's memory requirements:</p>
<pre>
memory_object = VK_NULL_HANDLE; 
for( uint32_t type = 0; type &lt; physical_device_memory_properties.memoryTypeCount; ++type ) { 
  if( (memory_requirements.memoryTypeBits &amp; (1 &lt;&lt; type)) &amp;&amp; 
    ((physical_device_memory_properties.memoryTypes[type].propertyFlags &amp; memory_properties) == memory_properties) ) { 

    VkMemoryAllocateInfo image_memory_allocate_info = { 

      VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,    
      nullptr,                                  
      memory_requirements.size,                
      type                                     
    }; 

    VkResult result = vkAllocateMemory( logical_device, &amp;image_memory_allocate_info, nullptr, &amp;memory_object ); 
    if( VK_SUCCESS == result ) { 
      break; 
    } 
  } 
}
</pre>
<p>Here, we iterate over all available memory types. If a given bit of the <kbd>memoryTypeBits</kbd> member of an image's memory properties is set, this means that a memory type with the same number is compatible with the image and we can use it for the memory object. We can also check for other properties of the memory type and find the one that is suitable for our needs. For example, we may want to use a memory that can be mapped on the CPU (a <strong>host-visible</strong> memory).</p>
<p>Next, we check whether the memory object allocation inside the loop was successful. And if yes, we bind the created memory object with our image:</p>
<pre>
if( VK_NULL_HANDLE == memory_object ) { 
  std::cout &lt;&lt; "Could not allocate memory for an image." &lt;&lt; std::endl; 
  return false; 
} 

VkResult result = vkBindImageMemory( logical_device, image, memory_object, 0 ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Could not bind memory object to an image." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>
<p>From now on, we can use the image for all purposes defined during its creation.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">There's more...</h1>
            </header>

            <article>
                
<p>Similarly to binding memory objects to buffers, we should allocate bigger memory objects and bind parts of them to multiple images. This way, we perform fewer memory allocations and the driver has to track a smaller number of memory objects. This may improve the performance of our application. It may also allow us to save some memory, as each allocation may require more memory than requested during allocation (in other words, its size may always be rounded up to a multiple of the memory page size). Allocating bigger memory objects and reusing parts of them for multiple images spares us the wasted area.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating an image</em></li>
<li><em>Setting an image memory barrier</em></li>
<li><em>Mapping, updating, and unmapping host-visible memory</em></li>
<li><em>Using a staging buffer to update an image with a device-local memory bound</em></li>
<li><em>Destroying an image</em></li>
<li><em>Freeing a memory object</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Setting an image memory barrier</h1>
            </header>

            <article>
                
<p>Images are created for various purposes--they are used as textures, by binding them to a pipeline via descriptor sets, as render targets, or as presentable images in swapchains. We can copy data to or from images--these are also separate usages defined during image creation.</p>
<p>Before we start using an image for any purpose, and every time we want to change the current usage of a given image, we need to inform a driver about this operation. We do this by using image memory barriers which are set during command buffer recording.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting ready</h1>
            </header>

            <article>
                
<p>For the purpose of this recipe, a custom structure type <kbd>ImageTransition</kbd> is introduced. It has the following definition:</p>
<pre>
struct ImageTransition { 
  VkImage             Image; 
  VkAccessFlags       CurrentAccess; 
  VkAccessFlags       NewAccess; 
  VkImageLayout       CurrentLayout; 
  VkImageLayout       NewLayout; 
  uint32_t            CurrentQueueFamily; 
  uint32_t            NewQueueFamily; 
  VkImageAspectFlags  Aspect; 
};
</pre>
<p>The <kbd>CurrentAccess</kbd> and <kbd>NewAccess</kbd> members define types of memory operations that were taking place in regard to a given image before the barrier, and that will occur after the barrier.</p>
<p>In Vulkan, images used for different purposes may have different internal memory organization. In other words, the memory of a given image may have a different <span class="KeyPACKT">layout</span> for different image usages. When we want to start using an image in a different way, we also need to change this memory <span class="KeyPACKT">layout</span>. This is done through the <kbd>CurrentLayout</kbd> and <kbd>NewLayout</kbd> members.</p>
<p>Memory barriers also allow us to transfer <span class="KeyPACKT">queue family</span> ownership if an image was created with an exclusive sharing mode. In the <kbd>CurrentQueueFamily</kbd> member, we define the index of a <span class="KeyPACKT">family</span> from which queues have been using an image so far. In <kbd>NewQueueFamily</kbd>, we need to define a <span class="KeyPACKT">family</span> index for queues that will be using an image after the barrier. We can also use a <kbd>VK_QUEUE_FAMILY_IGNORED</kbd> special value for both when we don't want to transfer an ownership.</p>
<p>The <kbd>Aspect</kbd> member defines the image's usage "context". We can choose from color, depth, or stencil aspects.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Prepare parameters for each image you want to set up a barrier for. Store them in a vector of type <kbd>std::vector&lt;ImageTransition&gt;</kbd> named <kbd>image_transitions</kbd>. For each image, use the following values:
<ul>
<li>Image's handle in an <kbd>Image</kbd> member</li>
<li>Type of memory operations that involved the image so far in the <kbd>CurrentAccess</kbd> member</li>
<li>Type of memory operations that will be performed on the image from now on, after the barrier, in the <kbd>NewAccess</kbd> member</li>
<li>Current image's internal memory <span class="KeyPACKT">layout</span> in <kbd>CurrentLayout</kbd> member</li>
<li><span class="KeyPACKT">Layout</span> image's memory should change into after the barrier in <kbd>NewLayout</kbd> member</li>
<li>Index of a <span class="KeyPACKT">queue family</span> that has been referencing the image so far (or a <kbd>VK_QUEUE_FAMILY_IGNORED</kbd> value if we don't want to transfer queue ownership) in the <kbd>CurrentQueueFamily</kbd> member</li>
<li>Index of a <span class="KeyPACKT">queue family</span> that will be referencing the image from now on (or a <kbd>VK_QUEUE_FAMILY_IGNORED</kbd> value if we don't want to transfer queue ownership) in the <kbd>NewQueueFamily</kbd> member</li>
<li>Image's aspect (color, depth, or stencil) in the <kbd>Aspect</kbd> member</li>
</ul>
</li>
<li>Create a vector variable of type <kbd>std::vector&lt;VkImageMemoryBarrier&gt;</kbd> named <kbd>image_memory_barriers</kbd>.</li>
</ol>
<ol start="3">
<li>For each element of the <kbd>image_transitions</kbd> variable, add a new element to the <kbd>image_memory_barriers</kbd> vector. Use the following values for members of the new element:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER</kbd> value for <kbd>sType</kbd> member.</li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd>.</li>
<li><kbd>CurrentAccess</kbd> value of the current element for <kbd>srcAccessMask</kbd>.</li>
<li><kbd>NewAccess</kbd> value of the current element for <kbd>dstAccessMask</kbd>.</li>
<li><kbd>CurrentLayout</kbd> member of the current element for <kbd>oldLayout</kbd>.</li>
<li><kbd>NewLayout</kbd> value of the current element for <kbd>newLayout</kbd>.</li>
<li><kbd>CurrentQueueFamily</kbd> value of the current element for <kbd>srcQueueFamilyIndex</kbd>.</li>
<li><kbd>NewQueueFamily</kbd> value of the current element for <kbd>dstQueueFamilyIndex</kbd>.</li>
<li>Image's handle for <kbd>image</kbd>.</li>
<li>The following values for the <kbd>subresourceRange</kbd> member of the new element:
<ul>
<li><kbd>Aspect</kbd> member of the current element for <kbd>aspectMask</kbd></li>
<li><kbd>0</kbd> value for <kbd>baseMipLevel</kbd></li>
<li><kbd>VK_REMAINING_MIP_LEVELS</kbd> value for <kbd>levelCount</kbd></li>
<li><kbd>0</kbd> value for <kbd>baseArrayLayer</kbd></li>
<li><kbd>VK_REMAINING_ARRAY_LAYERS</kbd> value for <kbd>layerCount</kbd></li>
</ul>
</li>
</ul>
</li>
<li>Take the handle of the <span class="KeyPACKT">command buffer</span> and store it in a variable of type <kbd>VkCommandBuffer</kbd> named <kbd>command_buffer</kbd>.</li>
<li>Make sure the <span class="KeyPACKT">command buffer</span> represented by the <kbd>command_buffer</kbd> handle is in the recording state (that the recording operation was started for the <span class="KeyPACKT">command buffer</span>).</li>
</ol>
<ol start="6">
<li>Create a variable of a bitfield type <kbd>VkPipelineStageFlags</kbd> named <kbd>generating_stages</kbd>. In this variable, store values representing pipeline stages that have been using the image so far.</li>
<li>Create a variable of a bitfield type <kbd>VkPipelineStageFlags</kbd> named <kbd>consuming_stages</kbd>. In this variable, store values representing <span class="KeyPACKT">pipeline</span> stages in which the image will be referenced after the barrier.</li>
<li>Call <kbd>vkCmdPipelineBarrier( command_buffer, generating_stages, consuming_stages, 0, 0, nullptr, 0, nullptr, static_cast&lt;uint32_t&gt;(image_memory_barriers.size()), &amp;image_memory_barriers[0] )</kbd> and provide the handle of the <span class="KeyPACKT">command buffer</span> in the first parameter, and the <kbd>generating_stages</kbd> and <kbd>consuming_stages</kbd> variables in the second and third parameters respectively. The number of elements of the <kbd>image_memory_barriers</kbd> vector should be provided in the second to last parameter, and the last parameter should point to the first element of the <kbd>image_memory_barriers</kbd> vector.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>In Vulkan, operations are processed in a pipeline. Even though the processing of operations needs to be started in the order in which they were submitted, parts of the pipeline may still be executed concurrently. But sometimes, we may need to synchronize these operations and tell the driver that we want some of them to wait for results of other operations.</p>
<div class="packt_tip">Memory barriers are used to define moments in <span class="KeyPACKT">command buffers</span>' execution, in which later commands should wait for the earlier commands to finish their job. They also cause the results of these operations to become visible for other operations.</div>
<p>Barriers are needed for memory operations to become visible for later commands. In cases where the operations write data to images and further operations will read from them, we need to use image memory barriers. The opposite situation also requires memory barriers to be used--operations that overwrite images' data should wait for earlier operations to stop reading data from them. Failing to do so, in both cases, will make the contents of an image invalid. But such situations should be as rare as possible or our application may suffer from performance loss. This is because such a pause in the <span class="KeyPACKT">command buffer</span>'s execution causes stalls in the graphics hardware's processing pipeline and, as a result, time being wasted:</p>
<div class="packt_tip">To avoid a negative impact on the performance of our application, we should set up parameters for as many images as possible in as few barriers as possible.</div>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/image_04_004.png"/></div>
<p>Image memory barriers are also used to define a change in how images are used. Such a usage change typically also requires us to synchronize submitted operations; that's why this is also done through memory barriers. For the purpose of changing an image's usage, we need to define types of memory operations that were performed on an image before and after the barrier (memory access). We also specify what the memory <span class="KeyPACKT">layout</span> was before the barrier, and how memory should be laid out after the barrier. This is because images may have different memory organization when they are used for different purposes. For example, sampling data from images inside shaders may need them to be cached in such a way that neighbor texels are also neighbors in memory. But, writing data to images may be performed faster when a memory is laid out linearly. That's why image <span class="KeyPACKT">layouts</span> were introduced in Vulkan. Each image usage has its own, designated <span class="KeyPACKT">layout</span>. There is one, general <span class="KeyPACKT">layout</span>, which can be used for all purposes. But, using the general <span class="KeyPACKT">layout</span> is not recommended because it may impact the performance on some hardware platforms.</p>
<div class="packt_tip">For the best performance, it is recommended to use designated image memory <span class="KeyPACKT">layouts</span> for specific usages, though care must be taken if layout transitions are performed too frequently.</div>
<p>Parameters that define usage change are specified through the variables of a <kbd>VkImageMemoryBarrier</kbd> type, like this:</p>
<pre>
std::vector&lt;VkImageMemoryBarrier&gt; image_memory_barriers; 

for( auto &amp; image_transition : image_transitions ) { 
  image_memory_barriers.push_back( { 
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER, 
    nullptr, 
    image_transition.CurrentAccess, 
    image_transition.NewAccess, 
    image_transition.CurrentLayout, 
    image_transition.NewLayout, 
    image_transition.CurrentQueueFamily, 
    image_transition.NewQueueFamily, 
    image_transition.Image, 
    { 
      image_transition.Aspect, 
      0, 
      VK_REMAINING_MIP_LEVELS, 
      0, 
      VK_REMAINING_ARRAY_LAYERS 
    } 
  } ); 
}
</pre>
<p>But for the barrier to work properly, we also need to define <span class="KeyPACKT">pipeline</span> stages in which images have been used so far, and in which images will be used from now on:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="552" src="assets/image_04_005.png" width="397"/></div>
<p>In the preceding diagram, we can see two examples of <span class="KeyPACKT">pipeline</span> barriers. On the left, color is generated by the fragment shader and, after all the fragment tests (depth test, blending), color data is written into the image. This image is then used in the vertex shader of the successive commands. There is a high chance that such a setup will generate stalls in the <span class="KeyPACKT">pipeline</span>.</p>
<p>The example on the right shows another dependency in graphics commands. Here, data is written into a resource in the vertex shader. Such data is then used by the fragment shader of the next command. This time, there is a high probability that all instances of the vertex shader will finish their jobs before the fragment shader of the next command begins executing. That's why it is important to lower the number of <span class="KeyPACKT">pipeline</span> barriers and, if required, to properly set up drawing commands and choose <span class="KeyPACKT">pipeline</span> stages for the barrier. The parameters of the barrier (generating and consuming stages) are aggregated for all images specified in the barrier using the following call:</p>
<pre>
if( image_memory_barriers.size() &gt; 0 ) { 
  vkCmdPipelineBarrier( command_buffer, generating_stages, consuming_stages, 0, 0, nullptr, 0, nullptr, static_cast&lt;uint32_t&gt;(image_memory_barriers.size()), &amp;image_memory_barriers[0] ); 
}
</pre>
<p>If the image is used in the same way multiple times and is not used for other purposes in between, we don't need to set a barrier before the image is actually used. We set it to signal the usage change, not the usage itself.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>In <a href="fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Command Buffers and Synchronization</em>, see the following recipe:</p>
<ul>
<li><em>Beginning a command buffer recording operation</em></li>
</ul>
<p>See the following recipes in this chapter:</p>
<ul>
<li><em>Creating an image</em></li>
<li><em>Allocating and binding a memory object to an image</em></li>
<li><em>Using a staging buffer to update an image with a device-local memory bound</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating an image view</h1>
            </header>

            <article>
                
<p>Images are rarely used directly in Vulkan commands. <span class="KeyPACKT">Framebuffers</span> and shaders (via <span class="KeyPACKT">descriptor sets</span>) access images through <span class="KeyPACKT">image views</span>. <span class="KeyPACKT">Image views</span> define a selected part of an image's memory and specify additional information needed to properly read an image's data. That's why we need to know how to create an <span class="KeyPACKT">image view</span>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a <span class="KeyPACKT">logical device</span> and use it to initialize a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Use the handle of a created image to initialize a variable of type <kbd>VkImage</kbd> named <kbd>image</kbd>.</li>
<li>Create a variable of type <kbd>VkImageViewCreateInfo</kbd> named <kbd>image_view_create_info</kbd>. Use the following values for its members:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li><kbd>0</kbd> value for <kbd>flags</kbd></li>
<li><kbd>image</kbd> variable for <kbd>image</kbd></li>
<li>Type of <span class="KeyPACKT">image view</span> for <kbd>viewType</kbd></li>
<li>Format of an image or other compatible format (if you want to reinterpret it inside the <span class="KeyPACKT">view</span>) for <kbd>format</kbd></li>
<li><kbd>VK_COMPONENT_SWIZZLE_IDENTITY</kbd> value for all members of a <kbd>components</kbd> member</li>
<li>Use the following values for members of a <kbd>subresourceRange</kbd> member:
<ul>
<li>Image's aspect (color, depth, or stencil) for <kbd>aspectMask</kbd></li>
<li><kbd>0</kbd> value for <kbd>baseMipLevel</kbd></li>
<li><kbd>VK_REMAINING_MIP_LEVELS</kbd> value for <kbd>levelCount</kbd></li>
<li><kbd>0</kbd> for <kbd>baseArrayLayer</kbd></li>
<li><kbd>VK_REMAINING_ARRAY_LAYERS</kbd> for <kbd>layerCount</kbd></li>
</ul>
</li>
</ul>
</li>
<li>Create a variable of type <kbd>VkImageView</kbd> named <kbd>image_view</kbd>. We will store a handle of a created <span class="KeyPACKT">image view</span> in it.</li>
<li>Call <kbd>vkCreateImageView( logical_device, &amp;image_view_create_info, nullptr, &amp;image_view )</kbd>, for which provide the handle of the <span class="KeyPACKT">logical device</span>, a pointer to the <kbd>image_view_create_info</kbd> variable, a <kbd>nullptr</kbd> value, and a pointer to the <kbd>image_view</kbd> variable.</li>
<li>Make sure the call was successful by comparing the returned value with the <kbd>VK_SUCCESS</kbd> value.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p><span class="KeyPACKT">Image view</span> defines additional metadata used for accessing the image. Through it, we can specify the parts of an image that should be accessed by the commands. Though this recipe shows how to create an <span class="KeyPACKT">image view</span> for the whole image data, it is possible to specify a smaller range of the resource which should be accessed. For example, when we render into an image inside a <span class="KeyPACKT">render pass</span>, we can specify that only one mipmap level should be updated.</p>
<p><span class="KeyPACKT">Image view</span> also defines how an image's memory should be interpreted. A good example is an image with multiple layers. For it, we can define an <span class="KeyPACKT">image view</span> that interprets the image directly, as a layered image, or we can use <span class="KeyPACKT">image view</span> to create a cubemap from it.</p>
<p>These parameters are specified like this:</p>
<pre>
VkImageViewCreateInfo image_view_create_info = { 
  VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, 
  nullptr, 
  0, 
  image, 
  view_type, 
  format, 
  { 
    VK_COMPONENT_SWIZZLE_IDENTITY, 
    VK_COMPONENT_SWIZZLE_IDENTITY, 
    VK_COMPONENT_SWIZZLE_IDENTITY, 
    VK_COMPONENT_SWIZZLE_IDENTITY 
  }, 
  { 
    aspect, 
    0, 
    VK_REMAINING_MIP_LEVELS, 
    0, 
    VK_REMAINING_ARRAY_LAYERS 
  } 
};
</pre>
<p>The <span class="KeyPACKT">image view</span> creation is performed through a single call of the <kbd>vkCreateImageView()</kbd> function. An example of such a call is shown here:</p>
<pre>
VkResult result = vkCreateImageView( logical_device, &amp;image_view_create_info, nullptr, &amp;image_view ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Could not create an image view." &lt;&lt; std::endl; 
  return false; 
} 
return true;
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating an image</em></li>
<li><em>Creating a 2D image and view</em></li>
<li><em>Destroying an image view</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a 2D image and view</h1>
            </header>

            <article>
                
<p>The most common image type that is used in many popular applications or games is typical 2D textures with four RGBA components and 32 bits per texel. To create such a resource in Vulkan, we need to create a 2D image and a proper <span class="KeyPACKT">image view</span>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take a handle of a <span class="KeyPACKT">logical device</span> and use it to initialize a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Select the data format used in the image and initialize a variable of type <kbd>VkFormat</kbd> named <kbd>format</kbd> with the selected value.</li>
<li>Choose the size of the image. Store it in a variable of type <kbd>VkExtent2D</kbd> named <kbd>size</kbd>.</li>
<li>Choose the number of mipmap levels that should compose the image. Initialize a variable of type <kbd>uint32_t</kbd> named <kbd>num_mipmaps</kbd> with the selected number of mipmaps.</li>
<li>Specify the number of image layers using a variable of type <kbd>uint32_t</kbd> named <kbd>num_layers</kbd>.</li>
<li>Select the number of per texel samples and store it in a variable of type <kbd>VkSampleCountFlagBits</kbd> named <kbd>samples</kbd>.</li>
<li>Think of all the purposes for which the image will be used in the application. Store the value that is a logical sum (<strong>OR</strong>) of all these usages in a variable of type <kbd>VkImageUsageFlags</kbd> named <kbd>usage</kbd>.</li>
<li>Create an image of <kbd>VK_IMAGE_TYPE_2D</kbd> type using the <kbd>logical_device</kbd>, <kbd>format</kbd>, <kbd>size</kbd>, <kbd>num_mipmaps</kbd>, <kbd>num_layers</kbd>, <kbd>samples</kbd>, and <kbd>usage</kbd> variables. Store the handle of the created image in a variable of type <kbd>VkImage</kbd> named <kbd>image</kbd> (refer to the <em>Creating an image</em> recipe).</li>
<li>Take the handle of a physical device from which the <kbd>logical_device</kbd> handle was acquired. Store the physical device's handle in a variable of type <kbd>VkPhysicalDevice</kbd> named <kbd>physical_device</kbd>.</li>
<li>Acquire the memory properties of the <kbd>physical_device</kbd> and use them to allocate a memory object that will be bound to an image represented by the <kbd>image</kbd> variable. Make sure a memory type with a <kbd>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</kbd> property is used. Store the allocated memory object in a variable of type <kbd>VkDeviceMemory</kbd> named <kbd>memory_object</kbd> (refer to the <em>Allocating and binding memory object to an image</em> recipe).</li>
<li>Select the image's aspect used for the <span class="KeyPACKT">image view</span> creation (color or depth and/or stencil) and store it in a variable of type <kbd>VkImageAspectFlags</kbd> named <kbd>aspect</kbd>.</li>
<li>Create an <span class="KeyPACKT">image view</span> of a <kbd>VK_IMAGE_VIEW_TYPE_2D</kbd> type. Use the <kbd>logical_device</kbd>, <kbd>image</kbd>, <kbd>format</kbd>, and <kbd>aspect</kbd> variables during <span class="KeyPACKT">image view</span> creation. Store the created handle in a variable of type <kbd>VkImageView</kbd> named <kbd>image_view</kbd> (refer to the <em>Creating an image view</em> recipe).</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Image creation requires us to perform three general steps:</p>
<ol>
<li>Create an image.</li>
<li>Create a memory object (or use an existing one) and bind it to the image.</li>
<li>Create an <span class="KeyPACKT">image view</span>.</li>
</ol>
<p>For an image typically used as a texture, we need to create an image of the type <kbd>VK_IMAGE_TYPE_2D</kbd> and the format <kbd>VK_FORMAT_R8G8B8A8_UNORM</kbd>, but we can set these parameters as we want. The rest of the image's properties depend on the size of the image (in other words, we are creating a texture from an existing image file and we need to match its dimensions), the type of filtering that should applied to an image (if we want to use mipmapping), the number of samples (if it should be multisampled), and the desired usage scenarios.</p>
<p>Image creation defined in the <em>Creating an image</em> recipe can be simplified to the following code:</p>
<pre>
if( !CreateImage( logical_device, VK_IMAGE_TYPE_2D, format, { size.width, size.height, 1 }, num_mipmaps, num_layers, samples, usage, false, image ) ) { 
  return false; 
}
</pre>
<p>Next, we need to allocate and bind a memory object to the image as described in the <em>Allocating and binding a memory object to an image</em> recipe. For the best performance, the memory object should be allocated on a fast, <strong>device-local</strong> memory like this:</p>
<pre>
if( !AllocateAndBindMemoryObjectToImage( physical_device, logical_device, image, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) { 
  return false; 
}
</pre>
<p>We can of course use an existing memory object if it fulfills the image's memory requirements and has enough storage.</p>
<p>After that, we must create an <span class="KeyPACKT">image view</span>. With it, we can tell the hardware how the image data should be interpreted. We can also use a different (but still compatible) format for an <span class="KeyPACKT">image view</span>. But for many (if not most) purposes, it is not necessary and we will specify the same format that was used for the image. For standard 2D textures, we also use a color aspect for <span class="KeyPACKT">view</span> creation, but for images with depth data (in other words, for images used as depth attachments), depth aspect must be specified. For more details on <span class="KeyPACKT">image view</span> creation, follow the <em>Creating an image view</em> recipe:</p>
<pre>
if( !CreateImageView( logical_device, image, VK_IMAGE_VIEW_TYPE_2D, format, aspect, image_view ) ) { 
  return false; 
}
</pre>
<p>Now, the image is ready to be used in our application. We can upload data from a file to the image and use it as a texture inside shaders (in this case, we also need a sampler and <span class="KeyPACKT">descriptor sets</span>). We can also bind the image's <span class="KeyPACKT">view</span> to a <span class="KeyPACKT">framebuffer</span> and use it as a color attachment (render target).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating an image</em></li>
<li><em>Allocating and binding a memory object to an image</em></li>
<li><em>Creating an image view</em></li>
<li><em>Destroying an image view</em></li>
<li><em>Destroying an image</em></li>
<li><em>Freeing a memory object</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a layered 2D image with a CUBEMAP view</h1>
            </header>

            <article>
                
<p>A quite common example of images used in 3D applications or games are CUBEMAPs, used for simulating an object reflecting its environment. For this purpose, we don't create a CUBEMAP image. We need to create a layered image and through <span class="KeyPACKT">image view</span>, we tell the hardware that it should interpret its layers as six CUBEMAP faces.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take a handle of a <span class="KeyPACKT">logical device</span>. Store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Choose the size of an image and remember it must be square. Save the image's dimensions in a variable of type <kbd>uint32_t</kbd> named <kbd>size</kbd>.</li>
<li>Select the number of the image's mipmap levels. Initialize a variable of type <kbd>uint32_t</kbd> named <kbd>num_mipmaps</kbd> with the chosen number.</li>
<li>Think about all different scenarios in which the image will be used. Store the logical sum (OR) of all these usages in a variable of type <kbd>VkImageUsageFlags</kbd> named <kbd>usage</kbd>.</li>
<li>Create an image of a <kbd>VK_IMAGE_TYPE_2D</kbd> type, a <kbd>VK_FORMAT_R8G8B8A8_UNORM</kbd> format, six layers, and one sample per texel. Use the <kbd>logical_device</kbd>, <kbd>size</kbd>, <kbd>num_mipmaps</kbd>, and <kbd>usage</kbd> variables for the rest of the image parameters. Store the handle of the created image in a variable of type <kbd>VkImage</kbd> named <kbd>image</kbd> (refer to the <em>Creating an image</em> recipe).</li>
<li>Take the handle of the physical device from which the <kbd>logical_device</kbd> handle was acquired. Store it in a variable of type <kbd>VkPhysicalDevice</kbd> named <kbd>physical_device</kbd>.</li>
<li>Acquire the memory properties of a <kbd>physical_device</kbd>. Use them to allocate a memory object using a memory type with a <kbd>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</kbd> property. Store the handle of the allocated memory object in a variable of type <kbd>VkDeviceMemory</kbd> named <kbd>memory_object</kbd>, and bind it to the image (refer to the <em>Allocating and binding a memory object to an image</em> recipe).</li>
</ol>
<ol start="8">
<li>Select the color aspect and store it in a variable of a <kbd>VkImageAspectFlags</kbd><br/>
type named <kbd>aspect</kbd>.</li>
<li>Create an <span class="KeyPACKT">image view</span> of a <kbd>VK_IMAGE_VIEW_TYPE_CUBE</kbd> type and a <kbd>VK_FORMAT_R8G8B8A8_UNORM</kbd> format. Use the <kbd>logical_device</kbd>, <kbd>image</kbd>, and <kbd>aspect</kbd> variables during <span class="KeyPACKT">image view</span> creation. Store the created handle in a variable of type <kbd>VkImageView</kbd> named <kbd>image_view</kbd> (refer to the <em>Creating an image view</em> recipe).</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>The process of creating a CUBEMAP is very similar to creating any other type of images. First, we create the image itself. We just need to remember that the image should have at least six layers that will be interpreted as six CUBEMAP faces. For CUBEMAPs, we also cannot use more than one sample per texel:</p>
<pre>
if( !CreateImage( logical_device, VK_IMAGE_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, { size, size, 1 }, num_mipmaps, 6, VK_SAMPLE_COUNT_1_BIT, usage, true, image ) ) { 
  return false; 
}
</pre>
<p>Next, we allocate and bind a memory object in the same way as for other resources:</p>
<pre>
if( !AllocateAndBindMemoryObjectToImage( physical_device, logical_device, image, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, memory_object ) ) { 
  return false; 
}
</pre>
<p>Finally, we need to create an <span class="KeyPACKT">image view</span>. Through it, we specify a CUBEMAP <span class="KeyPACKT">view</span> type:</p>
<pre>
if( !CreateImageView( logical_device, image, VK_IMAGE_VIEW_TYPE_CUBE, VK_FORMAT_R8G8B8A8_UNORM, aspect, image_view ) ) { 
  return false; 
}
</pre>
<div class="packt_tip">When using a CUBEMAP <span class="KeyPACKT">image view</span>, image layers correspond to faces in the order +X, -X, +Y, -Y, +Z, and -Z.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating an image</em></li>
<li><em>Allocating and binding a memory object to an image</em></li>
<li><em>Creating an image view</em></li>
<li><em>Destroying an image view</em></li>
<li><em>Destroying an image</em></li>
<li><em>Freeing a memory object</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Mapping, updating and unmapping host-visible memory</h1>
            </header>

            <article>
                
<p>For images and buffers that are used during rendering, it is recommended to bind a memory that is located on the graphics hardware (<strong>device-local</strong> memory). This gives us the best performance. But we can't access such memory directly, and we need to use intermediate (staging) resources which mediate the data transfer between a GPU (device) and a CPU (host).</p>
<p><strong>Staging resources</strong>, on the other hand, need to use memory that is <strong>host-visible</strong>. To upload data to such memory, or to read data from it, we need to map it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a created <span class="KeyPACKT">logical device</span> and store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Select a memory object that was allocated on a memory type with a <kbd>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</kbd> property. Store the memory object's handle in a variable of type <kbd>VkDeviceMemory</kbd> named <kbd>memory_object</kbd>.</li>
<li>Choose a memory region that should be mapped and updated. Store the offset (in bytes) from the beginning of a memory object's memory in a variable of type <kbd>VkDeviceSize</kbd> named <kbd>offset</kbd>.</li>
</ol>
<ol start="4">
<li>Select the size of data to be copied to the selected region of the memory object. Represent the data size with a variable of type <kbd>VkDeviceSize</kbd> named <kbd>data_size</kbd>.</li>
<li>Prepare data that should be copied to the memory object. Set up a pointer to the beginning of the data and use it to initialize a variable of type <kbd>void*</kbd> named <kbd>data</kbd>.</li>
<li>Create a variable of type <kbd>void*</kbd> named <kbd>pointer</kbd>. It will contain a pointer to the mapped memory range.</li>
<li>Map the memory with a <kbd>vkMapMemory( logical_device, memory_object, offset, data_size, 0, &amp;local_pointer )</kbd> call. Provide handles of the <span class="KeyPACKT">logical device</span> and the memory object, offset from the start of the memory and the size (in bytes) of the region we want to map, a <kbd>0</kbd> value, and a pointer to the <kbd>pointer</kbd> variable.</li>
<li>Make sure the call was successful by checking whether the returned value was equal to <kbd>VK_SUCCESS</kbd>.</li>
<li>Copy the prepared data to the memory pointed to by the <kbd>pointer</kbd> variable. It can be done with the following call: <kbd>std::memcpy( local_pointer, data, data_size )</kbd>.</li>
<li>Create a variable of type <kbd>std::vector&lt;VkMappedMemoryRange&gt;</kbd> named <kbd>memory_ranges</kbd>. For each modified range, add an element to the vector and use the following values to initialize its members:
<ul>
<li><kbd>VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE</kbd> value for <kbd>sType</kbd></li>
<li><kbd>nullptr</kbd> value for <kbd>pNext</kbd></li>
<li><kbd>memory_object</kbd> variable for <kbd>memory</kbd></li>
<li>Offset of each range for <kbd>offset</kbd></li>
<li>Size of each range for <kbd>size</kbd></li>
</ul>
</li>
</ol>
<ol start="5">
<li>Inform the driver which parts of the memory have changed. Do this by making the <kbd>vkFlushMappedMemoryRanges( logical_device, static_cast&lt;uint32_t&gt;(memory_ranges.size()), &amp;memory_ranges[0] )</kbd> call, for which provide the <kbd>logical_device</kbd> variable, the number of modified ranges (elements in the <kbd>memory_ranges</kbd> vector), and a pointer to the first element of the <kbd>memory_ranges</kbd> vector.</li>
<li>Make sure the flushing was successful and the call returned a <kbd>VK_SUCCESS</kbd> value.</li>
<li>To unmap the memory, call <kbd>vkUnmapMemory( logical_device, memory_object )</kbd>.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Mapping the memory is the simplest way to upload data to the Vulkan resources. During the mapping, we specify which part of the memory should be mapped (offset from the beginning of the memory object and a size of the mapped range):</p>
<pre>
VkResult result; 
void * local_pointer; 
result = vkMapMemory( logical_device, memory_object, offset, data_size, 0, &amp;local_pointer );  
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Could not map memory object." &lt;&lt; std::endl; 
  return false; 
}
</pre>
<p>Mapping gives us a pointer to the requested memory part. We can use this pointer like we use other pointers in typical C++ applications. There are no restrictions on whether we write or read data from such memory. In this recipe, we copy data from the application to the memory object:</p>
<pre>
std::memcpy( local_pointer, data, data_size );
</pre>
<p>When we update the mapped memory range, we need to inform the driver that memory contents were modified or the uploaded data may not immediately become visible for other operations submitted to queues. Informing about the memory data modifications performed by the CPU (host) is called flushing. For this, we prepare a list of updated memory ranges which don't need to cover the whole mapped memory:</p>
<pre>
std::vector&lt;VkMappedMemoryRange&gt; memory_ranges = { 
  { 
  VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE, 
  nullptr, 
  memory_object, 
  offset, 
  data_size 
  } 
}; 

vkFlushMappedMemoryRanges( logical_device, static_cast&lt;uint32_t&gt;(memory_ranges.size()), &amp;memory_ranges[0] ); 
if( VK_SUCCESS != result ) { 
  std::cout &lt;&lt; "Could not flush mapped memory." &lt;&lt; std::endl; 
  return false; 
}
</pre>
<p>After we are done dealing with a mapped memory, we can unmap it. Memory mapping shouldn't influence the performance of our application and we can keep the acquired pointer for the whole lifetime of our application. But, we should release it (unmap) before we close the application and destroy all resources:</p>
<pre>
if( unmap ) { 
  vkUnmapMemory( logical_device, memory_object ); 
} else if( nullptr != pointer ) { 
  *pointer = local_pointer; 
} 

return true;
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Allocating and binding a memory object to a buffer</em></li>
<li><em>Allocating and binding a memory object to an image</em></li>
<li><em>Using a staging buffer to update a buffer with a device-local memory bound</em></li>
<li><em>Using a staging buffer to update an image with a device-local memory bound</em></li>
<li><em>Freeing a memory object</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Copying data between buffers</h1>
            </header>

            <article>
                
<p>In Vulkan, to upload data to a buffer, we are not limited only to the memory mapping technique. It is possible to copy data between buffers, even if the memory objects bound to them were allocated from different memory types.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a <span class="KeyPACKT">command buffer</span>. Store it in a variable of type <kbd>VkCommandBuffer</kbd> named <kbd>command_buffer</kbd>. Make sure the <span class="KeyPACKT">command buffer</span> is in the recording state (refer to the <em>Beginning a command buffer recording operation</em> recipe from <a href="fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Command Buffers and Synchronization</em>).</li>
</ol>
<ol start="2">
<li>Take the buffer from which data will be copied. Represent this buffer with a variable of type <kbd>VkBuffer</kbd> named <kbd>source_buffer</kbd>.</li>
<li>Take the buffer to which data will be uploaded. Represent this buffer using a variable of type <kbd>VkBuffer</kbd> named <kbd>destination_buffer</kbd>.</li>
<li>Create a variable of type <kbd>std::vector&lt;VkBufferCopy&gt;</kbd> named <kbd>regions</kbd>. For each memory region from which data should be copied, add an element to the <kbd>regions</kbd> vector. In each element, specify the memory offset in the source buffer from which data should be copied, a memory offset in the target buffer to which data should be copied, and the size of data to be copied from a given region.</li>
<li>Call <kbd>vkCmdCopyBuffer( command_buffer, source_buffer, destination_buffer, static_cast&lt;uint32_t&gt;(regions.size()), &amp;regions[0] )</kbd>, for which use the <kbd>command_buffer</kbd>, <kbd>source_buffer</kbd> and <kbd>destination_buffer</kbd> variables, the number of elements in the <kbd>regions</kbd> vector, and a pointer to the first element of that vector.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Copying data between buffers is another way of updating the memory contents of a given resource. This operation needs to be recorded to the <span class="KeyPACKT">command buffer,</span> like this:</p>
<pre>
if( regions.size() &gt; 0 ) { 
  vkCmdCopyBuffer( command_buffer, source_buffer, destination_buffer, static_cast&lt;uint32_t&gt;(regions.size()), &amp;regions[0] ); 
}
</pre>
<p>For the best performance, resources that are used during rendering should have a device-local memory bound. But, we can't map such memory. Using the <kbd>vkCmdCopyBuffer()</kbd> function, we can copy data to such a buffer from another buffer that has a host-visible memory bound to it. Such memory can be mapped and updated directly from our application.</p>
<div class="packt_tip">
<p>Buffers from which data can be copied must be created with a <kbd>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</kbd> usage.</p>
<p>Buffers into which we transfer data must be created with a <kbd>VK_BUFFER_USAGE_TRANSFER_DST_BIT</kbd> usage.</p>
</div>
<p>When we want to use a buffer as a target for transfer operations (we want to copy data to the buffer), we should set a memory barrier that will inform the driver that from now on, operations performed on the buffer are represented by a <kbd>VK_ACCESS_TRANSFER_WRITE_BIT</kbd> memory access scheme. After we are done copying data to the destination buffer and we want to use it for the desired purpose, we should set another memory barrier. This time, we should specify that previously we were transferring data to the buffer (so the operations were represented by the <kbd>VK_ACCESS_TRANSFER_WRITE_BIT</kbd> memory access type), but after the barrier the buffer will be used differently, with another memory access type representing operations performed on it (refer to the <em>Setting a buffer memory barrier</em> recipe).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a buffer</em></li>
<li><em>Setting a buffer memory barrier</em></li>
<li><em>Mapping, updating, and unmapping host-visible memory</em></li>
<li><em>Using a staging buffer to update a buffer with a device-local memory bound</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Copying data from a buffer to an image</h1>
            </header>

            <article>
                
<p>For images, we can bind memory objects that are allocated from different memory types. Only host-visible memory can be mapped and updated directly from our application. When we want to update the memory of an image that uses a device-local memory, we need to copy data from a buffer.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a <span class="KeyPACKT">command buffer</span> and store it in a variable of type <kbd>VkCommandBuffer</kbd> named <kbd>command_buffer</kbd>. Make sure the <span class="KeyPACKT">command buffer</span> is already in a recording state (refer to the <em>Beginning a command buffer recording operation</em> recipe from <a href="fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Command Buffers and Synchronization</em>).</li>
<li>Take a buffer from which data will be copied. Store its handle in a variable of type <kbd>VkBuffer</kbd> named <kbd>source_buffer</kbd>.</li>
</ol>
<ol start="3">
<li>Take the image to which data will be copied. Represent this image with a variable of type <kbd>VkImage</kbd> named <kbd>destination_image</kbd>.</li>
<li>Create a variable of type <kbd>VkImageLayout</kbd> named <kbd>image_layout</kbd>, in which the image's current <span class="KeyPACKT">layout</span> will be stored.</li>
<li>Create a variable of type <kbd>std::vector&lt;VkBufferImageCopy&gt;</kbd> named <kbd>regions</kbd>. For each memory region from which data should be copied, add an element to the <kbd>regions</kbd> vector. Specify the following values for members of each element:
<ul>
<li>Offset from the beginning of a buffer's memory from which data should be copied for <kbd>bufferOffset</kbd>.</li>
<li>The length of data that represents a single row in the buffer or a <kbd>0</kbd> value if the data is tightly packed (according to the size of the destination image) for <kbd>bufferRowLength</kbd>.</li>
<li>The height of the imaginary image stored in the buffer or a <kbd>0</kbd> value if the buffer's data is tightly packed (according to the size of the destination image) for <kbd>bufferImageHeight</kbd>.</li>
<li>Initialize the <kbd>imageSubresource</kbd> member with the following values:
<ul>
<li>Image's aspect (color, depth or stencil) for <kbd>aspectMask</kbd></li>
<li>Number (index) of mipmap level to be updated for <kbd>mipLevel</kbd></li>
<li>Number of the first array layer to be updated for <kbd>baseArrayLayer</kbd></li>
<li>Number of array layers that will be updated for <kbd>layerCount</kbd></li>
</ul>
</li>
<li>Initial offset (in texels) of image's sub region that should be updated for <kbd>imageOffset</kbd></li>
<li>The size (dimensions) of an image for <kbd>imageExtent</kbd></li>
</ul>
</li>
<li>Call <kbd>vkCmdCopyBufferToImage( command_buffer, source_buffer, destination_image, image_layout, static_cast&lt;uint32_t&gt;(regions.size()), &amp;regions[0] )</kbd>, for which use the <kbd>command_buffer</kbd>, <kbd>source_buffer</kbd>, <kbd>destination_image</kbd> and <kbd>image_layout</kbd> variables, the number of elements in the <kbd>regions</kbd> vector, and a pointer to the first element of that vector.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Copying data between a buffer and an image is done through a <span class="KeyPACKT">command buffer</span>, in which we record the following operation:</p>
<pre>
if( regions.size() &gt; 0 ) { 
  vkCmdCopyBufferToImage( command_buffer, source_buffer, destination_image, image_layout, static_cast&lt;uint32_t&gt;(regions.size()), &amp;regions[0] ); 
}
</pre>
<p>We need to know how the image data is laid out inside the buffer, so the image's memory is properly uploaded. We need to provide a memory offset (from the beginning of the buffer's memory), the length of the data row, and the height of the data in a buffer. This allows the driver to properly address the memory and copy the buffer's contents into the image. We can also provide zeros for row length and a height, which means that the buffer contains data that is tightly packed and it corresponds to the destination image's dimensions.</p>
<p>We also need to provide information about the destination of a data transfer operation. This involves defining an offset from the image's origin (from the upper-left corner in texels) for x, y, and z dimensions, the mipmap level into which data will be copied and a base array layer, and the number of layers that will be updated. We also need to specify the destination image's dimensions.</p>
<p>All the preceding parameters are specified through an array of <kbd>VkBufferImageCopy</kbd> elements. We can provide many regions at once and copy memory ranges that are not continuous.</p>
<p>On hardware architectures with several different memory types exposed by a physical device, it is recommended to use a device-local-only memory for resources that are used during rendering (performance-critical paths of our application). Such memory is usually faster than the memory that is also host-visible. Host-visible memory should be used only for staging resources which are used to upload data from, or download data to, the CPU (our application).</p>
<p>On architectures with only one memory type that is both device-local and host-visible, we don't need to bother with intermediate staging resources for data upload. But, the presented approach is still valid and may unify the application's behavior across different execution environments. This may make maintenance of our application easier.</p>
<p>In both cases, we can easily map the staging resource's memory and access it in our application. Next we can use it to transfer data to and from a device-local memory, which (generally) cannot be mapped. This is achieved with the copy operation described in this recipe.</p>
<div class="packt_tip">
<p>Buffers from which data can be copied must be created with a <kbd>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</kbd> usage.</p>
<p>Images into which we transfer data must be created with a <kbd>VK_BUFFER_USAGE_TRANSFER_DST_BIT</kbd> usage. Before the transfer operation, we also need to transition the image <span class="KeyPACKT">layout</span> to a <kbd>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</kbd>.</p>
</div>
<p>Before we can transfer data to an image, we must change its memory <span class="KeyPACKT">layout</span>. We can only copy data to an image whose current memory <span class="KeyPACKT">layout</span> is set to <kbd>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</kbd>. We can also use a <kbd>VK_IMAGE_LAYOUT_GENERAL</kbd> <span class="KeyPACKT">layout</span>, but it is not recommended due to lower performance.</p>
<p>So before we can copy data to an image, we should set a memory barrier that will change the image's memory access type from the one that occurred so far to a <kbd>VK_ACCESS_TRANSFER_WRITE_BIT</kbd>. The barrier should also perform a <span class="KeyPACKT">layout</span> transition from the current <span class="KeyPACKT">layout</span> to the <kbd>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</kbd> <span class="KeyPACKT">layout</span>. After we are done copying data to the image and we want to use it for other purposes, we should set another memory barrier. This time, we should change the memory access type from <kbd>VK_ACCESS_TRANSFER_WRITE_BIT</kbd> to the access that corresponds to the purpose for which the image will be used. And we should also transition the image's <span class="KeyPACKT">layout</span> from <kbd>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</kbd> to the one that is compatible with the image's next usage (refer to the <em>Setting an image memory barrier</em> recipe). Without these barriers, not only might the data transfer operation be invalid, but the data might not become visible for other operations performed on the image.</p>
<p>If the buffer that is a source of data is used for other purposes, we should also set a memory barrier for it and perform similar memory access changes before and after the transfer operation. But as the buffer is a source of data, we set a <kbd>VK_ACCESS_TRANSFER_READ_BIT</kbd> access type in the first barrier. It can be done with the same pipeline barriers which changed the parameters of the image. Refer to the <em>Setting a buffer memory barrier</em> recipe for more details.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a buffer</em></li>
<li><em>Allocating and binding a memory object to a buffer</em></li>
<li><em>Setting a buffer memory barrier</em></li>
<li><em>Creating an image</em></li>
<li><em>Allocating and binding a memory object to an image</em></li>
<li><em>Setting an image memory barrier</em></li>
<li><em>Mapping, updating, and unmapping host-visible memory</em></li>
<li><em>Copying data from an image to a buffer</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Copying data from an image to a buffer</h1>
            </header>

            <article>
                
<p>In Vulkan, we can not only transfer data from a buffer to an image, but also the other way--we can copy data from an image to the buffer. It doesn't matter what the properties of memory objects bound to them are. But, the data copy operation is the only way to update a device-local memory which cannot be mapped.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a <span class="KeyPACKT">command buffer</span> and store it in a variable of type <kbd>VkCommandBuffer</kbd> named <kbd>command_buffer</kbd>. Make sure the <span class="KeyPACKT">command buffer</span> is already in a recording state (refer to the <em>Beginning a command buffer recording operation</em> recipe from <a href="fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Command Buffers and Synchronization</em>).</li>
<li>Take an image from which data will be copied. Store its handle in a variable of type <kbd>VkImage</kbd> named <kbd>source_image</kbd>.</li>
<li>Take the source image's current memory <span class="KeyPACKT">layout</span> and use it to initialize a variable of type <kbd>VkImageLayout</kbd> named <kbd>image_layout</kbd>.</li>
<li>Take the buffer to which data will be copied. Prepare its handle in a variable of type <kbd>VkBuffer</kbd> named <kbd>destination_buffer</kbd>.</li>
</ol>
<ol start="5">
<li>Create a variable of type <kbd>std::vector&lt;VkBufferImageCopy&gt;</kbd> named <kbd>regions</kbd>. For each region in the memory from which data should be copied, add an element to the <kbd>regions</kbd> vector. Specify the following values for members of each element:
<ul>
<li>Offset from the beginning of a buffer's memory to which data should be copied for <kbd>bufferOffset</kbd>.</li>
<li>The length of data that will compose a single row in the buffer or a <kbd>0</kbd> value if the data is tightly packed (according to the size of the source image) for <kbd>bufferRowLength</kbd>.</li>
<li>The height of the image in the buffer (number of rows) or a <kbd>0</kbd> value if the buffer's data is tightly packed (according to the size of the source image) for <kbd>bufferImageHeight</kbd>.</li>
<li>Initialize <kbd>imageSubresource</kbd> member with the following values:
<ul>
<li>Image's aspect (color, depth or stencil) for <kbd>aspectMask</kbd></li>
<li>Number (index) of a mipmap level from which data will be copied for <kbd>mipLevel</kbd></li>
<li>Index of the first array layer from which contents will be copied for <kbd>baseArrayLayer</kbd></li>
<li>Number of array layers to copy for <kbd>layerCount</kbd></li>
</ul>
</li>
<li>Initial offset (in texels) of image's subregion from which data will be read and copied to buffer for <kbd>imageOffset</kbd>.</li>
<li>The size of an image for <kbd>imageExtent</kbd>.</li>
</ul>
</li>
<li>Call <kbd>vkCmdCopyImageToBuffer( command_buffer, source_image, image_layout, destination_buffer, static_cast&lt;uint32_t&gt;(regions.size()), &amp;regions[0] )</kbd>, for which use the <kbd>command_buffer</kbd>, <kbd>source_image</kbd>, <kbd>image_layout</kbd>, and <kbd>destination_buffer</kbd> variables, the number of elements in the <kbd>regions</kbd> vector, and a pointer to the first element of that vector.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Data copy from an image to a buffer is an operation that is recorded to the <span class="KeyPACKT">command buffer</span> like this:</p>
<pre>
if( regions.size() &gt; 0 ) { 
  vkCmdCopyImageToBuffer( command_buffer, source_image, image_layout, destination_buffer, static_cast&lt;uint32_t&gt;(regions.size()), &amp;regions[0] ); 
}
</pre>
<p>The command buffer must be already in a recording state.</p>
<p>For the data to be copied properly, we need to provide multiple parameters that define the source of the data and the destination to which the data will be copied. These parameters consist of an offset from the image's origin (from the upper-left corner in texels) for x, y, and z dimensions, the mipmap level and a base array layer from which data will be copied, and the number of layers that will be the source of the data. Image dimensions are also required.</p>
<p>For the destination buffer, we specify a memory offset (from the beginning of the buffer's memory), the length of the data row and the height of the data in a buffer. We can also provide zeros for row length and height, which means that the data copied to the buffer will be tightly packed and will correspond to the source image's dimensions.</p>
<p>The preceding parameters are specified using an array of <kbd>VkBufferImageCopy</kbd> elements, similar to copying data from a buffer to an image as described in the <em>Copying data from a buffer to an image</em> recipe. We can provide many regions and copy memory ranges that are not continuous all as part of one copy operation.</p>
<div class="packt_tip">
<p>Images from which we copy data must be created with a <kbd>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</kbd> usage. Before the transfer operation, we also need to transition the image's <span class="KeyPACKT">layout</span> to a <kbd>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</kbd>.</p>
<p>Buffers to which data can be copied must be created with a <kbd>VK_BUFFER_USAGE_TRANSFER_DST_BIT</kbd> usage.</p>
</div>
<p>Before we can copy data from an image, we should set a memory barrier and change the image's <span class="KeyPACKT">layout</span> from the one currently used to the <kbd>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</kbd> <span class="KeyPACKT">layout</span>. We also should change the type of memory access from the one that occurred so far to <kbd>VK_ACCESS_TRANSFER_READ_BIT</kbd>. A barrier should also be set after we are done copying data from the image, if it will be used for other purposes from now on. This time, we should change the memory access type from <kbd>VK_ACCESS_TRANSFER_READ_BIT</kbd> to the access that corresponds to the purpose for which the image will be used. At the same time, we should transition the <span class="KeyPACKT">layout</span> from <kbd>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</kbd> to the one that is compatible with the image's next usage (refer to the <em>Setting an image memory barrier</em> recipe). Without these barriers, not only might the data transfer operation be performed in the wrong way, but later commands may overwrite the image's contents before the transfer operation has finished.</p>
<p>Similar barriers should be set for the buffer (but they can be a part of the same pipeline barrier). If previously the buffer was used for other purposes, we should change the memory access to <kbd>VK_ACCESS_TRANSFER_WRITE_BIT</kbd> before the transfer operation, as described in the <em>Setting a buffer memory barrier</em> recipe.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Creating a buffer</em></li>
<li><em>Allocating and binding a memory object to a buffer</em></li>
<li><em>Setting a buffer memory barrier</em></li>
<li><em>Creating an image</em></li>
<li><em>Allocating and binding a memory object to an image</em></li>
<li><em>Setting an image memory barrier</em></li>
<li><em>Mapping, updating, and unmapping host-visible memory</em></li>
<li><em>Copying data from a buffer to an image</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using a staging buffer to update a buffer with a device-local memory bound</h1>
            </header>

            <article>
                
<p>Staging resources are used to update the contents of a memory that is not host-visible. Such memory cannot be mapped, so we need an intermediate buffer whose contents can be easily mapped and updated, and from which data can be transferred.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a <span class="KeyPACKT">logical device</span> stored in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Prepare the data that should be uploaded to the target buffer. Set up a pointer to the beginning of a data source and store it in a variable of type <kbd>void*</kbd> named <kbd>data</kbd>. The size of the data (in bytes) should be represented with a variable of type <kbd>VkDeviceSize</kbd> named <kbd>data_size</kbd>.</li>
</ol>
<ol start="3">
<li>Create a variable of type <kbd>VkBuffer</kbd> named <kbd>staging_buffer</kbd>. In it, the handle of a staging buffer will be stored.</li>
<li>Create a buffer that is big enough to hold the <kbd>data_size</kbd> number of bytes. Specify <kbd>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</kbd> usage during buffer creation. Use the <kbd>logical_device</kbd> variable during the creation process and store the created handle in the <kbd>staging_buffer</kbd> variable (refer to the <em>Creating a buffer</em> recipe).</li>
<li>Take the handle of the physical device from which the <kbd>logical_device</kbd> handle was created. Use the physical device's handle to initialize a variable of type <kbd>VkPhysicalDevice</kbd> named <kbd>physical_device</kbd>.</li>
<li>Create a variable of type <kbd>VkDeviceMemory</kbd> named <kbd>memory_object</kbd> that will be used to create a memory object for the staging buffer.</li>
<li>Allocate a memory object using the <kbd>physical_device</kbd>, <kbd>logical_device</kbd>, and <kbd>staging_buffer</kbd> variables. Allocate a memory object from a memory type that has a <kbd>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</kbd> property. Store the created handle in the <kbd>memory_object</kbd> variable and bind it to the staging buffer (refer to the <em>Allocating and binding a memory object to a buffer</em> recipe).</li>
<li>Map the memory of the <kbd>memory_object</kbd> using the <kbd>logical_device</kbd> variable, a <kbd>0</kbd> value for offset, and the <kbd>data_size</kbd> variable for the size of the mapped memory. Copy the data from the <kbd>data</kbd> pointer to the memory pointed to by the acquired pointer. Un-map the memory (refer to the <em>Mapping, updating, and unmapping host-visible memory</em> recipe).</li>
<li>Take the handle of an allocated primary <span class="KeyPACKT">command buffer</span> and use it to initialize a variable of type <kbd>VkCommandBuffer</kbd> named <kbd>command_buffer</kbd>.</li>
<li>Begin recording of the <kbd>command_buffer</kbd>. Provide a <kbd>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</kbd> flag (refer to the <em>Beginning a command buffer recording operation</em> recipe from <a href="fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Command Buffers and Synchronization</em>).</li>
<li>Take the handle of a buffer to which data will be transferred. Make sure it was created with a <kbd>VK_BUFFER_USAGE_TRANSFER_DST_BIT</kbd> usage. Store its handle in a variable of type <kbd>VkBuffer</kbd> named <kbd>destination_buffer</kbd>.</li>
</ol>
<ol start="12">
<li>Record a memory barrier for a <kbd>destination_buffer</kbd> in the <kbd>command_buffer</kbd> variable. Provide pipeline stages which have been referencing the <kbd>destination_buffer</kbd> so far for the generating stages, and use a <kbd>VK_PIPELINE_STAGE_TRANSFER_BIT</kbd> stage for the consuming stages. Provide the type of memory access operations that have been referencing the buffer so far and use a <kbd>VK_ACCESS_TRANSFER_WRITE_BIT</kbd> value for the new memory access type. Ignore queue family indices--provide <kbd>VK_QUEUE_FAMILY_IGNORED</kbd> for both indices (refer to the <em>Setting a buffer memory barrier</em> recipe).</li>
<li>Create a variable of type <kbd>VkDeviceSize</kbd> named <kbd>destination_offset</kbd>, and initialize it with an offset value to which data should be transferred to in the target buffer's memory.</li>
<li>Copy data from the <kbd>staging_buffer</kbd> to the <kbd>destination_buffer</kbd> using the <kbd>command_buffer</kbd> variable. Provide a <kbd>0</kbd> value for the source offset, the <kbd>destination_offset</kbd> variable for the destination offset, and the <kbd>data_size</kbd> variable for the size of the data to be transferred (refer to the <em>Copying data between buffers</em> recipe).</li>
<li>Record another memory barrier for the <kbd>destination_buffer</kbd> in the <kbd>command_buffer</kbd> variable. Provide a <kbd>VK_PIPELINE_STAGE_TRANSFER_BIT</kbd> value for the generating stages and a set of pipeline stages in which <kbd>destination_buffer</kbd> will be used from now on. Use the <kbd>VK_ACCESS_TRANSFER_WRITE_BIT</kbd> value for the current memory access type and a value that is proper for the way in which the buffer will be used after the memory transfer. Use a <kbd>VK_QUEUE_FAMILY_IGNORED</kbd> value for <span class="KeyPACKT">queue family</span> indices (refer to the <em>Setting a buffer memory barrier</em> recipe).</li>
<li>End recording of the <kbd>command_buffer</kbd> (refer to the <em>Ending a command buffer recording operation</em> recipe in <a href="fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Command Buffers and Synchronization</em>).</li>
<li>Take the handle of the queue on which the transfer operation will be performed and store it in a variable of type <kbd>VkQueue</kbd> named <kbd>queue</kbd>.</li>
<li>Create a list of <span class="KeyPACKT">semaphores</span> that should be signaled when the transfer operation is completed. Store their handles in a variable of type <kbd>std::vector&lt;VkSemaphore&gt;</kbd> named <kbd>signal_semaphores</kbd>.</li>
<li>Create a variable of type <kbd>VkFence</kbd> named <kbd>fence</kbd>.</li>
<li>Create an unsignaled <span class="KeyPACKT">fence</span> using the <kbd>logical_device</kbd> variable. Store the created handle in the <kbd>fence</kbd> variable (refer to the <em>Creating a fence</em> recipe from <a href="https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=207&amp;action=edit#post_201"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Command Buffers and Synchronization</em>).</li>
</ol>
<ol start="21">
<li>Submit <kbd>command_buffer</kbd> to the <kbd>queue</kbd>. Provide a list of <span class="KeyPACKT">semaphores</span> from the <kbd>signal_semaphores</kbd> vector as a list of <span class="KeyPACKT">semaphores</span> to be signaled, and the <kbd>fence</kbd> variable for the <span class="KeyPACKT">fence</span> to be signaled (refer to the <em>Submitting command buffers to the queue</em> recipe in <a href="fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Command Buffers and Synchronization</em>).</li>
<li>Wait for the <span class="KeyPACKT">fence</span> object to be signaled using the <kbd>logical_device</kbd> and <kbd>fence</kbd> variables. Provide a desired timeout value (refer to the <em>Waiting for fences</em> recipe in <a href="fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Command Buffers and Synchronization</em>).</li>
<li>Destroy the buffer represented by the <kbd>staging_buffer</kbd> variable (refer to the <em>Destroying a buffer</em> recipe).</li>
<li>Free the memory object represented by the <kbd>memory_object</kbd> variable (refer to the <em>Freeing a memory object</em> recipe).</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>To use a staging resource for a transfer operation, we need a buffer with a memory that can be mapped. We can use an existing buffer or create a new one like this:</p>
<pre>
VkBuffer staging_buffer; 
if( !CreateBuffer( logical_device, data_size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, staging_buffer ) ) { 
  return false; 
} 

VkDeviceMemory memory_object; 
if( !AllocateAndBindMemoryObjectToBuffer( physical_device, logical_device, staging_buffer, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT, memory_object ) ) { 
  return false; 
}
</pre>
<p>Next, we need to map the buffer's memory and update its contents:</p>
<pre>
if( !MapUpdateAndUnmapHostVisibleMemory( logical_device, memory_object, 0, data_size, data, true, nullptr ) ) { 
  return false; 
}
</pre>
<p>With a staging buffer ready, we can begin a transfer operation that will copy the data to the desired, target buffer. First, we start by beginning the command buffer recording operation and setting a memory barrier for the destination buffer to change its usage to the target for data copy operation. We don't need the memory barrier for the staging buffer. When we map and update the buffer's memory, its contents become visible for other commands, because an implicit barrier is set for the host writer when we start a <span class="KeyPACKT">command buffer</span> recording:</p>
<pre>
if( !BeginCommandBufferRecordingOperation( command_buffer, VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, nullptr ) ) { 
  return false; 
} 

SetBufferMemoryBarrier( command_buffer, destination_buffer_generating_stages, VK_PIPELINE_STAGE_TRANSFER_BIT, { { destination_buffer, destination_buffer_current_access, VK_ACCESS_TRANSFER_WRITE_BIT, VK_QUEUE_FAMILY_IGNORED, VK_QUEUE_FAMILY_IGNORED } } );
</pre>
<p>Next, we can record data copying from the <strong>staging resource</strong> to the destination buffer:</p>
<pre>
CopyDataBetweenBuffers( command_buffer, staging_buffer, destination_buffer, { { 0, destination_offset, data_size } } );
</pre>
<p>After this, we need a second memory barrier for the target buffer. This time, we change its usage from being a target of copy operations to the one the buffer will be used for after the data transfer. We can also end <span class="KeyPACKT">command buffer</span> recording:</p>
<pre>
SetBufferMemoryBarrier( command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, destination_buffer_consuming_stages, { { destination_buffer, VK_ACCESS_TRANSFER_WRITE_BIT, destination_buffer_new_access, VK_QUEUE_FAMILY_IGNORED, VK_QUEUE_FAMILY_IGNORED } } ); 

if( !EndCommandBufferRecordingOperation( command_buffer ) ) { 
  return false; 
}
</pre>
<p>Next, we create a <span class="KeyPACKT">fence</span> and submit the <span class="KeyPACKT">command buffer</span> to the queue, where it will be processed and the data transfer will be actually performed:</p>
<pre>
VkFence fence; 
if( !CreateFence( logical_device, false, fence ) ) { 
  return false; 
} 
if( !SubmitCommandBuffersToQueue( queue, {}, { command_buffer }, signal_semaphores, fence ) ) { 
  return false; 
}
</pre>
<p>If we don't want to use a staging buffer any more, we can destroy it. But, we can't do this until the staging buffer won't be used any more by the commands submitted to the queue: that's why we need a fence. We wait on it until the driver signals when the processing of a submitted command buffer has finished. Then, we can safely destroy a staging buffer and free the memory object bound to it:</p>
<pre>
if( !WaitForFences( logical_device, { fence }, VK_FALSE, 500000000 ) ) { 
  return false; 
} 

DestroyBuffer( logical_device, staging_buffer ); 
FreeMemoryObject( logical_device, memory_object ); 
return true;
</pre>
<p>In real-life scenarios, we should use an existing buffer and reuse it as a staging buffer as many times as possible to avoid unnecessary buffer creation and destruction operations. This way, we also avoid waiting on a <span class="KeyPACKT">fence</span>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>In <a href="https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=207&amp;action=edit#post_201"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Command Buffers and Synchronization</em>, see the following recipes:</p>
<ul>
<li><em>Beginning a command buffer recording operation</em></li>
<li><em>Ending a command buffer recording operation</em></li>
<li><em>Creating a fence</em></li>
<li><em>Waiting for fences</em></li>
<li><em>Submitting command buffers to the queue</em></li>
</ul>
<p>See the following recipes in this chapter:</p>
<ul>
<li><em>Creating a buffer</em></li>
<li><em>Allocating and binding a memory object to a buffer</em></li>
<li><em>Setting an image memory barrier</em></li>
<li><em>Mapping, updating, and unmapping host-visible memory</em></li>
<li><em>Copying data from a buffer to an image</em></li>
<li><em>Using a staging buffer to update an image with a device-local memory bound</em></li>
<li><em>Freeing a memory object</em></li>
<li><em>Destroying a buffer</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using a staging buffer to update an image with a device-local memory bound</h1>
            </header>

            <article>
                
<p><strong>Staging</strong> buffers can be used not only to transfer data between buffers, but also to and from an image. Here, we will show how to map a buffer's memory and copy its contents to a desired image.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Create a staging buffer big enough to hold the entire data to be transferred. Specify a <kbd>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</kbd> usage for the buffer and store its handle in a variable of type <kbd>VkBuffer</kbd> named <kbd>staging_buffer</kbd>. Allocate a memory object that supports the <kbd>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</kbd> property and bind it to the staging buffer. Store the memory object's handle in a variable of type <kbd>VkDeviceMemory</kbd> named <kbd>memory_object</kbd>. Map the memory and update its contents with the data to be transferred to the image. Unmap the memory. Perform these steps as described in more detail in the <em>Using a staging buffer to update a buffer with a device-local memory bound</em> recipe.</li>
<li>Take the handle of a primary command buffer and use it to initialize a variable of type <kbd>VkCommandBuffer</kbd> named <kbd>command_buffer</kbd>.</li>
<li>Begin recording of the <kbd>command_buffer</kbd>. Provide a <kbd>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</kbd> flag (refer to the <em>Beginning a command buffer recording operation</em> recipe from <a href="fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Command Buffers and Synchronization</em>).</li>
</ol>
<ol start="4">
<li>Take the handle of the image to which data will be transferred and make sure it was created with a <kbd>VK_IMAGE_USAGE_TRANSFER_DST_BIT</kbd> specified. Use the handle to initialize a variable of type <kbd>VkImage</kbd> named <kbd>destination_image</kbd>.</li>
<li>Record an image memory barrier in the <kbd>command_buffer</kbd>. Specify the stages in which the image was used so far and use a <kbd>VK_PIPELINE_STAGE_TRANSFER_BIT</kbd> stage for the consuming stages. Use the <kbd>destination_image</kbd> variable, provide the image's current access, and use a <kbd>VK_ACCESS_TRANSFER_WRITE_BIT</kbd> value for the new access. Specify the image's current <span class="KeyPACKT">layout</span> and use a <kbd>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</kbd> value for the new <span class="KeyPACKT">layout</span>. Provide the image's aspect, but ignore <span class="KeyPACKT">queue family</span> indices--use <kbd>VK_QUEUE_FAMILY_IGNORED</kbd> values for both (refer to the <em>Setting an image memory barrier</em> recipe).</li>
<li>In the <kbd>command_buffer</kbd>, record the data transfer operation from <kbd>staging_buffer</kbd> to <kbd>destination_image</kbd>. Provide a <kbd>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</kbd> value as an image <span class="KeyPACKT">layout</span>, a <kbd>0</kbd> value for the buffer's offset, a <kbd>0</kbd> value for the buffer's row lengths, and a <kbd>0</kbd> value for the buffer's image height. Specify the image's memory region into which data should be copied by providing the desired mipmap level, base array layer index, and the number of layers to be updated. Provide the image's aspect too. Specify the offset into the image's x, y, and z coordinates (in texels) and the image's size (refer to the <em>Copying data from a buffer to an image</em> recipe).</li>
<li>Record another image memory barrier into the <kbd>command_buffer</kbd>. This time, specify a <kbd>VK_PIPELINE_STAGE_TRANSFER_BIT</kbd> value for generating stages and set proper stages in which the target image will be used after the data transfer. In the barrier, change the image's <span class="KeyPACKT">layout</span> from <kbd>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</kbd> into the value proper for the new usage. Set a <kbd>VK_QUEUE_FAMILY_IGNORED</kbd> value for both <span class="KeyPACKT">queue families</span> and also provide the image's aspect (refer to the <em>Setting an image memory barrier</em> recipe).</li>
<li>End the command buffer recording operation, create an unsignaled fence and use it, along with semaphores that should be signaled, during submitting the command buffer to the queue. Wait for the created fence to be signaled, destroy the staging buffer, and free its memory object as described in the <em>Using a staging buffer to update a buffer with a device-local memory bound</em> recipe.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>This recipe is very similar to the <em>Using a staging buffer to update a buffer with a device-local memory bound</em> recipe; that's why only the differences are described in more detail.</p>
<p>First we create a staging buffer, allocate a memory object for it, bind it to the buffer, and map it to upload data from our application to the GPU:</p>
<pre>
VkBuffer staging_buffer; 
if( !CreateBuffer( logical_device, data_size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, staging_buffer ) ) { 
  return false; 
} 

VkDeviceMemory memory_object; 
if( !AllocateAndBindMemoryObjectToBuffer( physical_device, logical_device, staging_buffer, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT, memory_object ) ) { 
  return false; 
} 

if( !MapUpdateAndUnmapHostVisibleMemory( logical_device, memory_object, 0, data_size, data, true, nullptr ) ) { 
  return false; 
}
</pre>
<p>Next we begin <span class="KeyPACKT">command buffer</span> recording, and set one barrier for the destination image so it can be used as a target for data transfer. We also record the data transfer operation:</p>
<pre>
if( !BeginCommandBufferRecordingOperation( command_buffer, VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, nullptr ) ) { 
  return false; 
} 

SetImageMemoryBarrier( command_buffer, destination_image_generating_stages, VK_PIPELINE_STAGE_TRANSFER_BIT, 
{ 
  { 
    destination_image, 
    destination_image_current_access, 
    VK_ACCESS_TRANSFER_WRITE_BIT, 
    destination_image_current_layout, 
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 
    VK_QUEUE_FAMILY_IGNORED, 
    VK_QUEUE_FAMILY_IGNORED, 
    destination_image_aspect 
  } } ); 

CopyDataFromBufferToImage( command_buffer, staging_buffer, destination_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 
{ 
  { 
    0, 
    0, 
    0, 
    destination_image_subresource, 
    destination_image_offset, 
    destination_image_size, 
  } } );
</pre>
<p>Next, we record another barrier that changes the image's usage from being the target of the copy operation to the one that is valid for the purpose for which the image will be used next. We also end the <span class="KeyPACKT">command buffer</span> recording operation:</p>
<pre>
SetImageMemoryBarrier( command_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, destination_image_consuming_stages, 
{ 
  { 
    destination_image, 
    VK_ACCESS_TRANSFER_WRITE_BIT, 
    destination_image_new_access, 
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 
    destination_image_new_layout, 
    VK_QUEUE_FAMILY_IGNORED, 
    VK_QUEUE_FAMILY_IGNORED, 
    destination_image_aspect 
  } } ); 

if( !EndCommandBufferRecordingOperation( command_buffer ) ) { 
  return false; 
}
</pre>
<p>After that, we create a <span class="KeyPACKT">fence</span> and submit a <span class="KeyPACKT">command buffer</span> to the queue. We then wait on the <span class="KeyPACKT">fence</span> to know the moment when we can safely delete the staging buffer and its memory object. We do it afterwards:</p>
<pre>
VkFence fence; 
if( !CreateFence( logical_device, false, fence ) ) { 
  return false; 
} 

if( !SubmitCommandBuffersToQueue( queue, {}, { command_buffer }, signal_semaphores, fence ) ) { 
  return false; 
} 

if( !WaitForFences( logical_device, { fence }, VK_FALSE, 500000000 ) ) { 
  return false; 
} 

DestroyBuffer( logical_device, staging_buffer ); 
FreeMemoryObject( logical_device, memory_object ); 

return true;
</pre>
<p>If we are reusing the existing buffer as a staging resource, we don't need the <span class="KeyPACKT">fence</span>, because the buffer will live much longer, maybe for the whole lifetime of the application. This way, we can avoid frequent and unnecessary buffer creation and deletion, and memory object allocation and freeing.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>In <a href="https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=207&amp;action=edit#post_201"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Command Buffer and Synchronization</em>, see the following recipes:</p>
<ul>
<li><em>Beginning a command buffer recording operation</em></li>
<li><em>Ending a command buffer recording operation</em></li>
<li><em>Creating a fence</em></li>
<li><em>Waiting for fences</em></li>
<li><em>Submitting command buffers to the queue</em></li>
</ul>
<p>See the following recipes in this chapter:</p>
<ul>
<li><em>Creating a buffer</em></li>
<li><em>Allocating and binding a memory object to a buffer</em></li>
<li><em>Setting an image memory barrier</em></li>
<li><em>Mapping, updating, and unmapping host-visible memory</em></li>
<li><em>Copying data from a buffer to an image</em></li>
<li><em>Using a staging buffer to update an image with a device-local memory bound</em></li>
<li><em>Freeing a memory object</em></li>
<li><em>Destroying a buffer</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Destroying an image view</h1>
            </header>

            <article>
                
<p>When we don't need an <span class="KeyPACKT">image view</span> any more, we should destroy it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a <span class="KeyPACKT">logical device</span> and store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Take the handle of an <span class="KeyPACKT">image view</span> stored in a variable of type <kbd>VkImageView</kbd> named <kbd>image_view</kbd>.</li>
<li>Call <kbd>vkDestroyImageView( logical_device, image_view, nullptr )</kbd> and provide the handle of the <span class="KeyPACKT">logical device</span>, the handle of the <span class="KeyPACKT">image view</span>, and a <kbd>nullptr</kbd> value.</li>
<li>For safety reasons, assign a <kbd>VK_NULL_HANDLE</kbd> value to the <kbd>image_view</kbd> variable.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Destroying an <span class="KeyPACKT">image view</span> requires us to use its handle and the handle of the <span class="KeyPACKT">logical device</span> on which the <span class="KeyPACKT">image view</span> was created. It is performed in the following way:</p>
<pre>
if( VK_NULL_HANDLE != image_view ) { 
  vkDestroyImageView( logical_device, image_view, nullptr ); 
  image_view = VK_NULL_HANDLE; 
}
</pre>
<p>First, we check whether the handle is not empty. We don't need to do it--destroying a null handle is silently ignored. But it's good to skip unnecessary function calls. Next, we destroy the <span class="KeyPACKT">image view</span> and assign a null handle to the variable in which the handle was stored.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li><em>Creating an image view</em> recipe in this chapter</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Destroying an image</h1>
            </header>

            <article>
                
<p>Images that won't be used any more should be destroyed to release their resources.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take a logical device and store its handle in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Use the image's handle to initialize a variable of type <kbd>VkImage</kbd> named <kbd>image</kbd>.</li>
<li>Call <kbd>vkDestroyImage( logical_device, image, nullptr )</kbd>. Provide the handle of the logical device, the handle of the image, and a <kbd>nullptr</kbd> value.</li>
<li>For safety reasons, assign a <kbd>VK_NULL_HANDLE</kbd> value to the <kbd>image</kbd> variable.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Images are destroyed through a single call of the <kbd>vkDestroyImage()</kbd> function. For it, we provide the handle of the <span class="KeyPACKT">logical device</span>, the handle of the image, and a <kbd>nullptr</kbd> value, like this:</p>
<pre>
if( VK_NULL_HANDLE != image ) { 
  vkDestroyImage( logical_device, image, nullptr ); 
  image = VK_NULL_HANDLE; 
}
</pre>
<p>We also try to avoid unnecessary function calls by checking whether the image's handle is not empty.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li><em>Creating an image</em> recipe in this chapter</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Destroying a buffer view</h1>
            </header>

            <article>
                
<p>When we don't need a buffer view any more, we should destroy it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take a <span class="KeyPACKT">logical device</span> and store its handle in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Use the buffer's view handle and initialize a variable of type <kbd>VkBufferView</kbd> named <kbd>buffer_view</kbd> with it.</li>
<li>Call <kbd>vkDestroyBufferView( logical_device, buffer_view, nullptr )</kbd>. Provide the handle of the <span class="KeyPACKT">logical device</span>, the handle of the buffer view, and a <kbd>nullptr</kbd> value.</li>
<li>For safety reasons, assign the <kbd>VK_NULL_HANDLE</kbd> value to the <kbd>buffer_view</kbd> variable.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Buffer views are destroyed using the <kbd>vkDestroyBufferView()</kbd> function:</p>
<pre>
if( VK_NULL_HANDLE != buffer_view ) { 
  vkDestroyBufferView( logical_device, buffer_view, nullptr ); 
  buffer_view = VK_NULL_HANDLE; 
}
</pre>
<p>To avoid unnecessary function calls, we check whether the buffer view's handle is not empty before we call a buffer view destroying function.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li><em>Creating a buffer view</em> recipe in this chapter</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Freeing a memory object</h1>
            </header>

            <article>
                
<p>In Vulkan, when we create resources, we later destroy them. On the other hand, resources that represent different memory objects or pools are allocated and freed. Memory objects bound to images and buffers are also freed. We should free them when we no longer need them.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the <span class="KeyPACKT">logical device</span>'s handle and store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Take the variable of type <kbd>VkDeviceMemory</kbd> named <kbd>memory_object</kbd>, in which the handle of the memory object is stored.</li>
<li>Call <kbd>vkFreeMemory( logical_device, memory_object, nullptr )</kbd>. Use the handle of the <span class="KeyPACKT">logical device</span>, the handle of the memory object, and a <kbd>nullptr</kbd> value.</li>
<li>For safety reasons, assign the <kbd>VK_NULL_HANDLE</kbd> value to the <kbd>memory_object</kbd> variable.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Memory objects can be freed before resources that were using them are destroyed. But we can't use these resources any more, we can only destroy them. In general, we can't bind one memory object to the resource, free it, and then bind another memory object to the same resource.</p>
<p>To free a memory object, we can write the following code:</p>
<pre>
if( VK_NULL_HANDLE != memory_object ) { 
  vkFreeMemory( logical_device, memory_object, nullptr ); 
  memory_object = VK_NULL_HANDLE; 
}
</pre>
<p>Memory objects must have been allocated from a logical device represented by the <kbd>logical_device</kbd> variable.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<p>The following recipes in this chapter:</p>
<ul>
<li><em>Allocating and binding a memory object to a buffer</em></li>
<li><em>Allocating and binding a memory object to an image</em></li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Destroying a buffer</h1>
            </header>

            <article>
                
<p>When a buffer is no longer used, we should destroy it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How to do it...</h1>
            </header>

            <article>
                
<ol>
<li>Take the handle of a <span class="KeyPACKT">logical device</span> and store it in a variable of type <kbd>VkDevice</kbd> named <kbd>logical_device</kbd>.</li>
<li>Store the buffer's handle in a variable of type <kbd>VkBuffer</kbd> named <kbd>buffer</kbd>.</li>
<li>Call <kbd>vkDestroyBuffer( logical_device, buffer, nullptr )</kbd> and provide the handle of the <span class="KeyPACKT">logical device</span>, the handle of the buffer, and a <kbd>nullptr</kbd> value.</li>
<li>For safety reasons, assign the <kbd>VK_NULL_HANDLE</kbd> value to the <kbd>buffer</kbd> variable.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">How it works...</h1>
            </header>

            <article>
                
<p>Buffers are destroyed using the <kbd>vkDestroyBuffer()</kbd> function like this:</p>
<pre>
if( VK_NULL_HANDLE != buffer ) { 
  vkDestroyBuffer( logical_device, buffer, nullptr ); 
  buffer = VK_NULL_HANDLE; 
}
</pre>
<p><kbd>logical_device</kbd> is a variable representing the <span class="KeyPACKT">logical device</span> on which the buffer was created. When we destroy a buffer, we assign an empty handle to the variable representing this buffer, so we won't try to destroy the same resource twice.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">See also</h1>
            </header>

            <article>
                
<ul>
<li><em>Creating a buffer view</em> recipe in this chapter</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>