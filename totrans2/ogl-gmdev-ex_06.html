<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Polishing the Silver"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Polishing the Silver</h1></div></div></div><p>I'm sure that you are as excited as I am about the progress that you have made on your game. It's almost ready to publish, right? Well, not quite! There is a lot of work that goes into polishing your game before it is ready, and that's what this chapter is all about.</p><p>Many people have a great idea for a game, and lots of enthusiastic coders, such as you, actually code their game to the point where we have reached so far. Unfortunately, this is where a lot of projects die. For some reason, many first-time game coders don't take the time to really finish their game. There are lots of things that still need to be done to make your game presentable:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Game state</strong></span>: We already touched on game state a little bit when you learned how to pause your game. This chapter will continue the discussion of how you use game state to manage your game at various stages of gameplay.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Splash screen</strong></span>: Most games display one or more screens before the game starts. These screens, known as splash screens, often display the logo and name of the studios that were involved in creating the game. A splash screen shows that you went the extra mile in polishing your game.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Menu screen</strong></span>: Most games start with a menu of choices for the player. We will create a simple menu that loads after our splash screen and gives the player a few options.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Scoring and statistics</strong></span>: You probably noticed that our game currently doesn't keep score. Although it is possible to design a game that doesn't involve scoring, most players want to know how they are doing in the game.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Winning and losing</strong></span>: Again, while there are certainly games out there where no one wins or loses, most games have win-or-lose conditions that signal that the game is over.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Game progression</strong></span>: Most games allow the player to continue playing as long as the player has achieved certain goals. Many games are broken down into a series of levels, with each level becoming a little more difficult than the previous one. You will learn how to add this type of progression to your game.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Credits</strong></span>: Everyone likes to get credit for their work! Just like the movies, it is traditional to include a screen that shows each person that was involved in creating the game and what their role was. I'll show you how to create a simple credits screen.</li></ul></div><div class="section" title="The state of the game"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec32"/>The state of the game</h1></div></div></div><p>Remember when we coded the pause button back in <a class="link" href="ch04.html" title="Chapter 4. Control Freak">Chapter 4</a>, <span class="emphasis"><em>Control Freak</em></span>? We had to add some code that told the<a id="id322" class="indexterm"/> game whether it was active or paused. In fact, we defined the following enums:</p><div class="informalexample"><pre class="programlisting">enum GameState
{
  GS_Running,
  GS_Paused
};</pre></div><p>These <code class="literal">enums</code> defined two game states: <code class="literal">GS_Running</code>, and <code class="literal">GS_Paused</code>. We then set the default game state to <code class="literal">GS_Running</code> in the <code class="literal">StartGame</code> function:</p><div class="informalexample"><pre class="programlisting">void StartGame()
{
  inputManager = new Input(hWnd);
  LoadTextures();
  <span class="strong"><strong>m_gameState = GS_Running;</strong></span>
  
  srand(time(NULL));
  pickupSpawnThreshold = 5.0f;
  pickupSpawnTimer = 0.0f;
}</pre></div><p>As long as the game state is set to <code class="literal">GS_Running</code>, then the game continues to cycle through the game loop, processing updates, and rendering the scene. However, when you click the pause button, the game state is set to <code class="literal">GS_Paused</code>. When the game is paused, we no longer update the game objects (that is, the robot, pickups, and enemies), but we do continue to render the scene and process the UI (user interface) so that buttons can be clicked.</p><div class="section" title="State machines"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec82"/>State machines</h2></div></div></div><p>The mechanism <a id="id323" class="indexterm"/>used to set up and control game states is known as<a id="id324" class="indexterm"/> a <span class="strong"><strong>state machine</strong></span>. A state machine sets up separate and distinct stages (or <span class="strong"><strong>states</strong></span>) for the game. Each state defines a certain set of rules for what is supposed to happen or not happen during each state. For example, our simple state machine has two states with the following rules, illustrated by the following matrix:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>GS_Running</p>
</th><th style="text-align: left" valign="bottom">
<p>GS_Paused</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Input</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>All input</p>
</td><td style="text-align: left" valign="top">
<p>Only UI input</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Objects Updating</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>All objects</p>
</td><td style="text-align: left" valign="top">
<p>Only UI objects</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Collision Detection</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>All collideables</p>
</td><td style="text-align: left" valign="top">
<p>No need to check for collisions</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Spawning</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>All spawnables</p>
</td><td style="text-align: left" valign="top">
<p>No spawning</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Rendering</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>All objects</p>
</td><td style="text-align: left" valign="top">
<p>All objects</p>
</td></tr></tbody></table></div><p>The state machine also defines the progression from one state to another. Here is a simple diagram showing the progression in our current state machine:</p><div class="mediaobject"><img src="graphics/8199OS_06_01.jpg" alt="State machines"/></div><p>This state <a id="id325" class="indexterm"/>diagram is pretty simple. If you are in the running state, then it<a id="id326" class="indexterm"/> is legal to go to the paused state. If you are in the paused state, then it is legal to go to the running state. As we will see, most games are much more complex than this!</p></div><div class="section" title="Why do we need a state machine?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec83"/>Why do we need a state machine?</h2></div></div></div><p>At first glance, you<a id="id327" class="indexterm"/> may wonder why we even need a state machine. You could, for example, set up several Boolean flags (maybe one called <code class="literal">running</code> and one called <code class="literal">paused</code>), and then insert them into the code in the same way that we are using our enums.</p><p>This solution may work considering that our current game only has two states, but even then, it starts to get complicated if you choose to use Booleans. For example, to change the state from running to paused, I would always have to make sure to properly set both Booleans:</p><div class="informalexample"><pre class="programlisting">running = false;
paused = true;</pre></div><p>When I went from the running state to the paused state, I would have to set both Booleans again:</p><div class="informalexample"><pre class="programlisting">running = true;
paused = false;</pre></div><p>Imagine the problem if I forgot to change both Booleans and left the game in a state where it was both running and paused! Then imagine how complicated this becomes if my game has three, four, or ten states!</p><p>Using enums is not the only way to set up a state engine, but it does have immediate advantages over using Booleans:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enums have a descriptive name associated with their value (for example, <code class="literal">GS_Paused</code>), whereas Booleans only have <code class="literal">true</code> and <code class="literal">false</code>.</li><li class="listitem" style="list-style-type: disc">Enums are already mutually exclusive. In order to make a set of Booleans mutually exclusive, I have to set one to <code class="literal">true</code> and all the others to <code class="literal">false</code>.</li></ul></div><p>The next consideration as to why we need a state machine is that it simplifies the coding of the control of the game. Most games have several game states, and it is important that we are able to easily manage which code runs in which state. An example of game states that are common to most games includes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loading</li><li class="listitem" style="list-style-type: disc">Starting</li><li class="listitem" style="list-style-type: disc">Running</li><li class="listitem" style="list-style-type: disc">Paused</li><li class="listitem" style="list-style-type: disc">Ending</li><li class="listitem" style="list-style-type: disc">GameWon</li><li class="listitem" style="list-style-type: disc">GameLost</li><li class="listitem" style="list-style-type: disc">GameOver</li><li class="listitem" style="list-style-type: disc">NextLevel</li><li class="listitem" style="list-style-type: disc">Exiting</li></ul></div><p>Of course, this is just<a id="id328" class="indexterm"/> a representative list, and each coder picks his or her own names for their game states. But I think that you get the idea: there are a lot of states that a game can be in, and that means it is important to be able to manage what happens during each state. Players tend to get angry if their character dies while the game was paused!</p></div><div class="section" title="Planning for state"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec84"/>Planning for state</h2></div></div></div><p>We are <a id="id329" class="indexterm"/>going to expand our simple state machine to include several more game states. This is going to help us to better organize the processing of the game, and better define which processes should be running at any particular time.</p><p>The following table shows the game states that we are going to define for our game:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>State</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Loading</p>
</td><td style="text-align: left" valign="top">
<p>The game is loading and the Splash screen should be displayed</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Menu</p>
</td><td style="text-align: left" valign="top">
<p>The main menu is showing</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Running</p>
</td><td style="text-align: left" valign="top">
<p>The game is actively running</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Paused</p>
</td><td style="text-align: left" valign="top">
<p>The game is paused</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>NextLevel</p>
</td><td style="text-align: left" valign="top">
<p>The game is loading the next level</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>GameOver</p>
</td><td style="text-align: left" valign="top">
<p>The game is over and the stats are being displayed</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Credits</p>
</td><td style="text-align: left" valign="top">
<p>Showing the Credits screen</p>
</td></tr></tbody></table></div><p>Here is our state diagram machine:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>Splash</p>
</th><th style="text-align: left" valign="bottom">
<p>Loading</p>
</th><th style="text-align: left" valign="bottom">
<p>Menu</p>
</th><th style="text-align: left" valign="bottom">
<p>Running</p>
</th><th style="text-align: left" valign="bottom">
<p>Paused</p>
</th><th style="text-align: left" valign="bottom">
<p>Next</p>
</th><th style="text-align: left" valign="bottom">
<p>GameOver</p>
</th><th style="text-align: left" valign="bottom">
<p>Credits</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Input</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>UI</p>
</td><td style="text-align: left" valign="top">
<p>All</p>
</td><td style="text-align: left" valign="top">
<p>UI</p>
</td><td style="text-align: left" valign="top">
<p>UI</p>
</td><td style="text-align: left" valign="top">
<p>UI</p>
</td><td style="text-align: left" valign="top">
<p>UI</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Updating</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>Splash</p>
</td><td style="text-align: left" valign="top">
<p>Splash</p>
</td><td style="text-align: left" valign="top">
<p>UI</p>
</td><td style="text-align: left" valign="top">
<p>All</p>
</td><td style="text-align: left" valign="top">
<p>UI</p>
</td><td style="text-align: left" valign="top">
<p>UI</p>
</td><td style="text-align: left" valign="top">
<p>UI</p>
</td><td style="text-align: left" valign="top">
<p>UI</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Collision Detection</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>All</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Spawning</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>All</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Rendering</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>Splash</p>
</td><td style="text-align: left" valign="top">
<p>Splash</p>
</td><td style="text-align: left" valign="top">
<p>Menu</p>
</td><td style="text-align: left" valign="top">
<p>Game</p>
</td><td style="text-align: left" valign="top">
<p>Game</p>
</td><td style="text-align: left" valign="top">
<p>Game</p>
</td><td style="text-align: left" valign="top">
<p>GameOver</p>
</td><td style="text-align: left" valign="top">
<p>Credits</p>
</td></tr></tbody></table></div><p>Finally, here <a id="id330" class="indexterm"/>is our state diagram:</p><div class="mediaobject"><img src="graphics/8199OS_06_02.jpg" alt="Planning for state"/></div><p>It turns out<a id="id331" class="indexterm"/> that our state diagram will also double as a UI diagram. A UI diagram is a diagram of all of the screens in a program and how they interact with each other. It turns out that each time that we want to change to a different screen in our game, we are also changing to a different screen. This isn't exactly the case—when the game is paused, it doesn't launch a completely new screen. However, there is often a very close correlation between the UI diagram and the state diagram.</p><p>Looking at the state diagram, you can easily see the legal state changes versus the illegal state changes. For example, it is legal to change the state from playing to paused, but you can't change the state from playing to credits.</p><p>Having this structure in place will guide us as we implement all of the final polish features that<a id="id332" class="indexterm"/> we want to add to our game.</p></div><div class="section" title="Defining the new state"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec85"/>Defining the new state</h2></div></div></div><p>The first step<a id="id333" class="indexterm"/> in expanding our game state machine is adding the required <code class="literal">enums</code>. Replace the <code class="literal">GameState enum</code> code with the following code:</p><div class="informalexample"><pre class="programlisting">enum GameState
{
  GS_Splash,
  GS_Loading,
  GS_Menu,
  GS_Credits,
  GS_Running,
  GS_NextLevel,
  GS_Paused,
  GS_GameOver,
};</pre></div><p>As we implement the polish features covered in this chapter, we will implement code that uses these game states.</p></div><div class="section" title="Implementing the state machine"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec86"/>Implementing the state machine</h2></div></div></div><p>In order for <a id="id334" class="indexterm"/>our state machine to have any effect, we need to modify the code so that key decisions are made based on the game state. There are three functions that game state affects in a big way:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Update</strong></span>: Some <a id="id335" class="indexterm"/>game states update game objects, while other game states update only the UI or a particular sprite</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Render</strong></span>: Different <a id="id336" class="indexterm"/>game states render different items</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Input</strong></span>: Some<a id="id337" class="indexterm"/> game states accept all input, while other game states only process UI input</li></ul></div><p>It should come as no surprise then that we will be changing the <code class="literal">Update</code>, <code class="literal">Render</code>, and <code class="literal">ProcessInput</code> functions.</p><p>First, let's modify the <code class="literal">Update</code> function. Change the <code class="literal">Update</code> function in <code class="literal">RoboRacer2D.cpp</code> to match the following code:</p><div class="informalexample"><pre class="programlisting">void Update(const float p_deltaTime)
{
 switch (m_gameState)
 {
 case GameState::GS_Splash:
 case GameState::GS_Loading:
 {
 }
 break;
 case GameState::GS_Menu:
 {
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;

 case GameState::GS_Credits:
 {
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;
 case GameState::GS_Running:
 {
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
  CheckBoundaries(player);
  CheckBackground();
  background-&gt;Update(p_deltaTime);
  robot_left-&gt;Update(p_deltaTime);
  robot_right-&gt;Update(p_deltaTime);
  robot_left_strip-&gt;Update(p_deltaTime);
  robot_right_strip-&gt;Update(p_deltaTime);
  pauseButton-&gt;Update(p_deltaTime);
  resumeButton-&gt;Update(p_deltaTime);
  pickup-&gt;Update(p_deltaTime);
  SpawnPickup(p_deltaTime);
  SpawnEnemy(p_deltaTime);
  enemy-&gt;Update(p_deltaTime);
  CheckCollisions();
 }
 break;
 case GameState::GS_Paused:
 {
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;
 case GameState::GS_NextLevel:
 {
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;
 case GameState::GS_GameOver:
 {
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;
 }
}</pre></div><p>As you can <a id="id338" class="indexterm"/>see, we are now using a <code class="literal">switch</code> statement to handle each game state. This is a whole lot more readable than using <code class="literal">if</code> statements, and it keeps the code much more structured. If we need to add another game state, we just add another <code class="literal">case</code> to the <code class="literal">switch</code> statement.</p><p>Notice that each <code class="literal">case</code> has its code to run specific to that game state. Some lines of code are duplicated (almost every state has some input), but this is a small price to pay for clarity. <code class="literal">GS_Running</code> has the most work to do, while <code class="literal">GS_Loading</code> has the least work to do. We will be adding code to each switch as we add polish features.</p><p>Now, let's give the <code class="literal">Render</code> function an upgrade. Replace the <code class="literal">Render</code> function with the following code:</p><div class="informalexample"><pre class="programlisting">switch (m_gameState)
 {
 case GameState::GS_Splash:
 case GameState::GS_Loading:
 {
 }
 break;
 case GameState::GS_Menu:
 {
 }
 break;
 case GameState::GS_Credits:
 {
 }
 break;
 case GameState::GS_Running:
 case GameState::GS_Paused:
 {
  background-&gt;Render();
  robot_left-&gt;Render();
  robot_right-&gt;Render();
  robot_left_strip-&gt;Render();
  robot_right_strip-&gt;Render();
  pauseButton-&gt;Render();
  resumeButton-&gt;Render();
  pickup-&gt;Render();
  enemy-&gt;Render();
  DrawScore();
 }
 break;
 case GameState::GS_NextLevel:
 {
 }
 break;
 case GameState::GS_GameOver:
 {
 }
 break;
 }
  
  SwapBuffers(hDC);
}</pre></div><p>In this<a id="id339" class="indexterm"/> case, we have some work that needs to be done regardless of the game state. We need to clear the OpenGL buffer, and set the matrix to identity. Then we decide which items to render based on the game state, and finally, we swap the buffers.</p><p>If you look closely, <code class="literal">GS_Running</code> and <code class="literal">GS_Paused</code> render the same items. This is because the pause and render buttons are rendered over the top of the gameplay screen, so we still need to render the entire game even when we are paused. We will be adding code to each switch as we add polish features.</p><p>Finally, we<a id="id340" class="indexterm"/> need to apply our state machine to the <code class="literal">ProcessInput</code> function. As the function is so long, I am only showing the top lines of the function. Change all of the lines above the <code class="literal">uiTimer += p_deltaTime;</code> statement to the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Replace highlighted code with:</strong></span>

<span class="strong"><strong> switch (m_gameState)</strong></span>
<span class="strong"><strong> {</strong></span>
<span class="strong"><strong> case GameState::GS_Splash:</strong></span>
<span class="strong"><strong> case GameState::GS_Loading:</strong></span>
<span class="strong"><strong> {</strong></span>
<span class="strong"><strong>  return;</strong></span>
<span class="strong"><strong> }</strong></span>
<span class="strong"><strong> break;</strong></span>
<span class="strong"><strong> case GameState::GS_Menu:</strong></span>
<span class="strong"><strong> case GameState::GS_Credits:</strong></span>
<span class="strong"><strong> case GameState::GS_Paused:</strong></span>
<span class="strong"><strong> case GameState::GS_NextLevel:</strong></span>
<span class="strong"><strong> case GameState::GS_GameOver:</strong></span>
<span class="strong"><strong> {</strong></span>
<span class="strong"><strong>  command = Input::Command::CM_UI;</strong></span>
<span class="strong"><strong> }</strong></span>
<span class="strong"><strong> break;</strong></span>
<span class="strong"><strong> case GameState::GS_Running:</strong></span>
<span class="strong"><strong> {</strong></span>
<span class="strong"><strong> }</strong></span>
<span class="strong"><strong>  break;</strong></span>
<span class="strong"><strong> }</strong></span>

<span class="strong"><strong>}</strong></span>

uiTimer += p_deltaTime;</pre></div><p>First, we get the latest command. Then, depending on the game state, we perform the following actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ignore and return if we are still in the loading state</li><li class="listitem" style="list-style-type: disc">Reset the command to only handle UI commands if the game state is menu, paused, next level, or game over</li><li class="listitem" style="list-style-type: disc">Leave the command unchanged if we are in the running game state</li></ul></div><p>This is exactly <a id="id341" class="indexterm"/>what we did in the prior versions, except we only had two game states to deal with in the prior versions. Once the command is handled, we move on to the <code class="literal">uiTimer += p_deltaTime;</code> (everything after this line is unchanged from the prior versions).</p></div></div></div>
<div class="section" title="Making a splash"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Making a splash</h1></div></div></div><p>A splash menu adds a touch of class to your game and also does a little bragging. Typically, the <a id="id342" class="indexterm"/>splash screen shows off your company logo. In fact, many game projects have multiple studios that work on them, so there are often multiple splash screens. We will use just one!</p><p>It is important to get the splash screen up and running as soon as possible, so we will do that before we perform any other loading. Part of the function of a splash screen is to give the player something pretty to look at while the rest of the game is loading.</p><div class="section" title="Creating the splash screen"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec87"/>Creating the splash screen</h2></div></div></div><p>It's up to you to <a id="id343" class="indexterm"/>create a splash screen that defines your game. For convenience, we have included one in the code resource package for this chapter called <code class="literal">splash.png</code>. Make sure you copy <code class="literal">splash.png</code> into your project. The only requirement for the splash image is that it is 800 x 600 pixels, the same resolution as our game screen.</p></div><div class="section" title="Defining the splash screen"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec88"/>Defining the splash screen</h2></div></div></div><p>As with <a id="id344" class="indexterm"/>all images in this game, we will implement the splash screen as a sprite. Declare the splash sprite at the top of <code class="literal">RoboRacer2D.cpp</code>:</p><div class="informalexample"><pre class="programlisting">Sprite* splashScreen;</pre></div><p>We also want to define some timers for the splash screen:</p><div class="informalexample"><pre class="programlisting">float splashDisplayTimer;
float splashDisplayThreshold;</pre></div><p>As we want to define the splash screen separately, we will create a separate function just to load it. Create the <code class="literal">LoadSplash</code> function using the following code:</p><div class="informalexample"><pre class="programlisting">void LoadSplash()
{
  m_gameState = GameState::GS_Splash;
  
  splashScreen = new Sprite(1);
  splashScreen-&gt;SetFrameSize(800.0f, 600.0f);
  splashScreen-&gt;SetNumberOfFrames(1);
  splashScreen-&gt;AddTexture("resources/splash.png", false);
  splashScreen-&gt;IsActive(true);
  splashScreen-&gt;IsVisible(true);
}</pre></div><p>We are not<a id="id345" class="indexterm"/> going to make a significant change to the <code class="literal">StartGame</code> function. We are going to only load the splash screen, and defer loading the other game resources. This will get our splash screen up as soon as possible. Change the <code class="literal">StartGame</code> function so that it looks like the following code:</p><div class="informalexample"><pre class="programlisting">void StartGame()
{
 LoadSplash();
 inputManager = new Input(hWnd);

 uiTimer = 0.0f;
 srand(time(NULL));

 pickupSpawnThreshold = 3.0f;
 pickupSpawnTimer = 0.0f;

 enemySpawnThreshold = 7.0f;
 enemySpawnTimer = 0.0f;

 splashDisplayTimer = 0.0f;
 splashDisplayThreshold = 5.0f;

}</pre></div><p>Notice that we only load the splash resources and set a few variables here. We also set the splash timer so that it will show up for at least five seconds.</p><p>Next, modify the <code class="literal">GS_Splash</code> case in the <code class="literal">Update</code> function to look like the following code:</p><div class="informalexample"><pre class="programlisting"> switch (m_gameState)
 {
 case GameState::GS_Splash:
 case GameState::GS_Loading:
 {
  splashScreen-&gt;Update(p_deltaTime);
  splashDisplayTimer += p_deltaTime;
  if (splashDisplayTimer &gt; splashDisplayThreshold)
  {
   m_gameState = GameState::GS_Menu;
  }
 }
 break;</pre></div><p>This code updates the splash timer. When the timer exceeds our threshold, then the game state changes<a id="id346" class="indexterm"/> to <code class="literal">GS_Menu</code>. We will define the code to load the next menu.</p><p>Modify the <code class="literal">GS_Splash</code> case in the <code class="literal">Render</code> function to look like the following code:</p><div class="informalexample"><pre class="programlisting">case GameState::GS_Loading:
<span class="strong"><strong>splashScreen-&gt;Render();</strong></span>
break;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip43"/>Tip</h3><p>As the splash sprite is only a static image, you may wonder why we update the splash sprite. While an update has no effect on our current code, consider a case where I wanted to implement a dynamic, animated splash screen.</p></div></div></div><div class="section" title="Loading our resources"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec89"/>Loading our resources</h2></div></div></div><p>If you have been<a id="id347" class="indexterm"/> paying attention, then you should realize that we removed the <code class="literal">LoadTextures</code> call from the <code class="literal">StartGame</code> function. Instead, we are going to load the textures in the <code class="literal">GameLoop</code> function. Change <code class="literal">GameLoop</code> so that it looks like the following code:</p><div class="informalexample"><pre class="programlisting">void GameLoop(const float p_deltatTime)
{
  <span class="strong"><strong>if (m_gameState == GameState::GS_Splash)</strong></span>
<span class="strong"><strong>  {</strong></span>
<span class="strong"><strong>    LoadTextures();</strong></span>
<span class="strong"><strong>    m_gameState = GameState::GS_Loading;</strong></span>
<span class="strong"><strong>  }</strong></span>
  Update(p_deltatTime);
  Render();
}</pre></div><p>If you recall, <code class="literal">GameLoop</code> is called every frame. We need <code class="literal">GameLoop</code> to be running to display our splash screen, which we have already loaded. But on the first call to <code class="literal">GameLoop</code>, we haven't loaded our other resources.</p><p>We check to see whether our game state is <code class="literal">GS_Splash</code>. If it is, we call load textures, and immediately change the game state to <code class="literal">GS_Loading</code>. If we didn't change the game state, then the game would attempt to load the textures every frame, which would be a very bad thing! This is another practical example of why we define different game states in our state machine.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip44"/>Tip</h3><p>In a way, we haven't created a true splash screen. That is because our splash still depends on Windows and OpenGL initializing before the splash screen can even be loaded and rendered. True splash screens use a snippet of code that does not depend on all of this initialization so that they can load before everything else. Unfortunately, that level of detail is beyond the scope of our book. Sometimes, the splash screen will run on a separate thread so that it is independent of the startup code.</p></div></div><div class="mediaobject"><img src="graphics/8199OS_06_03.jpg" alt="Loading our resources"/></div><p>When you <a id="id348" class="indexterm"/>run the game now, you should see the splash screen display, but then nothing else happens. This is because we changed the game state to <code class="literal">GS_Menu</code> in the <code class="literal">Update</code> function, and we have not coded for that game state yet! If you want to test your splash screen, change <code class="literal">m_gameState = GameState::GS_Menu</code> to <code class="literal">m_gameState = GameState::GS_Running</code> in the <code class="literal">Update</code> function. Just don't forget to change it back before you move on.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip45"/>Tip</h3><p>The ability to change your game state allows you to reroute the flow of your game. This is very useful, for example, when you are trying to code a new game state but you aren't ready to run it in the game yet. Once the new game state is coded, then you can wire it in.</p></div></div></div></div>
<div class="section" title="What's on the menu?"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>What's on the menu?</h1></div></div></div><p>Main menus may have disappeared in many applications, but they are still alive and well in games. The <a id="id349" class="indexterm"/>main menu gives the player a chance to decide what to do once the game has loaded. We are going to create a simple menu that allows the player to start the game, display the credits, or exit the game.</p><div class="section" title="Creating the menu"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec90"/>Creating the menu</h2></div></div></div><p>Our menu will be<a id="id350" class="indexterm"/> built out of two components. First, we will load an image to use as the background. Next, we will load additional images to use as UI buttons. Together, these images will create a screen that will allow the player to navigate our game.</p><p>We will start by defining a sprite to represent the menu. Add the following line of code to the variable declarations in <code class="literal">RoboRacer2D.cpp</code>:</p><div class="informalexample"><pre class="programlisting">Sprite* menuScreen;</pre></div><p>Next, we will instantiate the menu in the <code class="literal">LoadTextures</code> function. Add the following code to <code class="literal">LoadTextures</code>:</p><div class="informalexample"><pre class="programlisting">  menuScreen = new Sprite(1);
  menuScreen-&gt;SetFrameSize(800.0f, 600.0f);
  menuScreen-&gt;SetNumberOfFrames(1);
  menuScreen-&gt;AddTexture("resources/mainmenu.png", false);
  menuScreen-&gt;IsActive(true);
  menuScreen-&gt;IsVisible(true);</pre></div><p>Make sure that you have downloaded the <code class="literal">menu.png</code> texture from the book website, or that you have created your own background at 800 by 600 pixels.</p><p>Now, we must modify the <code class="literal">Update</code> and <code class="literal">Render</code> functions. Modify the <code class="literal">GS_Menu</code> case in <code class="literal">Update</code> to the following code:</p><div class="informalexample"><pre class="programlisting">case GameState::GS_Menu:
 {
  menuScreen-&gt;Update(p_deltaTime);
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;</pre></div><p>Next, modify the <code class="literal">GS_Menu</code> case in the <code class="literal">Render</code> function:</p><div class="informalexample"><pre class="programlisting">case GameState::GS_Menu:
{
  menuScreen-&gt;Render();
}
break;</pre></div><p>If you run the<a id="id351" class="indexterm"/> game now, the splash screen should display for five seconds, followed by the menu screen.</p></div><div class="section" title="Defining the menu buttons"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec91"/>Defining the menu buttons</h2></div></div></div><p>Our next task is<a id="id352" class="indexterm"/> to add buttons to the menu screen that the player can click. These buttons will work similar to the pause and resume buttons that we have already created.</p><p>We will start by declaring variables for the buttons. Add the following declarations to the variables section in <code class="literal">RoboRacer2D.cpp</code>:</p><div class="informalexample"><pre class="programlisting">Sprite* playButton;
Sprite* creditsButton;
Sprite* exitButton;</pre></div><p>These three pointers will manage the three buttons on our main menu. Next, add the following code to <code class="literal">LoadTextures</code> to instantiate the buttons:</p><div class="informalexample"><pre class="programlisting">playButton = new Sprite(1);
playButton-&gt;SetFrameSize(75.0f, 38.0f);
playButton-&gt;SetNumberOfFrames(1);
playButton-&gt;SetPosition(390.0f, 300.0f);
playButton-&gt;AddTexture("resources/playButton.png");
playButton-&gt;IsVisible(true);
playButton-&gt;IsActive(false);
inputManager-&gt;AddUiElement(playButton);

creditsButton = new Sprite(1);
creditsButton-&gt;SetFrameSize(75.0f, 38.0f);
creditsButton-&gt;SetNumberOfFrames(1);
creditsButton-&gt;SetPosition(390.0f, 350.0f);
creditsButton-&gt;AddTexture("resources/creditsButton.png");
creditsButton-&gt;IsVisible(true);
creditsButton-&gt;IsActive(false);
inputManager-&gt;AddUiElement(creditsButton);

exitButton = new Sprite(1);
exitButton-&gt;SetFrameSize(75.0f, 38.0f);
exitButton-&gt;SetNumberOfFrames(1);
exitButton-&gt;SetPosition(390.0f, 500.0f);
exitButton-&gt;AddTexture("resources/exitButton.png");
exitButton-&gt;IsVisible(true);
exitButton-&gt;IsActive(false);
inputManager-&gt;AddUiElement(exitButton);</pre></div><p>This code is<a id="id353" class="indexterm"/> mostly the same as the code that we used to instantiate the pause and resume buttons. One small difference is that we set all three buttons to be visible. Our code already enforces that these buttons will not render unless we are in the game state <code class="literal">GS_Menu</code>.</p><p>We do, however, want to set the buttons as inactive. This way the <code class="literal">input</code> class will ignore them until we want them to be activated.</p><p>As with all of our objects, we now need to wire them into the <code class="literal">Update</code> and <code class="literal">Render</code> functions. Change the <code class="literal">GS_Menu</code> case in the <code class="literal">Update</code> function to the following code:</p><div class="informalexample"><pre class="programlisting"> case GameState::GS_Menu:
 {
  menuScreen-&gt;Update(p_deltaTime);
  playButton-&gt;IsActive(true);
  creditsButton-&gt;IsActive(true);
  exitButton-&gt;IsActive(true);
  playButton-&gt;Update(p_deltaTime);
  creditsButton-&gt;Update(p_deltaTime);
  exitButton-&gt;Update(p_deltaTime);
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;</pre></div><p>This is where we set the buttons on our menu to be active. We want to guarantee that the buttons on the menu are active when we are in the game state <code class="literal">GS_Menu</code>.</p><p>Next, change the <code class="literal">GS_Menu</code> case in the <code class="literal">Render</code> function to the following code:</p><div class="informalexample"><pre class="programlisting">case GameState::GS_Menu:
 {
  menuScreen-&gt;Render();
  playButton-&gt;Render();
  creditsButton-&gt;Render();
  exitButton-&gt;Render();
 }
 break;</pre></div><p>In order for the buttons to actually do something, we need to add the following code to the <code class="literal">CM_UI</code> case in <code class="literal">ProcessInput</code>:</p><div class="informalexample"><pre class="programlisting">if (playButton-&gt;IsClicked())
{
  playButton-&gt;IsClicked(false);
  exitButton-&gt;IsActive(false);
  playButton-&gt;IsActive(false);
  creditsButton-&gt;IsActive(false);
  m_gameState = GameState::GS_Running;
}

if (creditsButton-&gt;IsClicked())
{
  creditsButton-&gt;IsClicked(false);
  exitButton-&gt;IsActive(false);
  playButton-&gt;IsActive(false);
  creditsButton-&gt;IsActive(false);
  m_gameState = GameState::GS_Credits;
}

if (exitButton-&gt;IsClicked())
{
  playButton-&gt;IsClicked(false);
  exitButton-&gt;IsActive(false);
  playButton-&gt;IsActive(false);
  creditsButton-&gt;IsActive(false);
  PostQuitMessage(0);
}</pre></div><p>Notice that we <a id="id354" class="indexterm"/>change the game state if the play button or credits button are clicked (if the exit button is clicked, we simply post the quit message). Notice that we have to do a little button management, setting the buttons on the menu to be inactive once we are no longer in the <code class="literal">GS_Menu</code> game state. This is because our input class checks the input for all buttons that are active. Leaving the buttons active would mean that they could still be clicked even though they are not being displayed on the screen.</p><p>We don't have to set the buttons to be invisible. This is because changing the state will automatically stop these buttons from updating or rendering. The same is true of the menu screen. Once the game state is changed, it will not render or update. This is one of the big advantages of utilizing a state machine.</p><div class="mediaobject"><img src="graphics/8199OS_06_04.jpg" alt="Defining the menu buttons"/></div><p>If you run<a id="id355" class="indexterm"/> the program right now, the main menu will display. If you click the play button, the game will start. If you click the exit button, the game will exit. We will implement the credit screen next.</p></div></div>
<div class="section" title="Getting some credit"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Getting some credit</h1></div></div></div><p>Everyone likes to get credit for their hard work! Most games will implement a credits screen that shows<a id="id356" class="indexterm"/> the name and function of each person involved in creating the game. For AAA titles, this list may be as long as a list for a movie. For smaller, independent games, this list might be three people.</p><div class="section" title="Creating the credits screen"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec92"/>Creating the credits screen</h2></div></div></div><p>Similarly to the main menu, the credits screen will be based on a background image and a button that <a id="id357" class="indexterm"/>can be clicked. We will also need to add text to the screen.</p><p>Let's start by declaring a pointer for our screen. Add the following declaration to the variables section of <code class="literal">RoboRacer2D.cpp</code>:</p><div class="informalexample"><pre class="programlisting">Sprite* creditsScreen;</pre></div><p>Then, we will instantiate the credits screen in <code class="literal">LoadTextures</code>:</p><div class="informalexample"><pre class="programlisting">creditsScreen = new Sprite(1);
creditsScreen-&gt;SetFrameSize(800.0f, 600.0f);
creditsScreen-&gt;SetNumberOfFrames(1);
creditsScreen-&gt;AddTexture("resources/credits.png", false);
creditsScreen-&gt;IsActive(false);
creditsScreen-&gt;IsVisible(true);</pre></div><p>Next, we <a id="id358" class="indexterm"/>wire the credits screen into <code class="literal">Update</code>:</p><div class="informalexample"><pre class="programlisting"> case GameState::GS_Credits:
 {
  creditsScreen-&gt;Update(p_deltaTime);
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;</pre></div><p>We also update <code class="literal">Render</code>:</p><div class="informalexample"><pre class="programlisting"> case GameState::GS_Credits:
 {
  creditsScreen-&gt;Render();
 }
 break;</pre></div></div><div class="section" title="Getting back to the main menu"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec93"/>Getting back to the main menu</h2></div></div></div><p>We now need to<a id="id359" class="indexterm"/> add a button that allows us to get from the credits screen back to the main menu. We first declare the pointer in the variables declaration section:</p><div class="informalexample"><pre class="programlisting">Sprite* menuButton;</pre></div><p>We then instantiate the button in <code class="literal">LoadTextures</code>:</p><div class="informalexample"><pre class="programlisting">menuButton = new Sprite(1);
menuButton-&gt;SetFrameSize(75.0f, 38.0f);
menuButton-&gt;SetNumberOfFrames(1);
menuButton-&gt;SetPosition(390.0f, 400.0f);
menuButton-&gt;AddTexture("resources/menuButton.png");
menuButton-&gt;IsVisible(true);
menuButton-&gt;IsActive(false);
inputManager-&gt;AddUiElement(menuButton);</pre></div><p>Let's add the button to <code class="literal">Update</code>:</p><div class="informalexample"><pre class="programlisting">case GameState::GS_Credits:
 {
  creditsScreen-&gt;Update(p_deltaTime);
  menuButton-&gt;IsActive(true);
  menuButton-&gt;Update(p_deltaTime);
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;</pre></div><p>We also update <code class="literal">Render</code>:</p><div class="informalexample"><pre class="programlisting"> case GameState::GS_Credits:
 {
  creditsScreen-&gt;Render();
  menuButton-&gt;Render();
 }
 break;</pre></div><p>Similarly to the<a id="id360" class="indexterm"/> menu buttons, we now need to add code to the case <code class="literal">Input::Command::CM_UI:</code> case in <code class="literal">ProcessInput</code> to handle clicking on the menu button:</p><div class="informalexample"><pre class="programlisting">if (menuButton-&gt;IsClicked())
{
  menuButton-&gt;IsClicked(false);
  menuButton-&gt;IsActive(false);
  m_gameState = GameState::GS_Menu;
}</pre></div><p>When the menu button is clicked, we change the game state back to menu, and set the menu button to be inactive. Due to the code that we have already written, the menu screen will automatically display.</p><div class="mediaobject"><img src="graphics/8199OS_06_05.jpg" alt="Getting back to the main menu"/></div></div></div>
<div class="section" title="Working with fonts"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Working with fonts</h1></div></div></div><p>Until now, we embedded any text that we needed inside of an existing texture. However, there are times <a id="id361" class="indexterm"/>when we may want to have the code decide what text to display. For example, on our credits screen, we don't want to make a graphic for each person's name who took part in creating the game.</p><div class="section" title="Creating the font"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec94"/>Creating the font</h2></div></div></div><p>We need a <a id="id362" class="indexterm"/>way to render text directly to the screen, and this means that we also need a way to define the font that we want to use when rendering the text. First, we need to add a global variable that services as a handle to our fonts. Add the following line to the variable declarations in the code:</p><div class="informalexample"><pre class="programlisting">GLuint fontBase;</pre></div><p>Now, we need to add the following code to create the font:</p><div class="informalexample"><pre class="programlisting">GLvoid BuildFont(GLvoid)
{
  HFONT newFont;
  HFONT tempFont;
  
  fontBase = glGenLists(96);
  
  tempFont = CreateFont(-26, // Height
  0,                        // Width
  0,                        // Escapement
  0,                        // Orientation
  FW_BOLD,                  // Weight
  FALSE,                    // Italic
  FALSE,                    // Underline
  FALSE,                    // Strikeout
  ANSI_CHARSET,         // Character Set
  OUT_TT_PRECIS,            // Output Precision
  CLIP_DEFAULT_PRECIS, // Clipping Precision
  ANTIALIASED_QUALITY,// Output Quality
  FF_DONTCARE | DEFAULT_PITCH, // Family/Pitch
  "Courier New");           // Font Name
  
  newFont = (HFONT)SelectObject(hDC, tempFont);
  wglUseFontBitmaps(hDC, 32, 96, fontBase);
  SelectObject(hDC, newFont);
  DeleteObject(tempFont);
}</pre></div><p>This code creates<a id="id363" class="indexterm"/> a font using three main elements.</p><p>First, we use <code class="literal">glGenLists</code> to create 96 display lists to hold each letter of our font. A display list is basically a buffer that can hold rendering data. Next, we call <code class="literal">CreateFont</code> to create a Windows font. The parameters of the <code class="literal">CreateFont</code> function specify the type of font that we want to create. Finally, we use <code class="literal">wglUseFontBitmaps</code> to assign our new font to the font handle that we created earlier.</p><p>One little twist is that we have to create a temporary <code class="literal">HFONT</code> object called <code class="literal">tempFont</code> with all the properties, then we assign <code class="literal">tempFont</code> to <code class="literal">newFont</code> and delete <code class="literal">tempFont</code>.</p><p>We will want to delete the display lists when the program closes down, so add the following utility function:</p><div class="informalexample"><pre class="programlisting">GLvoid KillFont(GLvoid)
{
  glDeleteLists(fontBase, 96);
}</pre></div><p>This code simply uses <code class="literal">glDeleteLists</code> to delete the display lists that we created to hold our font.</p></div><div class="section" title="Drawing text"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec95"/>Drawing text</h2></div></div></div><p>Now that we<a id="id364" class="indexterm"/> have a font, we need to have a function that will render text to the screen. Add the following function to the code:</p><div class="informalexample"><pre class="programlisting">void DrawText(const char* p_text, const float p_x, const float p_y, const float r, const float g, const float b)
{
 glBindTexture(GL_TEXTURE_2D, 0);
 glColor3f(r, g, b);

 glRasterPos2f(p_x, p_y);
 if (p_text != NULL)
 {
  glPushAttrib(GL_LIST_BIT);
  glListBase(fontBase - 32);
  glCallLists(strlen(p_text), GL_UNSIGNED_BYTE, p_text);
  glPopAttrib();
 }
 glColor3f(1.0f, 1.0f, 1.0f);

}</pre></div><p>This code takes a string and an <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> position, and draws the text at that position. It also takes <code class="literal">r</code>, <code class="literal">g</code>, and <code class="literal">b</code> parameters to define the text color:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">glBindTexture</code>(<code class="literal">GL_TEXTURE_2D</code>, <code class="literal">0</code>): This tells OpenGL that we are going to be working with 2D textures (i.e. the fonts) <code class="literal">glColor3f(r, g, b)</code>: This sets the color of the font.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glRasterPos2f</code>: This is used to set the current draw position on the screen.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glPushAttrib(GL_LIST_BIT)</code>: This tells OpenGL that we are going to render using display lists.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glListBase</code>: This sets the current start of the list. We subtract 32 because the ASCII value for a space is 32, and we don't use any characters with lower ASCII values.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glCallLists</code>: This is used to retrieve the lists for each character in the text.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glPopAttrib</code>: This returns the OpenGL attribute to its previous value.</li></ul></div><p>Now, we are<a id="id365" class="indexterm"/> ready to draw our credits text:</p><div class="informalexample"><pre class="programlisting">void DrawCredits()
{
 float startX = 325.0f;
 float startY = 250.0f;
 float spaceY = 30.0f;
 DrawText("Robert Madsen", startX, startY, 0.0f, 0.0f, 1.0f);
 DrawText("Author", startX, startY + spaceY, 0.0f, 0.0f, 1.0f);
}</pre></div><p>First, we set the position on the screen where we want to draw, then we use the <code class="literal">DrawText</code> function to actually perform the drawing. The first line adds me (a subtle indulgence), and the second line is for you!</p></div><div class="section" title="Wiring in the font support"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec96"/>Wiring in the font support</h2></div></div></div><p>We have a<a id="id366" class="indexterm"/> few more book keeping tasks to perform to get the font support to work. First, modify the <code class="literal">GameLoop</code> code, adding the highlighted line:</p><div class="informalexample"><pre class="programlisting">if (m_gameState == GameState::GS_Splash)
{
<span class="strong"><strong>  BuildFont();</strong></span>
  LoadTextures();
  m_gameState = GameState::GS_Loading;
}</pre></div><p>This will create our fonts when the game starts up.</p><p>Next, fill out the <code class="literal">GS_Credits</code> case of the <code class="literal">m_gameState</code> switch in the <code class="literal">Render</code> function:</p><div class="informalexample"><pre class="programlisting"> case GameState::GS_Credits:
 {
  creditsScreen-&gt;Update(p_deltaTime);
  menuButton-&gt;IsActive(true);
  menuButton-&gt;Update(p_deltaTime);
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;</pre></div><p>This<a id="id367" class="indexterm"/> draws the credits text when the game state changes to <code class="literal">GS_Credits</code>. Congratulations! You can finally get the credit that you deserve!</p></div></div>
<div class="section" title="Level up!"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Level up!</h1></div></div></div><p>A lot of the fun in games is trying to increase your score. Part of good game design is to make the game <a id="id368" class="indexterm"/>challenging to play, but not so challenging that the player cannot score or improve.</p><p>Most players also get better at a game as they play, so if the game difficulty does not increase, the player will eventually get bored because the player will no longer be challenged.</p><p>We will start by simply displaying the score on the screen so that the player can see how well they are doing. Then we will discuss techniques that are used to continually increase the difficulty of the game, thus steadily increasing the challenge.</p><div class="section" title="Displaying the score"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec97"/>Displaying the score</h2></div></div></div><p>We already<a id="id369" class="indexterm"/> learned how to display text on the screen when we <a id="id370" class="indexterm"/>were creating the credits screen. Now, we will use the same techniques to display the score.</p><p>If you recall, we already have a mechanism to keep track of the score. Every sprite has a value property. For pickups, we assign a positive value so that the player gains points for each pickup. For enemies, we assign a negative value so that the player loses points whenever they collide with an enemy. We store the current score in the value property of the player.</p><p>Add the following code to <code class="literal">RoboRacer2D.cpp</code> to create the <code class="literal">DrawScore</code> function:</p><div class="informalexample"><pre class="programlisting">void DrawScore()
{
 char score[50];
 sprintf_s(score, 50, "Score: %i", player-&gt;GetValue());
 DrawText(score, 350.0f, 25.0f, 0.0f, 0.0f, 1.0f);
}</pre></div><p>This code works just like the <code class="literal">DrawCredits</code> function that we created earlier. First, we create a character string that holds the current score and a caption, then we use <code class="literal">DrawText</code> to render the<a id="id371" class="indexterm"/> text.</p><p>We also need to <a id="id372" class="indexterm"/>wire this into the main game. Modify the <code class="literal">GS_Running</code> case of the <code class="literal">m_gameState</code> switch in the <code class="literal">Render</code> function with the highlighted line:</p><div class="informalexample"><pre class="programlisting"> case GameState::GS_Running:
 case GameState::GS_Paused:
 {
  background-&gt;Render();
  robot_left-&gt;Render();
  robot_right-&gt;Render();
  robot_left_strip-&gt;Render();
  robot_right_strip-&gt;Render();
  pauseButton-&gt;Render();
  resumeButton-&gt;Render();
  pickup-&gt;Render();
  enemy-&gt;Render();
  DrawScore();
 }
 break;</pre></div><p>The score will display both when the game is running and when the game is paused.</p></div><div class="section" title="Game progression"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec98"/>Game progression</h2></div></div></div><p>In order to <a id="id373" class="indexterm"/>add progression to the game, we need to have certain thresholds established. For our game, we will set three thresholds:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Each level will last two minutes</li><li class="listitem" style="list-style-type: disc">If the player receives less than five pickups during a level, the game will end, and the game over screen will be displayed</li><li class="listitem" style="list-style-type: disc">If the player receives five or more pickups, then the level ends and the next level screen is displayed</li></ul></div><p>For each level that the player successfully completes, we will make things a little more difficult. There are many ways that we could increase the difficulty of each level:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Increase the spawn time for pickups</li><li class="listitem" style="list-style-type: disc">Decrease the speed of the robot</li></ul></div><p>To keep<a id="id374" class="indexterm"/> things simple, we will only do one of these. We will increase the spawn time threshold for pickups by .25 seconds for each level. With pickups spawning less often, the player will eventually receive too few pickups, and the game will end.</p></div><div class="section" title="Defining game levels"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec99"/>Defining game levels</h2></div></div></div><p>Let's set up the <a id="id375" class="indexterm"/>code for level progression. We will start by defining a timer to keep track of how much time has passed. Add the following declarations to <code class="literal">RoboRacer2D.cpp</code>:</p><div class="informalexample"><pre class="programlisting">float levelTimer;
float levelMaxTime;
float pickupSpawnAdjustment;

int pickupsReceived;
int pickupsThreshold;
int enemiesHit;</pre></div><p>We will initialize the variables in the <code class="literal">StartGame</code> function:</p><div class="informalexample"><pre class="programlisting">levelTimer = 0.0f;
levelMaxTime = 30.0f;
pickupSpawnAdjustment = 0.25f;

pickupsReceived = 0;
pickupsThreshold = 5;
enemiesHit =0;</pre></div><p>We are setting up a timer that will run for 120 seconds, or two minutes. At the end of two minutes the level will end and the spawn time for pickups will be incremented by .25 seconds. We will also check to see whether the player has received five pickups. If not, the game will be over.</p><p>To handle the logic for the level progression, let's add a new function called <code class="literal">NextLevel</code> by adding the following code:</p><div class="informalexample"><pre class="programlisting">void NextLevel()
{
 if (pickupsReceived &lt; pickupsThreshold)
 {
  m_gameState = GameState::GS_GameOver;
 }
 else
 {
  pickupSpawnThreshold += pickupSpawnAdjustment;
  levelTimer = 0.0f;
  m_gameState = GameState::GS_NextLevel;
 }
}</pre></div><p>As stated previously, we check to see whether the number of pickups that the robot has is less than the <a id="id376" class="indexterm"/>pickup threshold. If so, we change the game state to <code class="literal">GS_GameOver</code>. Otherwise, we reset the level timer, reset the pickups received counter, increment the pickup spawn timer, and set the game state back to <code class="literal">GS_Running</code>.</p><p>We still need to add some code to update the level timer and check to see whether the level is over. Add the following code to the <code class="literal">GS_Running</code> case in the <code class="literal">Update</code> function:</p><div class="informalexample"><pre class="programlisting">levelTimer += p_deltaTime;
if (levelTimer &gt; levelMaxTime)
{
  NextLevel();
}</pre></div><p>This code updates the level timer. If the timer exceeds our threshold, then call <code class="literal">NextLevel</code> to see what happens next.</p><p>Finally, we need to add two lines of code to <code class="literal">CheckCollisions</code> to count the number of pickups received by the player. Add the following highlighted line of code to <code class="literal">CheckCollisions</code>:</p><div class="informalexample"><pre class="programlisting">if (player-&gt;IntersectsCircle(pickup))
{
  pickup-&gt;IsVisible(false);
  pickup-&gt;IsActive(false);
  player-&gt;SetValue(player-&gt;GetValue() + pickup-&gt;GetValue());
  pickupSpawnTimer = 0.0f;
<span class="strong"><strong>  pickupsReceived++;</strong></span>
}

 if (player-&gt;IntersectsRect(enemy))
 {
  enemy-&gt;IsVisible(false);
  enemy-&gt;IsActive(false);
  player-&gt;SetValue(player-&gt;GetValue() + enemy-&gt;GetValue());
  enemySpawnTimer = 0.0f;
  <span class="strong"><strong>enemiesHit++;</strong></span>
 }</pre></div></div><div class="section" title="Game stats"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec100"/>Game stats</h2></div></div></div><p>It would be<a id="id377" class="indexterm"/> nice for the player to be able to see how they did between each level. Let's add a function to display the player stats:</p><div class="informalexample"><pre class="programlisting">void DrawStats()
{
 char pickupsStat[50];
 char enemiesStat[50];
 char score[50];
 sprintf_s(pickupsStat, 50, "Enemies Hit: %i", enemiesHit);
 sprintf_s(enemiesStat, 50, "Pickups: %i", pickupsReceived);
 sprintf_s(score, 50, "Score: %i", player-&gt;GetValue());
 DrawText(enemiesStat, 350.0f, 270.0f, 0.0f, 0.0f, 1.0f);
 DrawText(pickupsStat, 350.0f, 320.0f, 0.0f, 0.0f, 1.0f);
 DrawText(score, 350.0f, 370.0f, 0.0f, 0.0f, 1.0f);
}</pre></div><p>We will<a id="id378" class="indexterm"/> now wire this into the next level screen.</p></div><div class="section" title="The next level screen"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec101"/>The next level screen</h2></div></div></div><p>Now that <a id="id379" class="indexterm"/>we have the logic in place to detect the end of the level, it is time to implement our next level screen. By now, the process should be second nature, so let's try an abbreviated approach:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare a pointer to the screen:<div class="informalexample"><pre class="programlisting">Sprite* nextLevelScreen;</pre></div></li><li class="listitem">Instantiate the sprite in <code class="literal">LoadTextures</code>:<div class="informalexample"><pre class="programlisting">nextLevelScreen = new Sprite(1);
nextLevelScreen-&gt;SetFrameSize(800.0f, 600.0f);
nextLevelScreen-&gt;SetNumberOfFrames(1);
nextLevelScreen-&gt;AddTexture("resources/level.png", false);
nextLevelScreen-&gt;IsActive(true);
nextLevelScreen-&gt;IsVisible(true);</pre></div></li><li class="listitem">Modify the <code class="literal">GS_NextLevel</code> case in the <code class="literal">Update</code> function:<div class="informalexample"><pre class="programlisting"> case GameState::GS_NextLevel:
 {
  nextLevelScreen-&gt;Update(p_deltaTime);
  continueButton-&gt;IsActive(true);
  continueButton-&gt;Update(p_deltaTime);
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
  break;
 }</pre></div></li><li class="listitem">Modify the <code class="literal">GS_NextLevel</code> case in the <code class="literal">Render</code> function to look like the following code::<div class="informalexample"><pre class="programlisting"> case GameState::GS_NextLevel:
 {
  nextLevelScreen-&gt;Render();
  DrawStats();
  continueButton-&gt;Render();
 }
 break;</pre></div></li></ol></div></div><div class="section" title="Continuing the game"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec102"/>Continuing the game</h2></div></div></div><p>Now, we need to add a button that allows the player to continue the game. Again, you have done this so<a id="id380" class="indexterm"/> many times, so we will use a shorthand approach:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare a pointer for the button:<div class="informalexample"><pre class="programlisting">Sprite* continueButton;</pre></div></li><li class="listitem">Instantiate the button in <code class="literal">LoadTextures</code>:<div class="informalexample"><pre class="programlisting">continueButton = new Sprite(1);
continueButton-&gt;SetFrameSize(75.0f, 38.0f);
continueButton-&gt;SetNumberOfFrames(1);
continueButton-&gt;SetPosition(390.0f, 400.0f);
continueButton-&gt;AddTexture("resources/continueButton.png");
continueButton-&gt;IsVisible(true);
continueButton-&gt;IsActive(false);
inputManager-&gt;AddUiElement(continueButton);</pre></div></li><li class="listitem">Add this code to <code class="literal">Update</code>:<div class="informalexample"><pre class="programlisting"> case GameState::GS_NextLevel:
 {
  nextLevelScreen-&gt;Update(p_deltaTime);
<span class="strong"><strong>  continueButton-&gt;IsActive(true);</strong></span>
<span class="strong"><strong>  continueButton-&gt;Update(p_deltaTime);</strong></span>
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;</pre></div></li><li class="listitem">Add this code to <code class="literal">Render</code>:<div class="informalexample"><pre class="programlisting"> case GameState::GS_NextLevel:
 {
  nextLevelScreen-&gt;Render();
  DrawStats();
<span class="strong"><strong>  continueButton-&gt;Render();</strong></span>
 }
 break;</pre></div></li><li class="listitem">Add this code to <code class="literal">ProcessInput</code>:<div class="informalexample"><pre class="programlisting">if (continueButton-&gt;IsClicked())
{
  continueButton-&gt;IsClicked(false);
  continueButton-&gt;IsActive(false);
  m_gameState = GameState::GS_Running;
pickupsReceived = 0;
enemiesHit = 0;
}</pre></div></li></ol></div><p>Clicking the continue button simply changes the game state back to <code class="literal">GS_Running</code>. The level <a id="id381" class="indexterm"/>calculations have already occurred when <code class="literal">NextLevel</code> was called.</p></div></div>
<div class="section" title="Game over"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Game over</h1></div></div></div><p>As the saying goes, all good things must come to an end. If the player doesn't meet the pickup threshold, the <a id="id382" class="indexterm"/>game will end, and the game over screen will be displayed. The player can choose to replay the game or exit.</p><div class="section" title="The game over screen"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec103"/>The game over screen</h2></div></div></div><p>Our last screen is the game over screen. By now, the process should be second nature, so let's try an <a id="id383" class="indexterm"/>abbreviated approach:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare a pointer to the screen:<div class="informalexample"><pre class="programlisting">Sprite* gameOverScreen;</pre></div></li><li class="listitem">Instantiate the sprite in <code class="literal">LoadTextures</code>:<div class="informalexample"><pre class="programlisting">gameOverScreen = new Sprite(1);
gameOverScreen-&gt;SetFrameSize(800.0f, 600.0f);
gameOverScreen-&gt;SetNumberOfFrames(1);
gameOverScreen-&gt;AddTexture("resources/gameover.png", false);
gameOverScreen-&gt;IsActive(true);
gameOverScreen-&gt;IsVisible(true);</pre></div></li><li class="listitem">Change the <code class="literal">GS_GameOver</code> case in the <code class="literal">Update</code> function to look like the following code:<div class="informalexample"><pre class="programlisting"> case GameState::GS_GameOver:
 {
  gameOverScreen-&gt;Update(p_deltaTime);
  replayButton-&gt;IsActive(true);
  replayButton-&gt;Update(p_deltaTime);
  exitButton-&gt;IsActive(true);
  exitButton-&gt;Update(p_deltaTime);
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;</pre></div></li><li class="listitem">Add the following code to <code class="literal">Render</code>:<div class="informalexample"><pre class="programlisting"> case GameState::GS_GameOver:
 {
  gameOverScreen-&gt;Render();
  replayButton-&gt;Render();
  DrawStats();
 }
 break;</pre></div></li></ol></div><p>As a bonus, we will also draw the game stats on the game over screen.</p><div class="mediaobject"><img src="graphics/8199OS_06_09.jpg" alt="The game over screen"/></div></div><div class="section" title="Replaying the game"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec104"/>Replaying the game</h2></div></div></div><p>We need a <a id="id384" class="indexterm"/>way to reset the game to its initial state. So, let's create a function to do this:</p><div class="informalexample"><pre class="programlisting">void RestartGame()
{
   player-&gt;SetValue(0);
 robot_right-&gt;SetValue(0);
 robot_left-&gt;SetValue(0);

pickupSpawnThreshold = 5.0f;
  pickupSpawnTimer = 0.0f;
  enemySpawnThreshold = 7.0f;
  enemySpawnTimer = 0.0f;
  splashDisplayTimer = 0.0f;
  splashDisplayThreshold = 5.0f;
  
  levelTimer = 0.0f;
  
  pickupsReceived = 0;
  pickupsThreshold = 5;
pickupsReceived = 0;
  
  pickup-&gt;IsVisible(false);
  enemy-&gt;IsVisible(false);
  
  background-&gt;SetVelocity(0.0f);
  robot_left-&gt;SetPosition(screen_width / 2.0f - 50.0f, screen_height - 130.0f);
  robot_left-&gt;IsVisible(false);
  
  robot_right-&gt;SetPosition(screen_width / 2.0f - 50.0f, screen_height - 130.0f);
  
  player = robot_right;
  player-&gt;IsActive(true);
  player-&gt;IsVisible(true);
  player-&gt;SetVelocity(0.0f);
}</pre></div><p>Next, we need to add a button that allows the player to replay the game. Again, as you have done this so many times, we will use a shorthand approach:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Declare a pointer for the button:<div class="informalexample"><pre class="programlisting">Sprite* replayButton;</pre></div></li><li class="listitem">Instantiate the button in <code class="literal">LoadTextures</code>:<div class="informalexample"><pre class="programlisting">replayButton = new Sprite(1);
replayButton-&gt;SetFrameSize(75.0f, 38.0f);
replayButton-&gt;SetNumberOfFrames(1);
replayButton-&gt;SetPosition(390.0f, 400.0f);
replayButton-&gt;AddTexture("resources/replayButton.png");
replayButton-&gt;IsVisible(true);
replayButton-&gt;IsActive(false);
inputManager-&gt;AddUiElement(replayButton);</pre></div></li><li class="listitem">Add the<a id="id385" class="indexterm"/> following code to <code class="literal">Update</code>:<div class="informalexample"><pre class="programlisting">case GameState::GS_GameOver:
 {
  gameOverScreen-&gt;Update(p_deltaTime);
  replayButton-&gt;IsActive(true);
  replayButton-&gt;Update(p_deltaTime);
  exitButton-&gt;IsActive(true);
  exitButton-&gt;Update(p_deltaTime);
  inputManager-&gt;Update(p_deltaTime);
  ProcessInput(p_deltaTime);
 }
 break;</pre></div></li><li class="listitem">Add the following code to <code class="literal">Render</code>:<div class="informalexample"><pre class="programlisting"> case GameState::GS_GameOver:
 {
  gameOverScreen-&gt;Render();
  replayButton-&gt;Render();
  DrawStats();
 }
 break;</pre></div></li><li class="listitem">Add the following code to <code class="literal">ProcessInput</code>:<div class="informalexample"><pre class="programlisting">if (replayButton-&gt;IsClicked())
{
  replayButton-&gt;IsClicked(false);
  replayButton-&gt;IsActive(false);
  exitButton-&gt;IsActive(false);
  RestartGame();
  m_gameState = GameState::GS_Running;
}</pre></div></li></ol></div><p>Notice how we are reusing the exit button in the <code class="literal">Update</code> function. Also, if the player wants to replay the game, we call the <code class="literal">RestartGame</code> function when the player clicks the replay button. This resets all of the game variables and allows the player to start all over.</p><div class="mediaobject"><img src="graphics/8199OS_06_07.jpg" alt="Replaying the game"/></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Summary</h1></div></div></div><p>We covered a lot of ground in this chapter. The focus of the chapter is to add all of the final elements to the game that make it a truly polished game. This involves adding a lot of screens and buttons, and to manage all of this, we introduced a more advanced state machine. The state machine acts like a traffic director, routing the game to the correct routines depending on the game state.</p><p>In the next chapter, we will add sound effects and music to our game!</p></div></body></html>