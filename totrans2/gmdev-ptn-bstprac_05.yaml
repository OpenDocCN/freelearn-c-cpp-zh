- en: Decoupling Code via the Factory Method Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过工厂方法模式解耦代码
- en: Every project and every game design is going to change. One of the goals of
    object-oriented programming is to program with that change in mind. This means
    writing flexible and reusable code so that, when changes happen, the project doesn't
    fall apart. Unfortunately, the requirements are never fully known and the vision
    of the designer is never 100% complete. The good news is that newly added features
    may interact with old features in unexpectedly fun ways, leading to unplanned
    features being created, which can make for a completely different, and more enjoyable,
    game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目和每个游戏设计都会发生变化。面向对象编程的一个目标就是考虑到这种变化来编程。这意味着编写灵活且可重用的代码，以便当发生变化时，项目不会崩溃。不幸的是，需求永远不会完全清楚，设计师的愿景也永远不会100%完整。好消息是，新添加的功能可能会以意想不到的有趣方式与旧功能交互，从而产生未计划的功能，这可以使游戏完全不同，并且更加有趣。
- en: In the worst-case scenario, the game design may not be fun at all, which can
    lead to drastic changes in game object types, object behaviors, and even the design
    of the entire game. In this case, we want to be able to rework our game to try
    new possibilities with the least amount of change to code. Changing code takes
    time to write, test, and debug, and any time new code is added, it has the possibility
    of causing bugs in older code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，游戏设计可能根本不好玩，这可能导致游戏对象类型、对象行为甚至整个游戏设计的巨大变化。在这种情况下，我们希望能够以最小的代码更改重新设计我们的游戏，以尝试新的可能性。更改代码需要时间来编写、测试和调试，并且每次添加新代码时，都有可能造成旧代码中的错误。
- en: Since we know that our design will change, we must plan for that change by following
    good design principles and utilizing design patterns to solve common problems.
    This includes using flexible designs such as the Component Object Model to avoid
    inheritance hierarchies. This includes using the State pattern and finite state
    machines to avoid complex `if` statements and cascading `if else` chains that
    lead to bugs any time a change occurs. This also includes things such as striving
    for low coupling and avoiding *hardcoding* anything.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道我们的设计将会改变，我们必须通过遵循良好的设计原则和利用设计模式来解决常见问题来为这种变化做出规划。这包括使用灵活的设计，如组件对象模型，以避免继承层次结构。这还包括使用状态模式和有限状态机来避免复杂的`if`语句和导致每次变化时出现错误的级联`if
    else`链。这还包括诸如努力降低耦合度并避免*硬编码*任何事情。
- en: We all know that as programmers, we should avoid *magic numbers*. We don't want
    to see seemingly random or odd numbers in our code. A hardcoded number isn't descriptive
    enough, which makes the code hard to read, maintain, and debug. If we need to
    change a magic number, we have to spend time searching our code for every time
    it appears. Unfortunately, these hardcoded values tend to change a lot during
    development. In the real world, gravity may be 9.8 m/s², but in the game world,
    we may need to adjust it so the game is more fun, or possibly change it at runtime
    so the player can walk on the ceiling.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，作为程序员，我们应该避免*魔法数字*。我们不希望在我们的代码中看到看似随机或奇怪的数字。硬编码的数字描述性不足，这使得代码难以阅读、维护和调试。如果我们需要更改魔法数字，我们必须花费时间在我们的代码中搜索它每次出现的地方。不幸的是，这些硬编码的值在开发过程中往往会频繁更改。在现实世界中，重力可能是9.8
    m/s²，但在游戏世界中，我们可能需要调整它，以便游戏更有趣，或者可能在运行时更改它，以便玩家可以在天花板上行走。
- en: When we think about hard coding, we usually think about magic numbers. However,
    a call to the `new` operator using a concrete class type such as a new `ChaseAIComponent`
    may be readable, but it is just as likely to change as the value of gravity or
    the size of an array.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑硬编码时，我们通常会想到魔法数字。然而，使用具体类类型（如新的`ChaseAIComponent`）调用`new`运算符可能是可读的，但它与重力值或数组大小一样可能发生变化。
- en: Chapter overview
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节概述
- en: In this chapter, you will be focusing on a common interface to create new objects
    without the need to call constructors directly. First, we will look at reasons
    why a `switch` statement can be harmful. Next we will look at a design principle
    that leads us to our final solution, a factory. Then we will look at few different
    ways to design our factories to make them flexible and reusable.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将专注于一个常见的接口来创建新对象，而无需直接调用构造函数。首先，我们将探讨为什么`switch`语句可能是有害的。接下来，我们将探讨一个设计原则，它引导我们到达最终的解决方案，即工厂。然后，我们将探讨几种不同的设计工厂的方法，使它们灵活且可重用。
- en: Your objective
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的目标
- en: 'Over the course of this chapter, we will be looking at a few more important
    concepts and principles that can make our programs better. Here is an outline
    of what we will cover and your tasks for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将探讨一些更多的重要概念和原则，这些可以使我们的程序变得更好。以下是本章我们将涵盖的内容和你的任务概述：
- en: Learning why using `switch` statements can be bad
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习为什么使用`switch`语句可能不好
- en: Learning the Dependency Inversion Principle
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习依赖倒置原则
- en: Learning the Factory Method pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习工厂方法模式
- en: Building a Component, Stage, and Object Factory
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建组件、阶段和对象工厂
- en: Improve your Factories by using templates
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用模板改进你的工厂
- en: The trouble with switch statements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`switch`语句的问题'
- en: 'When first learning to program, simply understanding the grammar of the language
    is very difficult. Often, new programmers focus on the syntax of a function call
    or `for` loop and they don''t even think about making reusable, maintainable code.
    This is partly because they jump into the coding without planning anything out.
    This is true for games as well. Often, new programmers want to get straight to
    writing the game and they forget about things such as user interface and pause
    menus. Things such as the window resolution, enemy placement in the stages, and
    even where the mouse should be when clicking buttons will be hardcoded. Here is
    code from one of the authors'' first games. This was a section in the `MainMenu`
    function that would switch the game into the Load state when the button was clicked.
    The variable `p` is the location of the mouse:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当刚开始学习编程时，仅仅理解语言的语法是非常困难的。通常，新手程序员会专注于函数调用或`for`循环的语法，甚至不会考虑编写可重用、可维护的代码。这主要是因为他们在没有规划的情况下直接开始编码。这一点在游戏开发中也是如此。新手程序员往往想直接编写游戏，而忘记了诸如用户界面和暂停菜单等问题。诸如窗口分辨率、阶段中敌人的放置，甚至点击按钮时鼠标应该在哪里，都会被硬编码。以下是作者第一个游戏中的一段代码。这是`MainMenu`函数中的一个部分，当按钮被点击时会将游戏切换到加载状态。变量`p`是鼠标的位置：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Code similar to this was repeated (without a loop) four times, because there
    were four buttons in the `MainMenu`. Of course, there were better (much better)
    ways to write this code. It is important to separate game stages from the `Graphics`
    class for one, and buttons can manage themselves if they are written correctly.
    However, the worst part of this old code base was how game stages were changed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与此类似的代码重复了四次（没有使用循环），因为`MainMenu`中有四个按钮。当然，有更好的（要好得多）编写这段代码的方法。首先，重要的是将游戏阶段与`Graphics`类分开，其次，如果编写得当，按钮可以自我管理。然而，这个旧代码库最糟糕的部分是游戏阶段的变化方式。
- en: 'In that game, there was an `Update` function in the `Engine` class that contained
    a 507-line-long `switch` statement. This included a `switch` within a `switch`
    for situations where there needed to be a menu stage, but there were multiple
    menus to choose from. Here is some sample code from when a level needed to be
    loaded:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个游戏中，`Engine`类中有一个名为`Update`的函数，包含了一个507行的`switch`语句。这包括了一个嵌套的`switch`语句，用于需要菜单阶段但可以选择多个菜单的情况。以下是当需要加载关卡时的部分代码示例：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you feel like that is hard to look at, you are right. For some reason, the
    stage-switching code was responsible for setting the player's health and position,
    moving the camera, setting the background texture, and going back to the menu
    if something failed to load.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这很难看，你是对的。由于某种原因，阶段切换代码负责设置玩家的健康和位置，移动摄像头，设置背景纹理，如果加载失败则返回菜单。
- en: The reason we are showing this is so you can see an example of really bad code.
    This `Engine` class was tightly coupled with the `graphics` class, the `physics`
    class, the `object manager` class, and the `player` class. If any of these classes
    changed or were removed, the code in the `Engine` class needed to change. Another
    problem is that there are many dependencies here, which means a change to any
    of the classes above will cause the code to be recompiled as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示这个例子是为了让你看到真正糟糕的代码。这个`Engine`类与`graphics`类、`physics`类、`object manager`类和`player`类紧密耦合。如果这些类中的任何一个发生变化或被删除，`Engine`类中的代码也需要更改。另一个问题是这里有许多依赖关系，这意味着上述任何类的更改都会导致代码重新编译。
- en: One of the authors was in a similar situation a few years later while working
    on an iPhone game as contract programmer. The original design called for only
    two stages, the main menu and the gameplay. Since the plan was so simple, code
    similar to what we saw above was used. This soon became a problem, because all
    game designs change even if the project is only three months long.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后，其中一位作者在担任iPhone游戏合同程序员时遇到了类似的情况。最初的设计只要求两个阶段，即主菜单和游戏玩法。由于计划非常简单，因此使用了类似于我们上面看到的代码。这很快变成了一个问题，因为即使项目只有三个月，所有的游戏设计都会发生变化。
- en: After one month, the game was completed to specification, including a level
    editor so the designer could create as many levels as were needed. The goal was
    to spend the rest of the time adding effects and polish to the game. However,
    every week, the producer and designer would come and say they needed a new menu
    or transition screen.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个月后，游戏按照规格完成，包括一个关卡编辑器，以便设计师可以创建所需的所有关卡。目标是花剩下的时间添加效果和润色游戏。然而，每周，制作人都会来要求添加新的菜单或过渡屏幕。
- en: 'In the end, the game design called for an options menu, a level select menu,
    a credits screen, a celebration screen every 10 levels, and a congratulations
    screen after completing the game. The simple two-stage code that was originally
    written ended up being a hacked-together mess because of the fast development
    timeline and the constant addition of new features. One horrible line of code
    was similar to this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，游戏设计要求有一个选项菜单、一个关卡选择菜单、一个致谢屏幕、每10个关卡一个庆祝屏幕，以及完成游戏后的祝贺屏幕。最初编写的简单两个阶段的代码最终因为快速的开发时间表和不断添加的新功能而变得一团糟。有一行糟糕的代码类似于以下内容：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This *worked* because there were 80 levels in the game and the `levelCounter`
    incremented after completing a level. After seeing game code like this, we hope
    you understand why it is important to plan for change to occur.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为游戏中共有80个关卡，`levelCounter`在完成一个关卡后会递增。在看到这样的游戏代码后，我们希望您能理解为什么规划变化发生的重要性。
- en: 'In [Chapter 3](part0064.html#1T1400-04600e4b10ea45a2839ef4fc3675aeb7), *Creating
    Flexibility with the Component Object Model*, we saw how to create components
    for our game object so we can easily handle changes to our object design. This
    is an important step in creating flexible code; however, when we create an object
    in our stage, we still must use new to hardcode the concrete types that make up
    our object:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0064.html#1T1400-04600e4b10ea45a2839ef4fc3675aeb7)，“使用组件对象模型创建灵活性”中，我们看到了如何为我们的游戏对象创建组件，以便我们能够轻松处理对象设计的更改。这是创建灵活代码的重要步骤；然而，当我们在我们阶段创建对象时，我们仍然必须使用`new`来硬编码构成我们的对象的具体类型：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This means that our derived `M5Stage` class is tightly coupled to the components
    of this object type, and really all object types that need to be created in this
    level. If the objects need different components, or any of the components are
    changed or removed, then our `Stage` class must be changed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的派生`M5Stage`类与该对象类型的组件紧密耦合，实际上是与需要在此级别创建的所有对象类型紧密耦合。如果对象需要不同的组件，或者任何组件被更改或删除，那么我们的`Stage`类必须进行更改。
- en: 'One way to *solve* this (as we saw in [Chapter 3](part0064.html#1T1400-04600e4b10ea45a2839ef4fc3675aeb7),
    *Creating Flexibility with the Component Object Model*) is to put this code into
    our `M5ObjectManager` class. This way, our stages don''t need to be constantly
    updated as our types are modified:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法（正如我们在[第3章](part0064.html#1T1400-04600e4b10ea45a2839ef4fc3675aeb7)，“使用组件对象模型创建灵活性”中看到的）是将此代码放入我们的`M5ObjectManager`类中。这样，我们的阶段就不需要随着类型的修改而不断更新：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This solves the problem of needing to change our stages whenever an object is
    changed. However, we will still have to change our `switch` statement and the
    object manager if our objects or components change. Actually, except for this
    function, the Object Manager doesn't really care about any derived component types.
    It only needs to be dependent on the `M5Component` abstract class. If we can fix
    this function, we can completely decouple our derived component types from this
    class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了在对象更改时需要更改我们的阶段的问题。然而，如果我们的对象或组件发生变化，我们仍然需要更改我们的`switch`语句和对象管理器。实际上，除了这个函数外，对象管理器并不真正关心任何派生组件类型。它只需要依赖于`M5Component`抽象类。如果我们能修复这个函数，我们就可以完全将派生组件类型与这个类解耦。
- en: The solution to our problem is the same solution used to solve the stage management
    problem I faced years ago, *the Dependency Inversion Principle*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 解决我们问题的方案与解决我多年前面临的阶段管理问题的方案相同，即*依赖倒置原则*。
- en: The Dependency Inversion Principle
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: 'The concept of avoiding `concreate` classes isn''t new. Robert C. Martin defined
    this idea in *The C++ Report* in May 1996 in an article titled *The Dependency
    Inversion Principle*. It is the D in his SOLID design principles. The principle
    has two parts:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 避免具体类的概念并不新鲜。Robert C. Martin在1996年5月的《C++ Report》杂志上发表了一篇题为《依赖倒置原则》的文章，定义了这个想法。这是他SOLID设计原则中的D。这个原则有两个部分：
- en: High-level modules should not depend on low-level modules. Both should depend
    on abstractions.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级模块不应依赖于低级模块。两者都应依赖于抽象。
- en: Abstractions should not depend on details. Details should depend on abstractions.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象不应依赖于细节。细节应依赖于抽象。
- en: While this may seem like a mouthful, the concept is actually very easy. Imagine
    we have a `StageManager` class that is responsible for initializing, updating,
    and shutting down all of the stages in our game. In this case, our `StageManager`
    is our high-level modules, and the stages are the low-level modules. The `StageManager`
    will control the creation and behavior of our low-level module, the stages. This
    principle says that our `StageManager` code shouldn't depend on derived stage
    classes, but should instead depend on an abstract stage class. To see why, let's
    look at an example of not following this principle.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这听起来可能很多，但这个概念实际上非常简单。想象一下，我们有一个`StageManager`类，它负责初始化、更新和关闭我们游戏中所有的阶段。在这种情况下，我们的`StageManager`是高级模块，而阶段是低级模块。`StageManager`将控制低级模块，即阶段的创建和行为。这个原则说，我们的`StageManager`代码不应该依赖于派生阶段类，而应该依赖于一个抽象阶段类。为了了解为什么，让我们看看不遵循此原则的一个例子。
- en: 'Here our `StageManager` has a function called `Update`, which looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的`StageManager`有一个名为`Update`的函数，其代码如下：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Of course, this is just the first level of our game, so we will need to include
    code to update the main menu, and the second level of our game. Since these classes
    are unrelated, we will need a `switch` statement to make a choice between stages:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是我们游戏的第一级，因此我们需要包含代码来更新主菜单和游戏的第二级。由于这些类是无关的，我们需要一个`switch`语句来在阶段之间做出选择：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can see that as we continue to add more and more levels, this code will
    get large very fast and it will quickly become impossible, or just really difficult
    to maintain. This is because we will need to go into this function and remember
    to update the `switch` statement every time a new stage is added to the game.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，随着我们继续添加越来越多的关卡，这段代码会迅速变得很大，很快就会变得难以维护。这是因为每次游戏中添加新的阶段时，我们都需要进入这个函数并记得更新`switch`语句。
- en: 'The first part of this section, tells us that that our `StageManager` class
    shouldn''t depend on levels or menus, but should instead depend on a common abstraction.
    That means that we should create an abstract base class for all of our stages.
    The second part says that the abstraction shouldn''t care whether the stage is
    a level or a menu. In fact, it shouldn''t even care that we are making a stage
    for a space shooter game, a platformer, or a racing game. A major benefit of using
    this principle, besides having more flexible code, is that our `StageManager`
    class will no longer depend on anything in this specific game, so we can reuse
    it for our next project:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的第一部分告诉我们，我们的`StageManager`类不应该依赖于关卡或菜单，而应该依赖于一个公共抽象。这意味着我们应该为所有阶段创建一个抽象基类。第二部分表示，抽象不应该关心阶段是关卡还是菜单。实际上，它甚至不应该关心我们正在为太空射击游戏、平台游戏或赛车游戏制作阶段。使用此原则的主要好处之一，除了代码更加灵活外，就是我们的`StageManager`类将不再依赖于这个特定游戏中的任何内容，因此我们可以将其用于我们的下一个项目：
- en: '![](img/00039.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: StageManager depends on specific classes
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: StageManager依赖于特定的类
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/00040.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00040.jpeg)'
- en: StageManager only depends on abstraction
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: StageManager只依赖于抽象
- en: Now the `Update` function of `StageManager` is much simpler. Since we are only
    dependent on the abstract class, our code no longer needs to change based on derived
    implementations. We have also simplified the interface of all stages. The functions
    of each stage no longer change based on the details of the class (menu, level,
    and so on); instead, they all share a common interface. As you can see, knowing
    about the Dependency Inversion Principle will not only make you a big hit at parties,
    it will also allow you to decouple your code base and reuse higher-level modules.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`StageManager` 的 `Update` 函数变得更加简单。由于我们只依赖于抽象类，我们的代码不再需要根据派生实现进行更改。我们还简化了所有阶段的接口。每个阶段的函数不再根据类的细节（菜单、等级等）进行更改；相反，它们都共享一个公共接口。正如你所看到的，了解依赖倒置原则不仅会在聚会上让你成为焦点，它还将允许你解耦代码库并重用高级模块。
- en: We still have the problem of selecting the correct derived class. We don't want
    to put a `switch` statement in the `Update` function of `StageManager`. If we
    do that, we will have dependency problems like before. Instead, we need a way
    to select the correct derived class while depending only on the base class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然面临选择正确派生类的问题。我们不想在 `StageManager` 的 `Update` 函数中放置 `switch` 语句。如果我们这样做，我们将会遇到之前的问题。相反，我们需要一种方法来选择正确的派生类，同时只依赖于基类。
- en: The Factory method pattern
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法模式
- en: The Factory method pattern is exactly the design pattern we need to solve our
    problem. The purpose of this pattern is to have a way of creating the derived
    class that we want without needed to specify the `concreate` class in our high-level
    module. This is done by defining an interface for creating objects, but letting
    subclasses decide which class to instantiate.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式正是我们解决问题的关键设计模式。该模式的目的在于提供一种创建我们想要的派生类的方法，而无需在我们的高级模块中指定具体的 `concreate`
    类。这是通过定义一个创建对象的接口来实现的，但让子类决定实例化哪个类。
- en: 'In our case, we will create a `StageFactory` interface with a method called
    `Build` that will return a `Stage*`. We can then create subclasses such as `Level2Factory`
    to instantiate our derived classes. Our `StageManager` class now only needs to
    know about the `Stage` and `StageFactory` abstractions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将创建一个名为 `StageFactory` 的接口，其中包含一个名为 `Build` 的方法，该方法将返回一个 `Stage*`。然后我们可以创建如
    `Level2Factory` 这样的子类来实例化我们的派生类。现在我们的 `StageManager` 类只需要了解 `Stage` 和 `StageFactory`
    抽象：
- en: '![](img/00041.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.jpeg)'
- en: Creating a Stage Factory
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个阶段工厂
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we have moved the call to new from our `StageManager::Update` function
    into derived `StageFactory` methods. We have successfully decoupled our `StageManager`
    from our derived `Stage` classes. However, the call to `Build` represents the
    creation of only one derived `Stage` class. We still need a way to choose which
    derived `Stage` we want to use and which derived `StageFactory` we need to instantiate.
    We need a way to choose between different types of factories. Before we look at
    the solution that was used in the Mach5 Engine, let's look at an alternative Factory
    method, the Static Factory.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将 `new` 的调用从 `StageManager::Update` 函数移动到了派生的 `StageFactory` 方法中。我们已经成功地将
    `StageManager` 与派生的 `Stage` 类解耦。然而，对 `Build` 的调用仅代表创建了一个派生的 `Stage` 类。我们仍然需要一个方法来选择我们想要使用的派生
    `Stage` 以及需要实例化的派生 `StageFactory`。我们需要一种方法来选择不同类型的工厂。在我们查看 Mach5 引擎中使用的解决方案之前，让我们看看另一种工厂方法，即静态工厂。
- en: The Static Factory
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态工厂
- en: 'The simplest way to implement a factory method the way we want is with either
    a global function or a static class function. We could define a function called
    `MakeStage` outside of `StateMananger` that is responsible for instantiating the
    correct derived type based on a parameter. In this case, we will use an `enum`
    called `StageType` to help us choose our correct type:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们想要的方式实现工厂方法的最简单方法是使用全局函数或静态类函数。我们可以在 `StateMananger` 之外定义一个名为 `MakeStage`
    的函数，该函数负责根据参数实例化正确的派生类型。在这种情况下，我们将使用一个名为 `StageType` 的 `enum` 来帮助我们选择正确的类型：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we use this style of factory, our `StageManager::Update` function will look
    like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这种风格的工厂，我们的 `StageManager::Update` 函数将看起来像这样：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This version of the factory method works exactly as we want. We can now choose
    which derived `Stage` class is instantiated. We still have a switch statement
    that we must maintain, but at least our higher-level module is no longer dependent
    on derived classes. In the default case, where our `switch` statement can't match
    the correct type, we are left with the choice of using an assert to crash the
    program, throwing an exception and letting the client resolve the issue, or perhaps
    returning null, which still gives responsibility to the client.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的工厂方法正好符合我们的需求。我们现在可以选择实例化哪个派生的 `Stage` 类。我们仍然有一个必须维护的 switch 语句，但至少我们的高级模块不再依赖于派生类。在默认情况下，当我们的
    `switch` 语句无法匹配正确的类型时，我们只剩下使用 assert 使程序崩溃、抛出异常并让客户端解决问题，或者返回 null，这仍然将责任留给了客户端。
- en: The Static Factory successfully decouples our `StageManager` class from specific
    derived `Stage` classes, while allowing us to choose which stage will be instantiated
    at runtime. This is great, but as I said, this isn't how the Mach5 Engine implements
    `Stage` or component factories. Instead, Mach5 uses a more dynamic solution, so
    we will call it the Dynamic Factory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 静态工厂成功地将我们的 `StageManager` 类与特定的派生 `Stage` 类解耦，同时允许我们在运行时选择要实例化的阶段。这很好，但正如我所说的，Mach5
    引擎并不是这样实现 `Stage` 或组件工厂的。相反，Mach5 使用了一个更动态的解决方案，因此我们将它称为动态工厂。
- en: The Dynamic Factory
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态工厂
- en: While the Static Factory is simple enough for our purpose, the Mach5 Engine
    uses a different approach. This approach combines the polymorphic solution of
    the classic Factory method with the selection capability of the Static Factory.
    This new approach uses a searchable collection of derived `StageFactory` classes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然静态工厂对于我们的目的来说足够简单，但 Mach5 引擎采用了不同的方法。这种方法结合了经典工厂方法的泛型解决方案和静态工厂的选择能力。这种新的方法使用了一个可搜索的派生
    `StageFactory` 类集合。
- en: Remember that problem with the classic Factory method is that the method represents
    only one class to instantiate. This allows our code to be flexible because we
    don't depend on a derived `Stage` class or a call to the `new` operator. However,
    we still needed a way to get specific derived `StageFactory` instances.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，经典工厂方法的问题在于该方法只代表一个要实例化的类。这使我们的代码更加灵活，因为我们不依赖于派生的 `Stage` 类或 `new` 操作符的调用。然而，我们仍然需要一个方法来获取特定的派生
    `StageFactory` 实例。
- en: 'In the Mach5 Engine, the names are changed a little. There is only one `StageFactory`
    class, which contains a collection of `M5StageBuilder` pointers (these are classic
    Factories), which implement a `Build` method. The design looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mach5 引擎中，名称有所改变。只有一个 `StageFactory` 类，它包含一个 `M5StageBuilder` 指针集合（这些是经典的工厂），这些指针实现了
    `Build` 方法。设计看起来是这样的：
- en: '![](img/00042.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: Design of Dynamic Factory
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 动态工厂的设计
- en: 'The first class we want to see is the base `M5Stage` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想看到的是基类 `M5Stage`：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The base `M5Stage` class is a pretty simple abstract base class with a virtual
    destructor. The specific virtual functions in `M5Stage` aren't important for the
    details of the factory. We are simply showing the class here, because the `M5StageManager`
    and `M5StageFactory` will be using this abstraction.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 基类 `M5Stage` 是一个相当简单的抽象基类，具有虚拟析构函数。`M5Stage` 中的特定虚拟函数对于工厂的细节并不重要。我们在这里展示这个类，因为
    `M5StageManager` 和 `M5StageFactory` 将会使用这个抽象。
- en: C++ classes intended for polymorphic use, including abstract base classes, should
    always implement a virtual destructor, otherwise the correct derived class destructor
    cannot be called.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 用于多态使用的 C++ 类，包括抽象基类，应始终实现虚拟析构函数，否则无法调用正确的派生类析构函数。
- en: Creating our Stage Builders
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的舞台构建器
- en: Next let's look at our base builder class. Notice that this is the same type
    of interface that would be used in the classic Factory method pattern. This abstraction
    declares a method that returns another abstraction, in this case `M5Stage`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看看我们的基构建器类。注意，这和经典工厂方法中会使用的接口类型相同。这种抽象声明了一个返回另一个抽象的方法，在这种情况下是 `M5Stage`。
- en: 'Just like before, we need to have an empty virtual destructor so when we use
    this class in a polymorphic way, the correct destructor will be called. Also like
    before, the other methods are marked as purely `virtual,` which disallows direct
    instantiation of this class. That means we cannot create an `M5StageBuilder` directly.
    We must derive from it, and implement the pure virtual methods:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们需要有一个空的虚拟析构函数，这样当我们以多态方式使用这个类时，就会调用正确的析构函数。同样，其他方法也被标记为纯虚拟的，这禁止了直接实例化这个类。这意味着我们不能直接创建一个`M5StageBuilder`。我们必须从它派生出来，并实现纯虚拟方法：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Even though the name is different, this is how the classic Factory method would
    be implemented. The Mach5 Engine calls this a *Builder* instead of a *Factory*
    but it is only a change in the name and not the functionality. The name of the
    `Build` method isn't important. Some programs will call the method `Create` or
    `Make`. Mach5 calls it `Build` but any of these names are fine.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 即使名称不同，这也是经典工厂方法实现的途径。Mach5 引擎将其称为*Builder*而不是*Factory*，但这只是名称上的变化，并没有改变功能。`Build`方法的名字并不重要。有些程序会把这个方法称为`Create`或`Make`。Mach5
    称其为`Build`，但任何这些名称都是可以的。
- en: 'No matter what the name is, a user creating a game with the Mach5 Engine would
    want to derive their own specific stage builders for the stages in their game.
    For this book, we have stages for a space shooter game called `AstroShot`. In
    order to make builders for these stages, we need to derive from `M5StageBuilder`
    and implement the `Build` method. For example, if we had `M5Stage` derived classes
    called `SplashStage` and `MainMenuStage`, we would create builders like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 无论名称如何，使用Mach5引擎创建游戏的用户都希望为游戏中的各个阶段创建自己的特定阶段构建器。对于这本书，我们有名为`AstroShot`的空间射击游戏阶段。为了为这些阶段创建构建器，我们需要从`M5StageBuilder`派生并实现`Build`方法。例如，如果我们有名为`SplashStage`和`MainMenuStage`的`M5Stage`派生类，我们会创建如下所示的构建器：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note here that the use of the keyword `virtual` in the derived classes is completely
    optional. In the pre C++ 11 days, programmers would mark the function `virtual`
    as a form of documentation to other programmers. These days, you can add the override
    specifier to a virtual function so the compiler can issue an error if the function
    isn't a true override.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里使用关键字`virtual`在派生类中是完全可选的。在C++ 11之前的日子里，程序员会将函数标记为`virtual`作为一种对其他程序员的文档说明。如今，你可以在虚拟函数上添加`override`指定符，这样编译器就会在函数不是真正的重写时发出错误。
- en: To some, this might seem a little tedious. In fact, the biggest complaint I
    hear from people first learning about object-oriented programming is that they
    feel like they waste a lot time creating many files with small classes in them.
    To them, it feels like a lot of work for very little pay-off.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对一些人来说，这可能会显得有些繁琐。实际上，我听到的关于面向对象编程初学者的最大抱怨是他们感觉像是在创建很多包含小类的文件上浪费了大量的时间。对他们来说，这感觉像是做了很多工作，但回报甚微。
- en: I agree that programming this way can require lots of files and lots of little
    classes. However, I disagree with it being a waste of time. I think these arguments
    are a result of shortsighted thinking. They are only thinking of the time it takes
    to write the original code, but they aren't thinking about the time it will save
    when making changes to the design or the time it will take to test and debug.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我同意以这种方式编程可能需要很多文件和很多小的类。然而，我不同意这是浪费时间。我认为这些论点是由于短视的思考而产生的。他们只考虑编写原始代码所需的时间，但没有考虑到在设计变更时节省的时间，以及测试和调试所需的时间。
- en: It doesn't take much time to create new files. With an integrated development
    environment such as Visual Studio, it takes less than 10 seconds to create a source
    and header file. Writing small classes such as the builders above doesn't take
    much time either. In total, writing these two classes takes less than five minutes.
    Of course, this is more than directly writing new into a high-level module, but
    remember that the goal is to write code that can adapt to change in our game design.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新文件并不需要花费太多时间。使用像Visual Studio这样的集成开发环境，创建源文件和头文件只需要不到10秒钟。编写像上面那样的小型类也不需要花费太多时间。总共，编写这两个类不到五分钟。当然，这比直接在一个高级模块中写入新内容要花更多时间，但记住，我们的目标是编写能够适应我们游戏设计变化的代码。
- en: These shortsighted arguments are similar to the complaints of new programmers
    learning to write functions. We have already discussed the benefits of writing
    functions and those same benefits apply here. We shouldn't think only of the time
    it takes to write the initial code. We need to factor in how long it will take
    to test and debug the code, how likely it is to introduce new bugs into old code,
    how long it will take to modify if our design changes a month or year from now,
    and if the design does change, how likely is it that modifying our code will introduce
    bugs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些短视的论点与新程序员学习编写函数时的抱怨相似。我们已经讨论了编写函数的好处，同样的好处也适用于这里。我们不应该只考虑编写初始代码所需的时间。我们需要考虑测试和调试代码所需的时间，引入新错误到旧代码中的可能性，如果我们的设计在一个月或一年后发生变化，修改所需的时间，以及如果设计发生变化，修改我们的代码引入错误的可能性有多大。
- en: It is important to understand that by using design patterns we are writing more
    code upfront, so that we can cut down on the time it takes to test, debug, integrate,
    maintain, and change our code in the future. It is important to understand that
    writing the original code is easy and cheap, while changing it later is much harder
    and more expensive. In this case, cheap and expensive could be referring to hours
    worked or money spent paying programmers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，通过使用设计模式，我们在一开始就需要编写更多的代码，这样我们才能减少未来测试、调试、集成、维护和更改我们代码所需的时间。重要的是要理解，编写原始代码是容易且成本低的，而稍后更改它则要困难得多，成本也更高。在这种情况下，“便宜”和“昂贵”可能是指工作小时数或支付程序员的费用。
- en: The template builder
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板构建器
- en: 'Those worried about writing a lot of little classes are in luck. Most, if not
    all, of our builders will be the same except for the specific derived class they
    instantiate. That means we can use the power of C++ templates to create builders
    for us. Our templated builder will look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 担心编写大量小类的人有运气。大多数，如果不是所有，我们的构建器除了它们实例化的具体派生类之外都是相同的。这意味着我们可以使用 C++ 模板的力量为我们创建构建器。我们的模板构建器将看起来像这样：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code works great for most of our stages. The only time it doesn't work
    is when we need to do something more specific, such as call a non-default constructor,
    or a function specific to the derived stage.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对我们大多数阶段都工作得很好。唯一不工作的时候是我们需要做更具体的事情，比如调用非默认构造函数，或者调用特定于派生阶段的函数。
- en: 'Notice that the implementation of the `Build` function is also included in
    the `.h` file. This is because `template` functions are not the same as regular
    functions. They work as recipes so the compiler knows how to generate the function
    for the specific type. Each time we need to use this function, the compiler will
    need to know about the recipe. This allows the compiler to instantiate the function
    as opposed to requiring the user to explicitly instantiate the `Builder` classes
    they need before using them. So when we want to use this class, it will look something
    like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `Build` 函数的实现也包含在 `.h` 文件中。这是因为模板函数与常规函数不同。它们作为配方工作，以便编译器知道如何为特定类型生成函数。每次我们需要使用这个函数时，编译器都需要知道这个配方。这使得编译器能够实例化函数，而不是要求用户在使用之前明确实例化所需的
    `Builder` 类。因此，当我们想要使用这个类时，它看起来可能像这样：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Creating the Dynamic Factory class
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动态工厂类
- en: 'So far, we have only created our builders, which are equivalent to the classic
    Factory method pattern. However, we haven''t seen the Factory part of the Dynamic
    Factory. Let''s look at how the Mach5 Engine implements the `StageFactory` class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只创建了我们的构建器，它们相当于经典的工厂方法模式。然而，我们还没有看到动态工厂的工厂部分。让我们看看 Mach5 引擎是如何实现 `StageFactory`
    类的：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, `M5StageFactory` isn't a very complicated class. Once you understand
    the design behind the patterns, implementing them is usually not very difficult.
    As for this class, it is only five methods and one member. The private section
    looks a little complicated because Mach5 prefers using a `typedef` for templated
    containers. Since the container is used in all of the private functions, let's
    look at the member before exploring the five methods.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`M5StageFactory` 并不是一个非常复杂的类。一旦您理解了模式背后的设计，实现它们通常并不困难。至于这个类，它只有五个方法和一个成员。私有部分看起来有点复杂，因为
    Mach5 倾向于使用 `typedef` 为模板容器。由于容器在所有私有函数中都被使用，让我们在探索五个方法之前先看看这个成员。
- en: 'Let''s first look the `typedefs`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看 `typedefs`：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since we want a container of `M5StageBuilders`, we have a few choices. We could
    use an STL vector or list, but those containers are not ideal for searching because
    of the potential lack of efficiency if we have many builders. However, this is
    exactly what the STL map and `unordered_map` are perfect for. They allow us to
    save key/value pairs and later use the key to efficiently find the value, even
    if we had thousands of builders. We will use the `M5StageTypes``enum` as our key,
    and use a derived `M5StageBuilder*` as our value.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要一个 `M5StageBuilders` 的容器，我们有几种选择。我们可以使用 STL 向量或列表，但那些容器由于潜在的低效性并不适合搜索，如果我们有很多构建器的话。然而，这正是
    STL 映射和无序映射的完美之处。它们允许我们保存键/值对，并稍后使用键来高效地找到值，即使我们有成千上万的构建器。我们将使用 `M5StageTypes`
    枚举作为我们的键，并使用派生的 `M5StageBuilder*` 作为我们的值。
- en: An STL map is implemented as a tree, while `unordered_map` is implemented as
    a hash table. In general, this means that the map will use less memory, but will
    be a little slower to search. `unordered_map` will use more memory but search
    much faster. In our games, we aren't likely to create thousands of stages, so
    the difference in speed isn't going to matter that much, especially since we won't
    be searching very often either. We choose the hash table because, on a PC, I am
    less concerned about memory and more concerned about speed. If you are interested
    in learning more, check out [http://www.cplusplus.com/reference/](http://www.cplusplus.com/reference/)
    for lots of information about the standard library.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: STL 映射实现为一个树，而 `unordered_map` 实现为一个哈希表。一般来说，这意味着映射将使用更少的内存，但搜索会稍微慢一些。`unordered_map`
    将使用更多的内存，但搜索速度会快得多。在我们的游戏中，我们不太可能创建成千上万阶段，所以速度上的差异不会很大，尤其是我们不太经常进行搜索。我们选择哈希表是因为，在
    PC 上，我更关心速度而不是内存。如果你有兴趣了解更多，请查看 [http://www.cplusplus.com/reference/](http://www.cplusplus.com/reference/)
    以获取有关标准库的大量信息。
- en: 'We should also prefer to have as readable code as possible. Using a `typedef`
    will help others understand our code, because we only need to write the long `std::unordered_map<
    M5StageTypes, M5StageBuilder*>` code one time. After that, we can use the shorted
    name, in this case `BuilderMap`. This also gives us the ability to easily change
    containers if we later decide to use a map instead:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也应该尽可能编写可读性强的代码。使用 `typedef` 将有助于他人理解我们的代码，因为我们只需要将长的 `std::unordered_map<
    M5StageTypes, M5StageBuilder*>` 代码写一次。之后，我们可以使用简短的名字，在这个例子中是 `BuilderMap`。这也给了我们将来如果决定使用映射而不是容器时轻松更改容器的能力：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The next `typedef` gives us a shorted name for our `BuilderMap` iterators.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个 `typedef` 给我们提供了一个简短的名字来表示我们的 `BuilderMap` 迭代器。
- en: This is unnecessary with the C++ 11 auto keyword, but doesn't make our code
    less readable so we have chosen to use the `typedef`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 11 的 `auto` 关键字下，这并不是必需的，但这并不使我们的代码可读性降低，所以我们选择了使用 `typedef`。
- en: 'Finally, the actual member:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实际的成员：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will be our container that maps `M5StageTypes` to `M5StageBuilder*`. We
    should make it private because we want all builders to be added and removed with
    the class methods so the data can be validated.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们将 `M5StageTypes` 映射到 `M5StageBuilder*` 的容器。我们应该将其设为私有，因为我们希望所有构建器都通过类方法添加和移除，以便验证数据。
- en: 'Now for the class methods. Let''s start with the most important method of the
    factory:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是类方法。让我们从工厂最重要的方法开始：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Build` method is where the *magic* happens, at least for the user. They
    pass in a stage type and we build the correct stage for them. Of course, we use
    the `find` method first to make sure the type has been added. If it can't be found,
    we use a debug assert to let the user know that this type wasn't added. In general,
    the `find` method is safer to use than the `operator[]` that exists in the map
    and unordered map. Using the `operator[]` will create and return a null value
    if the key doesn't exist. If that happened while trying to build, we would get
    a null pointer exception, which would crash the program without giving the user
    an explanation of why.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Build` 方法是发生“魔法”的地方，至少对于用户来说是这样。他们传递一个阶段类型，我们为他们构建正确的阶段。当然，我们首先使用 `find` 方法来确保类型已经被添加。如果找不到，我们使用调试断言来通知用户这种类型没有被添加。一般来说，`find`
    方法比存在于映射和无序映射中的 `operator[]` 更安全。使用 `operator[]` 如果键不存在，将会创建并返回一个空值。如果在构建过程中发生这种情况，我们将会得到一个空指针异常，这会导致程序崩溃，而不会给用户解释原因。'
- en: 'We have the choice of adding some default stage to the map, and building that
    if the correct type can''t be found. However, there is a chance that the programmer
    won''t notice that a mistake has been made. Instead, we have chosen to return
    a null pointer. The requires the user to check whether the builder is valid before
    using it, but also means that the code will crash if they don''t fix the problem:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择在映射中添加一些默认阶段，并在找不到正确类型时构建它。然而，程序员可能不会注意到已经犯了一个错误。相反，我们选择返回一个空指针。这要求用户在使用构建器之前检查其是否有效，但也意味着如果他们不修复问题，代码将崩溃：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `AddBuilder` method allows our user to associate an `M5StageTypes` value
    with a derived `M5StageBuilder`. In this case, our code doesn't know or care whether
    `pBuilder` is pointing to a templated class or not. All that matters is that it
    derives from `M5StageBuilder`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddBuilder` 方法允许我们的用户将一个 `M5StageTypes` 值与一个派生的 `M5StageBuilder` 关联。在这种情况下，我们的代码不知道或关心
    `pBuilder` 是否指向一个模板类。重要的是它是否从 `M5StageBuilder` 派生。'
- en: Just as before, we should write our code to help the user find and fix bugs
    if they occur. We do that by testing the return value of the insert method. The
    `insert` method returns a pair in which the second element will tell us whether
    the insert was successful or not. Since a map and an `unordered_map` do not allow
    duplicates, we can test to make sure the user isn't associating an `M5StageTypes`
    value with two different builders. If the user tries to use an `enum` value twice,
    the second builder will not be inserted and false will be returned.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前一样，我们应该编写代码来帮助用户在出现错误时找到并修复它们。我们通过测试插入方法的返回值来实现这一点。`insert` 方法返回一个对，其中第二个元素将告诉我们插入是否成功。由于
    `map` 和 `unordered_map` 不允许重复项，我们可以测试以确保用户不会将 `M5StageTypes` 值与两个不同的构建器关联。如果用户尝试两次使用
    `enum` 值，第二个构建器将不会被插入，并返回 `false`。
- en: The STL versions of map and `unordered_map` do not allow duplicate items. If
    you wish to have duplicates, you can replace the container with `multimap` or
    `unordered_multimap`, which do allow duplicates. It wouldn't be useful to use
    the multi versions in this class, but they are good tools to know about.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: STL 版本的 `map` 和 `unordered_map` 不允许重复项。如果您希望有重复项，可以将容器替换为 `multimap` 或 `unordered_multimap`，后者允许重复项。在这个类中使用多版本可能没有用，但它们是很好的工具，值得了解。
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By now, the pattern should feel routine. First we write code to make sure there
    are no errors, then we write the actual function code. In this function, we first
    check to make sure the user is removing a previously added builder. After we make
    sure the user didn't make a mistake, we then delete the builder and erase the
    iterator from the container.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这种模式应该感觉已经很常规了。首先我们编写代码以确保没有错误，然后我们编写实际的函数代码。在这个函数中，我们首先检查用户是否正在删除之前添加的构建器。在确保用户没有犯错误之后，我们然后删除构建器并从容器中删除迭代器。
- en: Since we are immediately erasing the iterator after deleting the builder, it
    is unnecessary to set the pointer to `0`. However, I always set the pointer to
    `0`. This helps find bugs. For example, if I forgot to erase the iterator and
    tried to use this builder again, the program would crash, resulting from using
    the null pointer. If I didn't set the pointer to `0` but still tried to use it,
    I would instead get undefined behavior.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在删除构建器后立即删除迭代器，因此设置指针为 `0` 是不必要的。然而，我总是将指针设置为 `0`。这有助于查找错误。例如，如果我忘记删除迭代器并再次尝试使用此构建器，程序将崩溃，这是由于使用了空指针。如果我没有将指针设置为
    `0` 但仍然尝试使用它，我将会得到未定义的行为。
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Just as with the `RemoveAllComponents` from the `M5Object`, the purpose of
    `ClearBuilders` is to help the destructor of the class. Since this code needs
    to be written anyway (it would go in the destructor), we think it is better to
    factor it into a separate function that the user can call if they need:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 `M5Object` 中的 `RemoveAllComponents` 一样，`ClearBuilders` 的目的是帮助类的析构器。由于这段代码无论如何都需要编写（它将放在析构器中），我们认为将其分解为用户可以调用的单独函数会更好：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, we have our factory destructor. This just ensures that we don't have
    any memory leaks by calling the `ClearBuilders` function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有我们的工厂析构器。这仅仅确保通过调用 `ClearBuilders` 函数，我们没有内存泄漏。
- en: Using the Dynamic Factory
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态工厂
- en: 'Now that we have a completed `Factory` class, let''s look at how we would use
    it. Since the goal of this class was to decouple our `M5StageManager` from our
    specific derived `M5Stage` classes, it makes sense that it will be used in the
    `M5StageManager` class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`Factory`类的创建，让我们看看如何使用它。由于这个类的目标是解耦我们的`M5StageManager`和特定的派生`M5Stage`类，因此它在`M5StageManager`类中使用是有意义的：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since the factory will be private in the `M5StageManager`, we will add interface
    functions so the user can control the factory without knowing the implementation.
    This allows us to change the details, without affecting the user.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工厂将在`M5StageManager`中是私有的，我们将添加接口函数，以便用户可以在不知道实现的情况下控制工厂。这允许我们更改细节，而不会影响用户。
- en: Inside the `M5StageManager::Update` function, we will use the factory to get
    access to the current stage. Notice that this class is completely decoupled from
    any specific `M5Stage` derived classes. This give the user freedom to change the
    game design, including stage types, stage count, and stage names, without needing
    to modify the `M5StageManager` class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`M5StageManager::Update`函数内部，我们将使用工厂来获取当前阶段。请注意，这个类与任何特定的`M5Stage`派生类完全解耦。这给了用户改变游戏设计的自由，包括阶段类型、阶段数量和阶段名称，而无需修改`M5StageManager`类。
- en: 'In fact, that is the purpose of creating the Mach5 Engine the way we are. It
    can be used and reused in many game projects without changing the engine code.
    Here is a simplified version (pausing/restarting code has been omitted) of the
    `M5StageManager::Update` showing code relevant to the stages and factory:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就是我们创建Mach5引擎的方式的目的。它可以被用于许多游戏项目，而无需更改引擎代码。以下是一个简化的`M5StageManager::Update`版本（省略了暂停/重新启动代码），显示了与阶段和工厂相关的代码：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the `M5StageManager` is completely decoupled from any derived
    `M5Stage` classes. This allows the user to change, add, or remove any stages during
    development without needing to modify the `M5StageManager` class. This also allows
    the `M5StageManager` and `M5StageFactory` classes to be reused in another game,
    shortening the development time of that project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`M5StageManager`与任何派生的`M5Stage`类完全解耦。这允许用户在开发过程中更改、添加或删除任何阶段，而无需修改`M5StageManager`类。这也允许`M5StageManager`和`M5StageFactory`类在另一个游戏中重用，缩短该项目的开发时间。
- en: 'Now that we have seen the dynamic factory and how to use it, an important question
    should come to your mind: what are the benefits of the Dynamic Factory? Both the
    Static and Dynamic Factories allow us to decouple our code. Since they both offer
    that benefit and the Static Factory is much easier to implement, why should we
    bother spending time on the Dynamic Factory? Asking questions like these is always
    a good idea. In this case, I think there are two benefits to using the Dynamic
    Factory over the Static Factory.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了动态工厂及其使用方法，一个重要的问题应该出现在你的脑海中：动态工厂有哪些好处？静态和动态工厂都能让我们解耦代码。既然它们都提供了这个好处，而静态工厂又更容易实现，我们为什么还要费心去研究动态工厂呢？提出这样的问题是始终一个好的主意。在这种情况下，我认为使用动态工厂而不是静态工厂有两个好处。
- en: The first benefit of the Dynamic Factory is that it is dynamic, meaning that
    we can load builders from a file at runtime or remove a stage if we will never
    use it again (`SplashStage`). Being dynamic allows us to swap out a builder at
    runtime. For example, depending on the difficulty the player selects, we can swap
    out a difficulty component on enemies. The code to these difficulty component
    builders could be put into the menu, and the rest of our game no longer needs
    to care about the difficulty, the levels just create enemies the same way, no
    matter what.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 动态工厂的第一个好处是它是动态的，这意味着我们可以在运行时从文件中加载构建器，或者如果我们永远不会再次使用它（例如`SplashStage`），我们可以移除一个阶段。动态性允许我们在运行时替换构建器。例如，根据玩家选择的难度，我们可以替换敌人的难度组件。这些难度组件构建器的代码可以放入菜单中，而我们的游戏的其他部分就不再需要关心难度，各个级别只是以相同的方式创建敌人，无论是什么。
- en: The second and more important benefit of creating the Dynamic Factory comes
    in the next step. Since we have successfully created a `StageFactory`, we should
    do the same thing for components and game objects. In the next section, we will
    take a look at creating these factories.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建动态工厂的第二个且更为重要的好处将在下一步出现。由于我们已经成功创建了`StageFactory`，我们也应该为组件和游戏对象做同样的事情。在下一节中，我们将探讨如何创建这些工厂。
- en: Creating a component and Object Factory
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组件和对象工厂
- en: 'Now that we have built a stage factory, building a component factory should
    be easy. Let''s take a look at what a component and object factory would look
    like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个阶段工厂，构建一个组件工厂应该很容易。让我们看看组件和对象工厂会是什么样子：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Looking at those classes, you will notice that they are almost identical to
    the `M5StageFactory` class. The only things that are different are the types involved.
    Instead of `M5StageTypes`, we use `M5ComponentTypes` or `M5ArcheTypes`. Instead
    of `M5StageBuilder`, we use `M5ComponentBuilder` or `M5ObjectBuilder`. Finally,
    instead of the `Build` method returning an `M5Stage*`, we return either an `M5Component*`
    or `M5Object*`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 看那些类，你会注意到它们几乎与`M5StageFactory`类相同。唯一不同的是涉及的类型。我们使用`M5ComponentTypes`或`M5ArcheTypes`而不是`M5StageTypes`。我们使用`M5ComponentBuilder`或`M5ObjectBuilder`而不是`M5StageBuilder`。最后，我们返回`M5Stage*`而不是`M5Component*`或`M5Object*`的`Build`方法。
- en: If we were to implement these classes, the code would be identical as well.
    You might think that the `M5ObjectFactory` would be a little different since the
    `M5Object` isn't part of an inheritance hierarchy, but it actually doesn't matter.
    Even though the derived class builders are all doing different work, they are
    always just returning a single pointer type. The builders might be different,
    but the return type isn't.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要实现这些类，代码也将完全相同。你可能会认为`M5ObjectFactory`会有所不同，因为`M5Object`不是继承层次结构的一部分，但实际上这并不重要。尽管派生类构建器都在做不同的工作，但它们总是只返回一个指针类型。构建器可能不同，但返回类型并不相同。
- en: The Templated Factory
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板工厂
- en: Since we need to create different versions of the same algorithms using different
    type, we should again make use of C++ templates. This will allow us to write the
    code one time, and reuse it for any factory type we need.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要使用不同的类型创建相同算法的不同版本，我们应该再次利用C++模板。这将允许我们一次性编写代码，并为我们需要的任何工厂类型重用代码。
- en: 'First we need to factor out the types that are different. If you look at all
    three classes, you will see that three types are different. The enumeration type,
    the builder type, and the return type for the `Build` method is different in all
    three classes. If we make those template parameters, we can reuse the same code
    instead of recreating the same class three times. Here is how we should refactor
    our code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要提取出不同的类型。如果你查看这三个类，你会看到三种类型是不同的。枚举类型、构建器类型和`Build`方法的返回类型在这三个类中都是不同的。如果我们将这些模板参数化，我们可以重用相同的代码，而不是重新创建相同的类三次。以下是我们应该如何重构我们的代码：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notice that our class is now a template class with three template parameters,
    `EnumType`, `BuilderType`, and `ReturnType`. Instead of any specific types such
    as `M5StageTypes`, we have used our template parameters. One change that confuses
    many people is this line:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的类现在是一个具有三个模板参数的模板类，分别是`EnumType`、`BuilderType`和`ReturnType`。我们使用模板参数而不是任何特定的类型，如`M5StageTypes`。一个让许多人感到困惑的变化是这一行：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the original, non-templated `M5StageFactory` class, the compiler was able
    to look at the code `BuilderMap::iterator` and know for certain that iterator
    was a type inside `BuilderMap`. Now that we have a template class, the compiler
    can't be sure whether `BuilderMap::iterator` is a variable or a type, so we need
    to help the compiler by using the `typename` keyword to say that this is a type.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的非模板`M5StageFactory`类中，编译器能够查看代码`BuilderMap::iterator`并确定迭代器是`BuilderMap`内部的一个类型。现在我们有了模板类，编译器无法确定`BuilderMap::iterator`是一个变量还是一个类型，因此我们需要通过使用`typename`关键字来帮助编译器，表明这是一个类型。
- en: 'Since our factory is now a templated class, we should again put all functions
    implementations into the header file. In addition, each implementation must be
    marked as a template function. Here is an example of one of the `Build` methods:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的工厂现在是一个模板类，因此我们应该再次将所有函数实现放入头文件中。此外，每个实现都必须标记为模板函数。以下是一个`Build`方法的示例：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Except for the change in the function signature, the `Build` function is exactly
    the same. This is true of `AddBuilder`, `RemoveBuilder`, and all functions of
    the class. As I said, by making the Dynamic Factory a template class, we can reuse
    the same code for our stage factory, our component factory, and our object factory.
    Since that is the case, we won''t spend time on making the template factory. However,
    we still need to see how to use this new class. Let''s look at our `M5StageFactory`
    class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了函数签名的变化外，`Build`函数完全相同。这也适用于`AddBuilder`、`RemoveBuilder`以及类中的所有其他函数。正如我所说的，通过将动态工厂做成模板类，我们可以为我们的阶段工厂、组件工厂和对象工厂重用相同的代码。既然如此，我们就不需要在制作模板工厂上浪费时间了。然而，我们仍然需要了解如何使用这个新类。让我们看看我们的`M5StageFactory`类：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'That is the only change we need to make to our `M5StageFactory`. Everything
    else will work the exact same way. The nice thing is that once we have our template
    factory completed, using a component factory is easy. Here is how we can use our
    component factory and object factory inside our `M5ObjectManager` class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们对`M5StageFactory`需要做的唯一更改。其他所有内容都将按原样工作。好事是，一旦我们完成了模板工厂，使用组件工厂就变得简单了。以下是如何在我们的`M5ObjectManager`类中使用我们的组件工厂和对象工厂：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Reusing the code is simple once we have created the template version. We should
    have created that first, but most programmers have a hard time thinking about
    how to reuse a class until after the initial code has been written. I think it
    is easier and more natural to create the stage factory first, then refactor the
    code into a template class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了模板版本，重用代码就变得简单了。我们应该首先创建它，但大多数程序员在编写初始代码之后才难以考虑如何重用类。我认为先创建阶段工厂，然后重构代码成模板类更容易、更自然。
- en: 'There is one more important thing to consider when using our factory: how to
    add our builders. For now, let''s only consider the `M5Factory` inside the `M5StageManager`
    since we have seen that code already. Somewhere in our code, we must still instantiate
    our derived builders so we can add them to the `M5StageManager`. For example,
    we would need a function like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用我们的工厂时，还有一件更重要的事情需要考虑：如何添加我们的构建器。目前，让我们只考虑`M5StageManager`内部的`M5Factory`，因为我们已经看到了那段代码。在我们的代码中，我们必须实例化我们的派生构建器，以便我们可以将它们添加到`M5StageManager`中。例如，我们可能需要一个像这样的函数：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, this function is dependent on all stages in our game and is
    likely to change as we change our design. Unfortunately, this is as far as we
    can decouple our code. At some point, we need to instantiate derived classes.
    Even though this is necessary, later we will look at how to minimize the work
    involved in maintaining this code. In the case of the Mach5 Engine, this code
    is auto generated with a Windows batch file before the code is compiled. By auto
    generating our file, we reduce the chance of forgetting to add a stage, and also
    minimize the work when our code changes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个函数依赖于我们游戏中的所有阶段，并且随着我们设计的变化可能会发生变化。不幸的是，这是我们能够解耦代码的极限。在某个时候，我们需要实例化派生类。尽管这是必要的，但稍后我们将探讨如何最小化维护此代码所需的工作。在Mach5引擎的情况下，这段代码在编译代码之前使用Windows批处理文件自动生成。通过自动生成我们的文件，我们减少了忘记添加阶段的可能性，并在代码更改时最小化了工作量。
- en: Architecting versus over-architecting
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构与过度架构
- en: Over-architecting is the concept of spending time planning as well as writing
    code that includes completely unneeded and ultimately unused features. Since every
    project has a deadline, over-architecting means wasting time that could be better
    spent writing code that will be used.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 过度架构是指花费时间规划以及编写包含完全不需要且最终未使用的功能的代码。由于每个项目都有截止日期，过度架构意味着浪费了本可以用来编写将被使用的代码的时间。
- en: In our effort to learn design patterns, we want to know not only how to use
    them, but also about when not to use them. When you are working on a project,
    you must always find the balance between writing flexible code and getting the
    project finished on time. It always takes more time to write flexible, reusable
    code, so you have to consider whether it is worth the extra time to write that
    code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习设计模式的过程中，我们不仅想知道如何使用它们，还要了解何时不应使用它们。当你正在处理一个项目时，你必须始终在编写灵活的代码和按时完成项目之间找到平衡。编写灵活、可重用的代码通常需要更多时间，因此你必须考虑是否值得花费额外的时间来编写那段代码。
- en: It would be great to spend time creating the ultimate graphics engine, or creating
    a content creation tool that can rival Unreal or Unity. However, if you strive
    to write perfect, flexible, 100% reusable code, you may never complete your game.
    You may end up writing a great particle system and have your designers only use
    10% of the capabilities. This is why many companies choose to use a premade engine
    in the first place. Those companies don't want to spend time or money on creating
    a tool. They want to spend time making a game that is fun.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间创建终极图形引擎或创建可以与Unreal或Unity相媲美的内容创建工具是非常好的。然而，如果你努力编写完美、灵活、100%可重用的代码，你可能永远无法完成你的游戏。你可能会编写一个很棒的粒子系统，而你的设计师可能只使用了10%的功能。这就是为什么许多公司最初选择使用预制的引擎。那些公司不想在创建工具上花费时间和金钱。他们想花时间制作一个有趣的游戏。
- en: The opposite of this situation is just as bad. We don't want to write code that
    breaks whenever a change is introduced, or is impossible to use again. We can
    all imagine how ugly the code would be if an entire game was written in the standard
    `main` function. We might laugh at the thought of someone doing that, while at
    the same time hardcoding behavior with large if/else chains instead of using Finite
    State Machines.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的反面同样糟糕。我们不希望编写在引入变更时就会崩溃的代码，或者再次使用变得不可能的代码。我们都可以想象，如果整个游戏都是用标准的`main`函数编写的，代码会多么丑陋。我们可能会嘲笑有人这样做，同时又会因为用大量if/else链而不是使用有限状态机来硬编码行为而感到好笑。
- en: Finding the balance between these two extremes is difficult. I already mentioned
    that besides writing the initial code, there are additional factors to consider.
    These include the time it takes to test and debug the code as well as time to
    modify code if and when change occurs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种极端之间找到平衡是困难的。我已经提到，除了编写初始代码之外，还有其他因素需要考虑。这包括测试和调试代码所需的时间，以及如果发生变更时修改代码所需的时间。
- en: Determining whether writing flexible code is worth the time also includes determining
    how likely that code is to change. This is why we are using Singleton classes
    for our core engines. These are unlikely to change during the project. Of course,
    if we need to support multiple graphics APIs, multiple platforms, or even a multithreaded
    environment, we might make a different decision. This is also why using the Component
    Object Model and Finite State Machines are very useful, since our game objects
    and their behavior are likely to change constantly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 确定编写灵活的代码是否值得花费时间，还包括确定该代码可能发生变化的概率。这就是为什么我们使用单例类作为我们的核心引擎。这些在项目期间不太可能发生变化。当然，如果我们需要支持多个图形API、多个平台，甚至多线程环境，我们可能会做出不同的决定。这也是为什么使用组件对象模型和有限状态机非常有用，因为我们的游戏对象及其行为可能会不断变化。
- en: 'In this case, we need to choose between using the Static Factory or the Dynamic
    Factory. The Static Factory is very simple to write and use. Since it is so simple,
    testing and debugging should be easy. It is likely to change, but those changes
    should be easy as well. However, when using the Static Factory, we must write,
    test, debug, and maintain code for at least three separate types in our game:
    the stages, components, and objects. These will change often during the development
    cycle. Each time a change occurs, you would need to go back and modify these functions.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要在静态工厂和动态工厂之间做出选择。静态工厂编写和使用的非常简单。由于它非常简单，测试和调试应该很容易。它可能会发生变化，但这些变化也应该很容易。然而，在使用静态工厂时，我们必须为我们的游戏中的至少三种不同类型编写、测试、调试和维护代码：阶段、组件和对象。这些在开发周期中会经常变化。每次发生变化时，你都需要回去修改这些函数。
- en: The templated Dynamic Factory is a little more difficult to implement, especially
    if you aren't very familiar with using templates. However, the major benefit of
    using the templated Dynamic Factory is that we only need to write the code once,
    and we can use it for stages, components, and objects. In addition, we have the
    ability to add, remove, or change items in our factories at runtime. As I mentioned,
    this could mean changing archetype builders based on difficulty to create harder
    versions of the same archetype without needing new enumeration values. Finally,
    we have the option of using this code again in another project, which is unlikely
    if we stick with the Static Factory.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 模板化动态工厂的实现稍微困难一些，尤其是如果你不太熟悉使用模板。然而，使用模板化动态工厂的主要好处是我们只需编写一次代码，就可以用于阶段、组件和对象。此外，我们还有在运行时添加、删除或更改工厂中项目的能力。正如我提到的，这可能意味着根据难度更改原型构建器，以创建相同原型的更难版本，而无需新的枚举值。最后，我们还有在另一个项目中再次使用此代码的选项，如果我们坚持使用静态工厂，这不太可能。
- en: In the end, the `M5Factory.h` file that contains the templated Dynamic factory
    is only around 125 lines of code, with maybe 30% of that being comments and white
    space. It may be a little more difficult, but I don't think it is so difficult
    that someone should prefer the Static Factory.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，包含模板化动态工厂的`M5Factory.h`文件大约有125行代码，其中可能有30%是注释和空白。这可能有点困难，但我认为这并不困难到有人会偏好静态工厂。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we focused a lot on decoupling code. Since our game design
    is very likely to change, we want to make sure that our high-level modules don''t
    depend on derived stages or components. That is why we should follow the Dependency
    Inversion Principle, which says the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们大量关注了代码解耦。由于我们的游戏设计很可能发生变化，我们希望确保我们的高级模块不依赖于派生阶段或组件。这就是为什么我们应该遵循依赖倒置原则，它指出以下内容：
- en: High-level modules should not depend on low-level modules. Both should depend
    on abstractions.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级模块不应依赖于低级模块。两者都应依赖于抽象。
- en: Abstractions should not depend on details. Details should depend on abstractions.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象不应依赖于细节。细节应依赖于抽象。
- en: In simpler terms, this means that all our code should be built around the interfaces.
    We used the example of our `M5StageManager` not being dependent on derived `M5Stage`
    classes. Since we want to avoid class dependencies like this, we learned that
    we should also avoid *hard coding*, including using calls to the `new` operator.
    In order to avoid direct calls to the `new` operator, we learned about three ways
    to make Factories.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这意味着我们所有的代码都应该围绕接口构建。我们以我们的`M5StageManager`为例，它不依赖于派生的`M5Stage`类。由于我们想要避免这种类依赖，我们了解到我们也应该避免*硬编码*，包括使用对`new`操作符的调用。为了避免直接调用`new`操作符，我们学习了三种创建工厂的方法。
- en: The first method was the classic Gang of Four Factory method, which says we
    should create a hierarchy of classes, each capable of instantiating a single class.
    This method helped us get to our final solution, but wasn't quite good enough,
    because we want to be able to select which derived class to instantiate via a
    string or an enum.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是经典的四人帮工厂方法，它说我们应该创建一个类层次结构，每个类都能实例化一个单一的类。这种方法帮助我们达到了最终解决方案，但还不够好，因为我们想要能够通过字符串或枚举来选择要实例化的派生类。
- en: The second method we learned was the Static Factory Method, which uses a simple
    global or static function and a switch statement to allow us to select our desired
    derived class. This works great for our needs, but we decided to go one step further
    and create an even more flexible, reusable factory.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习的第二种方法是静态工厂方法，它使用简单的全局或静态函数和switch语句来允许我们选择我们想要的派生类。这对于我们的需求来说非常好，但我们决定更进一步，创建一个更灵活、可重用的工厂。
- en: Finally, we learned about the Dynamic Factory, specifically the templated version
    of the Dynamic Factory, which combines both the classic Factory method and the
    Static Factory. The best part is that since we are using the power of C++ templates,
    we can reuse the code for stages and components, as well as objects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了动态工厂，特别是动态工厂的模板化版本，它结合了经典的工厂方法和静态工厂。最好的部分是，由于我们正在使用C++模板的强大功能，我们可以重用代码以用于阶段、组件以及对象。
- en: Throughout this chapter, but especially in the last section, we discussed the
    balance between spending time writing flexible code versus over-architecting.
    Of course, one strong reason to study design patterns is to learn how to write
    great reusable code, but we always want to make sure it fits the project and fits
    within the project deadline.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，尤其是在最后一节，我们讨论了在编写灵活的代码和过度设计之间取得平衡的问题。当然，学习设计模式的一个强有力的理由是学习如何编写优秀的可重用代码，但我们始终想要确保它符合项目需求，并且能够在项目截止日期内完成。
- en: The goal of this book is to help you understand when and where we should apply
    these patterns throughout a game. We already know how to create flexible game
    objects using components and Finite State Machines. Now that we know about the
    Dynamic factory, we have decoupled our stage and component creation from our core
    engine, making everything more reusable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目标是帮助你理解在游戏中何时何地应用这些模式。我们已经知道如何使用组件和有限状态机创建灵活的游戏对象。现在我们了解了动态工厂，我们已经将我们的舞台和组件创建与核心引擎解耦，使一切更加可重用。
- en: However, the ultimate goal is to make things so flexible that they can be changed
    from a text file or tool without the need to recompile anything. That is what
    we will learn how to do next.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终的目标是使事物足够灵活，以至于可以通过文本文件或工具进行更改，而无需重新编译任何内容。这就是我们接下来将要学习如何做到的。
