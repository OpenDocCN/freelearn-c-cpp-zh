- en: Decoupling Code via the Factory Method Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every project and every game design is going to change. One of the goals of
    object-oriented programming is to program with that change in mind. This means
    writing flexible and reusable code so that, when changes happen, the project doesn't
    fall apart. Unfortunately, the requirements are never fully known and the vision
    of the designer is never 100% complete. The good news is that newly added features
    may interact with old features in unexpectedly fun ways, leading to unplanned
    features being created, which can make for a completely different, and more enjoyable,
    game.
  prefs: []
  type: TYPE_NORMAL
- en: In the worst-case scenario, the game design may not be fun at all, which can
    lead to drastic changes in game object types, object behaviors, and even the design
    of the entire game. In this case, we want to be able to rework our game to try
    new possibilities with the least amount of change to code. Changing code takes
    time to write, test, and debug, and any time new code is added, it has the possibility
    of causing bugs in older code.
  prefs: []
  type: TYPE_NORMAL
- en: Since we know that our design will change, we must plan for that change by following
    good design principles and utilizing design patterns to solve common problems.
    This includes using flexible designs such as the Component Object Model to avoid
    inheritance hierarchies. This includes using the State pattern and finite state
    machines to avoid complex `if` statements and cascading `if else` chains that
    lead to bugs any time a change occurs. This also includes things such as striving
    for low coupling and avoiding *hardcoding* anything.
  prefs: []
  type: TYPE_NORMAL
- en: We all know that as programmers, we should avoid *magic numbers*. We don't want
    to see seemingly random or odd numbers in our code. A hardcoded number isn't descriptive
    enough, which makes the code hard to read, maintain, and debug. If we need to
    change a magic number, we have to spend time searching our code for every time
    it appears. Unfortunately, these hardcoded values tend to change a lot during
    development. In the real world, gravity may be 9.8 m/s², but in the game world,
    we may need to adjust it so the game is more fun, or possibly change it at runtime
    so the player can walk on the ceiling.
  prefs: []
  type: TYPE_NORMAL
- en: When we think about hard coding, we usually think about magic numbers. However,
    a call to the `new` operator using a concrete class type such as a new `ChaseAIComponent`
    may be readable, but it is just as likely to change as the value of gravity or
    the size of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will be focusing on a common interface to create new objects
    without the need to call constructors directly. First, we will look at reasons
    why a `switch` statement can be harmful. Next we will look at a design principle
    that leads us to our final solution, a factory. Then we will look at few different
    ways to design our factories to make them flexible and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Your objective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the course of this chapter, we will be looking at a few more important
    concepts and principles that can make our programs better. Here is an outline
    of what we will cover and your tasks for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning why using `switch` statements can be bad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the Dependency Inversion Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the Factory Method pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Component, Stage, and Object Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve your Factories by using templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trouble with switch statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When first learning to program, simply understanding the grammar of the language
    is very difficult. Often, new programmers focus on the syntax of a function call
    or `for` loop and they don''t even think about making reusable, maintainable code.
    This is partly because they jump into the coding without planning anything out.
    This is true for games as well. Often, new programmers want to get straight to
    writing the game and they forget about things such as user interface and pause
    menus. Things such as the window resolution, enemy placement in the stages, and
    even where the mouse should be when clicking buttons will be hardcoded. Here is
    code from one of the authors'' first games. This was a section in the `MainMenu`
    function that would switch the game into the Load state when the button was clicked.
    The variable `p` is the location of the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Code similar to this was repeated (without a loop) four times, because there
    were four buttons in the `MainMenu`. Of course, there were better (much better)
    ways to write this code. It is important to separate game stages from the `Graphics`
    class for one, and buttons can manage themselves if they are written correctly.
    However, the worst part of this old code base was how game stages were changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that game, there was an `Update` function in the `Engine` class that contained
    a 507-line-long `switch` statement. This included a `switch` within a `switch`
    for situations where there needed to be a menu stage, but there were multiple
    menus to choose from. Here is some sample code from when a level needed to be
    loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you feel like that is hard to look at, you are right. For some reason, the
    stage-switching code was responsible for setting the player's health and position,
    moving the camera, setting the background texture, and going back to the menu
    if something failed to load.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we are showing this is so you can see an example of really bad code.
    This `Engine` class was tightly coupled with the `graphics` class, the `physics`
    class, the `object manager` class, and the `player` class. If any of these classes
    changed or were removed, the code in the `Engine` class needed to change. Another
    problem is that there are many dependencies here, which means a change to any
    of the classes above will cause the code to be recompiled as well.
  prefs: []
  type: TYPE_NORMAL
- en: One of the authors was in a similar situation a few years later while working
    on an iPhone game as contract programmer. The original design called for only
    two stages, the main menu and the gameplay. Since the plan was so simple, code
    similar to what we saw above was used. This soon became a problem, because all
    game designs change even if the project is only three months long.
  prefs: []
  type: TYPE_NORMAL
- en: After one month, the game was completed to specification, including a level
    editor so the designer could create as many levels as were needed. The goal was
    to spend the rest of the time adding effects and polish to the game. However,
    every week, the producer and designer would come and say they needed a new menu
    or transition screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, the game design called for an options menu, a level select menu,
    a credits screen, a celebration screen every 10 levels, and a congratulations
    screen after completing the game. The simple two-stage code that was originally
    written ended up being a hacked-together mess because of the fast development
    timeline and the constant addition of new features. One horrible line of code
    was similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This *worked* because there were 80 levels in the game and the `levelCounter`
    incremented after completing a level. After seeing game code like this, we hope
    you understand why it is important to plan for change to occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 3](part0064.html#1T1400-04600e4b10ea45a2839ef4fc3675aeb7), *Creating
    Flexibility with the Component Object Model*, we saw how to create components
    for our game object so we can easily handle changes to our object design. This
    is an important step in creating flexible code; however, when we create an object
    in our stage, we still must use new to hardcode the concrete types that make up
    our object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This means that our derived `M5Stage` class is tightly coupled to the components
    of this object type, and really all object types that need to be created in this
    level. If the objects need different components, or any of the components are
    changed or removed, then our `Stage` class must be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to *solve* this (as we saw in [Chapter 3](part0064.html#1T1400-04600e4b10ea45a2839ef4fc3675aeb7),
    *Creating Flexibility with the Component Object Model*) is to put this code into
    our `M5ObjectManager` class. This way, our stages don''t need to be constantly
    updated as our types are modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This solves the problem of needing to change our stages whenever an object is
    changed. However, we will still have to change our `switch` statement and the
    object manager if our objects or components change. Actually, except for this
    function, the Object Manager doesn't really care about any derived component types.
    It only needs to be dependent on the `M5Component` abstract class. If we can fix
    this function, we can completely decouple our derived component types from this
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to our problem is the same solution used to solve the stage management
    problem I faced years ago, *the Dependency Inversion Principle*.
  prefs: []
  type: TYPE_NORMAL
- en: The Dependency Inversion Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of avoiding `concreate` classes isn''t new. Robert C. Martin defined
    this idea in *The C++ Report* in May 1996 in an article titled *The Dependency
    Inversion Principle*. It is the D in his SOLID design principles. The principle
    has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: High-level modules should not depend on low-level modules. Both should depend
    on abstractions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstractions should not depend on details. Details should depend on abstractions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this may seem like a mouthful, the concept is actually very easy. Imagine
    we have a `StageManager` class that is responsible for initializing, updating,
    and shutting down all of the stages in our game. In this case, our `StageManager`
    is our high-level modules, and the stages are the low-level modules. The `StageManager`
    will control the creation and behavior of our low-level module, the stages. This
    principle says that our `StageManager` code shouldn't depend on derived stage
    classes, but should instead depend on an abstract stage class. To see why, let's
    look at an example of not following this principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here our `StageManager` has a function called `Update`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this is just the first level of our game, so we will need to include
    code to update the main menu, and the second level of our game. Since these classes
    are unrelated, we will need a `switch` statement to make a choice between stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can see that as we continue to add more and more levels, this code will
    get large very fast and it will quickly become impossible, or just really difficult
    to maintain. This is because we will need to go into this function and remember
    to update the `switch` statement every time a new stage is added to the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of this section, tells us that that our `StageManager` class
    shouldn''t depend on levels or menus, but should instead depend on a common abstraction.
    That means that we should create an abstract base class for all of our stages.
    The second part says that the abstraction shouldn''t care whether the stage is
    a level or a menu. In fact, it shouldn''t even care that we are making a stage
    for a space shooter game, a platformer, or a racing game. A major benefit of using
    this principle, besides having more flexible code, is that our `StageManager`
    class will no longer depend on anything in this specific game, so we can reuse
    it for our next project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: StageManager depends on specific classes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: StageManager only depends on abstraction
  prefs: []
  type: TYPE_NORMAL
- en: Now the `Update` function of `StageManager` is much simpler. Since we are only
    dependent on the abstract class, our code no longer needs to change based on derived
    implementations. We have also simplified the interface of all stages. The functions
    of each stage no longer change based on the details of the class (menu, level,
    and so on); instead, they all share a common interface. As you can see, knowing
    about the Dependency Inversion Principle will not only make you a big hit at parties,
    it will also allow you to decouple your code base and reuse higher-level modules.
  prefs: []
  type: TYPE_NORMAL
- en: We still have the problem of selecting the correct derived class. We don't want
    to put a `switch` statement in the `Update` function of `StageManager`. If we
    do that, we will have dependency problems like before. Instead, we need a way
    to select the correct derived class while depending only on the base class.
  prefs: []
  type: TYPE_NORMAL
- en: The Factory method pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Factory method pattern is exactly the design pattern we need to solve our
    problem. The purpose of this pattern is to have a way of creating the derived
    class that we want without needed to specify the `concreate` class in our high-level
    module. This is done by defining an interface for creating objects, but letting
    subclasses decide which class to instantiate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we will create a `StageFactory` interface with a method called
    `Build` that will return a `Stage*`. We can then create subclasses such as `Level2Factory`
    to instantiate our derived classes. Our `StageManager` class now only needs to
    know about the `Stage` and `StageFactory` abstractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Stage Factory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have moved the call to new from our `StageManager::Update` function
    into derived `StageFactory` methods. We have successfully decoupled our `StageManager`
    from our derived `Stage` classes. However, the call to `Build` represents the
    creation of only one derived `Stage` class. We still need a way to choose which
    derived `Stage` we want to use and which derived `StageFactory` we need to instantiate.
    We need a way to choose between different types of factories. Before we look at
    the solution that was used in the Mach5 Engine, let's look at an alternative Factory
    method, the Static Factory.
  prefs: []
  type: TYPE_NORMAL
- en: The Static Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to implement a factory method the way we want is with either
    a global function or a static class function. We could define a function called
    `MakeStage` outside of `StateMananger` that is responsible for instantiating the
    correct derived type based on a parameter. In this case, we will use an `enum`
    called `StageType` to help us choose our correct type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use this style of factory, our `StageManager::Update` function will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This version of the factory method works exactly as we want. We can now choose
    which derived `Stage` class is instantiated. We still have a switch statement
    that we must maintain, but at least our higher-level module is no longer dependent
    on derived classes. In the default case, where our `switch` statement can't match
    the correct type, we are left with the choice of using an assert to crash the
    program, throwing an exception and letting the client resolve the issue, or perhaps
    returning null, which still gives responsibility to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The Static Factory successfully decouples our `StageManager` class from specific
    derived `Stage` classes, while allowing us to choose which stage will be instantiated
    at runtime. This is great, but as I said, this isn't how the Mach5 Engine implements
    `Stage` or component factories. Instead, Mach5 uses a more dynamic solution, so
    we will call it the Dynamic Factory.
  prefs: []
  type: TYPE_NORMAL
- en: The Dynamic Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the Static Factory is simple enough for our purpose, the Mach5 Engine
    uses a different approach. This approach combines the polymorphic solution of
    the classic Factory method with the selection capability of the Static Factory.
    This new approach uses a searchable collection of derived `StageFactory` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that problem with the classic Factory method is that the method represents
    only one class to instantiate. This allows our code to be flexible because we
    don't depend on a derived `Stage` class or a call to the `new` operator. However,
    we still needed a way to get specific derived `StageFactory` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Mach5 Engine, the names are changed a little. There is only one `StageFactory`
    class, which contains a collection of `M5StageBuilder` pointers (these are classic
    Factories), which implement a `Build` method. The design looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Design of Dynamic Factory
  prefs: []
  type: TYPE_NORMAL
- en: 'The first class we want to see is the base `M5Stage` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The base `M5Stage` class is a pretty simple abstract base class with a virtual
    destructor. The specific virtual functions in `M5Stage` aren't important for the
    details of the factory. We are simply showing the class here, because the `M5StageManager`
    and `M5StageFactory` will be using this abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: C++ classes intended for polymorphic use, including abstract base classes, should
    always implement a virtual destructor, otherwise the correct derived class destructor
    cannot be called.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Stage Builders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next let's look at our base builder class. Notice that this is the same type
    of interface that would be used in the classic Factory method pattern. This abstraction
    declares a method that returns another abstraction, in this case `M5Stage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like before, we need to have an empty virtual destructor so when we use
    this class in a polymorphic way, the correct destructor will be called. Also like
    before, the other methods are marked as purely `virtual,` which disallows direct
    instantiation of this class. That means we cannot create an `M5StageBuilder` directly.
    We must derive from it, and implement the pure virtual methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Even though the name is different, this is how the classic Factory method would
    be implemented. The Mach5 Engine calls this a *Builder* instead of a *Factory*
    but it is only a change in the name and not the functionality. The name of the
    `Build` method isn't important. Some programs will call the method `Create` or
    `Make`. Mach5 calls it `Build` but any of these names are fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter what the name is, a user creating a game with the Mach5 Engine would
    want to derive their own specific stage builders for the stages in their game.
    For this book, we have stages for a space shooter game called `AstroShot`. In
    order to make builders for these stages, we need to derive from `M5StageBuilder`
    and implement the `Build` method. For example, if we had `M5Stage` derived classes
    called `SplashStage` and `MainMenuStage`, we would create builders like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note here that the use of the keyword `virtual` in the derived classes is completely
    optional. In the pre C++ 11 days, programmers would mark the function `virtual`
    as a form of documentation to other programmers. These days, you can add the override
    specifier to a virtual function so the compiler can issue an error if the function
    isn't a true override.
  prefs: []
  type: TYPE_NORMAL
- en: To some, this might seem a little tedious. In fact, the biggest complaint I
    hear from people first learning about object-oriented programming is that they
    feel like they waste a lot time creating many files with small classes in them.
    To them, it feels like a lot of work for very little pay-off.
  prefs: []
  type: TYPE_NORMAL
- en: I agree that programming this way can require lots of files and lots of little
    classes. However, I disagree with it being a waste of time. I think these arguments
    are a result of shortsighted thinking. They are only thinking of the time it takes
    to write the original code, but they aren't thinking about the time it will save
    when making changes to the design or the time it will take to test and debug.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't take much time to create new files. With an integrated development
    environment such as Visual Studio, it takes less than 10 seconds to create a source
    and header file. Writing small classes such as the builders above doesn't take
    much time either. In total, writing these two classes takes less than five minutes.
    Of course, this is more than directly writing new into a high-level module, but
    remember that the goal is to write code that can adapt to change in our game design.
  prefs: []
  type: TYPE_NORMAL
- en: These shortsighted arguments are similar to the complaints of new programmers
    learning to write functions. We have already discussed the benefits of writing
    functions and those same benefits apply here. We shouldn't think only of the time
    it takes to write the initial code. We need to factor in how long it will take
    to test and debug the code, how likely it is to introduce new bugs into old code,
    how long it will take to modify if our design changes a month or year from now,
    and if the design does change, how likely is it that modifying our code will introduce
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that by using design patterns we are writing more
    code upfront, so that we can cut down on the time it takes to test, debug, integrate,
    maintain, and change our code in the future. It is important to understand that
    writing the original code is easy and cheap, while changing it later is much harder
    and more expensive. In this case, cheap and expensive could be referring to hours
    worked or money spent paying programmers.
  prefs: []
  type: TYPE_NORMAL
- en: The template builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Those worried about writing a lot of little classes are in luck. Most, if not
    all, of our builders will be the same except for the specific derived class they
    instantiate. That means we can use the power of C++ templates to create builders
    for us. Our templated builder will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code works great for most of our stages. The only time it doesn't work
    is when we need to do something more specific, such as call a non-default constructor,
    or a function specific to the derived stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the implementation of the `Build` function is also included in
    the `.h` file. This is because `template` functions are not the same as regular
    functions. They work as recipes so the compiler knows how to generate the function
    for the specific type. Each time we need to use this function, the compiler will
    need to know about the recipe. This allows the compiler to instantiate the function
    as opposed to requiring the user to explicitly instantiate the `Builder` classes
    they need before using them. So when we want to use this class, it will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Dynamic Factory class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have only created our builders, which are equivalent to the classic
    Factory method pattern. However, we haven''t seen the Factory part of the Dynamic
    Factory. Let''s look at how the Mach5 Engine implements the `StageFactory` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `M5StageFactory` isn't a very complicated class. Once you understand
    the design behind the patterns, implementing them is usually not very difficult.
    As for this class, it is only five methods and one member. The private section
    looks a little complicated because Mach5 prefers using a `typedef` for templated
    containers. Since the container is used in all of the private functions, let's
    look at the member before exploring the five methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look the `typedefs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since we want a container of `M5StageBuilders`, we have a few choices. We could
    use an STL vector or list, but those containers are not ideal for searching because
    of the potential lack of efficiency if we have many builders. However, this is
    exactly what the STL map and `unordered_map` are perfect for. They allow us to
    save key/value pairs and later use the key to efficiently find the value, even
    if we had thousands of builders. We will use the `M5StageTypes``enum` as our key,
    and use a derived `M5StageBuilder*` as our value.
  prefs: []
  type: TYPE_NORMAL
- en: An STL map is implemented as a tree, while `unordered_map` is implemented as
    a hash table. In general, this means that the map will use less memory, but will
    be a little slower to search. `unordered_map` will use more memory but search
    much faster. In our games, we aren't likely to create thousands of stages, so
    the difference in speed isn't going to matter that much, especially since we won't
    be searching very often either. We choose the hash table because, on a PC, I am
    less concerned about memory and more concerned about speed. If you are interested
    in learning more, check out [http://www.cplusplus.com/reference/](http://www.cplusplus.com/reference/)
    for lots of information about the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also prefer to have as readable code as possible. Using a `typedef`
    will help others understand our code, because we only need to write the long `std::unordered_map<
    M5StageTypes, M5StageBuilder*>` code one time. After that, we can use the shorted
    name, in this case `BuilderMap`. This also gives us the ability to easily change
    containers if we later decide to use a map instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The next `typedef` gives us a shorted name for our `BuilderMap` iterators.
  prefs: []
  type: TYPE_NORMAL
- en: This is unnecessary with the C++ 11 auto keyword, but doesn't make our code
    less readable so we have chosen to use the `typedef`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the actual member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will be our container that maps `M5StageTypes` to `M5StageBuilder*`. We
    should make it private because we want all builders to be added and removed with
    the class methods so the data can be validated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the class methods. Let''s start with the most important method of the
    factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `Build` method is where the *magic* happens, at least for the user. They
    pass in a stage type and we build the correct stage for them. Of course, we use
    the `find` method first to make sure the type has been added. If it can't be found,
    we use a debug assert to let the user know that this type wasn't added. In general,
    the `find` method is safer to use than the `operator[]` that exists in the map
    and unordered map. Using the `operator[]` will create and return a null value
    if the key doesn't exist. If that happened while trying to build, we would get
    a null pointer exception, which would crash the program without giving the user
    an explanation of why.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the choice of adding some default stage to the map, and building that
    if the correct type can''t be found. However, there is a chance that the programmer
    won''t notice that a mistake has been made. Instead, we have chosen to return
    a null pointer. The requires the user to check whether the builder is valid before
    using it, but also means that the code will crash if they don''t fix the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `AddBuilder` method allows our user to associate an `M5StageTypes` value
    with a derived `M5StageBuilder`. In this case, our code doesn't know or care whether
    `pBuilder` is pointing to a templated class or not. All that matters is that it
    derives from `M5StageBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: Just as before, we should write our code to help the user find and fix bugs
    if they occur. We do that by testing the return value of the insert method. The
    `insert` method returns a pair in which the second element will tell us whether
    the insert was successful or not. Since a map and an `unordered_map` do not allow
    duplicates, we can test to make sure the user isn't associating an `M5StageTypes`
    value with two different builders. If the user tries to use an `enum` value twice,
    the second builder will not be inserted and false will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: The STL versions of map and `unordered_map` do not allow duplicate items. If
    you wish to have duplicates, you can replace the container with `multimap` or
    `unordered_multimap`, which do allow duplicates. It wouldn't be useful to use
    the multi versions in this class, but they are good tools to know about.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: By now, the pattern should feel routine. First we write code to make sure there
    are no errors, then we write the actual function code. In this function, we first
    check to make sure the user is removing a previously added builder. After we make
    sure the user didn't make a mistake, we then delete the builder and erase the
    iterator from the container.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are immediately erasing the iterator after deleting the builder, it
    is unnecessary to set the pointer to `0`. However, I always set the pointer to
    `0`. This helps find bugs. For example, if I forgot to erase the iterator and
    tried to use this builder again, the program would crash, resulting from using
    the null pointer. If I didn't set the pointer to `0` but still tried to use it,
    I would instead get undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with the `RemoveAllComponents` from the `M5Object`, the purpose of
    `ClearBuilders` is to help the destructor of the class. Since this code needs
    to be written anyway (it would go in the destructor), we think it is better to
    factor it into a separate function that the user can call if they need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have our factory destructor. This just ensures that we don't have
    any memory leaks by calling the `ClearBuilders` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Dynamic Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a completed `Factory` class, let''s look at how we would use
    it. Since the goal of this class was to decouple our `M5StageManager` from our
    specific derived `M5Stage` classes, it makes sense that it will be used in the
    `M5StageManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Since the factory will be private in the `M5StageManager`, we will add interface
    functions so the user can control the factory without knowing the implementation.
    This allows us to change the details, without affecting the user.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `M5StageManager::Update` function, we will use the factory to get
    access to the current stage. Notice that this class is completely decoupled from
    any specific `M5Stage` derived classes. This give the user freedom to change the
    game design, including stage types, stage count, and stage names, without needing
    to modify the `M5StageManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, that is the purpose of creating the Mach5 Engine the way we are. It
    can be used and reused in many game projects without changing the engine code.
    Here is a simplified version (pausing/restarting code has been omitted) of the
    `M5StageManager::Update` showing code relevant to the stages and factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `M5StageManager` is completely decoupled from any derived
    `M5Stage` classes. This allows the user to change, add, or remove any stages during
    development without needing to modify the `M5StageManager` class. This also allows
    the `M5StageManager` and `M5StageFactory` classes to be reused in another game,
    shortening the development time of that project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen the dynamic factory and how to use it, an important question
    should come to your mind: what are the benefits of the Dynamic Factory? Both the
    Static and Dynamic Factories allow us to decouple our code. Since they both offer
    that benefit and the Static Factory is much easier to implement, why should we
    bother spending time on the Dynamic Factory? Asking questions like these is always
    a good idea. In this case, I think there are two benefits to using the Dynamic
    Factory over the Static Factory.'
  prefs: []
  type: TYPE_NORMAL
- en: The first benefit of the Dynamic Factory is that it is dynamic, meaning that
    we can load builders from a file at runtime or remove a stage if we will never
    use it again (`SplashStage`). Being dynamic allows us to swap out a builder at
    runtime. For example, depending on the difficulty the player selects, we can swap
    out a difficulty component on enemies. The code to these difficulty component
    builders could be put into the menu, and the rest of our game no longer needs
    to care about the difficulty, the levels just create enemies the same way, no
    matter what.
  prefs: []
  type: TYPE_NORMAL
- en: The second and more important benefit of creating the Dynamic Factory comes
    in the next step. Since we have successfully created a `StageFactory`, we should
    do the same thing for components and game objects. In the next section, we will
    take a look at creating these factories.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a component and Object Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have built a stage factory, building a component factory should
    be easy. Let''s take a look at what a component and object factory would look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Looking at those classes, you will notice that they are almost identical to
    the `M5StageFactory` class. The only things that are different are the types involved.
    Instead of `M5StageTypes`, we use `M5ComponentTypes` or `M5ArcheTypes`. Instead
    of `M5StageBuilder`, we use `M5ComponentBuilder` or `M5ObjectBuilder`. Finally,
    instead of the `Build` method returning an `M5Stage*`, we return either an `M5Component*`
    or `M5Object*`.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to implement these classes, the code would be identical as well.
    You might think that the `M5ObjectFactory` would be a little different since the
    `M5Object` isn't part of an inheritance hierarchy, but it actually doesn't matter.
    Even though the derived class builders are all doing different work, they are
    always just returning a single pointer type. The builders might be different,
    but the return type isn't.
  prefs: []
  type: TYPE_NORMAL
- en: The Templated Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we need to create different versions of the same algorithms using different
    type, we should again make use of C++ templates. This will allow us to write the
    code one time, and reuse it for any factory type we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need to factor out the types that are different. If you look at all
    three classes, you will see that three types are different. The enumeration type,
    the builder type, and the return type for the `Build` method is different in all
    three classes. If we make those template parameters, we can reuse the same code
    instead of recreating the same class three times. Here is how we should refactor
    our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that our class is now a template class with three template parameters,
    `EnumType`, `BuilderType`, and `ReturnType`. Instead of any specific types such
    as `M5StageTypes`, we have used our template parameters. One change that confuses
    many people is this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the original, non-templated `M5StageFactory` class, the compiler was able
    to look at the code `BuilderMap::iterator` and know for certain that iterator
    was a type inside `BuilderMap`. Now that we have a template class, the compiler
    can't be sure whether `BuilderMap::iterator` is a variable or a type, so we need
    to help the compiler by using the `typename` keyword to say that this is a type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our factory is now a templated class, we should again put all functions
    implementations into the header file. In addition, each implementation must be
    marked as a template function. Here is an example of one of the `Build` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Except for the change in the function signature, the `Build` function is exactly
    the same. This is true of `AddBuilder`, `RemoveBuilder`, and all functions of
    the class. As I said, by making the Dynamic Factory a template class, we can reuse
    the same code for our stage factory, our component factory, and our object factory.
    Since that is the case, we won''t spend time on making the template factory. However,
    we still need to see how to use this new class. Let''s look at our `M5StageFactory`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'That is the only change we need to make to our `M5StageFactory`. Everything
    else will work the exact same way. The nice thing is that once we have our template
    factory completed, using a component factory is easy. Here is how we can use our
    component factory and object factory inside our `M5ObjectManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Reusing the code is simple once we have created the template version. We should
    have created that first, but most programmers have a hard time thinking about
    how to reuse a class until after the initial code has been written. I think it
    is easier and more natural to create the stage factory first, then refactor the
    code into a template class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more important thing to consider when using our factory: how to
    add our builders. For now, let''s only consider the `M5Factory` inside the `M5StageManager`
    since we have seen that code already. Somewhere in our code, we must still instantiate
    our derived builders so we can add them to the `M5StageManager`. For example,
    we would need a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this function is dependent on all stages in our game and is
    likely to change as we change our design. Unfortunately, this is as far as we
    can decouple our code. At some point, we need to instantiate derived classes.
    Even though this is necessary, later we will look at how to minimize the work
    involved in maintaining this code. In the case of the Mach5 Engine, this code
    is auto generated with a Windows batch file before the code is compiled. By auto
    generating our file, we reduce the chance of forgetting to add a stage, and also
    minimize the work when our code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Architecting versus over-architecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over-architecting is the concept of spending time planning as well as writing
    code that includes completely unneeded and ultimately unused features. Since every
    project has a deadline, over-architecting means wasting time that could be better
    spent writing code that will be used.
  prefs: []
  type: TYPE_NORMAL
- en: In our effort to learn design patterns, we want to know not only how to use
    them, but also about when not to use them. When you are working on a project,
    you must always find the balance between writing flexible code and getting the
    project finished on time. It always takes more time to write flexible, reusable
    code, so you have to consider whether it is worth the extra time to write that
    code.
  prefs: []
  type: TYPE_NORMAL
- en: It would be great to spend time creating the ultimate graphics engine, or creating
    a content creation tool that can rival Unreal or Unity. However, if you strive
    to write perfect, flexible, 100% reusable code, you may never complete your game.
    You may end up writing a great particle system and have your designers only use
    10% of the capabilities. This is why many companies choose to use a premade engine
    in the first place. Those companies don't want to spend time or money on creating
    a tool. They want to spend time making a game that is fun.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite of this situation is just as bad. We don't want to write code that
    breaks whenever a change is introduced, or is impossible to use again. We can
    all imagine how ugly the code would be if an entire game was written in the standard
    `main` function. We might laugh at the thought of someone doing that, while at
    the same time hardcoding behavior with large if/else chains instead of using Finite
    State Machines.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the balance between these two extremes is difficult. I already mentioned
    that besides writing the initial code, there are additional factors to consider.
    These include the time it takes to test and debug the code as well as time to
    modify code if and when change occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Determining whether writing flexible code is worth the time also includes determining
    how likely that code is to change. This is why we are using Singleton classes
    for our core engines. These are unlikely to change during the project. Of course,
    if we need to support multiple graphics APIs, multiple platforms, or even a multithreaded
    environment, we might make a different decision. This is also why using the Component
    Object Model and Finite State Machines are very useful, since our game objects
    and their behavior are likely to change constantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we need to choose between using the Static Factory or the Dynamic
    Factory. The Static Factory is very simple to write and use. Since it is so simple,
    testing and debugging should be easy. It is likely to change, but those changes
    should be easy as well. However, when using the Static Factory, we must write,
    test, debug, and maintain code for at least three separate types in our game:
    the stages, components, and objects. These will change often during the development
    cycle. Each time a change occurs, you would need to go back and modify these functions.'
  prefs: []
  type: TYPE_NORMAL
- en: The templated Dynamic Factory is a little more difficult to implement, especially
    if you aren't very familiar with using templates. However, the major benefit of
    using the templated Dynamic Factory is that we only need to write the code once,
    and we can use it for stages, components, and objects. In addition, we have the
    ability to add, remove, or change items in our factories at runtime. As I mentioned,
    this could mean changing archetype builders based on difficulty to create harder
    versions of the same archetype without needing new enumeration values. Finally,
    we have the option of using this code again in another project, which is unlikely
    if we stick with the Static Factory.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the `M5Factory.h` file that contains the templated Dynamic factory
    is only around 125 lines of code, with maybe 30% of that being comments and white
    space. It may be a little more difficult, but I don't think it is so difficult
    that someone should prefer the Static Factory.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we focused a lot on decoupling code. Since our game design
    is very likely to change, we want to make sure that our high-level modules don''t
    depend on derived stages or components. That is why we should follow the Dependency
    Inversion Principle, which says the following:'
  prefs: []
  type: TYPE_NORMAL
- en: High-level modules should not depend on low-level modules. Both should depend
    on abstractions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstractions should not depend on details. Details should depend on abstractions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In simpler terms, this means that all our code should be built around the interfaces.
    We used the example of our `M5StageManager` not being dependent on derived `M5Stage`
    classes. Since we want to avoid class dependencies like this, we learned that
    we should also avoid *hard coding*, including using calls to the `new` operator.
    In order to avoid direct calls to the `new` operator, we learned about three ways
    to make Factories.
  prefs: []
  type: TYPE_NORMAL
- en: The first method was the classic Gang of Four Factory method, which says we
    should create a hierarchy of classes, each capable of instantiating a single class.
    This method helped us get to our final solution, but wasn't quite good enough,
    because we want to be able to select which derived class to instantiate via a
    string or an enum.
  prefs: []
  type: TYPE_NORMAL
- en: The second method we learned was the Static Factory Method, which uses a simple
    global or static function and a switch statement to allow us to select our desired
    derived class. This works great for our needs, but we decided to go one step further
    and create an even more flexible, reusable factory.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about the Dynamic Factory, specifically the templated version
    of the Dynamic Factory, which combines both the classic Factory method and the
    Static Factory. The best part is that since we are using the power of C++ templates,
    we can reuse the code for stages and components, as well as objects.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, but especially in the last section, we discussed the
    balance between spending time writing flexible code versus over-architecting.
    Of course, one strong reason to study design patterns is to learn how to write
    great reusable code, but we always want to make sure it fits the project and fits
    within the project deadline.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this book is to help you understand when and where we should apply
    these patterns throughout a game. We already know how to create flexible game
    objects using components and Finite State Machines. Now that we know about the
    Dynamic factory, we have decoupled our stage and component creation from our core
    engine, making everything more reusable.
  prefs: []
  type: TYPE_NORMAL
- en: However, the ultimate goal is to make things so flexible that they can be changed
    from a text file or tool without the need to recompile anything. That is what
    we will learn how to do next.
  prefs: []
  type: TYPE_NORMAL
