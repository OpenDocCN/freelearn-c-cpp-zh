- en: Chapter 1. Under the Hood - Setting up the Backend
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 内部结构 - 设置后端
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: What is the heart of any given piece of software? The answer to this question
    becomes apparent gradually while building a full-scale project, which can be a
    daunting task to undertake, especially when starting from scratch. It’s the design
    and capability of the back-end that either drives a game forward with full force
    by utilizing its power, or crashes it into obscurity through unrealized potential.
    Here, we’re going to be talking about that very foundation that keeps any given
    project up and standing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何软件的核心是什么？在构建一个完整规模的项目过程中，这个问题的答案会逐渐显现出来，这本身可能是一项艰巨的任务，尤其是从零开始。是后端的设计和能力，要么通过利用其力量全力推动游戏前进，要么因为未实现的能力而使游戏陷入默默无闻。在这里，我们将讨论保持任何项目持续运行和站立的基础。
- en: 'In this chapter, we''re going to be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Utility functions and filesystem specifics for Windows and Linux operating systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows和Linux操作系统的实用函数和文件系统特定信息
- en: The basics of the entity component system pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体组件系统模式的基本原理
- en: Window, event, and resource management techniques
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口、事件和资源管理技术
- en: Creating and maintaining application states
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和维护应用程序状态
- en: Graphical user interface basics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形用户界面基础
- en: Essentials for the 2D RPG game project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D RPG 游戏项目的必备要素
- en: There's a lot to cover, so let's not waste any time!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多内容要介绍，所以我们不要浪费时间！
- en: Pacing and source code examples
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速度和源代码示例
- en: All of the systems we're going to be talking about here could have entire volumes
    dedicated to them. Since time, as well as paper, is limited, we're only going
    to be briefly reviewing their very basics, which is just enough to feel comfortable
    with the rest of the information presented here.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的所有系统都可以有整本书来专门介绍。由于时间和纸张都有限，我们只会简要回顾它们的基本原理，这足以让我们对这里提供的信息感到舒适。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that, although we won't be going into too much detail in this particular
    chapter, the code that accompanies this book is a great resource to look through
    and experiment with for more detail and familiarity. It's greatly recommended
    to review it while reading this chapter in order to get a full grasp of it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管我们在这章中不会深入细节，但本书附带的代码是一个很好的资源，可以查阅和实验以获得更多细节和熟悉度。强烈建议在阅读本章时回顾它，以便全面掌握。
- en: Common utility functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用实用函数
- en: 'Let''s start by taking a look at a common function, which is going to be used
    to determine the full absolute path to the directory our executable is in. Unfortunately,
    there is no unified way of doing this across all platforms, so we''re going to
    have to implement a version of this utility function for each one, starting with
    Windows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看一个常见的函数开始，这个函数将用于确定我们的可执行文件所在的目录的完整绝对路径。不幸的是，在所有平台上都没有统一的方法来做这件事，所以我们将不得不为每个平台实现这个实用函数的版本，从Windows开始：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, we check if the `RUNNING_WINDOWS` macro is defined. This is the basic
    technique that can be used to actually let the rest of the code base know which
    OS it's running on. Next, another definition is made, specifically for the Windows
    header files we're including. It greatly reduces the number of other headers that
    get included in the process.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查`RUNNING_WINDOWS`宏是否定义。这是一种基本技术，可以用来让代码库的其余部分知道它正在运行哪个操作系统。接下来，我们定义了另一个特定的定义，针对我们包含的Windows头文件。这大大减少了在过程中包含的其他头文件的数量。
- en: 'With all of the necessary headers for the Windows OS included, let us take
    a look at how the actual function can be implemented:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含了Windows OS的所有必要头文件后，让我们看看实际函数是如何实现的：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we obtain the handle to the process that was created by our executable
    file. After the temporary path buffer is constructed and filled with the path
    string, the name, and extension of our executable is removed. We top it off by
    adding a trailing slash to the end of the path and returning it as a `std::string`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取由我们的可执行文件创建的进程句柄。在构建并填充了临时路径缓冲区、路径字符串、名称和扩展名之后，我们移除可执行文件的名字和扩展名。然后，我们在路径末尾添加一个尾随斜杠，并将其作为`std::string`返回。
- en: 'It will also come in handy to have a way of obtaining a list of files inside
    a specified directory:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种方法可以获取指定目录内文件列表，那将非常有用：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just like the directory function, this is specific to the Windows OS. It returns
    a vector of strings that represent file names and extensions. Once one is constructed,
    a path string is cobbled together. The `l_search` argument is provided with a
    default value, in case one is not specified. All files are listed by default.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就像目录函数一样，这也是Windows特有的。它返回一个表示文件名和扩展名的字符串向量。一旦构建完成，就会拼接一个路径字符串。`l_search`参数提供了一个默认值，以防未指定。默认情况下列出所有文件。
- en: After creating a structure that will hold our search data, we pass it to another
    Windows specific function that will find the very first file inside a directory.
    The rest of the work is done inside a `do-while` loop, which checks if the located
    item isn't in fact a directory. The appropriate items are then pushed into a vector,
    which gets returned later on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个将保存我们的搜索数据的结构之后，我们将其传递给另一个Windows特定函数，该函数将找到目录中的第一个文件。其余的工作在`do-while`循环中完成，该循环检查找到的项目实际上是否不是目录。然后适当的项被推入一个向量，稍后返回。
- en: The Linux version
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux版本
- en: 'As mentioned previously, both of the preceding functions are only functional
    on Windows. In order to add support for systems running Linux-based OSes, we''re
    going to need to implement them differently. Let''s start by including proper
    header files:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这两个先前的函数仅在Windows上有效。为了添加对基于Linux的操作系统运行系统的支持，我们需要以不同的方式实现它们。让我们首先包括适当的头文件：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As luck would have it, Linux does offer a single-call solution to finding exactly
    where our executable is located:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Linux确实提供了一个单次调用的解决方案来找到我们的可执行文件的确切位置：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that we're still adding a trailing slash to the end.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仍然在末尾添加一个尾随斜杠。
- en: 'Obtaining a file list of a specific directory is slightly more complicated
    this time around:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 获取特定目录的文件列表这次稍微复杂一些：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We start off in the same fashion as before, by creating a vector of strings.
    A pointer to the directory stream is then obtained through the `opendir()` function.
    Provided it isn't `NULL`, we begin modifying the search string. Unlike the fancier
    Windows alternative, we can't just pass a search string into a function and let
    the OS do all of the matching. In this case, it falls more under the category
    of matching a specific search string inside a filename that gets returned, so
    star symbols that mean anything need to be trimmed out.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以之前相同的方式开始，通过创建一个字符串向量。然后通过`opendir()`函数获取目录流指针。如果它不是`NULL`，我们就开始修改搜索字符串。与更花哨的Windows替代方案不同，我们不能仅仅将一个搜索字符串传递给一个函数，然后让操作系统完成所有的匹配。在这种情况下，它更接近于匹配返回的文件名中的特定搜索字符串，因此需要剪除表示任何含义的星号符号。
- en: Next, we utilize the `readdir()` function inside a `while` loop that's going
    to return a pointer to directory entry structures one by one. We also want to
    exclude any directories from the file list, so the entry's type is checked for
    not being equal to `DT_DIR`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们利用`readdir()`函数在一个`while`循环中，该循环将逐个返回目录条目结构的指针。我们还想排除文件列表中的任何目录，因此检查条目的类型是否不等于`DT_DIR`。
- en: Finally, the string matching begins. Presuming we're not just looking for any
    file with any extension (represented by `"*.*"`), the entry's name will be compared
    to the search string by length first. If the length of the string we're searching
    is longer than the filename itself, it's safe to assume we don't have a match.
    Otherwise, the search string is analyzed again to determine whether the filename
    is important for a positive match. Its first character being a period would denote
    that it isn't, so the file name's ending segment of the same length as the search
    string is compared to the search string itself. If, however, the name is important,
    we simply search the filename for the search string.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，开始字符串匹配。假设我们不是在寻找任何具有任何扩展名的文件（用`"*.*"`表示），将首先根据长度比较条目的名称与搜索字符串。如果我们要搜索的字符串长度比文件名本身长，那么可以安全地假设我们没有匹配。否则，将再次分析搜索字符串以确定文件名对于正匹配是否重要。如果第一个字符是点，则表示它不重要，因此将文件名与搜索字符串相同长度的末尾部分与搜索字符串本身进行比较。然而，如果名称很重要，我们只需在文件名中搜索搜索字符串。
- en: Once the procedure is complete, the directory is closed and the vector of strings
    representing files is returned.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序完成，目录被关闭，表示文件的字符串向量被返回。
- en: Other miscellaneous helper functions
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他一些辅助函数
- en: 'Sometimes, as text files are being read, it''s nice to grab a string that includes
    spaces while still maintaining a whitespace delimiter. In cases like that, we
    can use quotes along with this special function that helps us read the entire
    quoted segment from a whitespace delimited file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在读取文本文件时，能够获取一个包含空格的字符串，同时仍然保持空白分隔符，这很方便。在这种情况下，我们可以使用引号以及这个特殊函数，它帮助我们从一个空白分隔的文件中读取整个引号部分：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first segment of the stream is fed into the argument string. If it does
    indeed start with a double quote, a `while` loop is initiated to append to said
    string until it ends with another double quote, or until the stream reaches the
    end. Lastly, all double quotes from the string are erased, giving us the final
    result.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 流的第一个部分被输入到参数字符串中。如果它确实以双引号开头，则会启动一个`while`循环，将字符串附加到其中，直到它以另一个双引号结束，或者直到流到达末尾。最后，从字符串中删除所有双引号，得到最终结果。
- en: 'Interpolation is another useful tool in a programmer''s belt. Imagine having
    two different values of something at two different points in time, and then wanting
    to predict what the value would be somewhere in between those two time frames.
    This simple calculation makes that possible:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 插值是程序员工具箱中的另一个有用工具。想象一下，在两个不同时间点有两个不同的值，然后想要预测在这两个时间框架之间的某个点值会是什么。这个简单的计算使得这成为可能：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, let''s take a look at a few functions that can help us center instances
    of `sf::Text` better:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看几个可以帮助我们更好地居中`sf::Text`实例的函数：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Working with SFML text can be tricky sometimes, especially when centering it
    is of paramount importance. Some characters, depending on the font and other different
    attributes, can actually exceed the height of the bounding box that surrounds
    the `sf::Text` instance. To combat that, the first function iterates through every
    single character of a specific text instance and fetches the font glyph used to
    represent it. Its height is then checked and kept track of, so that the maximum
    height of the entire text can be determined and returned.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SFML文本有时可能很棘手，尤其是在居中非常重要的时候。一些字符，根据字体和其他不同属性，实际上可以超过包围`sf::Text`实例的边界框的高度。为了解决这个问题，第一个函数遍历特定文本实例的每个字符，并获取表示它的字体字形。然后检查其高度并跟踪，以便确定整个文本的最大高度并返回。
- en: The second function can be used for setting the absolute center of a `sf::Text`
    instance as its origin, in order to achieve perfect results. After its local bounding
    box is obtained and the maximum height is calculated, this information is used
    to move the original point of our text to its center.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数可以用来设置`sf::Text`实例的绝对中心作为其原点，以便实现完美的结果。在获取其局部边界框并计算最大高度后，这些信息被用来将我们的文本的原始点移动到其中心。
- en: Generating random numbers
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成随机数
- en: 'Most games out there rely on some level of randomness. While it may be tempting
    to simply use the classical approach of `rand()`, it can only take you so far.
    Generating random negative or floating point numbers isn''t straightforward, to
    say the least, plus it has a very lousy range. Luckily, newer versions of C++
    provide the answer in the form of uniform distributions and random number engines:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏都依赖于一定程度上的随机性。虽然简单地使用`rand()`的经典方法可能很有吸引力，但它只能带你走这么远。生成随机负数或浮点数至少不是那么直接，而且它的范围非常糟糕。幸运的是，C++的新版本提供了统一分布和随机数发生器的形式作为答案：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, note the `include` statements. The `random` library provides us with
    everything we need as far as number generation goes. On top of that, we're also
    going to be using SFML's mutexes and locks, in order to prevent a huge mess in
    case our code is being accessed by several separate threads.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意`include`语句。`random`库为我们提供了生成数字所需的一切。除此之外，我们还将使用SFML的互斥锁和锁，以防止我们的代码被多个独立的线程访问时出现混乱。
- en: The `std::random_device` class is a random number generator that is used to
    seed the engine, which will be used for further generations. The engine itself
    is based on the *Marsenne Twister* algorithm, and produces high-quality random
    *unsigned integers* that can later be filtered through a **uniform distribution**
    object in order to obtain a number that falls within a specific range. Ideally,
    since it is quite expensive to keep constructing and destroying these objects,
    we're going to want to keep a single copy of this class around. For this very
    reason, we have integer and float distributions together in the same class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::random_device`类是一个随机数生成器，用于初始化引擎，该引擎将用于进一步的生成。引擎本身基于*Marsenne Twister*算法，并产生高质量的随机**无符号整数**，这些整数可以通过一个**均匀分布**对象进行过滤，以获得特定范围内的数字。理想情况下，由于构建和销毁这些对象相当昂贵，我们希望保留这个类的单个副本。正因为如此，我们在同一个类中将整数和浮点数分布放在一起。'
- en: 'For convenience, the parenthesis operators are overloaded to take in ranges
    of numbers of both *integer* and *floating point* types. They invoke the `Generate`
    method, which is also overloaded to handle both data types:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，圆括号运算符被重载以接受整数和浮点数类型的数字范围。它们调用`Generate`方法，该方法也被重载以处理这两种数据类型：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Before generation can begin, we must establish a lock in order to be thread-safe.
    Because the order of `l_min` and `l_max` values matters, we must check if the
    provided values aren't in reverse, and swap them if they are. Also, the uniform
    distribution object has to be reconstructed if a different range needs to be used,
    so a check for that is in place as well. Finally, after all of that trouble, we're
    ready to return the random number by utilizing the parenthesis operator of a distribution,
    to which the engine instance is fed in.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成开始之前，我们必须建立一个锁以确保线程安全。因为`l_min`和`l_max`值的顺序很重要，我们必须检查提供的值是否没有反转，如果是，则进行交换。此外，如果需要使用不同的范围，必须重建均匀分布对象，因此也设置了相应的检查。最后，在经历了所有这些麻烦之后，我们准备通过利用分布的圆括号运算符来返回随机数，并将引擎实例传递给它。
- en: Service locator pattern
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务定位器模式
- en: 'Often, one or more of our classes will need access to another part of our code
    base. Usually, it''s not a major issue. All you would have to do is pass a pointer
    or two around, or maybe store them once as data members of the class in need.
    However, as the amount of code grows, relationships between classes get more and
    more complex. Dependencies can increase to a point, where a specific class will
    have more arguments/setters than actual methods. For convenience''s sake, sometimes
    it''s better to pass around a single pointer/reference instead of ten. This is
    where the **service locator** pattern comes in:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们的一个或多个类将需要访问我们的代码库的另一个部分。通常，这不是一个大问题。你只需要传递一个或两个指针，或者可能将它们存储为需要类的数据成员。然而，随着代码量的增加，类之间的关系变得越来越复杂。依赖性可能会增加到某个程度，以至于一个特定的类将具有比实际方法更多的参数/设置器。为了方便起见，有时传递单个指针/引用而不是十个更好。这就是**服务定位器**模式发挥作用的地方：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, it's just a `struct` with multiple pointers to the core classes
    of our project. All of those classes are forward-declared in order to avoid unnecessary
    `include` statements, and thus a bloated compilation process.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它只是一个包含多个指向我们项目核心类指针的`struct`。所有这些类都是提前声明的，以避免不必要的`include`语句，从而减少编译过程的膨胀。
- en: Entity component system core
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体组件系统核心
- en: Let's get to the essence of how our game entities are going to be represented.
    In order to achieve highest maintainability and code compartmentalization, it's
    best to use composition. The entity component system allows just that. For the
    sake of keeping this short and sweet, we're not going to be delving too deep into
    the implementation. This is simply a quick overview for the sake of being familiar
    with the code that will be used down the line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的游戏实体将如何表示的本质。为了实现最高的可维护性和代码模块化，最好使用组合。实体组件系统正是如此。为了保持简洁，我们不会深入探讨实现细节。这只是一个为了熟悉后续将使用的代码的快速概述。
- en: 'The ECS pattern consists of three cornerstones that make it possible: entities,
    components, and systems. An entity, ideally, is simply an identifier, as basic
    as an integer. Components are containers of data that have next to no logic inside
    them. There would be multiple types of components, such as position, movable,
    drawable, and so on, that don''t really mean much by themselves, but when composed,
    will form complex entities. Such composition would make it incredibly easy to
    save the state of any entity at any given time.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ECS模式由三个基石组成，使其成为可能：实体、组件和系统。理想情况下，实体只是一个标识符，就像一个整数一样简单。组件是包含几乎没有逻辑的数据容器。会有多种类型的组件，如位置、可移动、可绘制等，它们本身并没有太多意义，但组合起来将形成复杂的实体。这种组合将使在任何给定时间保存任何实体的状态变得极其容易。
- en: 'There are many ways to implement components. One of them is simply having a
    base component class, and inheriting from it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实现组件的方式有很多。其中一种就是简单地拥有一个基类组件，并从中继承：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Component` type is simply an *enum class* that lists different types of
    components we can have in a project. In addition to that, this base class also
    offers a means of filling in component data from a string stream, in order to
    load them more easily when files are being read.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Component`类型只是一个*枚举类*，列出了我们可以在项目中拥有的不同类型的组件。除此之外，这个基类还提供了一种从字符串流中填充组件数据的方法，以便在读取文件时更容易地加载它们。'
- en: 'In order to properly manage sets of components that belong to entities, we
    would need some sort of manager class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确管理属于实体的组件集合，我们需要某种类型的管理类：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, this is a fairly basic approach at managing these sets of data
    we call entities. The `EntityId` data type is simply a type definition for an
    **unsigned integer**. Creation of components happens by utilizing a factory pattern,
    lambdas and templates. This class is also responsible for loading entities from
    files that may look a little like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一种相当基本的处理我们称之为实体的数据集的方法。`EntityId`数据类型只是一个**无符号整数**的类型定义。组件的创建是通过利用工厂模式、lambda表达式和模板来实现的。这个类还负责从可能看起来像这样的文件中加载实体：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Attributes` field is a bit mask, the value of which is used to figure out
    which component types an entity has. The actual component data is stored in this
    file as well, and later loaded through the `ReadIn` method of our component base
    class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Attributes`字段是一个位掩码，其值用于确定实体具有哪些组件类型。实际的组件数据也存储在这个文件中，并且通过组件基类的`ReadIn`方法进行加载。'
- en: 'The last piece of the puzzle in ECS design is systems. This is where all of
    the logic happens. Just like components, there can be many types of systems responsible
    for collisions, rendering, movement, and so on. Each system must inherit from
    the system''s base class and implement all of the pure virtual methods:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ECS设计中最后一部分是系统。这是所有逻辑发生的地方。就像组件一样，可以有负责碰撞、渲染、移动等多种类型的系统。每个系统都必须继承自系统的基类并实现所有纯虚方法：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Systems have signatures of components they use, as well as a list of entities
    that meet the requirements of said signatures. When an entity is being modified
    by the addition or removal of a component, every system runs a check on it in
    order to add it to or remove it from itself. Note the inheritance from the `Observer`
    class. This is another pattern that aids in communication between entities and
    systems.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 系统具有它们使用的组件签名，以及满足这些签名要求的实体列表。当一个实体通过添加或删除组件被修改时，每个系统都会运行检查，以便将其添加到或从自身中删除。注意从`Observer`类继承。这是另一种有助于实体和系统之间通信的图案。
- en: 'An `Observer` class by itself is simply an interface with one purely virtual
    method that must be implemented by all derivatives:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Observer`类本身只是一个接口，包含一个必须由所有派生类实现的纯虚方法：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It utilizes messages that get sent to all observers of a specific target. How
    the derivative of this class reacts to the message is completely dependent on
    what it is.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它利用发送给特定目标所有观察者的消息。这个类的派生对象如何响应消息完全取决于它本身。
- en: 'Systems, which come in all shapes and sizes, need to be managed just as entities
    do. For that, we have another manager class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 形状和大小各异的系统需要像实体一样进行管理。为此，我们还有一个管理类：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This too utilizes the factory pattern, in that types of different classes are
    *registered* by using templates and lambdas, so that they can be constructed later,
    simply by using a `System` data type, which is an `enum class`. Starting to see
    the pattern?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样利用了工厂模式，通过使用模板和lambda来注册不同类型的类，以便稍后可以通过使用`System`数据类型（它是一个`enum class`）来构建它们。开始看到模式了吗？
- en: 'The system manager owns a data member of type `MessageHandler`. This is another
    part of the observer pattern. Let us take a look at what it does:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理器拥有一个类型为`MessageHandler`的数据成员。这是观察者模式的一部分。让我们看看它做了什么：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Message handlers are simply collections of `Communicator` objects, as shown
    here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 消息处理器只是`Communicator`对象的集合，如下所示：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each possible type of `EntityMessage`, which is just another *enum class*, is
    tied to a communicator that is responsible for sending out a message to all of
    its observers. Observers can subscribe to or unsubscribe from a specific message
    type. If they are subscribed to said type, they will receive the message when
    the `Dispatch` method is invoked.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每种可能的`EntityMessage`类型（它只是一个`enum class`）都与一个负责向所有观察者发送消息的通信器相关联。观察者可以订阅或取消订阅特定消息类型。如果他们订阅了该类型，当调用`Dispatch`方法时，他们将接收到该消息。
- en: 'The `Communicator` class itself is fairly simple:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Communicator` 类本身相当简单：'
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can gather, it supports the addition and removal of observers, and offers
    a way to broadcast a message to all of them. The actual container of observers
    is simply a vector of pointers:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，它支持添加和删除观察者，并提供了一种向所有观察者广播消息的方法。观察者的实际容器只是一个指针的向量：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Resource management
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源管理
- en: 'Another vital part of larger projects is an efficient way of managing resources.
    Since we''re going to have several types of resources, such as textures, fonts,
    and sounds, it would make sense to have separate managers for all of them. It''s
    time for a base class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在较大的项目中，另一个至关重要的部分是有效管理资源的方法。由于我们将拥有几种不同类型的资源，例如纹理、字体和声音，因此为所有这些资源分别拥有单独的管理器是有意义的。是时候有一个基类了：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The idea behind this particular resource management system is certain segments
    of code *requiring* and later *releasing* a certain resource identifier. The first
    time a resource is required it will be loaded into memory and kept there. Every
    time it's required after that will simply increment an integer that gets stored
    with it. The integer represents how many instances of code rely on this resource
    being loaded. Once they are done using the resource, it begins being released,
    which brings the counter down each time. When it reaches zero, the resource is
    removed from memory.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定资源管理系统的理念是某些代码段需要并随后释放特定的资源标识符。第一次需要资源时，它将被加载到内存中并保留在那里。之后每次需要时，将简单地增加一个与之存储的整数。这个整数表示依赖于该资源加载的代码实例的数量。一旦它们完成使用资源，它就开始释放，每次都会减少计数器。当它达到零时，资源将从内存中删除。
- en: 'It''s fair to point out that our resource manager base class utilizes the **Curiously
    Recurring Template Pattern** for setting up the resource instances after they''re
    created. As manager classes don''t really need to be stored together in the same
    container anywhere, static polymorphism makes a lot more sense than using virtual
    methods. Since textures, fonts, and sounds may be loaded in different ways, each
    subsequent manager must implement their own version of the `Load` method, like
    so:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，我们的资源管理器基类在创建资源实例之后使用**奇特重复的模板模式**来设置资源实例。由于管理器类实际上不需要在任何地方存储在一起，因此静态多态比使用虚方法更有意义。由于纹理、字体和声音可能以不同的方式加载，每个后续管理器都必须实现自己的`Load`方法版本，如下所示：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each single manager also has its own file, listing the relationships between
    names of resources and their paths. For textures, it can look something like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的管理器都有自己的文件，列出资源名称和它们路径之间的关系。对于纹理，它可以看起来像这样：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It simply avoids the need to pass around paths and filenames, by instead relating
    a name to each resource.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过将每个资源与一个名称相关联，简单地避免了传递路径和文件名，从而避免了这种需求。
- en: Windows system
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口系统
- en: 'There''s a lot that goes on behind the scenes when it comes to dealing with
    open windows. Everything from window dimensions and titles to keeping track of
    and dealing with special events is centralized within a designated window class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理打开的窗口时，幕后有很多事情在进行。从窗口尺寸和标题到跟踪和处理特殊事件，所有这些都在一个指定的窗口类中集中处理：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note the two highlighted methods. They will be used as call-backs in the event
    manager we'll discuss in the near future. Also note the return method for an object
    type `Renderer`. It’s a utility class that simply invokes the `.draw` call on
    a `RenderWindow`, thus localizing it and making it much easier to use shaders.
    More information on that will be revealed in [Chapter 6](ch06.html "Chapter 6. Adding
    Some Finishing Touches - Using Shaders"), *Adding Some Finishing Touches – Using
    Shaders*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两个突出显示的方法。它们将在我们即将讨论的事件管理器中用作回调。同时注意对象类型`Renderer`的返回方法。它是一个实用类，它简单地在一个`RenderWindow`上调用`.draw`方法，从而将其本地化并使其使用着色器变得更加容易。关于这一点，将在[第6章](ch06.html
    "第6章。添加一些收尾工作 - 使用着色器")中详细介绍，*添加一些收尾工作 – 使用着色器*。
- en: Application states
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序状态
- en: 'Another important aspect of a more complex application is keeping track of
    and managing its states. Whether the player is in the thick of the game, or simply
    browsing through the main menu, we want it to be handled seamlessly, and more
    importantly, be self-contained. We can start this by first defining different
    types of states we''ll be dealing with:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的应用程序的一个重要方面是跟踪和管理其状态。无论是玩家正在游戏中深入，还是简单地浏览主菜单，我们都希望它能够无缝处理，更重要的是，它应该是自包含的。我们可以通过首先定义我们将要处理的不同状态类型来开始这个过程：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For seamless integration, we want each state to behave in a predictable manner.
    This means that a state has to adhere to an interface we provide:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现无缝集成，我们希望每个状态都能以可预测的方式表现。这意味着状态必须遵循我们提供的接口：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Every state in the game will have its own view that it can alter. In addition
    to that, it is given the hooks to implement logic for various different scenarios,
    such as the state's creation, destruction, activation, deactivation, updating,
    and rendering. Lastly, it enables the possibility of being blended with other
    states during updating and rendering, by providing the `m_transparent` and `m_transcendent`
    flags.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的每个状态都将拥有自己的视图，它可以进行修改。除此之外，它还提供了钩子来实现各种不同场景的逻辑，例如状态的创建、销毁、激活、去激活、更新和渲染。最后，它通过提供`m_transparent`和`m_transcendent`标志，使得在更新和渲染过程中能够与其他状态混合。
- en: 'Managing these states is pretty straightforward:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 管理这些状态相当直接：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `StateManager` class is one of the few classes in the project that utilizes
    the shared context, since the states themselves may need access to any part of
    the code base. It also uses the factory pattern to dynamically create any state
    that is bound to a state type during runtime.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateManager`类是项目中少数几个使用共享上下文的类之一，因为状态本身可能需要访问代码库的任何部分。它还使用工厂模式在运行时动态创建任何与状态类型绑定的状态。'
- en: In order to keep things simple, we're going to be treating the loading state
    as a special case, and only allow one instance of it to be alive at all times.
    Loading might happen during the transition of any state, so it only makes sense.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将把加载状态视为一个特殊情况，并始终只允许一个实例存在。加载可能发生在任何状态的转换过程中，因此这样做是有意义的。
- en: 'One final thing that''s worth noting about the state manager is it''s keeping
    a list of state dependants. It''s simply an STL container of classes that inherit
    from this interface:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于状态管理值得注意的最后一件事是它维护一个状态依赖项列表。它只是一个从该接口继承的类的STL容器：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Because classes that deal with things such as sounds, GUI elements, or entity
    management need to support different states, they must also define what happens
    inside them as a state is created, changed, or removed, in order to properly allocate/de-allocate
    resources, stop updating data that is not in the same state, and so on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理声音、GUI元素或实体管理等事物的类需要支持不同的状态，因此它们还必须定义在状态创建、更改或删除时内部发生的事情，以便正确地分配/释放资源，停止更新不在同一状态中的数据，等等。
- en: Loading state
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载状态
- en: So, how exactly are we going to implement this loading state? Well, for flexibility
    and easy progress tracking by means of rendering fancy loading bars, threads are
    going to prove invaluable. Data that needs to be loaded into memory can be loaded
    in a separate thread, while the loading state itself continues to get updated
    and rendered in order to show us that things are indeed happening. Just knowing
    that the application did not hang on us should create a warm and fuzzy feeling.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们究竟将如何实现这个加载状态呢？嗯，为了灵活性和通过渲染花哨的加载条来轻松跟踪进度，线程将证明是无价的。需要加载到内存中的数据可以在单独的线程中加载，而加载状态本身则继续更新和渲染，以显示确实有事情在进行。仅仅知道应用程序没有挂起，就应该会让人感到温暖和舒适。
- en: 'First, let us implement the very basics of this system by providing an interface
    any threaded worker can use:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过提供一个任何线程工作者都可以使用的接口来实现这个系统的基本功能：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It has its own thread, which is bound to the pure virtual method called `Work`.
    The thread is launched whenever the `Begin()` method is invoked. In order to protect
    the data from being accessed from multiple threads at once, a `sf::Mutex` class
    is used by creating a lock during sensitive calls. Everything else within this
    very basic class is simply there to provide information to the outside world about
    the worker’s state.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 它有自己的线程，该线程绑定到名为`Work`的纯虚方法。每当调用`Begin()`方法时，线程就会被启动。为了保护数据不被多个线程同时访问，在敏感调用期间使用`sf::Mutex`类创建一个锁。这个非常基础的类中的其他一切只是为了向外界提供有关工作者状态的信息。
- en: File loader
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件加载器
- en: With threads out of the way, we can focus on actually loading some files now.
    This method is going to focus on working with text files. However, using binary
    formats should work in pretty much the exact same way, minus all the text processing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在线程的问题已经解决，我们可以专注于实际加载一些文件了。这个方法将专注于处理文本文件。然而，使用二进制格式应该以几乎相同的方式工作，只是没有文本处理。
- en: 'Let''s take a look at the base class for any file loading class we can think
    of:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看任何可想到的文件加载类的基类：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It's a distinct possibility that two or more files may need to be loaded at
    some point. The `FileLoader` class keeps track of all of the paths that get added
    to it, along with a number that represents the number of lines within that file.
    This is useful for determining the amount of progress that has been made while
    loading. In addition to the line count for each individual file, a total line
    count is also kept track of.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个明显的可能性，即在某些时候可能需要加载两个或更多文件。`FileLoader`类跟踪所有添加到其中的路径，以及代表该文件中行数的数字。这对于确定加载过程中所取得的进度非常有用。除了每个单独文件的行数外，还跟踪总行数。
- en: This class provides a single purely virtual method, called `ProcessLine`. It
    will be the way derivatives can define exactly how the file is loaded and processed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了一个单一的纯虚方法，称为`ProcessLine`。这将允许派生类定义文件的确切加载和处理方式。
- en: 'First, let us get the basic stuff out of the way:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们先处理一些基本的事情：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `ResetForNextFile()` virtual method is optional to implement, but can be
    used in order to clear the state of some internal data that needs to exist while
    a file is being loaded. Since file loaders that implement this class will only
    have the ability to process one line at a time inside a single method, any temporary
    data that would normally be stored as a local variable within that method would
    instead need to go somewhere else. This is why we must make sure that there is
    actually a way to know when we're done with one file and start loading another,
    as well as to perform some sort of action, if necessary.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResetForNextFile()`虚拟方法不是必须实现的，但可以用来清除在文件加载期间需要存在的某些内部数据的状态。由于实现此类的文件加载器将只能够在单个方法中一次处理一行，任何通常在该方法内部作为局部变量存储的临时数据都需要放在其他地方。这就是为什么我们必须确保实际上有一种方式可以知道我们何时完成了一个文件的加载并开始加载另一个文件，以及在必要时执行某种操作。'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the mutex locks in the two getter methods above. They’re there to make
    sure those variables aren’t written to and read from at the same time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上面两个获取方法中的互斥锁。它们的存在是为了确保那些变量不会被同时写入和读取。
- en: 'Now, let''s get into the code that is going to be executed in a different thread:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看将在不同线程中执行的一段代码：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: A private method for counting all the lines in whatever files are about to be
    loaded is called first. If, for any reason, the total line count is zero, there
    is no purpose in proceeding, so the `Worker::Done()` method is invoked just before
    a return. This little bit of code is really easy to forget, but is extremely important
    in order for this to work. All it does is set the `m_done` flag of the `Worker`
    base class to `true`, which lets outside code know that the process is finished.
    Since there is currently no way to check if an SFML thread is actually finished,
    this is pretty much the only option.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先调用一个私有方法来计算即将加载的任何文件中的所有行数。如果由于任何原因，总行数为零，继续下去没有意义，因此在返回之前调用`Worker::Done()`方法。这段代码非常容易忘记，但对于使此功能正常工作至关重要。它所做的只是将`Worker`基类的`m_done`标志设置为`true`，这样外部代码就知道处理已经完成。由于目前没有检查SFML线程是否真正完成的方法，这几乎是唯一的选择。
- en: We begin looping through different files that need to get loaded and invoke
    the reset method before work begins. Note the lack of checking as we're attempting
    to open a file. This will be explained when we cover the next method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始循环遍历需要加载的不同文件，并在开始工作之前调用重置方法。注意，在尝试打开文件时没有进行检查。这将在介绍下一个方法时进行解释。
- en: As each line of the file is being read, it's important to make sure that all
    the line count information is updated. A temporary lock for the current thread
    is established, in order to prevent two threads from accessing the line count
    as its modified. In addition to that, lines that start with a pipe symbol are
    excluded, since this is our standard comment pragma.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取文件的每一行时，确保更新所有行数信息非常重要。为了防止两个线程同时访问正在修改的行数，为当前线程建立了一个临时锁。此外，以管道符号开头的行被排除在外，因为这是我们标准的注释说明。
- en: Finally, a `stringstream` object is constructed for the current line, and passed
    into the `ProcessLine()` method. For extra points, it returns a *boolean* value
    that can signal an error and stop the current file from being processed any further.
    If that happens, the remaining lines within that specific file are added to the
    total count, and the loop is broken.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为当前行构造了一个`stringstream`对象，并将其传递给`ProcessLine()`方法。为了加分，它返回一个布尔值，可以表示错误并停止当前文件的处理。如果发生这种情况，该特定文件中的剩余行将添加到总行数中，并且循环被中断。
- en: 'The final piece of the puzzle is this chunk of code, responsible for verifying
    file validity and determining the amount of work ahead of us:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一块拼图是这段代码，负责验证文件的有效性并确定我们面前的工作量：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After initial zero values for line counts are set up, all added paths are iterated
    over and checked. We first trim out any paths that are empty. Each path is then
    attempted to be opened, and erased if that operation fails. Finally, in order
    to achieve accurate results, the file input stream is ordered to ignore empty
    lines. After a lock is established, `std::count` is used to count the amount of
    lines in a file. That number is then added to the amount of total lines we have,
    the path iterator is advanced, and the file is properly closed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置行数的初始零值后，遍历所有添加的路径并进行检查。我们首先删除任何空路径。然后尝试打开每个路径，如果操作失败则删除。最后，为了获得准确的结果，文件输入流被设置为忽略空行。在建立锁之后，使用`std::count`来计算文件中的行数。然后将这个数字添加到总行数中，路径迭代器前进，文件被正确关闭。
- en: Since this method eliminates files that were either non-existent or unable to
    be opened, there is no reason to check for that again anywhere else.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此方法消除了不存在或无法打开的文件，因此没有必要在其他任何地方再次检查这些文件。
- en: Implementing the loading state
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现加载状态
- en: 'Everything is now in place in order for us to successfully implement the loading
    state:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有东西都已经就绪，我们可以成功实现加载状态：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The state itself will keep a vector of pointers to different file loader classes,
    which will have lists of their own files respectively. It also provides a way
    for these objects to be added. Also, note the `Proceed()` method. This is another
    call-back that will be used in the event manager we're about to cover soon.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 状态本身将保留一个指向不同文件加载类指针的向量，这些类分别有自己的文件列表。它还提供了一种将这些对象添加到其中的方法。此外，请注意`Proceed()`方法。这是在即将介绍的的事件管理器中将要使用的一个回调。
- en: 'For the visual portion, we will be using the bare essentials of graphics: a
    bit of text for the progress percentage, and a rectangle shape that represents
    a loading bar.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视觉部分，我们将使用图形的最基本要素：一些文本表示进度百分比，以及一个表示加载条的矩形形状。
- en: 'Let''s take a look at all of the setup this class will do once it''s constructed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个类构建后将要进行的所有设置：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, a font manager is obtained through the shared context. The font with
    a name `"Main"` is required and used to set up the text instance. After all of
    the visual bits are set up, the event manager is used to register a call-back
    for the loading state. This will be covered soon, but it's quite easy to deduce
    what's happening by simply looking at the arguments. Whenever the spacebar is
    pressed, the `Proceed` method of the `State_Loading` class is going to be invoked.
    The actual instance of the class is passed in as the last argument.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过共享上下文获取字体管理器。需要并使用名为`"Main"`的字体来设置文本实例。在所有视觉元素设置完毕后，使用事件管理器为加载状态注册回调。这将在稍后介绍，但通过查看参数可以很容易地推断出正在发生的事情。每当按下空格键时，`State_Loading`类的`Proceed`方法将被调用。实际的类实例作为最后一个参数传递。
- en: 'Remember that, by design, the resources we require must also be released. A
    perfect place to do that for the loading state is exactly as it is destroyed:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，按照设计，我们需要的资源也必须被释放。对于加载状态来说，一个完美的释放位置就是它被销毁的时候：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In addition to the font being released, the call-back for the spacebar is also
    removed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了释放字体外，空格键的回调也被移除。
- en: 'Next, let us actually write some code that''s going to bring the pieces together
    into a cohesive, functional whole:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实际编写一些代码，将各个部分组合成一个完整、功能性的整体：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first check is used to determine if all of the file loaders have been removed
    from the vector due to finishing. The `m_manualContinue` flag is used to let the
    loading state know if it should wait for the spacebar to be pressed, or if it
    should just dispel itself automatically. If, however, we still have some loaders
    in the vector, the top one is checked for having concluded its work. Given that's
    the case, the loader is popped and the vector is checked again for being empty,
    which would require us to update the loading text to represent completion.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个检查用于确定是否由于完成而将所有文件加载器从向量中移除。`m_manualContinue`标志用于让加载状态知道它是否应该等待空格键被按下，或者如果应该自动消失。然而，如果我们仍然有一些加载器在向量中，我们将检查顶部加载器是否已完成其工作。如果是这样，加载器将被弹出，并再次检查向量是否为空，这将需要我们更新加载文本以表示完成。
- en: To keep this process fully automated, we need to make sure that after the top
    file loader is removed, the next one is started, which is where the following
    check comes in. Finally, the progress percentage is calculated, and the loading
    text is updated to represent that value, just before the loading bar's size is
    adjusted to visually aid us.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个过程完全自动化，我们需要确保在顶文件加载器被移除后，下一个加载器开始工作，这就是下面检查的作用所在。最后，计算进度百分比，并在调整加载条大小以视觉辅助我们之前，更新加载文本以表示该值。
- en: 'Drawing is going to be extremely straightforward for this state:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此状态，绘图将非常简单：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The render window is first obtained through the shared context, and then used
    to draw the text and rectangle shape that represent the loading bar together.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先通过共享上下文获取渲染窗口，然后使用它来绘制代表加载条的文本和矩形形状。
- en: 'The `Proceed` call-back method is equally straightforward:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Proceed`回调方法同样简单：'
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It has to make a check first, to make sure that we don't switch states before
    all the work is through. If that's not the case, the state manager is used to
    switch to a state that was created **before** the loading commenced.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须先进行检查，以确保在所有工作完成之前不切换状态。如果不是这种情况，则使用状态管理器切换到在加载开始之前创建的状态。
- en: 'All of the other loading state logic pretty much consists of single lines of
    code for each method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 其他所有加载状态逻辑基本上由每个方法的单行代码组成：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Although this looks fairly simple, the `Activate()` method holds a fairly important
    role. Since the loading state is treated as a special case here, one thing has
    to be kept in mind: it is *never* going to be removed before the application is
    closed. This means that every time we want to use it again, some things have to
    be reset. In this case, it''s the `m_originalWork` data member, that''s simply
    the count of all the loader classes. This number is used to calculate the progress
    percentage accurately, and the best place to reset it is inside the method, which
    gets called every time the state is activated again.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来相当简单，但`Activate()`方法扮演着相当重要的角色。由于在这里将加载状态视为一个特殊情况，必须记住一件事：它**永远不会**在应用程序关闭之前被移除。这意味着每次我们再次使用它时，都必须重置一些东西。在这种情况下，是`m_originalWork`数据成员，它只是所有加载类数量的计数。这个数字用于准确计算进度百分比，而重置它的最佳位置是在每次状态再次激活时被调用的方法内部。
- en: Managing application events
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理应用程序事件
- en: 'Event management is one of the cornerstones that provide us with fluid control
    experience. Any key presses, window changes, or even custom events created by
    the GUI system we''ll be covering later are going to be processed and handled
    by this system. In order to effectively unify event information coming from different
    sources, we first must unify their types by enumerating them correctly:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 事件管理是我们提供流畅控制体验的基石之一。任何按键、窗口变化，甚至是稍后我们将要介绍的GUI系统创建的定制事件都将由这个系统处理和解决。为了有效地统一来自不同来源的事件信息，我们首先必须通过正确枚举它们来统一它们的类型：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'SFML events come first, since they are the only ones following a strict enumeration
    scheme. They are then followed by the live SFML input types and four GUI events.
    We also enumerate event information types, which are going to be used inside this
    structure:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: SFML事件排在首位，因为它们是唯一遵循严格枚举方案的。然后是实时SFML输入类型和四个GUI事件。我们还枚举了事件信息类型，这些类型将用于此结构中：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Because we care about more than just the event type that took place, there needs
    to be a good way of storing additional data that comes with it. C++11's unrestricted
    union is a perfect candidate for that. The only downside is that now we have to
    worry about manually managing the data inside the union, which comes complete
    with data allocations and direct invocation of destructors.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不仅关心发生的事件类型，还需要有一种良好的方式来存储与之相关的附加数据。C++11的无限制联合是这一点的完美候选人。唯一的缺点是现在我们必须手动管理联合内部的数据，这包括数据分配和直接调用析构函数。
- en: 'As event call-backs are being invoked, it''s a good idea to provide them with
    the actual event information. Because it''s possible to construct more complex
    requirements for specific call-backs, we can''t get away with unions this time.
    Any possible information that may be relevant needs to be stored, and that''s
    precisely what is done here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件回调被调用时，向它们提供实际的事件信息是个好主意。因为可以为特定的回调构造更复杂的要求，所以我们这次不能使用联合。任何可能相关的信息都需要被存储，这正是这里所做的事情：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This structure is filled with every single bit of information that is available
    as the events are processed, and then passed as an argument to the call-back that
    gets invoked. It also provides a `Clear()` method, because instead of being created
    only for the time during the call-back, it lives inside the binding structure:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构填充了在事件处理过程中可用的所有信息，然后作为参数传递给被调用的回调。它还提供了一个`Clear()`方法，因为它的创建不仅限于回调期间，而是存在于绑定结构内部：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A binding is what actually allows events to be grouped together in order to
    form more complex requirements. Think of it in terms of multiple keys needing
    to be pressed at once in order to perform an action, such as *Ctrl* + *C* for
    copying a piece of text. A binding for that type of situation would have two events
    it''s waiting for: the *Ctrl* key and the *C* key.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定实际上允许事件被分组在一起，以形成更复杂的要求。从多个键需要同时按下以执行操作的角度来考虑，例如*Ctrl* + *C*复制文本。这种情况的绑定将等待两个事件：*Ctrl*键和*C*键。
- en: Event manager interface
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件管理器接口
- en: 'With all of the key pieces being covered, all that''s left is actually managing
    everything properly. Let''s start with some type definitions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在涵盖了所有关键部分之后，剩下的就是正确管理一切。让我们从一些类型定义开始：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'All bindings are attached to specific names that get loaded from a `keys.cfg`
    file when the application is started. It follows a basic format like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所有绑定都附加到特定的名称上，当应用程序启动时从`keys.cfg`文件中加载。它遵循一个基本格式，如下所示：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Of course these are very basic examples. More complex bindings would have multiple
    events separated by white spaces.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些都是非常基础的例子。更复杂的绑定会有多个通过空格分隔的事件。
- en: 'Call-backs are also stored in an *unordered map*, as well as tied to the name
    of a binding that they''re watching. The actual call-back containers are then
    grouped by state, in order to avoid multiple functions/methods getting called
    when similar keys are pressed. As you can imagine, the event manager is going
    to be inheriting from a `StateDependent` class for this very reason:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 回调也存储在一个*无序映射*中，以及与它们监视的绑定的名称相关联。然后根据状态对实际的回调容器进行分组，以避免在按下类似键时调用多个函数/方法。正如你可以想象的那样，事件管理器将继承自`StateDependent`类，正是出于这个原因：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once again, this is quite simple. Since this is a state-dependent class, it
    needs to implement the `ChangeState()` and `RemoveState()` methods. It also keeps
    track of when the window focus is obtained/lost, in order to avoid polling events
    of minimized/unfocused windows. Two versions of `AddCallback` are provided: one
    for a specified state, and one for the current state. Separate `HandleEvent()`
    methods are also available for every event type supported. So far, we only have
    two: SFML events, and GUI events. The latter is going to be used in the upcoming
    section.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这相当简单。由于这是一个状态相关的类，它需要实现`ChangeState()`和`RemoveState()`方法。它还跟踪窗口焦点何时获得/丢失，以避免轮询最小化/未聚焦窗口的事件。提供了两种版本的`AddCallback`：一个用于指定状态，另一个用于当前状态。还有为支持的所有事件类型提供的单独的`HandleEvent()`方法。到目前为止，我们只有两种：SFML事件和GUI事件。后者将在下一节中使用。
- en: Use of graphical user interfaces
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形用户界面的使用
- en: 'A friendly way of interfacing with applications in a day and age where computers
    are basically a necessity inside every household is a must. The entire subject
    of GUIs could fill multiple books by itself, so for the sake of keeping this simple,
    we are only going to scratch the surface of what we have to work with:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个计算机基本上是每个家庭必需品的时代，以一种友好的方式与应用程序交互是必不可少的。GUI（图形用户界面）的整个主题本身就可以填满多本书，所以为了保持简单，我们只将触及我们必须要处理的部分：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Interface management, quite predictably, is also dependent on application states.
    The interfaces themselves are also assigned names, which is how they are loaded
    and stored. Mouse input, as well as text enter events, are both utilized in making
    the GUI system work, which is why this class actually uses the event manager and
    registers three call-backs with it. Not unlike other classes we have discussed,
    it also uses the factory method, in order to be able to dynamically create different
    types of elements that populate our interfaces.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接口管理，不出所料，也依赖于应用程序状态。接口本身也被分配了名称，这就是它们被加载和存储的方式。鼠标输入以及文本输入事件都被用于使GUI系统工作，这就是为什么这个类实际上使用了事件管理器，并与之注册了三个回调。与其他我们讨论过的类一样，它也使用工厂方法，以便能够动态创建填充我们接口的不同类型的元素。
- en: 'Interfaces are described as groups of elements, like so:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接口被描述为元素组，如下所示：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Each element also supports styles for the three different states it can be
    in: neutral, hovered, and clicked. A single style file describes what an element
    would look like under all of these conditions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素也支持它可能处于的三种不同状态的风格：中性、悬停和点击。一个单独的样式文件描述了元素在这些所有条件下的外观：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `Neutral` style serves as a base for the other two, which is why they only
    define attributes that are different from it. Using this model, interfaces of
    great complexity can be constructed and customized to do almost anything.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Neutral`样式是其他两种样式的基础，这就是为什么它们只定义与它不同的属性。使用这种模型，可以构建和定制具有高度复杂性的接口，几乎可以完成任何事情。'
- en: Representing a 2D map
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示2D地图
- en: 'Maps are another crucial part of having a decently complex game. For our purposes,
    we''re going to be representing 2D maps that support different layers in order
    to fake 3D depth:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 地图是拥有一个复杂游戏的关键部分之一。就我们的目的而言，我们将表示支持不同层级的2D地图，以模拟3D深度：
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As you can see, this class is actually inheriting from the `FileLoader`, which
    we covered earlier. It also supports something that''s referred to as `MapLoadee*`,
    which are simply classes that will store certain data inside map files, and need
    to be notified when such data is encountered during the loading process. It''s
    simply an interface that they have to implement:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个类实际上是从我们之前提到的`FileLoader`继承的。它还支持一种称为`MapLoadee*`的功能，这些只是将某些数据存储在地图文件中的类，并在加载过程中遇到此类数据时需要通知。它只是一个它们必须实现的接口：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The map files themselves are fairly straightforward:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 地图文件本身相当简单：
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: A good candidate for a `MapLoadee` here would be a class that handles entities
    being spawned. The two entity lines would be directly handled by it, which creates
    a nice level of separation between codes that shouldn't really overlap.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个好的`MapLoadee`候选者是一个处理生成实体的类。两个实体行将直接由它处理，这为不应真正重叠的代码创建了一个很好的分离级别。
- en: Sprite system
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵系统
- en: 'Since we''re working on a 2D game, the most likely candidate for the way graphics
    are going to be done is a sprite sheet. Unifying the way sprite sheet cropping
    and animations are handled is key to not only minimizing code, but also creating
    a simple, neat interface that''s easy to interact with. Let us take a look at
    how that can be done:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在开发2D游戏，图形最有可能采用的方法是精灵图集。统一处理精灵图集裁剪和动画的方式不仅有助于最小化代码，还能创建一个简单、整洁且易于交互的接口。让我们看看如何实现这一点：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `SpriteSheet` class itself isn't really that complex. It offers helper methods
    for cropping the sheet down to a specific rectangle, altering the stored direction,
    defining different attributes, such as spacing, padding, and so on, and manipulating
    the animation data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpriteSheet`类本身并不复杂。它提供了将图集裁剪到特定矩形、更改存储方向、定义不同的属性（如间距、填充等）以及操作动画数据的方法。'
- en: 'Animations are stored in this class by name:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 动画通过名称存储在这个类中：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The interface of an animation class looks like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 动画类的接口看起来是这样的：
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: First, the `Frame` data type is simply a type definition of an integer. This
    class keeps track of all necessary animation data, and even provides a way to
    set up specific frame ranges (also referred to as actions), which can be used
    for something such as an entity only *attacking* something if the attack animation
    is within that specific action range.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Frame`数据类型只是一个整型的类型定义。这个类跟踪所有必要的动画数据，并提供了一种设置特定帧范围（也称为动作）的方法，这可以用于实体仅在攻击动画位于该特定动作范围内时攻击某物。
- en: The obvious thing about this class is that it does not represent any single
    type of animation, but rather all the common elements of every type. This is why
    three different purely virtual methods are provided, so that different types of
    animation can define how the frame step is handled, define the specific method,
    the location of cropping, and the exact process of the animation being loaded
    from a file. This helps us separate directional animations, where every row represents
    a character facing a different way, from simple, sequential animations of frames
    following each other in a linear order.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类明显的一点是它不代表任何单一类型的动画，而是代表每种类型动画的共同元素。这就是为什么提供了三个不同的纯虚方法，以便不同类型的动画可以定义如何处理帧步进、定义特定方法、裁剪位置以及从文件中加载动画的确切过程。这有助于我们区分方向动画，其中每一行代表一个朝向不同方向的字符，以及简单的、按线性顺序跟随的帧序列动画。
- en: Sound system
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音响系统
- en: 'Last, but definitely not least, the sound system deserves a brief overview.
    It probably would be a surprise to nobody at this point to learn that sounds are
    also reliant upon application states, which is why we''re inheriting from `StateDependent`
    again:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但绝对不是最不重要的，音响系统值得简要概述。在这个阶段，了解到声音同样依赖于应用程序状态，可能对任何人来说都不会感到惊讶，这就是为什么我们再次从`StateDependent`继承：
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `AudioManager` class is responsible for managing auditory resources, in
    the same way textures and fonts are managed elsewhere. One of the bigger differences
    here is that we can actually play sounds in 3D space, hence the use of a `sf::Vector3f`
    structure wherever a position needs to be represented. Sounds are also grouped
    by specific names, but there is a slight twist to this system. SFML can only handle
    about 255 different sounds playing all at once, which includes `sf::Music` instances
    as well. It's because of this that we have to implement a recycling system that
    utilizes discarded instances of sounds, as well as a static limit of the maximum
    number of sounds allowed all at once.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioManager` 类负责管理音频资源，就像纹理和字体在其他地方被管理一样。这里的一个较大差异是，我们实际上可以在3D空间中播放声音，因此当需要表示位置时，会使用
    `sf::Vector3f` 结构。声音也可以按特定名称分组，但这个系统有一个小小的转折。SFML只能同时处理大约255个不同的声音，这包括`sf::Music`实例。正因为如此，我们必须实现一个回收系统，该系统利用被丢弃的声音实例，以及一次允许的最大声音数量的静态限制。'
- en: 'Every different sound that is loaded and played has specific set up properties
    that can be tweaked. They are represented by this data structure:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每个加载和播放的不同声音都有特定的设置属性可以调整。它们由以下数据结构表示：
- en: '[PRE59]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`audioName` is simply the identifier of the audio resource that is loaded in
    memory. The volume of a sound can obviously be tweaked, as well as its pitch.
    The last two properties are slightly more intricate. A sound at a point in space
    would begin to grow quieter and quieter, as we begin to move away from it. The
    minimum distance property describes the unit distance from the sound source, after
    which the sound begins to lose its volume. The rate at which this volume is lost
    after that point is reached is described by the attenuation factor.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`audioName` 只是加载到内存中的音频资源的标识符。声音的音量显然可以调整，以及其音调。最后两个属性稍微复杂一些。在空间中的某个点，声音会开始变得越来越小，因为我们开始远离它。最小距离属性描述了从声音源的单位距离，在此距离之后，声音开始失去音量。达到该点后音量损失的速度由衰减因子描述。'
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That was quite a lot of information to take in. In the span of around forty
    pages we have managed to summarize the better part of the entire code base that
    would make any basic to intermediate complexity game tick. Keep in mind that although
    many topics got covered here, all of the information was rather condensed. Feel
    free to look through the code files we provide until you feel comfortable to proceed
    to actually building a game, which is precisely what's coming in the next chapter.
    See you there!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的信息量相当大。在约四十页的篇幅内，我们成功总结了整个代码库的大部分内容，这些内容足以让任何基础到中级复杂度的游戏运行。请记住，尽管这里涵盖了众多主题，但所有信息都相当精炼。请随意查阅我们提供的代码文件，直到您感到舒适地继续实际构建游戏，这正是下一章将要介绍的内容。我们那里见！
