- en: Chapter 6. Objects, Classes, and Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed functions as a way to bundle up a bunch
    of lines of related code. We talked about how functions abstracted away implementation
    details and how the `sqrt()` function does not require you to understand how it
    works internally to use it to find roots. This was a good thing, primarily because
    it saved the programmer time and effort, while making the actual work of finding
    square roots easier. This principle of *abstraction* will come up again here when
    we discuss objects.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, objects tie together methods and their related data into a single
    structure. This structure is called a *class*. The main idea of using objects
    is to create a code representation for every thing inside your game. Every object
    represented in the code will have data and associated functions that operate on
    that data. So you'd have an *object* to represent your player instance and related
    functions that make the player `jump()`, `shoot()`, and `pickupItem()` functions.
    You'd also have an object to represent every monster instance and related functions
    such as `growl()`, `attack()`, and possibly `follow()`.
  prefs: []
  type: TYPE_NORMAL
- en: Objects are types of variables, though, and objects will stay in memory as long
    as you keep them there. You create an object instance once when the thing in your
    game it represents is created, and you destroy the object instance when the thing
    in your game it represents dies.
  prefs: []
  type: TYPE_NORMAL
- en: Objects can be used to represent in-game things, but they can also be used to
    represent any other type of thing. For example, you can store an image as an object.
    The data fields will be the image's width of the image, its height, and the collection
    of pixels inside it. C++ strings are also objects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter contains a lot of keywords that might be difficult to grasp at
    first, including `virtual` and `abstract`.
  prefs: []
  type: TYPE_NORMAL
- en: Don't let the more difficult sections of this chapter bog you down. I included
    descriptions of many advanced concepts for completeness. However, bear in mind
    that you don't need to completely understand everything in this chapter to write
    working C++ code in UE4\. It helps to understand it, but if something doesn't
    make sense, don't get stuck. Give it a read and then move on. Probably what will
    happen is you will not get it at first, but remember a reference to the concept
    in question when you're coding. Then, when you open this book up again, "voilà!"
    It will make sense.
  prefs: []
  type: TYPE_NORMAL
- en: struct objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An object in C++ is basically any variable type that is made up of a conglomerate
    of simpler types. The most basic object in C++ is `struct`. We use the `struct`
    keyword to glue together a bunch of smaller variables into one big variable. If
    you recall, we did introduce `struct` briefly in [Chapter 2](part0022_split_000.html#KVCC2-dd4a3f777fc247568443d5ffb917736d
    "Chapter 2. Variables and Memory"), *Variables and Memory*. Let''s revise that
    simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is the structure definition for what makes a `Player` object. The player
    has a `string` for his `name` and an integer for his `hp` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ll recall from [Chapter 2](part0022_split_000.html#KVCC2-dd4a3f777fc247568443d5ffb917736d
    "Chapter 2. Variables and Memory"), *Variables and Memory*, the way we make an
    instance of the `Player` object is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we can access the fields of the `me` object like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, here's the exciting part. We can attach member functions to the `struct`
    definition simply by writing these functions inside the `struct Player` definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A member function is just a C++ function that is declared inside a `struct`
    or `class` definition. Isn't that a great idea?
  prefs: []
  type: TYPE_NORMAL
- en: There is a bit of a funny idea here, so I'll just come out and say it. The variables
    of `struct Player` are accessible to all the functions inside `struct Player`.
    Inside each of the member functions of `struct Player`, we can actually access
    the `name` and `hp` variables as if they were local to the function. In other
    words, the `name` and `hp` variables of `struct Player` are shared between all
    the member functions of `struct Player`.
  prefs: []
  type: TYPE_NORMAL
- en: The this keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some C++ code (in later chapters), you will see more references to the `this`
    keyword. The `this` keyword is a pointer that refers to the current object. Inside
    the `Player::damage()` function, for example, we can write our reference to `this`
    explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `this` keyword only makes sense inside a member function. We could explicitly
    include use of keyword `this` inside member functions, but without writing `this`,
    it is implied that we are talking about the `hp` of the current object.
  prefs: []
  type: TYPE_NORMAL
- en: Strings are objects?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yes! Every time you've used a string variable in the past, you were using an
    object. Let's try out some of the member functions of the `string` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What we've done here is use the `append()` member function to add on two extra
    characters to the end of the string (`!!`). Member functions always apply to the
    object that calls the member function (the object to the left of the dot).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see the listing of members and member functions available on an object, type
    the object's variable name in Visual Studio, then a dot (`.`), then press *Ctrl*
    and spacebar. A member listing will pop up.
  prefs: []
  type: TYPE_NORMAL
- en: '![Strings are objects?](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Pressing *Ctrl* and spacebar will make the member listing appear
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a member function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Member functions can be invoked with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The object invoking the member function is on the left of the dot. The member
    function to call is on the right of the dot. A member function invocation is always
    followed by round brackets `()`, even when no arguments are passed to the brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the part of the program where the monster attacks, we can reduce the
    player''s `hp` value like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Which isn''t that more readable than the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When member functions and objects are used effectively, your code will read
    more like prose or poetry than a bunch of operator symbols slammed together.
  prefs: []
  type: TYPE_NORMAL
- en: Besides beauty and readability, what is the point of writing member functions?
    Outside the `Player` object, we can now do more with a single line of code than
    just reduce the `hp` member by `15`. We can also do other things as we're reducing
    the player's `hp`, such as take into account the player's armor, check whether
    the player is invulnerable, or have other effects occur when the player is damaged.
    What happens when the player is damaged should be abstracted away by the `damage()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now think if the player had an armor class. Let''s add a field to `struct Player`
    for armor class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''d need to reduce the damage received by the player by the armor class of
    the player. So we''d type a formula now to reduce `hp`. We can do it the non-object-oriented
    way by accessing the data fields of the `player` object directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we can do it the object-oriented way by writing a member function
    that changes the data members of the `player` object as needed. Inside the `Player`
    object, we can write a member function `damage()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a subtle bug in the player''s `damage` function in the preceding code.
    Can you find and fix it? Hint: What happens if the damage dealt is less than `armorClass`
    of the player?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having only a number for armor class doesn't give enough information about the
    armor! What is the armor's name? What does it look like? Devise a `struct` function
    for the Player's armor with fields for name, armor class, and durability rating.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The solution is in the `struct` player code listed in the next section, *Privates
    and encapsulation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance of `Armor` will then be placed inside `struct Player`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This means the player has an armor. Keep this in mind—we'll explore `has-a`
    versus `is-a` relationships later.
  prefs: []
  type: TYPE_NORMAL
- en: Privates and encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So now we've defined a couple of member functions, whose purpose it is to modify
    and maintain the data members of our `Player` object, but some people have come
    up with an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An object's data members should only ever be accessed only through its member
    functions, never directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that you should never access an object''s data members from outside
    the object directly, in other words, modify the player''s `hp` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be forbidden, and users of the class should be forced to use the
    proper member functions instead to change the values of data members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This principle is called *encapsulation*. Encapsulation is the concept that
    every object should be interacted via its member functions only. Encapsulation
    says that raw data members should never be accessed directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reasons behind encapsulation are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**To make the class self contained**: The primary idea behind encapsulation
    is that objects work best when they are programmed such that they manage and maintain
    their own internal state variables without a need for code outside the class to
    examine that class'' private data. When objects are coded this way, it makes the
    object much easier to work with, that is, easier to read and maintain. To make
    the player object jump, you should just have to call `player.jump()`; let the
    player object manage state changes to its `y-height` position (making the player
    jump!). When an object''s internal members are not exposed, interacting with that
    object is much easier and more efficient. Interact only with an object''s public
    member functions; let the object manage its internal state (we will explain the
    keywords `private` and `public` in a moment).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To avoid breaking code**: When code outside of a class interacts with that
    class'' public member functions only (the class'' public interface), then an object''s
    internal state management is free to change, without breaking any of the calling
    code. This way, if an object''s internal data members change for any reason, all
    code using the object still remains valid as long as the member functions remain
    the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So how can we prevent the programmer from doing the wrong thing and accessing
    data members directly? C++ introduces the concept of *access modifiers* to prevent
    access of an object's internal data.
  prefs: []
  type: TYPE_NORMAL
- en: Here is how we'd use access modifiers to forbid access to certain sections of
    `struct Player` from outside of `struct Player`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you''d do is decide which sections of the `struct` definition
    you want to be accessible outside of the class. These section will be labelled
    `public`. All other regions that will not be accessible outside of `struct` will
    be labelled `private`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Some people like it public
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some people do unabashedly use `public` data members and do not encapsulate
    their objects. This is a matter of preference, though considered as bad object-oriented
    programming practice.
  prefs: []
  type: TYPE_NORMAL
- en: However, classes in UE4 do use `public` members sometimes. It's a judgment call;
    whether a data member should be `public` or `private` is really up to the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: With experience, you will find that sometimes you get into a situation that
    requires quite a bit of refactoring when you make a data member `public` that
    should have been `private`.
  prefs: []
  type: TYPE_NORMAL
- en: class versus struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have seen a different way of declaring an object, using the `class`
    keyword, instead of `struct`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `class` and `struct` keywords in C++ are almost identical. There is only
    one difference between `class` and `struct`, and it is that the data members inside
    a `struct` keyword will be declared `public` by default, while in a `class` keyword
    the data members inside the class will be declared `private` by default. (This
    is why I introduced objects using `struct`; I didn't want to put `public` inexplicably
    as the first line of `class`.)
  prefs: []
  type: TYPE_NORMAL
- en: In general, `struct` is preferred for simple types that don't use encapsulation,
    don't have many member functions, and must be backward compatible with C. Classes
    are used almost everywhere else.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, let's use the `class` keyword instead of `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that once we slap `private` onto the `Player` class definition,
    we can no longer read or write the name of the player from outside the `Player`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try and read the name with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Or write to the name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `struct Player` definition with `private` members, we will get the
    following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is just what we asked for when we labeled the `name` field `private`. We
    made it completely inaccessible outside the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A getter (also known as an accessor function) is used to pass back copies of
    internal data members to the caller. To read the player''s name, we''d deck out
    the `Player` class with a member function specifically to retrieve a copy of that
    `private` data member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'So now it is possible to read the player''s name information. We can do this
    by using the following code statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Getters are used to retrieve `private` members that would otherwise be inaccessible
    to you from outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Real world tip–Keyword const**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside a class, you can add the `const` keyword to a member function declaration.
    What the `const` keyword does is promises to the compiler that the internal state
    of the object will not change as a result of running this function. Attaching
    the `const` keyword will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: No assignments to data members can happen inside a member function that is marked
    `const`. As the internal state of the object is guaranteed not to change as a
    result of running a `const` function, the compiler can make some optimizations
    around function calls to `const` member functions.
  prefs: []
  type: TYPE_NORMAL
- en: Setters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A setter (also known as a modifier function or mutator function) is a member
    function whose sole purpose is to change the value of an internal variable inside
    the class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So we can still change the `private` function of a `class` from outside the
    `class` function, but only if we do so through a setter function.
  prefs: []
  type: TYPE_NORMAL
- en: But what's the point of get/set operations?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So the first question that crosses a newbie programmer's mind when he first
    encounters get/set operations on `private` members is, isn't get/set self-defeating?
    I mean, what's the point in hiding access to data members when we're just going
    to expose that same data again in another way? It's like saying, "You can't have
    any chocolates because they are private, unless you say please `getMeTheChocolate()`.
    Then, you can have the chocolates."
  prefs: []
  type: TYPE_NORMAL
- en: 'Some expert programmers even shorten the get/set functions to one liners, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's answer the question. Doesn't a get/set pair break encapsulation by exposing
    the data completely?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is twofold. First, get member functions typically only return a copy
    of the data member being accessed. This means that the original data member's
    value remains protected and is not modifiable through a `get()` operation.
  prefs: []
  type: TYPE_NORMAL
- en: '`Set()` (mutator method) operations are a little bit counterintuitive though.
    If the setter is a `passthru` operation, such as `void setName( string newName
    ) { name=newName; }`, then having the setter might seem pointless. What is the
    advantage of using a mutator method instead of overwriting the variable directly?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument for using mutator methods is to write additional code before the
    assignment of a variable to guard the variable from taking on incorrect values.
    Say, for example, we have a setter for the `hp` data member, which will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The mutator method is supposed to prevent the internal `hp` data member from
    taking on negative values. You might consider mutator methods a bit retroactive.
    Should the responsibility lie with the calling code to check the value it is setting
    before calling `setHp( -2 )`, and not let that only get caught in the mutator
    method? Can't you use a `public` member variable and put the responsibility for
    making sure the variable doesn't take on invalid values in the calling code, instead
    of in the setter? You can.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is the core of the reason behind using mutator methods. The idea
    behind mutator methods is so that the calling code can pass any value it wants
    to the `setHp` function (for example, `setHp( -2 )`), without having to worry
    whether the value it is passing to the function is valid or not. The `setHp` function
    then takes the responsibility of ensuring that the value is valid for the `hp`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers consider direct mutator functions such as `getHp()`/`setHp()`
    a code smell. A code smell is in general a bad programming practice that people
    don't overtly take notice of, except for a niggling feeling that something is
    being done suboptimally. They argue that higher-level member functions can be
    written instead of mutators. For example, instead of a `setHp()` member function,
    we should have `public` member functions such as `heal()` and `damage()` instead.
    An article on this topic is available at [http://c2.com/cgi/wiki?AccessorsAreEvil](http://c2.com/cgi/wiki?AccessorsAreEvil).
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and destructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The constructor in your C++ code is a simple little function that runs once
    when the C++ object is first created. The destructor runs once when the C++ object
    is destroyed. Say we have the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So here we have created a `Player` object. The output of this code will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that happens during object construction is that the constructor
    actually runs. This prints the line `Player object constructed`. Following this,
    the line with the player''s name gets printed: `Player named ''Diplo''`. Why is
    the player named *Diplo*? Because that is the name assigned in the `Player()`
    constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at the end of the program, the player destructor gets called, and we
    see `Player object destroyed`. The player object gets destroyed when it goes out
    of scope at the end of `main()` (at `}` of `main`).
  prefs: []
  type: TYPE_NORMAL
- en: 'So what are constructors and destructors good for? Exactly what they appear
    to be for: setting up and tearing down of an object. The constructor can be used
    for initialization of data fields and the destructor to call delete on any dynamically
    allocated resources (we haven''t covered dynamically allocated resources yet,
    so don''t worry about this last point yet).'
  prefs: []
  type: TYPE_NORMAL
- en: Class inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You use inheritance when you want to create a new, more functional class of
    code, based on some existing class of code. Inheritance is a tricky topic to cover.
    Let's start with the concept of a *derived class* (or subclass).
  prefs: []
  type: TYPE_NORMAL
- en: Derived classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most natural way to consider inheritance is by analogy with the animal
    kingdom. The classification of living things is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Derived classes](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What this diagram means is that **Dog**, **Cat**, **Horse** **,** and **Human**
    are all **Mammals**. What that means is that dog, cat, horse, and human all share
    some common characteristics, such as having common organs (brain with neocortex,
    lungs, liver, and uterus in females), while being completely different in other
    regard. How each walks is different. How each talks is also different.
  prefs: []
  type: TYPE_NORMAL
- en: What does that mean if you were coding creatures? You would only have to program
    the common functionality once. Then, you would implement the code for the different
    parts specifically for each of the dog, cat, horse and human classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A concrete example of the preceding figure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: All of `Dog`, `Cat`, and `Human` inherit from `class Mammal`. This means that
    dog, cat, and human are mammals, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax of inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax of inheritance is quite simple. Let''s take the `Human` class definition
    as an example. The following screenshot is a typical inheritance statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Syntax of inheritance](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The class on the left of the colon (**:**) is the new, derived class, and the
    class on the right of the colon is the base class.
  prefs: []
  type: TYPE_NORMAL
- en: What does inheritance do?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The point of inheritance is for the derived class to take on all the characteristics
    (data members, member functions) of the base class, and then to extend it with
    even more functionality. For instance, all mammals have a `breathe()` function.
    By inheriting from the `Mammal` class, the `Dog`, `Cat`, and `Human` classes all
    automatically gain the ability to `breathe()`.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance reduces replication of code since we don't have to re-implement
    common functionalities (such as `.breathe()`) for `Dog`, `Cat`, and `Human`. Instead,
    each of these derived classes enjoys the reuse of the `breathe()` function defined
    in `class Mammal`.
  prefs: []
  type: TYPE_NORMAL
- en: However, only the `Human` class has the `attack()`member function. This would
    mean that, in our code, only the `Human` class attacks. The `cat.attack()` function
    will introduce a compiler error, unless you write a member function `attack()`
    inside `class Cat` (or in `class Mammal`).
  prefs: []
  type: TYPE_NORMAL
- en: is-a relationship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inheritance is often said to be an `is-a` relationship. When a `Human` class
    inherits from `Mammal` class, then we say that human *is-a* mammal.
  prefs: []
  type: TYPE_NORMAL
- en: '![is-a relationship](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Human inherits all the traits a Mammal has
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a `Human` object contains a `Mammal` function inside it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we would say the human *has-a* `Mammal` on it somewhere (which
    would make sense if the human were pregnant, or somehow carrying a mammal).
  prefs: []
  type: TYPE_NORMAL
- en: '![is-a relationship](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This Human class instance has some kind of mammal attached in it
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we previously gave `Player` an `Armor` object inside it. It wouldn't
    make sense for the `Player` object to inherit from the `Armor` class, because
    it wouldn't make sense to say *the Player is-an Armor*. When deciding whether
    one class inherits from another or not in code design (for example, the Human
    class inherits from the Mammal class), you must always be able to comfortably
    say something like the Human class *is-a* Mammal. If the *is-a* statement sounds
    wrong, then it is likely that inheritance is the wrong relationship for that pair
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we're introducing a few new C++ keywords here. The
    first is `protected`.
  prefs: []
  type: TYPE_NORMAL
- en: protected variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `protected` member variable is different from a `public` or `private` variable.
    All three classes of variables are accessible inside the class in which they are
    defined. The difference between them is in regard to accessibility outside the
    class. A `public` variable is accessible anywhere inside the class and outside
    the class. A `private` variable is accessible inside the class but not outside
    the class. A `protected` variable is accessible inside the class, and inside of
    derived subclasses, but is not accessible outside the class. So, the `hp` and
    `speed` members of `class Mammal` will be accessible in the derived classes Dog,
    Cat, Horse, and Human, but not outside of these classes (in `main()` for instance).
  prefs: []
  type: TYPE_NORMAL
- en: Virtual functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A virtual function is a member function whose implementation can be overridden
    in a derived class. In this example, the `talk()` member function (defined in
    `class Mammal`) is marked `virtual`. This means that the derived classes might
    or might not choose to implement their own version of what the `talk()` member
    function means.
  prefs: []
  type: TYPE_NORMAL
- en: Purely virtual functions (and abstract classes)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A purely virtual function is one whose implementation you are required to override
    in the derived class. The `walk()` function in `class Mammal` is purely virtual;
    it was declared like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `= 0` part at the end of the preceding code is what makes the function purely
    `virtual`.
  prefs: []
  type: TYPE_NORMAL
- en: The `walk()` function in `class Mammal` is purely `virtual` and this makes the
    Mammal class abstract. An abstract class in C++ is any class that has at least
    one purely virtual function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a class contains a purely virtual function and is abstract, then that class
    cannot be instantiated directly. That is, you cannot create a `Mammal` object
    now, on account of the purely virtual function `walk()`. If you tried to do the
    following code, you would get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to create a `Mammal` object, you will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can, however, create instances of derivatives of `class Mammal`, as long
    as the derived classes have all of the purely virtual member functions implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not everything multiple is as good as it sounds. Multiple inheritance is when
    a derived class inherits from more than one base class. Usually, this works without
    a hitch if the multiple base classes we are inheriting from are completely unrelated.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can have a class `Window` that inherits from the `SoundManager`
    and `GraphicsManager` base classes. If `SoundManager` provides a member function
    `playSound()` and `GraphicsManager` provides a member function `drawSprite()`,
    then the `Window` class will be able to use those additional capabilities without
    a hitch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple inheritance](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Game Window inheriting from Sound Man and Graphics Man means Game Window will
    have both sets of capabilities
  prefs: []
  type: TYPE_NORMAL
- en: However, multiple inheritance can have negative consequences. Say we want to
    create a class `Mule` that derives from both the `Donkey` and `Horse` classes.
    The `Donkey` and `Horse` classes, however, both inherit from the base class `Mammal`.
    We instantly have an issue! If we were to call `mule.talk()`, but `mule` does
    not override the `talk()` function, which member function should be invoked, that
    of `Horse` or `Donkey`? It's ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: private inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A less talked about feature of C++ is `private` inheritance. Whenever a class
    inherits from another class publicly, it is known to all code whose parent class
    it belongs to. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that all code will know that `Cat` is an object of `Mammal`, and
    it will be possible to point to a `Cat*` instance using a base class `Mammal*`
    pointer. For example, the following code will be valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is fine if `Cat` inherits from `Mammal` publicly. Private
    inheritance is where code outside the `Cat` class is not allowed to know the parent
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, externally calling code will not "know" that the `Cat` class derives from
    the `Mammal` class. Casting a `Cat` instance to the `Mammal` base class is not
    allowed by the compiler when inheritance is `private`. Use `private` inheritance
    when you need to hide the fact that a certain class derives from a certain parent
    class.
  prefs: []
  type: TYPE_NORMAL
- en: However, private inheritance is rarely used in practice. Most classes just use
    `public` inheritance. If you want to know more about private inheritance, see
    [http://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c](http://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c).
  prefs: []
  type: TYPE_NORMAL
- en: Putting your classes into headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our classes have just been pasted before `main()`. If you continue to
    program that way, your code will all be in one file and appear as one big disorganized
    mess.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is a good programming practice to organize your classes into separate
    files. This makes editing each class's code individually much easier when there
    are multiple classes inside the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take `class Mammal` and its derived classes from earlier. We will properly
    organize that example into separate files. Let''s do it in steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in your C++ project called `Mammal.h`. Cut and paste the entire
    `Mammal` class into that file. Notice that since the `Mammal` class included the
    use of `cout`, we write a `#include <iostream>` statement in that file as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a " `#include` `Mammal.h`" statement at the top of your `Source.cpp` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An example of what this looks like is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting your classes into headers](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What's happening here when the code is compiled is that the entire `Mammal`
    class is copied and pasted (#include) into the `Source.cpp` file, which contains
    the `main()` function, and the rest of the classes are derived from `Mammal`.
    Since `#include` is a copy and paste function, the code will function exactly
    the same as it did before; the only difference is that it will be much better
    organized and easier to look at. Compile and run your code at this step to make
    sure it still works.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check that your code compiles and runs often, especially when refactoring. When
    you don't know the rules, you're bound to make a lot of mistakes. This is why
    you should do your refactoring only in small steps. Refactoring is the name for
    the activity we are doing now—we are reorganizing the source to make better sense
    to other readers of our codebase. Refactoring usually does not involve rewriting
    too much of it.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing you need to do is isolate the Dog, Cat, and Human classes into
    their own files. To do so, create the `Dog.h`, `Cat.h`, and `Human.h` files and
    add them to your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the Dog class, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting your classes into headers](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you use exactly this setup and try to compile and run your project, you
    will see the **''Mammal'' : ''class'' type redefinition** error, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting your classes into headers](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What this error means is that `Mammal.h` has been included twice in your project,
    once in `Source.cpp` and then again in `Dog.h`. This means effectively two versions
    of the Mammal class got added to the compiling code, and C++ is unsure which version
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways to fix this issue, but the easiest (and the one that Unreal
    Engine uses) is the `#pragma once` macro, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting your classes into headers](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We write `#pragma once` at the top of each header file. This way, the second
    time `Mammal.h` is included, the compiler doesn't copy and paste its contents
    again, since it already has been included before, and its content is actually
    already in the compiling group of files.
  prefs: []
  type: TYPE_NORMAL
- en: Do the same thing for `Cat.h` and `Human.h`, then `include` them both into your
    `Source.cpp` file where your `main()` function resides.
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting your classes into headers](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Diagram with all classes included
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've included all classes into your project, the code should compile
    and run.
  prefs: []
  type: TYPE_NORMAL
- en: .h and .cpp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next level of organization is to leave the class declarations in the header
    files (`.h`) and put the actual function implementation bodies inside some new
    `.cpp` files. Also, leave existing members inside the `class Mammal` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each class, perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete all function bodies (code between `{` and `}`) and replace them with
    just a semicolon. For the `Mammal` class, this would look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `.cpp` file called `Mammal.cpp`. Then simply put the member function
    bodies inside this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is important to note the use of the class name and scope resolution operator
    (double colon) when declaring the member function bodies. We prefix all member
    functions belonging to the `Mammal` class with `Mammal::`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the purely virtual function does not have a body; it's not supposed
    to! Purely virtual functions are simply declared (and initialized to 0) in the
    base class, but implemented later in derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Complete the separation of the different creature classes above into class header
    (`.h`) and class definition files (`.cpp`)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned about objects in C++; they are pieces of code that tie data members
    and member functions together into a bundle of code called `class` or `struct`.
    Object-oriented programming means that your code will be filled with things instead
    of just `int`, `float`, and `char` variables. You will have a variable that represents
    `Barrel`, another variable that represents `Player`, and so on, that is, a variable
    to represent every entity in your game. You will be able to reuse code by using
    inheritance; if you had to code implementations of `Cat` and `Dog`, you can code
    a common functionality in the base class `Mammal`. We also discussed encapsulation
    and how it is easier and more efficient to program objects such that they maintain
    their own internal state.
  prefs: []
  type: TYPE_NORMAL
