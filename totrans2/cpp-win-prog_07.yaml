- en: Chapter 7. Keyboard Input and Character Calculation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue our work on the word processor from [Chapter
    6](ch06.html "Chapter 6. Building a Word Processor"), *Building a Word Processor*.
    More specifically, we will look into keyboard input and character calculation.
    The keyboard handling section deals with regular character input and a rather
    large set of special keys, such as *Home*, *End*, *Page Up* and *Page Down*, *Return*,
    *Backspace*, and arrows.
  prefs: []
  type: TYPE_NORMAL
- en: The calculation section deals with the calculation of each character with regards
    to its font and the alignment of its paragraph as well as the page settings. In
    the end, we will calculate the position and size of each individual character
    in the document.
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin with, we look into the input of regular characters. The `OnChar` method
    is called every time a user presses a graphical character (with an ASCII value
    between 32 and 127, inclusive) or the *Return* key. If a part of the text is marked,
    that part is removed first. Then the character is added to the character list
    by the `InsertChar` method of the `OverwriteChar` class, depending on the `keyboard`
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When inserting a character, we have three cases, which are similar to the `UpdateCaret`
    and `OnFont` methods from [Chapter 6](ch06.html "Chapter 6. Building a Word Processor"),
    *Building a Word Processor*. If the `nextFont` parameter is active (if it does
    not equal `SystemFont`), we use it for the new character. Then, the `nextFont`
    parameter is cleared by the `ClearNextFont` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If the `nextFont` parameter is not active and the input is not at the beginning
    of the paragraph, we use the font of the preceding character for the new character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However, if the input is at the beginning of the paragraph, we use the font
    of the first character in the paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In order to make room for the inserted character, we increase the last index
    of its paragraph. We also increase the first and last index of the succeeding
    paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the `overwrite` mode, we have two cases. If the input is at the very end
    of the document, we insert the character instead of overwriting it; otherwise,
    we overwrite the newline terminating the last paragraph. However, we are free
    to overwrite the terminating newline of every paragraph except the last one, in
    which case, the two paragraphs are merged into one.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the `InsertChar` method, we use the `nextFont` parameter if it is
    not equal to the `SystemFont` parameter. If it is equal to the `SystemFont` parameter,
    we use the font of the character we overwrite rather than the preceding character
    as we did in the `InsertChar` case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `ClearNextFont` method clears the `nextFont` parameter by setting its value
    to the `SystemFont` font. It also recalculates the edit paragraph and the document,
    since the removal of the `nextFont` parameter may cause the edit line (and thereby
    the edit paragraph) to be lowered. The fonts of the character on the line may
    all be lower than the `nextFont` parameter, which causes the line to be lower
    when the `nextFont` parameter is removed from the line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `OnKeyDown` method is called every time the user presses a key. Depending
    on the key and whether the *Shift* key is pressed, the `OnKeyDown` method in turn
    calls the `OnShiftKey`, `OnRegularKey`, or `OnNeutralKey` method. The *Delete*,
    *Backspace*, and *Return* keys perform the same actions irrespective of whether
    the *Shift* key is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the user presses a graphical key, the application will be set to the `edit`
    mode. The `EnsureEditStatus` method makes sure of it. The key stroke may move
    the caret to a position outside the visible part of the client area. Therefore,
    we call the `MakeVisible` method to move the scroll bars if necessary, so that
    the caret appears in the visible part of the client area. The idea is to make
    the caret and the edit character always visible in the window.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We must make sure that the application is set to the `edit` mode when the user
    presses *Page Up*, *Page Down*, or one of the arrow keys, without pressing the
    *Shift* key. The `EnsureEditStatus` method takes care of that. The `editIndex`
    is set to `lastMarkIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Arrow keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `OnLeftArrowKey` method is called when the user presses the left arrow key.
    Its purpose is to move the caret one step to the left, which is simple enough.
    We must make sure that the edit position is not already at the beginning of the
    document. If we move the position to the left, we also need to clear the `nextFont`
    parameter, since it will be active only when the user is about to input a new
    character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `OnRightArrowKey` method is called when the user presses the right arrow
    key. If the caret position is not at the end of the document, we move it one step
    to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When the user presses the up arrow key, we have to find the key above the edit
    line. We do that by simulating a mouse click slightly above (one logical unit)
    the line. Note that we have to look up the edit line. It is not enough to use
    the character rectangle, since the characters may differ in height and ascent
    (refer to the next section) and we cannot be sure that the character rectangle
    is the highest rectangle on the line. Therefore, we look up the height of the
    edit line. In the following screenshot, the text is surrounded by rectangles for
    the purpose of clarification. The code does not actually draw the rectangles.
    If we would use the rectangle of the digit four, we would not reach the preceding
    line because the rectangle of the digit **5** is higher. Instead, we have to use
    the line rectangle of the line **456**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Arrow keys](img/B05475_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We need to check that the edit character is not located on the first line of
    the document. If the edit character is already located on the first line then
    nothing will happen to the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When the user presses the down arrow key, we simulate a mouse click by calling
    the `MousePointToIndexDown` method. In the call, we use the position slightly
    under the edit line (1 unit) in order to find the index of the character in the
    same horizontal position on the next line. One difference compared to the preceding
    `UpArrowKey` case is that we call the `MousePointToIndexDown` method instead of
    the `MousePointToIndex` method because it might be the last line of the paragraph,
    and there might be some space before the next paragraph. In that case, we would
    want the index of the character following the empty space, which the `MousePointToIndexDown`
    method returns, while the `MousePointToIndex` method returns the index of the
    character preceding the empty space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the preceding `OnUpArrowKey` case, we need to ensure that the edit
    line is not the last line in the document. We do so by comparing it to the bottom
    of the last paragraph. If it is the last line then nothing will happen to the
    output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `MousePointToIndexDown` method returns the index of the character on which
    we click. If the mouse point is between two paragraphs, the index of the preceding
    character is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As this method always finds the correct paragraph, this point will never be
    reached, but we assert that in case of coding error it behaves otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `OnPageUp` and `OnPageDown` methods look up the height of the current vertical
    scroll bar in order to simulate a mouse click one page up or down.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Home and End
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `OnHomeKey` method is called when the user presses the *Home* key. It looks
    up the index of the first character on the edit line by following its paragraph
    and line pointers. It uses the index of the first character of the line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If the edit character is not already at the beginning of the line, the `nextFont`
    parameter is cleared by the `ClearNextFont` method, the edit index is updated,
    and the caret is updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `OnEndKey` method is called when the user presses the *End* key. It looks
    up the index of the last character on the edit line by following its paragraph
    and line pointers and using the index of the last character of the line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If the edit character is not already at the end of the line, the `nextFont`
    parameter is cleared by the `ClearNextFont` method, the edit index is updated,
    and the caret is updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Shift arrow keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OnShiftKey` method is called when the user presses a key together with
    the *Shift* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If the user presses a key together with the *Shift* key, we must make sure that
    the application is set to the `mark` mode; the `EnsureMarkMode` method deals with
    that. It clears the `nextFont` parameter (by setting it to `SystemFont`), sets
    the application to the `mark` mode, and assigns both the first and last marked
    index to the edit index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnShiftLeftArrowKey` method decreases the last marked index. Note that
    we only invalidate the indexes between the old and new value of the `lastMarkIndex`
    method in order to avoid dazzle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `OnShiftRightArrowKey` method moves the position of the last marked character
    in a way similar to the `OnShiftLeftArrowKey` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `OnShiftUpArrowKey` and `OnShiftDownArrowKey` methods are called when the
    user presses the up or down arrow key together with the *Shift* key. Its task
    is to move the last marked position one line upward. We simulate the mouse click
    in the same way as we did for the `OnUpArrowKey` and `OnDownArrowKey` method earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Shift Page Up and Page Down
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OnShiftPageUpKey` and `OnShiftPageDown` methods move the edit character
    index one page-height by simulating a mouse click on *Page Up* or *Page Down*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Shift Home and End
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OnShiftHomeKey` and `OnShiftEndKey` methods are called when the user presses
    the *Home* or *End* key together with the *Shift* key. Their task is to mark the
    line from the current position to the beginning or end of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Control Home and End
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OnControlHomeKey` and `OnControlEndKey` methods set the edit character
    position to the beginning or end of the document. Since these methods are listeners
    and not called by the `OnRegularKey` method, we need to call the `EnsureEditStatus`,
    `MakeVisible`, and `UpdateCaret` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Shift Control Home and End
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OnShiftControlHomeKey` and `OnShiftControlEndKey` methods set the last
    mark index to the beginning or end of the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Neutral keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *Backspace* and *Return* keys are neutral keys in the sense that we do
    not care whether the user presses the *Shift* or *Ctrl* key. Note that the *Delete*
    key is not handled by the `OnNeutralKey` method because the **Delete** menu item
    has the *Delete* key as its accelerator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: What the `OnBackSpaceKey` method does is quite simple–it just calls the `OnDelete`
    method. In the `edit` mode, we first move one step to the left unless the edit
    position is not already at the beginning of the document. If it is, nothing happens.
    In the `mark` mode, the *Delete* key and the *Backspace* key have the same effect–they
    both delete the marked text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `OnReturnKey` method is called when the user presses the *Return* key. First,
    we call the `OnChar` method with a newline. The `OnChar` method is never called
    with newline on any other occasion, since newline is not a graphical character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After the newline has been added to the character list, we need to split the
    edit paragraph into two. The `editIndex` field has been updated by the `OnChar`
    method, and it is now the index of the character after the newline. The second
    paragraph starts at the edit index and ends at the end of the first paragraph.
    The first paragraph's last index is set to the edit index minus one. This means
    that the first paragraph holds the characters up to the newline, inclusive, while
    the second paragraph holds the characters one step beyond the newline.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We insert the second paragraph in the paragraph list; we also need to set the
    characters in the second paragraph to point to the second paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We need to recalculate both the first and second paragraph, since the first
    paragraph has lost characters and the second paragraph has been recently created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Since we have added a paragraph, we need to increase the indexes of the succeeding
    paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Visible characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the user uses the keyboard, the edit character or the last marked character
    will always be visible. We start by finding the area that is visible; in `edit`
    mode, it is the area of the edit character. In the `mark` mode, it is the area
    of the character before the last marked index, unless it is zero, in which case
    the index is set to zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We test whether the visible area is in fact visible at the moment. If it is
    not visible, we adjust the scroll bars in order to make it visible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If the left border of the visible area is not visible, we set the horizontal
    scroll position to its left border. In the same way, we set the vertical scroll
    position to the top border of the visible area if it is not visible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It becomes a little bit more complicated when it comes to the right and bottom
    border of the visible area. We start by calculating the distance between the right
    border of the visible area and the right scroll position (the left scroll position
    plus the size of the horizontal scroll bar) and increase the horizontal scroll
    position by that distance. In the same way, we calculate the distance between
    the right border of the visible area and the bottom scroll position (the top scroll
    position plus the size of the vertical scroll bar) and increase the vertical scroll
    position by that distance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Character calculation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `GenerateParagraph` fucnction generates the character rectangles and the
    line lists of a paragraph every time characters are added or removed or when the
    font or alignment is changed. First, we generate lists of sizes and ascents for
    every character as well as the line list by calling the `GenerateSizeAndAscentList`
    and `GenerateLineList` methods. Then, we iterate through the line list and generate
    the character rectangles by calling the `GenerateLineRectList` method. Finally,
    we invalidate the characters that have been changed by comparing them to the original
    rectangle lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Character size and ascent line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ascent line separates the upper and lower part of a letter, which is shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Character size and ascent line](img/B05475_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `GenerateSizeAndAscentList` method fills the given lists with the size
    (width and height) and ascent of every character in the paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Line generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `GenerateLineList` method generates the line list. The main point is that
    we have to decide how many words fit on each line. We iterate through the characters
    and calculate the size of each word. When the next word does not fit on the line,
    we start a new line. We save the index of the first and last character on the
    line as well as its top position. We also save its maximum height and ascent,
    which is the height and ascent of the largest character on the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We delete the lines previously stored in the line list. The line list and the
    paragraph height are cleared. The `lineTop` variable is set to zero and is used
    when calculating the top position of each line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If the `nextFont` parameter is active (does not equal `SystemFont`) and we have
    reached the edit index in edit mode, we calculate the height and ascent of the
    `nextFont` parameter. In this case, we are only interested in the height and ascent
    of the font, and we do not need to calculate the width of its average character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have to subtract the first index of the paragraph, since the indexes
    of each line are relative to the beginning of the paragraph. Remember that the
    character list is common to all paragraphs in the document.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When we find a newline, we have reached the end of the paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When the width of the edit line exceeds the page width, we have, in fact, three
    different cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The line is made up by at least one complete word (`space` is not equal to minus
    one)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line is made up by one word too long to fit on the page (`space` is equal
    to minus one and `charIndex` is greater than `startIndex`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line is made up by one single character wider than the page (space is equal
    to minus one and `charIndex` equals `startIndex`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third case is unlikely but possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If the line is constituted by at least one complete word followed by a space,
    we discard the latest space and start the new line from the next character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If the line is constituted by one single word (with at least two letters) such
    that its width does not fit on the page, we define the line to hold the word including
    the last fitting character, and we start the new line with the succeeding character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in the unlikely event that one single character is wider than the page,
    we just let that character constitute the whole line and let the next index be
    the start index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The height and ascent of the line are the maximal height and ascent (the height
    and ascent of the character with the largest height and ascent).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We set all characters on the line to point at the line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The height of the paragraph is increased by the height of the line, and the
    line pointer is added to the line pointer list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In order to prepare for the next iteration, the line width, the maximal height,
    and ascent are cleared.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `charIndex` loop variable is set to the latest space index and the `spaceIndex`
    is set to `-1`, indicating that we have not yet found a space on the new line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Regular and justified rectangle list generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we have decided the size and ascent line for each character and divided
    the characters into lines, it is time to generate the character rectangles. For
    a regular (left, center, or right-aligned) paragraph, we do that in three steps.
    The justified-aligned paragraph is handled by the `GenerateJustifiedLineRectList`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We sum the width of each line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We find the leftmost position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We generate the rectangles for the characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We iterate through the characters of the line and sum its width. If the character
    after the last character of the line is not a space or newline, we generate its
    rectangle too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Then, we find the leftmost position of the line to start the rectangle generation.
    In the case of left alignment, the starting position is always zero. In the case
    of center alignment, it is half the difference between the page and text width.
    In the case of right alignment, it is the whole difference between the page and
    text width.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Next, we iterate through the line and generate each rectangle. If the character
    after the last character of the line is a space, we generate its rectangle too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `GenerateJustifiedLineRectList` method is slightly more complicated than
    the `GenerateRegularLineRectList` method. We follow the same three steps as mentioned
    previously. However, when calculating the width of the text, we omit the width
    of spaces from the text width. Instead, we count the number of spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We include every character on the line in `lineWidth`, except spaces and newlines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the previous left-alignment case, the leftmost position in justified
    alignment is always zero. If there is at least one space on the line, we calculate
    the width of the spaces by dividing the difference between the page and text width
    with the number of spaces. We need to check that the number of spaces is greater
    than zero. Otherwise, we would be dividing by zero. On the other hand, if the
    number of spaces is zero, we do not need the space width.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If the character is a space, we use the calculated space width instead of its
    actual width.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Invalidate rectangle set generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we need to invalidate the set of rectangles that have been changed.
    There are two cases to be considered. First, we have the rectangles themselves.
    We iterate through the character list, and for each character we compare its previous
    and current rectangle, and invalidate both of them if they differ (which causes
    both their areas to be repainted). Remember that invalidate means that we prepare
    the areas to be repainted next time the window is updated. Then we to look into
    the line list and add the areas to the left and right of the text on the line,
    if present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we finished the development of our word processor by looking
    into keyboard handling and character calculation. In [Chapter 8](ch08.html "Chapter 8. Building
    a Spreadsheet Application"), *Building a Spreadsheet Application*, we will start
    developing a spreadsheet program.
  prefs: []
  type: TYPE_NORMAL
