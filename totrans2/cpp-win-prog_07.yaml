- en: Chapter 7. Keyboard Input and Character Calculation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 键盘输入和字符计算
- en: In this chapter, we will continue our work on the word processor from [Chapter
    6](ch06.html "Chapter 6. Building a Word Processor"), *Building a Word Processor*.
    More specifically, we will look into keyboard input and character calculation.
    The keyboard handling section deals with regular character input and a rather
    large set of special keys, such as *Home*, *End*, *Page Up* and *Page Down*, *Return*,
    *Backspace*, and arrows.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续在第6章*构建一个文字处理器*的基础上对文字处理器进行工作。更具体地说，我们将探讨键盘输入和字符计算。键盘处理部分处理常规字符输入和一组相当大的特殊键，例如*Home*、*End*、*Page
    Up*和*Page Down*、*Return*、*Backspace*和箭头键。
- en: The calculation section deals with the calculation of each character with regards
    to its font and the alignment of its paragraph as well as the page settings. In
    the end, we will calculate the position and size of each individual character
    in the document.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算部分处理每个字符的计算，包括其字体、段落对齐以及页面设置。最后，我们将计算文档中每个单独字符的位置和大小。
- en: Keyboard handling
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘处理
- en: To begin with, we look into the input of regular characters. The `OnChar` method
    is called every time a user presses a graphical character (with an ASCII value
    between 32 and 127, inclusive) or the *Return* key. If a part of the text is marked,
    that part is removed first. Then the character is added to the character list
    by the `InsertChar` method of the `OverwriteChar` class, depending on the `keyboard`
    mode.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一下常规字符的输入。每当用户按下图形字符（ASCII值在32到127之间，包括127）或*回车*键时，都会调用`OnChar`方法。如果文本的一部分被标记，那么这部分首先会被移除。然后，根据`keyboard`模式，通过`OverwriteChar`类的`InsertChar`方法将字符添加到字符列表中。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When inserting a character, we have three cases, which are similar to the `UpdateCaret`
    and `OnFont` methods from [Chapter 6](ch06.html "Chapter 6. Building a Word Processor"),
    *Building a Word Processor*. If the `nextFont` parameter is active (if it does
    not equal `SystemFont`), we use it for the new character. Then, the `nextFont`
    parameter is cleared by the `ClearNextFont` method.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当插入字符时，我们有三种情况，这与第6章中`UpdateCaret`和`OnFont`方法的处理类似，即*构建一个文字处理器*。如果`nextFont`参数是激活的（如果不等于`SystemFont`），我们则用它来处理新字符。然后，通过`ClearNextFont`方法清除`nextFont`参数。
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the `nextFont` parameter is not active and the input is not at the beginning
    of the paragraph, we use the font of the preceding character for the new character.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`nextFont`参数未激活且输入不在段落的开始处，我们则使用前一个字符的字体来处理新字符。
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, if the input is at the beginning of the paragraph, we use the font
    of the first character in the paragraph.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果输入位于段落的开始处，我们则使用段落中第一个字符的字体。
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In order to make room for the inserted character, we increase the last index
    of its paragraph. We also increase the first and last index of the succeeding
    paragraphs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为插入的字符腾出空间，我们增加其段落的最后一个索引。同时，我们也增加后续段落的第一个和最后一个索引。
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `overwrite` mode, we have two cases. If the input is at the very end
    of the document, we insert the character instead of overwriting it; otherwise,
    we overwrite the newline terminating the last paragraph. However, we are free
    to overwrite the terminating newline of every paragraph except the last one, in
    which case, the two paragraphs are merged into one.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在`overwrite`模式下，我们有两种情况。如果输入位于文档的末尾，我们则插入字符而不是覆盖它；否则，我们覆盖最后一个段落的换行符。然而，我们可以自由地覆盖除最后一个段落外的每个段落的终止换行符，在这种情况下，两个段落将合并为一个。
- en: Similar to the `InsertChar` method, we use the `nextFont` parameter if it is
    not equal to the `SystemFont` parameter. If it is equal to the `SystemFont` parameter,
    we use the font of the character we overwrite rather than the preceding character
    as we did in the `InsertChar` case.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与`InsertChar`方法类似，如果`nextFont`参数不等于`SystemFont`参数，我们则使用它。如果它等于`SystemFont`参数，我们则使用被覆盖字符的字体，而不是像在`InsertChar`情况中那样使用前一个字符的字体。
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `ClearNextFont` method clears the `nextFont` parameter by setting its value
    to the `SystemFont` font. It also recalculates the edit paragraph and the document,
    since the removal of the `nextFont` parameter may cause the edit line (and thereby
    the edit paragraph) to be lowered. The fonts of the character on the line may
    all be lower than the `nextFont` parameter, which causes the line to be lower
    when the `nextFont` parameter is removed from the line.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClearNextFont` 方法通过将其值设置为 `SystemFont` 字体来清除 `nextFont` 参数。它还会重新计算编辑段落和文档，因为移除
    `nextFont` 参数可能会导致编辑行（以及因此的编辑段落）降低。行上的字符字体可能都低于 `nextFont` 参数，这会导致移除 `nextFont`
    参数后行降低。'
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `OnKeyDown` method is called every time the user presses a key. Depending
    on the key and whether the *Shift* key is pressed, the `OnKeyDown` method in turn
    calls the `OnShiftKey`, `OnRegularKey`, or `OnNeutralKey` method. The *Delete*,
    *Backspace*, and *Return* keys perform the same actions irrespective of whether
    the *Shift* key is pressed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户按下键时，都会调用 `OnKeyDown` 方法。根据键和是否按下 *Shift* 键，`OnKeyDown` 方法会依次调用 `OnShiftKey`、`OnRegularKey`
    或 `OnNeutralKey` 方法。*Delete*、*Backspace* 和 *Return* 键在是否按下 *Shift* 键的情况下执行相同的行为。
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the user presses a graphical key, the application will be set to the `edit`
    mode. The `EnsureEditStatus` method makes sure of it. The key stroke may move
    the caret to a position outside the visible part of the client area. Therefore,
    we call the `MakeVisible` method to move the scroll bars if necessary, so that
    the caret appears in the visible part of the client area. The idea is to make
    the caret and the edit character always visible in the window.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下图形键时，应用程序将被设置为 `edit` 模式。`EnsureEditStatus` 方法确保这一点。按键可能将光标移动到客户端区域可见部分之外的位置。因此，如果需要，我们调用
    `MakeVisible` 方法来移动滚动条，以便光标出现在客户端区域的可见部分。想法是使光标和编辑字符始终在窗口中可见。
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We must make sure that the application is set to the `edit` mode when the user
    presses *Page Up*, *Page Down*, or one of the arrow keys, without pressing the
    *Shift* key. The `EnsureEditStatus` method takes care of that. The `editIndex`
    is set to `lastMarkIndex`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下 *Page Up*、*Page Down* 或箭头键之一，而没有按下 *Shift* 键时，我们必须确保应用程序设置为 `edit` 模式。`EnsureEditStatus`
    方法负责这一点。`editIndex` 被设置为 `lastMarkIndex`。
- en: '[PRE9]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Arrow keys
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头键
- en: The `OnLeftArrowKey` method is called when the user presses the left arrow key.
    Its purpose is to move the caret one step to the left, which is simple enough.
    We must make sure that the edit position is not already at the beginning of the
    document. If we move the position to the left, we also need to clear the `nextFont`
    parameter, since it will be active only when the user is about to input a new
    character.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下左箭头键时，会调用 `OnLeftArrowKey` 方法。它的目的是将光标向左移动一步，这很简单。我们必须确保编辑位置不在文档的开始处。如果我们向左移动位置，我们还需要清除
    `nextFont` 参数，因为它只有在用户即将输入新字符时才会激活。
- en: '[PRE10]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `OnRightArrowKey` method is called when the user presses the right arrow
    key. If the caret position is not at the end of the document, we move it one step
    to the right.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下右箭头键时，会调用 `OnRightArrowKey` 方法。如果光标位置不在文档末尾，我们将它向右移动一步。
- en: '[PRE11]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When the user presses the up arrow key, we have to find the key above the edit
    line. We do that by simulating a mouse click slightly above (one logical unit)
    the line. Note that we have to look up the edit line. It is not enough to use
    the character rectangle, since the characters may differ in height and ascent
    (refer to the next section) and we cannot be sure that the character rectangle
    is the highest rectangle on the line. Therefore, we look up the height of the
    edit line. In the following screenshot, the text is surrounded by rectangles for
    the purpose of clarification. The code does not actually draw the rectangles.
    If we would use the rectangle of the digit four, we would not reach the preceding
    line because the rectangle of the digit **5** is higher. Instead, we have to use
    the line rectangle of the line **456**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下上箭头键时，我们必须找到编辑行上面的键。我们通过在行稍上方（一个逻辑单位）模拟鼠标点击来实现这一点。请注意，我们必须查找编辑行。仅使用字符矩形是不够的，因为字符的高度和上升（参考下一节）可能不同，我们无法确定字符矩形是该行上最高的矩形。因此，我们查找编辑行的高度。在下面的屏幕截图中，文本被矩形包围以供说明。代码实际上并没有绘制矩形。如果我们使用数字四的矩形，我们就不会达到前面的行，因为数字
    **5** 的矩形更高。相反，我们必须使用行 **456** 的行矩形。
- en: '![Arrow keys](img/B05475_07_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![箭头键](img/B05475_07_01.jpg)'
- en: '[PRE12]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We need to check that the edit character is not located on the first line of
    the document. If the edit character is already located on the first line then
    nothing will happen to the output.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查编辑字符是否不在文档的第一行。如果编辑字符已经在第一行，则输出不会发生任何变化。
- en: '[PRE13]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the user presses the down arrow key, we simulate a mouse click by calling
    the `MousePointToIndexDown` method. In the call, we use the position slightly
    under the edit line (1 unit) in order to find the index of the character in the
    same horizontal position on the next line. One difference compared to the preceding
    `UpArrowKey` case is that we call the `MousePointToIndexDown` method instead of
    the `MousePointToIndex` method because it might be the last line of the paragraph,
    and there might be some space before the next paragraph. In that case, we would
    want the index of the character following the empty space, which the `MousePointToIndexDown`
    method returns, while the `MousePointToIndex` method returns the index of the
    character preceding the empty space.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下向下箭头键时，我们通过调用`MousePointToIndexDown`方法来模拟鼠标点击。在调用中，我们使用位于编辑行稍下方的位置（1个单位）来找到下一行相同水平位置上的字符索引。与前面的`UpArrowKey`情况相比，我们调用`MousePointToIndexDown`方法而不是`MousePointToIndex`方法，因为这可能是在段落的最后一行，并且可能在下一个段落之前有一些空间。在这种情况下，我们希望得到空格后面的字符的索引，这是`MousePointToIndexDown`方法返回的，而`MousePointToIndex`方法返回的是空格前面的字符的索引。
- en: '[PRE14]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Similar to the preceding `OnUpArrowKey` case, we need to ensure that the edit
    line is not the last line in the document. We do so by comparing it to the bottom
    of the last paragraph. If it is the last line then nothing will happen to the
    output.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的`OnUpArrowKey`情况类似，我们需要确保编辑行不是文档中的最后一行。我们通过将其与最后一个段落的底部进行比较来实现这一点。如果是最后一行，则输出不会发生任何变化。
- en: '[PRE15]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `MousePointToIndexDown` method returns the index of the character on which
    we click. If the mouse point is between two paragraphs, the index of the preceding
    character is returned.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`MousePointToIndexDown`方法返回被点击的字符的索引。如果鼠标点在两个段落之间，则返回前一个字符的索引。'
- en: '[PRE16]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As this method always finds the correct paragraph, this point will never be
    reached, but we assert that in case of coding error it behaves otherwise.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此方法始终找到正确的段落，因此此点永远不会达到，但我们断言在编码错误的情况下，其行为可能会有所不同。
- en: '[PRE17]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `OnPageUp` and `OnPageDown` methods look up the height of the current vertical
    scroll bar in order to simulate a mouse click one page up or down.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnPageUp`和`OnPageDown`方法查找当前垂直滚动条的高度，以便模拟向上或向下翻一页的鼠标点击。'
- en: '[PRE18]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Home and End
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Home和End
- en: The `OnHomeKey` method is called when the user presses the *Home* key. It looks
    up the index of the first character on the edit line by following its paragraph
    and line pointers. It uses the index of the first character of the line.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下*Home*键时调用`OnHomeKey`方法。它通过跟随其段落和行指针来查找编辑行上第一个字符的索引。它使用行中第一个字符的索引。
- en: '[PRE19]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the edit character is not already at the beginning of the line, the `nextFont`
    parameter is cleared by the `ClearNextFont` method, the edit index is updated,
    and the caret is updated.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编辑字符尚未位于行的开头，`ClearNextFont`方法会清除`nextFont`参数，更新编辑索引，并更新光标。
- en: '[PRE20]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `OnEndKey` method is called when the user presses the *End* key. It looks
    up the index of the last character on the edit line by following its paragraph
    and line pointers and using the index of the last character of the line.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下*End*键时调用`OnEndKey`方法。它通过跟随其段落和行指针并使用行中最后一个字符的索引来查找编辑行上最后一个字符的索引。
- en: '[PRE21]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the edit character is not already at the end of the line, the `nextFont`
    parameter is cleared by the `ClearNextFont` method, the edit index is updated,
    and the caret is updated.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编辑字符尚未位于行的末尾，`ClearNextFont`方法会清除`nextFont`参数，更新编辑索引，并更新光标。
- en: '[PRE22]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Shift arrow keys
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shift箭头键
- en: 'The `OnShiftKey` method is called when the user presses a key together with
    the *Shift* key:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户同时按下*Shift*键和某个键时调用`OnShiftKey`方法：
- en: '[PRE23]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the user presses a key together with the *Shift* key, we must make sure that
    the application is set to the `mark` mode; the `EnsureMarkMode` method deals with
    that. It clears the `nextFont` parameter (by setting it to `SystemFont`), sets
    the application to the `mark` mode, and assigns both the first and last marked
    index to the edit index.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户同时按下*Shift*键和某个键，我们必须确保应用程序设置为`mark`模式；`EnsureMarkMode`方法处理这个问题。它会清除`nextFont`参数（通过将其设置为`SystemFont`），将应用程序设置为`mark`模式，并将第一个和最后一个标记的索引分配给编辑索引。
- en: '[PRE24]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `OnShiftLeftArrowKey` method decreases the last marked index. Note that
    we only invalidate the indexes between the old and new value of the `lastMarkIndex`
    method in order to avoid dazzle:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnShiftLeftArrowKey` 方法减少最后一个标记索引。请注意，我们只使 `lastMarkIndex` 方法的旧值和新值之间的索引无效，以避免闪烁：'
- en: '[PRE25]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `OnShiftRightArrowKey` method moves the position of the last marked character
    in a way similar to the `OnShiftLeftArrowKey` method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnShiftRightArrowKey` 方法以类似于 `OnShiftLeftArrowKey` 方式移动最后标记字符的位置。'
- en: '[PRE26]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `OnShiftUpArrowKey` and `OnShiftDownArrowKey` methods are called when the
    user presses the up or down arrow key together with the *Shift* key. Its task
    is to move the last marked position one line upward. We simulate the mouse click
    in the same way as we did for the `OnUpArrowKey` and `OnDownArrowKey` method earlier.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户同时按下上箭头键或下箭头键以及 *Shift* 键时，会调用 `OnShiftUpArrowKey` 和 `OnShiftDownArrowKey`
    方法。其任务是向上移动最后一个标记位置。我们以与之前 `OnUpArrowKey` 和 `OnDownArrowKey` 方法相同的方式模拟鼠标点击。
- en: '[PRE27]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Shift Page Up and Page Down
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shift Page Up 和 Page Down
- en: 'The `OnShiftPageUpKey` and `OnShiftPageDown` methods move the edit character
    index one page-height by simulating a mouse click on *Page Up* or *Page Down*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnShiftPageUpKey` 和 `OnShiftPageDown` 方法通过模拟在 *Page Up* 或 *Page Down* 上进行鼠标点击来移动编辑字符索引一个页面高度：'
- en: '[PRE28]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Shift Home and End
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shift Home 和 End
- en: 'The `OnShiftHomeKey` and `OnShiftEndKey` methods are called when the user presses
    the *Home* or *End* key together with the *Shift* key. Their task is to mark the
    line from the current position to the beginning or end of the line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户同时按下 *Home* 或 *End* 键以及 *Shift* 键时，会调用 `OnShiftHomeKey` 和 `OnShiftEndKey`
    方法。它们的作用是标记从当前位置到行首或行尾的整行：
- en: '[PRE29]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Control Home and End
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Control Home 和 End
- en: 'The `OnControlHomeKey` and `OnControlEndKey` methods set the edit character
    position to the beginning or end of the document. Since these methods are listeners
    and not called by the `OnRegularKey` method, we need to call the `EnsureEditStatus`,
    `MakeVisible`, and `UpdateCaret` methods:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnControlHomeKey` 和 `OnControlEndKey` 方法将编辑字符位置设置为文档的开始或结束。由于这些方法是监听器，而不是由
    `OnRegularKey` 方法调用，因此我们需要调用 `EnsureEditStatus`、`MakeVisible` 和 `UpdateCaret`
    方法：'
- en: '[PRE30]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Shift Control Home and End
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shift Control Home 和 End
- en: 'The `OnShiftControlHomeKey` and `OnShiftControlEndKey` methods set the last
    mark index to the beginning or end of the document:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnShiftControlHomeKey` 和 `OnShiftControlEndKey` 方法将最后一个标记索引设置为文档的开始或结束：'
- en: '[PRE31]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Neutral keys
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中性键
- en: 'The *Backspace* and *Return* keys are neutral keys in the sense that we do
    not care whether the user presses the *Shift* or *Ctrl* key. Note that the *Delete*
    key is not handled by the `OnNeutralKey` method because the **Delete** menu item
    has the *Delete* key as its accelerator:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*Backspace* 和 *Return* 键是中性键，从意义上讲，我们不在乎用户是否按下了 *Shift* 或 *Ctrl* 键。注意，*Delete*
    键不是由 `OnNeutralKey` 方法处理的，因为 **Delete** 菜单项将 *Delete* 键作为其快捷键：'
- en: '[PRE32]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What the `OnBackSpaceKey` method does is quite simple–it just calls the `OnDelete`
    method. In the `edit` mode, we first move one step to the left unless the edit
    position is not already at the beginning of the document. If it is, nothing happens.
    In the `mark` mode, the *Delete* key and the *Backspace* key have the same effect–they
    both delete the marked text.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnBackSpaceKey` 方法所做的是相当简单的——它只是调用 `OnDelete` 方法。在 `edit` 模式下，我们首先向左移动一步，除非编辑位置已经不在文档的开始处。如果是这样，则不执行任何操作。在
    `mark` 模式下，*Delete* 键和 *Backspace* 键具有相同的效果——它们都删除标记的文本。'
- en: '[PRE33]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `OnReturnKey` method is called when the user presses the *Return* key. First,
    we call the `OnChar` method with a newline. The `OnChar` method is never called
    with newline on any other occasion, since newline is not a graphical character.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下 *Return* 键时，会调用 `OnReturnKey` 方法。首先，我们使用换行符调用 `OnChar` 方法。`OnChar` 方法在其他任何情况下都不会带换行符调用，因为换行符不是一个图形字符。
- en: '[PRE34]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After the newline has been added to the character list, we need to split the
    edit paragraph into two. The `editIndex` field has been updated by the `OnChar`
    method, and it is now the index of the character after the newline. The second
    paragraph starts at the edit index and ends at the end of the first paragraph.
    The first paragraph's last index is set to the edit index minus one. This means
    that the first paragraph holds the characters up to the newline, inclusive, while
    the second paragraph holds the characters one step beyond the newline.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符列表中添加换行后，我们需要将编辑段落分成两部分。`editIndex` 字段已被 `OnChar` 方法更新，现在是换行后的字符索引。第二段从编辑索引开始，到第一段末尾结束。第一段的最后一个索引设置为编辑索引减一。这意味着第一段包含换行符及其之前的所有字符，而第二段包含换行符之后的字符。
- en: '[PRE35]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We insert the second paragraph in the paragraph list; we also need to set the
    characters in the second paragraph to point to the second paragraph.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在段落列表中插入第二段；我们还需要将第二段中的字符设置为指向第二段。
- en: '[PRE36]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We need to recalculate both the first and second paragraph, since the first
    paragraph has lost characters and the second paragraph has been recently created.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一段丢失了字符，而第二段是最近创建的，我们需要重新计算第一段和第二段。
- en: '[PRE37]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Since we have added a paragraph, we need to increase the indexes of the succeeding
    paragraphs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们添加了一个段落，我们需要增加后续段落的索引。
- en: '[PRE38]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Visible characters
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可见字符
- en: When the user uses the keyboard, the edit character or the last marked character
    will always be visible. We start by finding the area that is visible; in `edit`
    mode, it is the area of the edit character. In the `mark` mode, it is the area
    of the character before the last marked index, unless it is zero, in which case
    the index is set to zero.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用键盘时，编辑中的字符或最后标记的字符始终可见。我们首先找到可见区域；在`编辑`模式下，它是编辑字符的区域。在`标记`模式下，它是最后一个标记索引之前的字符区域，除非它是零，在这种情况下，索引被设置为零。
- en: '[PRE39]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We test whether the visible area is in fact visible at the moment. If it is
    not visible, we adjust the scroll bars in order to make it visible.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试可见区域是否在当前时刻实际上是可见的。如果不可见，我们调整滚动条以使其可见。
- en: '[PRE40]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If the left border of the visible area is not visible, we set the horizontal
    scroll position to its left border. In the same way, we set the vertical scroll
    position to the top border of the visible area if it is not visible.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可见区域的左边界不可见，我们将水平滚动位置设置为它的左边界。同样，如果可见区域的顶部边界不可见，我们将垂直滚动位置设置为它的顶部边界。
- en: '[PRE41]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It becomes a little bit more complicated when it comes to the right and bottom
    border of the visible area. We start by calculating the distance between the right
    border of the visible area and the right scroll position (the left scroll position
    plus the size of the horizontal scroll bar) and increase the horizontal scroll
    position by that distance. In the same way, we calculate the distance between
    the right border of the visible area and the bottom scroll position (the top scroll
    position plus the size of the vertical scroll bar) and increase the vertical scroll
    position by that distance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到可见区域的右边界和底部边界时，事情变得稍微复杂一些。我们首先计算可见区域右边界和右滚动位置（左滚动位置加上水平滚动条的大小）之间的距离，并将水平滚动位置增加该距离。同样，我们计算可见区域右边界和底部滚动位置（顶部滚动位置加上垂直滚动条的大小）之间的距离，并将垂直滚动位置增加该距离。
- en: '[PRE42]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Character calculation
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符计算
- en: 'The `GenerateParagraph` fucnction generates the character rectangles and the
    line lists of a paragraph every time characters are added or removed or when the
    font or alignment is changed. First, we generate lists of sizes and ascents for
    every character as well as the line list by calling the `GenerateSizeAndAscentList`
    and `GenerateLineList` methods. Then, we iterate through the line list and generate
    the character rectangles by calling the `GenerateLineRectList` method. Finally,
    we invalidate the characters that have been changed by comparing them to the original
    rectangle lists:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateParagraph`函数在字符添加或删除、字体或对齐方式更改时，为段落生成字符矩形和行列表。首先，我们通过调用`GenerateSizeAndAscentList`和`GenerateLineList`方法生成每个字符的大小和上升线列表以及行列表。然后，我们遍历行列表，通过调用`GenerateLineRectList`方法生成字符矩形。最后，我们通过将它们与原始矩形列表进行比较来使已更改的字符无效：'
- en: '[PRE43]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Character size and ascent line
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符大小和上升线
- en: 'The ascent line separates the upper and lower part of a letter, which is shown
    in the following figure:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上升线分隔字母的上部和下部，如下图所示：
- en: '![Character size and ascent line](img/B05475_07_02.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![字符大小和上升线](img/B05475_07_02.jpg)'
- en: 'The `GenerateSizeAndAscentList` method fills the given lists with the size
    (width and height) and ascent of every character in the paragraph:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateSizeAndAscentList`方法将给定的列表填充为段落中每个字符的大小（宽度和高度）和上升线：'
- en: '[PRE44]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Line generation
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行生成
- en: 'The `GenerateLineList` method generates the line list. The main point is that
    we have to decide how many words fit on each line. We iterate through the characters
    and calculate the size of each word. When the next word does not fit on the line,
    we start a new line. We save the index of the first and last character on the
    line as well as its top position. We also save its maximum height and ascent,
    which is the height and ascent of the largest character on the line:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateLineList`方法生成行列表。主要点是我们必须决定每行可以容纳多少单词。我们遍历字符并计算每个单词的大小。当下一个单词无法适应行时，我们开始新的一行。我们保存行上第一个和最后一个字符的索引以及其顶部位置。我们还保存其最大高度和上升，即行上最大字符的高度和上升：'
- en: '[PRE45]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We delete the lines previously stored in the line list. The line list and the
    paragraph height are cleared. The `lineTop` variable is set to zero and is used
    when calculating the top position of each line.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除先前存储在行列表中的行。清除行列表和段落高度。将`lineTop`变量设置为零，并在计算每行的顶部位置时使用。
- en: '[PRE46]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If the `nextFont` parameter is active (does not equal `SystemFont`) and we have
    reached the edit index in edit mode, we calculate the height and ascent of the
    `nextFont` parameter. In this case, we are only interested in the height and ascent
    of the font, and we do not need to calculate the width of its average character.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`nextFont`参数是活动的（不等于`SystemFont`）并且我们在编辑模式下达到了编辑索引，我们计算`nextFont`参数的高度和上升。在这种情况下，我们只对字体的高度和上升感兴趣，而不需要计算其平均字符的宽度。
- en: '[PRE47]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that we have to subtract the first index of the paragraph, since the indexes
    of each line are relative to the beginning of the paragraph. Remember that the
    character list is common to all paragraphs in the document.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须减去段落的第一个索引，因为每行的索引都是相对于段落开头的。记住，字符列表是文档中所有段落的公共部分。
- en: '[PRE48]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When we find a newline, we have reached the end of the paragraph.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们找到换行符时，我们已经到达段落的末尾。
- en: '[PRE49]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When the width of the edit line exceeds the page width, we have, in fact, three
    different cases:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当编辑行的宽度超过页面宽度时，实际上有三种不同的情况：
- en: The line is made up by at least one complete word (`space` is not equal to minus
    one)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行由至少一个完整的单词组成（空格不等于负一）
- en: The line is made up by one word too long to fit on the page (`space` is equal
    to minus one and `charIndex` is greater than `startIndex`)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行由一个太长而无法适应页面的单词组成（空格等于负一且`charIndex`大于`startIndex`）
- en: The line is made up by one single character wider than the page (space is equal
    to minus one and `charIndex` equals `startIndex`
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行由一个比页面宽一个字符的单词组成（空格等于负一且`charIndex`等于`startIndex`）
- en: The third case is unlikely but possible.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种情况不太可能但有可能发生。
- en: '[PRE50]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If the line is constituted by at least one complete word followed by a space,
    we discard the latest space and start the new line from the next character.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一行由至少一个完整的单词后跟一个空格组成，我们丢弃最后一个空格，并从下一个字符开始新行。
- en: '[PRE51]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If the line is constituted by one single word (with at least two letters) such
    that its width does not fit on the page, we define the line to hold the word including
    the last fitting character, and we start the new line with the succeeding character.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一行由一个单独的单词（至少有两个字母）组成，且其宽度不适合在页面上，我们定义该行包含最后一个适合的字符，并从下一个字符开始新行。
- en: '[PRE52]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Finally, in the unlikely event that one single character is wider than the page,
    we just let that character constitute the whole line and let the next index be
    the start index.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在不太可能的情况下，如果单个字符比页面宽，我们只需让该字符构成整个行，并让下一个索引是起始索引。
- en: '[PRE53]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The height and ascent of the line are the maximal height and ascent (the height
    and ascent of the character with the largest height and ascent).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 行的高度和上升是最大高度和上升（具有最大高度和上升的字符的高度和上升）。
- en: '[PRE54]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We set all characters on the line to point at the line.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将行上的所有字符设置为指向该行。
- en: '[PRE55]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The height of the paragraph is increased by the height of the line, and the
    line pointer is added to the line pointer list.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 段落的高度通过行高增加，并将行指针添加到行指针列表中。
- en: '[PRE56]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In order to prepare for the next iteration, the line width, the maximal height,
    and ascent are cleared.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备下一次迭代，清除行宽、最大高度和上升。
- en: '[PRE57]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `charIndex` loop variable is set to the latest space index and the `spaceIndex`
    is set to `-1`, indicating that we have not yet found a space on the new line.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将`charIndex`循环变量设置为最新的空格索引，并将`spaceIndex`设置为`-1`，表示我们尚未在新行上找到空格。
- en: '[PRE58]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Regular and justified rectangle list generation
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正规和两端对齐的矩形列表生成
- en: 'When we have decided the size and ascent line for each character and divided
    the characters into lines, it is time to generate the character rectangles. For
    a regular (left, center, or right-aligned) paragraph, we do that in three steps.
    The justified-aligned paragraph is handled by the `GenerateJustifiedLineRectList`
    method as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为每个字符决定大小和上升线，并将字符分成行后，就是生成字符矩形的时候了。对于常规（左、居中或右对齐）段落，我们分三步进行。对齐对齐的段落由`GenerateJustifiedLineRectList`方法如下处理：
- en: We sum the width of each line.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算每行的宽度。
- en: We find the leftmost position.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们找到最左端的位置。
- en: We generate the rectangles for the characters.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为字符生成矩形。
- en: '[PRE59]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We iterate through the characters of the line and sum its width. If the character
    after the last character of the line is not a space or newline, we generate its
    rectangle too.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历行的字符并计算其宽度。如果行的最后一个字符之后不是空格或换行符，我们也为其生成矩形。
- en: '[PRE60]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Then, we find the leftmost position of the line to start the rectangle generation.
    In the case of left alignment, the starting position is always zero. In the case
    of center alignment, it is half the difference between the page and text width.
    In the case of right alignment, it is the whole difference between the page and
    text width.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们找到行的最左端位置以开始矩形生成。在左对齐的情况下，起始位置始终为零。在居中对齐的情况下，它是页面和文本宽度差的一半。在右对齐的情况下，它是页面和文本宽度之间的整个差值。
- en: '[PRE61]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Next, we iterate through the line and generate each rectangle. If the character
    after the last character of the line is a space, we generate its rectangle too.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历行并生成每个矩形。如果行的最后一个字符之后是空格，我们也为其生成矩形。
- en: '[PRE62]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `GenerateJustifiedLineRectList` method is slightly more complicated than
    the `GenerateRegularLineRectList` method. We follow the same three steps as mentioned
    previously. However, when calculating the width of the text, we omit the width
    of spaces from the text width. Instead, we count the number of spaces.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateJustifiedLineRectList`方法比`GenerateRegularLineRectList`方法稍微复杂一些。我们遵循之前提到的相同三个步骤。然而，在计算文本宽度时，我们省略了空格的宽度，而是计算空格的数量。'
- en: '[PRE63]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We include every character on the line in `lineWidth`, except spaces and newlines.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将行上的每个字符都包括在`lineWidth`中，除了空格和换行符。
- en: '[PRE64]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Similar to the previous left-alignment case, the leftmost position in justified
    alignment is always zero. If there is at least one space on the line, we calculate
    the width of the spaces by dividing the difference between the page and text width
    with the number of spaces. We need to check that the number of spaces is greater
    than zero. Otherwise, we would be dividing by zero. On the other hand, if the
    number of spaces is zero, we do not need the space width.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的左对齐情况类似，对齐对齐的左端位置始终为零。如果行上至少有一个空格，我们通过将页面和文本宽度的差除以空格的数量来计算空格的宽度。我们需要检查空格的数量是否大于零。否则，我们将除以零。另一方面，如果空格的数量为零，我们不需要空格宽度。
- en: '[PRE65]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If the character is a space, we use the calculated space width instead of its
    actual width.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符是空格，我们使用计算出的空格宽度而不是其实际宽度。
- en: '[PRE66]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Invalidate rectangle set generation
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无效矩形集生成
- en: Finally, we need to invalidate the set of rectangles that have been changed.
    There are two cases to be considered. First, we have the rectangles themselves.
    We iterate through the character list, and for each character we compare its previous
    and current rectangle, and invalidate both of them if they differ (which causes
    both their areas to be repainted). Remember that invalidate means that we prepare
    the areas to be repainted next time the window is updated. Then we to look into
    the line list and add the areas to the left and right of the text on the line,
    if present.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要使已更改的矩形集无效。有两种情况需要考虑。首先，我们有矩形本身。我们遍历字符列表，并对每个字符比较其先前和当前的矩形，如果它们不同（这将导致它们两个区域都被重绘），则使它们两个都无效。记住，无效意味着我们准备在下次窗口更新时重绘的区域。然后我们查看行列表，并在行上如果有，将文本左侧和右侧的区域添加到其中。
- en: '[PRE67]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we finished the development of our word processor by looking
    into keyboard handling and character calculation. In [Chapter 8](ch08.html "Chapter 8. Building
    a Spreadsheet Application"), *Building a Spreadsheet Application*, we will start
    developing a spreadsheet program.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过查看键盘处理和字符计算完成了我们的文字处理器的开发。在[第8章](ch08.html "第8章。构建电子表格应用程序")《构建电子表格应用程序》中，我们将开始开发电子表格程序。
