- en: Chapter 1. Getting Started with SDL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. SDL 入门
- en: '**Simple DirectMedia Layer** (**SDL**) is a cross-platform multimedia library
    created by Sam Oscar Latinga. It provides low-level access to input (via mouse,
    keyboard, and gamepads/joysticks), 3D hardware, and the 2D video frame buffer.
    SDL is written in the C programming language, yet has native support for C++.
    The library also has bindings for several other languages such as Pascal, Objective-C,
    Python, Ruby, and Java; a full list of supported languages is available at [http://www.libsdl.org/languages.php](http://www.libsdl.org/languages.php).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单直接媒体层**（**SDL**）是一个由 Sam Oscar Latinga 创建的跨平台多媒体库。它提供了对输入（通过鼠标、键盘和游戏手柄/摇杆）、3D
    硬件和 2D 视频帧缓冲区的低级访问。SDL 使用 C 编程语言编写，但具有对 C++ 的原生支持。该库还对 Pascal、Objective-C、Python、Ruby
    和 Java 等几种其他语言提供了绑定；支持的语言完整列表可在 [http://www.libsdl.org/languages.php](http://www.libsdl.org/languages.php)
    上找到。'
- en: 'SDL has been used in many commercial games including World of Goo, Neverwinter
    Nights, and Second Life. It is also used in emulators such as ZSNES, Mupen64,
    and VisualBoyAdvance. Some popular games ported to Linux platforms such as Quake
    4, Soldier of Fortune, and Civilization: Call to Power utilize SDL in some form.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'SDL 已被用于许多商业游戏，包括《World of Goo》、《Neverwinter Nights》和《Second Life》。它也被用于诸如
    ZSNES、Mupen64 和 VisualBoyAdvance 这样的模拟器。一些流行的游戏，如移植到 Linux 平台上的《Quake 4》、《Soldier
    of Fortune》和《Civilization: Call to Power》，以某种形式使用了 SDL。'
- en: SDL is not just used for games. It is useful for all manner of applications.
    If your software needs access to graphics and input, chances are that SDL will
    be a great help. The SDL official website has a list of applications that have
    been created using the library ([http://www.libsdl.org/applications.php](http://www.libsdl.org/applications.php)).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SDL 不仅用于游戏。它对各种应用程序都很有用。如果你的软件需要访问图形和输入，那么 SDL 可能会非常有帮助。SDL 官方网站列出了使用该库创建的应用程序列表（[http://www.libsdl.org/applications.php](http://www.libsdl.org/applications.php)）。
- en: 'In this chapter we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Getting the latest SDL build from the Mercurial repository
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Mercurial 仓库获取最新的 SDL 构建
- en: Building and setting up SDL in Visual C++ 2010 Express
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual C++ 2010 Express 中构建和设置 SDL
- en: Creating a window with SDL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SDL 创建窗口
- en: Implementing a basic game class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个基本的游戏类
- en: Why use SDL?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用 SDL？
- en: Each platform has its own way of creating and displaying windows and graphics,
    handling user input, and accessing any low-level hardware; each one with its own
    intricacies and syntax. SDL provides a uniform way of accessing these platform-specific
    features. This uniformity leads to more time spent tweaking your game rather than
    worrying about how a specific platform allows you to render or get user input,
    and so on. Game programming can be quite difficult, and having a library such
    as SDL can get your game up and running relatively quickly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平台都有其创建和显示窗口、处理用户输入以及访问任何底层硬件的独特方式；每种方式都有其复杂性以及语法。SDL 提供了一种统一的方式来访问这些特定平台的特性。这种一致性使得你花更多的时间调整游戏，而不是担心特定平台如何让你渲染或获取用户输入等问题。游戏编程可能相当困难，而拥有像
    SDL 这样的库可以使你的游戏相对快速地启动和运行。
- en: The ability to write a game on Windows and then go on to compile it on OSX or
    Linux with little to no changes in the code is extremely powerful and perfect
    for developers who want to target as many platforms as possible; SDL makes this
    kind of cross-platform development a breeze. While SDL is extremely effective
    for cross-platform development, it is also an excellent choice for creating a
    game with just one platform in mind, due to its ease of use and abundance of features.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在 Windows 上编写游戏，然后将其编译到 OSX 或 Linux 上，而代码几乎不需要任何修改，这种能力非常强大，非常适合希望针对尽可能多的平台进行开发的开发者；SDL
    使得这种跨平台开发变得轻而易举。虽然 SDL 对于跨平台开发非常有效，但它也是一个创建仅针对一个平台的游戏的绝佳选择，因为它易于使用且功能丰富。
- en: SDL has a large user base and is being actively updated and maintained. There
    is also a responsive community along with a helpful mailing list. Documentation
    for SDL 2.0 is up-to-date and constantly maintained. Visiting the SDL website,
    [libsdl.org](http://libsdl.org), offers up lots of articles and information with
    links to the documentation, mailing list, and forums.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SDL 拥有庞大的用户群体，并且正在积极地进行更新和维护。同时，还有一个响应迅速的社区以及一个有帮助的邮件列表。SDL 2.0 的文档是最新的，并且持续得到维护。访问
    SDL 网站 [libsdl.org](http://libsdl.org)，可以找到大量的文章和信息，包括对文档、邮件列表和论坛的链接。
- en: Overall, SDL offers a great place to start with game development, allowing you
    to focus on the game itself and ignore which platform you are developing for,
    until it is completely necessary. Now, with SDL 2.0 and the new features it brings
    to the table, SDL has become an even more capable library for game development
    using C++.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best way to find out what you can do with SDL and its various functions
    is to use the documentation found at [http://wiki.libsdl.org/moin.cgi/CategoryAPI](http://wiki.libsdl.org/moin.cgi/CategoryAPI).
    There you can see a list of all of SDL 2.0's functions along with various code
    examples.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: What is new in SDL 2.0?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The latest version of SDL and SDL 2.0, which we will be covering in this book,
    is still in development. It adds many new features to the existing SDL 1.2 framework.
    The SDL 2.0 Roadmap ([wiki.libsdl.org/moin.cgi/Roadmap](http://wiki.libsdl.org/moin.cgi/Roadmap))
    lists these features as:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: A 3D accelerated, texture-based rendering API
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware-accelerated 2D graphics
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for render targets
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple window support
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API support for clipboard access
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple input device support
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for 7.1 audio
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple audio device support
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Force-feedback API for joysticks
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Horizontal mouse wheel support
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multitouch input API support
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio capture support
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improvements to multithreading
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While not all of these will be used in our game-programming adventures, some
    of them are invaluable and make SDL an even better framework to use to develop
    games. We will be taking advantage of the new hardware-accelerated 2D graphics
    to make sure our games have excellent performance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Migrating SDL 1.2 extensions
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SDL has separate extensions that can be used to add new capabilities to the
    library. The reason these extensions are not included in the first place is to
    keep SDL as lightweight as possible, with the extensions serving to add functionality
    only when necessary. The next table shows some useful extensions along with their
    purpose. These extensions have been updated from their SDL1.2/3 Versions to support
    SDL 2.0, and this book will cover cloning and building them from their respective
    repositories as and when they are needed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| `SDL_image` | This is an image file loading library with support for BMP,
    GIF, PNG, TGA, PCX, and among others. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| `SDL_net` | This is a cross-platform networking library. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| `SDL_mixer` | This is an audio mixer library. It has support for MP3, MIDI,
    and OGG. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| `SDL_ttf` | This is a library supporting the use of `TrueType` fonts in SDL
    applications. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| `SDL_rtf` | This is a library to support the rendering of the **Rich Text
    Format** (**RTF**). |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: Setting up SDL in Visual C++ Express 2010
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book will cover setting up SDL 2.0 in Microsoft's Visual C++ Express 2010
    IDE. This IDE was chosen as it is available for free online, and is a widely used
    development environment within the games industry. The application is available
    at [https://www.microsoft.com/visualstudio/en-gb/express](https://www.microsoft.com/visualstudio/en-gb/express).
    Once the IDE has been installed we can go ahead and download SDL 2.0\. If you
    are not using Windows to develop games, then these instructions can be altered
    to suit your IDE of choice using its specific steps to link libraries and include
    files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'SDL 2.0 is still in development so there are no official releases as yet. The
    library can be retrieved in two different ways:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: One is to download the under-construction snapshot; you can then link against
    this to build your games (the quickest option)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second option is to clone the latest source using mercurial-distributed
    source control and build it from scratch (a good option to keep up with the latest
    developments of the library)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these options are available at [http://www.libsdl.org/hg.php](http://www.libsdl.org/hg.php).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Building SDL 2.0 on Windows also requires the latest DirectX SDK, which is available
    at [http://www.microsoft.com/en-gb/download/details.aspx?id=6812](http://www.microsoft.com/en-gb/download/details.aspx?id=6812),
    so make sure this is installed first.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Using Mercurial to get SDL 2.0 on Windows
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting SDL 2.0 directly from the constantly updated repository is the best
    way of making sure you have the latest build of SDL 2.0 and that you are taking
    advantage of any current bug fixes. To download and build the latest version of
    SDL 2.0 on Windows, we must first install a mercurial source control client so
    that we can mirror the latest source code and build from it. There are various
    command-line tools and GUIs available for use with mercurial. We will use TortoiseHg,
    a free and user-friendly mercurial application; it is available at [tortoisehg.bitbucket.org](http://tortoisehg.bitbucket.org).
    Once the application is installed, we can go ahead and grab the latest build.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Cloning and building the latest SDL 2.0 repository
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Cloning and building the latest version of SDL directly from the repository
    is relatively straightforward when following these steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Open up the **TortoiseHg Workbench** window.![Cloning and building the latest
    SDL 2.0 repository](img/6821OT_01_01.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pressing *Ctrl* + *Shift* + *N* will open the clone dialog box.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input the source of the repository; in this case it is listed on the SDL 2.0
    website as [http://hg.libsdl.org/SDL](http://hg.libsdl.org/SDL).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input or browse to choose a destination for the cloned repository—this book
    will assume that `C:\SDL2` is set as the location.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Clone** and allow the repository to copy to the chosen destination.![Cloning
    and building the latest SDL 2.0 repository](img/6821OT_01_02.jpg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `C:\SDL2` directory there will be a `VisualC` folder; inside the
    folder there is a Visual C++ 2010 solution, which we have to open with Visual
    C++ Express 2010.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual C++ Express will throw up a few errors about solution folders not being
    supported in the express version, but they can be safely ignored without affecting
    our ability to build the library.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the current build configuration to release and also choose 32 or 64 bit
    depending on your operating system.![Cloning and building the latest SDL 2.0 repository](img/6821OT_01_03.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project named **SDL** listed in the **Solution Explorer**
    list and choose **Build**.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a build of the SDL 2.0 library to use. It will be located at `C:\SDL2\VisualC\SDL\Win32(or
    x64)\Release\SDL.lib`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to build the SDL main library file, so choose it within the **Solution
    Explorer** list and build it. This file will build to `C:\SDL2\VisualC\SDLmain\Win32(or
    x64)\Release\SDLmain.lib`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a folder named `lib` in `C:\SDL2` and copy `SDL.lib` and `SDLmain.lib`
    into this newly created folder.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I have the library; now what?
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now a Visual C++ 2010 project can be created and linked with the SDL library.
    Here are the steps involved:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Create a new empty project in Visual C++ express and give it a name, such as
    `SDL-game`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once created, right-click on the project in the **Solution Explorer** list and
    choose **Properties**.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the configuration drop-down list to **All Configurations**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **VC++ Directories**, click on **Include Directories**. A small arrow
    will allow a drop-down menu; click on **<Edit…>**.![I have the library; now what?](img/6821OT_01_04.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click inside the box to create a new location. You can type or browse
    to `C:\SDL2.0\include` and click on **OK**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, do the same thing under library directories, this time passing in your
    created `lib` folder (`C:\SDL2\lib`).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, navigate to the **Linker** heading; inside the heading there will be an
    **Input** choice. Inside **Additional Dependencies** type `SDL.lib SDLmain.lib`:![I
    have the library; now what?](img/6821OT_01_05.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **System** heading and set the **SubSystem** heading to **Windows(/SUBSYSTEM:WINDOWS)**.![I
    have the library; now what?](img/6821OT_01_06.jpg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** and we are done.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hello SDL
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have an empty project, which links to the SDL library, so it is time
    to start our SDL development. Click on **Source Files** and use the keyboard shortcut
    *Ctrl* + *Shift* + *A* to add a new item. Create a C++ file called `main.cpp`.
    After creating this file, copy the following code into the source file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now attempt to build our first SDL application. Right-click on the project
    and choose **Build**. There will be an error about the `SDL.dll` file not being
    found:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![Hello SDL](img/6821OT_01_07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: The attempted build should have created a `Debug` or `Release` folder within
    the project directory (usually located in your `Documents` folder under visual
    studio and projects). This folder contains the `.exe` file from our attempted
    build; we need to add the `SDL.dll` file to this folder. The `SDL.dll` file is
    located at `C:\SDL2\VisualC\SDL\Win32` (or `x64)\Release\SDL.dll l`). When you
    want to distribute your game to another computer, you will have to share this
    file as well as the executable. After you have added the `SDL.dll` file to the
    executable folder, the project will now compile and show an SDL window; wait for
    5 seconds and then close.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Hello SDL
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go through the `Hello SDL` code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we included the `SDL.h` header file so that we have access to all of
    SDL''s functions:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next step is to create some global variables. One is a pointer to an `SDL_Window`
    function, which will be set using the `SDL_CreateWindow` function. The second
    is a pointer to an `SDL_Renderer` object; set using the `SDL_CreateRenderer` function:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now initialize SDL. This example initializes all of SDL''s subsystems
    using the `SDL_INIT_EVERYTHING` flag, but this does not always have to be the
    case (see SDL initialization flags):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the SDL initialization was successful, we can create the pointer to our
    window. `SDL_CreateWindow` returns a pointer to a window matching the passed parameters.
    The parameters are the window title, *x* position of the window, *y* position
    of the window, width, height, and any required `SDL_flags` (we will cover these
    later in the chapter). `SDL_WINDOWPOS_CENTERED` will center our window relative
    to the screen:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can now check whether the window creation was successful, and if so, move
    on to set the pointer to our renderer, passing the window we want the renderer
    to use as a parameter; in our case, it is the newly created `g_pWindow` pointer.
    The second parameter passed is the index of the rendering driver to initialize;
    in this case, we use `-1` to use the first capable driver. The final parameter
    is `SDL_RendererFlag` (see SDL renderer flags):'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If everything was successful, we can now create and show our window:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: SDL initialization flags
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Event handling, file I/O, and threading subsystems are all initialized by default
    in SDL. Other subsystems can be initialized using the following flags:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Initialized subsystem(s) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| `SDL_INIT_HAPTIC` | Force feedback subsystem |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| `SDL_INIT_AUDIO` | Audio subsystem |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| `SDL_INIT_VIDEO` | Video subsystem |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `SDL_INIT_TIMER` | Timer subsystem |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| `SDL_INIT_JOYSTICK` | Joystick subsystem |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| `SDL_INIT_EVERYTHING` | All subsystems |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| `SDL_INIT_NOPARACHUTE` | Don''t catch fatal signals |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: 'We can also use bitwise (`|`) to initialize more than one subsystem. To initialize
    only the audio and video subsystems, we can use a call to `SDL_Init`, for example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Checking whether a subsystem has been initialized or not can be done with a
    call to the `SDL_WasInit()` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: SDL renderer flags
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SDL 渲染器标志
- en: 'When initializing an `SDL_Renderer` flag, we can pass in a flag to determine
    its behavior. The following table describes each flag''s purpose:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始化 `SDL_Renderer` 标志时，我们可以传递一个标志来决定其行为。以下表格描述了每个标志的目的：
- en: '| Flag | Purpose |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 目的 |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SDL_RENDERER_SOFTWARE` | Use software rendering |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_RENDERER_SOFTWARE` | 使用软件渲染 |'
- en: '| `SDL_RENDERER_ACCELERATED` | Use hardware acceleration |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_RENDERER_ACCELERATED` | 使用硬件加速 |'
- en: '| `SDL_RENDERER_PRESENTVSYNC` | Synchronize renderer update with screen''s
    refresh rate |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_RENDERER_PRESENTVSYNC` | 将渲染器更新与屏幕刷新率同步 |'
- en: '| `SDL_RENDERER_TARGETTEXTURE` | Supports render to texture |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_RENDERER_TARGETTEXTURE` | 支持渲染到纹理 |'
- en: What makes up a game
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构成游戏的因素
- en: 'Outside the design and gameplay of a game, the underlying mechanics are essentially
    the interaction of various subsystems such as graphics, game logic, and user input.
    The graphics subsystem should not know how the game logic is implemented or vice
    versa. We can think of the structure of a game as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了游戏的设计和玩法之外，底层机制基本上是各种子系统的交互，如图形、游戏逻辑和用户输入。图形子系统不应该知道游戏逻辑是如何实现的，反之亦然。我们可以将游戏的结构想象如下：
- en: '![What makes up a game](img/6821OT_01_08.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![构成游戏的因素](img/6821OT_01_08.jpg)'
- en: Once the game is initialized, it then goes into a loop of checking for user
    input, updating any values based on the game physics, before rendering to the
    screen. Once the user chooses to exit, the loop is broken and the game moves onto
    cleaning everything up and exiting. This is the basic scaffold for a game and
    it is what will be used in this book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦游戏初始化，它就会进入一个循环，检查用户输入，根据游戏物理更新任何值，然后渲染到屏幕上。一旦用户选择退出，循环就会中断，游戏就会进入清理一切并退出的阶段。这是游戏的基本框架，也是本书中将使用的内容。
- en: We will be building a reusable framework that will take all of the legwork out
    of creating a game in SDL 2.0\. When it comes to boilerplate code and setup code,
    we really only want to write it once and then reuse it within new projects. The
    same can be done with drawing code, event handling, map loading, game states,
    and anything else that all games may require. We will start by breaking up the
    Hello SDL 2.0 example into separate parts. This will help us to start thinking
    about how code can be broken into reusable standalone chunks rather than packing
    everything into one large file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个可重用的框架，它将消除在 SDL 2.0 中创建游戏的所有繁琐工作。当涉及到样板代码和设置代码时，我们真的只想写一次，然后在新的项目中重用它。绘图代码、事件处理、地图加载、游戏状态以及所有游戏可能需要的其他内容也是如此。我们将从将
    Hello SDL 2.0 示例分解成单独的部分开始。这将帮助我们开始思考如何将代码分解成可重用的独立块，而不是将所有内容都打包到一个大文件中。
- en: Breaking up the Hello SDL code
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解 Hello SDL 代码
- en: 'We can break up the Hello SDL into separate functions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 Hello SDL 分解成单独的函数：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Follow these steps to break the `Hello SDL` code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤分解 `Hello SDL` 代码：
- en: 'Create an `init` function after the two global variables that takes any necessary
    values as parameters and passes them to the `SDL_CreateWindow` function:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个全局变量之后创建一个 `init` 函数，它接受任何必要的值作为参数并将它们传递给 `SDL_CreateWindow` 函数：
- en: '[PRE10]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our main function can now use these functions to initialize SDL:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的主函数现在可以使用这些函数来初始化 SDL：
- en: '[PRE11]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, we have broken the code up into separate parts: one function
    does the initialization for us and the other does the rendering code. We''ve added
    a way to keep the program running in the form of a `while` loop that runs continuously,
    rendering our window.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经将代码分解成单独的部分：一个函数为我们执行初始化，另一个执行渲染代码。我们添加了一种方式来保持程序运行，即一个持续运行的 `while`
    循环，渲染我们的窗口。
- en: 'Let''s take it a step further and try to identify which separate parts a full
    game might have and how our main loop might look. Referring to the first screenshot,
    we can see that the functions we will need are `initialize`, `get input`, `do
    physics`, `render`, and `exit`. We will generalize these functions slightly and
    rename them to `init()`, `handleEvents()`, `update()`, `render()`, and `clean()`.
    Let''s put these functions into `main.cpp`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，尝试确定一个完整游戏可能包含哪些单独的部分以及我们的主循环可能看起来像什么。参考第一张截图，我们可以看到我们需要的功能是 `initialize`、`get
    input`、`do physics`、`render` 和 `exit`。我们将稍微泛化这些函数并将它们重命名为 `init()`、`handleEvents()`、`update()`、`render()`
    和 `clean()`。让我们将这些函数放入 `main.cpp`：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What does this code do?
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这段代码做了什么？
- en: 'This code does not do much at the moment, but it shows the bare bones of a
    game and how a main loop might be broken apart. We declare some functions that
    can be used to run our game: first, the `init()` function, which will initialize
    SDL and create our window, and second, we declare the core loop functions of `render`,
    `update`, and `handle events`. We also declare a `clean` function, which will
    clean up code at the end of our game. We want this loop to continue running so
    we have a Boolean value that is set to `true`, so that we can continuously call
    our core loop functions.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The Game class
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, now that we have an idea of what makes up a game, we can separate the functions
    into their own class by following these steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create a new file in the project called `Game.h`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we can move our functions from the `main.cpp` file into the `Game.h`
    header file:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can alter the `main.cpp` file to use this new `Game` class:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our `main.cpp` file now does not declare or define any of these functions; it
    simply creates an instance of `Game` and calls the needed methods.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have this skeleton code, we can go ahead and tie SDL into it to
    create a window; we will also add a small event handler so that we can exit the
    application rather than having to force it to quit. We will slightly alter our
    `Game.h` file to allow us to add some SDL specifics and to also allow us to use
    an implementation file instead of defining functions in the header:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Looking back at the first part of this chapter (where we created an SDL window),
    we know that we need a pointer to an `SDL_Window` object that is set when calling
    `SDL_CreateWindow`, and a pointer to an `SDL_Renderer` object that is created
    by passing our window into `SDL_CreateRenderer`. The `init` function can be extended
    to use the same parameters as in the initial sample as well. This function will
    now return a Boolean value so that we can check whether SDL is initialized correctly:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can now create a new implementation `Game.cpp` file in the project so that
    we can create the definitions for these functions. We can take the code from the
    *Hello SDL* section and add it to the functions in our new `Game` class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `Game.cpp` and we can begin adding some functionality:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must include our `Game.h` header file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we can define our `init` function; it is essentially the same as the
    `init` function we have previously written in our `main.cpp` file:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will also define the `render` function. It clears the renderer and then
    renders again with the clear color:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we can clean up. We destroy both the window and the renderer and also
    call the `SDL_Quit` function to close all the subsystems:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So we have moved the `Hello SDL 2.0` code from the `main.cpp` file into a class
    called `Game`. We have freed up the `main.cpp` file to handle only the `Game`
    class; it knows nothing about SDL or how the `Game` class is implemented. Let''s
    add one more thing to the class to allow us to close the application the regular
    way:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will cover event handling in more detail in a forthcoming chapter. What
    this function now does is check if there is an event to handle, and if so, check
    if it is an `SDL_QUIT` event (by clicking on the cross to close a window). If
    the event is `SDL_QUIT`, we set the `Game` class'' `m_bRunning` member variable
    to `false`. The act of setting this variable to `false` makes the main loop stop
    and the application move onto cleaning up and then exiting:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `clean()` function destroys the window and renderer and then calls the `SDL_Quit()`
    function, closing all the initialized SDL subsystems.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To enable us to view our `std::cout` messages, we must first include `Windows.h`
    and then call `AllocConsole(); andfreopen("CON", "w", stdout);`. You can do this
    in the `main.cpp` file. Just remember to remove it when sharing your game.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Fullscreen SDL
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SDL_CreateWindow` takes an enumeration value of type `SDL_WindowFlags`. These
    values set how the window will behave. We created an `init` function in our `Game`
    class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The final parameter is an `SDL_WindowFlags` value, which is then passed into
    the `SDL_CreateWindow` function when initializing:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is a table of the `SDL_WindowFlags` function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Purpose |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| `SDL_WINDOW_FULLSCREEN` | Make the window fullscreen |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| `SDL_WINDOW_OPENGL` | Window can be used with as an OpenGL context |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| `SDL_WINDOW_SHOWN` | The window is visible |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `SDL_WINDOW_HIDDEN` | Hide the window |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| `SDL_WINDOW_BORDERLESS` | No border on the window |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| `SDL_WINDOW_RESIZABLE` | Enable resizing of the window |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| `SDL_WINDOW_MINIMIZED` | Minimize the window |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| `SDL_WINDOW_MAXIMIZED` | Maximize the window |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| `SDL_WINDOW_INPUT_GRABBED` | Window has grabbed input focus |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| `SDL_WINDOW_INPUT_FOCUS` | Window has input focus |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| `SDL_WINDOW_MOUSE_FOCUS` | Window has mouse focus |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| `SDL_WINDOW_FOREIGN` | The window was not created using SDL |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: 'Let''s pass in `SDL_WINDOW_FULLSCREEN` to the `init` function and test out
    some fullscreen SDL. Open up the `main.cpp` file and add this flag:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Build the application again and you should see that the window is fullscreen.
    To exit the application, it will have to be forced to quit (*Alt* + *F4* on Windows);
    we will be able to use the keyboard to quit the application in forthcoming chapters,
    but for now, we won't need fullscreen. One problem we have here is that we have
    now added something SDL specific to the `main.cpp` file. While we will not use
    any other frameworks in this book, in future we may want to use another. We can
    remove this SDL-specific flag and replace it with a Boolean value for whether
    we want fullscreen or not.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `int flags` parameter in our `Game init` function with a `boolfullscreen`
    parameter:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们 `Game init` 函数中的 `int flags` 参数替换为 `boolfullscreen` 参数：
- en: 'The code snippet for `Game.h`:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game.h` 的代码片段：'
- en: '[PRE27]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The code snippet for `Game.cpp`:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game.cpp` 的代码片段：'
- en: '[PRE28]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We create an `int` flags variable to pass into the `SDL_CreateWindow` function;
    if we have set `fullscreen` to `true`, then this value will be set to the `SDL_WINDOW_FULLSCREEN`
    flag, otherwise it will remain as `0` to signify that no flags are being used.
    Let''s test this now in our `main.cpp` file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 `int` 类型的 `flags` 变量，将其传递给 `SDL_CreateWindow` 函数；如果我们已将 `fullscreen`
    设置为 `true`，则此值将被设置为 `SDL_WINDOW_FULLSCREEN` 标志，否则它将保持为 `0`，表示没有使用任何标志。现在让我们在我们的
    `main.cpp` 文件中测试一下：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will again set our window to fullscreen, but we aren't using the SDL-specific
    flag to do it. Set it to `false` again as we will not need fullscreen for a while.
    Feel free to try out a few of the other flags to see what effects they have.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将再次将我们的窗口设置为全屏，但我们不会使用 SDL 特定的标志来完成它。再次将其设置为 `false`，因为我们暂时不需要全屏。您可以自由尝试其他标志，看看它们会产生什么效果。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A lot of ground has been covered in this chapter. We learned what SDL is and
    why it is a great tool for game development. We looked at the overall structure
    of a game and how it can be broken into individual parts, and we started to develop
    the skeleton of our framework by creating a `Game` class that can be used to initialize
    SDL and render things to the screen. We also had a small look at how SDL handles
    events by listening for a `quit` event to close our application. In the next chapter
    we will look at drawing in SDL and building the `SDL_image` extension.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。我们学习了 SDL 是什么以及为什么它是游戏开发的伟大工具。我们探讨了游戏的整体结构以及如何将其分解成单独的部分，并通过创建一个可以用来初始化
    SDL 并将内容渲染到屏幕上的 `Game` 类来开始构建我们框架的骨架。我们还简要地了解了 SDL 通过监听 `quit` 事件来处理事件的方式，以关闭我们的应用程序。在下一章中，我们将探讨在
    SDL 中绘图以及构建 `SDL_image` 扩展。
