- en: Chapter 1. Getting Started with SDL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. SDL 入门
- en: '**Simple DirectMedia Layer** (**SDL**) is a cross-platform multimedia library
    created by Sam Oscar Latinga. It provides low-level access to input (via mouse,
    keyboard, and gamepads/joysticks), 3D hardware, and the 2D video frame buffer.
    SDL is written in the C programming language, yet has native support for C++.
    The library also has bindings for several other languages such as Pascal, Objective-C,
    Python, Ruby, and Java; a full list of supported languages is available at [http://www.libsdl.org/languages.php](http://www.libsdl.org/languages.php).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单直接媒体层**（**SDL**）是一个由 Sam Oscar Latinga 创建的跨平台多媒体库。它提供了对输入（通过鼠标、键盘和游戏手柄/摇杆）、3D
    硬件和 2D 视频帧缓冲区的低级访问。SDL 使用 C 编程语言编写，但具有对 C++ 的原生支持。该库还对 Pascal、Objective-C、Python、Ruby
    和 Java 等几种其他语言提供了绑定；支持的语言完整列表可在 [http://www.libsdl.org/languages.php](http://www.libsdl.org/languages.php)
    上找到。'
- en: 'SDL has been used in many commercial games including World of Goo, Neverwinter
    Nights, and Second Life. It is also used in emulators such as ZSNES, Mupen64,
    and VisualBoyAdvance. Some popular games ported to Linux platforms such as Quake
    4, Soldier of Fortune, and Civilization: Call to Power utilize SDL in some form.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'SDL 已被用于许多商业游戏，包括《World of Goo》、《Neverwinter Nights》和《Second Life》。它也被用于诸如
    ZSNES、Mupen64 和 VisualBoyAdvance 这样的模拟器。一些流行的游戏，如移植到 Linux 平台上的《Quake 4》、《Soldier
    of Fortune》和《Civilization: Call to Power》，以某种形式使用了 SDL。'
- en: SDL is not just used for games. It is useful for all manner of applications.
    If your software needs access to graphics and input, chances are that SDL will
    be a great help. The SDL official website has a list of applications that have
    been created using the library ([http://www.libsdl.org/applications.php](http://www.libsdl.org/applications.php)).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SDL 不仅用于游戏。它对各种应用程序都很有用。如果你的软件需要访问图形和输入，那么 SDL 可能会非常有帮助。SDL 官方网站列出了使用该库创建的应用程序列表（[http://www.libsdl.org/applications.php](http://www.libsdl.org/applications.php)）。
- en: 'In this chapter we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Getting the latest SDL build from the Mercurial repository
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Mercurial 仓库获取最新的 SDL 构建
- en: Building and setting up SDL in Visual C++ 2010 Express
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual C++ 2010 Express 中构建和设置 SDL
- en: Creating a window with SDL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SDL 创建窗口
- en: Implementing a basic game class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个基本的游戏类
- en: Why use SDL?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用 SDL？
- en: Each platform has its own way of creating and displaying windows and graphics,
    handling user input, and accessing any low-level hardware; each one with its own
    intricacies and syntax. SDL provides a uniform way of accessing these platform-specific
    features. This uniformity leads to more time spent tweaking your game rather than
    worrying about how a specific platform allows you to render or get user input,
    and so on. Game programming can be quite difficult, and having a library such
    as SDL can get your game up and running relatively quickly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平台都有其创建和显示窗口、处理用户输入以及访问任何底层硬件的独特方式；每种方式都有其复杂性以及语法。SDL 提供了一种统一的方式来访问这些特定平台的特性。这种一致性使得你花更多的时间调整游戏，而不是担心特定平台如何让你渲染或获取用户输入等问题。游戏编程可能相当困难，而拥有像
    SDL 这样的库可以使你的游戏相对快速地启动和运行。
- en: The ability to write a game on Windows and then go on to compile it on OSX or
    Linux with little to no changes in the code is extremely powerful and perfect
    for developers who want to target as many platforms as possible; SDL makes this
    kind of cross-platform development a breeze. While SDL is extremely effective
    for cross-platform development, it is also an excellent choice for creating a
    game with just one platform in mind, due to its ease of use and abundance of features.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在 Windows 上编写游戏，然后将其编译到 OSX 或 Linux 上，而代码几乎不需要任何修改，这种能力非常强大，非常适合希望针对尽可能多的平台进行开发的开发者；SDL
    使得这种跨平台开发变得轻而易举。虽然 SDL 对于跨平台开发非常有效，但它也是一个创建仅针对一个平台的游戏的绝佳选择，因为它易于使用且功能丰富。
- en: SDL has a large user base and is being actively updated and maintained. There
    is also a responsive community along with a helpful mailing list. Documentation
    for SDL 2.0 is up-to-date and constantly maintained. Visiting the SDL website,
    [libsdl.org](http://libsdl.org), offers up lots of articles and information with
    links to the documentation, mailing list, and forums.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SDL 拥有庞大的用户群体，并且正在积极地进行更新和维护。同时，还有一个响应迅速的社区以及一个有帮助的邮件列表。SDL 2.0 的文档是最新的，并且持续得到维护。访问
    SDL 网站 [libsdl.org](http://libsdl.org)，可以找到大量的文章和信息，包括对文档、邮件列表和论坛的链接。
- en: Overall, SDL offers a great place to start with game development, allowing you
    to focus on the game itself and ignore which platform you are developing for,
    until it is completely necessary. Now, with SDL 2.0 and the new features it brings
    to the table, SDL has become an even more capable library for game development
    using C++.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，SDL 为游戏开发提供了一个很好的起点，让你能够专注于游戏本身，而忽略你正在为哪个平台开发，直到完全必要。现在，随着 SDL 2.0 及其带来的新特性，SDL
    已经成为使用 C++ 进行游戏开发的一个更强大的库。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The best way to find out what you can do with SDL and its various functions
    is to use the documentation found at [http://wiki.libsdl.org/moin.cgi/CategoryAPI](http://wiki.libsdl.org/moin.cgi/CategoryAPI).
    There you can see a list of all of SDL 2.0's functions along with various code
    examples.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 SDL 及其各种功能可以做什么，最好的方法是使用在 [http://wiki.libsdl.org/moin.cgi/CategoryAPI](http://wiki.libsdl.org/moin.cgi/CategoryAPI)
    找到的文档。在那里，你可以看到 SDL 2.0 所有功能的列表以及各种代码示例。
- en: What is new in SDL 2.0?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SDL 2.0 的新特性是什么？
- en: 'The latest version of SDL and SDL 2.0, which we will be covering in this book,
    is still in development. It adds many new features to the existing SDL 1.2 framework.
    The SDL 2.0 Roadmap ([wiki.libsdl.org/moin.cgi/Roadmap](http://wiki.libsdl.org/moin.cgi/Roadmap))
    lists these features as:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将要介绍的 SDL 和 SDL 2.0 的最新版本仍在开发中。它为现有的 SDL 1.2 框架添加了许多新特性。SDL 2.0 路线图 ([wiki.libsdl.org/moin.cgi/Roadmap](http://wiki.libsdl.org/moin.cgi/Roadmap))
    列出了以下特性：
- en: A 3D accelerated, texture-based rendering API
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基于纹理的 3D 加速渲染 API
- en: Hardware-accelerated 2D graphics
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件加速 2D 图形
- en: Support for render targets
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持渲染目标
- en: Multiple window support
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多窗口支持
- en: API support for clipboard access
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持剪贴板访问的 API
- en: Multiple input device support
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多输入设备支持
- en: Support for 7.1 audio
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 7.1 音频
- en: Multiple audio device support
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多音频设备支持
- en: Force-feedback API for joysticks
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏手柄的力反馈 API
- en: Horizontal mouse wheel support
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平鼠标滚轮支持
- en: Multitouch input API support
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多点触控输入 API 支持
- en: Audio capture support
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频捕获支持
- en: Improvements to multithreading
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程改进
- en: While not all of these will be used in our game-programming adventures, some
    of them are invaluable and make SDL an even better framework to use to develop
    games. We will be taking advantage of the new hardware-accelerated 2D graphics
    to make sure our games have excellent performance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们游戏编程冒险中不会使用所有这些特性，但其中一些是非常宝贵的，使得 SDL 成为开发游戏时更好的框架。我们将利用新的硬件加速 2D 图形，确保我们的游戏有出色的性能。
- en: Migrating SDL 1.2 extensions
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移 SDL 1.2 扩展
- en: SDL has separate extensions that can be used to add new capabilities to the
    library. The reason these extensions are not included in the first place is to
    keep SDL as lightweight as possible, with the extensions serving to add functionality
    only when necessary. The next table shows some useful extensions along with their
    purpose. These extensions have been updated from their SDL1.2/3 Versions to support
    SDL 2.0, and this book will cover cloning and building them from their respective
    repositories as and when they are needed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: SDL 有独立的扩展，可以用来向库添加新功能。这些扩展最初没有被包含在内，是为了使 SDL 尽可能保持轻量级，扩展的作用是在必要时添加功能。下表展示了某些有用的扩展及其用途。这些扩展已经从
    SDL1.2/3 版本更新，以支持 SDL 2.0，本书将介绍如何从各自的仓库克隆和构建它们，当需要时。
- en: '| Name | Description |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SDL_image` | This is an image file loading library with support for BMP,
    GIF, PNG, TGA, PCX, and among others. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_image` | 这是一个支持 BMP、GIF、PNG、TGA、PCX 等图像文件加载的库。|'
- en: '| `SDL_net` | This is a cross-platform networking library. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_net` | 这是一个跨平台网络库。|'
- en: '| `SDL_mixer` | This is an audio mixer library. It has support for MP3, MIDI,
    and OGG. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_mixer` | 这是一个音频混音库。它支持 MP3、MIDI 和 OGG。|'
- en: '| `SDL_ttf` | This is a library supporting the use of `TrueType` fonts in SDL
    applications. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_ttf` | 这是一个支持在 SDL 应用中使用 `TrueType` 字体的库。|'
- en: '| `SDL_rtf` | This is a library to support the rendering of the **Rich Text
    Format** (**RTF**). |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_rtf` | 这是一个支持渲染富文本格式（**RTF**）的库。|'
- en: Setting up SDL in Visual C++ Express 2010
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Visual C++ Express 2010 中设置 SDL
- en: This book will cover setting up SDL 2.0 in Microsoft's Visual C++ Express 2010
    IDE. This IDE was chosen as it is available for free online, and is a widely used
    development environment within the games industry. The application is available
    at [https://www.microsoft.com/visualstudio/en-gb/express](https://www.microsoft.com/visualstudio/en-gb/express).
    Once the IDE has been installed we can go ahead and download SDL 2.0\. If you
    are not using Windows to develop games, then these instructions can be altered
    to suit your IDE of choice using its specific steps to link libraries and include
    files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将介绍在微软的 Visual C++ Express 2010 IDE 中设置 SDL 2.0。选择这个 IDE 是因为它可以在网上免费使用，并且在游戏行业中是一个广泛使用的开发环境。应用程序可在
    [https://www.microsoft.com/visualstudio/en-gb/express](https://www.microsoft.com/visualstudio/en-gb/express)
    获取。一旦安装了 IDE，我们就可以继续下载 SDL 2.0。如果您不是在 Windows 上开发游戏，则可以修改这些说明以适应您选择的 IDE，使用其特定的步骤来链接库和包含文件。
- en: 'SDL 2.0 is still in development so there are no official releases as yet. The
    library can be retrieved in two different ways:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: SDL 2.0 仍在开发中，因此目前还没有官方发布版本。库可以通过两种不同的方式检索：
- en: One is to download the under-construction snapshot; you can then link against
    this to build your games (the quickest option)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种方法是下载正在构建的快照；然后您可以将它链接起来构建您的游戏（最快的选择）
- en: The second option is to clone the latest source using mercurial-distributed
    source control and build it from scratch (a good option to keep up with the latest
    developments of the library)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是使用 mercurial 分布式源控制克隆最新源并从头开始构建（跟踪库最新发展的好方法）
- en: Both of these options are available at [http://www.libsdl.org/hg.php](http://www.libsdl.org/hg.php).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项均可在 [http://www.libsdl.org/hg.php](http://www.libsdl.org/hg.php) 找到。
- en: Building SDL 2.0 on Windows also requires the latest DirectX SDK, which is available
    at [http://www.microsoft.com/en-gb/download/details.aspx?id=6812](http://www.microsoft.com/en-gb/download/details.aspx?id=6812),
    so make sure this is installed first.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上构建 SDL 2.0 还需要最新的 DirectX SDK，它可在 [http://www.microsoft.com/en-gb/download/details.aspx?id=6812](http://www.microsoft.com/en-gb/download/details.aspx?id=6812)
    获取，因此请确保首先安装它。
- en: Using Mercurial to get SDL 2.0 on Windows
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Mercurial 在 Windows 上获取 SDL 2.0
- en: Getting SDL 2.0 directly from the constantly updated repository is the best
    way of making sure you have the latest build of SDL 2.0 and that you are taking
    advantage of any current bug fixes. To download and build the latest version of
    SDL 2.0 on Windows, we must first install a mercurial source control client so
    that we can mirror the latest source code and build from it. There are various
    command-line tools and GUIs available for use with mercurial. We will use TortoiseHg,
    a free and user-friendly mercurial application; it is available at [tortoisehg.bitbucket.org](http://tortoisehg.bitbucket.org).
    Once the application is installed, we can go ahead and grab the latest build.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从不断更新的仓库获取 SDL 2.0 是确保您拥有 SDL 2.0 的最新构建版本并利用任何当前错误修复的最佳方式。要在 Windows 上下载和构建
    SDL 2.0 的最新版本，我们必须首先安装一个 mercurial 版本控制客户端，以便我们可以镜像最新的源代码并从中构建。有各种命令行工具和 GUI 可用于与
    mercurial 一起使用。我们将使用 TortoiseHg，这是一个免费且用户友好的 mercurial 应用程序；它可在 [tortoisehg.bitbucket.org](http://tortoisehg.bitbucket.org)
    获取。一旦安装了应用程序，我们就可以继续获取最新的构建。
- en: Cloning and building the latest SDL 2.0 repository
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从仓库克隆和构建最新的 SDL 2.0 仓库
- en: 'Cloning and building the latest version of SDL directly from the repository
    is relatively straightforward when following these steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤从仓库直接克隆和构建 SDL 的最新版本相对简单：
- en: Open up the **TortoiseHg Workbench** window.![Cloning and building the latest
    SDL 2.0 repository](img/6821OT_01_01.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **TortoiseHg 工作台** 窗口。![从仓库克隆和构建最新的 SDL 2.0 仓库](img/6821OT_01_01.jpg)
- en: Pressing *Ctrl* + *Shift* + *N* will open the clone dialog box.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *Shift* + *N* 将打开克隆对话框。
- en: Input the source of the repository; in this case it is listed on the SDL 2.0
    website as [http://hg.libsdl.org/SDL](http://hg.libsdl.org/SDL).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入仓库的源；在这个例子中，它列在 SDL 2.0 网站上，网址为 [http://hg.libsdl.org/SDL](http://hg.libsdl.org/SDL)。
- en: Input or browse to choose a destination for the cloned repository—this book
    will assume that `C:\SDL2` is set as the location.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入或浏览以选择克隆仓库的目的地——本书将假设 `C:\SDL2` 被设置为位置。
- en: Click on **Clone** and allow the repository to copy to the chosen destination.![Cloning
    and building the latest SDL 2.0 repository](img/6821OT_01_02.jpg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **克隆** 并允许仓库复制到所选位置。![从仓库克隆和构建最新的 SDL 2.0 仓库](img/6821OT_01_02.jpg)
- en: Within the `C:\SDL2` directory there will be a `VisualC` folder; inside the
    folder there is a Visual C++ 2010 solution, which we have to open with Visual
    C++ Express 2010.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`C:\SDL2`目录下将有一个`VisualC`文件夹；在文件夹内部有一个Visual C++ 2010解决方案，我们必须使用Visual C++
    Express 2010打开它。
- en: Visual C++ Express will throw up a few errors about solution folders not being
    supported in the express version, but they can be safely ignored without affecting
    our ability to build the library.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual C++ Express可能会抛出一些关于Express版本不支持解决方案文件夹的错误，但可以安全忽略，而不会影响我们构建库的能力。
- en: Change the current build configuration to release and also choose 32 or 64 bit
    depending on your operating system.![Cloning and building the latest SDL 2.0 repository](img/6821OT_01_03.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前构建配置更改为发布，并根据您的操作系统选择32位或64位。![克隆和构建最新的SDL 2.0存储库](img/6821OT_01_03.jpg)
- en: Right-click on the project named **SDL** listed in the **Solution Explorer**
    list and choose **Build**.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**解决方案资源管理器**列表中名为**SDL**的项目，并选择**构建**。
- en: We now have a build of the SDL 2.0 library to use. It will be located at `C:\SDL2\VisualC\SDL\Win32(or
    x64)\Release\SDL.lib`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了SDL 2.0库的构建版本可以使用。它将位于`C:\SDL2\VisualC\SDL\Win32(or x64)\Release\SDL.lib`。
- en: We also need to build the SDL main library file, so choose it within the **Solution
    Explorer** list and build it. This file will build to `C:\SDL2\VisualC\SDLmain\Win32(or
    x64)\Release\SDLmain.lib`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要构建SDL主库文件，因此在**解决方案资源管理器**列表中选择它并构建它。此文件将构建到`C:\SDL2\VisualC\SDLmain\Win32(or
    x64)\Release\SDLmain.lib`。
- en: Create a folder named `lib` in `C:\SDL2` and copy `SDL.lib` and `SDLmain.lib`
    into this newly created folder.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`C:\SDL2`中创建一个名为`lib`的文件夹，并将`SDL.lib`和`SDLmain.lib`复制到这个新创建的文件夹中。
- en: I have the library; now what?
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我已经有了库；现在该做什么？
- en: 'Now a Visual C++ 2010 project can be created and linked with the SDL library.
    Here are the steps involved:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以创建一个Visual C++ 2010项目，并将其链接到SDL库。以下是涉及的步骤：
- en: Create a new empty project in Visual C++ express and give it a name, such as
    `SDL-game`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual C++ express中创建一个新的空项目，并给它起一个名字，例如`SDL-game`。
- en: Once created, right-click on the project in the **Solution Explorer** list and
    choose **Properties**.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建完成后，右键单击**解决方案资源管理器**列表中的项目，并选择**属性**。
- en: Change the configuration drop-down list to **All Configurations**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将配置下拉列表更改为**所有配置**。
- en: Under **VC++ Directories**, click on **Include Directories**. A small arrow
    will allow a drop-down menu; click on **<Edit…>**.![I have the library; now what?](img/6821OT_01_04.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**VC++目录**下，点击**包含目录**。一个小箭头将允许下拉菜单；点击**<编辑…**>。![我有了库；现在该做什么？](img/6821OT_01_04.jpg)
- en: Double-click inside the box to create a new location. You can type or browse
    to `C:\SDL2.0\include` and click on **OK**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击框内创建一个新位置。您可以在其中键入或浏览到`C:\SDL2.0\include`，然后点击**确定**。
- en: Next, do the same thing under library directories, this time passing in your
    created `lib` folder (`C:\SDL2\lib`).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在库目录下做同样的事情，这次传递你创建的`lib`文件夹（`C:\SDL2\lib`）。
- en: Next, navigate to the **Linker** heading; inside the heading there will be an
    **Input** choice. Inside **Additional Dependencies** type `SDL.lib SDLmain.lib`:![I
    have the library; now what?](img/6821OT_01_05.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导航到**链接器**标题；在标题内部将有一个**输入**选项。在**附加依赖项**中输入`SDL.lib SDLmain.lib`：![我有了库；现在该做什么？](img/6821OT_01_05.jpg)
- en: Navigate to the **System** heading and set the **SubSystem** heading to **Windows(/SUBSYSTEM:WINDOWS)**.![I
    have the library; now what?](img/6821OT_01_06.jpg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**系统**标题，并将**子系统**标题设置为**Windows(/SUBSYSTEM:WINDOWS)**。![我有了库；现在该做什么？](img/6821OT_01_06.jpg)
- en: Click on **OK** and we are done.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**，我们就完成了。
- en: Hello SDL
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello SDL
- en: 'We now have an empty project, which links to the SDL library, so it is time
    to start our SDL development. Click on **Source Files** and use the keyboard shortcut
    *Ctrl* + *Shift* + *A* to add a new item. Create a C++ file called `main.cpp`.
    After creating this file, copy the following code into the source file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个空的项目，它链接到了SDL库，所以是时候开始我们的SDL开发了。点击**源文件**，并使用键盘快捷键*Ctrl* + *Shift* +
    *A*添加一个新项。创建一个名为`main.cpp`的C++文件。创建此文件后，将以下代码复制到源文件中：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now attempt to build our first SDL application. Right-click on the project
    and choose **Build**. There will be an error about the `SDL.dll` file not being
    found:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以尝试构建我们的第一个SDL应用程序。右键单击项目并选择**构建**。将会有一个关于找不到`SDL.dll`文件的错误：
- en: '![Hello SDL](img/6821OT_01_07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Hello SDL](img/6821OT_01_07.jpg)'
- en: The attempted build should have created a `Debug` or `Release` folder within
    the project directory (usually located in your `Documents` folder under visual
    studio and projects). This folder contains the `.exe` file from our attempted
    build; we need to add the `SDL.dll` file to this folder. The `SDL.dll` file is
    located at `C:\SDL2\VisualC\SDL\Win32` (or `x64)\Release\SDL.dll l`). When you
    want to distribute your game to another computer, you will have to share this
    file as well as the executable. After you have added the `SDL.dll` file to the
    executable folder, the project will now compile and show an SDL window; wait for
    5 seconds and then close.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试构建应该在项目目录内创建一个`Debug`或`Release`文件夹（通常位于Visual Studio下的`Documents`文件夹中）。这个文件夹包含我们尝试构建的`.exe`文件；我们需要将`SDL.dll`文件添加到这个文件夹中。`SDL.dll`文件位于`C:\SDL2\VisualC\SDL\Win32`（或`x64`）\Release\SDL.dll。当你想要将你的游戏分发到另一台计算机时，你将不得不分享这个文件以及可执行文件。在你将`SDL.dll`文件添加到可执行文件文件夹后，项目现在将编译并显示一个SDL窗口；等待5秒钟然后关闭。
- en: An overview of Hello SDL
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello SDL的概述
- en: 'Let''s go through the `Hello SDL` code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`Hello SDL`的代码：
- en: 'First, we included the `SDL.h` header file so that we have access to all of
    SDL''s functions:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包含了`SDL.h`头文件，以便我们可以访问SDL的所有函数：
- en: '[PRE1]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next step is to create some global variables. One is a pointer to an `SDL_Window`
    function, which will be set using the `SDL_CreateWindow` function. The second
    is a pointer to an `SDL_Renderer` object; set using the `SDL_CreateRenderer` function:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一些全局变量。一个是`SDL_Window`函数的指针，它将通过`SDL_CreateWindow`函数来设置。另一个是`SDL_Renderer`对象的指针；通过`SDL_CreateRenderer`函数来设置：
- en: '[PRE2]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now initialize SDL. This example initializes all of SDL''s subsystems
    using the `SDL_INIT_EVERYTHING` flag, but this does not always have to be the
    case (see SDL initialization flags):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以初始化SDL。这个例子使用`SDL_INIT_EVERYTHING`标志初始化了SDL的所有子系统，但这并不总是必须的（见SDL初始化标志）：
- en: '[PRE3]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the SDL initialization was successful, we can create the pointer to our
    window. `SDL_CreateWindow` returns a pointer to a window matching the passed parameters.
    The parameters are the window title, *x* position of the window, *y* position
    of the window, width, height, and any required `SDL_flags` (we will cover these
    later in the chapter). `SDL_WINDOWPOS_CENTERED` will center our window relative
    to the screen:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果SDL初始化成功，我们可以创建指向我们的窗口的指针。`SDL_CreateWindow`返回一个指向匹配传递参数的窗口的指针。参数是窗口标题、窗口的*x*位置、窗口的*y*位置、宽度、高度以及任何所需的`SDL_flags`（我们将在本章后面介绍这些）。`SDL_WINDOWPOS_CENTERED`将使窗口相对于屏幕居中：
- en: '[PRE4]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can now check whether the window creation was successful, and if so, move
    on to set the pointer to our renderer, passing the window we want the renderer
    to use as a parameter; in our case, it is the newly created `g_pWindow` pointer.
    The second parameter passed is the index of the rendering driver to initialize;
    in this case, we use `-1` to use the first capable driver. The final parameter
    is `SDL_RendererFlag` (see SDL renderer flags):'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以检查窗口创建是否成功，如果是的话，继续设置指向我们的渲染器的指针，传递我们想要渲染器使用的窗口作为参数；在我们的例子中，是新建的`g_pWindow`指针。传递的第二个参数是初始化的渲染驱动程序的索引；在这种情况下，我们使用`-1`来使用第一个可用的驱动程序。最后一个参数是`SDL_RendererFlag`（见SDL渲染器标志）：
- en: '[PRE5]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If everything was successful, we can now create and show our window:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们现在可以创建并显示我们的窗口：
- en: '[PRE6]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: SDL initialization flags
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SDL初始化标志
- en: 'Event handling, file I/O, and threading subsystems are all initialized by default
    in SDL. Other subsystems can be initialized using the following flags:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理、文件I/O和线程子系统在SDL中默认初始化。其他子系统可以使用以下标志进行初始化：
- en: '| Flag | Initialized subsystem(s) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 初始化的子系统 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SDL_INIT_HAPTIC` | Force feedback subsystem |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_INIT_HAPTIC` | 力反馈子系统 |'
- en: '| `SDL_INIT_AUDIO` | Audio subsystem |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_INIT_AUDIO` | 音频子系统 |'
- en: '| `SDL_INIT_VIDEO` | Video subsystem |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_INIT_VIDEO` | 视频子系统 |'
- en: '| `SDL_INIT_TIMER` | Timer subsystem |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_INIT_TIMER` | 计时器子系统 |'
- en: '| `SDL_INIT_JOYSTICK` | Joystick subsystem |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_INIT_JOYSTICK` | 游戏手柄子系统 |'
- en: '| `SDL_INIT_EVERYTHING` | All subsystems |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_INIT_EVERYTHING` | 所有子系统 |'
- en: '| `SDL_INIT_NOPARACHUTE` | Don''t catch fatal signals |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_INIT_NOPARACHUTE` | 不捕获致命信号 |'
- en: 'We can also use bitwise (`|`) to initialize more than one subsystem. To initialize
    only the audio and video subsystems, we can use a call to `SDL_Init`, for example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用位运算符（`|`）来初始化多个子系统。要仅初始化音频和视频子系统，我们可以使用对`SDL_Init`的调用，例如：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Checking whether a subsystem has been initialized or not can be done with a
    call to the `SDL_WasInit()` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个子系统是否已初始化可以通过调用`SDL_WasInit()`函数来完成：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: SDL renderer flags
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SDL 渲染器标志
- en: 'When initializing an `SDL_Renderer` flag, we can pass in a flag to determine
    its behavior. The following table describes each flag''s purpose:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始化 `SDL_Renderer` 标志时，我们可以传递一个标志来决定其行为。以下表格描述了每个标志的目的：
- en: '| Flag | Purpose |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 目的 |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SDL_RENDERER_SOFTWARE` | Use software rendering |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_RENDERER_SOFTWARE` | 使用软件渲染 |'
- en: '| `SDL_RENDERER_ACCELERATED` | Use hardware acceleration |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_RENDERER_ACCELERATED` | 使用硬件加速 |'
- en: '| `SDL_RENDERER_PRESENTVSYNC` | Synchronize renderer update with screen''s
    refresh rate |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_RENDERER_PRESENTVSYNC` | 将渲染器更新与屏幕刷新率同步 |'
- en: '| `SDL_RENDERER_TARGETTEXTURE` | Supports render to texture |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_RENDERER_TARGETTEXTURE` | 支持渲染到纹理 |'
- en: What makes up a game
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构成游戏的因素
- en: 'Outside the design and gameplay of a game, the underlying mechanics are essentially
    the interaction of various subsystems such as graphics, game logic, and user input.
    The graphics subsystem should not know how the game logic is implemented or vice
    versa. We can think of the structure of a game as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了游戏的设计和玩法之外，底层机制基本上是各种子系统的交互，如图形、游戏逻辑和用户输入。图形子系统不应该知道游戏逻辑是如何实现的，反之亦然。我们可以将游戏的结构想象如下：
- en: '![What makes up a game](img/6821OT_01_08.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![构成游戏的因素](img/6821OT_01_08.jpg)'
- en: Once the game is initialized, it then goes into a loop of checking for user
    input, updating any values based on the game physics, before rendering to the
    screen. Once the user chooses to exit, the loop is broken and the game moves onto
    cleaning everything up and exiting. This is the basic scaffold for a game and
    it is what will be used in this book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦游戏初始化，它就会进入一个循环，检查用户输入，根据游戏物理更新任何值，然后渲染到屏幕上。一旦用户选择退出，循环就会中断，游戏就会进入清理一切并退出的阶段。这是游戏的基本框架，也是本书中将使用的内容。
- en: We will be building a reusable framework that will take all of the legwork out
    of creating a game in SDL 2.0\. When it comes to boilerplate code and setup code,
    we really only want to write it once and then reuse it within new projects. The
    same can be done with drawing code, event handling, map loading, game states,
    and anything else that all games may require. We will start by breaking up the
    Hello SDL 2.0 example into separate parts. This will help us to start thinking
    about how code can be broken into reusable standalone chunks rather than packing
    everything into one large file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个可重用的框架，它将消除在 SDL 2.0 中创建游戏的所有繁琐工作。当涉及到样板代码和设置代码时，我们真的只想写一次，然后在新的项目中重用它。绘图代码、事件处理、地图加载、游戏状态以及所有游戏可能需要的其他内容也是如此。我们将从将
    Hello SDL 2.0 示例分解成单独的部分开始。这将帮助我们开始思考如何将代码分解成可重用的独立块，而不是将所有内容都打包到一个大文件中。
- en: Breaking up the Hello SDL code
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解 Hello SDL 代码
- en: 'We can break up the Hello SDL into separate functions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 Hello SDL 分解成单独的函数：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Follow these steps to break the `Hello SDL` code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤分解 `Hello SDL` 代码：
- en: 'Create an `init` function after the two global variables that takes any necessary
    values as parameters and passes them to the `SDL_CreateWindow` function:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个全局变量之后创建一个 `init` 函数，它接受任何必要的值作为参数并将它们传递给 `SDL_CreateWindow` 函数：
- en: '[PRE10]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our main function can now use these functions to initialize SDL:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的主函数现在可以使用这些函数来初始化 SDL：
- en: '[PRE11]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, we have broken the code up into separate parts: one function
    does the initialization for us and the other does the rendering code. We''ve added
    a way to keep the program running in the form of a `while` loop that runs continuously,
    rendering our window.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经将代码分解成单独的部分：一个函数为我们执行初始化，另一个执行渲染代码。我们添加了一种方式来保持程序运行，即一个持续运行的 `while`
    循环，渲染我们的窗口。
- en: 'Let''s take it a step further and try to identify which separate parts a full
    game might have and how our main loop might look. Referring to the first screenshot,
    we can see that the functions we will need are `initialize`, `get input`, `do
    physics`, `render`, and `exit`. We will generalize these functions slightly and
    rename them to `init()`, `handleEvents()`, `update()`, `render()`, and `clean()`.
    Let''s put these functions into `main.cpp`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，尝试确定一个完整游戏可能包含哪些单独的部分以及我们的主循环可能看起来像什么。参考第一张截图，我们可以看到我们需要的功能是 `initialize`、`get
    input`、`do physics`、`render` 和 `exit`。我们将稍微泛化这些函数并将它们重命名为 `init()`、`handleEvents()`、`update()`、`render()`
    和 `clean()`。让我们将这些函数放入 `main.cpp`：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What does this code do?
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这段代码做了什么？
- en: 'This code does not do much at the moment, but it shows the bare bones of a
    game and how a main loop might be broken apart. We declare some functions that
    can be used to run our game: first, the `init()` function, which will initialize
    SDL and create our window, and second, we declare the core loop functions of `render`,
    `update`, and `handle events`. We also declare a `clean` function, which will
    clean up code at the end of our game. We want this loop to continue running so
    we have a Boolean value that is set to `true`, so that we can continuously call
    our core loop functions.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码目前并没有做太多，但它展示了游戏的基本结构和主循环可能被拆分的方式。我们声明了一些可以用来运行我们的游戏的功能：首先，`init()` 函数，它将初始化
    SDL 并创建我们的窗口；其次，我们声明了核心循环函数 `render`、`update` 和 `handle events`。我们还声明了一个 `clean`
    函数，它将在游戏结束时清理代码。我们希望这个循环持续运行，所以我们设置了一个布尔值，将其设置为 `true`，这样我们就可以连续调用我们的核心循环函数。
- en: The Game class
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏类
- en: 'So, now that we have an idea of what makes up a game, we can separate the functions
    into their own class by following these steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经了解了构成游戏的基本要素，我们可以按照以下步骤将这些函数分离到它们自己的类中：
- en: 'Go ahead and create a new file in the project called `Game.h`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中创建一个名为 `Game.h` 的新文件：
- en: '[PRE13]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we can move our functions from the `main.cpp` file into the `Game.h`
    header file:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以将我们的函数从 `main.cpp` 文件移动到 `Game.h` 头文件中：
- en: '[PRE14]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can alter the `main.cpp` file to use this new `Game` class:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以修改 `main.cpp` 文件以使用这个新的 `Game` 类：
- en: '[PRE15]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our `main.cpp` file now does not declare or define any of these functions; it
    simply creates an instance of `Game` and calls the needed methods.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的 `main.cpp` 文件现在不声明或定义这些函数；它只是创建 `Game` 的一个实例并调用所需的方法。
- en: 'Now that we have this skeleton code, we can go ahead and tie SDL into it to
    create a window; we will also add a small event handler so that we can exit the
    application rather than having to force it to quit. We will slightly alter our
    `Game.h` file to allow us to add some SDL specifics and to also allow us to use
    an implementation file instead of defining functions in the header:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了这个骨架代码，我们可以继续将其与 SDL 集成以创建窗口；我们还将添加一个小的事件处理器，以便我们可以退出应用程序而不是强制它退出。我们将稍微修改我们的
    `Game.h` 文件，以便我们可以添加一些 SDL 特定内容，并允许我们使用实现文件而不是在头文件中定义函数：
- en: '[PRE16]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Looking back at the first part of this chapter (where we created an SDL window),
    we know that we need a pointer to an `SDL_Window` object that is set when calling
    `SDL_CreateWindow`, and a pointer to an `SDL_Renderer` object that is created
    by passing our window into `SDL_CreateRenderer`. The `init` function can be extended
    to use the same parameters as in the initial sample as well. This function will
    now return a Boolean value so that we can check whether SDL is initialized correctly:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本章的第一部分（我们创建了一个 SDL 窗口），我们知道我们需要一个指向 `SDL_Window` 对象的指针，该对象在调用 `SDL_CreateWindow`
    时设置，以及一个指向由将窗口传递给 `SDL_CreateRenderer` 创建的 `SDL_Renderer` 对象的指针。`init` 函数可以扩展以使用与初始示例相同的参数。这个函数现在将返回一个布尔值，这样我们就可以检查
    SDL 是否正确初始化：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can now create a new implementation `Game.cpp` file in the project so that
    we can create the definitions for these functions. We can take the code from the
    *Hello SDL* section and add it to the functions in our new `Game` class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在项目中创建一个新的实现文件 `Game.cpp`，以便我们可以为这些函数创建定义。我们可以从 *Hello SDL* 部分取代码并添加到我们新的
    `Game` 类中。
- en: 'Open up `Game.cpp` and we can begin adding some functionality:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Game.cpp` 文件，我们可以开始添加一些功能：
- en: 'First, we must include our `Game.h` header file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须包含我们的 `Game.h` 头文件：
- en: '[PRE18]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we can define our `init` function; it is essentially the same as the
    `init` function we have previously written in our `main.cpp` file:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以定义我们的 `init` 函数；它基本上与我们在 `main.cpp` 文件中之前编写的 `init` 函数相同：
- en: '[PRE19]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will also define the `render` function. It clears the renderer and then
    renders again with the clear color:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将定义 `render` 函数。它清除渲染器，然后使用清除颜色重新渲染：
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we can clean up. We destroy both the window and the renderer and also
    call the `SDL_Quit` function to close all the subsystems:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以进行清理。我们销毁窗口和渲染器，并调用 `SDL_Quit` 函数来关闭所有子系统：
- en: '[PRE21]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So we have moved the `Hello SDL 2.0` code from the `main.cpp` file into a class
    called `Game`. We have freed up the `main.cpp` file to handle only the `Game`
    class; it knows nothing about SDL or how the `Game` class is implemented. Let''s
    add one more thing to the class to allow us to close the application the regular
    way:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将 `Hello SDL 2.0` 代码从 `main.cpp` 文件移动到了一个名为 `Game` 的类中。我们使 `main.cpp` 文件空闲出来，只处理
    `Game` 类；它对 SDL 或 `Game` 类的实现一无所知。让我们给这个类添加一个功能，以便我们能够以常规方式关闭应用程序：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will cover event handling in more detail in a forthcoming chapter. What
    this function now does is check if there is an event to handle, and if so, check
    if it is an `SDL_QUIT` event (by clicking on the cross to close a window). If
    the event is `SDL_QUIT`, we set the `Game` class'' `m_bRunning` member variable
    to `false`. The act of setting this variable to `false` makes the main loop stop
    and the application move onto cleaning up and then exiting:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中更详细地介绍事件处理。现在这个函数所做的就是检查是否有事件需要处理，如果有，就检查它是否是 `SDL_QUIT` 事件（通过点击窗口上的叉号来关闭窗口）。如果事件是
    `SDL_QUIT`，我们将 `Game` 类的 `m_bRunning` 成员变量设置为 `false`。将此变量设置为 `false` 使得主循环停止，应用程序进入清理和退出阶段：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `clean()` function destroys the window and renderer and then calls the `SDL_Quit()`
    function, closing all the initialized SDL subsystems.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`clean()` 函数销毁窗口和渲染器，然后调用 `SDL_Quit()` 函数，关闭所有初始化的 SDL 子系统。'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To enable us to view our `std::cout` messages, we must first include `Windows.h`
    and then call `AllocConsole(); andfreopen("CON", "w", stdout);`. You can do this
    in the `main.cpp` file. Just remember to remove it when sharing your game.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够查看我们的 `std::cout` 消息，我们首先必须包含 `Windows.h`，然后调用 `AllocConsole();` 和 `freopen("CON",
    "w", stdout);`。你可以在 `main.cpp` 文件中这样做。只需记住在分享你的游戏时将其移除。
- en: Fullscreen SDL
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全屏 SDL
- en: '`SDL_CreateWindow` takes an enumeration value of type `SDL_WindowFlags`. These
    values set how the window will behave. We created an `init` function in our `Game`
    class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`SDL_CreateWindow` 函数接受一个类型为 `SDL_WindowFlags` 的枚举值。这些值决定了窗口的行为。我们在 `Game`
    类中创建了一个 `init` 函数：'
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The final parameter is an `SDL_WindowFlags` value, which is then passed into
    the `SDL_CreateWindow` function when initializing:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数是一个 `SDL_WindowFlags` 值，然后在初始化时传递给 `SDL_CreateWindow` 函数：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is a table of the `SDL_WindowFlags` function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `SDL_WindowFlags` 函数的表格：
- en: '| Flag | Purpose |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 目的 |'
- en: '| --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SDL_WINDOW_FULLSCREEN` | Make the window fullscreen |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_WINDOW_FULLSCREEN` | 使窗口全屏 |'
- en: '| `SDL_WINDOW_OPENGL` | Window can be used with as an OpenGL context |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_WINDOW_OPENGL` | 窗口可以作为 OpenGL 上下文使用 |'
- en: '| `SDL_WINDOW_SHOWN` | The window is visible |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_WINDOW_SHOWN` | 窗口是可见的 |'
- en: '| `SDL_WINDOW_HIDDEN` | Hide the window |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_WINDOW_HIDDEN` | 隐藏窗口 |'
- en: '| `SDL_WINDOW_BORDERLESS` | No border on the window |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_WINDOW_BORDERLESS` | 窗口无边框 |'
- en: '| `SDL_WINDOW_RESIZABLE` | Enable resizing of the window |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_WINDOW_RESIZABLE` | 允许调整窗口大小 |'
- en: '| `SDL_WINDOW_MINIMIZED` | Minimize the window |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_WINDOW_MINIMIZED` | 最小化窗口 |'
- en: '| `SDL_WINDOW_MAXIMIZED` | Maximize the window |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_WINDOW_MAXIMIZED` | 最大化窗口 |'
- en: '| `SDL_WINDOW_INPUT_GRABBED` | Window has grabbed input focus |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_WINDOW_INPUT_GRABBED` | 窗口已捕获输入焦点 |'
- en: '| `SDL_WINDOW_INPUT_FOCUS` | Window has input focus |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_WINDOW_INPUT_FOCUS` | 窗口拥有输入焦点 |'
- en: '| `SDL_WINDOW_MOUSE_FOCUS` | Window has mouse focus |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_WINDOW_MOUSE_FOCUS` | 窗口拥有鼠标焦点 |'
- en: '| `SDL_WINDOW_FOREIGN` | The window was not created using SDL |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_WINDOW_FOREIGN` | 窗口不是使用 SDL 创建的 |'
- en: 'Let''s pass in `SDL_WINDOW_FULLSCREEN` to the `init` function and test out
    some fullscreen SDL. Open up the `main.cpp` file and add this flag:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `SDL_WINDOW_FULLSCREEN` 传递给 `init` 函数，并测试一下全屏的 SDL。打开 `main.cpp` 文件并添加此标志：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Build the application again and you should see that the window is fullscreen.
    To exit the application, it will have to be forced to quit (*Alt* + *F4* on Windows);
    we will be able to use the keyboard to quit the application in forthcoming chapters,
    but for now, we won't need fullscreen. One problem we have here is that we have
    now added something SDL specific to the `main.cpp` file. While we will not use
    any other frameworks in this book, in future we may want to use another. We can
    remove this SDL-specific flag and replace it with a Boolean value for whether
    we want fullscreen or not.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建应用程序，你应该会看到窗口已全屏。要退出应用程序，必须强制退出（Windows上的 *Alt* + *F4*）；我们将在后续章节中能够使用键盘退出应用程序，但现在我们不需要全屏。我们在这里遇到的一个问题是，我们已经将一些
    SDL 特定的内容添加到了 `main.cpp` 文件中。虽然我们在这本书中不会使用任何其他框架，但在将来我们可能想使用另一个。我们可以移除这个 SDL 特定的标志，并用一个布尔值替换，以表示我们是否想要全屏。
- en: 'Replace the `int flags` parameter in our `Game init` function with a `boolfullscreen`
    parameter:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们 `Game init` 函数中的 `int flags` 参数替换为 `boolfullscreen` 参数：
- en: 'The code snippet for `Game.h`:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game.h` 的代码片段：'
- en: '[PRE27]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The code snippet for `Game.cpp`:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game.cpp` 的代码片段：'
- en: '[PRE28]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We create an `int` flags variable to pass into the `SDL_CreateWindow` function;
    if we have set `fullscreen` to `true`, then this value will be set to the `SDL_WINDOW_FULLSCREEN`
    flag, otherwise it will remain as `0` to signify that no flags are being used.
    Let''s test this now in our `main.cpp` file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 `int` 类型的 `flags` 变量，将其传递给 `SDL_CreateWindow` 函数；如果我们已将 `fullscreen`
    设置为 `true`，则此值将被设置为 `SDL_WINDOW_FULLSCREEN` 标志，否则它将保持为 `0`，表示没有使用任何标志。现在让我们在我们的
    `main.cpp` 文件中测试一下：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will again set our window to fullscreen, but we aren't using the SDL-specific
    flag to do it. Set it to `false` again as we will not need fullscreen for a while.
    Feel free to try out a few of the other flags to see what effects they have.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将再次将我们的窗口设置为全屏，但我们不会使用 SDL 特定的标志来完成它。再次将其设置为 `false`，因为我们暂时不需要全屏。您可以自由尝试其他标志，看看它们会产生什么效果。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A lot of ground has been covered in this chapter. We learned what SDL is and
    why it is a great tool for game development. We looked at the overall structure
    of a game and how it can be broken into individual parts, and we started to develop
    the skeleton of our framework by creating a `Game` class that can be used to initialize
    SDL and render things to the screen. We also had a small look at how SDL handles
    events by listening for a `quit` event to close our application. In the next chapter
    we will look at drawing in SDL and building the `SDL_image` extension.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。我们学习了 SDL 是什么以及为什么它是游戏开发的伟大工具。我们探讨了游戏的整体结构以及如何将其分解成单独的部分，并通过创建一个可以用来初始化
    SDL 并将内容渲染到屏幕上的 `Game` 类来开始构建我们框架的骨架。我们还简要地了解了 SDL 通过监听 `quit` 事件来处理事件的方式，以关闭我们的应用程序。在下一章中，我们将探讨在
    SDL 中绘图以及构建 `SDL_image` 扩展。
