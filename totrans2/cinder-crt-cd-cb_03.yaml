- en: Chapter 3. Using Image Processing Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming image contrast and brightness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with OpenCV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting edges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting faces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting features in image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting images to vector graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will show examples of using image processing techniques
    implemented in Cinder and using third-party libraries. In most of the examples,
    we will use the following famous test image widely used to illustrate computer
    vision algorithms and techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/8703OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can download Lenna's image from Wikipedia ([http://en.wikipedia.org/wiki/File:Lenna.png](http://en.wikipedia.org/wiki/File:Lenna.png)).
  prefs: []
  type: TYPE_NORMAL
- en: Transforming image contrast and brightness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will cover basic image color transformations using the `Surface`
    class for pixel manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To change the values of contrast and brightness we will use `InterfaceGl` covered
    in [Chapter 2](ch02.html "Chapter 2. Preparing for Development"), *Preparing for
    Development in the Setting up GUI for parameters tweaking* recipe. We will need
    a sample image to proceed with; save it in your `assets` folder as `image.png`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an application with simple GUI for contrast and brightness manipulation
    on the sample image. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include necessary headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add properties to the main class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `setup` method an image is loaded for processing and the `Surface` object
    is prepared to store processed image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set window size to default values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add parameter controls to the `InterfaceGl` window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `update` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we will draw the original and processed images by adding the following
    lines of code inside the `draw` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important part is inside the `update` method. In step 6 we checked
    if the parameters for contrast and brightness had been changed. If they have,
    we iterate through all the pixels of the original image and store recalculated
    color values in `mImageOutput`. While modifying the brightness is just increasing
    or decreasing each color component, calculating contrast is a little more complicated.
    For each color component we are using the multiplying formula, *color = (color
    - 0.5) * contrast + 0.5*, where contrast is a number between 0.5 and 2\. In the
    GUI we are setting a value between -0.5 and 1.0, which is more natural range;
    it is then recalculated at the beginning of step 6\. While processing the image
    we have to change color value of all pixels, so later in step 6, you can see that
    we iterate through later columns of each row of the pixels using two `while` loops.
    To move to the next row we invoked the `line` method on the `Surface` iterator
    and then the `pixel` method to move to the next pixel of the current row. This
    method is much faster than using, for example, the `getPixel` and `setPixel` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8703OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our application is rendering the original image on the left-hand side and the
    processed image on the right-hand side, so you can compare the results of color
    adjustment.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenCV is a very powerful open-source library for computer vision. The library
    is written in C++ so it can be easily integrated in your Cinder application. There
    is a very useful OpenCV Cinder block provided within Cinder package available
    at the GitHub repository ([https://github.com/cinder/Cinder-OpenCV](https://github.com/cinder/Cinder-OpenCV)).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have Xcode up and running with a Cinder project opened.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will add OpenCV Cinder block to your project, which also illustrates the
    usual way of adding any other Cinder block to your project. Perform the following
    steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new group to our Xcode project root and name it `Blocks.` Next, drag the
    `opencv` folder inside the `Blocks` group. Be sure to select the **Create groups
    for any added folders** radio button, as shown in the following screenshot:![How
    to do it…](img/8703OS_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will need only the `include` folder inside the `opencv` folder in your project
    structure, so delete any reference to others. The final project structure should
    look like the following screenshot:![How to do it…](img/8703OS_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the paths to the OpenCV library files in the **Other Linker Flags** section
    of your project''s build settings, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These paths are shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/8703OS_03_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Add the paths to the OpenCV Cinder block headers you are going to use in the
    **User Header Search Paths** section of your project''s build settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This path is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/8703OS_03_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Include OpenCV Cinder block header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OpenCV Cinder block provides the `toOcv` and `fromOcv` functions for data exchange
    between Cinder and OpenCV. After setting up your project you can use them, as
    shown in the following short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `toOcv` and `fromOcv` functions to convert between Cinder and
    OpenCV types, storing image data such as `Surface` or `Channel` handled through
    the `ImageSourceRef` type; there are also other types, as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Cinder types | OpenCV types |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ImageSourceRef` | `Mat` |'
  prefs: []
  type: TYPE_TB
- en: '| `Color` | `Scalar` |'
  prefs: []
  type: TYPE_TB
- en: '| `Vec2f` | `Point2f` |'
  prefs: []
  type: TYPE_TB
- en: '| `Vec2i` | `Point` |'
  prefs: []
  type: TYPE_TB
- en: '| `Area` | `Rect` |'
  prefs: []
  type: TYPE_TB
- en: 'In this example we are linking against the following three files from the OpenCV
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`libopencv_imgproc.a`: This image processing module includes image manipulation
    functions, filters, feature detection, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libopencv_core.a`: This module provides core functionality and data structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libopencv_objdetect.a`: This module has object detection tools such as cascade
    classifiers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the documentation on all OpenCV modules at [http://docs.opencv.org/index.html](http://docs.opencv.org/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some features that are not available in precompiled OpenCV libraries
    packaged in OpenCV Cinder block, but you can always compile your own OpenCV libraries
    and still use exchange functions from OpenCV Cinder block in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting edges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will demonstrate how to use edge detection function, which
    is one of the image processing functions implemented directly in Cinder.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have Xcode up and running with an empty Cinder project opened.
    We will need a sample image to proceed, so save it in your assets folder as `image.png`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will process the sample image with the edge detection function. Perform
    the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include necessary headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add two properties to your main class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the source image and set up `Surface` for processed images inside the
    `setup` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use image processing functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `draw` method add the following two lines of code for drawing images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, detecting edges in Cinder is pretty easy because of implementation
    of basic image processing functions directly in Cinder, so you don't have to include
    any third-party libraries. In this case we are using the `grayscale` function
    to convert the original image color space to grayscale. It is a commonly used
    feature in image processing because many algorithms work more efficiently on grayscale
    images or are even designed to work only with grayscale source images. The edge
    detection is implemented with the `edgeDetectSobel` function and uses the Sobel
    algorithm. In this case, the first parameter is the source original grayscale
    image and the second parameter, is the output `Surface` object in which the result
    will be stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `draw` method we are drawing both images, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may find the image processing functions implemented in Cinder insufficient,
    so you can also include to your project, third-party library such as OpenCV. We
    explained how we can use Cinder and OpenCV together in the preceding recipe, *Integrating
    with OpenCV*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other useful functions in the context of edge detection are `Canny` and `findContours`.
    The following is the example of how we can use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After executing the preceding code, the points, which form the contours are
    stored in the `contours` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting faces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will examine how our application can be used to recognize
    human faces. Thanks to the OpenCV library, it is really easy.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the OpenCV library, so please refer to the *Integrating with
    OpenCV* recipe for information on how to set up your project. We will need a sample
    image to proceed, so save it in your `assets` folder as `image.png`. Put the Haar
    cascade classifier file for frontal face recognition inside the `assets` directory.
    The cascade file can be found inside the downloaded OpenCV package or in the online
    public repository, located at [https://github.com/Itseez/opencv/blob/master/data/haarcascades/haarcascade_frontalface_alt.xml](https://github.com/Itseez/opencv/blob/master/data/haarcascades/haarcascade_frontalface_alt.xml).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an application that demonstrates the usage of cascade classifier
    from OpenCV with Cinder. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include necessary headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following members to your main class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet to the `setup` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also add the following code snippet at the end of the `setup` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `draw` method add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 3 we loaded an image file for processing and an XML classifier file,
    which has description of the object features to be recognized. In step 4 we performed
    an image detection by invoking the `detectMultiScale` function on the `mFaceCC`
    object, where we pointed to `cvImage` as an input and stored the result in a vector
    structure, `cvImage` is converted from `mImage` as an 8-bit, single channel image
    (`CV_8UC1`). What we did next was iterating through all the detected faces and
    storing `Rectf` variable, which describes a bounding box around the detected face.
    Finally, in step 5 we drew our original image and all the recognized faces as
    stroked rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: We are using cascade classifier implemented in OpenCV, which can be trained
    to detect a specific object in the image. More on training and using cascade classifier
    for object detection can be found in the OpenCV documentation, located at [http://docs.opencv.org/modules/objdetect/doc/cascade_classification.html](http://docs.opencv.org/modules/objdetect/doc/cascade_classification.html).
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use a video stream from your camera and process each frame to track
    faces of people in real time. Please refer to the *Capturing from the camera*
    recipe in [Chapter 11](ch11.html "Chapter 11. Sensing and Tracking Input from
    the Camera"), *Sensing and Tracking Input from the Camera*.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting features in an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will use one of the methods of finding characteristic features
    in the image. We will use the SURF algorithm implemented by the OpenCV library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the OpenCV library, so please refer to the *Integrating with
    OpenCV* recipe for information on how to set up your project. We will need a sample
    image to proceed, so save it in your `assets` folder as `image.png`, then save
    a copy of the sample image as `image2.png` and perform some transformation on
    it, for example rotation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an application that visualizes matched features between two
    images. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the paths to the OpenCV library files in the **Other Linker Flags** section
    of your project''s build settings, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include necessary headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your main class declaration add the method and properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `setup` method load the images and invoke the matching method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you have to implement previously declared `matchImages` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing is to visualize the matches, so put the following line of code
    inside the `draw` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s discuss the code under step 5\. First we are converting `image1` and
    `image2` to an OpenCV Mat structure. Then we are converting both images to grayscale.
    Now we can start processing images with SURF, so we are detecting keypoints –
    the characteristic points of the image calculated by this algorithm. We can use
    calculated keypoints from these two images and match them using FLANN, or more
    precisely the `FlannBasedMatcher` class. After filtering out the proper matches
    and storing them in the `good_matches` vector we can visualize them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Please notice that second image is rotated, however the algorithm can still
    find and link the corresponding keypoints.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Detecting characteristic features in the images is crucial for matching pictures
    and is part of more advanced algorithms used in augmented reality applications.
  prefs: []
  type: TYPE_NORMAL
- en: If images match
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to determine if one of the images is a copy of another or is
    it rotated. You can use a number of matches returned by the `matchImages` method.
  prefs: []
  type: TYPE_NORMAL
- en: Other possibilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SURF is rather a slow algorithm for real-time matching so you can try the FAST
    algorithm for your project if you need to process frames from the camera at real
    time. The FAST algorithm is also included in the OpenCV library.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The comparison of the OpenCV's feature detection algorithms can be found at
    [http://computer-vision-talks.com/2011/01/comparison-of-the-opencvs-feature-detection-algorithms-2/](http://computer-vision-talks.com/2011/01/comparison-of-the-opencvs-feature-detection-algorithms-2/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting images to vector graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will try to convert simple, hand-drawn sketches to vector
    graphics using image processing functions from the OpenCV library and Cairo library
    for vector drawing and exporting.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the OpenCV library, so please refer to the *Integrating with
    OpenCV* recipe earlier in this chapter for information on how to set up your project.
    You may want to prepare your own drawing to be processed. In this example we are
    using a photo of some simple geometric shapes sketched on paper.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](img/8703OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an application to illustrate the conversion to vector shapes.
    Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include necessary headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following declarations to your main class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load your drawing and set default values inside the `setup` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `setup` method add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add implementation for the `renderDrawing` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement your `draw` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `keyDown` method insert the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key part is implemented in step 4 where we are detecting edges in the image
    and then finding contours. We are drawing vector representation of processed shapes
    in step 5, inside the `renderDrawing` method. For drawing vector graphics we are
    using the Cairo library, which is also able to save results into a file in several
    vector formats. As you can see in the following screenshot, there is an original
    image in the upper-left corner and just under it is the preview of the detected
    contours. The vector version of our simple hand-drawn image is on the right-hand
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each shape is a filled path with black color. Paths consist of points calculated
    in step 4\. The following is the visualization with highlighted points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can save a vector graphic as a file by pressing the *S* key. The file will
    be saved in the same folder as application executable under the name `output.svg`.
    SVG is only one of the following available exporting options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SurfaceSvg` | Preparing context for SVG file rendering |'
  prefs: []
  type: TYPE_TB
- en: '| `SurfacePdf` | Preparing context for PDF file rendering |'
  prefs: []
  type: TYPE_TB
- en: '| `SurfacePs` | Preparing context for PostScript file rendering |'
  prefs: []
  type: TYPE_TB
- en: '| `SurfaceEps` | Preparing context for Illustrator EPS file rendering |'
  prefs: []
  type: TYPE_TB
- en: 'The exported graphics look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8703OS_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Cairo**: [http://cairographics.org/](http://cairographics.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
