["```cpp\n    $ cat eh.cpp\n    class Ex1 {};\n    void throw_exception(int a, int b) {\n     Ex1 ex1;\n     if (a > b) {\n     throw ex1;\n     }\n    }\n\n    int test_try_catch() {\n     try {\n     throw_exception(2, 1);\n     }\n     catch(...) {\n     return 1;\n     }\n     return 0;\n    }\n\n    ```", "```cpp\n    $ clang -c eh.cpp -emit-llvm -o eh.bc\n\n    ```", "```cpp\n    $ llvm-dis eh.bc -o -\n    ; ModuleID = 'eh.bc'\n    target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n    target triple = \"x86_64-unknown-linux-gnu\"\n\n    %class.Ex1 = type { i8 }\n\n    @_ZTVN10__cxxabiv117__class_type_infoE = external global i8*\n    @_ZTS3Ex1 = linkonce_odr constant [5 x i8] c\"3Ex1\\00\"\n    @_ZTI3Ex1 = linkonce_odr constant { i8*, i8* } { i8* bitcast (i8** getelementptr inbounds (i8** @_ZTVN10__cxxabiv117__class_type_infoE, i64 2) to i8*), i8* getelementptr inbounds ([5 x i8]* @_ZTS3Ex1, i32 0, i32 0) }\n\n    ; Function Attrs: uwtable\n    define void @_Z15throw_exceptionii(i32 %a, i32 %b) #0 {\n     %1 = alloca i32, align 4\n     %2 = alloca i32, align 4\n     %ex1 = alloca %class.Ex1, align 1\n     store i32 %a, i32* %1, align 4\n     store i32 %b, i32* %2, align 4\n     %3 = load i32* %1, align 4\n     %4 = load i32* %2, align 4\n     %5 = icmp sgt i32 %3, %4\n     br i1 %5, label %6, label %9\n\n    ; <label>:6                                       ; preds = %0\n     %7 = call i8* @__cxa_allocate_exception(i64 1) #1\n     %8 = bitcast i8* %7 to %class.Ex1*\n     call void @__cxa_throw(i8* %7, i8* bitcast ({ i8*, i8* }* @_ZTI3Ex1 to i8*), i8* null) #2\n     unreachable\n\n    ; <label>:9                                       ; preds = %0\n     ret void\n    }\n\n    declare i8* @__cxa_allocate_exception(i64)\n\n    declare void @__cxa_throw(i8*, i8*, i8*)\n\n    ; Function Attrs: uwtable\n    define i32 @_Z14test_try_catchv() #0 {\n     %1 = alloca i32, align 4\n     %2 = alloca i8*\n     %3 = alloca i32\n     %4 = alloca i32\n     invoke void @_Z15throw_exceptionii(i32 2, i32 1)\n     to label %5 unwind label %6\n\n    ; <label>:5                                       ; preds = %0\n     br label %13\n\n    ; <label>:6                                       ; preds = %0\n     %7 = landingpad { i8*, i32 } personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*)\n     catch i8* null\n     %8 = extractvalue { i8*, i32 } %7, 0\n     store i8* %8, i8** %2\n     %9 = extractvalue { i8*, i32 } %7, 1\n     store i32 %9, i32* %3\n     br label %10\n\n    ; <label>:10                                      ; preds = %6\n     %11 = load i8** %2\n     %12 = call i8* @__cxa_begin_catch(i8* %11) #1\n     store i32 1, i32* %1\n     store i32 1, i32* %4\n     call void @__cxa_end_catch()\n     br label %14\n\n    ; <label>:13                                      ; preds = %5\n     store i32 0, i32* %1\n     br label %14\n\n    ; <label>:14                                      ; preds = %13, %10\n     %15 = load i32* %1\n     ret i32 %15\n    }\n\n    declare i32 @__gxx_personality_v0(...)\n\n    declare i8* @__cxa_begin_catch(i8*)\n\n    declare void @__cxa_end_catch()\n\n    attributes #0 = { uwtable \"less-precise-fpmad\"=\"false\" \"no-frame-pointer-elim\"=\"true\" \"no-frame-pointer-elim-non-leaf\" \"no-infs-fp-math\"=\"false\" \"no-nans-fp-math\"=\"false\" \"stack-protector-buffer-size\"=\"8\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" }\n    attributes #1 = { nounwind }\n    attributes #2 = { noreturn }\n\n    !llvm.ident = !{!0}\n\n    !0 = metadata !{metadata !\"clang version 3.6.0 (220636)\"}\n\n    ```", "```cpp\ninvoke void @_Z15throw_exceptionii(i32 2, i32 1)\n          to label %5 unwind label %6\n```", "```cpp\n%7 = landingpad { i8*, i32 } personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*)\n     catch i8* null\n```", "```cpp\ncd llvm/projects\nsvn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt\n```", "```cpp\n    $ cat asan.c\n    int main() {\n    int a[5];\n    int index = 6;\n    int retval = a[index];\n    return retval;\n    }\n\n    ```", "```cpp\n    $ clang -fsanitize=address asan.c\n\n    ```", "```cpp\n    $ ASAN_SYMBOLIZER_PATH=/usr/local/bin/llvm-symbolizer ./a.out\n\n    ```", "```cpp\n*address = ...;\n```", "```cpp\nif (IsPoisoned(address)) {\n  ReportError(address, kAccessSize, kIsWrite);\n}\n*address = ...;\n```", "```cpp\n    $ cat testgc.ll\n\n    declare i8* @llvm_gc_allocate(i32)\n    declare void @llvm_gc_initialize(i32)\n\n    declare void @llvm.gcroot(i8**, i8*)\n    declare void @llvm.gcwrite(i8*, i8*, i8**)\n\n    define i32 @main() gc \"shadow-stack\" {\n    entry:\n     %A = alloca i8*\n     %B = alloca i8**\n\n     call void @llvm_gc_initialize(i32 1048576)  ; Start with 1MB heap\n\n     ;; void *A;\n     call void @llvm.gcroot(i8** %A, i8* null)\n\n     ;; A = gcalloc(10);\n     %Aptr = call i8* @llvm_gc_allocate(i32 10)\n     store i8* %Aptr, i8** %A\n\n     ;; void **B;\n     %tmp.1 = bitcast i8*** %B to i8**\n     call void @llvm.gcroot(i8** %tmp.1, i8* null)\n\n     ;; B = gcalloc(4);\n     %B.upgrd.1 = call i8* @llvm_gc_allocate(i32 8)\n     %tmp.2 = bitcast i8* %B.upgrd.1 to i8**\n     store i8** %tmp.2, i8*** %B\n\n     ;; *B = A;\n     %B.1 = load i8**, i8*** %B\n     %A.1 = load i8*, i8** %A\n     call void @llvm.gcwrite(i8* %A.1, i8* %B.upgrd.1, i8** %B.1)\n\n     br label %AllocLoop\n\n    AllocLoop:\n     %i = phi i32 [ 0, %entry ], [ %indvar.next, %AllocLoop ]\n     ;; Allocated mem: allocated memory is immediately dead.\n     call i8* @llvm_gc_allocate(i32 100)\n\n     %indvar.next = add i32 %i, 1\n     %exitcond = icmp eq i32 %indvar.next, 10000000\n     br i1 %exitcond, label %Exit, label %AllocLoop\n\n    Exit:\n     ret i32 0\n    }\n\n    declare void @__main()\n\n    ```", "```cpp\n    $ llc testgc.ll\n\n    $ cat testgc.s\n     .text\n     .file  \"testgc.ll\"\n     .globl  main\n     .align  16, 0x90\n     .type  main,@function\n    main:                                   # @main\n    .Lfunc_begin0:\n     .cfi_startproc\n     .cfi_personality 3, __gcc_personality_v0\n     .cfi_lsda 3, .Lexception0\n    # BB#0:                                 # %entry\n     pushq  %rbx\n    .Ltmp9:\n     .cfi_def_cfa_offset 16\n     subq  $32, %rsp\n    .Ltmp10:\n     .cfi_def_cfa_offset 48\n    .Ltmp11:\n     .cfi_offset %rbx, -16\n     movq  llvm_gc_root_chain(%rip), %rax\n     movq  $__gc_main, 8(%rsp)\n     movq  $0, 16(%rsp)\n     movq  %rax, (%rsp)\n     leaq  (%rsp), %rax\n     movq  %rax, llvm_gc_root_chain(%rip)\n     movq  $0, 24(%rsp)\n    .Ltmp0:\n     movl  $1048576, %edi          # imm = 0x100000\n     callq  llvm_gc_initialize\n    .Ltmp1:\n    # BB#1:                                 # %entry.cont3\n    .Ltmp2:\n     movl  $10, %edi\n     callq  llvm_gc_allocate\n    .Ltmp3:\n    # BB#2:                                 # %entry.cont2\n     movq  %rax, 16(%rsp)\n    .Ltmp4:\n     movl  $8, %edi\n     callq  llvm_gc_allocate\n    .Ltmp5:\n    # BB#3:                                 # %entry.cont\n     movq  %rax, 24(%rsp)\n     movq  16(%rsp), %rcx\n     movq  %rcx, (%rax)\n     movl  $10000000, %ebx         # imm = 0x989680\n     .align  16, 0x90\n    .LBB0_4:                                # %AllocLoop\n     # =>This Inner Loop Header: Depth=1\n    .Ltmp6:\n     movl  $100, %edi\n     callq  llvm_gc_allocate\n    .Ltmp7:\n    # BB#5:                                 # %AllocLoop.cont\n     #   in Loop: Header=BB0_4 Depth=1\n     decl  %ebx\n     jne  .LBB0_4\n    # BB#6:                                 # %Exit\n     movq  (%rsp), %rax\n     movq  %rax, llvm_gc_root_chain(%rip)\n     xorl  %eax, %eax\n     addq  $32, %rsp\n     popq  %rbx\n     retq\n    .LBB0_7:                                # %gc_cleanup\n    .Ltmp8:\n     movq  (%rsp), %rcx\n     movq  %rcx, llvm_gc_root_chain(%rip)\n     movq  %rax, %rdi\n     callq  _Unwind_Resume\n    .Lfunc_end0:\n     .size  main, .Lfunc_end0-main\n     .cfi_endproc\n     .section  .gcc_except_table,\"a\",@progbits\n     .align  4\n    GCC_except_table0:\n    .Lexception0:\n     .byte  255                     # @LPStart Encoding = omit\n     .byte  3                       # @TType Encoding = udata4\n     .asciz  \"\\234\"                  # @TType base offset\n     .byte  3                       # Call site Encoding = udata4\n     .byte  26                      # Call site table length\n     .long  .Ltmp0-.Lfunc_begin0    # >> Call Site 1 <<\n     .long  .Ltmp7-.Ltmp0           #   Call between .Ltmp0 and .Ltmp7\n     .long  .Ltmp8-.Lfunc_begin0    #     jumps to .Ltmp8\n     .byte  0                       #   On action: cleanup\n     .long  .Ltmp7-.Lfunc_begin0    # >> Call Site 2 <<\n     .long  .Lfunc_end0-.Ltmp7      #   Call between .Ltmp7 and .Lfunc_end0\n     .long  0                       #     has no landing pad\n     .byte  0                       #   On action: cleanup\n     .align  4\n\n     .type  llvm_gc_root_chain,@object # @llvm_gc_root_chain\n     .bss\n     .weak  llvm_gc_root_chain\n     .align  8\n    llvm_gc_root_chain:\n     .quad  0\n     .size  llvm_gc_root_chain, 8\n\n     .type  __gc_main,@object       # @__gc_main\n     .section  .rodata,\"a\",@progbits\n     .align  8\n    __gc_main:\n     .long  2                       # 0x2\n     .long  0                       # 0x0\n     .size  __gc_main, 8\n\n     .section  \".note.GNU-stack\",\"\",@progbits\n\n    ```", "```cpp\ndefine i32 @main() gc \"shadow-stack\"\n```", "```cpp\ncall void @llvm.gcroot(i8** %tmp.1, i8* null)\n```", "```cpp\ncall void @llvm.gcwrite(i8* %A.1, i8* %B.upgrd.1, i8** %B.1)\n```", "```cpp\n    ./emsdk update\n    ./emsdk install latest\n    ./emsdk activate latest\n\n    ```", "```cpp\n    $ cat test.c\n    #include<stdio.h>\n\n    int main() {\n     printf(\"hi, user!\\n\");\n     return 0;\n    }\n\n    ```", "```cpp\n    $ clang –S –emit-llvm test.c\n\n    ```", "```cpp\n    $ ./emcc test.ll\n\n    ```", "```cpp\n    $ nodejs a.out.js\n    hi, user!\n\n    ```", "```cpp\n    $ cat sa.c\n    int func() {\n    int a = 0;\n    int b = 1/a;\n    return b;\n    }\n\n    ```", "```cpp\n    $ clang -cc1 -analyze -analyzer-checker=core.DivideZero sa.c\n    sa.c:3:10: warning: Division by zero\n    int b = 1/a;\n     ~^~\n    1 warning generated.\n\n    ```", "```cpp\n    $ cat crash-narrowfunctiontest.ll\n    define i32 @foo() { ret i32 1 }\n\n    define i32 @test() {\n     call i32 @test()\n     ret i32 %1\n    }\n    define i32 @bar() { ret i32 2 }\n\n    ```", "```cpp\n    $ bugpoint -load  path-to-llvm/build/./lib/BugpointPasses.so crash-narrowfunctiontest.ll -output-prefix crash-narrowfunctiontest.ll.tmp -bugpoint-cras\n    hcalls -silence-passes\n    Read input file      : 'crash-narrowfunctiontest.ll'\n    *** All input ok\n    Running selected passes on program to test for crash: Crashed: Aborted (core dumped)\n    Dumped core\n\n    *** Debugging optimizer crash!\n    Checking to see if these passes crash: -bugpoint-crashcalls: Crashed: Aborted (core dumped)\n    Dumped core\n\n    *** Found crashing pass: -bugpoint-crashcalls\n    Emitted bitcode to 'crash-narrowfunctiontest.ll.tmp-passes.bc'\n\n    *** You can reproduce the problem with: opt crash-narrowfunctiontest.ll.tmp-passes.bc -load /home/mayur/LLVMSVN_REV/llvm/llvm/rbuild/./lib/BugpointPasses.so -bugpoint-crashcalls\n\n    *** Attempting to reduce the number of functions in the testcase\n    Checking for crash with only these functions:  foo test bar: Crashed: Aborted (core dumped)\n    Dumped core\n    Checking for crash with only these functions:  foo test: Crashed: Aborted (core dumped)\n    Dumped core\n    Checking for crash with only these functions:  test: Crashed: Aborted (core dumped)\n    Dumped core\n    Emitted bitcode to 'crash-narrowfunctiontest.ll.tmp-reduced-function.bc'\n\n    *** You can reproduce the problem with: opt crash-narrowfunctiontest.ll.tmp-reduced-function.bc -load /home/mayur/LLVMSVN_REV/llvm/llvm/rbuild/./lib/BugpointPasses.so -bugpoint-crashcalls\n    Checking for crash with only these blocks: : Crashed: Aborted (core dumped)\n    Dumped core\n    Emitted bitcode to 'crash-narrowfunctiontest.ll.tmp-reduced-blocks.bc'\n\n    *** You can reproduce the problem with: opt crash-narrowfunctiontest.ll.tmp-reduced-blocks.bc -load /home/mayur/LLVMSVN_REV/llvm/llvm/rbuild/./lib/BugpointPasses.so -bugpoint-crashcalls\n    Checking for crash with only 1 instruction: Crashed: Aborted (core dumped)\n    Dumped core\n\n    *** Attempting to reduce testcase by deleting instructions: Simplification Level #1\n    Checking instruction:   %1 = call i32 @test()Success!\n\n    *** Attempting to reduce testcase by deleting instructions: Simplification Level #0\n    Checking instruction:   %1 = call i32 @test()Success!\n\n    *** Attempting to perform final cleanups: Crashed: Aborted (core dumped)\n    Dumped core\n    Emitted bitcode to 'crash-narrowfunctiontest.ll.tmp-reduced-simplified.bc'\n\n    *** You can reproduce the problem with: opt crash-narrowfunctiontest.ll.tmp-reduced-simplified.bc -load /home/mayur/LLVMSVN_REV/llvm/llvm/rbuild/./lib/BugpointPasses.so -bugpoint-crashcalls\n\n    ```", "```cpp\n    $ llvm-dis crash-narrowfunctiontest.ll.tmp-reduced-simplified.bc\n    $ cat $ cat crash-narrowfunctiontest.ll.tmp-reduced-simplified.ll\n    define void @test() {\n     call void @test()\n     ret void\n    }\n\n    ```", "```cpp\n    svn co http://llvm.org/svn/llvm-project/lldb/trunk lldb\n\n    ```", "```cpp\n    $ cat lldbexample.c\n    #include<stdio.h>\n    int globalvar = 0;\n\n    int func2(int a, int b) {\n    globalvar++;\n    return a*b;\n    }\n\n    int func1(int a, int b) {\n    globalvar++;\n    int d = a + b;\n    int e = a - b;\n    int f = func2(d, e);\n    return f;\n    }\n\n    int main() {\n    globalvar++;\n    int a = 5;\n    int b = 3;\n\n    int c = func1(a,b);\n    printf(\"%d\", c);\n    return c;\n    }\n\n    ```", "```cpp\n    $ clang -g lldbexample.c\n\n    ```", "```cpp\n    $ lldb a.out\n    (lldb) target create \"a.out\"\n    Current executable set to 'a.out' (x86_64).\n\n    ```", "```cpp\n    (lldb) breakpoint set --name main\n    Breakpoint 1: where = a.out'main + 15 at lldbexample.c:20, address = 0x00000000004005bf\n\n    ```", "```cpp\n    (lldb) breakpoint list\n    Current breakpoints:\n    1: name = 'main', locations = 1\n     1.1: where = a.out'main + 15 at lldbexample.c:20, address = a.out[0x00000000004005bf], unresolved, hit count = 0\n\n    ```", "```cpp\n    (lldb) breakpoint command add 1.1\n    Enter your debugger command(s).  Type 'DONE' to end.\n    > bt \n    > DONE\n\n    ```", "```cpp\n    (lldb) process launch\n    Process 2999 launched: '/home/mayur/book/chap9/a.out' (x86_64)\n    Process 2999 stopped\n    * thread #1: tid = 2999, 0x00000000004005bf a.out'main + 15 at lldbexample.c:20, name = 'a.out', stop reason = breakpoint 1.1\n     frame #0: 0x00000000004005bf a.out'main + 15 at lldbexample.c:20\n     17\n     18\n     19    int main() {\n    -> 20    globalvar++;\n     21    int a = 5;\n     22    int b = 3;\n     23\n    (lldb)  bt\n    * thread #1: tid = 2999, 0x00000000004005bf a.out'main + 15 at lldbexample.c:20, name = 'a.out', stop reason = breakpoint 1.1\n     * frame #0: 0x00000000004005bf a.out'main + 15 at lldbexample.c:20\n     frame #1: 0x00007ffff7a35ec5 libc.so.6'__libc_start_main(main=0x00000000004005b0, argc=1, argv=0x00007fffffffda18, init=<unavailable>, fini=<unavailable>, rtld_fini=<unavailable>, stack_end=0x00007fffffffda08) + 245 at libc-start.c:287\n     frame #2: 0x0000000000400469 a.out\n\n    ```", "```cpp\n    (lldb) watch set var globalvar\n    Watchpoint created: Watchpoint 1: addr = 0x00601044 size = 4 state = enabled type = w\n     declare @ '/home/mayur/book/chap9/lldbexample.c:2'\n     watchpoint spec = 'globalvar'\n     new value: 0\n\n    ```", "```cpp\n    (lldb) watch modify -c '(globalvar==3)'\n    To view list of all watch points:\n    (lldb) watch list\n    Number of supported hardware watchpoints: 4\n    Current watchpoints:\n    Watchpoint 1: addr = 0x00601044 size = 4 state = enabled type = w\n     declare @ '/home/mayur/book/chap9/lldbexample.c:2'\n     watchpoint spec = 'globalvar'\n     new value: 0\n     condition = '(globalvar==3)'\n\n    ```", "```cpp\n    (lldb) thread step-over\n    (lldb) Process 2999 stopped\n    * thread #1: tid = 2999, 0x000000000040054b a.out'func2(a=8, b=2) + 27 at lldbexample.c:6, name = 'a.out', stop reason = watchpoint 1\n     frame #0: 0x000000000040054b a.out'func2(a=8, b=2) + 27 at lldbexample.c:6\n     3\n     4     int func2(int a, int b) {\n     5     globalvar++;\n    -> 6     return a*b;\n     7     }\n     8\n     9\n\n    Watchpoint 1 hit:\n    old value: 0\n    new value: 3\n    (lldb) bt\n    * thread #1: tid = 2999, 0x000000000040054b a.out'func2(a=8, b=2) + 27 at lldbexample.c:6, name = 'a.out', stop reason = watchpoint 1\n     * frame #0: 0x000000000040054b a.out'func2(a=8, b=2) + 27 at lldbexample.c:6\n     frame #1: 0x000000000040059c a.out'func1(a=5, b=3) + 60 at lldbexample.c:14\n     frame #2: 0x00000000004005e9 a.out'main + 57 at lldbexample.c:24\n     frame #3: 0x00007ffff7a35ec5 libc.so.6'__libc_start_main(main=0x00000000004005b0, argc=1, argv=0x00007fffffffda18, init=<unavailable>, fini=<unavailable>, rtld_fini=<unavailable>, stack_end=0x00007fffffffda08) + 245 at libc-start.c:287\n     frame #4: 0x0000000000400469 a.out\n\n    ```", "```cpp\n    (lldb) thread continue\n    Resuming thread 0x0bb7 in process 2999\n    Process 2999 resuming\n    Process 2999 exited with status = 16 (0x00000010)\n\n    ```", "```cpp\n    (lldb)  exit\n\n    ```", "```cpp\n    $ cat utility.ll\n    declare double @foo()\n\n    declare double @bar()\n\n    define double @baz(double %x) {\n    entry:\n     %ifcond = fcmp one double %x, 0.000000e+00\n     br i1 %ifcond, label %then, label %else\n\n    then:       ; preds = %entry\n     %calltmp = call double @foo()\n     br label %ifcont\n\n    else:       ; preds = %entry\n     %calltmp1 = call double @bar()\n     br label %ifcont\n\n    ifcont:     ; preds = %else, %then\n     %iftmp = phi double [ %calltmp, %then ], [ %calltmp1, %else ]\n     ret double %iftmp\n    }\n\n    ```", "```cpp\n    $ opt –view-cfg-only utility.ll\n\n    ```", "```cpp\n    $ opt –view-dom utility.ll\n\n    ```"]