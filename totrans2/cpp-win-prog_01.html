<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Introduction</h1></div></div></div><p>The purpose of this book is to learn how to develop applications in Windows. In order to do so, I have developed Small Windows, which is a C++ object-oriented class library for graphical applications in Windows.</p><p>The idea is to guide you into Windows programming by introducing increasingly more advanced applications written in C++ with Small Windows, thereby hiding the technical details of the <strong>Windows 32-bit Applications Programming Interface</strong> (<strong>Win32 API</strong>), which is the underlying library for Windows development. With this approach, we can focus on the business logic without struggling with the underlying technical details. If you are interested in knowing how the Win32 API works, the second part of this book gives a detailed description of how Small Windows is implemented.</p><p>This book is made up of two parts, where the first part describes the applications developed in C++ with Small Windows. While some books have many examples, this book only includes six examples, among which the last four are rather advanced: the Tetris game, a drawing program, a word processor, and a spreadsheet program. Note that this book is not only a tutorial about Windows programming, but also a tutorial about how to develop object-oriented graphical applications.</p><p>The second part holds a detailed description of the implementation of Small Windows in the Win32 API. Note that the Win32 API is not introduced until the second part. Some of you may be satisfied with the high level aspects of Small Windows and only want to study application-specific problems, while others may want to read the second part in order to understand how the classes, methods, and macros of Small Windows are implemented in the Win32 API.</p><p>Naturally, I am aware of the existence of modern object-oriented class libraries for Windows. However, the purpose of those libraries is to make it easier for the developer by hiding the details of the architecture, which also prevents the developer from using the Windows architecture to its full extent. Even though the Win32 API has been around for a while, I regard it as the best way to develop professional Windows applications and to understand the Windows architecture.</p><p>All source code is given in this book; it is also available as a Visual Studio solution.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec8"/>The library</h1></div></div></div><p>This section gives an introduction to Small Windows. The first part of a Small Windows application is the <code class="literal">MainWindow</code> function. It corresponds to <code class="literal">main</code> in regular C++. Its task is to set the name of the application and create the main window of the application.</p><p>In this book we talk about <strong>definitions</strong> and <strong>declarations</strong>. A declaration is just a notification for the compiler, while a definition is what defines the feature. Below is the declaration of the <code class="literal">MainWindow</code> function. Its definition is left to the user of Small Windows.</p><pre class="programlisting">void MainWindow(vector&lt;String&gt;argumentList,&#13;
                SmallWindows::WindowShow windowShow);</pre><p>Simply put, in Windows the application does not take any initiative; rather, it waits for messages and reacts when it receives them. Informally speaking, <em>you do not call Windows, Windows calls you</em>.</p><p>The most central part of Small Windows is the <code class="literal">Application</code> class. In Windows, each event generates a message that is sent to the window that has input focus at the moment. The <code class="literal">Application</code> class implements the <code class="literal">RunMessageLoop</code> method, which makes sure that each message is sent to the correct window. It also closes the application when a special quit message is sent.</p><p>The creation of a window takes place in two steps. In the first step, the <code class="literal">RegisterWindowClasses</code> method sets features such as style, color, and appearance. Note that Windows classes are not C++ classes:</p><pre class="programlisting">class Application { &#13;
  public: &#13;
    static int RunMessageLoop(); &#13;
    static void RegisterWindowClasses(HINSTANCE instanceHandle); &#13;
}; &#13;
</pre><p>The next step is to create an individual window, which is done by the <code class="literal">Window</code> class. All <code class="literal">virtual</code> methods are empty and are intended to be overridden by sub classes shown as follows:</p><pre class="programlisting">  class Window { &#13;
    public: &#13;
</pre><p>A window can be visible or invisible, enabled or disabled. When a window is enabled, it accepts mouse, touch, and keyboard input:</p><pre class="programlisting">      void ShowWindow(bool visible); &#13;
      void EnableWindow(bool enable); &#13;
</pre><p>The <code class="literal">OnMove</code> and the <code class="literal">OnSize</code> methods are called when the window is moved or resized. The <code class="literal">OnHelp</code> method is called when the user presses the <em>F1</em> key or the <strong>Help</strong> button in a message box:</p><pre class="programlisting">      virtual void OnMove(Point topLeft); &#13;
      virtual void OnSize(Size windowSize); &#13;
      virtual void OnHelp(); &#13;
</pre><p>The <strong>client area</strong> is the part of the window that it is possible to paint in. Informally, the client area is the window minus its frame. The contents of the client area can be zoomed. The default zoom factor is 1.0:</p><pre class="programlisting">      double GetZoom() const; &#13;
      void SetZoom(double zoom); &#13;
</pre><p>The <strong>timer</strong> can be set to an interval in milliseconds. The <code class="literal">OnTimer</code> method is called on every interval. It is possible to set up several timers, as long as they have different identity numbers:</p><pre class="programlisting">      void SetTimer(int timerId, unsigned int interval); &#13;
      void DropTimer(int timerId); &#13;
      virtual void OnTimer(int timerId); &#13;
</pre><p>The <code class="literal">OnMouseDown</code>, <code class="literal">OnMouseUp</code>, and <code class="literal">OnDoubleClick</code> methods are called when the user presses, releases, or double-clicks on a mouse button. The <code class="literal">OnMouseMove</code> method is called when the user moves the mouse with at least one button pressed. The <code class="literal">OnMouseWheel</code> method is called when the user moves the mouse wheel with one click:</p><pre class="programlisting">      virtual void OnMouseDown(MouseButton mouseButtons, &#13;
                           Point mousePoint, bool shiftPressed, &#13;
                           bool controlPressed); &#13;
&#13;
&#13;
      virtual void OnMouseUp(MouseButton mouseButtons, &#13;
                           Point mousePoint, bool shiftPressed, &#13;
                           bool controlPressed); &#13;
      virtual void OnDoubleClick(MouseButton mouseButtons, &#13;
                           Point mousePoint, bool shiftPressed, &#13;
                           bool controlPressed); &#13;
      virtual void OnMouseMove(MouseButton mouseButtons, &#13;
                           Point mousePoint, bool shiftPressed, &#13;
                           bool controlPressed); &#13;
      virtual void OnMouseWheel(WheelDirection direction, &#13;
                           bool shiftPressed, bool controlPressed); &#13;
</pre><p>The <code class="literal">OnTouchDown</code>, <code class="literal">OnTouchMove</code>, and <code class="literal">OnTouchDown</code> methods work in the same way as the mouse methods. However, as the user can touch several points at the same time, the methods takes lists of points rather than an individual point:</p><pre class="programlisting">    virtual void OnTouchDown(vector&lt;Point&gt; pointList); &#13;
    virtual void OnTouchMove(vector&lt;Point&gt; pointList); &#13;
    virtual void OnTouchUp(vector&lt;Point&gt; pointList); &#13;
</pre><p>The <code class="literal">OnKeyDown</code> and <code class="literal">OnKeyUp</code> methods are called when the user presses or releases a key. If the user presses a graphical key (a key with an ASCII value between 32 and 127, inclusive), the <code class="literal">OnChar</code> method is called in between:</p><pre class="programlisting">      virtual bool OnKeyDown(WORD key, bool shiftPressed, &#13;
                             bool controlPressed); &#13;
      virtual void OnChar(TCHAR tChar); &#13;
      virtual bool OnKeyUp(WORD key, bool shiftPressed, &#13;
                           bool controlPressed); &#13;
</pre><p>The <code class="literal">Invalidate</code> method marks a part of the client area (or the whole client area) to be repainted; the area becomes <strong>invalidated</strong>. The area is cleared before the painting if <code class="literal">clear</code> is <code class="literal">true</code>. The <code class="literal">UpdateWindow</code> method forces a repainting of the invalidated area. It causes the <code class="literal">OnPaint</code> method to be called eventually:</p><pre class="programlisting">      void Invalidate(Rect areaRect, bool clear = true) const; &#13;
      void Invalidate(bool clear = true) const; &#13;
      void UpdateWindow(); &#13;
</pre><p>The <code class="literal">OnPaint</code> method is called when some part of the client area needs to be repainted and the <code class="literal">OnPrint</code> method is called when it is sent to a printer. Their default behavior is to call the <code class="literal">OnDraw</code> method with <code class="literal">Paint</code> or <code class="literal">Print</code> as the value of the <code class="literal">drawMode</code> parameter:</p><pre class="programlisting">      virtual void OnPaint(Graphics&amp; graphics) const;&#13;
      virtual void OnPrint(Graphics&amp; graphics, int page, &#13;
                           int copy, int totalPages) const;&#13;
      virtual void OnDraw(Graphics&amp; graphics, DrawMode drawMode)&#13;
                          const;&#13;
</pre><p>The <code class="literal">OnClose</code> method closes the window if <code class="literal">TryClose</code> returns <code class="literal">true</code>. The <code class="literal">OnDestroy</code> method is called when the window is being closed:</p><pre class="programlisting">      virtual void OnClose(); &#13;
      virtual bool TryClose(); &#13;
      virtual void OnDestroy(); &#13;
</pre><p>The following methods inspect and modify the size and position of the window. Note that we cannot set the size of the client area; it can only be set indirectly by resizing the window:</p><pre class="programlisting">      Size GetWindowSize() const; &#13;
      void SetWindowSize(Size windowSize); &#13;
      Point GetWindowPosition() const; &#13;
      void SetWindowPosition(Point topLeft); &#13;
      Size GetClientSize() const; &#13;
</pre><p>In the word processor and spreadsheet programs in this book, we handle text and need to calculate the size of individual characters. The following methods calculate the width of a character with a given font. They also calculate the height, ascent, and average character width of a font:</p><pre class="programlisting">      int GetCharacterWidth(Font font, TCHAR tChar) const; &#13;
      int GetCharacterHeight(Font font) const; &#13;
      int GetCharacterAscent(Font font) const; &#13;
      int GetCharacterAverageWidth(Font font) const; &#13;
</pre><p>The ascent line separates the upper and lower part of a letter, shown as follows:</p><p>
</p><div><img src="img/B05475_01_01.jpg" alt="The library"/></div><p>
</p><p>Finally, the <code class="literal">MessageBox</code> method displays a simple message box in the window:</p><pre class="programlisting">      Answer MessageBox(String message,&#13;
                    String caption = TEXT("Error"),&#13;
                    ButtonGroup buttonGroup = Ok,&#13;
                    Icon icon = NoIcon, bool help = false) const;&#13;
};</pre><p>The <code class="literal">Window</code> class also uses the <code class="literal">Graphics</code> class responsible for drawing text and geometrical objects in the window. A reference to a <code class="literal">Graphics</code> object is sent to the <code class="literal">OnPaint</code>, <code class="literal">OnPrint</code>, and <code class="literal">OnDraw</code> methods in the <code class="literal">Window</code> class. It can be used to draw lines, rectangles, and ellipses and to write text:</p><pre class="programlisting">  class Graphics { &#13;
    public: &#13;
      void DrawLine(Point startPoint, Point endPoint, &#13;
                    Color penColor, PenStyle penStyle = Solid); &#13;
      void DrawRectangle(Rect rect, Color penColor, &#13;
                         PenStyle = Solid); &#13;
      void FillRectangle(Rect rect, Color penColor, &#13;
                       Color brushColor, PenStyle penStyle=Solid); &#13;
      void DrawEllipse(Rect rect, Color penColor, &#13;
                       PenStyle = Solid); &#13;
      void FillEllipse(Rect rect, Color penColor, &#13;
                       Color brushColor, PenStyle penStyle=Solid); &#13;
      void DrawText(Rect areaRect, String text, Font font, &#13;
                    Color textColor, Color backColor, &#13;
                    bool pointsToMeters = true); &#13;
  }; &#13;
</pre><p>The <code class="literal">Document</code> class extends the <code class="literal">Window</code> class with some functionality common to document-based applications. The scroll thumbs are automatically set to reflect the visible part of the document. The mouse wheel moves the vertical scroll bar one line-height for each click. The height of a line is set by the constructor. The code snippet for it is shown as follows:</p><pre class="programlisting">  class Document : public Window { &#13;
    public: &#13;
</pre><p>The <strong>dirty flag</strong> is <code class="literal">true</code> when the user has made a change in the document and it needs to be saved. In <code class="literal">Document</code>, the dirty flag is set manually, but in the following <code class="literal">StandardDocument</code> subclass it is handled by the framework:</p><pre class="programlisting">      bool IsDirty() const; &#13;
      void SetDirty(bool dirty); &#13;
</pre><p>The <strong>caret</strong> is the blinking marker that indicates to the user where they should input the next character. The keyboard can be set (with the Insert key) to insert or overwrite mode. The caret is often a thin vertical bar in insert mode and a block with the width of an average character in overwrite mode.</p><p>The caret can be set or cleared. For instance, in the word processor, the caret is visible when the user writes text and invisible when the user marks text. When the window gains focus, the caret becomes visible if it has earlier been set. When the window loses focus, the caret becomes invisible, regardless of whether it has earlier been set:</p><pre class="programlisting">      void SetCaret(Rect caretRect); &#13;
      void ClearCaret(); &#13;
      void OnGainFocus(); &#13;
      void OnLoseFocus(); &#13;
</pre><p>A document may hold a menu bar, which is set by the <code class="literal">SetMenuBar</code> method:</p><pre class="programlisting">      void SetMenuBar(Menu&amp; menuBar); &#13;
</pre><p>The <code class="literal">OnDropFiles</code> method is called when the user drops one or several files in the window. Their paths are stored in the path list:</p><pre class="programlisting">      virtual void OnDropFile(vector&lt;String&gt; pathList); &#13;
</pre><p>The keyboard mode of a document can be set to <strong>insert</strong> or <strong>overwrite</strong> as follows:</p><pre class="programlisting">      KeyboardMode GetKeyboardMode() const; &#13;
      void SetKeyboardMode(KeyboardMode mode); &#13;
</pre><p>The <code class="literal">OnHorizontalScroll</code> and <code class="literal">OnVerticalScroll</code> methods are called when the user scrolls the bar by clicking on the scroll bar arrows or the scroll bar fields, or dragging the scroll thumbs. The code snippet for it is shown as follows:</p><pre class="programlisting">      virtual void OnHorizontalScroll(WORD flags,WORD thumbPos=0); &#13;
      virtual void OnVerticalScroll(WORD flags, WORD thumbPos =0); &#13;
</pre><p>There is a large set of methods for inspecting or changing scroll bar settings. The size of a line or page is set by the constructor:</p><pre class="programlisting">      void SetHorizontalScrollPosition(int scrollPos); &#13;
      int GetHorizontalScrollPosition() const; &#13;
      void SetVerticalScrollPosition(int scrollPos); &#13;
      int GetVerticalScrollPosition() const; &#13;
 &#13;
      void SetHorizontalScrollLineWidth(int lineWidth); &#13;
      int GetHorizontalScrollLineHeight() const; &#13;
      void SetVerticalScrollLineHeight(int lineHeight); &#13;
      int GetVerticalScrollLineHeight() const; &#13;
 &#13;
      void SetHorizontalScrollPageWidth(int pageWidth); &#13;
      int GetHorizontalScrollPageWidth() const; &#13;
      void SetVerticalScrollPageHeight(int pageHeight); &#13;
      int GetVerticalScrollPageHeight() const; &#13;
&#13;
&#13;
 &#13;
      void SetHorizontalScrollTotalWidth(int scrollWidth); &#13;
      int GetHorizontalScrollTotalWidth() const; &#13;
      void SetVerticalScrollTotalHeight(int scrollHeight); &#13;
      int GetVerticalScrollTotalHeight() const; &#13;
  }; &#13;
</pre><p>The <code class="literal">Menu</code> class handles the menu bar, a menu, a menu item, or a menu item separator (a horizontal bar) in the document. The <code class="literal">selection</code> listener is called when the user selects the menu item. The <code class="literal">enable</code>, <code class="literal">check</code>, and <code class="literal">radio</code> listeners are called (unless they are null) when the item is about to become visible. If they return <code class="literal">true</code>, the item is enabled or annotated with a check box or radio button:</p><pre class="programlisting">  class Menu { &#13;
    public: &#13;
      void AddMenu(Menu&amp; menu); &#13;
      void AddSeparator(); &#13;
      void AddItem(String text, VoidListener selection, &#13;
                   BoolListener enable = nullptr, &#13;
                   BoolListener check = nullptr, &#13;
                   BoolListener radio = nullptr); &#13;
  }; &#13;
</pre><p>An <strong>accelerator</strong> is a shortcut command. For instance, often, the <strong>Open</strong> item in the <strong>File</strong> menu is annotated with the text <strong>Ctrl+O</strong>. This means that you can obtain the same result by pressing the <em>
<strong>Ctrl</strong>
</em> key and the <em>
<strong>O</strong>
</em> key at the same time, just as if you selected the <strong>Open</strong> menu item. In both cases, the Open dialog is displayed.</p><p>The <code class="literal">Accelerator</code> class holds only the <code class="literal">TextToAccelerator</code> method. It interprets the menu item text and adds the accelerator, if present, to the accelerator set:</p><pre class="programlisting">class Accelerator { &#13;
    public: &#13;
      static void TextToAccelerator(String&amp; text, int idemId, &#13;
                                    list&lt;ACCEL&gt;&amp; acceleratorSet); &#13;
  }; &#13;
</pre><p>The <code class="literal">StandardDocument</code> class extends the <code class="literal">Document</code> class and sets up a framework that takes care of all traditional tasks, such as load and save, and cut, copy, and paste, in a document-based application:</p><pre class="programlisting">  class StandardDocument : public Document { &#13;
    public: &#13;
</pre><p>The <code class="literal">StandardDocument</code> class comes equipped with the common <strong>File</strong>, <strong>Edit</strong>, and <strong>Help</strong> menus. The <strong>File</strong> menu can optionally (if the <code class="literal">print</code> parameter is <code class="literal">true</code>) be equipped with menu items for printing and print previewing:</p><pre class="programlisting">      Menu StandardFileMenu(bool print); &#13;
      Menu StandardEditMenu(); &#13;
      Menu StandardHelpMenu(); &#13;
</pre><p>The <code class="literal">ClearDocument</code> method is called when the user selects the <strong>New</strong> menu item; its task is to clear the document. The <code class="literal">WriteDocumentToStream</code> method is called when the user selects the <strong>Save</strong> or <strong>Save As</strong> menu item and the <code class="literal">ReadDocumentFromStream</code> method is called when the user selects the <strong>Open</strong> menu item:</p><pre class="programlisting">      virtual void ClearDocument(); &#13;
      virtual bool WriteDocumentToStream(String name, &#13;
                                         ostream&amp; outStream)const; &#13;
      virtual bool ReadDocumentFromStream(String name, &#13;
                                          istream&amp; inStream); &#13;
</pre><p>The <code class="literal">CopyAscii</code>, <code class="literal">CopyUnicode</code>, and <code class="literal">CopyGeneric</code> methods are called when the user selects the <strong>Cut</strong> or <strong>Copy</strong> menu item and the corresponding <code class="literal">ready</code> method returns <code class="literal">true</code>. The code snippet for it is shown as follows:</p><pre class="programlisting">      virtual void CopyAscii(vector&lt;String&gt;&amp; textList) const; &#13;
      virtual bool IsCopyAsciiReady() const; &#13;
      virtual void CopyUnicode(vector&lt;String&gt;&amp; textList) const; &#13;
      virtual bool IsCopyUnicodeReady() const; &#13;
      virtual void CopyGeneric(int format, InfoList&amp; infoList)  &#13;
                               const; &#13;
      virtual bool IsCopyGenericReady(int format) const; &#13;
</pre><p>In the same way, the <code class="literal">PasteAscii</code>, <code class="literal">PasteUnicode</code>, and <code class="literal">PasteGeneric</code> methods are called when the user selects the <strong>Paste</strong> menu item and the corresponding <code class="literal">ready</code> method returns <code class="literal">true</code>:</p><pre class="programlisting">      virtual void PasteAscii(const vector&lt;String&gt;&amp; textList); &#13;
      virtual bool IsPasteAsciiReady &#13;
                   (const vector&lt;String&gt;&amp; textList) const; &#13;
      virtual void PasteUnicode(const vector&lt;String&gt;&amp; textList); &#13;
      virtual bool IsPasteUnicodeReady &#13;
                   (const vector&lt;String&gt;&amp; textList) const; &#13;
      virtual void PasteGeneric(int format, InfoList&amp; infoList); &#13;
      virtual bool IsPasteGenericReady(int format, &#13;
                                       InfoList&amp; infoList) const; &#13;
</pre><p>The <code class="literal">OnDropFile</code> method checks the path list and accepts the drop if exactly one file has the suffix of the document type of the application (set by the constructor):</p><pre class="programlisting">      void OnDropFile(vector&lt;String&gt; pathList); &#13;
  }; &#13;
</pre><p>In Small Windows, we do not care about the pixel size. Instead, we use <strong>logical units</strong> that stay the same, regardless of the physical resolution of the screen. We can choose from the following three coordinate systems:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LogicalWithScroll</code>: A logical unit is one hundredth of a millimeter, with the current scroll bar settings taken into account. The drawing program and word processor use this system.</li><li class="listitem" style="list-style-type: disc"><code class="literal">LogicalWithoutScroll</code>: A logical unit is one hundredth of a millimeter also in this case, but the current scroll bar settings are ignored. The spreadsheet program uses this system.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PreviewCoordinate</code>: The client area of the window is set to a fixed logical size when the window is created. This means that the size of the logical units changes when the user changes the window size. The Tetris game and the <code class="literal">PreviewDocument</code> class uses this system.</li></ul></div><p>Besides the <code class="literal">StandardDocument</code> class, there is also the <code class="literal">PrintPreviewDocument</code>, which class that also extends the <code class="literal">Document</code> class. It displays one of the pages of a standard document. It is possible for the user to change the page by using the arrow keys and the <em>
<strong>Page Up</strong>
</em> and <em>
<strong>Page Down</strong>
</em> keys or by using the vertical scroll bar:</p><pre class="programlisting">  class PrintPreviewDocument : Document { &#13;
    public: &#13;
      PrintPreviewDocument(StandardDocument* parentDocument, &#13;
                  int page = 1, Size pageSize = USLetterPortrait); &#13;
      bool OnKeyDown(WORD key, bool shiftPressed, &#13;
                     bool controlPressed); &#13;
      void OnVerticalScroll(WORD flags, WORD thumbPos = 0); &#13;
      void OnPaint(Graphics&amp; graphics) const; &#13;
  }; &#13;
</pre><p>There are also the simple auxiliary classes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Point</code>: It holds a two-dimensional point (x and y)</li><li class="listitem" style="list-style-type: disc"><code class="literal">Size</code>: It holds two-dimensional width and height</li><li class="listitem" style="list-style-type: disc"><code class="literal">Rect</code>: It holds the four corners of a rectangle</li><li class="listitem" style="list-style-type: disc"><code class="literal">DynamicList</code>: It holds a dynamic list</li><li class="listitem" style="list-style-type: disc"><code class="literal">Tree</code>: It holds a tree structure</li><li class="listitem" style="list-style-type: disc"><code class="literal">InfoList</code>: It holds a list of generic information that can be transformed into a memory block</li></ul></div><p>The <code class="literal">Registry</code> class holds an interface to the <strong>Windows Registry</strong>, the database in the Windows system that we can use to store values in between the execution of our applications. The <code class="literal">Clipboard</code> class holds an interface to the <strong>Windows Clipboard</strong>, an area in Windows intended for short-term data storage that we can use to store information cut, copied, and pasted between applications.</p><p>The <code class="literal">Dialog</code> class is designed for customized dialogs. The <code class="literal">Control</code> class is the root class for the controls of the dialog. The <code class="literal">CheckBox</code>, <code class="literal">RadioButton</code>, <code class="literal">PushButton</code>, <code class="literal">ListBox</code>, and <code class="literal">ComboBox</code> classes are classes for the specific controls. The <code class="literal">TextField</code> class holds a text field that can be translated to different types by the <code class="literal">Converter</code> class. Finally, the <code class="literal">PageSetupDialog</code> class extends the <code class="literal">Dialog</code> class and implements a dialog with controls and converters.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec9"/>Summary</h1></div></div></div><p>This chapter has given an introduction to Small Windows. In <a class="link" href="ch02.html" title="Chapter 2. Hello, Small World!">Chapter 2</a>, <em>Hello, Small World</em>, we will start to develop applications with Small Windows.</p></div></body></html>