<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Filesystem</h1>
                
            
            <article>
                
<p class="calibre2">One of the biggest new features of C++17 is its <kbd class="calibre12">&lt;filesystem&gt;</kbd> library. This library, like many other major features of modern C++, originated in the Boost project. In 2015, it went into a standard technical specification to gather feedback, and finally, was merged into the C++17 standard <span>with some changes based on that feedback</span>.</p>
<p class="calibre2">In this chapter, you'll learn the following:</p>
<ul class="calibre14">
<li class="calibre15">How <kbd class="calibre12">&lt;filesystem&gt;</kbd> returns dynamically typed errors without throwing exceptions, and how you can too</li>
<li class="calibre15">The format of a <em class="calibre22">path,</em> and the fundamentally incompatible positions of POSIX and Windows on the subject</li>
<li class="calibre15">How to stat files and walk directories using portable C++17</li>
<li class="calibre15">How to create, copy, rename, and remove files and directories</li>
<li class="calibre15">How to fetch the free space of a filesystem</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A note about namespaces</h1>
                
            
            <article>
                
<p class="calibre2">The standard C++17 filesystem facilities are all provided in a single header, <kbd class="calibre12">&lt;filesystem&gt;</kbd>, and everything in that header is placed in its own namespace: <kbd class="calibre12">namespace std::filesystem</kbd>. This follows the precedent set by C++11's <kbd class="calibre12">&lt;chrono&gt;</kbd> header with its <kbd class="calibre12">namespace std::chrono</kbd>. (This book omits a full treatment of <kbd class="calibre12">&lt;chrono&gt;</kbd>. Its interactions with <kbd class="calibre12">std::thread</kbd> and <kbd class="calibre12">std::timed_mutex</kbd> are covered briefly in <a href="part0108.html#36VSO0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 7</a>, <em class="calibre22">Concurrency</em>.)</p>
<p class="calibre2">This namespacing strategy means that when you use the <kbd class="calibre12">&lt;filesystem&gt;</kbd> facilities, you'll be using identifiers such as <kbd class="calibre12">std::filesystem::directory_iterator</kbd> and <kbd class="calibre12">std::filesystem::temp_directory_path()</kbd>. These fully qualified names are quite unwieldy! But pulling the entire namespace into your current context with a <kbd class="calibre12">using</kbd> declaration is probably an overkill, especially, if you have to do it at file scope. We've all been taught over the past decade never to write <kbd class="calibre12">using namespace std</kbd>, and that advice won't change, no matter how deeply the standard library nests its namespaces. Consider the following code:</p>
<pre class="mce-root">    using namespace std::filesystem;<br class="title-page-name"/><br class="title-page-name"/>    void foo(path p)<br class="title-page-name"/>    {<br class="title-page-name"/>      remove(p); // What function is this?<br class="title-page-name"/>    }</pre>
<p class="calibre2">A better solution for everyday purposes is to define a <em class="calibre22">namespace alias</em> at file scope (in a <kbd class="calibre12">.cc</kbd> file) or namespace scope (in a <kbd class="calibre12">.h</kbd> file). A namespace alias allows you to refer to an existing namespace by a new name, as seen in the following example:</p>
<pre class="mce-root1">    namespace fs = std::filesystem;<br class="title-page-name"/><br class="title-page-name"/>    void foo(fs::path p)<br class="title-page-name"/>    {<br class="title-page-name"/>      fs::remove(p); // Much clearer!<br class="title-page-name"/>    }</pre>
<p class="calibre2">In the remainder of this chapter, I will be using the namespace alias <kbd class="calibre12">fs</kbd> to refer to <kbd class="calibre12">namespace std::filesystem</kbd>. When I say <kbd class="calibre12">fs::path</kbd>, I mean <kbd class="calibre12">std::filesystem::path</kbd>. When I say <kbd class="calibre12">fs::remove</kbd>, I mean <kbd class="calibre12">std::filesystem::remove</kbd>.</p>
<p class="calibre2">Defining a namespace alias <kbd class="calibre12">fs</kbd> somewhere global has another pragmatic benefit as well. At press time, of all the major library vendors, only Microsoft Visual Studio claims to have implemented the C++17 <kbd class="calibre12">&lt;filesystem&gt;</kbd> header. However, the facilities of <kbd class="calibre12">&lt;filesystem&gt;</kbd> are very similar to those provided by libstdc++ and libc++ in <kbd class="calibre12">&lt;experimental/filesystem&gt;</kbd>, and by Boost in <kbd class="calibre12">&lt;boost/filesystem.hpp&gt;</kbd>. So, if you consistently refer to these facilities by a custom namespace alias, such as <kbd class="calibre12">fs</kbd>, you'll be able to switch from one vendor's implementation to another just by changing the target of that alias<span>--</span>a one-line change, as opposed to a massive and error-prone search-and-replace operation on your entire codebase. This can be seen in the following example:</p>
<pre class="mce-root1">    #if USE_CXX17<br class="title-page-name"/>     #include &lt;filesystem&gt;<br class="title-page-name"/>     namespace fs = std::filesystem;<br class="title-page-name"/>    #elif USE_FILESYSTEM_TS<br class="title-page-name"/>     #include &lt;experimental/filesystem&gt;<br class="title-page-name"/>     namespace fs = std::experimental::filesystem;<br class="title-page-name"/>    #elif USE_BOOST<br class="title-page-name"/>     #include &lt;boost/filesystem.hpp&gt;<br class="title-page-name"/>     namespace fs = boost::filesystem;<br class="title-page-name"/>    #endif</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A very long note on error-reporting</h1>
                
            
            <article>
                
<p class="calibre2">C++ has a love-hate relationship with error-reporting. By "error-reporting" in this context, I mean "what to do, when you can't do what you were asked". The classical, typical, and still the best-practice way to report this kind of "disappointment" in C++ is to throw an exception. We have seen in the previous chapters that, sometimes, throwing an exception is the <em class="calibre22">only</em> sensible thing to do, because there is no way to return to your caller. For example, if your task was to construct an object, and construction fails, you cannot return; when a constructor fails, the only same course of action is to throw. However, we have <em class="calibre22">also</em> seen (in <a href="part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 9</a><em class="calibre22">, Iostreams</em>) that C++'s own <kbd class="calibre12">&lt;iostream&gt;</kbd> library does not take this sane course of action! If the construction of a <kbd class="calibre12">std::fstream</kbd> object fails (because the named file cannot be opened), you will get an exception; you'll get a fully constructed <kbd class="calibre12">fstream</kbd> object where <kbd class="calibre12">f.fail() &amp;&amp; !f.is_open()</kbd>.</p>
<p class="calibre2">The reason we gave in <a href="https://cdp.packtpub.com/mastering_c___stl/wp-admin/post.php?post=64&amp;action=edit#post_58" class="calibre4">Chapter 9</a><em class="calibre22">, Iostreams</em>, for the "bad" behavior of <kbd class="calibre12">fstream</kbd> was the <em class="calibre22">relatively high likelihood</em> that the named file will not be openable. Throwing an exception every time a file can't be opened is uncomfortably close to using exceptions for control flow, which we have been taught<span>--</span>properly<span>--</span>to avoid. So, rather than force the programmer to write <kbd class="calibre12">try</kbd> and <kbd class="calibre12">catch</kbd> blocks everywhere, the library returns as if the operation had succeeded, but allows the user to check (with a normal <kbd class="calibre12">if</kbd>, not a <kbd class="calibre12">catch</kbd>) whether the operation really did succeed or not.</p>
<p class="calibre2">That is, we can avoid writing this cumbersome code:</p>
<pre class="mce-root">    try {<br class="title-page-name"/>      f.open("hello.txt");<br class="title-page-name"/>      // Opening succeeded.<br class="title-page-name"/>    } catch (const std::ios_base::failure&amp;) {<br class="title-page-name"/>      // Opening failed.<br class="title-page-name"/>    }</pre>
<p class="calibre2">Instead, we can simply write this:</p>
<pre class="mce-root">    f.open("hello.txt");<br class="title-page-name"/>    if (f.is_open()) {<br class="title-page-name"/>      // Opening succeeded.<br class="title-page-name"/>    } else {<br class="title-page-name"/>      // Opening failed.<br class="title-page-name"/>    }</pre>
<p class="calibre2">The iostreams approach works pretty well when the result of the operation is described by a heavyweight object (such as an <kbd class="calibre12">fstream</kbd>) which has a natural <em class="calibre22">failed</em> state, or where such a <em class="calibre22">failed</em> state can be added during the design stage. However, it has some downsides as well, and it flatly cannot be used if there is no heavyweight type involved. We saw this scenario at the end of <a href="part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 9</a>, <em class="calibre22">Iostreams</em>, when we looked at ways of parsing integers from strings. If we don't expect failure, or don't mind the performance hit of "using exceptions for control flow," then we use <kbd class="calibre12">std::stoi</kbd>:</p>
<pre class="mce-root">    // Exception-throwing approach.<br class="title-page-name"/>    try {<br class="title-page-name"/>      int i = std::stoi(s);<br class="title-page-name"/>      // Parsing succeeded.<br class="title-page-name"/>    } catch (...) {<br class="title-page-name"/>      // Parsing failed.<br class="title-page-name"/>    }</pre>
<p class="calibre2">If we need portability to C++03, we use <kbd class="calibre12">strtol</kbd>, which reports errors via the thread-local global variable <kbd class="calibre12">errno</kbd>, as seen in this code:</p>
<pre class="mce-root">    char *endptr = nullptr;<br class="title-page-name"/>    errno = 0;<br class="title-page-name"/>    long i = strtol(s, &amp;endptr, 10);<br class="title-page-name"/>    if (endptr != s &amp;&amp; !errno) {<br class="title-page-name"/>      // Parsing succeeded.<br class="title-page-name"/>    } else {<br class="title-page-name"/>      // Parsing failed.<br class="title-page-name"/>    }</pre>
<p class="calibre2">And in bleeding-edge C++17 style, we use <kbd class="calibre12">std::from_chars</kbd>, which returns a lightweight struct containing the end-of-string pointer and a value of the strong enum type <kbd class="calibre12">std::errc</kbd> indicating success or failure, as follows:</p>
<pre class="mce-root">    int i = 0;<br class="title-page-name"/>    auto [ptr, ec] = std::from_chars(s, end(s), i);<br class="title-page-name"/>    if (ec != std::errc{}) {<br class="title-page-name"/>      // Parsing succeeded.<br class="title-page-name"/>    } else {<br class="title-page-name"/>      // Parsing failed.<br class="title-page-name"/>    }</pre>
<p class="calibre2">The <kbd class="calibre12">&lt;filesystem&gt;</kbd> library needs approximately the same capacity for error-reporting as <kbd class="calibre12">std::from_chars</kbd>. Pretty much any operation you can perform on your filesystem might fail due to the actions of other processes running on the system; so, throwing an exception on every failure (á là <kbd class="calibre12">std::stoi</kbd>) seems uncomfortably close to using exceptions for control flow. But threading an "error result" like <kbd class="calibre12">ec</kbd> through your entire codebase can also be tedious and (no pun intended) error-prone. So, the standard library decided to have its cake and eat it too by providing <em class="calibre22">two interfaces</em> to almost every function in the <kbd class="calibre12">&lt;filesystem&gt;</kbd> header!</p>
<p class="calibre2">For example, the following are the two <kbd class="calibre12">&lt;filesystem&gt;</kbd> functions for determining the size of a file on disk:</p>
<pre class="mce-root">    uintmax_t file_size(const fs::path&amp; p);<br class="title-page-name"/><br class="title-page-name"/>    uintmax_t file_size(const fs::path&amp; p,<br class="title-page-name"/>       std::error_code&amp; ec) noexcept;</pre>
<p class="calibre2">Both the preceding functions take an <kbd class="calibre12">fs::path</kbd> (which we'll discuss more further in the chapter), and return a <kbd class="calibre12">uintmax_t</kbd> telling the size of the named file in bytes. But what if the file doesn't exist, or it exists, but the current user-account doesn't have permission to query its size? Then, the first overload will simply <em class="calibre22">throw an exception</em> of type <kbd class="calibre12">fs::filesystem_error</kbd>, indicating what went wrong. But the second overload will never throw (in fact, it's marked <kbd class="calibre12">noexcept</kbd>). Instead, it takes an out-parameter of type <kbd class="calibre12">std::error_code</kbd>, which the library will fill in with an indication of what went wrong (or clear, if nothing went wrong at all).</p>
<p class="calibre2">Comparing the signatures of <kbd class="calibre12">fs::file_size</kbd> and <kbd class="calibre12">std::from_chars</kbd>, you might notice that <kbd class="calibre12">from_chars</kbd> deals in <kbd class="calibre12">std::errc</kbd>, and <kbd class="calibre12">file_size</kbd> deals in <kbd class="calibre12">std::error_code</kbd>. These two types, while related, are not the same! To understand the difference<span>--</span>and the entire design of the non-throwing <kbd class="calibre12">&lt;filesystem&gt;</kbd> API<span>--</span>we'll have to take a quick detour into another part of the C++11 standard library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using &lt;system_error&gt;</h1>
                
            
            <article>
                
<p class="calibre2">The difference between the error-reporting mechanisms of <kbd class="calibre12">std::from_chars</kbd> and <kbd class="calibre12">fs::file_size</kbd> is a difference in their intrinsic complexity. <kbd class="calibre12">from_chars</kbd> can fail in exactly two ways-- either the given string had no initial string of digits at all, else there were so <em class="calibre22">many</em> digits that it would cause an overflow to read them all. In the former case, a classic (but inefficient and, generally, dangerous) way to report the error would be to set <kbd class="calibre12">errno</kbd> to <kbd class="calibre12">EINVAL</kbd> (and return some useless value such as <kbd class="calibre12">0</kbd>). In the latter case, a classic approach would be to set <kbd class="calibre12">errno</kbd> to <kbd class="calibre12">ERANGE</kbd> (and return some useless value). This is more or less (but rather less than more) the approach taken by <kbd class="calibre12">strtol</kbd>.</p>
<p class="calibre2">The salient point is that with <kbd class="calibre12">from_chars</kbd>, there are exactly two things that can possibly <em class="calibre22">ever</em> go wrong, and they are completely describable by the single set of error codes provided by POSIX <kbd class="calibre12">&lt;errno.h&gt;</kbd>. So, in order to bring the 1980'<span>s</span> <kbd class="calibre12">strtol</kbd> into the twenty-first century, all we need to fix is to make it return its error code directly to the caller rather than indirectly, via the thread-local <kbd class="calibre12">errno</kbd>. And so, that's all the standard library did. The classic POSIX <kbd class="calibre12">&lt;errno.h&gt;</kbd> values are still provided as macros via <kbd class="calibre12">&lt;cerrno&gt;</kbd>, but as of C++11, they're also provided via a strongly typed enumeration in <kbd class="calibre12">&lt;system_error&gt;</kbd>, as shown in the following code:</p>
<pre class="mce-root1"> namespace std {<br class="title-page-name"/>   enum class errc {<br class="title-page-name"/>     // implicitly, "0" means "no error"<br class="title-page-name"/>     operation_not_permitted = EPERM,<br class="title-page-name"/>     no_such_file_or_directory = ENOENT,<br class="title-page-name"/>     no_such_process = ESRCH,<br class="title-page-name"/>     // ...<br class="title-page-name"/>     value_too_large = EOVERFLOW<br class="title-page-name"/>   };<br class="title-page-name"/> } // namespace std</pre>
<p class="calibre2"><kbd class="calibre12">std::from_chars</kbd> reports errors by returning a struct (<kbd class="calibre12">struct from_chars_result</kbd>) containing a member variable of type <kbd class="calibre12">enum std::errc</kbd>, which will be either <kbd class="calibre12">0</kbd> for <em class="calibre22">no error</em>, or one of the two possible error-indicating values.</p>
<p class="calibre2">Now, what about <kbd class="calibre12">fs::file_size</kbd>? The set of possible errors encountered by <kbd class="calibre12">file_size</kbd> is much much larger<span>--</span>in fact, when you think of the number of operating systems in existence, and the number of different filesystems supported by each, and the fact that some filesystems (such as NFS) are distributed over <em class="calibre22">networks</em> of various types, the set of possible errors seems an awful lot like an <em class="calibre22">open set</em>. It might be possible to boil them all down onto the seventy-eight standard <kbd class="calibre12">sys::errc</kbd> enumerators (one for each POSIX <kbd class="calibre12">errno</kbd> value except <kbd class="calibre12">EDQUOT</kbd>, <kbd class="calibre12">EMULTIHOP</kbd>, and <kbd class="calibre12">ESTALE</kbd>), but that would lose a lot of information. Heck, at least one of the missing POSIX enumerators (<kbd class="calibre12">ESTALE</kbd>) is a legitimate failure mode of <kbd class="calibre12">fs::file_size</kbd>! And, of course, your underlying filesystem might want to report its own filesystem-specific errors; for example, while there is a standard POSIX error code for <em class="calibre22">name too long</em>, there is no POSIX error code for <em class="calibre22">name contains disallowed character</em> (for reasons we'll see in the next major section of this chapter). A filesystem might want to report exactly that error without worrying that <kbd class="calibre12">fs::file_size</kbd> was going to squash it down onto some fixed enumeration type.</p>
<p class="calibre2">The essential issue here is that the errors reported by <kbd class="calibre12">fs::file_size</kbd> might not all come from the same <em class="calibre22">domain</em>, and therefore, they cannot be represented by a single fixed-in-stone <em class="calibre22">type</em> (for example, <kbd class="calibre12">std::errc</kbd>). C++ exception-handling solves this problem elegantly; it is fine and natural for different levels of the program to throw different types of exceptions. If the lowest level of a program throws <kbd class="calibre12">myfs::DisallowedCharacterInName</kbd>, the topmost level can catch it<span>--</span>either by name, by base class, or by <kbd class="calibre12">...</kbd>. If we follow the general rule that everything thrown in a program should derive from <kbd class="calibre12">std::exception</kbd>, then any <kbd class="calibre12">catch</kbd> block will be able to use <kbd class="calibre12">e.what()</kbd> so that at least the user gets some vaguely human-readable indication of the problem, no matter what the problem was.</p>
<p class="calibre2">The standard library <em class="calibre22">reifies</em> the idea of multiple error domains into the base class <kbd class="calibre12">std::error_category</kbd>, as seen in the following code:</p>
<pre class="mce-root1"> namespace std {<br class="title-page-name"/><br class="title-page-name"/> class error_category {<br class="title-page-name"/> public:<br class="title-page-name"/>   virtual const char *name() const noexcept = 0;<br class="title-page-name"/>   virtual std::string message(int err) const = 0;<br class="title-page-name"/><br class="title-page-name"/>   // other virtual methods not shown<br class="title-page-name"/><br class="title-page-name"/>   bool operator==(const std::error_category&amp; rhs) const {<br class="title-page-name"/>     return this == &amp;rhs;<br class="title-page-name"/>   }<br class="title-page-name"/> };<br class="title-page-name"/><br class="title-page-name"/> } // namespace std</pre>
<p class="calibre2"><kbd class="calibre12">error_category</kbd> behaves a lot like <kbd class="calibre12">memory_resource</kbd> from <a href="part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 8</a>, <em class="calibre22">Allocators</em>; it defines a classically polymorphic interface, and certain kinds of libraries are expected to subclass it. With <kbd class="calibre12">memory_resource</kbd>, we saw that some subclasses are global singletons, and some aren't. With <kbd class="calibre12">error_category</kbd>, <em class="calibre22">each</em> subclass <em class="calibre22">must</em> be a global singleton, or it's not going to work.</p>
<p class="calibre2">To make memory resources useful, the library gives us <em class="calibre22">containers</em> (see <a href="part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 4</a>, <em class="calibre22">The Container Zoo</em>). At the most basic level, a container is a pointer representing some allocated memory, plus a handle to the <em class="calibre22">memory resource</em> that knows how to deallocate that pointer. (Recall that a handle to a memory resource is called an <em class="calibre22">allocator</em>.)</p>
<p class="calibre2">To make the <kbd class="calibre12">error_category</kbd> subclasses useful, the library gives us <kbd class="calibre12">std::error_code</kbd>. At the most basic level (which is the <em class="calibre22">only</em> level, in this case), an <kbd class="calibre12">error_code</kbd> is an <kbd class="calibre12">int</kbd> representing an error enumerator plus a handle to the <kbd class="calibre12">error_category</kbd> that knows how to interpret that enumerator. It looks like this:</p>
<pre class="mce-root">    namespace std {<br class="title-page-name"/><br class="title-page-name"/>    class error_code {<br class="title-page-name"/>      const std::error_category *m_cat;<br class="title-page-name"/>      int m_err;<br class="title-page-name"/>    public:<br class="title-page-name"/>      const auto&amp; category() const { return m_cat; }<br class="title-page-name"/>      int value() const { return m_err; }<br class="title-page-name"/>      std::string message() const { return m_cat-&gt;message(m_err); }<br class="title-page-name"/>      explicit operator bool() const { return m_err != 0; }<br class="title-page-name"/><br class="title-page-name"/>      // other convenience methods not shown<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    } // namespace std</pre>
<p class="calibre2">So, to create a finicky filesystem library subsystem, we could write the following:</p>
<pre class="mce-root">    namespace FinickyFS {<br class="title-page-name"/><br class="title-page-name"/>    enum class Error : int {<br class="title-page-name"/>      success = 0,<br class="title-page-name"/>      forbidden_character = 1,<br class="title-page-name"/>      forbidden_word = 2,<br class="title-page-name"/>      too_many_characters = 3,<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    struct ErrorCategory : std::error_category<br class="title-page-name"/>    {<br class="title-page-name"/>      const char *name() const noexcept override {<br class="title-page-name"/>        return "finicky filesystem";<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>      std::string message(int err) const override {<br class="title-page-name"/>        switch (err) {<br class="title-page-name"/>          case 0: return "Success";<br class="title-page-name"/>          case 1: return "Invalid filename";<br class="title-page-name"/>          case 2: return "Bad word in filename";<br class="title-page-name"/>          case 3: return "Filename too long";<br class="title-page-name"/>        }<br class="title-page-name"/>        throw Unreachable();<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>      static ErrorCategory&amp; instance() {<br class="title-page-name"/>        static ErrorCategory instance;<br class="title-page-name"/>        return instance;<br class="title-page-name"/>      }<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    std::error_code make_error_code(Error err) noexcept<br class="title-page-name"/>   {<br class="title-page-name"/>      return std::error_code(int(err), ErrorCategory::instance());<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    } // namespace FinickyFS</pre>
<p class="calibre2">This preceding code defines a new error domain, the <kbd class="calibre12">FinickyFS::Error</kbd> domain, reified as <kbd class="calibre12">FinickyFS::ErrorCategory::instance()</kbd>. It allows us to create objects of type <kbd class="calibre12">std::error_code</kbd> via expressions such as <kbd class="calibre12">make_error_code(FinickyFS::Error::forbidden_word)</kbd>.</p>
<div class="packt_tip">Notice that <strong class="calibre47">argument-dependent lookup</strong> (<strong class="calibre47">ADL</strong>) will find the correct overload of <kbd class="calibre25">make_error_code</kbd> without any help from us. <kbd class="calibre25">make_error_code</kbd> is a customization point in exactly the same way as <kbd class="calibre25">swap</kbd>: just define a function with that name in your enum's namespace, and it will work without any additional effort.</div>
<pre class="calibre23">    // An error fits comfortably in a statically typed<br class="title-page-name"/>    // and value-semantic std::error_code object...<br class="title-page-name"/>    std::error_code ec =    <br class="title-page-name"/>      make_error_code(FinickyFS::Error::forbidden_word);<br class="title-page-name"/><br class="title-page-name"/>    // ...Yet its "what-string" remains just as<br class="title-page-name"/>    // accessible as if it were a dynamically typed<br class="title-page-name"/>    // exception!<br class="title-page-name"/>    assert(ec.message() == "Bad word in filename");</pre>
<p class="calibre2">We now have a way to pass <kbd class="calibre12">FinickyFS::Error</kbd> codes losslessly through the system--by wrapping them inside trivially copyable <kbd class="calibre12">std::error_code</kbd> objects, and getting the original error back out at the topmost level. When I put it that way, it sounds almost like magic--like exception handling without exceptions! But as we've just seen, it's very simple to implement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Error codes and error conditions</h1>
                
            
            <article>
                
<p class="calibre2">Notice that <kbd class="calibre12">FinickyFS::Error</kbd> is not implicitly convertible to <kbd class="calibre12">std::error_code</kbd>; in the last example, we used the syntax <kbd class="calibre12">make_error_code(FinickyFS::Error::forbidden_word)</kbd> to construct our initial <kbd class="calibre12">error_code</kbd> object. We can make <kbd class="calibre12">FinickyFS::Error</kbd> more convenient for the programmer if we tell <kbd class="calibre12">&lt;system_error&gt;</kbd> to enable implicit conversions from <kbd class="calibre12">FinickyFS::Error</kbd> to <kbd class="calibre12">std::error_code</kbd>, as follows:</p>
<pre class="mce-root">    namespace std {<br class="title-page-name"/>    template&lt;&gt;<br class="title-page-name"/>    struct is_error_code_enum&lt;::FinickyFS::Error&gt; : true_type {};<br class="title-page-name"/>    } // namespace std</pre>
<p class="calibre2">Be careful when reopening namespace <kbd class="calibre12">std</kbd>--remember that you must be outside any other namespace when you do it! Otherwise, you'll be creating a nested namespace such as namespace <kbd class="calibre12">FinickyFS::std</kbd>. In this particular case, if you get it wrong, the compiler will helpfully error out when you try to specialize the non-existent <kbd class="calibre12">FinickyFS::std::is_error_code_enum</kbd>. As long as you only ever reopen namespace <kbd class="calibre12">std</kbd> in order to specialize templates (and as long as you don't mess up the template-specialization syntax), you won't have to worry too much about anything <em class="calibre22">quietly</em> failing.</p>
<p class="calibre2">Once you've specialized <kbd class="calibre12">std::is_error_code_enum</kbd> for your enum type, the library takes care of the rest, as seen in this code:</p>
<pre class="mce-root">    class error_code {<br class="title-page-name"/>      // ...<br class="title-page-name"/>      template&lt;<br class="title-page-name"/>        class E,<br class="title-page-name"/>        class = enable_if_t&lt;is_error_code_enum_v&lt;E&gt;&gt;<br class="title-page-name"/>      &gt;<br class="title-page-name"/>      error_code(E err) noexcept {<br class="title-page-name"/>        *this = make_error_code(err);<br class="title-page-name"/>      }<br class="title-page-name"/>    };</pre>
<p class="calibre2">The implicit conversion seen in the previous code enables convenient syntax such as direct comparisons via <kbd class="calibre12">==</kbd>, but because each <kbd class="calibre12">std::error_code</kbd> object carries its domain along with it, comparisons are strongly typed. Value-equality for the <kbd class="calibre12">error_code</kbd> objects depends not only on their <em class="calibre22">integer</em> <em class="calibre22">value</em>, but also the <em class="calibre22">address</em> of their associated error-category singletons.</p>
<pre class="mce-root">    std::error_code ec = FinickyFS::Error::forbidden_character;<br class="title-page-name"/><br class="title-page-name"/>      // Comparisons are strongly typed.<br class="title-page-name"/>    assert(ec == FinickyFS::Error::forbidden_character);<br class="title-page-name"/>    assert(ec != std::io_errc::stream);</pre>
<p class="calibre2">Specializing <kbd class="calibre12">is_error_code_enum&lt;X&gt;</kbd> is helpful if you're often going to be assigning <kbd class="calibre12">X</kbd> to variables of type <kbd class="calibre12">std::error_code</kbd>, or returning it from functions that return <kbd class="calibre12">std::error_code</kbd>. In other words, it's useful if your type <kbd class="calibre12">X</kbd> really does represent <em class="calibre22">the source of an error</em><span>--</span>the throwing side of the equation, so to speak. But what about the catching side? Suppose you notice that you've written this function, and several more like it:</p>
<pre class="mce-root">    bool is_malformed_name(std::error_code ec) {<br class="title-page-name"/>      return (<br class="title-page-name"/>        ec == FinickyFS::Error::forbidden_character ||<br class="title-page-name"/>        ec == FinickyFS::Error::forbidden_word ||<br class="title-page-name"/>        ec == std::errc::illegal_byte_sequence);<br class="title-page-name"/>    }</pre>
<p class="calibre2">The preceding function defines a <em class="calibre22">unary</em> <em class="calibre22">predicate</em> over the entire universe of error codes; it returns <kbd class="calibre12">true</kbd> for any error code associated with the concept of malformed names as far as our <kbd class="calibre12">FinickyFS</kbd> library is concerned. We can just drop this function straight into our library as <kbd class="calibre12">FinickyFS::is_malformed_name()</kbd>--and, in fact, that's the approach I personally recommend--but the standard library also provides another possible approach. You can define not an <kbd class="calibre12">error_code</kbd>, but an <kbd class="calibre12">error_condition</kbd>, as follows:</p>
<pre class="mce-root">    namespace FinickyFS {<br class="title-page-name"/><br class="title-page-name"/>    enum class Condition : int {<br class="title-page-name"/>      success = 0,<br class="title-page-name"/>      malformed_name = 1,<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    struct ConditionCategory : std::error_category {<br class="title-page-name"/>      const char *name() const noexcept override {<br class="title-page-name"/>        return "finicky filesystem";<br class="title-page-name"/>      }<br class="title-page-name"/>      std::string message(int cond) const override {<br class="title-page-name"/>        switch (cond) {<br class="title-page-name"/>          case 0: return "Success";<br class="title-page-name"/>          case 1: return "Malformed name";<br class="title-page-name"/>        }<br class="title-page-name"/>        throw Unreachable();<br class="title-page-name"/>      }<br class="title-page-name"/>      bool equivalent(const std::error_code&amp; ec, int cond) const  <br class="title-page-name"/>      noexcept override {<br class="title-page-name"/>        switch (cond) {<br class="title-page-name"/>          case 0: return !ec;<br class="title-page-name"/>          case 1: return is_malformed_name(ec);<br class="title-page-name"/>        }<br class="title-page-name"/>        throw Unreachable();<br class="title-page-name"/>      }<br class="title-page-name"/>      static ConditionCategory&amp; instance() {<br class="title-page-name"/>        static ConditionCategory instance;<br class="title-page-name"/>        return instance;<br class="title-page-name"/>      }<br class="title-page-name"/>    };<br class="title-page-name"/>    std::error_condition make_error_condition(Condition cond) noexcept  <br class="title-page-name"/>    {<br class="title-page-name"/>      return std::error_condition(int(cond),  <br class="title-page-name"/>      ConditionCategory::instance());<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    } // namespace FinickyFS<br class="title-page-name"/> <br class="title-page-name"/>    namespace std {<br class="title-page-name"/>    template&lt;&gt;<br class="title-page-name"/>    struct is_error_condition_enum&lt;::FinickyFS::Condition&gt; : true_type  <br class="title-page-name"/>    {};<br class="title-page-name"/>    } // namespace std</pre>
<p class="calibre2">Once you've done this, you can get the effect of calling <kbd class="calibre12">FinickyFS::is_malformed_name(ec)</kbd> by writing the comparison <kbd class="calibre12">(ec == FinickyFS::Condition::malformed_name)</kbd>, like this:</p>
<pre class="mce-root">    std::error_code ec = FinickyFS::Error::forbidden_word;<br class="title-page-name"/><br class="title-page-name"/>      // RHS is implicitly converted to error_code<br class="title-page-name"/>    assert(ec == FinickyFS::Error::forbidden_word);<br class="title-page-name"/><br class="title-page-name"/>      // RHS is implicitly converted to error_condition<br class="title-page-name"/>    assert(ec == FinickyFS::Condition::malformed_name);</pre>
<p class="calibre2">However, because we did not provide a function <kbd class="calibre12">make_error_code(FinickyFS::Condition)</kbd>, there will be no easy way to construct a <kbd class="calibre12">std::error_code</kbd>} object holding one of these conditions. This is appropriate; condition enums are for testing against on the catching side, not for converting to <kbd class="calibre12">error_code</kbd> on the throwing side.</p>
<p class="calibre2">The standard library provides two code enum types (<kbd class="calibre12">std::future_errc</kbd> and <kbd class="calibre12">std::io_errc</kbd>), and one condition enum type (<kbd class="calibre12">std::errc</kbd>). That's right--the POSIX error enum <kbd class="calibre12">std::errc</kbd> actually enumerates <em class="calibre22">conditions</em>, not <em class="calibre22">codes</em>! This means that if you're trying to stuff POSIX error codes into a <kbd class="calibre12">std::error_code</kbd> object, you're doing it wrong; they are <em class="calibre22">conditions</em>, which means they're for <em class="calibre22">testing</em> <em class="calibre22">against</em> on the catching side, not for throwing. Sadly, the standard library gets this wrong in at least two ways. First, as we've seen, <kbd class="calibre12">std::from_chars</kbd> does throw a value of type <kbd class="calibre12">std::errc</kbd> (which is doubly inconvenient; it would be more consistent to throw a <kbd class="calibre12">std::error_code</kbd>). Second, the function <kbd class="calibre12">std::make_error_code(std::errc)</kbd> exists, cluttering up the semantic space, when really only <kbd class="calibre12">std::make_error_condition(std::errc)</kbd> should (and does) exist.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Throwing errors with std::system_error</h1>
                
            
            <article>
                
<p class="calibre2">So far, we've considered <kbd class="calibre12">std::error_code</kbd>, a nifty non-throwing alternative to C++ exception-handling. But sometimes, you need to mix non-throwing and throwing libraries at different levels of the system. The standard library has your back--for one-half of the problem, anyway. <kbd class="calibre12">std::system_error</kbd> is a concrete exception type derived from <kbd class="calibre12">std::runtime_error</kbd>, which has just enough storage for a single <kbd class="calibre12">error_code</kbd>. So, if you are writing a library API which is throw-based, not <kbd class="calibre12">error_code</kbd>-based, and you receive an <kbd class="calibre12">error_code</kbd> indicating failure from a lower level of the system, it is perfectly appropriate to wrap that <kbd class="calibre12">error_code</kbd> in a <kbd class="calibre12">system_error</kbd> object, and <kbd class="calibre12">throw</kbd> it upward.</p>
<pre class="mce-root">    // The lower level is error_code-based.<br class="title-page-name"/>    uintmax_t file_size(const fs::path&amp; p,<br class="title-page-name"/>        std::error_code&amp; ec) noexcept;<br class="title-page-name"/><br class="title-page-name"/>    // My level is throw-based.<br class="title-page-name"/>    uintmax_t file_size(const fs::path&amp; p)<br class="title-page-name"/>    {<br class="title-page-name"/>      std::error_code ec;<br class="title-page-name"/>      uintmax_t size = file_size(p, ec);<br class="title-page-name"/>      if (ec) {<br class="title-page-name"/>        throw std::system_error(ec);<br class="title-page-name"/>      }<br class="title-page-name"/>      return size;<br class="title-page-name"/>    }</pre>
<p class="calibre2">In the opposite case--where you've written your library API to be non-throwing, but you make calls into lower levels that might throw<span>--</span>the standard library provides, basically, no help. But you can write an <kbd class="calibre12">error_code</kbd> unwrapper fairly easily yourself:</p>
<pre class="mce-root">    // The lower level is throw-based.<br class="title-page-name"/>    uintmax_t file_size(const fs::path&amp; p);<br class="title-page-name"/><br class="title-page-name"/>    // My level is error_code-based.<br class="title-page-name"/>    uintmax_t file_size(const fs::path&amp; p,<br class="title-page-name"/>        std::error_code&amp; ec) noexcept<br class="title-page-name"/>    {<br class="title-page-name"/>      uintmax_t size = -1;<br class="title-page-name"/>      try {<br class="title-page-name"/>        size = file_size(p);<br class="title-page-name"/>      } catch (...) {<br class="title-page-name"/>        ec = current_exception_to_error_code();<br class="title-page-name"/>      }<br class="title-page-name"/>      return size;<br class="title-page-name"/>    }</pre>
<p class="calibre2">The preceding code snippet calls <kbd class="calibre12">current_exception_to_error_code()</kbd>, which is a non-standard function you can write yourself. I recommend something along these lines:</p>
<pre class="mce-root1"> namespace detail {<br class="title-page-name"/><br class="title-page-name"/> enum Error : int {<br class="title-page-name"/>    success = 0,<br class="title-page-name"/>    bad_alloc_thrown = 1,<br class="title-page-name"/>    unknown_exception_thrown = 2,<br class="title-page-name"/> };<br class="title-page-name"/> struct ErrorCategory : std::error_category {<br class="title-page-name"/>    const char *name() const noexcept override;<br class="title-page-name"/>    std::string message(int err) const override;<br class="title-page-name"/>    static ErrorCategory&amp; instance();<br class="title-page-name"/> };<br class="title-page-name"/> std::error_code make_error_code(Error err) noexcept {<br class="title-page-name"/>    return std::error_code(int(err), ErrorCategory::instance());<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> } // namespace detail<br class="title-page-name"/><br class="title-page-name"/> std::error_code current_exception_to_error_code()<br class="title-page-name"/> {<br class="title-page-name"/>    try {<br class="title-page-name"/>        throw;<br class="title-page-name"/>    } catch (const std::system_error&amp; e) {<br class="title-page-name"/>        // also catches std::ios_base::failure<br class="title-page-name"/>        // and fs::filesystem_error<br class="title-page-name"/>        return e.code();<br class="title-page-name"/>    } catch (const std::future_error&amp; e) {<br class="title-page-name"/>        // catches the oddball<br class="title-page-name"/>        return e.code();<br class="title-page-name"/>    } catch (const std::bad_alloc&amp;) {<br class="title-page-name"/>        // bad_alloc is often of special interest<br class="title-page-name"/>        return detail::bad_alloc_thrown;<br class="title-page-name"/>    } catch (...) {<br class="title-page-name"/>        return detail::unknown_exception_thrown;<br class="title-page-name"/>    }<br class="title-page-name"/> }</pre>
<p class="calibre2">This concludes our digression into the confusing world of <kbd class="calibre12">&lt;system_error&gt;</kbd>. We now return you to your regularly scheduled <kbd class="calibre12">&lt;filesystem&gt;</kbd>, already in progress.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Filesystems and paths</h1>
                
            
            <article>
                
<p class="calibre2">In <a href="part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 9</a>, <em class="calibre22">Iostreams</em>, we discussed the POSIX concept of file descriptors. A file descriptor<br class="title-page-name"/>
represents a source or sink of data which can be targeted by <kbd class="calibre12">read</kbd> and/or <kbd class="calibre12">write</kbd>; often, but not always, it corresponds to a file on disk. (Recall that file descriptor number <kbd class="calibre12">1</kbd> refers to <kbd class="calibre12">stdout</kbd>, which is usually connected to the human user's screen. File descriptors can also refer to network sockets, devices such as <kbd class="calibre12">/dev/random</kbd>, and so on.)</p>
<p class="calibre2">Furthermore, POSIX file descriptors, <kbd class="calibre12">&lt;stdio.h&gt;</kbd>, and <kbd class="calibre12">&lt;iostream&gt;</kbd> are all concerned, specifically, with the <em class="calibre22">contents</em> of a file on disk (or wherever)<span>--</span>the sequence of bytes that makes up the <em class="calibre22">contents</em> of the file. A file in the <em class="calibre22">file</em><em class="calibre22">system</em> sense has many more salient attributes that are not exposed by the file-reading-and-writing APIs. We cannot use the APIs of <a href="part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 9</a>, <em class="calibre22">Iostreams</em>, to determine the ownership of a file, or its last-modified date; nor can we determine the number of files in a given directory. The purpose of <kbd class="calibre12">&lt;filesystem&gt;</kbd> is to allow our C++ programs to interact with these <em class="calibre22">filesystem</em> attributes in a portable, cross-platform way.</p>
<p class="calibre2">Let's begin again. What is a filesystem? A filesystem is an abstract mapping from <em class="calibre22">paths</em> to <em class="calibre22">files</em>, by means of <em class="calibre22">directory</em> <em class="calibre22">entries</em>. Perhaps a diagram will help, if you take it with a large grain of salt:</p>
<div class="cdpaligncenter"><img class="calibre40" src="../images/00025.jpeg"/></div>
<p class="calibre2">At the top of the preceding diagram, we have the somewhat abstract world of "names." We have a mapping from those names (such as <kbd class="calibre12">speech.txt</kbd>) onto concrete structures that POSIX calls <em class="calibre22">inodes</em>. The term "inode" is not used by the C++ standard--it uses the generic term "file"--but I will try to use the term inode when I want to be precise. Each inode contains a full set of attributes describing a single file on disk: its owner, its date of last modification, its <em class="calibre22">type</em>, and so on. Most importantly, the inode also tells exactly how big the file is, and gives a pointer to its actual contents (similarly to how a <kbd class="calibre12">std::vector</kbd> or <kbd class="calibre12">std::list</kbd> holds a pointer to <em class="calibre22">its</em> contents). The exact representation of inodes and blocks on disk depends on what kind of filesystem you're running; names of some common filesystems include ext4 (common on Linux), HFS+ (on OS X), and NTFS (on Windows).</p>
<p class="calibre2">Notice that a few of the blocks in that diagram hold data that is just a tabular mapping of <em class="calibre22">names</em> to <em class="calibre22">inode numbers</em>. This brings us full circle! A <em class="calibre22">directory</em> is just an inode with a certain <em class="calibre22">type</em>, whose contents are a tabular mapping of names to inode numbers. Each filesystem has one special well-known inode called its <em class="calibre22">root directory</em>.</p>
<p class="calibre2">Suppose that the inode labeled "<kbd class="calibre12">2</kbd>" in our diagram is the <em class="calibre22">root directory</em>. Then we can unambiguously identify the file containing "Now is the time..." by a path of names that leads from the root directory down to that file. For example, <kbd class="calibre12">/My Documents/speech.txt</kbd> is such a path: starting from the root directory, <kbd class="calibre12">My Documents</kbd> maps to inode 42, which is a directory where <kbd class="calibre12">speech.txt</kbd> maps to inode 17, which is a normal file whose contents on disk are "Now is the time...". We use slashes to compose these individual names into a single path, and we put a single slash on the front to indicate that we're starting from the root directory. (In Windows, each partition or drive has a separate root directory. So, instead of writing just <kbd class="calibre12">/My Documents/speech.txt</kbd>, we might write <kbd class="calibre12">c:/My Documents/speech.txt</kbd> to indicate that we're starting from drive C's root directory.)</p>
<p class="calibre2">Alternatively, "<kbd class="calibre12">/alices-speech.txt</kbd>" is a path leading straight from the root directory to inode 17. We say that these two paths ("<kbd class="calibre12">/My Documents/speech.txt</kbd>" and "<kbd class="calibre12">/alices-speech.txt</kbd>") are both <em class="calibre22">hard</em>-<em class="calibre22">links</em> for the same underlying inode, which is to say, the same underlying <em class="calibre22">file</em>. Some filesystems (such as the FAT filesystem used by many USB sticks) do not support having multiple hard links to the same file. When multiple hard links <em class="calibre22">are</em> supported, the filesystem must count the number of references to each inode so that it knows when it's safe to delete and free up an inode<span>--</span>in a procedure exactly analogous to the <kbd class="calibre12">shared_ptr</kbd> reference-counting we saw in <a href="part0093.html#2OM4A0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 6</a>, <em class="calibre22">Smart Pointers</em>.</p>
<p class="calibre2">When we ask a library function such as <kbd class="calibre12">open</kbd> or <kbd class="calibre12">fopen</kbd> to "open a file," this is the process it's going through deep down in the innards of the filesystem. It takes the filename you gave it and treats it as a <em class="calibre22">path</em><span>--</span>splits it up at the slashes, and descends into the directory structure of the filesystem until it finally reaches the inode of the file you asked for (or until it hits a dead end). Notice that once we have reached the inode, there is no longer any sense in asking "What is the name of this file?", as it has at least as many names as there are hard-links to it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Representing paths in C++</h1>
                
            
            <article>
                
<p class="calibre2">Throughout <a href="part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 9</a>, <em class="calibre22">Iostreams</em>, every function that expected a "filename" (that is, a path) as a parameter was happy to take that path as a simple const char <kbd class="calibre12">*</kbd>. But in the <kbd class="calibre12">&lt;filesystem&gt;</kbd> library, we're going to complicate that picture, all because of Windows.</p>
<p class="calibre2">All POSIX filesystems store names (like <kbd class="calibre12">speech.txt</kbd>) as simple raw byte strings. The only rules in POSIX are that your names can't contain <kbd class="calibre12">'\0'</kbd>, and your names can't contain <kbd class="calibre12">'/'</kbd> (because that's the character we're going to split on). On POSIX, <kbd class="calibre12">"\xC1.h"</kbd> is a perfectly valid filename, despite the fact that it is <em class="calibre22">not</em> valid UTF-8 and <em class="calibre22">not</em> valid ASCII, and the way it'll display on your screen when you <kbd class="calibre12">ls .</kbd> is completely dependent on your current locale and codepage. After all, it's just a string of three bytes, none of which are <kbd class="calibre12">'/'</kbd>.</p>
<p class="calibre2">On the other hand, Window'<span>s</span> native file APIs, such as <kbd class="calibre12">CreateFileW</kbd>, always store names as UTF-16. This means that, by definition, paths in Windows are always valid Unicode strings. This is a major philosophical difference between POSIX and NTFS! Let me say it again, slowly: In POSIX, file names are <em class="calibre22">strings of bytes</em>. In Windows, file names are <em class="calibre22">strings of Unicode characters</em>.</p>
<p class="calibre2">If you follow the general principle from <a href="part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 9</a>, <em class="calibre22">Iostreams</em> that everything in the world should be encoded with UTF-8, then the difference between POSIX and Windows will be manageable<span>--</span>maybe, even negligible. But if you are ever required to debug problems with strangely named files on one or the other system, keep in mind: In POSIX, filenames are strings of bytes. In Windows, filenames are strings of characters.</p>
<p class="calibre2">Since Windows APIs expect UTF-16 strings (<kbd class="calibre12">std::u16string</kbd>) and POSIX APIs expect byte strings (<kbd class="calibre12">std::string</kbd>), neither representation is exactly appropriate for a cross-platform library. So, <kbd class="calibre12">&lt;filesystem&gt;</kbd> invents a new type: <kbd class="calibre12">fs::path</kbd>. (Recall that we're using our namespace alias throughout this chapter. That's <kbd class="calibre12">std::filesystem::path</kbd> in reality.) <kbd class="calibre12">fs::path</kbd> looks something like this:</p>
<pre class="mce-root">    class path {<br class="title-page-name"/>    public:<br class="title-page-name"/>      using value_type = std::conditional_t&lt;<br class="title-page-name"/>        IsWindows, wchar_t, char<br class="title-page-name"/>      &gt;;<br class="title-page-name"/>      using string_type = std::basic_string&lt;value_type&gt;;<br class="title-page-name"/><br class="title-page-name"/>      const auto&amp; native() const { return m_path; }<br class="title-page-name"/>      operator string_type() const { return m_path; }<br class="title-page-name"/>      auto c_str() const { return m_path.c_str(); }<br class="title-page-name"/><br class="title-page-name"/>      // many constructors and accessors omitted<br class="title-page-name"/>    private:<br class="title-page-name"/>      string_type m_path;<br class="title-page-name"/>    };</pre>
<p class="calibre2">Notice that <kbd class="calibre12">fs::path::value_type</kbd> is <kbd class="calibre12">wchar_t</kbd> in Windows, even though C++11's UTF-16 character type <kbd class="calibre12">char16_t</kbd> would be more appropriate. This is just an artifact of the library's historical roots in Boost, which dates back to before C++11. In this chapter, whenever we talk about <kbd class="calibre12">wchar_t</kbd>, you can assume we're talking about UTF-16, and vice versa.</p>
<p class="calibre2">To write portable code, pay attention to the return type of any function you use to convert an <kbd class="calibre12">fs::path</kbd> to a string. For example, notice that the return type of <kbd class="calibre12">path.c_str()</kbd> is not the const char <kbd class="calibre12">*</kbd><span>--</span>it's const value_type <kbd class="calibre12">*</kbd>!</p>
<pre class="mce-root">    fs::path p("/foo/bar");<br class="title-page-name"/><br class="title-page-name"/>    const fs::path::value_type *a = p.c_str();<br class="title-page-name"/>      // Portable, for whatever that's worth.<br class="title-page-name"/><br class="title-page-name"/>    const char *b = p.c_str();<br class="title-page-name"/>      // OK on POSIX; compilation error on Windows.<br class="title-page-name"/><br class="title-page-name"/>    std::string s = p.u8string();<br class="title-page-name"/>    const char *c = s.c_str();<br class="title-page-name"/>      // OK on both POSIX and Windows.<br class="title-page-name"/>      // Performs 16-to-8 conversion on Windows.</pre>
<p class="calibre2">The preceding example, case <kbd class="calibre12">c</kbd>, is guaranteed to compile, but its behavior differs on the two platforms: in POSIX platforms, it'll give you the raw byte-string you want, and in Windows, it'll expensively convert <kbd class="calibre12">path.native()</kbd> from UTF-16 to UTF-8 (which is exactly what you asked for<span>--</span>but your program might be faster if you found a way to avoid asking).</p>
<p class="calibre2"><kbd class="calibre12">fs::path</kbd> has a templated constructor that can construct a <kbd class="calibre12">path</kbd> from just about any argument. The argument can be a sequence of any character type (<kbd class="calibre12">char</kbd>, <kbd class="calibre12">wchar_t</kbd>, <kbd class="calibre12">char16_t</kbd>, or <kbd class="calibre12">char32_t</kbd>), and that sequence can be expressed as a pointer to a null-terminated string, an <em class="calibre22">iterator</em> to a null-terminated string, a <kbd class="calibre12">basic_string</kbd>, a <kbd class="calibre12">basic_string_view</kbd>, or an iterator-pair. As usual, I mention this huge variety of overloads not because you'll want to use any of them beyond the basics, but so that you'll know how to avoid them.</p>
<p class="calibre2">The standard also provides the free function <kbd class="calibre12">fs::u8path("path")</kbd>, which is just a synonym for <kbd class="calibre12">fs::path("path")</kbd>, but might serve as a reminder that the string you're passing in is supposed to be UTF-8-encoded. I recommend ignoring <kbd class="calibre12">u8path</kbd>.</p>
<p class="calibre2">This all might sound scarier than it is. Bear in mind that if you stick to ASCII filenames, you won't need to worry about encoding issues; and if you remember to avoid the "native" accessor methods, <kbd class="calibre12">path.native()</kbd> and <kbd class="calibre12">path.c_str()</kbd>, and avoid the implicit conversion to <kbd class="calibre12">fs::path::string_type</kbd>, then you won't have to worry too much about portability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Operations on paths</h1>
                
            
            <article>
                
<p class="calibre2">Once we have a path object, we can query it for many useful combinations of its slash-separated components. In the following code snippet, each identifier <kbd class="calibre12">x</kbd> (except <kbd class="calibre12">path</kbd> itself) represents the return value of the member function <kbd class="calibre12">path.x()</kbd>:</p>
<pre class="mce-root">    assert(root_path == root_name / root_directory);<br class="title-page-name"/>    assert(path == root_name / root_directory / relative_path);<br class="title-page-name"/>    assert(path == root_path / relative_path);<br class="title-page-name"/><br class="title-page-name"/>    assert(path == parent_path / filename);<br class="title-page-name"/>    assert(filename == stem + extension);<br class="title-page-name"/><br class="title-page-name"/>    assert(is_absolute == !is_relative);<br class="title-page-name"/>    if (IsWindows) {<br class="title-page-name"/>      assert(is_relative == (root_name.empty() ||  <br class="title-page-name"/>    root_directory.empty()));<br class="title-page-name"/>    } else {<br class="title-page-name"/>      assert(is_relative == (root_name.empty() &amp;&amp;  <br class="title-page-name"/>    root_directory.empty()));<br class="title-page-name"/>    }</pre>
<p class="calibre2">So, for example, given the path <kbd class="calibre12">p = "c:/foo/hello.txt"</kbd>, we have <kbd class="calibre12">p.root_name() == "c:"</kbd>, <kbd class="calibre12">p.root_directory() == "/"</kbd>, <kbd class="calibre12">p.relative_path() == "foo/hello.txt"</kbd>, <kbd class="calibre12">p.stem() == "hello"</kbd>, and <kbd class="calibre12">p.extension() == ".txt"</kbd>. At least, that's what we'd have in Windows! Notice that in Windows, an absolute path requires both a root name and a root directory (neither "<kbd class="calibre12">c:foo/hello.txt</kbd>" nor "<kbd class="calibre12">/foo/hello.txt</kbd>" is an absolute path), whereas, in POSIX, where root names don't exist, an absolute path requires only a root directory ("<kbd class="calibre12">/foo/hello.txt</kbd>" is an absolute path, and "<kbd class="calibre12">c:foo/hello.txt</kbd>" is a relative path that starts with the funny-looking directory name "<kbd class="calibre12">c:foo</kbd>").</p>
<p class="calibre2">In the last code snippet, we use <kbd class="calibre12">operator/</kbd> to concatenate paths. <kbd class="calibre12">fs::path</kbd> supports both <kbd class="calibre12">operator/</kbd> and <kbd class="calibre12">operator/=</kbd> for this purpose, and they do almost exactly what you'd expect<span>--</span>concatenate two pieces of a path with a slash in between them. If you want to concatenate pieces of a path without adding that slash, use <kbd class="calibre12">operator+=</kbd>. Unfortunately, the C++17 standard library is missing <kbd class="calibre12">operator+</kbd> for paths, but it's easy to add as a free function, as follows:</p>
<pre class="mce-root">    static fs::path operator+(fs::path a, const fs::path&amp; b)<br class="title-page-name"/>    {<br class="title-page-name"/>      a += b;<br class="title-page-name"/>      return a;<br class="title-page-name"/>    }</pre>
<p class="calibre2">Paths also support concatenation with and without slashes under the confusing member-function names <kbd class="calibre12">path.concat("foo")</kbd> (without slash) and <kbd class="calibre12">path.append("foo")</kbd>(with slash). Beware that this is exactly backwards from what you'd expect! Therefore, I strongly advise never to use the named member functions; always use the operators (perhaps including your custom-defined <kbd class="calibre12">operator+</kbd> as described in the preceding code).</p>
<p class="calibre2">The last potentially confusing thing about <kbd class="calibre12">fs::path</kbd> is that it provides <kbd class="calibre12">begin</kbd> and <kbd class="calibre12">end</kbd> methods, just like <kbd class="calibre12">std::string</kbd>. But unlike <kbd class="calibre12">std::string</kbd>, the unit of iteration is not the single character<span>--</span>the unit of iteration is the <em class="calibre22">name</em>! This is seen in the following example:</p>
<pre class="mce-root">    fs::path p = "/foo/bar/baz.txt";<br class="title-page-name"/>    std::vector&lt;fs::path&gt; v(p.begin(), p.end());<br class="title-page-name"/>    assert((v == std::vector&lt;fs::path&gt;{<br class="title-page-name"/>      "/", "foo", "bar", "baz.txt"<br class="title-page-name"/>    }));</pre>
<p class="calibre2">You'll never have a reason to iterate over an absolute <kbd class="calibre12">fs::path</kbd> in real code. Iterating over <kbd class="calibre12">p.relative_path().parent_path()</kbd><span>--</span>where every iterated element is guaranteed to be a directory name<span>--</span>might have some value in unusual circumstances.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Statting files with directory_entry</h1>
                
            
            <article>
                
<div class="packt_tip">Beware! <kbd class="calibre25">directory_entry</kbd> is the most bleeding-edge part of the C++17 <kbd class="calibre25">&lt;filesystem&gt;</kbd> library. What I am about to describe is neither implemented by Boost, nor by <kbd class="calibre25">&lt;experimental/filesystem&gt;</kbd>.</div>
<p class="calibre2">Retrieving a file's metadata from its inode is done by querying an object of type <kbd class="calibre12">fs::directory_entry</kbd>. If you're familiar with the POSIX approach to retrieving metadata, imagine that a <kbd class="calibre12">fs::directory_entry</kbd> contains a member of <kbd class="calibre12">type fs::path</kbd> and a member of type <kbd class="calibre12">std::optional&lt;struct stat&gt;</kbd>. Calling <kbd class="calibre12">entry.refresh()</kbd> is, basically, the same thing as calling the POSIX function <kbd class="calibre12">stat()</kbd>; and calling any <kbd class="calibre12">accessor</kbd> method, such as <kbd class="calibre12">entry.file_size()</kbd>, will implicitly call <kbd class="calibre12">stat()</kbd> if and only if the optional member is still disengaged. Merely constructing an instance of <kbd class="calibre12">fs::directory_entry</kbd> won't query the filesystem; the library waits until you ask a specific question before it acts. Asking a specific question, such as <kbd class="calibre12">entry.file_size()</kbd>, may cause the library to query the filesystem, or (if the optional member is already engaged) it might just use the cached value from the last time it queried.</p>
<pre class="mce-root">    fs::path p = "/tmp/foo/bar.txt";<br class="title-page-name"/>    fs::directory_entry entry(p);<br class="title-page-name"/>      // Here, we still have not touched the filesystem.<br class="title-page-name"/><br class="title-page-name"/>    while (!entry.exists()) {<br class="title-page-name"/>       std::cout &lt;&lt; entry.path() &lt;&lt; " does not exist yet\n";<br class="title-page-name"/>       std::this_thread::sleep_for(100ms);<br class="title-page-name"/>       entry.refresh();<br class="title-page-name"/>         // Without refresh(), this would loop forever.<br class="title-page-name"/>    }<br class="title-page-name"/>      // If the file is deleted right now, the following<br class="title-page-name"/>      // line might print stale cached values, or it<br class="title-page-name"/>      // might try to refresh the cache and throw.<br class="title-page-name"/>    std::cout &lt;&lt; entry.path() &lt;&lt; " has size "<br class="title-page-name"/>          &lt;&lt; entry.file_size() &lt;&lt; "\n";</pre>
<p class="calibre2">An older way to accomplish the same goal is to use <kbd class="calibre12">fs::status("path")</kbd> or <kbd class="calibre12">fs::symlink_status("path")</kbd> to retrieve an instance of the class <kbd class="calibre12">fs::file_status</kbd>, and then to pull information out of the <kbd class="calibre12">file_status</kbd> object via cumbersome operations such as <kbd class="calibre12">status.type() == fs::file_type::directory</kbd>. I recommend you not try to use <kbd class="calibre12">fs::file_status</kbd>; prefer to use <kbd class="calibre12">entry.is_directory()</kbd> and so on. For the masochistic, you can still retrieve a <kbd class="calibre12">fs::file_status</kbd> instance directly from a <kbd class="calibre12">directory_entry</kbd>: <kbd class="calibre12">entry.status()</kbd> is the equivalent of <kbd class="calibre12">fs::status(entry.path())</kbd>, and <kbd class="calibre12">entry.symlink_status()</kbd> is the equivalent of <kbd class="calibre12">fs::symlink_status(entry.path())</kbd>, which, in turn, is a slightly faster equivalent of<br class="title-page-name"/>
<kbd class="calibre12">fs::status(entry.is_symlink() ? fs::read_symlink(entry.path()) : entry.path())</kbd>.</p>
<p class="calibre2">Incidentally, the free function <kbd class="calibre12">fs::equivalent(p, q)</kbd> can tell you if two paths are both hard-linked to the same inode; and <kbd class="calibre12">entry.hard_link_count()</kbd> can tell you the total number of hard-links to this particular inode. (The only way to determine the <em class="calibre22">names</em> of those hard-links is to walk the entire filesystem; and even then, your current user account might not have the permission to stat those paths.)</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Walking directories with directory_iterator</h1>
                
            
            <article>
                
<p class="calibre2">A <kbd class="calibre12">fs::directory_iterator</kbd> is just what it says on the tin. An object of this type lets you walk the contents of a single directory, entry by entry:</p>
<pre class="mce-root">    fs::path p = fs::current_path();<br class="title-page-name"/>      // List the current directory.<br class="title-page-name"/>    for (fs::directory_entry entry : fs::directory_iterator(p)) {<br class="title-page-name"/>      std::cout &lt;&lt; entry.path().string() &lt;&lt; ": "<br class="title-page-name"/>      &lt;&lt; entry.file_size() &lt;&lt; " bytes\n";<br class="title-page-name"/>    }</pre>
<p class="calibre2">Incidentally, notice the use of <kbd class="calibre12">entry.path().string()</kbd> in the preceding code. This is required, because <span><kbd class="calibre12">operator&lt;&lt;</kbd></span> acts extremely bizarrely on path objects<span>--</span>it always outputs as if you'd written <kbd class="calibre12">std::quoted(path.string())</kbd>. If you want the path itself, with no extra quotes, you always have to convert to <kbd class="calibre12">std::string</kbd> before outputting. (Similarly, <kbd class="calibre12">std::cin &gt;&gt; path</kbd> won't work to get a path from the user, but that's less obnoxious, since you should never use <kbd class="calibre12">operator&gt;&gt;</kbd> anyway. See <a href="part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapters 9</a>, <em class="calibre22">Iostreams</em>, and <a href="part0161.html#4PHAI0-2fdac365b8984feebddfbb9250eaf20d" class="calibre4">Chapter 10</a>, <em class="calibre22">Regular Expressions</em>, for more information on lexing and parsing input from the user.)</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Recursive directory walking</h1>
                
            
            <article>
                
<p class="calibre2">To recurse down a whole directory tree, in the style of Python's <kbd class="calibre12">os.walk()</kbd>, you can use this recursive function modeled on the previous code snippet:</p>
<pre class="mce-root">    template&lt;class F&gt;<br class="title-page-name"/>    void walk_down(const fs::path&amp; p, const F&amp; callback)<br class="title-page-name"/>    {<br class="title-page-name"/>      for (auto entry : fs::directory_iterator(p)) {<br class="title-page-name"/>        if (entry.is_directory()) {<br class="title-page-name"/>          walk_down(entry.path(), callback);<br class="title-page-name"/>        } else {<br class="title-page-name"/>          callback(entry);<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">Or, you can simply use a <kbd class="calibre12">fs::recursive_directory_iterator</kbd>:</p>
<pre class="mce-root">    template&lt;class F&gt;<br class="title-page-name"/>    void walk_down(const fs::path&amp; p, const F&amp; callback)<br class="title-page-name"/>    {<br class="title-page-name"/>      for (auto entry : fs::recursive_directory_iterator(p)) {<br class="title-page-name"/>        callback(entry);<br class="title-page-name"/>      }<br class="title-page-name"/>    }</pre>
<p class="calibre2">The constructor of <kbd class="calibre12">fs::recursive_directory_iterator</kbd> can take an extra argument of type <kbd class="calibre12">fs::directory_options</kbd>, which modifies the exact nature of the recursion. For example, you can pass <kbd class="calibre12">fs::directory_options::follow_directory_symlink</kbd> to follow symlinks, although this is a good way to wind up in an infinite loop if a malicious user creates a symlink pointing back to its own parent directory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Modifying the filesystem</h1>
                
            
            <article>
                
<p class="calibre2">Most of the <kbd class="calibre12">&lt;filesystem&gt;</kbd> header's facilities are concerned with examining the filesystem, not modifying it. But there are several gems hidden in the rubble. Many of these functions seem designed to make the effects of the classic POSIX command-line utilities available in portable C++:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre12">fs::copy_file(old_path, new_path)</kbd> : Copy the file at <kbd class="calibre12">old_path</kbd> to a new file (that is, a new inode) at <kbd class="calibre12">new_path</kbd>, as if by <kbd class="calibre12">cp -n</kbd>. Error if <kbd class="calibre12">new_path</kbd> already exists.</li>
<li class="calibre15"><kbd class="calibre12">fs::copy_file(old_path, new_path, fs::copy_options::overwrite_existing)</kbd>: Copy <kbd class="calibre12">old_path</kbd> to <kbd class="calibre12">new_path</kbd>. Overwrite <kbd class="calibre12">new_path</kbd> if possible. Error if <kbd class="calibre12">new_path</kbd> exists and is not a regular file, or if it's the same as <kbd class="calibre12">old_path</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">fs::copy_file(old_path, new_path, fs::copy_options::update_existing)</kbd>: Copy <kbd class="calibre12">old_path</kbd> to <kbd class="calibre12">new_path</kbd>. Overwrite <kbd class="calibre12">new_path</kbd> if and only if it's older than the file at <kbd class="calibre12">old_path</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">fs::copy(old_path, new_path, fs::copy_options::recursive | fs::copy_options::copy_symlinks)</kbd>: Copy an entire directory from <kbd class="calibre12">old_path</kbd> to <kbd class="calibre12">new_path</kbd> as if by <kbd class="calibre12">cp -R</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">fs::create_directory(new_path)</kbd>: Create a directory as if by <kbd class="calibre12">mkdir</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">fs::create_directories(new_path)</kbd>: Create a directory as if by mkdir <kbd class="calibre12">-p</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">fs::create_directory(new_path, old_path)</kbd> (notice the reversal of the arguments!): Create a directory, but copy its attributes from those of the directory at <kbd class="calibre12">old_path</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">fs::create_symlink(old_path, new_path)</kbd>: Create a symlink from <kbd class="calibre12">new_path</kbd> to <kbd class="calibre12">old_path</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">fs::remove(path)</kbd>: Remove a file or an empty directory as if by <kbd class="calibre12">rm</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">fs::remove_all(path)</kbd>: Remove a file or directory as if by <kbd class="calibre12">rm -r</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">fs::rename(old_path, new_path)</kbd>: Rename a file or directory as if by <kbd class="calibre12">mv</kbd>.</li>
<li class="calibre15"><kbd class="calibre12">fs::resize_file(path, new_size)</kbd>: Extend (with zeroes) or truncate a regular file.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Reporting disk usage</h1>
                
            
            <article>
                
<p class="calibre2">Speaking of classic command-line utilities, one final thing we might want to do with a filesystem is ask how full it is. This is the domain of the command-line utility <kbd class="calibre12">df -h</kbd> or the POSIX library function <kbd class="calibre12">statvfs</kbd>. In C++17, we can do it with <kbd class="calibre12">fs::space("path")</kbd>, which returns (by value) a struct of type <kbd class="calibre12">fs::space_info</kbd>:</p>
<pre class="mce-root1"> struct space_info {<br class="title-page-name"/>    uintmax_t capacity;<br class="title-page-name"/>    uintmax_t free;<br class="title-page-name"/>    uintmax_t available;<br class="title-page-name"/> };</pre>
<p class="calibre2">Each of these fields is measured in bytes, and we should have <kbd class="calibre12">available &lt;= free &lt;= capacity</kbd>. The distinction between <kbd class="calibre12">available</kbd> and <kbd class="calibre12">free</kbd> has to do with user limits: On some filesystems, a portion of the free space might be reserved for the root user, and on others, there might be per-user-account disk quotas.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">Use namespace aliases to save typing, and to allow dropping in alternative implementations<br class="title-page-name"/>
of a library namespace, such as Boost.</p>
<p class="calibre2"><kbd class="calibre12">std::error_code</kbd> provides a very neat way to pass integer error codes up the stack without exception handling; consider using it if you work in a domain where exception handling is frowned upon. (In which case, that is likely <em class="calibre22">all</em> you will be able to take away from this particular chapter! <span>The <kbd class="calibre12">&lt;filesystem&gt;</kbd> library provides both throwing and non-throwing APIs; however,</span> <span>both APIs use the heap-allocating (and, potentially, throwing <kbd class="calibre12">fs::path</kbd> as a vocabulary type. The only reason to use the non-throwing API is if it eliminates a case of</span> <span>"using exceptions for control flow.</span>)</p>
<p class="calibre2"><kbd class="calibre12">std::error_condition</kbd> provides only syntactic sugar for "catching" error codes; avoid it like the plague.</p>
<p class="calibre2">A <kbd class="calibre12">path</kbd> consists of a <kbd class="calibre12">root_name</kbd>, a <kbd class="calibre12">root_directory</kbd>, and a <kbd class="calibre12">relative_path</kbd>; the last of these is made up of <em class="calibre22">names</em> separated by slashes. To POSIX, a <em class="calibre22">name</em> is a string of raw bytes; to Windows, a <em class="calibre22">name</em> is a string of Unicode characters. The <kbd class="calibre12">fs::path</kbd> type attempts to use the appropriate kind of string for each platform. To avoid portability problems, beware of <kbd class="calibre12">path.c_str()</kbd> and implicit conversions to <kbd class="calibre12">fs::path::string_type</kbd>.</p>
<p class="calibre2">Directories store mappings from <em class="calibre22">names</em> to <em class="calibre22">inodes</em> (which the C++ standard just calls "files"). In C++, you can loop over an <kbd class="calibre12">fs::directory_iterator</kbd> to retrieve <kbd class="calibre12">fs::directory_entry</kbd> objects; methods on the <kbd class="calibre12">fs::directory_entry</kbd> allow you to query the corresponding inode. Restatting an inode is as simple as calling <kbd class="calibre12">entry.refresh()</kbd>.</p>
<p class="calibre2"><kbd class="calibre12">&lt;filesystem&gt;</kbd> provides a whole zoo of free functions for creating, copying, renaming, removing, and resizing files and directories, and one last function to get the total capacity of the filesystem.</p>
<p class="calibre2">Much of what was discussed in this chapter (the <kbd class="calibre12">&lt;filesystem&gt;</kbd> parts, at least) is bleeding-edge C++17 that, as of press time, has not been implemented by any compiler vendor. Use such new features with caution.</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>


            </article>

            
        </section>
    </body></html>