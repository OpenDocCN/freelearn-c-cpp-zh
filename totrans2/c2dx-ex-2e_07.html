<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Adding the Looks – Victorian Rush Hour</h1></div></div></div><p class="calibre6">
<em class="calibre8">Now that we have our test game, it's time to make it all pretty! We'll go over the new sprite elements added to make the game look nice, and cover a new topic or two. However, by now, you should be able to understand everything in the final code of this project.</em>
</p><p class="calibre6">
<em class="calibre8">So you can sit back and relax a bit. This time, I won't make you type so much. Promise!</em>
</p><p class="calibre6">In this chapter, you will learn:</p><div><ul class="itemizedlist"><li class="listitem">How to use multiple sprites to texture a tiled terrain</li><li class="listitem">How to use multiple containers inside <code class="email">SpriteBatchNode</code></li><li class="listitem">How to create a parallax effect</li><li class="listitem">How to add a menu to your game</li><li class="listitem">How to build a game tutorial</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec99" class="calibre1"/>Victorian Rush Hour – the game</h1></div></div></div><p class="calibre6">Download <a id="id262" class="calibre1"/>the <code class="email">4198_07_START_PROJECT.zip</code> file from this book's <strong class="calibre7">Support</strong> page (<a class="calibre1" href="http://www.packtpub.com/support">www.packtpub.com/support</a>) and run the project in Xcode. You should be able to recognize all the work we did in the test version, and pinpoint the few extra elements. You will also see that nothing was added to the actual gameplay.</p><p class="calibre6">In <em class="calibre8">Victorian Rush Hour</em>, I wanted to make the terrain the main challenge in the game, but I also wanted to show you how easily you can add new elements to the buildings and interact with them.</p><p class="calibre6">You can later use the same logic to add enemies, obstacles, or pickups for the cyclist sprite. All you need to do really is extend the collision detection logic to check for the new items. You<a id="id263" class="calibre1"/> could, for instance, add umbrellas as pickups, and every time the <code class="email">_player</code> object floated, he would be minus one umbrella.</p><p class="calibre6">Next, I'll list the new elements added to the game.</p><div><img src="img/00024.jpeg" alt="Victorian Rush Hour – the game" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec85" class="calibre1"/>New sprites</h2></div></div></div><p class="calibre6">Quite a few <a id="id264" class="calibre1"/>sprites were added to our game:</p><div><ul class="itemizedlist"><li class="listitem">There is a group of cyclists at the beginning of the game representing the traffic.</li><li class="listitem">We add a background layer (<code class="email">cityscape</code>) and a foreground layer (<code class="email">lamp posts</code>) to help us with our parallax effect. The clouds in the background are also part of the effect.</li><li class="listitem">We add chimneys to the buildings. These puff smoke as the player taps the screen.</li><li class="listitem">And, of course, the usual stuff—score label, game logo, and a game over message.<p class="calibre13">In the following screenshot, you can see an image of the <code class="email">player</code> sprite and the group of cyclists:</p><div><img src="img/00025.jpeg" alt="New sprites" class="calibre9"/></div><p class="calibre14"> </p></li></ul></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec86" class="calibre1"/>Animations</h2></div></div></div><p class="calibre6">Some <a id="id265" class="calibre1"/>of the sprites now run animation actions:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="email">_player</code> sprite runs an animation showing him riding the bicycle (<code class="email">_rideAnimation</code>).</li><li class="listitem">I also added our old friend, the swinging animation, shown when the <code class="email">_player</code> sprite is floating (<code class="email">_floatAnimation</code>). This is the reason for the odd registration point on the cyclist sprite, as the swing animation looks better if the sprite's anchor point is not centered.</li><li class="listitem">Our group of cyclists is also animated during the introduction section of the game, and is moved offscreen when the game starts (<code class="email">_jamAnimate</code>, <code class="email">_jamMove</code>).</li><li class="listitem">We show a puff of smoke coming out of the chimneys whenever the player jumps. This animation is stored inside the new <code class="email">Block.cpp</code> class and it's created through a series of actions, including a frame animation (<code class="email">_puffAnimation</code>, <code class="email">_puffSpawn</code>, <code class="email">_puffMove</code>, <code class="email">_puffFade</code>, and <code class="email">_puffScale</code>).</li><li class="listitem">In <code class="email">GameLayer.cpp</code>, when the <code class="email">_player</code> object dies, we run a few actions on a <code class="email">_hat</code> sprite to make it rise in the air and drop down again, just to add some humor.</li></ul></div><p class="calibre6">Now let's go over the added logic.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec100" class="calibre1"/>Texturing our buildings with sprites</h1></div></div></div><p class="calibre6">So in <a id="id266" class="calibre1"/>the test version we just coded, our game screen was divided into tiles of 128 pixels in the iPad retina screen. The width and height properties of the <code class="email">Block</code> objects are based on this measurement. So a building two tiles wide and three tiles tall would have, in effect, 256 pixels in width and 384 pixels in height. A gap too would be measured this way, though its height is set to <code class="email">0</code>.</p><p class="calibre6">The logic we use to texture the buildings will take these tiles into account.</p><div><img src="img/00026.jpeg" alt="Texturing our buildings with sprites" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">So let's take a look at the code to add texture to our buildings.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec101" class="calibre1"/>Time for action – texturing the buildings</h1></div></div></div><p class="calibre6">There<a id="id267" class="calibre1"/> are a few changes to the way the <code class="email">initBlock</code> method runs now:</p><div><ol class="orderedlist"><li class="listitem" value="1">Each block will store references to four different types of texture, representing the four types of buildings used in the game (<code class="email">_tile1</code>, <code class="email">_tile2</code>, <code class="email">_tile3</code>, and <code class="email">_tile4</code>). So we now store that information in the <code class="email">initBlock</code> method:<div><pre class="programlisting">void Block::initBlock() {

  _tile1 = SpriteFrameCache::getInstance()- &gt;getSpriteFrameByName ("building_1.png");
  _tile2 = SpriteFrameCache::getInstance()- &gt;getSpriteFrameByName ("building_2.png");
  _tile3 = SpriteFrameCache::getInstance()- &gt;getSpriteFrameByName ("building_3.png");
  _tile4 = SpriteFrameCache::getInstance()- &gt;getSpriteFrameByName ("building_4.png");</pre></div></li><li class="listitem" value="2">Each block also stores references to two types of textures for the building roof tile (<code class="email">_roof1</code> and <code class="email">_roof2</code>):<div><pre class="programlisting">_roof1 = SpriteFrameCache::getInstance()-&gt; getSpriteFrameByName ("roof_1.png");
  _roof2 = SpriteFrameCache::getInstance()- &gt;getSpriteFrameByName ("roof_2.png");</pre></div></li><li class="listitem" value="3">Next, we create and distribute the various sprite tiles that form our building:<div><pre class="programlisting">//create tiles
for (int i = 0; i &lt; 5; i++) {
   auto tile = Sprite::createWithSpriteFrameName("roof_1.png");
   tile-&gt;setAnchorPoint(Vec2(0, 1));
   tile-&gt;setPosition(Vec2(i * _tileWidth, 0));
   tile-&gt;setVisible(false);
   this-&gt;addChild(tile, kMiddleground, kRoofTile);
   _roofTiles.pushBack(tile);
   for (int j = 0; j &lt; 4; j++) {
      tile =  Sprite::createWithSpriteFrameName("building_1.png");
      tile-&gt;setAnchorPoint(Vec2(0, 1));
      tile-&gt;setPosition(Vec2(i * _tileWidth, -1 *  (_tileHeight * 0.47f + j * _tileHeight)));
      tile-&gt;setVisible(false);
      this-&gt;addChild(tile, kBackground, kWallTile);
      _wallTiles.pushBack(tile);
   }
}</pre></div><p class="calibre13">A block comprises 20 sprites stored inside a <code class="email">_wallTiles</code> vector and five sprites<a id="id268" class="calibre1"/> stored in a <code class="email">_roofTiles</code> vector. So, when we initialize a <code class="email">Block</code> object, we in effect create a building that is five tiles wide and four tiles tall. I made the decision that no building in the game would exceed this size. If you decide to change this, then here is where you would need to do it.</p></li><li class="listitem" value="4">The <code class="email">initBlock</code> method also creates five chimney sprites and places them at the top of the building. These will be spread out later according to the building type and could be very easily turned into obstacles for our <code class="email">_player</code> sprite. We also create the animation actions for the puffs of smoke, here inside <code class="email">initBlock</code>.</li><li class="listitem" value="5">Moving on to our new <code class="email">setupBlock</code> method, this is where the unnecessary tiles and chimneys are turned invisible and where we spread out the visible chimneys. We begin the method as follows:<div><pre class="programlisting">void Block::setupBlock (int width, int height, int type) {
  
  this-&gt;setPuffing(false);
  
  _type = type;

  _width = width * _tileWidth;
  //add the roof height to the final height of the block
  _height = height * _tileHeight + _tileHeight * 0.49f;
  this-&gt;setPositionY(_height);

  SpriteFrame * wallFrame;
  SpriteFrame * roofFrame = rand() % 10 &gt; 6 ? _roof1 :  _roof2;

  int num_chimneys;
  float chimneyX[] = {0,0,0,0,0};</pre></div></li><li class="listitem" value="6">Then, based on building type, we give different <code class="email">x</code> positions for the chimney sprites and determine the texture we'll use on the wall tiles:<div><pre class="programlisting">switch (type) {

  case kBlockGap:
    this-&gt;setVisible(false);
    return;

  case kBlock1:
    wallFrame = _tile1;
    chimneyX[0] = 0.2f;
    chimneyX[1] = 0.8f;
    num_chimneys = 2;
    break;
  case kBlock2:
    wallFrame = _tile2;
    chimneyX[0] = 0.2f;
     chimneyX[1] = 0.8f;
    chimneyX[2] = 0.5f;
    num_chimneys = 3;
    break;
  case kBlock3:
    wallFrame = _tile3;
    chimneyX[0] = 0.2f;
    chimneyX[1] = 0.8f;
    chimneyX[2] = 0.5f;
    num_chimneys = 3;

    break;
  case kBlock4:
    wallFrame = _tile4;
    chimneyX[0] = 0.2f;
    chimneyX[1] = 0.5f;
    num_chimneys = 2;
    break;
}</pre></div></li><li class="listitem" value="7">The <a id="id269" class="calibre1"/>method then proceeds to position the visible chimneys. And we finally move to texturing the building. The logic to texture the roof and wall tiles is the same; for instance, here's how the walls are tiled by changing the texture of each wall sprite through the <code class="email">setDisplayFrame</code> method and then turning unused tiles invisible:<div><pre class="programlisting">count = _wallTiles-&gt;count();
  for (i  = 0; i &lt; count; i++) {
    tile = (Sprite *) _wallTiles-&gt;objectAtIndex(i);
    if (tile-&gt;getPositionX() &lt; _width &amp;&amp; tile -&gt;getPositionY() &gt; -_height) {
      tile-&gt;setVisible(true);
      tile-&gt;setDisplayFrame(wallFrame);
    } else {
      tile-&gt;setVisible(false);
    }
  }
}</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec87" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">When we instantiate a block in <code class="email">initBlock</code>, we create a 5 x 4 building made out of wall tiles and roof tiles, each a sprite. And when we need to turn this building into a 3 x 2 building, or<a id="id270" class="calibre1"/> a 4 x 4 building, or whatever, we simply turn the excess tiles invisible at the end of <code class="email">setupBlock</code>.</p><p class="calibre6">The texture used for the roof is picked randomly, but the one picked for the walls is based on building type (from our <code class="email">patterns</code> array). It is also inside this <code class="email">for</code> loop that all the tiles positioned at a point greater than the new building's width and height are turned invisible.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec102" class="calibre1"/>Containers within containers</h1></div></div></div><p class="calibre6">Before <a id="id271" class="calibre1"/>we move to the parallax effect logic, there is something I wanted to talk about related to the layering of our <code class="email">_gameBatchNode</code> object, which you'll recall is a <code class="email">SpriteBatchNode</code> object.</p><p class="calibre6">If you go to the static <code class="email">create</code> method inside <code class="email">Terrain.cpp</code>, you will notice that the object is still created with a reference to a <code class="email">blank.png</code> texture:</p><div><pre class="programlisting">terrain-&gt;initWithSpriteFrameName("blank.png")</pre></div><p class="calibre6">In fact, the same 1 x 1 pixel image used in the test version is now in our sprite sheet, only this time the image is transparent.</p><p class="calibre6">This is a bit of a hack, but necessary, because a sprite can only be placed inside a batch node if its texture source is the same used to create the batch node. But <code class="email">Terrain</code> is just a container, it has no texture. However, by setting its <code class="email">blank</code> texture to something contained in our sprite sheet, we can place <code class="email">_terrain</code> inside <code class="email">_gameBatchNode</code>.</p><p class="calibre6">The same thing is done with the <code class="email">Block</code> class, which now, in the final version of the game, behaves like another textureless container. It will contain the various sprites for the wall and roof tiles as well as chimneys and puff animations as its children.</p><p class="calibre6">The organization of the layers inside our <code class="email">_gameBatchNode</code> object can seem complex and at times even absurd. After all, in the same node, we have a foreground "layer" of lampposts, a middle-ground "layer" of buildings, and a background "layer" containing a cityscape. The player is also placed in the background but on top of the cityscape. Not only that, but all three layers are moved at different speeds to create our parallax effect, and all this inside the same <code class="email">SpriteBatchNode</code>!</p><p class="calibre6">But the amount of code this arrangement saves us justifies any confusion we might have at times when attempting to keep the batch node organized. Now we can animate the puffs of smoke, for instance, and never worry about keeping them "attached" to their respective <code class="email">chimney</code> sprite as the terrain scrolls to the left. The container will take care of keeping things together.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec103" class="calibre1"/>Creating a parallax effect</h1></div></div></div><p class="calibre6">Cocos2d-x has a special node called <code class="email">ParallaxNode</code>, and one surprising thing about it is how<a id="id272" class="calibre1"/> little you get to use it! <code class="email">ParallaxNode</code> helps create a parallax effect with finite layers, or finite scrolling, which means that you can use it if your game screen has a limit to how much it can scroll each way. Implementing <code class="email">ParallaxNode</code> to a game screen that can scroll indefinitely, such as the one in <em class="calibre8">Victorian Rush Hour</em>, usually requires more effort than it takes to build your own effect.</p><p class="calibre6">A parallax effect is created by moving objects at different depths at different speeds. The farther a layer appears from the screen, the slower its speed should be. In a game, this usually means that the player sprite's speed is fractioned to all the layers that appear behind it, and multiplied for the layers that appear in front of the player sprite:</p><div><img src="img/00027.jpeg" alt="Creating a parallax effect" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">Let's add this to our game.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec104" class="calibre1"/>Time for action – creating a parallax effect</h1></div></div></div><p class="calibre6">The <a id="id273" class="calibre1"/>parallax effect in our game takes place inside the main loop:</p><div><ol class="orderedlist"><li class="listitem" value="1">So in our <code class="email">update</code> method, you will find the following lines of code:<div><pre class="programlisting">if (_player-&gt;getVector().x &gt; 0) {
  _background-&gt;setPositionX(_background-&gt;getPosition().x -  _player-&gt;getVector().x * 0.25f);</pre></div><p class="calibre13">First, we move the <code class="email">_background</code> sprite, which contains the cityscape texture repeated three times along the <code class="email">x</code> axis, and we move it at one-fourth of the speed of the <code class="email">_player</code> sprite.</p></li><li class="listitem" value="2">The <code class="email">_background</code> sprite scrolls to the left, and as soon as the first cityscape texture is off the screen, we shift the entire <code class="email">_background</code> container to the right at precisely the spot where the second cityscape texture would appear if allowed to continue. We get this value by subtracting where the sprite would be from the total width of the sprite:<div><pre class="programlisting">float diffx;
  
if (_background-&gt;getPositionX() &lt; -_background -&gt;getContentSize().width) {
  diffx = fabs(_background-&gt;getPositionX()) - _background -&gt;getContentSize().width;
  _background-&gt;setPositionX(-diffx);
}</pre></div><p class="calibre13">So, in effect, we only ever scroll the first texture sprite inside the container.</p></li><li class="listitem" value="3">A <a id="id274" class="calibre1"/>similar process is<a id="id275" class="calibre1"/> repeated with the <code class="email">_foreground</code> sprite and the three lamppost sprites it contains. Only the <code class="email">_foreground</code> sprite moves at four times the speed of the <code class="email">_player</code> sprite. These are coded as follows:<div><pre class="programlisting">_foreground-&gt;setPositionX(_foreground-&gt;getPosition().x - _player-&gt;getVector().x * 4);
  
if (_foreground-&gt;getPositionX() &lt; -_foreground -&gt;getContentSize().width * 4) {
  diffx = fabs(_foreground-&gt;getPositionX()) - _foreground -&gt;getContentSize().width * 4;
  _foreground-&gt;setPositionX(-diffx);
}</pre></div></li><li class="listitem" value="4">We also employ our <code class="email">cloud</code> sprites in the parallax effect. Since they appear behind the cityscape, so even farther away from <code class="email">_player</code>, the clouds move at an even lower rate (<code class="email">0.15</code>):<div><pre class="programlisting">for (auto cloud : _clouds) {
   cloud-&gt;setPositionX(cloud-&gt;getPositionX() - _player-&gt;getVector().x * 0.15f);
   if (cloud-&gt;getPositionX() + cloud-&gt;getBoundingBox().size.width * 0.5f &lt; 0 ) {
      cloud-&gt;setPositionX(_screenSize.width + cloud-&gt;getBoundingBox().size.width * 0.5f);
   }
}</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec88" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We just added the parallax effect in our game by simply using the player speed at different ratios at different depths. The only slightly complicated part of the logic is how to ensure the sprites scroll continuously. But the math of it is very simple. You just need to make sure the sprites align correctly.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec105" class="calibre1"/>Adding a menu to our game</h1></div></div></div><p class="calibre6">Right now, we<a id="id276" class="calibre1"/> only see the game logo on our introduction screen. We need to add buttons to start the game and also for the option to play a tutorial.</p><p class="calibre6">In order to do that, we'll use a special kind of <code class="email">Layer</code> class, called <code class="email">Menu</code>.</p><p class="calibre6">
<code class="email">Menu</code> is a collection of <code class="email">MenuItems</code>. The layer is responsible for distributing its items as well as tracking touch events on all items. Items can be sprites, labels, images, and so on.</p><div><img src="img/00028.jpeg" alt="Adding a menu to our game" class="calibre9"/></div><p class="calibre10"> </p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec106" class="calibre1"/>Time for action – creating Menu and MenuItem</h1></div></div></div><p class="calibre6">In <code class="email">GameLayer.cpp</code>, scroll down to the <code class="email">createGameScreen</code> method. We'll add the new logic<a id="id277" class="calibre1"/> to the end of this method.</p><div><ol class="orderedlist"><li class="listitem" value="1">First, create<a id="id278" class="calibre1"/> the menu item for our start game button:<div><pre class="programlisting">auto menuItemOn =  Sprite::createWithSpriteFrameName("btn_new_on.png");
auto menuItemOff =  Sprite::createWithSpriteFrameName("btn_new_off.png");

auto starGametItem = MenuItemSprite::create( menuItemOff,
menuItemOn, CC_CALLBACK_1(GameLayer::startGame, this));</pre></div><p class="calibre13">We create a <code class="email">MenuItemSprite</code> object by passing it one sprite per state of the button. When the user touches a <code class="email">MenuItemSprite</code> object, the off state sprite is turned invisible and the on state sprite is turned visible, all inside the touch began event. If the touch is ended or cancelled, the off state is displayed once again.</p><p class="calibre13">We also pass the callback function for this item; in this case, <code class="email">GameLayer::StartGame</code>.</p></li><li class="listitem" value="2">Next, we add the tutorial button:<div><pre class="programlisting">menuItemOn =  Sprite::createWithSpriteFrameName("btn_howto_on.png");
menuItemOff =  Sprite::createWithSpriteFrameName("btn_howto_off.png");

auto howToItem = MenuItemSprite::create( menuItemOff,  menuItemOn, CC_CALLBACK_1(GameLayer::showTutorial, this));</pre></div></li><li class="listitem" value="3">Then it's time<a id="id279" class="calibre1"/> to create the menu:<div><pre class="programlisting">_mainMenu = Menu::create(howToItem, starGametItem, nullptr);
_mainMenu-&gt;alignItemsHorizontallyWithPadding(120);
_mainMenu-&gt;setPosition(Vec2(_screenSize.width *  0.5f, _screenSize.height * 0.54));

this-&gt;addChild(_mainMenu, kForeground);</pre></div><p class="calibre13">The <code class="email">Menu</code> constructor can receive as many <code class="email">MenuItemSprite</code> objects as you wish<a id="id280" class="calibre1"/> to display. These items are then distributed with one of the following calls: <code class="email">alignItemsHorizontally</code>, <code class="email">alignItemsHorizontallyWithPadding</code>, <code class="email">alignItemsHorizontally</code>, <code class="email">alignItemsVerticallyWithPadding</code>, <code class="email">alignItemsInColumns</code>, and <code class="email">alignItemsInRows</code>. And the items appear in the order they are passed to the <code class="email">Menu</code> constructor.</p></li><li class="listitem" value="4">Then we need to add our callback functions:<div><pre class="programlisting">void GameLayer::startGame (Ref* pSender) {
  _tutorialLabel-&gt;setVisible(false);
  _intro-&gt;setVisible(false);
  _mainMenu-&gt;setVisible(false);

  _jam-&gt;runAction(_jamMove);
  SimpleAudioEngine::getInstance() -&gt;playEffect("start.wav");
  _terrain-&gt;setStartTerrain ( true );
  _state = kGamePlay;
}

void GameLayer::showTutorial (Ref* pSender) {
  _tutorialLabel-&gt;setString ("Tap the screen to make the player jump.");
  _state = kGameTutorialJump;
  _jam-&gt;runAction(_jamMove);
  _intro-&gt;setVisible(false);
  _mainMenu-&gt;setVisible(false);
  SimpleAudioEngine::getInstance() -&gt;playEffect("start.wav");
  _tutorialLabel-&gt;setVisible(true);

}</pre></div><p class="calibre13">These are called when our menu buttons are clicked on, one method to start the game and one to show the tutorial.</p></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec89" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We just<a id="id281" class="calibre1"/> created our game's main menu. <code class="email">Menu</code> can save us a lot of time handling all the interactivity logic of buttons. Though<a id="id282" class="calibre1"/> it might not be as flexible as other items in Cocos2d-x, it's still good to know it's there if we need it.</p><p class="calibre6">We'll tackle the tutorial section next.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec107" class="calibre1"/>Adding a tutorial to our game</h1></div></div></div><p class="calibre6">Let's face it. With<a id="id283" class="calibre1"/> the possible exception of <em class="calibre8">Air Hockey</em>, every game so far in this book could benefit from a tutorial, or a "how to play" section. With <em class="calibre8">Victorian Rush Hour</em>, I'm going to show you a quick way to implement one.</p><p class="calibre6">The unspoken rule of game tutorials is—make it playable. And that's what we'll attempt to do here.</p><p class="calibre6">We'll create a game state for our tutorial, and we'll add a <code class="email">Label</code> object to our stage and make it invisible unless the tutorial state is on. We'll use the <code class="email">Label</code> object to display our tutorial text, as shown in the image here:</p><div><img src="img/00029.jpeg" alt="Adding a tutorial to our game" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">Let's go over the steps necessary to create our game tutorial.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec108" class="calibre1"/>Time for action – adding a tutorial</h1></div></div></div><p class="calibre6">Let's move back to our <code class="email">createGameScreen</code> method.</p><div><ol class="orderedlist"><li class="listitem" value="1">Inside that method, add the following lines to create our <code class="email">Label</code> object:<div><pre class="programlisting">_tutorialLabel = Label::createWithTTF("", "fonts/Times.ttf", 60);
_tutorialLabel-&gt;setPosition(Vec2 (_screenSize.width *  0.5f, _screenSize.height * 0.6f) );
this-&gt;addChild(_tutorialLabel, kForeground);
_tutorialLabel-&gt;setVisible(false);</pre></div></li><li class="listitem" value="2">We add<a id="id284" class="calibre1"/> four states to our enumerated list of game states. These will represent the different steps in our tutorial:<div><pre class="programlisting">typedef enum {
  kGameIntro,
  kGamePlay,
  kGameOver,
  kGameTutorial,
  kGameTutorialJump,
  kGameTutorialFloat,
  kGameTutorialDrop

} GameState;</pre></div><p class="calibre13">The first tutorial state, <code class="email">kGameTutorial</code>, acts as a separator from all other game states. So, if the value for <code class="email">_state</code> is greater than <code class="email">kGameTutorial</code>, we are in tutorial mode.</p><p class="calibre13">Now, depending on the mode, we display a different message and we wait on a different condition to change to a new tutorial state.</p></li><li class="listitem" value="3">If you recall, our <code class="email">showTutorial</code> method starts with a message telling the player to tap the screen to make the sprite jump:<div><pre class="programlisting">_tutorialLabel-&gt;setString ("Tap the screen to make the player jump.");
_state = kGameTutorialJump;</pre></div></li><li class="listitem" value="4">Then, at the end of the <code class="email">update</code> method, we start adding the lines that will display the rest of our tutorial information. First, if the player sprite is in the midst of a jump and has just begun falling, we use the following:<div><pre class="programlisting">if (_state &gt; kGameTutorial) {
  if (_state == kGameTutorialJump) {
    if (_player-&gt;getState() == kPlayerFalling &amp;&amp; _player -&gt;getVector().y &lt; 0) {
      _player-&gt;stopAllActions();
      _jam-&gt;setVisible(false);
      _jam-&gt;stopAllActions();
      _running = false;
      _tutorialLabel-&gt;setString ("While in the air, tap the screen to float.");
      _state = kGameTutorialFloat;
    }</pre></div><p class="calibre13">As you can see, we let the player know that another tap will open the umbrella and cause the sprite to float.</p></li><li class="listitem" value="5">Next, as<a id="id285" class="calibre1"/> the sprite is floating, when it reaches a certain distance from the buildings, we inform the player that another tap will close the umbrella and cause the sprite to drop. Here's the code for these instructions:<div><pre class="programlisting">  } else if (_state == kGameTutorialFloat) {
    if (_player-&gt;getPositionY() &lt; _screenSize.height *  0.95f) {
      _player-&gt;stopAllActions();
      _running = false;
      _tutorialLabel-&gt;setString ("While floating, tap the screen again to drop.");
      _state = kGameTutorialDrop;
    }</pre></div></li><li class="listitem" value="6">After that, the tutorial will be complete and we show the message that the player may start the game:<div><pre class="programlisting">  } else {
    _tutorialLabel-&gt;setString ("That's it. Tap the screen to play.");
    _state = kGameTutorial;
  }
}</pre></div><p class="calibre13">Whenever we change a tutorial state, we pause the game momentarily and wait for a tap. We handle the rest of our logic inside <code class="email">onTouchBegan</code>, so we'll add that next.</p></li><li class="listitem" value="7">Inside <code class="email">onTouchBegan</code>, in the <code class="email">switch</code> statement, add the following cases:<div><pre class="programlisting">case kGameTutorial:
  _tutorialLabel-&gt;setString("");
  _tutorialLabel-&gt;setVisible(false);
  _terrain-&gt;setStartTerrain ( true );
  _state = kGamePlay;
  break;

case kGameTutorialJump:
  if (_player-&gt;getState() == kPlayerMoving) {
    SimpleAudioEngine::getInstance() -&gt;playEffect("jump.wav");
    _player-&gt;setJumping(true);
  }
  break;

case kGameTutorialFloat:
  if (!_player-&gt;getFloating()) {
    _player-&gt;setFloating (true);
    _running = true;
  }
  break;

case kGameTutorialDrop:
  _player-&gt;setFloating (false);
  _running = true;
  break;</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec90" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We <a id="id286" class="calibre1"/>added a tutorial to our game! As you can see, we used quite a few new states. But now we can incorporate the tutorial right into our game and have one flow smoothly into the other. All these changes can be seen in action in the final version of this project, <code class="email">4198_07_FINAL_PROJECT.zip</code>, which you can find on this book's <strong class="calibre7">Support</strong> page.</p><p class="calibre6">Now, you guessed it, let's run it in Android.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec109" class="calibre1"/>Time for action – running the game in Android</h1></div></div></div><p class="calibre6">Follow<a id="id287" class="calibre1"/> these steps to deploy the game to Android:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open your project's <code class="email">Android.mk</code> file in a text editor.</li><li class="listitem" value="2">Edit the lines in <code class="email">LOCAL_SRC_FILES</code> to read:<div><pre class="programlisting">LOCAL_SRC_FILES := hellocpp/main.cpp \
                   ../../Classes/AppDelegate.cpp \
                   ../../Classes/Block.cpp \
                   ../../Classes/GameSprite.cpp \
                   ../../Classes/Player.cpp \
                   ../../Classes/Terrain.cpp \
                   ../../Classes/GameLayer.cpp</pre></div></li><li class="listitem" value="3">Import the game into Eclipse and wait until all classes are compiled.</li><li class="listitem" value="4">That's it. Save it and run your application.</li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec91" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">You now have <em class="calibre8">Victorian Rush Hour</em> running in Android.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec110" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">After we got all the gameplay details ironed out in our test game, bringing in a sprite sheet and game states seems remarkably simple and easy.</p><p class="calibre6">But during this stage, we can also think of new ways to improve gameplay. For instance, the realization that clouds of smoke coming out of chimneys would offer a nice visual cue to the player to identify where the buildings were, if the cyclist happened to jump too high. Or that a hat flying through the air could be funny!</p><p class="calibre6">Now it's time to bring physics to our games, so head on to the next chapter.</p></div></body></html>