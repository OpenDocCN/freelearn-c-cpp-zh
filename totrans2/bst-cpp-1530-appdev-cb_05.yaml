- en: Chapter 5. Multithreading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 多线程
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating an execution thread
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建执行线程
- en: Syncing access to a common resource
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步访问公共资源
- en: Fast access to a common resource using atomics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子操作快速访问公共资源
- en: Creating a work_queue class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建工作队列类
- en: Multiple-readers-single-writer lock
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多读单写锁
- en: Creating variables that are unique per thread
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建每个线程唯一的变量
- en: Interrupting a thread
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断线程
- en: Manipulating a group of threads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作线程组
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter we'll take care of threads and all of the stuff connected with
    them. Basic knowledge of multithreading is encouraged.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理线程及其相关内容。鼓励读者具备基本的多线程知识。
- en: '**Multithreading** means that multiple execution threads exist within a single
    process. Threads may share process resources and have their own resources. Those
    execution threads may run independently on different CPUs, leading to faster and
    more responsive programs.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**多线程**意味着在单个进程中存在多个执行线程。线程可以共享进程资源并拥有自己的资源。这些执行线程可以在不同的 CPU 上独立运行，从而实现更快和更响应的程序。'
- en: The `Boost.Thread` library provides uniformity across operating system interfaces
    for working with threads. It is not a header-only library, so all of the examples
    from this chapter will need to link against the `libboost_thread` and `libboost_system`
    libraries.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Thread` 库为操作系统接口提供了跨平台的统一性，用于处理线程。它不是一个仅包含头文件的库，因此本章中的所有示例都需要链接到 `libboost_thread`
    和 `libboost_system` 库。'
- en: Creating an execution thread
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建执行线程
- en: 'On modern multi-core compilers, to achieve maximal performance (or just to
    provide a good user experience), programs usually must use multiple execution
    threads. Here is a motivating example in which we need to create and fill a big
    file in a thread that draws the user interface:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代多核编译器上，为了实现最大性能（或仅仅提供良好的用户体验），程序通常必须使用多个执行线程。以下是一个激励示例，其中我们需要在绘制用户界面的线程中创建和填充一个大文件：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will require knowledge of the `boost::bind` library.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要了解 `boost::bind` 库。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Starting an execution thread was never so easy:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 启动执行线程从未如此简单：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: The `boost::thread` variable accepts a functional object that can be called
    without parameters (we provided one using `boost::bind`) and creates a separate
    execution thread. That functional object will be copied into a constructed execution
    thread and will be run there.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::thread` 变量接受一个可以无参数调用的函数对象（我们使用 `boost::bind` 提供了一个），并创建一个单独的执行线程。该函数对象将被复制到构建的执行线程中并在那里运行。'
- en: '![How it works...](img/4880OS_05_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4880OS_05_01.jpg)'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In all of the recipes with the `Boost.Thread` library, we'll be using Version
    4 (defined `BOOST_THREAD_VERSION to 4`) of threads by default and pointing out
    some important differences between `Boost.Thread` versions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有使用 `Boost.Thread` 库的配方中，我们将默认使用线程的版本 4（定义 `BOOST_THREAD_VERSION` 为 4）并指出
    `Boost.Thread` 版本之间的一些重要差异。
- en: 'After that, we call the `detach()` function, which will do the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们调用 `detach()` 函数，它将执行以下操作：
- en: The execution thread will be detached from the `boost::thread` variable but
    will continue its execution
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行线程将从 `boost::thread` 变量中分离，但将继续其执行
- en: The `boost::thread` variable will hold a `Not-A-Thread` state
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::thread` 变量将保持 `Not-A-Thread` 状态'
- en: Note that without a call to `detach()`, the destructor of `boost::thread` will
    notice that it still holds a thread and will call `std::terminate`, which will
    terminate our program.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有调用 `detach()`，`boost::thread` 的析构函数会注意到它仍然持有线程，并将调用 `std::terminate`，这将终止我们的程序。
- en: Default constructed threads will also have a `Not-A-Thread` state, and they
    won't create a separate execution thread.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造的线程也将具有 `Not-A-Thread` 状态，并且它们不会创建单独的执行线程。
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'What if we want to make sure that a file was created and written before doing
    some other job? In that case we need to join a thread using the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在执行其他工作之前确保文件已被创建并写入，我们需要使用以下方法连接线程：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After the thread is joined, the `boost::thread` variable will hold a `Not-A-Thread`
    state and its destructor won't call `std::terminate`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程连接后，`boost::thread` 变量将保持 `Not-A-Thread` 状态，其析构函数不会调用 `std::terminate`。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the thread must be joined or detached before its destructor is
    called. Otherwise, your program will terminate!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在调用析构函数之前，线程必须被连接或分离。否则，你的程序将终止！
- en: Beware that `std::terminate()` is called when any exception that is not of type
    `boost::thread_interrupted` leaves the boundary of the functional object and is
    passed to the `boost::thread` constructor.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当任何非`boost::thread_interrupted`类型的异常离开功能对象的边界并传递给`boost::thread`构造函数时，会调用`std::terminate()`。
- en: The `boost::thread` class was accepted as a part of the C++11 standard and you
    can find it in the `<thread>` header in the `std::` namespace. By default, with
    `BOOST_THREAD_VERSION=2`, the destructor of `boost::thread` will call `detach()`,
    which won't lead to `std::terminate`. But doing so will break compatibility with
    `std::thread`, and some day, when your project is moving to the C++ standard library
    threads or when `BOOST_THREAD_VERSION=2` is no longer supported this will give
    you a lot of surprises. Version 4 of `Boost.Thread` is more explicit and strong,
    which is usually preferable in C++ language.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::thread`类被接受为C++11标准的一部分，你可以在`std::`命名空间中的`<thread>`头文件中找到它。默认情况下，当`BOOST_THREAD_VERSION=2`时，`boost::thread`的析构函数将调用`detach()`，这不会导致`std::terminate`。但是这样做会破坏与`std::thread`的兼容性，而且有一天，当你的项目转移到C++标准库线程或者当`BOOST_THREAD_VERSION=2`不再被支持时，这会给你带来很多惊喜。`Boost.Thread`的版本4更加明确和强大，这在C++语言中通常是首选的。'
- en: 'There is a very helpful wrapper that works as a RAII wrapper around the thread
    and allows you to emulate the `BOOST_THREAD_VERSION=2` behavior; it is called
    `boost::scoped_thread<T>`, where `T` can be one of the following classes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常有用的包装器，它作为线程的RAII包装器工作，允许你模拟`BOOST_THREAD_VERSION=2`的行为；它被称为`boost::scoped_thread<T>`，其中`T`可以是以下类之一：
- en: '`boost::interrupt_and_join_if_joinable`: To interrupt and join thread at destruction'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::interrupt_and_join_if_joinable`: 在析构时中断并连接线程'
- en: '`boost::join_if_joinable`: To join a thread at destruction'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::join_if_joinable`: 在析构时连接一个线程'
- en: '`boost::detach`: To detach a thread at destruction'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::detach`: 在析构时分离一个线程'
- en: 'Here is a small example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小例子：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We added additional parentheses around `(boost::thread(&some_func))` so that
    the compiler won't interpret it as a function declaration instead of a variable
    construction.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`(boost::thread(&some_func))`周围添加了额外的括号，这样编译器就不会将其解释为函数声明而不是变量构造。
- en: There is no big difference between the Boost and C++11 STL versions of the `thread`
    class; however, `boost::thread` is available on the C++03 compilers, so its usage
    is more versatile.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost`和C++11 STL版本的`thread`类之间没有太大区别；然而，`boost::thread`在C++03编译器上可用，因此它的使用更加灵活。'
- en: See also
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: All of the recipes in this chapter will be using `Boost.Thread`; you may continue
    reading to get more information about them
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的所有配方都将使用`Boost.Thread`；你可以继续阅读以获取更多关于它们的信息
- en: The official documentation has a full list of the `boost::thread` methods and
    remarks about their availability in the C++11 STL implementation; it can be found
    at [http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档列出了`boost::thread`的所有方法和关于它们在C++11 STL实现中可用性的说明；它可以在[http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)找到。
- en: The *Interrupting a thread* recipe will give you an idea of what the `boost::interrupt_and_join_if``_joinable`
    class does
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “中断线程”的配方将给你一个关于`boost::interrupt_and_join_if_joinable`类所做事情的概念。
- en: Syncing access to a common resource
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步访问公共资源
- en: 'Now that we know how to start execution threads, we want to have access to
    some common resources from different threads:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何启动执行线程，我们希望从不同的线程访问一些公共资源：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This `''Oops!''` is not written there accidentally. For some people it will
    be a surprise, but there is a big chance that `shared_i` won''t be equal to 0:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“Oops!”并不是无意中写上去的。对某些人来说，这可能是个惊喜，但有很大可能性`shared_i`不会等于0：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Modern compilers and processors have a huge number of different, tricky optimizations
    that can break the preceding code. We won't discuss them here, but there is a
    useful link in the *See also* section to a document that briefly describes them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编译器和处理器有大量不同且复杂的优化，这些优化可能会破坏前面的代码。我们在这里不会讨论它们，但在“参见”部分有一个有用的链接，指向一个简要描述它们的文档。
- en: And it will get even worse in cases when a common resource has some non-trivial
    classes; segmentation faults and memory leaks may (and will) occur.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 而在公共资源包含一些非平凡类的情况下，情况会更糟；可能会（并且将会）发生段错误和内存泄漏。
- en: We need to change the code so that only one thread modifies the `shared_i` variable
    at a single moment of time and so that all of the processor and compiler optimizations
    that inflict multithreaded code are bypassed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改代码，使得只有一个线程在某一时刻修改 `shared_i` 变量，并且绕过所有影响多线程代码的处理器和编译器优化。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of threads is recommended for this recipe.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 建议对线程有基本了解才能理解这个食谱。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see how we can fix the previous example and make `shared_i` equal at
    the end of the run:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何修复前面的示例，并使 `shared_i` 在运行结束时相等：
- en: 'First of all we''ll need to create a mutex:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个互斥锁：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Put all the operations that modify or get data from the `shared_i` variable
    between the following:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将修改或从 `shared_i` 变量获取数据的所有操作放在以下内容之间：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And the following:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以及以下内容：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is what it will look like:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是这样的：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `boost::mutex` class takes care of all of the synchronization stuff. When
    a thread tries to lock it via the `boost::lock_guard<boost::mutex>` variable and
    there is no other thread holding a lock, it will successfully acquire unique access
    to the section of code until the lock is unlocked or destroyed. If some other
    thread already holds a lock, the thread that tried to acquire the lock will wait
    until another thread unlocks the lock. All the locking/unlocking operations imply
    specific instructions so that the changes made in a **critical section** will
    be visible to all threads. Also, you no longer need to *make sure that modified
    values of resources are visible to all cores and are not just modified in the
    processor's register* and *force the processor and compiler to not reorder the
    instructions*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::mutex` 类负责处理所有的同步问题。当一个线程尝试通过 `boost::lock_guard<boost::mutex>` 变量来锁定它，并且没有其他线程持有锁时，它将成功获取对代码段的独占访问权，直到锁被解锁或销毁。如果其他线程已经持有锁，尝试获取锁的线程将等待直到另一个线程解锁。所有的锁定/解锁操作都隐含了特定的指令，以确保在**临界区**中做出的更改对所有线程都是可见的。此外，你也不再需要**确保修改后的资源值对所有核心都是可见的，并且不仅仅是在处理器的寄存器中修改**，以及**强制处理器和编译器不重新排序指令**。'
- en: The `boost::lock_guard` class is a very simple RAII class that stores a reference
    to the mutex and calls `lock()` in the single-parameter constructor and `unlock()`
    in the destructor. Note the curly bracket usage in the preceding example; the
    `lock` variable is constructed inside them so that, on reaching the `critical
    section` closing bracket, the destructor for the `lock` variable will be called
    and the mutex will be unlocked. Even if some exception occurs in the critical
    section, the mutex will be correctly unlocked.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::lock_guard` 类是一个非常简单的RAII类，它存储对互斥锁的引用，并在单参数构造函数中调用 `lock()`，在析构函数中调用
    `unlock()`。注意前面示例中的花括号使用；`lock` 变量是在其中构造的，这样当达到 `critical section` 结束括号时，`lock`
    变量的析构函数将被调用，互斥锁将被解锁。即使临界区中发生异常，互斥锁也会被正确解锁。'
- en: '![How it works...](img/4880OS_05_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/4880OS_05_02.jpg)'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you have some resources that are used from different threads, usually all
    the code that uses them must be treated as a critical section and secured by a
    mutex.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些资源被不同的线程使用，通常所有使用它们的代码都必须被视为临界区，并由互斥锁来保护。
- en: There's more...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Locking a mutex is potentially a very slow operation, which may stop your code
    for a long time, until some other thread releases a lock. Try to make critical
    sections as small as possible and try to have less of them in your code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定互斥锁可能是一个非常慢的操作，这可能会导致你的代码长时间停止，直到其他线程释放锁。尽量使临界区尽可能小，并尽量减少代码中的临界区数量。
- en: 'Let''s take a look at how some operating systems (OS) handle locking on a multicore
    CPU. When `thread #1`, running on CPU1, tries to lock a mutex that is already
    locked by another thread, `thread #1` is stopped by the OS till the lock is released.
    The stopped thread does not *eat* processor resources, so the OS will still execute
    other threads on CPU1\. Now we have some threads running on CPU1; some other thread
    releases the lock, and now the OS has to resume execution of a `thread #1`. So
    it will resume its execution on a currently free CPU, for example, CPU2\. This
    will result in CPU cache misses, and code will be running slightly slower after
    the mutex is released. This is another reason to reduce the number of critical
    sections. However, things are not so bad because a good OS will try to resume
    the thread on the same CPU that it was using before.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看看一些操作系统（OS）如何在多核CPU上处理锁定。当 `thread #1` 在 CPU1 上运行并尝试锁定另一个线程已锁定的互斥量时，`thread
    #1` 会被操作系统停止，直到锁被释放。被停止的线程不会**消耗**处理器资源，因此操作系统仍然会在 CPU1 上执行其他线程。现在我们在 CPU1 上有一些线程正在运行；其他某个线程释放了锁，现在操作系统必须恢复
    `thread #1` 的执行。所以它将在当前空闲的 CPU 上恢复执行，例如，CPU2。这将导致 CPU 缓存未命中，并且在互斥量释放后代码将运行得略慢。这是减少关键区数量另一个原因。然而，事情并不那么糟糕，因为一个好的操作系统会尝试在之前使用的相同
    CPU 上恢复线程。'
- en: Do not attempt to lock a `boost::mutex` variable twice in the same thread; it
    will lead to a **deadlock**. If locking a mutex multiple times from a single thread
    is required, use `boost::recursive_mutex` instead of the `<boost/thread/recursive_mutex.hpp>`
    header. Locking it multiple times won't lead to a deadlock. The `boost::recursive_mutex`
    will release the lock only after `unlock()` is called once for each `lock()` call.
    Avoid using `boost::recursive_mutex`; it is slower than `boost::mutex` and usually
    indicates bad code flow design.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不要尝试在同一个线程中两次锁定一个 `boost::mutex` 变量；这将导致**死锁**。如果需要从单个线程多次锁定互斥量，请使用 `boost::recursive_mutex`
    而不是 `<boost/thread/recursive_mutex.hpp>` 头文件。多次锁定它不会导致死锁。`boost::recursive_mutex`
    只在每次 `lock()` 调用后对每个 `unlock()` 调用释放锁。避免使用 `boost::recursive_mutex`；它比 `boost::mutex`
    慢，通常表示代码流程设计不佳。
- en: The `boost::mutex`, `boost::recursive_mutex`, and `boost::lock_guard` classes
    were accepted to the C++11 standard, and you may find them in the `<mutex>` header
    in the `std::` namespace. No big difference between Boost and STL versions exists;
    a Boost version may have some extensions (which are marked in the official documentation
    as *EXTENSION*) and provide better portability because they can be used even on
    C++03 compilers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::mutex`、`boost::recursive_mutex` 和 `boost::lock_guard` 类被纳入 C++11 标准，你可以在
    `std::` 命名空间中的 `<mutex>` 头文件中找到它们。Boost 和 STL 版本之间没有太大区别；Boost 版本可能有一些扩展（这些扩展在官方文档中被标记为
    *EXTENSION*），并且提供更好的可移植性，因为它们甚至可以在 C++03 编译器上使用。'
- en: See also
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The next recipe will give you some ideas on how to make this example much faster
    (and shorter).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个示例将给你一些想法，如何使这个例子更快（更短）。
- en: Read the first recipe from this chapter to get more information about the `boost::thread`
    class. The official documentation for `Boost.Thread` may help you too; it can
    be found at [http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读本章的第一个示例以获取更多关于 `boost::thread` 类的信息。`Boost.Thread` 的官方文档也可能有所帮助；它可以在 [http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)
    找到。
- en: 'For more information about why the first example will fail and how multiprocessors
    work with common resources, see *Memory Barriers: a Hardware View for Software
    Hackers* at [http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf](http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '更多关于第一个示例为何会失败以及多处理器如何与公共资源协同工作的信息，请参阅 *《Memory Barriers: a Hardware View for
    Software Hackers》*，可在 [http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf](http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf)
    查看。'
- en: Fast access to common resource using atomics
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原子操作快速访问公共资源
- en: 'In the previous recipe, we saw how to safely access a common resource from
    different threads. But in that recipe, we were doing two system calls (in locking
    and unlocking the mutex) just to get the value from an integer:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了如何从不同的线程安全地访问一个公共资源。但在那个示例中，我们只是为了从一个整数中获取值，就做了两次系统调用（在锁定和解锁互斥量时）：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This looks lame! And slow! Can we make the code from the previous recipe better?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很糟糕！而且很慢！我们能否使前面示例中的代码更好？
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Reading the first recipe is all you need to start with this. Or just some basic
    knowledge of multithreading.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读第一个食谱就是开始这个的起点。或者，只需要一些关于多线程的基本知识。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see how to improve our previous example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何改进我们之前的示例：
- en: 'We will need different headers:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要不同的头文件：
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Changing the type of `shared_i` is required (as it is no longer needed in the
    mutex):'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要更改`shared_i`的类型（因为它在互斥锁中不再需要）：
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Remove all the `boost::lock_guard` variables:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除所有的`boost::lock_guard`变量：
- en: '[PRE13]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And that's it! Now it works.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样！现在它工作了。
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: Processors provide specific atomic operations that cannot be interfered with
    by other processors or processor cores. These operations appear to occur instantaneously
    for a system. `Boost.Atomic` provides classes that wrap around system-specific
    atomic operations and provide a uniform and portable interface to work with them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器提供特定的原子操作，这些操作不会被其他处理器或处理器核心干扰。对于系统来说，这些操作似乎瞬间发生。`Boost.Atomic`提供围绕系统特定原子操作的类，并提供一个统一且可移植的接口来与之交互。
- en: 'In other words, it is safe to use the `boost::atomic<>` variables from different
    threads simultaneously. Each operation on the atomic variable will be seen by
    the system as a single transaction. Series of operations on the atomic variables
    will be treated by the system as a series of transactions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，可以安全地在不同的线程中同时使用`boost::atomic<>`变量。对原子变量的每次操作都会被系统视为一个单独的事务。对原子变量的操作序列将被系统视为一系列事务：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![How it works...](img/4880OS_05_03.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4880OS_05_03.jpg)'
- en: There's more...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Boost.Atomic` library can work only with POD types; otherwise, its behavior
    is undefined. Some platforms/processors do not provide atomic operations for some
    types, so `Boost.Atomic` will emulate atomic behavior using `boost::mutex`. The
    atomic type won''t use `boost::mutex` if the type-specific macro is set to `2`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Atomic`库只能与POD类型一起工作；否则，其行为是未定义的。一些平台/处理器可能不提供某些类型的原子操作，因此`Boost.Atomic`将使用`boost::mutex`来模拟原子行为。如果类型特定的宏设置为`2`，则原子类型不会使用`boost::mutex`：'
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `boost::atomic<T>::is_lock_free` member function depends on runtime, so
    it is not good for compile-time checks but may provide a more readable syntax
    when the runtime check is enough:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::atomic<T>::is_lock_free`成员函数依赖于运行时，因此它不适合编译时检查，但在运行时检查足够的情况下，它可能提供更易读的语法：'
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Atomics work much faster than mutexes. If we compare the execution time of a
    recipe that uses mutexes (0:00.08 seconds) and the execution time of the preceding
    example in this recipe (0:00.02 seconds), we'll see the difference (tested on
    3,00,000 iterations).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作比互斥锁快得多。如果我们比较使用互斥锁的食谱的执行时间（0:00.08秒）和这个食谱中前一个示例的执行时间（0:00.02秒），我们会看到差异（在3,00,000次迭代中进行了测试）。
- en: The C++11 compilers should have all the atomic classes, typedefs, and macros
    in the `<atomic>` header in the `std::` namespace. Compiler-specific implementations
    of `std::atomic` may work faster than the Boost's version, if the compiler correctly
    supports the C++11 memory model and atomic operations are not a compiler barrier
    for it any more.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C++11编译器应该在`std::`命名空间中的`<atomic>`头文件中包含所有的原子类、typedefs和宏。如果编译器正确支持C++11内存模型，并且原子操作不再是编译器的障碍，那么特定编译器的`std::atomic`实现可能比Boost版本运行得更快。
- en: See also
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official documentation may give you many more examples and some theoretical
    information on the topic; it can be found at [http://www.boost.org/doc/libs/1_53_0/doc/html/atomic.html](http://www.boost.org/doc/libs/1_53_0/doc/html/atomic.html)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档可能会给你提供更多关于这个主题的示例和一些理论信息；它可以在[http://www.boost.org/doc/libs/1_53_0/doc/html/atomic.html](http://www.boost.org/doc/libs/1_53_0/doc/html/atomic.html)找到
- en: 'For more information about how atomics work, see *Memory Barriers: a Hardware
    View for Software Hackers* at [http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf](http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '关于原子操作如何工作的更多信息，请参阅[http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf](http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf)上的*Memory
    Barriers: a Hardware View for Software Hackers*'
- en: Creating a work_queue class
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个`work_queue`类
- en: Let's call the functional object that takes no arguments (a task, in short).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称这个不接受任何参数的功能对象（简称为任务）。
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And now, imagine a situation where we have threads that post tasks and threads
    that execute posted tasks. We need to design a class that can be safely used by
    both types of thread. This class must have methods for getting a task (or blocking
    and waiting for a task until it is posted by another thread), checking and getting
    a task if we have one (returning an empty task if no tasks remain), and a method
    to post tasks.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下我们有两种类型的线程：一种是发布任务的线程，另一种是执行已发布任务的线程。我们需要设计一个可以被这两种类型的线程安全使用的类。这个类必须具有获取任务（或阻塞并等待任务，直到另一个线程发布它）的方法，检查和获取任务（如果没有任务剩余，则返回空任务），以及发布任务的方法。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you feel comfortable with `boost::thread` or `std::thread` and
    know some basics of mutexes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你对`boost::thread`或`std::thread`感到舒适，并且了解互斥锁的一些基础知识。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The classes that we are going to implement will be close in functionality to
    `std::queue<task_t>` and will also have thread synchronization. Let''s start:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的类在功能上将与`std::queue<task_t>`相似，并且也将具有线程同步。让我们开始：
- en: 'We''ll need the following headers and members:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以下头文件和成员：
- en: '[PRE19]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A function for putting a task in the queue will look like this:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任务放入队列的函数看起来像这样：
- en: '[PRE20]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A non-blocking function for getting a pushed task or an empty task (if no tasks
    remain):'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于获取已推送任务或空任务（如果没有任务剩余）的非阻塞函数：
- en: '[PRE21]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Blocking function for getting a pushed task or for blocking while the task
    is pushed by another thread:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于获取已推送任务或阻塞直到另一个线程推送任务的阻塞函数：
- en: '[PRE22]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And this is how a `work_queue` class may be used:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是`work_queue`类可能的使用方式：
- en: '[PRE23]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this example, we will see a new RAII class `boost::unique_lock`. It is just
    a `boost::lock_guard` class with additional functionality; for example, it has
    methods for explicit unlocking and locking mutexes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将看到一个新的RAII类`boost::unique_lock`。它只是具有附加功能的`boost::lock_guard`类；例如，它具有显式解锁和锁定互斥锁的方法。
- en: Going back to our `work_queue` class, let's start with the `pop_task()` function.
    In the beginning, we are acquiring a lock and checking for available tasks. If
    there is a task, we return it; otherwise, `cond_.wait(lock)` is called. This method
    will unlock the lock and pause the execution thread until till some other thread
    notifies the current thread.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`work_queue`类，让我们从`pop_task()`函数开始。一开始，我们获取一个锁并检查是否有可用的任务。如果有任务，我们返回它；否则，调用`cond_.wait(lock)`。此方法将解锁锁并暂停执行线程，直到其他线程通知当前线程。
- en: Now, let's take a look at the `push_task` method. In it we also acquire a lock,
    push a task to `tasks_.queue`, unlock the lock, and call `cond_notify_one()`,
    which will wake up the thread (if any) waiting in `cond_wait(lock)`. So, after
    that, if some thread was waiting on a conditional variable in a `pop_task()` method,
    the thread will continue its execution, call `lock.lock()` deep inside `cond_wait(lock)`,
    and check `tasks_empty()` in the while loop. Because we just added a task in `tasks_`,
    we'll get out from the `while` loop, unlock the mutex (the `lock` variable will
    go out of scope), and return a task.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`push_task`方法。在其中，我们也获取了一个锁，将任务推送到`tasks_.queue`，解锁锁，并调用`cond_notify_one()`，这将唤醒在`cond_wait(lock)`中等待的线程（如果有）。所以，在那之后，如果某个线程在`pop_task()`方法中等待一个条件变量，该线程将继续执行，在`cond_wait(lock)`深处调用`lock.lock()`，并在while循环中检查`tasks_empty()`。因为我们刚刚在`tasks_`中添加了一个任务，所以我们将退出`while`循环，解锁互斥锁（`lock`变量将超出作用域），并返回一个任务。
- en: '![How it works...](img/4880OS_05_04.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/4880OS_05_04.jpg)'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is highly recommended that you check conditions in a loop, not just in an
    `if` statement. The `if` statement will lead to an error if `thread #1` pops a
    task after it is pushed by `thread #2` but `thread #3` is notified by `thread
    #2` before it (`thread #3`) starts waiting.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '强烈建议你在循环中检查条件，而不仅仅是`if`语句。如果`thread #1`在`thread #2`推送任务之后弹出任务，但`thread #3`在它（`thread
    #3`）开始等待之前被`thread #2`通知，那么`if`语句将导致错误。'
- en: There's more...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Note that we explicitly unlocked the mutex before calling `notify_one()`. Without
    unlocking, our example would still work.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在调用`notify_one()`之前明确解锁了互斥锁。如果没有解锁，我们的示例仍然可以工作。
- en: But, in that case, the thread that has woken up may be blocked once more during
    an attempt to call `lock.lock()` deep inside `cond_wait(lock)`, which leads to
    more context switches and worse performance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在这种情况下，唤醒的线程可能在尝试在`cond_wait(lock)`深处调用`lock.lock()`时再次被阻塞，这会导致更多的上下文切换和更差的表现。
- en: 'With `tests_tasks_count` set to `3000000` and without explicit unlocking, this
    example runs for 7 seconds:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 `tests_tasks_count` 设置为 `3000000` 且没有明确解锁时，此示例运行时间为 7 秒：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With explicit unlocking, this example runs for 5 seconds:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显式解锁，此示例运行时间为 5 秒：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You may also notify all the threads waiting on a specific conditional variable
    using `cond_notify_all()`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `cond_notify_all()` 通知等待特定条件变量的所有线程。
- en: The C++11 standard has `std::condition_variable` declared in the `<condition_variable>`
    header and `std::unique_lock` declared in the `<mutex>` header. Use the Boost
    version if you need portable behavior, use C++03 compiler, or just use some of
    the Boost's extensions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 标准在 `<condition_variable>` 头文件中声明了 `std::condition_variable`，在 `<mutex>`
    头文件中声明了 `std::unique_lock`。如果你需要可移植的行为，使用 Boost 版本，使用 C++03 编译器，或者只是使用一些 Boost
    的扩展。
- en: See also
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The first three recipes in this chapter provide a lot of useful information
    about `Boost.Thread`
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的前三个食谱提供了关于 `Boost.Thread` 的许多有用信息
- en: The official documentation may give you many more examples and some theoretical
    information on the topic; it can be found at [http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档可能会给你提供更多示例以及一些关于该主题的理论信息；它可以在 [http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)
    找到
- en: Multiple-readers-single-writer lock
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多读单写锁
- en: 'Imagine that we are developing some online services. We have a map of registered
    users with some properties for each user. This set is accessed by many threads,
    but it is very rarely modified. All operations with the following set are done
    in a thread-safe manner:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们正在开发一些在线服务。我们有一个注册用户的映射，每个用户有一些属性。这个集合被许多线程访问，但它很少被修改。所有对以下集合的操作都是以线程安全的方式完成的：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: But any operation will acquire a unique lock on the `mutex_` variable, so even
    getting resources will result in waiting on a locked mutex; therefore, this class
    will become a bottleneck very soon.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但任何操作都会在 `mutex_` 变量上获取唯一锁，因此即使获取资源也会导致在锁定互斥锁上等待；因此，这个类很快就会成为瓶颈。
- en: Can we fix it?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能修复它吗？
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Replace `boost::unique_locks` with `boost::shared_lock` for methods that do
    not modify data:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不修改数据的方法，将 `boost::unique_locks` 替换为 `boost::shared_lock`：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We can allow getting the data from multiple threads simultaneously if those
    threads do not modify it. We need to uniquely own the mutex only if we are going
    to modify the data in it; in all other situations simultaneous access to it is
    allowed. And that is what `boost::shared_mutex` was designed for. It allows shared
    locking (read locking), which allows multiple simultaneous access to resources.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果那些线程不修改数据，我们可以允许从多个线程同时获取数据。只有当我们打算修改其中的数据时，我们才需要唯一拥有互斥锁；在其他所有情况下，允许同时访问它。这正是
    `boost::shared_mutex` 被设计出来的原因。它允许共享锁定（读取锁定），这允许对资源的多个同时访问。
- en: When we do try to unique lock a resource that is shared locked, operations will
    be blocked until there are no read locks remaining and only after that resource
    is unique locked, forcing new shared locks to wait until the unique lock is released.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试对共享锁定的资源进行唯一锁定时，操作将被阻塞，直到没有剩余的读取锁，并且只有在那个资源被唯一锁定之后，才允许新的共享锁等待直到唯一锁被释放。
- en: Some readers may be seeing the mutable keyword for the first time. This keyword
    can be applied to non-static and non-constant class members. The mutable data
    member can be modified in the constant member functions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能第一次看到可变关键字。此关键字可以应用于非静态和非常量类成员。可变数据成员可以在常量成员函数中修改。
- en: There's more...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When you do need only unique locks, do not use `boost::shared_mutex` because
    it is slightly slower than a usual `boost::mutex` class. However, in other cases,
    it may give a big performance gain. For example, with four reading threads, shared
    mutex will work almost four times faster than `boost::mutex`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只需要唯一锁时，不要使用 `boost::shared_mutex`，因为它比普通的 `boost::mutex` 类稍微慢一些。然而，在其他情况下，它可能会带来很大的性能提升。例如，对于四个读取线程，共享互斥锁将比
    `boost::mutex` 快近四倍。
- en: Unfortunately, shared mutexes are not the part of the C++11 standard.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，共享互斥锁不是 C++11 标准的一部分。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: There is also a `boost::upgrade_mutex` class, which may be useful for cases
    when a shared lock needs promotion to unique lock. See the `Boost.Thread` documentation
    at [http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)
    for more information.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一个 `boost::upgrade_mutex` 类，在需要将共享锁提升为独占锁的情况下可能很有用。有关更多信息，请参阅 `Boost.Thread`
    文档 [http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)。
- en: For more information about the mutable keyword see [http://herbsutter.com/2013/01/01/video-you-dont-know-const-and-mutable/](http://herbsutter.com/2013/01/01/video-you-dont-know-const-and-mutable/).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 `mutable` 关键字的信息，请参阅 [http://herbsutter.com/2013/01/01/video-you-dont-know-const-and-mutable/](http://herbsutter.com/2013/01/01/video-you-dont-know-const-and-mutable/)。
- en: Creating variables that are unique per thread
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建每个线程唯一的变量
- en: Let's take a glance at the recipe *Creating a* *work_queue class*. Each task
    there can be executed in one of many threads and we do not know which one. Imagine
    that we want to send the results of an executed task using some connection.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下 *创建一个* *工作队列类* 的配方。那里的每个任务都可以在许多线程中的一个上执行，我们不知道是哪一个。想象一下，我们想要使用某个连接发送已执行任务的成果。
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have the following solutions:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下解决方案：
- en: Open a new connection when we need to send the data (which is slow)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要发送数据时打开一个新的连接（这很慢）
- en: Have a single connection for all the threads and wrap them in mutex (which is
    also slow)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有线程提供一个单一的连接，并将它们包装在互斥锁中（这也很慢）
- en: Have a pool of connections, get a connection from it in a thread-safe manner
    and use it (a lot of coding is required, but this solution is fast)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个连接池，以线程安全的方式从中获取一个连接并使用它（需要大量的编码，但这个解决方案速度快）
- en: Have a single connection per thread (fast and simple to implement)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个线程有一个单一的连接（快速且易于实现）
- en: So, how can we implement the last solution?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现最后的解决方案呢？
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of threads is required.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 需要基本了解线程知识。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'It is time to make a thread local variable:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建一个线程局部变量了：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Using a thread-specific resource was never so easy:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程特定的资源从未如此简单：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::thread_specific_ptr` variable holds a separate pointer for each
    thread. Initially, this pointer is equal to `NULL`; that is why we check for `!p`
    and open a connection if it is `NULL`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::thread_specific_ptr` 变量为每个线程持有单独的指针。最初，这个指针等于 `NULL`；这就是为什么我们检查 `!p`
    并在它是 `NULL` 时打开一个连接。'
- en: So, when we enter `get_connection()` from the thread that has already initiated
    the pointer, `!p` will return the value `false` and we'll return the already opened
    connection. `delete` for the pointer will be called when the thread is exiting,
    so we do not need to worry about memory leaks.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们从已经初始化指针的线程进入 `get_connection()` 时，`!p` 将返回 `false` 的值，我们将返回已经打开的连接。当线程退出时，将调用
    `delete` 指针，所以我们不需要担心内存泄漏。
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You may provide your own cleanup function that will be called instead of `delete`
    at thread exit. A cleanup function must have the `void (*cleanup_function)(T*)`
    signature and will be passed during the `boost::thread_specific_ptr` construction.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提供一个自己的清理函数，该函数将在线程退出时调用而不是 `delete`。清理函数必须具有 `void (*cleanup_function)(T*)`
    签名，并在 `boost::thread_specific_ptr` 构造期间传递。
- en: C++11 has a special keyword, `thread_local`, to declare variables with thread
    local storage duration. C++11 has no `thread_specific_ptr` class, but you may
    use `thread_local boost::scoped_ptr<T>` or `thread_local std::unique_ptr<T>` to
    achieve the same behavior on compilers that support `thread_local`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 有一个特殊的关键字，`thread_local`，用于声明具有线程局部存储持续时间的变量。C++11 没有提供 `thread_specific_ptr`
    类，但您可以使用 `thread_local boost::scoped_ptr<T>` 或 `thread_local std::unique_ptr<T>`
    在支持 `thread_local` 的编译器上实现相同的行为。
- en: See also
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `Boost.Thread` documentation gives a lot of good examples on different cases;
    it can be found at [http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Thread` 文档提供了大量关于不同情况的好例子；它可以在 [http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)
    找到。'
- en: Reading this topic at [http://stackoverflow.com/questions/13106049/c11-gcc-4-8-thread-local-performance-penalty.html](http://stackoverflow.com/questions/13106049/c11-gcc-4-8-thread-local-performance-penalty.html)
    and about the `GCC__thread` keyword at [http://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/Thread-Local.html](http://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/Thread-Local.html)
    may give you some ideas about how `thread_local` is implemented in compilers and
    how fast it is
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读这个主题[http://stackoverflow.com/questions/13106049/c11-gcc-4-8-thread-local-performance-penalty.html](http://stackoverflow.com/questions/13106049/c11-gcc-4-8-thread-local-performance-penalty.html)以及关于`GCC__thread`关键字的[http://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/Thread-Local.html](http://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/Thread-Local.html)可能会给你一些关于编译器中`thread_local`是如何实现的以及它的速度如何的想法
- en: Interrupting a thread
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断线程
- en: 'Sometimes, we need to kill a thread that ate too many resources or that is
    just executing for too long. For example, some parser works in a thread (and actively
    uses `Boost.Thread`), but we already have the required amount of data from it,
    so parsing can be stopped. All we have is:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要终止消耗过多资源或执行时间过长的线程。例如，某些解析器在一个线程中工作（并积极使用`Boost.Thread`），但我们已经从它那里获得了所需的数据量，因此解析可以停止。我们只需要：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How can we do it?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何做到这一点？
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Almost nothing is required for this recipe. You only need to have at least basic
    knowledge of threads.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，几乎不需要什么。你只需要至少具备基本线程知识。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We can stop a thread by interrupting it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过中断来停止线程：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`Boost.Thread` provides some predefined interruption points in which the thread
    is checked for being interrupted via the `interrupt()` call. If the thread was
    interrupted, the exception `boost::thread_interrupted` is thrown.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Thread`提供了一些预定义的中断点，在这些中断点中，线程通过`interrupt()`调用被检查是否被中断。如果线程被中断，将抛出异常`boost::thread_interrupted`。'
- en: '`boost::thread_interrupted` is not derived from `std::exception`!'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::thread_interrupted`不是从`std::exception`派生的！'
- en: There's more...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As we know from the first recipe, if a function passed into a thread won't catch
    an exception and the exception will leave function bounds, the application will
    terminate. `boost::thread_interrupted` is the only exception to that rule; it
    may leave function bounds and does not `std::terminate()` application; instead,
    it stops the execution thread.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从第一个配方所知，如果一个传递给线程的函数不会捕获异常，并且异常将离开函数边界，应用程序将终止。`boost::thread_interrupted`是这一规则的唯一例外；它可以离开函数边界，并且不会`std::terminate()`应用程序；相反，它停止执行线程。
- en: 'We may also add interruption points at any point. All we need is to call `boost::this_thread::interruption_point()`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在任何地方添加中断点。我们只需要调用`boost::this_thread::interruption_point()`：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If interruptions are not required for a project, defining `BOOST_THREAD_DONT_PROVIDE_INTERRUPTIONS`
    gives a small performance boost and totally disables thread interruptions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目不需要中断，定义`BOOST_THREAD_DONT_PROVIDE_INTERRUPTIONS`可以提供一些性能提升，并完全禁用线程中断。
- en: 'C++11 has no thread interruptions but you can partially emulate them using
    atomic operations:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: C++11没有线程中断，但你可以使用原子操作部分模拟它们：
- en: Create an atomic Boolean variable
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个原子布尔变量
- en: Check the atomic variable in the thread and throw some exception if it has changed
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查线程中的原子变量，如果它已更改则抛出一些异常
- en: Do not forget to catch that exception in the function passed to the thread (otherwise
    your application will terminate)
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记在传递给线程的函数中捕获那个异常（否则你的应用程序将终止）
- en: However, this won't help you if the code is waiting somewhere in a conditional
    variable or in a sleep method.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果代码在条件变量或睡眠方法中的某个地方等待，这不会对你有所帮助。
- en: See also
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official documentation for `Boost.Thread` provides a list of predefined
    interruption points at [http://www.boost.org/doc/libs/1_53_0/doc/html/thread/thread_management.html#thread.thread_management.tutorial.interruption.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread/thread_management.html#thread.thread_management.tutorial.interruption.html)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Thread`的官方文档提供了预定义的中断点的列表，请参阅[http://www.boost.org/doc/libs/1_53_0/doc/html/thread/thread_management.html#thread.thread_management.tutorial.interruption.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread/thread_management.html#thread.thread_management.tutorial.interruption.html)'
- en: As an exercise, see the other recipes from this chapter and think of where additional
    interruption points would improve the code
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为练习，查看本章的其他配方，并思考在哪些地方添加额外的中断点可以改进代码
- en: Reading other parts of the `Boost.Thread` documentation may be useful; go to
    [http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读其他部分的`Boost.Thread`文档可能很有用；请访问[http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)
- en: Manipulating a group of threads
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作线程组
- en: 'Those readers who were trying to repeat all the examples by themselves or those
    who were experimenting with threads must already be bored with writing the following
    code to launch threads:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 那些试图自己重复所有示例的读者，或者那些在实验线程的读者，可能已经对编写以下代码来启动线程感到厌烦了：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Maybe there is a better way to do this?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有更好的方法来做这件事？
- en: Getting ready
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of threads will be more than enough for this recipe.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，对线程的基本知识将绰绰有余。
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We may manipulate a group of threads using the `boost::thread_group` class.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`boost::thread_group`类来操作一组线程。
- en: 'Construct a `boost::thread_group` variable:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个`boost::thread_group`变量：
- en: '[PRE35]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create threads into the preceding variable:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将线程创建到前面的变量中：
- en: '[PRE36]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now you may call functions for all the threads inside `boost::thread_group`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以调用`boost::thread_group`内部的所有线程的函数：
- en: '[PRE37]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::thread_group` variable just holds all the threads constructed or
    moved to it and may send some calls to all the threads.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::thread_group`变量仅保存构建或移动到其中的所有线程，并可能向所有线程发送一些调用。'
- en: There's more...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++11 has no `thread_group` class; it's Boost specific.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: C++11没有`thread_group`类；这是Boost特有的。
- en: See also
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official documentation of `Boost.Thread` may surprise you with a lot of
    other useful classes that were not described in this chapter; go to [http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Thread`的官方文档可能会让你惊讶于本章未描述的许多其他有用的类；请访问[http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html](http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html)'
