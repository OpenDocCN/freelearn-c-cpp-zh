["```cpp\n#ifdef RUNNING_WINDOWS \n#define WIN32_LEAN_AND_MEAN \n#include <windows.h> \n#include <Shlwapi.h> \n\n```", "```cpp\ninline std::string GetWorkingDirectory() \n{ \n   HMODULE hModule = GetModuleHandle(nullptr); \n   if (!hModule) { return \"\"; } \n   char path[256]; \n   GetModuleFileName(hModule,path,sizeof(path)); \n   PathRemoveFileSpec(path); \n   strcat_s(path,\"\"); \n   return std::string(path); \n} \n\n```", "```cpp\ninline std::vector<std::string> GetFileList( \n   const std::string& l_directory, \n   const std::string& l_search = \"*.*\") \n{ \n   std::vector<std::string> files; \n   if(l_search.empty()) { return files; } \n   std::string path = l_directory + l_search; \n   WIN32_FIND_DATA data; \n   HANDLE found = FindFirstFile(path.c_str(), &data); \n   if (found == INVALID_HANDLE_VALUE) { return files; } \n   do{ \n       if (!(data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) \n       { \n          files.emplace_back(data.cFileName); \n       } \n     }while (FindNextFile(found, &data)); \n   FindClose(found); \n   return files; \n} \n\n```", "```cpp\n#elif defined RUNNING_LINUX \n#include <unistd.h> \n#include <dirent.h> \n\n```", "```cpp\ninline std::string GetWorkingDirectory() \n{ \n   char cwd[1024]; \n   if(!getcwd(cwd, sizeof(cwd))){ return \"\"; } \n   return std::string(cwd) + std::string(\"/\"); \n} \n\n```", "```cpp\ninline std::vector<std::string> GetFileList( \n   const std::string& l_directory, \n   const std::string& l_search = \"*.*\") \n{ \n   std::vector<std::string> files; \n\n   DIR *dpdf; \n   dpdf = opendir(l_directory.c_str()); \n   if (!dpdf) { return files; } \n   if(l_search.empty()) { return files; } \n   std::string search = l_search; \n   if (search[0] == '*') { search.erase(search.begin()); } \n   if (search[search.length() - 1] == '*') { search.pop_back(); } \n  struct dirent *epdf; \n  while (epdf = readdir(dpdf)) { \n    std::string name = epdf->d_name; \n    if (epdf->d_type == DT_DIR) { continue; } \n    if (l_search != \"*.*\") { \n      if (name.length() < search.length()) { continue; } \n      if (search[0] == '.') { \n        if (name.compare(name.length() - search.length(), \n          search.length(), search) != 0) \n        { continue; } \n      } else if (name.find(search) == std::string::npos) { \n        continue; \n      } \n    } \n    files.emplace_back(name); \n  } \n  closedir(dpdf); \n  return files; \n} \n\n```", "```cpp\ninline void ReadQuotedString(std::stringstream& l_stream, \n  std::string& l_string) \n{ \n  l_stream >> l_string; \n  if (l_string.at(0) == '\"'){ \n    while (l_string.at(l_string.length() - 1) != '\"' || \n      !l_stream.eof()) \n    { \n      std::string str; \n      l_stream >> str; \n      l_string.append(\" \" + str); \n    } \n  } \n  l_string.erase(std::remove( \n    l_string.begin(), l_string.end(), '\"'), l_string.end()); \n} \n\n```", "```cpp\ntemplate<class T> \ninline T Interpolate(float tBegin, float tEnd, \n   const T& begin_val, const T& end_val, float tX) \n{ \n   return static_cast<T>(( \n      ((end_val - begin_val) / (tEnd - tBegin)) * \n      (tX - tBegin)) + begin_val); \n} \n\n```", "```cpp\ninline float GetSFMLTextMaxHeight(const sf::Text& l_text) { \n  auto charSize = l_text.getCharacterSize(); \n  auto font = l_text.getFont(); \n  auto string = l_text.getString().toAnsiString(); \n  bool bold = (l_text.getStyle() & sf::Text::Bold); \n  float max = 0.f; \n  for (size_t i = 0; i < string.length(); ++i) { \n    sf::Uint32 character = string[i]; \n    auto glyph = font->getGlyph(character, charSize, bold); \n    auto height = glyph.bounds.height; \n    if (height <= max) { continue; } \n    max = height; \n  } \n  return max; \n} \n\ninline void CenterSFMLText(sf::Text& l_text) { \n  sf::FloatRect rect = l_text.getLocalBounds(); \n  auto maxHeight = Utils::GetSFMLTextMaxHeight(l_text); \n  l_text.setOrigin( \n    rect.left + (rect.width * 0.5f), \n    rect.top + ((maxHeight >= rect.height ? \n      maxHeight * 0.5f : rect.height * 0.5f))); \n} \n\n```", "```cpp\n#include <random> \n#include <SFML/System/Mutex.hpp> \n#include <SFML/System/Lock.hpp> \n\nclass RandomGenerator { \npublic: \n  RandomGenerator() : m_engine(m_device()){} \n  ... \n  float operator()(float l_min, float l_max) { \n    return Generate(l_min, l_max); \n  } \n  int operator()(int l_min, int l_max) { \n    return Generate(l_min, l_max); \n  } \nprivate: \n  std::random_device m_device; \n  std::mt19937 m_engine; \n  std::uniform_int_distribution<int> m_intDistribution; \n  std::uniform_real_distribution<float> m_floatDistribution; \n  sf::Mutex m_mutex; \n}; \n\n```", "```cpp\nint Generate(int l_min, int l_max) { \n  sf::Lock lock(m_mutex); \n  if (l_min > l_max) { std::swap(l_min, l_max); } \n  if (l_min != m_intDistribution.min() || \n    l_max != m_intDistribution.max()) \n  { \n    m_intDistribution = \n      std::uniform_int_distribution<int>(l_min, l_max); \n  } \n  return m_intDistribution(m_engine); \n} \n\nfloat Generate(float l_min, float l_max) { \n  sf::Lock lock(m_mutex); \n  if (l_min > l_max) { std::swap(l_min, l_max); } \n  if (l_min != m_floatDistribution.min() || \n    l_max != m_floatDistribution.max()) \n  { \n    m_floatDistribution = \n      std::uniform_real_distribution<float>(l_min, l_max); \n  } \n  return m_floatDistribution(m_engine); \n} \n\n```", "```cpp\nclass Window; \nclass EventManager; \nclass TextureManager; \nclass FontManager; \n... \nstruct SharedContext{ \n  SharedContext(): \n    m_wind(nullptr), \n    m_eventManager(nullptr), \n    m_textureManager(nullptr), \n    m_fontManager(nullptr), \n    ... \n  {} \n\n  Window* m_wind; \n  EventManager* m_eventManager; \n  TextureManager* m_textureManager; \n  FontManager* m_fontManager; \n  ... \n}; \n\n```", "```cpp\nclass C_Base{ \npublic: \n  C_Base(const Component& l_type): m_type(l_type){} \n  virtual ~C_Base(){} \n\n  Component GetType() const { return m_type; } \n\n  friend std::stringstream& operator >>( \n    std::stringstream& l_stream, C_Base& b) \n    { \n      b.ReadIn(l_stream); \n      return l_stream; \n    } \n\n  virtual void ReadIn(std::stringstream& l_stream) = 0; \nprotected: \n  Component m_type; \n}; \n\n```", "```cpp\nclass EntityManager{ \npublic: \n  EntityManager(SystemManager* l_sysMgr, \n    TextureManager* l_textureMgr); \n  ~EntityManager(); \n\n  int AddEntity(const Bitmask& l_mask); \n  int AddEntity(const std::string& l_entityFile); \n  bool RemoveEntity(const EntityId& l_id); \n\n  bool AddComponent(const EntityId& l_entity, \n    const Component& l_component); \n\n  template<class T> \n  void AddComponentType(const Component& l_id) { ... } \n\n  template<class T> \n  T* GetComponent(const EntityId& l_entity, \n    const Component& l_component){ ... } \n\n  bool RemoveComponent(const EntityId& l_entity, \n    const Component& l_component); \n  bool HasComponent(const EntityId& l_entity, \n    const Component& l_component) const; \n  void Purge(); \nprivate: \n  ... \n}; \n\n```", "```cpp\nName Player \nAttributes 255 \n|Component|ID|Individual attributes| \nComponent 0 0 0 1 \nComponent 1 Player \nComponent 2 0 \nComponent 3 128.0 1024.0 1024.0 1 \nComponent 4 \nComponent 5 20.0 20.0 0.0 0.0 2 \nComponent 6 footstep:1,4 \nComponent 7 \n\n```", "```cpp\nclass S_Base : public Observer{ \npublic: \n  S_Base(const System& l_id, SystemManager* l_systemMgr); \n  virtual ~S_Base(); \n\n  bool AddEntity(const EntityId& l_entity); \n  bool HasEntity(const EntityId& l_entity) const; \n  bool RemoveEntity(const EntityId& l_entity); \n\n  System GetId() const; \n\n  bool FitsRequirements(const Bitmask& l_bits) const; \n  void Purge(); \n\n  virtual void Update(float l_dT) = 0; \n  virtual void HandleEvent(const EntityId& l_entity, \n    const EntityEvent& l_event) = 0; \nprotected: \n  ... \n}; \n\n```", "```cpp\nclass Observer{ \npublic: \n  virtual ~Observer(){} \n  virtual void Notify(const Message& l_message) = 0; \n}; \n\n```", "```cpp\nclass SystemManager{ \npublic: \n  ... \n  template<class T> \n  void AddSystem(const System& l_system) { ... } \n\n  template<class T> \n  T* GetSystem(const System& l_system){ ... } \n  void AddEvent(const EntityId& l_entity, const EventID& l_event); \n\n  void Update(float l_dT); \n  void HandleEvents(); \n  void Draw(Window* l_wind, unsigned int l_elevation); \n\n  void EntityModified(const EntityId& l_entity, \n    const Bitmask& l_bits); \n  void RemoveEntity(const EntityId& l_entity); \n\n  void PurgeEntities(); \n  void PurgeSystems(); \nprivate: \n  ... \n  MessageHandler m_messages; \n}; \n\n```", "```cpp\nclass MessageHandler{ \npublic: \n  bool Subscribe(const EntityMessage& l_type, \n    Observer* l_observer){ ... } \n  bool Unsubscribe(const EntityMessage& l_type, \n    Observer* l_observer){ ... } \n  void Dispatch(const Message& l_msg){ ... } \nprivate: \n  Subscribtions m_communicators; \n}; \n\n```", "```cpp\nusing Subscribtions = \n  std::unordered_map<EntityMessage,Communicator>; \n\n```", "```cpp\nclass Communicator{ \npublic: \n  virtual ~Communicator(){ m_observers.clear(); } \n  bool AddObserver(Observer* l_observer){ ... } \n  bool RemoveObserver(Observer* l_observer){ ... } \n  bool HasObserver(const Observer* l_observer) const { ... } \n  void Broadcast(const Message& l_msg){ ... } \nprivate: \n  ObserverContainer m_observers; \n}; \n\n```", "```cpp\n// Not memory-owning pointers. \nusing ObserverContainer = std::vector<Observer*>; \n\n```", "```cpp\ntemplate<typename Derived, typename T> \nclass ResourceManager{ \npublic: \n  ResourceManager(const std::string& l_pathsFile){ \n    LoadPaths(l_pathsFile); \n  } \n  virtual ~ResourceManager(){ ... } \n  T* GetResource(const std::string& l_id){ ... } \n  std::string GetPath(const std::string& l_id){ ... } \n  bool RequireResource(const std::string& l_id){ ... } \n  bool ReleaseResource(const std::string& l_id){ ... } \n  void PurgeResources(){ ... } \nprotected: \n  bool Load(T* l_resource, const std::string& l_path) { \n    return static_cast<Derived*>(this)->Load(l_resource, l_path); \n  } \nprivate: \n  ... \n}; \n\n```", "```cpp\nclass TextureManager : public ResourceManager<TextureManager, \n  sf::Texture> \n{ \npublic: \n  TextureManager() : ResourceManager(\"textures.cfg\"){} \n\n  bool Load(sf::Texture* l_resource, const std::string& l_path){ \n    return l_resource->loadFromFile( \n      Utils::GetWorkingDirectory() + l_path); \n  } \n}; \n\n```", "```cpp\nIntro media/Textures/intro.png \nPlayerSprite media/Textures/PlayerSheet.png \n... \n\n```", "```cpp\nclass Window{\npublic:\n  Window(const std::string& l_title = \"Window\",\n    const sf::Vector2u& l_size = {640,480},\n    bool l_useShaders = true);\n  ~Window();\n\n  void BeginDraw();\n  void EndDraw();\n\n  void Update();\n\n  bool IsDone() const;\n  bool IsFullscreen() const;\n  bool IsFocused() const;\n\n  void ToggleFullscreen(EventDetails* l_details);\n  void Close(EventDetails* l_details = nullptr);\n\n  sf::RenderWindow* GetRenderWindow();\n  Renderer* GetRenderer();\n  EventManager* GetEventManager();\n  sf::Vector2u GetWindowSize();\n  sf::FloatRect GetViewSpace();\nprivate:\n  ...\n};\n\n```", "```cpp\nenum class StateType { Intro = 1, MainMenu, Game, Loading }; \n\n```", "```cpp\nclass BaseState{ \nfriend class StateManager; \npublic: \n  BaseState(StateManager* l_stateManager)  \n    :m_stateMgr(l_stateManager), m_transparent(false), \n    m_transcendent(false){} \n  virtual ~BaseState(){} \n\n  virtual void OnCreate() = 0; \n  virtual void OnDestroy() = 0; \n\n  virtual void Activate() = 0; \n  virtual void Deactivate() = 0; \n\n  virtual void Update(const sf::Time& l_time) = 0; \n  virtual void Draw() = 0; \n  ... \n  sf::View& GetView(){ return m_view; } \n  StateManager* GetStateManager(){ return m_stateMgr; } \nprotected: \n  StateManager* m_stateMgr; \n  bool m_transparent; \n  bool m_transcendent; \n  sf::View m_view; \n}; \n\n```", "```cpp\nclass StateManager{ \npublic: \n  StateManager(SharedContext* l_shared); \n  ~StateManager(); \n  void Update(const sf::Time& l_time); \n  void Draw(); \n  void ProcessRequests(); \n  SharedContext* GetContext(); \n  bool HasState(const StateType& l_type) const; \n  StateType GetNextToLast() const; \n  void SwitchTo(const StateType& l_type); \n  void Remove(const StateType& l_type); \n  template<class T> \n  T* GetState(const StateType& l_type){ ... } \n  template<class T> \n  void RegisterState(const StateType& l_type) { ... } \n  void AddDependent(StateDependent* l_dependent); \n  void RemoveDependent(StateDependent* l_dependent); \nprivate: \n  ... \n  State_Loading* m_loading; \n  StateDependents m_dependents; \n}; \n\n```", "```cpp\nclass StateDependent { \npublic: \n  StateDependent() : m_currentState((StateType)0){} \n  virtual ~StateDependent(){} \n  virtual void CreateState(const StateType& l_state){} \n  virtual void ChangeState(const StateType& l_state) = 0; \n  virtual void RemoveState(const StateType& l_state) = 0; \nprotected: \n  void SetState(const StateType& l_state){m_currentState=l_state;} \n  StateType m_currentState; \n}; \n\n```", "```cpp\nclass Worker { \npublic: \n  Worker() : m_thread(&Worker::Work, this), m_done(false), \n    m_started(false) {} \n  void Begin() { \n    if(m_done || m_started) { return; } \n    m_started = true; \n    m_thread.launch(); \n  } \n  bool IsDone() const { return m_done; } \n  bool HasStarted() const { return m_started; } \nprotected: \n  void Done() { m_done = true; } \n  virtual void Work() = 0; \n  sf::Thread m_thread; \n  bool m_done; \n  bool m_started; \n}; \n\n```", "```cpp\nusing LoaderPaths = std::vector<std::pair<std::string, size_t>>; \n\nclass FileLoader : public Worker { \npublic: \n  FileLoader(); \n  void AddFile(const std::string& l_file);\n  virtual void SaveToFile(const std::string& l_file);\n\n  size_t GetTotalLines() const; \n  size_t GetCurrentLine() const; \nprotected: \n  virtual bool ProcessLine(std::stringstream& l_stream) = 0; \n  virtual void ResetForNextFile(); \n  void Work(); \n  void CountFileLines(); \n\n  LoaderPaths m_files; \n  size_t m_totalLines; \n  size_t m_currentLine; \n}; \n\n```", "```cpp\nFileLoader::FileLoader() : m_totalLines(0), m_currentLine(0) {}\nvoid FileLoader::AddFile(const std::string& l_file) {\n  m_files.emplace_back(l_file, 0);\n}\nsize_t FileLoader::GetTotalLines()const {\n  sf::Lock lock(m_mutex);\n  return m_totalLines;\n}\nsize_t FileLoader::GetCurrentLine()const {\n  sf::Lock lock(m_mutex);\n  return m_currentLine;\n}\nvoid FileLoader::SaveToFile(const std::string& l_file) {}\nvoid FileLoader::ResetForNextFile(){}\n```", "```cpp\nvoid FileLoader::Work() { \n  CountFileLines(); \n  if (!m_totalLines) { Done(); return; } \n  for (auto& path : m_files) { \n    ResetForNextFile(); \n    std::ifstream file(path.first); \n    std::string line; \n    std::string name; \n    auto linesLeft = path.second; \n    while (std::getline(file, line)) { \n      { \n        sf::Lock lock(m_mutex); \n        ++m_currentLine; \n        --linesLeft; \n      } \n      if (line[0] == '|') { continue; } \n      std::stringstream keystream(line); \n      if (!ProcessLine(keystream)) { \n        std::cout << \n          \"File loader terminated due to an internal error.\" \n          << std::endl; \n        { \n          sf::Lock lock(m_mutex); \n          m_currentLine += linesLeft; \n        } \n        break; \n      } \n    } \n    file.close(); \n  } \n  Done(); \n} \n\n```", "```cpp\nvoid FileLoader::CountFileLines() {\n  m_totalLines = 0;\n  m_currentLine = 0;\n  for (auto path = m_files.begin(); path != m_files.end();) {\n    if (path->first.empty()) { m_files.erase(path); continue; }\n    std::ifstream file(path->first);\n    if (!file.is_open()) {\n      std::cerr << “Failed to load file: “ << path->first\n        << std::endl;\n      m_files.erase(path);\n      continue;\n    }\n    file.unsetf(std::ios_base::skipws);\n    {\n      sf::Lock lock(m_mutex);\n      path->second = static_cast<size_t>(std::count(\n        std::istreambuf_iterator<char>(file),\n        std::istreambuf_iterator<char>(), ‘\\n’));\n      m_totalLines += path->second;\n    }\n    ++path;\n    file.close();\n  }\n}\n```", "```cpp\nusing LoaderContainer = std::vector<FileLoader*>; \n\nclass State_Loading : public BaseState { \npublic: \n  ... \n  void AddLoader(FileLoader* l_loader); \n  bool HasWork() const; \n  void SetManualContinue(bool l_continue); \n  void Proceed(EventDetails* l_details); \nprivate: \n  void UpdateText(const std::string& l_text, float l_percentage); \n  float CalculatePercentage(); \n  LoaderContainer m_loaders; \n  sf::Text m_text; \n  sf::RectangleShape m_rect; \n  unsigned short m_percentage; \n  size_t m_originalWork; \n  bool m_manualContinue; \n}; \n\n```", "```cpp\nvoid State_Loading::OnCreate() { \n  auto context = m_stateMgr->GetContext(); \n  context->m_fontManager->RequireResource(\"Main\"); \n  m_text.setFont(*context->m_fontManager->GetResource(\"Main\")); \n  m_text.setCharacterSize(14); \n  m_text.setStyle(sf::Text::Bold); \n\n  sf::Vector2u windowSize = m_stateMgr->GetContext()-> \n    m_wind->GetRenderWindow()->getSize(); \n\n  m_rect.setFillColor(sf::Color(0, 150, 0, 255)); \n  m_rect.setSize(sf::Vector2f(0.f, 32.f)); \n  m_rect.setOrigin(0.f, 16.f); \n  m_rect.setPosition(0.f, windowSize.y / 2.f); \n\n  EventManager* evMgr = m_stateMgr->GetContext()->m_eventManager; \n  evMgr->AddCallback(StateType::Loading, \"Key_Space\", \n    &State_Loading::Proceed, this); \n} \n\n```", "```cpp\nvoid State_Loading::OnDestroy() { \n  auto context = m_stateMgr->GetContext(); \n  EventManager* evMgr = context->m_eventManager; \n  evMgr->RemoveCallback(StateType::Loading, \"Key_Space\"); \n  context->m_fontManager->ReleaseResource(\"Main\"); \n} \n\n```", "```cpp\nvoid State_Loading::Update(const sf::Time& l_time) \n  if (m_loaders.empty()) {\n    if (!m_manualContinue) { Proceed(nullptr); }\n    return;\n  }\n  auto windowSize = m_stateMgr->GetContext()->\n    m_wind->GetRenderWindow()->getSize();\n  if (m_loaders.back()->IsDone()) {\n    m_loaders.back()->OnRemove();\n    m_loaders.pop_back();\n    if (m_loaders.empty()) {\n      m_rect.setSize(sf::Vector2f(\n        static_cast<float>(windowSize.x), 16.f));\n      UpdateText(\".Press space to continue.\", 100.f);\n      return;\n    }\n  }\n  if (!m_loaders.back()->HasStarted()) {\n    m_loaders.back()->Begin();\n  }\n\n  auto percentage = CalculatePercentage();\n  UpdateText(\"\", percentage);\n  m_rect.setSize(sf::Vector2f(\n    (windowSize.x / 100) * percentage, 16.f));\n}\n```", "```cpp\nvoid State_Loading::Draw() { \n  sf::RenderWindow* wind = m_stateMgr->GetContext()-> \n    m_wind->GetRenderWindow(); \n  wind->draw(m_rect); \n  wind->draw(m_text); \n} \n\n```", "```cpp\nvoid State_Loading::Proceed(EventDetails* l_details){ \n  if (!m_loaders.empty()) { return; } \n  m_stateMgr->SwitchTo(m_stateMgr->GetNextToLast()); \n} \n\n```", "```cpp\nvoid State_Loading::AddLoader(FileLoader* l_loader) {\n m_loaders.emplace_back(l_loader);\n  l_loader->OnAdd();\n}\nbool State_Loading::HasWork() const { return !m_loaders.empty(); }\nvoid State_Loading::SetManualContinue(bool l_continue) {\n  m_manualContinue = l_continue;\n}\nvoid State_Loading::Activate(){m_originalWork = m_loaders.size();}\n```", "```cpp\nenum class EventType { \n  KeyDown = sf::Event::KeyPressed, \n  KeyUp = sf::Event::KeyReleased, \n  MButtonDown = sf::Event::MouseButtonPressed, \n  MButtonUp = sf::Event::MouseButtonReleased, \n  MouseWheel = sf::Event::MouseWheelMoved, \n  WindowResized = sf::Event::Resized, \n  GainedFocus = sf::Event::GainedFocus, \n  LostFocus = sf::Event::LostFocus, \n  MouseEntered = sf::Event::MouseEntered, \n  MouseLeft = sf::Event::MouseLeft, \n  Closed = sf::Event::Closed, \n  TextEntered = sf::Event::TextEntered, \n  Keyboard = sf::Event::Count + 1, Mouse, Joystick, \n  GUI_Click, GUI_Release, GUI_Hover, GUI_Leave \n}; \n\nenum class EventInfoType { Normal, GUI }; \n\n```", "```cpp\nstruct EventInfo { \n  EventInfo() : m_type(EventInfoType::Normal), m_code(0) {} \n  EventInfo(int l_event) : m_type(EventInfoType::Normal), \n    m_code(l_event) {} \n  EventInfo(const GUI_Event& l_guiEvent): \n    m_type(EventInfoType::GUI), m_gui(l_guiEvent) {} \n  EventInfo(const EventInfoType& l_type) { \n    if (m_type == EventInfoType::GUI) { DestroyGUIStrings(); } \n    m_type = l_type; \n    if (m_type == EventInfoType::GUI){ CreateGUIStrings(\"\", \"\"); } \n  } \n\n  EventInfo(const EventInfo& l_rhs) { Move(l_rhs); } \n\n  EventInfo& operator=(const EventInfo& l_rhs) { \n    if (&l_rhs != this) { Move(l_rhs); } \n    return *this; \n  } \n\n  ~EventInfo() { \n    if (m_type == EventInfoType::GUI) { DestroyGUIStrings(); } \n  } \n  union { \n    int m_code; \n    GUI_Event m_gui; \n  }; \n\n  EventInfoType m_type; \nprivate: \n  void Move(const EventInfo& l_rhs) { \n    if (m_type == EventInfoType::GUI) { DestroyGUIStrings(); } \n    m_type = l_rhs.m_type; \n    if (m_type == EventInfoType::Normal){ m_code = l_rhs.m_code; } \n    else { \n      CreateGUIStrings(l_rhs.m_gui.m_interface, \n        l_rhs.m_gui.m_element); \n      m_gui = l_rhs.m_gui; \n    } \n  } \n\n  void DestroyGUIStrings() { \n    m_gui.m_interface.~basic_string(); \n    m_gui.m_element.~basic_string(); \n  } \n\n  void CreateGUIStrings(const std::string& l_interface, \n    const std::string& l_element) \n  { \n    new (&m_gui.m_interface) std::string(l_interface); \n    new (&m_gui.m_element) std::string(l_element); \n  } \n}; \n\n```", "```cpp\nstruct EventDetails { \n  EventDetails(const std::string& l_bindName): m_name(l_bindName){ \n    Clear(); \n  } \n\n  std::string m_name; \n  sf::Vector2i m_size; \n  sf::Uint32 m_textEntered; \n  sf::Vector2i m_mouse; \n  int m_mouseWheelDelta; \n  int m_keyCode; // Single key code. \n\n  std::string m_guiInterface; \n  std::string m_guiElement; \n  GUI_EventType m_guiEvent; \n\n  void Clear() { ... } \n}; \n\n```", "```cpp\nusing Events = std::vector<std::pair<EventType, EventInfo>>; \n\nstruct Binding { \n  Binding(const std::string& l_name) : m_name(l_name), \n    m_details(l_name), c(0) {} \n  void BindEvent(EventType l_type, EventInfo l_info = EventInfo()) \n  { ... } \n\n  Events m_events; \n  std::string m_name; \n  int c; // Count of events that are \"happening\". \n\n  EventDetails m_details; \n}; \n\n```", "```cpp\nusing Bindings = std::unordered_map<std::string, \n  std::unique_ptr<Binding>>; \nusing CallbackContainer = std::unordered_map<std::string, \n  std::function<void(EventDetails*)>>; \nenum class StateType; \nusing Callbacks = std::unordered_map<StateType, \n  CallbackContainer>; \n\n```", "```cpp\nWindow_close 0:0 \nFullscreen_toggle 5:89 \nIntro_Continue 5:57 \nMouse_Left 9:0 \n\n```", "```cpp\nclass EventManager : public StateDependent{ \npublic: \n  ... \n  bool AddBinding(std::unique_ptr<Binding> l_binding); \n  bool RemoveBinding(std::string l_name); \n  void ChangeState(const StateType& l_state); \n  void RemoveState(const StateType& l_state); \n  void SetFocus(bool l_focus); \n\n  template<class T> \n  bool AddCallback(const StateType& l_state, \n    const std::string& l_name,  \n    void(T::*l_func)(EventDetails*), T* l_instance) \n  { ... } \n\n  template<class T> \n  bool AddCallback(const std::string& l_name, \n    void(T::*l_func)(EventDetails*), T* l_instance) \n  { ... } \n\n  bool RemoveCallback(const StateType& l_state, \n    const std::string& l_name){ ... } \n  void HandleEvent(sf::Event& l_event); \n  void HandleEvent(GUI_Event& l_event); \n  void Update(); \n  sf::Vector2i GetMousePos(sf::RenderWindow* l_wind = nullptr) \n    const { ... } \nprivate: \n  ... \n  Bindings m_bindings; \n  Callbacks m_callbacks; \n}; \n\n```", "```cpp\nclass GUI_Manager : public StateDependent{ \n  friend class GUI_Interface; \npublic: \n  ... \n  bool AddInterface(const StateType& l_state, \n    const std::string& l_name); \n  bool AddInterface(const std::string& l_name); \n  GUI_Interface* GetInterface(const StateType& l_state, \n    const std::string& l_name); \n  GUI_Interface* GetInterface(const std::string& l_name); \n  bool RemoveInterface(const StateType& l_state, \n    const std::string& l_name); \n  bool RemoveInterface(const std::string& l_name); \n  bool LoadInterface(const StateType& l_state, \n    const std::string& l_interface, const std::string& l_name); \n  bool LoadInterface(const std::string& l_interface, \n    const std::string& l_name); \n  void ChangeState(const StateType& l_state); \n  void RemoveState(const StateType& l_state); \n  SharedContext* GetContext() const; \n  void DefocusAllInterfaces(); \n  void HandleClick(EventDetails* l_details); \n  void HandleRelease(EventDetails* l_details); \n  void HandleTextEntered(EventDetails* l_details); \n  void AddEvent(GUI_Event l_event); \n  bool PollEvent(GUI_Event& l_event); \n  void Update(float l_dT); \n  void Render(sf::RenderWindow* l_wind); \n  template<class T> \n  void RegisterElement(const GUI_ElementType& l_id){ ... } \nprivate: \n  ... \n}; \n\n```", "```cpp\nInterface MainMenu MainMenu.style 0 0 Immovable NoTitle \"Main menu\" \nElement Label Title 100 0 MainMenuTitle.style \"Main menu:\" \nElement Label Play 0 32 MainMenuLabel.style \"PLAY\" \nElement Label Credits 0 68 MainMenuLabel.style \"CREDITS\" \nElement Label Quit 0 104 MainMenuLabel.style \"EXIT\" \n\n```", "```cpp\nState Neutral \nSize 300 32 \nBgColor 255 0 0 255 \nTextColor 255 255 255 255 \nTextSize 14 \nFont Main \nTextPadding 150 16 \nTextOriginCenter \n/State \n\nState Hover \nBgColor 255 100 0 255 \n/State \n\nState Clicked \nBgColor 255 150 0 255 \n/State \n\n```", "```cpp\nclass Map : public FileLoader{ \npublic: \n  ... \n  Tile* GetTile(unsigned int l_x, unsigned int l_y, \n    unsigned int l_layer); \n  TileInfo* GetDefaultTile(); \n  TileSet* GetTileSet(); \n  unsigned int GetTileSize()const; \n  sf::Vector2u GetMapSize()const; \n  sf::Vector2f GetPlayerStart()const; \n  int GetPlayerId()const; \n  void PurgeMap(); \n  void AddLoadee(MapLoadee* l_loadee); \n  void RemoveLoadee(MapLoadee* l_loadee); \n  void Update(float l_dT); \n  void Draw(unsigned int l_layer); \nprotected: \n  bool ProcessLine(std::stringstream& l_stream); \n  ... \n}; \n\n```", "```cpp\nclass MapLoadee { \npublic: \n  virtual void ReadMapLine(const std::string& l_type, \n    std::stringstream& l_stream) = 0; \n}; \n\n```", "```cpp\nSIZE 64 64 \nDEFAULT_FRICTION 1.0 1.0 \n|ENTITY|Name|x|y|elevation| \nENTITY Player 715 360 1 \nENTITY Skeleton 256.0 768.0 1 \n|TILE|ID|x|y|layer|solid| \nTILE 0 0 0 0 0 \nTILE 0 0 1 0 0 \nTILE 0 0 2 0 0 \n... \n\n```", "```cpp\nclass SpriteSheet{ \npublic: \n  ... \n  void CropSprite(const sf::IntRect& l_rect); \n  const sf::Vector2u& GetSpriteSize()const; \n  const sf::Vector2f& GetSpritePosition()const; \n  void SetSpriteSize(const sf::Vector2u& l_size); \n  void SetSpritePosition(const sf::Vector2f& l_pos); \n  void SetDirection(const Direction& l_dir); \n  Direction GetDirection() const; \n  void SetSheetPadding(const sf::Vector2f& l_padding); \n  void SetSpriteSpacing(const sf::Vector2f& l_spacing); \n  const sf::Vector2f& GetSheetPadding()const; \n  const sf::Vector2f& GetSpriteSpacing()const; \n  bool LoadSheet(const std::string& l_file); \n  void ReleaseSheet(); \n  Anim_Base* GetCurrentAnim(); \n  bool SetAnimation(const std::string& l_name, \n    bool l_play = false, bool l_loop = false); \n  void Update(float l_dT); \n  void Draw(sf::RenderWindow* l_wnd); \nprivate: \n  ... \n  Animations m_animations; \n}; \n\n```", "```cpp\nusing Animations = std::unordered_map<std::string, \n  std::unique_ptr<Anim_Base>>; \n\n```", "```cpp\nclass Anim_Base{ \n  friend class SpriteSheet; \npublic: \n  ... \n  void SetSpriteSheet(SpriteSheet* l_sheet); \n  bool SetFrame(Frame l_frame); \n  void SetStartFrame(Frame l_frame); \n  void SetEndFrame(Frame l_frame); \n  void SetFrameRow(unsigned int l_row); \n  void SetActionStart(Frame l_frame); \n  void SetActionEnd(Frame l_frame); \n  void SetFrameTime(float l_time); \n  void SetLooping(bool l_loop); \n  void SetName(const std::string& l_name); \n  SpriteSheet* GetSpriteSheet(); \n  Frame GetFrame() const; \n  Frame GetStartFrame() const; \n  Frame GetEndFrame() const; \n  unsigned int GetFrameRow() const; \n  int GetActionStart() const; \n  int GetActionEnd() const; \n  float GetFrameTime() const; \n  float GetElapsedTime() const; \n  bool IsLooping() const; \n  bool IsPlaying() const; \n  bool IsInAction() const; \n  bool CheckMoved(); \n  std::string GetName() const; \n  void Play(); \n  void Pause(); \n  void Stop(); \n  void Reset(); \n  virtual void Update(float l_dT); \n  friend std::stringstream& operator >>( \n    std::stringstream&l_stream, Anim_Base& a){ ... } \nprotected: \n  virtual void FrameStep() = 0; \n  virtual void CropSprite() = 0; \n  virtual void ReadIn(std::stringstream& l_stream) = 0; \n  ... \n}; \n\n```", "```cpp\nclass SoundManager : public StateDependent{ \npublic: \n  SoundManager(AudioManager* l_audioMgr); \n  ~SoundManager(); \n\n  void ChangeState(const StateType& l_state); \n  void RemoveState(const StateType& l_state); \n\n  void Update(float l_dT); \n\n  SoundID Play(const std::string& l_sound, \n    const sf::Vector3f& l_position, \n    bool l_loop = false, bool l_relative = false); \n  bool Play(const SoundID& l_id); \n  bool Stop(const SoundID& l_id); \n  bool Pause(const SoundID& l_id); \n\n  bool PlayMusic(const std::string& l_musicId, \n    float l_volume = 100.f, bool l_loop = false); \n  bool PlayMusic(const StateType& l_state); \n  bool StopMusic(const StateType& l_state); \n  bool PauseMusic(const StateType& l_state); \n\n  bool SetPosition(const SoundID& l_id, \n    const sf::Vector3f& l_pos); \n  bool IsPlaying(const SoundID& l_id) const; \n  SoundProps* GetSoundProperties(const std::string& l_soundName); \n\n  static const int Max_Sounds = 150; \n  static const int Sound_Cache = 75; \nprivate: \n  ... \n  AudioManager* m_audioManager; \n}; \n\n```", "```cpp\nstruct SoundProps{ \n  SoundProps(const std::string& l_name): m_audioName(l_name), \n    m_volume(100), m_pitch(1.f), m_minDistance(10.f), \n    m_attenuation(10.f){} \n  std::string m_audioName; \n  float m_volume; \n  float m_pitch; \n  float m_minDistance; \n  float m_attenuation; \n}; \n\n```"]