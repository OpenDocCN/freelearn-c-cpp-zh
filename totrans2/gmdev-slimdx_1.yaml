- en: Chapter 1. Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So maybe you have played with XNA Game Studio and already know that it can help
    you get a small game going relatively quickly. As you get better with it, you
    start to uncover its limitations. You'd prefer to have the full power of DirectX
    available to you in C#, since C# is nicer to work in than C++. Is there an alternative
    to XNA that can give you this? The answer is yes. **SlimDX** will give you that
    power in C#. It also gives you the power to work with different versions of DirectX
    as well. This means that you can make your games support multiple DirectX versions
    so that they can run on more computers, expanding your potential user base.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Visual Studio 2013 Express and SlimDX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our initial framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GameWindow class and the GameLoop method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing our game window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Visual Studio 2013 Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using Visual Studio 2013 Express since it is freely available from
    Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to set up Visual Studio 2013 Express:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To download Visual Studio 2013 Express, you can visit the Microsoft website
    at: [http://www.visualstudio.com/downloads/download-visual-studio-vs](http://www.visualstudio.com/downloads/download-visual-studio-vs).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This website will show you all of the Express versions of Visual Studio that
    are available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will have to choose **Visual Studio Express 2013 for Windows Desktop** since
    we are focusing on PC development. Click on it to expand its section of the page,
    and then click on the **Install now** link to begin downloading the installer
    (`wdexpress_full.exe`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you've downloaded the installer for Visual Studio 2013 Express, it's
    time to install it. Just double-click on the installer file to begin the installation
    process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you start up Visual Studio 2013 Express, you will get a window asking you
    to log in with your Microsoft account. This is the account you will use to log
    in to your Hotmail account or your Xbox 360 (if you have one).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you log in, Visual Studio 2013 Express will be registered to your Microsoft
    account. This is a smoother process than what it used to be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up SlimDX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we need to download and install SlimDX. You can get SlimDX from its official
    website: [http://www.slimdx.org.](http://www.slimdx.org.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to set up SlimDX:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you go to the SlimDX website, click on the **Download** tab at the top
    of the page. This will take you to the downloads page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the time of this writing, the January 2012 release of SlimDX is the latest
    version. In order to create SlimDX-based software, we need to get the **SlimDX
    Developer SDK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So go to the section of the page with the heading **Developer SDK**. There is
    a short paragraph here and an orange button that says **Install Developer SDK**.
    As you can see from the short paragraph, this SDK contains all of the SlimDX binaries
    (the compiled SlimDX software), documentation, and samples. The SDK also supports
    both 32- and 64-bit systems. Click on the **Install Developer SDK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This opens a second web page with a link at the top to a file called `SlimDX
    SDK (January 2012).msi`. Click on this link to begin downloading the SlimDX Developer
    SDK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the download has completed, simply double-click on the installer file to
    begin the installation process. When the installer is finished, click on the **Finish**
    button to close it. We are now ready to write our first bits of code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make things easier, we will make a framework project that will contain code
    that we will use in numerous demo projects. It will be a class library that will
    hold our **engine code** . It is code that is not specific to a particular game,
    but rather is designed to be able to be re-used in multiple game development projects.
    If this sounds complicated, don't worry. It is really very easy to do. We will
    use the term **game code** to refer to code that is specific to a certain game.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should *always* keep your engine code separated from your game code as much
    as possible. This increases the reusability of your engine code so that you can
    use it in multiple game development projects much more easily. This can also potentially
    save you a lot of time on future projects since you won't have to start completely
    from scratch every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to create a Visual Studio project that will store our framework
    code and resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio Express, if you haven't already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **New Project...** link on the left-hand side of the **Start Page**,
    or from the **FILE** menu, choose **New** **Project...**; either way you will
    end up in the **New Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to choose the type of project we wish to create. In this case, we first
    need to click on the **Visual C#** category in the left-hand side column. The
    screen changes to show C# project types in the center portion of the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now select **Class Library** shown in the middle of the window. A class library
    is just that, a library of classes. It cannot be executed by itself though.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a name for the project in the **Name** textbox at the bottom of the window.
    We'll call this project `SlimFramework`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don't have one ready, you will need to create a folder somewhere on your
    computer to store your work. Then specify that folder in the **Location** textbox
    at the bottom of the window shown in the following screenshot:![Creating a framework](img/7389OS_01_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The New Project window
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can click on the **Browse** button to open a folder browser window that
    you can use to specify the folder you want to save to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the **Create directory for solution** checkbox checked so that Visual
    Studio will make a subfolder to put this project in. Your **New Project** window
    should look like the previous screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **OK** button to create the `SlimFramework` project. Visual Studio
    will create the project and display the `Class1.cs` file. It is just an empty
    class for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make a game, we first need a window to display our game in. So we will start
    our framework by creating a simple game window class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Class1.cs` file in the **Solution Explorer** pane. The **Solution
    Explorer** pane is on the upper-right portion of the Visual Studio window and
    allows us to see the files in our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is not there, you can access it by opening the **VIEW** menu and choosing
    **Solution Explorer** to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Class1.cs` file and rename it to `GameWindow.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may get a message box asking if you want to also rename all references to
    the code element `Class1`. If you click on **Yes**, it will replace any occurrences
    of `Class1` in your code with the new name so that your code won't be broken since
    you renamed the class. You will usually need to click on **Yes** for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we can start creating this class though, we need to add some references
    to our project. To accomplish this, right-click on the heading **References**
    in the **Solution Explorer** pane and choose **Add Reference...**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Reference Manager** window will appear. The **Framework** category is
    currently selected, which is fine, because two of the references we need are in
    this category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down the list until you find **System.Windows.Forms**. A checkbox appears
    for the highlighted extension. Check this checkbox since we want to add a reference
    to this extension. This is shown in the following screenshot:![Creating a framework](img/7389OS_01_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a reference to System.Windows.Forms
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, scroll up to find **System.Drawing** and put a check in its checkbox too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to select the **Extensions** category in the left-hand side column.
    This causes the list in the center of the window to display extensions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down until you find **SlimDX** in the list. You will find that there
    are two versions. You will have to select Version 4 as shown in the following
    screenshot:![Creating a framework](img/7389OS_01_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a reference to SlimDX
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **OK** button and Visual Studio will add all of the references
    we specified to the project for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you now expand the **References** heading in the **Solution Explorer** pane,
    you will see that **SlimDX** now appears in the list of references that our project
    is using, as do **System.Windows.Forms** and **System.Drawing**. Now that we have
    added our references, we will be able to use SlimDX in our project.
  prefs: []
  type: TYPE_NORMAL
- en: The GameWindow class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GameWindow` class will provide basic game window functionality. It will
    provide all of the basic properties we want to have in our game window, and it
    will be used as a base class. We will not be making many game window subclasses
    in this book, but the idea here is that you can make different subclasses for
    different types of game windows. For example, you can have a game window class
    for DirectX 10 as well as a game window class for DirectX 11.
  prefs: []
  type: TYPE_NORMAL
- en: The main things we need to implement for the `GameWindow` class are a constructor
    to initialize it, **Game Loop** , `UpdateScene()` and `RenderScene()` methods,
    and a cleanup code for when the window is closed. A game loop is a method that
    is essentially the heart of a game engine. It is called repeatedly as long as
    the game is running. It is called once per frame in order to run the code that
    makes everything happen in our game world. It calls the `UpdateScene()` method,
    which updates objects in our game world. For example, this method will call on
    the physics system to simulate the physics for objects that are moving around
    in our game world.
  prefs: []
  type: TYPE_NORMAL
- en: Once `UpdateScene()` has finished updating the states of all of the objects
    in our game world, the game loop will then call the `RenderScene()` method to
    draw the current frame. So ultimately, the game loop simulates and draws the game
    world frame-by-frame. Each time it is called, it simulates another frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'A video game is composed of frames, just like movies are, except that in a
    video game each frame is being generated on the fly by the computer. Ideally,
    we want a game to run at least at 30 FPS (frames per second) so that the video
    is smooth. If the frame rate is too low, the game''s video will become choppy,
    or worse the game can become unplayable. Let''s go ahead and get started with
    implementing our `GameWindow` class. First, we need to add some `using` statements
    at the beginning of the `GameWindow.cs` file so that we can use some classes defined
    by SlimDX and the .NET Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: In some places in this book, not all code is shown due to space constraints.
    I will make a note of it when this is the case, so you will need to download the
    code for this book to see the full code for some demos.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a member variables section at the beginning of the `GameWindow`
    class. Inside it, we will define all of the member variables for storing various
    information about the game window. Here is the the finished member variables section
    in the `GameWindow` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Most of these are fairly self-explanatory, but I'll run through them just in
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The downloadable code for this book is fully commented. I've removed comments
    here to save space and make the page look clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of our member variables and what each one is for:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Member variables | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `m_IsDisposed` | Simply indicates whether or not our game window has been
    disposed of. |'
  prefs: []
  type: TYPE_TB
- en: '| `m_IsInitialized` | Indicates whether or not our game window has been initialized
    yet. |'
  prefs: []
  type: TYPE_TB
- en: '| `m_IsFullScreen` | Indicates whether or not the game window is running in
    full-screen mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `m_IsPaused` | This, of course, indicates whether or not the game window
    is paused. |'
  prefs: []
  type: TYPE_TB
- en: '| `m_Form` | This holds the SlimDX `RenderForm` object that represents the
    game window itself. |'
  prefs: []
  type: TYPE_TB
- en: '| `m_ClearColor` | This simply specifies the color to use whenever the screen
    is cleared. This is essentially the background color that we start with when we
    draw our scene. |'
  prefs: []
  type: TYPE_TB
- en: '| `m_CurrFrameTime` | Holds the time in ticks when we start processing the
    current frame. |'
  prefs: []
  type: TYPE_TB
- en: '| `m_LastFrameTime` | Holds the time in ticks when we start processing the
    previous frame. |'
  prefs: []
  type: TYPE_TB
- en: '| `m_FrameCount` | This is only used by the debug code in the `GameLoop()`
    method. |'
  prefs: []
  type: TYPE_TB
- en: '| `m_FPS` | Holds the current FPS (frames per second) that the game loop is
    running at. |'
  prefs: []
  type: TYPE_TB
- en: Now that we've created our member variables, we need to make some **properties**
    to provide access to the ones that need to be accessible from outside of this
    class. A property is just a pair of methods for getting and setting the value
    of the member variable it represents. These methods are often called **accessor
    methods** or **accessors**. Most of the variables we just created will have accessors,
    but we don't have room to show them all here, so we will just look at the first
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check out the downloadable code to see the rest of the accessor methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `ClearColor` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `ClearColor` property defines both the `get` and `set` methods.
    The `set` method is declared `protected` so that this property can only be set
    by this class or subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we need to set up a constructor for our `GameWindow` class. Here is the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines of code simply set the basic properties of the window to
    the values that have been passed into the constructor. The next line sets the
    default color, which is black. This means that each time we draw a new frame,
    we start with an empty black screen. The color is an **ARGB** (**Alpha, Red, Green,
    and Blue**) value. As you can see, this line sets all of the color channels to
    a value of `0.0f` (except for alpha)which gives us the color black. A value of
    `1.0f` for alpha means the color is opaque, while a value of `0.0f` would make
    it completely transparent. A value of `0.5f` would make the color 50 percent transparent.
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines create the `RenderForm` object, set its title text, and initialize
    it to the size that was passed into the constructor. `RenderForm` is a SlimDX
    class that represents a window for us to draw on. And finally, the last line simply
    subscribes the `GameWindow` class to the `Closed` event of the `RenderForm` object.
    This causes the `GameWindow` class to be notified when the window is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our constructor, we need to define an event handler for the
    event we just subscribed the `GameWindow` class to. As you might guess, this event
    is fired when the game window is closed (either by the user or programmatically).
    Here is the code, which is pretty short as you can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement checks to see if the game window has already been disposed
    of. If not, then it calls the `Dispose()` method to dispose of it.
  prefs: []
  type: TYPE_NORMAL
- en: The IDisposable interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, the declaration of our `GameWindow` class says that it does not
    inherit from any other class, nor does it implement an interface. We are going
    to change this because we are going to implement the `IDisposable` interface.
    It is a very small interface so implementing it will be quick. First, we need
    to edit the declaration of our class to say that it will be implementing this
    interface. To do this, simply go to the beginning of the `GameWindow` class and
    change `public class GameWindow` to `public class GameWindow : IDisposable`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This tells the compiler that this class implements the `IDisposable` interface.
    Now we have to adhere to this interface. It has one method that we need to implement.
    This method will perform cleanup operations when the game window is closed. There
    isn''t much in this function at the moment, but here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Dispose(bool)` method is protected because we do not want it to be called
    from outside of the `GameWindow` class. Instead, we will create the second `Dispose()`
    method that is `public` and has no parameters. This way we can tell the object
    that we are done with it by calling this public method, and it will take care
    of cleaning up after itself. The `Dispose(bool)` method starts by checking to
    see if the game window has already been disposed of. If not, then it checks to
    see if the `disposing` parameter is set to `true`. This parameter simply indicates
    whether the game window is disposing of itself or whether it is being disposed
    of by the **Garbage Collector**.
  prefs: []
  type: TYPE_NORMAL
- en: The Garbage Collector is a part of managed languages such as C#. When your program
    is no longer using an object, the Garbage Collector will reclaim the memory that
    object was using so that it can be used for something else. This will only happen
    if the program no longer has any references to the object. However, the Garbage
    Collector is not guaranteed to reclaim that memory immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should avoid creating large numbers of objects that you only use for a short
    time. This can keep the Garbage Collector much busier and you will pay the price
    in the form of lower FPS or lag spikes.
  prefs: []
  type: TYPE_NORMAL
- en: If the `disposing` parameter is set to `true`, then the code inside the `if`
    statement will unregister events and call the `Dispose()` method on any managed
    objects it is using. Currently, it only unregisters the `Closed` event that we
    previously subscribed to. Then, the code following the `if` statement cleans up
    any unmanaged objects that it may be using. We won't have any unmanaged objects
    since we are using only **managed** code. Managed means that memory management
    is handled automatically for us for the most part.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, at the end of this method, the `m_IsDisposed` member variable is set
    to `true`. This indicates that the window has been disposed of so the `RenderScene()`
    method will know that it should not try to render anything anymore, as doing so
    can cause the program to crash. We'll discuss the `RenderScene()` method in a
    moment, but first we need to finish with `IDisposable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to implement the public `Dispose()` method, which is a very short
    method as you can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This method calls the `Dispose(bool)` method to dispose of the game window.
    The value `true` is passed in because this method is part of the `GameWindow`
    class, and thus the `GameWindow` class is disposing of itself in this case. Then
    we call `GC.SuppressFinalize(this)` to tell the Garbage Collector that this object
    has already been disposed of. You may have noticed that we never implemented `Finalizer`
    in this class. This is because the `Finalize()` method is used to clean up unmanaged
    resources in the object. It is called automatically by the Garbage Collector before
    it destroys the object. This allows it to clean up its unmanaged resources before
    it is destroyed. As such, we do not need to implement this method since we are
    only using managed code.
  prefs: []
  type: TYPE_NORMAL
- en: The GameLoop method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we need to create our game loop. As mentioned earlier, the game loop is
    the main block of code that repeats endlessly until we close our game. It calls
    the code that will process and draw each frame, so it is essentially the heart
    of the game. We will create a new `GameLoop()` method that will be our game loop.
    Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we first take the value of `m_CurrFrameTime` and copy it
    into `m_LastFrameTime`. Each time this function is called, we are processing a
    new frame. This means the value in `m_CurrFrameTime` now is the time for the previous
    frame. So we copy it into that variable. Next, we get the current time from the
    high performance timer and store it in `m_CurrFrameTime` via the `StopWatch` class.
    This class uses the high performance hardware timer, if it is available. Most
    PCs now have them, so this should not be a problem. Next, we go ahead and call
    the `UpdateScene()` and `RenderFrame()` methods. The `UpdateScene()` method is
    just an empty method for now, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we calculate our FPS based on the duration of the previous frame. We
    simply take `StopWatch.Frequency` and divide it by the duration of the previous
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter of the `UpdateScene()` method is the amount of time that has
    elapsed since the last time `UpdateScene()` was called. So we calculate that by
    subtracting the previous frame''s time from the current frame''s time. We then
    divide by `StopWatch.Frequency` to convert the result into seconds. This is necessary
    because the `StopWatch.GetTimeStamp()` function returns the current time in ticks.
    Essentially, it is a count of how many ticks have elapsed on the system timer
    since Windows was last booted up. The `StopWatch.Frequency` property tells us
    how many ticks our system timer does in one second. This is important because
    the timer in one computer may be faster or slower than the timer in another. The
    `RenderScene()` method is mostly empty for now too, but it does have a simple
    `if` statement in it though. Here is its code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement in the `RenderScene()` method checks to see if the game window
    is ready for rendering. If the game window has not been initialized yet, or if
    the game window has been disposed of, then we simply return out of this function.
    This is important because it prevents possible crashing when the game window first
    starts up and when it shuts down.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `IsInitialized` and `IsDisposed` are two of the properties we talked
    about earlier for our member variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We almost have a functional `GameWindow` class now. But we need to add a `StartGameLoop()`
    method. This method is called to start up the game loop. It only contains the
    following few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, this function checks if the game window has already been initialized.
    If so, then we simply return out of this function. Otherwise, we set the `m_IsInitialized`
    member variable to `true` to indicate that it has been initialized. This function
    is essentially the initialization function for our game loop. And lastly, it calls
    `MessagePump.Run` passing in our `RenderForm` object (the game window itself)
    and our `GameLoop()` function. This will cause the `GameLoop()` function to be
    called repeatedly until we close the game window. (`RenderForm` and `MessagePump`
    are SlimDX classes.)
  prefs: []
  type: TYPE_NORMAL
- en: So why do we need `MessagePump`? In Windows, applications receive messages,
    which are just notifications that something has occurred. For example, a key press
    will generate a key pressed message. These messages are sent to whichever window
    is currently active. That program can then process and respond to the message.
  prefs: []
  type: TYPE_NORMAL
- en: In a game, we want a loop that runs continuously to simulate and draw each frame
    immediately after the previous one. We still have to handle messages from Windows
    though, or our game window will not work correctly anymore. For example, if we
    just had the program stuck in a loop, never checking Windows messages, then nothing
    will happen when you try to close the window since the program will never process
    the close message. So, we use this `MessagePump` class to handle Windows messages
    for us while running our game loop.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our game window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is now time for us to test our game window! We will add a second project
    to our solution. With the `SlimFramework` solution still open, open the **FILE**
    menu, and select **New Project...**. Name the new project, for example, `Ch01`.
    Make sure you change the selected project type to **Windows Forms Application**.
    Also, it is very important that you make sure that the **Solution** drop-down
    list at the bottom of the window is set to **Add to solution** or Visual Studio
    will create a new solution instead of adding this project to our existing solution.
    If this option is not present, then it will add the new project to this solution.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **OK** and the new project will be created and added to our solution.
    Right-click on it in the **Solution Explorer** pane and choose **Set as StartUp
    Project**. By doing this, we've told Visual Studio that this is the project we
    want to start up when we tell it to run our code.
  prefs: []
  type: TYPE_NORMAL
- en: The `SlimFramework` project can't be the startup project since it is just a
    class library, and therefore cannot execute on its own. This is because the `Class
    Library` project type does not have the `Main` method, like a `Console Application`
    or `Windows Forms Application` does. A Main Method is the first method that is
    called when the program starts up. So it is essentially the starting point of
    the program. You should also delete the `Form1.cs` file from this new project
    since we don't need it.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to add a reference to our project. Right-click on the **References**
    heading for the `Ch01` project in the **Solution Explorer** pane. Then click on
    **Add Reference...**. In the **Reference Manager** window, select the **Projects**
    category. Now check the checkbox next to the `SlimFramework` project. Click on
    **OK** and Visual Studio will add a reference to the `SlimFramework` project into
    the `Ch01` project. We can now use classes defined in the `SlimFramework` project
    in `Ch01`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add a couple of lines of code to the `Main` method in our
    new `Ch01` project. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code is fairly simple. The first two lines were already there, created
    by Visual Studio. I removed the third line that Visual Studio added—which made
    a call to `Application.Run()`—since we don't need it. The next line simply creates
    a new `GameWindow` object and passes in parameters to specify the title of the
    window, the width and height of the window, and lastly whether or not we want
    to run it in fullscreen mode. In this case, we set the window title to `Our First
    Game Window`, and the window size to `640x480`. And lastly, we pass in the value
    `false` for the last parameter since we do not want to run in fullscreen mode,
    as we haven't implemented it yet anyway. The last line of code in this method
    calls the `GameWindow` class's `StartGameLoop()` method to start up the game loop.
    The parameter of the `Main()` method is simply a `String` array that contains
    any command-line arguments that were passed in when the application was started.
    You would simply add code somewhere that would process the passed in command-line
    arguments, if any. This is how you would add some command-line switches to your
    game.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to compile and run our code. To do this, click on the **Start**
    button on Visual Studio's toolbar. This button has a green triangle icon beside
    it. The following screenshot shows what our game window looks like when you run
    the program. You may recall that we set black as our default background color,
    but the background of this window is not very black. This is not a bug, it is
    simply because we have no drawing code yet.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you get an error stating that **A project with an Output Type of Class Library
    cannot be started directly** when you try to run the program, it means that you
    forgot to set `Ch01` as the startup project as mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows our game window in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our game window](img/7389OS_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The game window in action
  prefs: []
  type: TYPE_NORMAL
- en: It's not that impressive now, but it won't be too much longer before we can
    start rendering some graphics on the screen, which makes things a lot more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got Visual Studio and SlimDX set up and ready to go. We
    created a project to work in and built the beginnings of our little framework.
    It consists only of our `GameWindow` class for now, which creates a game window
    for us to draw our game on. We gave our `GameWindow` class a constructor and also
    covered the `GameLoop` function. We gave it `UpdateScene()` and `RenderScene()`
    methods for updating and drawing our game world at each frame. We also covered
    interfaces, specifically the `IDisposable` interface, and gave the game window
    a `ToggleFullscreen()` method. And finally, we tested our game window and saw
    it in action for the first time. In the next chapter, we will dive into user input
    and how to respond to the player's actions.
  prefs: []
  type: TYPE_NORMAL
