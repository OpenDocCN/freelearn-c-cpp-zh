["```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"GameGrid.h\" \n#include \"TetrisFigure.h\" \n#include \"RedFigure.h\" \n#include \"BrownFigure.h\" \n#include \"TurquoiseFigure.h\" \n#include \"GreenFigure.h\" \n#include \"YellowFigure.h\" \n#include \"BlueFigure.h\" \n#include \"PurpleFigure.h\" \n#include \"TetrisWindow.h\" \n\nvoid MainWindow(vector<String> /* argumentList */, \n                WindowShow windowShow) { \n  Application::ApplicationName() = TEXT(\"Tetris\"); \n  Application::MainWindowPtr() = new TetrisWindow(windowShow); \n} \n\n```", "```cpp\nclass TetrisWindow : public Window { \n  public: \n    TetrisWindow(WindowShow windowShow); \n    ~TetrisWindow(); \n\n```", "```cpp\n    bool OnKeyDown(WORD key, bool shiftPressed, \n                   bool controlPressed); \n\n```", "```cpp\n    void OnDraw(Graphics& graphics, DrawMode drawMode) const; \n\n```", "```cpp\n    void OnGainFocus(); \n    void OnLoseFocus(); \n\n```", "```cpp\n    void OnTimer(int timerId); \n    void EndOfFigure(); \n    void GameOver(); \n    void NewGame(); \n\n```", "```cpp\n    void DeleteFullRows(); \n    bool IsRowFull(int row); \n    void FlashRow(int row); \n    void DeleteRow(int markedRow); \n\n```", "```cpp\n    bool TryClose(); \n\n```", "```cpp\n  private: \n    GameGrid gameGrid; \n    TetrisFigure fallingFigure, nextFigure; \n\n    int currScore = 0; \n    bool timerActive = true, inverse = false; \n\n    static const int TimerId = 1000; \n    vector<TetrisFigure> figureList; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"GameGrid.h\" \n#include \"TetrisFigure.h\" \n#include \"RedFigure.h\" \n#include \"BrownFigure.h\" \n#include \"TurquoiseFigure.h\" \n#include \"GreenFigure.h\" \n#include \"YellowFigure.h\" \n#include \"BlueFigure.h\" \n#include \"PurpleFigure.h\" \n#include \"TetrisWindow.h\" \n\nTetrisWindow::TetrisWindow(WindowShow windowShow) \n :Window(PreviewCoordinate, Rect(0, 0, 100, 100), \n         nullptr, OverlappedWindow, NoStyle, Normal), \n\n```", "```cpp\n  gameGrid(Rect(0, 20, 100, 100)) { \n\n```", "```cpp\n  SetHeader(TEXT(\"Tetris\")); \n\n```", "```cpp\n  SetTimer(TimerId, 1000); \n  srand((unsigned int) time(nullptr)); \n\n```", "```cpp\n  figureList.push_back(RedFigure(this, &gameGrid)); \n  figureList.push_back(BrownFigure(this, &gameGrid)); \n  figureList.push_back(TurquoiseFigure(this, &gameGrid)); \n  figureList.push_back(GreenFigure(this, &gameGrid)); \n  figureList.push_back(YellowFigure(this, &gameGrid)); \n  figureList.push_back(BlueFigure(this, &gameGrid)); \n  figureList.push_back(PurpleFigure(this, &gameGrid)); \n\n  fallingFigure = figureList[rand() % figureList.size()]; \n  nextFigure = figureList[rand() % figureList.size()]; \n} \n\n```", "```cpp\nTetrisWindow::~TetrisWindow() { \n  DropTimer(TimerId); \n} \n\n```", "```cpp\nbool TetrisWindow::OnKeyDown(WORD key, bool /* shiftPressed */, \n                             bool /* controlPressed */) { \n  switch (key) { \n    case KeyLeft: \n      fallingFigure.TryMoveLeft(); \n      break; \n\n    case KeyRight: \n      fallingFigure.TryMoveRight(); \n      break; \n\n    case KeyUp: \n      fallingFigure.TryRotateAnticlockwise(); \n      break; \n\n    case KeyDown: \n      fallingFigure.TryRotateAnticlockwise(); \n      break; \n\n```", "```cpp\n    case KeySpace: \n      while (fallingFigure.TryMoveDown()) { \n        ::Sleep(10); \n      } \n      break; \n  } \n\n  return true; \n} \n\n```", "```cpp\nvoid TetrisWindow::OnDraw(Graphics& graphics, \n                          DrawMode /* drawMode */) const { \n  gameGrid.DrawGameGrid(graphics, inverse); \n  graphics.FillRectangle(Rect(Point(0, 0), Point(100,20)), \n                         White, White); \n  graphics.DrawLine(Point(40, 0), Point(40, 20), Black); \n  graphics.DrawLine(Point(0, 20), Point(100, 20), Black); \n\n```", "```cpp\n  fallingFigure.DrawFigure(graphics); \n  nextFigure.DrawFigure(graphics, Size(25, -18)); \n\n```", "```cpp\n  Font scoreFont(TEXT(\"Times New Roman\"), 10); \n\n```", "```cpp\n  graphics.DrawText(Rect(0, 0, 40, 20), to_String(currScore), \n                    scoreFont, Black, White, false); \n} \n\n```", "```cpp\nvoid TetrisWindow::OnGainFocus() { \n  SetTimer(TimerId, 1000); \n} \n\nvoid TetrisWindow::OnLoseFocus() { \n  DropTimer(TimerId); \n} \n\n```", "```cpp\nvoid TetrisWindow::OnTimer(int /* timerId */) { \n  if (timerActive) { \n    if (!fallingFigure.TryMoveDown()) { \n      EndOfFigure(); \n    } \n  } \n} \n\n```", "```cpp\nvoid TetrisWindow::NewFigure() { \n  fallingFigure.AddToGrid(); \n  fallingFigure = nextFigure; \n  fallingFigure.InvalidateFigure(); \n\n  nextFigure = figureList[rand() % figureList.size()]; \n  Rect nextArea(40, 0, 100, 20); \n  Invalidate(nextArea); \n  UpdateWindow(); \n\n```", "```cpp\n  DeleteFullRows(); \n  UpdateWindow(); \n\n```", "```cpp\n  if (!fallingFigure.IsFigureValid()) { \n    GameOver(); \n  } \n} \n\n```", "```cpp\nvoid TetrisWindow::GameOver() { \n  Invalidate(); \n  UpdateWindow(); \n\n```", "```cpp\n  timerActive = false; \n  String message = TEXT(\"Game Over.\\nYou scored \") + \n                   to_String(currScore) + \n                   TEXT(\" points.\\nAnother game?\"); \n\n  if (MessageBox(message, TEXT(\"Tetris\"), YesNo, Question)==Yes) { \n    NewGame(); \n  } \n  else { \n    ::PostQuitMessage(0); \n  } \n} \n\n```", "```cpp\nvoid TetrisWindow::NewGame() { \n  fallingFigure = figureList[rand() % figureList.size()]; \n  nextFigure = figureList[rand() % figureList.size()]; \n\n  currScore = 0; \n  gameGrid.ClearGameGrid(); \n  timerActive = true; \n  Invalidate(); \n  UpdateWindow(); \n} \n\n```", "```cpp\nvoid TetrisWindow::DeleteFullRows() { \n  int row = Rows - 1;  \n  while (row >= 0) { \n    if (IsRowFull(row)) { \n      FlashRow(row); \n      DeleteRow(row); \n\n      ++currScore; \n      Rect scoreArea(0, 0, 40, 20); \n      Invalidate(scoreArea); \n      UpdateWindow(); \n    } \n    else { \n      --row; \n    } \n  } \n} \n\n```", "```cpp\nbool TetrisWindow::IsRowFull(int row) { \n  for (int col = 0; col < Cols; ++col) { \n    if (gameGrid[row][col] == White) { \n      return false; \n    } \n  } \n\n  return true; \n}  \n\n```", "```cpp\nvoid TetrisWindow::FlashRow(int row) { \n  Rect gridArea = gameGrid.GridArea(); \n  int colWidth = gridArea.Width() / Cols, \n      rowHeight = gridArea.Height() / Rows; \n\n  Rect rowArea(0, row * rowHeight, Cols * colWidth, \n               (row + 1) * rowHeight); \n\n  for (int count = 0; count < 3; ++count) { \n    inverse = true; \n    Invalidate(rowArea + gridArea.Top()Left()); \n    UpdateWindow(); \n    ::Sleep(50); \n\n    inverse = false; \n    Invalidate(rowArea + gridArea.Top()Left()); \n    UpdateWindow(); \n    ::Sleep(50); \n  } \n} \n\n```", "```cpp\nvoid TetrisWindow::DeleteRow(int markedRow) { \n  for (int row = markedRow; row > 0; --row) { \n    for (int col = 0; col < Cols; ++col) { \n      gameGrid[row][col] = gameGrid[row - 1][col]; \n    } \n  } \n\n  for (int col = 0; col < Cols; ++col) { \n    gameGrid[0][col] = White; \n  } \n\n  Invalidate(gameGrid.GridArea()); \n  Invalidate(g); \n  UpdateWindow(); \n} \n\n```", "```cpp\nbool TetrisWindow::TryClose() { \n  timerActive = false; \n\n  if (MessageBox(TEXT(\"Quit?\"), TEXT(\"Tetris\"), \n                 YesNo, Question) == Yes) { \n    return true; \n  } \n\n  timerActive = true; \n  return false; \n} \n\n```", "```cpp\nclass TetrisFigure { \n  public: \n    TetrisFigure(); \n\n  protected: \n    TetrisFigure(Window* windowPtr, GameGrid* colorGridPtr, \n           Color color, int row, int col, Direction direction, \n           IntPair* northList, IntPair* eastList, \n           IntPair* southList, IntPair* westList); \n\n  public: \n    TetrisFigure& operator=(const TetrisFigure& figure); \n\n```", "```cpp\n    void TryMoveLeft(); \n    void TryMoveRight(); \n    void TryRotateClockwise(); \n    void TryRotateAnticlockwise(); \n    bool TryMoveDown(); \n\n```", "```cpp\n    bool IsFigureValid();\n    static bool IsFigureValid(int direction, int row, int col,\n                  GameGrid* gameGridPtr, IntPair* figureInfo[]);\n    static bool IsSquareValid(int row, int col,\n                              GameGrid* gameGridPtr);\n```", "```cpp\n    void AddToGrid();\n\n```", "```cpp\n    void InvalidateFigure(Size offsetSize = ZeroSize); \n    void DrawFigure(Graphics& graphics, \n                    Size offsetSize = ZeroSize) const; \n\n```", "```cpp\n  protected: \n    Window* windowPtr; \n    GameGrid* gameGridPtr; \n    Color color; \n    int row, col; \n    Direction direction; \n    IntPair* figureInfo[4]; \n }; \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"GameGrid.h\" \n#include \"TetrisFigure.h\" \n#include \"TetrisWindow.h\" \n\nTetrisFigure::TetrisFigure() { \n  // Empty \n} \n\n```", "```cpp\nTetrisFigure::TetrisFigure(Window*windowPtr, GameGrid*gameGridPtr, \n                           Color color, int row, int col, \n                           Direction direction, \n                           IntPair* northList, IntPair* eastList, \n                           IntPair* southList, IntPair* westList) \n :windowPtr(windowPtr), \n  gameGridPtr(gameGridPtr), \n  color(color), \n  row(row), \n  col(col), \n  direction(direction) { \n  figureInfo[North] = northList; \n  figureInfo[East] = eastList; \n  figureInfo[South] = southList; \n  figureInfo[West] = westList; \n} \n\n```", "```cpp\nTetrisFigure& TetrisFigure::operator=(const TetrisFigure& figure) { \n  if (this != &figure) { \n    windowPtr = figure.windowPtr; \n    gameGridPtr = figure.gameGridPtr; \n    color = figure.color; \n    row = figure.row; \n    col = figure.col; \n    direction = figure.direction; \n    figureInfo[North] = figure.figureInfo[North]; \n    figureInfo[East] = figure.figureInfo[East]; \n    figureInfo[South] = figure.figureInfo[South]; \n    figureInfo[West] = figure.figureInfo[West]; \n  } \n\n  return *this; \n} \n\n```", "```cpp\nvoid TetrisFigure::TryMoveLeft() { \n  if (IsFigureValid(direction, row, col - 1\n                    gameGridPtr, figureInfo)) { \n    windowPtr->Invalidate(Area()); \n    --col; \n    windowPtr->Invalidate(Area()); \n    windowPtr->UpdateWindow(); \n  } \n} \n\nvoid TetrisFigure::TryMoveRight() { \n  if (IsFigureValid(direction, row, col + 1\n                     gameGridPtr, figureInfo)) { \n    windowPtr->Invalidate(Area()); \n    ++col; \n    windowPtr->Invalidate(Area()); \n    windowPtr->UpdateWindow(); \n  } \n} \n\nvoid TetrisFigure::TryRotateClockwise() { \n  Direction newDirection = (direction == West) ? North : \n                           ((Direction) (direction + 1)); \n\n  if (IsFigureValid(newDirection, row, col, \n                    gameGridPtr, figureInfo)) { \n    InvalidateFigure(); \n    direction = newDirection; \n    InvalidateFigure(); \n    windowPtr->UpdateWindow(); \n  } \n} \n\nvoid TetrisFigure::TryRotateAnticlockwise() { \n  Direction newDirection = (this->direction == North) ? West : \n                           ((Direction) (direction - 1)); \n\n  if (IsFigureValid(newDirection, row, col, \n                    gameGridPtr, figureInfo)) { \n    InvalidateFigure(); \n    direction = newDirection; \n    InvalidateFigure(); \n    windowPtr->UpdateWindow(); \n  } \n} \n\n```", "```cpp\nbool TetrisFigure::TryMoveDown() { \n  if (IsFigureValid(direction, row + 1, col\n                     gameGridPtr, figureInfo)) { \n    windowPtr->Invalidate(Area()); \n    ++row; \n    windowPtr->Invalidate(Area()); \n    windowPtr->UpdateWindow(); \n    return true; \n  } \n\n  return false; \n} \n\n```", "```cpp\nbool TetrisFigure::IsFigureValid() { \n  return IsFigureValid(direction, row, col\n                     gameGridPtr, figureInfo); \n} \n\n```", "```cpp\nbool TetrisFigure::IsFigureValid(int direction, int row, int col, \n                                 GameGrid* gameGridPtr, \n                                 IntPair* figureInfo[]) { \n  int relRow0 = row + figureInfo[direction][0].first, \n      relCol0 = col + figureInfo[direction][0].second, \n      relRow1 = row + figureInfo[direction][1].first, \n      relCol1 = col + figureInfo[direction][1].second, \n      relRow2 = row + figureInfo[direction][2].first, \n      relCol2 = col + figureInfo[direction][2].second; \n\n  return IsSquareValid(row, col, gameGridPtr) && \n         IsSquareValid(relRow0, relCol0, gameGridPtr) && \n         IsSquareValid(relRow1, relCol1, gameGridPtr) && \n         IsSquareValid(relRow2, relCol2, gameGridPtr); \n} \n\n```", "```cpp\nbool TetrisFigure::IsSquareValid(int row, int col,\n                                 GameGrid* gameGridPtr) { \n  return (row >= 0) && (row < Rows) && \n         (col >= 0) && (col < Cols) && \n         ((*gameGridPtr)[row][col] == White); \n} \n\n```", "```cpp\nvoid TetrisFigure::AddToGrid() { \n  (*gameGridPtr)[row][col] = color; \n\n  { int relRow = row + figureInfo[direction][0].first, \n        relCol = col + figureInfo[direction][0].second; \n    (*gameGridPtr)[relRow][relCol] = color; \n  } \n\n  { int relRow = row + figureInfo[direction][1].first, \n        relCol = col + figureInfo[direction][1].second; \n    (*gameGridPtr)[relRow][relCol] = color; \n  } \n\n  { int relRow = row + figureInfo[direction][2].first, \n        relCol = col + figureInfo[direction][2].second; \n    (*gameGridPtr)[relRow][relCol] = color; \n  } \n} \n\n```", "```cpp\nvoid TetrisFigure::InvalidateFigure(Size offsetSize/*=ZeroSize*/){ \n  gameGridPtr->InvalidateSquare(windowPtr, row, col, offsetSize); \n\n  { int relRow = row + figureInfo[direction][0].first, \n        relCol = col + figureInfo[direction][0].second; \n    gameGridPtr->InvalidateSquare(windowPtr, relRow, \n                                  relCol, offsetSize); \n  }  \n  { int relRow = row + figureInfo[direction][1].first, \n        relCol = col + figureInfo[direction][1].second; \n    gameGridPtr->InvalidateSquare(windowPtr, relRow, \n                                  relCol, offsetSize); \n  } \n  { int relRow = row + figureInfo[direction][2].first, \n        relCol = col + figureInfo[direction][2].second; \n    gameGridPtr->InvalidateSquare(windowPtr, relRow, \n                                  relCol, offsetSize); \n  } \n} \n\n```", "```cpp\nvoid TetrisFigure::DrawFigure(Graphics& graphics,Size offsetSize) \n                              const { \n  gameGridPtr->DrawSquare(graphics, row, col, \n                          Black, color, offsetSize); \n\n  { int relRow = row + figureInfo[direction][0].first, \n        relCol = col + figureInfo[direction][0].second; \n    gameGridPtr->DrawSquare(graphics, relRow, relCol, \n                            Black, color, offsetSize); \n  } \n\n  { int relRow = row + figureInfo[direction][1].first, \n        relCol = col + figureInfo[direction][1].second; \n    gameGridPtr->DrawSquare(graphics, relRow, relCol, \n                            Black, color, offsetSize); \n  } \n\n  { int relRow = row + figureInfo[direction][2].first, \n        relCol = col + figureInfo[direction][2].second; \n    gameGridPtr->DrawSquare(graphics, relRow, relCol, \n                            Black, color, offsetSize); \n  } \n} \n\n```", "```cpp\nclass RedFigure : public TetrisFigure { \n  public: \n    static IntPair GenericList[]; \n    RedFigure(Window* windowPtr, GameGrid* gameGridPtr); \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"GameGrid.h\" \n#include \"TetrisFigure.h\" \n#include \"RedFigure.h\" \n\nIntPair RedFigure::GenericList[] =\n                 {IntPair(0,1), IntPair(1,0), IntPair(1,1)};\n\nRedFigure::RedFigure(Window* windowPtr, GameGrid* gameGridPtr)\n :TetrisFigure(windowPtr, gameGridPtr, Red, 1, (Cols / 2) - 1,\n                 North, GenericList, GenericList, GenericList, \n                 GenericList) {\n // Empty.\n}\n```", "```cpp\nclass BrownFigure : public TetrisFigure { \n  public: \n    static IntPair HorizontalList[], VerticalList[]; \n    BrownFigure(Window* windowPtr, GameGrid* gameGridPtr); \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"GameGrid.h\" \n#include \"TetrisFigure.h\" \n#include \"BrownFigure.h\"\n\nIntPair BrownFigure::HorizontalList[] =\n                     {IntPair(-1,0), IntPair(1,0), IntPair(2,0)},\n        BrownFigure::VerticalList[] =\n                     {IntPair(0,-1), IntPair(0,1), IntPair(0,2)};\n\nBrownFigure::BrownFigure(Window* windowPtr, GameGrid* gameGridPtr)\n  :TetrisFigure(windowPtr, gameGridPtr, Brown, 1, (Cols / 2) - 1,\n                North, HorizontalList, VerticalList,\n                HorizontalList, VerticalList) {\n // Empty.\n}\n```", "```cpp\nclass TurquoiseFigure : public TetrisFigure { \n  public: \n    static IntPair HorizontalList[], VerticalList[]; \n    TurquoiseFigure(Window* windowPtr, GameGrid* gameGridPtr); \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\"\n#include \"GameGrid.h\"\n#include \"TetrisFigure.h\"\n#include \"TurquoiseFigure.h\"\n\nIntPair TurquoiseFigure::HorizontalList[] =\n                 {IntPair(-1,0), IntPair(0,1), IntPair(1,1)},\n        TurquoiseFigure::VerticalList[] =\n                 {IntPair(1,-1), IntPair(1,0), IntPair(0,1)};\n\nTurquoiseFigure::TurquoiseFigure(Window* windowPtr,\n                                 GameGrid* gameGridPtr)\n :TetrisFigure(windowPtr, gameGridPtr, Turquoise, 1, (Cols/2) - 1,\n               North, HorizontalList, VerticalList,\n               HorizontalList, VerticalList) {\n  // Empty.\n}\n```", "```cpp\nclass GreenFigure : public TetrisFigure { \n  public: \n    static IntPair HorizontalList[], VerticalList[]; \n    GreenFigure(Window* windowPtr, GameGrid* gameGridPtr); \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\"\n#include \"GameGrid.h\"\n#include \"TetrisFigure.h\"\n#include \"GreenFigure.h\"\n\nIntPair GreenFigure::HorizontalList[] =\n                  {IntPair(1,-1), IntPair(0,-1), IntPair(-1,0)}, GreenFigure::VerticalList[] = \n                  {IntPair(0,-1), IntPair(1,0), IntPair(1,1)}; \n\nGreenFigure::GreenFigure(Window* windowPtr, GameGrid* gameGridPtr)\n :TetrisFigure(windowPtr, gameGridPtr, Green, 1, Cols / 2, \n               North, HorizontalList, VerticalList,\n               HorizontalList, VerticalList) {\n // Empty.\n}\n```", "```cpp\nclass YellowFigure : public TetrisFigure { \n  public: \n    static IntPair NorthList[], EastList[], \n                   SouthList[], WestList[]; \n    YellowFigure(Window* windowPtr, GameGrid* gameGridPtr); \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\"\n#include \"GameGrid.h\"\n#include \"TetrisFigure.h\"\n#include \"YellowFigure.h\"\nIntPair YellowFigure::NorthList[] =\n              {IntPair(0,-1), IntPair(-1,0), IntPair(0,1)},\n        YellowFigure::EastList[] =\n              {IntPair(-1,0),IntPair(0,1),IntPair(1,0)}, \n        YellowFigure::SouthList[] = \n              {IntPair(0,-1),IntPair(1,0),IntPair(0,1)},\n        YellowFigure::WestList[] = \n              {IntPair(-1,0),IntPair(0,-1),IntPair(1,0)};\n\nYellowFigure::YellowFigure(Window* windowPtr,\n                           GameGrid* gameGridPtr)\n :TetrisFigure(windowPtr, gameGridPtr, Yellow, 1, (Cols / 2) - 1,\n               South, NorthList, EastList, SouthList, WestList) {\n  // Empty. \n}\n```", "```cpp\nclass BlueFigure : public TetrisFigure { \n  public: \n    static IntPair NorthList[], EastList[], \n           SouthList[], WestList[]; \n    BlueFigure(Window* windowPtr, GameGrid* gameGridPtr); \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\"\n#include \"GameGrid.h\"\n#include \"TetrisFigure.h\"\n#include \"BlueFigure.h\"\n\nIntPair BlueFigure::NorthList[] =\n                    {IntPair(0,-2),IntPair(0,-1),IntPair(-1,0)},\n        BlueFigure::EastList[] =\n                    {IntPair(-2,0), IntPair(-1,0), IntPair(0,1)},\n        BlueFigure::SouthList[] =\n                    {IntPair(1,0), IntPair(0,1), IntPair(0,2)},\n        BlueFigure::WestList[] =\n                    {IntPair(0,-1), IntPair(1,0), IntPair(2,0)};\n\nBlueFigure::BlueFigure(Window* windowPtr, GameGrid* gameGridPtr)\n :TetrisFigure(windowPtr, gameGridPtr, Blue, 1, (Cols / 2) - 1,\n              South, NorthList, EastList, SouthList, WestList) {\n  // Empty. \n}\n```", "```cpp\nclass PurpleFigure : public TetrisFigure { \n  public: \n    static IntPair NorthList[], EastList[], \n                   SouthList[], WestList[]; \n    PurpleFigure(Window* windowPtr, GameGrid* gameGridPtr); \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\"\n#include \"GameGrid.h\"\n#include \"TetrisFigure.h\"\n#include \"PurpleFigure.h\"\n\nIntPair PurpleFigure::NorthList[] =\n              {IntPair(-1,0),IntPair(0,1),IntPair(0,2)},\n        PurpleFigure::EastList[] =\n              {IntPair(1,0), IntPair(2,0), IntPair(0,1)},\n        PurpleFigure::SouthList[] =\n              {IntPair(0,-2),IntPair(0,-1),IntPair(1,0)},\n        PurpleFigure::WestList[] =\n              {IntPair(0,-1),IntPair(-2,0),IntPair(-1,0)}; \n\nPurpleFigure::PurpleFigure(Window* windowPtr,\n                           GameGrid* gameGridPtr)\n :TetrisFigure(windowPtr, gameGridPtr, Purple, 1, Cols / 2, South,\n               NorthList, EastList, SouthList, WestList) {\n  // Empty. \n}\n```", "```cpp\nconst int Rows = 20, Cols = 10;  \n\nclass GameGrid { \n  public: \n    GameGrid(Rect gridArea); \n    void ClearGameGrid(); \n\n    Color* operator[](int row) {return gameGrid[row];} \n    void InvalidateSquare(Window* windowPtr, int row, \n                          int col, Size offsetSize); \n    void DrawGameGrid(Graphics& graphics, bool inverse) const; \n\n    void DrawSquare(Graphics& graphics, int row, int col, \n                    Color penColor, Color brushColor, \n                    Size offsetSize = ZeroSize) const; \n\n    Rect GridArea() const {return gridArea;} \n\n  private: \n    Rect gridArea; \n    Color gameGrid[Rows][Cols]; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"GameGrid.h\" \n\nGameGrid::GameGrid(Rect gridArea) \n :gridArea(gridArea) { \n  ClearGameGrid(); \n} \n\n```", "```cpp\nvoid GameGrid::ClearGameGrid () { \n  for (int row = 0; row < Rows; ++row) { \n    for (int col = 0; col < Cols; ++col) { \n      gameGrid[row][col] = White; \n    } \n  } \n} \n\n```", "```cpp\nvoid GameGrid::DrawGameGrid(Graphics& graphics, bool inverse) \n                            const { \n  for (int row = 0; row < Rows; ++row) { \n    for (int col = 0; col < Cols; ++col) { \n      Color squareColor = gameGrid[row][col]; \n      Color penColor = (squareColor == White) ? White : Black; \n      Color brushColor = inverse ? squareColor.Inverse() \n                                 : squareColor; \n      DrawSquare(graphics, row, col, penColor, brushColor); \n    } \n  } \n} \n\n```", "```cpp\nvoid GameGrid::InvalidateSquare(Window* windowPtr, int row, \n                                int col, Size offsetSize) { \n  int colWidth = gridArea.Width() / Cols, \n      rowHeight = gridArea.Height() / Rows; \n\n  Rect squareArea(col * colWidth, row * rowHeight, \n                  (col + 1) * colWidth, (row + 1) * rowHeight); \n  windowPtr->Invalidate(gridArea.TopLeft() + squareArea + \n                        offsetSize); \n} \n\nvoid GameGrid::DrawSquare(Graphics& graphics, int row, int col, \n                          Color penColor, Color brushColor, \n                          Size offsetSize /* = ZeroSize */) const{ \n  int colWidth = gridArea.Width() / Cols, \n      rowHeight = gridArea.Height() / Rows; \n\n  Rect squareArea (col * colWidth, row * rowHeight, \n                  (col + 1) * colWidth, (row + 1) * rowHeight); \n  graphics.FillRectangle(gridArea.TopLeft() + squareArea + \n                         offsetSize, penColor, brushColor); \n} \n\n```"]