<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Target-independent Code Generator</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">The life of an LLVM IR instruction</li><li class="listitem">Visualizing the LLVM IR CFG using GraphViz</li><li class="listitem">Describing the target using TableGen</li><li class="listitem">Defining an instruction set</li><li class="listitem">Adding a machine code descriptor</li><li class="listitem">Implementing the MachineInstrBuilder class</li><li class="listitem">Implementing the MachineBasicBlock class</li><li class="listitem">Implementing the MachineFunction class</li><li class="listitem">Writing an instruction selector</li><li class="listitem">Legalizing SelectionDAG</li><li class="listitem">Optimizing SelectionDAG</li><li class="listitem">Selecting instructions from the DAG</li><li class="listitem">Scheduling instructions in SelectionDAG</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Introduction</h1></div></div></div><p>After optimizing the LLVM IR, it needs to be converted into machine instructions for execution. The machine-independent code generator interface gives an abstract layer that helps convert IR into machine instructions. In this phase, the IR is converted into SelectionDAG (<strong>DAG</strong> <a id="id252" class="indexterm"/>stands for <strong>Directed Acyclic Graph</strong>). Various phases work on the nodes of SelectionDAG. This chapter describes the important phases in target-independent code generation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec60"/>The life of an LLVM IR instruction</h1></div></div></div><p>In previous chapters, we saw <a id="id253" class="indexterm"/>how high-level language instructions, statements, logical blocks, function calls, loops, and so on get transformed into the LLVM IR. Various optimization passes then process the IR to make it more optimal. The IR generated is in the SSA form and, in abstract format, almost independent of any high- or low-level language constraints, which facilitates optimization passes running on it. There might be some optimizations that are target-specific and take place later, when the IR gets converted into machine instructions.</p><p>After we get an optimal LLVM IR, the next phase is to convert it into target-machine-specific instructions. LLVM uses the SelectionDAG approach to convert the IR into machine instructions. The Linear IR is converted into SelectionDAG, a DAG that represents instructions as nodes. The SDAG<a id="id254" class="indexterm"/> then goes through various phases:</p><div><ul class="itemizedlist"><li class="listitem">The SelectionDAG is created out of LLVM IR</li><li class="listitem">Legalizing SDAG nodes</li><li class="listitem">DAG combine optimization</li><li class="listitem">Instruction selection from the target instruction</li><li class="listitem">Scheduling and emitting a machine instruction</li><li class="listitem">Register allocation—SSA destruction, register assignment, and register spilling</li><li class="listitem">Emitting code</li></ul></div><p>All the preceding stages are modularized in LLVM.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec172"/>C Code to LLVM IR</h2></div></div></div><p>The first step is to convert the front end<a id="id255" class="indexterm"/> language example to LLVM IR. Let's take an <a id="id256" class="indexterm"/>example:</p><div><pre class="programlisting">    int test (int a, int b, int c) {
            return c/(a+b);
    }</pre></div><p>Its LLVM IR will be as follows:</p><div><pre class="programlisting">define i32 @test(i32 %a, i32 %b, i32 %c) {
      %add = add nsw i32 %a, %b
      %div = sdiv i32 %add, %c
      return i32 %div
    }</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec173"/>IR optimization</h2></div></div></div><p>The IR then goes through <a id="id257" class="indexterm"/>various optimization passes, as described in previous chapters. The IR, in the transformation phase, goes through the <code class="literal">InstCombiner::visitSDiv()</code> function in the <code class="literal">InstCombine</code> pass. In that function, it also goes through the <code class="literal">SimplifySDivInst()</code> function and tries to check whether an opportunity exists to further simplify the instruction.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec174"/>LLVM IR to SelectionDAG</h2></div></div></div><p>After the IR transformations and <a id="id258" class="indexterm"/>optimizations are over, the LLVM IR <a id="id259" class="indexterm"/>instruction passes through a <strong>Selection DAG node</strong>
<a id="id260" class="indexterm"/> incarnation. Selection DAG nodes are created by the <code class="literal">SelectionDAGBuilder</code> class. The <code class="literal">SelectionDAGBuilder::visit()</code> function call from the <code class="literal">SelectionDAGISel</code> class visits each IR instruction for creating an <code class="literal">SDAGNode</code> node. The method that handles an <code class="literal">SDiv</code> instruction is <code class="literal">SelectionDAGBuilder::visitSDiv</code>. It requests a new <code class="literal">SDNode</code> node from the DAG with the<code class="literal">ISD::SDIV</code> opcode, which then becomes a node in the DAG.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec175"/>SelectionDAG legalization</h2></div></div></div><p>The <code class="literal">SelectionDAG</code> node created may not be <a id="id261" class="indexterm"/>supported by the target architecture. In the initial phase of Selection DAG, these unsupported nodes are called <em>illegal</em>. Before the <code class="literal">SelectionDAG</code> machinery actually emits machine instructions from the DAG nodes, these undergo a few other transformations, legalization being one of the important phases.</p><p>The legalization of <code class="literal">SDNode</code> involves type and operation legalization. The target-specific information is conveyed to the target-independent algorithms via an interface called <code class="literal">TargetLowering</code>. This interface is implemented by the target and, describes how LLVM IR instructions should be lowered to legal <code class="literal">SelectionDAG</code> operations. For instance, x86 lowering is implemented in the <code class="literal">X86TargetLowering</code> interface. The <code class="literal">setOperationAction()</code> function specifies whether the ISD node needs to be expanded or customized by operation legalization. When <code class="literal">SelectionDAGLegalize::LegalizeOp</code> sees the expand flag, it replaces the <code class="literal">SDNode</code> node with the parameter specified in the <code class="literal">setOperationAction()</code> call.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec176"/>Conversion from target-independent DAG to machine DAG</h2></div></div></div><p>Now that we have legalized the<a id="id262" class="indexterm"/> instruction, <code class="literal">SDNode</code> <a id="id263" class="indexterm"/>should be converted to <code class="literal">MachineSDNode</code>. The machine instructions are described in a generic table-based fashion in the target description <code class="literal">.td</code> files. Using <code class="literal">tablegen</code>, these files are then converted into <code class="literal">.inc</code> files that have registers/instructions as enums to refer to in the C++ code. Instructions can be selected by an automated selector, <code class="literal">SelectCode</code>, or they can be handled specifically by writing a customized <code class="literal">Select</code> function in the <code class="literal">SelectionDAGISel</code> class. The DAG node created at this step is a <code class="literal">MachineSDNode</code> node, a subclass of <code class="literal">SDNode</code> that holds the information required to construct an actual machine instruction but is still in the DAG node form.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec177"/>Scheduling instructions</h2></div></div></div><p>A machine executes a linear<a id="id264" class="indexterm"/> set of instructions. So far, we have had machine instructions that are still in the DAG form. To convert a DAG into a linear set of instructions, a topological sort of the DAG can yield the instructions in linear order. However, the linear set of instructions generated might not result in the most optimized code, and may cause execution delays due to dependencies among instructions, register pressure, and pipeline stalling issues. Therein comes the concept of scheduling instructions. Since each target has its own set of registers and customized pipelining of the instructions, each target has its own hook for scheduling and calculating heuristics to produce optimized, faster code. After calculating the best possible way to arrange instructions, the scheduler emits the machine instructions in the machine basic block, and finally destroys the DAG.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec178"/>Register allocation</h2></div></div></div><p>The registers allocated are virtual<a id="id265" class="indexterm"/> registers after the machine instructions are emitted. Practically, an infinite number of virtual registers can be allocated, but the actual target has a limited number of registers. These limited registers need to be allocated efficiently. If this is not done, some registers have to be spilled onto the memory, and this may result in redundant load/store operations. This will also result in wastage of CPU cycles, slowing down the execution as well as increasing the memory footprint.</p><p>There are various register allocation algorithms. An important analysis is done when allocating registers—liveness of variables and live interval analysis. If two variables live in the same interval (that is, if there exists an interval interference), then they cannot be allocated the same register. An interference graph is created by analyzing liveness, and a graph coloring algorithm can be used to allocate the registers. This algorithm, however, takes quadratic time to run. Hence, it may result in longer compilation time.</p><p>LLVM employs a greedy approach for register allocation, where variables that have large live ranges are allocated registers first. Small ranges fit into the gaps of registers available, resulting in less spill weight. Spilling is a load-store operation that occurs because no registers are available to be allocated. Spill weight is the cost of operations involved in the spilling. Sometimes, live range splitting also takes place to accommodate variables into the registers.</p><p>Note that the instructions are in the SSA form before register allocation. Now, the SSA form cannot exist in the real world because of the limited number of registers available. In some types of architecture, some instructions require fixed registers.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec179"/>Code emission</h2></div></div></div><p>Now that the original high-level <a id="id266" class="indexterm"/>code has been translated into machine instructions, the next step is to emit the code. LLVM does this in two ways; the first is JIT, which directly emits the code to the memory. The second way is by using the MC framework to emit assembly and object files for all backend targets.The <code class="literal">LLVMTargetMachine::addPassesToEmitFile</code> function is responsible for defining the sequence of actions required to emit an object file. The actual MI-to-MCInst translation is done in the <code class="literal">EmitInstruction</code> function of the <code class="literal">AsmPrinter</code> interface. The static compiler tool, llc, generates assembly instructions for a target. Object file (or assembly code) emission is done by implementing the <code class="literal">MCStreamer</code> interface.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec61"/>Visualizing LLVM IR CFG using GraphViz</h1></div></div></div><p>The LLVM IR control flow<a id="id267" class="indexterm"/> graph can be visualized using the <strong>GraphViz</strong> tool. It <a id="id268" class="indexterm"/>gives a visual depiction of the nodes formed and how the code flow follows in the IR generated. Since the important data structures in LLVM are graphs, this can be a very useful way to understand the IR flow when writing a custom pass or studying the behavior of the IR pattern.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec180"/>Getting ready</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">To install <code class="literal">graphviz</code> on Ubuntu, first add its <code class="literal">ppa</code> repository:<div><pre class="programlisting">
<strong>$ sudo apt-add-repository ppa:dperry/ppa-graphviz-test</strong>
</pre></div></li><li class="listitem">Update the package repository:<div><pre class="programlisting">
<strong>$ sudo apt-get update</strong>
</pre></div></li><li class="listitem">Install <code class="literal">graphviz</code>:<div><pre class="programlisting">
<strong>$ sudo apt-get install graphviz</strong>
</pre></div><div><h3 class="title"><a id="note05"/>Note</h3><p>If you get the <code class="literal">graphviz : Depends: libgraphviz4 (&gt;= 2.18) but it is not going to be installed</code> error, run the following commands:</p><div><pre class="programlisting">
<strong>$ sudo apt-get remove libcdt4</strong>
<strong>$ sudo apt-get remove libpathplan4</strong>
</pre></div><p>Then install <code class="literal">graphviz</code> again with the following command:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install graphviz</strong>
</pre></div></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec181"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Once the IR has<a id="id269" class="indexterm"/> been converted to DAG, it <a id="id270" class="indexterm"/>can be viewed in different phases. Create a test.ll file with the following code:<div><pre class="programlisting">
<strong>$ cat test.ll</strong>
<strong>define i32 @test(i32 %a, i32 %b, i32 %c) {</strong>
<strong>  %add = add nsw i32 %a, %b</strong>
<strong>  %div = sdiv i32 %add, %c</strong>
<strong>  ret i32 %div</strong>
<strong>}</strong>
</pre></div></li><li class="listitem">To display the DAG after it is built, before the first optimization pass, enter the following command:<div><pre class="programlisting">
<strong>$ llc -view-dag-combine1-dags test.ll</strong>
</pre></div><p>The following diagram shows the DAG before the first optimization pass:</p><div><img src="img/image00255.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">To display the<a id="id271" class="indexterm"/> DAG before legalization, run <a id="id272" class="indexterm"/>this command:<div><pre class="programlisting">
<strong>$ llc -view-legalize-dags test.ll</strong>
</pre></div><p>Here is a diagram that shows the DAG before the legalization phase:</p><div><img src="img/image00256.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">To display the <a id="id273" class="indexterm"/>DAG before the second<a id="id274" class="indexterm"/> optimization pass, run the following command:<div><pre class="programlisting">
<strong>$ llc -view-dag-combine2-dags test.ll</strong>
</pre></div><p>The following diagram shows the DAG before the second optimization pass:</p><div><img src="img/image00257.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">To display the<a id="id275" class="indexterm"/> DAG before the selection<a id="id276" class="indexterm"/> phase, enter this command:<div><pre class="programlisting">
<strong>$ llc -view-isel-dags test.ll</strong>
</pre></div><p>Here is a diagram that shows the DAG before the selection phase:</p><div><img src="img/image00258.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">To display the <a id="id277" class="indexterm"/>DAG before scheduling, run <a id="id278" class="indexterm"/>the following command:<div><pre class="programlisting">
<strong>$ llc -view-sched-dags test.ll</strong>
</pre></div><p>The following diagram shows the DAG before the scheduling phase:</p><div><img src="img/image00259.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">To display the<a id="id279" class="indexterm"/> scheduler's <a id="id280" class="indexterm"/>dependency graph, run this command:<div><pre class="programlisting">
<strong>$ llc -view-sunit-dags test.ll</strong>
</pre></div><p>This diagram shows the scheduler's dependency graph:</p><div><img src="img/image00260.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div><p>Notice the <a id="id281" class="indexterm"/>difference in the DAG before and after the <a id="id282" class="indexterm"/>legalize phase. The <code class="literal">sdiv</code> node has been converted into an <code class="literal">sdivrem</code> node. The x86 target doesn't support the <code class="literal">sdiv</code> node but supports the <code class="literal">sdivrem</code> instruction. In a way, the <code class="literal">sdiv</code> instruction is illegal for the x86 target. The legalize phase converted it into an <code class="literal">sdivrem</code> instruction, which is supported by the x86 target.</p><p>Also note the difference in the DAG before and after the instruction selection (ISel) phase. Target-machine-independent instructions such as <code class="literal">Load</code> are converted into the <code class="literal">MOV32rm</code> machine code (which means, move 32-bit data from the memory to the register). The ISel phase is an important phase that will be described in later recipes.</p><p>Observe the scheduling units for the DAG. Each unit is linked to other units, which shows the dependency between them. This dependency information is very important for deciding scheduling algorithms. In the preceding case, scheduling unit 0 (SU0) is dependent on scheduling unit 1 (SU1). So, the instructions in SU0 cannot be scheduled before the instructions in SU1. SU1 is dependent on SU2, and so is SU2 on SU3.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec182"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">For more details on how to view <a id="id283" class="indexterm"/>graphs in debug mode, go to <a class="ulink" href="http://llvm.org/docs/ProgrammersManual.html#viewing-graphs-while-debugging-code">http://llvm.org/docs/ProgrammersManual.html#viewing-graphs-while-debugging-code</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec62"/>Describing targets using TableGen</h1></div></div></div><p>The target architecture<a id="id284" class="indexterm"/> can be described in terms of the registers <a id="id285" class="indexterm"/>present, the instruction set, and so on. Describing each of them manually is a tedious task. <code class="literal">TableGen</code> is a tool for backend developers that describes their target machine with a declarative language—<code class="literal">*.td</code>. The <code class="literal">*.td</code> files will be converted to enums, DAG-pattern matching functions, instruction encoding/decoding functions, and so on, which can then be used in other C++ files for coding.</p><p>To define registers and the register set in the target description's <code class="literal">.td</code> files, <code class="literal">tablegen</code> will convert the intended <code class="literal">.td</code> file into <code class="literal">.inc</code> files, which will be <code class="literal">#include</code> syntax in our <code class="literal">.cpp</code> files referring to the registers.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec183"/>Getting ready</h2></div></div></div><p>Let's assume that the sample target machine has four registers, <code class="literal">r0-r3</code>; a stack register, <code class="literal">sp</code>; and a link register, <code class="literal">lr</code>. These can be specified in the <code class="literal">SAMPLERegisterInfo.td</code> file. <code class="literal">TableGen</code> provides the <code class="literal">Register</code> class, which can be extended to specify registers.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec184"/>How to do it</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a new folder in <code class="literal">lib/Target</code> named <code class="literal">SAMPLE</code>:<div><pre class="programlisting">
<strong>$ mkdir llvm_root_directory/lib/Target/SAMPLE</strong>
</pre></div></li><li class="listitem">Create a new file called <code class="literal">SAMPLERegisterInfo.td</code> in the new <code class="literal">SAMPLE</code> folder:<div><pre class="programlisting">
<strong>$ cd llvm_root_directory/lib/Target/SAMPLE</strong>
<strong>$ vi SAMPLERegisterInfo.td</strong>
</pre></div></li><li class="listitem">Define the hardware encoding, namespace, registers, and register class:<div><pre class="programlisting">class SAMPLEReg&lt;bits&lt;16&gt; Enc, string n&gt; : Register&lt;n&gt; {
  let HWEncoding = Enc;
  let Namespace = "SAMPLE";
}

foreach i = 0-3 in {
  def R#i : R&lt;i, "r"#i &gt;;
}

def SP  : SAMPLEReg&lt;13, "sp"&gt;;
def LR  : SAMPLEReg&lt;14, "lr"&gt;;

def GRRegs : RegisterClass&lt;"SAMPLE", [i32], 32,
  (add R0, R1, R2, R3, SP)&gt;;</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec185"/>How it works</h2></div></div></div><p>
<code class="literal">TableGen</code> processes <a id="id286" class="indexterm"/>this <code class="literal">.td</code> file to generate the <code class="literal">.inc</code> files, which have<a id="id287" class="indexterm"/> registers represented in the form of enums that can be used in the <code class="literal">.cpp</code> files. These <code class="literal">.inc</code> files will be generated when we build the LLVM project.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec186"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">To get more details on how registers are defined for more advanced architecture, such as the x86, refer to the <code class="literal">X86RegisterInfo.td</code> file located at <code class="literal">llvm_source_code/lib/Target/X86/</code></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec63"/>Defining an instruction set</h1></div></div></div><p>The instruction set of an<a id="id288" class="indexterm"/> architecture varies according to various features present in the architecture. This recipe demonstrates how instruction sets are defined for the target architecture.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec187"/>Getting ready</h2></div></div></div><p>Three things are defined in the instruction target description file: operands, an assembly string, and an instruction pattern. The specification contains a list of definitions or outputs and a list of uses or inputs. There can be different operand classes such as the register class, and immediate or more complex <code class="literal">register + imm</code> operands.</p><p>Here, a simple add instruction definition is demonstrated. It takes two registers for the input and one register for the output.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec188"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a new file called <code class="literal">SAMPLEInstrInfo.td</code> in the <code class="literal">lib/Target/SAMPLE</code> folder:<div><pre class="programlisting">
<strong>$ vi SAMPLEInstrInfo.td</strong>
</pre></div></li><li class="listitem">Specify the operands, assembly string, and instruction pattern for the add instruction between two register operands:<div><pre class="programlisting">def ADDrr : InstSAMPLE&lt;(outs GRRegs:$dst),
          (ins GRRegs:$src1, GRRegs:$src2),
           "add $dst, $src1, $src2",
           [(set i32:$dst, (add i32:$src1, i32:$src2))]&gt;;</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec189"/>How it works…</h2></div></div></div><p>The <code class="literal">add</code> register instruction <a id="id289" class="indexterm"/>specifies <code class="literal">$dst</code> as the resultant operand, which belongs to the general register type class; the <code class="literal">$src1</code> and <code class="literal">$src2</code> inputs as two input operands, which also belong to the general register class; and the instruction assembly string as <code class="literal">add $dst, $src1, $src2</code>, which is of the 32-bit integer type.</p><p>So, an assembly will be generated for add between two registers, like this:</p><div><pre class="programlisting">add r0, r0, r1</pre></div><p>This tells us to add the <code class="literal">r0</code> and <code class="literal">r1</code> registers' content and store the result in the <code class="literal">r0</code> register.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec190"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">For more detailed information on various types of instruction sets for advanced architecture, such as the x86, refer to the <code class="literal">X86InstrInfo.td</code> file located at <code class="literal">lib/Target/X86/</code></li><li class="listitem">Detailed information of how target-specific things are defined will be covered in <a class="link" title="Chapter 8. Writing an LLVM Backend" href="part0087.xhtml#aid-2IV0U1">Chapter 8</a>, <em>Writing an LLVM Backend</em>. Some concepts might get repetitive, as the preceding recipes were described in brief to get a glimpse of the target architecture description and get a foretaste of the upcoming recipes</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec64"/>Adding a machine code descriptor</h1></div></div></div><p>The LLVM IR has functions, which<a id="id290" class="indexterm"/> have basic blocks. Basic blocks in turn have instructions. The next logical step is to convert those IR abstract blocks into machine-specific blocks. LLVM code is translated into a machine-specific representation formed from the <code class="literal">MachineFunction</code>, <code class="literal">MachineBasicBlock</code>, and <code class="literal">MachineInstr</code> instances. This representation contains instructions in their most abstract form—that is, having an opcode and a series of operands.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec191"/>How it's done…</h2></div></div></div><p>Now the LLVM IR instruction has to be represented in the machine instruction. Machine instructions are instances of the <code class="literal">MachineInstr</code> class. This class is an extremely abstract way of representing machine instructions. In particular, it only keeps track of an opcode number and a set of operands. The opcode number is a simple unsigned integer that has a meaning only for a specific backend.</p><p>Let's look at some important functions <a id="id291" class="indexterm"/>defined in the <code class="literal">MachineInstr.cpp</code> file:</p><p>The <code class="literal">MachineInstr</code> constructor:</p><div><pre class="programlisting">MachineInstr::MachineInstr(MachineFunction &amp;MF, const MCInstrDesc &amp;tid, const DebugLoc dl, bool NoImp)
  : MCID(&amp;tid), Parent(nullptr), Operands(nullptr), NumOperands(0),
    Flags(0), AsmPrinterFlags(0),
    NumMemRefs(0), MemRefs(nullptr), debugLoc(dl) {
  // Reserve space for the expected number of operands.
  if (unsigned NumOps = MCID-&gt;getNumOperands() +
    MCID-&gt;getNumImplicitDefs() + MCID-&gt;getNumImplicitUses()) {
    CapOperands = OperandCapacity::get(NumOps);
    Operands = MF.allocateOperandArray(CapOperands);
  }

  if (!NoImp)
    addImplicitDefUseOperands(MF);
}</pre></div><p>This constructor creates an object of <code class="literal">MachineInstr</code> class and adds the implicit operands. It reserves space for the number of operands specified by the <code class="literal">MCInstrDesc</code> class.</p><p>One of the important functions is <code class="literal">addOperand</code>. It adds the specified operand to the instruction. If it is an implicit operand, it is added at the end of the operand list. If it is an explicit operand, it is added at the end of the explicit operand list, as shown here:</p><div><pre class="programlisting">void MachineInstr::addOperand(MachineFunction &amp;MF, const MachineOperand &amp;Op) {
  assert(MCID &amp;&amp; "Cannot add operands before providing an instr descriptor");
  if (&amp;Op &gt;= Operands &amp;&amp; &amp;Op &lt; Operands + NumOperands) {
    MachineOperand CopyOp(Op);
    return addOperand(MF, CopyOp);
  }
  unsigned OpNo = getNumOperands();
  bool isImpReg = Op.isReg() &amp;&amp; Op.isImplicit();
  if (!isImpReg &amp;&amp; !isInlineAsm()) {
    while (OpNo &amp;&amp; Operands[OpNo-1].isReg() &amp;&amp; Operands[OpNo-1].isImplicit()) {
      --OpNo;
      assert(!Operands[OpNo].isTied() &amp;&amp; "Cannot move tied operands");
    }
  }

#ifndef NDEBUG
  bool isMetaDataOp = Op.getType() == MachineOperand::MO_Metadata;
  assert((isImpReg || Op.isRegMask() || MCID-&gt;isVariadic() ||
          OpNo &lt; MCID-&gt;getNumOperands() || isMetaDataOp) &amp;&amp;
         "Trying to add an operand to a machine instr that is already done!");
#endif

  MachineRegisterInfo *MRI = getRegInfo();
  OperandCapacity OldCap = CapOperands;
  MachineOperand *OldOperands = Operands;
  if (!OldOperands || OldCap.getSize() == getNumOperands()) {
    CapOperands = OldOperands ? OldCap.getNext() : OldCap.get(1);
    Operands = MF.allocateOperandArray(CapOperands);
    if (OpNo)
      moveOperands(Operands, OldOperands, OpNo, MRI);
  }
  if (OpNo != NumOperands)
    moveOperands(Operands + OpNo + 1, OldOperands + OpNo, NumOperands - OpNo,
                 MRI);
  ++NumOperands;
  if (OldOperands != Operands &amp;&amp; OldOperands)
    MF.deallocateOperandArray(OldCap, OldOperands);
  MachineOperand *NewMO = new (Operands + OpNo) MachineOperand(Op);
  NewMO-&gt;ParentMI = this;
  if (NewMO-&gt;isReg()) {
        NewMO-&gt;Contents.Reg.Prev = nullptr;
    NewMO-&gt;TiedTo = 0;
        if (MRI)
      MRI-&gt;addRegOperandToUseList(NewMO);
        if (!isImpReg) {
            if (NewMO-&gt;isUse()) {
        int DefIdx = MCID-&gt;getOperandConstraint(OpNo, MCOI::TIED_TO);
        if (DefIdx != -1)
          tieOperands(DefIdx, OpNo);
      }
           if (MCID-&gt;getOperandConstraint(OpNo, MCOI::EARLY_CLOBBER) != -1)
        NewMO-&gt;setIsEarlyClobber(true);
    }
  }
}</pre></div><p>The target architecture has some memory operands as well. To add those memory operands, a function called <code class="literal">addMemOperands()</code> is defined:</p><div><pre class="programlisting">void MachineInstr::addMemOperand(MachineFunction &amp;MF,
                                 MachineMemOperand *MO) {
  mmo_iterator OldMemRefs = MemRefs;
  unsigned OldNumMemRefs = NumMemRefs;
  unsigned NewNum = NumMemRefs + 1;
  mmo_iterator NewMemRefs = MF.allocateMemRefsArray(NewNum);
  std::copy(OldMemRefs, OldMemRefs + OldNumMemRefs, NewMemRefs);
  NewMemRefs[NewNum - 1] = MO;
  setMemRefs(NewMemRefs, NewMemRefs + NewNum);
}</pre></div><p>The <code class="literal">setMemRefs()</code> function is <a id="id292" class="indexterm"/>the primary method for setting up a <code class="literal">MachineInstr</code> <code class="literal">MemRefs</code> list.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec192"/>How it works…</h2></div></div></div><p>The <code class="literal">MachineInstr</code> class has an MCID member, with the <code class="literal">MCInstrDesc</code> type for describing the instruction, a <code class="literal">uint8_t</code> flags member, a memory reference member (<code class="literal">mmo_iterator</code> <code class="literal">MemRefs</code>), and a vector member of the <code class="literal">std::vector&lt;MachineOperand</code>&gt; operands. In terms of methods, the <code class="literal">MachineInstr</code> class provides the following:</p><div><ul class="itemizedlist"><li class="listitem">A basic set of <code class="literal">get**</code> and <code class="literal">set**</code> functions for information queries, for example, <code class="literal">getOpcode()</code>, <code class="literal">getNumOperands()</code>, and so on</li><li class="listitem">Bundle-related operations, for example, <code class="literal">isInsideBundle()</code></li><li class="listitem">Checking whether the instruction has certain properties, for example, <code class="literal">isVariadic()</code>, <code class="literal">isReturn()</code>, <code class="literal">isCall()</code>, and so on</li><li class="listitem">Machine instruction manipulation, for example, <code class="literal">eraseFromParent()</code></li><li class="listitem">Register-related operations, such as <code class="literal">ubstituteRegister()</code>, <code class="literal">addRegisterKilled()</code>, and so on</li><li class="listitem">Machine-instruction-creating methods, for example, <code class="literal">addOperand()</code>, <code class="literal">setDesc()</code>, and so on</li></ul></div><p>Note that, although the <code class="literal">MachineInstr</code> class provides machine-instruction-creating methods, a dedicated function called <code class="literal">BuildMI()</code>, based on the <code class="literal">MachineInstrBuilder</code> class, is more convenient.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec65"/>Implementing the MachineInstrBuilder class</h1></div></div></div><p>The <code class="literal">MachineInstrBuilder</code> class exposes a function called <code class="literal">BuildMI()</code>. This function is used to build machine instructions.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec193"/>How to do it…</h2></div></div></div><p>Machine instructions are<a id="id293" class="indexterm"/> created by using the <code class="literal">BuildMI</code> functions, located in the <code class="literal">include/llvm/CodeGen/MachineInstrBuilder.h</code> file. The <code class="literal">BuildMI</code> functions make it easy to build arbitrary machine instructions.</p><p>For example, you can use <code class="literal">BuildMI</code> in code snippets for the following purposes:</p><div><ol class="orderedlist arabic"><li class="listitem">To create a <code class="literal">DestReg = mov 42</code> (rendered in the x86 assembly as <code class="literal">mov DestReg, 42</code>) instruction:<div><pre class="programlisting">MachineInstr *MI = BuildMI(X86::MOV32ri, 1, DestReg).addImm(42);</pre></div></li><li class="listitem">To create the same instruction, but insert it at the end of a basic block:<div><pre class="programlisting">MachineBasicBlock &amp;MBB = BuildMI(MBB, X86::MOV32ri, 1, DestReg).addImm(42);</pre></div></li><li class="listitem">To create the same instruction, but insert it before a specified iterator point:<div><pre class="programlisting">MachineBasicBlock::iterator MBBI = 
BuildMI(MBB, MBBI, X86::MOV32ri, 1, DestReg).addImm(42)</pre></div></li><li class="listitem">To create a self-looping branch instruction:<div><pre class="programlisting">BuildMI(MBB, X86::JNE, 1).addMBB(&amp;MBB);</pre></div></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec194"/>How it works…</h2></div></div></div><p>The <code class="literal">BuildMI()</code> function is required for specifying the number of operands that the machine instruction will take, which facilitates efficient memory allocation. It is also required to specify whether operands use values or definitions.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec66"/>Implementing the MachineBasicBlock class</h1></div></div></div><p>Similar to basic blocks in<a id="id294" class="indexterm"/> the LLVM IR, a <code class="literal">MachineBasicBlock</code> class has a set of machine instructions in sequential order. Mostly, a <code class="literal">MachineBasicBlock</code> class maps to a single LLVM IR basic block. However, there can be cases where multiple <code class="literal">MachineBasicBlocks</code> classes map to a single LLVM IR basic block. The <code class="literal">MachineBasicBlock</code> class has a method, called <code class="literal">getBasicBlock()</code>, that returns the IR basic block to which it is mapping.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec195"/>How to do it…</h2></div></div></div><p>The following steps show<a id="id295" class="indexterm"/> how machine basic blocks are added:</p><div><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">getBasicBlock</code> method will return only the current basic block:<div><pre class="programlisting">const <strong>BasicBlock</strong> *<strong>getBasicBlock()</strong> const { return BB; }</pre></div></li><li class="listitem">The basic blocks have successor as well as predecessor basic blocks. To keep track of those, vectors are defined as follows:<div><pre class="programlisting">std::vector&lt;MachineBasicBlock *&gt; Predecessors;
std::vector&lt;MachineBasicBlock *&gt; Successors;</pre></div></li><li class="listitem">An <code class="literal">insert</code> function should be added to insert a machine instruction into the basic block:<div><pre class="programlisting">  MachineBasicBlock::insert(instr_iterator I, MachineInstr *MI) {
assert(!MI-&gt;isBundledWithPred() &amp;&amp; !MI-&gt;isBundledWithSucc()  &amp;&amp; "Cannot insert instruction with bundle flags");

if (I != instr_end() &amp;&amp; I-&gt;isBundledWithPred()) {        MI-&gt;setFlag(MachineInstr::BundledPred);              MI-&gt;setFlag(MachineInstr::BundledSucc);
}
    return Insts.insert(I, MI);
}</pre></div></li><li class="listitem">A function called <code class="literal">SplitCriticalEdge()</code> splits the critical edges from this block to the given successor block, and returns the newly created block, or null if splitting is not possible. This function updates the <code class="literal">LiveVariables</code>, <code class="literal">MachineDominatorTree</code>, and <code class="literal">MachineLoopInfo</code> classes:<div><pre class="programlisting">MachineBasicBlock *
MachineBasicBlock::SplitCriticalEdge(MachineBasicBlock *Succ, Pass *P) {
…
…
…
}</pre></div></li></ol><div></div><div><h3 class="title"><a id="note07"/>Note</h3><p>The full implementation of the preceding code is shown in the <code class="literal">MachineBasicBlock.cpp</code> file located at <code class="literal">lib/CodeGen/</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec196"/>How it works…</h2></div></div></div><p>As listed previously, several <a id="id296" class="indexterm"/>representative functions of different categories form the interface definition of the <code class="literal">MachineBasicBlock</code> class. The <code class="literal">MachineBasicBlock</code> class keeps a list of machine instructions such as <code class="literal">typedef ilist&lt;MachineInstr&gt;</code> instructions, instructions <code class="literal">Insts</code>, and the original LLVM BB (basic block). It also provides methods for purposes such as these:</p><div><ul class="itemizedlist"><li class="listitem">BB information querying (for example, <code class="literal">getBasicBlock()</code> and <code class="literal">setHasAddressTaken()</code>)</li><li class="listitem">BB-level manipulation (for example, <code class="literal">moveBefore()</code>, <code class="literal">moveAfter()</code>, and <code class="literal">addSuccessor()</code>)</li><li class="listitem">Instruction-level manipulation (for example, <code class="literal">push_back()</code>, <code class="literal">insertAfter()</code>, and so on)</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec197"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">To see a detailed implementation of the <code class="literal">MachineBasicBlock class</code>, go through the <code class="literal">MachineBasicBlock.cpp</code> file located at <code class="literal">lib/CodeGen/</code></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec67"/>Implementing the MachineFunction class</h1></div></div></div><p>Similar to the LLVM<a id="id297" class="indexterm"/> IR <code class="literal">FunctionBlock</code> class, a <code class="literal">MachineFunction</code> class contains a series of <code class="literal">MachineBasicBlocks</code> classes. These <code class="literal">MachineFunction</code> classes map to LLVM IR functions that are given as input to the instruction selector. In addition to a list of basic blocks, the <code class="literal">MachineFunction</code> class contains the <code class="literal">MachineConstantPool</code>, <code class="literal">MachineFrameInfo</code>, <code class="literal">MachineFunctionInfo</code>, and <code class="literal">MachineRegisterInfo</code> classes.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec198"/>How to do it…</h2></div></div></div><p>Many functions are defined in the <code class="literal">MachineFunction</code> class, which does specific tasks. There are also many class member objects that keep information, such as the following:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">RegInfo</code> keeps information about each register that is in use in the function:<div><pre class="programlisting">MachineRegisterInfo *RegInfo;</pre></div></li><li class="listitem"><code class="literal">MachineFrameInfo</code> keeps track of objects allocated on the stack:<div><pre class="programlisting">MachineFrameInfo *FrameInfo;</pre></div></li><li class="listitem"><code class="literal">ConstantPool</code> keeps track of constants that have been spilled to the memory:<div><pre class="programlisting">MachineConstantPool *ConstantPool;</pre></div></li><li class="listitem"><code class="literal">JumpTableInfo</code> keeps track of jump tables for switch instructions:<div><pre class="programlisting">MachineJumpTableInfo *JumpTableInfo;</pre></div></li><li class="listitem">The list of machine basic blocks in the function:<div><pre class="programlisting">typedef ilist&lt;MachineBasicBlock&gt; BasicBlockListType;
BasicBlockListType BasicBlocks;</pre></div></li><li class="listitem">The <code class="literal">getFunction</code> function returns the LLVM function that the current machine code represents:<div><pre class="programlisting">const Function *getFunction() const { return Fn; }</pre></div></li><li class="listitem"><code class="literal">CreateMachineInstr</code> allocates a new <code class="literal">MachineInstr</code> class:<div><pre class="programlisting">MachineInstr *CreateMachineInstr(const MCInstrDesc &amp;MCID,
DebugLoc DL,
bool NoImp = false);</pre></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec199"/>How it works…</h2></div></div></div><p>The <code class="literal">MachineFunction</code> <a id="id298" class="indexterm"/>class primarily contains a list of <code class="literal">MachineBasicBlock</code> objects (<code class="literal">typedef ilist&lt;MachineBasicBlock&gt; BasicBlockListType; BasicBlockListType BasicBlocks;</code>), and defines various methods for retrieving information about the machine function and manipulating the objects in the basic blocks member. A very important point to note is that the <code class="literal">MachineFunction</code> class maintains the <strong>control flow graph</strong> (<strong>CFG</strong>)<a id="id299" class="indexterm"/> of all basic blocks in a function. Control flow information in CFG is crucial for many optimizations and analyses. So, it is important to know how the <code class="literal">MachineFunction</code> objects and the corresponding CFGs are constructed.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec200"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">A detailed implementation of the <code class="literal">MachineFunction</code> class can be found in the <code class="literal">MachineFunction.cpp</code> file located at <code class="literal">lib/Codegen/</code></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec68"/>Writing an instruction selector</h1></div></div></div><p>LLVM uses <a id="id300" class="indexterm"/>the <code class="literal">SelectionDAG</code> representation to represent the LLVM IR in a low-level data-dependence DAG for instruction selection. Various simplifications and target-specific optimizations can be applied to the <code class="literal">SelectionDAG</code> representation. This representation is target-independent. It is a significant, simple, and powerful representation used to implement IR lowering to target instructions.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec201"/>How to do it…</h2></div></div></div><p>The following code<a id="id301" class="indexterm"/> shows a brief skeleton of the <code class="literal">SelectionDAG</code> class, its data members, and various methods used to set/retrieve useful information from this class. The <code class="literal">SelectionDAG</code> class is defined as follows:</p><div><pre class="programlisting">class SelectionDAG {
const TargetMachine &amp;TM;
const TargetLowering &amp;TLI;
const TargetSelectionDAGInfo &amp;TSI;
MachineFunction *MF;
LLVMContext *Context;
CodeGenOpt::Level OptLevel;

SDNode EntryNode;
// Root - The root of the entire DAG.
SDValue Root;

// AllNodes - A linked list of nodes in the current DAG.
ilist&lt;SDNode&gt; AllNodes;

// NodeAllocatorType - The AllocatorType for allocating SDNodes. We use

typedef RecyclingAllocator&lt;BumpPtrAllocator, SDNode, sizeof(LargestSDNode),
AlignOf&lt;MostAlignedSDNode&gt;::Alignment&gt;
NodeAllocatorType;

BumpPtrAllocator OperandAllocator;

BumpPtrAllocator Allocator;

SDNodeOrdering *Ordering;

public:

struct DAGUpdateListener {

DAGUpdateListener *const Next;

SelectionDAG &amp;DAG;

explicit DAGUpdateListener(SelectionDAG &amp;D)
: Next(D.UpdateListeners), DAG(D) {
DAG.UpdateListeners = this;
}

private:

friend struct DAGUpdateListener;

DAGUpdateListener *UpdateListeners;


void init(MachineFunction &amp;mf);

// Function to set root node of SelectionDAG
const SDValue &amp;setRoot(SDValue N) {
  assert((!N.getNode() || N.getValueType() == MVT::Other) &amp;&amp;
    "DAG root value is not a chain!");
  if (N.getNode())
    checkForCycles(N.getNode());
  Root = N;
  if (N.getNode())
    checkForCycles(this);
  return Root;
}

void Combine(CombineLevel Level, AliasAnalysis &amp;AA,
CodeGenOpt::Level OptLevel);

SDValue getConstant(uint64_t Val, EVT VT, bool isTarget = false);

SDValue getConstantFP(double Val, EVT VT, bool isTarget = false);

SDValue getGlobalAddress(const GlobalValue *GV, DebugLoc DL, EVT VT, int64_t offset = 0, bool isTargetGA = false, 
unsigned char TargetFlags = 0);

SDValue getFrameIndex(int FI, EVT VT, bool isTarget = false);

SDValue getTargetIndex(int Index, EVT VT, int64_t Offset = 0,
unsigned char TargetFlags = 0);

// Function to return Basic Block corresponding to this MachineBasicBlock
SDValue getBasicBlock(MachineBasicBlock *MBB);

SDValue getBasicBlock(MachineBasicBlock *MBB, DebugLoc dl);

SDValue getExternalSymbol(const char *Sym, EVT VT);

SDValue getExternalSymbol(const char *Sym, DebugLoc dl, EVT VT);

SDValue getTargetExternalSymbol(const char *Sym, EVT VT,
unsigned char TargetFlags = 0);

// Return the type of the value this SelectionDAG node corresponds // to
SDValue getValueType(EVT);

SDValue getRegister(unsigned Reg, EVT VT);

SDValue getRegisterMask(const uint32_t *RegMask);

SDValue getEHLabel(DebugLoc dl, SDValue Root, MCSymbol *Label);

SDValue getBlockAddress(const BlockAddress *BA, EVT VT,
int64_t Offset = 0, bool isTarget = false,
unsigned char TargetFlags = 0);

SDValue getSExtOrTrunc(SDValue Op, DebugLoc DL, EVT VT);

SDValue getZExtOrTrunc(SDValue Op, DebugLoc DL, EVT VT);

SDValue getZeroExtendInReg(SDValue Op, DebugLoc DL, EVT SrcTy);

SDValue getNOT(DebugLoc DL, SDValue Val, EVT VT);

// Function to get SelectionDAG node.
SDValue getNode(unsigned Opcode, DebugLoc DL, EVT VT);

SDValue getNode(unsigned Opcode, DebugLoc DL, EVT VT, SDValue N);

SDValue getNode(unsigned Opcode, DebugLoc DL, EVT VT, SDValue N1, SDValue N2);

SDValue getNode(unsigned Opcode, DebugLoc DL, EVT VT,
SDValue N1, SDValue N2, SDValue N3);

SDValue getMemcpy(SDValue Chain, DebugLoc dl, SDValue Dst, SDValue Src,SDValue Size, unsigned Align, bool isVol, bool AlwaysInline,
MachinePointerInfo DstPtrInfo,MachinePointerInfo SrcPtrInfo);

SDValue getAtomic(unsigned Opcode, DebugLoc dl, EVT MemVT, SDValue Chain,
SDValue Ptr, SDValue Cmp, SDValue Swp,
MachinePointerInfo PtrInfo, unsigned Alignment,
AtomicOrdering Ordering,
SynchronizationScope SynchScope);

SDNode *UpdateNodeOperands(SDNode *N, SDValue Op);

SDNode *UpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2);

SDNode *UpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2,
SDValue Op3);

SDNode *SelectNodeTo(SDNode *N, unsigned TargetOpc, EVT VT);

SDNode *SelectNodeTo(SDNode *N, unsigned TargetOpc, EVT VT, SDValue Op1);

SDNode *SelectNodeTo(SDNode *N, unsigned TargetOpc, EVT VT,
SDValue Op1, SDValue Op2);

MachineSDNode *getMachineNode(unsigned Opcode, DebugLoc dl, EVT VT);
MachineSDNode *getMachineNode(unsigned Opcode, DebugLoc dl, EVT VT,
SDValue Op1);

MachineSDNode *getMachineNode(unsigned Opcode, DebugLoc dl, EVT VT,
SDValue Op1, SDValue Op2);

void ReplaceAllUsesWith(SDValue From, SDValue Op);

void ReplaceAllUsesWith(SDNode *From, SDNode *To);

void ReplaceAllUsesWith(SDNode *From, const SDValue *To);

bool isBaseWithConstantOffset(SDValue Op) const;

bool isKnownNeverNaN(SDValue Op) const;

bool isKnownNeverZero(SDValue Op) const;

bool isEqualTo(SDValue A, SDValue B) const;

SDValue UnrollVectorOp(SDNode *N, unsigned ResNE = 0);

bool isConsecutiveLoad(LoadSDNode *LD, LoadSDNode *Base,

unsigned Bytes, int Dist) const;

unsigned InferPtrAlignment(SDValue Ptr) const;

private:

bool RemoveNodeFromCSEMaps(SDNode *N);

void AddModifiedNodeToCSEMaps(SDNode *N);

SDNode *FindModifiedNodeSlot(SDNode *N, SDValue Op, void *&amp;InsertPos);

SDNode *FindModifiedNodeSlot(SDNode *N, SDValue Op1, SDValue Op2,
void *&amp;InsertPos);

SDNode *FindModifiedNodeSlot(SDNode *N, const SDValue *Ops, unsigned NumOps,void *&amp;InsertPos);

SDNode *UpdadeDebugLocOnMergedSDNode(SDNode *N, DebugLoc loc);

void DeleteNodeNotInCSEMaps(SDNode *N);

void DeallocateNode(SDNode *N);

unsigned getEVTAlignment(EVT MemoryVT) const;

void allnodes_clear();

std::vector&lt;SDVTList&gt; VTList;

std::vector&lt;CondCodeSDNode*&gt; CondCodeNodes;

std::vector&lt;SDNode*&gt; ValueTypeNodes;

std::map&lt;EVT, SDNode*, EVT::compareRawBits&gt; ExtendedValueTypeNodes;

StringMap&lt;SDNode*&gt; ExternalSymbols;

std::map&lt;std::pair&lt;std::string, unsigned char&gt;,SDNode*&gt; TargetExternalSymbols;
};</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec202"/>How it works…</h2></div></div></div><p>From the preceding <a id="id302" class="indexterm"/>code, it can be seen that the <code class="literal">SelectionDAG</code> class provides lots of target-independent methods to create <code class="literal">SDNode</code> of various kinds, and retrieves/computes useful information from the nodes in the <code class="literal">SelectionDAG</code> graph. There are also update and replace methods provided in the <code class="literal">SelectionDAG</code> class. Most of these methods are defined in the <code class="literal">SelectionDAG.cpp</code> file. Note that the <code class="literal">SelectionDAG</code> graph and its node type, <code class="literal">SDNode</code>, are designed in a way that is capable of storing both target-independent and target-specific information. For example, the <code class="literal">isTargetOpcode()</code> and <code class="literal">isMachineOpcode()</code> methods in the <code class="literal">SDNode</code> class can be used to determine whether an opcode is a target opcode or a machine opcode (target-independent). This is because the same class type, <code class="literal">NodeType</code>, is used to represent both the opcode of a real target and the opcode of a machine instruction, but with separate ranges.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec69"/>Legalizing SelectionDAG</h1></div></div></div><p>A <code class="literal">SelectionDAG</code> representation<a id="id303" class="indexterm"/> is a target-independent representation of instructions and operands. However, a target may not always support the instruction or data type represented by <code class="literal">SelectionDAG</code>. In that sense, the initial <code class="literal">SelectionDAG</code> graph constructed can be called illegal. The DAG legalize phase converts the illegal DAG into a legal DAG supported by the target architecture.</p><p>A DAG legalize phase can follow two ways to convert unsupported data types into supported data types—by promoting smaller data types to larger data types, or by truncating larger data types into smaller ones. For example, suppose that a type of target architecture supports only i32 data types. In that case, smaller data types such as i8 and i16 need to be promoted to the i32 type. A larger data type, such as i64, can be expanded to give two i32 data types. The <code class="literal">Sign</code> and <code class="literal">Zero</code> extensions can be added so that the result remains consistent in the process of promoting or expanding data types.</p><p>Similarly, vector types can be legalized to supported vector types by either splitting the vector into smaller sized vectors (by extracting the elements from the vector), or by widening smaller vector types to larger, supported vector types. If vectors are not supported in the target architecture, then every element of the vector in the IR needs to be extracted in the scalar form.</p><p>The legalize phase can also instruct the kind of classes of registers supported for given data.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec203"/>How to do it…</h2></div></div></div><p>The <code class="literal">SelectionDAGLegalize</code> class<a id="id304" class="indexterm"/> consists of various data members, tracking data structures to keep a track of legalized nodes, and various methods that are used to operate on nodes to legalize them. A sample snapshot of the legalize phase code from the LLVM trunk shows the basic skeleton of implementation of the legalize phase, as follows:</p><div><pre class="programlisting">namespace {
class SelectionDAGLegalize : public SelectionDAG::DAGUpdateListener {

const TargetMachine &amp;TM;

const TargetLowering &amp;TLI;

SelectionDAG &amp;DAG;

SelectionDAG::allnodes_iterator LegalizePosition;

// LegalizedNodes - The set of nodes which have already been legalized.
SmallPtrSet&lt;SDNode *, 16&gt; LegalizedNodes;

public:
explicit SelectionDAGLegalize(SelectionDAG &amp;DAG);
void LegalizeDAG();

private:

void LegalizeOp(SDNode *Node);

SDValue OptimizeFloatStore(StoreSDNode *ST);

// Legalize Load operations
void LegalizeLoadOps(SDNode *Node);

// Legalize Store operations
void LegalizeStoreOps(SDNode *Node);

// Main legalize function which operates on Selection DAG node
void SelectionDAGLegalize::LegalizeOp(SDNode *Node) {
// A target node which is constant need not be legalized further
  if (Node-&gt;getOpcode() == ISD::TargetConstant)
    return;

  for (unsigned i = 0, e = Node-&gt;getNumValues(); i != e; ++i)
    assert(TLI.getTypeAction(*DAG.getContext(), Node-&gt;getValueType(i)) == TargetLowering::TypeLegal &amp;&amp; "Unexpected illegal type!");

  for (unsigned i = 0, e = Node-&gt;getNumOperands(); i != e; ++i)
    assert((TLI.getTypeAction(*DAG.getContext(),
    Node-&gt;getOperand(i).getValueType()) == TargetLowering::TypeLegal ||
      Node-&gt;getOperand(i).getOpcode() == ISD::TargetConstant) &amp;&amp; "Unexpected illegal type!");

  TargetLowering::LegalizeAction Action = TargetLowering::Legal;
  bool SimpleFinishLegalizing = true;

// Legalize based on instruction opcode
  switch (Node-&gt;getOpcode()) {
    case ISD::INTRINSIC_W_CHAIN:
    case ISD::INTRINSIC_WO_CHAIN:
    case ISD::INTRINSIC_VOID:
    case ISD::STACKSAVE:
          Action = TLI.getOperationAction(Node-&gt;getOpcode(), MVT::Other);
    break;
…
…
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec204"/>How it works…</h2></div></div></div><p>Many function members of<a id="id305" class="indexterm"/> the <code class="literal">SelectionDAGLegalize</code> class, such as <code class="literal">LegalizeOp</code>, rely on target-specific information provided by the <code class="literal">const TargetLowering &amp;TLI</code> member (other function members may also depend on the <code class="literal">const TargetMachine &amp;TM</code> member) in the <code class="literal">SelectionDAGLegalize</code> class. Let's take an example to demonstrate how legalization works.</p><p>There are two types of legalization: type legalization and instruction legalization. Let's first see how type legalization works. Create a <code class="literal">test.ll</code> file using the following commands:</p><div><pre class="programlisting">
<strong>$ cat test.ll</strong>
<strong>define i64 @test(i64 %a, i64 %b, i64 %c) {</strong>
<strong>  %add = add nsw i64 %a, %b</strong>
<strong>  %div = sdiv i64 %add, %c</strong>
<strong>  ret i64 %div</strong>
<strong>}</strong>
</pre></div><p>The data type in this case is i64. For the x86 target, which supports only the 32-bit data type, the data type you just saw is illegal. To run the preceding code, the data type has to be converted to i32. This is done by the DAG Legalization phase.</p><p>To view the DAG before type<a id="id306" class="indexterm"/> legalization, run the following command line:</p><div><pre class="programlisting">
<strong>$ llc -view-dag-combine1-dags test.ll</strong>
</pre></div><p>The following figure shows the DAG before type legalization:</p><div><img src="img/image00261.jpeg" alt="How it works…"/></div><p style="clear:both; height: 1em;"> </p><p>To see DAG after type legalization, enter the following command line:</p><div><pre class="programlisting">
<strong>$ llc -view-dag-combine2-dags test.ll</strong>
</pre></div><p>The following figure shows the DAG after type legalization:</p><div><img src="img/image00262.jpeg" alt="How it works…"/></div><p style="clear:both; height: 1em;"> </p><p>On observing the DAG <a id="id307" class="indexterm"/>nodes carefully, you can see that every operation before legalization had the i64 type. This was because the IR had the data type i64—one-to-one mapping from the IR instruction to the DAG nodes. However, the target x86 machine supports only the i32 type (32-bit integer type). The DAG legalize phase converts unsupported i64 types to supported i32 types. This operation is called expanding—splitting larger types into smaller types. For example, in a target accepting only i32 values, all i64 values are broken down to pairs of i32 values. So, after legalization, you can see that all the operations now have i32 as the data type.</p><p>Let's see how instructions are legalized; create a <code class="literal">test.ll</code> file using the following commands:</p><div><pre class="programlisting">
<strong>$ cat test.ll</strong>
<strong>define i32 @test(i32 %a, i32 %b, i32 %c) {</strong>
<strong>  %add = add nsw i32 %a, %b</strong>
<strong>  %div = sdiv i32 %add, %c</strong>
<strong>  ret i32 %div</strong>
<strong>}</strong>
</pre></div><p>To view the DAG before legalization, enter the following command:</p><div><pre class="programlisting">
<strong>$ llc –view-dag-combine1-dags test.ll</strong>
</pre></div><p>The following figure shows the DAG before legalization:</p><div><img src="img/image00263.jpeg" alt="How it works…"/></div><p style="clear:both; height: 1em;"> </p><p>To view the DAG after <a id="id308" class="indexterm"/>legalization, enter the following command:</p><div><pre class="programlisting">
<strong>$ llc -view-dag-combine2-dags test.ll</strong>
</pre></div><p>The following figure shows the DAG after the legalization phase:</p><div><img src="img/image00264.jpeg" alt="How it works…"/></div><p style="clear:both; height: 1em;"> </p><p>The DAG, before <a id="id309" class="indexterm"/>instruction legalization, consists of <code class="literal">sdiv</code> instructions. Now, the x86 target does not support the <code class="literal">sdiv</code> instruction, hence it is illegal for the target. It does, however, support the <code class="literal">sdivrem</code> instruction. So, the legalization phase involves conversion of the <code class="literal">sdiv</code> instruction to the <code class="literal">sdivrem</code> instruction, as visible in the preceding two DAGs.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec70"/>Optimizing SelectionDAG</h1></div></div></div><p>A <code class="literal">SelectionDAG</code> representation <a id="id310" class="indexterm"/>shows data and instructions in the form of nodes. Similar to the <code class="literal">InstCombine</code> pass in the LLVM IR, these nodes can be combined and optimized to form a minimized <code class="literal">SelectionDAG</code>. But, it's not just a <code class="literal">DAGCombine</code> operation that optimizes the SelectionDAG. A <code class="literal">DAGLegalize</code> phase may generate some unnecessary DAG nodes, which are cleaned up by subsequent runs of the DAG optimization pass. This finally represents the <code class="literal">SelectionDAG</code> in a more simple and elegant way.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec205"/>How to do it…</h2></div></div></div><p>There are lots and lots of function members (most of them are named like this: <code class="literal">visit**()</code>) provided in the <code class="literal">DAGCombiner</code> class to perform optimizations by folding, reordering, combining, and modifying <code class="literal">SDNode</code> nodes. Note that, from the <code class="literal">DAGCombiner</code> constructor, we can guess that some optimizations require alias analysis information:</p><div><pre class="programlisting">class DAGCombiner {
SelectionDAG &amp;DAG;
const TargetLowering &amp;TLI;
CombineLevel Level;
CodeGenOpt::Level OptLevel;
bool LegalOperations;
bool LegalTypes;

SmallPtrSet&lt;SDNode*, 64&gt; WorkListContents;
SmallVector&lt;SDNode*, 64&gt; WorkListOrder;

AliasAnalysis &amp;AA;

// Add SDnodes users to worklist
void AddUsersToWorkList(SDNode *N) {
  for (SDNode::use_iterator UI = N-&gt;use_begin(),
        UE = N-&gt;use_end(); UI != UE; ++UI)
    AddToWorkList(*UI);
}
SDValue visit(SDNode *N);

public:

void AddToWorkList(SDNode *N) {
  WorkListContents.insert(N);
  WorkListOrder.push_back(N);
}

void removeFromWorkList(SDNode *N) {
  WorkListContents.erase(N);
}

// SDnode combine operations.
SDValue CombineTo(SDNode *N, const SDValue *To, unsigned NumTo,
bool AddTo = true);

SDValue CombineTo(SDNode *N, SDValue Res, bool AddTo = true) {
  return CombineTo(N, &amp;Res, 1, AddTo);
}

SDValue CombineTo(SDNode *N, SDValue Res0, SDValue Res1,
bool AddTo = true) {
  SDValue To[] = { Res0, Res1 };
  return CombineTo(N, To, 2, AddTo);
}
void CommitTargetLoweringOpt(const TargetLowering::TargetLoweringOpt &amp;TLO);

private:

bool SimplifyDemandedBits(SDValue Op) {
  unsigned BitWidth = Op.getValueType().getScalarType().getSizeInBits();
  APInt Demanded = APInt::getAllOnesValue(BitWidth);
  return SimplifyDemandedBits(Op, Demanded);
}
bool SimplifyDemandedBits(SDValue Op, const APInt &amp;Demanded);

bool CombineToPreIndexedLoadStore(SDNode *N);

bool CombineToPostIndexedLoadStore(SDNode *N);

void ReplaceLoadWithPromotedLoad(SDNode *Load, SDNode *ExtLoad);

SDValue PromoteOperand(SDValue Op, EVT PVT, bool &amp;Replace);

SDValue SExtPromoteOperand(SDValue Op, EVT PVT);

SDValue ZExtPromoteOperand(SDValue Op, EVT PVT);

SDValue PromoteIntBinOp(SDValue Op);

SDValue PromoteIntShiftOp(SDValue Op);

SDValue PromoteExtend(SDValue Op);

bool PromoteLoad(SDValue Op);

void ExtendSetCCUses(SmallVector&lt;SDNode*, 4&gt; SetCCs,
SDValue Trunc, SDValue ExtLoad, DebugLoc DL,
ISD::NodeType ExtType);

SDValue combine(SDNode *N);

// Various visit functions operating on instructions represented
// by SD node. Similar to instruction combining at IR level.
SDValue visitTokenFactor(SDNode *N);

SDValue visitMERGE_VALUES(SDNode *N);

SDValue visitADD(SDNode *N);
SDValue visitSUB(SDNode *N);
SDValue visitADDC(SDNode *N);
SDValue visitSUBC(SDNode *N);
SDValue visitADDE(SDNode *N);
SDValue visitSUBE(SDNode *N);
SDValue visitMUL(SDNode *N);

public:

DAGCombiner(SelectionDAG &amp;D, AliasAnalysis &amp;A, CodeGenOpt::Level OL)
: DAG(D), TLI(D.getTargetLoweringInfo()), Level(BeforeLegalizeTypes),
  OptLevel(OL), LegalOperations(false), LegalTypes(false), AA(A) {}

// Selection DAG transformation for following ops
SDValue DAGCombiner::visitMUL(SDNode *N) {
  SDValue N0 = N-&gt;getOperand(0);
  SDValue N1 = N-&gt;getOperand(1);
  ConstantSDNode *N0C = dyn_cast&lt;ConstantSDNode&gt;(N0);
  ConstantSDNode *N1C = dyn_cast&lt;ConstantSDNode&gt;(N1);
  EVT VT = N0.getValueType();
  if (VT.isVector()) {
    SDValue FoldedVOp = SimplifyVBinOp(N);
    if (FoldedVOp.getNode()) return FoldedVOp;
  }
  if (N0.getOpcode() == ISD::UNDEF || N1.getOpcode() == ISD::UNDEF)
    return DAG.getConstant(0, VT);

  if (N0C &amp;&amp; N1C)
    return DAG.FoldConstantArithmetic(ISD::MUL, VT, N0C, N1C);

  if (N0C &amp;&amp; !N1C)
    return DAG.getNode(ISD::MUL, N-&gt;getDebugLoc(), VT, N1, N0);

  if (N1C &amp;&amp; N1C-&gt;isNullValue())
    return N1;

  if (N1C &amp;&amp; N1C-&gt;isAllOnesValue())
    return DAG.getNode(ISD::SUB, N-&gt;getDebugLoc(), VT, DAG.getConstant(0, VT), N0);
  if (N1C &amp;&amp; N1C-&gt;getAPIntValue().isPowerOf2())
    return DAG.getNode(ISD::SHL, N-&gt;getDebugLoc(), VT, N0,
           DAG.getConstant(N1C-&gt;getAPIntValue().logBase2(),
               getShiftAmountTy(N0.getValueType())));

  if (N1C &amp;&amp; (-N1C-&gt;getAPIntValue()).isPowerOf2()) {
    unsigned Log2Val = (-N1C-&gt;getAPIntValue()).logBase2();
    return DAG.getNode(ISD::SUB, N-&gt;getDebugLoc(), VT, DAG.getConstant(0, VT),
    DAG.getNode(ISD::SHL, N-&gt;getDebugLoc(), VT, N0,
    DAG.getConstant(Log2Val, getShiftAmountTy(N0.getValueType()))));
  }

  if (N1C &amp;&amp; N0.getOpcode() == ISD::SHL &amp;&amp;
      isa&lt;ConstantSDNode&gt;(N0.getOperand(1))) {
    SDValue C3 = DAG.getNode(ISD::SHL, N-&gt;getDebugLoc(), VT, N1, N0.getOperand(1));
    AddToWorkList(C3.getNode());
    return DAG.getNode(ISD::MUL, N-&gt;getDebugLoc(), VT,
    N0.getOperand(0), C3);
  }

  if (N0.getOpcode() == ISD::SHL &amp;&amp; isa&lt;ConstantSDNode&gt;(N0.getOperand(1)) &amp;&amp;
      N0.getNode()-&gt;hasOneUse()) {
    Sh = N0; Y = N1;
  } else if (N1.getOpcode() == ISD::SHL &amp;&amp; isa&lt;ConstantSDNode&gt;(N1.getOperand(1)) &amp;&amp;
            N1.getNode()-&gt;hasOneUse()) {
    Sh = N1; Y = N0;
  }
  if (Sh.getNode()) {
  SDValue Mul = DAG.getNode(ISD::MUL, N-&gt;getDebugLoc(), VT, Sh.getOperand(0), Y);
    return DAG.getNode(ISD::SHL, N-&gt;getDebugLoc(), VT,
    Mul, Sh.getOperand(1));
    }
  }
  if (N1C &amp;&amp; N0.getOpcode() == ISD::ADD &amp;&amp; N0.getNode()-&gt;hasOneUse() &amp;&amp;
      isa&lt;ConstantSDNode&gt;(N0.getOperand(1)))
    return DAG.getNode(ISD::ADD, N-&gt;getDebugLoc(), VT, DAG.getNode(ISD::MUL, N0.getDebugLoc(),
    VT, N0.getOperand(0), N1), DAG.getNode(ISD::MUL, N1.getDebugLoc(), VT, N0.getOperand(1), N1));

  SDValue RMUL = ReassociateOps(ISD::MUL, N-&gt;getDebugLoc(), N0, N1);

  if (RMUL.getNode() != 0) return RMUL;
  return SDValue();
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec206"/>How it works…</h2></div></div></div><p>As seen in the preceding <a id="id311" class="indexterm"/>code, some <code class="literal">DAGCombine</code> passes search for a pattern and then fold the patterns into a single DAG. This basically reduces the number of DAGs, while lowering DAGs. The result is an optimized <code class="literal">SelectionDAG</code> class.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec207"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">For a more detailed implementation of the optimized <code class="literal">SelectionDAG</code> class, see the <code class="literal">DAGCombiner.cpp</code> file located at <code class="literal">lib/CodeGen/SelectionDAG/</code></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec71"/>Selecting instruction from the DAG</h1></div></div></div><p>After legalization and DAG <a id="id312" class="indexterm"/>combination, the <code class="literal">SelectionDAG</code> representation is<a id="id313" class="indexterm"/> in the optimized phase. However, the instructions represented are still target-independent and need to be mapped on target-specific instructions. The instruction selection phase takes the target-independent DAG nodes as the input, matches patterns in them, and gives the output DAG nodes, which are target-specific.</p><p>The <code class="literal">TableGen</code> DAG instruction selector generator reads the instruction patterns from the <code class="literal">.td</code> file, and automatically builds parts of the pattern matching code.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec208"/>How to do it…</h2></div></div></div><p>
<code class="literal">SelectionDAGISel</code> is the common base class used for pattern-matching instruction selectors that are based on <code class="literal">SelectionDAG</code>. It inherits the <code class="literal">MachineFunctionPass</code> class. It has various functions used to determine the legality and profitability of operations such as folding. The basic skeleton of this class is as follows:</p><div><pre class="programlisting">class SelectionDAGISel : public MachineFunctionPass {
public:
const TargetMachine &amp;TM;
const TargetLowering &amp;TLI;
const TargetLibraryInfo *LibInfo;
FunctionLoweringInfo *FuncInfo;
MachineFunction *MF;
MachineRegisterInfo *RegInfo;
SelectionDAG *CurDAG;
SelectionDAGBuilder *SDB;
AliasAnalysis *AA;
GCFunctionInfo *GFI;
CodeGenOpt::Level OptLevel;
static char ID;

explicit SelectionDAGISel(const TargetMachine &amp;tm,
CodeGenOpt::Level OL = CodeGenOpt::Default);

virtual ~SelectionDAGISel();

const TargetLowering &amp;getTargetLowering() { return TLI; }

virtual void getAnalysisUsage(AnalysisUsage &amp;AU) const;

virtual bool runOnMachineFunction(MachineFunction &amp;MF);

virtual void EmitFunctionEntryCode() {}

virtual void PreprocessISelDAG() {}

virtual void PostprocessISelDAG() {}

virtual SDNode *Select(SDNode *N) = 0;

virtual bool SelectInlineAsmMemoryOperand(const SDValue &amp;Op,
char ConstraintCode,
std::vector&lt;SDValue&gt; &amp;OutOps) {
  return true;
}

virtual bool IsProfitableToFold(SDValue N, SDNode *U, SDNode *Root) const;

static bool IsLegalToFold(SDValue N, SDNode *U, SDNode *Root,
CodeGenOpt::Level OptLevel,
bool IgnoreChains = false);

enum BuiltinOpcodes {
OPC_Scope,
OPC_RecordNode,
OPC_CheckOpcode,
OPC_SwitchOpcode,
OPC_CheckFoldableChainNode,
OPC_EmitInteger,
OPC_EmitRegister,
OPC_EmitRegister2,
OPC_EmitConvertToTarget,
OPC_EmitMergeInputChains,
};

static inline int getNumFixedFromVariadicInfo(unsigned Flags) {
  return ((Flags&amp;OPFL_VariadicInfo) &gt;&gt; 4)-1;
}

protected:
// DAGSize - Size of DAG being instruction selected.
unsigned DAGSize;

void ReplaceUses(SDValue F, SDValue T) {
  CurDAG-&gt;ReplaceAllUsesOfValueWith(F, T);
}

void ReplaceUses(const SDValue *F, const SDValue *T, unsigned Num) {
  CurDAG-&gt;ReplaceAllUsesOfValuesWith(F, T, Num);
}

void ReplaceUses(SDNode *F, SDNode *T) {
  CurDAG-&gt;ReplaceAllUsesWith(F, T);
}

void SelectInlineAsmMemoryOperands(std::vector&lt;SDValue&gt; &amp;Ops);

public:
bool CheckAndMask(SDValue LHS, ConstantSDNode *RHS,
int64_t DesiredMaskS) const;

bool CheckOrMask(SDValue LHS, ConstantSDNode *RHS,
int64_t DesiredMaskS) const;

virtual bool CheckPatternPredicate(unsigned PredNo) const {
  llvm_unreachable("Tblgen should generate the implementation of this!");
}

virtual bool CheckNodePredicate(SDNode *N, unsigned PredNo) const {
  llvm_unreachable("Tblgen should generate the implementation of this!");
}

private:

SDNode *Select_INLINEASM(SDNode *N);

SDNode *Select_UNDEF(SDNode *N);

void CannotYetSelect(SDNode *N);

void DoInstructionSelection();

SDNode *MorphNode(SDNode *Node, unsigned TargetOpc, SDVTList VTs,
const SDValue *Ops, unsigned NumOps, unsigned EmitNodeInfo);

void PrepareEHLandingPad();

void SelectAllBasicBlocks(const Function &amp;Fn);

bool TryToFoldFastISelLoad(const LoadInst *LI, const Instruction *FoldInst, FastISel *FastIS);

void FinishBasicBlock();

void SelectBasicBlock(BasicBlock::const_iterator Begin,
BasicBlock::const_iterator End,
bool &amp;HadTailCall);

void CodeGenAndEmitDAG();

void LowerArguments(const BasicBlock *BB);

void ComputeLiveOutVRegInfo();
  ScheduleDAGSDNodes *CreateScheduler();
};</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec209"/>How it works…</h2></div></div></div><p>The instruction selection<a id="id314" class="indexterm"/> phase involves converting target-independent<a id="id315" class="indexterm"/> instructions to target-specific instructions. The <code class="literal">TableGen</code> class helps select target-specific instructions. This phase basically matches target-independent input nodes, which gives an output consisting of target-supported nodes.</p><p>The <code class="literal">CodeGenAndEmitDAG()</code> function calls the <code class="literal">DoInstructionSelection()</code> function, which visits each DAG node and calls the <code class="literal">Select()</code> function for each node, like this:</p><div><pre class="programlisting">SDNode *ResNode = Select(Node);</pre></div><p>The <code class="literal">Select()</code> function is an abstract method implemented by the targets. The x86 target implements it in the <code class="literal">X86DAGToDAGISel::Select()</code> function. The <code class="literal">X86DAGToDAGISel::Select()</code> function intercepts some nodes for manual matching, but delegates the bulk of the work to the <code class="literal">X86DAGToDAGISel::SelectCode()</code> function.</p><p>The <code class="literal">X86DAGToDAGISel::SelectCod</code>e function is autogenerated by <code class="literal">TableGen</code>. It contains the matcher table, followed<a id="id316" class="indexterm"/> by a<a id="id317" class="indexterm"/> call to the generic <code class="literal">SelectionDAGISel::SelectCodeCommon()</code> function, passing it the table.</p><p>For example:</p><div><pre class="programlisting">$ cat test.ll
define i32 @test(i32 %a, i32 %b, i32 %c) {
  %add = add nsw i32 %a, %b
  %div = sdiv i32 %add, %c
  ret i32 %div
}</pre></div><p>To see the DAG before instruction selection, enter the following command line:</p><div><pre class="programlisting">
<strong>$ llc –view-isel-dags test.ll</strong>
</pre></div><p>The following figure shows the DAG before the instruction selection:</p><div><img src="img/image00265.jpeg" alt="How it works…"/></div><p style="clear:both; height: 1em;"> </p><p>To see how DAG looks <a id="id318" class="indexterm"/>like after the instruction selection, enter the<a id="id319" class="indexterm"/> following command:</p><div><pre class="programlisting">
<strong>$ llc –view-sched-dags test.ll</strong>
</pre></div><p>The following figure shows the DAG after the instruction selection:</p><div><img src="img/image00266.jpeg" alt="How it works…"/></div><p style="clear:both; height: 1em;"> </p><p>As seen, the <code class="literal">Load</code> operation is <a id="id320" class="indexterm"/>converted into the <code class="literal">MOV32rm</code> machine code by the<a id="id321" class="indexterm"/> instruction selection phase.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec210"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">To see the detailed implementation of the instruction selection, take a look at the <code class="literal">SelectionDAGISel.cpp</code> file located at <code class="literal">lib/CodeGen/SelectionDAG/</code></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec72"/>Scheduling instructions in SelectionDAG</h1></div></div></div><p>So far, we have had <code class="literal">SelectionDAG</code> nodes <a id="id322" class="indexterm"/>consisting of target-supported <a id="id323" class="indexterm"/>instructions and operands. However, the code is still in DAG representation. The target architecture executes instructions in sequential form. So, the next logical step is to schedule the <code class="literal">SelectionDAG</code> nodes.</p><p>A scheduler assigns the order of execution of instructions from the DAG. In this process, it takes into account various heuristics, such as register pressure, to optimize the execution order of instructions and to minimize latencies in instruction execution. After assigning the order of execution to the DAG nodes, the nodes are converted into a list of <code class="literal">MachineInstrs</code> and the <code class="literal">SelectionDAG</code> nodes are destroyed.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec211"/>How to do it…</h2></div></div></div><p>There are several basic structures that are defined in the <code class="literal">ScheduleDAG.h</code> file and implemented in the <code class="literal">ScheduleDAG.cpp</code> file. The <code class="literal">ScheduleDAG</code> class is a base class for other schedulers to inherit, and it provides only graph-related manipulation operations such as an iterator, DFS, topological sorting, functions for moving nodes around, and so on:</p><div><pre class="programlisting">class ScheduleDAG {
public:
  const TargetMachine &amp;TM;              // Target processor
  const TargetInstrInfo *TII;           // Target instruction
  const TargetRegisterInfo *TRI;        // Target processor register info
  MachineFunction &amp;MF;                  // Machine function
  MachineRegisterInfo &amp;MRI;             // Virtual/real register map
  std::vector&lt;SUnit&gt; SUnits;            // The scheduling units.
  SUnit EntrySU;                        // Special node for the region entry.
  SUnit ExitSU;                         // Special node for the region exit.

  explicit ScheduleDAG(MachineFunction &amp;mf);

  virtual ~ScheduleDAG();

  void clearDAG();

const MCInstrDesc *getInstrDesc(const SUnit *SU) const {
  if (SU-&gt;isInstr()) return &amp;SU-&gt;getInstr()-&gt;getDesc();
    return getNodeDesc(SU-&gt;getNode());
}

virtual void dumpNode(const SUnit *SU) const = 0;

private:

const MCInstrDesc *getNodeDesc(const SDNode *Node) const;
};

class SUnitIterator : public std::iterator&lt;std::forward_iterator_tag,
SUnit, ptrdiff_t&gt; {
};

template &lt;&gt; struct GraphTraits&lt;SUnit*&gt; {
  typedef SUnit NodeType;
  typedef SUnitIterator ChildIteratorType;
  static inline NodeType *getEntryNode(SUnit *N) {
    return N;
  }
  static inline ChildIteratorType child_begin(NodeType *N) {
  return SUnitIterator::begin(N);
  }

static inline ChildIteratorType child_end(NodeType *N) {
  return SUnitIterator::end(N);
  }
};

template &lt;&gt; struct GraphTraits&lt;ScheduleDAG*&gt; : public GraphTraits&lt;SUnit*&gt; {
…};

// Topological sorting of DAG to linear set of instructions
class ScheduleDAGTopologicalSort {
  std::vector&lt;SUnit&gt; &amp;SUnits;
  SUnit *ExitSU;
  std::vector&lt;int&gt; Index2Node;
  std::vector&lt;int&gt; Node2Index;
  BitVector Visited;
// DFS to be run on DAG to sort topologically
  void DFS(const SUnit *SU, int UpperBound, bool&amp; HasLoop);

  void Shift(BitVector&amp; Visited, int LowerBound, int UpperBound);

  void Allocate(int n, int index);

public:

  ScheduleDAGTopologicalSort(std::vector&lt;SUnit&gt; &amp;SUnits, SUnit *ExitSU);

  void InitDAGTopologicalSorting();

  bool IsReachable(const SUnit *SU, const SUnit *TargetSU);

  bool WillCreateCycle(SUnit *SU, SUnit *TargetSU);

  void AddPred(SUnit *Y, SUnit *X);

  void RemovePred(SUnit *M, SUnit *N);

  typedef std::vector&lt;int&gt;::iterator iterator;

  typedef std::vector&lt;int&gt;::const_iterator const_iterator;

  iterator begin() { return Index2Node.begin(); }

  const_iterator begin() const { return Index2Node.begin(); }

  iterator end() { return Index2Node.end();}}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec212"/>How it works…</h2></div></div></div><p>The scheduling algorithm<a id="id324" class="indexterm"/> implements the scheduling of instructions<a id="id325" class="indexterm"/> in the <code class="literal">SelectionDAG</code> class, which involves a variety of algorithms such as topological sorting, depth-first searching, manipulating functions, moving nodes, and iterating over a list of instructions. It takes into account various heuristics, such as register pressure, spilling cost, live interval analysis, and so on to determine the best possible scheduling of instructions.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec213"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">For a detailed implementation of scheduling instructions, see the <code class="literal">ScheduleDAGSDNodes.cpp</code>, <code class="literal">ScheduleDAGSDNodes.h</code>, <code class="literal">ScheduleDAGRRList.cpp</code>, <code class="literal">ScheduleDAGFast.cpp</code>, and <code class="literal">ScheduleDAGVLIW.cpp</code> files located in the <code class="literal">lib/CodeGen/SelectionDAG</code> folder</li></ul></div></div></div></body></html>