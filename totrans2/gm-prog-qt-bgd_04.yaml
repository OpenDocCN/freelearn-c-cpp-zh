- en: Chapter 4. Qt Core Essentials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。Qt核心基础
- en: '*This chapter will help you master Qt ways of basic data processing and storage.
    First of all, you will learn how to handle textual data and how to match text
    against regular expressions. Then, you will see how to store and fetch data from
    files and how to use different storage formats for text and binary data. By the
    end of this chapter, you will be able to implement non-trivial logic and data
    processing in your games efficiently. You will also know how to load external
    data in your games and how to save your own data in permanent storage for future
    use.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*本章将帮助你掌握Qt的基本数据处理和存储方式。首先，你将学习如何处理文本数据以及如何将文本与正则表达式匹配。然后，你将了解如何从文件中存储和检索数据，以及如何使用不同的存储格式来存储文本和二进制数据。到本章结束时，你将能够高效地在你的游戏中实现非平凡逻辑和数据处理。你还将了解如何在游戏中加载外部数据，以及如何将你的数据保存到永久存储中以便将来使用。*'
- en: Text handling
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本处理
- en: Applications with a graphical user interface (and games surely fall into this
    category) are able to interact with users by displaying text and by expecting
    textual input from the user. We have already scratched the surface of this topic
    in the previous chapter by using the `QString` class. Now, we will go into more
    details.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 带有图形用户界面（游戏当然属于这一类）的应用程序能够通过显示文本并期望用户输入文本与用户交互。我们已经在上一章通过使用`QString`类来触及了这个话题的表面。现在，我们将深入探讨。
- en: Manipulating strings
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串操作
- en: 'Text in Qt is internally encoded using Unicode, which allows to represent characters
    in almost all languages spoken in the world and is de facto standard for native
    encoding of text in most modern operating systems. You have to be aware though
    that contrary to the `QString` class, the C++ language does not use Unicode by
    default. Thus, each string literal (that is, each bare text you wrap in quotation
    marks) that you enter in your code needs to be converted to Unicode first before
    it can be stored in any of Qt''s string handling classes. By default, this is
    done implicitly assuming that the string literal is UTF-8 encoded, but `QString`
    provides a number of static methods to convert from other encodings such as `QString::fromLatin1()`
    or `QString::fromUtf16()`. This conversion is done at runtime, which adds an overhead
    to the program execution time, especially if you tend to do a lot of such conversions
    in your programs. Luckily, there is a solution for this:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Qt内部使用Unicode对文本进行编码，这允许表示世界上几乎所有的语言字符，并且是大多数现代操作系统中文本本地编码的事实标准。然而，你必须意识到，与`QString`类不同，C++语言默认不使用Unicode。因此，你输入代码中的每个字符串字面量（即你用引号包裹的每个裸文本）在可以存储在Qt的任何字符串处理类之前，都需要先转换为Unicode。默认情况下，这会隐式地假设字符串字面量是UTF-8编码的，但`QString`提供了一系列静态方法来从其他编码（如`QString::fromLatin1()`或`QString::fromUtf16()`）转换。这种转换是在运行时完成的，这会增加程序执行时间，特别是如果你在程序中倾向于进行大量的此类转换。幸运的是，有一个解决方案：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can wrap your string literal in a call to `QStringLiteral`, as shown in
    the preceding code, which if your compiler supports, will perform the conversion
    at compile time. It's a good habit to wrap all your string literals into `QStringLiteral`
    but it is not required, so don't worry if you forget to do that.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将你的字符串字面量包裹在`QStringLiteral`的调用中，就像前面代码所示，如果你的编译器支持，它将在编译时执行转换。将所有字符串字面量包裹成`QStringLiteral`是一个好习惯，但这不是必需的，所以如果你忘记这样做，请不要担心。
- en: We will not go into great detail here when describing the `QString` class, as
    in many aspects it is similar to `std::string`, which is part of the standard
    C++. Instead, we will focus on the differences between the two classes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述`QString`类时，我们不会深入细节，因为它在许多方面与C++标准库中的`std::string`相似。相反，我们将关注这两个类之间的差异。
- en: Encoding and decoding text
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本编码和解码
- en: The first difference has already been mentioned—`QString` keeps the data encoded
    as Unicode. This has the advantage of being able to express text in virtually
    any language at the cost of having to convert from other encodings. Most popular
    encodings—UTF-8, UTF-16, and Latin1—have convenience methods in `QString` for
    converting from and to the internal representation. But, Qt knows how to handle
    many other encodings as well. This is done using the `QTextCodec` class.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个差异已经提到——`QString`将数据编码为Unicode。这有一个优点，即能够用几乎任何语言表达文本，但代价是需要从其他编码转换。大多数流行的编码——UTF-8、UTF-16和Latin1——在`QString`中都有方便的方法来转换到和从内部表示。但是，Qt也知道如何处理许多其他编码。这是通过使用`QTextCodec`类来完成的。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can list the codecs supported on your installation by using the `QTextCodec::availableCodecs()`static
    method. In most installations, Qt can handle almost 1,000 different text codecs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `QTextCodec::availableCodecs()` 静态方法列出你的安装上支持的 codec。在大多数安装中，Qt 可以处理近
    1,000 种不同的文本 codec。
- en: 'Most Qt entities that handle text can access instances of this class to transparently
    perform the conversion. If you want to perform such conversion manually, you can
    ask Qt for an instance of a codec by its name and make use of the `fromUnicode()`
    and `toUnicode()` methods:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数处理文本的 Qt 实体都可以访问此类实例以透明地执行转换。如果你想手动执行此类转换，你可以通过名称请求 Qt 的 codec 实例并使用 `fromUnicode()`
    和 `toUnicode()` 方法：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Basic string operations
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本字符串操作
- en: The most basic tasks that involve text strings are those where you add or remove
    characters from the string, concatenate strings, and access the string's content.
    In this regard, `QString` offers an interface that is compatible with `std::string`,
    but it also goes beyond that, exposing many more useful methods.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及文本字符串的最基本任务包括添加或删除字符串中的字符、连接字符串以及访问字符串内容。在这方面，`QString` 提供了一个与 `std::string`
    兼容的接口，但它还超越了这一点，暴露了许多更多有用的方法。
- en: 'Adding data at the beginning or at the end of the string can be done using
    the `prepend()` and `append()` methods, which have a couple of overloads that
    accept different objects that can hold textual data, including the classic `const
    char*` array. Inserting data in the middle of a string can be done with the `insert()`
    method that takes the position of the character where we need to start inserting
    as its first argument and the actual text as its second argument. The `insert`
    method has exactly the same overloads as `prepend` and `append`, excluding `const
    char*`. Removing characters from a string is similar. The basic way to do this
    is to use the `remove()` method that accepts the position at which we need to
    delete characters and the number of characters to delete is as shown:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `prepend()` 和 `append()` 方法可以在字符串的开始或末尾添加数据，这些方法有几个重载，可以接受不同可以包含文本数据的对象，包括经典的
    `const char*` 数组。使用 `insert()` 方法可以在字符串的中间插入数据，该方法将需要开始插入的字符位置作为其第一个参数，实际文本作为其第二个参数。`insert`
    方法具有与 `prepend` 和 `append` 相同的重载，但不包括 `const char*`。从字符串中删除字符的方式类似。基本方法是使用 `remove()`
    方法，该方法接受需要删除字符的位置和要删除的字符数，如下所示：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is also a remove overload that accepts another string. When called, all
    its occurrences are removed from the original string. This overload has an optional
    argument that states whether comparison should be done in the default case-sensitive
    (`Qt::CaseSensitive`) or case-insensitive (`Qt::CaseInsensitive`) way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个接受另一个字符串的重载。当调用时，它会从原始字符串中删除所有其出现。此重载有一个可选参数，指定比较是否应该以默认的大小写敏感（`Qt::CaseSensitive`）或大小写不敏感（`Qt::CaseInsensitive`）的方式进行：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To concatenate strings, you can either simply add two strings together or you
    can append one string to the other:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接字符串，你可以简单地将两个字符串相加，或者将一个字符串追加到另一个字符串上：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Accessing strings can be divided into two use cases. The first is when you
    wish to extract a part of the string. For this, you can use one of these three
    methods: `left()`, `right()`, and `mid()` that return the given number of characters
    from the beginning or end of the string or extract a substring of a specified
    length, starting from a given position in the string:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 访问字符串可以分为两种用例。第一种是你希望提取字符串的一部分。为此，你可以使用以下三种方法之一：`left()`、`right()` 和 `mid()`，它们从字符串的开始或末尾返回指定数量的字符，或者从字符串中指定位置开始提取指定长度的子字符串：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The second use case is when you wish to access a single character of the string.
    The use of the index operator works with `QString` in a similar fashion as with
    `std::string`, returning a copy or non-const reference to a given character that
    is represented by the `QChar` class, as shown in the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种用例是你希望访问字符串的单个字符。索引操作符在 `QString` 中的使用方式与 `std::string` 类似，返回一个副本或非 const
    引用到由 `QChar` 类表示的给定字符，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In addition to this, Qt offers a dedicated method—`at()`—that returns a copy
    of the character:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Qt 还提供了一个专门的方法——`at()`，它返回字符的副本：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You should prefer to use `at()` instead of the index operator for operations
    that do not modify the character, as this explicitly sets the operation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该优先使用 `at()` 而不是索引操作符来执行不修改字符的操作，因为这明确设置了操作。
- en: The string search and lookup
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串搜索和查找
- en: The second group of functionality is related to searching for the string. You
    can use methods such as `startsWith()`, `endsWith()`, and `contains()` to search
    for substrings in the beginning or end or in an arbitrary place in the string.
    The number of occurrences of a substring in the string can be retrieved by using
    the `count()` method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 功能的第二组与字符串搜索相关。你可以使用 `startsWith()`、`endsWith()` 和 `contains()` 等方法在字符串的开始、结束或任意位置搜索子字符串。可以通过使用
    `count()` 方法检索字符串中子字符串的出现次数。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be careful, there is also a `count()` method that doesn't take any parameters
    and returns the number of characters in the string.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有一个不带参数的 `count()` 方法，它返回字符串中的字符数。
- en: 'If you need to know the exact position of the match, you can use `indexOf()`
    or `lastIndexOf()` to receive the position in the string where the match occurs.
    The first call works by searching forward and the other one searches backwards.
    Each of these calls takes two optional parameters—the second one determines whether
    the search is case-sensitive (similar to how `remove` works). The first one is
    the position in the string where the search begins. It lets you find all the occurrences
    of a given substring:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要知道匹配的确切位置，可以使用 `indexOf()` 或 `lastIndexOf()` 来接收字符串中匹配发生的位置。第一个调用通过向前搜索工作，而另一个调用通过向后搜索。这些调用都接受两个可选参数——第二个参数确定搜索是否区分大小写（类似于
    `remove` 的工作方式）。第一个参数是字符串中搜索开始的位臵。它让你能够找到给定子字符串的所有出现：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Dissecting strings
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串分解
- en: There is one more group of useful string functionalities that makes `QString`
    different from `std::string`. That is, cutting strings into smaller parts and
    building larger strings from smaller pieces.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一组有用的字符串功能，这使得 `QString` 与 `std::string` 不同。那就是，将字符串切割成更小的部分，并从更小的片段构建更大的字符串。
- en: 'Very often, a string contains substrings that are glued together by a repeating
    separator. A common case is the **Comma-separated Values** (**CSV**) format where
    a data record is encoded in a single string where fields in the record are separated
    by commas. While you could extract each field from the record using functions
    that you already know (for example, `indexOf`), an easier way exists. `QString`
    contains a `split()` method that takes the separator string as its parameter and
    returns a list of strings that are represented in Qt by the `QStringList` class.
    Then, dissecting the record into separate fields is as easy as calling the following
    code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，一个字符串包含通过重复分隔符粘合在一起的子字符串。一个常见的情况是 **逗号分隔值**（**CSV**）格式，其中数据记录被编码在一个单独的字符串中，记录中的字段通过逗号分隔。虽然你可以使用你已知的函数（例如，`indexOf`）从记录中提取每个字段，但存在一种更简单的方法。`QString`
    包含一个 `split()` 方法，它接受分隔符字符串作为参数，并返回一个由 Qt 中的 `QStringList` 类表示的字符串列表。然后，将记录分解成单独的字段就像调用以下代码一样简单：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The inverse of this method is the `join()` method present in the `QStringList`
    class, which returns all the items in the list as a single string merged together
    with a given separator:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的逆操作是 `QStringList` 类中存在的 `join()` 方法，它将列表中的所有项合并成一个字符串，并用给定的分隔符连接起来：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Converting between numbers and strings
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字与字符串之间的转换
- en: '`QString` also provides some methods for convenient conversion between textual
    and numerical values. Methods such as `toInt()`, `toDouble()`, or `toLongLong()`
    make it easy to extract numerical values from strings. Apart from `toDouble()`,
    they all take two optional parameters—the first one is a pointer to a `bool` variable
    that is set to `true` or `false` depending on whether the conversion was successful
    or not. The second parameter specifies the numerical base (for example, binary,
    octal, decimal, or hexadecimal) of the value. The `toDouble()` method only takes
    a `bool` pointer to mark the success or failure as shown in the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`QString` 还提供了一些方便在文本和数值之间进行转换的方法。例如 `toInt()`、`toDouble()` 或 `toLongLong()`
    可以轻松地从字符串中提取数值。除了 `toDouble()` 之外，它们都接受两个可选参数——第一个是一个指向 `bool` 变量的指针，根据转换是否成功将其设置为
    `true` 或 `false`。第二个参数指定值的数值基数（例如，二进制、八进制、十进制或十六进制）。`toDouble()` 方法只接受一个 `bool`
    指针来标记成功或失败，如下面的代码所示：'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A static method called `number()` performs the conversion in the other direction—it
    takes a numerical value and number base and returns the textual representation
    of the value:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `number()` 的静态方法执行相反方向的转换——它接受一个数值和数值基数，并返回值的文本表示：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you have to combine both `QString` and `std::string` in one program, `QString`
    offers you the `toStdString()` and `fromStdString()` methods to perform an adequate
    conversion.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须在一个程序中同时使用 `QString` 和 `std::string`，`QString` 提供了 `toStdString()` 和 `fromStdString()`
    方法来执行适当的转换。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some of the other classes that represent values also provide conversions to
    and from `QString`. An example of such a class is `QDate`, which represents a
    date and provides the `fromString()` and `toString()` methods.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表示值的其他类也提供了到和从 `QString` 的转换。这样的一个类是 `QDate`，它表示一个日期并提供 `fromString()` 和 `toString()`
    方法。
- en: Using arguments in strings
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在字符串中使用参数
- en: 'A common task is to have a string that needs to be dynamic in such a way that
    its content depends on the value of some external variable—for instance, you would
    like to inform the user about the number of files being copied, showing "copying
    file 1 of 2" or "copying file 2 of 5" depending on the value of counters that
    denote the current file and total number of files. It might be tempting to do
    this by assembling all the pieces together using one of the available approaches:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的任务是需要一个字符串，其内容需要是动态的，这样它的内容就依赖于某些外部变量的值——例如，你可能想通知用户正在复制的文件数量，显示“正在复制文件
    1/2”或“正在复制文件 2/5”，这取决于表示当前文件和文件总数的计数器的值。可能会诱使你通过使用可用的方法之一将所有片段组装在一起来完成这项任务：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are a number of drawbacks to such an approach; the biggest of them is
    the problem of translating the string into other languages (this will be discussed
    later in this chapter) where in different languages their grammar might require
    the two arguments to be positioned differently than in English.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个缺点；其中最大的问题是将字符串翻译成其他语言的问题（这个问题将在本章后面讨论），在这些语言中，它们的语法可能要求这两个参数的位置与英语不同。
- en: 'Instead, Qt allows us to specify positional parameters in strings and then
    replace them with real values. Positions in the string are marked with the `%`
    sign (for example, `%1`, `%2`, and so on) and they are replaced by making a call
    to `arg()` and passing it the value that is used to replace the next lowest marker
    in the string. Our file copy message construction code then becomes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Qt 允许我们在字符串中指定位置参数，然后使用实值替换它们。字符串中的位置用 `%` 符号标记（例如，`%1`、`%2` 等），并通过调用 `arg()`
    并传递用于替换字符串中下一个最低标记的值来替换它们。然后我们的文件复制消息构建代码变为：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `arg` method can accept single characters, strings, integers, and real numbers
    and its syntax is similar to that of `QString::number()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`arg` 方法可以接受单个字符、字符串、整数和实数，其语法与 `QString::number()` 类似。'
- en: Regular expressions
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Let's briefly talk about **regular expressions**—usually shortened as **regex**
    or **regexp**. You will need these regular expressions whenever you have to check
    whether a string or parts of it matches a given pattern or when you want to find
    specific parts inside the text and possibly want to extract them. Both the validity
    check and the finding/extraction are based on the so-called pattern of the regular
    expression, which describes the format a string must have to be valid, to be found,
    or to be extracted. Since this book is focused on Qt, there is unfortunately no
    time to cover regular expressions in depth. This is not a huge problem, however,
    since you can find plenty of good websites that provide introductions to regular
    expressions on the Internet. A short introduction can be found in Qt's documentation
    of `QRegExp` as well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地谈谈**正则表达式**——通常简称为**regex**或**regexp**。当你需要检查一个字符串或其部分是否与给定的模式匹配，或者当你想要在文本中找到特定的部分并可能提取它们时，你需要这些正则表达式。验证和查找/提取都是基于所谓的正则表达式模式，它描述了字符串必须具有的格式才能有效、可找到或可提取。由于这本书专注于
    Qt，很遗憾没有时间深入探讨正则表达式。然而，这不是一个大问题，因为你可以在网上找到许多提供正则表达式介绍的优质网站。Qt 的 `QRegExp` 文档中也可以找到简短的介绍。
- en: Even though there are many flavors of the regular expression's syntax, the one
    that Perl uses has become the *de facto* standard. According to `QRegularExpression`,
    Qt offers Perl-compatible regular expressions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管正则表达式的语法有很多种，但 Perl 使用的语法已经成为事实上的标准。根据 `QRegularExpression`，Qt 提供了与 Perl 兼容的正则表达式。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`QRegularExpression` was first introduced with Qt 5\. In the previous versions,
    you''ll find the older `QRegExp` class. Since `QRegularExpression` is closer to
    the Perl standard and since its execution speed is much faster compared to `QRegExp`,
    we advise you to use `QRegularExpression` whenever possible. Nevertheless, you
    can read the `QRegExp` documentation about the general introduction of regular
    expressions.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`QRegularExpression` 首次在 Qt 5 中引入。在之前的版本中，你会找到较老的 `QRegExp` 类。由于 `QRegularExpression`
    更接近 Perl 标准，并且其执行速度比 `QRegExp` 快得多，我们建议尽可能使用 `QRegularExpression`。尽管如此，你仍然可以阅读有关正则表达式一般介绍的
    `QRegExp` 文档。'
- en: Time for action – a simple quiz game
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候进行一个简单的问答游戏了
- en: 'To introduce you to the main usage of `QRegularExpression`, let''s imagine
    this game: a photo, showing an object, is shown to multiple players and each of
    them has to estimate the object''s weight. The player whose estimate is closest
    to the actual weight wins. The estimates will be submitted via `QLineEdit`. Since
    you can write anything in a line edit, we have to make sure that the content is
    valid.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解 `QRegularExpression` 的主要用法，让我们想象这个游戏：展示一个物体的照片给多个玩家看，每个玩家都必须估计物体的重量。估计值最接近实际重量的玩家获胜。估计将通过
    `QLineEdit` 提交。由于你可以在行编辑中写任何东西，我们必须确保内容是有效的。
- en: 'So what does valid mean? In this example, we define that a value between 1
    g and 999 kg is valid. Knowing this specification, we can construct a regular
    expression that will verify the format. The first part of the text is a number,
    which can be between 1 and 999\. Thus, the corresponding pattern looks like `[1-9][0-9]{0,2}`,
    where `[1-9]` allows—and demands—exactly one digit, except zero, which is optionally
    followed by up to two digits including zero. This is expressed through `[0-9]{0,2}`.
    The last part of the input is the weight''s unit. With a pattern such as `(mg|g|kg)`,
    we allow the weight to be input in **milligrams** (**mg**), **grams** (**g**),
    or **kilograms** (**kg**). With `[ ]?`, we finally allow an optional space between
    the number and unit. Combined together, the pattern and construction of the related
    `QRegularExpression` object looks like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那么“有效”是什么意思呢？在这个例子中，我们定义一个介于 1 克和 999 公斤之间的值是有效的。了解这个规范后，我们可以构建一个正则表达式来验证格式。文本的第一部分是一个数字，可以是
    1 到 999 之间的任何数字。因此，相应的模式看起来像 `[1-9][0-9]{0,2}`，其中 `[1-9]` 允许并且要求恰好一个数字，除了零，零可以可选地后面跟最多两个数字，包括零。这通过
    `[0-9]{0,2}` 来表达。输入的最后部分是重量的单位。使用如 `(mg|g|kg)` 这样的模式，我们允许重量以 **毫克**（**mg**）、**克**（**g**）或
    **公斤**（**kg**）输入。通过 `[ ]?`，我们最终允许数字和单位之间有一个可选的空格。结合模式和相关 `QRegularExpression`
    对象的构建，看起来是这样的：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*What just happened?*'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'In the first line, we constructed the aforementioned `QRegularExpression` object
    while passing the regular expression''s pattern as a parameter to the constructor.
    We also could have called `setPattern()` to set the pattern:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们构建了上述 `QRegularExpression` 对象，同时将正则表达式的模式作为参数传递给构造函数。我们也可以调用 `setPattern()`
    来设置模式：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Both the approaches are equivalent. If you have a closer look at the unit,
    you can see that right now, the unit is only allowed to be entered in lowercase.
    We want, however, to also allow it to be in uppercase or mixed case. To achieve
    this, we can of course write `(mg|mG|Mg|MG|g|G|kg|kG|Kg|KG)`. Not only is this
    a hell of a work when you have more units, this is also very error-prone, and
    so we opt for a cleaner and more readable solution. On the second line of the
    initial code example, you see the answer: a pattern option. We used `setPatternOptions()`
    to set the `QRegularExpression::CaseInsensitiveOption` option, which does not
    respect the case of the characters used. Of course, there are a few more options
    that you can read about in Qt''s documentation on `QRegularExpression::PatternOption`.
    Instead of calling `setPatternOptions()`, we could have also passed the option
    as a second parameter to the constructor of `QRegularExpression`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都是等效的。如果你仔细看看单位，你会看到现在单位只能以小写形式输入。然而，我们希望它也可以是大写或混合大小写。为了实现这一点，我们当然可以写
    `(mg|mG|Mg|MG|g|G|kg|kG|Kg|KG)`。当你有更多单位时，这确实是一项艰巨的工作，而且很容易出错，所以我们选择了更干净、更易读的解决方案。在初始代码示例的第二行，你看到了答案：一个模式选项。我们使用了
    `setPatternOptions()` 来设置 `QRegularExpression::CaseInsensitiveOption` 选项，该选项不尊重字符的大小写。当然，你还可以在
    Qt 的 `QRegularExpression::PatternOption` 文档中了解一些更多选项。我们也可以将选项作为 `QRegularExpression`
    构造函数的第二个参数传递，而不是调用 `setPatternOptions()`：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s see how to use this expression to verify the validity of a string.
    For the sake of simplicity and better illustration, we simply declared a string
    called `input`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用这个表达式来验证字符串的有效性。为了简单起见和更好的说明，我们简单地声明了一个名为 `input` 的字符串：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All we have to do is call `match()`, passing the string we would like to check
    against it. In return, we get an object of the `QRegularExpressionMatch` type
    that contains all the information that is further needed—and not only to check
    the validity. With `QRegularExpressionMatch::hasMatch()`, we then can determine
    whether the input matches our criteria, as it returns `true` if the pattern could
    be found. Otherwise, of course, `false` is returned.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是调用 `match()`，传递我们想要检查的字符串。作为回报，我们得到一个 `QRegularExpressionMatch` 类型的对象，它包含所有进一步需要的信息——而不仅仅是检查有效性。然后，我们可以通过
    `QRegularExpressionMatch::hasMatch()` 确定输入是否匹配我们的标准，因为它在找到模式时返回 `true`。当然，如果没有找到模式，则返回
    `false`。
- en: 'Attentive readers surely will have noticed that our pattern is not quite finished.
    The `hasMatch()` method would also return `true` if we matched it against "foo
    142g bar". So, we have to define that the pattern is checked from the beginning
    to the end of the matched string. This is done by the `\A` and `\z` anchors. The
    former marks the start of a string and the latter the end of a string. Don''t
    forget to escape the slashes when you use such anchors. The correct pattern would
    then look as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细的读者肯定已经注意到我们的模式还没有完全完成。`hasMatch()` 方法也会在将模式与 "foo 142g bar" 进行匹配时返回 `true`。因此，我们必须定义模式是从匹配字符串的开始到结束进行检查的。这是通过
    `\A` 和 `\z` 锚点来完成的。前者标记字符串的开始，后者标记字符串的结束。在使用这样的锚点时，不要忘记转义斜杠。正确的模式如下所示：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Extracting information out of a string
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从字符串中提取信息
- en: After we have checked that the sent guess is well formed, we have to extract
    the actual weight from the string. In order to be able to easily compare the different
    guesses, we further need to transform all values to a common reference unit. In
    this case, it should be a milligram, the lowest unit. So, let's see what `QRegularExpressionMatch`
    can offer us for this task.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查发送的猜测是否良好形成之后，我们必须从字符串中提取实际的重量。为了能够轻松比较不同的猜测，我们还需要将所有值转换为共同的参考单位。在这种情况下，应该是毫克，这是最低的单位。那么，让我们看看
    `QRegularExpressionMatch` 可以为我们提供什么来完成任务。
- en: 'With `capturedTexts()`, we get a string list of the pattern''s captured groups.
    In our example, this list would contain "23kg" and "kg". The first element is
    always the string that was fully matched by the pattern followed by all the sub
    strings captured by the used brackets. Since we are missing the actual number,
    we have to alter the pattern''s beginning to `([1-9][0-9]{0,2})`. Now, the list''s
    second element is the number and the third element is the unit. Thus, we can write
    the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `capturedTexts()`，我们得到一个包含模式捕获组的字符串列表。在我们的例子中，这个列表将包含 "23kg" 和 "kg"。列表的第一个元素总是被模式完全匹配的字符串，然后是所有由使用的括号捕获的子字符串。由于我们缺少实际的数字，我们必须将模式的开始更改为
    `([1-9][0-9]{0,2})`。现在，列表的第二个元素是数字，第三个元素是单位。因此，我们可以写出以下内容：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the function's first two lines, we set up the pattern and its option. Then,
    we match it against the passed argument. If `QRegularExpressionMatch::hasMatch()`
    returns `true`, the input is valid and we extract the number and unit. Instead
    of fetching the entire list of captured text with `capturedTexts()`, we query
    specific elements directly by calling `QRegularExpressionMatch::captured()`. The
    passed integer argument signifies the element's position inside the list. So,
    calling `captured(1)` returns the matched digits as a `QString`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的前两行中，我们设置了模式和它的选项。然后，我们将它与传递的参数进行匹配。如果 `QRegularExpressionMatch::hasMatch()`
    返回 `true`，则输入有效，我们提取数字和单位。我们不是通过调用 `capturedTexts()` 获取捕获文本的整个列表，而是通过调用 `QRegularExpressionMatch::captured()`
    直接查询特定元素。传递的整数参数表示列表中元素的位位置。因此，调用 `captured(1)` 返回匹配的数字作为一个 `QString`。
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`QRegularExpressionMatch::captured()` also takes `QString` as the argument''s
    type. This is useful if you have used named groups inside the pattern, for example,
    if you have written `(?<number>[1-9][0-9]{0,2})`, then you can get the digits
    by calling `match.captured("number")`. Named groups pay off if you have long patterns
    or when there is a high probability that further brackets will be added in future.
    Be aware that adding a group at a later time will shift the indices of all the
    following groups by `1` and you will have to adjust your code!'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`QRegularExpressionMatch::captured()` 也接受 `QString` 作为参数类型。如果你在模式中使用了命名组，这会很有用，例如，如果你写的是
    `(?<number>[1-9][0-9]{0,2})`，那么你可以通过调用 `match.captured("number")` 来获取数字。如果模式很长或者未来有很高的概率会添加更多的括号，命名组会很有用。请注意，稍后添加一个组将会将所有后续组的索引移动
    `1` 位，你将不得不调整你的代码！'
- en: To be able to calculate using the extracted number, we need to convert `QString`
    into an integer. This is done by calling `QString::toInt()`. The result of this
    conversion is then stored in the `weight` variable. Next, we fetch the unit and
    transform it to lowercase characters on-the-fly. This way, we can, for example,
    easily determine whether the user's guess is expressed in grams by checking the
    unit against the lowercase "g". We do not need to take care of the capital "G"
    or the variants "KG", "Kg", and the unusual "kG" for kilogram.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用提取出的数字进行计算，我们需要将 `QString` 转换为整数。这是通过调用 `QString::toInt()` 来完成的。转换的结果随后存储在
    `weight` 变量中。接下来，我们获取单位并将其转换为小写字母。这样，例如，我们可以轻松地确定用户的猜测是否以克为单位，只需将单位与小写 "g" 进行比较。我们不需要关心大写
    "G" 或 "KG"、"Kg" 和不寻常的 "kG"（千克）。
- en: To get the standardized weight in milligrams, we multiply `weight` by 1,000
    or 1,000,000, depending on whether this was expressed in g or kg. Lastly, we return
    this standardized weight. If the string wasn't well formed, we return `-1` to
    indicate that the given guess was invalid. It is then the caller's duty to determinate
    which player's guess was the best.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到标准化的重量（毫克），我们需要将 `weight` 乘以 1,000 或 1,000,000，具体取决于这是否以 g 或 kg 表示。最后，我们返回这个标准化的重量。如果字符串格式不正确，我们返回
    `-1` 来指示给定的猜测无效。然后调用者负责确定哪个玩家的猜测是最好的。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pay attention to whether your chosen integer type can handle the weight's value.
    For our example, 100,000,000 is the biggest possible value that can be held by
    a signed integer on a 32-bit system. If you are not sure whether your code will
    be compiled on a 32-bit system, use `qint32`, which is guaranteed to be a 32-bit
    integer on every system that Qt supports, allowing decimal notations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你选择的整数类型是否可以处理重量的值。在我们的例子中，对于 32 位系统，1,000,000,000 是可以由有符号整数持有的最大可能值。如果你不确定你的代码是否会在
    32 位系统上编译，使用 `qint32`，它在 Qt 支持的每个系统上都是保证为 32 位整数的，允许十进制表示法。
- en: As an exercise, try to extend the example by allowing decimal numbers so that
    23.5g is a valid guess. To achieve this, you have to alter the pattern in order
    to enter decimal numbers and you also have to deal with `double` instead of `int`
    for the standardized weight.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试扩展示例，允许小数数字，例如 23.5g 是一个有效的猜测。为了实现这一点，你必须修改模式以输入小数数字，并且你还必须处理 `double`
    而不是 `int` 作为标准化的重量。
- en: Finding all pattern occurrences
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找所有模式出现
- en: 'Lastly, let''s have a final look at how to find, for example, all numbers inside
    a string, even those leading with zeros:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何找到字符串中的所有数字，即使是那些以零开头的数字：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `input` QString instance contains an exemplary text in which we would like
    to find all numbers. The "foo" as well as "1a" variables should not be found by
    the pattern since these are not valid numbers. Therefore, we set up the pattern
    defining that we require at least one digit, `[0-9]+`, and that this digit—or
    these digits—should be wrapped by word boundaries, `\b`. Note that you have to
    escape the slash. With this pattern, we initiate the `QRegularExpression` object
    and call `globalMatch()` on it. Inside the passed argument, the pattern will be
    searched. This time, we do not get `QRegularExpressionMatch` back but, instead,
    an iterator of the `QRegularExpressionMatchIterator` type. Since `QRegularExpressionMatchIterator`
    behaves like a Java iterator, with `hasNext()`, we check whether there is a further
    match and if so we bring up the next match by calling `next()`. The type of the
    returned match is then `QRegularExpressionMatch`, which you already know.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`input` QString 实例包含一个示例文本，我们希望在其中找到所有数字。由于“foo”以及“1a”不是有效的数字，因此不应通过该模式找到这些变量。因此，我们设置了定义我们至少需要一个数字
    `[0-9]+`，并且这个数字——或者这些数字——应该被单词边界 `\b` 包围的模式。请注意，您必须转义斜杠。使用此模式，我们初始化 `QRegularExpression`
    对象，并在其上调用 `globalMatch()`。在传递的参数内部，将搜索该模式。这次，我们没有返回 `QRegularExpressionMatch`，而是返回
    `QRegularExpressionMatchIterator` 类型的迭代器。由于 `QRegularExpressionMatchIterator`
    的行为类似于 Java 迭代器，具有 `hasNext()` 方法，我们检查是否存在进一步的匹配，如果存在，则通过调用 `next()` 获取下一个匹配。返回的匹配类型是
    `QRegularExpressionMatch`，这是您已经知道的。'
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you need to know about the next match inside the `while` loop, you can use
    `QRegularExpressionMatchIterator::peekNext()` to receive it. The upside of this
    function is that it does not move the iterator.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在 `while` 循环内部了解下一个匹配项，你可以使用 `QRegularExpressionMatchIterator::peekNext()`
    来接收它。这个函数的优点是它不会移动迭代器。
- en: This way, you can iterate all pattern occurrences in the string. This is helpful
    if you, for example, want to highlight a search string in text.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以遍历字符串中的所有模式出现。如果你，例如，想在文本中突出显示搜索字符串，这将很有帮助。
- en: 'Our example would give the output: `("123"), ("09") and ("3")`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将给出输出：`("123"), ("09") and ("3")`。
- en: Taking into account that this was just a brief introduction to regular expressions,
    we would like to encourage you to read the *Detailed Description* section in the
    documentation to `QRegularExpression`, `QRegularExpressionMatch`, and `QRegularExpressionMatchIterator`.
    Regular expressions are very powerful and useful, so, in your daily programming
    life, you can benefit from the profound knowledge of regular expressions!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这只是一个关于正则表达式的简要介绍，我们鼓励你阅读文档中关于 `QRegularExpression`、`QRegularExpressionMatch`
    和 `QRegularExpressionMatchIterator` 的 *详细描述* 部分。正则表达式非常强大且有用，因此，在你的日常编程生活中，你可以从正则表达式的深刻知识中受益！
- en: Data storage
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据存储
- en: When implementing games, you will often have to work with persistent data—you
    will need to store the saved game data, load maps, and so on. For that, you have
    to learn about the mechanisms that let you use the data stored on digital media.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现游戏时，你通常会需要处理持久数据——你需要存储保存的游戏数据、加载地图等等。为此，你必须了解让你能够使用存储在数字媒体上的数据的机制。
- en: Files and devices
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件和设备
- en: The most basic and low-level mechanism that is used to access data is to save
    and load it from the files. While you can use the classic file access approaches
    provided by C and C++, such as `stdio` or `iostream`, Qt provides its own wrapper
    over the file abstraction that hides platform-dependent details and provides a
    clean API that works across all platforms in a uniform manner.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数据的最基本和底层机制是从文件中保存和加载它。虽然你可以使用 C 和 C++ 提供的经典的文件访问方法，如 `stdio` 或 `iostream`，但
    Qt 提供了对文件抽象的自己的包装，它隐藏了平台相关的细节，并提供了一个在所有平台上以统一方式工作的干净 API。
- en: The two basic classes that you will work with when using files are `QDir` and
    `QFile`. The former represents the contents of a directory, lets you traverse
    filesystems, creates and remove directories, and finally, access all files in
    a particular directory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用文件时，你将工作的两个基本类是 `QDir` 和 `QFile`。前者表示目录的内容，允许你遍历文件系统，创建和删除目录，最后，访问特定目录中的所有文件。
- en: Traversing directories
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历目录
- en: Traversing directories with `QDir` is really easy. The first thing to do is
    to have an instance of `QDir` in the first place. The easiest way to do this is
    to pass the directory path to the `QDir` constructor.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `QDir` 遍历目录非常简单。首先要做的事情是首先有一个 `QDir` 实例。最简单的方法是将目录路径传递给 `QDir` 构造函数。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Qt handles file paths in a platform-independent way. Even though the regular
    directory separator on Windows is a backwards slash character (`\`) and on other
    platforms it is the forward slash (`/`), Qt accepts forward slash as a directory
    separator on Windows platforms as well. Therefore, you can always use `/` to separate
    directories when you pass paths to Qt functions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Qt以平台无关的方式处理文件路径。尽管Windows上的常规目录分隔符是反斜杠字符（`\`），而其他平台上是正斜杠（`/`），但Qt在Windows平台上也接受正斜杠作为目录分隔符。因此，当将路径传递给Qt函数时，你始终可以使用`/`来分隔目录。
- en: You can learn the native directory separator for the current platform is by
    calling the `QDir::separator()`static function. You can transform between native
    and non-native separators with the `QDir::toNativeSeparators()` and `QDir::fromNativeSeparators()`functions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`QDir::separator()`静态函数来学习当前平台的本地目录分隔符。你可以使用`QDir::toNativeSeparators()`和`QDir::fromNativeSeparators()`函数在本地和非本地分隔符之间进行转换。
- en: 'Qt provides a number of static methods to access some special directories.
    The following table lists these special directories and functions that access
    them:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了一些静态方法来访问一些特殊目录。以下表格列出了这些特殊目录及其访问函数：
- en: '| Access function | Directory |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 访问函数 | 目录 |'
- en: '| --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `QDir::current()` | The current working directory |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::current()` | 当前工作目录 |'
- en: '| `QDir::home()` | The home directory of the current user |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::home()` | 当前用户的家目录 |'
- en: '| `QDir::root()` | The root directory—usually `/` for Unix and `C:\` for Windows
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::root()` | 根目录——通常在Unix中为`/`，在Windows中为`C:\` |'
- en: '| `QDir::temp()` | The system temporary directory |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::temp()` | 系统临时目录 |'
- en: When you already have a valid `QDir` object, you can start moving between directories.
    To do that, you can use the `cd()` and `cdUp()` methods. The former moves to the
    named subdirectory, while the latter moves to the parent directory.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你已经有一个有效的`QDir`对象时，你可以开始在不同目录之间移动。为此，你可以使用`cd()`和`cdUp()`方法。前者移动到命名的子目录，而后者移动到父目录。
- en: 'To list files and subdirectories in a particular directory, you can use the
    `entryList()` method, which returns a list of entries in the directory that match
    the criteria passed to `entryList()`. This method has two overloads. The basic
    version takes a list of flags that correspond to the different attributes that
    an entry needs to have to be included in the result and a set of flags that determine
    the order in which entries are included in the set. The other overload also accepts
    a list of file name patterns in the form of `QStringList` as its first parameter.
    The most commonly used filter and sort flags are listed as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出特定目录中的文件和子目录，你可以使用`entryList()`方法，该方法返回目录中符合`entryList()`传入的标准的条目列表。此方法有两个重载版本。基本版本接受一个标志列表，这些标志对应于条目需要具有的不同属性才能包含在结果中，以及一组标志，用于确定条目在集合中包含的顺序。另一个重载版本还接受一个`QStringList`格式的文件名模式列表作为其第一个参数。最常用的筛选和排序标志如下所示：
- en: '| Filter flags |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 筛选标志 |'
- en: '| --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `QDir::Dirs, QDir::Files, QDir::Drives, QDir::AllEntries` | List directories,
    files, drives (or all) that match the filters |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::Dirs, QDir::Files, QDir::Drives, QDir::AllEntries` | 列出匹配筛选条件的目录、文件、驱动器（或所有）
    |'
- en: '| `QDir::AllDirs` | List all subdirectories regardless of whether they match
    the filter or not |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::AllDirs` | 列出所有子目录，无论它们是否匹配筛选条件 |'
- en: '| `QDir::Readable, QDir::Writable, QDir::Executable` | List entries that can
    be read, written, or executed |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::Readable, QDir::Writable, QDir::Executable` | 列出可读、可写或可执行的条目 |'
- en: '| `QDir::Hidden, QDir::System` | List hidden files and system files |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::Hidden, QDir::System` | 列出隐藏文件和系统文件 |'
- en: '| **Sort flags** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **排序标志** |'
- en: '| `QDir::Unsorted` | The order of entries is undefined |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::Unsorted` | 条目的顺序是未定义的 |'
- en: '| `QDir::Name, QDir::Time, QDir::Size, QDir::Type` | Sort by appropriate entry
    attributes |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::Name, QDir::Time, QDir::Size, QDir::Type` | 根据适当的条目属性进行排序 |'
- en: '| `QDir::DirsFirst, QDir::DirsLast` | Determines whether directories should
    be listed before or after files |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::DirsFirst, QDir::DirsLast` | 确定目录是否应在文件之前或之后列出 |'
- en: 'Here is an example call that returns all JPEG files in the user''s `home` directory
    sorted by size:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例调用，它返回用户`home`目录中所有按大小排序的JPEG文件：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `<<` operator is a nice and fast way to append entries to `QStringList`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<`运算符是一种简单快捷的方法，可以将条目追加到`QStringList`。'
- en: Getting access to the basic file
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取基本文件的访问权限
- en: 'Once you know the path to a file (either by using `QDir::entryList()`, from
    some external source, or even by hardcoding the file path in code), you can pass
    it to `QFile` to receive an object that acts as a handle to the file. Before the
    file contents can be accessed, the file needs to be opened using the `open()`
    method. The basic variant of this method takes a mode in which we need to open
    the file. The following table explains the modes that are available:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道了文件的路径（无论是通过使用 `QDir::entryList()`、来自外部源，甚至是在代码中硬编码文件路径），就可以将其传递给 `QFile`
    以接收一个作为文件句柄的对象。在可以访问文件内容之前，需要使用 `open()` 方法打开文件。此方法的基本变体需要一个模式，其中我们需要打开文件。以下表格解释了可用的模式：
- en: '| Mode | Description |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 描述 |'
- en: '| --- | --- |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ReadOnly` | This file can be read from |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `ReadOnly` | 此文件可读 |'
- en: '| `WriteOnly` | This file can be written to |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `WriteOnly` | 此文件可写入 |'
- en: '| `ReadWrite` | This file can be read from and written to |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `ReadWrite` | 此文件可读和写 |'
- en: '| `Append` | All data writes will be written at the end of the file |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `Append` | 所有数据写入都将写入文件末尾 |'
- en: '| `Truncate` | If the file is present, its content is deleted before we open
    it |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `Truncate` | 如果文件存在，则在打开之前删除其内容 |'
- en: '| `Text` | Native line endings are transformed to `\n` and back |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `Text` | 本地行结束符转换为 `\n` 并返回 |'
- en: '| `Unbuffered` | The flag prevents the file from being buffered by the system
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `Unbuffered` | 该标志防止系统对文件进行缓冲 |'
- en: 'The `open()` method returns `true` or `false` depending on whether the file
    was opened or not. The current status of the file can be checked by calling `isOpen()`
    on the file object. Once the file is open, it can be read from or written to depending
    on the options that are passed when the file is opened. Reading and writing is
    done using the `read()` and `write()` methods. These methods have a number of
    overloads, but I suggest that you focus on using those variants that accept or
    return a `QByteArray` object, which is essentially a series of bytes—it can hold
    both textual and nontextual data. If you are working with plain text, then a useful
    overload for `write` is the one that accepts the text directly as input. Just
    remember that the text has to be null or terminated. When reading from a file,
    Qt offers a number of other methods that might come in handy in some situations.
    One of these methods is `readLine()`, which tries to read from the file until
    it encounters a new line character. If you use it together with the `atEnd()`
    method that tells you whether you have reached the end of the file, you can realize
    the line-by-line reading of a text file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()` 方法根据文件是否被打开返回 `true` 或 `false`。可以通过在文件对象上调用 `isOpen()` 来检查文件当前的状态。一旦文件打开，就可以根据打开文件时传递的选项来读取或写入。读取和写入是通过
    `read()` 和 `write()` 方法完成的。这些方法有很多重载，但我建议您专注于使用那些接受或返回 `QByteArray` 对象的变体，它本质上是一系列字节——它可以存储文本和非文本数据。如果您正在处理纯文本，那么
    `write` 方法的一个有用的重载是直接接受文本作为输入的变体。只需记住，文本必须是空或终止的。当从文件读取时，Qt 提供了其他一些可能在某些情况下很有用的方法。其中一种方法是
    `readLine()`，它尝试从文件中读取，直到遇到新行字符。如果您与告诉您是否已到达文件末尾的 `atEnd()` 方法一起使用，您就可以实现逐行读取文本文件：'
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Another useful method is `readAll()`, which simply returns the file content,
    starting from the current position of the file pointer until the end of the file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有用的方法是 `readAll()`，它简单地返回从文件指针当前位置开始直到文件末尾的内容。
- en: 'You have to remember though that when using these helper methods, you should
    be really careful if you don''t know how much data the file contains. It might
    happen that when reading line by line or trying to read the whole file into memory
    in one step, you exhaust the amount of memory that is available for your process
    (you can check the size of the file by calling `size()` on the `QFile` instance).
    Instead, you should process the file''s data in steps, reading only as much as
    you require at a time. This makes the code more complex but allows us to better
    manage the available resources. If you require constant access to some part of
    the file, you can use the `map()` and `unmap()` calls that add and remove mappings
    of the parts of a file to a memory address that you can then use like a regular
    array of bytes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须记住，在使用这些辅助方法时，如果你不知道文件包含多少数据，你应该非常小心。可能会发生这种情况，当你逐行读取或尝试一次性将整个文件读入内存时，你会耗尽你的进程可用的内存量（你可以通过在`QFile`实例上调用`size()`来检查文件的大小）。相反，你应该分步骤处理文件数据，一次只读取所需的量。这使得代码更复杂，但使我们能够更好地管理可用资源。如果你需要经常访问文件的一部分，你可以使用`map()`和`unmap()`调用，这些调用将文件的一部分添加到或从内存地址映射中移除，然后你可以像使用常规字节数组一样使用它：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Devices
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备
- en: '`QFile` is really a descendant class of `QIODevice`, which is a Qt interface
    that is used to abstract entities related to reading and writing. There are two
    types of devices: sequential and random access devices. `QFile` belongs to the
    latter group—it has the concepts of start, end, size, and current position that
    can be changed by the user with the `seek()` method. Sequential devices, such
    as sockets and pipes, represent streams of data—there is no way to rewind the
    stream or check its size; you can only keep reading the data sequentially—piece
    by piece, and you can check how far away you currently are from the end of data.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFile`实际上是`QIODevice`的子类，`QIODevice`是一个Qt接口，用于抽象与读取和写入相关的实体。有两种类型的设备：顺序访问设备和随机访问设备。`QFile`属于后者——它具有开始、结束、大小和当前位置的概念，用户可以通过`seek()`方法更改这些概念。顺序设备，如套接字和管道，表示数据流——没有方法可以回滚流或检查其大小；你只能按顺序逐个读取数据——一次读取一部分，你可以检查你目前距离数据末尾有多远。'
- en: All I/O devices can be opened and closed. They all implement `open()`, `read()`,
    and `write()` interfaces. Writing to the device queues the data for writing; when
    the data is actually written, the `bytesWritten()` signal is emitted that carries
    the amount of data that was written to the device. If more data becomes available
    in the sequential device, it emits the `readyRead()` signal, which informs you
    that if you call `read` now, you can expect to receive some data from the device.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所有I/O设备都可以打开和关闭。它们都实现了`open()`、`read()`和`write()`接口。向设备写入数据会将数据排队等待写入；当数据实际写入时，会发出`bytesWritten()`信号，该信号携带写入设备的数据量。如果在顺序设备中还有更多数据可用，它会发出`readyRead()`信号，通知你如果现在调用`read`，你可以期望从设备接收一些数据。
- en: Time for action – implementing a device to encrypt data
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施加密数据设备的行动时间
- en: Let's implement a really simple device that encrypts or decrypts the data that
    is streamed through it using a very simple algorithm—the Caesar cipher. What it
    does is that when encrypting, it shifts each character in the plaintext by a number
    of characters defined by the key and does the reverse when decrypting. Thus, if
    the key is `2` and the plaintext character is `a`, the ciphertext becomes `c`.
    Decrypting `z` with the key `4` will yield the value `v`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个非常简单的设备，它使用一个非常简单的算法——凯撒密码来加密或解密通过它的数据。它的作用是在加密时，将明文中的每个字符按密钥定义的字符数进行移位，解密时进行相反的操作。因此，如果密钥是`2`，明文字符是`a`，密文就变成了`c`。使用密钥`4`解密`z`将得到值`v`。
- en: 'We will start by creating a new empty project and adding a class derived from
    `QIODevice`. The basic interface of the class is going to accept an integer key
    and set an underlying device that serves as the source or destination of data.
    This is all simple coding that you should already understand, so it shouldn''t
    need any extra explanation, as shown:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的空项目，并添加一个从`QIODevice`派生的类。该类的基本接口将接受一个整数密钥并设置一个作为数据源或目的地的底层设备。这些都是你应该已经理解的简单编码，因此不需要任何额外的解释，如下所示：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next thing is to make sure that the device cannot be used if there is no
    device to operate on (that is, when `m_device == 0`). For this, we have to reimplement
    the `QIODevice::open()` method and return `false` when we want to prevent operating
    on our device:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确保如果没有设备可供操作（即当 `m_device == 0` 时），则不能使用该设备。为此，我们必须重新实现 `QIODevice::open()`
    方法，并在我们想要阻止操作我们的设备时返回 `false`：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The method accepts the mode that the user wants to open the device with. We
    perform an additional check to verify that the base device was opened in the same
    mode before calling the base class implementation that will mark the device as
    open.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受用户想要以何种模式打开设备。我们在调用将设备标记为打开的基类实现之前执行一个额外的检查，以验证基本设备是否以相同的模式打开。
- en: 'To have a fully functional device, we still need to implement the two protected
    pure virtual methods, which do the actual reading and writing. These methods are
    called by Qt from other methods of the class when needed. Let''s start with `writeData()`,
    which accepts a pointer to a buffer containing the data and size of that a buffer:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要有一个完全功能的设备，我们仍然需要实现两个受保护的纯虚方法，这些方法执行实际的读取和写入操作。这些方法在需要时由 Qt 从类的其他方法中调用。让我们从
    `writeData()` 开始，它接受一个指向包含数据的缓冲区的指针以及该缓冲区的大小：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, we copy the data into a local byte array. Then, we iterate the array,
    adding to each byte the value of the key (which effectively performs the encryption).
    Finally, we try to write the byte array to the underlying device. Before informing
    the caller about the amount of data that was really written, we emit a signal
    that carries the same information.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将数据复制到一个局部字节数组中。然后，我们遍历数组，将密钥的值添加到每个字节（这实际上执行了加密）。最后，我们尝试将字节数组写入底层设备。在通知调用者实际写入的数据量之前，我们发出一个携带相同信息的信号。
- en: 'The last method that we need to implement is the one that performs decryption
    by reading from the base device and adding the key to each cell of the data. This
    is done by implementing `readData()`, which accepts a pointer to the buffer that
    the method needs to write to and the size of the buffer. The code is quite similar
    to that of `writeData()` except that we are subtracting the key value instead
    of adding it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一个方法是执行解密操作，通过从基本设备读取并给数据中的每个单元格添加密钥。这是通过实现 `readData()` 来完成的，它接受一个指向方法需要写入的缓冲区的指针以及缓冲区的大小。代码与
    `writeData()` 非常相似，只是我们是在减去密钥值而不是添加它：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we read from the underlying device as much as we can fit into the buffer
    and store the data in a byte array. Then, we iterate the array and set subsequent
    bytes of data buffer to the decrypted value. Finally, we return the amount of
    data that was really read.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从底层设备读取尽可能多的数据，将其存储在字节数组中。然后，我们遍历数组并将数据缓冲区的后续字节设置为解密值。最后，我们返回实际读取的数据量。
- en: 'A simple `main()` function that can test the class looks as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的 `main()` 函数，可以测试该类，如下所示：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We use the `QBuffer` class that implements the `QIODevice` API and acts as an
    adapter for `QByteArray` or `QString`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用实现 `QIODevice` API 并作为 `QByteArray` 或 `QString` 适配器的 `QBuffer` 类。
- en: '*What just happened?*'
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created an encryption object and set its key to `3`. We also told it to use
    a `QBuffer` instance to store the processed content. After opening it for writing,
    we sent some data to it that gets encrypted and written to the base device. Then,
    we created a similar device, passing the same buffer again as the base device,
    but now, we open the device for reading. This means that the base device contains
    ciphertext. After this, we read all data from the device, which results in reading
    data from the buffer, decrypting it, and returning the data so that it can be
    written to the debug console.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个加密对象，并将其密钥设置为 `3`。我们还告诉它使用一个 `QBuffer` 实例来存储处理后的内容。在打开它以供写入后，我们向其中发送了一些数据，这些数据被加密并写入基本设备。然后，我们创建了一个类似的设备，再次将相同的缓冲区作为基本设备传递，但现在我们打开设备以供读取。这意味着基本设备包含密文。在此之后，我们从设备中读取所有数据，这导致从缓冲区中读取数据，解密它，并将数据返回以便写入调试控制台。
- en: Have a go hero – a GUI for the Caesar cipher
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 一个凯撒密码的图形用户界面
- en: You can combine what you already know by implementing a full-blown GUI application
    that is able to encrypt or decrypt files using the Caesar cipher `QIODevice` class
    that we just implemented. Remember that `QFile` is also `QIODevice`, so you can
    pass its pointer directly to `setBaseDevice()`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过实现一个完整的GUI应用程序来结合你已知的知识，该应用程序能够使用我们刚刚实现的Caesar cipher `QIODevice`类加密或解密文件。记住，`QFile`也是`QIODevice`，所以你可以直接将其指针传递给`setBaseDevice()`。
- en: This is just a starting point for you. The `QIODevice` API is quite rich and
    contains numerous methods that are virtual, so you can reimplement them in subclasses.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是你的起点。`QIODevice` API非常丰富，包含许多虚拟方法，因此你可以在子类中重新实现它们。
- en: Text streams
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本流
- en: Much of the data produced by computers nowadays is based on text. You can create
    such files using a mechanism that you already know—opening `QFile` to write, converting
    all data into strings using `QString::arg()`, optionally encoding strings using
    `QTextCodec`, and dumping the resulting bytes to the file by calling `write`.
    However, Qt provides a nice mechanism that does most of this automatically for
    you in a way similar to how the standard C++ `iostream` classes work. The `QTextStream`
    class operates on any `QIODevice` API in a stream-oriented way. You can send tokens
    to the stream using the `<<` operator, where they get converted into strings,
    separated by spaces, encoded using a codec of your choice, and written to the
    underlying device. It also works the other way round; using the `>>` operator,
    you can stream data from a text file, transparently converting it from strings
    to appropriate variable types. If the conversion fails, you can discover it by
    inspecting the result of the `status()` method—if you get `ReadPastEnd` or `ReadCorruptData`,
    then this means that the read has failed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现今计算机产生的大部分数据都是基于文本的。你可以使用你已知的机制创建此类文件——打开`QFile`进行写入，使用`QString::arg()`将所有数据转换为字符串，可选地使用`QTextCodec`对字符串进行编码，并通过调用`write`将生成的字节写入文件。然而，Qt提供了一个很好的机制，可以自动为你完成大部分工作，其工作方式类似于标准C++
    `iostream`类。`QTextStream`类以流式方式操作任何`QIODevice` API。你可以使用`<<`运算符向流发送标记，它们将被转换为字符串，用空格分隔，使用你选择的编解码器编码，并写入底层设备。它也可以反过来工作；使用`>>`运算符，你可以从文本文件中流式传输数据，透明地将字符串转换为适当的变量类型。如果转换失败，你可以通过检查`status()`方法的结果来发现它——如果你得到`ReadPastEnd`或`ReadCorruptData`，这意味着读取失败。
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While `QIODevice` is the main class that `QTextStream` operates on, it can also
    manipulate `QString` or `QByteArray`, which makes it useful for us to compose
    or parse strings.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`QIODevice`是`QTextStream`操作的主要类，但它也可以操作`QString`或`QByteArray`，这使得它对我们来说很有用，可以组合或解析字符串。
- en: 'Using `QTextStream` is simple—you just have to pass it the device that you
    want it to operate on and you''re good to go. The stream accepts strings and numerical
    values:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`QTextStream`很简单——你只需传递给它你想要其操作的设备，然后就可以开始了。流接受字符串和数值：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Apart from directing content into the stream, the stream can accept a number
    of manipulators, such as `endl`, which have a direct or indirect influence on
    how the stream behaves. For instance, you can tell the stream to display a number
    as decimal and another as hexadecimal with uppercase digits using the following
    code (highlighted in the code are all manipulators):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将内容直接导入流中，流还可以接受多个操作符，例如`endl`，这些操作符会直接或间接影响流的行为。例如，你可以告诉流以十进制显示一个数字，并以大写字母显示另一个十六进制数字，如下面的代码所示（代码中突出显示的都是操作符）：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is not the end of the capabilities of `QTextStream`. It also allows us
    to display data in a tabular manner by defining column widths and alignments.
    Suppose that you have a set of records for game players that is defined by the
    following structure:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是`QTextStream`功能的终点。它还允许我们通过定义列宽和对齐方式以表格形式显示数据。假设你有一组游戏玩家记录，其结构如下：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s dump such info into a file in a tabular manner:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此类信息以表格形式输出到文件中：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After running the program, you should get a result similar to the one shown
    in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后，你应该得到一个类似于以下截图所示的结果：
- en: '![Text streams](img/8874OS_04_01.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![文本流](img/8874OS_04_01.jpg)'
- en: 'One last thing about `QTextStream` is that it can operate on standard C file
    structures, which makes it possible for us to use `QTextStream` to, for example,
    write to `stdout` or read from `stdin`, as shown in the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`QTextStream`的最后一件事是，它可以操作标准C文件结构，这使得我们可以使用`QTextStream`，例如写入`stdout`或从`stdin`读取，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Data serialization
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据序列化
- en: More than often, we have to store object data in a device-independent way so
    that it can be restored later, possibly on a different machine with a different
    data layout and so on. In computer science, this is called serialization. Qt provides
    several serialization mechanisms and now we will have a brief look at some of
    them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的时候，我们必须以设备无关的方式存储对象数据，以便以后可以恢复，可能在不同的机器上，具有不同的数据布局等等。在计算机科学中，这被称为序列化。Qt提供了几种序列化机制，现在我们将简要地看看其中的一些。
- en: Binary streams
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制流
- en: If you look at `QTextStream` from a distance, you will notice that what it really
    does is serialize and deserialize data to a text format. Its close cousin is the
    `QDataStream` class that handles serialization and deserialization of arbitrary
    data to a binary format. It uses a custom data format to store and retrieve data
    from `QIODevice` in a platform-independent way. It stores enough data so that
    a stream written on one platform can be successfully read on a different platform.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从远处看`QTextStream`，你会注意到它真正做的是将数据序列化和反序列化到文本格式。它的近亲是`QDataStream`类，它处理任意数据的序列化和反序列化到二进制格式。它使用自定义数据格式以平台无关的方式存储和检索`QIODevice`中的数据。它存储足够的数据，以便在一个平台上编写的流可以在不同的平台上成功读取。
- en: '`QDataStream` is used in a similar fashion as `QTextStream`—the operators `<<`
    and `>>` are used to redirect data into or out of the stream. The class supports
    most of the built-in Qt types so that you can operate on classes such as `QColor`,
    `QPoint`, or `QStringList` directly:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDataStream`的使用方式与`QTextStream`类似——运算符`<<`和`>>`用于将数据重定向到或从流中。该类支持大多数内置的Qt类型，因此你可以直接操作`QColor`、`QPoint`或`QStringList`等类：'
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you want to serialize custom data types, you can teach `QDataStream` to do
    that by implementing proper redirection operators.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想序列化自定义数据类型，你可以通过实现适当的重定向运算符来教会`QDataStream`这样做。
- en: Time for action – serialization of a custom structure
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候进行动作了——自定义结构的序列化
- en: 'Let''s perform another small exercise by implementing functions that are required
    to use `QDataStream` to serialize the same simple structure that contains the
    player information that we used for text streaming:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现使用`QDataStream`序列化包含我们用于文本流传输的玩家信息的简单结构的函数来做一个小的练习：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For this, two functions need to be implemented, both returning a `QDataStream`
    reference that was taken earlier as an argument to the call. Apart from the stream
    itself, the serialization operator accepts a constant reference to the class that
    is being saved. The most simple implementation just streams each member into the
    stream and returns the stream afterwards:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，需要实现两个函数，这两个函数都返回一个之前作为调用参数传入的`QDataStream`引用。除了流本身之外，序列化运算符还接受一个对正在保存的类的常量引用。最简单的实现是将每个成员流式传输到流中，然后返回流：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Complementary to this, deserializing is done by implementing a redirection
    operator that accepts a mutable reference to the structure that is filled by data
    that is read from the stream:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为补充，反序列化是通过实现一个接受对由从流中读取的数据填充的结构的可变引用的重定向运算符来完成的：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Again, at the end, the stream itself is returned.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，最后返回的是流本身。
- en: '*What just happened?*'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We provided two standalone functions that define redirection operators for the
    `Player` class to and from a `QDataStream` instance. This lets your class be serialized
    and deserialized using mechanisms offered and used by Qt.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了两个独立的函数，用于定义`Player`类到`QDataStream`实例的重定向运算符。这使得你的类可以使用Qt提供的机制进行序列化和反序列化。
- en: XML streams
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML流
- en: XML has become one of the most popular standards that is used to store hierarchical
    data. Despite its verbosity and difficulty to read by human eye, it is used in
    virtually any domain where data persistency is required, as it is very easy to
    read by machines. Qt provides support for reading and writing XML documents in
    two modules. First, the `QtXml` module provides access using the **Document Object
    Model** (**DOM**) standard with classes such as `QDomDocument`, `QDomElement`,
    and others. We will not discuss this approach here, as now the recommended approach
    is to use streaming classes from the `QtCore` module. One of the downsides of
    `QDomDocument` is that it requires us to load the whole XML tree into the memory
    before parsing it. In some situations, this is compensated for by the ease of
    use of the DOM approach as compared to a streamed approach, so you can consider
    using it if you feel you have found the right task for it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: XML已经成为存储层次化数据的最受欢迎的标准之一。尽管它冗长且难以用肉眼阅读，但它几乎在需要数据持久化的任何领域都被使用，因为它非常容易由机器读取。Qt提供了两个模块来支持读取和写入XML文档。首先，`QtXml`模块通过**文档对象模型**（**DOM**）标准，使用`QDomDocument`、`QDomElement`等类提供访问。我们在这里不会讨论这种方法，因为现在推荐的方法是使用来自`QtCore`模块的流式类。`QDomDocument`的一个缺点是它要求我们在解析之前将整个XML树加载到内存中。在某些情况下，与流式方法相比，DOM方法的易用性可以弥补这一点，所以如果你觉得找到了合适的任务，可以考虑使用它。
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to use the DOM access to XML in Qt, remember to enable the `QtXml`
    module in your applications by adding a `QT += xml` line in the project configuration
    files.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Qt中使用DOM访问XML，请记住在项目配置文件中添加`QT += xml`行以启用`QtXml`模块。
- en: As already said, we will focus on the stream approach implemented by the `QXmlStreamReader`
    and `QXmlStreamWriter` classes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所说，我们将关注由`QXmlStreamReader`和`QXmlStreamWriter`类实现的流式方法。
- en: Time for action – implementing an XML parser for player data
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始行动时间 - 实现玩家数据的XML解析器
- en: 'In this exercise, we are going to create a parser to fill data that represents
    players and their inventory in an RPG game:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个解析器来填充表示玩家及其在RPG游戏中的库存数据的结构：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Save the following document somewhere. We will use it to test whether the parser
    can read it:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下文档保存在某个地方。我们将使用它来测试解析器是否可以读取它：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s create a class called `PlayerInfoReader` that will wrap `QXmlStreamReader`
    and expose a parser interface for the `PlayerInfo` instances. The class will contain
    two private members—the reader itself and a `PlayerInfo` instance that acts as
    a container for the data that is currently being read. We''ll provide a `result()`
    method that returns this object once the parsing is complete, as shown in the
    following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`PlayerInfoReader`的类，它将包装`QXmlStreamReader`并公开一个解析器接口，用于`PlayerInfo`实例。该类将包含两个私有成员——读取器本身以及一个`PlayerInfo`实例，它作为当前正在读取的数据的容器。我们将提供一个`result()`方法，在解析完成后返回此对象，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The class constructor accepts a `QIODevice` pointer that the reader is going
    to use to retrieve data as it needs it. The constructor is trivial, as it simply
    passes the device to the `reader` object:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数接受一个`QIODevice`指针，读者将使用它来按需检索数据。构造函数很简单，因为它只是将设备传递给`reader`对象：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Before we go into parsing, let''s prepare some code to help us with the process.
    First, let''s add an enumeration type to the class that will list all the possible
    tokens—tag names that we want to handle in the parser:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始解析之前，让我们准备一些代码来帮助我们处理这个过程。首先，让我们向类中添加一个枚举类型，它将列出所有可能的令牌——我们希望在解析器中处理的标签名称：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To use these tags, we''ll add a static method to the class that returns the
    token type based on its textual representation:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些标签，我们将在类中添加一个静态方法，它根据其文本表示返回令牌类型：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can notice that we are using a class called `QStringRef`. It represents
    a string reference—a substring in an existing string—and is implemented in a way
    that avoids expensive string construction; therefore, it is very fast. We're using
    this class here because that's how `QXmlStreamReader` reports tag names. Inside
    this static method, we are converting the string reference to a real string and
    trying to match it against a list of known tags. If the matching fails, `-1` is
    returned, which corresponds to our `T_Invalid` token.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到我们正在使用一个名为`QStringRef`的类。它代表一个字符串引用——现有字符串中的子串，并且以避免昂贵的字符串构造的方式实现；因此，它非常快。我们在这里使用这个类是因为这是`QXmlStreamReader`报告标签名的方式。在这个静态方法中，我们将字符串引用转换为真实字符串，并尝试将其与已知标签列表进行匹配。如果匹配失败，则返回`-1`，这对应于我们的`T_Invalid`令牌。
- en: 'Now, let''s add an entry point to start the parsing process. Add a public `read`
    method that initializes the data structure and performs initial checks on the
    input stream:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个入口点来启动解析过程。添加一个公共的`read`方法，它初始化数据结构并对输入流进行初始检查：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After clearing the data structure, we call `readNextStartElement()` on the reader
    to make it find the starting tag of the first element, and if it is found, we
    check whether the root tag of the document is what we expect it to be. If so,
    we call the `readPlayerInfo()` method and return its result, denoting whether
    the parsing was successful. Otherwise, we bail out, reporting an error.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在清除数据结构后，我们在读取器上调用`readNextStartElement()`，使其找到第一个元素的起始标签，并且如果找到了，我们检查文档的根标签是否是我们期望的。如果是这样，我们调用`readPlayerInfo()`方法并返回其结果，表示解析是否成功。否则，我们退出，报告错误。
- en: The `QXmlStreamReader` subclasses usually follow the same pattern. Each parsing
    method first checks whether it operates on a tag that it expects to find. Then,
    it iterates all the starting elements, handling those it knows and ignoring all
    others. Such an approach lets us maintain forward compatibility, since all tags
    introduced in newer versions of the document are silently skipped by an older
    parser.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`QXmlStreamReader`子类通常遵循相同的模式。每个解析方法首先检查它是否操作的是它期望找到的标签。然后，它迭代所有起始元素，处理它所知道的元素，并忽略所有其他元素。这种做法使我们能够保持向前兼容性，因为较旧解析器会静默跳过文档新版本中引入的所有标签。'
- en: 'Now, let''s implement the `readPlayerInfo` method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现`readPlayerInfo`方法：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: After verifying that we are working on a `PlayerInfo` tag, we iterate all the
    starting subelements of the current tag. For each of them, we check whether it
    is a `Player` tag and call `readPlayer()` to descend into the level of parsing
    data for a single player. Otherwise, we call `skipCurrentElement()`, which fast-forwards
    the stream until a matching ending element is encountered.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证我们正在处理`PlayerInfo`标签后，我们迭代当前标签的所有起始子元素。对于其中的每一个，我们检查它是否是`Player`标签，并调用`readPlayer()`来进入单个玩家解析数据级别的解析。否则，我们调用`skipCurrentElement()`，这将快速前进流，直到遇到匹配的结束元素。
- en: 'The structure of `readPlayer()` is similar; however, it is more complicated
    as we also want to read data from attributes of the `Player` tag itself. Let''s
    take a look at the function piece by piece:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`readPlayer()`的结构类似；然而，它更复杂，因为我们还想要从`Player`标签本身的属性中读取数据。让我们逐部分查看这个函数：'
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After checking for the right tag, we get the list of attributes associated
    with the opening tag and ask for values of the two attributes that we are interested
    in. After this, we loop all child tags and fill the `Player` structure based on
    the tag names. By converting tag names to tokens, we can use a `switch` statement
    to neatly structure the code in order to extract information from different tag
    types, as shown in the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查正确的标签后，我们获取与打开标签关联的属性列表，并请求我们感兴趣的两种属性的值。之后，我们循环所有子标签，并根据标签名填充`Player`结构。通过将标签名转换为令牌，我们可以使用`switch`语句来整洁地组织代码，以便从不同的标签类型中提取信息，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If we are interested in the textual content of the tag, we can use `readElementText()`
    to extract it. This method reads until it encounters the closing tag and returns
    the text contained within it. For the `Inventory` tag, we call the dedicated `readInventory()`
    method.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对标签的文本内容感兴趣，我们可以使用`readElementText()`来提取它。此方法读取直到遇到关闭标签，并返回其内的文本。对于`Inventory`标签，我们调用专门的`readInventory()`方法。
- en: 'For the `Location` tag, the code is more complex than before as we again descend
    into reading child tags, extracting the required information and skipping all
    unknown tags:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Location`标签，代码比之前更复杂，因为我们再次进入读取子标签，提取所需信息并跳过所有未知标签：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The last method is similar in structure to the previous one—iterate all the
    tags, skip everything that we don''t want to handle (everything that is not an
    inventory item), fill the inventory item data structure, and append the item to
    the list of already parsed items, as shown in the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法的结构与上一个类似——遍历所有标签，跳过我们不想处理的标签（即不是存货项目的所有标签），填充存货项目数据结构，并将项目添加到已解析项目列表中，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In `main()` of your project, write some code that will check whether the parser
    works correctly. You can use the `qDebug()` statements to output the sizes of
    lists and contents of variables. Take a look at the following code for an example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目`main()`函数中，编写一些代码来检查解析器是否工作正确。你可以使用`qDebug()`语句来输出列表的大小和变量的内容。以下代码是一个示例：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*What just happened?*'
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The code you just wrote implements a full top-down parser of the XML data. First,
    the data goes through a tokenizer, which returns identifiers that are much easier
    to handle than strings. Then, each method can easily check whether the token it
    receives is an acceptable input for the current parsing stage. Based on the child
    token, the next parsing function is determined and the parser descends to a lower
    level until there is nowhere to descend to. Then, the flow goes back up one level
    and processes the next child. If at any point an unknown tag is found, it gets
    ignored. This approach supports a situation when a new version of software introduces
    new tags to the file format specification, but an old version of software can
    still read the file by skipping all the tags that it doesn't understand.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才编写的代码实现了XML数据的完整自顶向下解析器。首先，数据通过一个分词器，它返回比字符串更容易处理的标识符。然后，每个方法都可以轻松检查它接收到的标记是否是当前解析阶段的可接受输入。根据子标记，确定下一个解析函数，并解析器下降到较低级别，直到没有下降的地方。然后，流程向上回退一级并处理下一个子项。如果在任何点上发现未知标签，它将被忽略。这种方法支持一种情况，即新版本的软件引入了新的标签到文件格式规范中，但旧版本的软件仍然可以通过跳过所有它不理解的标签来读取文件。
- en: Have a go hero – an XML serializer for player data
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄——玩家数据的XML序列化器
- en: Now that you know how to parse XML data, you can create the complementary part—a
    module that will serialize `PlayerInfo` structures into XML documents using `QXmlStreamWriter`.
    Use methods such as `writeStartDocument()`, `writeStartElement()`, `writeCharacters()`,
    and `writeEndElement()` for this. Verify that the documents saved with your code
    can be parsed with what we implemented together.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何解析XML数据，你可以创建其互补部分——一个模块，它将使用`QXmlStreamWriter`将`PlayerInfo`结构序列化为XML文档。为此，你可以使用`writeStartDocument()`、`writeStartElement()`、`writeCharacters()`和`writeEndElement()`等方法。验证你用代码保存的文档是否可以用我们共同实现的解析器进行解析。
- en: JSON files
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON文件
- en: '**JSON** stands for **JavaScript Object Notation,** which is a popular lightweight
    textual format that is used to store object-oriented data in a human-readable
    form. It comes from JavaScript where it is the native format used to store object
    information; however, it is commonly used across many programming languages and
    a popular format for web data exchange. A simple JSON-formatted definition looks
    as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**代表**JavaScript对象表示法**，这是一种流行的轻量级文本格式，用于以人类可读的形式存储面向对象的数据。它源自JavaScript，在那里它是存储对象信息的原生格式；然而，它被广泛应用于许多编程语言，并且是网络数据交换的流行格式。一个简单的JSON格式定义如下：'
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'JSON can express two kinds of entities: objects (enclosed in braces) and arrays
    (enclosed in square brackets) where an object is defined as a set of key-value
    pairs, where a value can be a simple string, an object, or array. In the previous
    example, we had an object containing three properties—name, age, and inventory.
    The first two properties are simple values and the last property is an array that
    contains two objects with two properties each.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: JSON可以表示两种类型的实体：对象（用大括号括起来）和数组（用方括号括起来），其中对象被定义为键值对的集合，其中值可以是简单的字符串、对象或数组。在先前的例子中，我们有一个包含三个属性的对象——名称、年龄和存货。前两个属性是简单值，最后一个属性是一个包含两个对象且每个对象有两个属性的数组。
- en: Qt can create and read JSON descriptions using the `QJsonDocument` class. A
    document can be created from the UTF-8-encoded text using the `QJsonDocument::fromJson()`
    static method and can later be stored in a textual form again using `toJson()`.
    Since the structure of JSON closely resembles that of `QVariant` (which can also
    hold key-value pairs using `QVariantMap` and arrays using `QVariantList`), conversion
    methods to this class also exist using a set of `fromVariant()` and `toVariant()`
    calls. Once a JSON document is created, you can check whether it represents an
    object or an array using one of the `isArray` and `isObject` calls. Then, the
    document can be transformed into `QJsonArray` or `QJsonObject` using the `toArray`
    and `toObject` methods.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Qt可以使用`QJsonDocument`类创建和读取JSON描述。可以使用`QJsonDocument::fromJson()`静态方法从UTF-8编码的文本中创建一个文档，稍后可以使用`toJson()`方法将其再次存储为文本形式。由于JSON的结构与`QVariant`（也可以使用`QVariantMap`来存储键值对，使用`QVariantList`来存储数组）非常相似，因此也存在一组`fromVariant()`和`toVariant()`调用方法来实现到这个类的转换。一旦创建了一个JSON文档，就可以使用`isArray`和`isObject`调用之一来检查它是否表示一个对象或数组。然后，可以使用`toArray`和`toObject`方法将文档转换为`QJsonArray`或`QJsonObject`。
- en: '`QJsonObject` is an iterable type that can be queried for a list of keys (using
    `keys()`) or asked for a value of a specific key (with a `value()` method). Values
    are represented using the `QJsonValue` class, which can store simple values, an
    array, or object. New properties can be added to the object using the `insert()`
    method that takes a key as a string, a value can be added as `QJsonValue`, and
    the existing properties can be removed using `remove()`.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`QJsonObject`是一种可迭代的类型，可以查询其键列表（使用`keys()`）或询问特定键的值（使用`value()`方法）。值使用`QJsonValue`类表示，它可以存储简单值、数组或对象。可以使用`insert()`方法向对象添加新属性，该方法接受一个字符串形式的键，可以将值作为`QJsonValue`添加，并可以使用`remove()`方法移除现有属性。'
- en: '`QJsonArray` is also an iterable type that contains a classic list API—it contains
    methods such as `append()`, `insert()`, `removeAt()`, `at()`, and `size()` to
    manipulate entries in the array, again working on `QJsonValue` as the item type.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`QJsonArray`也是一种可迭代的类型，它包含一个经典的列表API——它包含`append()`、`insert()`、`removeAt()`、`at()`和`size()`等方法来操作数组中的条目，再次以`QJsonValue`作为项目类型。'
- en: Time for action – the player data JSON serializer
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始行动——玩家数据JSON序列化器
- en: Our next exercise is to create a serializer of the same `PlayerInfo` structure
    as we used for the XML exercise, but this time the destination data format is
    going to be JSON.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的练习是创建一个与我们在XML练习中使用的`PlayerInfo`结构相同的序列化器，但这次目标数据格式将是JSON。
- en: 'Start by creating a `PlayerInfoJSON` class and give it an interface similar
    to the one shown in the following code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个`PlayerInfoJSON`类，并给它一个类似于以下代码的接口：
- en: '[PRE53]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'All that is really required is to implement the `writePlayerInfo` method. This
    method will use `QJsonDocument::fromVariant()` to perform the serialization; thus,
    what we really have to do is convert our player data to a variant. Let''s add
    a protected method to do that:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 真正需要实现的是`writePlayerInfo`方法。这个方法将使用`QJsonDocument::fromVariant()`来进行序列化；因此，我们真正需要做的是将我们的玩家数据转换为一种变体。让我们添加一个受保护的方法来完成这个任务：
- en: '[PRE54]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Since the structure is really a list of players, we can iterate the list of
    players, serialize each player to a variant, and append the result to `QVariantList`.
    Having this function ready, we can descend a level and implement an overload for
    `toVariant()` that takes a `Player` object:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于结构实际上是一个玩家列表，我们可以迭代玩家列表，将每个玩家序列化为一个变体，并将结果追加到`QVariantList`中。有了这个函数，我们就可以向下深入并实现一个`toVariant()`的重载，它接受一个`Player`对象：
- en: '[PRE55]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Tip
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Qt''s `foreach` macro takes two parameters—a declaration of a variable and
    a container to iterate. At each iteration, the macro assigns subsequent elements
    to the declared variable and executes the statement located directly after the
    macro. A C++11 equivalent of `foreach` is a range that is based for construct:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的`foreach`宏接受两个参数——一个变量的声明和一个要迭代的容器。在每次迭代中，宏将后续元素分配给声明的变量，并执行宏后面的语句。C++11中`foreach`的等价物是基于for构造的range：
- en: '[PRE56]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This time, we are using `QVariantMap` as our base type, since we want to associate
    values with keys. For each key, we use the index operator to add entries to the
    map. The position key holds a `QPoint` value, which is supported natively by `QVariant`;
    however, such a variant can''t be automatically encoded in JSON, so we convert
    the point to a variant map using the C++11 initializer list. The situation is
    different with the inventory—again, we have to write an overload for `toVariant`
    that will perform the conversion:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用 `QVariantMap` 作为我们的基本类型，因为我们想将值与键关联起来。对于每个键，我们使用索引运算符向映射中添加条目。位置键包含一个
    `QPoint` 值，这是 `QVariant` 本地支持的；然而，这样的变体不能自动编码为 JSON，因此我们使用 C++11 初始化列表将点转换为变体映射。对于库存，情况不同——我们再次必须为
    `toVariant` 编写一个重载，以执行转换：
- en: '[PRE57]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The code is almost identical to the one handling `PlayerInfo` objects, so let''s
    focus on the last overload of `toVariant`—the one that accepts `Item` instances:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 代码几乎与处理 `PlayerInfo` 对象的代码相同，所以让我们关注 `toVariant` 的最后一个重载——接受 `Item` 实例的那个：
- en: '[PRE58]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There is not much to comment here—we add all keys to the map, treating the item
    type as an integer for simplicity (this is not the best approach in a general
    case, as if we serialize our data and then change the order of values in the original
    enumeration, we will not get the proper item types after deserialization).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多可评论的——我们将所有键添加到映射中，将项目类型视为整数以简化（在一般情况下，这不是最佳方法，因为我们序列化数据并更改原始枚举中的值顺序后，反序列化后不会得到正确的项目类型）。
- en: 'What remains is to use the code we have just written in the `writePlayerInfo`
    method:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是使用我们在 `writePlayerInfo` 方法中刚刚编写的代码：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Time for action – implementing a JSON parser
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候实现 JSON 解析器了
- en: 'Let''s extend the `PlayerInfoJSON` class and equip it with a reverse conversion:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展 `PlayerInfoJSON` 类并为其添加反向转换：
- en: '[PRE60]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'First, we read the document and check whether it is valid and holds the expected
    array. Upon failure, an empty structure is returned; otherwise, `readPlayerInfo`
    is called and is given `QJsonArray` to work with:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们读取文档并检查它是否有效以及是否包含预期的数组。如果失败，则返回空结构；否则，调用 `readPlayerInfo` 并提供 `QJsonArray`
    进行操作：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Since the array is iterable, we can again use `foreach` to iterate it and use
    another method—`readPlayer`—to extract all the needed data:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组是可迭代的，我们再次可以使用 `foreach` 来迭代它，并使用另一个方法——`readPlayer`——来提取所有所需的数据：
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In this function, we used `QJsonObject::value()` to extract data from the object
    and then we used different functions to convert the data to the desired type.
    Note that in order to convert to `QPoint`, we first converted it to `QVariantMap`
    and then extracted the values before using them to build `QPoint`. In each case,
    if the conversion fails, we get a default value for that type (for example, an
    empty string). To read the inventory, we employ a custom method:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用 `QJsonObject::value()` 从对象中提取数据，然后使用不同的函数将数据转换为所需的类型。请注意，为了转换为 `QPoint`，我们首先将其转换为
    `QVariantMap`，然后提取值，在构建 `QPoint` 之前使用它们。在每种情况下，如果转换失败，我们都会得到该类型的默认值（例如，一个空字符串）。为了读取库存，我们采用自定义方法：
- en: '[PRE63]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'What remains is to implement `readItem()`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是实现 `readItem()`：
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '*What just happened?*'
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: The class that was implemented can be used for bidirectional conversion between
    `Item` instances and a `QByteArray` object, which contains the object data in
    the JSON format. We didn't do any error checking here; instead, we relied on automatic
    type conversion handling in `QJsonObject` and `QVariant`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的类可用于在 `Item` 实例和包含对象数据的 JSON 格式的 `QByteArray` 对象之间进行双向转换。在这里我们没有进行任何错误检查；相反，我们依赖于
    `QJsonObject` 和 `QVariant` 中的自动类型转换处理。
- en: QSettings
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: QSettings
- en: 'While not strictly a serialization issue, the aspect of storing application
    settings is closely related to the described subject. A Qt solution for this is
    the `QSettings` class. By default, it uses different backends on different platforms,
    such as system registry on Windows or INI files on Linux. The basic use of `QSettings`
    is very easy—you just need to create the object and use `setValue()` and `value()`
    to store and load data from it:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这严格来说不是一个序列化问题，但存储应用程序设置的方面与描述的主题密切相关。Qt 的解决方案是 `QSettings` 类。默认情况下，它在不同平台上使用不同的后端，例如
    Windows 上的系统注册表或 Linux 上的 INI 文件。`QSettings` 的基本用法非常简单——你只需要创建对象并使用 `setValue()`
    和 `value()` 来存储和加载数据：
- en: '[PRE65]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The only thing you need to remember is that it operates on `QVariant`, so the
    return value needs to be converted to the proper type if needed as shown in the
    last line of the preceding code. A call to `value()` can take an additional argument
    that contains the value to be returned if the requested key is not present in
    the map. This allows you to handle default values, for example, in a situation
    when the application is first started and the settings are not saved yet:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住的唯一一点是它操作的是`QVariant`，因此如果需要，返回值需要转换为正确的类型，如前述代码的最后一行所示。如果请求的键不在映射中，`value()`调用可以接受一个额外的参数，该参数包含要返回的值。这允许你在默认值的情况下进行处理，例如，当应用程序首次启动且设置尚未保存时：
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The simplest scenario assumes that settings are "flat" in the way that all
    keys are defined on the same level. However, this does not have to be the case—correlated
    settings can be put into named groups. To operate on a group, you can use the
    `beginGroup()` and `endGroup()` calls:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况假设设置是“扁平”的，即所有键都在同一级别上定义。然而，这不必是这种情况——相关的设置可以放入命名的组中。要操作一个组，你可以使用`beginGroup()`和`endGroup()`调用：
- en: '[PRE67]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When using this syntax, you have to remember to end the group after you are
    done with it. An alternative to using the two mentioned methods is to pass the
    group name directly to invocation of `value()`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此语法时，你必须记住在完成操作后结束组。除了使用前面提到的两种方法之外，还可以直接将组名传递给`value()`调用的调用：
- en: '[PRE68]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As was mentioned earlier, `QSettings` can use different backends on different
    platforms; however, we can have some influence on which is chosen and which options
    are passed to it by passing appropriate options to the constructor of the `settings`
    object. By default, the place where the settings for an application are stored
    is determined by two values—the organization and the application name. Both are
    textual values and both can be passed as arguments to the `QSettings` constructor
    or defined a priori using appropriate static methods in `QCoreApplication`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`QSettings`可以在不同的平台上使用不同的后端；然而，我们可以通过向`settings`对象的构造函数传递适当的选项来影响选择哪个后端以及传递哪些选项给它。默认情况下，应用程序设置存储的位置由两个值决定——组织名称和应用程序名称。这两个都是文本值，都可以作为参数传递给`QSettings`构造函数，或者使用`QCoreApplication`中的适当静态方法预先定义：
- en: '[PRE69]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This code is equivalent to:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码等同于：
- en: '[PRE70]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'All of the preceding code use the default backend for the system. However,
    it is often desirable to use a different backend. This can be done using the `Format`
    argument, where we can pass one of the two options—`NativeFormat` or `IniFormat`.
    The former chooses the default backend, while the latter forces the INI-file backend.
    When choosing the backend, you can also decide whether settings should be saved
    in a system-wide location or in the user''s settings storage by passing one more
    argument—the scope of which can be either `UserScope` or `SystemScope`. This can
    extend our final construction call to:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述代码都使用了系统的默认后端。然而，通常希望使用不同的后端。这可以通过`Format`参数来完成，其中我们可以传递两个选项之一——`NativeFormat`或`IniFormat`。前者选择默认后端，而后者强制使用INI文件后端。在选择后端时，你还可以决定是否应该将设置保存在系统范围内的位置或用户的设置存储中，通过传递另一个参数——其作用域可以是`UserScope`或`SystemScope`。这可以扩展我们的最终构造调用为：
- en: '[PRE71]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'There is one more option available for total control of where the settings
    data resides—tell the constructor directly where the data should be located:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个选项可以完全控制设置数据的位置——直接告诉构造函数数据应该位于何处：
- en: '[PRE72]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Tip
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `QStandardPaths` class provides methods to determine standard locations
    for files depending on the task at hand.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`QStandardPaths`类提供了根据任务确定文件标准位置的方法。'
- en: '`QSettings` also allows you to register your own formats so that you can control
    the way your settings are stored—for example, by storing them using XML or by
    adding on-the-fly encryption. This is done using `QSettings::registerFormat()`,
    where you need to pass the file extension and two pointers to functions that perform
    reading and writing of the settings, respectively, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSettings`还允许你注册自己的格式，以便你可以控制设置存储的方式——例如，通过使用XML存储或添加即时加密。这是通过`QSettings::registerFormat()`完成的，你需要传递文件扩展名和两个函数指针，分别用于读取和写入设置，如下所示：'
- en: '[PRE73]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Pop quiz – Qt core essentials
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速测验 - Qt核心要点
- en: Q1\. What is the closest equivalent `std::string` in Qt?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 在Qt中，`std::string`最接近的等效是什么？
- en: '`QString`'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QString`'
- en: '`QByteArray`'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QByteArray`'
- en: '`QStringLiteral`'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QStringLiteral`'
- en: Q2\. Which regular expression can be used to validate an IPv4 address, which
    is an address composed of four dot-separated decimal numbers with values ranging
    from 0 to 255?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 哪个正则表达式可以用来验证一个IPv4地址，IPv4地址是由四个用点分隔的十进制数字组成，其值范围在0到255之间？
- en: Q3\. Which do you think is the best serialization mechanism to use if you expect
    the data structure to evolve (gain new information) in future versions of the
    software?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 如果你预计数据结构将在软件的未来版本中演变（获取新信息），你认为使用哪种序列化机制是最好的？
- en: JSON
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSON
- en: XML
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XML
- en: QDataStream
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: QDataStream
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned a number of core Qt technologies ranging from text
    manipulation, to accessing devices that can be used to transfer or store data
    using a number of popular technologies such as XML or JSON. You should be aware
    that we have barely scratched the surface of what Qt offers and there are many
    other interesting classes you should familiarize yourself with but this minimum
    amount of information should give you a head start and show you the direction
    to follow with your future research.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了从文本操作到访问可以使用XML或JSON等流行技术传输或存储数据的设备的一系列核心Qt技术。你应该意识到，我们只是触及了Qt所能提供的一小部分，还有许多其他有趣的类你需要熟悉。但这个最小量的信息应该能给你一个良好的起点，并展示你未来研究的方向。
- en: In the next chapter, we will switch from describing data manipulation, which
    can be visualized using text or only in your imagination, to a more appealing
    media. We will start talking about graphics and how to transfer what you can see
    in your imagination to the screen of your computer.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从描述数据操作（可以使用文本或仅凭想象力进行可视化）转换到一个更吸引人的媒体。我们将开始讨论图形，以及如何将你想象中看到的内容传输到电脑屏幕上。
