<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;An Introduction to Real-time Graphics Rendering on a Mobile Platform using OpenGL ES 3.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. An Introduction to Real-time Graphics Rendering on a Mobile Platform using OpenGL ES 3.0</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up the Android SDK</li><li class="listitem" style="list-style-type: disc">Setting up the <a id="id295" class="indexterm"/><span class="strong"><strong>Android Native Development Kit</strong></span> (<span class="strong"><strong>NDK</strong></span>)</li><li class="listitem" style="list-style-type: disc">Developing a basic framework to integrate the Android NDK</li><li class="listitem" style="list-style-type: disc">Creating your first Android application with OpenGL ES 3.0</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Introduction</h1></div></div></div><p>In this chapter, we will transition to an increasingly powerful and ubiquitous computing platform by demonstrating how to visualize data on the latest mobile devices, from smart phones to tablets, using <span class="strong"><strong>OpenGL for Embedded Systems</strong></span> (<span class="strong"><strong>OpenGL ES</strong></span>). As mobile devices become more <a id="id296" class="indexterm"/>ubiquitous and with their increasing computing capability, we now have an unprecedented opportunity to develop novel interactive data visualization tools using high-performance graphics hardware directly integrated into modern mobile devices. </p><p>OpenGL ES plays an important role in standardizing the 2D and 3D graphics APIs to allow the large-scale deployment of mobile applications on embedded systems with various hardware settings. Among the various mobile platforms (predominantly Google Android, Apple iOS, and Microsoft Windows Phone), the Android mobile operating system is currently one of the most popular ones. Therefore, in this chapter, we will focus primarily on the development of an Android-based application (API 18 and higher) using OpenGL ES 3.0, which provides a newer version of GLSL support (including full support for integer and 32-bit floating point operations) and enhanced texture rendering support. Nevertheless, OpenGL ES 3.0 is also supported on other mobile platforms, such as Apple iOS and Microsoft Phone.</p><p>Here, we will first introduce how to set up the Android development platform, including the SDK that provides the essential tools to build mobile applications, and the NDK, which enables the use of native-code languages (C/C++) for high-performance scientific computing and simulations by exploiting direct hardware acceleration. We will provide a script to simplify the process of deploying your first Android-based application on your mobile device.</p></div></div>
<div class="section" title="Setting up the Android SDK"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Setting up the Android SDK</h1></div></div></div><p>The Google Android OS website <a id="id297" class="indexterm"/>provides a standalone package for Android application development called the <span class="strong"><strong>Android SDK</strong></span>. It contains all the necessary compilation and <a id="id298" class="indexterm"/>debugging tools to develop an Android application (except native code support, which is provided by the Android NDK). The upcoming steps explain the installation procedure in Mac OS X or, similarly, in Linux, with minor modifications to the script and binary packages required.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec118"/>How to do it...</h2></div></div></div><p>To install the Android SDK, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the<a id="id299" class="indexterm"/> standalone package from the Android Developers website at <a class="ulink" href="http://dl.google.com/android/android-sdk_r24.3.3-macosx.zip">http://dl.google.com/android/android-sdk_r24.3.3-macosx.zip</a>.</li><li class="listitem">Create a new directory called <code class="literal">3rd_party/android</code> and move the setup file into this folder:<div class="informalexample"><pre class="programlisting">mkdir 3rd_party/android
mv android-sdk_r24.3.3-macosx.zip 3rd_party/android </pre></div></li><li class="listitem">Unzip the package:<div class="informalexample"><pre class="programlisting">cd 3rd_party/android &amp;&amp; unzip android-sdk_r24.3.3-macosx.zip</pre></div></li><li class="listitem">Execute the Android SDK Manager:<div class="informalexample"><pre class="programlisting">./android-sdk-macosx/tools/android</pre></div></li><li class="listitem">Select <span class="strong"><strong>Android 4.3.1 (API 18)</strong></span> from the list of packages in addition to the default options. Deselect <span class="strong"><strong>Android M (API22, MBC preview)</strong></span> and <span class="strong"><strong>Android 5.1.1 (API 22)</strong></span>. Press the <span class="strong"><strong>Install 9 packages...</strong></span> button on the <span class="strong"><strong>Android SDK Manager</strong></span> screen, as shown here:<div class="mediaobject"><img src="graphics/9727OS_07_01.jpg" alt="How to do it..."/></div></li><li class="listitem">Select <span class="strong"><strong>Accept</strong></span><a id="id300" class="indexterm"/><span class="strong"><strong> License</strong></span> and click on the <span class="strong"><strong>Install</strong></span> button:<div class="mediaobject"><img src="graphics/9727OS_07_02.jpg" alt="How to do it..."/></div></li><li class="listitem">To verify the installation, type the following command into the terminal:<div class="informalexample"><pre class="programlisting">./android-sdk-macosx/tools/android list</pre></div></li><li class="listitem">This is an example<a id="id301" class="indexterm"/> that illustrates the successful installation of the Android 4.3.1 platform:<div class="informalexample"><pre class="programlisting">Available Android targets:
----------
id: 1 or "android-18"
Name: Android 4.3.1
Type: Platform
API level: 18
Revision: 3
Skins: HVGA, QVGA, WQVGA400, WQVGA432, WSVGA, WVGA800 (default), WVGA854, WXGA720, WXGA800, WXGA800-7in
Tag/ABIs : default/armeabi-v7a, default/x86
...</pre></div></li><li class="listitem">Finally, we will install Apache Ant to automate the software build process for Android application development. We can easily obtain the Apache Ant package by using<a id="id302" class="indexterm"/> MacPort with the command line or from its official website at <a class="ulink" href="http://ant.apache.org/">http://ant.apache.org/</a>:<div class="informalexample"><pre class="programlisting">sudo port install apache-ant</pre></div></li></ol></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec119"/>See also</h2></div></div></div><p>To install the Android SDK in Linux or Windows, download the corresponding installation files and follow the<a id="id303" class="indexterm"/> instructions on the Android developer website at <a class="ulink" href="https://developer.android.com/sdk/index.html">https://developer.android.com/sdk/index.html</a>.</p><p>The setup procedures to<a id="id304" class="indexterm"/> set up the Android SDK in Linux are essentially identical using the command-line interface, except that a different standalone package should be <a id="id305" class="indexterm"/>downloaded using this link: <a class="ulink" href="http://dl.google.com/android/android-sdk_r24.3.3-linux.tgz">http://dl.google.com/android/android-sdk_r24.3.3-linux.tgz</a>.</p><p>In addition, for Windows users, the standalone<a id="id306" class="indexterm"/> package can be obtained using this link: <a class="ulink" href="http://dl.google.com/android/installer_r24.3.3-windows.exe">http://dl.google.com/android/installer_r24.3.3-windows.exe</a>.</p><p>To verify that your mobile phone has proper OpenGL ES 3.0 support, consult the Android documentation on how<a id="id307" class="indexterm"/> to check the OpenGL ES version at runtime: <a class="ulink" href="http://developer.android.com/guide/topics/graphics/opengl.html#version-check">http://developer.android.com/guide/topics/graphics/opengl.html#version-check</a>.</p></div></div>
<div class="section" title="Setting up the Android Native Development Kit (NDK)"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Setting up the Android Native Development Kit (NDK)</h1></div></div></div><p>The Android NDK environment is essential for native-code language development. Here, we will outline the setup <a id="id308" class="indexterm"/>steps for the Mac OS X platform again.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec120"/>How to do it...</h2></div></div></div><p>To install the Android NDK, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the<a id="id309" class="indexterm"/> NDK installation package from the Android developer website at <a class="ulink" href="http://dl.google.com/android/ndk/android-ndk-r10e-darwin-x86_64.bin">http://dl.google.com/android/ndk/android-ndk-r10e-darwin-x86_64.bin</a>.</li><li class="listitem">Move the setup file into the same installation folder:<div class="informalexample"><pre class="programlisting">mv android-ndk-r10e-darwin-x86_64.bin 3rd_party/android </pre></div></li><li class="listitem">Set the permission of the file to be an executable:<div class="informalexample"><pre class="programlisting">cd 3rd_party/android &amp;&amp; chmod +x android-ndk-r10e-darwin-x86_64.bin</pre></div></li><li class="listitem">Run the NDK installation package:<div class="informalexample"><pre class="programlisting">./android-ndk-r10e-darwin-x86_64.bin</pre></div></li><li class="listitem">The installation process is fully automated and the following output confirms the successful installation of the Android NDK:<div class="informalexample"><pre class="programlisting">...
Extracting  android-ndk-r10e/build/tools
Extracting  android-ndk-r10e/build/gmsl
Extracting  android-ndk-r10e/build/core
Extracting  android-ndk-r10e/build/awk
Extracting  android-ndk-r10e/build
Extracting  android-ndk-r10e

Everything is Ok</pre></div></li></ol></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec121"/>See also</h2></div></div></div><p>To install the Android <a id="id310" class="indexterm"/>NDK on Linux or Windows, download the corresponding installation files and follow the instructions on the Android developer <a id="id311" class="indexterm"/>website at <a class="ulink" href="https://developer.android.com/tools/sdk/ndk/index.html">https://developer.android.com/tools/sdk/ndk/index.html</a>.</p></div></div>
<div class="section" title="Developing a basic framework to integrate the Android NDK"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Developing a basic framework to integrate the Android NDK</h1></div></div></div><p>Now that we have <a id="id312" class="indexterm"/>successfully installed the Android SDK and NDK, we will demonstrate how to develop a basic framework to integrate native C/C++ code into a Java-based Android application. Here, we describe the general mechanism to create high-performance code for <a id="id313" class="indexterm"/>deployment on mobile devices using OpenGL ES 3.0.</p><p>OpenGL ES 3.0 supports both Java and C/C++ interfaces. Depending on the specific requirements of the application, you may choose to implement the solution in Java due to its flexibility and portability. For high-performance computing and applications that require a high memory bandwidth, it is preferable that you use the NDK for fine-grain optimization and memory management. In addition, we can port our existing libraries, such as OpenCV with Android NDK, using static library linking. The cross-platform compilation capability opens up many possibilities for real-time image and signal processing on a mobile platform with minimal development effort.</p><p>Here, we introduce a basic framework that consists of three classes: <code class="literal">GL3JNIActivity</code>, <code class="literal">GL3JNIView</code>, and <code class="literal">GL3JNIActivity</code>. We show a simplified class diagram in the following figure, illustrating<a id="id314" class="indexterm"/> the relationship between the classes. The native code (C/C++) is implemented separately and will be described in detail in the next section:</p><div class="mediaobject"><img src="graphics/9727OS_07_03.jpg" alt="Developing a basic framework to integrate the Android NDK"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec122"/>How to do it...</h2></div></div></div><p>First, we will create the <a id="id315" class="indexterm"/>core Java source files that are essential to an Android application. These files serve as a wrapper for our OpenGL ES 3.0 native code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the project directory, create a folder named <code class="literal">src/com/android/gl3jni</code> with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mkdir src/com/android/gl3jni</strong></span>
</pre></div></li><li class="listitem">Create the first class, <code class="literal">GL3JNIActivity</code>, in the Java source file, <code class="literal">GL3JNIActivity.java</code>, within the new folder, <code class="literal">src/com/android/gl3jni/</code>:<div class="informalexample"><pre class="programlisting">package com.android.gl3jni;

import android.app.Activity;
import android.os.Bundle;
/**
 * Main application for Android
 */
public class GL3JNIActivity extends Activity {

  GL3JNIView mView;

  @Override protected void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    mView = new GL3JNIView(getApplication());
    setContentView(mView);
  }

  @Override protected void onPause() {
    super.onPause();
    mView.onPause();
  }

  @Override protected void onResume() {
    super.onResume();
    mView.onResume();
  }
}</pre></div></li><li class="listitem">Next, implement<a id="id316" class="indexterm"/> the <code class="literal">GL3JNIView</code> class, which handles the OpenGL rendering setup<a id="id317" class="indexterm"/> in the <code class="literal">GL3JNIView.java</code> source file inside <code class="literal">src/com/android/gl3jni/</code>:<div class="informalexample"><pre class="programlisting">package com.android.gl3jni;

import android.content.Context;
import android.opengl.GLSurfaceView;
import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

/**
* A simple application that uses OpenGL ES3 and GLSurface
*/
class GL3JNIView extends GLSurfaceView {
  public GL3JNIView(Context context) {
    super(context);
     /* Pick an EGLConfig with RGB8 color, 16-bit depth, no stencil, supporting OpenGL ES 3.0 or later */
    setEGLConfigChooser(8, 8, 8, 0, 16, 0);
    setEGLContextClientVersion(3);
    setRenderer(new Renderer());
  }
  private static class Renderer implements GLSurfaceView.Renderer {
    public void onDrawFrame(GL10 gl) {
      GL3JNILib.step();
    }

    public void onSurfaceChanged(GL10 gl, int width, int height) {
      GL3JNILib.init(width, height);
    }
    public void onSurfaceCreated(GL10 gl, EGLConfig config) {
    }
  }
}</pre></div></li><li class="listitem">Finally, create the<a id="id318" class="indexterm"/> <code class="literal">GL3JNILib</code> class to handle native library loading and<a id="id319" class="indexterm"/> calling in <code class="literal">GL3JNILib.java</code> inside <code class="literal">src/com/android/gl3jni</code>:<div class="informalexample"><pre class="programlisting">package com.android.gl3jni;

public class GL3JNILib {
  static {
    System.loadLibrary("gl3jni");
  }

  public static native void init(int width, int height);
  public static native void step();
}</pre></div></li><li class="listitem">Now, in the project <a id="id320" class="indexterm"/>directory of the project, add the <code class="literal">AndroidManifest.xml</code> file, which contains all the<a id="id321" class="indexterm"/> essential information about your application on the Android system:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest xmlns:android=
  "http://schemas.android.com/apk/res/android" 
  package="com.android.gl3jni"&gt;
    &lt;application android:label=
    "@string/gl3jni_activity"&gt;
      &lt;activity android:name="GL3JNIActivity"           android:theme=
      "@android:style/Theme.NoTitleBar.Fullscreen" 
      android:launchMode="singleTask"             android:configChanges=
      "orientation|keyboardHidden"&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=
          "android.intent.action.MAIN" /&gt;
                &lt;category android:name=
                  "android.intent.category.LAUNCHER" /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;
    &lt;uses-feature android:glEsVersion="0x00030000"/&gt;
    &lt;uses-sdk android:minSdkVersion="18"/&gt;
&lt;/manifest&gt;</pre></div></li><li class="listitem">In the <code class="literal">res/values/</code> directory, add the <code class="literal">strings.xml</code> file, which saves our application's name:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;
  &lt;string name="gl3jni_activity"&gt;OpenGL ES Demo&lt;/string&gt;
&lt;/resources&gt;</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec123"/>How it works...</h2></div></div></div><p>The following class diagram illustrates the core functions and relationships between the classes. Similar to <a id="id322" class="indexterm"/>all other Android applications with a user interface, we define the <span class="strong"><strong>Activity</strong></span> class, which handles the <a id="id323" class="indexterm"/>core interactions. The implementation of <code class="literal">GL3JNIActivity</code> is straightforward. It captures the events from the Android application (for example, <code class="literal">onPause</code> and <code class="literal">onResume</code>) and also creates an instance of the <code class="literal">GL3JNIView</code> class, which handles graphics rendering. Instead of adding UI elements, such as textboxes or labels, we create a surface based on <code class="literal">GLSurfaceView</code>, which handles hardware-accelerated OpenGL rendering:</p><div class="mediaobject"><img src="graphics/9727OS_07_04.jpg" alt="How it works..."/></div><p>The <code class="literal">GL3JNIView</code> class is a subclass of the <code class="literal">GLSurfaceView</code> class, which provides a dedicated surface for OpenGL rendering. We choose the RGB8 color mode, a 16-bit depth buffer, and no stencil with the <code class="literal">setEGLConfigChooser</code> function and ensure that the environment is set up for OpenGL ES 3.0 by using the <code class="literal">setEGLContextClientVersion</code> function. The <code class="literal">setRenderer</code> function then registers the custom <code class="literal">Renderer</code> class, which is responsible for the actual <a id="id324" class="indexterm"/>OpenGL rendering.</p><p>The <code class="literal">Renderer</code> class implements the key event functions—<code class="literal">onDrawFrame</code>, <code class="literal">onSurfaceChanged</code>, and <code class="literal">onSurfaceCreated</code>—in the rendering loop. These functions connect to the native implementation (C/C++) portion of the code that is handled by the <code class="literal">GL3JNILib</code> class.</p><p>Finally, the <code class="literal">GL3JNILib</code> class creates the interface to communicate with the native code functions. First, it loads the native library named <code class="literal">gl3jni</code>, which contains the actual OpenGL ES 3.0 implementation. The function prototypes, <code class="literal">step</code> and <code class="literal">init</code>, are used to interface with the native code, which will be defined separately in the next section. Note that we can also pass in the canvas width and height values to the native functions as parameters.</p><p>The <code class="literal">AndroidManifest.xml</code><a id="id325" class="indexterm"/> and <code class="literal">strings.xml</code> files are the configuration files required by the Android application, and they must be stored in the root directory of the project in the XML format. The <code class="literal">AndroidManifest.xml</code> file defines all the essential information including the name of the Java package and the declaration of permission requirements (for example, file read/write access), as well as the minimum version of the Android API that the application requires.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec124"/>See also</h2></div></div></div><p>For further information <a id="id326" class="indexterm"/>on Android application development, the Android Developers website provides detailed documentation <a id="id327" class="indexterm"/>on the API at <a class="ulink" href="http://developer.android.com/guide/index.html">http://developer.android.com/guide/index.html</a>.</p><p>For further information on using OpenGL ES within an Android application, the Android programming guide describes the programming workflow in detail and provides useful examples at <a class="ulink" href="http://developer.android.com/training/graphics/opengl/environment.html">http://developer.android.com/training/graphics/opengl/environment.html</a>.</p></div></div>
<div class="section" title="Creating your first Android application with OpenGL ES 3.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec48"/>Creating your first Android application with OpenGL ES 3.0</h1></div></div></div><p>In this section, we<a id="id328" class="indexterm"/> will complete our implementation with native code in C/C++ to create the first Android application with OpenGL ES 3.0. As illustrated in the simplified class diagram, the Java code only provides the<a id="id329" class="indexterm"/> basic interface on the mobile device. Now, on the C/C++ side, we implement all the functionalities previously defined on the Java side and also include all the required libraries from <a id="id330" class="indexterm"/>OpenGL ES 3.0 (inside the <code class="literal">main_simple.cpp</code> file). The <code class="literal">main_simple.cpp</code> file also defines the key interface between the C/C++ and Java side by using the <span class="strong"><strong>Java Native Interface</strong></span> (<span class="strong"><strong>JNI</strong></span>):</p><div class="mediaobject"><img src="graphics/9727OS_07_05.jpg" alt="Creating your first Android application with OpenGL ES 3.0"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec125"/>Getting ready</h2></div></div></div><p>We assume that you have installed all the prerequisite tools from the Android SDK and NDK in addition to<a id="id331" class="indexterm"/> setting up the basic framework introduced in the previous section. Also, you should review the basics <a id="id332" class="indexterm"/>of shader programming, introduced in earlier chapters, before you proceed.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec126"/>How to do it...</h2></div></div></div><p>Here, we describe the implementation of the OpenGL ES 3.0 native code to complete the demo application:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the project directory, create a folder named <code class="literal">jni</code> by using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mkdir jni</strong></span>
</pre></div></li><li class="listitem">Create a file named <code class="literal">main_simple.cpp</code> and store it inside the <code class="literal">jni</code> directory.</li><li class="listitem">Include all necessary header files for JNI and OpenGL ES 3.0:<div class="informalexample"><pre class="programlisting">//header for JNI
#include &lt;jni.h&gt;

//header for the OpenGL ES3 library
#include &lt;GLES3/gl3.h&gt;</pre></div></li><li class="listitem">Include the logging header and define the macros to show the debug messages:<div class="informalexample"><pre class="programlisting">#include &lt;android/log.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

//android error log interface
#define  LOG_TAG    "libgl3jni"
#define  LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
#define  LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)</pre></div></li><li class="listitem">Declare the shader program variables for our demo application:<div class="informalexample"><pre class="programlisting">GLuint gProgram;
GLuint gvPositionHandle;
GLuint gvColorHandle;

int width = 1280;
int height = 720;</pre></div></li><li class="listitem">Define the shader <a id="id333" class="indexterm"/>program code for<a id="id334" class="indexterm"/> the vertex shader and the fragment shader:<div class="informalexample"><pre class="programlisting">// Vertex shader source code
static const char g_vshader_code[] =
  "#version 300 es\n"
    "in vec4 vPosition;\n"
  "in vec4 vColor;\n"
    "out vec4 color;\n"
    "void main() {\n"
      "  gl_Position = vPosition;\n"
      "  color = vColor;\n"
  "}\n";

// fragment shader source code
static const char g_fshader_code[] =
  "#version 300 es\n"
    "precision mediump float;\n"
  "in vec4 color;\n"
    "out vec4 color_out;\n"
    "void main() {\n"
      "  color_out = color;\n"
  "}\n";</pre></div></li><li class="listitem">Implement the error call handlers for OpenGL ES, using the Android log:<div class="informalexample"><pre class="programlisting">/**
 * Print out the error string from OpenGL
 */
static void printGLString(const char *name, GLenum s) {
  const char *v = (const char *) glGetString(s);
  LOGI("GL %s = %s\n", name, v);
}

/**
* Error checking with OpenGL calls
*/
static void checkGlError(const char* op) {
  for (GLint error = glGetError(); error; error
  = glGetError()) {
    LOGI("After %s() glError (0x%x)\n", op, error);
  }
}</pre></div></li><li class="listitem">Implement the <a id="id335" class="indexterm"/>vertex or fragment program-loading mechanisms. The warning and error messages are<a id="id336" class="indexterm"/> redirected to the Android log output:<div class="informalexample"><pre class="programlisting">GLuint loadShader(GLenum shader_type, const char* p_source) {
  GLuint shader = glCreateShader(shader_type);
  if (shader) {
    glShaderSource(shader, 1, &amp;p_source, 0);
    glCompileShader(shader);
    GLint compiled = 0;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compiled);

    //Report error and delete the shader
    if (!compiled) {
      GLint infoLen = 0;
      glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;infoLen);
      if (infoLen) {
        char* buf = (char*) malloc(infoLen);
        if (buf) {
          glGetShaderInfoLog(shader, infoLen, 0, buf);
          LOGE("Could not compile shader %d:\n%s\n", shader_type, buf);
          free(buf);
        }
        glDeleteShader(shader);
        shader = 0;
      }
    }
  }
  return shader;
}</pre></div></li><li class="listitem">Implement the<a id="id337" class="indexterm"/> shader program creation mechanism. The function also attaches and links<a id="id338" class="indexterm"/> the shader program:<div class="informalexample"><pre class="programlisting">GLuint createShaderProgram(const char *vertex_shader_code, const char *fragment_shader_code){
  //create the vertex and fragment shaders
  GLuint vertex_shader_id = loadShader(GL_VERTEX_SHADER, vertex_shader_code);
  if (!vertex_shader_id) {
    return 0;
  }

  GLuint fragment_shader_id = loadShader(GL_FRAGMENT_SHADER, fragment_shader_code);
  if (!fragment_shader_id) {
    return 0;
  }

  GLint result = GL_FALSE;
  //link the program
  GLuint program_id = glCreateProgram();
  glAttachShader(program_id, vertex_shader_id);
  checkGlError("glAttachShader");
  glAttachShader(program_id, fragment_shader_id);
  checkGlError("glAttachShader");
  glLinkProgram(program_id);
  
  //check the program and ensure that the program is linked properly
  glGetProgramiv(program_id, GL_LINK_STATUS, &amp;result);
  if ( result != GL_TRUE ){
    //error handling with Android
    GLint bufLength = 0;
    glGetProgramiv(program_id, GL_INFO_LOG_LENGTH, &amp;bufLength);
    if (bufLength) {
      char* buf = (char*) malloc(bufLength);
      if (buf) {
        glGetProgramInfoLog(program_id, bufLength, 0, buf);
        LOGE("Could not link program:\n%s\n", buf);
        free(buf);
      }
    }
    glDeleteProgram(program_id);
    program_id = 0;
  }
  else {
    LOGI("Linked program Successfully\n");
  }

  glDeleteShader(vertex_shader_id);
  glDeleteShader(fragment_shader_id);

  return program_id;
}</pre></div></li><li class="listitem">Create a function to<a id="id339" class="indexterm"/> handle the initialization. This function is a helper function that handles requests from<a id="id340" class="indexterm"/> the Java side:<div class="informalexample"><pre class="programlisting">bool setupGraphics(int w, int h) {
  printGLString("Version", GL_VERSION);
  printGLString("Vendor", GL_VENDOR);
  printGLString("Renderer", GL_RENDERER);
  printGLString("Extensions", GL_EXTENSIONS);

  LOGI("setupGraphics(%d, %d)", w, h);
  gProgram = createShaderProgram(g_vshader_code, g_fshader_code);
  if (!gProgram) {
    LOGE("Could not create program.");
    return false;
  }
  gvPositionHandle = glGetAttribLocation(gProgram, "vPosition");
  checkGlError("glGetAttribLocation");
  LOGI("glGetAttribLocation(\"vPosition\") = %d\n",
  gvPositionHandle);

  gvColorHandle = glGetAttribLocation(gProgram, "vColor");
  checkGlError("glGetAttribLocation");
  LOGI("glGetAttribLocation(\"vColor\") = %d\n",
  gvColorHandle);

  glViewport(0, 0, w, h);
  width = w;
  height = h;

  checkGlError("glViewport");

  return true;
}</pre></div></li><li class="listitem">Set up the rendering<a id="id341" class="indexterm"/> function that <a id="id342" class="indexterm"/>draws a triangle on the screen with red, green, and blue vertices:<div class="informalexample"><pre class="programlisting">//vertices
GLfloat gTriangle[9]={-1.0f, -1.0f, 0.0f,
  1.0f, -1.0f, 0.0f,
  0.0f, 1.0f, 0.0f};
GLfloat gColor[9]={1.0f, 0.0f, 0.0f,
  0.0f, 1.0f, 0.0f,
  0.0f, 0.0f, 1.0f};

void renderFrame() {
  glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
  checkGlError("glClearColor");

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  checkGlError("glClear");

  glUseProgram(gProgram);
  checkGlError("glUseProgram");
  
  glVertexAttribPointer(gvPositionHandle, 3, GL_FLOAT, GL_FALSE, 0, gTriangle);
  checkGlError("glVertexAttribPointer");

  glVertexAttribPointer(gvColorHandle, 3, GL_FLOAT, GL_FALSE, 0, gColor);
  checkGlError("glVertexAttribPointer");

  glEnableVertexAttribArray(gvPositionHandle);
  checkGlError("glEnableVertexAttribArray");

  glEnableVertexAttribArray(gvColorHandle);
  checkGlError("glEnableVertexAttribArray");

  glDrawArrays(GL_TRIANGLES, 0, 9);
  checkGlError("glDrawArrays");
}</pre></div></li><li class="listitem">Define the JNI<a id="id343" class="indexterm"/> prototypes that connect to the Java side. These calls are the interfaces to communicate between<a id="id344" class="indexterm"/> the Java code and the C/C++ native code:<div class="informalexample"><pre class="programlisting">//external calls for Java
extern "C" {
  JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_init(JNIEnv * env, jobject obj, jint width, jint height);
  JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_step(JNIEnv * env, jobject obj);
};</pre></div></li><li class="listitem">Set up the internal function calls with the helper functions:<div class="informalexample"><pre class="programlisting">//link to internal calls
JNIEXPORT void JNICALL 
Java_com_android_gl3jni_GL3JNILib_init(JNIEnv * env, 
  jobject obj, jint width, jint height)
{
  setupGraphics(width, height);
}

JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_step(JNIEnv * env, jobject obj)
{
  renderFrame();
}
//end of file</pre></div></li><li class="listitem">Now that we have completed the implementation of the native code, we must compile the code and link it to the Android application. To compile the code, create a <code class="literal">build</code> file that is similar to a <code class="literal">Makefile</code>, called <code class="literal">Android.mk</code>, in the <code class="literal">jni</code> folder:<div class="informalexample"><pre class="programlisting">LOCAL_PATH:= $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := libgl3jni
LOCAL_CFLAGS    := -Werror
#for simplified demo
LOCAL_SRC_FILES := main_simple.cpp
LOCAL_LDLIBS    := -llog -lGLESv3

include $(BUILD_SHARED_LIBRARY)</pre></div></li><li class="listitem">In addition, we<a id="id345" class="indexterm"/> must create an <code class="literal">Application.mk</code> file that provides information about the build type, such as the <a id="id346" class="indexterm"/><span class="strong"><strong>Application Binary Interface</strong></span> (<span class="strong"><strong>ABI</strong></span>). The <code class="literal">Application.mk</code> file must<a id="id347" class="indexterm"/> be stored inside the <code class="literal">jni</code> directory:<div class="informalexample"><pre class="programlisting">APP_ABI := armeabi-v7a
#required for GLM and other static libraries
APP_STL := gnustl_static</pre></div></li><li class="listitem">At this point, we should have the following list of files in the root directory:<div class="informalexample"><pre class="programlisting">src/com/android/gl3jni/GL3JNIActivity.java
src/com/android/gl3jni/GL3JNILib.java
src/com/android/gl3jni/GL3JNIView.java
AndroidManifest.xml
res/value/strings.xml
jni/Android.mk
jni/Application.mk
jni/main_simple.cpp</pre></div></li></ol></div><p>To compile the native source code and deploy our application on a mobile phone, run the following <code class="literal">build</code> script in the terminal, which is shown as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Set up our environment variables for the SDK and the NDK. (Note that the following relative paths assume that the SDK and NDK are installed 3 levels outside the current directory, where the <code class="literal">compile.sh</code> and <code class="literal">install.sh</code> scripts are executed in the code package. These paths should be modified to match your code directory structure as necessary.):<div class="informalexample"><pre class="programlisting">export ANDROID_SDK_PATH="../../../3rd_party/android/android-sdk-macosx"
export ANDROID_NDK_PATH="../../../3rd_party/android/android-ndk-r10e"</pre></div></li><li class="listitem">Initialize the project with the android <code class="literal">update</code> command for the first-time compilation. This will generate all the necessary files (such as the <code class="literal">build.xml</code> file) for later steps:<div class="informalexample"><pre class="programlisting">$ANDROID_SDK_PATH/tools/android update project -p . -s --target "android-18"</pre></div></li><li class="listitem">Compile the JNI native code with the <code class="literal">build</code> command:<div class="informalexample"><pre class="programlisting">$ANDROID_NDK_PATH/ndk-build</pre></div></li><li class="listitem">Run the <code class="literal">build</code> command. Apache<a id="id348" class="indexterm"/> Ant takes the <code class="literal">build.xml</code> script and builds the <span class="strong"><strong>Android Application Package</strong></span> (<span class="strong"><strong>APK</strong></span>) file that is ready for deployment:<div class="informalexample"><pre class="programlisting">ant debug</pre></div></li><li class="listitem">Install the Android<a id="id349" class="indexterm"/> application by using the <a id="id350" class="indexterm"/><span class="strong"><strong>Android Debug Bridge</strong></span> (<span class="strong"><strong>adb</strong></span>) command:<div class="informalexample"><pre class="programlisting">$ANDROID_SDK_PATH/platform-tools/adb install -r bin/GL3JNIActivity-debug.apk</pre></div></li></ol></div><p>For this command to work, before connecting the mobile device through the USB port, ensure that the USB<a id="id351" class="indexterm"/> Debugging mode is enabled and accept any prompts for security-related warnings. On most devices, you can find this option by navigating to <span class="strong"><strong>Settings</strong></span> | <span class="strong"><strong>Applications</strong></span> | <span class="strong"><strong>Development</strong></span> or <span class="strong"><strong>Settings</strong></span> | <span class="strong"><strong>Developer</strong></span>. However, on Android 4.2 or higher, this option is hidden by default and must be enabled by navigating to <span class="strong"><strong>Settings</strong></span> | <span class="strong"><strong>About Phone</strong></span> (or <span class="strong"><strong>About Tablet</strong></span>) and tapping <span class="strong"><strong>Build Number</strong></span> multiple times. For further details, follow the instructions provided on the official <a id="id352" class="indexterm"/>Android Developer website at <a class="ulink" href="http://developer.android.com/tools/device.html">http://developer.android.com/tools/device.html</a>. Here is a sample screenshot of an Android phone with the USB debugging mode successfully configured:</p><div class="mediaobject"><img src="graphics/9727OS_07_06.jpg" alt="How to do it..."/></div><p>After the application<a id="id353" class="indexterm"/> is installed, we can execute the <a id="id354" class="indexterm"/>application as we normally do with any other Android application by opening it directly using the application icon on the phone, as shown here:</p><div class="mediaobject"><img src="graphics/9727OS_07_07.jpg" alt="How to do it..."/></div><p>A screenshot after launching the application is <a id="id355" class="indexterm"/>shown next. Note that the CPU monitor has been enabled to show the CPU utilization. This is<a id="id356" class="indexterm"/> not enabled by default but can be found in <span class="strong"><strong>Developer Options</strong></span>. The application supports both the portrait and landscape modes and the graphics automatically scale to the window size upon changing the frame buffer size:</p><div class="mediaobject"><img src="graphics/9727OS_07_08.jpg" alt="How to do it..."/></div><p>Here is another<a id="id357" class="indexterm"/> screenshot of the<a id="id358" class="indexterm"/> landscape mode:</p><div class="mediaobject"><img src="graphics/9727OS_07_09.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec127"/>How it works...</h2></div></div></div><p>This chapter demonstrates the portability of our approach in previous chapters. Essentially, the native code developed in this chapter resembles what we covered in previous chapters. In particular, the shader program's creation and loading mechanism is virtually identical, except that we have used a predefined string (<code class="literal">static char[]</code>) to simplify the complexity<a id="id359" class="indexterm"/> of loading files in Android. However, there are some subtle differences. Here, we will list the differences and new features.</p><p>In the fragment program and vertex program, we need to add the <code class="literal">#version 300 es</code> directive to ensure that the <a id="id360" class="indexterm"/>shader code can access the new features, such as uniform blocks and the full support of integer and floating point operations. For example, OpenGL ES 3.0 replaces the attribute and varying qualifiers with the <span class="strong"><strong>in</strong></span> and <span class="strong"><strong>out</strong></span> keywords. This standardization allows much faster code development of OpenGL on various platforms.</p><p>The other notable difference is that we have replaced the GLFW library completely with the EGL library, which comes as a standard library in Android, for context management. All event handling, such as Windows management and user inputs, are now handled through the Android API and the native code is only responsible for graphics rendering.</p><p>The Android log and error reporting system is now accessible through the Android <code class="literal">adb</code> program. The interaction is similar to a terminal output, and we can see the log in real time with the following command:</p><div class="informalexample"><pre class="programlisting">adb logcat </pre></div><p>For example, our application reports the OpenGL ES version, as well as the extensions supported by the mobile device in the log. With the preceding command, we can extract the following information:</p><div class="informalexample"><pre class="programlisting">I/libgl3jni( 6681): GL Version = OpenGL ES 3.0 V@66.0 AU@04.04.02.048.042 LNXBUILD_AU_LINUX_ANDROID_LNX.LA.3.5.1_RB1.04.04.02.048.042+PATCH[ES]_msm8974_LNX.LA.3.5.1_RB1__release_ENGG (CL@)
I/libgl3jni( 6681): GL Vendor = Qualcomm
I/libgl3jni( 6681): GL Renderer = Adreno (TM) 330
I/libgl3jni( 6681): GL Extensions = GL_AMD_compressed_ATC_texture GL_AMD_performance_monitor GL_AMD_program_binary_Z400 GL_EXT_debug_label GL_EXT_debug_marker GL_EXT_discard_framebuffer GL_EXT_robustness GL_EXT_texture_format_BGRA8888 GL_EXT_texture_type_2_10_10_10_REV GL_NV_fence GL_OES_compressed_ETC1_RGB8_texture GL_OES_depth_texture GL_OES_depth24 GL_OES_EGL_image GL_OES_EGL_image_external GL_OES_element_index_uint GL_OES_fbo_render_mipmap GL_OES_fragment_precision_high GL_OES_get_program_binary GL_OES_packed_depth_stencil GL_OES_depth_texture_cube_map GL_OES_rgb8_rgba8 GL_OES_standard_derivatives GL_OES_texture_3D GL_OES_texture_float GL_OES_texture_half_float GL_OES_texture_half_float_linear GL_OES_texture_npot GL_OES_vertex_half_float GL_OES_vertex_type_10_10_10_2 GL_OES_vertex_array_object GL_QCOM_alpha_test GL_QCOM_binning_control GL_QCOM_driver_control GL_QCOM_perfmon_global_mode GL_QCOM_extended_get GL_QCOM_extended_get2 GL_QCOM_tiled_rendering GL_QCOM_writeonly_rendering GL_EXT_sRGB GL_EXT_sRGB_write_control GL_EXT_
I/libgl3jni( 6681): setupGraphics(1440, 2560)</pre></div><p>The real-time log data is very useful for debugging and can allow developers to quickly analyze the problem.</p><p>One common question is<a id="id361" class="indexterm"/> how the Java and C/C++ elements communicate with each other. The JNI syntax is rather puzzling to understand in the first place, but we can decode it by carefully analyzing the following code snippet:</p><div class="informalexample"><pre class="programlisting">JNIEXPORT void JNICALL Java_com_android_gl3jni_GL3JNILib_init
(JNIEnv *env, jobject obj, jint width, jint height)</pre></div><p>The <code class="literal">JNIEXPORT</code> and <code class="literal">JNICALL</code> tags allow the functions to be located in the shared library at runtime. The<a id="id362" class="indexterm"/> class name is specified by <code class="literal">com_android_gl3jni_GL3JNILib</code> (<code class="literal">com.android.gl3jni.GL3JNILib</code>), and <code class="literal">init</code> is the method name of the Java native function. As we can see, the period in the class name is replaced by an underscore. In addition, we have two additional parameters, namely the width and height of the frame buffer. More parameters can be simply appended to the end of the parameters' list in the function, as required.</p><p>In terms of backward compatibility, we can see that OpenGL 4.3 is a complete superset of OpenGL ES 3.0. In OpenGL 3.1 and higher, we can see that the embedded system version of OpenGL and the standard Desktop version of OpenGL are slowly converging, which reduces the<a id="id363" class="indexterm"/> underlying complexity<a id="id364" class="indexterm"/> in maintaining various versions of OpenGL in the application life cycle.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec128"/>See also</h2></div></div></div><p>A detailed description of the Android OS architecture is beyond the scope of this book. However, you are encouraged to <a id="id365" class="indexterm"/>consult the official developer workflow guide at <a class="ulink" href="http://developer.android.com/tools/workflow/index.html">http://developer.android.com/tools/workflow/index.html</a>.</p><p>Further information on the OpenGL ES Shading Language can be found at <a class="ulink" href="https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf">https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf</a>.</p></div></div></body></html>