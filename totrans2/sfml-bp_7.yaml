- en: Chapter 7. Building a Real-time Tower Defense Game from Scratch – Part 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。从零开始构建实时塔防游戏 - 第1部分
- en: Now that you have all the basic tools, it's time for us to build something new.
    What about a mix of a **Real Time Strategy** (**RTS**) and a tower defense? And
    what about making it a multiplayer game? You like these ideas? Great! This is
    exactly what we will start building.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了所有基本工具，是时候我们来构建一些新的东西了。比如，一个结合了**实时策略**（**RTS**）和塔防的游戏怎么样？再考虑一下让它成为一个多人游戏？你喜欢这些想法吗？太好了！这正是我们将开始构建的内容。
- en: 'As this project is much more consequent than all the others, it will be split
    in two parts. The first one will focus on the game mechanism and logic, and the
    second on the multiplayer layer. So, in this chapter we will do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个项目比其他所有项目都要复杂得多，它将被分为两部分。第一部分将专注于游戏机制和逻辑，第二部分将专注于多人层。因此，在本章中，我们将做以下事情：
- en: Create animations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动画
- en: Build and use a generic map system with tile model and dynamic loading
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建并使用具有瓦片模型和动态加载的通用地图系统
- en: Build an entity system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建实体系统
- en: Make the game's logic
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定游戏逻辑
- en: This project will reuse a lot of the components made previously, such as `ActionTarget`,
    `ResourceManager`, our GUI, and the game loop. To allow you to reuse these components
    easily for future projects, they have been gathered into a single framework (`SFML-utils`)
    that has been separated from the code in this book. This framework is available
    on the GitHub website at [https://github.com/Krozark/SFML-utils](https://github.com/Krozark/SFML-utils),
    due to which these components have been moved from the book namespace to `SFML-utils`.
    Moreover, the map and entity systems that will be explained in this chapter are
    also part of this framework.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将重用之前制作的许多组件，例如`ActionTarget`、`ResourceManager`、我们的GUI和游戏循环。为了让你能够轻松地将这些组件用于未来的项目，它们已经被收集到一个单独的框架（`SFML-utils`）中，这个框架已经从本书的代码中分离出来。这个框架可以在GitHub网站上找到，网址为[https://github.com/Krozark/SFML-utils](https://github.com/Krozark/SFML-utils)，因此这些组件已经从本书的命名空间移动到了`SFML-utils`。此外，本章将解释的地图和实体系统也是这个框架的一部分。
- en: 'The final result of this chapter will look as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最终结果将如下所示：
- en: '![Building a Real-time Tower Defense Game from Scratch – Part 1](img/8477OS_07_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![从零开始构建实时塔防游戏 - 第1部分](img/8477OS_07_01.jpg)'
- en: The goal of the game
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏的目标
- en: First of all, let's explain our goal. As we said previously, we will build a
    new game that will be a mix of a real-time strategy game and tower defense.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们解释我们的目标。正如我们之前所说的，我们将构建一个新游戏，它将是一个实时策略游戏和塔防的结合。
- en: The idea is that each team starts with some money/gold and a main building named
    GQ. When a team loses all its GQ, it loses the game. The money can be spent to
    build other buildings with different abilities, or to upgrade them. For example,
    some of the buildings will spawn warriors who will attack the enemies; other buildings
    will only defend the surrounding area. There is also a restriction concerning
    the area where new buildings can be made. In fact, you can only place a new building
    around your team's existing buildings. This keeps you from placing a big tower
    in the center of the enemy camp at the start of the game. It's also important
    to notice that once a building is built, you don't control its behavior just as
    you don't control the different warriors spawn by it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是每个队伍开始时都有一笔钱/金币和一个名为GQ的主要建筑。当一个队伍的所有GQ都被摧毁时，它就输了游戏。这些钱可以用来建造具有不同能力的其他建筑，或者升级它们。例如，一些建筑将产生战士来攻击敌人；其他建筑只会防御周围区域。还有关于可以建造新建筑区域的限制。事实上，你只能在你的队伍现有建筑周围放置新建筑。这防止你在游戏开始时在敌人营地中央放置一个大塔。同样重要的是要注意，一旦建造了建筑，你就不能控制它的行为，就像你不能控制由它产生的不同战士的行为一样。
- en: Also, each time an enemy is destroyed, some gold is added to your gold stock,
    allowing you to build more towers, thus increasing your power to defeat your enemies.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每次摧毁一个敌人，你都会获得一些金币，这让你能够建造更多的塔，从而增强你击败敌人的能力。
- en: 'Now that the game has been introduced, let''s list our needs:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经介绍完毕，让我们列出我们的需求：
- en: '**Resources and event management**: These two features have been created previously,
    so we will just reuse them.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源和事件管理**：这两个特性之前已经创建，所以我们将直接重用它们。'
- en: '**GUI**: This feature has also been developed already in [Chapter 5](ch05.html
    "Chapter 5. Playing with User Interfaces"), *Playing with User Interfaces*. We
    will reuse it as is.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GUI**：这个特性已经在[第5章](ch05.html "第5章。玩转用户界面")中开发完成，即“玩转用户界面”。我们将直接重用它。'
- en: '**Animation**: In SFML, there is no class to manage animated sprites in SFML,
    but for our game, we will need this functionality. So we will build it and add
    it to our framework.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画**：在 SFML 中，没有类来管理动画精灵，但对我们来说，我们需要这个功能。因此，我们将构建它并将其添加到我们的框架中。'
- en: '**Tile map**: This functionality is very important and has to be as flexible
    as possible to allow us to reuse it in many other projects.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瓦片地图**：这个功能非常重要，必须尽可能灵活，以便我们可以在许多其他项目中重用它。'
- en: '**Entity manager**: If you remember, this was introduced in [Chapter 3](ch03.html
    "Chapter 3. Making an Entire 2D Game"), *Making an Entire 2D Game*. Now it''s
    time for us to really see it. This system will avoid a complex inheritance tree.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体管理器**：如果您还记得，这是在 [第 3 章](ch03.html "第 3 章。制作一个完整的 2D 游戏") 中引入的，*制作一个完整的
    2D 游戏*。现在是时候真正看到它了。这个系统将避免复杂的继承树。'
- en: As you can see, this project is a bit more challenging than the previous one
    due its complexity, but it will also be much more interesting.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个项目由于其复杂性，比之前的更具挑战性，但它也会更有趣。
- en: Building animations
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建动画
- en: In all our previous games, all the different entities displayed on the screen
    were static; at least they were not animated. For a more attractive game, the
    simplest thing to do is add some animations and different entities on the player.
    For us, this will be applied on the different buildings and warriors.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的所有游戏中，屏幕上显示的所有不同实体都是静态的；至少它们没有动画。为了使游戏更具吸引力，最简单的事情就是给玩家添加一些动画和不同的实体。对我们来说，这将被应用于不同的建筑和战士。
- en: 'As we use a sprite-based game and not real-time animation based on bone movement,
    we need some textures with the animations that are already prepared. So, our textures
    will look as shown in the following figure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用基于精灵的游戏，而不是基于骨骼运动的实时动画，我们需要一些已经准备好的动画纹理。因此，我们的纹理将看起来如下所示：
- en: '![Building animations](img/8477OS_07_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![构建动画](img/8477OS_07_02.jpg)'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the green grid is not a part of the image and is only shown here for
    information; the background is transparent in reality.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，绿色网格不是图像的一部分，这里仅为了信息展示；实际上背景是透明的。
- en: This type of texture is called a sprite sheet. In this example, the image can
    be split in two lines of four columns. Each line represents a direction of movement,
    namely left and right. Each cell of these lines represents a step of the future
    animation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的纹理被称为精灵图。在这个例子中，图像可以被分成两行四列。每一行代表一个移动方向，即左和右。这些行的每个单元格代表未来动画的一个步骤。
- en: The aim of the work for this part is to be able to display a sprite using this
    sheet as an animation frame.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分工作的目标是能够使用这张图作为动画帧来显示精灵。
- en: We will follow the design of the SFML by building two classes. The first one
    will store the animations and the second one will be used to display works such
    as `sf::Texture` and `sf::Sprite`. These two classes are named as `Animation`
    and `AnimatedSprite`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循 SFML 的设计，构建两个类。第一个类将存储动画，第二个类将用于显示如 `sf::Texture` 和 `sf::Sprite` 的工作。这两个类被命名为
    `Animation` 和 `AnimatedSprite`。
- en: The Animation class
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Animation 类
- en: The `Animation` class only stores all the required data, for example, the textures
    and the different frames.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Animation` 类只存储所有所需的数据，例如纹理和不同的帧。'
- en: As this class is a kind of resource, we will use it through our `ResourceManager`
    class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个类是一种资源，我们将通过我们的 `ResourceManager` 类来使用它。
- en: 'Here is the header of the class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类的头文件：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, this class is nothing but a container for a texture and some
    rectangles. To simplify the usage of this class, some helper functions have been
    created, namely `addFramesLines()` and `addFramesColumn()`. Each of these functions
    add a complete line or column to the internal `_frames` list. The implementation
    of this class is also very simple and is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个类只是一个纹理和一些矩形的容器。为了简化这个类的使用，创建了一些辅助函数，即 `addFramesLines()` 和 `addFramesColumn()`。这些函数中的每一个都会向内部的
    `_frames` 列表添加一个完整的行或列。这个类的实现也非常简单，如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The three `addFrameXXX()` functions allow us to add frames to our animation.
    The last two ones are some shortcuts to add an entire line or column. The rest
    of the methods allow us to access to the internal data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 三个 `addFrameXXX()` 函数允许我们向我们的动画添加帧。最后两个是添加整个行或列的快捷方式。其余的方法允许我们访问内部数据。
- en: Nothing more is required by our frame container. It's now time to build the
    `AnimatedSprite` class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的帧容器不再需要其他东西。现在是时候构建 `AnimatedSprite` 类了。
- en: The AnimatedSprite class
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AnimatedSprite 类
- en: The `AnimatedSprite` class is in charge of the animation displayed on the screen.
    Due to this, it will keep a reference to an `Animation` class and will change
    the sub-rectangle of the texture periodically, just like `sf::Sprite`. We will
    also copy the `sf::Music`/`sf::Sound` API concerning the play/pause/stop ability.
    An `AnimatedSprite` instance should also be able to display on the screen and
    be transformable, due to which the class will inherit from `sf::Drawable` and
    `sf::Transformable`. We will also add a callback that will be triggered when the
    animation is complete. It could be interesting for the future.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimatedSprite` 类负责屏幕上显示的动画。因此，它将保留对 `Animation` 类的引用，并定期更改纹理的子矩形，就像 `sf::Sprite`。我们还将复制
    `sf::Music`/`sf::Sound` API 中的播放/暂停/停止功能。`AnimatedSprite` 实例也应该能够在屏幕上显示并且可变换，因此该类将继承自
    `sf::Drawable` 和 `sf::Transformable`。我们还将添加一个当动画完成时被触发的回调。这可能会很有趣。'
- en: 'The header looks as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 标头如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, this class is bigger than the previous one. Its main functionality
    is to store an array of four vertices that will represent a frame taken from the
    associated animation. We also need some other information, such as the time between
    two frames, if the animation is a loop. This is why we need so many little functions.
    Now, let''s see how all these are implemented:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此类比之前的大。其主要功能是存储一个代表从相关动画中取出的帧的四个顶点的数组。我们还需要一些其他信息，例如两个帧之间的时间，如果动画是循环的。这就是为什么我们需要这么多小函数的原因。现在，让我们看看所有这些是如何实现的：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The constructor only initializes all the different attributes to their correct
    values:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数仅将所有不同的属性初始化为其正确的值：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function changes the current texture for a new one only if they are different,
    and resets the frame to the first one of the new animation. Note that at least
    one frame has to be stored in the new animation received as a parameter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仅在当前纹理与新纹理不同时更改当前纹理，并将帧重置为新动画的第一个帧。请注意，新动画作为参数接收时至少必须存储一个帧。
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All these functions are simple getters and setters. They allow us to manage
    basic elements of the `AnimatedSprite` class, as depicted in the previous code
    snippet.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都是简单的获取器和设置器。它们允许我们管理 `AnimatedSprite` 类的基本元素，如前一个代码片段所示。
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function changes the current frame to a new one taken from the internal
    `Animation` class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将当前帧更改为从内部 `Animation` 类中取出的新帧。
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function changes the color mask of the displayed image. To do this, we
    set the color of each internal vertex to the new color received as a parameter:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数更改显示图像的颜色遮罩。为此，我们将每个内部顶点的颜色设置为作为参数接收的新颜色：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function is the main one. Its job is to change from the current frame
    to the next one when the time limit is reached. Once we reach the last frame of
    the animation, you can do the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是主要的。其任务是当时间限制达到时，从当前帧更改为下一帧。一旦我们达到动画的最后一帧，你可以做以下操作：
- en: Reset the animation from the first one, depending of the `_loop` value
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据 `_loop` 值重置动画到第一个
- en: Reset the animation from the first one if the `_repeat` value authorizes us
    to do it
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `_repeat` 值允许，则从第一个动画重置动画
- en: In all other cases, we trigger the event "on finish" by calling the internal
    callback
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有其他情况下，我们通过调用内部回调触发“完成”事件
- en: 'Now, take a look at the function that updates the frame''s skin:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看更新帧皮肤的函数：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function is also an important one. Its aims is to update the attributes
    of the different vertices to those taken from the internal `Animation` class,
    namely the position and texture coordinates:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数也是一个重要的函数。其目的是将不同顶点的属性更新为从内部 `Animation` 类中取出的属性，即位置和纹理坐标：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The final function of this class manages the display. Because we inherit from
    `sf::Transformable`, we need to take into account the possible transformation.
    Then, we set the texture we used and finally draw the internal vertices array.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此类中的最终功能负责显示。因为我们从 `sf::Transformable` 继承，所以我们需要考虑可能的变换。然后，我们设置我们使用的纹理，最后绘制内部顶点数组。
- en: A usage example
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用示例
- en: Now that we have the requisite classes to display an animation, let's build
    a little usage example.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了显示动画所需的类，让我们构建一个小型的使用示例。
- en: 'Now, here''s the implementation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里是实现：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For a better understanding of this code snippet, I've written some comments
    in the code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这段代码，我在代码中添加了一些注释。
- en: This short program displays an animation on the screen. You can also change
    its position by moving it using the arrows on your keyboard. The animation will
    also change depending on the direction of movement.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短程序在屏幕上显示动画。您也可以通过使用键盘上的箭头移动它来改变其位置。动画也会根据移动方向而改变。
- en: Now that the first point of this chapter has been explained, let's continue
    to the second one, building a map.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经解释了本章的第一个要点，让我们继续第二个要点，构建地图。
- en: Building a generic Tile Map
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建通用的瓦片地图
- en: For our project, we need something that will manage the map. In fact, the map
    is nothing but a big grid. The cells can be of any shape (square, hexagonal, and
    so on). The only restriction is that all the cells of a single map should have
    the same geometry.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们需要一个可以管理地图的东西。实际上，地图不过是一个大网格。单元格可以是任何形状（方形、六边形等）。唯一的限制是，单个地图的所有单元格应该具有相同的几何形状。
- en: Moreover, each cell can contain several objects, possibly of different types.
    For example, a cell can contain some background texture for the ground, a tree,
    and a bird. Because SFML doesn't use a `z` buffer with sprites (also called a
    depth buffer), we need to simulate it by hand. This is called the Painter's Algorithm.
    Its principle is very simple; draw everything but by depth order, starting with
    the most distant. It's how a tradition art painter would paint.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个单元格可以包含多个对象，可能是不同类型的。例如，一个单元格可以包含一些用于地面的背景纹理、一棵树和一只鸟。由于SFML不使用精灵的`z`缓冲区（也称为深度缓冲区），我们需要手动模拟它。这被称为画家算法。其原理非常简单；按照深度顺序绘制所有内容，从最远的开始。这就是传统艺术画家作画的方式。
- en: 'All this information brings us to the following structure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都带我们来到了以下结构：
- en: A `Map` class must be of a specific geometry and must contain any number of
    layers sorted by their `z` buffer.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`类必须具有特定的几何形状，并且必须包含按其`z`缓冲区排序的任意数量的层。'
- en: A `Layer` contains only a specific type. It also has a `z` buffer and stores
    a list of content sorted by their positions.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Layer`只包含特定类型。它也有一个`z`缓冲区，并存储一个按位置排序的内容列表。'
- en: The `CONTENT` and `GEOMETRY` classes are template parameters but they need to
    have a specific API.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONTENT`和`GEOMETRY`类是模板参数，但它们需要具有特定的API。'
- en: 'Here is the flowchart representing the class hierarchy of the previously explained
    structure:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是表示之前解释的结构类层次的流程图：
- en: '![Building a generic Tile Map](img/8477OS_07_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![构建通用的瓦片地图](img/8477OS_07_04.jpg)'
- en: 'Following is the explanation of the flowchart:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是流程图的说明：
- en: The `CONTENT` template class can be any class that inherits from `sf::Drawable`
    and `sf::Transformable`.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONTENT`模板类可以是任何继承自`sf::Drawable`和`sf::Transformable`的类。'
- en: The `GEOMETRY` class is a new one that we will learn about shortly. It only
    defines the geometric shape and some helper functions to manipulate coordinates.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GEOMETRY`类是一个新类，我们将在稍后了解它。它只定义了几何形状和一些用于操作坐标的帮助函数。'
- en: The `VLayer` class defines a common class for all the different types of layers.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VLayer`类定义了一个适用于所有不同类型层的通用类。'
- en: The `Layer` class is just a container of a specific type with a depth variable
    that defines its draw order for the painter algorithm.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Layer`类只是一个具有深度变量的特定类型容器，该变量定义了其在画家算法中的绘制顺序。'
- en: The `VMap` class defines a common API for the entire Map. It also contains a
    list of `VLayer` that is displayed using the painter algorithm.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VMap`类定义了整个地图的通用API。它还包含一个`VLayer`列表，该列表使用画家算法显示。'
- en: The `Map` class inherits from `VMap` and is of a specific geometry.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`类从`VMap`继承，并具有特定的几何形状。'
- en: The Geometry class as an isometric hexagon
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等距六边形的几何类
- en: 'For our project, I made the choice of an isometric view with the tile as a
    hexagon. An isometric view is really simple to obtain but needs to be understood
    well. Following are the steps we need to follow:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我选择了以瓦片为六边形的等距视图。等距视图非常简单获得，但需要很好地理解。以下是我们需要遵循的步骤：
- en: First, view your tile from the top view:![The Geometry class as an isometric
    hexagon](img/8477OS_07_05.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从俯视图查看你的瓦片：![等距六边形的几何类](img/8477OS_07_05.jpg)
- en: Then, rotate it 45 degrees clockwise:![The Geometry class as an isometric hexagon](img/8477OS_07_06.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，顺时针旋转45度：![等距六边形的几何类](img/8477OS_07_06.jpg)
- en: Finally, divide its height by 2:![The Geometry class as an isometric hexagon](img/8477OS_07_07.jpg)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将其高度除以2：![等距六边形的几何类](img/8477OS_07_07.jpg)
- en: You now have a nice isometric view. Now, let's take a look at the hexagon:![The
    Geometry class as an isometric hexagon](img/8477OS_07_08.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你有一个很好的等距视图。现在，让我们看看六边形：![等距六边形的几何类](img/8477OS_07_08.jpg)
- en: 'As you know, we need to calculate the coordinates of each of the edges using
    trigonometry, especially the Pythagoras theorem. This is without taking into account
    the rotation and the height resize. We need to follow two steps to find the right
    coordinates:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，我们需要使用三角学计算每条边的坐标，特别是毕达哥拉斯定理。这是不考虑旋转和高度调整的情况。我们需要遵循两个步骤来找到正确的坐标：
- en: Calculate the coordinates from the rotated shape (adding 45 degrees).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从旋转的形状（添加45度）计算坐标。
- en: 'Divide the total height value by two. By doing this, you will finally be able
    to build `sf::Shape`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将总高度值除以二。通过这样做，你最终将能够构建`sf::Shape`：
- en: '[PRE12]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The major part of the `GEOMETRY` class has been made. What remains is only a
    conversion from world to pixel coordinates, and the reverse. If you are interested
    in doing this, take a look at the class implementation in the `SFML-utils/src/SFML-utils/map/HexaIso.cpp`
    file.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GEOMETRY`类的大部分已经完成。剩下的是从世界坐标到像素坐标的转换，以及反向转换。如果你对此感兴趣，可以查看`SFML-utils/src/SFML-utils/map/HexaIso.cpp`文件中的类实现。'
- en: Now that the main geometry has been defined, let's construct a `Tile<GEOMETRY>`
    class on it. This class will simply encapsulate `sf::Shape` , which is initialized
    by the geometry, and with the different requirements to be able to be use a `COMPONENT`
    parameter for the map. As this class is not very important, I will not explain
    it through this book, but you can take a look at its implementation in the `SFML-utils/include/SFML-utils/map/Tile.tpl`
    file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在主几何已经定义，让我们在此基础上构建一个`Tile<GEOMETRY>`类。这个类将简单地封装由几何初始化的`sf::Shape`，并且具有不同的要求，以便能够使用`COMPONENT`参数为地图使用。由于这个类不是很重要，我将不会通过这本书来解释它，但你可以在`SFML-utils/include/SFML-utils/map/Tile.tpl`文件中查看它的实现。
- en: VLayer and Layer classes
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VLayer和Layer类
- en: The aim of a layer is to manage any number of components at the same depth.
    To do this, each layer contains its depth and a container of components. It also
    has the ability to resort the container to respect the painter algorithm. The
    `VLayer` class is an interface that only defines the API of the layer, allowing
    the map to store any kind of layer, thanks to polymorphism.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 层的目标是管理同一深度的任意数量的组件。为此，每个层都包含其深度和组件容器。它还具有重新排序容器的能力，以尊重绘图算法。`VLayer`类是一个接口，它只定义了层的API，允许地图存储任何类型的层，这得益于多态性。
- en: 'Here is the header of the `Layer` class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Layer`类的标题：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As mentioned previously, this class will not only store a container of its `template`
    class argument, but also its depth (`z`) and an is static Boolean member contained
    in the `Vlayer` class to optimize the display. The idea under this argument is
    that if the content within the layer doesn't move at all, it doesn't need to repaint
    the scene each time. The result is stored in an internal `sf::RenderTexture` parameter
    and will be refreshed only when the scene moves. For example, the ground never
    moves nor is it animated. So we can display it on a big texture and display this
    texture on the screen. This texture will be refreshed when the view is moved/resized.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个类不仅将存储其`template`类参数的容器，还将存储其深度（`z`）和一个包含在`Vlayer`类中的静态布尔成员，以优化显示。这个参数背后的想法是，如果层内的内容根本不移动，那么每次场景移动时就不需要重新绘制场景。结果存储在一个内部的`sf::RenderTexture`参数中，并且只有在场景移动时才会刷新。例如，地面永远不会移动，也没有动画。因此，我们可以将其显示在一个大纹理上，并在屏幕上显示这个纹理。这个纹理将在视图移动/调整大小时刷新。
- en: To take this idea further, we only need to display content that appears on the
    screen. We don't need do draw something out of the screen. That's why we have
    the `viewport` attribute of the `draw()` method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步阐述这个想法，我们只需要显示屏幕上出现的内容。我们不需要绘制屏幕外的任何东西。这就是为什么我们有`draw()`方法的`viewport`属性。
- en: 'All other functions manage the content of the layer. Now, take a look at its
    implementation:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他函数管理层的内容。现在，让我们看看它的实现：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This function adds new content to the layer, sort it if requested, and finally,
    return a reference to the new object:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数向层添加新内容，如果需要则对其进行排序，并最终返回对新对象的引用：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function returns all the different objects to the same place. This is
    useful to pick up objects, for example, to pick objects under the cursor:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将所有不同的对象返回到同一个地方。这对于拾取对象很有用，例如，拾取光标下的对象：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is the reverse function of `add()`. Using its address, it removes a component
    from the container:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`add()`函数的反函数。使用其地址，它从容器中移除一个组件：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This function sorts all the content with respect to the painter algorithm order:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数根据画家算法顺序对所有内容进行排序：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This function is much more complicated than what we expect because of some
    optimizations. Let''s explain it step by step:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一些优化，这个函数比我们预期的要复杂得多。让我们一步一步地解释它：
- en: 'First, we separate two cases. In the case of a static map we do as follows:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们区分两种情况。在静态地图的情况下，我们这样做：
- en: Check if the view port has changed
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查视口是否已更改
- en: Resize the internal texture if needed
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如有必要，调整内部纹理的大小
- en: Reset the textures
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置纹理
- en: Draw each object with a position inside the view port into the `textureDisplay`
    the texture for the `RenderTarget` argument.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将视口内的每个对象的位置绘制到`textureDisplay`纹理中，作为`RenderTarget`参数。
- en: Draw each object with a position inside the view port into the `RenderTarget`
    argument if the layer contains dynamic objects (not static).
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果层包含动态对象（非静态），则将视口内的每个对象的位置绘制到`RenderTarget`参数的`textureDisplay`中。
- en: As you can see, the `draw()` function uses a naive algorithm in the case of
    dynamic content and optimizes the statics. To give you an idea of the benefits,
    with a layer of 10000 objects, the FPS was approximately 20\. With position optimization,
    it reaches 400, and with static optimization, 2,000\. So, I think the complexity
    of this function is justified by the enormous performance benefits.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`draw()`函数在动态内容的情况下使用了一种朴素算法，并优化了静态内容。为了给你一个概念，当有一层10000个对象时，帧率大约是20。通过位置优化，它达到400，通过静态优化，达到2000。所以，我认为这个函数的复杂性是由巨大的性能收益所证明的。
- en: Now that the `layer` class has been exposed to you, let's continue with the
    `map` class.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经向你介绍了`layer`类，让我们继续介绍`map`类。
- en: VMap and Map classes
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VMap和Map类
- en: A map is a container of `VLayer`. It will implement the usual `add()`/`remove()`
    functions. This class can also be constructed from a file (described in the *Dynamic
    board loading* section) and handle unit conversion (coordinate to pixel and vice
    versa).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 地图是`VLayer`的容器。它将实现常用的`add()`/`remove()`函数。此类还可以从文件（在*动态板加载*部分描述）中构建并处理单位转换（坐标到像素和反之亦然）。
- en: 'Internally, a `VMap` class store has the following layers:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，`VMap`类存储有如下层：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are only two interesting functions in this class. The others are simply
    shortcuts, so I will not explain the entire class. Let us see the concerned functions:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中只有两个有趣的功能。其他的是简单的快捷方式，所以我不打算解释整个类。让我们看看相关的函数：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This function sorts the different layers by their `z` buffer with respect to
    the Painter's Algorithm. In fact, this function is simple but very important.
    We need to call it each time a layer is added to the map.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数根据画家算法对不同的层进行排序。实际上，这个函数很简单但非常重要。每次向地图添加一个层时，我们都需要调用它。
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The function draws each layer by calling its draw method; but first, we adjust
    the screen view port by adding a little delta on each of its borders. This is
    done to display all the tiles that appear on the screen, even partially (when
    its position is out on the screen).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通过调用其绘制方法来绘制每个层；但首先，我们在其每个边框上添加一个小增量来调整屏幕视口。这样做是为了显示屏幕上出现的所有瓦片，即使它们只部分显示（当其位置在屏幕外时）。
- en: Dynamic board loading
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态板加载
- en: 'Now that the map structure is done, we need a way to load it. For this, I''ve
    chosen the `JSON` format. There are two reasons for this choice:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在地图结构已经完成，我们需要一种加载它的方法。为此，我选择了`JSON`格式。选择这个格式的有两个原因：
- en: It can be read by humans
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以被人类阅读
- en: The format is not verbose, so the final file is quite small even for big map
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式不是冗长的，所以即使是对于大地图，最终的文件也相当小。
- en: 'We will need some information to construct a map. This includes the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些信息来构建地图。这包括以下内容：
- en: The map's geometry
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图的几何形状
- en: The size of each tile (cell)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个瓦片（单元格）的大小
- en: 'Define the layers as per the following:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下方式定义层：
- en: The `z` buffer
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z`缓冲区'
- en: If it is static or dynamic
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是静态的还是动态的
- en: The content type
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容类型
- en: 'Depending on the content type of the layer, some other information to build
    this content could be specified. Most often, this extra information could be as
    follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 根据层的内 容类型，可能需要指定一些其他信息来构建此内容。最常见的情况如下：
- en: Texture
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理
- en: Coordinates
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐标
- en: Size
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小
- en: 'So, the `JSON` file will look as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`JSON`文件将如下所示：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the different datasets are present to create a map with the
    isometric hexagon geometry with two layers. The first layer contains the grid
    with the ground texture and the second one contains some sprite for decoration.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，不同的数据集存在以创建具有等距六边形几何形状的地图，并具有两层。第一层包含带有地面纹理的网格，第二层包含一些用于装饰的精灵。
- en: To use this file, we need a `JSON` parser. You can use any existing one, build
    yours, or take the one built with this project. Next, we need a way to create
    an entire map from a file or update its content from a file. In the second case,
    the geometry will be ignored because we can't change the value of a template at
    runtime.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此文件，我们需要一个 `JSON` 解析器。你可以使用任何现有的，构建自己的，或者使用本项目构建的。接下来，我们需要一种从文件创建整个地图或从文件更新其内容的方法。在第二种情况下，几何形状将被忽略，因为我们不能在运行时更改模板的值。
- en: 'So, we will add a static method to the `VMap` class to create a new `Map`,
    and add another method to update its content. The signature will be as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将向 `VMap` 类添加一个静态方法来创建一个新的 `Map`，并添加另一个方法来更新其内容。签名如下：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `loadFromJson()` function has to be virtual and implemented in the `Map`
    class because of the `GEOMETRY` parameter required by the `Tile` class. The `createMapFromFile()`
    function will be used internationally. Let''s see its implementation:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Tile` 类需要的 `GEOMETRY` 参数，`loadFromJson()` 函数必须是虚拟的，并在 `Map` 类中实现。`createMapFromFile()`
    函数将用于国际使用。让我们看看它的实现：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The goal of this function is pretty simple; construct the appropriate map depending
    on the geometry parameter and forward it the rest of the job.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的目标非常简单；根据几何参数构建适当的地图，并将剩余的工作传递出去。
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For a better understanding, the previous function was explained with raw comments.
    It's aimed at building layers and filling them with the data picked from the `JSON`
    file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，前面的函数是用原始注释解释的。它的目的是构建层并将从 `JSON` 文件中挑选的数据填充到层中。
- en: Now that we are able to build a map and fill it from a file, the last thing
    we need to do is display it on the screen. This will be done with the `MapViewer`
    class.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够从文件构建地图并填充其内容，我们需要做的最后一件事是将它显示在屏幕上。这将通过 `MapViewer` 类来完成。
- en: The MapViewer class
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MapViewer 类
- en: This class encapsulates a `Map` class and manages some events such as mouse
    movement, moving the view, zoom, and so on. This is a really simple class with
    nothing new. This is why I will not go into details about anything but the `draw()`
    method (because of the view port). If you are interested in the full implementation,
    take a look at the `SFML-utils/src/SFML-utils/map/MapViewer.cpp` file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类封装了一个 `Map` 类，并管理一些事件，如鼠标移动、移动视图、缩放等。这是一个非常简单的类，没有新内容。这就是为什么我不会详细介绍任何内容，除了
    `draw()` 方法（因为视口）。如果你对完整的实现感兴趣，请查看 `SFML-utils/src/SFML-utils/map/MapViewer.cpp`
    文件。
- en: 'So here is the draw method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里是 draw 方法：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As usual, we receive `sf::RenderTarget` and `sf::RenderStates` as parameters.
    However, here we don''t want to interact with the current view of the target,
    so we make a backup of it and attach our local view to the rendered target. Then,
    we call the draw method of the internal map, forwarding the target, and states
    but adding the view port. This parameter is very important because it''s used
    by our layers for optimization. So, we need to build a view port with the size
    of the rendered target, and thanks to SFML, it''s very simple. We convert the
    top-left coordinate to the world coordinate, relative to our view. The result
    is in the top-left coordinate of the displayed area. Now, we only need the size.
    Here again, SFML provides use all the need: `sf::View::getSize()`. With this information,
    we are now able to build the correct view port and pass it to the map `draw()`
    function.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们接收 `sf::RenderTarget` 和 `sf::RenderStates` 作为参数。然而，在这里我们不想与目标当前视图交互，因此我们备份了它并将我们的本地视图附加到渲染的目标上。然后，我们调用内部地图的
    draw 方法，传递目标和状态，但添加了视口。这个参数非常重要，因为它被我们的层用于优化。因此，我们需要构建一个与渲染目标大小相同的视口，多亏了 SFML，这非常简单。我们将左上角坐标转换为相对于我们视图的世界坐标。结果是显示区域左上角的坐标。现在，我们只需要大小。在这里，SFML
    也提供了我们所需的一切：`sf::View::getSize()`。有了这些信息，我们现在能够构建正确的视口并将其传递给地图 `draw()` 函数。
- en: Once the rendering is complete, we restore the initial view back to the rendered
    target.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦渲染完成，我们将初始视图恢复到渲染目标。
- en: A usage example
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用示例
- en: 'We now have all the requirements to load and display a map to the screen. The
    following code snippet shows you the minimal steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经具备了加载和显示地图到屏幕上的所有要求。以下代码片段显示了最小步骤：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The different steps of this function are as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的不同步骤如下：
- en: Creating a window
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建窗口
- en: Creating a map from a file
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件创建映射
- en: Process the events and quit if requests
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理事件并在请求时退出
- en: Update the viewer
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新查看器
- en: Display the viewer on the screen
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕上显示查看器
- en: 'The result will be as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![A usage example](img/8477OS_07_09.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![使用示例](img/8477OS_07_09.jpg)'
- en: Now that the map is done, we need to fill it with some entities.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了映射，我们需要用一些实体填充它。
- en: Building an entity system
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建实体系统
- en: First of all, what is an entity system?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是什么是实体系统？
- en: An **entity system** is a design pattern that focuses on data. Instead of creating
    a complex hierarchical tree of all possible entities, the idea is to build a system
    that allows us to add components to an entity at runtime. These components could
    be anything such as health points, artificial intelligence, skin, weapon, and
    everything but data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体系统**是一种关注数据的设计模式。它不是创建所有可能实体的复杂层次树，而是构建一个系统，允许我们在运行时向实体添加组件。这些组件可以是任何东西，如生命值、人工智能、皮肤、武器，以及除了数据之外的一切。'
- en: However, if none of the entities and components hold functionalities, where
    are they stored? The answer is in the systems. Each system manages at least one
    component, and all the logic is inside these systems. Moreover, it is not possible
    to build an entity directly. You have to create or update it using an entity manager.
    It will be in charge of a set of entities, managing their components, creation,
    and destruction.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果实体和组件都不包含功能，它们存储在哪里呢？答案是系统。每个系统管理至少一个组件，所有逻辑都包含在这些系统中。此外，无法直接构建实体。您必须使用实体管理器创建或更新它。它将负责一组实体，管理它们的组件、创建和销毁。
- en: 'The structure is represented by the following chart:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结构由以下图表表示：
- en: '![Building an entity system](img/8477OS_07_10.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![构建实体系统](img/8477OS_07_10.jpg)'
- en: There are many ways to implement such a structure. My choice was to use template
    and polymorphism.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种结构有许多方法。我的选择是使用模板和多态。
- en: Use of the entity system
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体系统的使用
- en: 'Without going much into the internal structure, we create a new component with
    this system as a structure, with no method except a constructor/destructor, and
    inherit from `Component` as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入内部结构，我们创建一个新的组件，将其作为结构，没有方法，除了构造函数/析构函数，并从`Component`继承如下：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The inheritance is important to have a common base class between all the components.
    The same idea is used to create `System`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 继承对于在所有组件之间有一个公共基类很重要。同样的想法用于创建`System`：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The reason for the inheritance is to have a common parent and API (the `update`
    function). Finally, to create an entity, you will have to do the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的原因是为了有一个公共父类和API（`update`函数）。最后，要创建实体，您必须执行以下操作：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we continue this example, when an entity has no `hp`, we have to remove
    it from the board. This part of the logic is implemented inside the `SysHp::update()`
    function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续这个例子，当一个实体没有`hp`时，我们必须将其从板上删除。这部分逻辑是在`SysHp::update()`函数中实现的：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This `SysHp::update()` function is used to create a specific functionality.
    Its aim is to remove all the entities with `hp` under or equal to zero. To do
    this, we initialize `ComponentHandler<CompHp>` using the `CompHp::Handle` shortcut
    (defined in the `Component` class). Then we create our query on the world. In
    our case, we need to get all the entities with `CompHp` attached to them. The
    multiple criteria query is also possible for more complex systems.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`SysHp::update()`函数用于创建特定的功能。其目的是删除所有`hp`值小于或等于零的实体。为此，我们使用`CompHp::Handle`快捷方式（在`Component`类中定义）初始化`ComponentHandler<CompHp>`。然后我们在世界上创建我们的查询。在我们的例子中，我们需要获取所有带有`CompHp`的实体。对于更复杂的系统，也可以进行多标准查询。
- en: 'Once we have our view, we iterate on it. Each iteration gives us access to
    `Entity` and updates the handler values to the entity components. So, creating
    access to the `hp` handler is equivalent to the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了我们的视图，我们就迭代它。每次迭代都给我们访问`Entity`并更新处理程序值的权限到实体组件。因此，创建对`hp`处理程序的访问相当于以下：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Then, we check the `_hp` value and remove the entity if needed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查`_hp`值，并在需要时删除实体。
- en: It's important to note that the entity will actually be removed only when the
    `EntityManager::update()` function is called to keep data consistent inside the
    system loops.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，实体实际上只有在调用`EntityManager::update()`函数以保持系统循环内部数据一致性时才会被删除。
- en: 'Now that the `SysHp` parameter has been completed, we need to register it to
    `SystemManager` that is linked to `EntityManager`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由于`SysHp`参数已经完成，我们需要将其注册到与`EntityManager`相连的`SystemManager`：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We have now built an entity manager, a component, a system, and an entity.
    Putting them all together will result in the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经构建了一个实体管理器、一个组件、一个系统和一个实体。将它们全部组合在一起将得到以下代码：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This little code will create an entity and system manager. Then, we create 10
    entities and add them to the `CompHp` component. Finally, we enter the game loop.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这段小代码将创建一个实体和系统管理器。然后，我们创建10个实体并将它们添加到`CompHp`组件中。最后，我们进入游戏循环。
- en: As mentioned previously, don't detail the implementation of the entity system;
    focus on its usage. If you are interested in the implementation, which is a bit
    complex, take a look at the files in the `SFML-utils/include/SFML-utils/es` directory.
    This is header only library.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，不要详细说明实体系统的实现；关注其使用。如果你对实现感兴趣，它有点复杂，请查看`SFML-utils/include/SFML-utils/es`目录下的文件。这是一个仅包含头文件的库。
- en: Advantages of the entity system approach
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体系统方法的优点
- en: With a component system, each entity is represented as a single unique integer
    (its ID). These components are nothing but data. So, this is really simple to
    create a serialization function that saves the entire world. Database saving is
    made very simple with this approach but it's not the only point.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件系统，每个实体都表示为一个唯一的整数（其ID）。这些组件不过是数据。因此，创建一个保存整个世界的序列化函数实际上非常简单。使用这种方法，数据库保存变得非常简单，但这不是唯一的好处。
- en: To create a flying car with a classic hierarchical tree, you have to inherit
    it from two different classes, namely car and flying vehicle. Each of these classes
    could inherit from the other. In fact, when the number of entities become large,
    the hierarchical tree is too much. For the same example, create an entity with
    the entity system, attach it to some wheels and wings. That's it! I agree that
    creating an entity system can be difficult, but its usage simplifies a lot the
    game's complexity.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用经典分层树创建一个飞行汽车，你必须从两个不同的类中继承它，即汽车和飞行器。这些类中的每一个都可以从另一个继承。事实上，当实体数量变得很大时，分层树就太多了。对于相同的例子，使用实体系统创建一个实体，将其附加到一些轮子和翅膀上。就这样！我同意创建实体系统可能很困难，但它的使用大大简化了游戏的复杂性。
- en: Building the game logic
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建游戏逻辑
- en: 'We now have all the requirements to start our game: resource management, events
    management, GUI, animations, map, and the entity system. It''s time for us to
    group them into a single project.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了启动游戏的所有要求：资源管理、事件管理、GUI、动画、地图和实体系统。是时候将它们组合成一个单一的项目了。
- en: 'First, we need to create our entities. Thanks to the entity system previously
    described, we only need to build some components and their systems. We can build
    many of them, but the main components for the project are as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建我们的实体。多亏了之前描述的实体系统，我们只需要构建一些组件及其系统。我们可以构建很多，但项目的主要组件如下：
- en: '| Components | Entities |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 实体 |'
- en: '| --- | --- |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Skin | Animation |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 皮肤 | 动画 |'
- en: '| Health points | Current health |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 健康点 | 当前健康值 |'
- en: '| Maximum health |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 最大健康值 |'
- en: '| Team | Identifier for the team |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 队伍 | 队伍的标识符 |'
- en: '| Build area | The authorized range around the entity |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 构建区域 | 实体周围的授权范围 |'
- en: '| Movement | Speed |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 移动 | 速度 |'
- en: '| Destination |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 目标 |'
- en: '| Artificial intelligence for warriors | Delta time |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 战士的人工智能 | Δ时间 |'
- en: '| Damage |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 伤害 |'
- en: '| Length of hit |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 击中长度 |'
- en: The interesting ones are artificial intelligence (to damage) and movement. The
    others are pretty naive. Of course, you can create your own component in addition/replacement
    of those proposed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的是人工智能（用于伤害）和移动。其他的是相当简单的。当然，你可以创建自己的组件，作为那些提议的补充或替代。
- en: Building our components
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的组件
- en: 'We know all the data needed by our components, so let''s build the two interesting
    components, namely the `walker AI` and the `warrior AI`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的组件需要所有数据，因此让我们构建两个有趣的组件，即`walker AI`和`warrior AI`：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This component handles the speed and destination. The destination can be updated
    by anything (for example, when an enemy is detected at proximity):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件处理速度和目的地。目的地可以通过任何东西更新（例如，当检测到近距离的敌人时）：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This component stores the aggressiveness of an entity, with its damaged, attack
    speed and area of aggressively.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件存储实体的攻击性，包括其受损情况、攻击速度和攻击范围。
- en: 'As we will use this component in the system section, I will also explain the
    `CompSkin` component. This component stores an `AnimatedSkin` and different possible
    `Animation` that could be applied to it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在系统部分使用此组件，我还会解释`CompSkin`组件。此组件存储一个`AnimatedSkin`和可以应用于它的不同可能的`Animation`：
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now that the components have been built, take a look at the systems.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在组件已经构建完成，让我们看看系统。
- en: Creating the different systems
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建不同的系统
- en: We need as many systems as the number of components. The skin system simply
    calls the update function on the animation. We have already built the related
    system for the health. For the team component, we don't need any system because
    this component is used only by artificial intelligence. The two systems left are
    more complex.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的系统数量与组件数量相同。皮肤系统简单地调用动画的更新函数。我们已经为健康构建了相关的系统。对于团队组件，我们不需要任何系统，因为这个组件仅由人工智能使用。剩下的两个系统更复杂。
- en: 'Let''s start with the movement:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从移动开始：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice that the `Level` class has not yet been introduced. This class regroups
    an `EntityManager` and a `SystemManager` classes and gives us access to some functions
    concerning the map geometry, without having to know it. I will explain it later.
    In our case, we will need some information about the distance between the actual
    position of the component and its destination. This is why we need to keep a reference
    to the level.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Level`类尚未介绍。此类将`EntityManager`和`SystemManager`类分组，并为我们提供访问有关地图几何形状的一些函数，而无需了解它。我稍后会解释它。在我们的情况下，我们需要有关组件实际位置与其目的地之间距离的一些信息。这就是为什么我们需要保留对等级的引用。
- en: 'Here''s the implementation of the walker system:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是步行者系统的实现：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This system doesn't just move the entity but also makes different things. The
    position is stored inside the `CompSkin` component, so we need to iterate on the
    entities by getting the `CompAIWalker` and `CompSkin` components attached to them.
    Then, we calculate the position of the entity in the world coordinate and check
    if a move is needed. If we need to move, we calculate the vector corresponding
    to the total displacement (direction). This vector gives us the direction that
    the entity needs to follow. Then, we calculate the distance between the end point
    and the current position. Depending on the speed, we change the current position
    to the new one.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此系统不仅移动实体，还执行不同的操作。位置存储在`CompSkin`组件中，因此我们需要通过获取附加到实体上的`CompAIWalker`和`CompSkin`组件来迭代实体。然后，我们计算实体在世界坐标系中的位置并检查是否需要移动。如果我们需要移动，我们计算对应于总位移（方向）的向量。这个向量告诉我们实体需要跟随的方向。然后，我们计算终点和当前位置之间的距离。根据速度，我们将当前位置更改为新位置。
- en: Once the movement is complete, we also change the current animation to the one
    matching the movement direction taken by the entity.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦移动完成，我们还将当前动画更改为与实体采取的移动方向相匹配的动画。
- en: 'Now, let''s take an interest in the `Warrior AI`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注一下`战士AI`：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This system requires three components, namely `CompSkin` (for position), `CompTeam`
    (for detect enemy), and `CompAIWarrior`. The first thing to do is update the delta
    time. Then, we check if we have some enemies to defeat. Next, we search for an
    enemy who is closer (I won't detail this part because you can put your own algorithm).
    If an enemy is found, we check the distance between us and the enemy. If we can
    shoot the enemy, we do so and reset the delta time to avoid hitting each frame.
    We also trigger some events (for example, to create sound) and add gold to the
    team if we just kill the enemy. We also set the destination of the `CompAIWarrior`
    to the current position (to stay fighting) if we can, or move closer to the next
    enemy.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此系统需要三个组件，即`CompSkin`（用于位置）、`CompTeam`（用于检测敌人）和`CompAIWarrior`。首先，我们需要更新delta时间。然后，我们检查是否有敌人需要击败。接下来，我们寻找一个更近的敌人（我不会详细说明这部分，因为你可以使用自己的算法）。如果找到敌人，我们检查我们与敌人之间的距离。如果我们能够射击敌人，我们就这样做，并将delta时间重置以避免每帧都击中。我们还触发一些事件（例如，创建声音）并在我们刚刚击败敌人时为团队添加金币。如果可能，我们还将`CompAIWarrior`的目的地设置为当前位置（以保持战斗状态），或者移动到下一个敌人更近的位置。
- en: We now have all the components and systems to manage them. So, we will continue
    with the game architecture.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了所有组件和系统来管理它们。因此，我们将继续进行游戏架构。
- en: The level class
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等级类
- en: As usual, we split the game into several parts. The `level` class represents
    a map. This class stores all the entities, systems, viewers, maps, sounds, and
    so on. As previously explained, it also implements an abstraction layer above
    the map geometry.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们将游戏分成几个部分。`level`类代表一个地图。这个类存储了所有实体、系统、查看器、地图、声音等。正如之前解释的，它还在地图几何之上实现了一个抽象层。
- en: In fact, a level is a very simple object; it is just the glue between others.
    It registers all the systems, constructs the map, initializes a `MapViewer`, events,
    and regroups all the different update calls into one method. This class also offers
    users the ability to create new entities, by creating them through the internal
    `EntityManager`, and adding them to a map layer. The map is always synchronized
    with the `EntityManager` while doing this.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一个关卡是一个非常简单的对象；它只是连接其他对象的粘合剂。它注册所有系统，构建地图，初始化一个`MapViewer`，事件，并将所有不同的更新调用组合到一个方法中。这个类还允许用户通过创建内部的`EntityManager`来创建新的实体，并将它们添加到地图层中。在这个过程中，地图始终与`EntityManager`保持同步。
- en: If you are interested in this implementation, take a look at the `SFML-book/07_2D_iso_game/src/SFML-Book/Level.cpp`
    file.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个实现感兴趣，请查看`SFML-book/07_2D_iso_game/src/SFML-Book/Level.cpp`文件。
- en: The game class
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏类
- en: Now, the `game` class! You should be familiar with this class by now. Its global
    behavior hasn't changed and still contains the same functionalities (`update()`,
    `processEvents()`, and `render()`).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`game`类！你现在应该熟悉这个类。它的全局行为没有改变，仍然包含相同的函数（`update()`、`processEvents()`和`render()`）。
- en: The big change here is that the game class will initialize a `Level` and `Team`.
    One of these will be the one controlled by the player, and the GUI depends on
    it. This is the reason that the GUI for this project was attached to a team instead
    of the entire game. I won't say that it's the best way, but it's the simplest
    and allows us to jump from one team to another.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重大变化是，游戏类将初始化一个`Level`和`Team`。其中之一将是玩家控制的，GUI依赖于它。这也是为什么这个项目的GUI被附加到一个团队而不是整个游戏的原因。我不会说这是最好的方法，但这是最简单的方法，并允许我们从一个团队跳到另一个团队。
- en: If you are interested in this implementation, take a look at the `SFML-book/07_2D_iso_game/src/SFML-Book/Game.cpp`
    file.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个实现感兴趣，请查看`SFML-book/07_2D_iso_game/src/SFML-Book/Game.cpp`文件。
- en: The Team GUI class
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 团队GUI类
- en: This class handles different information and is the interface between the game
    and the player. It should allow the player to build some entities and interact
    with them.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类处理不同的信息，是游戏和玩家之间的接口。它应该允许玩家构建一些实体并与它们交互。
- en: 'The following screen shows you the **Build** menu. This menu shows the player
    the different entities that can be created and the current gold amount:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕显示了**构建**菜单。此菜单向玩家展示了可以创建的不同实体以及当前的金币数量：
- en: '![The Team GUI class](img/8477OS_07_11.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![团队GUI类](img/8477OS_07_11.jpg)'
- en: Of course, we can complete this menu a lot, but this is the minimum information
    required by our game. Using our previously made GUI will facilitate this task
    a lot.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以进一步完善这个菜单，但这是我们游戏所需的最基本信息。使用我们之前制作的GUI将大大简化这项任务。
- en: 'Once an entity is selected, we just have to place it into the game keeping
    in mind the following criteria:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了一个实体，我们只需将其放置到游戏中，同时考虑到以下标准：
- en: The amount of gold
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金币数量
- en: The build area
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建区域
- en: After this, everything will run easily. Don't hesitate to make some helper functions
    that create different entities by adding some components with specific values.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，一切都将顺利运行。不要犹豫，创建一些辅助函数，通过添加具有特定值的组件来创建不同的实体。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered different things, such as creating animations. This
    class allowed us to display animated characters on screen. Then, we built a `Map`
    class that was filled with some entities. We also learned how to use an entity
    system by creating some components and systems to build our game logic. Finally,
    we put all the accumulated knowledge together to build a complete game with some
    artificial intelligence, a user interface, sounds, and animations.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了不同的事情，例如创建动画。这个类使我们能够在屏幕上显示动画角色。然后，我们构建了一个`Map`类，其中包含了一些实体。我们还学习了如何通过创建一些组件和系统来使用实体系统构建我们的游戏逻辑。最后，我们将所有积累的知识结合起来，构建了一个包含一些人工智能、用户界面、声音和动画的完整游戏。
- en: With all this knowledge, you are now able to build any kind of game based on
    a tile system without too much effort.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有所有这些知识，你现在可以轻松地基于拼图系统构建任何类型的游戏。
- en: In the next chapter, we will turn this game in a multiplayer one by using networking.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使用网络将这个游戏转变为多人游戏。
