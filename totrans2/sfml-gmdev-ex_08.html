<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. The More You Know – Common Game Programming Patterns</h1></div></div></div><p>As we move past the halfway point of this book, the bells and whistles in our games are going to get more and more advanced. To showcase them properly, the genre of our final project will be a classical 2D <strong>Role Playing Game</strong> with orthographic projection. With our code-base <a id="id295" class="indexterm"/>growing at a rapid rate, poor design quickly becomes tedious to maintain, or even unmanageable. As new features get added, we want expansion of code to be easy and not slow down the overall process. This is the area where game programming patterns shine the brightest.</p><p>In this chapter, we will be covering:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The design and implementation of the entity component system</li><li class="listitem" style="list-style-type: disc">Inter-system communication using the observer pattern</li><li class="listitem" style="list-style-type: disc">Render ordering</li><li class="listitem" style="list-style-type: disc">Implementation of map layers</li></ul></div><p>Let's not waste any time and jump right into making our code base more robust!</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Use of copyrighted resources</h1></div></div></div><p>Once <a id="id296" class="indexterm"/>again, before beginning this chapter, we'd like to give credit <a id="id297" class="indexterm"/>where credit's due. The graphics used for the third project of this book consist of but are not limited to:</p><p>
<em>[LPC] Medieval fantasy character sprites</em> by <em>wulax</em> under CC-BY-SA 3.0 and GPL 3.0 licenses:</p><p>
<a class="ulink" href="http://opengameart.org/content/lpc-medieval-fantasy-character-sprites">http://opengameart.org/content/lpc-medieval-fantasy-character-sprites</a>
</p><p>
<em>Lots of free 2D tiles and sprites</em> by <em>Hyptosis</em> under the CC-BY 3.0 license:</p><p>
<a class="ulink" href="http://opengameart.org/content/lots-of-free-2d-tiles-and-sprites-by-hyptosis">http://opengameart.org/content/lots-of-free-2d-tiles-and-sprites-by-hyptosis</a>
</p><p>All of the <a id="id298" class="indexterm"/>licenses that apply to the use of these resources<a id="id299" class="indexterm"/> can be found here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.gnu.org/licenses/gpl-3.0.html">http://www.gnu.org/licenses/gpl-3.0.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec71"/>What is a programming pattern?</h1></div></div></div><p>Programming<a id="id300" class="indexterm"/> patterns, or design patterns, at they're more commonly referred to, are reusable and widely-implemented solutions to a given problem. That is not to say that these patterns exist as some sort of libraries out there, although there are libraries based on them. Instead, a programming pattern is more of an idea or a strategy. It is a well laid out plan on tackling a certain problem, the best possible answer to a given problematic situation, proven by time and experience, which is one of the the best reasons they should be used.</p><p>There are quite a few design patterns out there, as well as books, tutorials and even classes dedicated solely to understanding and implementing them. For our purposes, we're going to be covering four: the entity component system, event queue, observer and factory patterns. We'll be talking about each one separately, as they're non overlapping in function, even though they can be working together.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec72"/>The entity component system</h1></div></div></div><p>The <strong>entity component system</strong> is a programming pattern, which allows entities to possess <a id="id301" class="indexterm"/>properties and functionality through the means of composition, as opposed to inheritance. The biggest benefits of using this pattern include stronger decoupling of logic, easier serialization and de-serialization of entities, better reusability of code and ease of creating new entities. It does, however, add a fair bit of complexity to your code base.</p><p>The typical implementation of this pattern consists of three parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Entities</strong>: In<a id="id302" class="indexterm"/> most cases, entities are barely anything more than identifiers, slapped on a collection of components</li><li class="listitem" style="list-style-type: disc"><strong>Components</strong>: These <a id="id303" class="indexterm"/>are the building blocks of entities, that are nothing more than collections of data</li><li class="listitem" style="list-style-type: disc"><strong>Systems</strong>: These are specialized classes that deal with a very specific task and are responsible<a id="id304" class="indexterm"/> for holding all of the logic in this paradigm</li></ul></div><p>In addition<a id="id305" class="indexterm"/> to working with these three distinct types of elements, our entity component system is also going to need an entity manager to keep and manage all of the entity and component data, as well as the system manager, which will be responsible for updating each system, in addition to some other functionality we'll be covering soon.</p><p>In order to differentiate between different types of components and systems, we're going to create a new header file, <code class="literal">ECS_Types.h</code>, which will be used to store this information:</p><div><pre class="programlisting">using ComponentType = unsigned int;
#define N_COMPONENT_TYPES 32

enum class Component{
 Position = 0, SpriteSheet, State, Movable, Controller, Collidable
};

enum class System{
 Renderer = 0, Movement, Collision, Control, State, SheetAnimation
};</pre></div><p>In addition to component and system enumerations, we're also aliasing an unsigned integer to act as the component type and defining a macro <code class="literal">N_COMPONENT_TYPES</code>, which represents the maximum number of component types we can have.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec36"/>What is a component?</h2></div></div></div><p>Within<a id="id306" class="indexterm"/> the entity component system paradigm, a<a id="id307" class="indexterm"/> <strong>component</strong> is the smallest, non-overlapping aspect of an entity, such as its position, velocity or a sprite. From the programming point of view, however, it is nothing more than a simple data structure, which has no real logic in it. Its only job is storing information about the feature of an entity it represents, as illustrated below:</p><div><img src="img/B04284_08_01.jpg" alt="What is a component?"/></div><p>In <a id="id308" class="indexterm"/>order to store components easily, they have to rely <a id="id309" class="indexterm"/>on principles of inheritance. Let's take a look at a base component class definition:</p><div><pre class="programlisting">class C_Base{
public:
  C_Base(const Component&amp; l_type): m_type(l_type){}
  virtual ~C_Base(){}

  Component GetType(){ return m_type; }

  friend std::stringstream&amp; operator &gt;&gt;(
    std::stringstream&amp; l_stream, C_Base&amp; b)
  {
    b.ReadIn(l_stream);
    return l_stream;
  }

  virtual void ReadIn(std::stringstream&amp; l_stream) = 0;
protected:
  Component m_type;
};</pre></div><p>The constructor of our component base class will take in the type of the component it represents. One thing to note is the overloaded <code class="literal">&gt;&gt;</code> operator, which calls a purely virtual function <code class="literal">ReadIn</code>. This serves as a quick way to read component data in from a file. Because each component is unique, it defines its own version of the <code class="literal">ReadIn</code> method in order <a id="id310" class="indexterm"/>to<a id="id311" class="indexterm"/> load its data correctly.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec37"/>The position component</h2></div></div></div><p>A <a id="id312" class="indexterm"/>good example of putting the base<a id="id313" class="indexterm"/> component class to work is actually implementing the first and arguably most common type of component: <strong>position</strong>.</p><div><pre class="programlisting">class C_Position : public C_Base{
public:
  C_Position(): C_Base(Component::Position), m_elevation(0){}
  ~C_Position(){}

  void ReadIn(std::stringstream&amp; l_stream){
    l_stream &gt;&gt; m_position.x &gt;&gt; m_position.y &gt;&gt; m_elevation;
  }

  const sf::Vector2f&amp; GetPosition(){ return m_position; }
  const sf::Vector2f&amp; GetOldPosition(){ return m_positionOld; }
  unsigned int GetElevation(){ return m_elevation; }

  void SetPosition(float l_x, float l_y){
    m_positionOld = m_position;
    m_position = sf::Vector2f(l_x,l_y);
  }

  void SetPosition(const sf::Vector2f&amp; l_vec){
    m_positionOld = m_position;
    m_position = l_vec;
  }

  void SetElevation(unsigned int l_elevation){
    m_elevation = l_elevation;
  }

  void MoveBy(float l_x, float l_y){
    m_positionOld = m_position;
    m_position += sf::Vector2f(l_x,l_y);
  }

  void MoveBy(const sf::Vector2f&amp; l_vec){
    m_positionOld = m_position;
    m_position += l_vec;
  }

private:
  sf::Vector2f m_position;
  sf::Vector2f m_positionOld;
  unsigned int m_elevation;
};</pre></div><p>The<a id="id314" class="indexterm"/> constructor of our component base class is<a id="id315" class="indexterm"/> invoked in the initializer list, with the component type being passed in as the only argument. Although there are better ways of assigning individual component types their own unique identifiers, it's better to start simple for clarity's sake.</p><p>This component keeps track of three pieces of data: its current position, the position it was at during the previous cycle, and the current elevation of an entity, which is simply a value that represents how high the entity is in relation to the map.</p><p>Much like any other component we will be covering later in the chapter, it offers a number of methods for modifying and obtaining its data members. While making its data members publically available is perfectly valid, offering helper methods reduces code redundancy and offers a familiar interface.</p><p>Lastly, note the implementation of the <code class="literal">ReadIn</code> method. It uses a <code class="literal">stringstream</code> object as an argument and loads the relevant pieces of data from it.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec38"/>The bitmask</h2></div></div></div><p>Having a <a id="id316" class="indexterm"/>lightweight, easy-to-use as well as easy-to-expend data structure, representing the makeup of any given entity, as<a id="id317" class="indexterm"/> well as a set of requirements imposed by a system saves a lot of headaches. For us, that data structure is a <strong>bitmask</strong>.</p><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>The standard template library provides its own version of a bitmask: the <code class="literal">std::bitset</code>. For educational purposes, we're going to be implementing our own version of this class.</p></div></div><p>As you probably know already, in binary, any and all numbers can be represented as a combination of zeroes and ones. However, who's to say that those two values have to be used only to represent a number? With some quick bitwise operator magic, any simple integer can be turned into a string of continuous flags that represent different aspects of an entity, such as which components it has, or types of components it needs to have in order to belong to a system. </p><p>Consider the following illustration:</p><div><img src="img/B04284_08_02.jpg" alt="The bitmask"/></div><p>The only<a id="id318" class="indexterm"/> real difference in practice would be a lot<a id="id319" class="indexterm"/> more than eight flags available. Let's get coding:</p><div><pre class="programlisting">#include &lt;stdint.h&gt;

using Bitset = uint32_t;
class Bitmask{
public:
  Bitmask() : bits(0){}
  Bitmask(const Bitset&amp; l_bits) : bits(l_bits){}

  Bitset GetMask() const{ return bits; }
  void SetMask(const Bitset&amp; l_value){ bits = l_value; }

  bool Matches(const Bitmask&amp; l_bits, 
    const Bitset&amp; l_relevant = 0)const
  {
    return(l_relevant ?
      ((l_bits.GetMask() &amp; l_relevant) == (bits &amp; l_relevant))
      :(l_bits.GetMask() == bits));
  }

  bool GetBit(const unsigned int&amp; l_pos)const{
    return ((bits&amp;(1 &lt;&lt; l_pos)) != 0);
  }
  void TurnOnBit(const unsigned int&amp; l_pos){
    bits |= 1 &lt;&lt; l_pos;
  }
  void TurnOnBits(const Bitset&amp; l_bits){
    bits |= l_bits;
  }
  void ClearBit(const unsigned int&amp; l_pos){
    bits &amp;= ~(1 &lt;&lt; l_pos);
  }
  void ToggleBit(const unsigned int&amp; l_pos){
    bits ^= 1 &lt;&lt; l_pos;
  }
  
  void Clear(){ bits = 0; }
private:
  Bitset bits;
};</pre></div><p>We begin<a id="id320" class="indexterm"/> by defining the data type for our bitset, kindly <a id="id321" class="indexterm"/>provided by the <code class="literal">stdint.h</code> header. As the name implies, the <code class="literal">uint32_t</code> type is exactly 32 bits wide. Using this type, and not, let's say, a typical integer, eliminates the possibility of cross-platform differences. A regular integer could take up less or more memory, depending on the platform our code is executed on. Using specialized types from the <code class="literal">stdint.h</code> header ensures the exact same results, regardless of platform differences.</p><p>The majority of the <code class="literal">Bitmask</code> class consists of nothing but bitwise operations, which are an essential part of the C/C++ background. If you are not yet familiar with them, it's not the end of the world, however, it would be more beneficial to at least understand how they work before moving forward.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Managing entities</h1></div></div></div><p>Now that <a id="id322" class="indexterm"/>we have the building blocks of entities defined, it's time to talk about storing and managing them. As mentioned previously, all an entity is at this point is a single identifier. Knowing that, we can begin shaping the way this data is going to be stored, beginning, as always, with the definition of data types to be used:</p><div><pre class="programlisting">using EntityId = unsigned int;

using ComponentContainer = std::vector&lt;C_Base*&gt;;
using EntityData = std::pair&lt;Bitmask,ComponentContainer&gt;;
using EntityContainer = std::unordered_map&lt;EntityId,EntityData&gt;;
using ComponentFactory = std::unordered_map&lt;
  Component,std::function&lt;C_Base*(void)&gt;&gt;;</pre></div><p>The first data type we'll be working with is the entity identifier, once again represented by an unsigned integer. Next, a container is needed to hold all of the components for an entity. A vector works just fine for this purpose. Following that, we define a pair, a bitmask and the component container, which will hold all of the information about the entity. The bitmask is used here in order to alleviate the need to iterate over containers searching for components, when it can be quickly queried for the same purpose. The last piece of the entity puzzle is mapping an entity identifier to all of its data, for which we'll be using the <code class="literal">unordered_map</code>.</p><p>In order <a id="id323" class="indexterm"/>to generate different component types with as little code as possible, we'll be using our trusty lambda-expression factory method here as well. The last four lines of type definitions here make that possible.</p><p>Having all of the data types defined allows us to finally take a look at the entity manager class declaration:</p><div><pre class="programlisting">class SystemManager;
class EntityManager{
public:
  EntityManager(SystemManager* l_sysMgr,
    TextureManager* l_textureMgr);
  ~EntityManager();

  int AddEntity(const Bitmask&amp; l_mask);
  int AddEntity(const std::string&amp; l_entityFile);
  bool RemoveEntity(const EntityId&amp; l_id);

  bool AddComponent(const EntityId&amp; l_entity,
    const Component&amp; l_component);

  template&lt;class T&gt;
  T* GetComponent(const EntityId&amp; l_entity,
    const Component&amp; l_component){ ... }

  bool RemoveComponent(const EntityId&amp; l_entity,
    const Component&amp; l_component);
  bool HasComponent(const EntityId&amp; l_entity,
    const Component&amp; l_component);

  void Purge();
private:
  template&lt;class T&gt;
  void AddComponentType(const Component&amp; l_id){
    m_cFactory[l_id] = []()-&gt;C_Base* { return new T(); };
  }

  // Data members
  unsigned int m_idCounter;
  EntityContainer m_entities;
  ComponentFactory m_cFactory;

  SystemManager* m_systems;
  TextureManager* m_textureManager;
};</pre></div><p>In a fairly <a id="id324" class="indexterm"/>predictable fashion, we have all of the methods that would exist in any other class that serves as a container. Two different versions of adding entities are provided, one based on a bitmask passed in as an argument, and the other for loading an entity configuration from a file. The method for obtaining a component from a specific entity is templated, reducing the amount of code that has to be written outside of this class in order to obtain the type of component that is desired. Let's take a look at how it's implemented:</p><div><pre class="programlisting">template&lt;class T&gt;
T* GetComponent(const EntityId&amp; l_entity,
  const Component&amp; l_component)
{
  auto itr = m_entities.find(l_entity);
  if (itr == m_entities.end()){ return nullptr; }
  // Found the entity.
  if (!itr-&gt;second.first.GetBit((unsigned int)l_component))
  {
    return nullptr;
  }
  // Component exists.
  auto&amp; container = itr-&gt;second.second;
  auto component = std::find_if(container.begin(),container.end(),
    [&amp;l_component](C_Base* c){
      return c-&gt;GetType() == l_component;
    });
  return (component != container.end() ?
    dynamic_cast&lt;T*&gt;(*component) : nullptr);
}</pre></div><p>The entity argument passed into the method is evaluated first, in order to determine if one with the provided identifier exists. If it does, the bitmask of that entity is checked to verify that a component with the requested type is part of it. The component is then located in the vector and returned as the dynamically-cast type of the template.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec39"/>Implementing the entity manager</h2></div></div></div><p>With <a id="id325" class="indexterm"/>the class definition out of the way, we can <a id="id326" class="indexterm"/>start implementing its methods. As per usual, let's address the constructor and destructor of the entity manager class first: </p><div><pre class="programlisting">EntityManager::EntityManager(SystemManager* l_sysMgr, 
  TextureManager* l_textureMgr): m_idCounter(0), 
  m_systems(l_sysMgr), m_textureManager(l_textureMgr)
{
  AddComponentType&lt;C_Position&gt;(Component::Position);
  AddComponentType&lt;C_SpriteSheet&gt;(Component::SpriteSheet);
  AddComponentType&lt;C_State&gt;(Component::State);
  AddComponentType&lt;C_Movable&gt;(Component::Movable);
  AddComponentType&lt;C_Controller&gt;(Component::Controller);
  AddComponentType&lt;C_Collidable&gt;(Component::Collidable);
}

EntityManager::~EntityManager(){ Purge(); }</pre></div><p>The <a id="id327" class="indexterm"/>constructor takes in a pointer to the <code class="literal">SystemManager</code> class, which we will be implementing shortly, as well as a pointer the <code class="literal">TextureManager</code>. In its<a id="id328" class="indexterm"/> initializer list, the <code class="literal">idCounter</code> data member is set to zero. This is simply a variable that will be used to keep track of the last identifier that was given to an entity. Additionally, both the system manager and the texture manager pointers are stored for later reference. The last purpose of the constructor is adding all of the different types of components to the component factory.</p><p>The destructor simply invokes a <code class="literal">Purge</code> method, which will be used to clean up all of the dynamically allocated memory and clear all possible containers in this class.</p><div><pre class="programlisting">int EntityManager::AddEntity(const Bitmask&amp; l_mask){
  unsigned int entity = m_idCounter;
  if (!m_entities.emplace(entity,
    EntityData(0,ComponentContainer())).second)
  { return -1; }
  ++m_idCounter;
  for(unsigned int i = 0; i &lt; N_COMPONENT_TYPES; ++i){
    if(l_mask.GetBit(i)){ AddComponent(entity,(Component)i); }
  }
  // Notifying the system manager of a modified entity.
  m_systems-&gt;EntityModified(entity,l_mask);
  m_systems-&gt;AddEvent(entity,(EventID)EntityEvent::Spawned);
  return entity;
}</pre></div><p>In the case of adding an entity based on the provided bitmask, a new entity pair is inserted into the entity container first. If the insertion was successful, a <code class="literal">for</code> loop iterates over all possible types of components and checks the mask for that type. The <code class="literal">AddComponent</code> method is then invoked, if the bitmask has the said type enabled.</p><p>After the component insertion, the system manager is notified of an entity being modified, or, in this case, inserted. The entity identifier, along with the bitmask of the said entity is passed into the <code class="literal">EntityModified</code> method of the system manager. An event is also created to alert the systems that this entity just spawned.</p><p>The identifier of the newly created entity is then returned. If the method failed to add an entity, -1 is returned instead, to signify an error.</p><p>Removing <a id="id329" class="indexterm"/>an entity is every bit as easy, if not <a id="id330" class="indexterm"/>more so:</p><div><pre class="programlisting">bool EntityManager::RemoveEntity(const EntityId&amp; l_id){
  auto itr = m_entities.find(l_id);
  if (itr == m_entities.end()){ return false; }
  // Removing all components.
  while(itr-&gt;second.second.begin() != itr-&gt;second.second.end()){
    delete itr-&gt;second.second.back();
    itr-&gt;second.second.pop_back();
  }
  m_entities.erase(itr);
  m_systems-&gt;RemoveEntity(l_id);
  return true;
}</pre></div><p>After the entity is successfully located in the entity container, the dynamically allocated memory of every single component it has is first freed, and the component is then removed from the vector. The entity itself is then erased from the entity container and the system manager is notified of its removal.</p><div><pre class="programlisting">bool EntityManager::AddComponent(const EntityId&amp; l_entity, 
  const Component&amp; l_component)
{
  auto itr = m_entities.find(l_entity);
  if (itr == m_entities.end()){ return false; }
  if (itr-&gt;second.first.GetBit((unsigned int)l_component))
  {
    return false;
  }
  // Component doesn't exist.
  auto itr2 = m_cFactory.find(l_component);
  if (itr2 == m_cFactory.end()){ return false; }
  // Component type does exist.
  C_Base* component = itr2-&gt;second();
  itr-&gt;second.second.emplace_back(component);
  itr-&gt;second.first.TurnOnBit((unsigned int)l_component);
  // Notifying the system manager of a modified entity.
  m_systems-&gt;EntityModified(l_entity,itr-&gt;second.first);
  return true;
}</pre></div><p>Adding a component to an entity begins by verifying an entity with the provided identifier exists. If it does, and if there isn't already a component of that type added to the entity, the lambda-function container is queried for the desired type. Once the memory for the<a id="id331" class="indexterm"/> component is allocated, it's pushed into the <a id="id332" class="indexterm"/>component vector. The bitmask is then modified to reflect the changes made to the entity. The system manager is notified of those changes as well.</p><p>Predictably, a very similar process takes place when removing the component from an entity:</p><div><pre class="programlisting">bool EntityManager::RemoveComponent(const EntityId&amp; l_entity,
  const Component&amp; l_component)
{
  auto itr = m_entities.find(l_entity);
  if (itr == m_entities.end()){ return false; }
  // Found the entity.
  if (!itr-&gt;second.first.GetBit((unsigned int)l_component))
  {
    return false;
  }
  // Component exists.
  auto&amp; container = itr-&gt;second.second;
  auto component = std::find_if(container.begin(),container.end(),
    [&amp;l_component](C_Base* c){
      return c-&gt;GetType() == l_component;
    });
  if (component == container.end()){ return false; }
  delete (*component);
  container.erase(component);
  itr-&gt;second.first.ClearBit((unsigned int)l_component);

  m_systems-&gt;EntityModified(l_entity, itr-&gt;second.first);
  return true;
}</pre></div><p>After confirming that both the entity and component exist, the memory allocated for the component is freed and the component itself is erased. The bitmask also gets modified to reflect these changes. Much like before, the system manager needs to know if an entity was altered, so the <code class="literal">EntityModified</code> method is invoked.</p><p>A fairly useful method to have for outside classes is one that checks if an entity has a certain type of component:</p><div><pre class="programlisting">bool EntityManager::HasComponent(const EntityId&amp; l_entity,
  const Component&amp; l_component)
{
  auto itr = m_entities.find(l_entity);
  if (itr == m_entities.end()){ return false; }
  return itr-&gt;second.first.GetBit((unsigned int)l_component);
}</pre></div><p>This follows the same pattern as before by checking if an entity exists first, then checking its bitmask for a certain component type.</p><p>It's<a id="id333" class="indexterm"/> cleanup time. Correctly disposing of all allocated <a id="id334" class="indexterm"/>resources is left up to the <code class="literal">Purge</code> method:</p><div><pre class="programlisting">void EntityManager::Purge(){
  m_systems-&gt;PurgeEntities();
  for(auto&amp; entity : m_entities){
    for(auto &amp;component : entity.second.second){delete component;}
    entity.second.second.clear();
    entity.second.first.Clear();
  }
  m_entities.clear();
  m_idCounter = 0;
}</pre></div><p>The system manager is notified to remove all of its entities first. While iterating over all of the entities in storage, it frees up the memory of every single component. The component container is then cleared. Lastly, the entity container itself is cleared and the identification counter is set back to 0.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec05"/>The factory pattern</h3></div></div></div><p>With <a id="id335" class="indexterm"/>complex data structures such as entities, chances are the <a id="id336" class="indexterm"/>programmer will not be setting up and initializing every single component by hand. Setting up entities with any arrangement of components quickly and with as little repeated code as possible is very much the goal here. Luckily, a programming pattern exists to solve this particular problem. It is simply referred to as the <strong>factory</strong> pattern.</p><p>The philosophy of use for this neat pattern is quite simple. There exists a class with some abstract method that takes in one or two arguments, pertaining to some vague identifying qualities. This class then generates, based on the information it was given, a class or a number of classes and returns a handle to them, effectively cutting out the part where data allocation or member initialization is done by hand. In other words, it is given a blueprint and produces a product based on it, hence the name "factory". This functionality was already achieved in a way by creating entities based on a bitmask, however, no actual data was initialized, only the defaults. Having a more pristine way of actually setting up these entities requires a more elaborate blueprint, so why not use text files? For example:</p><div><pre class="programlisting">Name Player
Attributes 63
|Component|ID|Individual attributes|
Component 0 0 0 1
...</pre></div><p>This format<a id="id337" class="indexterm"/> would allow everything there is to an entity to be <a id="id338" class="indexterm"/>stored in plain text as a blueprint and loaded at any time to produce any number of entities with exactly the same qualities. Let's take a look at how processing entity files could be achieved:</p><div><pre class="programlisting">int EntityManager::AddEntity(const std::string&amp; l_entityFile){
  int EntityId = -1;

  std::ifstream file;
  file.open(Utils::GetWorkingDirectory() +
    "media/Entities/" + l_entityFile + ".entity");
  if (!file.is_open()){
    std::cout &lt;&lt; "! Failed to load entity: "
      &lt;&lt; l_entityFile &lt;&lt; std::endl;
    return -1;
  }
  std::string line;
  while(std::getline(file,line)){
    if (line[0] == '|'){ continue; }
    std::stringstream keystream(line);
    std::string type;
    keystream &gt;&gt; type;
    if(type == "Name"){
      
    } else if(type == "Attributes"){
      if (EntityId != -1){ continue; }
      Bitset set = 0;
      Bitmask mask;
      keystream &gt;&gt; set;
      mask.SetMask(set);
      EntityId = AddEntity(mask);
      if(EntityId == -1){ return -1; }
    } else if(type == "Component"){
      if (EntityId == -1){ continue; }
      unsigned int c_id = 0;
      keystream &gt;&gt; c_id;
      C_Base* component = GetComponent&lt;C_Base&gt;
        (EntityId,(Component)c_id);
      if (!component){ continue; }
      keystream &gt;&gt; *component;
      if(component-&gt;GetType() == Component::SpriteSheet){
        C_SpriteSheet* sheet = (C_SpriteSheet*)component;
        sheet-&gt;Create(m_textureManager);
      }
    }
  }
  file.close();
  return EntityId;
}</pre></div><p>Loading<a id="id339" class="indexterm"/> entity files isn't much different from any other files <a id="id340" class="indexterm"/>we've processed in the past. For now, reading entity names hasn't yet been implemented. The attributes line is simply the numeric value that the bitmask has with the desired components enabled. Once that value is read in, we pass it in to the other version of <code class="literal">AddEntity</code>, in order to create it and have all of the components properly allocated.</p><p>Reading in the actual components is slightly more complicated. First, we must make sure that the entity has been created. This means that the "Attributes" line has to come before the individual component data in the entity file. If the entity ID is greater than -1, we proceed with reading in the component ID and obtaining the actual object based on it. The overloaded <code class="literal">&gt;&gt;</code> operator comes in handy here, since it greatly simplifies actually streaming in the component data.</p><p>Lastly, due to the nature of resource handling, the component type has to be checked in order to provide its instance with a pointer to the texture manager class, if it needs it. We haven't yet created such components, however one of them will be the sprite sheet component that will represent some entities.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Designing the systems</h1></div></div></div><p>With <a id="id341" class="indexterm"/>the data side of this paradigm being accounted for, the last remaining<a id="id342" class="indexterm"/> component remains to be the <strong>system</strong>. As the name loosely implies, systems are responsible for handling all of the logic that takes place inside and between components. Things ranging from sprites being rendered to collision checks are all handled by their own, respective systems to ensure complete separation between non-overlapping parts of the game. At least, that's how it should play out in an ideal world. In reality, as hard as one tries to decouple and categorize logic or data, some things still remain loosely connected, which is just the nature of the beast. Information still has to be traded between systems, however. Certain functionality also needs to be invoked as a consequence of a totally unrelated system's actions. To put it simply, there needs to be a way for systems<a id="id343" class="indexterm"/> to talk to each other without them knowing anything about how the other one works.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec40"/>Entity events</h2></div></div></div><p>A fairly<a id="id344" class="indexterm"/> simplistic, and as it happens, necessary approach to handling<a id="id345" class="indexterm"/> inter-system relations is dispatching events. Every other system could be listening for those events and performing their own logic, completely separate from everything else, in response to a certain event taking place. Let's take a look at a possible list of entity events:</p><div><pre class="programlisting">enum class EntityEvent{ 
  Spawned, Despawned, Colliding_X, Colliding_Y, 
  Moving_Left, Moving_Right, Moving_Up, Moving_Down,
  Elevation_Change, Became_Idle, Began_Moving
};</pre></div><p>This should give you a pretty good idea of how system communication will take place. Let's say that an entity is moving in the left direction. The "movement system" starts dispatching events, saying that it's in motion. The "animation system" listens for those events, and when they're received, it proceeds to increase frames in the entity's sprite sheet. Keep in mind that all of these chunks of logic are still completely separate from one another. The "movement system" is not increasing the frames of the entity's sprite sheet. It's simply saying to all of the other systems "Hello, I am moving entity x to the left," while they listen and react. It sounds like we can benefit from the "event queue."</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec06"/>Entity event queue</h3></div></div></div><p>The <strong>event queue</strong> is a <a id="id346" class="indexterm"/>programming pattern, which is used to<a id="id347" class="indexterm"/> decouple when an event is fired from when it's actually processed. This illustration should capture the essence of it:</p><div><img src="img/B04284_08_03.jpg" alt="Entity event queue"/></div><p>A queue is what's referred to as a First-In-First-Out data container. The data that is pushed onto it earliest is removed first. This serves our needs nicely. As the definition of the event <a id="id348" class="indexterm"/>queue states, its events are processed at a completely <a id="id349" class="indexterm"/>different time in relation to them being added. With that in mind, let's start designing the <code class="literal">EventQueue</code> class:</p><div><pre class="programlisting">using EventID = unsigned int;

class EventQueue{
public:
  void AddEvent(const EventID&amp; l_event){m_queue.push(l_event);}

  bool ProcessEvents(EventID&amp; l_id){
    if (m_queue.empty()){ return false; }
    l_id = m_queue.front();
    m_queue.pop();
    return true;
  }

  void Clear(){ while(!m_queue.empty()){ m_queue.pop(); }}
private:
  std::queue&lt;EventID&gt; m_queue;
};</pre></div><p>The event identifier is represented with an unsigned integer. In order to store the actual events, we'll be using, appropriately enough, a <code class="literal">queue</code> container. Adding an event to it is as simple as any other STL container. This class offers a method that can be used with while loops in order to simplify event processing. It returns a Boolean value in order to break the loop when the event queue is empty and its sole argument is taken by reference, in order to modify it each time the method is called. This is similar to the way SFML handles events.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec41"/>The base system</h2></div></div></div><p>In order <a id="id350" class="indexterm"/>to begin implementing our systems, they must first have a<a id="id351" class="indexterm"/> common base class, which not only provides a common interface that must be implemented, but also eliminates code redundancy. Much like most other classes we build, it will have its own data types defined:</p><div><pre class="programlisting">using EntityList = std::vector&lt;EntityId&gt;;
using Requirements = std::vector&lt;Bitmask&gt;;</pre></div><p>The system identifier, just like the component identifier, is represented by an unsigned integer. All of the entity identifiers will be stored in a vector container, much like the requirement bitmasks. The reason we would ever want to have more than one requirement bitmask is to have the ability to define combinations of different types of components that could still belong to the same system. A good example of that would be different drawable types belonging to the same rendering system.</p><p>Let's take <a id="id352" class="indexterm"/>a look <a id="id353" class="indexterm"/>at the header of our system base class:</p><div><pre class="programlisting">class SystemManager;
class S_Base{
public:
  S_Base(const System&amp; l_id, SystemManager* l_systemMgr);
  virtual ~S_Base();

  bool AddEntity(const EntityId&amp; l_entity);
  bool HasEntity(const EntityId&amp; l_entity);
  bool RemoveEntity(const EntityId&amp; l_entity);

  System GetId();

  bool FitsRequirements(const Bitmask&amp; l_bits);
  void Purge();

  virtual void Update(float l_dT) = 0;
  virtual void HandleEvent(const EntityId&amp; l_entity,
    const EntityEvent&amp; l_event) = 0;
protected:
  System m_id;
  Requirements m_requiredComponents;
  EntityList m_entities;

  SystemManager* m_systemManager;
};</pre></div><p>We want every single system to have its own update method, as well as its own version of event handling. Additionally, systems having access to their own manager is also desired. Everything else that is not system-specific, like checking requirement bitmasks, is handled by the base class.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec07"/>Implementing the base system</h3></div></div></div><p>Because all <a id="id354" class="indexterm"/>systems require a pointer to the system manager, there's an issue of cross-inclusion. A forward declaration of it right before the class header and the inclusion of the system manager header in the implementation file takes care of the issue:</p><div><pre class="programlisting">#include "System_Manager.h"</pre></div><p>Time to go down the list of methods to implement, starting with the constructor and destructor:</p><div><pre class="programlisting">S_Base::S_Base(const System&amp; l_id, SystemManager* l_systemMgr) 
    : m_id(l_id), m_systemManager(l_systemMgr){}

S_Base::~S_Base(){ Purge(); }</pre></div><p>Each system<a id="id355" class="indexterm"/> has to have its own identifier, much like all of the components. That gets passed in the argument list to the constructor, along with a pointer to the system manager. Aside from setting the appropriate data members to these values in an initializer list, the constructor of a base system does nothing else.</p><p>The destructor, following the typical fashion, invokes the <code class="literal">Purge</code> method to do the cleanup.</p><div><pre class="programlisting">bool S_Base::AddEntity(const EntityId&amp; l_entity){
  if (HasEntity(l_entity)){ return false; }
  m_entities.emplace_back(l_entity);
  return true;
}</pre></div><p>Adding an entity to a system is fairly easy. If the identifier that was provided as an argument doesn't already exist within the said system, it simply gets pushed into the vector. How does a system determine if it has an entity with such an identifier? Let's find out:</p><div><pre class="programlisting">bool S_Base::HasEntity(const EntityId&amp; l_entity){
  return std::find(m_entities.begin(),
    m_entities.end(), l_entity) != m_entities.end();
}</pre></div><p>Utilizing the <code class="literal">std::find</code> function allows us to sum up this method in a single line. Removing an entity also takes advantage of a similar function:</p><div><pre class="programlisting">bool S_Base::RemoveEntity(const EntityId&amp; l_entity){
  auto entity = std::find_if(m_entities.begin(), m_entities.end(),
    [&amp;l_entity](EntityId&amp; id){ return id = l_entity; });
  if (entity == m_entities.end()){ return false; }
  m_entities.erase(entity);
  return true;
}</pre></div><p>In this case, we're using the <code class="literal">std::find_if</code> function, which takes a predicate as the third argument. A predicate is just another function that compares two elements together in order to find a match. In this case, we simply construct a lambda function that takes in an <code class="literal">EntityId</code> and returns a Boolean value, which will tell the find function whether a match was found. If it was, the entity is then removed.</p><p>Each system has to make sure that an entity has all the required components in order to be added to it. That's where this method comes in:</p><div><pre class="programlisting">bool S_Base::FitsRequirements(const Bitmask&amp; l_bits){
  return std::find_if(m_requiredComponents.begin(),
    m_requiredComponents.end(), [&amp;l_bits](Bitmask&amp; b){
      return b.Matches(l_bits, b.GetMask());
    }) != m_requiredComponents.end();
}</pre></div><p>It takes in<a id="id356" class="indexterm"/> a bitmask as an argument and utilizes the same <code class="literal">std::find_if</code> function in conjunction with a lambda to locate a match. Very few systems will even need to define more than one bitmask for its required components, however it's nice to have this functionality when the need for it arises.</p><p>Lastly, here's the method for cleaning up:</p><div><pre class="programlisting">void S_Base::Purge(){ m_entities.clear(); }</pre></div><p>Because there's no actual dynamic memory being allocated here, it's safe to just empty the container of all the entity identifiers.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec42"/>Handling messages</h2></div></div></div><p>Entity <a id="id357" class="indexterm"/>events, while useful for a lot of situations, aren't perfect for<a id="id358" class="indexterm"/> everything. For instance, carrying data between systems is impossible using the event queue. The events are also being delivered to every single system, which can be wasteful. Instead, why not have an additional method of communication that not only carries data around, but also allows systems to pick and choose what they want to receive? Entity component system messaging serves exactly that purpose, and there just so happens to be yet another programming pattern, which allows easy implementation of the message-subscription approach.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec08"/>The observer pattern</h3></div></div></div><p>As the<a id="id359" class="indexterm"/> name entails, the <strong>observer</strong> pattern allows its users to pick <a id="id360" class="indexterm"/>and choose what they will be notified of. In other words, the observer will lay dormant after subscribing to information types it wishes to receive, and will only be notified if those types are encountered. Let's take a look at a very basic implementation of the <code class="literal">Observer</code> base class: </p><div><pre class="programlisting">class Observer{
public:
    virtual ~Observer(){}
    virtual void Notify(const Message&amp; l_message) = 0;
};</pre></div><p>The <code class="literal">Observer</code> class is simply an interface, the inheritors of which must define a single method in order to use it. Although it looks simple, many features we desire in our game wouldn't be <a id="id361" class="indexterm"/>possible without it. Let's take a look at what these<a id="id362" class="indexterm"/> observers will be notified with:</p><div><pre class="programlisting">using MessageType = unsigned int;
struct TwoFloats{ float m_x; float m_y; };

struct Message{
    Message(const MessageType&amp; l_type) : m_type(l_type){}

    MessageType m_type;
    int m_sender;
    int m_receiver;

    union{
        TwoFloats m_2f;
        bool m_bool;
        int m_int;
    };
};</pre></div><p>Aside from holding the information about the sender and receiver entities, as well as the message type, it employs a <code class="literal">union</code> in order to avoid inheritance. That essentially means that all of the data members within this union will be sharing the same space in memory, and only one of them can be valid at a time.</p><p>The last piece of the puzzle is containing all possible observers in a <code class="literal">Communicator</code> class. For this, we'll be using a vector:</p><div><pre class="programlisting">using ObserverContainer = std::vector&lt;Observer*&gt;;</pre></div><p>Because this class has relatively simple methods that simply deal with managing a vector container, let's take a look at the full class definition head to toe:</p><div><pre class="programlisting">class Communicator{
public:
  ~Communicator(){ m_observers.clear(); }

  bool AddObserver(Observer* l_observer){
    if (HasObserver(l_observer)){ return false; }
    m_observers.emplace_back(l_observer);
    return true;
  }

  bool RemoveObserver(Observer* l_observer){
    auto observer = std::find_if(m_observers.begin(),
      m_observers.end(), [&amp;l_observer](Observer* o){
        return o == l_observer; });
    if (observer == m_observers.end()){ return false; }
    m_observers.erase(observer);
    return true;
  }

  bool HasObserver(const Observer* l_observer){
    return (std::find_if(m_observers.begin(), m_observers.end(),
      [&amp;l_observer](Observer* o){
        return o == l_observer;
      }) != m_observers.end());
  }

  void Broadcast(const Message&amp; l_msg){
    for(auto&amp; itr : m_observers){ itr-&gt;Notify(l_msg); }
  }

private:
  ObserverContainer m_observers;
};</pre></div><p>The basic<a id="id363" class="indexterm"/> methods for adding, removing and looking for an observer <a id="id364" class="indexterm"/>are all typical. One thing to note, however, is the <code class="literal">Broadcast</code> method, which simply invokes the <code class="literal">Notify</code> method of an observer and passes in a message to send.</p><p>Last, and definitely the least amount of code is responsible for actually putting the observer approach to use:</p><div><pre class="programlisting">class S_Base : public Observer{ ... }</pre></div><p>Because the base system class has virtual methods, it doesn't need to implement its own version of <code class="literal">Notify</code>. That will be the job for all the systems that inherit from this class.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec43"/>The message handler class</h2></div></div></div><p>We <a id="id365" class="indexterm"/>have all of the pieces to build a cohesive messaging <a id="id366" class="indexterm"/>system. Let's take a look at some data types that will be used to store message subscription information:</p><div><pre class="programlisting">using Subscribtions = std::unordered_map&lt;
  EntityMessage,Communicator&gt;;</pre></div><p>Each possible message type will have its own communicator that will broadcast the message to all of its observers. Using an <code class="literal">unordered_map</code> is perfect for expressing such a relationship.</p><p>The message handler is a very simple class, so let's take a look at its entire implementation:</p><div><pre class="programlisting">class MessageHandler{
public:
  bool Subscribe(const EntityMessage&amp; l_type
    Observer* l_observer)
  {
    return m_communicators[l_type].AddObserver(l_observer);
  }

  bool Unsubscribe(const EntityMessage&amp; l_type,
    Observer* l_observer)
  {
    return m_communicators[l_type].RemoveObserver(l_observer);
  }

  void Dispatch(const Message&amp; l_msg){
    auto itr = m_communicators.find(
      (EntityMessage)l_msg.m_type);
    if (itr == m_communicators.end()){ return; }
    itr-&gt;second.Broadcast(l_msg);
  }
private:
  Subscriptions m_communicators;
};</pre></div><p>Subscribing <a id="id367" class="indexterm"/>and unsubscribing to message types is simply <a id="id368" class="indexterm"/>done by manipulating the unordered map data container. When a message is dispatched, the message type in the subscription container is queried. If it is found, the communicator's <code class="literal">Broadcast</code> method is invoked with the message passed in as the argument.</p><p>At this point you might be wondering what kind of messages we'll be handling. Let's take a gander at the <code class="literal">EntityMessages.h</code> file:</p><div><pre class="programlisting">enum class EntityMessage{ 
    Move, Is_Moving, State_Changed, Direction_Changed,
    Switch_State, Attack_Action, Dead
};</pre></div><p>The purpose of a messaging system quickly becomes clear, even by simply reading the names of message types. Every one of them lends itself to either needing to contain extra data or only ever applying to a single system.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec75"/>Managing systems</h1></div></div></div><p>Finally, we've <a id="id369" class="indexterm"/>arrived at the last stop on the entity component system route: handling systems themselves. Let's quickly review our custom data types for this class:</p><div><pre class="programlisting">using SystemContainer = std::unordered_map&lt;System,S_Base*&gt;;
using EntityEventContainer = std::unordered_map&lt;
  EntityId,EventQueue&gt;;</pre></div><p>The first data type, <code class="literal">SystemContainer</code>, is really hard to misinterpret. An unordered map is used to link system identifiers to actual systems. The second type definition here is responsible for storage of entity events. It also uses an unordered map and links entity identifiers to <code class="literal">EventQueue</code> instances, that all hold events for a specific entity until they're processed.</p><p>It's time to design the system manager class:</p><div><pre class="programlisting">class EntityManager;
class SystemManager{
public:
  SystemManager();
  ~SystemManager();

  void SetEntityManager(EntityManager* l_entityMgr);
  EntityManager* GetEntityManager();
  MessageHandler* GetMessageHandler();

  template&lt;class T&gt;
  T* GetSystem(const System&amp; l_system){...}
  
  void AddEvent(const EntityId&amp; l_entity, const EventID&amp; l_event);

  void Update(float l_dT);
  void HandleEvents();
  void Draw(Window* l_wind, unsigned int l_elevation);

  void EntityModified(const EntityId&amp; l_entity,
    const Bitmask&amp; l_bits);
  void RemoveEntity(const EntityId&amp; l_entity);
  
  void PurgeEntities();
  void PurgeSystems();
private:
  SystemContainer m_systems;
  EntityManager* m_entityManager;
  EntityEventContainer m_events;
  MessageHandler m_messages;
};</pre></div><p>As expected, it needs to have methods for adding and handling events, updating and drawing the<a id="id370" class="indexterm"/> systems, notifying them of entity changes and removal requests, and obtaining them as well. The template method for getting a particular system is implemented this way:</p><div><pre class="programlisting">template&lt;class T&gt;
T* GetSystem(const System&amp; l_system){
  auto itr = m_systems.find(l_system);
  return(itr != m_systems.end() ?
    dynamic_cast&lt;T*&gt;(itr-&gt;second) : nullptr);
}</pre></div><p>Just like the entity manager's method of obtaining components, this method relies on the use of templates and dynamic casting in order to obtain a system in the correct form.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec44"/>Implementing the system manager</h2></div></div></div><p>Cross-inclusion peaks its ugly head once more, so we must combat it with forward declarations <a id="id371" class="indexterm"/>and inclusions of headers in the implementation files:</p><div><pre class="programlisting">#include "Entity_Manager.h"</pre></div><p>With that out of the way, we can now start implementing the constructor and destructor:</p><div><pre class="programlisting">SystemManager::SystemManager(): m_entityManager(nullptr){
  m_systems[System::State] = new S_State(this);
  m_systems[System::Control] = new S_Control(this);
  m_systems[System::Movement] = new S_Movement(this);
  m_systems[System::Collision] = new S_Collision(this);
  m_systems[System::SheetAnimation] = new S_SheetAnimation(this);
  m_systems[System::Renderer] = new S_Renderer(this);
}

SystemManager::~SystemManager(){
  PurgeSystems();
}</pre></div><p>The constructor sets up a pointer to an entity manager class before initializing all of the systems it holds. The destructor performs its usual job of cleaning up the mess, which is entrusted to the <code class="literal">PurgeSystems</code> method.</p><p>Because the system manager needs to have a pointer to the entity manager and vice versa, the one that's instantiated first will not simply be able to take a pointer to the other class in its constructor, hence the need for the <code class="literal">SetEntityManager</code> method:</p><div><pre class="programlisting">void SystemManager::SetEntityManager(EntityManager* l_entityMgr){
    if(!m_entityManager){ m_entityManager = l_entityMgr; }
}</pre></div><p>With a class<a id="id372" class="indexterm"/> so broadly applied, it needs to provide getter methods for its data members:</p><div><pre class="programlisting">EntityManager* SystemManager::GetEntityManager(){
    return m_entityManager;
}

MessageHandler* SystemManager::GetMessageHandler(){
    return &amp;m_messages;
}</pre></div><p>This ensures that all systems have access to the message handler, as well as the entity handler.</p><p>Speaking of system access, they also must be able to add events to any entity:</p><div><pre class="programlisting">void SystemManager::AddEvent(const EntityId&amp; l_entity, const EventID&amp; l_event)
{
    m_events[l_entity].AddEvent(l_event);
}</pre></div><p>Using an <code class="literal">unordered_map</code> structure here really makes this method simple and neat. The entity identifier being the key, it's easy to access its individual event queue and add to it.</p><p>Providing we want those systems to tick, an update loop is in order:</p><div><pre class="programlisting">void SystemManager::Update(float l_dT){
  for(auto &amp;itr : m_systems){
    itr.second-&gt;Update(l_dT);
  }
  HandleEvents();
}</pre></div><p>Here, every single system's update method is invoked and the elapsed time is passed in. The event handling takes place after all of the systems have been updated. Time to dissect that method:</p><div><pre class="programlisting">void SystemManager::HandleEvents(){
  for(auto &amp;event : m_events){
    EventID id = 0;
    while(event.second.ProcessEvents(id)){
      for(auto &amp;system : m_systems)
      {
        if(system.second-&gt;HasEntity(event.first)){
          system.second-&gt;HandleEvent(event.first,(EntityEvent)id);
        }
      }
    }
  }
}</pre></div><p>We begin by iterating over the event queues of different entities. An event identifier variable is set up and used in a <code class="literal">while</code> loop by reference, in order to obtain information from the queue. Every system in the manager is iterated over and checked for having the entity of interest. If it does, the system's <code class="literal">HandleEvent</code> method is invoked and the relevant<a id="id373" class="indexterm"/> information is passed in. That, in a nutshell, concludes event management on a larger scale. Now every individual system only has to worry about which events it wants to handle and how it wants to respond to them.</p><p>In order to populate the dark void of the screen with entities, we're going to need a <code class="literal">Draw</code> method:</p><div><pre class="programlisting">void SystemManager::Draw(Window* l_wind,
  unsigned int l_elevation)
{
  auto itr = m_systems.find(System::Renderer);
  if (itr == m_systems.end()){ return; }
  S_Renderer* system = (S_Renderer*)itr-&gt;second;
  system-&gt;Render(l_wind, l_elevation);
}</pre></div><p>For most needs, having a single system devoted to rendering entities more than suffices. Ergo, the renderer system is located in the system container and type-cast up from the base class. Its <code class="literal">Render</code> method is then invoked with relevant arguments, one of which is the current elevation that's being rendered. Drawing it this way allows the feel of "depth" to be achieved within our game.</p><p>As entities are not static in their composure, systems must be aware of these changes and properly take in or dispose of them, given the circumstances. This specific method has already been brought up multiple times during the implementation of the entity manager class, so let's take a look at how it works:</p><div><pre class="programlisting">void SystemManager::EntityModified(const EntityId&amp; l_entity,
  const Bitmask&amp; l_bits)
{
  for(auto &amp;s_itr : m_systems){
    S_Base* system = s_itr.second;
    if(system-&gt;FitsRequirements(l_bits)){
      if(!system-&gt;HasEntity(l_entity)){
        system-&gt;AddEntity(l_entity);
      }
    } else {
      if(system-&gt;HasEntity(l_entity)){
        system-&gt;RemoveEntity(l_entity);
      }
    }
  }
}</pre></div><p>Upon any<a id="id374" class="indexterm"/> changes regarding entities taking place, the <code class="literal">EntityModified</code> method must be invoked with the identifier of the entity and its new bitmask passed in as arguments. Every system is then iterated over. Their respective <code class="literal">FitsRequirements</code> methods are invoked with the new bitmask as the argument. If the entity fits the requirements of a system and it doesn't belong to it, it is added. If, however, the entity does not fit these requirements but a system still has this entity, it's removed. The use of this simple concept allows entities to be dynamic in structure. Any given entity can lose or gain a component and immediately "transform" into something else.</p><p>Removal of entities is quite simple:</p><div><pre class="programlisting">void SystemManager::RemoveEntity(const EntityId&amp; l_entity){
  for(auto &amp;system : m_systems){
    system.second-&gt;RemoveEntity(l_entity);
  }
}</pre></div><p>All that needs to happen here is the <code class="literal">RemoveEntity</code> method of every system being invoked, which is quite similar to purging all entities:</p><div><pre class="programlisting">void SystemManager::PurgeEntities(){
  for(auto &amp;system : m_systems){
    system.second-&gt;Purge();
  }
}</pre></div><p>Getting rid of all systems in the system manager is also a cake walk:</p><div><pre class="programlisting">void SystemManager::PurgeSystems(){
  for (auto &amp;system : m_systems){
    delete system.second;
  }
  m_systems.clear();
}</pre></div><p>Because systems are dynamically allocated, the memory has to be freed for each of them. The system container is then simply cleared.</p><p>This last method marks the completion of our system manager, as well as the core structure of the entity component system paradigm. All of the basic tools for shaping our game are now present, so let's implement the first and most important system in the game: the<a id="id375" class="indexterm"/> renderer.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Implementing the rendering system</h1></div></div></div><p>In order for<a id="id376" class="indexterm"/> entities to be drawn on screen, they must have a component that represents them visually. After some careful planning, one can deduce that an entity will probably not have just one possible choice for a graphical representation. For example, instead of a sprite sheet, an entity can be a simple shape with a single color fill. In order to make that happen, we need a common interface for drawable components. Let's see what we can come up with:</p><div><pre class="programlisting">class C_Drawable : public C_Base{
public:
  C_Drawable(const Component&amp; l_type) : C_Base(l_type){}
  virtual ~C_Drawable(){}

  virtual void UpdatePosition(const sf::Vector2f&amp; l_vec) = 0;
  virtual const sf::Vector2u&amp; GetSize() = 0;
  virtual void Draw(sf::RenderWindow* l_wind) = 0;
private:

};</pre></div><p>The first thing to note here is that the constructor of this class also takes in a component type, and simply passes it to the base class. Since <code class="literal">C_Drawable</code> only has purely virtual methods, it can never be instantiated and will only be used as a mold to shape other drawable components. It requires all derived classes to implement a method for updating the drawable's position, obtaining its size and drawing it on screen.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec45"/>The sprite sheet component</h2></div></div></div><p>With<a id="id377" class="indexterm"/> the base class set up, it's time to take a look at creating the sprite sheet component:</p><div><pre class="programlisting">class C_SpriteSheet : public C_Drawable{
public:
    ...
private:
    SpriteSheet* m_spriteSheet;
    std::string m_sheetName;
};</pre></div><p>This component will, of course, be utilizing the <code class="literal">SpriteSheet</code> class we built in the past as one of its data members. We also want to hold on to the sprite sheet name in order to properly allocate resources after the time of de-serialization. Let's begin implementing the sprite sheet component:</p><div><pre class="programlisting">C_SpriteSheet(): C_Drawable(Component::SpriteSheet),
    m_spriteSheet(nullptr){}

~C_SpriteSheet(){
    if(m_spriteSheet){ delete m_spriteSheet; }
}</pre></div><p>So far, nothing is <a id="id378" class="indexterm"/>out of the ordinary. The constructor uses the initializer list to set up the component type and set the sprite sheet pointer to <code class="literal">NULL</code>, while the destructor takes care of de-allocating the memory that's taken up by said sprite sheet.</p><p>Next, let's handle reading in the component data, which only consists of the sprite sheet name:</p><div><pre class="programlisting">void ReadIn(std::stringstream&amp; l_stream){
    l_stream &gt;&gt; m_sheetName;
}</pre></div><p>Due to the nature of this particular drawable component, it needs access to the texture manager. In order to set up the sprite sheet properly, the <code class="literal">Create</code> method is introduced:</p><div><pre class="programlisting">void Create(TextureManager* l_textureMgr, 
  const std::string&amp; l_name = "")
{
  if (m_spriteSheet){ return; }
  m_spriteSheet = new SpriteSheet(l_textureMgr);
  m_spriteSheet-&gt;LoadSheet("media/Spritesheets/" +
    (l_name != "" ? l_name : m_sheetName) + ".sheet");
}</pre></div><p>As seen previously, this particular method is used to set up the sprite sheet component during entity loading. It first checks if the memory for the <code class="literal">m_spriteSheet</code> data member hasn't already been allocated. If it hasn't, a new <code class="literal">SpriteSheet</code> object is created with the texture manager pointer passed in as its sole argument. The rest of the code deals with the second, optional argument. The name of the texture can be passed to the <code class="literal">Create</code> method itself, or it can use the <code class="literal">m_sheetName</code> data member that has been read in from the entity file.</p><p>Lastly, all of the virtual methods of the <code class="literal">C_Drawable</code> class must be implemented here:</p><div><pre class="programlisting">SpriteSheet* GetSpriteSheet(){ return m_spriteSheet; }
void UpdatePosition(const sf::Vector2f&amp; l_vec){
  m_spriteSheet-&gt;SetSpritePosition(l_vec);
}

const sf::Vector2u&amp; GetSize(){ 
  return m_spriteSheet-&gt;GetSpriteSize();
}
void Draw(sf::RenderWindow* l_wind){
  if (!m_spriteSheet){ return; }
  m_spriteSheet-&gt;Draw(l_wind);
}</pre></div><p>All of the <a id="id379" class="indexterm"/>work done on the <code class="literal">SpriteSheet</code> class in the past makes this pretty easy. One thing to note is that due to the nature of loading sprite sheet components, it may be wise to check if it has actually been allocated, before attempting to draw it.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec46"/>The renderer</h2></div></div></div><p>With the <a id="id380" class="indexterm"/>simple part out of the way, let's focus on creating our first system ever built, the renderer:</p><div><pre class="programlisting">class S_Renderer : public S_Base{
public:
  S_Renderer(SystemManager* l_systemMgr);
  ~S_Renderer();

  void Update(float l_dT);
  void HandleEvent(const EntityId&amp; l_entity,
    const EntityEvent&amp; l_event);
  void Notify(const Message&amp; l_message);
  void Render(Window* l_wind, unsigned int l_layer);
private:
  void SetSheetDirection(const EntityId&amp; l_entity,
    const Direction&amp; l_dir);
  void SortDrawables();
};</pre></div><p>The header for all of the other systems will look very much like this one, with the exception of private methods, specific to the function that each individual system performs. Each system must implement its own <code class="literal">Update</code> and <code class="literal">HandleEvent</code> methods. Additionally, being an observer requires a unique implementation of the <code class="literal">Notify</code> method as well. Time to take a stab at implementing the renderer system:</p><div><pre class="programlisting">S_Renderer::S_Renderer(SystemManager* l_systemMgr)
  :S_Base(System::Renderer, l_systemMgr)
{
  Bitmask req;
  req.TurnOnBit((unsigned int)Component::Position);
  req.TurnOnBit((unsigned int)Component::SpriteSheet);
  m_requiredComponents.push_back(req);
  req.Clear();

  m_systemManager-&gt;GetMessageHandler()-&gt;
    Subscribe(EntityMessage::Direction_Changed,this);
}
S_Renderer::~S_Renderer(){}</pre></div><p>After invoking<a id="id381" class="indexterm"/> the base system's constructor and passing in the appropriate type, along with a pointer to the system manager, the renderer sets up a bitmask of requirements an entity has to meet in order to belong to this system. As you can see, it only needs to have the position and sprite sheet components. Once the requirement bitmask is added to the system, it also subscribes to the <code class="literal">Direction_Changed</code> message type. This utilizes the observer pattern discussed previously.</p><p>Let's take a look at the update method:</p><div><pre class="programlisting">void S_Renderer::Update(float l_dT){
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  for(auto &amp;entity : m_entities)
  {
    C_Position* position = entities-&gt;
      GetComponent&lt;C_Position&gt;(entity, Component::Position);
    C_Drawable* drawable = nullptr;
    if (entities-&gt;HasComponent(entity, Component::SpriteSheet)){
      drawable = entities-&gt;
        GetComponent&lt;C_Drawable&gt;(entity, Component::SpriteSheet);
    } else { continue; }
    drawable-&gt;UpdatePosition(position-&gt;GetPosition());
  }
}</pre></div><p>During iteration over all of the entities that belong to this system, the position and drawable components are obtained through the entity manager. The drawable's position is then updated through the use of its <code class="literal">UpdatePosition</code> method. This method can obviously be expanded if additional drawable types are added in the future.</p><p>Next, let's handle the appropriate events:</p><div><pre class="programlisting">void S_Renderer::HandleEvent(const EntityId&amp; l_entity,
  const EntityEvent&amp; l_event)
{
  if (l_event == EntityEvent::Moving_Left ||
    l_event == EntityEvent::Moving_Right ||
    l_event == EntityEvent::Moving_Up ||
    l_event == EntityEvent::Moving_Down ||
    l_event == EntityEvent::Elevation_Change ||
    l_event == EntityEvent::Spawned)
  {
    SortDrawables();
  }
}</pre></div><p>If the system<a id="id382" class="indexterm"/> encounters any events of entities spawning, changing their position or elevation, their drawable representations have to be re-sorted in order to assure the correct layering. The result of this is quite worth the trouble:</p><div><img src="img/B04284_08_04.jpg" alt="The renderer"/></div><p>The code for message handling here is as follows:</p><div><pre class="programlisting">void S_Renderer::Notify(const Message&amp; l_message){
  if(HasEntity(l_message.m_receiver)){
    EntityMessage m = (EntityMessage)l_message.m_type;
    switch(m){
    case EntityMessage::Direction_Changed: 
      SetSheetDirection(l_message.m_receiver,
        (Direction)l_message.m_int);
      break;
    }
  }
}</pre></div><p>Since messages are globally broadcasted to every system regardless of what entities they have, and the renderer only deals with a single message type that pertains to specific entities only, a check takes place in order to make sure the entity exists within the renderer system. The sole message type we care about so far is the direction being altered, in which case a private method is invoked to adjust it.</p><p>Now, let's address the main purpose the renderer system exists:</p><div><pre class="programlisting">void S_Renderer::Render(Window* l_wind, unsigned int l_layer)
{
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  for(auto &amp;entity : m_entities){
    C_Position* position = entities-&gt;
      GetComponent&lt;C_Position&gt;(entity, Component::Position);
    if(position-&gt;GetElevation() &lt; l_layer){ continue; }
    if(position-&gt;GetElevation() &gt; l_layer){ break; }
    C_Drawable* drawable = nullptr;
    if (!entities-&gt;HasComponent(entity,
      Component::SpriteSheet))
    {
      continue;
    }
    drawable = entities-&gt;
      GetComponent&lt;C_Drawable&gt;(entity, Component::SpriteSheet);
    sf::FloatRect drawableBounds;
    drawableBounds.left = position-&gt;GetPosition().x –
      (drawable-&gt;GetSize().x / 2);
    drawableBounds.top = position-&gt;GetPosition().y –
      drawable-&gt;GetSize().y;
    drawableBounds.width = drawable-&gt;GetSize().x;
    drawableBounds.height = drawable-&gt;GetSize().y;
    if (!l_wind-&gt;GetViewSpace().intersects(
      drawableBounds))
    {
      continue;
    }
    drawable-&gt;Draw(l_wind-&gt;GetRenderWindow());
  }
}</pre></div><p>Each entity is<a id="id383" class="indexterm"/> iterated over, much like any other system. The main difference here is the layer argument the method takes in. Because we want to have a map that has many different layers entities can be, for the lack of better term, "sandwiched" in, rendering elevation by elevation is necessary in order to maintain the correct draw order and offer the feeling of depth, as illustrated here:</p><div><img src="img/B04284_08_05.jpg" alt="The renderer"/></div><p>The second half of the <code class="literal">Render</code> method is devoted to entity culling. First, a rectangle structure is created in order to represent the boundaries of a drawable. In the case of a sprite sheet, we<a id="id384" class="indexterm"/> know that its origin is set at the point of half its width and its full height. Using this information, the rectangle structure is properly set up and inspected for intersections with the view space, which essentially means the sprite is on screen and should be drawn.</p><p>Re-using code as much as possible makes life easier in the long run, hence the existence of many private methods amongst multiple systems, regarding modifications of entity components. For example:</p><div><pre class="programlisting">void S_Renderer::SetSheetDirection(const EntityId&amp; l_entity,
  const Direction&amp; l_dir)
{
  EntityManager* entities = m_systemManager-&gt;GetEntityManager();
  if (!entities-&gt;HasComponent(l_entity,
    Component::SpriteSheet))
  {
    return;
  }
  C_SpriteSheet* sheet = entities-&gt;
    GetComponent&lt;C_SpriteSheet&gt;(l_entity,Component::SpriteSheet);
  sheet-&gt;GetSpriteSheet()-&gt;SetDirection(l_dir);
}</pre></div><p>The <code class="literal">SetSheetDirection</code> method simply fetches the sprite sheet component and changes its direction.</p><p>The last feature we want to work on implementing is the render order of drawables in order to simulate depth. Drawing entities in a correct sequence requires them being sorted. This is where the <code class="literal">SortDrawables</code> method comes in:</p><div><pre class="programlisting">void S_Renderer::SortDrawables(){
  EntityManager* e_mgr = m_systemManager-&gt;GetEntityManager();
  std::sort(m_entities.begin(), m_entities.end(),
    [e_mgr](unsigned int l_1, unsigned int l_2)
  {
    auto pos1 = e_mgr-&gt;
      GetComponent&lt;C_Position&gt;(l_1, Component::Position);
    auto pos2 = e_mgr-&gt;
      GetComponent&lt;C_Position&gt;(l_2, Component::Position);
    if (pos1-&gt;GetElevation() == pos2-&gt;GetElevation()){
      return pos1-&gt;GetPosition().y &lt; pos2-&gt;GetPosition().y;
    }
    return pos1-&gt;GetElevation() &lt; pos2-&gt;GetElevation();
  });
}</pre></div><p>Here, we<a id="id385" class="indexterm"/> simply invoke the <code class="literal">std::sort</code> function, with the last argument being the predicate lambda that we've already seen before. Elevation is given top priority when entity sprites are being sorted. Anything with a higher elevation will be drawn on top, while sprites on the same elevation are sorted based on their <em>Y</em> coordinate.</p><p>With that, the rendering system is now complete! Putting all of the pieces together is the final step in employing the entity component system pattern in our game.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Putting the ECS to work</h1></div></div></div><p>Due to the <a id="id386" class="indexterm"/>part this paradigm plays in the overall structure of our application, we want the system manager and entity manager classes to be accessible to the majority of our code base. Having these objects be part of the shared context is the best way to do so:</p><div><pre class="programlisting">struct SharedContext{
    SharedContext():
        ...
        m_systemManager(nullptr),
        m_entityManager(nullptr),
        ...{}
    ...
    SystemManager* m_systemManager;
    EntityManager* m_entityManager;
    ...
};</pre></div><p>Adjusting the shared context means we have two extra classes to keep track of in <code class="literal">Game.h</code>:</p><div><pre class="programlisting">class Game{
...
private:
    ...
    SystemManager m_systemManager;
    EntityManager m_entityManager;
    ...
};</pre></div><p>These<a id="id387" class="indexterm"/> classes have to be properly initialized, which is done in <code class="literal">Game.cpp</code>:</p><div><pre class="programlisting">Game::Game(): m_window("Chapter 8", sf::Vector2u(800,600)), 
  <strong>m_entityManager(&amp;m_systemManager, &amp;m_textureManager)</strong>,
  m_stateManager(&amp;m_context)
{
  ...
  <strong>m_systemManager.SetEntityManager(&amp;m_entityManager);</strong>
  <strong>m_context.m_systemManager = &amp;m_systemManager;</strong>
  <strong>m_context.m_entityManager = &amp;m_entityManager;</strong>
  ...
}</pre></div><p>Notice that the entity manager is initialized in the initializer list. The system manager is then given a pointer to the entity manager, and both of these classes are added to the shared context.</p><p>Next up, some changes have to be made to the game state:</p><div><pre class="programlisting">class State_Game : public BaseState{
public:
    ...
    void PlayerMove(EventDetails* l_details);
    ...
private:
    ...
    Void UpdateCamera();
    int m_player;
};</pre></div><p>The game state currently keeps track of the player's entity identifier in addition to providing a new method for updating the camera, as well as moving the player, which will be set up as a callback like so:</p><div><pre class="programlisting">void State_Game::OnCreate(){
  ...
  evMgr-&gt;AddCallback(StateType::Game, "Player_MoveLeft",
    &amp;State_Game::PlayerMove, this);
  evMgr-&gt;AddCallback(StateType::Game, "Player_MoveRight",
    &amp;State_Game::PlayerMove, this);
  evMgr-&gt;AddCallback(StateType::Game, "Player_MoveUp",
    &amp;State_Game::PlayerMove, this);
  evMgr-&gt;AddCallback(StateType::Game, "Player_MoveDown",
    &amp;State_Game::PlayerMove, this);
  ...
  m_player = m_gameMap-&gt;GetPlayerId();
}</pre></div><p>After the game <a id="id388" class="indexterm"/>map is loaded, the player entity identifier is obtained through the <code class="literal">Map</code> class, which stores this information during map loading.</p><p>The next task is getting the camera to follow our hero. This can be accomplished by first calling our <code class="literal">UpdateCamera</code> method in the <code class="literal">Update</code> method of our game state:</p><div><pre class="programlisting">void State_Game::Update(const sf::Time&amp; l_time){
  SharedContext* context = m_stateMgr-&gt;GetContext();
  UpdateCamera();
  m_gameMap-&gt;Update(l_time.asSeconds());
  context-&gt;m_systemManager-&gt;Update(l_time.asSeconds());
}</pre></div><p>The actual <code class="literal">UpdateCamera</code> method itself is implemented like so:</p><div><pre class="programlisting">void State_Game::UpdateCamera(){
  if (m_player == -1){ return; }
  SharedContext* context = m_stateMgr-&gt;GetContext();
  C_Position* pos = m_stateMgr-&gt;GetContext()-&gt;m_entityManager-&gt;
    GetComponent&lt;C_Position&gt;(m_player, Component::Position);

  m_view.setCenter(pos-&gt;GetPosition());
  context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view);

  sf::FloatRect viewSpace = context-&gt;m_wind-&gt;GetViewSpace();
  if (viewSpace.left &lt;= 0){
    m_view.setCenter(viewSpace.width / 2, m_view.getCenter().y);
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view);
  } else if (viewSpace.left + viewSpace.width &gt;
    (m_gameMap-&gt;GetMapSize().x) * Sheet::Tile_Size)
  {
    m_view.setCenter(
      ((m_gameMap-&gt;GetMapSize().x) * Sheet::Tile_Size) -
      (viewSpace.width / 2), m_view.getCenter().y);
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view);
  }

  if (viewSpace.top &lt;= 0){
    m_view.setCenter(m_view.getCenter().x, viewSpace.height / 2);
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view);
  } else if (viewSpace.top + viewSpace.height &gt;
    (m_gameMap-&gt;GetMapSize().y) * Sheet::Tile_Size)
  {
    m_view.setCenter(m_view.getCenter().x,
      ((m_gameMap-&gt;GetMapSize().y) * Sheet::Tile_Size) -
      (viewSpace.height / 2));
    context-&gt;m_wind-&gt;GetRenderWindow()-&gt;setView(m_view);
  }
}</pre></div><p>The player<a id="id389" class="indexterm"/> identifier first is verified of being a non-negative value, which would signify an error. The position component of the player entity is then obtained and used for updating the position of the current view. The rest of the code deals with adjusting the view to fit within the boundaries of the map, if it wanders outside of it. This is also where the system manager update method must be invoked.</p><p>Drawing our game world also needs revising:</p><div><pre class="programlisting">void State_Game::Draw(){
  for(unsigned int i = 0; i &lt; Sheet::Num_Layers; ++i){
    m_gameMap-&gt;Draw(i);
    m_stateMgr-&gt;GetContext()-&gt;m_systemManager-&gt;Draw(
      m_stateMgr-&gt;GetContext()-&gt;m_wind, i);
  }
}</pre></div><p>First, a <code class="literal">for</code> loop iterates over each layer that might be used in the game. The <code class="literal">Num_Layers</code> value is part of the <code class="literal">Sheet</code> enumeration, which is defined in the <code class="literal">Map</code> class header. We'll be covering that shortly. The map <code class="literal">Draw</code> method now needs to know which layer to draw, as they're not all drawn at the same time anymore. After the appropriate layer is rendered, all of the entities that occupy the same elevation are also rendered on screen, giving the impression of depth in the game, like so:</p><div><img src="img/B04284_08_06.jpg" alt="Putting the ECS to work"/></div><p>Lastly, we need <a id="id390" class="indexterm"/>to define the callback method for moving a player:</p><div><pre class="programlisting">void State_Game::PlayerMove(EventDetails* l_details){
  Message msg((MessageType)EntityMessage::Move);
  if (l_details-&gt;m_name == "Player_MoveLeft"){
    msg.m_int = (int)Direction::Left;
  } else if (l_details-&gt;m_name == "Player_MoveRight"){
    msg.m_int = (int)Direction::Right;
  } else if (l_details-&gt;m_name == "Player_MoveUp"){
    msg.m_int = (int)Direction::Up;
  } else if (l_details-&gt;m_name == "Player_MoveDown"){
    msg.m_int = (int)Direction::Down;
  }
  msg.m_receiver = m_player;
  m_stateMgr-&gt;GetContext()-&gt;m_systemManager-&gt;
    GetMessageHandler()-&gt;Dispatch(msg);
}</pre></div><p>A message of type <code class="literal">Move</code> is created and set up in order to hold the direction in its <code class="literal">m_int</code> data member. The receiver of the message is also set to be the player, and the message is dispatched through the system manager's message handler. This message will be handled by one of the systems we'll be building in a later chapter.</p><p>The last change from our previous project is the number of directions an entity can move in. Given the format of our new entity spritesheets, let's modify <code class="literal">Directions.h</code>:</p><div><pre class="programlisting">enum class Direction{ Up = 0, Left, Down, Right };</pre></div><p>Since the direction is used as a way to offset numbers of rows in sprite sheets for obtaining correct animations, the values set here are important. This small change concludes<a id="id391" class="indexterm"/> building and setting up the core of our component entity system! All that's left now is adjusting the <code class="literal">Map</code> class to satisfy and complement the new, shiny features of our game.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec78"/>The new and improved map</h1></div></div></div><p>For as <a id="id392" class="indexterm"/>good as the second project of this book looked, a lot of things about it were fairly primitive. Among its other shortcomings, the map design lacked complexity due to its inability to support tile layers. Having a more complex scene requires tiles being able to layer over each other, in a manner best represented by this illustration:</p><div><img src="img/B04284_08_07.jpg" alt="The new and improved map"/></div><p>Adding layer support, as well as loading entity information after re-designing the way entities are handled requires some changes to be made to the map file format. Let's take a look at an example:</p><div><pre class="programlisting">SIZE 32 32
DEFAULT_FRICTION 1.0 1.0
|ENTITY|Name|x|y|elevation|
ENTITY Player 256.0 256.0 1
...
|TILE|ID|x|y|layer|solid|
TILE 3 0 0 0 0
...</pre></div><p>While some map properties remain in place, things like gravity or background images have been removed, as it no longer suits the genre of the game we're making. The main changes here are the entity and tile lines. </p><p>Loading an entity is as simple as providing the name of its entity file and a few pieces of data, relevant to maps, such as its position and elevation.</p><p>Tile loading is also slightly different now. In addition to its identifier and position, a tile now also requires having a layer, as well as a flag for solidity, which will be covered more in <a id="id393" class="indexterm"/>depth in the next chapter.</p><p>Amongst some of the bigger changes, a new value inside the <em>Sheet</em> enumeration is defined. It represents the maximum possible number of layers in any given map:</p><div><pre class="programlisting">enum Sheet{
  Tile_Size = 32, Sheet_Width = 256,
  Sheet_Height = 256, <strong>Num_Layers = 4</strong>
};</pre></div><p>Also, in order to allow individual solidity options, each tile now carries a solidity flag that can be turned on or off:</p><div><pre class="programlisting">struct Tile{
    ...
    bool m_solid; // Is the tile a solid.
};</pre></div><p>Working with an extra piece of information, the tile layer, requires certain modifications to be made to the <code class="literal">GetTile</code> and <code class="literal">ConvertCoords</code> methods:</p><div><pre class="programlisting">class Map{
public:
    ...
    Tile* GetTile(unsigned int l_x, unsigned int l_y, unsigned int l_layer);
    ...
    void Draw(unsigned int l_layer);
private:
    unsigned int ConvertCoords(unsigned int l_x, unsigned int l_y,unsigned int l_layer)const;
    ...
    <strong>int m_playerId;</strong>
    ...
};</pre></div><p>Note the <code class="literal">m_playerId</code> data member. It keeps track of what entity ID the player has been given after loading the map file.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec47"/>Adjusting the Map class</h2></div></div></div><p>It's time<a id="id394" class="indexterm"/> to start implementing all of these changes! First, let's take a look at the method used for obtaining map tiles:</p><div><pre class="programlisting">Tile* Map::GetTile(unsigned int l_x, unsigned int l_y,
  unsigned int l_layer)
{
  if(l_x &lt; 0 || l_y &lt; 0 || l_x &gt;= m_maxMapSize.x ||
    l_y &gt;= m_maxMapSize.y || l_layer &lt; 0 ||
    l_layer &gt;= Sheet::Num_Layers)
  {
    return nullptr;
  }
  auto itr = m_tileMap.find(ConvertCoords(l_x,l_y,l_layer));
  if (itr == m_tileMap.end()){ return nullptr; }
  return itr-&gt;second;
}</pre></div><p>The biggest<a id="id395" class="indexterm"/> difference here is the check for accessing tiles that are out of boundaries of the map. The method itself takes an additional argument that represents the tile layer, which it then passes into the <code class="literal">ConvertCoords</code> method. Working with tile layers would require having a third dimension added to a 2D array of tiles. Since we're storing all of this information in a one-dimensional array, some additional math has to be done in order to perform the conversion:</p><div><pre class="programlisting">unsigned int Map::ConvertCoords(unsigned int l_x,
  unsigned int l_y, unsigned int l_layer)const
{
  return ((l_layer*m_maxMapSize.y+l_y) * m_maxMapSize.x + l_x);
}</pre></div><p>If you previously visualized the map as a 2D grid, it's now becoming a 3D cube, with the layer value representing its depth.</p><p>The desired functionality of the updated <code class="literal">Draw</code> method has been outlined quite clearly in the game state <code class="literal">Draw</code> method. Let's implement that:</p><div><pre class="programlisting">void Map::Draw(unsigned int l_layer){
  if (l_layer &gt;= Sheet::Num_Layers){ return; }
  sf::RenderWindow* l_wind = m_context-&gt;m_wind-&gt;GetRenderWindow();
  sf::FloatRect viewSpace = m_context-&gt;m_wind-&gt;GetViewSpace();

  sf::Vector2i tileBegin(
    floor(viewSpace.left / Sheet::Tile_Size),
    floor(viewSpace.top / Sheet::Tile_Size));
  sf::Vector2i tileEnd(
    ceil((viewSpace.left + viewSpace.width) / Sheet::Tile_Size),
    ceil((viewSpace.top + viewSpace.height) / Sheet::Tile_Size));

  unsigned int count = 0;
  for(int x = tileBegin.x; x &lt;= tileEnd.x; ++x){
    for(int y = tileBegin.y; y &lt;= tileEnd.y; ++y){
      Tile* tile = GetTile(x,y,l_layer);
      if (!tile){ continue; }
      sf::Sprite&amp; sprite = tile-&gt;m_properties-&gt;m_sprite;
      sprite.setPosition(x * Sheet::Tile_Size,
        y * Sheet::Tile_Size);
      l_wind-&gt;draw(sprite);
      ++count;
    }
  }
}</pre></div><p>Before we<a id="id396" class="indexterm"/> get into any actual rendering, we must make sure that the provided layer argument does not exceed the defined maximum. Aside from that, the only real difference here is that we're passing the layer argument into the <code class="literal">GetTile</code> method now. That's quite a simple adjustment.</p><p>Lastly, the way tiles and entities are loaded has to be fixed. Let's take a look at snippets from the <code class="literal">LoadMap</code> method:</p><div><pre class="programlisting">if(type == "TILE"){
  ...
  sf::Vector2i tileCoords;
  unsigned int tileLayer = 0;
  unsigned int tileSolidity = 0;
  keystream &gt;&gt; tileCoords.x &gt;&gt; tileCoords.y &gt;&gt;
    tileLayer &gt;&gt; tileSolidity;
  if (tileCoords.x &gt; m_maxMapSize.x ||
    tileCoords.y &gt; m_maxMapSize.y ||
    tileLayer &gt;= Sheet::Num_Layers)
  {
    std::cout &lt;&lt; "! Tile is out of range: " &lt;&lt;
      tileCoords.x &lt;&lt; " " &lt;&lt; tileCoords.y &lt;&lt; std::endl;
    continue;
  }
  Tile* tile = new Tile();
  // Bind properties of a tile from a set.
  tile-&gt;m_properties = itr-&gt;second;
  tile-&gt;m_solid = (bool)tileSolidity;
  if(!m_tileMap.emplace(ConvertCoords(
    tileCoords.x,tileCoords.y,tileLayer),tile).second)
  {
    ...
  }
  ...
} else if ...</pre></div><p>The majority of this code remains unchanged. Reading in the layer and solidity data has been added, as well as checking if the layer value is valid, together with the coordinate values. The entity side of things, however, is quite different:</p><div><pre class="programlisting">} else if(type == "ENTITY"){
  // Set up entity here.
  std::string name;
  keystream &gt;&gt; name;
  if (name == "Player" &amp;&amp; m_playerId != -1){ continue; }
  int entityId = m_context-&gt;m_entityManager-&gt;AddEntity(name);
  if (entityId &lt; 0){ continue; }
  if(name == "Player"){ m_playerId = entityId; }
  C_Base* position = m_context-&gt;m_entityManager-&gt;
    GetComponent&lt;C_Position&gt;(entityId,Component::Position);
  if(position){ keystream &gt;&gt; *position; }
} else ...</pre></div><p>The <a id="id397" class="indexterm"/>name of an entity is read in first. If it's a player entity and it hasn't yet been set up based on the <code class="literal">m_playerId</code> data member, or if it's just any other entity, an attempt is made to add it. Upon successfully doing so, its name is checked once more in order to make sure the player entity identifier is caught and stored. The position component is then obtained and its data is read in directly from the map file.</p><p>Once the <code class="literal">Map</code> class is finished, compiling and rendering our project and loading in a valid map should leave us with a few entities standing around peacefully:</p><div><img src="img/B04284_08_08.jpg" alt="Adjusting the Map class"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec79"/>Summary</h1></div></div></div><p>With the invention of all the tools we need, we will next be working on adding the most common game elements to our final project and bringing it to life, not to mention actually flexing the backend functionality we built. Although this chapter has come to an end, this is by no means the last of us discovering and applying new programming patterns, should a need ever arise again to use one.</p><p>A good code-base is one that can handle new features and expansion of old ones with ease. The fruition of this chapter marks the point, at which the games we make are no longer bound to be simplistic due to design restrictions or inconvenient expansion. At this point, the question is no longer "How?", it's "Why not?" Seeing as you have made it this far, why not keep going? See you in the next chapter!</p></div></body></html>