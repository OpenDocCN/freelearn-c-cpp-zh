["```cpp\nGLuint texture = SOIL_load_OGL_texture\n(\n  imageName,\n  SOIL_LOAD_AUTO,\n  SOIL_CREATE_NEW_ID,\n  0\n);\n```", "```cpp\n#pragma once:\n#include <gl\\gl.h>\n\nclass Sprite\n{\n  public:\nstruct Point\n{\n  GLfloat x;\n  GLfloat y;\n};\n\n   struct Size\n {\n  GLfloat width;\n  GLfloat height;\n };\n struct Rect\n {\n  GLfloat top;\n  GLfloat bottom;\n  GLfloat left;\n  GLfloat right;\n };\n\n  protected:\n  GLuint* m_textures;\n  unsigned int m_textureIndex;\n  unsigned int m_currentFrame;\n  unsigned int m_numberOfFrames;\n  GLfloat m_animationDelay;\n  GLfloat m_animationElapsed;\n\n  Point m_position;\n  Size m_size;\n  GLfloat m_velocity;\n\n  bool m_isCollideable;\n  bool m_flipHorizontal;\n  bool m_flipVertical;\n  bool m_isVisible;\n  bool m_isActive;\n  bool m_useTransparency;\n  bool m_isSpriteSheet;\n\n  public:\n  Sprite(const unsigned int m_pNumberOfTextures);\n  ~Sprite();\n\n  void Update(const float p_deltaTime);\n  void Render();\n\n  const bool AddTexture(const char* p_fileName, const bool p_useTransparency = true);\n   const GLuint GetCurrentFrame() {\n  if (m_isSpriteSheet)\n  {\n   return m_textures[0];\n  }\n  else\n  {\n   return m_textures[m_currentFrame];\n  }\n }\n\n  void SetPosition(const GLfloat p_x, const GLfloat p_y) { m_position.x = p_x; m_position.y = p_y; }\n   void SetPosition(const Point p_position) { m_position = p_position; }\n const Point GetPosition() { return m_position; }\n const Size GetSize() const { return m_size; }\nvoid SetFrameSize(const GLfloat p_width, const GLfloat p_height) {\nm_size.width = p_width; m_size.height = p_height; }\n  void SetVelocity(const GLfloat p_velocity) { m_velocity = p_velocity; }\n  void SetNumberOfFrames(const unsigned int p_frames) { m_numberOfFrames = p_frames;  }\n\n  const bool isCollideable() const { return m_isCollideable; }\nvoid IsCollideable(const bool p_value) { m_isCollideable = p_value;  }\n  void FlipHorizontal(const bool p_value) { m_flipHorizontal = p_value; }\n  void FlipVertical(const bool p_value) { m_flipVertical = p_value; }\n  void IsActive(const bool p_value) { m_isActive = p_value; }\n  const bool IsActive() const { return m_isActive; }\nvoid IsVisible(const bool p_value) { m_isVisible = p_value; }\nconst bool IsVisible() const { return m_isVisible; }\nvoid UseTransparency(const bool p_value) { m_useTransparency = p_value; }\n};\n```", "```cpp\n    #ifndef SPRITE_H\n    #define SPRITE_H\n    ...code...\n    #endif\n    ```", "```cpp\n#include \"stdafx.h\"\n#include \"Sprite.h\"\n#include \"SOIL.h\"\n\nSprite::Sprite(const unsigned int p_numberOfTextures)\n{â€©  \n  m_textures = new GLuint[p_numberOfTextures];\n  m_textureIndex = 0;\n  m_currentFrame = 0;\n  m_numberOfFrames = 0;\n  m_animationDelay = 0.25f;\n  m_animationElapsed = 0.0f;\n  m_position.x = 0.0f;\n  m_position.y = 0.0f;\n  m_size.height = 0.0f;\n  m_size.width = 0.0f;\n  m_velocity = 0.0f;\n\n  m_isCollideable = true;\n  m_flipHorizontal = false;\n  m_flipVertical = false;\n  m_isVisible = false;\n  m_isActive = false;\n  m_isSpriteSheet = false;\n}\n\nSprite::~Sprite()\n{\n  delete[] m_textures;\n}\n```", "```cpp\nrobot_right = new Sprite(4);\n robot_right->SetFrameSize(100.0f, 125.0f);\n robot_right->SetNumberOfFrames(4);\n robot_right->SetPosition(0, screen_height - 130.0f);\n robot_right->AddTexture(\"resources/robot_right_00.png\");\n robot_right->AddTexture(\"resources/robot_right_01.png\");\n robot_right->AddTexture(\"resources/robot_right_02.png\");\n robot_right->AddTexture(\"resources/robot_right_03.png\");\n```", "```cpp\n robot_right_strip = new Sprite(1);\n robot_right_strip->SetFrameSize(125.0f, 100.0f);\n robot_right_strip->SetNumberOfFrames(4);\n robot_right_strip->SetPosition(0, screen_height - 130.0f);\n robot_right_strip->AddTexture(\"resources/robot_right_strip.png\");\n```", "```cpp\n#include \"Sprite.h\"\n```", "```cpp\nSprite* robot_left;\nSprite* robot_right;\nSprite* robot_right_strip;\nSprite* robot_left_strip;\nSprite* background;\nSprite* player;\n```", "```cpp\nconst bool LoadTextures()\n{\n  background = new Sprite(1);\n  background->SetFrameSize(1877.0f, 600.0f);\n  background->SetNumberOfFrames(1);\n  background->AddTexture(\"resources/background.png\", false);\n\n  robot_right = new Sprite(4);\n  robot_right->SetFrameSize(100.0f, 125.0f);\n  robot_right->SetNumberOfFrames(4);\n  robot_right->SetPosition(0, screen_height - 130.0f);\n  robot_right->AddTexture(\"resources/robot_right_00.png\");\n  robot_right->AddTexture(\"resources/robot_right_01.png\");\n  robot_right->AddTexture(\"resources/robot_right_02.png\");\n  robot_right->AddTexture(\"resources/robot_right_03.png\");\n\n  robot_left = new Sprite(4);\n  robot_left->SetFrameSize(100.0f, 125.0f);\n  robot_left->SetNumberOfFrames(4);\n  robot_left->SetPosition(0, screen_height - 130.0f);\n  robot_left->AddTexture(\"resources/robot_left_00.png\");\n  robot_left->AddTexture(\"resources/robot_left_01.png\");\n  robot_left->AddTexture(\"resources/robot_left_02.png\");\n  robot_left->AddTexture(\"resources/robot_left_03.png\");\n\n  robot_right_strip = new Sprite(1);\n  robot_right_strip->SetFrameSize(125.0f, 100.0f);\n  robot_right_strip->SetNumberOfFrames(4);\n  robot_right_strip->SetPosition(0, screen_height - 130.0f);\n  robot_right_strip->AddTexture(\"resources/robot_right_strip.png\");\n\n  robot_left_strip = new Sprite(1);\n  robot_left_strip->SetFrameSize(125.0f, 100.0f);\n  robot_left_strip->SetNumberOfFrames(4);\n  robot_right_strip->SetPosition(0, screen_height - 130.0f);\n  robot_left_strip->AddTexture(\"resources/robot_left_strip.png\");\n\n  background->IsVisible(true);\n  background->IsActive(true);\n  background->SetVelocity(-50.0f);\n\n  robot_right->IsActive(true);\n  robot_right->IsVisible(true);\n  robot_right->SetVelocity(50.0f);\n\n  player = robot_right;\n  player->IsActive(true);\n  player->IsVisible(true);\n  player->SetVelocity(50.0f);\n\n  return true;\n}\n```", "```cpp\nvoid StartGame()\n{\n  LoadTextures();\n}\n```", "```cpp\nconst bool Sprite::AddTexture(const char* p_imageName, const bool p_useTransparency)\n{\n  GLuint texture = SOIL_load_OGL_texture( p_imageName, SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, 0 );\n  if (texture == 0)\n  {\n    return false;\n  }\n\n  m_textures[m_textureIndex] = texture;\n  m_textureIndex++;\n  if (m_textureIndex == 1 && m_numberOfFrames > 1)\n  {\n    m_isSpriteSheet= true;\n  }\n  else\n  {\n    m_isSpriteSheet = false;\n  }\n  m_useTransparency = p_useTransparency;\n  return true;\n}\n```", "```cpp\nvoid GameLoop()\n{\n  Render();\n}\n```", "```cpp\nvoid Render()\n{\n  glClear(GL_COLOR_BUFFER_BIT);\n  glLoadIdentity();\n\n  background->Render();\n  robot_left->Render();\n  robot_right->Render();\n  robot_left_strip->Render();\n  robot_right_strip->Render();\n\n  SwapBuffers(hDC);\n}\n```", "```cpp\nvoid Sprite::Render()\n{\n  if (m_isVisible)\n  {\n    if (m_useTransparency)\n    {\n      glEnable(GL_BLEND);\n      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    }\n\n    glBindTexture(GL_TEXTURE_2D, GetCurrentFrame());\n\n    glBegin(GL_QUADS);\n\n    GLfloat x = m_position.x;\n    GLfloat y = m_position.y;\n\n    GLfloat w = m_size.width;\n    GLfloat h = m_size.height;\n\n    GLfloat texWidth = (GLfloat)m_textureIndex / (GLfloat)m_numberOfFrames;\n    GLfloat texHeight = 1.0f;\n    GLfloat u = 0.0f;\n    GLfloat v = 0.0f;\n    if (m_textureIndex < m_numberOfFrames)\n    {\n      u = (GLfloat)m_currentFrame * texWidth;\n    }\n    glTexCoord2f(u, v); glVertex2f(x, y);\n    glTexCoord2f(u + texWidth, v); glVertex2f(x + w, y);\n    glTexCoord2f(u + texWidth, v + texHeight); glVertex2f(x + w, y + h);\n    glTexCoord2f(u, v + texHeight); glVertex2f(x, y + h);\n\n    glEnd();\n\n    if (m_useTransparency)\n    {\n      glDisable(GL_BLEND);\n    }\n  }\n}\n```", "```cpp\nconst GLuint GetCurrentFrame()\n{\n\n  if(m_isSpriteSheet)\n  {\n    return m_textures[0];\n  }\n  else\n  {\n    return m_textures[m_currentFrame];\n  }\n}\n```", "```cpp\nvoid GameLoop(const float p_deltatTime)\n{\n  Update(p_deltatTime);\n  Render();\n}\n```", "```cpp\nvoid Update(const float p_deltaTime)\n{\n  background->Update(p_deltaTime);\n  robot_left->Update(p_deltaTime);\n  robot_right->Update(p_deltaTime);\n  robot_left_strip->Update(p_deltaTime);\n  robot_right_strip->Update(p_deltaTime);\n}\n```", "```cpp\nvoid Sprite::Update(const float p_deltaTime)\n{\n  float dt = p_deltaTime;\n\n  if (m_isActive)\n  {\n    m_animationElapsed += dt;\n    if (m_animationElapsed >= m_animationDelay)\n    {\n      m_currentFrame++;\n      if (m_currentFrame >= m_numberOfFrames) m_currentFrame = 0;\n      m_animationElapsed = 0.0f;\n    }\n    m_position.x = m_position.x + m_velocity * dt;\n  }\n}\n```", "```cpp\nvoid Update(float deltaTime);\n```", "```cpp\nm_position.x += m_velocity * dt;\n```", "```cpp\nint previousTime = glutGet(GLUT_ELAPSED_TIME);\n```", "```cpp\nint currentTime = glutGet(GLUT_ELAPSED_TIME);\nfloat deltaTime = (float)(currentTime - previousTime) / 1000;\npreviousTime= currentTime;\nGameLoop(deltaTime);\n```", "```cpp\nbackground->SetVelocity(-50.0f); \n```"]