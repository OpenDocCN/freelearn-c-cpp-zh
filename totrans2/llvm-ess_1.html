<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;1.&#xA0;Playing with LLVM" id="DB7S1-684481f6e3394b1e8596d1aa3001290f"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Playing with LLVM</h1></div></div></div><p class="calibre7">The <a id="id0" class="calibre1"/>LLVM Compiler infrastructure project, started in 2000 in University of Illinois, was originally a research project to provide modern, SSA based compilation technique for arbitrary static and dynamic programming languages. Now it has grown to be an umbrella project with many sub projects within it, providing a set of reusable libraries having well defined interfaces.</p><p class="calibre7">LLVM<a id="id1" class="calibre1"/> is implemented in C++ and the main crux of it is the LLVM core libraries it provides. These libraries provide us with opt tool, the target independent optimizer, and code generation support for various target architectures. There are other tools which make use of core libraries, but our main focus in the book will be related to the three mentioned above. These are built around LLVM Intermediate Representation (LLVM IR), which can almost map all the high-level languages. So basically, to use LLVM's optimizer and code generation technique for code written in a certain programming language, all we need to do is write a frontend for a language that takes the high level language and generates LLVM IR. There are already many frontends available for languages such as C, C++, Go, Python, and so on. We will cover the following topics in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Modular design and collection of libraries</li><li class="listitem">Getting familiar with LLVM IR</li><li class="listitem">LLVM Tools and using them at command line</li></ul></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Playing with LLVM" id="DB7S1-684481f6e3394b1e8596d1aa3001290f">
<div class="book" title="Modular design and collection of libraries"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec08" class="calibre1"/>Modular design and collection of libraries</h1></div></div></div><p class="calibre7">The most important<a id="id2" class="calibre1"/> thing about LLVM is that it is designed as a <a id="id3" class="calibre1"/>collection of libraries. Let's understand these by taking the example of LLVM optimizer opt. There are many different optimization passes that the optimizer can run. Each of these passes is written as a C++ class derived from the <code class="email">Pass</code> class of LLVM. Each of the written passes can be compiled into a <span class="strong"><strong class="calibre2">.o</strong></span> file and subsequently they are archived into a <span class="strong"><strong class="calibre2">.a</strong></span> library. This library will contain all the passes for <code class="email">opt</code> tool. All the passes in this library are loosely coupled, that is they mention explicitly the dependencies on other passes.</p><p class="calibre7">When the optimizer is ran, the LLVM <code class="email">PassManager</code> uses the explicitly mentioned dependency information and runs the passes in optimal way. The library based design allows the implementer to choose the order in which passes will execute and also choose which passes are to be executed based on the requirements. Only the passes that are required are linked to the final application, not the entire optimizer.</p><p class="calibre7">The following <a id="id4" class="calibre1"/>figure demonstrates how each pass can be linked to a specific <a id="id5" class="calibre1"/>object file within a specific library. In the following figure, the <span class="strong"><strong class="calibre2">PassA</strong></span> references <span class="strong"><strong class="calibre2">LLVMPasses.a</strong></span> for <span class="strong"><strong class="calibre2">PassA.o</strong></span>, whereas the custom pass refers to a different library <span class="strong"><strong class="calibre2">MyPasses.a</strong></span> for the <span class="strong"><strong class="calibre2">MyPass.o</strong></span> object file.</p><div class="mediaobject"><img src="../images/00002.jpeg" alt="Modular design and collection of libraries" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre7">The code generator also makes use of this modular design like the <a id="id6" class="calibre1"/>
<span class="strong"><strong class="calibre2">Optimizer</strong></span>, for splitting the code generation into individual passes, namely, instruction selection, register allocation, scheduling, code layout optimization, and assembly emission.</p><p class="calibre7">In each of the following phases mentioned there are some common things for almost every target, such as an algorithm for assigning physical registers available to virtual registers even though the set of registers for different targets vary. So, the compiler writer can modify each of the passes mentioned above and create custom target-specific passes. The use of the <code class="email">tablegen</code> tool<a id="id7" class="calibre1"/> helps in achieving this using table description <code class="email">.td</code> files for specific architectures. We will discuss how this happens later in the book.</p><p class="calibre7">Another capability <a id="id8" class="calibre1"/>that arises out of this is the ability to easily pinpoint a bug to a <a id="id9" class="calibre1"/>particular pass in the optimizer. A tool name <code class="email">Bugpoint</code> <a id="id10" class="calibre1"/>makes use of this capability to automatically reduce the test case and pinpoint the pass that is causing the bug.</p></div></div>
<div class="book" title="Getting familiar with LLVM IR"><div class="book" id="E9OE2-684481f6e3394b1e8596d1aa3001290f"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec09" class="calibre1"/>Getting familiar with LLVM IR</h1></div></div></div><p class="calibre7">LLVM <span class="strong"><strong class="calibre2">Intermediate Representation</strong></span> (<span class="strong"><strong class="calibre2">IR</strong></span>) is the heart <a id="id11" class="calibre1"/>of the LLVM project. In general every compiler produces an intermediate representation on which it runs most of its optimizations. For a compiler targeting multiple-source languages and different architectures the important decision while selecting an IR is that it should neither be of very high-level, as in very closely attached to the source language, nor it should be very low-level, as in close to the target machine instructions. LLVM IR aims to be a universal IR of a kind, by being at a low enough level that high-level ideas may be cleanly mapped to it. Ideally the LLVM IR should have been target-independent, but it is not so because of the inherent target dependence in some of the programming languages itself. For example, when using standard C headers in a Linux system, the header files itself are target dependent, which may specify a particular type to an entity so that it matches the system calls of the particular target architecture.</p><p class="calibre7">Most of the LLVM tools revolve around this Intermediate Representation. The frontends of different languages generate this IR from the high-level source language. The optimizer tool of LLVM runs on this generated IR to optimize the code for better performance and the code generator makes use of this IR for target specific code generation. This IR has three equivalent forms:</p><div class="book"><ul class="itemizedlist"><li class="listitem">An in-memory compiler IR</li><li class="listitem">An on-disk bitcode representation</li><li class="listitem">A Human readable form (LLVM Assembly)</li></ul></div><p class="calibre7">Now let's take an example to see how this LLVM IR looks like. We will take a small C code and convert it into LLVM IR using clang and try to understand the details of LLVM IR by mapping it back to the source language.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ cat add.c</strong></span>
<span class="strong"><strong class="calibre2">int globvar = 12;</strong></span>

<span class="strong"><strong class="calibre2">int add(int a) {</strong></span>
<span class="strong"><strong class="calibre2">return globvar + a;</strong></span>
<span class="strong"><strong class="calibre2">}</strong></span>
</pre></div><p class="calibre7">Use the clang frontend with<a id="id12" class="calibre1"/> the following options to convert it to LLVM IR:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ clang -emit-llvm -c -S add.c</strong></span>
<span class="strong"><strong class="calibre2">$ cat add.ll</strong></span>
<span class="strong"><strong class="calibre2">; ModuleID = 'add.c'</strong></span>
<span class="strong"><strong class="calibre2">target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"</strong></span>
<span class="strong"><strong class="calibre2">target triple = "x86_64-unknown-linux-gnu"</strong></span>

<span class="strong"><strong class="calibre2">@globvar = global i32 12, align 4</strong></span>

<span class="strong"><strong class="calibre2">; Function Attrs: nounwind uwtable</strong></span>
<span class="strong"><strong class="calibre2">define i32 @add(i32 %a) #0 {</strong></span>
<span class="strong"><strong class="calibre2">  %1 = alloca i32, align 4</strong></span>
<span class="strong"><strong class="calibre2">  store i32 %a, i32* %1, align 4</strong></span>
<span class="strong"><strong class="calibre2">  %2 = load i32, i32* @globvar, align 4</strong></span>
<span class="strong"><strong class="calibre2">  %3 = load i32, i32* %1, align 4</strong></span>
<span class="strong"><strong class="calibre2">  %4 = add nsw i32 %2, %3</strong></span>
<span class="strong"><strong class="calibre2">  ret i32 %4</strong></span>
<span class="strong"><strong class="calibre2">}</strong></span>

<span class="strong"><strong class="calibre2">attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "unsafe-fp-math"="false" "use-soft-float"="false" }</strong></span>

<span class="strong"><strong class="calibre2">!llvm.ident = !{!0}</strong></span>
</pre></div><p class="calibre7">Now let's look at the IR generated and see what it is all about. You can see the very first line giving the ModuleID, that it defines the LLVM module for <code class="email">add.c</code> file. An LLVM module is a top–level data structure that has the entire contents of the input LLVM file. It consists of functions, global variables, external function prototypes, and symbol table entries.</p><p class="calibre7">The following lines show the target data layout and target triple from which we can know that the target is x86_64 processor with Linux running on it. The <code class="email">datalayout</code> string tells us what is the endianess of machine ('<code class="email">e</code>' meaning little endian), and the name mangling (<code class="email">m : e</code> denotes elf type). Each specification is separated by '<code class="email">–</code>'and each following spec gives information about the type and size of that type. For example, <code class="email">i64:64</code> says 64 bit integer is of 64 bits.</p><p class="calibre7">Then we have a global <a id="id13" class="calibre1"/>variable <code class="email">globvar</code>. In LLVM IR all globals start with '<code class="email">@</code>' and all local variables start with '<code class="email">%</code>'. There are two main reasons why the variables are prefixed with these symbols. The first one being, the compiler won't have to bother about a name clash with reserved words, the other being that the compiler can come up quickly with a temporary name without having to worry about a conflict with symbol table conflicts. This second property is useful for representing the IR in <span class="strong"><strong class="calibre2">static single assignment</strong></span> (<span class="strong"><strong class="calibre2">SSA</strong></span>)<a id="id14" class="calibre1"/> from where each variable is assigned only a single time and every use of a variable is preceded by its definition. So, while converting a normal program to SSA form, we create a new temporary name for every redefinition of a variable and limit the range of earlier definition till this redefinition.</p><p class="calibre7">LLVM views global variables as pointers, so an explicit dereference of the global variable using load instruction is required. Similarly, to store a value, an explicit store instruction is required.</p><p class="calibre7">Local variables have two categories:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Register allocated local variables</strong></span>: These are the<a id="id15" class="calibre1"/> temporaries and <a id="id16" class="calibre1"/>allocated virtual registers. The virtual registers are allocated physical registers during the code generation phase which we will see in a later chapter of the book. They are created by using a new symbol for the variable like:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">%1 = some value</strong></span>
</pre></div></li><li class="listitem"><span class="strong"><strong class="calibre2">Stack allocated local variables</strong></span>: These are <a id="id17" class="calibre1"/>created by<a id="id18" class="calibre1"/> allocating variables on the stack frame of a currently executing function, using the <code class="email">alloca</code> instruction. The <code class="email">alloca</code> instruction gives a pointer to the allocated type and explicit use of load and store instructions is required to access and store the value.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">%2 = alloca i32</strong></span>
</pre></div></li></ul></div><p class="calibre7">Now let's see how the <code class="email">add</code> function is represented in LLVM IR. <code class="email">define i32 @add(i32 %a)</code> is very similar to how functions are declared in C. It specifies the function returns integer type <code class="email">i32</code> and takes an integer argument. Also, the function name is preceded by '<code class="email">@</code>', meaning it has global visibility.</p><p class="calibre7">Within the function is actual processing for functionality. Some important things to note here are that LLVM uses a three-address instruction, that is a data processing instruction, which has two source operands and places the result in a separate destination operand (<code class="email">%4 = add  i32 %2, %3</code>). Also the code is in SSA form, that is each value in the IR has a single assignment which defines the value. This is useful for a number of optimizations.</p><p class="calibre7">The attributes string that follows in the generated IR specifies the function attributes which are very similar to C++ attributes. These attributes are for the function that has been defined. For each function defined there is a set of attributes defined in the LLVM IR.</p><p class="calibre7">The code that follows the <a id="id19" class="calibre1"/>attributes is for the <code class="email">ident</code> directive that identifies the module and compiler version.</p></div>
<div class="book" title="LLVM tools and using them in the command line"><div class="book" id="F8902-684481f6e3394b1e8596d1aa3001290f"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>LLVM tools and using them in the command line</h1></div></div></div><p class="calibre7">Until now, we have understood what LLVM IR (human readable form) is and how it can be used to represent a high-level language. Now, we will take a look at some of the tools that LLVM provides so that we can play around with this IR converting to other formats and back again to the <a id="id20" class="calibre1"/>original form. Let's take a look at these tools one by one along with examples.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">llvm-as</strong></span>: This is the <a id="id21" class="calibre1"/>LLVM assembler that takes LLVM IR in assembly <a id="id22" class="calibre1"/>form (human readable) and converts it to bitcode format. Use the preceding <code class="email">add.ll</code> as an example to convert it into bitcode. To know more about the <a id="id23" class="calibre1"/>LLVM Bitcode file format refer to <a class="calibre1" href="http://llvm.org/docs/BitCodeFormat.html">http://llvm.org/docs/BitCodeFormat.html</a><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ llvm-as add.ll –o add.bc</strong></span>
</pre></div><p class="calibre12">To view the content of this bitcode file, a tool such as <code class="email">hexdump</code> can be used.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ hexdump –c add.bc</strong></span>
</pre></div></li><li class="listitem"><span class="strong"><strong class="calibre2">llvm-dis</strong></span>: This is<a id="id24" class="calibre1"/> the LLVM disassembler. It takes a bitcode file as <a id="id25" class="calibre1"/>input and outputs the llvm assembly.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ llvm-dis add.bc –o add.ll</strong></span>
</pre></div><p class="calibre12">If you check <code class="email">add.ll</code> and compare it with the previous version, it will be the same as the previous one.</p></li><li class="listitem"><span class="strong"><strong class="calibre2">llvm-link</strong></span>: llvm-link links<a id="id26" class="calibre1"/> two or more<a id="id27" class="calibre1"/> llvm bitcode files and outputs one llvm bitcode file. To view a demo write a <code class="email">main.c</code> file that calls the function in the <code class="email">add.c</code> file.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ cat main.c</strong></span>
<span class="strong"><strong class="calibre2">#include&lt;stdio.h&gt;</strong></span>

<span class="strong"><strong class="calibre2">extern int add(int);</strong></span>

<span class="strong"><strong class="calibre2">int main() {</strong></span>
<span class="strong"><strong class="calibre2">int a = add(2);</strong></span>
<span class="strong"><strong class="calibre2">printf("%d\n",a);</strong></span>
<span class="strong"><strong class="calibre2">return 0;</strong></span>
<span class="strong"><strong class="calibre2">}</strong></span>
</pre></div><p class="calibre12">Convert the C source code to LLVM bitcode format using the following command.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ clang -emit-llvm -c main.c</strong></span>
</pre></div><p class="calibre12">Now<a id="id28" class="calibre1"/> link <code class="email">main.bc</code> <a id="id29" class="calibre1"/>and <code class="email">add.bc</code> to generate <code class="email">output.bc</code>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ llvm-link main.bc add.bc -o output.bc</strong></span>
</pre></div></li><li class="listitem"><span class="strong"><strong class="calibre2">lli</strong></span>: lli<a id="id30" class="calibre1"/> directly<a id="id31" class="calibre1"/> executes programs in LLVM bitcode format using a just-in-time compiler or interpreter, if one is available for the current architecture. lli is not like a virtual machine and cannot execute IR of different architecture and can only interpret for host architecture. Use the bitcode format file generated by llvm-link as input to lli. It will display the output on the standard output.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ lli output.bc</strong></span>
<span class="strong"><strong class="calibre2">14</strong></span>
</pre></div></li><li class="listitem"><span class="strong"><strong class="calibre2">llc</strong></span>: llc<a id="id32" class="calibre1"/> is the static<a id="id33" class="calibre1"/> compiler. It compiles LLVM inputs (assembly form/ bitcode form) into assembly language for a specified architecture.  In the following example it takes the <code class="email">output.bc</code> file generated by llvm-link and generates the assembly file <code class="email">output.s</code>.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ llc output.bc –o output.s</strong></span>
</pre></div><p class="calibre12">Let's look at the content of the <code class="email">output.s</code> assembly, specifically the two functions of the generated code, which is very similar to what a native assembler would have generated.</p><div class="informalexample"><pre class="programlisting">Function main:
  .type  main,@function
main:                                   # @main
  .cfi_startproc
# BB#0:
  pushq  %rbp
.Ltmp0:
  .cfi_def_cfa_offset 16
.Ltmp1:
  .cfi_offset %rbp, -16
  movq  %rsp, %rbp
.Ltmp2:
  .cfi_def_cfa_register %rbp
  subq  $16, %rsp
  movl  $0, -4(%rbp)
  movl  $2, %edi
  callq  add
  movl  %eax, %ecx
  movl  %ecx, -8(%rbp)
  movl  $.L.str, %edi
  xorl  %eax, %eax
  movl  %ecx, %esi
  callq  printf
  xorl  %eax, %eax
  addq  $16, %rsp
  popq  %rbp
  retq
.Lfunc_end0:


Function: add
add:                                    # @add
  .cfi_startproc
# BB#0:
  pushq  %rbp
.Ltmp3:
  .cfi_def_cfa_offset 16
.Ltmp4:
  .cfi_offset %rbp, -16
  movq  %rsp, %rbp
.Ltmp5:
  .cfi_def_cfa_register %rbp
  movl  %edi, -4(%rbp)
  addl  globvar(%rip), %edi
  movl  %edi, %eax
  popq  %rbp
  retq
.Lfunc_end1:</pre></div></li></ul></div><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">opt</strong></span>: This is <a id="id34" class="calibre1"/>modular<a id="id35" class="calibre1"/> LLVM analyzer and optimizer. It takes the input file and runs the optimization or analysis specified on the command line. Whether it runs the analyzer or optimizer depends on the command-line option.<div class="informalexample"><pre class="programlisting">opt [options] [input file name]</pre></div><p class="calibre12">When the <code class="email">–analyze</code> option is provided it performs various analysis on the input. There is a set of  analysis options already provided that can be specified through command line or else one can write down their own analysis pass and provide the library to that analysis pass. Some of the useful analysis passes that can be specified using the following <a id="id36" class="calibre1"/>command line arguments are:</p><div class="book"><ul class="itemizedlist1"><li class="listitem"><span class="strong"><strong class="calibre2">basicaa</strong></span>: basic <a id="id37" class="calibre1"/>alias analysis</li><li class="listitem"><span class="strong"><strong class="calibre2">da</strong></span>: dependence<a id="id38" class="calibre1"/> analysis</li><li class="listitem"><span class="strong"><strong class="calibre2">instcount</strong></span>: count the <a id="id39" class="calibre1"/>various instruction types.</li><li class="listitem"><span class="strong"><strong class="calibre2">loops</strong></span>: information<a id="id40" class="calibre1"/> about loops</li><li class="listitem"><span class="strong"><strong class="calibre2">scalar evolution</strong></span>: analysis<a id="id41" class="calibre1"/> of scalar <a id="id42" class="calibre1"/>evolution</li></ul></div><p class="calibre12">When the <code class="email">–analyze</code> option is not passed, the opt tool does the actual optimization work and tries to optimize the code depending upon the command-line options passed. Similarly to the preceding case, you can use some of the optimization passes already present or write your own pass for optimization. Some of the useful optimization passes that can be specified using the following command-line arguments are:</p><div class="book"><ul class="itemizedlist1"><li class="listitem"><span class="strong"><strong class="calibre2">constprop</strong></span>: simple <a id="id43" class="calibre1"/>constant <code class="email">propagation.</code></li><li class="listitem"><span class="strong"><strong class="calibre2">dce</strong></span>: <code class="email">dead</code> code elimination pass</li><li class="listitem"><span class="strong"><strong class="calibre2">globalopt</strong></span>: pass for <a id="id44" class="calibre1"/>global variable optimization </li><li class="listitem"><span class="strong"><strong class="calibre2">inline</strong></span>: pass for <a id="id45" class="calibre1"/>function inlining</li><li class="listitem"><span class="strong"><strong class="calibre2">instcombine</strong></span>: for<a id="id46" class="calibre1"/> combining redundant instructions</li><li class="listitem"><span class="strong"><strong class="calibre2">licm</strong></span>: loop <a id="id47" class="calibre1"/>invariant code motion</li><li class="listitem"><span class="strong"><strong class="calibre2">tailcallelim</strong></span>: Tail <a id="id48" class="calibre1"/>Call elimination</li></ul></div></li></ul></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre7">Before going ahead we must note that all the tools mentioned in this chapter are meant for compiler writers. An end user can directly use clang for compilation of C code without converting the C code into intermediate representation</p></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre7">
<span class="strong"><strong class="calibre2">Downloading the example code</strong></span>
</p><p class="calibre7">You can download the example code files from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div>
<div class="book" title="Summary" id="G6PI1-684481f6e3394b1e8596d1aa3001290f"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we looked into the modular design of LLVM: How it is used in the opt tool of LLVM, and how it is applicable across LLVM core libraries. Then we took a look into LLVM intermediate representation, and how various entities (variables, functions etc.) of a language are mapped to LLVM IR. In the last section, we discussed about some of the important LLVM tools, and how they can be used to transform the LLVM IR from one form to another.</p><p class="calibre7">In the next chapter, we will see how we can write a frontend for a language that can output LLVM IR using the LLVM machinery.</p></div></body></html>