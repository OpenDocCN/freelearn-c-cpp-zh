<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Sensing with Digital Inputs"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Sensing with Digital Inputs</h1></div></div></div><p>Arduino boards have inputs and outputs. Indeed, this is also one of the strengths of this platform: to directly provide headers connecting the ATMega chipset legs. We can then directly wire an input or output to any other external component or circuit without having to solder.</p><p>In case you need it here, I'm reminding you of some points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Arduino has digital and analog inputs</li><li class="listitem" style="list-style-type: disc">Arduino has digital outputs that can also be used to mimic analog outputs</li></ul></div><p>We are going to talk about digital inputs in this chapter.</p><p>We'll learn about the global concept of sensing the world. We are going to meet a new companion named <span class="strong"><strong>Processing</strong></span> <a id="id506" class="indexterm"/>because it is a nice way to visualize and illustrate all that we are going to do in a more graphical way. It is also a pretext to show you this very powerful and open source tool. Then, it will drive us to design the first serial communication protocol between the board and a piece of software.</p><p>We'll specifically play with switches, but we will also cover some useful hardware design patterns.</p><div class="section" title="Sensing the world"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Sensing the world</h1></div></div></div><p>In our over-connected world, a lot of systems don't even have sensors<a id="id507" class="indexterm"/>. We, humans, own a bunch of biological sensors directly in and over our body. We are able to feel temperature with our skin, light with our eyes, chemical components with both our nose and mouth, and air movement with ears. From a characteristic of our world, we are able to sense, integrate this feeling, and eventually to react.</p><p>If I go a bit further, I can remember a definition for senses from my early physiological courses at university (you remember, I was a biologist in one of my previous lives):</p><div class="blockquote"><blockquote class="blockquote"><p>"Senses are physiological <a id="id508" class="indexterm"/>capacities that provide data for perception"</p></blockquote></div><p>This basic physiological model is a nice way to understand how we can work with an Arduino board to make it sense the world.</p><p>Indeed, it introduces three elements we need:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A capacity</li><li class="listitem" style="list-style-type: disc">Some data</li><li class="listitem" style="list-style-type: disc">A perception</li></ul></div><div class="section" title="Sensors provide new capacities"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Sensors provide new capacities</h2></div></div></div><p>A sensor is a physical<a id="id509" class="indexterm"/> converter, able to measure a physical quantity and to translate it into a signal understandable directly or indirectly by humans or machines.</p><p>A<a id="id510" class="indexterm"/> thermometer, for example, is a sensor. It is able to measure the local temperature and to translate it into a signal. Alcohol-based or Mercury-based thermometers provide a scale written on them and the contraction/dilatation of the chemical matter according to the temperature makes them easy to read.</p><p>In order to make our Arduino able to sense the world, temperature for instance, we would have to connect a sensor.</p><div class="section" title="Some types of sensors"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec56"/>Some types of sensors</h3></div></div></div><p>We can find<a id="id511" class="indexterm"/> various types of types of sensors. We often think about environmental sensors when we use the term sensor.</p><p>I'll begin by quoting some environmental quantities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Temperature</li><li class="listitem" style="list-style-type: disc">Humidity</li><li class="listitem" style="list-style-type: disc">Pressure</li><li class="listitem" style="list-style-type: disc">Gas sensors (gas-specific or not, smoke)</li><li class="listitem" style="list-style-type: disc">Electromagnetic fields</li><li class="listitem" style="list-style-type: disc">Anemometer (wind speed)</li><li class="listitem" style="list-style-type: disc">Light</li><li class="listitem" style="list-style-type: disc">Distance</li><li class="listitem" style="list-style-type: disc">Capacitance</li><li class="listitem" style="list-style-type: disc">Motion</li></ul></div><p>This is a non-exhaustive list. For almost each quantity, we can find a sensor. Indeed, for each quantifiable <a id="id512" class="indexterm"/>physical or chemical phenomenon, there is a way to measure and track it. Each of them provides data related to the quantity measured.</p></div></div><div class="section" title="Quantity is converted to data"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Quantity is converted to data</h2></div></div></div><p>When we use sensors, the reason is that we need to have a numeric value coming from a physical phenomenon, such as temperature or movement. If we could directly measure the temperature with our skin's thermal sensors, we would have been able to understand the relationship between the volume of chemical components and temperature itself. Because we know this relationship from other physical measures or calculations, we have been able to design thermometers.</p><p>Indeed, thermometers<a id="id513" class="indexterm"/> are converting a quantity (here a volume) related to the temperature into a value readable on the scale of the thermometer. In fact, we have a double conversion here. The volume is a function depending on the temperature. The height of the liquid inside the thermometer is a function depending on the volume of the liquid. Thus, we can understand that the height and temperature are related. This is the double conversion.</p><p>Anyway, the thermometer is a nice module that integrates all this mathematical and physical wizardry to provide data, a value: the temperature. As shown in the following figure, volume is used to provide a temperature:</p><div class="mediaobject"><img src="graphics/7584_05_01.jpg" alt="Quantity is converted to data"/></div><p>All sensors work like that. They are modules measuring physical phenomenon and providing a value. We'll see later that those values can be very different, and eventually encoded too.</p></div><div class="section" title="Data has to be perceived"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Data has to be perceived</h2></div></div></div><p>The data provided by a sensor makes more sense if it is read. This can be obvious but imagine that the reader isn't a human but is instead an instrument, a machine, or in our case, an Arduino board.</p><p>Indeed, let's take an electronic thermal sensor. At first, this one has to be supplied with electricity in order to work. Then, if we are able to supply it but unable to physically measure the electric potential generated by it from its pins, we couldn't appreciate the main value it tries to provide us: the temperature.</p><p>In our case, the Arduino would be the device that is able to convert the electric potential to something readable or at least easier to understand for us, humans. This is again a conversion. From the physical phenomenon that we want to translate, to the device displaying the value explaining the physical phenomenon, there are conversions and perceptions.</p><p>I can simplify the process as shown in the following figure:</p><div class="mediaobject"><img src="graphics/7584_05_02.jpg" alt="Data has to be perceived"/></div></div></div></div>
<div class="section" title="What does digital mean?"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>What does digital mean?</h1></div></div></div><p>Let's define precisely what the digital term means here.</p><div class="section" title="Digital and analog concepts"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Digital and analog concepts</h2></div></div></div><p>Digital, in<a id="id514" class="indexterm"/> the computer and electronic worlds, means discrete, which is the opposite of analog/continuous. It is also a mathematical definition. We often talk about domains to define the cases for use of digital and analog.</p><p>Usually, the analog<a id="id515" class="indexterm"/> domain is the domain related to physical measures. Our temperature can have all the values that are possible and that exist, even if our measuring equipment dosen't have an infinite resolution.</p><p>The digital domain is the one of computers. Because of the encoding and finite memory size, computers translates analog/continuous values into digital representations.</p><p>On a graph, this could be visualized as follows:</p><div class="mediaobject"><img src="graphics/7584_05_03.jpg" alt="Digital and analog concepts"/></div></div><div class="section" title="Inputs and outputs of Arduino"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Inputs and outputs of Arduino</h2></div></div></div><p>Arduino owns inputs<a id="id516" class="indexterm"/> and<a id="id517" class="indexterm"/> outputs. We can also distinguish analog and digital pins.</p><p>You have to remember the following points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Arduino provides digital pins that can be both an input or an output</li><li class="listitem" style="list-style-type: disc">Arduino provides only analog input, not output</li></ul></div><p>Inputs and outputs are pins provided by the board to communicate with external peripherals.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>Inputs provide the ability to feel the world.</p><p>Outputs provide the ability to alter the world.</p></div></div><p>We often talk about <span class="emphasis"><em>reading pins</em></span> for inputs and <span class="emphasis"><em>writing pins</em></span> for outputs. Indeed, from the Arduino board point of view, we are reading from the world and writing to the world, aren't we?</p><p>A digital input is a digital pin set up like an input and providing the capacity for electrical potential reading and conversion to 0 or 1 to the Arduino board. We'll illustrate this very soon using switches.</p><p>But before manipulating this directly, let me introduce a new friend named <span class="strong"><strong>Processing</strong></span>. We'll use it to easily illustrate our Arduino tests further in the book.</p></div></div>
<div class="section" title="Introducing a new friend &#x2013; Processing"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Introducing a new friend – Processing</h1></div></div></div><p>Processing<a id="id518" class="indexterm"/> is an open source programming language and Integrated Development Environment (IDE) for people who want to create images, animations, and interaction.</p><p>This major open source project was initiated in 2001 by Ben Fry and Casey Reas, two gurus and former students of John Maeda at the Aesthetics and Computation Group at the MIT Media Lab.</p><p>It is a programming framework most used by non-programmers. Indeed, it has been designed primarily for this purpose. One of the first targets of Processing is to provide an easy way of programming for non-programmers through the instant gratification of visual feedback. Indeed, as we know, programming can be very abstract. Processing natively provides a canvas on which we can draw, write, and do more. It also provides a very user-friendly IDE that we are going to see on the official website at <a class="ulink" href="http://processing.org">http://processing.org</a>.</p><p>You'll probably also find the term Processing written as <span class="strong"><strong>Proce55ing</strong></span>
<a id="id519" class="indexterm"/> as the domain name <code class="literal">processing.org</code> was already taken at the time of its inception.</p><div class="section" title="Is Processing a language?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Is Processing a language?</h2></div></div></div><p>Processing isn't a language in the strictest sense. It's a subset of Java with some external libraries and a custom IDE.</p><p>Programming with Processing is usually performed using the native IDE comes with the download as we will see in this section.</p><p>Processing uses the Java language but provides simplified syntax and graphics programming. It also simplifies all compilations steps into a one-click action like Arduino IDE.</p><p>Like Arduino core, it provides a huge set of ready-to-use functions. You can find all references at <a class="ulink" href="http://processing.org/reference">http://processing.org/reference</a>.</p><p>There is now more than one way to use Processing. Indeed, because JavaScript runtimes integrated in web browsers became more and more powerful, we can use a JavaScript derived project. You still continue to code using Java, you include this code in your webpage, and as the official website says "<span class="emphasis"><em>Processing.js does the rest. It's not magic, but almost</em></span>." The <a id="id520" class="indexterm"/>website is <a class="ulink" href="http://processingjs.org">http://processingjs.org</a>.</p><p>There is also something very interesting: You can package applications coded using Processing for Android mobile OS. You can read this if you are interested at <a class="ulink" href="http://processing.org/learning/android">http://processing.org/learning/android</a>.</p><p>I will avoid going on a tangent with the JS and Android applications, but I felt it was important enough to mention these usages.</p></div><div class="section" title="Let's install and launch it"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec76"/>Let's install and launch it</h2></div></div></div><p>Like the Arduino <a id="id521" class="indexterm"/>framework, the Processing framework doesn't include installation program. You just have to put it somewhere and run it from there.</p><p>The download <a id="id522" class="indexterm"/>URL is: <a class="ulink" href="http://processing.org/download">http://processing.org/download</a>.</p><p>First, download the package corresponding to your OS. Please refer to the website for the install process for your specific OS.</p><p>On OS X, you have to <a id="id523" class="indexterm"/>deflate the zip file and run the resulting file with the icon:</p><div class="mediaobject"><img src="graphics/7584_05_004.jpg" alt="Let's install and launch it"/><div class="caption"><p>Processing icon</p></div></div><p>Double-click on the icon, and you'll see a pretty nice splash screen:</p><div class="mediaobject"><img src="graphics/7584_05_005.jpg" alt="Let's install and launch it"/></div><p>Then you'll see the <a id="id524" class="indexterm"/>Processing IDE as shown in the following image:</p><div class="mediaobject"><img src="graphics/7584_05_006.jpg" alt="Let's install and launch it"/><div class="caption"><p>Processing's IDE looks like others</p></div></div></div><div class="section" title="A very familiar IDE"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec77"/>A very familiar IDE</h2></div></div></div><p>Indeed, the <a id="id525" class="indexterm"/>Processing IDE looks like the Arduino one. The Processing IDE is like the father of the Arduino IDE.</p><p>This is totally normal because the Arduino IDE has been forked from the Processing IDE. Now, we are going to check that we'll be very comfortable with the Processing IDE as well.</p><p>Let's explore it and run a small example:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to <span class="strong"><strong>Files</strong></span> | <span class="strong"><strong>Examples Basics</strong></span> | <span class="strong"><strong>Arrays</strong></span> | <span class="strong"><strong>ArraysObjects</strong></span>.</li><li class="listitem">Then, click on the first icon (the play symbol arrow). You should see the following screenshot:<div class="mediaobject"><img src="graphics/7584_05_007.jpg" alt="A very familiar IDE"/><div class="caption"><p>Running ArrayObjects native example in Processing</p></div></div></li><li class="listitem">Now click on the small square (stop symbol). Yes, this new playground is very familiar.<div class="mediaobject"><img src="graphics/7584_05_008.jpg" alt="A very familiar IDE"/><div class="caption"><p>Processing IDE with ArrayObjects example opened</p></div></div></li></ol></div><p>At the top we can see some familiar icons.</p><p>From <a id="id526" class="indexterm"/>left to right, they are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Run</strong></span> (small arrow): This is used to compile and run your program</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stop</strong></span> (small square): This is used to stop the program when it is running</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>New project</strong></span> (small page): This is used to open a blank canvas</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Open project</strong></span> (top arrow): This is used to open an existing project</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Save project</strong></span> (down arrow): This is used to save a project</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Export application</strong></span> (right arrow): This is used to create an application</li></ul></div><p>No Upload button of course. There is no need to upload anything here; we are on the computer and we only want to code applications, compile them, and run them.</p><p>With Processing, you have everything in hand to code, compile, and run.</p><p>You can have some tabs if you use more than one file in your project (especially if you use some separate Java classes).</p><p>Under this tab zone, you have the text area where you type your code. Code is colored as in the Arduino IDE, and this is very useful.</p><p>At last, at the <a id="id527" class="indexterm"/>bottom, you have the log console area where all the messages can be output, from errors to our own tracer messages.</p><div class="section" title="Alternative IDEs and versioning"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec57"/>Alternative IDEs and versioning</h3></div></div></div><p>If you are interested in<a id="id528" class="indexterm"/> digging some IDE alternatives, I'd suggest that you use the universal and open source software development environment Eclipse. I suggest that to all the students I meet who want to go further in pure-development fields. This powerful IDE can be easily set up to support versioning.</p><p>Versioning<a id="id529" class="indexterm"/> is a very nice concept providing an easy way to track versions of your code. You can, for instance, code something, test it, back it up in your versioning system, then continue your code design. If you run it and have a nice and cute crash at some point, you can easily check the differences between your working code and the new non working one and make your troubleshooting much easier! I won't describe versioning systems in detail, but I want to introduce you to the two main systems that are widely used a</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://subversion.apache.org">http://subversion.apache.org</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Git</strong></span><a id="id530" class="indexterm"/>: <a class="ulink" href="http://git-scm.com">http://git-scm.com</a></li></ul></div><p>
</p></div></div><div class="section" title="Checking an example"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec78"/>Checking an example</h2></div></div></div><p>Here is a small piece of <a id="id531" class="indexterm"/>code showing some cheap and easy design patterns. You can also find this code in the folder <code class="literal">Chapter05</code>
<code class="literal">/p</code>
<code class="literal">rocessingMultipleEasing/</code> in the code bundle:</p><div class="informalexample"><pre class="programlisting">// some declarations / definitions
int particlesNumber = 80;    // particles number
float[] positionsX = new float[particlesNumber]; // store particles X-coordinates float[] positionsY = new float[particlesNumber]; // store particles Y-coordinates
float[] radii = new float[particlesNumber];      // store particles radii
float[] easings = new float[particlesNumber];    // store particles easing amount

// setup is run one time at the beginning
void setup() {
  size(600, 600); // define the playground
  noStroke();     // define no stroke for all shapes drawn

  // for loop initializing easings &amp; radii for all particles
  for (int i=0 ; i &lt; particlesNumber ; i++)
  {
    easings[i] = 0.04 * i / particlesNumber;  // filling the easing array
    radii[i] = 30 * i / particlesNumber ;     // filling the radii array
  }
}

// draw is run infinitely
void draw() {
  background(34);  // define the background color of the playground

  // let's store the current mouse position
  float targetX = mouseX;  
  float targetY = mouseY;

  // for loop across all particles
  for (int i=0 ; i &lt; particlesNumber ; i++)
  {


    float dx = targetX - positionsX[i];  // calculate X distance mouse / particle
    if (abs(dx) &gt; 1) {                   // if distance &gt; 1, update position
      positionsX[i] += dx * easings[i];
    }


    float dy = targetY - positionsY[i];    // same for Y
    if (abs(dy) &gt; 1) {
      positionsY[i] += dy * easings[i];
    }
    // change the color of the pencil for the particle i
    fill(255 * i / particlesNumber);

    // draw the particle i
    ellipse(positionsX[i], positionsY[i], radii[i], radii[i]);
  }
}</pre></div><p>You can run <a id="id532" class="indexterm"/>this piece of code. Then, you can move the mouse into the canvas and enjoy what is happening.</p><div class="mediaobject"><img src="graphics/7584_05_010.jpg" alt="Checking an example"/><div class="caption"><p>processingMultipleEasing code running and showing a strange series of particles following the mouse</p></div></div><p>First, check the code. Basically, this is Java. I guess you aren't shocked too much, are you? Indeed, Java derives from C.</p><p>You can see three main parts in your code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Variable declarations/definitions</li><li class="listitem" style="list-style-type: disc">The <code class="literal">setup()</code>function<a id="id533" class="indexterm"/> that runs only once at the beginning</li><li class="listitem" style="list-style-type: disc">The<code class="literal"> draw()</code> function<a id="id534" class="indexterm"/> that runs infinitely until you press stop</li></ul></div><p>Ok. You <a id="id535" class="indexterm"/>can see the <code class="literal">setup()</code> functions in the Arduino core and Processing have similar roles, and <code class="literal">loop()</code> and <code class="literal">draw()</code> too.</p><p>This piece of code shows some usual design patterns with Processing. I first initiate a variable storing the global number of particles, then I initiate some arrays for each particle I want to create. Please notice all these arrays are empty at this step!</p><p>This pattern is usual because it offers good readability and works fine too. I could have used classes or even multidimensional arrays, but in this latter case, I would not even have benefits except a shorter (but less readable) code. In all those arrays, the <span class="emphasis"><em>N</em></span>th indexed value represents the particle <span class="emphasis"><em>N</em></span>. In order to store/retrieve the parameters of particle <span class="emphasis"><em>N</em></span>, I have to manipulate the <span class="emphasis"><em>N</em></span>th value for each array. The parameters are spread inside each array but are easy to store and retrieve, aren't they?</p><p>In <code class="literal">setup()</code>, I define and instantiate the canvas and its size of 600 x 600. Then, I'm defining that there will be no stroke in any of my drawings. The stroke of a circle, for instance, is its border.</p><p>Then, I'm <a id="id536" class="indexterm"/>filling the <code class="literal">easing</code> and <code class="literal">radii</code> arrays using a <code class="literal">for</code> loop structure. This is a very usual pattern where we can use <code class="literal">setup()</code> to initialize a bunch of parameters at the beginning. Then we can check the <code class="literal">draw()</code> loop. I'm defining a color for the background. This function also erases the canvas and fills it with the color in argument. Check the background function on the reference page to understand how we can use it. This erase/fill is a nice way to erase each frame and to reset the canvas.</p><p>After this erase/fill, I'm storing the current position of the mouse for each coordinate in the local variables <code class="literal">targetX</code> and <code class="literal">targetY</code>.</p><p>The core of the program sits in the <code class="literal">for</code> loop. This loop walks over each particle and makes something for each of them. The code is quite self-explanatory. I can add here that I'm checking the distance between the mouse and each particle for each frame (each run of <code class="literal">draw()</code>), and I draw each particle by moving them a bit, according to its easing.</p><p>This is a very simple example but a nice one I used to show to illustrate the power of Processing.</p></div><div class="section" title="Processing and Arduino"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec79"/>Processing and Arduino</h2></div></div></div><p>Processing and <a id="id537" class="indexterm"/>Arduino are very good friends.</p><p>Firstly, they are <a id="id538" class="indexterm"/>both open source. It is a very friendly characteristic bringing a lot of advantages like code source sharing and gigantic communities, among others. They are available for all OSes: Windows, OS X, and Linux. We also can download them for free and run them in a couple of clicks.</p><p>I began to program primarily with Processing, and I use it a lot for some of my own data visualization projects and art too. Then, we can illustrate complex and abstract data flows by smooth and primitive shapes on a screen.</p><p>What we are going to do together now is display Arduino activity on the Processing canvas. Indeed, this is a common use of Processing as an eye-friendly software for Arduino.</p><p>We are going to design a very trivial and cheap protocol of communication between the hardware and the software. This will show you the path that we'll dig further in the next chapters of this book. Indeed, if you want to get your Arduino talking with another software framework (I'm thinking about Max 6, openFrameworks, Cinder, and many others), you'll have to follow the same ways of design.</p><div class="mediaobject"><img src="graphics/7584_05_011.jpg" alt="Processing and Arduino"/><div class="caption"><p>Arduino and some software friends</p></div></div><p>I often say <a id="id539" class="indexterm"/>Arduino can work as a very smart <span class="emphasis"><em>organ</em></span> of software. If you<a id="id540" class="indexterm"/> want to connect some software to the real, physical world, Arduino is the way to go. Indeed, that way, software can sense the world, providing your computer with new features. Let's move on by displaying some physical world events on the computer.</p></div></div>
<div class="section" title="Pushing the button"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Pushing the button</h1></div></div></div><p>We are going to<a id="id541" class="indexterm"/> have fun. Yes, this is the very special moment when we are going to link the physical world to the virtual world. Arduino is all about this.</p><div class="section" title="What is a button, a switch?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec80"/>What is a button, a switch?</h2></div></div></div><p>A <span class="strong"><strong>switch</strong></span>
<a id="id542" class="indexterm"/> is an electrical component that is able to break an electrical circuit. There are a lot of different types of switches.</p><div class="section" title="Different types of switches"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec58"/>Different types of switches</h3></div></div></div><p>Some switches<a id="id543" class="indexterm"/> are called <span class="strong"><strong>toggles</strong></span>. Toggles are also named continuous switches. In order to act on the circuit, the toggle can be pushed and released each time you want to act and when you release it, the action continues.</p><p>Some others are called <a id="id544" class="indexterm"/>
<span class="strong"><strong>momentaries</strong></span>. Momentaries are named <span class="strong"><strong>push for action</strong></span> too. In order to act on the circuit, you have to push and keep the switch pushed to continue the action. If you release it, the action stops.</p><p>Usually, all our switches at home are <a id="id545" class="indexterm"/>toggles. Except the one for the mixer that you have to push to cut and release to stop it, which means it is a momentary.</p></div></div><div class="section" title="A basic circuit"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec81"/>A basic circuit</h2></div></div></div><p>Here is a <a id="id546" class="indexterm"/>basic circuit with an Arduino, a momentary switch and a resistor.</p><p>We want to turn the board's built-in LED ON when we push the momentary switch and turn it OFF when we release it.</p><div class="mediaobject"><img src="graphics/7584_05_12.jpg" alt="A basic circuit"/><div class="caption"><p>A small circuit</p></div></div><p>I'm presenting you with the circuit on which we are going to work right now. This is also a nice pretext to make you more familiar with circuit diagrams.</p><div class="section" title="Wires"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec59"/>Wires</h3></div></div></div><p>Each line represents<a id="id547" class="indexterm"/> a link between two components. By definition, a line is a wire and there is no electrical potential from one side to the other. It can also be defined as follows: a wire has a resistance of 0 ohm. Then we can say that two points linked by a wire have the same electrical potential.</p></div><div class="section" title="The circuit in the real world"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec60"/>The circuit in the real world</h3></div></div></div><p>Of course, I didn't <a id="id548" class="indexterm"/>want to show you the next diagram directly. Now we have to build the real circuit, so please take some wires, your breadboard, and the momentary switch, and wire the whole circuit as shown in the next diagram.</p><p>You can take a resistor around 10 Kohms. We'll explain the purpose of the resistor in the next pages.</p><div class="mediaobject"><img src="graphics/7584_05_014.jpg" alt="The circuit in the real world"/><div class="caption"><p>The momentary switch in a real circuit</p></div></div><p>Let's explain things a bit more.</p><p>Let's<a id="id549" class="indexterm"/> remember the breadboard wiring; I'm using cold and hot rails at the top of the breadboard (cold is blue and means ground, hot is red and means +5 V). After I have wired the ground and +5 V from the Arduino to the rails, I'm using rails to wire the other parts of the board; it is easier and requires shorter cables.</p><p>There is a resistor between the ground and the digital pin 2. There is a momentary switch between the +5 V line and the pin 2 as well. The pin 2 will be set up as an input, which means it will be able to sink current.</p><p>Usually, switches are <span class="emphasis"><em>push-to-on</em></span>. Pushing them closes the circuit and lets the current flow. So, in that case, if I don't push the switch, there is no current from +5 V to the pin 2.</p><p>For the duration it is pressed, the circuit is closed. Then, current flows from the +5 V to the pin 2. It is a bit metaphoric and abusive, and I should say we have created an electrical potential between +5 V and the pin 2, but I need to be shorter to hit the point home.</p><p>And this resistor, why is it here?</p></div></div><div class="section" title="The pull-up and pull-down concept"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec82"/>The pull-up and pull-down concept</h2></div></div></div><p>If the global circuit is <a id="id550" class="indexterm"/>easy, the <a id="id551" class="indexterm"/>resistor part can be a bit tricky at first sight.</p><p>A digital pin<a id="id552" class="indexterm"/> set up as an input provides the ability to <span class="emphasis"><em>sink</em></span> current. This means it behaves like the ground. Indeed, and in fact, internally, it works exactly as if the concerned pin was connected to the ground.</p><p>With a properly coded firmware, we would have the ability to check pin 2. This means we could test it and read the value of the electrical potential. Because it is a digital input, an electrical potential near +5 V would be translated as the value HIGH, and if it is near 0 V, it will be translated as the value LOW. Both values are constants defined inside the Arduino core. But if everything seems totally perfect in a perfect digital world, it is not true.</p><p>Indeed, the input signal noise could potentially be read as a button press.</p><p>To be sure and safe, we use what we call a <span class="emphasis"><em>pull-down resistor</em></span>. This is usually a high impedance resistance that provides a current sink to the digital pin considered, making it safer at the value 0 V if the switch is not pressed. Pull down to be more consistently recognized as a LOW value, pull up to be more consistently recognized as the HIGH value.</p><p>Of course, the global energy consumption increases a bit. In our case, this is not important here but you have to know that. On this same concept, a pull-up resistor can be used to link the +5 V to the digital output. Generally, you should know that a chipset's I/O shouldn't be floating.</p><p>Here is what you have to remember:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Type of Digital Pin</p>
</th><th style="text-align: left" valign="bottom">
<p>Input</p>
</th><th style="text-align: left" valign="bottom">
<p>Output</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Pull Resistor</p>
</td><td style="text-align: left" valign="top">
<p>Pull-down resistor</p>
</td><td style="text-align: left" valign="top">
<p>Pull-up resistor</p>
</td></tr></tbody></table></div><p>We want to push<a id="id553" class="indexterm"/> a switch, and particularly, this action has to turn the LED ON. We are going to write a pseudocode first.</p><div class="section" title="The pseudocode"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec61"/>The pseudocode</h3></div></div></div><p>Here is a possible <a id="id554" class="indexterm"/>pseudocode. Following are the steps we want our firmware to follow:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the pins.</li><li class="listitem">Define a variable for the current switch state.</li><li class="listitem">Set up the LED pin as an output.</li><li class="listitem">Set up the switch pin as an input.</li><li class="listitem">Set up an<a id="id555" class="indexterm"/> infinite loop. In the infinite loop do the following:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Read the input state and store it.</li><li class="listitem">If the input state is HIGH, turn the LED ON.</li><li class="listitem">Else turn the LED OFF.</li></ol></div></li></ol></div></div><div class="section" title="The code"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec62"/>The code</h3></div></div></div><p>Here is a <a id="id556" class="indexterm"/>translation of this pseudocode in valid C code:</p><div class="informalexample"><pre class="programlisting">const int switchPin = 2;     // pin of the digital input related to the switch
const int ledPin =  13;      // pin of the board built-in LED

int switchState = 0;         // storage variable for current switch state

void setup() {
  pinMode(ledPin, OUTPUT);   // the led pin is setup as an output
  pinMode(switchPin, INPUT); // the switch pin is setup as an input
}

void loop(){
  switchState = digitalRead(switchPin);  // read the state of the digital pin 2

  if (switchState == HIGH) {     // test if the switch is pushed or not

    digitalWrite(ledPin, HIGH);  // turn the LED ON if it is currently pushed
  }
  else {
    digitalWrite(ledPin, LOW);   // turn the LED OFF if it is currently pushed
  }
}</pre></div><p>As usual you can also find the code in the <code class="literal">Chapter05/MonoSwitch/</code> folder available for download along with other code files on Packt Publishing's site.</p><p>Upload it and see what happens. You should have a nice system on which you can push a switch and turn on an LED. Splendid!</p><p>Now let's <a id="id557" class="indexterm"/>make the Arduino board and Processing communicate with each other.</p></div></div><div class="section" title="Making Arduino and Processing talk"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec83"/>Making Arduino and Processing talk</h2></div></div></div><p>Let's say we want to visualize our switch's manipulations on the computer.</p><p>We have to define a small <a id="id558" class="indexterm"/>communication protocol between Arduino and Processing. Of course, we'll use a serial communication protocol because it is quite easy to set it up and it is light.</p><p>We could design a<a id="id559" class="indexterm"/> protocol as a library of communication. We only design a protocol using the native Arduino core at the moment. Then, later in this book, we will design a library.</p><div class="section" title="The communication protocol"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec63"/>The communication protocol</h3></div></div></div><p>A <a id="id560" class="indexterm"/>communication protocol is a system of rules and formats designed for exchanging messages between two entities. Those entities can be humans, computers and maybe more.</p><p>Indeed, I'd use a basic analogy with our language. In order to understand each other, we have to follow some rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Syntactic and grammatical rules (I have to use words that you know)</li><li class="listitem" style="list-style-type: disc">Physical rules (I have to talk loud enough)</li><li class="listitem" style="list-style-type: disc">Social rules (I shouldn't insult you just before asking you for the time)</li></ul></div><p>I could quote many other rules like the speed of talking, the distance between the two entities, and so on. If each rule is agreed upon and verified, we can talk together. Before designing a protocol, we have to define our requirements.</p><div class="section" title="Protocol requirements"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec24"/>Protocol requirements</h4></div></div></div><p>What do we want to do?</p><p>We need a <a id="id561" class="indexterm"/>communication protocol between our Arduino and Processing inside the computer. Right! These requirements are usually the same for a lot of communication protocols you'll design.</p><p>Here is a short list of very important ones:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The protocol must be expandable without having to rewrite everything each time I want to add new message types</li><li class="listitem" style="list-style-type: disc">The protocol <a id="id562" class="indexterm"/>must be able to send enough data quite quickly</li><li class="listitem" style="list-style-type: disc">The protocol must be easy to understand and well commented, especially for open source and collaborative projects</li></ul></div></div><div class="section" title="Protocol design"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec25"/>Protocol design</h4></div></div></div><p>Each message <a id="id563" class="indexterm"/>will be 2 bytes in size. This is a common data packet size and I propose to organize data like this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Byte 1</strong></span>: switch number</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Byte 2</strong></span>: switch state</li></ul></div><p>The fact that I defined byte 1 as a representation of the switch number is typically because of the requirement of expandability. With one switch, the number will be 0.</p><p>I can easily instantiate serial communication between the board and the computer. Indeed, we already made that when we used Serial Monitoring at least on the Arduino side.</p><p>How can we do that using Processing?</p></div></div><div class="section" title="The Processing code"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec64"/>The Processing code</h3></div></div></div><p>Processing <a id="id564" class="indexterm"/>comes with very useful set of libraries already integrated into its core. Specifically, we are going to use the serial library.</p><p>Let's sketch a pseudocode first, as usual.</p><div class="section" title="Sketching a pseudocode"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec26"/>Sketching a pseudocode</h4></div></div></div><p>What do we <a id="id565" class="indexterm"/>want the program to do?</p><p>I propose to have a big circle. Its color will represent the switch's state. <span class="emphasis"><em>Dark</em></span> will mean released, and <span class="emphasis"><em>green</em></span> will mean pushed.</p><p>The pseudocode can be created as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define and instantiate the serial port.</li><li class="listitem">Define a current drawing color to dark.</li><li class="listitem">In the infinite loop, do the following:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Check if the serial port and grab data have been received.</li><li class="listitem">If data indicates that state is off, change current drawing from color to dark.</li><li class="listitem">Else, change current drawing color to green.</li><li class="listitem">Draw<a id="id566" class="indexterm"/> the circle with the current drawing color.</li></ol></div></li></ol></div></div><div class="section" title="Let's write that code"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec27"/>Let's write that code</h4></div></div></div><p>Let's open a new <a id="id567" class="indexterm"/>processing canvas. </p><p>Because the Processing IDE works like the Arduino IDE and needs to create all saved project files in a folder, I'd suggest that you directly save the canvas, even empty, in the right place on your disk. Call it <code class="literal">processingOneButtonDisplay</code>.</p><p>You can find the code in the <code class="literal">Chapter05/processingOneButtonDisplay/</code> folder available for download along with other code files on Packt's site.</p><div class="mediaobject"><img src="graphics/7584_05_015.jpg" alt="Let's write that code"/><div class="caption"><p>Making a library inclusion in your code</p></div></div><p>To include the serial library from the Processing core, you can go to <span class="strong"><strong>Sketch | Import Library… | serial</strong></span>. It adds this row to your code: <code class="literal">processing.serial.*;</code>
</p><p>You could <a id="id568" class="indexterm"/>also type this statement by yourself.</p><p>Following is the code, with a lot of comments:</p><div class="informalexample"><pre class="programlisting">import processing.serial.*;

Serial theSerialPort;            // create the serial port object
int[] serialBytesArray = new int[2];  // array storing current message
int switchState;                 // current switch state
int switchID;                    // index of the switch
int bytesCount = 0;              // current number of bytes relative to messages
boolean init = false;            // init state
int fillColor = 40;              // defining the initial fill color

void setup(){
  
  // define some canvas and drawing parameters
  size(500,500);
  background(70);
  noStroke();
  
  // printing the list of all serial devices (debug purpose)
  println(Serial.list());
  
  // On osx, the Arduino port is the first into the list
  String thePortName = Serial.list()[0];
  
  // Instantate the Serial Communication
  theSerialPort = new Serial(this, thePortName, 9600);
}

void draw(){
  
  // set the fill color
  fill(fillColor);
  
  // draw a circle in the middle of the screen
  ellipse(width/2, height/2, 230, 230);
}


void serialEvent(Serial myPort) {
  
  // read a byte from the serial port
  int inByte = myPort.read();
  
  if (init == false) {         // if there wasn't the first hello
    if (inByte == 'Z') {       // if the byte read is Z
      myPort.clear();          // clear the serial port buffer
      init = true;             // store the fact we had the first hello
      myPort.write('Z');       // tell the Arduino to send more !
    } 
  } 
  else {                       // if there already was the first hello
  
    // Add the latest byte from the serial port to array
    serialBytesArray[bytesCount] = inByte;
    bytesCount++;

    // if the messages is 2 bytes length
    if (bytesCount &gt; 1 ) {
      switchID = serialBytesArray[0]; // store the ID of the switch
      switchState = serialBytesArray[1]; // store the state of the switch
 
      // print the values (for debugging purposes):
      println(switchID + "\t" + switchState);

      // alter the fill color according to the message received from Arduino
      if (switchState == 0) fillColor = 40;
      else fillColor = 255;
      
      
      // Send a capital Z to request new sensor readings
      myPort.write('Z');
      
      // Reset bytesCount:
      bytesCount = 0;
    }
  }
}</pre></div></div><div class="section" title="Variable definitions"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec28"/>Variable definitions</h4></div></div></div><p>
<code class="literal">theSerialPort</code> is <a id="id569" class="indexterm"/>an object<a id="id570" class="indexterm"/> of the <code class="literal">Serial</code> library. I have to create it first.</p><p>
<code class="literal">serialBytesArray</code> is<a id="id571" class="indexterm"/> an <a id="id572" class="indexterm"/>array of two integers used to store messages coming from Arduino. Do you remember? When we designed the protocol, we talked about 2 byte messages.</p><p>
<code class="literal">switchState</code> <a id="id573" class="indexterm"/>and <code class="literal">switchID</code> <a id="id574" class="indexterm"/>are global but temporary variables used to store the switch state and the switch ID corresponding to the message coming from the board. Switch ID has been put there for (close) future implementation to distinguish the different switches in case we use more than one.</p><p>
<code class="literal">bytesCount</code> is a<a id="id575" class="indexterm"/> useful variable tracking the current position in our message reading.</p><p>
<code class="literal">init</code> is <a id="id576" class="indexterm"/>defined to <code class="literal">false</code> at the beginning and becomes <code class="literal">true</code> when the first byte from the Arduino (and a special one, <code class="literal">Z</code>) has been received for the first time. It is a kind of first-contact purpose.</p><p>Then, we keep a trace of the fill color and the initial one is <code class="literal">40</code>. <code class="literal">40</code> is only an integer and will be used a bit further as an argument of the function <code class="literal">fill()</code>.</p></div><div class="section" title="setup()"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec29"/>setup()</h4></div></div></div><p>We define the <a id="id577" class="indexterm"/>canvas (size, background color, and no stroke).</p><p>We print a list of all the <a id="id578" class="indexterm"/>serial ports available on your computer. This is debug information for the next statement where we store the name of the first serial port into a String. Indeed, you could be led to change the array element from 0 to the correct one according to the position of your Arduino's port in the printed list.</p><p>This String is then used in the very important statement that instantiates serial communication at 9600 bauds.</p><p>This <code class="literal">setup()</code> function, of course, runs only once.</p></div><div class="section" title="draw()"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec30"/>draw()</h4></div></div></div><p>The <a id="id579" class="indexterm"/>draw<a id="id580" class="indexterm"/> function is very light here.</p><p>We pass the variable <code class="literal">fillColor</code> <a id="id581" class="indexterm"/>to the<a id="id582" class="indexterm"/> <code class="literal">fill()</code> function, setting up the color with which all further shapes will be filled.</p><p>Then, we draw the circle with the ellipse function. This function takes four arguments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">x coordinates of the center of the ellipse (here <code class="literal">width/2</code>)</li><li class="listitem" style="list-style-type: disc">y coordinates of the center of the ellipse (here <code class="literal">height/2</code>)</li><li class="listitem" style="list-style-type: disc">Width of the ellipse (here <code class="literal">230</code>)</li><li class="listitem" style="list-style-type: disc">Height of the ellipse (here <code class="literal">230</code>)</li></ul></div><p>
<code class="literal">width</code> and <code class="literal">height</code> colored in blue in the Processing IDE are the current width and height of the canvas. It is very useful to use them because if you change the <code class="literal">setup()</code> statement by choosing a new size for the canvas, all <code class="literal">width</code> and <code class="literal">height</code> in your code will be updated <a id="id583" class="indexterm"/>automatically<a id="id584" class="indexterm"/> without needing to change them all manually.</p><p>Please keep in mind that an ellipse with same values for <code class="literal">width</code> and <code class="literal">height</code> is a circle (!). Ok. But where is the magic here? It will only draw a circle, every time the same one (size and position). <code class="literal">fillColor</code> is the only variable of the <code class="literal">draw()</code> function. Let's see that strange callback named <code class="literal">serialEvent()</code>.</p></div><div class="section" title="The serialEvent() callback"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec31"/>The serialEvent() callback</h4></div></div></div><p>We talked about<a id="id585" class="indexterm"/> callbacks in <a class="link" href="ch04.html" title="Chapter 4. Improve Programming with Functions, Math, and Timing">Chapter 4</a>, <span class="emphasis"><em>Improve Programming with Functions, Math, and Timing</em></span>.</p><p>Here, we have a pure<a id="id586" class="indexterm"/> callback method in Processing. This is an event-driven callback. It is useful and efficient not to have to poll every time our serial port wants to know if there is something to read. Indeed, user interfaces related events are totally less numerous than the number of Arduino board's processor cycles. It is smarter to implement a callback in that case; as soon as a serial event occurs (that is, a message is received), we execute a series of statements.</p><p>
<code class="literal">myPort.read()</code> will first read the bytes received. Then we make the test with the <code class="literal">init</code> variable. Indeed, if this is the very first message, we want to check if the communication has already begun.</p><p>In the case where it is the first hello (<code class="literal">init == false</code>), if the message coming from the Arduino Board is <code class="literal">Z</code>, Processing program clear its own serial port, stores the fact the communication has just started, and resends back <code class="literal">Z</code> to the Arduino board. It is not so tricky.</p><p>It can be illustrated as follows:</p><p>Imagine we can begin to talk only if we begin by saying "hello" to each other. We aren't watching each other (no event). Then I begin to talk. You turn your head to me (serial event occurs) and listen. Am I saying "hello" to you? (whether the message is <code class="literal">Z</code>?). If I'm not, you just turn your head back (no <code class="literal">else</code> statement). If I am, you answer "hello" (sending back <code class="literal">Z</code>) and the communication begins.</p><p>What happens then?</p><p>If communication has already begun, we have to store bytes read into the <code class="literal">serialBytesArray</code> and increment the <code class="literal">bytesCount</code>. While bytes are being received and <code class="literal">bytesCount</code> is smaller or equal to 1, this means we don't have a complete message (a complete message is two bytes) and we store more bytes in the array.</p><p>As soon as the bytes count equals <code class="literal">2</code>, we have a complete message and we can "split" it into the variables <code class="literal">switchID</code> and <code class="literal">switchState</code>. Here's how we do that:</p><div class="informalexample"><pre class="programlisting">switchID = serialBytesArray[0]; 
switchState = serialBytesArray[1];</pre></div><p>This <a id="id587" class="indexterm"/>next statement is a debug one: we print each variable. Then, the core of the method is the test of the <code class="literal">switchState</code> variable. If it is <code class="literal">0</code>, it means the switch is released, and we modify the <code class="literal">fillColor</code> to <code class="literal">40</code> (dark color, <code class="literal">40</code> means the value 40 for each<a id="id588" class="indexterm"/> RGB component; check <code class="literal">color()</code> method in Processing reference at <a class="ulink" href="http://processing.org/reference/color_.html">http://processing.org/reference/color_.html</a>). If it isn't <code class="literal">0</code>, we modify the <code class="literal">fillColor</code> to <code class="literal">255</code>, which means white. We could be a bit safer by not using only <code class="literal">else</code>, but <code class="literal">else if (switchState ==1)</code> also.</p><p>Why? Because if we are not sure about all the messages that can be sent (lack of documentation or whatever else making us unsure), we can modify the color to white <span class="emphasis"><em>only</em></span> if <code class="literal">switchState</code> equals <code class="literal">1</code>. This concept can be done at the optimization state too, but here, it is quite light so we can leave it like that.</p><p>Ok. It is a nice, heavy piece, right? Now, let's see how we have to modify the Arduino code. Do you remember? It isn't communication ready yet.</p></div></div><div class="section" title="The new Arduino firmware talk-ready"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec65"/>The new Arduino firmware talk-ready</h3></div></div></div><p>Because we now have <a id="id589" class="indexterm"/>a nice way to display our switch state, I'll remove all things related to the built-in LED of the board and following is the result:</p><div class="informalexample"><pre class="programlisting">const int switchPin = 2;     // pin of the digital input related to the switch
int switchState = 0;         // storage variable for current switch state

void setup() {
  pinMode(switchPin, INPUT); // the switch pin is setup as an input
}

void loop(){
    switchState = digitalRead(switchPin); 
}</pre></div><p>What do we have to add? All the <code class="literal">Serial</code> stuff. I also want to add a small function dedicated to the first "hello".</p><p>Here is the result, then we will see the explanations:</p><div class="informalexample"><pre class="programlisting">const int switchPin = 2;     // pin of the digital input related to the switch
int switchState = 0;         // storage variable for current switch state
int inByte = 0;

void setup() {
  Serial.begin(9600);
  pinMode(switchPin, INPUT); // the switch pin is setup as an input
  sayHello();
}

void loop(){

  // if a valid byte is received from processing, read the digital in.
  if (Serial.available() &gt; 0) {
    // get incoming byte:
    inByte = Serial.read();
    switchState = digitalRead(switchPin); 

    // send switch state to Arduino
    Serial.write("0");
    Serial.write(switchState);
  }
}

void sayHello() {
  while (Serial.available() &lt;= 0) {
    Serial.print('Z');   // send a capital Z to Arduino to say "HELLO!"
    delay(200);
  }
}</pre></div><p>I'm defining <a id="id590" class="indexterm"/>one new variable first: <code class="literal">inByte</code>. This stores the bytes read. Then inside the <code class="literal">setup()</code> method, I'm instantiating serial communication as we already learned to do with Arduino. I'm setting up the <code class="literal">pinMode</code> method of the switch pin then, I'm calling <code class="literal">sayHello()</code>.</p><p>This function just waits for something. Please focus on this.</p><p>I'm calling this function in <code class="literal">setup()</code>. This is a <span class="emphasis"><em>simple</em></span> call, not a callback or whatever else. This function contains a <code class="literal">while</code> loop while <code class="literal">Serial.available()</code> is smaller or equal to zero. What does this mean? It means this function pauses the <code class="literal">setup()</code> method while the first byte comes to the serial port of the Arduino board. The <code class="literal">loop()</code> done doesn't run while the <code class="literal">setup()</code> done has finished, so this is a nice trick to wait for the first external event; in this case, the first communication. Indeed, the board is sending the message <code class="literal">Z</code> (that is, the "hello") while Processing doesn't answer.</p><p>The<a id="id591" class="indexterm"/> consequence is that when you can plug in your board, it sends <code class="literal">Z</code> continuously while you run your Processing program. Then the communication begins and you can push the switch and see what is happening. Indeed, as soon as the communication begins, <code class="literal">loop()</code> begins its infinite loop. At first a test is made at each cycle and we only test if a byte is being received. Whatever the byte received (Processing only sends <code class="literal">Z</code> to the board), we read the digital pin of the switch and send back two bytes. Here too, pay attention please: each byte is written to the serial port using <code class="literal">Serial.write()</code>. You have to send 2 bytes, so you stack two <code class="literal">Serial.write()</code>. The first byte is the number (ID) of the switch that is pushed/released; here, it is not a variable because we have one and only one switch, so it is an integer 0. The second byte is the switch state. We just saw here a nice design pattern involving the board, an external program running on a computer and a communication between both of them.</p><p>Now, let's go further and play with more than one switch.</p></div></div></div>
<div class="section" title="Playing with multiple buttons"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Playing with multiple buttons</h1></div></div></div><p>We can <a id="id592" class="indexterm"/>extrapolate our previously designed logic with more than one switch.</p><p>There are many ways to use multiple switches, and, in general, multiple inputs on the Arduino. We're going to see a cheap and easy first way right now. This way doesn't involve multiplexing a lot of inputs on only a couple of Arduino inputs but a basic one to one wiring where each switch is wired to one input. We'll learn multiplexing a bit later (in the next chapter).</p><div class="section" title="The circuit"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec84"/>The circuit</h2></div></div></div><p>Following is the <a id="id593" class="indexterm"/>circuit diagram required to work with multiple switches:</p><div class="mediaobject"><img src="graphics/7584_05_16.jpg" alt="The circuit"/><div class="caption"><p>Wiring three momentary switches to the Arduino board</p></div></div><p>The schematic is an extrapolation of the previous one that showed only one switch. We can see the three switches between the +5 V and the three pull-down resistors. Then we can also see the three wires going to digital inputs 2 to 4 again.</p><p>Here is a small memory refresh: Why didn't I use the digital pins 0 or 1?</p><p>Because I'm<a id="id594" class="indexterm"/> using serial communication from the Arduino, we cannot use the digital pins 0 and 1 (each one respectively corresponding to RX and TX used in serial communication). Even if we are using the USB link as the physical support for our serial messages, the Arduino board is designed like that and we have to be very careful with it.</p><p>Here is the circuit view with the breadboard. I voluntarily didn't align every wire. Why? Don't you remember that I want you to be totally autonomous after reading this book and yes, you'll find many schematics in the real world made sometimes like that. You have to become familiar with them too. It could be an (easy) homework assignment.</p><div class="mediaobject"><img src="graphics/7584_05_017.jpg" alt="The circuit"/></div><p>The<a id="id595" class="indexterm"/> preceding circuit shows the three switches, the three pull-down resistors, and the Arduino board.</p><p>Both source codes have to be modified to provide a support for the new circuit.</p><p>Let's add things there.</p></div><div class="section" title="The Arduino code"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec85"/>The Arduino code</h2></div></div></div><p>Here is the <a id="id596" class="indexterm"/>new code; of course, you can find it in the <code class="literal">Chapter05/MultipleSwitchesWithProcessing/</code> folder available for download along with other code files on Packt's site:</p><div class="informalexample"><pre class="programlisting">#define switchesNumber 3             // define the number of switches as a constant

int switchesStates[switchesNumber] ; // array storing current switches states
int inByte = 0;

void setup() {
  Serial.begin(9600);

  // initiating each pins as input and filling switchesStates with zeroes
  for(int i = 0 ; i &lt; switchesNumber ; i++)
  {
// BE CAREFUL TO THAT INDEX
pinMode(i + 2, INPUT); // the switch pin is setup as an input

    switchesStates[i] = 0 ;
  }

  sayHello(); // waiting for the processing program hello answer
}

void loop(){

  // if a valid byte is received from processing, read all digital inputs.
  if (Serial.available() &gt; 0) {

    // get incoming byte
    inByte = Serial.read();

    for(int i = 0 ; i &lt; switchesNumber ; i++)
    {
      switchesStates[i] = digitalRead(i+2); // BE CAREFUL TO THAT INDEX
   // WE ARE STARTING FROM PIN 2 !
      Serial.write(i);                 // 1st byte = switch number (0 to 2)
      Serial.write(switchesStates[i]); // 2nd byte = the switch i state
    }
  }
}

void sayHello() {
  while (Serial.available() &lt;= 0) {
    Serial.print('Z');   // send a capital Z to Arduino to say "HELLO!"
    delay(200);
  }
}</pre></div><p>Let's explain this code.</p><p>At first, I <a id="id597" class="indexterm"/>defined a constant <code class="literal">switchesNumber</code> to the number <code class="literal">3</code>. This number can be changed to any other number from <code class="literal">1</code> to <code class="literal">12</code>. This number represents the current number of switches wired to the board from digital pin 2 to digital pin 14. All switches have to be linked without an empty pin between them.</p><p>Then, I defined an array to store the switch's states. I declared it using the <code class="literal">switchesNumber</code> constant as the length. I have to fill this array with zeroes in the <code class="literal">setup()</code> method, that I made with a <code class="literal">for</code> loop. It provides a safe way to be sure that all switches have a release state in the code.</p><p>I still use the <code class="literal">sayHello()</code> function, to set up the communication start with Processing.</p><p>Indeed, I have to fill each switch state in the array <code class="literal">switchesStates</code> so I added the <code class="literal">for</code> loop. Please notice the index trick in each <code class="literal">for</code> loop. Indeed, because it seems to be more convenient to start from 0 and because in the real world we mustn't use digital pins 0 and 1 while using serial communications, I added <code class="literal">2</code> as soon as I dealt with the real number of the digital pin, that is, with the two functions <code class="literal">pinMode()</code> and <code class="literal">digitalRead()</code>.</p><p>Now, let's upgrade the Processing code too.</p></div><div class="section" title="The Processing code"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec86"/>The Processing code</h2></div></div></div><p>Here is the<a id="id598" class="indexterm"/> new code; you can find it in the <code class="literal">Chapter05/MultipleSwitchesWithProcessing/</code> folder available for download along with other code files on Packt's site:</p><div class="informalexample"><pre class="programlisting">import processing.serial.*;

int switchesNumber = 2;

Serial theSerialPort;                 // create the serial port object
int[] serialBytesArray = new int[2];  // array storing current message
int switchID;                         // index of the switch
int[] switchesStates = new int[switchesNumber]; // current switch state
int bytesCount = 0; // current number of bytes relative to messages
boolean init = false;                 // init state
int fillColor = 40;                   // defining the initial fill color

// circles display stuff
int distanceCircles ;
int radii;

void setup() {

  // define some canvas and drawing parameters
  size(500, 500);
  background(70);
  noStroke();
  distanceCircles = width / switchesNumber;
  radii = distanceCircles/2;

  // printing the list of all serial devices (debug purpose)
  println(Serial.list());

  // On osx, the Arduino port is the first into the list
  String thePortName = Serial.list()[0];

  // Instantate the Serial Communication
  theSerialPort = new Serial(this, thePortName, 9600);

  for (int i = 0 ; i &lt; switchesNumber ; i++)
  {
    switchesStates[i] = 0;
  }
}

void draw() {

  for (int i = 0 ; i &lt; switchesNumber ; i++)
  {
    if (switchesStates[i] == 0) fill(0);
    else fill(255);

    // draw a circle in the middle of the screen
    ellipse(distanceCircles * (i + 1) - radii, height/2, radii, radii);
  }
}


void serialEvent(Serial myPort) {

  // read a byte from the serial port
  int inByte = myPort.read();

  if (init == false) {         // if this is the first hello
    if (inByte == 'Z') {       // if the byte read is Z
      myPort.clear();          // clear the serial port buffer
      init = true;             // store the fact we had the first hello
      myPort.write('Z');       // tell the Arduino to send more !
    }
  }
  else {                       // if there already was the first hello

    // Add the latest byte from the serial port to array
    serialBytesArray[bytesCount] = inByte;
    bytesCount++;

    // if the messages is 2 bytes length
    if (bytesCount &gt; 1 ) {
      switchID = serialBytesArray[0];      // store the ID of the switch
      switchesStates[switchID] = serialBytesArray[1]; // store state of the switch

      // print the values (for debugging purposes):
      println(switchID + "\t" + switchesStates[switchID]);
      // Send a capital Z to request new sensor readings
      myPort.write('Z');

      // Reset bytesCount:
      bytesCount = 0;
    }
  }
}</pre></div><p>Following is <a id="id599" class="indexterm"/>a screenshot of the render of this code used with five switches while I was pushing on the fourth button:</p><div class="mediaobject"><img src="graphics/7584_05_020.jpg" alt="The Processing code"/></div><p>So, what did I alter?</p><p>Following<a id="id600" class="indexterm"/> the same concept as with the Arduino code, I added a variable (not a constant here), named <code class="literal">switchesNumber</code>. A nice evolution could be to add something to the protocol about the number of the switch. For instance, the Arduino board could inform Processing about the switch's number according to only one constant defined in the Arduino firmware. This would save the manual update of the processing code when we change this number.</p><p>I also transformed the variable <code class="literal">switchState</code> into an array of integers <code class="literal">switchesStates</code>. This one stores all the switches' states. I added two variables related to the display: <code class="literal">distanceCircles</code> and <code class="literal">radii</code>. Those are used for dynamically displaying the position of circles according to the number of switches. Indeed, we want one circle per switch.</p><p>The <code class="literal">setup()</code> function is almost the same as before.</p><p>I'm calculating here the distance between two circles by dividing the width of the canvas by the number of circles. Then, I'm calculating the radii of each circle by using the distance between them divided by 2. These numbers can be changed. You could have a very different aesthetical choice.</p><p>Then the big difference here is also the <code class="literal">for</code> loop. I'm filling the whole <code class="literal">switchesStates</code> array with zeroes to initialize it. At the beginning, none of the switches are pushed. The <code class="literal">draw()</code> function now also includes a <code class="literal">for</code> loop. Pay attention here. I removed the <code class="literal">fillColor</code> method because I moved the fill color choice to the draw. This is an alternative, showing you the flexibility of the code.</p><p>In the same for loop, I'm drawing the circle number <span class="emphasis"><em>i</em></span>. I will let you check for yourself how I have placed the circles. The <code class="literal">serialEvent()</code> method doesn't change a lot either. I removed the fill color change as I wrote before. I also used the <code class="literal">switchesStates</code> array, and the index provided by the first byte of the message that I stored in <code class="literal">switchID</code>.</p><p>Now, you <a id="id601" class="indexterm"/>can run the code on each side after you have uploaded the firmware on the Arduino board.</p><p>Magic? I guess you now know that it isn't magic at all, but beautiful, maybe.</p><p>Let's go a bit further talking about something important about switches, but also related to other switches.</p></div></div>
<div class="section" title="Understanding the debounce concept"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Understanding the debounce concept</h1></div></div></div><p>Now here is a small section that is<a id="id602" class="indexterm"/> quite cool and light compared to analog inputs, which we will dive into in the next chapter.</p><p>We are going to talk about something that happens when someone pushes a button.</p><div class="section" title="What? Who is bouncing?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec87"/>What? Who is bouncing?</h2></div></div></div><p>Now, we have to take our microscopic biocybernetic eyes to zoom into the switch's structure.</p><p>A switch is made with pieces of metal and plastic. When you push the cap, a piece of metal moves and comes into contact with another piece of metal, closing the circuit. Microscopically and during a very small time interval, things aren't that clean. Indeed, the moving piece of metal bounces against the other part. With an oscilloscope measuring the electrical potential at the digital pin of the Arduino, we can see some noise in the voltage curve around 1 ms after the push.</p><p>These oscillations could generate incorrect inputs in some programs. Imagine, that you want to count the states transitions in order, for instance, to run something when the user pushed the switch seven times. If you have a bouncing system, by pushing only once, the program could count a lot of transitions even if the user pushed the switch only once.</p><p>Check the next graph. It represents the voltage in relation to time. The small arrows on the time axis show the<a id="id603" class="indexterm"/> moment when the switch has been pushed:</p><div class="mediaobject"><img src="graphics/7584_05_18.jpg" alt="What? Who is bouncing?"/></div><p>How can we deal with these oscillations?</p></div><div class="section" title="How to debounce"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec88"/>How to debounce</h2></div></div></div><p>We have two distinct elements on which we can act:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The circuit itself</li><li class="listitem" style="list-style-type: disc">The firmware</li></ul></div><p>The circuit itself can be modified. I could quote some solutions such as adding diodes, capacitors, and some Schmitt trigger inverters. I won't explain that solution in detail because we are going to do that in software, but I can explain the global concept. The capacitor in that case will be charged and discharged while the switch will be bouncing, smoothing those peaks of noise. Of course, some tests are needed in order to find the perfect components fitting your precise needs.</p><p>The firmware can also be modified.</p><p>Basically, we <a id="id604" class="indexterm"/>can use a time-based filter, because the bounce occurs during a particular amount of time.</p><p>Following is<a id="id605" class="indexterm"/> the code, then will come explanations:</p><div class="informalexample"><pre class="programlisting">const int switchPin = 2;     // pin of the digital input related to the switch
const int ledPin =  13;      // pin of the board built-in LED

int switchState = 0;         // storage variable for current switch state
int lastSwitchState= LOW;

// variables related to the debouncing system
long lastDebounceTime = 0;
long debounceDelay = 50;

void setup() {
  pinMode(ledPin, OUTPUT);   // the led pin is setup as an output
  pinMode(switchPin, INPUT); // the switch pin is setup as an input
}

void loop(){

  // read the state of the digital pin
  int readInput = digitalRead(switchPin);
  
  // if freshly read state is different than the last debounced value
  if (readInput != lastSwitchState){
   // reset the debounce counter by storing the current uptime ms
   lastDebounceTime = millis();
  }
  
  // if the time since the last debounce is greater than the debounce delay
  if ( (millis() - lastDebounceTime) &gt; debounceDelay ){
   // store the value because it is a debounced one and we are safe
   switchState = readInput;
  }
  
  // store the last read state for the next loop comparison purpose
  lastSwitchState = readInput;

  // modify the LED state according to the switch state
  if (switchState == HIGH)
  {     // test if the switch is pushed or not

    digitalWrite(ledPin, HIGH);  // turn the LED ON if it is currently pushed
  }
  else
  {
    digitalWrite(ledPin, LOW);   // turn the LED OFF if it is currently pushed
  }
}</pre></div><p>Following is an example of the debouncing cycle.</p><p>At the beginning, I defined some variables:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">lastSwitchState</code>: This stores the last read state</li><li class="listitem" style="list-style-type: disc"><code class="literal">lastDebounceTime</code>: This stores the moment when the last debounce occurred</li><li class="listitem" style="list-style-type: disc"><code class="literal">debounceDelay</code>: This is the value during which nothing is taken as a safe value</li></ul></div><p>We are <a id="id606" class="indexterm"/>using <code class="literal">millis()</code> here in order to measure the time. We already talked about this time function in <a class="link" href="ch04.html" title="Chapter 4. Improve Programming with Functions, Math, and Timing">Chapter 4</a>, <span class="emphasis"><em>Improve Programming with Functions, Math, and Timing</em></span>.</p><p>Then, at each <code class="literal">loop()</code> cycle, I read the input but basically I don't store it in the <code class="literal">switchState</code> variable that is used to the test to turning ON or OFF the LED. Basically, I used to say that <code class="literal">switchState</code> is the official variable that I don't want to modify before the debounce process. Using other terms, I can say that I'm storing something in <code class="literal">switchState</code> only when I'm sure about the state, not before.</p><p>So I read the input at each cycle and I store it in <code class="literal">readInput</code>. I compare <code class="literal">readInput</code> to the <code class="literal">lastSwitchState</code> variable that is the last read value. If both variables are different, what does it mean? It means a change occurs, but it can be a bounce (unwanted event) or a real push. Anyway, in that case, we reset the counter by putting the current time provided by <code class="literal">millis()</code> to <code class="literal">lastDebounceTime</code>.</p><p>Then, we check if the time since the last debounce is greater than our delay. If it is, then we can consider the last <code class="literal">readInput</code> in this cycle as the real switch state and we can store it into the corresponding variable. In the other case, we store the last read value into <code class="literal">lastSwitchState</code> to keep it for the next cycle comparison.</p><p>This method is a general concept used to smooth inputs.</p><p>We can find here and there some examples of software debouncing used not only for switches but also for noisy inputs. In everything related to a user-driven event, I would advise using this kind of debouncer. But for everything related to system communication, debounce can be very useless and even a problem, because we can ignore some important messages and data. Why? Because a communication system is much faster than any user, and if we can use 50 ms as the time during which nothing is considered as a real push or a real release with users, we cannot do that for very fast chipset signals and other events that could occurs between systems themselves.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Summary</h1></div></div></div><p>We have learnt a bit more about digital inputs. Digital inputs can be used <span class="emphasis"><em>directly</em></span>, as we just did, or also <span class="emphasis"><em>indirectly</em></span>. I'm using this term because indeed, we can use other peripherals for encoding data before sending them to digital inputs. I used some distance sensors that worked like that, using digital inputs and not analog inputs. They encoded distance and popped it out using the I2C protocol. Some specific operations were required to extract and use the distance. In this way, we are making an indirect use of digital inputs.</p><p>Another nice way to sense the world is the use of analog inputs. Indeed, this opens a new world of continuous values. Let's move on.</p></div></body></html>