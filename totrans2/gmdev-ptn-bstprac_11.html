<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Understanding Graphics and Animation</h1>
            

            <article>
                
<p class="calibre2">Over the last 10Â chapters, we have dived deeply into some of the most popular design patterns. The goal of each chapter was to understand and solve some common problems that everyone encounters when creating games. Along the way, we have created component-based game objects with flexible State-based, decision-making capabilities. We have created core engines such as the <kbd class="calibre14">StageManager</kbd> and <kbd class="calibre14">ObjectManager</kbd> using the Singleton pattern, so that communication between game objects, components, and engines is incredibly simple. We also looked at Object Pools and the Flyweight pattern, which allow our game to use memory more efficiently.</p>
<p class="calibre2">In this chapter, we will focus on graphics. However, we will not be focusing on how to implement a graphics engine. That would require more than a single chapter. Instead we will focus on concepts that need to be understood, regardless of which graphics <strong class="calibre1">Application Programming Interface</strong> (<strong class="calibre1">API</strong>) you use.</p>
<p class="calibre2">Graphics is a large part of any game engine and is very likely the performance bottleneck of the game. However, whether we are using DirectX, OpenGL, or some other graphics API, we must understand what is happening behind the scenes. We shouldn't fall into the trap of thinking that just because we didn't write the graphics API, there are no design decisions to be made.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Chapter overview</h1>
            

            <article>
                
<p class="calibre2">This chapter is a little different than the ones before because it isn't focused on a design pattern. Instead we will focus on the low-level details of graphics so we can better understand how our code affects moving and animating our game objects.</p>
<p class="calibre2">First, we will look at how a computer monitor works. We will dive into the details of pixels and screen resolutions. We will look at how pixels are drawn on screen as well as understand the concept of tearing, learn why we hear so much about <strong class="calibre1">frames per second</strong> (<strong class="calibre1">fps</strong>), and why games try to achieve 30 or 60 frames per second.</p>
<p class="calibre2">Next, we will look at timing in games. We will learn why we want a consistent frame rate. We will also look at what happens when our frame rate isn't consistent and how we can ensure that our frame time stays consistent throughout the game.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Your objectives</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">Learn how computer monitors work and what a refresh rate is</li>
<li class="calibre18">Learn about double buffering and why it is used for graphics</li>
<li class="calibre18">Learn about time-based movement and animation, and why we want a consistent frame rate</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction to monitor refresh rates</h1>
            

            <article>
                
<p class="calibre2">These days, flat screen <strong class="calibre1">Liquid Crystal Display</strong> (<strong class="calibre1">LCD</strong>) monitors are very common. However, to understand refresh rates and double buffering, we need to understand how older monitors display an image. Along the way, we will learn about common graphics terms, such as pixels and screen resolution:</p>
<div class="packt_figure"><img class="image-border31" src="../images/00060.jpeg"/></div>
<div class="packt_figure1">Figure 11.1 - Simplified cathode ray tube diagram</div>
<p class="calibre2"><strong class="calibre1">Cathode Ray Tube</strong> (<strong class="calibre1">CRT</strong>) monitors contain screens with millions of tiny red, green, and blue phosphor dots. These dots glow for a short time when struck by an electron beam that travels across the screen to create an image. The <em class="calibre12">cathode</em> is a heated filament inside a vacuum sealed glass tube. The <em class="calibre12">ray</em> is a stream of electrons generated by an electron gun, which is directed by magnetic deflection plates. By adjusting the magnetic field of the plates, the electron beam can be moved around and adjusted to strike every part of the screen.</p>
<p class="calibre2">The screen is coated with phosphor, an organic material that glows for a short time when struck by the electrons. It contains many groups of red, green, and blue dots. By varying the intensity of the electron ray on each dot, different colors can be generated. For example, with red, green, and blue fired at maximum strength, the color white is produced.</p>
<p class="calibre2">Since one color is produced by a group of red, green, and blue dots, the maximum number of these dot groups limits how many colors can be displayed horizontally or vertically. The diagonal distance between two dots of the same color is known as the dot pitch.</p>
<div class="packt_figure"><img class="image-border32" src="../images/00061.jpeg"/></div>
<div class="packt_figure1">Figure 11.2 Close of view of the Pixel on the screen</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">What is a pixel?</h1>
            

            <article>
                
<p class="calibre2">A pixel, or <em class="calibre12">picture element</em>, is the basic unit of programmable color on a computer image or display. It is better to think about a pixel as a logical unit, rather than a physical unit. This is because the size of a pixel depends on the current resolution of the display screen. At the maximum resolution of the screen, one pixel maps exactly to one dot group. This means the size of a pixel at maximum resolution is equal to the dot pitch. Smaller resolutions will use more than one dot group to create a single color.</p>
<p class="calibre2">The resolution of the screen is the number of horizontal pixels multiplied by the number of vertical pixels, and is usually written as <strong class="calibre1">width x height</strong>. For example, a 640 x 480 resolution means that the screen is 640 pixels wide and 480 pixels high for a total of 307,200 pixels. Of course, the color data for each pixel must be stored in computer memory, so a higher resolution uses more pixels and more memory. For example, if each pixel used one byte of memory, our 640 x 480 display would need 300 kilobytes of memory. A 1280 x 1024 display would need 1.25 megabytes. Let's have a look at the following screenshot:</p>
<div class="packt_figure"><img class="image-border33" src="../images/00062.jpeg"/></div>
<div class="packt_figure1">Figure 11.3 - An example of 800 x 600 screen resolution</div>
<p class="calibre2">The location in RAM that stores pixel color information is called the <strong class="calibre1">framebuffer</strong>. The framebuffer is written by a program and then transmitted to the monitor. The cathode ray interprets the pixel color and fires the electron ray at the proper intensity. The deflection plates direct the electron beam to the proper dot groups on the phosphor screen.</p>
<p class="calibre2">In the examples above, the size of each pixel was only 1 byte. However, a pixel can be, and usually is, more than 1 byte. As computers get faster and memory gets cheaper, we can use more bits per pixel. With 8-bit color, red and green each use 3 bits or a total of 8 levels of color each, while blue only uses 2 bits or 4 levels. This totals 256 possible colors for each pixel.</p>
<p class="calibre2">16-bit color, or high color, offers a few different options. One possibility is 4 bits for each red, green, and blue. These 4 bits provide 16 levels for each color for a total of 4,096 (16 x 16 x 16) colors, with an optional 4 bits for transparency. Another possibility is 5 bits per color and 1 bit for transparency for a total of 32,768 colors. Finally, a total of 65,536 can be achieved with 5 bits for both red and blue, and 6 bits for green.</p>
<p class="calibre2">True color is defined at 8 bits per color. This means that red, green, and blue all have 8 bits, or 256 possible color levels. If 24 bits are used, we get a total of 16,777,216 possible colors. These days, 32 bits per pixel are often used. The last 8 bits are for transparency. The transparency allows for different levels of blending with the background colors. This allows for a total of 4,294,967,295 colors per pixel.</p>
<p class="calibre2">The size of the framebuffer is calculated by multiplying the resolution and the numbers of bytes per pixels (color depth). For a game using a 1280 x 1024 display, we need 1280 x 1024 x 4 bytes, or 5 megabytes for the framebuffer. This might not seem like much considering that modern computers often have 8 to 12 gigabytes of RAM. However, it is worth remembering that if we are updating every pixel on screen, we are updating 1,310,720 pixels, or 5,242,880 bytes of data. This is assuming we only fill in each color one time and don't need to blend with overlapping colors.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The horizontal and vertical blank</h1>
            

            <article>
                
<p class="calibre2">The display is updated by reading data from the framebuffer and updating in sequence, starting from the left to right and top to bottom. We can think about this exactly as if we were iterating through a 2D array in C or C++. At the end of each scan line, the electron gun is adjusted to point at the start of the next scan line. Another adjustment must be made after the last pixel is lit so the beam can start again at the top.</p>
<p class="calibre2">The time it takes for the electron gun to move from the rightmost pixel of scan line <em class="calibre12">X</em> to the leftmost pixel of scan line <em class="calibre12">X + 1</em> is called the <strong class="calibre1">Horizontal Blank Interval</strong>. This is because the electron gun is blanked, meaning that it is outputting zero electrons during this interval. This is to prevent pixels from being lit up while traveling from scan line to scan line. Similarly, the time it takes for the electron gun to move from the end of the last scan line back up to the first scan line is called the <strong class="calibre1">Vertical Blank Interval</strong>. Again, the electron gun is blanked to prevent pixels from being lit up while traveling back to the top scan line. The Vertical Blank Interval is a short period where the entire display has been updated and the framebuffer is not currently being read by the display:</p>
<pre class="calibre23">
//Example code drawing 640x480 display <br class="title-page-name"/>//Including H Blank Interval and V-Blank Interval <br class="title-page-name"/>for(int h = 0; h &lt; 480; ++h) <br class="title-page-name"/>{ <br class="title-page-name"/>  for(int w = 0; w &lt; 640; ++w) <br class="title-page-name"/>  { <br class="title-page-name"/>    //Sets pixel color and moves to next pixel <br class="title-page-name"/>    SetPixel(framebuffer[h][w]); <br class="title-page-name"/>  } <br class="title-page-name"/>//Resets to start of scan line and moves down one row <br class="title-page-name"/>  ResetHorizontal(); <br class="title-page-name"/>} <br class="title-page-name"/>//Resets to first pixel of first scan line <br class="title-page-name"/>ResetVerticle();
</pre>
<div class="packt_figure"><img class="image-border34" src="../images/00063.jpeg"/></div>
<div class="packt_figure1">Figure 11.4-Showing the movement pattern of the electron gun including the Horizontal and Vertical Blank Intervals</div>
<p class="calibre2">The phosphor dots on the screen are only lit up for a short period, so the electron gun must constantly relight them. The gun moves from left to right and top to bottom many times per second to refresh each pixel and display the correct image. If this process is too slow, the display will appear to flicker.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Refresh rate</h1>
            

            <article>
                
<p class="calibre2">The number of times per second a monitor refreshes the display is known as it's vertical refresh rate, or just refresh rate. The refresh rate of a monitor is measured in hertz (Hz). So, a monitor that can refresh the display 30 times per second has a refresh rate of 30 Hz. Many monitors refresh at 60 Hz, however, it is becoming common to see monitors with refresh rates of 120 Hz or even 240 Hz.</p>
<p class="calibre2">It is important to realize that the refresh rate of a monitor has nothing to do with the performance of a game or program. Having a monitor with a higher refresh rate will not improve the frame rate of a game, unless the game itself can support higher frame rates. The number of times a program updates the framebuffer is measured in frames per second or fps, and is completely independent from the number of times the monitor refreshes. When these two numbers are out-of-sync, the display will not look correct. Let's look at the problem of when the frames per second is less than the refresh rate:</p>
<div class="packt_figure"><img class="image-border35" src="../images/00064.jpeg"/></div>
<div class="packt_figure1">Figure 11.5 Comparing FPS versus Refresh Rate</div>
<p class="calibre2">These days, TV shows and movies are often displayed at 24 frames per second while the TV sets and monitors have a typical refresh rate of 60 Hz. In <em class="calibre12">Figure 11.5</em>, we have taken one second and split it into 60 red bars on the top to represent our refresh rate and 24 blue bars on the bottom to represent the frames of a movie. Each red bar represents the 1/60th of a second that the frame will be on screen. Each vertical dark red line represents when the monitor is refreshed.</p>
<p class="calibre2">As you can see, the refresh periods do not line up properly with the frames of the movie. In <em class="calibre12">Figure 11.5</em> we can clearly see that <strong class="calibre1">Frame 1</strong> is on screen for 3/60th (or 1/20th) of a second, while <strong class="calibre1">Frame 2</strong> is only on screen for 2/60th (or 1/30th) of a second. <strong class="calibre1">Frame 1</strong> is on screen longer than the original 1/24th of a second and <strong class="calibre1">Frame 2</strong> is on screen less. Since the frames are not on screen for an equal amount of time, the video seems jittery. While this may not seem like much of a difference, some people are sensitive enough to notice a slight speeding up and slowing down effect:</p>
<div class="packt_figure"><img class="image-border36" src="../images/00065.jpeg"/></div>
<div class="packt_figure1">Figure 11.6 - Example of refresh rate and frames per second Out-Of-Sync</div>
<p class="calibre2">TVs and movies have ways of adjusting for this problem, such as interpolating between frames. Since <strong class="calibre1">Frame 1</strong> and <strong class="calibre1">Frame 2</strong> are already known, it is easy to blend, interpolate, and generate intermediate frames before displaying them. However, that doesn't help us when our games are out-of-sync with the monitor.</p>
<p class="calibre2">Since games are interactive, the player's actions determine what will be displayed next on screen. The details of <strong class="calibre1">Frame 2</strong> are determined by player input in response to <strong class="calibre1">Frame 1</strong>. This means that the contents of the framebuffer must be generated each frame, it can't be known ahead of time.</p>
<p class="calibre2">In the above example, we were simplifying a little by pretending that writing to the framebuffer was instantaneous. Of course, this isn't true. Even though the next frame of a movie is already known, it still takes time to write to the framebuffer. Unless we can copy to the framebuffer completely during the Vertical Blank Interval, we will need to write to the framebuffer while the display is being drawn on screen.</p>
<p class="calibre2">If we can time everything correctly, we can always write a pixel just after the electron gun has read it. However, if we are out-of-sync with the electron gun, eventually there will be a point when we haven't written the pixel for the current frame and the electron gun reads the old value. Let's look at this problem up close:</p>
<div class="packt_figure"><img class="image-border37" src="../images/00066.jpeg"/></div>
<div class="packt_figure1">Figure 11.7 - Start position (Left) and End position (Right) in the framebuffer</div>
<p class="calibre2"><em class="calibre12">Figure 11.7</em>Â shows what we would like to see on screen. The left image is the position of a game object in frame 1. The right image is the ending position after the object has moved. These are two discrete points in time that we want to show. However, if the display is reading the pixels as we are writing them to the framebuffer, we can see a tearing effect if we haven't finished writing the current frame:</p>
<div class="packt_figure"><img class="image-border38" src="../images/00067.jpeg"/></div>
<div class="packt_figure1">Figure 11.8 - Example of tearing in the framebuffer</div>
<p class="calibre2">As we can see in <em class="calibre12">Figure 11.8</em>, the first image is correct. We are writing to a pixel after the display has read it. In the second image, the pixel being read has almost caught up to the pixel that is being written. At this point, the framebuffer contains half of each image. The third image shows that the display has overtaken the write pixel. The correct pixels have been written but they were written too late. The fourth image shows what the user would see on screen. Since the display read faster than the pixels could be written, the image looks as if it has been torn in half. This effect is known as tearing.</p>
<p class="calibre2">Tearing occurs when our frames per second and our refresh rate are out-of-sync. Unfortunately, it can be very difficult to get these two values perfectly aligned, and being a little off will cause some tearing. To solve this problem, we need to write out an entire frame of pixels before the display reads them.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Double buffering</h1>
            

            <article>
                
<p class="calibre2">The solution to our read/write problem is double buffering. Double buffering is exactly what it sounds like. Instead of using only one framebuffer, we will use two:Â one for reading and one for writing. Of course, since we now have two framebuffers, we need twice the memory. For a 1280 x 1024 display using 4 bytes per pixel, we need 5 megabytes per framebuffer for a total of 10 megabytes.</p>
<p class="calibre2">Everything up to this point could have been implemented in software by using operating system commands. However, as displays started requiring more memory and more complex images, special hardware was created. Modern graphics cards can contain gigabytes of memory used for framebuffers, textures, 3D triangle meshes, and much more. They can also contain hundreds or even thousands of cores to transform 3D points into pixel data simultaneously.</p>
<p class="calibre2">It is important to understand this because, as a programmer, you don't need to implement double buffering yourself. It is implemented at a hardware level and our games will be double buffered automatically by using a 3D graphics API such as DirectX or OpenGL. However, we still need to understand how this process works so we can understand the implications to our frame rate.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The back buffer</h1>
            

            <article>
                
<p class="calibre2">As we said, double buffering works by using two framebuffers so that we are never setting pixels on the same buffer that is being used for the display. The framebuffer that is currently being displayed is called the front buffer or primary buffer, and the framebuffer that we are drawing to is called the back buffer or secondary buffer.</p>
<p class="calibre2">When drawing is completed on the back buffer, the buffers are swapped so that the back buffer is now the front buffer and the front buffer is now the back buffer. Of course, the buffers themselves are not swapped. Instead, pointers to the buffers are swapped. The monitor has a pointer to one buffer and is currently reading it. The graphics card has a pointer to another buffer that it uses for all draw operations. This pointer swap, or page flipping as it is sometimes called, is much faster than copying data from the back buffer to the front buffer:</p>
<div class="packt_figure"><img class="image-border39" src="../images/00068.jpeg"/></div>
<div class="packt_figure1">Figure 11.9 - Example of double buffering</div>
<p class="calibre2">As you can see in the next two images, the display can read the front buffer while the graphics processing unit or GPU draws to the back buffer. However, there is nothing about double buffering that has prevented tearing. We have prevented drawing to the same buffer that is being displayed but, if we swap buffers in the middle of a screen refresh, we will still have tearing. This is an important first step in solving the tearing problem. However, before we solve it, let's talk about what happens when we are out-of-sync with the monitor refresh rate because we are generating too many frames per second:</p>
<div class="packt_figure"><img class="image-border40" src="../images/00069.jpeg"/></div>
<div class="packt_figure1">Figure 11.10 - Double buffering after the page flip</div>
<p class="calibre2">Imagine the situation in which our game is generating 90 frames per second. This is 30 frames more than we need to achieve 1 frame per refresh. This means we are wasting time creating frames that will never be seen. At 90 frames per second, one third of the frames will never be seen by the player. As you can see in <em class="calibre12">Figure 11.11</em>, every third frame, which is highlighted in green, will be skipped because it falls between two refresh intervals. Even more frames will be skipped if we are updating at 120 fps or more:</p>
<div class="packt_figure"><img class="image-border41" src="../images/00070.jpeg"/></div>
<div class="packt_figure1">Figure 11.11 - Comparing 60 Hz refresh with 90 fps</div>
<p class="calibre2">At 90 frames per second, every frame takes 1/90th of a second to complete. From the player's perspective, the third frame that gets shown (which is really our fourth frame) has been updated for a total of 1/45th of a second, or double the amount of time. Just like with the movie at 24 fps, this can cause a jittery effect that some players may notice because all objects will appear to have moved twice as far.</p>
<p class="calibre2">When updating this many times per second, these time slices are very small. It is possible that they are so small that they may go unnoticed by the player. The real problem with skipping frames is that our game is doing work that it just doesn't need to. Since the frame will never be seen by the player, there is no point in wasting game time generating it.</p>
<p class="calibre2">It is worth pointing out that only the graphics part of the update is wasted. It is perfectly fine to update input, AI, or physics faster than the monitor can refresh. In fact, physics will be more accurate if the time step is smaller. We just want to really emphasize that there is absolutely no reason to draw frames faster than the monitor's refresh rate.</p>
<p class="calibre2">For most games this is never a problem. The usual solution to having a high frame rate is to do more work and make your game more interesting. If your game is too fast, draw more particles, have more enemies, calculate more accurate physics, or just do more physics effects. If you find that your game runs faster than 60 fps, your game probably isn't the best it could be. Again, there is no reason to draw more frames per second than can appear on screen.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">VSync</h1>
            

            <article>
                
<p class="calibre2">So now we have seen both situations where our frame count is out-of-sync with our refresh rate. In both cases we can have tearing, and in the case of a very high frame rate, we are wasting CPU/GPU cycles that could be used to improve our game. We want to avoid tearing. We want to be in-sync with the monitor refresh. How can we solve this problem?</p>
<p class="calibre2">The solution is the Vertical Blank Interval. Remember that the Vertical Blank Interval is when the electron gun is repositioning itself from the last pixel on the display back to the first pixel. During this short period, the entire display has been drawn and the front buffer isn't being used. This period is too short to copy all the contents of the back buffer to the front buffer. However, it is long enough to swap the pointers, which is how the page flipping mechanism works.</p>
<p class="calibre2">Modern computer monitors and TVs can send a signal back to the computer when the Vertical Blank, Interval, or V-Blank occurs. The graphics card waits until a V-Blank before swapping the buffers after the back buffer is completely drawn. This guarantees that there will never be tearing because parts of different frames can never be read in a single refresh.</p>
<p class="calibre2">As we said, double buffering is implemented at the hardware level. This is also true of synchronizing with the Vertical Blank Interval. By using a 3D graphics API such as DirectX or OpenGL, you get this for free. This V-Blank syncing or VSync is an option that must be enabled when initializing graphics. Once VSync is turned on, we don't need to worry about tearing. Additionally, the game will never generate more than one frame per monitor refresh because the graphics card will always wait for the V-Blank signal before swapping the buffers.</p>
<p class="calibre2">Syncing with the refresh rate of the monitor is a great way to prevent tearing. If a game can update 60 or more times a second, the back buffer and the front buffer will always be able to swap and we will have a smooth, tear-free game. However, we haven't talked about what happens if the back buffer isn't ready to be swapped because the frame is taking longer than 1/60<sup class="calibre30">th</sup> of a second to complete.</p>
<p class="calibre2">It is important to understand that the front and back buffers do not swap automatically every time the V-Blank signal arrives. Instead, the swap is performed at the request of the programmer. A function call is made to tell the graphics card that a new frame is prepared and the buffers should be swapped. This swap will happen immediately if VSync is turned off. However, if the VSync is turned on, the graphics card will wait for the V-Blank signal to arrive, no matter how long that is. If our update is just 1/100th slower, meaning a frame takes 1/59<sup class="calibre30">th</sup> of a second to complete, we will miss the V-Blank and need to wait for the next one.</p>
<p class="calibre2">Since the current frame wasn't ready, the monitor displays the previous frame again. The same frame will be on screen for 1/30th of a second. Since the back buffer must wait to be swapped until the next V-Blank, our game can't start working on the next frame. Our game is idle while waiting for the V-Blank. This means that if our game is using VSync and it can't achieve 60 frames per second, our frame rate will drop down to 30 frames per second. If our game can't achieve 30 frames per second, our frame rate will take 3/60th of a second, or 20 fps.</p>
<p class="calibre2">For some programmers and some games, achieving 30 frames per second is perfectly fine. To implement more beautiful effects or more accurate physics, dropping to 30 frames per second might be an important trade off. Everyone must decide for their own game what is right. However, many players simply do not like 30 frames per second. Players often say they can notice more jittery movement and more importantly, they notice input lag.</p>
<p class="calibre2">Remember, if we can't achieve our goal of 60 fps, the graphics card must wait for the next V-Blank before returning from the swap call. This means that our game can't process physics, AI, or even input. The player is seeing half as many frames on screen, which means objects are moving more each frame. Additionally, input is now being gathered from the player once every 1/30th of a second instead of once every 1/60th of a second. While this may not seem like much, for fast, twitch response games such as <em class="calibre12">First Person Shooters</em>, this can be too long.</p>
<p class="calibre2"><em class="calibre12">Figure 11.12</em> shows an example of the contents of both the front and back buffers in a VSync scenario where a game can't update at the same rate as the monitor. The display refreshes every 1/60th of a second or every 0.0167 seconds. The game can update every 1/50th of a second or every 0.02 seconds. In the image below, the monitor refreshes are colored red or green. The red refreshes are when the game frame isn't ready and so the previous frame is displayed. The green refreshes are when the game frame is ready and so the buffers are swapped.</p>
<p class="calibre2">The blue represents when the game frame is completed. This doesn't mean that the new frame is instantly displayed. This is because the graphics card waits until the next refresh to swap buffers. It is important to understand that the game doesn't update every 1/50th of a second for the same reason. Instead, each game update is 1/50th of a second after the last buffer swap:</p>
<div class="packt_figure"><img class="image-border42" src="../images/00071.jpeg"/></div>
<div class="packt_figure1">Figure 11.12 - Showing contents of back buffer and front buffer when using VSync</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Triple buffering</h1>
            

            <article>
                
<p class="calibre2">Turning on VSync in our games can improve the look of our graphics because we are guaranteed that tearing will never occur. Unfortunately, if our game frame isn't completed in time for the next refresh, the graphics card waits until the next V-Blank to swap buffers. This is true even if our game misses the refresh by only 1/100th of a second. If our frame is off by this short amount, our fps drops to 30. This is because the content of the back buffer hasn't been swapped yet, so we can't start drawing the next frame.</p>
<p class="calibre2">It would be nice if we could start drawing the next frame while still waiting for the V-Blank signal. To do this, we would need an extra framebuffer to draw to while we are waiting. This is exactly how triple buffering works.</p>
<p class="calibre2">For triple buffering we have a total of three framebuffers. For a 1280 x 1024 display with 4 bytes per pixel we would need a total of 15 megabytes. However, by using this extra memory, we will always have a framebuffer to draw to, so we should always be able to hit our fps goal.</p>
<p class="calibre2">In triple buffering, we have our primary and secondary buffers just like before but now we have a tertiary buffer as well. We start out drawing to the back buffer. If we finish the current frame before the refresh, we can immediately move on to drawing on the tertiary buffer. If we don't finish in time for the refresh we will need to wait for the next refresh, just as we did in the double buffer scenario. However, we only need to miss a refresh this one time. Once the back buffer is filled, we can immediately start working on the tertiary buffer. Either way, once the back buffer has been filled, we will be forever one frame ahead. The primary buffer will be used for display, the secondary buffer will be ready and waiting for the swap, and the graphics card will use the tertiary buffer for drawing:</p>
<div class="packt_figure"><img class="image-border43" src="../images/00072.jpeg"/></div>
<div class="packt_figure1">Figure 11.13 - Drawing to the tertiary buffer before the V-Blank</div>
<p class="calibre2">When the V-Blank occurs, all the buffers can swap if they are ready. The secondary buffer becomes the primary buffer for display. The tertiary buffer becomes the secondary buffer and waits to be displayed. Finally, the primary buffer becomes the new tertiary buffer used for drawing:</p>
<div class="packt_figure"><img class="image-border44" src="../images/00073.jpeg"/></div>
<div class="packt_figure1">Figure 11.14 - Scenario 1 - Swapping all buffers after V-Blank</div>
<p class="calibre2">Â If the tertiary buffer isn't ready at the time of the V-Blank, it continues drawing until the frame is completed and can swap with the original primary buffer without waiting for the V-Blank:</p>
<div class="packt_figure"><img class="image-border45" src="../images/00074.jpeg"/></div>
<div class="packt_figure1">Figure 11 15 - Scenario 2A - Swap primary and secondary buffers after V-Blank</div>
<p class="calibre2">By using triple buffering, we solve the problem of suddenly dropping from 60 fps to 30 fps when there are a few slow frames in our game. This also allows us to avoid the drop to 30 fps and (almost) consistently achieve 60 fps in cases which are just below 60, since we don't need wait until a V-Blank before we can start the next frame:</p>
<div class="packt_figure"><img class="image-border46" src="../images/00075.jpeg"/></div>
<div class="packt_figure1">Figure 11.16 - Scenario 2B - Swap secondary and tertiary buffers when drawing is complete</div>
<p class="calibre2">However, as you can see in <em class="calibre12">Figure 11.17</em>, triple buffering still has the chance to miss a refresh. Using the same case as before where our game updates at 1/50th of a second and the monitor refreshes at 1/60th of a second, we still miss one out of every six refreshes. It should come as no surprise that the lower our frame rate, the more refreshes we will miss. If each of our frames takes 1/30th of a second or more to complete, we can't expect to achieve 60 fps:</p>
<div class="packt_figure"><img class="image-border47" src="../images/00076.jpeg"/></div>
<div class="packt_figure1">Figure 11.17 - Example of missing the refresh when using triple buffering</div>
<p class="calibre2">Even though triple buffering allows us to avoid tearing while maintaining 60 fps, there is an important factor that you must consider before deciding to use it. There is a two-frame delay between what has just appeared on screen and the current frame being processed. Triple buffering allows us to process another frame in the tertiary buffer while the next frame in the secondary buffer is waiting to be displayed, all while the primary buffer is currently being displayed. This puts us one frame ahead so we can avoid frame rate drop, but lowers response time for the player.</p>
<p class="calibre2">If the jump button is pressed, the player avatar won't appear to jump until the current frame and the next frame have been displayed. This is because the frame being processed, including game object responses to input, is being put into the tertiary buffer. If the primary and secondary buffers are on screen for 1/60th of a second each, there will be an effective lag of 1/30th of a second for player input. The game will look like it is running at 60 fps (because it is), physics will behave like the game is running at 60 fps (because it is), but because of the input delay, the game will feel like it is running at 30 fps.</p>
<p class="calibre2">It is up to you to decide what is best for your game. Many players may not even notice the input lag because the time slice is so small. However, for fast twitch games such as first person shooters, or games that require precision control for jumping or steering, this may be unacceptable.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">LCD monitors</h1>
            

            <article>
                
<p class="calibre2">We spent a lot of time talking about how Cathode Ray Tube monitors work. This was important so that we could understand the Vertical Blank interval and how it relates to double buffering. However, it seems a little outdated since LCD and LED monitors are much more common. We aren't going to discuss how these two types of monitors work, because it has no effect on our frame rate. What is important is that these monitors fake the V-Blank signal. Even though they don't need to refresh and have no electron gun, they still send a fake signal to the graphics card. This way, your program can still be locked with the <em class="calibre12">refresh</em> rate of the monitor.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Time-based movement and animation</h1>
            

            <article>
                
<p class="calibre2">We have covered a lot so far in this chapter. We have been looking at the frame rate and refresh rate so we can understand how it relates to what is displayed on screen. However, the frame rate of a game has the chance to impact upon every engine of the game. It can even affect testing and debugging during development.</p>
<p class="calibre2">At the start of a game's development, the game logic isn't very complicated and the unit count is very low. For this reason, it is common to see thousands of frames per second. As development continues, this frame rate will slowly drop to hundreds and then (hopefully) settle around 60Â frames per second. Imagine if there was some game logic to spawn an enemy once every 10Â frames. Depending on where we are in the development cycle, we might be spawning six or sixty enemies every second. This makes the game very hard to test and debug because it is not consistent.</p>
<p class="calibre2">What makes this problem even more interesting is that, even within a single play session, nothing is guaranteed to be consistent. At the start of the game, there are no enemies, so the frame rate might be as high as 600Â frames per second. This means we are spawning 60Â enemies every second. After five seconds, there are 300Â enemies on screen which makes both physics and graphics very slow. Suddenly our frame rate might drop to 30 frames per second, slowing down enemy creation. As the player kills more enemies, the frame rate will rise, causing enemies to spawn faster and dropping the frame rate again.</p>
<p class="calibre2">This problem isn't just limited to affecting game logic. It is a problem that affects anything that changes between frames. In particular, it is going to affect animation of game objects. Here, animation refers to anything that changes within a game object. This includes changing a game object's texture over time, which is how we typically think of animation. However, it also includes moving, scaling, rotating, or changing the color and transparency of an object over time. To understand this problem more, let's look at how moving a unit every frame can adversely affect game development.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Frame-based movement</h1>
            

            <article>
                
<p class="calibre2">When we want to move a game object, the simplest way to do it is to update the position at a constant rate. This can work fine for some games. However, for simulating cars, spaceships, or even gravity, it won't look correct. For now, we will use this method as an example then look at physics-based movement a little later. Since we are just updating the object's position, the code to move the player to the right will look like this:</p>
<pre class="calibre23">
//Move the player to the right <br class="title-page-name"/>//This is just an example <br class="title-page-name"/>//A game should not be hard-coded like this <br class="title-page-name"/>pos.x += 5;
</pre>
<p class="calibre2">It is worth noting that the value 5 is not measured in inches or meters; it is in game units. Game units are completely arbitrary and are dependent on the size of objects in the game. 3D modeling programs will allow you to set up units of scale for your models. If the same units are used for every model, and the models are not scaled in the game world, it would be possible to think about the game world in terms of those units. However, it is more common to consider everything as arbitrary game units. The amount an object moves on the screen depends on the size of the object and how far it is from the camera. If everything looks and feels correct in relation to everything else, it is OK.</p>
<p class="calibre2">In the preceding example, assuming the size and camera distance are fixed, the distance on screen that the player moves will be completely dependent on our frame rate. For example, if we are getting 1,000Â frames per second, as we might early in the development, our player will move 5,000Â game units in the <kbd class="calibre14">x</kbd> direction. Later in development, when we are getting 100 frames per second, our player will only be moving 500Â units in the <kbd class="calibre14">x</kbd> direction. To get the same amount of movement, we would need to change the speed of the player:</p>
<pre class="calibre23">
//Move the player to the right <br class="title-page-name"/>//This is just an example <br class="title-page-name"/>//A game should not be hard-coded like this <br class="title-page-name"/>pos.x += 50;
</pre>
<p class="calibre2">As we get closer to finishing the game, we might only be getting 60 frames per second. This would mean the speed of the player would need to be changed again. To get the same amount of movement, the player speed would need to be 83.333 fps. Unfortunately, even after the game is released, we still have the same problem. As graphics cards and CPUs become faster, our game's frame rate will increase, meaning the player will be moving too fast. The gameplay experience is completely dependent on the computer hardware.</p>
<p class="calibre2">This problem could be solved by enabling VSync. As we saw earlier, using VSync will effectively lock our frame rate to the refresh rate of the monitor. This would guarantee that our frame rate has a maximum value. However, the player will be very confused when they upgrade to a 120 Hz monitor and the player moves twice as fast. Additionally, if the game runs slow for a few frames, VSync causes our frame rate to drop down to 30 fps. Suddenly, the player is moving at half speed. Even when using VSync, our gameplay experience is completely dependent on the hardware.</p>
<p class="calibre2">Obviously using frame-based movement is not the way to go. As our frame rate rises and falls, we must change the movement speed of the player. As we said, this same problem occurs in all animation. Rotational speed of spinning objects, scale, fade speed of particles, and the number of frames to display a texture before changing it all must be constantly modified during development, and still won't be consistent across different hardware.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Time-based movement</h1>
            

            <article>
                
<p class="calibre2">Instead of using frame-based movement, it is much better to base our movement on time. Time is guaranteed to be consistent throughout development and on all hardware, now and in the future. Whether our game is updating at three frames per second or 3,000Â frames per second, one second will always be equal to one second.</p>
<p class="calibre2">Using time-based movement is great because it allows us to use equations that have existed for hundreds of years. We don't need to reinvent the wheel to simulate velocity and acceleration. As we said before, using a constant speed to move the player is OKÂ for some games, but that isn't how real physics works. Cars and spaceships do not accelerate instantly. Gravity pulls you down faster and faster the longer you fall.</p>
<p class="calibre2">When you toss a ball to a ten year old child, they don't need to do complex calculations to catch the ball; they can just do it. Similarly, in a semi-realistic simulation, players will expect the physics to behave <em class="calibre12">normally</em>. To simulate realistic or semi-realistic physics in our game, we should understand how to incorporate velocity and physics into our movement.</p>
<p class="calibre2">We can calculate an object's velocity by subtracting the initial position of an object from the final position of an object, and dividing that by how long the displacement took. Another way to say this is that velocity is equal to the change in the position divided by the change in time. We can use this to create an equation that we can put in our code:</p>
<div class="packt_figure"><img src="../images/00077.jpeg" class="calibre31"/></div>
<div class="packt_figure"><img src="../images/00078.jpeg" class="calibre32"/></div>
<div class="packt_figure"><img src="../images/00079.jpeg" class="calibre33"/></div>
<div class="packt_figure"><img src="../images/00080.jpeg" class="calibre33"/></div>
<p class="calibre2">We can also calculate an object's acceleration by subtracting the initial velocity from the final velocity and dividing by the change in time. Acceleration is change in velocity over change in time:</p>
<div class="packt_figure"><img src="../images/00081.jpeg" class="calibre34"/></div>
<div class="packt_figure"><img src="../images/00082.jpeg" class="calibre35"/></div>
<div class="packt_figure"><img src="../images/00083.jpeg" class="calibre36"/></div>
<div class="packt_figure"><img src="../images/00084.jpeg" class="calibre37"/></div>
<p class="calibre2">We also know from Newton's second law of motion that force equals mass times acceleration. This also means that acceleration is equal to force divided by mass:</p>
<div class="packt_figure"><img src="../images/00085.jpeg" class="calibre38"/></div>
<div class="packt_figure"><img src="../images/00086.jpeg" class="calibre39"/></div>
<p class="calibre2">What this means is that, if we know the current position, velocity, and the forces acting on an object, we can find the position and velocity at some point in the future. In our games, we can use these three equations to simulate motion:</p>
<div class="packt_figure"><img src="../images/00087.jpeg" class="calibre40"/></div>
<div class="packt_figure"><img src="../images/00088.jpeg" class="calibre37"/></div>
<div class="packt_figure"><img src="../images/00089.jpeg" class="calibre41"/></div>
<p class="calibre2">The first two of these three equations are called Euler (pronounced Oiler) Integration. Specifically, it is called explicit Euler. In code, it will look something like this:</p>
<pre class="calibre23">
float EulerIntegration(float pos, float vel, float accel, <br class="title-page-name"/>   float totalTime, float dt) <br class="title-page-name"/>{ <br class="title-page-name"/>  float time = 0.0f; <br class="title-page-name"/>  while (time &lt; totalTime) <br class="title-page-name"/>  { <br class="title-page-name"/>    pos += vel * dt; <br class="title-page-name"/>    vel += accel * dt; <br class="title-page-name"/>    time += dt; <br class="title-page-name"/>    } <br class="title-page-name"/>  return pos; <br class="title-page-name"/>}
</pre>
<p class="calibre2">The inner loop of this code is a close example of how we will use this in a game. Every frame, we will update our position and velocity based on <kbd class="calibre14">dt</kbd> and the acceleration. The velocity calculated in this frame will be used to update the position of an object in the next frame. Outside of a loop, these equations make perfect sense. If we are traveling at 55 mph down the freeway, after one hour we expect to be 55 miles further down the road. Similarly, if we are accelerating at 8 miles per hour per second then after ten seconds we expect to have a velocity of 80 mph.</p>
<p class="calibre2">However, inside of the loop we will have some errors. Euler Integration is only accurate if acceleration and velocity are held constant. In the preceding code example, velocity is changing every time through the loop, so it is inaccurate proportional to the square of the step size. That means that the larger the step, the more error it has.</p>
<p class="calibre2">Let's compare Euler Integration with one of the Kinematics Equations of motion to see how this error effects our results. The Kinematics Equation that we will test with is:</p>
<div class="packt_figure"><img src="../images/00090.jpeg" class="calibre42"/></div>
<p class="calibre2">Where <kbd class="calibre14">p</kbd> is our new position, <kbd class="calibre14">p<sup class="calibre43">0</sup></kbd> is our initial position, <kbd class="calibre14">v<sup class="calibre43">0</sup></kbd> is our initial velocity, <kbd class="calibre14">a</kbd> is our acceleration and <kbd class="calibre14">t</kbd> is our time.</p>
<p class="calibre2">Let's assume that our starting position is 0 and our starting velocity is 0. Typically, in physics equations, acceleration is in units of seconds per second instead of hours per second. So, let's say we are accelerating at 20 feet per second for 10 seconds. After 10 seconds, our car will have traveled 500 feet:</p>
<div class="packt_figure"><img src="../images/00091.jpeg" class="calibre44"/></div>
<div class="packt_figure"><img src="../images/00092.jpeg" class="calibre45"/></div>
<div class="packt_figure"><img src="../images/00093.jpeg" class="calibre46"/></div>
<div class="packt_figure"><img src="../images/00094.jpeg" class="calibre47"/></div>
<p class="calibre2">So, the Kinematics equations say we will be <kbd class="calibre14">1000</kbd> feet from where we started after <kbd class="calibre14">10</kbd> seconds. Using this same data, let plug it into our Euler Integration function. We will be integrating every second for 10 seconds:</p>
<pre class="calibre23">
  Time = 0  pos =    0.00 vel =   0.00 <br class="title-page-name"/>  Time = 1  pos =    0.00 vel =  20.00 <br class="title-page-name"/>  Time = 2  pos =   20.00 vel =  40.00 <br class="title-page-name"/>  Time = 3  pos =   60.00 vel =  60.00 <br class="title-page-name"/>  Time = 4  pos =  120.00 vel =  80.00 <br class="title-page-name"/>  Time = 5  pos =  200.00 vel = 100.00 <br class="title-page-name"/>  Time = 6  pos =  300.00 vel = 120.00 <br class="title-page-name"/>  Time = 7  pos =  420.00 vel = 140.00 <br class="title-page-name"/>  Time = 8  pos =  560.00 vel = 160.00 <br class="title-page-name"/>  Time = 9  pos =  720.00 vel = 180.00 <br class="title-page-name"/>  Time = 10 pos =  900.00 vel = 200.00
</pre>
<p class="calibre2">Euler Integration says we will be 900 feet from where we started. The Kinematics Equation and Euler Integration are 100 feet off. This is after only 10 seconds. The longer we integrate for, the more the error. Of course, we already explained why we have this problem. The error is proportional to the time step. If we use a smaller time step, we will have a smaller error. Luckily our game will be updating more than oneÂ frame per second. Let's integrate again, but let's use some more realistic time steps. Let's choose values for 30 fps, 60 fps, and 120 fps. These give us time steps of .0333, .0167, and .008 respectively:</p>
<pre class="calibre23">
  dt = 1.000000   pos = 900.00 <br class="title-page-name"/>  dt = 0.033333   pos = 996.67 <br class="title-page-name"/>  dt = 0.016667   pos = 998.33 <br class="title-page-name"/>dt = 0.008333   pos = 1000.83
</pre>
<p class="calibre2">As you can see, by using a smaller time step, we come closer to the matching result. At 120 fps, we are pretty accurate but, even at 60 fps, we have calculated a few feet off. Unfortunately, even the Kinematics equations are not accurate unless acceleration is held constant.</p>
<p class="calibre2">For many games, Euler Integration will be all you need. The errors are small enough that players may not notice. This of course depends on gameplay and the frame rate. Creating an extremely accurate physics integrator is beyond the scope of this book.</p>
<div class="packt_infobox">If your game requires very accurate physics, check out Verlet Integration or RK4 Integration at:<br class="calibre27"/>
<span class="urlpackt"><a href="https://en.wikipedia.org/wiki/Verlet_integration" target="_blank" class="calibre24">https://en.wikipedia.org/wiki/Verlet_integration</a>,<br class="calibre27"/></span> <a href="https://en.wikipedia.org/wiki/Runge-Kutta_methods" target="_blank" class="calibre24"><span class="urlpackt">https://en.wikipedia.org/wiki/Runge-Kutta_methods</span></a></div>
<p class="calibre2">Whichever integration method you choose, it will be better and more reliable than using frame-based movement. The important thing to remember is that anything that changes in the game must use time. This includes rotations, which can use similar rotational velocity and rotational acceleration if you want. It also includes scaling over time, animating a texture over time, and even changing color and transparency. This will give our game a very consistent look and feel, as well as making it easier to test and debug throughout development.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">We have really covered a lot in this chapter. Now, you know more about how computer monitors work than you probably ever wanted. In this chapter, we dived into the nitty gritty details of framebuffers and how pixels are colored on screen. We saw that having a frame rate that was out-of-sync with the monitor can cause tearing. We also looked at how double buffering and using VSync can fix this problem. Unfortunately, we also saw that VSync can cause problems of its own. We also looked at triple buffering and saw the pros and cons there. In the end, there is no perfect answer. There will always be some trade-off. You must either accept tearing or the possibility of a drastic drop in frame rate due to VSync.</p>
<p class="calibre2">Finally, we finished this chapter by looking at how our frame rate affects the rest of our gameplay code. Specifically, we looked at physics and animation, and learned that we must use time-based physics and animation for a more consistent look and feel in our game.</p>
<p class="calibre2">In the next chapter, we are going to get away from the low-level details and look at the big picture of programming. This includes our coding philosophy and why we care about high quality code. We will look at a few tips and tricks that can help make developing a game less of a headache, as well as covering a few specific things in the Mach5 engine that aren't patterns but can still make your coding life much easier.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>