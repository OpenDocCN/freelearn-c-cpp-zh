- en: Chapter 7. Generating Code for Target Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 生成目标架构代码
- en: The code generated by the compiler finally has to execute on the target machines.
    The abstract form of the LLVM IR helps to generate code for various architectures.
    The target machine can be anything – CPU, GPU, DSP's, and so on. The target machine
    has some defining aspects such as the register sets, the instruction set, the
    calling convention of the function, and the instruction pipeline. These aspects
    or properties are generated using the **tablegen** tool so that they can be used
    easily while programming code generation for the machine.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成的代码最终必须在目标机器上执行。LLVM IR的抽象形式有助于为各种架构生成代码。目标机器可以是任何东西——CPU、GPU、DSP等。目标机器有一些定义性的方面，如寄存器集、指令集、函数的调用约定和指令流水线。这些方面或属性是通过**tablegen**工具生成的，以便在编写机器代码生成程序时易于使用。
- en: LLVM has a pipeline structure for the backend, where instructions travel through
    phases—from the LLVM IR to **SelectionDAG**, then to **MachineDAG**, then to **MachineInstr**,
    and finally to **MCInst**. The IR is converted to SelectionDAG. SelectionDAG then
    goes through legalization and optimizations. After this stage, the DAG nodes are
    mapped to target instructions (instruction selection). The DAG then goes through
    instruction scheduling, emitting linear sequences of instructions. The virtual
    registers are then allotted the target machine registers, which involves optimal
    register allocation minimizing memory spills.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM后端有一个流水线结构，其中指令通过阶段从LLVM IR到**SelectionDAG**，然后到**MachineDAG**，然后到**MachineInstr**，最后到**MCInst**。IR被转换为SelectionDAG。然后SelectionDAG经过合法化和优化。在此阶段之后，DAG节点被映射到目标指令（指令选择）。然后DAG经过指令调度，生成指令的线性序列。虚拟寄存器随后被分配到目标机器寄存器，这涉及到最优化的寄存器分配以最小化内存溢出。
- en: This chapter describes how to represent target architecture. It also describes
    how to emit assembly code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了如何表示目标架构。它还描述了如何生成汇编代码。
- en: 'The topics discussed in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的主题如下：
- en: Defining registers and register sets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义寄存器和寄存器集
- en: Defining the calling convention
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义调用约定
- en: Defining the instruction set
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义指令集
- en: Implementing frame lowering
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现帧降低
- en: Selecting an instruction
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择指令
- en: Printing an instruction
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印指令
- en: Registering a target
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册目标
- en: Sample backend
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例后端
- en: To understand target code generation, we define a simple RISC-type architecture
    TOY machine with minimal registers, say `r0-r3`, a stack pointer `SP`, a link
    register, `LR` (for storing the return address); and a `CPSR` – current state
    program register. The calling convention of this toy backend is similar to the
    ARM thumb-like architecture—arguments passed to the function will be stored in
    register sets `r0-r1`, and the return value will be stored in `r0`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解目标代码生成，我们定义了一个简单的RISC型架构TOY机器，具有最少的寄存器，例如`r0-r3`，一个栈指针`SP`，一个链接寄存器`LR`（用于存储返回地址）；以及一个`CPSR`——当前状态程序寄存器。这个玩具后端的调用约定类似于ARM
    thumb-like架构——传递给函数的参数将存储在寄存器集`r0-r1`中，返回值将存储在`r0`中。
- en: Defining registers and register sets
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义寄存器和寄存器集
- en: 'Register sets are defined using the tablegen tool. Tablegen helps to maintain
    large number of records of domain specific information. It factors out the common
    features of these records. This helps in reducing duplication in the description
    and forms a structural way of representing domain information. Please visit [http://llvm.org/docs/TableGen/](http://llvm.org/docs/TableGen/)
    to understand tablegen in detail. `TableGen` files are interpreted by the `TableGen
    binary: llvm-tblgen`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器集是通过tablegen工具定义的。Tablegen有助于维护大量特定领域的信息记录。它提取了这些记录的共同特征。这有助于减少描述中的重复，并形成表示领域信息的一种结构化方式。请访问[http://llvm.org/docs/TableGen/](http://llvm.org/docs/TableGen/)以详细了解tablegen。`TableGen`文件由`TableGen二进制：llvm-tblgen`解释。
- en: We have described our sample backend in the preceding paragraph, which has four
    registers (`r0-r3`), a stack register (`SP`), and a link register (`LR`). These
    can be specified in the `TOYRegisterInfo.td` file. The `tablegen` function provides
    the `Register` class, which can be extended to specify the registers. Create a
    new file named `TOYRegisterInfo.td`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一段落中描述了我们的示例后端，它有四个寄存器（`r0-r3`），一个栈寄存器（`SP`）和一个链接寄存器（`LR`）。这些可以在`TOYRegisterInfo.td`文件中指定。`tablegen`函数提供了`Register`类，可以扩展以指定寄存器。创建一个名为`TOYRegisterInfo.td`的新文件。
- en: The registers can be defined by extending the `Register` class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器可以通过扩展 `Register` 类来定义。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The registers `r0-r3` belong to a general purpose `Register` class. This can
    be specified by extending `RegisterClass`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器 `r0-r3` 属于通用 `Register` 类。这可以通过扩展 `RegisterClass` 来指定。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The remainings, register `SP`, `LR`, and `CPSR`, can be defined as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的，寄存器 `SP`、`LR` 和 `CPSR` 可以如下定义：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the whole thing is put together, the `TOYRegisterInfo.td` looks like the
    following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有这些放在一起时，`TOYRegisterInfo.td` 看起来如下所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can put this file in a new folder named `TOY` in the parent folder named
    `Target` in the llvm's root directory, which is `llvm_root_directory/lib/Target/TOY/
    TOYRegisterInfo.td`
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此文件放在名为 `TOY` 的新文件夹中，该文件夹位于名为 `Target` 的父文件夹中，位于 llvm 的根目录下，即 `llvm_root_directory/lib/Target/TOY/
    TOYRegisterInfo.td`。
- en: The tablegen tool `llvm-tablegen`, processes this `.td` file to generate the
    `.inc` file, which generally has enums generated for these registers. These enums
    can be used in the `.cpp` files, in which the registers can be referenced as `TOY::R0`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表生成工具 `llvm-tablegen` 处理这个 `.td` 文件以生成 `.inc` 文件，该文件通常为这些寄存器生成枚举。这些枚举可以在 `.cpp`
    文件中使用，其中寄存器可以引用为 `TOY::R0`。
- en: Defining the calling convention
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义调用约定
- en: The calling convention specifies how values are passed to and returned from
    a function call. Our `TOY` architecture specifies that two arguments are passed
    in two registers, `r0` and `r1`, while the remaining ones are passed to the stack.
    Calling convention defined is then used in the Instruction Selection phase by
    referring to the function pointer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 调用约定指定了值如何传递到和从函数调用返回。我们的 `TOY` 架构指定两个参数通过两个寄存器 `r0` 和 `r1` 传递，其余的传递到栈上。定义的调用约定随后通过引用函数指针在指令选择阶段使用。
- en: While defining a calling convention, we have to represent two sections—one to
    define the convention return value, and other to define the convention for argument
    passing. The parent class `CallingConv` is inherited to define the calling convention.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义调用约定时，我们必须表示两个部分——一个用于定义约定返回值，另一个用于定义参数传递的约定。父类 `CallingConv` 被继承以定义调用约定。
- en: 'In our `TOY` architecture, the return value is stored in `r0` register. If
    there are more arguments, integer values get stored in stack slots that are 4
    bytes in size and 4-byte aligned. This can be declared in `TOYCallingConv.td`
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `TOY` 架构中，返回值存储在 `r0` 寄存器中。如果有更多参数，整数值将存储在大小为 4 字节且 4 字节对齐的栈槽中。这可以在 `TOYCallingConv.td`
    中如下声明：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The argument passing convention can be defined as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 参数传递约定可以定义为以下内容：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding declaration says three things, which are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的声明说明了以下三个内容：
- en: If the datatype of the arguments is `i8` or `i16`, it will get promoted to `i32`
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数的数据类型是 `i8` 或 `i16`，它将被提升为 `i32`
- en: The first two arguments will be stored in register `r0` and `r1`
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个参数将存储在寄存器 `r0` 和 `r1` 中
- en: If there are more arguments, they will be stored in `Stack`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有更多参数，它们将存储在 `Stack`
- en: We also define the callee-saved register since callee-saved registers are used
    to hold long-lived values that should be preserved across calls.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了调用者保留寄存器，因为调用者保留寄存器用于存储应在调用之间保留的长生存期值。
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `llvm-tablegen` tool generates a `TOYCallingConv.inc` file after building
    the project, which will be included in the Instruction Selection phase in the
    `TOYISelLowering.cpp` file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建项目后，`llvm-tablegen` 工具生成一个 `TOYCallingConv.inc` 文件，该文件将在 `TOYISelLowering.cpp`
    文件中的指令选择阶段被包含。
- en: Defining the instruction set
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义指令集
- en: 'Architectures have rich instruction sets to represent various operations supported
    by the target machine. Typically, three things need to be defined in the target
    description file when representing the instructions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 架构具有丰富的指令集来表示目标机器支持的各项操作。在表示指令时，通常需要在目标描述文件中定义以下三个内容：
- en: operands
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数
- en: the assembly string
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇编字符串
- en: the instruction pattern
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令模式
- en: The specification contains a list of definitions or outputs, and a list of uses
    or inputs. There can be different operand classes, such as the `Register` class,
    and the immediate and more complex `register+imm` operands.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 规范包含一个定义或输出的列表，以及一个使用或输入的列表。可以有不同类型的操作数类，例如 `Register` 类，以及立即数和更复杂的 `register+imm`
    操作数。
- en: 'For example, we define register to register addition for our Toy machine as
    follows in `TOYInstrInfo.td`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在 `TOYInstrInfo.td` 中如下定义我们的玩具机器的寄存器到寄存器的加法：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the above declaration, the ''`ins`'' has two registers `$src1` and `$src2`
    belonging to the general purpose register class, which holds the two operands.
    The result of the operation will be put into ''`outs`'', which is a `$dst` register
    belonging to the general purpose `Register` class. The assembly string is "`add
    $dst, $src1,z$src2`". The values of `$src1`, `$src2` and `$dst` will be determined
    at the time of register allocation. So, an assembly will be generated for `add`
    between two registers, like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述声明中，`'ins'` 有两个属于通用寄存器类的寄存器 `$src1` 和 `$src2`，它们持有两个操作数。操作的结果将被放入 `'outs'`，这是一个属于通用
    `Register` 类的 `$dst` 寄存器。汇编字符串是 "`add $dst, $src1,z$src2`"。`$src1`、`$src2` 和 `$dst`
    的值将在寄存器分配时确定。因此，将生成两个寄存器之间 `add` 操作的汇编，如下所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We saw above how a simple instruction can be represented using tablegen. Similar
    to the `add register to register` instruction, a `subtract register from a register`
    instruction can be defined. We leave it to the readers to try it out. A more detailed
    representation of complex instructions can be examined from the ARM or X86 architecture
    specifications in the project code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面看到，一个简单的指令可以使用 tablegen 来表示。类似于 `add register to register` 指令，可以定义一个 `subtract
    register from a register` 指令。我们留给读者去尝试。更详细地表示复杂指令可以从项目代码中的 ARM 或 X86 架构规范中找到。
- en: Implementing frame lowering
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现帧降低
- en: Frame lowering involves emitting function prologue and epilogue. The prologue
    happens at the beginning of a function. It sets up the stack frame of the called
    function. The epilogue happens last in a function, it restores the stack frame
    of the calling (parent) function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 帧降低涉及发出函数的前置和后置代码。前置代码发生在函数的开始处，它设置了被调用函数的栈帧。后置代码在函数的最后执行，它恢复调用（父）函数的栈帧。
- en: 'The "`stack`" serves several purposes in the execution of a program, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行过程中，"`栈`" 扮演着几个角色，如下所述：
- en: Keeping track of return address, when calling a function
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用函数时跟踪返回地址
- en: Storage of local variables in the context of a function call
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数调用上下文中存储局部变量
- en: Passing arguments from the caller to the callee.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从调用者传递参数给被调用者。
- en: Thus there are 2 main functions that need to be defined when implementing frame
    lowering – `emitPrologue()` and `emitEpilogue()`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在实现帧降低时，需要定义两个主要功能 - `emitPrologue()` 和 `emitEpilogue()`。
- en: 'The `emitPrologue()` function can be defined as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`emitPrologue()` 函数可以定义为以下内容：'
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The above function moves over **Machine Basic Block**. It calculates stack size
    for the function, calculates offset for the stack size, and emits instructions
    to set up the frame with a stack register.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的函数遍历 **Machine Basic Block**。它为函数计算栈大小，计算栈大小的偏移量，并发出使用栈寄存器设置帧的指令。
- en: 'Similarly, the `emitEpilogue()` function can be defined as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`emitEpilogue()` 函数可以定义为以下内容：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding function also calculates stack size, over goes the machine basic
    block, and sets up the function frame when returning from the function. Please
    note that the stack here is descending.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数还计算栈大小，遍历机器基本块，并在函数返回时设置函数帧。请注意，这里的栈是递减的。
- en: The `emitPrologue()` function first computes the stack size to determine whether
    the prologue is required at all. Then it adjusts the stack pointer by calculating
    the offset. For the `emitEpilogue()`, it first checks whether the epilogue is
    required or not. Then it restores the stack pointer to what it was at the beginning
    of the function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`emitPrologue()` 函数首先计算栈大小以确定是否需要前置代码。然后它通过计算偏移量来调整栈指针。对于 `emitEpilogue()`，它首先检查是否需要后置代码。然后它将栈指针恢复到函数开始时的状态。'
- en: 'For example, consider this input IR:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个输入 IR：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The TOY assembly generated will look like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 TOY 汇编将看起来像这样：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Lowering instructions
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 降低指令
- en: In this chapter, we will see the implementation of 3 things – Function call
    calling convention, Formal argument calling convention, and Return value calling
    convention. We create a file `TOYISelLowering.cpp`, and implement Instructions
    Lowering in it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到三个方面的实现 - 函数调用约定、形式参数调用约定和返回值调用约定。我们创建一个文件 `TOYISelLowering.cpp`，并在其中实现指令降低。
- en: First, let's look at how a call calling convention can be implemented.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何实现调用约定。
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the above function, we first analyzed the operands of the call, assigned
    a location to each operand, and calculated the size of the argument stack space.
    Then we scanned the `register/memloc` assignment and inserted `copies` and `loads`.
    For our sample target, we support passing arguments through registers or via stack
    (remember the calling convention defined in the previous section). We then emit
    all the stores making sure they happen before call. We build a sequence of `copy-to-reg`
    nodes that copy the outgoing arguments into the appropriate registers. Then, we
    add a register mask operand representing the call-preserved registers. We return
    a chain and a flag for return value copy to use and finally handle result values,
    copying them out of `physregs` into `vregs` that we return.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述函数中，我们首先分析了调用的操作数，为每个操作数分配位置，并计算了参数栈空间的大小。然后，我们扫描`register/memloc`分配，并插入`copies`和`loads`。对于我们的示例目标，我们支持通过寄存器或通过栈传递参数（记住上一节中定义的调用约定）。然后，我们发出所有存储操作，确保它们在调用之前发生。我们构建一系列`copy-to-reg`节点，将输出参数复制到适当的寄存器中。然后，我们添加一个表示调用保留寄存器的寄存器掩码操作数。我们返回一个链和标志，用于返回值复制，并最终处理结果值，将它们从`physregs`复制到我们返回的`vregs`中。
- en: We will now look at the implementation of a formal argument calling convention.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看正式参数调用约定的实现。
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the above implementation of a formal argument calling convention, we assigned
    a location to all the incoming arguments. We handle only the arguments passed
    via a register or a stack. We will now look at the implementation of a return
    value calling convention.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述正式参数调用约定的实现中，我们为所有传入的参数分配了位置。我们只处理通过寄存器或栈传递的参数。我们现在将查看返回值调用约定的实现。
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We first see if we can lower a return. We then gather information about registers
    and stack slots. We copy the result values in the output registers and finally
    return a DAG node for a return value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否可以降低返回值。然后收集有关寄存器和栈槽位的信息。我们将结果值复制到输出寄存器中，并最终返回一个表示返回值的DAG节点。
- en: Printing an instruction
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印指令
- en: Printing an assembly instruction is an important step in generating target code.
    Various classes are defined that work as a gateway to the streamers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 打印汇编指令是生成目标代码的重要步骤。定义了各种类，它们作为流式传输的网关。
- en: 'First, we initialize the class for instruction, assigning the operands, the
    assembly string, pattern, the output variable, and so on in the `TOYInstrFormats.td`
    file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`TOYInstrFormats.td`文件中初始化指令类，分配操作数、汇编字符串、模式、输出变量等：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then, we define functions to print operands in `TOYInstPrinter.cpp`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`TOYInstPrinter.cpp`中定义了打印操作数的函数。
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function simply prints operands, registers, or immediate values, as the
    case may be.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数简单地打印操作数、寄存器或立即值，视情况而定。
- en: 'We also define a function to print the register names in the same file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在同一文件中定义了一个打印寄存器名称的函数：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we define a function to print the instruction:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个打印指令的函数：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we declare and define assembly info as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们如下声明和定义汇编信息：
- en: 'We create a `TOYMCAsmInfo.h` and declare an `ASMInfo` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`TOYMCAsmInfo.h`并声明一个`ASMInfo`类：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The constructor can be defined in `TOYMCAsmInfo.cpp` as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数可以在`TOYMCAsmInfo.cpp`中定义如下：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For compilation, we define `LLVMBuild.txt` as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '对于编译，我们如下定义`LLVMBuild.txt`:'
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Furthermore, we define the `CMakeLists.txt` file as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们定义了`CMakeLists.txt`文件如下：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When the final compilation takes place, the `llc` tool—a static compiler—will
    generate the assembly of the `TOY` architecture (after registering the TOY architecture
    with the `llc` tool).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当最终编译发生时，`llc`工具（一个静态编译器）将生成`TOY`架构的汇编代码（在将`TOY`架构注册到`llc`工具之后）。
- en: 'To register our `TOY` target with static compiler `llc`, follow the steps mentioned
    below:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的`TOY`目标注册到静态编译器`llc`，请遵循以下步骤：
- en: 'First, add the entry of the `TOY` backend to `llvm_root_dir/CMakeLists.txt`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，将`TOY`后端条目添加到`llvm_root_dir/CMakeLists.txt`:'
- en: '[PRE24]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, add the `toy` entry to `llvm_root_dir/include/llvm/ADT/Triple.h`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，将`toy`条目添加到`llvm_root_dir/include/llvm/ADT/Triple.h`:'
- en: '[PRE25]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the `toy` entry to `llvm_root_dir/include/llvm/ MC/MCExpr.h`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将`toy`条目添加到`llvm_root_dir/include/llvm/MC/MCExpr.h`:'
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the `toy` entry to `llvm_root_dir/include/llvm/ Support/ELF.h`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将`toy`条目添加到`llvm_root_dir/include/llvm/Support/ELF.h`:'
- en: '[PRE27]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, add the `toy` entry to `lib/MC/MCExpr.cpp`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，将`toy`条目添加到`lib/MC/MCExpr.cpp`:'
- en: '[PRE28]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, add the `toy` entry to `lib/Support/Triple.cpp`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，将`toy`条目添加到`lib/Support/Triple.cpp`:'
- en: '[PRE29]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the `toy` directory entry to `lib/Target/LLVMBuild.txt`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将`toy`目录条目添加到`lib/Target/LLVMBuild.txt`:'
- en: '[PRE30]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a new file called `TOY.h` in the `lib/Target/TOY` folder:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`lib/Target/TOY`文件夹中创建一个名为`TOY.h`的新文件：
- en: '[PRE31]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a new folder called `TargetInfo` in the `lib/Target/TOY` folder. Inside
    that folder, create a new file called `TOYTargetInfo.cpp`, as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`lib/Target/TOY`文件夹中创建一个名为`TargetInfo`的新文件夹。在该文件夹内，创建一个名为`TOYTargetInfo.cpp`的新文件，如下所示：
- en: '[PRE32]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the same folder, create the `CMakeLists.txt` file:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件夹中创建`CMakeLists.txt`文件：
- en: '[PRE33]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create an `LLVMBuild.txt` file:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`LLVMBuild.txt`文件：
- en: '[PRE34]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `lib/Target/TOY` folder, create a file called `TOYTargetMachine.cpp`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`lib/Target/TOY`文件夹中创建一个名为`TOYTargetMachine.cpp`的文件：
- en: '[PRE35]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a new folder called `MCTargetDesc` and a new file called `TOYMCTargetDesc.h`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MCTargetDesc`的新文件夹和一个名为`TOYMCTargetDesc.h`的新文件：
- en: '[PRE36]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create one more file, called `TOYMCTargetDesc.cpp`, in the same folder:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件夹中再创建一个名为`TOYMCTargetDesc.cpp`的文件：
- en: '[PRE37]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the same folder, create an `LLVMBuild.txt` file:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件夹中创建一个`LLVMBuild.txt`文件：
- en: '[PRE38]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create a CMakeLists.txt file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`CMakeLists.txt`文件：
- en: '[PRE39]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Build the enitre LLVM project, as follows:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按如下方式构建整个LLVM项目：
- en: '[PRE40]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following IR, when given to the `llc` tool, will generate an assembly as
    shown:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下IR，当提供给`llc`工具时，将生成如下的汇编：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To see the details of how to register a target with `llc`, you can visit [http://llvm.org/docs/WritingAnLLVMBackend.html#target-registration](http://llvm.org/docs/WritingAnLLVMBackend.html#target-registration)
    and [http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration](http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration)
    by Chen Chung-Shu and Anoushe Jamshidi.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看如何使用`llc`注册目标的详细信息，您可以访问[http://llvm.org/docs/WritingAnLLVMBackend.html#target-registration](http://llvm.org/docs/WritingAnLLVMBackend.html#target-registration)和[http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration](http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration)由陈中舒和Anoushe
    Jamshidi编写。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had a brief discussion about how a target architecture machine
    can be represented in LLVM. We saw the ease of using tablegen in organizing data
    such as register sets, instruction sets, calling conventions, and so on, for a
    given target. The `llvm-tablegen` then converts these target descriptor `.td`
    fies into enums, which can be used in program logic such as frame lowering, instruction
    selection, instruction printing, and so on. More detailed and complex architectures
    like ARM and X86 can give insight on a detailed description of the target.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要讨论了如何在LLVM中表示目标架构机器。我们看到了使用tablegen组织数据（如寄存器集、指令集、调用约定等）的便捷性，对于给定的目标。然后`llvm-tablegen`将这些目标描述`.td`文件转换为枚举，这些枚举可以在程序逻辑（如帧降低、指令选择、指令打印等）中使用。更详细和复杂的架构，如ARM和X86，可以提供对目标详细描述的见解。
- en: In the first chapter, we tried a basic exercise to get hands-on with various
    tools provided by the LLVM infrastructure. In the subsequent chapters, that is,
    [Chapter 2](part0018_split_000.html#H5A41-684481f6e3394b1e8596d1aa3001290f "Chapter 2. Building
    LLVM IR"), *Building LLVM IR*, and [Chapter 3](part0028_split_000.html#QMFO1-684481f6e3394b1e8596d1aa3001290f
    "Chapter 3. Advanced LLVM IR"), *Advanced LLVM IR*, we used APIs provided by LLVM
    to emit IRs. Readers can use those APIs in their frontend to convert their language
    to LLVM IR. In [Chapter 5](part0041_split_000.html#173722-684481f6e3394b1e8596d1aa3001290f
    "Chapter 5. Advanced IR Block Transformations"), *Advanced IR Block Transformations*,
    we got used to Pass Pipeline for IR optimization and went through some examples.
    In [Chapter 6](part0046_split_000.html#1BRPS2-684481f6e3394b1e8596d1aa3001290f
    "Chapter 6. IR to Selection DAG phase"), *IR to Selection DAG Phase*, readers
    got familiar with the conversion of IR to selection DAG, which is a step towards
    emitting machine code. In this final chapter, we saw how to represent sample architecture
    with tablegen and use it for emitting code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们尝试了一个基本练习，以熟悉LLVM基础设施提供的各种工具。在随后的章节中，即[第二章](part0018_split_000.html#H5A41-684481f6e3394b1e8596d1aa3001290f
    "第二章. 构建LLVM IR")，*构建LLVM IR*和[第三章](part0028_split_000.html#QMFO1-684481f6e3394b1e8596d1aa3001290f
    "第三章. 高级LLVM IR")，*高级LLVM IR*中，我们使用了LLVM提供的API来生成IR。读者可以在他们的前端使用这些API将他们的语言转换为LLVM
    IR。在[第五章](part0041_split_000.html#173722-684481f6e3394b1e8596d1aa3001290f "第五章.
    高级IR块变换")，*高级IR块变换*中，我们习惯了IR优化的Pass Pipeline，并经历了一些示例。在[第六章](part0046_split_000.html#1BRPS2-684481f6e3394b1e8596d1aa3001290f
    "第六章. IR到选择DAG阶段")，*IR到选择DAG阶段*中，读者熟悉了将IR转换为选择DAG的过程，这是生成机器代码的一个步骤。在本章的最后，我们看到了如何使用tablegen表示示例架构并用于生成代码。
- en: After reading this book, we hope that readers become familiar with LLVM infrastructure
    and are ready to dive deeply into LLVM and create compilers on their own for their
    custom architecture or a custom language. Happy Compiling!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完这本书后，我们希望读者能够熟悉 LLVM 基础设施，并准备好深入探索 LLVM，为自己的定制架构或定制语言创建编译器。编译愉快！
