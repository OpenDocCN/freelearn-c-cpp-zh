- en: Chapter 7. Generating Code for Target Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code generated by the compiler finally has to execute on the target machines.
    The abstract form of the LLVM IR helps to generate code for various architectures.
    The target machine can be anything – CPU, GPU, DSP's, and so on. The target machine
    has some defining aspects such as the register sets, the instruction set, the
    calling convention of the function, and the instruction pipeline. These aspects
    or properties are generated using the **tablegen** tool so that they can be used
    easily while programming code generation for the machine.
  prefs: []
  type: TYPE_NORMAL
- en: LLVM has a pipeline structure for the backend, where instructions travel through
    phases—from the LLVM IR to **SelectionDAG**, then to **MachineDAG**, then to **MachineInstr**,
    and finally to **MCInst**. The IR is converted to SelectionDAG. SelectionDAG then
    goes through legalization and optimizations. After this stage, the DAG nodes are
    mapped to target instructions (instruction selection). The DAG then goes through
    instruction scheduling, emitting linear sequences of instructions. The virtual
    registers are then allotted the target machine registers, which involves optimal
    register allocation minimizing memory spills.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes how to represent target architecture. It also describes
    how to emit assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics discussed in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining registers and register sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the calling convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the instruction set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing frame lowering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting an instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing an instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering a target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand target code generation, we define a simple RISC-type architecture
    TOY machine with minimal registers, say `r0-r3`, a stack pointer `SP`, a link
    register, `LR` (for storing the return address); and a `CPSR` – current state
    program register. The calling convention of this toy backend is similar to the
    ARM thumb-like architecture—arguments passed to the function will be stored in
    register sets `r0-r1`, and the return value will be stored in `r0`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining registers and register sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Register sets are defined using the tablegen tool. Tablegen helps to maintain
    large number of records of domain specific information. It factors out the common
    features of these records. This helps in reducing duplication in the description
    and forms a structural way of representing domain information. Please visit [http://llvm.org/docs/TableGen/](http://llvm.org/docs/TableGen/)
    to understand tablegen in detail. `TableGen` files are interpreted by the `TableGen
    binary: llvm-tblgen`.'
  prefs: []
  type: TYPE_NORMAL
- en: We have described our sample backend in the preceding paragraph, which has four
    registers (`r0-r3`), a stack register (`SP`), and a link register (`LR`). These
    can be specified in the `TOYRegisterInfo.td` file. The `tablegen` function provides
    the `Register` class, which can be extended to specify the registers. Create a
    new file named `TOYRegisterInfo.td`.
  prefs: []
  type: TYPE_NORMAL
- en: The registers can be defined by extending the `Register` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The registers `r0-r3` belong to a general purpose `Register` class. This can
    be specified by extending `RegisterClass`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The remainings, register `SP`, `LR`, and `CPSR`, can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When the whole thing is put together, the `TOYRegisterInfo.td` looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can put this file in a new folder named `TOY` in the parent folder named
    `Target` in the llvm's root directory, which is `llvm_root_directory/lib/Target/TOY/
    TOYRegisterInfo.td`
  prefs: []
  type: TYPE_NORMAL
- en: The tablegen tool `llvm-tablegen`, processes this `.td` file to generate the
    `.inc` file, which generally has enums generated for these registers. These enums
    can be used in the `.cpp` files, in which the registers can be referenced as `TOY::R0`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the calling convention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The calling convention specifies how values are passed to and returned from
    a function call. Our `TOY` architecture specifies that two arguments are passed
    in two registers, `r0` and `r1`, while the remaining ones are passed to the stack.
    Calling convention defined is then used in the Instruction Selection phase by
    referring to the function pointer.
  prefs: []
  type: TYPE_NORMAL
- en: While defining a calling convention, we have to represent two sections—one to
    define the convention return value, and other to define the convention for argument
    passing. The parent class `CallingConv` is inherited to define the calling convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `TOY` architecture, the return value is stored in `r0` register. If
    there are more arguments, integer values get stored in stack slots that are 4
    bytes in size and 4-byte aligned. This can be declared in `TOYCallingConv.td`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The argument passing convention can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding declaration says three things, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the datatype of the arguments is `i8` or `i16`, it will get promoted to `i32`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two arguments will be stored in register `r0` and `r1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are more arguments, they will be stored in `Stack`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also define the callee-saved register since callee-saved registers are used
    to hold long-lived values that should be preserved across calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `llvm-tablegen` tool generates a `TOYCallingConv.inc` file after building
    the project, which will be included in the Instruction Selection phase in the
    `TOYISelLowering.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the instruction set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Architectures have rich instruction sets to represent various operations supported
    by the target machine. Typically, three things need to be defined in the target
    description file when representing the instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: operands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the assembly string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the instruction pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specification contains a list of definitions or outputs, and a list of uses
    or inputs. There can be different operand classes, such as the `Register` class,
    and the immediate and more complex `register+imm` operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we define register to register addition for our Toy machine as
    follows in `TOYInstrInfo.td`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above declaration, the ''`ins`'' has two registers `$src1` and `$src2`
    belonging to the general purpose register class, which holds the two operands.
    The result of the operation will be put into ''`outs`'', which is a `$dst` register
    belonging to the general purpose `Register` class. The assembly string is "`add
    $dst, $src1,z$src2`". The values of `$src1`, `$src2` and `$dst` will be determined
    at the time of register allocation. So, an assembly will be generated for `add`
    between two registers, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We saw above how a simple instruction can be represented using tablegen. Similar
    to the `add register to register` instruction, a `subtract register from a register`
    instruction can be defined. We leave it to the readers to try it out. A more detailed
    representation of complex instructions can be examined from the ARM or X86 architecture
    specifications in the project code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing frame lowering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frame lowering involves emitting function prologue and epilogue. The prologue
    happens at the beginning of a function. It sets up the stack frame of the called
    function. The epilogue happens last in a function, it restores the stack frame
    of the calling (parent) function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The "`stack`" serves several purposes in the execution of a program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of return address, when calling a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage of local variables in the context of a function call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing arguments from the caller to the callee.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus there are 2 main functions that need to be defined when implementing frame
    lowering – `emitPrologue()` and `emitEpilogue()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `emitPrologue()` function can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The above function moves over **Machine Basic Block**. It calculates stack size
    for the function, calculates offset for the stack size, and emits instructions
    to set up the frame with a stack register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `emitEpilogue()` function can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function also calculates stack size, over goes the machine basic
    block, and sets up the function frame when returning from the function. Please
    note that the stack here is descending.
  prefs: []
  type: TYPE_NORMAL
- en: The `emitPrologue()` function first computes the stack size to determine whether
    the prologue is required at all. Then it adjusts the stack pointer by calculating
    the offset. For the `emitEpilogue()`, it first checks whether the epilogue is
    required or not. Then it restores the stack pointer to what it was at the beginning
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this input IR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The TOY assembly generated will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Lowering instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will see the implementation of 3 things – Function call
    calling convention, Formal argument calling convention, and Return value calling
    convention. We create a file `TOYISelLowering.cpp`, and implement Instructions
    Lowering in it.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's look at how a call calling convention can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the above function, we first analyzed the operands of the call, assigned
    a location to each operand, and calculated the size of the argument stack space.
    Then we scanned the `register/memloc` assignment and inserted `copies` and `loads`.
    For our sample target, we support passing arguments through registers or via stack
    (remember the calling convention defined in the previous section). We then emit
    all the stores making sure they happen before call. We build a sequence of `copy-to-reg`
    nodes that copy the outgoing arguments into the appropriate registers. Then, we
    add a register mask operand representing the call-preserved registers. We return
    a chain and a flag for return value copy to use and finally handle result values,
    copying them out of `physregs` into `vregs` that we return.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at the implementation of a formal argument calling convention.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the above implementation of a formal argument calling convention, we assigned
    a location to all the incoming arguments. We handle only the arguments passed
    via a register or a stack. We will now look at the implementation of a return
    value calling convention.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We first see if we can lower a return. We then gather information about registers
    and stack slots. We copy the result values in the output registers and finally
    return a DAG node for a return value.
  prefs: []
  type: TYPE_NORMAL
- en: Printing an instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Printing an assembly instruction is an important step in generating target code.
    Various classes are defined that work as a gateway to the streamers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we initialize the class for instruction, assigning the operands, the
    assembly string, pattern, the output variable, and so on in the `TOYInstrFormats.td`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then, we define functions to print operands in `TOYInstPrinter.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This function simply prints operands, registers, or immediate values, as the
    case may be.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also define a function to print the register names in the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a function to print the instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we declare and define assembly info as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a `TOYMCAsmInfo.h` and declare an `ASMInfo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor can be defined in `TOYMCAsmInfo.cpp` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For compilation, we define `LLVMBuild.txt` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we define the `CMakeLists.txt` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When the final compilation takes place, the `llc` tool—a static compiler—will
    generate the assembly of the `TOY` architecture (after registering the TOY architecture
    with the `llc` tool).
  prefs: []
  type: TYPE_NORMAL
- en: 'To register our `TOY` target with static compiler `llc`, follow the steps mentioned
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the entry of the `TOY` backend to `llvm_root_dir/CMakeLists.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the `toy` entry to `llvm_root_dir/include/llvm/ADT/Triple.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `toy` entry to `llvm_root_dir/include/llvm/ MC/MCExpr.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `toy` entry to `llvm_root_dir/include/llvm/ Support/ELF.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the `toy` entry to `lib/MC/MCExpr.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the `toy` entry to `lib/Support/Triple.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `toy` directory entry to `lib/Target/LLVMBuild.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file called `TOY.h` in the `lib/Target/TOY` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new folder called `TargetInfo` in the `lib/Target/TOY` folder. Inside
    that folder, create a new file called `TOYTargetInfo.cpp`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same folder, create the `CMakeLists.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `LLVMBuild.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `lib/Target/TOY` folder, create a file called `TOYTargetMachine.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new folder called `MCTargetDesc` and a new file called `TOYMCTargetDesc.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create one more file, called `TOYMCTargetDesc.cpp`, in the same folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same folder, create an `LLVMBuild.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a CMakeLists.txt file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the enitre LLVM project, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following IR, when given to the `llc` tool, will generate an assembly as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: To see the details of how to register a target with `llc`, you can visit [http://llvm.org/docs/WritingAnLLVMBackend.html#target-registration](http://llvm.org/docs/WritingAnLLVMBackend.html#target-registration)
    and [http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration](http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration)
    by Chen Chung-Shu and Anoushe Jamshidi.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a brief discussion about how a target architecture machine
    can be represented in LLVM. We saw the ease of using tablegen in organizing data
    such as register sets, instruction sets, calling conventions, and so on, for a
    given target. The `llvm-tablegen` then converts these target descriptor `.td`
    fies into enums, which can be used in program logic such as frame lowering, instruction
    selection, instruction printing, and so on. More detailed and complex architectures
    like ARM and X86 can give insight on a detailed description of the target.
  prefs: []
  type: TYPE_NORMAL
- en: In the first chapter, we tried a basic exercise to get hands-on with various
    tools provided by the LLVM infrastructure. In the subsequent chapters, that is,
    [Chapter 2](part0018_split_000.html#H5A41-684481f6e3394b1e8596d1aa3001290f "Chapter 2. Building
    LLVM IR"), *Building LLVM IR*, and [Chapter 3](part0028_split_000.html#QMFO1-684481f6e3394b1e8596d1aa3001290f
    "Chapter 3. Advanced LLVM IR"), *Advanced LLVM IR*, we used APIs provided by LLVM
    to emit IRs. Readers can use those APIs in their frontend to convert their language
    to LLVM IR. In [Chapter 5](part0041_split_000.html#173722-684481f6e3394b1e8596d1aa3001290f
    "Chapter 5. Advanced IR Block Transformations"), *Advanced IR Block Transformations*,
    we got used to Pass Pipeline for IR optimization and went through some examples.
    In [Chapter 6](part0046_split_000.html#1BRPS2-684481f6e3394b1e8596d1aa3001290f
    "Chapter 6. IR to Selection DAG phase"), *IR to Selection DAG Phase*, readers
    got familiar with the conversion of IR to selection DAG, which is a step towards
    emitting machine code. In this final chapter, we saw how to represent sample architecture
    with tablegen and use it for emitting code.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this book, we hope that readers become familiar with LLVM infrastructure
    and are ready to dive deeply into LLVM and create compilers on their own for their
    custom architecture or a custom language. Happy Compiling!
  prefs: []
  type: TYPE_NORMAL
