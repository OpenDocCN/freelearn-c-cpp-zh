- en: Chapter 3. Extending the Frontend and Adding JIT Support
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 扩展前端和添加JIT支持
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Handling decision making paradigms – if/then/else constructs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理决策范式 - `if/then/else`结构
- en: Generating code for loops
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成循环代码
- en: Handling user-defined operators – binary operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户定义的运算符 - 二元运算符
- en: Handling user-defined operators – unary operators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户定义的运算符 - 一元运算符
- en: Adding JIT support
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加JIT支持
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the last chapter, the basics of the frontend component for a language were
    defined. This included defining tokens for different types of expressions, writing
    a lexer to tokenize a stream of input, chalking out a skeleton for the abstract
    syntax tree of various expressions, writing a parser, and generating code for
    the language. Also, how various optimizations can be hooked to the frontend was
    explained.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，定义了语言前端组件的基本。这包括为不同类型的表达式定义标记，编写一个词法分析器来标记输入流，为各种表达式的抽象语法树勾勒出框架，编写解析器，并为语言生成代码。还解释了如何将各种优化连接到前端。
- en: A language is more powerful and expressive when it has control flow and loops
    to decide the flow of a program. JIT support explores the possibility of compiling
    code on-the-fly. In this chapter, implementation of these more sophisticated programming
    paradigms will be discussed. This chapter deals with enhancements of a programming
    language that make it more meaningful and powerful to use. The recipes in this
    chapter demonstrate how to include those enhancements for a given language.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当一种语言具有控制流和循环来决定程序流程时，它就更加强大和表达。JIT支持探索了即时编译代码的可能性。在本章中，将讨论这些更复杂的编程范式的实现。本章处理了使编程语言更有意义和强大的增强。本章中的食谱展示了如何为给定的语言包含这些增强。
- en: Handling decision making paradigms – if/then/else constructs
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理决策范式 - `if/then/else`结构
- en: In any programming language, executing a statement based on certain conditions
    gives a very powerful advantage to the language. The `if`/`then`/`else` constructs
    provide the capability to alter the control flow of a program, based on certain
    conditions. The condition is present in an `if` construct. If the condition is
    true, the expression following the `then` construct is executed. If it is `false`,
    the expression following the `else` construct is executed. This recipe demonstrates
    a basic infrastructure to parse and generate code for the `if`/`then`/`else` construct.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中，根据某些条件执行语句给语言带来了非常强大的优势。`if`/`then`/`else`结构提供了根据某些条件改变程序控制流的能力。条件存在于`if`结构中。如果条件为真，则执行`then`结构之后的表达式。如果它是`false`，则执行`else`结构之后的表达式。这个食谱演示了解析和生成`if`/`then`/`else`结构代码的基本基础设施。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The TOY language for `if`/`then`/`else` can be defined as:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`if`/`then`/`else`的TOY语言可以定义为：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For checking a condition, a comparison operator is required. A simple *less
    than* operator, `<`, will serve the purpose. To handle `<`, precedence needs to
    be defined in the `init_precedence()` function, as shown here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查条件，需要一个比较运算符。一个简单的`<`（小于）运算符将满足这个目的。为了处理`<`，需要在`init_precedence()`函数中定义优先级，如下所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also, the `codegen()` function for binary expressions needs to be included
    for `<`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还需要包含二进制表达式的`codegen()`函数以处理`<`：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, the LLVM IR will generate a comparison instruction and a Boolean instruction
    as a result of the comparison, which will be used to determine where the control
    of the program will flow. It's time to handle the `if`/`then`/`else` paradigm
    now.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，LLVM IR将生成一个比较指令和一个布尔指令作为比较的结果，这将用于确定程序控制流的方向。现在是时候处理`if`/`then`/`else`范式了。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Do the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'The lexer in the `toy.cpp` file has to be extended to handle the `if`/`then`/`else`
    constructs. This can be done by appending a token for this in the `enum` of tokens:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`toy.cpp`文件中的词法分析器需要扩展以处理`if`/`then`/`else`结构。这可以通过在`enum`标记中添加一个标记来完成：'
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next step is to append the entries for these tokens in the `get_token()`
    function, where we match strings and return the appropriate tokens:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在`get_token()`函数中添加这些标记的条目，其中我们匹配字符串并返回适当的标记：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we define an AST node in the `toy.cpp` file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在`toy.cpp`文件中定义一个AST节点：
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next step is to define the parsing logic for the `if`/`then`/`else` constructs:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是定义`if`/`then`/`else`结构的解析逻辑：
- en: '[PRE6]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The parser logic is simple: first, the `if` token is searched for and the expression
    following it is parsed for the condition. After that, the `then` token is identified
    and the true condition expression is parsed. Then the `else` token is searched
    for and the false condition expression is parsed.'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解析器的逻辑很简单：首先，搜索`if`标记，并解析其后的表达式作为条件。之后，识别`then`标记并解析真条件表达式。然后搜索`else`标记并解析假条件表达式。
- en: 'Next we hook up the previously defined function with `Base_Parser()`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们将之前定义的函数与`Base_Parser()`连接起来：
- en: '[PRE7]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that the AST of `if`/`then`/`else` is filled with the expression by the
    parser, it''s time to generate the LLVM IR for the conditional paradigm. Let''s
    define the `Codegen()` function:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在已经通过解析器将`if`/`then`/`else`的AST填充了表达式，是时候生成条件范式的LLVM IR了。让我们定义`Codegen()`函数：
- en: '[PRE8]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we are ready with the code, let's compile and run it on a sample program
    containing the `if`/`then`/`else` constructs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了代码，让我们在一个包含`if`/`then`/`else`结构的示例程序上编译并运行它。
- en: How it works…
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'Do the following steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Compile the `toy.cpp` file:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译`toy.cpp`文件：
- en: '[PRE9]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open an example file:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个示例文件：
- en: '[PRE10]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Write the following `if`/`then`/`else` code in the example file:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例文件中编写以下`if`/`then`/`else`代码：
- en: '[PRE11]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Compile the example file with the TOY compiler:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用TOY编译器编译示例文件：
- en: '[PRE12]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The LLVM IR generated for the `if`/`then`/`else` code will look like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为`if`/`then`/`else`代码生成的LLVM IR看起来如下：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s what the output looks like:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果的样子：
- en: '![How it works…](img/image00254.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/image00254.jpeg)'
- en: The parser identifies the `if`/`then`/`else` constructs and the statements that
    are to be executed in true and false conditions, and stores them in the AST. The
    code generator then converts the AST into LLVM IR, where the condition statement
    is generated. IR is generated for true as well as false conditions. Depending
    on the state of the condition variable, the appropriate statement is executed
    at runtime.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器识别`if`/`then`/`else`结构和在真和假条件下要执行的语句，并将它们存储在AST中。然后代码生成器将AST转换为LLVM IR，其中生成条件语句。为真和假条件都生成了IR。根据条件变量的状态，在运行时执行适当的语句。
- en: See also
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For a detailed example on how an `if else` statement is handled in C++ by Clang,
    refer to [http://clang.llvm.org/doxygen/classclang_1_1IfStmt.html](http://clang.llvm.org/doxygen/classclang_1_1IfStmt.html).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Clang如何处理C++中的`if else`语句的详细示例，请参阅[http://clang.llvm.org/doxygen/classclang_1_1IfStmt.html](http://clang.llvm.org/doxygen/classclang_1_1IfStmt.html)。
- en: Generating code for loops
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成循环的代码
- en: Loops make a language powerful enough to perform the same operation several
    times, with limited lines of code. Loops are present in almost every language.
    This recipe demonstrates how loops are handled in the TOY language.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 循环使语言足够强大，可以在有限的代码行数内执行相同的操作多次。几乎每种语言都有循环。这个示例展示了在TOY语言中如何处理循环。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'A loop typically has a start that initializes the induction variable, a step
    that indicates an increment or decrement in the induction variable, and an end
    condition for termination of the loop. The loop in our TOY language can be defined
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 循环通常有一个初始化归纳变量的起始点，一个指示归纳变量增加或减少的步长，以及一个终止循环的结束条件。在我们的TOY语言中，循环可以定义为以下内容：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The start expression is the initialization of `i = 1`. The end condition for
    the loop is `i<n`. The first line of the code indicates `i` be incremented by
    `1`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 起始表达式是`i = 1`的初始化。循环的结束条件是`i<n`。代码的第一行表示`i`增加`1`。
- en: 'As long as the end condition is true, the loop iterates and, after each iteration,
    the induction variable, `i`, is incremented by 1\. An interesting thing called
    **PHI** node comes into the picture to decide which value the induction variable,
    `i`, will take. Remember that our IR is in the **single static assignment** (**SSA**)
    form. In a control flow graph, for a given variable, the values can come from
    two different blocks. To represent SSA in LLVM IR, the `phi` instruction is defined.
    Here is an example of `phi`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 只要结束条件为真，循环就会迭代，并且在每次迭代后，归纳变量`i`会增加1。一个有趣的现象叫做**PHI**节点，它将决定归纳变量`i`将取哪个值。记住，我们的IR是**单赋值**（**SSA**）形式。在控制流图中，对于给定的变量，其值可能来自两个不同的块。为了在LLVM
    IR中表示SSA，定义了`phi`指令。以下是一个`phi`的例子：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding IR indicates that the value for `i` can come from two basic blocks:
    `%entry` and `%loop`. The value from the `%entry` block will be `1`, while the
    `%nextvar` variable will be from `%loop`. We will see the details after implementing
    the loop for our toy compiler.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述IR表明`i`的值可以来自两个基本块：`%entry`和`%loop`。`%entry`块的值将是`1`，而`%nextvar`变量将来自`%loop`。我们将在实现我们的玩具编译器的循环后看到详细信息。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Like any other expression, loops are also handled by including states in lexer,
    defining the AST data structure to hold loop values, and defining the parser and
    the `Codegen()` function to generate the LLVM IR:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何其他表达式一样，循环也是通过在词法分析器中包含状态、定义用于存储循环值的AST数据结构以及定义解析器和`Codegen()`函数来生成LLVM IR来处理的：
- en: 'The first step is to define tokens in the lexer in `toy.cpp` file:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是在`toy.cpp`文件中的词法分析器中定义标记：
- en: '[PRE16]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we include the logic in the lexer:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在词法分析器中包含逻辑：
- en: '[PRE17]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next step is to define the AST for the `for` loop:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是定义`for`循环的AST：
- en: '[PRE18]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we define the parser logic for the loop:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义循环的解析逻辑：
- en: '[PRE19]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next we define the `Codegen()` function to generate the LLVM IR:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们定义`Codegen()`函数以生成LLVM IR：
- en: '[PRE20]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Do the following steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Compile the `toy.cpp` file:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译`toy.cpp`文件：
- en: '[PRE21]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open an example file:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个示例文件：
- en: '[PRE22]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Write the following code for a `for` loop in the example file:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例文件中为`for`循环编写以下代码：
- en: '[PRE23]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Compile the example file with the TOY compiler:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用TOY编译器编译示例文件：
- en: '[PRE24]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The LLVM IR for the preceding `for` loop code will be generated, as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下`for`循环代码的LLVM IR如下：
- en: '[PRE25]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The parser you just saw identifies the loop, initialization of the induction
    variable, the termination condition, the step value for the induction variable,
    and the body of the loop. It then converts each of the blocks in LLVM IR, as seen
    previously.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才看到的解析器识别了循环、归纳变量的初始化、终止条件、归纳变量的步长值以及循环体。然后它将LLVM IR中每个块转换为前面看到的。
- en: 'As seen previously, a `phi` instruction gets two values for the variable `i`
    from two basic blocks: `%entry` and `%loop`. In the preceding case, the `%entry`
    block represents the value assigned to the induction variable at the start of
    the loop (this is `1`). The next updated value of `i` comes from the `%loop` block,
    which completes one iteration of the loop.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一个`phi`指令从两个基本块`%entry`和`%loop`中为变量`i`获取两个值。在前面的例子中，`%entry`块表示循环开始时分配给归纳变量的值（这是`1`）。`i`的下一个更新值来自`%loop`块，它完成了循环的一次迭代。
- en: See also
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To get a detailed overview of how loops are handled for C++ in Clang, visit
    [http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Parse/ParseExprCXX.cpp](http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Parse/ParseExprCXX.cpp)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要详细了解Clang中如何处理C++中的循环，请访问[http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Parse/ParseExprCXX.cpp](http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Parse/ParseExprCXX.cpp)
- en: Handling user-defined operators – binary operators
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户定义的操作符 - 二元操作符
- en: User-defined operators are similar to the C++ concept of operator overloading,
    where a default definition of an operator is altered to operate on a wide variety
    of objects. Typically, operators are unary or binary operators. Implementing binary
    operator overloading is easier with the existing infrastructure. Unary operators
    need some additional code to handle. First, binary operator overloading will be
    defined, and then unary operator overloading will be looked into.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的操作符类似于C++中的操作符重载概念，其中默认的操作符定义被修改以在多种对象上操作。通常，操作符是一元或二元操作符。使用现有基础设施实现二元操作符重载更容易。一元操作符需要一些额外的代码来处理。首先，将定义二元操作符重载，然后研究一元操作符重载。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The first part is to define a binary operator for overloading. The logical
    OR operator (`|`) is a good example to start with. The `|` operator in our TOY
    language can be used as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是定义一个用于重载的二进制操作符。逻辑或操作符（`|`）是一个很好的起点。在我们的TOY语言中，`|`操作符可以如下使用：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As seen in the preceding code, if any of the values of the LHS or RHS are not
    equal to 0, then we return `1`. If both the LHS and RHS are null, then we return
    `0`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果LHS或RHS的任何值不等于0，则返回`1`。如果LHS和RHS都为null，则返回`0`。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Do the following steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'The first step, as usual, is to append the `enum` states for the binary operator
    and return the enum states on encountering the `binary` keyword:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步，像往常一样，是追加二元操作符的`enum`状态，并在遇到`binary`关键字时返回枚举状态：
- en: '[PRE27]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next step is to add an AST for the same. Note that it doesn''t need a new
    AST to be defined. It can be handled with the function declaration AST. We just
    need to modify it by adding a flag to represent whether it''s a binary operator.
    If it is, then determine its precedence:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是为同一运算符添加AST。请注意，不需要定义新的AST。它可以由函数声明AST处理。我们只需要通过添加一个标志来修改它，以表示它是否为二进制运算符。如果是，则确定其优先级：
- en: '[PRE28]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once the modified AST is ready, the next step is to modify the parser of the
    function declaration:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦修改后的AST准备好了，下一步是修改函数声明的解析器：
- en: '[PRE29]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then we modify the `Codegen()` function for the binary AST:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们修改二进制AST的`Codegen()`函数：
- en: '[PRE30]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next we modify the function definition; it can be defined as:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步我们修改函数定义；它可以定义为：
- en: '[PRE31]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Do the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Compile the `toy.cpp` file:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译`toy.cpp`文件：
- en: '[PRE32]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Open an example file:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个示例文件：
- en: '[PRE33]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Write the following binary operator overloading code in the example file:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例文件中编写以下二进制运算符重载代码：
- en: '[PRE34]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Compile the example file with the TOY compiler:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用TOY编译器编译示例文件：
- en: '[PRE35]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The binary operator we just defined will be parsed. Its definition is also parsed.
    Whenever the `|` binary operator is encountered, the LHS and RHS are initialized
    and the definition body is executed, giving the appropriate result as per the
    definition. In the preceding example, if either the LHS or RHS is nonzero, then
    the result is `1`. If both the LHS and RHS are zero, then the result is `0`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义的二进制运算符将被解析。其定义也将被解析。每当遇到`|`二进制运算符时，LHS和RHS将被初始化，并执行定义体，根据定义给出适当的结果。在上面的示例中，如果LHS或RHS中任意一个不为零，则结果为`1`。如果LHS和RHS都为零，则结果为`0`。
- en: See also
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For detailed examples on handling other binary operators, refer to [http://llvm.org/docs/tutorial/LangImpl6.html](http://llvm.org/docs/tutorial/LangImpl6.html)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关处理其他二进制运算符的详细示例，请参阅[http://llvm.org/docs/tutorial/LangImpl6.html](http://llvm.org/docs/tutorial/LangImpl6.html)
- en: Handling user-defined operators – unary operators
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户定义的运算符 - 一元运算符
- en: We saw in the previous recipe how binary operators can be handled. A language
    may also have some unary operator, operating on 1 operand. In this recipe, we
    will see how to handle unary operators.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在先前的配方中看到了如何处理二进制运算符。一种语言也可能有一些一元运算符，它们对一个操作数进行操作。在这个配方中，我们将看到如何处理一元运算符。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The first step is to define a unary operator in the TOY language. A simple
    unary NOT operator (`!`) can serve as a good example; let''s see one definition:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在TOY语言中定义一元运算符。一个简单的NOT一元运算符（`!`）可以作为一个很好的例子；让我们看看一个定义：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If the value `v` is equal to `1`, then `0` is returned. If the value is `0`,
    `1` is returned as the output.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值`v`等于`1`，则返回`0`。如果值是`0`，则输出`1`。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Do the following steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'The first step is to define the `enum` token for the unary operator in the
    `toy.cpp` file:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是在`toy.cpp`文件中定义一元运算符的`enum`标记：
- en: '[PRE37]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then we identify the unary string and return a unary token:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们识别一元字符串并返回一个一元标记：
- en: '[PRE38]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we define an AST for the unary operator:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为一元运算符定义AST：
- en: '[PRE39]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The AST is now ready. Let''s define a parser for the unary operator:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AST现在准备好了。让我们为一元运算符定义一个解析器：
- en: '[PRE40]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next step is to call the `unary_parser()` function from the binary operator
    parser:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是从二进制运算符解析器中调用`unary_parser()`函数：
- en: '[PRE41]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now let''s call the `unary_parser()` function from the expression parser:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们从表达式解析器中调用`unary_parser()`函数：
- en: '[PRE42]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we modify the function declaration parser:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们修改函数声明解析器：
- en: '[PRE43]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The final step is to define the `Codegen()` function for the unary operator:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是为一元运算符定义`Codegen()`函数：
- en: '[PRE44]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Do the following steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Compile the `toy.cpp` file:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译`toy.cpp`文件：
- en: '[PRE45]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Open an example file:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个示例文件：
- en: '[PRE46]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Write the following unary operator overloading code in the example file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例文件中编写以下一元运算符重载代码：
- en: '[PRE47]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Compile the example file with the TOY compiler:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用TOY编译器编译示例文件：
- en: '[PRE48]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output should be as shown:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE49]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The unary operator defined by the user will be parsed, and IR will be generated
    for it. In the case you just saw, if the unary operand is not zero then the result
    is `0`. If the operand is zero, then the result is `1`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的一元运算符将被解析，并为它生成IR。在你刚才看到的例子中，如果一元操作数不为零，则结果为`0`。如果操作数为零，则结果为`1`。
- en: See also
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more detailed implementations of unary operators, visit [http://llvm.org/docs/tutorial/LangImpl6.html](http://llvm.org/docs/tutorial/LangImpl6.html)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解一元运算符的更详细实现，请访问 [http://llvm.org/docs/tutorial/LangImpl6.html](http://llvm.org/docs/tutorial/LangImpl6.html)
- en: Adding JIT support
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 JIT 支持
- en: A wide variety of tools can be applied to LLVM IR. For example, as demonstrated
    in [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. LLVM Design and Use"), *LLVM
    Design and Use*, the IR can be dumped into bitcode or into an assembly. An optimization
    tool called opt can be run on IR. IR acts as the common platform—an abstract layer
    for all of these tools.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将各种工具应用于 LLVM IR。例如，正如在[第1章](part0015.xhtml#aid-E9OE1 "第1章. LLVM 设计和使用")中所示，*LLVM
    设计和使用*，IR 可以被转换为位码或汇编。可以在 IR 上运行一个名为 opt 的优化工具。IR 作为通用平台——所有这些工具的抽象层。
- en: JIT support can also be added. It immediately evaluates the top-level expressions
    typed in. For example, `1 + 2;`, as soon as it is typed in, evaluates the code
    and prints the value as `3`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可以添加 JIT 支持。它立即评估输入的最高级表达式。例如，`1 + 2;`，一旦输入，就会评估代码并打印出值 `3`。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Do the following steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Define a static global variable for the execution engine in the `toy.cpp` file:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `toy.cpp` 文件中为执行引擎定义一个静态全局变量：
- en: '[PRE50]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the `toy.cpp` file''s `main()` function, write the code for JIT:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `toy.cpp` 文件的 `main()` 函数中，编写 JIT 代码：
- en: '[PRE51]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Modify the top-level expression parser in the `toy.cpp` file:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `toy.cpp` 文件中的顶层表达式解析器：
- en: '[PRE52]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Do the following steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Compile the `toy.cpp` program:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译 `toy.cpp` 程序：
- en: '[PRE53]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Open an example file:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个示例文件：
- en: '[PRE54]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Write the following TOY code in the example file:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例文件中编写以下 TOY 代码：
- en: '[PRE55]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, run the TOY compiler on the example file:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在示例文件上运行 TOY 编译器：
- en: '[PRE56]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The LLVM JIT compiler matches the native platform ABI, casts the result pointer
    into a function pointer of that type, and calls it directly. There is no difference
    between JIT-compiled code and native machine code that is statically linked to
    the application.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM JIT 编译器匹配原生平台 ABI，将结果指针转换为该类型的函数指针，并直接调用它。JIT 编译的代码与与应用程序静态链接的原生机器代码之间没有区别。
