- en: Chapter 3. Extending the Frontend and Adding JIT Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling decision making paradigms – if/then/else constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating code for loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling user-defined operators – binary operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling user-defined operators – unary operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding JIT support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, the basics of the frontend component for a language were
    defined. This included defining tokens for different types of expressions, writing
    a lexer to tokenize a stream of input, chalking out a skeleton for the abstract
    syntax tree of various expressions, writing a parser, and generating code for
    the language. Also, how various optimizations can be hooked to the frontend was
    explained.
  prefs: []
  type: TYPE_NORMAL
- en: A language is more powerful and expressive when it has control flow and loops
    to decide the flow of a program. JIT support explores the possibility of compiling
    code on-the-fly. In this chapter, implementation of these more sophisticated programming
    paradigms will be discussed. This chapter deals with enhancements of a programming
    language that make it more meaningful and powerful to use. The recipes in this
    chapter demonstrate how to include those enhancements for a given language.
  prefs: []
  type: TYPE_NORMAL
- en: Handling decision making paradigms – if/then/else constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any programming language, executing a statement based on certain conditions
    gives a very powerful advantage to the language. The `if`/`then`/`else` constructs
    provide the capability to alter the control flow of a program, based on certain
    conditions. The condition is present in an `if` construct. If the condition is
    true, the expression following the `then` construct is executed. If it is `false`,
    the expression following the `else` construct is executed. This recipe demonstrates
    a basic infrastructure to parse and generate code for the `if`/`then`/`else` construct.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The TOY language for `if`/`then`/`else` can be defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For checking a condition, a comparison operator is required. A simple *less
    than* operator, `<`, will serve the purpose. To handle `<`, precedence needs to
    be defined in the `init_precedence()` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the `codegen()` function for binary expressions needs to be included
    for `<`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, the LLVM IR will generate a comparison instruction and a Boolean instruction
    as a result of the comparison, which will be used to determine where the control
    of the program will flow. It's time to handle the `if`/`then`/`else` paradigm
    now.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The lexer in the `toy.cpp` file has to be extended to handle the `if`/`then`/`else`
    constructs. This can be done by appending a token for this in the `enum` of tokens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to append the entries for these tokens in the `get_token()`
    function, where we match strings and return the appropriate tokens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we define an AST node in the `toy.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to define the parsing logic for the `if`/`then`/`else` constructs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parser logic is simple: first, the `if` token is searched for and the expression
    following it is parsed for the condition. After that, the `then` token is identified
    and the true condition expression is parsed. Then the `else` token is searched
    for and the false condition expression is parsed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next we hook up the previously defined function with `Base_Parser()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the AST of `if`/`then`/`else` is filled with the expression by the
    parser, it''s time to generate the LLVM IR for the conditional paradigm. Let''s
    define the `Codegen()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we are ready with the code, let's compile and run it on a sample program
    containing the `if`/`then`/`else` constructs.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the `toy.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open an example file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the following `if`/`then`/`else` code in the example file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the example file with the TOY compiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The LLVM IR generated for the `if`/`then`/`else` code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/image00254.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The parser identifies the `if`/`then`/`else` constructs and the statements that
    are to be executed in true and false conditions, and stores them in the AST. The
    code generator then converts the AST into LLVM IR, where the condition statement
    is generated. IR is generated for true as well as false conditions. Depending
    on the state of the condition variable, the appropriate statement is executed
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a detailed example on how an `if else` statement is handled in C++ by Clang,
    refer to [http://clang.llvm.org/doxygen/classclang_1_1IfStmt.html](http://clang.llvm.org/doxygen/classclang_1_1IfStmt.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating code for loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loops make a language powerful enough to perform the same operation several
    times, with limited lines of code. Loops are present in almost every language.
    This recipe demonstrates how loops are handled in the TOY language.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A loop typically has a start that initializes the induction variable, a step
    that indicates an increment or decrement in the induction variable, and an end
    condition for termination of the loop. The loop in our TOY language can be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The start expression is the initialization of `i = 1`. The end condition for
    the loop is `i<n`. The first line of the code indicates `i` be incremented by
    `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as the end condition is true, the loop iterates and, after each iteration,
    the induction variable, `i`, is incremented by 1\. An interesting thing called
    **PHI** node comes into the picture to decide which value the induction variable,
    `i`, will take. Remember that our IR is in the **single static assignment** (**SSA**)
    form. In a control flow graph, for a given variable, the values can come from
    two different blocks. To represent SSA in LLVM IR, the `phi` instruction is defined.
    Here is an example of `phi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding IR indicates that the value for `i` can come from two basic blocks:
    `%entry` and `%loop`. The value from the `%entry` block will be `1`, while the
    `%nextvar` variable will be from `%loop`. We will see the details after implementing
    the loop for our toy compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like any other expression, loops are also handled by including states in lexer,
    defining the AST data structure to hold loop values, and defining the parser and
    the `Codegen()` function to generate the LLVM IR:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to define tokens in the lexer in `toy.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we include the logic in the lexer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to define the AST for the `for` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we define the parser logic for the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next we define the `Codegen()` function to generate the LLVM IR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the `toy.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open an example file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the following code for a `for` loop in the example file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the example file with the TOY compiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The LLVM IR for the preceding `for` loop code will be generated, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The parser you just saw identifies the loop, initialization of the induction
    variable, the termination condition, the step value for the induction variable,
    and the body of the loop. It then converts each of the blocks in LLVM IR, as seen
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen previously, a `phi` instruction gets two values for the variable `i`
    from two basic blocks: `%entry` and `%loop`. In the preceding case, the `%entry`
    block represents the value assigned to the induction variable at the start of
    the loop (this is `1`). The next updated value of `i` comes from the `%loop` block,
    which completes one iteration of the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a detailed overview of how loops are handled for C++ in Clang, visit
    [http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Parse/ParseExprCXX.cpp](http://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Parse/ParseExprCXX.cpp)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling user-defined operators – binary operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User-defined operators are similar to the C++ concept of operator overloading,
    where a default definition of an operator is altered to operate on a wide variety
    of objects. Typically, operators are unary or binary operators. Implementing binary
    operator overloading is easier with the existing infrastructure. Unary operators
    need some additional code to handle. First, binary operator overloading will be
    defined, and then unary operator overloading will be looked into.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first part is to define a binary operator for overloading. The logical
    OR operator (`|`) is a good example to start with. The `|` operator in our TOY
    language can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the preceding code, if any of the values of the LHS or RHS are not
    equal to 0, then we return `1`. If both the LHS and RHS are null, then we return
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step, as usual, is to append the `enum` states for the binary operator
    and return the enum states on encountering the `binary` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to add an AST for the same. Note that it doesn''t need a new
    AST to be defined. It can be handled with the function declaration AST. We just
    need to modify it by adding a flag to represent whether it''s a binary operator.
    If it is, then determine its precedence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the modified AST is ready, the next step is to modify the parser of the
    function declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we modify the `Codegen()` function for the binary AST:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next we modify the function definition; it can be defined as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the `toy.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open an example file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the following binary operator overloading code in the example file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the example file with the TOY compiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The binary operator we just defined will be parsed. Its definition is also parsed.
    Whenever the `|` binary operator is encountered, the LHS and RHS are initialized
    and the definition body is executed, giving the appropriate result as per the
    definition. In the preceding example, if either the LHS or RHS is nonzero, then
    the result is `1`. If both the LHS and RHS are zero, then the result is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For detailed examples on handling other binary operators, refer to [http://llvm.org/docs/tutorial/LangImpl6.html](http://llvm.org/docs/tutorial/LangImpl6.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling user-defined operators – unary operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw in the previous recipe how binary operators can be handled. A language
    may also have some unary operator, operating on 1 operand. In this recipe, we
    will see how to handle unary operators.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to define a unary operator in the TOY language. A simple
    unary NOT operator (`!`) can serve as a good example; let''s see one definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If the value `v` is equal to `1`, then `0` is returned. If the value is `0`,
    `1` is returned as the output.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to define the `enum` token for the unary operator in the
    `toy.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we identify the unary string and return a unary token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we define an AST for the unary operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The AST is now ready. Let''s define a parser for the unary operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to call the `unary_parser()` function from the binary operator
    parser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s call the `unary_parser()` function from the expression parser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we modify the function declaration parser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step is to define the `Codegen()` function for the unary operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the `toy.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open an example file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the following unary operator overloading code in the example file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the example file with the TOY compiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should be as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The unary operator defined by the user will be parsed, and IR will be generated
    for it. In the case you just saw, if the unary operand is not zero then the result
    is `0`. If the operand is zero, then the result is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more detailed implementations of unary operators, visit [http://llvm.org/docs/tutorial/LangImpl6.html](http://llvm.org/docs/tutorial/LangImpl6.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding JIT support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A wide variety of tools can be applied to LLVM IR. For example, as demonstrated
    in [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. LLVM Design and Use"), *LLVM
    Design and Use*, the IR can be dumped into bitcode or into an assembly. An optimization
    tool called opt can be run on IR. IR acts as the common platform—an abstract layer
    for all of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: JIT support can also be added. It immediately evaluates the top-level expressions
    typed in. For example, `1 + 2;`, as soon as it is typed in, evaluates the code
    and prints the value as `3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a static global variable for the execution engine in the `toy.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `toy.cpp` file''s `main()` function, write the code for JIT:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the top-level expression parser in the `toy.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the `toy.cpp` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open an example file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the following TOY code in the example file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, run the TOY compiler on the example file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The LLVM JIT compiler matches the native platform ABI, casts the result pointer
    into a function pointer of that type, and calls it directly. There is no difference
    between JIT-compiled code and native machine code that is statically linked to
    the application.
  prefs: []
  type: TYPE_NORMAL
