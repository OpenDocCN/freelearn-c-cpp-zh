<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Keyboard Input and Character Calculation</h1></div></div></div><p>In this chapter, we will continue our work on the word processor from <a class="link" href="ch06.html" title="Chapter 6. Building a Word Processor">Chapter 6</a>, <em>Building a Word Processor</em>. More specifically, we will look into keyboard input and character calculation. The keyboard handling section deals with regular character input and a rather large set of special keys, such as <em>Home</em>, <em>End</em>, <em>Page Up</em> and <em>Page Down</em>, <em>Return</em>, <em>Backspace</em>, and arrows.</p><p>The calculation section deals with the calculation of each character with regards to its font and the alignment of its paragraph as well as the page settings. In the end, we will calculate the position and size of each individual character in the document.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec31"/>Keyboard handling</h1></div></div></div><p>To begin with, we look into the input of regular characters. The <code class="literal">OnChar</code> method is called every time a user presses a graphical character (with an ASCII value between 32 and 127, inclusive) or the <em>Return</em> key. If a part of the text is marked, that part is removed first. Then the character is added to the character list by the <code class="literal">InsertChar</code> method of the <code class="literal">OverwriteChar</code> class, depending on the <code class="literal">keyboard</code> mode.</p><pre class="programlisting">void WordDocument::OnChar(TCHAR tChar) { &#13;
  if (isprint(tChar) || (tChar == NewLine)) { &#13;
    if (wordMode == WordMark) { &#13;
      OnDelete(); &#13;
    } &#13;
 &#13;
    Paragraph* paragraphPtr = charList[editIndex].ParagraphPtr(); &#13;
 &#13;
    switch (GetKeyboardMode()) { &#13;
      case InsertKeyboard: &#13;
        OnInsertChar(tChar, paragraphPtr); &#13;
        break; &#13;
 &#13;
      case OverwriteKeyboard: &#13;
        OnOverwriteChar(tChar, paragraphPtr); &#13;
        break; &#13;
    } &#13;
 &#13;
    SetDirty(true); &#13;
    GenerateParagraph(paragraphPtr); &#13;
    CalculateDocument(); &#13;
 &#13;
    if (MakeVisible()) { &#13;
      Invalidate(); &#13;
      UpdateWindow(); &#13;
    } &#13;
 &#13;
    UpdateCaret(); &#13;
  } &#13;
} &#13;
</pre><p>When inserting a character, we have three cases, which are similar to the <code class="literal">UpdateCaret</code> and <code class="literal">OnFont</code> methods from <a class="link" href="ch06.html" title="Chapter 6. Building a Word Processor">Chapter 6</a>, <em>Building a Word Processor</em>. If the <code class="literal">nextFont</code> parameter is active (if it does not equal <code class="literal">SystemFont</code>), we use it for the new character. Then, the <code class="literal">nextFont</code> parameter is cleared by the <code class="literal">ClearNextFont</code> method.</p><pre class="programlisting">void WordDocument::OnInsertChar(TCHAR tChar, &#13;
                                Paragraph* paragraphPtr) { &#13;
  if (nextFont != SystemFont) { &#13;
    charList.Insert(editIndex++, &#13;
                    CharInfo(paragraphPtr, tChar, nextFont)); &#13;
    ClearNextFont(); &#13;
  } &#13;
</pre><p>If the <code class="literal">nextFont</code> parameter is not active and the input is not at the beginning of the paragraph, we use the font of the preceding character for the new character.</p><pre class="programlisting">  else if (charList[editIndex].ParagraphPtr()-&gt;First() &lt; &#13;
           editIndex) { &#13;
    Font font = charList[editIndex - 1].CharFont(); &#13;
    charList.Insert(editIndex++, &#13;
                    CharInfo(paragraphPtr, tChar, font)); &#13;
  } &#13;
</pre><p>However, if the input is at the beginning of the paragraph, we use the font of the first character in the paragraph.</p><pre class="programlisting">  else { &#13;
    Font font = charList[editIndex].CharFont(); &#13;
    charList.Insert(editIndex++, &#13;
                    CharInfo(paragraphPtr, tChar, font)); &#13;
  } &#13;
</pre><p>In order to make room for the inserted character, we increase the last index of its paragraph. We also increase the first and last index of the succeeding paragraphs.</p><pre class="programlisting">  ++paragraphPtr-&gt;Last(); &#13;
 &#13;
  for (int parIndex = paragraphPtr-&gt;Index() + 1; &#13;
       parIndex &lt;= paragraphList.Size() - 1; ++parIndex) { &#13;
    ++paragraphList[parIndex]-&gt;First(); &#13;
    ++paragraphList[parIndex]-&gt;Last(); &#13;
  } &#13;
} &#13;
</pre><p>In the <code class="literal">overwrite</code> mode, we have two cases. If the input is at the very end of the document, we insert the character instead of overwriting it; otherwise, we overwrite the newline terminating the last paragraph. However, we are free to overwrite the terminating newline of every paragraph except the last one, in which case, the two paragraphs are merged into one.</p><p>Similar to the <code class="literal">InsertChar</code> method, we use the <code class="literal">nextFont</code> parameter if it is not equal to the <code class="literal">SystemFont</code> parameter. If it is equal to the <code class="literal">SystemFont</code> parameter, we use the font of the character we overwrite rather than the preceding character as we did in the <code class="literal">InsertChar</code> case.</p><pre class="programlisting">void WordDocument::OnOverwriteChar(TCHAR tChar, &#13;
                                   Paragraph* paragraphPtr) { &#13;
  if (editIndex == (charList.Size() - 1)) { &#13;
    if (nextFont != SystemFont) { &#13;
      charList.Insert(editIndex++, &#13;
        CharInfo(paragraphPtr, tChar, nextFont)); &#13;
      charList[editIndex] = &#13;
        CharInfo(paragraphPtr, NewLine, nextFont); &#13;
      ClearNextFont(); &#13;
    } &#13;
    else { &#13;
      Font font = charList[editIndex].CharFont(); &#13;
      charList.Insert(editIndex++, &#13;
                      CharInfo(paragraphPtr, tChar, font)); &#13;
    } &#13;
 &#13;
    ++paragraphPtr-&gt;Last(); &#13;
  } &#13;
  else { &#13;
    if (nextFont != SystemFont) { &#13;
      charList[editIndex++] = &#13;
        CharInfo(paragraphPtr, tChar, nextFont); &#13;
      ClearNextFont(); &#13;
    } &#13;
    else { &#13;
      Font font = charList[editIndex].CharFont(); &#13;
      charList[editIndex++] = CharInfo(paragraphPtr, tChar, font); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">ClearNextFont</code> method clears the <code class="literal">nextFont</code> parameter by setting its value to the <code class="literal">SystemFont</code> font. It also recalculates the edit paragraph and the document, since the removal of the <code class="literal">nextFont</code> parameter may cause the edit line (and thereby the edit paragraph) to be lowered. The fonts of the character on the line may all be lower than the <code class="literal">nextFont</code> parameter, which causes the line to be lower when the <code class="literal">nextFont</code> parameter is removed from the line.</p><pre class="programlisting">void WordDocument::ClearNextFont() { &#13;
  if (nextFont != SystemFont) { &#13;
    nextFont = SystemFont; &#13;
    Paragraph* paragraphPtr = charList[editIndex].ParagraphPtr(); &#13;
    GenerateParagraph(paragraphPtr); &#13;
    CalculateDocument(); &#13;
    UpdateWindow(); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnKeyDown</code> method is called every time the user presses a key. Depending on the key and whether the <em>Shift</em> key is pressed, the <code class="literal">OnKeyDown</code> method in turn calls the <code class="literal">OnShiftKey</code>, <code class="literal">OnRegularKey</code>, or <code class="literal">OnNeutralKey</code> method. The <em>Delete</em>, <em>Backspace</em>, and <em>Return</em> keys perform the same actions irrespective of whether the <em>Shift</em> key is pressed.</p><pre class="programlisting">bool WordDocument::OnKeyDown(WORD key, bool shiftPressed, &#13;
                             bool /* controlPressed */) { &#13;
  switch (key) { &#13;
    case KeyLeft: &#13;
    case KeyRight: &#13;
    case KeyUp: &#13;
    case KeyDown: &#13;
    case KeyHome: &#13;
    case KeyEnd: { &#13;
&#13;
        if (shiftPressed) { &#13;
          OnShiftKey(key); &#13;
        } &#13;
        else { &#13;
          OnRegularKey(key); &#13;
        } &#13;
      } &#13;
      return true; &#13;
 &#13;
    case KeyBackspace: &#13;
    case KeyReturn: &#13;
      OnNeutralKey(key); &#13;
      return true; &#13;
  } &#13;
 &#13;
  return false; &#13;
} &#13;
</pre><p>When the user presses a graphical key, the application will be set to the <code class="literal">edit</code> mode. The <code class="literal">EnsureEditStatus</code> method makes sure of it. The key stroke may move the caret to a position outside the visible part of the client area. Therefore, we call the <code class="literal">MakeVisible</code> method to move the scroll bars if necessary, so that the caret appears in the visible part of the client area. The idea is to make the caret and the edit character always visible in the window.</p><pre class="programlisting">void WordDocument::OnRegularKey(WORD key) { &#13;
  EnsureEditStatus(); &#13;
 &#13;
  switch (key) { &#13;
    case KeyLeft: &#13;
      OnLeftArrowKey(); &#13;
      break; &#13;
 &#13;
    case KeyRight: &#13;
      OnRightArrowKey(); &#13;
      break; &#13;
 &#13;
    case KeyUp: &#13;
      OnUpArrowKey(); &#13;
      break; &#13;
 &#13;
    case KeyDown: &#13;
      OnDownArrowKey(); &#13;
      break; &#13;
 &#13;
&#13;
&#13;
    case KeyHome: &#13;
      OnHomeKey(); &#13;
      break; &#13;
 &#13;
    case KeyEnd: &#13;
      OnEndKey(); &#13;
      break; &#13;
  } &#13;
 &#13;
  if (MakeVisible()) { &#13;
    Invalidate(); &#13;
    UpdateWindow(); &#13;
    UpdateCaret(); &#13;
  } &#13;
} &#13;
</pre><p>We must make sure that the application is set to the <code class="literal">edit</code> mode when the user presses <em>Page Up</em>, <em>Page Down</em>, or one of the arrow keys, without pressing the <em>Shift</em> key. The <code class="literal">EnsureEditStatus</code> method takes care of that. The <code class="literal">editIndex</code> is set to <code class="literal">lastMarkIndex</code>.</p><pre class="programlisting">void WordDocument::EnsureEditStatus() { &#13;
  if (wordMode == WordMark) { &#13;
    wordMode = WordEdit; &#13;
    editIndex = lastMarkIndex; &#13;
    InvalidateBlock(firstMarkIndex, lastMarkIndex); &#13;
    UpdateCaret(); &#13;
    UpdateWindow(); &#13;
  } &#13;
} &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch07lvl2sec51"/>Arrow keys</h2></div></div></div><p>The <code class="literal">OnLeftArrowKey</code> method is called when the user presses the left arrow key. Its purpose is to move the caret one step to the left, which is simple enough. We must make sure that the edit position is not already at the beginning of the document. If we move the position to the left, we also need to clear the <code class="literal">nextFont</code> parameter, since it will be active only when the user is about to input a new character.</p><pre class="programlisting">void WordDocument::OnLeftArrowKey() { &#13;
  if (editIndex &gt; 0) { &#13;
    ClearNextFont(); &#13;
    --editIndex; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnRightArrowKey</code> method is called when the user presses the right arrow key. If the caret position is not at the end of the document, we move it one step to the right.</p><pre class="programlisting">void WordDocument::OnRightArrowKey() { &#13;
  if (editIndex &lt; (charList.Size() - 1)) { &#13;
    ClearNextFont(); &#13;
    ++editIndex; &#13;
  } &#13;
} &#13;
</pre><p>When the user presses the up arrow key, we have to find the key above the edit line. We do that by simulating a mouse click slightly above (one logical unit) the line. Note that we have to look up the edit line. It is not enough to use the character rectangle, since the characters may differ in height and ascent (refer to the next section) and we cannot be sure that the character rectangle is the highest rectangle on the line. Therefore, we look up the height of the edit line. In the following screenshot, the text is surrounded by rectangles for the purpose of clarification. The code does not actually draw the rectangles. If we would use the rectangle of the digit four, we would not reach the preceding line because the rectangle of the digit <strong>5</strong> is higher. Instead, we have to use the line rectangle of the line <strong>456</strong>.</p><p>
</p><div><img src="img/B05475_07_01.jpg" alt="Arrow keys"/></div><p>
</p><pre class="programlisting">void WordDocument::OnUpArrowKey() { &#13;
  CharInfo charInfo = charList[editIndex]; &#13;
 &#13;
  Paragraph* paragraphPtr = charInfo.ParagraphPtr(); &#13;
  Point topLeft(0, paragraphPtr-&gt;Top()); &#13;
 &#13;
  LineInfo* lineInfoPtr = charInfo.LineInfoPtr(); &#13;
  Rect lineRect = &#13;
    topLeft + Rect(0, lineInfoPtr-&gt;Top(), PageInnerWidth(), &#13;
                      lineInfoPtr-&gt;Top() + lineInfoPtr-&gt;Height()); &#13;
</pre><p>We need to check that the edit character is not located on the first line of the document. If the edit character is already located on the first line then nothing will happen to the output.</p><pre class="programlisting">  if (lineRect.Top() &gt; 0) { &#13;
    ClearNextFont(); &#13;
    Rect charRect = topLeft + charInfo.CharRect(); &#13;
    editIndex = &#13;
      MousePointToIndex(Point(charRect.Left(), lineRect.Top()-1)); &#13;
  } &#13;
} &#13;
</pre><p>When the user presses the down arrow key, we simulate a mouse click by calling the <code class="literal">MousePointToIndexDown</code> method. In the call, we use the position slightly under the edit line (1 unit) in order to find the index of the character in the same horizontal position on the next line. One difference compared to the preceding <code class="literal">UpArrowKey</code> case is that we call the <code class="literal">MousePointToIndexDown</code> method instead of the <code class="literal">MousePointToIndex</code> method because it might be the last line of the paragraph, and there might be some space before the next paragraph. In that case, we would want the index of the character following the empty space, which the <code class="literal">MousePointToIndexDown</code> method returns, while the <code class="literal">MousePointToIndex</code> method returns the index of the character preceding the empty space.</p><pre class="programlisting">void WordDocument::OnDownArrowKey() { &#13;
  CharInfo charInfo = charList[editIndex];  &#13;
  Paragraph* paragraphPtr = charInfo.ParagraphPtr(); &#13;
  Point topLeft(0, paragraphPtr-&gt;Top());  &#13;
  LineInfo* lineInfoPtr = charInfo.LineInfoPtr(); &#13;
  Rect lineRect = &#13;
    topLeft + Rect(0, lineInfoPtr-&gt;Top(), PageInnerWidth(), &#13;
                      lineInfoPtr-&gt;Top() + lineInfoPtr-&gt;Height()); &#13;
</pre><p>Similar to the preceding <code class="literal">OnUpArrowKey</code> case, we need to ensure that the edit line is not the last line in the document. We do so by comparing it to the bottom of the last paragraph. If it is the last line then nothing will happen to the output.</p><pre class="programlisting">  Paragraph* lastParagraphPtr = paragraphList.Back(); &#13;
  int bottom = lastParagraphPtr-&gt;Top() + &#13;
               lastParagraphPtr-&gt;Height(); &#13;
 &#13;
  if (lineRect.Bottom() &lt; bottom) { &#13;
    ClearNextFont(); &#13;
    Rect charRect = topLeft + charInfo.CharRect(); &#13;
    editIndex = &#13;
      MousePointToIndexDown(Point(charRect.Left(), &#13;
                                  lineRect.Bottom() + 1)); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">MousePointToIndexDown</code> method returns the index of the character on which we click. If the mouse point is between two paragraphs, the index of the preceding character is returned.</p><pre class="programlisting">int WordDocument::MousePointToIndexDown(Point mousePoint) const{ &#13;
  for (int parIndex = 0; parIndex &lt; paragraphList.Size(); &#13;
       ++parIndex) { &#13;
    Paragraph* paragraphPtr = paragraphList[parIndex]; &#13;
 &#13;
    if (mousePoint.Y() &lt;= &#13;
        (paragraphPtr-&gt;Top() + paragraphPtr-&gt;Height())) { &#13;
      return MousePointToParagraphIndex &#13;
             (paragraphList[parIndex], mousePoint); &#13;
    } &#13;
  } &#13;
</pre><p>As this method always finds the correct paragraph, this point will never be reached, but we assert that in case of coding error it behaves otherwise.</p><pre class="programlisting">  assert(false); &#13;
  return 0; &#13;
} &#13;
</pre><p>The <code class="literal">OnPageUp</code> and <code class="literal">OnPageDown</code> methods look up the height of the current vertical scroll bar in order to simulate a mouse click one page up or down.</p><pre class="programlisting">void WordDocument::OnPageUpKey() { &#13;
  CharInfo charInfo = charList[editIndex]; &#13;
  Rect editRect = charInfo.CharRect(); &#13;
 &#13;
  Paragraph* paragraphPtr = charInfo.ParagraphPtr(); &#13;
  Point topLeft(0, paragraphPtr-&gt;Top()); &#13;
 &#13;
  int scrollPage = GetVerticalScrollPageHeight(); &#13;
  Point editPoint((editRect.Left() + editRect.Right()) / 2, &#13;
        ((editRect.Top() + editRect.Bottom()) / 2) - scrollPage); &#13;
 &#13;
  editIndex = MousePointToIndex(topLeft + editPoint); &#13;
} &#13;
 &#13;
void WordDocument::OnPageDownKey() { &#13;
  CharInfo charInfo = charList[editIndex]; &#13;
  Rect editRect = charInfo.CharRect(); &#13;
 &#13;
  Paragraph* paragraphPtr = charInfo.ParagraphPtr(); &#13;
  Point topLeft(0, paragraphPtr-&gt;Top()); &#13;
 &#13;
  int scrollPage = GetVerticalScrollPageHeight(); &#13;
  Point editPoint((editRect.Left() + editRect.Right()) / 2, &#13;
        ((editRect.Top() + editRect.Bottom()) / 2) + scrollPage); &#13;
 &#13;
  editIndex = MousePointToIndex(topLeft + editPoint); &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec52"/>Home and End</h2></div></div></div><p>The <code class="literal">OnHomeKey</code> method is called when the user presses the <em>Home</em> key. It looks up the index of the first character on the edit line by following its paragraph and line pointers. It uses the index of the first character of the line.</p><pre class="programlisting">void WordDocument::OnHomeKey() { &#13;
  CharInfo charInfo = charList[editIndex]; &#13;
  int homeCharIndex = charInfo.ParagraphPtr()-&gt;First() + &#13;
                      charInfo.LineInfoPtr()-&gt;First(); &#13;
</pre><p>If the edit character is not already at the beginning of the line, the <code class="literal">nextFont</code> parameter is cleared by the <code class="literal">ClearNextFont</code> method, the edit index is updated, and the caret is updated.</p><pre class="programlisting">  if (homeCharIndex &lt; editIndex) { &#13;
    ClearNextFont(); &#13;
    editIndex = homeCharIndex; &#13;
    UpdateCaret(); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnEndKey</code> method is called when the user presses the <em>End</em> key. It looks up the index of the last character on the edit line by following its paragraph and line pointers and using the index of the last character of the line.</p><pre class="programlisting">void WordDocument::OnEndKey() { &#13;
  CharInfo charInfo = charList[editIndex]; &#13;
  int endCharIndex = charInfo.ParagraphPtr()-&gt;First() + &#13;
                     charInfo.LineInfoPtr()-&gt;Last(); &#13;
</pre><p>If the edit character is not already at the end of the line, the <code class="literal">nextFont</code> parameter is cleared by the <code class="literal">ClearNextFont</code> method, the edit index is updated, and the caret is updated.</p><pre class="programlisting">  if (editIndex &lt; endCharIndex) { &#13;
    ClearNextFont(); &#13;
    editIndex = endCharIndex; &#13;
    UpdateCaret(); &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec53"/>Shift arrow keys</h2></div></div></div><p>The <code class="literal">OnShiftKey</code> method is called when the user presses a key together with the <em>Shift</em> key:</p><pre class="programlisting">void WordDocument::OnShiftKey(WORD key) { &#13;
  EnsureMarkStatus(); &#13;
  switch (key) { &#13;
    case KeyLeft: &#13;
      OnShiftLeftArrowKey(); &#13;
      break; &#13;
 &#13;
    case KeyRight: &#13;
      OnShiftRightArrowKey(); &#13;
      break; &#13;
 &#13;
    case KeyUp: &#13;
      OnShiftUpArrowKey(); &#13;
      break; &#13;
 &#13;
    case KeyDown: &#13;
      OnShiftDownArrowKey(); &#13;
      break; &#13;
 &#13;
    case KeyPageUp: &#13;
      OnShiftPageUpKey(); &#13;
      break; &#13;
 &#13;
    case KeyPageDown: &#13;
      OnShiftPageDownKey(); &#13;
      break; &#13;
 &#13;
    case KeyHome: &#13;
      OnShiftHomeKey(); &#13;
      break; &#13;
 &#13;
    case KeyEnd: &#13;
      OnShiftEndKey(); &#13;
      break; &#13;
  } &#13;
 &#13;
  if (MakeVisible()) { &#13;
    Invalidate(); &#13;
    UpdateWindow(); &#13;
    UpdateCaret(); &#13;
  } &#13;
} &#13;
</pre><p>If the user presses a key together with the <em>Shift</em> key, we must make sure that the application is set to the <code class="literal">mark</code> mode; the <code class="literal">EnsureMarkMode</code> method deals with that. It clears the <code class="literal">nextFont</code> parameter (by setting it to <code class="literal">SystemFont</code>), sets the application to the <code class="literal">mark</code> mode, and assigns both the first and last marked index to the edit index.</p><pre class="programlisting">void WordDocument::EnsureMarkStatus() { &#13;
  if (wordMode == WordEdit) { &#13;
    ClearNextFont(); &#13;
    wordMode = WordMark; &#13;
    firstMarkIndex = editIndex; &#13;
    lastMarkIndex = editIndex; &#13;
    UpdateCaret(); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnShiftLeftArrowKey</code> method decreases the last marked index. Note that we only invalidate the indexes between the old and new value of the <code class="literal">lastMarkIndex</code> method in order to avoid dazzle:</p><pre class="programlisting">void WordDocument::OnShiftLeftArrowKey() { &#13;
  if (lastMarkIndex &gt; 0) { &#13;
    InvalidateBlock(lastMarkIndex, --lastMarkIndex); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnShiftRightArrowKey</code> method moves the position of the last marked character in a way similar to the <code class="literal">OnShiftLeftArrowKey</code> method.</p><pre class="programlisting">void WordDocument::OnShiftRightArrowKey() { &#13;
  if (lastMarkIndex &lt; charList.Size()) { &#13;
    InvalidateBlock(lastMarkIndex, lastMarkIndex++); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnShiftUpArrowKey</code> and <code class="literal">OnShiftDownArrowKey</code> methods are called when the user presses the up or down arrow key together with the <em>Shift</em> key. Its task is to move the last marked position one line upward. We simulate the mouse click in the same way as we did for the <code class="literal">OnUpArrowKey</code> and <code class="literal">OnDownArrowKey</code> method earlier.</p><pre class="programlisting">void WordDocument::OnShiftUpArrowKey() { &#13;
  CharInfo charInfo = charList[lastMarkIndex]; &#13;
 &#13;
  Paragraph* paragraphPtr = charInfo.ParagraphPtr(); &#13;
  Point topLeft(0, paragraphPtr-&gt;Top()); &#13;
 &#13;
  LineInfo* lineInfoPtr = charInfo.LineInfoPtr(); &#13;
&#13;
  Rect lineRect = &#13;
    topLeft + Rect(0, lineInfoPtr-&gt;Top(), PageInnerWidth(), &#13;
                      lineInfoPtr-&gt;Top() + lineInfoPtr-&gt;Height()); &#13;
 &#13;
  if ((paragraphPtr-&gt;Top() + lineRect.Top()) &gt; 0) { &#13;
    Rect charRect = topLeft + charInfo.CharRect(); &#13;
    int newLastMarkIndex = &#13;
      MousePointToIndex(Point(charRect.Left(), lineRect.Top()-1)); &#13;
    InvalidateBlock(lastMarkIndex, newLastMarkIndex); &#13;
    lastMarkIndex = newLastMarkIndex; &#13;
  } &#13;
} &#13;
 &#13;
void WordDocument::OnShiftDownArrowKey() { &#13;
  CharInfo charInfo = charList[lastMarkIndex]; &#13;
 &#13;
  Paragraph* paragraphPtr = charInfo.ParagraphPtr(); &#13;
  Point topLeft(0, paragraphPtr-&gt;Top()); &#13;
 &#13;
  LineInfo* lineInfoPtr = charInfo.LineInfoPtr(); &#13;
  Rect lineRect = &#13;
    topLeft + Rect(0, lineInfoPtr-&gt;Top(), PageInnerWidth(), &#13;
                      lineInfoPtr-&gt;Top() + lineInfoPtr-&gt;Height()); &#13;
 &#13;
  Paragraph* lastParagraphPtr = paragraphList.Back(); &#13;
  int bottom = lastParagraphPtr-&gt;Top() + &#13;
               lastParagraphPtr-&gt;Height(); &#13;
 &#13;
  if (lineRect.Bottom() &lt; bottom) { &#13;
    Rect charRect = topLeft + charInfo.CharRect(); &#13;
    int newLastMarkIndex = &#13;
      MousePointToIndexDown(Point(charRect.Left(), &#13;
                                  lineRect.Bottom() + 1)); &#13;
    InvalidateBlock(lastMarkIndex, newLastMarkIndex); &#13;
    lastMarkIndex = newLastMarkIndex; &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec54"/>Shift Page Up and Page Down</h2></div></div></div><p>The <code class="literal">OnShiftPageUpKey</code> and <code class="literal">OnShiftPageDown</code> methods move the edit character index one page-height by simulating a mouse click on <em>Page Up</em> or <em>Page Down</em>:</p><pre class="programlisting">void WordDocument::OnShiftPageUpKey() { &#13;
  Rect lastRectMark = charList[lastMarkIndex].CharRect(); &#13;
  int scrollPage = GetVerticalScrollPageHeight(); &#13;
  Point lastPointMark &#13;
    ((lastRectMark.Left() + lastRectMark.Right()) / 2, &#13;
     (lastRectMark.Top()+lastRectMark.Bottom()) / 2 - scrollPage); &#13;
 &#13;
  int newLastMarkIndex = MousePointToIndex(lastPointMark); &#13;
  InvalidateBlock(lastMarkIndex, newLastMarkIndex); &#13;
  lastMarkIndex = newLastMarkIndex; &#13;
} &#13;
 &#13;
void WordDocument::OnShiftPageDownKey() { &#13;
  Rect lastRectMark = charList[lastMarkIndex].CharRect(); &#13;
 &#13;
  int scrollPage = GetVerticalScrollPageHeight(); &#13;
  Point lastPointMark &#13;
    ((lastRectMark.Left() + lastRectMark.Right()) / 2, &#13;
     (lastRectMark.Top()+lastRectMark.Bottom())/2 + scrollPage); &#13;
 &#13;
  int newLastMarkIndex = MousePointToIndexDown(lastPointMark); &#13;
  InvalidateBlock(lastMarkIndex, newLastMarkIndex); &#13;
  lastMarkIndex = newLastMarkIndex; &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec55"/>Shift Home and End</h2></div></div></div><p>The <code class="literal">OnShiftHomeKey</code> and <code class="literal">OnShiftEndKey</code> methods are called when the user presses the <em>Home</em> or <em>End</em> key together with the <em>Shift</em> key. Their task is to mark the line from the current position to the beginning or end of the line:</p><pre class="programlisting">void WordDocument::OnShiftHomeKey() { &#13;
  CharInfo charInfo = charList[editIndex]; &#13;
  int homeCharIndex = charInfo.ParagraphPtr()-&gt;First() + &#13;
                      charInfo.LineInfoPtr()-&gt;First(); &#13;
 &#13;
  if (homeCharIndex &lt; lastMarkIndex) { &#13;
    InvalidateBlock(lastMarkIndex, homeCharIndex); &#13;
    lastMarkIndex = homeCharIndex; &#13;
  } &#13;
} &#13;
 &#13;
void WordDocument::OnShiftEndKey() { &#13;
  CharInfo charInfo = charList[editIndex]; &#13;
  int endCharIndex = charInfo.ParagraphPtr()-&gt;First() + &#13;
                     charInfo.LineInfoPtr()-&gt;Last(); &#13;
 &#13;
  if (lastMarkIndex &lt; endCharIndex) { &#13;
    InvalidateBlock(lastMarkIndex, endCharIndex); &#13;
    lastMarkIndex = endCharIndex; &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec56"/>Control Home and End</h2></div></div></div><p>The <code class="literal">OnControlHomeKey</code> and <code class="literal">OnControlEndKey</code> methods set the edit character position to the beginning or end of the document. Since these methods are listeners and not called by the <code class="literal">OnRegularKey</code> method, we need to call the <code class="literal">EnsureEditStatus</code>, <code class="literal">MakeVisible</code>, and <code class="literal">UpdateCaret</code> methods:</p><pre class="programlisting">void WordDocument::OnControlHomeKey() { &#13;
  EnsureEditStatus(); &#13;
 &#13;
  if (editIndex &gt; 0) { &#13;
    editIndex = 0; &#13;
     &#13;
    if (MakeVisible()) { &#13;
      Invalidate(); &#13;
      UpdateWindow(); &#13;
    } &#13;
 &#13;
    UpdateCaret(); &#13;
  } &#13;
} &#13;
 &#13;
void WordDocument::OnControlEndKey() { &#13;
  EnsureEditStatus(); &#13;
 &#13;
  if (editIndex &lt; (charList.Size() - 1)) { &#13;
    editIndex = charList.Size() - 1; &#13;
 &#13;
    if (MakeVisible()) { &#13;
      Invalidate(); &#13;
      UpdateWindow(); &#13;
    } &#13;
 &#13;
    UpdateCaret(); &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec57"/>Shift Control Home and End</h2></div></div></div><p>The <code class="literal">OnShiftControlHomeKey</code> and <code class="literal">OnShiftControlEndKey</code> methods set the last mark index to the beginning or end of the document:</p><pre class="programlisting">void WordDocument::OnShiftControlHomeKey() { &#13;
  EnsureMarkStatus(); &#13;
  ClearNextFont(); &#13;
 &#13;
  if (lastMarkIndex &gt; 0) { &#13;
    InvalidateBlock(0, lastMarkIndex); &#13;
    lastMarkIndex = 0; &#13;
 &#13;
    if (MakeVisible()) { &#13;
      Invalidate(); &#13;
      UpdateWindow(); &#13;
    } &#13;
 &#13;
    UpdateCaret(); &#13;
  } &#13;
} &#13;
 &#13;
void WordDocument::OnShiftControlEndKey() { &#13;
  EnsureMarkStatus(); &#13;
 &#13;
  if (lastMarkIndex &lt; (charList.Size() - 1)) { &#13;
    int lastIndex = charList.Size() - 1; &#13;
    InvalidateBlock(lastMarkIndex, lastIndex); &#13;
    lastMarkIndex = lastIndex; &#13;
 &#13;
    if (MakeVisible()) { &#13;
      Invalidate(); &#13;
      UpdateWindow(); &#13;
    } &#13;
 &#13;
    UpdateCaret(); &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec58"/>Neutral keys</h2></div></div></div><p>The <em>Backspace</em> and <em>Return</em> keys are neutral keys in the sense that we do not care whether the user presses the <em>Shift</em> or <em>Ctrl</em> key. Note that the <em>Delete</em> key is not handled by the <code class="literal">OnNeutralKey</code> method because the <strong>Delete</strong> menu item has the <em>Delete</em> key as its accelerator:</p><pre class="programlisting">void WordDocument::OnNeutralKey(WORD key) { &#13;
  switch (key) { &#13;
    case KeyBackspace: &#13;
      OnBackspaceKey(); &#13;
      break; &#13;
    case KeyReturn: &#13;
      OnReturnKey(); &#13;
      break; &#13;
  } &#13;
 &#13;
  if (MakeVisible()) { &#13;
    Invalidate(); &#13;
    UpdateWindow(); &#13;
    UpdateCaret(); &#13;
  } &#13;
} &#13;
</pre><p>What the <code class="literal">OnBackSpaceKey</code> method does is quite simple–it just calls the <code class="literal">OnDelete</code> method. In the <code class="literal">edit</code> mode, we first move one step to the left unless the edit position is not already at the beginning of the document. If it is, nothing happens. In the <code class="literal">mark</code> mode, the <em>Delete</em> key and the <em>Backspace</em> key have the same effect–they both delete the marked text.</p><pre class="programlisting">void WordDocument::OnBackspaceKey() { &#13;
  switch (wordMode) { &#13;
    case WordEdit: &#13;
      if (editIndex &gt; 0) { &#13;
        OnLeftArrowKey(); &#13;
        OnDelete(); &#13;
      } &#13;
      break; &#13;
 &#13;
    case WordMark: &#13;
      OnDelete(); &#13;
      break; &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">OnReturnKey</code> method is called when the user presses the <em>Return</em> key. First, we call the <code class="literal">OnChar</code> method with a newline. The <code class="literal">OnChar</code> method is never called with newline on any other occasion, since newline is not a graphical character.</p><pre class="programlisting">void WordDocument::OnReturnKey() { &#13;
  OnChar(NewLine); &#13;
</pre><p>After the newline has been added to the character list, we need to split the edit paragraph into two. The <code class="literal">editIndex</code> field has been updated by the <code class="literal">OnChar</code> method, and it is now the index of the character after the newline. The second paragraph starts at the edit index and ends at the end of the first paragraph. The first paragraph's last index is set to the edit index minus one. This means that the first paragraph holds the characters up to the newline, inclusive, while the second paragraph holds the characters one step beyond the newline.</p><pre class="programlisting">  Paragraph* firstParagraphPtr = &#13;
    charList[editIndex].ParagraphPtr(); &#13;
  Paragraph* secondParagraphPtr = &#13;
    new Paragraph(editIndex, firstParagraphPtr-&gt;Last(), &#13;
                  firstParagraphPtr-&gt;AlignmentField(), &#13;
                  firstParagraphPtr-&gt;Index() + 1); &#13;
  assert(firstParagraphPtr != nullptr); &#13;
  firstParagraphPtr-&gt;Last() = editIndex - 1; &#13;
</pre><p>We insert the second paragraph in the paragraph list; we also need to set the characters in the second paragraph to point to the second paragraph.</p><pre class="programlisting">  paragraphList.Insert(firstParagraphPtr-&gt;Index() + 1, &#13;
                       secondParagraphPtr); &#13;
  for (int charIndex = secondParagraphPtr-&gt;First(); &#13;
       charIndex &lt;= secondParagraphPtr-&gt;Last(); ++charIndex) { &#13;
    charList[charIndex].ParagraphPtr() = secondParagraphPtr; &#13;
  } &#13;
</pre><p>We need to recalculate both the first and second paragraph, since the first paragraph has lost characters and the second paragraph has been recently created.</p><pre class="programlisting">  GenerateParagraph(firstParagraphPtr); &#13;
  GenerateParagraph(secondParagraphPtr); &#13;
</pre><p>Since we have added a paragraph, we need to increase the indexes of the succeeding paragraphs.</p><pre class="programlisting">  for (int parIndex = secondParagraphPtr-&gt;Index() + 1; &#13;
       parIndex &lt; paragraphList.Size(); ++parIndex) { &#13;
    ++paragraphList[parIndex]-&gt;Index(); &#13;
  } &#13;
 &#13;
  SetDirty(true); &#13;
  CalculateDocument(); &#13;
  UpdateCaret(); &#13;
  UpdateWindow(); &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec59"/>Visible characters</h2></div></div></div><p>When the user uses the keyboard, the edit character or the last marked character will always be visible. We start by finding the area that is visible; in <code class="literal">edit</code> mode, it is the area of the edit character. In the <code class="literal">mark</code> mode, it is the area of the character before the last marked index, unless it is zero, in which case the index is set to zero.</p><pre class="programlisting">bool WordDocument::MakeVisible() { &#13;
  Rect visibleArea; &#13;
 &#13;
  switch (wordMode) { &#13;
    case WordEdit: { &#13;
        Paragraph* editParagraphPtr = &#13;
          charList[editIndex].ParagraphPtr(); &#13;
        Point topLeft(0, editParagraphPtr-&gt;Top()); &#13;
        visibleArea = topLeft + charList[editIndex].CharRect(); &#13;
      } &#13;
      break; &#13;
 &#13;
    case WordMark: { &#13;
        Paragraph* lastParagraphPtr = &#13;
          charList[max(0, lastMarkIndex - 1)].ParagraphPtr(); &#13;
        Point topLeft(0, lastParagraphPtr-&gt;Top()); &#13;
        visibleArea = &#13;
          topLeft + charList[max(0,lastMarkIndex - 1)].CharRect(); &#13;
      } &#13;
      break; &#13;
  } &#13;
</pre><p>We test whether the visible area is in fact visible at the moment. If it is not visible, we adjust the scroll bars in order to make it visible.</p><pre class="programlisting">  int horiScrollLeft = GetHorizontalScrollPosition(), &#13;
      horiScrollPage = GetHorizontalScrollPageWidth(), &#13;
      vertScrollTop = GetVerticalScrollPosition(), &#13;
      vertScrollPage = GetVerticalScrollPageHeight();  &#13;
  int horiScrollRight = horiScrollLeft + horiScrollPage, &#13;
      vertScrollBottom = vertScrollTop + vertScrollPage; &#13;
</pre><p>If the left border of the visible area is not visible, we set the horizontal scroll position to its left border. In the same way, we set the vertical scroll position to the top border of the visible area if it is not visible.</p><pre class="programlisting">  if (visibleArea.Left() &lt; horiScrollLeft) { &#13;
    SetHorizontalScrollPosition(visibleArea.Left()); &#13;
    return true; &#13;
  } &#13;
 &#13;
  if (visibleArea.Top() &lt; vertScrollTop) { &#13;
    SetVerticalScrollPosition(visibleArea.Top()); &#13;
    return true; &#13;
  } &#13;
</pre><p>It becomes a little bit more complicated when it comes to the right and bottom border of the visible area. We start by calculating the distance between the right border of the visible area and the right scroll position (the left scroll position plus the size of the horizontal scroll bar) and increase the horizontal scroll position by that distance. In the same way, we calculate the distance between the right border of the visible area and the bottom scroll position (the top scroll position plus the size of the vertical scroll bar) and increase the vertical scroll position by that distance.</p><pre class="programlisting">  if (visibleArea.Right() &gt; horiScrollRight) { &#13;
    int horiDifference = visibleArea.Right() - horiScrollRight; &#13;
    SetHorizontalScrollPosition(horiScrollLeft + horiDifference); &#13;
    return true; &#13;
  } &#13;
 &#13;
  if (visibleArea.Bottom() &gt; vertScrollBottom) { &#13;
    int vertDifference = visibleArea.Bottom() - vertScrollBottom; &#13;
    SetVerticalScrollPosition(vertScrollTop + vertDifference); &#13;
    return true; &#13;
  } &#13;
 &#13;
  return false; &#13;
} &#13;
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec32"/>Character calculation</h1></div></div></div><p>The <code class="literal">GenerateParagraph</code> fucnction generates the character rectangles and the line lists of a paragraph every time characters are added or removed or when the font or alignment is changed. First, we generate lists of sizes and ascents for every character as well as the line list by calling the <code class="literal">GenerateSizeAndAscentList</code> and <code class="literal">GenerateLineList</code> methods. Then, we iterate through the line list and generate the character rectangles by calling the <code class="literal">GenerateLineRectList</code> method. Finally, we invalidate the characters that have been changed by comparing them to the original rectangle lists:</p><pre class="programlisting">void WordDocument::GenerateParagraph(Paragraph* paragraphPtr) { &#13;
  if (!charList.Empty()) { &#13;
    DynamicList&lt;Size&gt; sizeList; &#13;
    DynamicList&lt;int&gt; ascentList; &#13;
    DynamicList&lt;CharInfo&gt; prevCharList; &#13;
&#13;
    charList.Copy(prevCharList, paragraphPtr-&gt;First(), &#13;
                  paragraphPtr-&gt;Last()); &#13;
 &#13;
    GenerateSizeAndAscentList(paragraphPtr, sizeList, ascentList); &#13;
    GenerateLineList(paragraphPtr, sizeList, ascentList); &#13;
 &#13;
    for (LineInfo* lineInfoPtr : paragraphPtr-&gt;LinePtrList()) { &#13;
      if (paragraphPtr-&gt;AlignmentField() == Justified) { &#13;
        GenerateJustifiedLineRectList(paragraphPtr, lineInfoPtr, &#13;
                                      sizeList, ascentList); &#13;
      } &#13;
      else {      &#13;
        GenerateRegularLineRectList(paragraphPtr, lineInfoPtr, &#13;
                                    sizeList, ascentList); &#13;
      } &#13;
    } &#13;
 &#13;
    GenerateRepaintSet(paragraphPtr, prevCharList); &#13;
  } &#13;
} &#13;
</pre><div><div><div><div><h2 class="title"><a id="ch07lvl2sec60"/>Character size and ascent line</h2></div></div></div><p>The ascent line separates the upper and lower part of a letter, which is shown in the following figure:</p><p>
</p><div><img src="img/B05475_07_02.jpg" alt="Character size and ascent line"/></div><p>
</p><p>The <code class="literal">GenerateSizeAndAscentList</code> method fills the given lists with the size (width and height) and ascent of every character in the paragraph:</p><pre class="programlisting">void WordDocument::GenerateSizeAndAscentList &#13;
         (Paragraph* paragraphPtr, DynamicList&lt;Size&gt;&amp; sizeList, &#13;
             DynamicList&lt;int&gt;&amp; ascentList) { &#13;
  int index = 0; &#13;
 &#13;
  for (int charIndex = paragraphPtr-&gt;First(); &#13;
       charIndex &lt;= paragraphPtr-&gt;Last(); ++charIndex) { &#13;
    CharInfo charInfo = charList[charIndex]; &#13;
    TCHAR tChar = (charInfo.Char() == NewLine) ? Space &#13;
                                               : charInfo.Char(); &#13;
 &#13;
    int width = GetCharacterWidth(charInfo.CharFont(), tChar), &#13;
        height = GetCharacterHeight(charInfo.CharFont()), &#13;
        ascent = GetCharacterAscent(charInfo.CharFont()); &#13;
 &#13;
    sizeList.PushBack(Size(width, height)); &#13;
    ascentList.PushBack(ascent); &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec61"/>Line generation</h2></div></div></div><p>The <code class="literal">GenerateLineList</code> method generates the line list. The main point is that we have to decide how many words fit on each line. We iterate through the characters and calculate the size of each word. When the next word does not fit on the line, we start a new line. We save the index of the first and last character on the line as well as its top position. We also save its maximum height and ascent, which is the height and ascent of the largest character on the line:</p><pre class="programlisting">void WordDocument::GenerateLineList(Paragraph* paragraphPtr, &#13;
                                    DynamicList&lt;Size&gt;&amp; sizeList, &#13;
                                    DynamicList&lt;int&gt;&amp; ascentList){ &#13;
  int maxHeight = 0, maxAscent = 0, lineWidth = 0, &#13;
      spaceLineHeight = 0, spaceLineAscent = 0, &#13;
      startIndex = paragraphPtr-&gt;First(), spaceIndex = -1; &#13;
</pre><p>We delete the lines previously stored in the line list. The line list and the paragraph height are cleared. The <code class="literal">lineTop</code> variable is set to zero and is used when calculating the top position of each line.</p><pre class="programlisting">  for (LineInfo* lineInfoPtr : paragraphPtr-&gt;LinePtrList()) { &#13;
    delete lineInfoPtr; &#13;
  } &#13;
 &#13;
  paragraphPtr-&gt;Height() = 0; &#13;
  paragraphPtr-&gt;LinePtrList().Clear(); &#13;
  int lineTop = 0; &#13;
 &#13;
  for (int charIndex = paragraphPtr-&gt;First(); &#13;
       charIndex &lt;= paragraphPtr-&gt;Last(); ++charIndex) { &#13;
    CharInfo charInfo = charList[charIndex]; &#13;
 &#13;
    if (charInfo.Char() != NewLine) { &#13;
      lineWidth += &#13;
        sizeList[charIndex - paragraphPtr-&gt;First()].Width(); &#13;
    } &#13;
</pre><p>If the <code class="literal">nextFont</code> parameter is active (does not equal <code class="literal">SystemFont</code>) and we have reached the edit index in edit mode, we calculate the height and ascent of the <code class="literal">nextFont</code> parameter. In this case, we are only interested in the height and ascent of the font, and we do not need to calculate the width of its average character.</p><pre class="programlisting">    if ((nextFont != SystemFont) &amp;&amp; (charIndex == editIndex) &amp;&amp; &#13;
        (wordMode == WordEdit)) { &#13;
      maxHeight = max(maxHeight, GetCharacterHeight(nextFont)); &#13;
      maxAscent = max(maxAscent, GetCharacterAscent(nextFont)); &#13;
    } &#13;
</pre><p>Note that we have to subtract the first index of the paragraph, since the indexes of each line are relative to the beginning of the paragraph. Remember that the character list is common to all paragraphs in the document.</p><pre class="programlisting">    else { &#13;
      maxHeight = max(maxHeight, &#13;
        sizeList[charIndex - paragraphPtr-&gt;First()].Height()); &#13;
      maxAscent = max(maxAscent, &#13;
        ascentList[charIndex - paragraphPtr-&gt;First()]); &#13;
    } &#13;
 &#13;
    if (charInfo.Char() == Space) { &#13;
      spaceIndex = charIndex; &#13;
 &#13;
      spaceLineHeight = max(spaceLineHeight, maxHeight); &#13;
      spaceLineAscent = max(spaceLineAscent, maxAscent); &#13;
 &#13;
      maxHeight = 0; &#13;
      maxAscent = 0; &#13;
    } &#13;
</pre><p>When we find a newline, we have reached the end of the paragraph.</p><pre class="programlisting">    if (charInfo.Char() == NewLine) { &#13;
      spaceLineHeight = max(spaceLineHeight, maxHeight); &#13;
      spaceLineAscent = max(spaceLineAscent, maxAscent); &#13;
 &#13;
      LineInfo* lineInfoPtr = &#13;
        new LineInfo(startIndex - paragraphPtr-&gt;First(), &#13;
                     charIndex - paragraphPtr-&gt;First(), &#13;
                     lineTop, spaceLineHeight, spaceLineAscent); &#13;
      assert(lineInfoPtr != nullptr); &#13;
 &#13;
&#13;
&#13;
&#13;
      for (int index = lineInfoPtr-&gt;First(); &#13;
           index &lt;= lineInfoPtr-&gt;Last(); ++index) { &#13;
        charList[paragraphPtr-&gt;First() + index].LineInfoPtr() = &#13;
          lineInfoPtr; &#13;
      } &#13;
 &#13;
      paragraphPtr-&gt;Height() += spaceLineHeight; &#13;
      paragraphPtr-&gt;LinePtrList().PushBack(lineInfoPtr); &#13;
      break; &#13;
    } &#13;
</pre><p>When the width of the edit line exceeds the page width, we have, in fact, three different cases:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The line is made up by at least one complete word (<code class="literal">space</code> is not equal to minus one)</li><li class="listitem" style="list-style-type: disc">The line is made up by one word too long to fit on the page (<code class="literal">space</code> is equal to minus one and <code class="literal">charIndex</code> is greater than <code class="literal">startIndex</code>)</li><li class="listitem" style="list-style-type: disc">The line is made up by one single character wider than the page (space is equal to minus one and <code class="literal">charIndex</code> equals <code class="literal">startIndex</code></li></ul></div><p>The third case is unlikely but possible.</p><pre class="programlisting">    if (lineWidth &gt; PageInnerWidth()) { &#13;
      LineInfo* lineInfoPtr = new LineInfo(); &#13;
      assert(lineInfoPtr != nullptr); &#13;
      lineInfoPtr-&gt;Top() = lineTop; &#13;
      lineTop += spaceLineHeight; &#13;
</pre><p>If the line is constituted by at least one complete word followed by a space, we discard the latest space and start the new line from the next character.</p><pre class="programlisting">      if (spaceIndex != -1) { &#13;
        lineInfoPtr-&gt;First() = startIndex - paragraphPtr-&gt;First(); &#13;
        lineInfoPtr-&gt;Last() = spaceIndex - paragraphPtr-&gt;First(); &#13;
        lineInfoPtr-&gt;Ascent() = spaceLineAscent; &#13;
        lineInfoPtr-&gt;Height() = spaceLineHeight; &#13;
        startIndex = spaceIndex + 1; &#13;
      } &#13;
</pre><p>If the line is constituted by one single word (with at least two letters) such that its width does not fit on the page, we define the line to hold the word including the last fitting character, and we start the new line with the succeeding character.</p><pre class="programlisting">      else { &#13;
        if (charIndex &gt; startIndex) { &#13;
          lineInfoPtr-&gt;First() = &#13;
            startIndex - paragraphPtr-&gt;First(); &#13;
          lineInfoPtr-&gt;Last() = &#13;
            charIndex - paragraphPtr-&gt;First() - 1; &#13;
          startIndex = charIndex; &#13;
        } &#13;
</pre><p>Finally, in the unlikely event that one single character is wider than the page, we just let that character constitute the whole line and let the next index be the start index.</p><pre class="programlisting">        else { &#13;
          lineInfoPtr-&gt;First() =charIndex - paragraphPtr-&gt;First(); &#13;
          lineInfoPtr-&gt;Last() = charIndex - paragraphPtr-&gt;First(); &#13;
          startIndex = charIndex + 1; &#13;
        } &#13;
</pre><p>The height and ascent of the line are the maximal height and ascent (the height and ascent of the character with the largest height and ascent).</p><pre class="programlisting">        lineInfoPtr-&gt;Height() = maxHeight; &#13;
        lineInfoPtr-&gt;Ascent() = maxAscent; &#13;
      } &#13;
</pre><p>We set all characters on the line to point at the line.</p><pre class="programlisting">      for (int index = lineInfoPtr-&gt;First(); &#13;
           index &lt;= lineInfoPtr-&gt;Last(); ++index) { &#13;
        charList[paragraphPtr-&gt;First() + index].LineInfoPtr() = &#13;
          lineInfoPtr; &#13;
      } &#13;
</pre><p>The height of the paragraph is increased by the height of the line, and the line pointer is added to the line pointer list.</p><pre class="programlisting">      paragraphPtr-&gt;Height() += spaceLineHeight; &#13;
      paragraphPtr-&gt;LinePtrList().PushBack(lineInfoPtr); &#13;
</pre><p>In order to prepare for the next iteration, the line width, the maximal height, and ascent are cleared.</p><pre class="programlisting">      lineWidth = 0; &#13;
      maxAscent = 0; &#13;
      maxHeight = 0; &#13;
</pre><p>The <code class="literal">charIndex</code> loop variable is set to the latest space index and the <code class="literal">spaceIndex</code> is set to <code class="literal">-1</code>, indicating that we have not yet found a space on the new line.</p><pre class="programlisting">      charIndex = startIndex; &#13;
      spaceIndex = -1; &#13;
    } &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec62"/>Regular and justified rectangle list generation</h2></div></div></div><p>When we have decided the size and ascent line for each character and divided the characters into lines, it is time to generate the character rectangles. For a regular (left, center, or right-aligned) paragraph, we do that in three steps. The justified-aligned paragraph is handled by the <code class="literal">GenerateJustifiedLineRectList</code> method as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">We sum the width of each line.</li><li class="listitem">We find the leftmost position.</li><li class="listitem">We generate the rectangles for the characters.</li></ol></div><pre class="programlisting">void WordDocument::GenerateRegularLineRectList &#13;
                   (Paragraph* paragraphPtr,LineInfo* lineInfoPtr, &#13;
                    DynamicList&lt;Size&gt;&amp; sizeList, &#13;
                    DynamicList&lt;int&gt;&amp; ascentList) { &#13;
</pre><p>We iterate through the characters of the line and sum its width. If the character after the last character of the line is not a space or newline, we generate its rectangle too.</p><pre class="programlisting">  for (int charIndex = lineInfoPtr-&gt;First(); &#13;
       charIndex &lt; lineInfoPtr-&gt;Last(); ++charIndex) { &#13;
    if (charList[paragraphPtr-&gt;First() + charIndex].Char() != &#13;
        NewLine) { &#13;
      lineWidth += &#13;
        sizeList[charIndex - lineInfoPtr-&gt;First()].Width(); &#13;
    } &#13;
  } &#13;
 &#13;
  if ((charList[paragraphPtr-&gt;First()+lineInfoPtr-&gt;Last()].Char() &#13;
      != Space) &amp;&amp; &#13;
      (charList[paragraphPtr-&gt;First()+lineInfoPtr-&gt;Last()].Char() &#13;
      !=NewLine)) { &#13;
    lineWidth += &#13;
      sizeList[lineInfoPtr-&gt;Last()-lineInfoPtr-&gt;First()].Width(); &#13;
  } &#13;
</pre><p>Then, we find the leftmost position of the line to start the rectangle generation. In the case of left alignment, the starting position is always zero. In the case of center alignment, it is half the difference between the page and text width. In the case of right alignment, it is the whole difference between the page and text width.</p><pre class="programlisting">  int leftPos; &#13;
 &#13;
  switch (paragraphPtr-&gt;AlignmentField()) { &#13;
    case Left: &#13;
      leftPos = 0; &#13;
      break; &#13;
 &#13;
    case Center: &#13;
      leftPos = (PageInnerWidth() - lineWidth) / 2; &#13;
      break; &#13;
 &#13;
    case Right: &#13;
      leftPos = PageInnerWidth() - lineWidth; &#13;
      break; &#13;
  } &#13;
</pre><p>Next, we iterate through the line and generate each rectangle. If the character after the last character of the line is a space, we generate its rectangle too.</p><pre class="programlisting">  for (int charIndex = lineInfoPtr-&gt;First(); &#13;
       charIndex &lt;= lineInfoPtr-&gt;Last(); ++charIndex) { &#13;
    Size charSize = sizeList[charIndex]; &#13;
    int ascent = ascentList[charIndex]; &#13;
    int topPos = lineInfoPtr-&gt;Top() + &#13;
                 lineInfoPtr-&gt;Ascent() - ascent; &#13;
    charList[paragraphPtr-&gt;First() + charIndex].CharRect() = &#13;
      Rect(leftPos, topPos, leftPos + charSize.Width(), &#13;
           topPos + charSize.Height()); &#13;
    leftPos += charSize.Width(); &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">GenerateJustifiedLineRectList</code> method is slightly more complicated than the <code class="literal">GenerateRegularLineRectList</code> method. We follow the same three steps as mentioned previously. However, when calculating the width of the text, we omit the width of spaces from the text width. Instead, we count the number of spaces.</p><pre class="programlisting">void WordDocument::GenerateJustifiedLineRectList &#13;
     (Paragraph* paragraphPtr, LineInfo* lineInfoPtr, &#13;
      DynamicList&lt;Size&gt;&amp; sizeList, DynamicList&lt;int&gt;&amp; ascentList) { &#13;
  int spaceCount = 0, lineWidth = 0; &#13;
 &#13;
  for (int charIndex = lineInfoPtr-&gt;First(); &#13;
       charIndex &lt;= lineInfoPtr-&gt;Last(); ++charIndex) { &#13;
    CharInfo charInfo = &#13;
      charList[paragraphPtr-&gt;First() + charIndex]; &#13;
</pre><p>We include every character on the line in <code class="literal">lineWidth</code>, except spaces and newlines.</p><pre class="programlisting">    if (charInfo.Char() == Space) { &#13;
      ++spaceCount; &#13;
    } &#13;
    else if (charInfo.Char() != NewLine) { &#13;
      lineWidth += sizeList[charIndex].Width(); &#13;
    } &#13;
  } &#13;
 &#13;
  if ((charList[paragraphPtr-&gt;First()+lineInfoPtr-&gt;Last()].Char() &#13;
      != Space) &amp;&amp; &#13;
      (charList[paragraphPtr-&gt;First()+lineInfoPtr-&gt;Last()].Char()  &#13;
      !=NewLine)) { &#13;
    lineWidth += sizeList[lineInfoPtr-&gt;Last()].Width(); &#13;
  } &#13;
</pre><p>Similar to the previous left-alignment case, the leftmost position in justified alignment is always zero. If there is at least one space on the line, we calculate the width of the spaces by dividing the difference between the page and text width with the number of spaces. We need to check that the number of spaces is greater than zero. Otherwise, we would be dividing by zero. On the other hand, if the number of spaces is zero, we do not need the space width.</p><pre class="programlisting">  int leftPos = 0, spaceWidth; &#13;
  if (spaceCount &gt; 0) { &#13;
    spaceWidth = (PageInnerWidth() - lineWidth) / spaceCount; &#13;
  } &#13;
 &#13;
  for (int charIndex = lineInfoPtr-&gt;First(); &#13;
       charIndex &lt;= lineInfoPtr-&gt;Last(); ++charIndex) { &#13;
    Size charSize = sizeList[charIndex]; &#13;
    int ascent = ascentList[charIndex], charWidth; &#13;
</pre><p>If the character is a space, we use the calculated space width instead of its actual width.</p><pre class="programlisting">    if (charList[paragraphPtr-&gt;First() + charIndex].Char() == &#13;
        Space) { &#13;
      charWidth = spaceWidth; &#13;
    } &#13;
    else { &#13;
      charWidth = charSize.Width(); &#13;
    } &#13;
 &#13;
    int topPos = &#13;
      lineInfoPtr-&gt;Top() + lineInfoPtr-&gt;Ascent() - ascent; &#13;
    charList[paragraphPtr-&gt;First() + charIndex].CharRect() = &#13;
      Rect(leftPos, topPos, leftPos + charWidth, &#13;
           topPos + charSize.Height()); &#13;
    leftPos += charWidth; &#13;
  } &#13;
} &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec63"/>Invalidate rectangle set generation</h2></div></div></div><p>Finally, we need to invalidate the set of rectangles that have been changed. There are two cases to be considered. First, we have the rectangles themselves. We iterate through the character list, and for each character we compare its previous and current rectangle, and invalidate both of them if they differ (which causes both their areas to be repainted). Remember that invalidate means that we prepare the areas to be repainted next time the window is updated. Then we to look into the line list and add the areas to the left and right of the text on the line, if present.</p><pre class="programlisting">void WordDocument::GenerateRepaintSet(Paragraph* paragraphPtr, &#13;
                           DynamicList&lt;CharInfo&gt;&amp; prevCharList) { &#13;
  Point topLeft(0, paragraphPtr-&gt;Top()); &#13;
 &#13;
  for (int charIndex = paragraphPtr-&gt;First(); &#13;
       charIndex &lt;= paragraphPtr-&gt;Last(); ++ charIndex) { &#13;
    Rect prevRect = &#13;
      prevCharList[charIndex - paragraphPtr-&gt;First()].CharRect(), &#13;
         currRect = charList[charIndex].CharRect(); &#13;
 &#13;
    if (prevRect != currRect) { &#13;
      Invalidate(topLeft + prevRect); &#13;
      Invalidate(topLeft + currRect); &#13;
    } &#13;
  }  &#13;
  int pageWidth = PageInnerWidth(); &#13;
 &#13;
  for (LineInfo* lineInfoPtr : paragraphPtr-&gt;LinePtrList()) { &#13;
    Rect firstRect = charList[paragraphPtr-&gt;First() + &#13;
                              lineInfoPtr-&gt;First()].CharRect(); &#13;
 &#13;
    if (firstRect.Left() &gt; 0) { &#13;
      Rect leftRect(0, lineInfoPtr-&gt;Top(), firstRect.Left(), &#13;
                    lineInfoPtr-&gt;Top() + lineInfoPtr-&gt;Height()); &#13;
      Invalidate(topLeft + leftRect); &#13;
    } &#13;
 &#13;
    Rect lastRect = charList[paragraphPtr-&gt;First() + &#13;
                             lineInfoPtr-&gt;Last()].CharRect(); &#13;
 &#13;
    if (lastRect.Right() &lt; pageWidth) { &#13;
      Rect rightRect(lastRect.Right(), lineInfoPtr-&gt;Top(), &#13;
             pageWidth, lineInfoPtr-&gt;Top()+lineInfoPtr-&gt;Height()); &#13;
      Invalidate(topLeft + rightRect); &#13;
    } &#13;
  } &#13;
} &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, we finished the development of our word processor by looking into keyboard handling and character calculation. In <a class="link" href="ch08.html" title="Chapter 8. Building a Spreadsheet Application">Chapter 8</a>, <em>Building a Spreadsheet Application</em>, we will start developing a spreadsheet program.</p></div></body></html>