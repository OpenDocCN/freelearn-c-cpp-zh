- en: Chapter 6. Getting Wired and Managing Downloads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章：连接网络和管理下载
- en: 'Network modules have become crucial nowadays and are also a must-have feature
    for development frameworks; therefore, Qt does provide APIs for network programming.
    Sit tight, we''re going to get wired and download files from the network. In addition
    to this, threading is included in this chapter, which is a vital programming skill
    to avoid blocking. This chapter''s topics are listed as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络模块在当今已成为关键部分，也是开发框架必备的功能；因此，Qt 为网络编程提供了 API。请耐心等待，我们将连接网络并下载文件。此外，本章还包括了线程，这是避免阻塞的重要编程技能。本章的主题如下：
- en: Introducing Qt network programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Qt 网络编程
- en: Utilizing `QNetworkAccessManager`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 `QNetworkAccessManager`
- en: Making use of the progress bar
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用进度条
- en: Writing multithreaded applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写多线程应用程序
- en: Managing a system network session
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理系统网络会话
- en: Introducing Qt network programming
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Qt 网络编程
- en: Qt supports network programming and provides lots of high-level APIs to ease
    your work. `QNetworkRequest`, `QNetworkReply`, and `QNetworkAccessManager` use
    common protocols to perform network operations. Qt also offers lower-level classes
    to represent low level network concepts.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 支持网络编程并提供大量高级 API 以简化您的开发工作。`QNetworkRequest`、`QNetworkReply` 和 `QNetworkAccessManager`
    使用通用协议执行网络操作。Qt 还提供表示低级网络概念的底层类。
- en: In this chapter, we're going to utilize the high-level APIs that Qt has offered
    to write a downloader to retrieve the Internet files and save them to your disk.
    As I mentioned earlier, the application will need the `QNetworkRequest`, `QNetworkReply`,
    and `QNetworkAccessManager` classes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用 Qt 提供的高级 API 来编写一个下载器，用于检索互联网文件并将它们保存到您的磁盘上。正如我之前提到的，该应用程序将需要 `QNetworkRequest`、`QNetworkReply`
    和 `QNetworkAccessManager` 类。
- en: Firstly, all network requests are represented by the `QNetworkRequest` class,
    which is a general container for information associated with a request, including
    the header and encryption. Currently, HTTP, FTP, and local file URLs are supported
    for uploading and downloading.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，所有网络请求都由 `QNetworkRequest` 类表示，它是一个用于与请求相关信息的通用容器，包括头信息和加密。目前，支持 HTTP、FTP
    和本地文件 URL 的上传和下载。
- en: Once a request has been created, the `QNetworkAccessManager` class is used to
    dispatch it and emits signals, reporting the progress. Then, it creates the reply
    to a network request, represented by the `QNetworkReply` class. At the same time,
    the signals provided by `QNetworkReply` can be used to monitor each reply individually.
    Some developers will discard the reference to the reply and use the `QNetworkAccessManager`
    class's signals for that purpose, though. All replies can be handled synchronously
    or asynchronously, because `QNetworkReply` is a subclass of `QIODevice`, which
    means that it's possible to implement nonblocking operations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个请求，就使用 `QNetworkAccessManager` 类来分发它并发出信号，报告进度。然后，它创建一个网络请求的回复，由 `QNetworkReply`
    类表示。同时，`QNetworkReply` 提供的信号可以用来单独监控每个回复。尽管如此，一些开发者会丢弃回复的引用，并使用 `QNetworkAccessManager`
    类的信号来达到这个目的。所有回复都可以同步或异步处理，因为 `QNetworkReply` 是 `QIODevice` 的子类，这意味着可以实现非阻塞操作。
- en: 'Here is a diagram that describes the relationship between these classes:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个描述这些类之间关系的图示：
- en: '![Introducing Qt network programming](img/4615OS_06_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![介绍 Qt 网络编程](img/4615OS_06_01.jpg)'
- en: 'Likewise, the network-related stuff is offered in the network module. To use
    this module, you need to edit the project file and add network to QT. Now, create
    a new Qt Widget Application project and edit the project file. In our `Downloader_Demo`
    example, the `downloader_demo.pro` project file is shown here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，网络相关的内容在网络模块中提供。要使用此模块，您需要编辑项目文件并将网络添加到 QT。现在，创建一个新的 Qt Widget 应用程序项目并编辑项目文件。在我们的
    `Downloader_Demo` 示例中，`downloader_demo.pro` 项目文件如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Utilizing QNetworkAccessManager
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 QNetworkAccessManager
- en: Now, we're going to discover how to write an application that is able to download
    files from other locations. By other locations, we mean that you can download
    files from a local position; it doesn't have to be an Internet address, since
    the local file URLs are supported by Qt as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨如何编写一个能够从其他位置下载文件的应用程序。这里的“其他位置”意味着您可以从本地位置下载文件；它不一定是互联网地址，因为 Qt 也支持本地文件
    URL。
- en: 'First of all, let''s create a `Downloader` class that will use `QNetworkAccessManager`
    to do the downloading work for us. The `downloader.h` header file is pasted shown
    as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个`Downloader`类，它将使用`QNetworkAccessManager`为我们执行下载工作。以下是将`downloader.h`头文件粘贴显示的内容：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We expose the download slot to get the URL and the saving target. Accordingly,
    `saveFile` is used to store the saving target. In addition to this, we use an
    `naManager` object of the `QNetworkAccessManager` class to manage the downloading
    process.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暴露下载槽以获取URL和保存目标。相应地，`saveFile`用于存储保存目标。除此之外，我们使用`QNetworkAccessManager`类的`naManager`对象来管理下载过程。
- en: Let's check the definitions of these functions in the `downloader.cpp` file.
    In the following constructor, we connect the `naManager` object's `finished` signal
    to the `onDownloadFinished` slot. Therefore, when a network connection is finished,
    a relevant `QNetworkReply` reference will be passed via this signal.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`downloader.cpp`文件中这些函数的定义。在以下构造函数中，我们将`naManager`对象的`finished`信号连接到`onDownloadFinished`槽。因此，当网络连接完成时，将通过此信号传递一个相关的`QNetworkReply`引用。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Accordingly, in the `onDownloadFinished` slot, we have to handle `QNetworkReply`
    with caution. If there is any error, which means that the download has failed,
    we expose the `errorString()` function by the `errorString` signal. Otherwise,
    we call the `saveToDisk` function to save the file to the disk. Then, we use `deleteLater()`
    to release the `QNetworkReply` object safely. As stated in the Qt documentation,
    it's not safe to use the `delete` statement directly; since it's finished, we
    emit the available and running signals. Those signals will later be used to change
    the user interface.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，在`onDownloadFinished`槽中，我们必须谨慎处理`QNetworkReply`。如果有任何错误，这意味着下载失败，我们通过`errorString`信号暴露`errorString()`函数。否则，我们调用`saveToDisk`函数将文件保存到磁盘。然后，我们使用`deleteLater()`安全地释放`QNetworkReply`对象。正如Qt文档中所述，直接使用`delete`语句是不安全的；因为它已经完成，我们发出可用性和运行信号。这些信号将后来用于更改用户界面。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `saveToDisk` function, we just implement `QFile` to save all the downloaded
    data to the disk. This is feasible because `QNetworkReply` inherits from `QIODevice`.
    Therefore, in addition to the networking APIs, you can treat `QNetworkReply` as
    a normal `QIODevice` object. In this case, use the `readAll()` function to get
    all data:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在`saveToDisk`函数中，我们只是实现`QFile`将所有下载的数据保存到磁盘。这是可行的，因为`QNetworkReply`继承自`QIODevice`。因此，除了网络API之外，您可以将`QNetworkReply`视为一个普通的`QIODevice`对象。在这种情况下，使用`readAll()`函数获取所有数据：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, let's see inside the `download` function that will be used by `MainWindow`
    later. Firstly, we store the saved file to `saveFile`. Then, we construct `QNetworkRequest
    req` using the `QUrl` object, `url`. Next, we send `req` to the `naManager` object
    of `QNetworkAccessManager`, while saving the reference to the created `QNetworkManager`
    object to `reply`. After this, we connect the two `downloadProgress` signals together,
    which is simply exposing the `downloadProgress` signal of the reply. At last,
    we end up emitting two signals, indicating the availability and running status
    respectively.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看将被`MainWindow`后来使用的`download`函数内部。首先，我们将保存的文件存储到`saveFile`中。然后，我们使用`QUrl`对象`url`构建`QNetworkRequest
    req`。接下来，我们将`req`发送到`QNetworkAccessManager`的`naManager`对象，同时将创建的`QNetworkManager`对象的引用保存到`reply`中。之后，我们将两个`downloadProgress`信号连接在一起，这仅仅是暴露了回复的`downloadProgress`信号。最后，我们发出两个信号，分别表示可用性和运行状态。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We described the `Downloader` class. Now, we''re going to add `DownloadDialog`
    by navigating to **Qt Designer** | **Dialog with Buttons Bottom**. This class
    is used to get the URL and save the path for the user. For the design of `downloaddialog.ui`,
    we use the two `QLineEdit` objects to get the URL and saved path respectively.
    One of the object names is `urlEdit`, and the other is `saveAsEdit`. In order
    to open a file dialog for the user to choose the saving location, a `saveAsButton`
    attribute of `QPushButton` is added to the right-hand side of `saveAsEdit`. The
    following screenshot shows you the layout of this UI file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了`Downloader`类。现在，我们将通过导航到**Qt Designer** | **带有底部按钮的对话框**来添加`DownloadDialog`。这个类用于获取用户输入的URL和保存路径。对于`downloaddialog.ui`的设计，我们使用两个`QLineEdit`对象分别获取URL和保存路径。其中一个对象的名字是`urlEdit`，另一个是`saveAsEdit`。为了打开文件对话框让用户选择保存位置，我们在`saveAsEdit`的右侧添加了一个`QPushButton`的`saveAsButton`属性。以下截图显示了此UI文件的布局：
- en: '![Utilizing QNetworkAccessManager](img/4615OS_06_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![利用QNetworkAccessManager](img/4615OS_06_02.jpg)'
- en: You need to change the layout of this dialog to **Lay Out in a Grid**. In a
    similar way as we did before, in order to pass the values to the main window,
    we need to delete the default `accepted` signal and slot connection in **Signals
    & Slots Editor**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将此对话框的布局更改为**网格布局**。与之前类似，为了将值传递到主窗口，我们需要在**信号与槽编辑器**中删除默认的`accepted`信号和槽连接。
- en: 'The contents of this class''s `downloaddialog.h` header file are shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此类的`downloaddialog.h`头文件内容如下所示：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, a new signal named `accepted` is added to pass the URL and save
    the location. Besides, the two `private` slots are used to handle the `accepted`
    event of the button box and the `saveAsButtonClicked` signal, respectively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，添加了一个名为`accepted`的新信号，用于传递URL和保存位置。此外，两个`private`槽分别用于处理按钮框的`accepted`事件和`saveAsButtonClicked`信号。
- en: 'The definitions are in the `downloaddialog.cpp` source file, which is shown
    here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 定义在`downloaddialog.cpp`源文件中，如下所示：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the constructor of `DownloadDialog`, just connect the signals and slots.
    In the `onButtonAccepted` slot, we emit the `accepted` signal, which is to pass
    the URL and the saving path, where a temporary `QUrl` class is constructed using
    the text of `urlEdit`. Then, the `accept` function is invoked to close the dialog.
    Meanwhile, in the `onSaveAsButtonClicked` slot function, we use the `static` function
    provided by the `QFileDialog` class to obtain the saving location. Do nothing
    if the `QString` return is empty; this means that the user may have clicked on
    **Cancel** in the file dialog.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DownloadDialog`的构造函数中，仅连接信号和槽。在`onButtonAccepted`槽中，我们发出`accepted`信号，用于传递URL和保存路径，其中使用`urlEdit`的文本构造一个临时的`QUrl`类。然后，调用`accept`函数关闭对话框。同时，在`onSaveAsButtonClicked`槽函数中，我们使用`QFileDialog`类提供的`static`函数获取保存位置。如果`QString`返回值为空，则不执行任何操作；这意味着用户可能在文件对话框中点击了**取消**。
- en: Making use of the progress bar
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用进度条
- en: 'An intuitive way to indicate the downloading progress is by using a progress
    bar. In Qt, it is the `QProgressBar` class that provides a horizontal or vertical
    progress bar widget. It uses `minimum`, `value`, and `maximum` to determine the
    completed percentage. The percentage is calculated by the formula, `(value – minimum)
    / (maximum – minimum)`. We''ll use this useful widget in our example application
    by performing the following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用进度条直观地指示下载进度是一种方法。在Qt中，提供水平或垂直进度条小部件的是`QProgressBar`类。它使用`minimum`、`value`和`maximum`来确定完成百分比。百分比通过以下公式计算，`(value
    – minimum) / (maximum – minimum)`。我们将在示例应用程序中通过以下步骤使用这个有用的组件：
- en: Go back to the `MainWindow` class.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`MainWindow`类。
- en: Edit the `mainwindow.ui` file in the **Design** mode.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设计**模式下编辑`mainwindow.ui`文件。
- en: Drag **Push Button** and rename it as `newDownloadButton` with `New Download`
    as its text.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动**按钮**并将其重命名为`newDownloadButton`，其文本为`New Download`。
- en: Drag **Progress Bar** just beneath `newDownloadButton`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**进度条**拖到`newDownloadButton`下方。
- en: Change the layout to **Lay Out Vertically**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将布局更改为**垂直布局**。
- en: Uncheck `textVisible` in the `progressBar` widget's property.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`progressBar`小部件的属性中取消选中`textVisible`。
- en: 'The push button, `newDownloadButton`, is used to popup `DownloadDialog` to
    get a new download task. We need to apply some modifications to `mainwindow.h`,
    as suggested here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 推出按钮`newDownloadButton`用于弹出`DownloadDialog`以获取新的下载任务。我们需要根据以下建议对`mainwindow.h`进行一些修改：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In order to use the `Downloader` and `DownloadDialog` classes, we have to include
    them in the `header` file. Then, we can include them as the `private` pointers.
    For the `private` slots, `onNewDownloadButtonPressed` is used to handle the `newDownloadButton`
    clicked signal. While `showMessage` is a slot function that displays the message
    on status bar, the last one, `onDownloadProgress`, is used to update the progress
    bar.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`Downloader`和`DownloadDialog`类，我们必须在`header`文件中包含它们。然后，我们可以将它们作为`private`指针包含。对于`private`槽，`onNewDownloadButtonPressed`用于处理`newDownloadButton`点击信号。而`showMessage`是一个槽函数，用于在状态栏上显示消息，最后一个`onDownloadProgress`用于更新进度条。
- en: 'Similarly, for the `mainwindow.cpp` source file, we connect the signals and
    slots in the constructor, shown as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于`mainwindow.cpp`源文件，我们在构造函数中连接信号和槽，如下所示：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before beginning to create these connections, we need to hide the progress bar
    and create a new `Downloader` class, using `MainWindow` as the `QObject` parent.
    Meanwhile, in these connections, the first one is to connect the `newDownloadButton`
    clicked signal. Then, we connect the `errorString` signal of downloader to `showMessage`,
    which enables the status bar to show the error message directly. Next, we connect
    the `downloadProgress` signal to our `onDownloadProgress` handler. As for the
    available and running signals, they're connected to control the availability and
    visibility of `newDownloadButton` and `progressBar`, respectively.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始创建这些连接之前，我们需要隐藏进度条并创建一个新的`Downloader`类，使用`MainWindow`作为`QObject`父类。同时，在这些连接中，第一个是将`newDownloadButton`点击信号连接起来。然后，我们将下载器的`errorString`信号连接到`showMessage`，这样状态栏就可以直接显示错误消息。接下来，我们将`downloadProgress`信号连接到我们的`onDownloadProgress`处理程序。至于可用和运行信号，它们分别连接到控制`newDownloadButton`和`progressBar`的可用性和可见性。
- en: Inside the `onNewDownloadButtonPressed` slot function, we construct a `DownloadDialog`
    object, `ddlg`, then connect the accepted signal of `DownloadDialog` to the `Downloader`
    class's download slot. Then, use `exec` to run the dialog and block the event
    loop. After this, we call `deleteLater` to safely release the resource allocated
    for `ddlg`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onNewDownloadButtonPressed`槽函数内部，我们构建一个`DownloadDialog`对象`ddlg`，然后将`DownloadDialog`的接受信号连接到`Downloader`类的下载槽。然后使用`exec`运行对话框并阻塞事件循环。之后，我们调用`deleteLater`来安全地释放为`ddlg`分配的资源。
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As for the `showMessage` slot function, it simply calls the `showMessage` function
    of `statusBar` with a three second timeout, as shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`showMessage`槽函数，它只是简单地调用`statusBar`的`showMessage`函数，并设置三秒的超时时间，如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At last, we can update the progress bar via the `onDownloadProgress` function,
    which is shown in the following code. Since the `minimum` value is `0` by default,
    we don't need to change it. Instead, we change the `maximum` value to the total
    bytes of the download, and `value` to the current downloaded bytes. Note that
    if the total size is unknown, then the value of the total size is `-1`, which
    will happen to make the progress bar display in a busy style.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过`onDownloadProgress`函数更新进度条，如下面的代码所示。由于`minimum`值默认为`0`，我们不需要更改它。相反，我们将`maximum`值更改为下载的总字节数，并将`value`更改为当前已下载的字节数。请注意，如果总大小未知，则总大小的值为`-1`，这将导致进度条以忙碌样式显示。
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, give the application a run and click on the **New Download** button. The
    **Add New Download** dialog will pop up, where you can add a new download task
    as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序并点击**新下载**按钮。将弹出**添加新下载**对话框，您可以在其中添加新的下载任务，如下所示：
- en: '![Making use of the progress bar](img/4615OS_06_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![利用进度条](img/4615OS_06_03.jpg)'
- en: 'Click on **OK**, if there is no error; a progress bar is expected to show up
    and display the current download progress, shown as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**，如果没有错误；预期将显示进度条并显示当前的下载进度，如下所示：
- en: '![Making use of the progress bar](img/4615OS_06_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![利用进度条](img/4615OS_06_04.jpg)'
- en: As you can see, the **New Download** button is not enabled now, since it is
    associated with the available signal of `downloader`. Besides, the progress bar
    won't even show if `downloader` isn't running.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，**新下载**按钮目前不可用，因为它与`downloader`的可用信号相关联。此外，如果`downloader`没有运行，进度条甚至不会显示。
- en: While this downloader demo still lacks a basic function, which is to cancel
    downloading, it is, in fact, easy to implement. There is a slot function called
    `abort` in the `QNetworkReply` class. You may have to store the reference to `QNetworkReply`
    and then call abort if some button in `MainWindow` is clicked. This won't be demonstrated
    here. It has been left up to you to practice on your own.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个下载器演示仍然缺少一个基本功能，即取消下载，但实际上很容易实现。在`QNetworkReply`类中有一个名为`abort`的槽函数。您可能需要存储`QNetworkReply`的引用，然后在`MainWindow`中的某个按钮被点击时调用`abort`。这里不会演示这个功能。它已经留给了您自己练习。
- en: Writing multithreaded applications
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写多线程应用程序
- en: I bet multithread or threading isn't unfamiliar to you. Using other threads
    saves the GUI application from freezing. If the application runs on a single thread,
    it'll get stuck if there it's a synchronous time-consuming operation. Multiple
    threads make application running much smoother. Although most of the Qt Network
    APIs are nonblocking, it is not that difficult to practice on it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Qt provides a `QThread` class to implement threading on all supported platforms.
    In other words, we don't need to write platform-specific code utilizing POSIX
    Threads or a Win32 API. Instead, `QThread` provides a platform-independent way
    to manage threads. A `QThread` object manages a thread within the program, which
    begins executing in `run()` and ends when calling `quit()` or `exit()`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: For some historical reason, it's still possible to subclass `QThread` and put
    the blocking or time-consuming code in the reimplemented `run()` function. However,
    it's considered an incorrect practice and is not recommended to do so. The right
    way is to use `QObject::moveToThread`, which will be demonstrated later.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to put the `Downloader::download` function into a new thread.
    In fact, it''s the `QNetworkAccessManager::get` function that will be moved onto
    another thread. Let''s create a new C++ class, `DownloadWorker`, whose `downloadworker.h`
    header file is pasted as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The constructor is removed from the code because we can't make a child object
    that will be in another thread. This is almost the only limitation of `QThread`.
    In contrast to this, you can connect signals and slots between different threads
    without any problems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Don't split parent and children between threads. Parent objects and children
    objects can only be in the same thread.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare the `doDownload` slot function to do the `QNetworkAccessManager::get`
    function work for us. On the other hand, the `downloadProgress` signal is used
    to expose the `downloadProgress` signal of `QNetworkReply` as we did. The contents
    of `downloadworker.cpp` is shown as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code is an example of a simple `worker` class. Now, we have to
    change the `Downloader` class to use the `DownloadWorker` class. The `header`
    file of the `Downloader` class, `downloader.h`, needs a few modifications, shown
    here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, we have declared a new `private` member, `workerThread`, which
    is a type of `QThread`. Also, a `DownloadWorker` object worker has been declared
    as well. There are more changes in the `downloader.cpp` source file, as displayed
    here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the constructor, we will create a new `DownloadWorker` class, and move it
    to another thread, `workerThread`. By connecting the `finished` signal of `workerThread`
    to the `deleteLater` function of `worker`, the resources of `worker` can be deleted
    safely after the exit of `workerThread`. Then, we need to expose `downloadProgress`
    again, since it's moved into `worker`. At last, we call the `start()` function,
    to start `workerThread`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: As a reverse operation, we call the `quit()` function to exit `workerThread`
    and then use `wait()` to ensure it quits successfully.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为反向操作，我们调用`quit()`函数退出`workerThread`，然后使用`wait()`确保其成功退出。
- en: Since a lot of code has been moved into the `doDownload` function of `worker`,
    we only need to call `doDownload` of `worker` here. In fact, the function calling
    is inter-thread, which means that the main thread won't be blocked by that statement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大量的代码已经移动到`worker`的`doDownload`函数中，我们在这里只需要调用`worker`的`doDownload`。实际上，函数调用是跨线程的，这意味着主线程不会因为那个语句而被阻塞。
- en: Since `get` is not blocking, you may not feel the difference. However, I'm sure
    you have some applications that have frozen, which therefore need to be modified
    to adapt to `QThread`. Always remember to put only the background blocking operations
    in another thread. This is mainly because these operations are easily separated
    from GUI into single objects without parents or children. Due to this limitation,
    almost all the GUI objects must be in the same thread, which is the main thread
    in most cases.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`get`不是阻塞的，你可能感觉不到区别。然而，我相信你有一些应用程序已经冻结了，因此需要修改以适应`QThread`。始终记得只将后台阻塞操作放在另一个线程中。这主要是因为这些操作很容易从GUI中分离成没有父或子对象的单个对象。由于这种限制，几乎所有GUI对象都必须在同一个线程中，在大多数情况下是主线程。
- en: Managing a system network session
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理系统网络会话
- en: In addition to networking applications, Qt also provides you with cross-platform
    APIs to control network interfaces and access points. Although it's not very common
    to control the network state, there are some certain situations where it's required
    to do this.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网络应用程序之外，Qt还为你提供了跨平台的API来控制网络接口和接入点。尽管控制网络状态并不常见，但在某些情况下确实需要这样做。
- en: 'First, I''d like to introduce `QNetworkConfigurationManager` to you. This class
    manages the network configurations provided by the system. It enables you access
    to them, as well as to detect the system''s capabilities during runtime. The network
    configuration is presented by the `QNetworkConfiguration` class, which abstracts
    a set of configuration options concerning how a network interface has to be configured
    in order to connect to the target network. To control the network session, you
    need to use the `QNetworkSession` class. This class provides you with control
    over the system''s access points and enables session management. It also enables
    you to control network interfaces that are represented by the `QNetworkInterface`
    class. To help you figure out this relationship, a diagram is shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我想向你介绍`QNetworkConfigurationManager`。这个类管理由系统提供的网络配置。它使你能够访问它们，并在运行时检测系统的能力。网络配置由`QNetworkConfiguration`类表示，它抽象了一组配置选项，这些选项涉及如何配置网络接口以连接到目标网络。要控制网络会话，你需要使用`QNetworkSession`类。这个类为你提供了对系统接入点的控制，并允许会话管理。它还允许你控制由`QNetworkInterface`类表示的网络接口。为了帮助你理解这种关系，这里显示了一个图表：
- en: '![Managing a system network session](img/4615OS_06_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![管理系统网络会话](img/4615OS_06_05.jpg)'
- en: As you can see, the structure is similar to `QNetworkAccessManager`, `QNetworkReply`,
    and `QNetworkRequest`. Especially, there is another manager class. Let's see how
    to deal with these classes in practice.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结构类似于`QNetworkAccessManager`、`QNetworkReply`和`QNetworkRequest`。特别是，还有一个另一个管理类。让我们看看在实际中如何处理这些类。
- en: 'Create a new Qt Widgets Application project as usual. The example regarding
    this topic is called `NetworkManager_Demo`. Remember to add network to Qt in your
    project file, as we did in the previous example. Then, edit `mainwindow.ui` in
    the **Design** mode and perform the following steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规创建一个新的Qt Widgets Application项目。关于这个主题的示例称为`NetworkManager_Demo`。记得在你的项目文件中将网络添加到Qt中，就像我们在前面的示例中所做的那样。然后，在**Design**模式下编辑`mainwindow.ui`并执行以下步骤：
- en: Remove the status bar, menu bar, and tool bar since we don't need them in this
    application.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在这个应用程序中不需要它们，请移除状态栏、菜单栏和工具栏。
- en: Add **List View** (under the **Item Views (Model-Based)** category).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Item Views (Model-Based)**类别下添加**List View**。
- en: Drag **Vertical Layout** to the right of `listView`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Vertical Layout**拖到`listView`的右侧。
- en: Change **Lay out** in **MainWindow** to **Lay Out Horizontally**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**MainWindow**中的**Lay out**改为**Lay Out Horizontally**。
- en: Drag **Label** into `verticalLayout` and rename it as `onlineStatus`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Label**拖入`verticalLayout`并重命名为`onlineStatus`。
- en: Drag **Progress Bar** into `verticalLayout`. Change its `maximum` value to `0`
    and uncheck `textVisible` so that it can be used as a busy indicator.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**进度条**拖动到`verticalLayout`中。将其`maximum`值更改为`0`并取消选中`textVisible`，以便它可以作为忙碌指示器使用。
- en: Add three **Push Button** buttons; **Refresh**, **Connect**, and **Disconnect**;
    beneath the progress bar. Their object names are `refreshButton`, `connectButton`,
    and `disconnectButton`, respectively.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加三个**按钮**：**刷新**、**连接**和**断开连接**；在进度条下方。它们的对象名称分别是`refreshButton`、`connectButton`和`disconnectButton`。
- en: At last, drag **Vertical Spacer** between `progressBar` and `onlineStatus` to
    separate them.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将**垂直间隔**拖动到`progressBar`和`onlineStatus`之间以分隔它们。
- en: 'As usual, we need to do some declarations in `mainwindow.h` header file as
    shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们需要在`mainwindow.h`头文件中进行一些声明，如下所示：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, we only utilize the `QNetworkConfigurationManager`, `QNetworkConfiguration`,
    and `QNetworkSession` classes to manage the system network sessions. Therefore,
    we need to include them in an appropriate location.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只利用`QNetworkConfigurationManager`、`QNetworkConfiguration`和`QNetworkSession`类来管理系统网络会话。因此，我们需要在适当的位置包含它们。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we only need to declare a `private` member, in this case `networkConfManager`,
    of the `QNetworkConfigurationManager` class, because the `QNetworkConfiguration`
    can be retrieved from this manager, while `QNetworkSession` is bound to `QNetworkConfiguration`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只需要声明一个`private`成员，在这种情况下是`networkConfManager`，`QNetworkConfigurationManager`类，因为可以从这个管理器中检索`QNetworkConfiguration`，而`QNetworkSession`绑定到`QNetworkConfiguration`。
- en: As for `QStandardItemModel`, remember the model/view stuff in [Chapter 3](ch03.xhtml
    "Chapter 3. Cooking an RSS Reader with Qt Quick"), *Cooking an RSS Reader with
    Qt Quick*. The only difference between that chapter and this one is that we wrote
    QML in the former. However, we are using a C++ application in this chapter. They
    share the same concept, though, and it's just the tool that changes. `QStandardItemModel
    *confListModel` is the exact model of `listView` in the UI file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 至于`QStandardItemModel`，记得[第3章](ch03.xhtml "第3章。使用 Qt Quick 制作 RSS 阅读器")中的模型/视图内容，*使用
    Qt Quick 制作 RSS 阅读器*。这一章和这一章之间的唯一区别是我们之前写了 QML。然而，在这一章中，我们使用的是 C++ 应用程序。尽管工具不同，但它们共享相同的概念。`QStandardItemModel
    *confListModel`是 UI 文件中`listView`的确切模型。
- en: Last, but not least, is the declaration of some slots. Apart from the button
    click handlers, the first two are used to monitor the network system. This is
    explained later.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，是一些槽的声明。除了按钮点击处理程序之外，前两个用于监控网络系统。这将在后面解释。
- en: 'Let''s edit the `mainwindow.cpp` file and take a look at the constructor of
    `MainWindow`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编辑`mainwindow.cpp`文件，看看`MainWindow`的构造函数：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We construct `QNetworkConfigurationManager` with this object, also known as
    `MainWindow` as its `QObject` parent. Then, we look at the construction of `confListModel`.
    The arguments are the count of row, the count of column, and the `QObject` parent,
    which is this as usual. We will use only one column because we use **List View**
    to display the data. If you use **Table View**, you will probably use more columns.
    Then, we bind this model to `listView` of `ui`. After this, we hide `progressBar`
    because it's a `busy` indicator, which only shows up when there is work running.
    There will be several `connect` statements before we call two member functions
    explicitly. Among them, you may want to look into the signals of `QNetworkConfigurationManager`.
    The `onlineStateChanged` signal is emitted if the `online` status of the system
    is changed, that is, `offline` from `online`. The `configurationChanged` signal
    is emitted whenever the state of `QNetworkConfiguration` is changed. Once `QNetworkConfigurationManager`
    finished `updateConfigurations`, the `updateCompleted` signal will be emitted.
    In the end of the constructor, we call `onOnlineStateChanged` directly in order
    to set up the text of `onlineStatus`. Similarly, calling `onRefreshClicked` enables
    an application to scan for all the network configurations at the start.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此对象，也称为`MainWindow`作为其`QObject`父对象来构建`QNetworkConfigurationManager`。然后，我们来看`confListModel`的构建。参数包括行数、列数以及`QObject`父对象，通常情况下就是它。我们将只使用一列，因为我们使用**列表视图**来显示数据。如果你使用**表格视图**，你可能需要使用更多的列。然后，我们将此模型绑定到`ui`的`listView`。在此之后，我们隐藏`progressBar`，因为它是一个`忙碌`指示器，只有在有工作运行时才会显示。在我们显式调用两个成员函数之前，将会有几个`connect`语句。其中，你可能想查看`QNetworkConfigurationManager`的信号。如果系统的`online`状态发生变化，即从`online`变为`offline`，则`onlineStateChanged`信号会被发出。每当`QNetworkConfiguration`的状态发生变化时，`configurationChanged`信号会被发出。一旦`QNetworkConfigurationManager`完成`updateConfigurations`，`updateCompleted`信号将被发出。在构造函数的末尾，我们直接调用`onOnlineStateChanged`以设置`onlineStatus`的文本。同样，调用`onRefreshClicked`可以使应用程序在启动时扫描所有网络配置。
- en: 'As mentioned before, the `onOnlineStateChanged` function is used to set up
    `onlineStatus`. It''ll display `Online` if the system is considered to be connected
    to another device via an active network interface; otherwise, it''ll display `Offline`.
    This function''s definition is shown as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`onOnlineStateChanged`函数用于设置`onlineStatus`。如果系统被认为通过一个活动的网络接口连接到另一个设备，它将显示`Online`；否则，它将显示`Offline`。此函数的定义如下所示：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Inside the `onConfigurationChanged` slot function, which is shown in the following
    code, we change the item's background color to indicate whether a configuration
    is active or not. We use the `findItems` function to get `itemList`, which contains
    only some `QStandardItem` that matches `config.name()` exactly. However, the configuration
    name may not be unique. This is why we use a `foreach` loop to compare the identifier
    of `config`, which is a unique string, where the `data` function is used to retrieve
    the specific data whose type is `QVariant`. Then, we use `toString` to cast it
    back to `QString`. `QStandardItem` enables us set multiple data into one item.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中显示的`onConfigurationChanged`槽函数内部，我们更改项的背景颜色以指示配置是否活动。我们使用`findItems`函数获取`itemList`，它只包含一些与`config.name()`完全匹配的`QStandardItem`。然而，配置名称可能不是唯一的。这就是为什么我们使用一个`foreach`循环来比较`config`的标识符，它是一个唯一的字符串，其中使用`data`函数检索特定数据，其类型为`QVariant`。然后，我们使用`toString`将其转换回`QString`。`QStandardItem`使我们能够将多个数据设置到一个项中。
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This means that we store `identifier` as a `Qt::UserRole` data. It won't be
    displayed on the screen; instead, it serves as a specific data carrier, which
    turns out to be very helpful in this case. Thus, after this, if it's active, we
    set the background color to green; otherwise, use no brush, which means a default
    background. Note that the `state` function of `QNetworkConfiguration` returns
    `StateFlags`, which is actually a `QFlag` template class, where the best practice
    is to check whether or not a flag is set is to use the `testFlag` function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将`identifier`存储为`Qt::UserRole`数据。它不会显示在屏幕上；相反，它作为一个特定的数据载体，在这种情况下非常有助于我们。因此，在此之后，如果它是活动的，我们将背景颜色设置为绿色；否则，不使用画笔，这意味着默认背景。请注意，`QNetworkConfiguration`的`state`函数返回`StateFlags`，这实际上是一个`QFlag`模板类，其中最佳实践是检查是否设置了标志，可以使用`testFlag`函数。
- en: Let's check the `onRefreshClicked` function, which is shown in the following
    code before `onRefreshCompleted`. It'll call `updateConfigurations` of the `QNetworkConfigurationManager
    *networkConfManager`. This function is a time consuming one, especially if it
    needs to scan WLAN. Therefore, we show `progressBar` to tell users to be patient
    and disable `refreshButton`, since it's refreshing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`onRefreshClicked`函数，该函数在`onRefreshCompleted`之前显示。它将调用`QNetworkConfigurationManager
    *networkConfManager`的`updateConfigurations`函数。这个函数是一个耗时的函数，特别是如果它需要扫描WLAN。因此，我们显示`progressBar`来告诉用户要有耐心，并禁用`refreshButton`，因为它正在刷新。
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When the update has been completed, the `updateCompleted` signal is emitted
    and the `onRefreshCompleted` bound slot is executed. Check the following function
    shown here, where we need to purge the list. However, instead of calling the `clear`
    function, we use `removeRows`, which would spare the column. If you're calling
    `clear`, beware to add the column back; otherwise, there is literally no column,
    which means that there is no place to put the item. In the `foreach` loop, we
    add all the configurations that `networkConfManager` has found to `confListModel`.
    As I mentioned previously, we use the name as displaying `text`, while we set
    its identifier as a hidden user role data. After the loop, hide `progressBar`
    as the refreshing is finished, and then enable `refreshButton`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 更新完成后，将发出`updateCompleted`信号，并执行与`onRefreshCompleted`绑定的槽。检查以下函数，在这里我们需要清除列表。然而，我们不是调用`clear`函数，而是使用`removeRows`，这样可以保留列。如果你调用`clear`，请注意将列添加回来；否则，实际上就没有列了，这意味着没有地方放置项目。在`foreach`循环中，我们将`networkConfManager`找到的所有配置添加到`confListModel`中。正如我之前提到的，我们使用名称作为显示的`text`，而将其标识符设置为隐藏的用户角色数据。循环结束后，隐藏`progressBar`，因为刷新已完成，然后启用`refreshButton`。
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The remaining two are handlers to the `connect` and `disconnect` buttons. For
    `connectButton`, we show `progressBar` because it may take a long time to get
    the IP address from the router. Then, we get `identifier` from the data of `confListModel`
    directly and save it as `QString ident`, where the `currentIndex` function of
    `listView` will return the current `QModelIndex` of the view. By using this index,
    we can get the currently selected data from the model. Then, we construct `QNetworkConfiguration`
    from `ident` by calling `configurationFromIdentifier` of `networkConfManager`.
    The `QNetworkSession` session is constructed using `QNetworkConfiguration`. At
    last, open this network session and wait for 1,000 milliseconds. Then, call `deleteLater`
    to safely release the session. Also, hide `progressBar` after all these works
    in the end.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个处理程序是对`connect`和`disconnect`按钮的处理。对于`connectButton`，我们显示`progressBar`，因为从路由器获取IP地址可能需要很长时间。然后，我们直接从`confListModel`的数据中获取`identifier`并将其保存为`QString
    ident`，其中`listView`的`currentIndex`函数将返回当前视图的`QModelIndex`。通过使用此索引，我们可以从模型中获取当前选中的数据。然后，我们通过调用`networkConfManager`的`configurationFromIdentifier`从`ident`构建`QNetworkConfiguration`。最后，使用`QNetworkConfiguration`构建`QNetworkSession`会话，并打开此网络会话，等待1,000毫秒。然后，调用`deleteLater`以安全地释放会话。最后，在这些工作完成后，隐藏`progressBar`。
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As for `disconnectButton`, the `onDisconnectClicked` handler will do the reverse,
    which is to stop the network session. The first three lines are identical to those
    in `onConnectClicked`. However, we then need to test whether the platform supports
    out-of-process sessions. As stated in the Qt documentation, the result of calling
    `close` will be as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`disconnectButton`，`onDisconnectClicked`处理程序将执行相反的操作，即停止网络会话。前三行与`onConnectClicked`中的相同。然而，我们需要测试平台是否支持进程外会话。正如Qt文档中所述，调用`close`的结果如下：
- en: '*void QNetworkSession::close() [slot]*'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*void QNetworkSession::close() [slot]*'
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Decreases the session counter on the associated network configuration. If
    the session counter reaches zero the active network interface is shut down. This
    also means that state() will only change from Connected to Disconnected if the
    current session was the last open session.*'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*减少关联网络配置的会话计数器。如果会话计数器达到零，则关闭活动网络接口。这也意味着，只有当当前会话是最后一个打开的会话时，状态()才会从Connected变为Disconnected。*'
- en: However, if the platform doesn't support out-of-process sessions, the `close`
    function won't stop the interface, in which case we need to use stop instead.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果平台不支持进程外会话，`close`函数将不会停止接口，在这种情况下，我们需要使用`stop`代替。
- en: Therefore, we call the `capabilities` function of `networkConfManager` to check
    whether it has `SystemSessionSupport`. Call `close` if it does, otherwise call
    `stop`. Then, we just call `deleteLater` to safely release the session.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们调用 `networkConfManager` 的 `capabilities` 函数来检查它是否具有 `SystemSessionSupport`。如果有，则调用
    `close`，否则调用 `stop`。然后，我们只需调用 `deleteLater` 来安全地释放会话。
- en: 'Now, run this application, and you''ll expect it works as the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行这个应用程序，你期望它的工作方式如下截图所示：
- en: '![Managing a system network session](img/4615OS_06_06.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![管理系统网络会话](img/4615OS_06_06.jpg)'
- en: On Windows, the network architecture is different from that of the world of
    Unix. So, you may find some odd configurations in the list, such as **Teredo Tunneling
    Pseudo-Interface** in the screenshot. Don't worry about these configurations and
    just ignore them! Also, there is no Qt API to allow you to connect to a newly
    discovered encrypted Wi-Fi access point. This is because there is no implementation
    in place to access the WLAN system passwords. In other words, it can only be used
    to control the network sessions that are already known to the system.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，网络架构与 Unix 世界不同。因此，你可能会在列表中找到一些奇怪的配置，例如截图中的**Teredo 隧道伪接口**。不用担心这些配置，只需忽略它们！此外，没有
    Qt API 允许你连接到一个新发现的加密 Wi-Fi 接入点。这是因为没有实现用于访问 WLAN 系统密码的功能。换句话说，它只能用来控制系统已知的网络会话。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have had a chance to practice what you have learned in
    the previous chapters while picking up new skills in Qt. So far, you'll have gained
    an insight into the architecture of Qt that is commonly seen and shared by its
    submodules. After all, networking and threading will definitely bring your applications
    to a higher level.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你有机会在掌握前几章所学内容的同时，学习 Qt 的新技能。到目前为止，你已经对 Qt 的常见架构有了深入了解，这是其子模块共享的。毕竟，网络和线程技术将使你的应用程序达到更高的水平。
- en: In the next chapter, besides parsing XML and JSON documents, we're going to
    rock Android with Qt!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，除了解析 XML 和 JSON 文档外，我们还将用 Qt 来震撼 Android！
