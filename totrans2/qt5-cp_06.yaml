- en: Chapter 6. Getting Wired and Managing Downloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Network modules have become crucial nowadays and are also a must-have feature
    for development frameworks; therefore, Qt does provide APIs for network programming.
    Sit tight, we''re going to get wired and download files from the network. In addition
    to this, threading is included in this chapter, which is a vital programming skill
    to avoid blocking. This chapter''s topics are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Qt network programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing `QNetworkAccessManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making use of the progress bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing multithreaded applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing a system network session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Qt network programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt supports network programming and provides lots of high-level APIs to ease
    your work. `QNetworkRequest`, `QNetworkReply`, and `QNetworkAccessManager` use
    common protocols to perform network operations. Qt also offers lower-level classes
    to represent low level network concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to utilize the high-level APIs that Qt has offered
    to write a downloader to retrieve the Internet files and save them to your disk.
    As I mentioned earlier, the application will need the `QNetworkRequest`, `QNetworkReply`,
    and `QNetworkAccessManager` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, all network requests are represented by the `QNetworkRequest` class,
    which is a general container for information associated with a request, including
    the header and encryption. Currently, HTTP, FTP, and local file URLs are supported
    for uploading and downloading.
  prefs: []
  type: TYPE_NORMAL
- en: Once a request has been created, the `QNetworkAccessManager` class is used to
    dispatch it and emits signals, reporting the progress. Then, it creates the reply
    to a network request, represented by the `QNetworkReply` class. At the same time,
    the signals provided by `QNetworkReply` can be used to monitor each reply individually.
    Some developers will discard the reference to the reply and use the `QNetworkAccessManager`
    class's signals for that purpose, though. All replies can be handled synchronously
    or asynchronously, because `QNetworkReply` is a subclass of `QIODevice`, which
    means that it's possible to implement nonblocking operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram that describes the relationship between these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Qt network programming](img/4615OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Likewise, the network-related stuff is offered in the network module. To use
    this module, you need to edit the project file and add network to QT. Now, create
    a new Qt Widget Application project and edit the project file. In our `Downloader_Demo`
    example, the `downloader_demo.pro` project file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Utilizing QNetworkAccessManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we're going to discover how to write an application that is able to download
    files from other locations. By other locations, we mean that you can download
    files from a local position; it doesn't have to be an Internet address, since
    the local file URLs are supported by Qt as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create a `Downloader` class that will use `QNetworkAccessManager`
    to do the downloading work for us. The `downloader.h` header file is pasted shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We expose the download slot to get the URL and the saving target. Accordingly,
    `saveFile` is used to store the saving target. In addition to this, we use an
    `naManager` object of the `QNetworkAccessManager` class to manage the downloading
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Let's check the definitions of these functions in the `downloader.cpp` file.
    In the following constructor, we connect the `naManager` object's `finished` signal
    to the `onDownloadFinished` slot. Therefore, when a network connection is finished,
    a relevant `QNetworkReply` reference will be passed via this signal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Accordingly, in the `onDownloadFinished` slot, we have to handle `QNetworkReply`
    with caution. If there is any error, which means that the download has failed,
    we expose the `errorString()` function by the `errorString` signal. Otherwise,
    we call the `saveToDisk` function to save the file to the disk. Then, we use `deleteLater()`
    to release the `QNetworkReply` object safely. As stated in the Qt documentation,
    it's not safe to use the `delete` statement directly; since it's finished, we
    emit the available and running signals. Those signals will later be used to change
    the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `saveToDisk` function, we just implement `QFile` to save all the downloaded
    data to the disk. This is feasible because `QNetworkReply` inherits from `QIODevice`.
    Therefore, in addition to the networking APIs, you can treat `QNetworkReply` as
    a normal `QIODevice` object. In this case, use the `readAll()` function to get
    all data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let's see inside the `download` function that will be used by `MainWindow`
    later. Firstly, we store the saved file to `saveFile`. Then, we construct `QNetworkRequest
    req` using the `QUrl` object, `url`. Next, we send `req` to the `naManager` object
    of `QNetworkAccessManager`, while saving the reference to the created `QNetworkManager`
    object to `reply`. After this, we connect the two `downloadProgress` signals together,
    which is simply exposing the `downloadProgress` signal of the reply. At last,
    we end up emitting two signals, indicating the availability and running status
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We described the `Downloader` class. Now, we''re going to add `DownloadDialog`
    by navigating to **Qt Designer** | **Dialog with Buttons Bottom**. This class
    is used to get the URL and save the path for the user. For the design of `downloaddialog.ui`,
    we use the two `QLineEdit` objects to get the URL and saved path respectively.
    One of the object names is `urlEdit`, and the other is `saveAsEdit`. In order
    to open a file dialog for the user to choose the saving location, a `saveAsButton`
    attribute of `QPushButton` is added to the right-hand side of `saveAsEdit`. The
    following screenshot shows you the layout of this UI file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing QNetworkAccessManager](img/4615OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You need to change the layout of this dialog to **Lay Out in a Grid**. In a
    similar way as we did before, in order to pass the values to the main window,
    we need to delete the default `accepted` signal and slot connection in **Signals
    & Slots Editor**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of this class''s `downloaddialog.h` header file are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a new signal named `accepted` is added to pass the URL and save
    the location. Besides, the two `private` slots are used to handle the `accepted`
    event of the button box and the `saveAsButtonClicked` signal, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definitions are in the `downloaddialog.cpp` source file, which is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor of `DownloadDialog`, just connect the signals and slots.
    In the `onButtonAccepted` slot, we emit the `accepted` signal, which is to pass
    the URL and the saving path, where a temporary `QUrl` class is constructed using
    the text of `urlEdit`. Then, the `accept` function is invoked to close the dialog.
    Meanwhile, in the `onSaveAsButtonClicked` slot function, we use the `static` function
    provided by the `QFileDialog` class to obtain the saving location. Do nothing
    if the `QString` return is empty; this means that the user may have clicked on
    **Cancel** in the file dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Making use of the progress bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An intuitive way to indicate the downloading progress is by using a progress
    bar. In Qt, it is the `QProgressBar` class that provides a horizontal or vertical
    progress bar widget. It uses `minimum`, `value`, and `maximum` to determine the
    completed percentage. The percentage is calculated by the formula, `(value – minimum)
    / (maximum – minimum)`. We''ll use this useful widget in our example application
    by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the `MainWindow` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `mainwindow.ui` file in the **Design** mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Push Button** and rename it as `newDownloadButton` with `New Download`
    as its text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Progress Bar** just beneath `newDownloadButton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the layout to **Lay Out Vertically**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck `textVisible` in the `progressBar` widget's property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The push button, `newDownloadButton`, is used to popup `DownloadDialog` to
    get a new download task. We need to apply some modifications to `mainwindow.h`,
    as suggested here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In order to use the `Downloader` and `DownloadDialog` classes, we have to include
    them in the `header` file. Then, we can include them as the `private` pointers.
    For the `private` slots, `onNewDownloadButtonPressed` is used to handle the `newDownloadButton`
    clicked signal. While `showMessage` is a slot function that displays the message
    on status bar, the last one, `onDownloadProgress`, is used to update the progress
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, for the `mainwindow.cpp` source file, we connect the signals and
    slots in the constructor, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Before beginning to create these connections, we need to hide the progress bar
    and create a new `Downloader` class, using `MainWindow` as the `QObject` parent.
    Meanwhile, in these connections, the first one is to connect the `newDownloadButton`
    clicked signal. Then, we connect the `errorString` signal of downloader to `showMessage`,
    which enables the status bar to show the error message directly. Next, we connect
    the `downloadProgress` signal to our `onDownloadProgress` handler. As for the
    available and running signals, they're connected to control the availability and
    visibility of `newDownloadButton` and `progressBar`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `onNewDownloadButtonPressed` slot function, we construct a `DownloadDialog`
    object, `ddlg`, then connect the accepted signal of `DownloadDialog` to the `Downloader`
    class's download slot. Then, use `exec` to run the dialog and block the event
    loop. After this, we call `deleteLater` to safely release the resource allocated
    for `ddlg`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the `showMessage` slot function, it simply calls the `showMessage` function
    of `statusBar` with a three second timeout, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: At last, we can update the progress bar via the `onDownloadProgress` function,
    which is shown in the following code. Since the `minimum` value is `0` by default,
    we don't need to change it. Instead, we change the `maximum` value to the total
    bytes of the download, and `value` to the current downloaded bytes. Note that
    if the total size is unknown, then the value of the total size is `-1`, which
    will happen to make the progress bar display in a busy style.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, give the application a run and click on the **New Download** button. The
    **Add New Download** dialog will pop up, where you can add a new download task
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making use of the progress bar](img/4615OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **OK**, if there is no error; a progress bar is expected to show up
    and display the current download progress, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making use of the progress bar](img/4615OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the **New Download** button is not enabled now, since it is
    associated with the available signal of `downloader`. Besides, the progress bar
    won't even show if `downloader` isn't running.
  prefs: []
  type: TYPE_NORMAL
- en: While this downloader demo still lacks a basic function, which is to cancel
    downloading, it is, in fact, easy to implement. There is a slot function called
    `abort` in the `QNetworkReply` class. You may have to store the reference to `QNetworkReply`
    and then call abort if some button in `MainWindow` is clicked. This won't be demonstrated
    here. It has been left up to you to practice on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Writing multithreaded applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I bet multithread or threading isn't unfamiliar to you. Using other threads
    saves the GUI application from freezing. If the application runs on a single thread,
    it'll get stuck if there it's a synchronous time-consuming operation. Multiple
    threads make application running much smoother. Although most of the Qt Network
    APIs are nonblocking, it is not that difficult to practice on it.
  prefs: []
  type: TYPE_NORMAL
- en: Qt provides a `QThread` class to implement threading on all supported platforms.
    In other words, we don't need to write platform-specific code utilizing POSIX
    Threads or a Win32 API. Instead, `QThread` provides a platform-independent way
    to manage threads. A `QThread` object manages a thread within the program, which
    begins executing in `run()` and ends when calling `quit()` or `exit()`.
  prefs: []
  type: TYPE_NORMAL
- en: For some historical reason, it's still possible to subclass `QThread` and put
    the blocking or time-consuming code in the reimplemented `run()` function. However,
    it's considered an incorrect practice and is not recommended to do so. The right
    way is to use `QObject::moveToThread`, which will be demonstrated later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to put the `Downloader::download` function into a new thread.
    In fact, it''s the `QNetworkAccessManager::get` function that will be moved onto
    another thread. Let''s create a new C++ class, `DownloadWorker`, whose `downloadworker.h`
    header file is pasted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The constructor is removed from the code because we can't make a child object
    that will be in another thread. This is almost the only limitation of `QThread`.
    In contrast to this, you can connect signals and slots between different threads
    without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: Don't split parent and children between threads. Parent objects and children
    objects can only be in the same thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare the `doDownload` slot function to do the `QNetworkAccessManager::get`
    function work for us. On the other hand, the `downloadProgress` signal is used
    to expose the `downloadProgress` signal of `QNetworkReply` as we did. The contents
    of `downloadworker.cpp` is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is an example of a simple `worker` class. Now, we have to
    change the `Downloader` class to use the `DownloadWorker` class. The `header`
    file of the `Downloader` class, `downloader.h`, needs a few modifications, shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have declared a new `private` member, `workerThread`, which
    is a type of `QThread`. Also, a `DownloadWorker` object worker has been declared
    as well. There are more changes in the `downloader.cpp` source file, as displayed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we will create a new `DownloadWorker` class, and move it
    to another thread, `workerThread`. By connecting the `finished` signal of `workerThread`
    to the `deleteLater` function of `worker`, the resources of `worker` can be deleted
    safely after the exit of `workerThread`. Then, we need to expose `downloadProgress`
    again, since it's moved into `worker`. At last, we call the `start()` function,
    to start `workerThread`.
  prefs: []
  type: TYPE_NORMAL
- en: As a reverse operation, we call the `quit()` function to exit `workerThread`
    and then use `wait()` to ensure it quits successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Since a lot of code has been moved into the `doDownload` function of `worker`,
    we only need to call `doDownload` of `worker` here. In fact, the function calling
    is inter-thread, which means that the main thread won't be blocked by that statement.
  prefs: []
  type: TYPE_NORMAL
- en: Since `get` is not blocking, you may not feel the difference. However, I'm sure
    you have some applications that have frozen, which therefore need to be modified
    to adapt to `QThread`. Always remember to put only the background blocking operations
    in another thread. This is mainly because these operations are easily separated
    from GUI into single objects without parents or children. Due to this limitation,
    almost all the GUI objects must be in the same thread, which is the main thread
    in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Managing a system network session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to networking applications, Qt also provides you with cross-platform
    APIs to control network interfaces and access points. Although it's not very common
    to control the network state, there are some certain situations where it's required
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I''d like to introduce `QNetworkConfigurationManager` to you. This class
    manages the network configurations provided by the system. It enables you access
    to them, as well as to detect the system''s capabilities during runtime. The network
    configuration is presented by the `QNetworkConfiguration` class, which abstracts
    a set of configuration options concerning how a network interface has to be configured
    in order to connect to the target network. To control the network session, you
    need to use the `QNetworkSession` class. This class provides you with control
    over the system''s access points and enables session management. It also enables
    you to control network interfaces that are represented by the `QNetworkInterface`
    class. To help you figure out this relationship, a diagram is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing a system network session](img/4615OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the structure is similar to `QNetworkAccessManager`, `QNetworkReply`,
    and `QNetworkRequest`. Especially, there is another manager class. Let's see how
    to deal with these classes in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Qt Widgets Application project as usual. The example regarding
    this topic is called `NetworkManager_Demo`. Remember to add network to Qt in your
    project file, as we did in the previous example. Then, edit `mainwindow.ui` in
    the **Design** mode and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the status bar, menu bar, and tool bar since we don't need them in this
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add **List View** (under the **Item Views (Model-Based)** category).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Vertical Layout** to the right of `listView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change **Lay out** in **MainWindow** to **Lay Out Horizontally**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Label** into `verticalLayout` and rename it as `onlineStatus`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Progress Bar** into `verticalLayout`. Change its `maximum` value to `0`
    and uncheck `textVisible` so that it can be used as a busy indicator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three **Push Button** buttons; **Refresh**, **Connect**, and **Disconnect**;
    beneath the progress bar. Their object names are `refreshButton`, `connectButton`,
    and `disconnectButton`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At last, drag **Vertical Spacer** between `progressBar` and `onlineStatus` to
    separate them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As usual, we need to do some declarations in `mainwindow.h` header file as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we only utilize the `QNetworkConfigurationManager`, `QNetworkConfiguration`,
    and `QNetworkSession` classes to manage the system network sessions. Therefore,
    we need to include them in an appropriate location.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we only need to declare a `private` member, in this case `networkConfManager`,
    of the `QNetworkConfigurationManager` class, because the `QNetworkConfiguration`
    can be retrieved from this manager, while `QNetworkSession` is bound to `QNetworkConfiguration`.
  prefs: []
  type: TYPE_NORMAL
- en: As for `QStandardItemModel`, remember the model/view stuff in [Chapter 3](ch03.xhtml
    "Chapter 3. Cooking an RSS Reader with Qt Quick"), *Cooking an RSS Reader with
    Qt Quick*. The only difference between that chapter and this one is that we wrote
    QML in the former. However, we are using a C++ application in this chapter. They
    share the same concept, though, and it's just the tool that changes. `QStandardItemModel
    *confListModel` is the exact model of `listView` in the UI file.
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, is the declaration of some slots. Apart from the button
    click handlers, the first two are used to monitor the network system. This is
    explained later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s edit the `mainwindow.cpp` file and take a look at the constructor of
    `MainWindow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We construct `QNetworkConfigurationManager` with this object, also known as
    `MainWindow` as its `QObject` parent. Then, we look at the construction of `confListModel`.
    The arguments are the count of row, the count of column, and the `QObject` parent,
    which is this as usual. We will use only one column because we use **List View**
    to display the data. If you use **Table View**, you will probably use more columns.
    Then, we bind this model to `listView` of `ui`. After this, we hide `progressBar`
    because it's a `busy` indicator, which only shows up when there is work running.
    There will be several `connect` statements before we call two member functions
    explicitly. Among them, you may want to look into the signals of `QNetworkConfigurationManager`.
    The `onlineStateChanged` signal is emitted if the `online` status of the system
    is changed, that is, `offline` from `online`. The `configurationChanged` signal
    is emitted whenever the state of `QNetworkConfiguration` is changed. Once `QNetworkConfigurationManager`
    finished `updateConfigurations`, the `updateCompleted` signal will be emitted.
    In the end of the constructor, we call `onOnlineStateChanged` directly in order
    to set up the text of `onlineStatus`. Similarly, calling `onRefreshClicked` enables
    an application to scan for all the network configurations at the start.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, the `onOnlineStateChanged` function is used to set up
    `onlineStatus`. It''ll display `Online` if the system is considered to be connected
    to another device via an active network interface; otherwise, it''ll display `Offline`.
    This function''s definition is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `onConfigurationChanged` slot function, which is shown in the following
    code, we change the item's background color to indicate whether a configuration
    is active or not. We use the `findItems` function to get `itemList`, which contains
    only some `QStandardItem` that matches `config.name()` exactly. However, the configuration
    name may not be unique. This is why we use a `foreach` loop to compare the identifier
    of `config`, which is a unique string, where the `data` function is used to retrieve
    the specific data whose type is `QVariant`. Then, we use `toString` to cast it
    back to `QString`. `QStandardItem` enables us set multiple data into one item.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This means that we store `identifier` as a `Qt::UserRole` data. It won't be
    displayed on the screen; instead, it serves as a specific data carrier, which
    turns out to be very helpful in this case. Thus, after this, if it's active, we
    set the background color to green; otherwise, use no brush, which means a default
    background. Note that the `state` function of `QNetworkConfiguration` returns
    `StateFlags`, which is actually a `QFlag` template class, where the best practice
    is to check whether or not a flag is set is to use the `testFlag` function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's check the `onRefreshClicked` function, which is shown in the following
    code before `onRefreshCompleted`. It'll call `updateConfigurations` of the `QNetworkConfigurationManager
    *networkConfManager`. This function is a time consuming one, especially if it
    needs to scan WLAN. Therefore, we show `progressBar` to tell users to be patient
    and disable `refreshButton`, since it's refreshing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When the update has been completed, the `updateCompleted` signal is emitted
    and the `onRefreshCompleted` bound slot is executed. Check the following function
    shown here, where we need to purge the list. However, instead of calling the `clear`
    function, we use `removeRows`, which would spare the column. If you're calling
    `clear`, beware to add the column back; otherwise, there is literally no column,
    which means that there is no place to put the item. In the `foreach` loop, we
    add all the configurations that `networkConfManager` has found to `confListModel`.
    As I mentioned previously, we use the name as displaying `text`, while we set
    its identifier as a hidden user role data. After the loop, hide `progressBar`
    as the refreshing is finished, and then enable `refreshButton`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The remaining two are handlers to the `connect` and `disconnect` buttons. For
    `connectButton`, we show `progressBar` because it may take a long time to get
    the IP address from the router. Then, we get `identifier` from the data of `confListModel`
    directly and save it as `QString ident`, where the `currentIndex` function of
    `listView` will return the current `QModelIndex` of the view. By using this index,
    we can get the currently selected data from the model. Then, we construct `QNetworkConfiguration`
    from `ident` by calling `configurationFromIdentifier` of `networkConfManager`.
    The `QNetworkSession` session is constructed using `QNetworkConfiguration`. At
    last, open this network session and wait for 1,000 milliseconds. Then, call `deleteLater`
    to safely release the session. Also, hide `progressBar` after all these works
    in the end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As for `disconnectButton`, the `onDisconnectClicked` handler will do the reverse,
    which is to stop the network session. The first three lines are identical to those
    in `onConnectClicked`. However, we then need to test whether the platform supports
    out-of-process sessions. As stated in the Qt documentation, the result of calling
    `close` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*void QNetworkSession::close() [slot]*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Decreases the session counter on the associated network configuration. If
    the session counter reaches zero the active network interface is shut down. This
    also means that state() will only change from Connected to Disconnected if the
    current session was the last open session.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, if the platform doesn't support out-of-process sessions, the `close`
    function won't stop the interface, in which case we need to use stop instead.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we call the `capabilities` function of `networkConfManager` to check
    whether it has `SystemSessionSupport`. Call `close` if it does, otherwise call
    `stop`. Then, we just call `deleteLater` to safely release the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run this application, and you''ll expect it works as the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing a system network session](img/4615OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On Windows, the network architecture is different from that of the world of
    Unix. So, you may find some odd configurations in the list, such as **Teredo Tunneling
    Pseudo-Interface** in the screenshot. Don't worry about these configurations and
    just ignore them! Also, there is no Qt API to allow you to connect to a newly
    discovered encrypted Wi-Fi access point. This is because there is no implementation
    in place to access the WLAN system passwords. In other words, it can only be used
    to control the network sessions that are already known to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have had a chance to practice what you have learned in
    the previous chapters while picking up new skills in Qt. So far, you'll have gained
    an insight into the architecture of Qt that is commonly seen and shared by its
    submodules. After all, networking and threading will definitely bring your applications
    to a higher level.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, besides parsing XML and JSON documents, we're going to
    rock Android with Qt!
  prefs: []
  type: TYPE_NORMAL
