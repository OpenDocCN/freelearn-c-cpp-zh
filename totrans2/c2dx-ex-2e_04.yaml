- en: Chapter 4. Fun with Sprites – Sky Defense
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Time to build our second game! This time, you will get acquainted with the
    power of actions in Cocos2d-x. I''ll show you how an entire game could be built
    just by running the various action commands contained in Cocos2d-x to make your
    sprites move, rotate, scale, fade, blink, and so on. And you can also use actions
    to animate your sprites using multiple images, like in a movie. So let''s get
    started.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to optimize the development of your game with sprite sheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use bitmap fonts in your game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How easy it is to implement and run actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to scale, rotate, swing, move, and fade out a sprite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to load multiple `.png` files and use them to animate a sprite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a universal game with Cocos2d-x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game – sky defense
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Meet our stressed-out city of...your name of choice here. It's a beautiful day
    when suddenly the sky begins to fall. There are meteors rushing toward the city
    and it is your job to keep it safe.
  prefs: []
  type: TYPE_NORMAL
- en: The player in this game can tap the screen to start growing a bomb. When the
    bomb is big enough to be activated, the player taps the screen again to detonate
    it. Any nearby meteor will explode into a million pieces. The bigger the bomb,
    the bigger the detonation, and the more meteors can be taken out by it. But the
    bigger the bomb, the longer it takes to grow it.
  prefs: []
  type: TYPE_NORMAL
- en: But it's not just bad news coming down. There are also health packs dropping
    from the sky and if you allow them to reach the ground, you'll recover some of
    your energy.
  prefs: []
  type: TYPE_NORMAL
- en: The game settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a universal game. It is designed for the iPad retina screen and it will
    be scaled down to fit all the other screens. The game will be played in landscape
    mode, and it will not need to support multitouch.
  prefs: []
  type: TYPE_NORMAL
- en: The start project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go ahead and download the file `4198_04_START_PROJECT.zip` from this book's
    support page ([www.packtpub.com/support](http://www.packtpub.com/support)). When
    you uncompress the file, you will find the basic project already set up and ready
    for you to work on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps involved in creating this project are similar to the ones I showed
    you in our previous game. The command line I used was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In Xcode you must set the **Devices** field in **Deployment Info** to **Universal**,
    and the **Device Family** field is set to **Universal**. And in `RootViewController.mm`,
    the supported interface orientation is set to **Landscape**.
  prefs: []
  type: TYPE_NORMAL
- en: The game we are going to build requires only one class, `GameLayer.cpp`, and
    you will find that the interface for this class already contains all the information
    it needs.
  prefs: []
  type: TYPE_NORMAL
- en: Also, some of the more trivial or old-news logic is already in place in the
    implementation file as well. But I'll go over this as we work on the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding screen support for a universal app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous game, we targeted iPad size screens only. Now things get a bit
    more complicated as we add support for smaller screens in our universal game,
    as well as some of the most common Android screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So open `AppDelegate.cpp`. Inside the `applicationDidFinishLaunching` method,
    we now have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we tell our `GLView` object (our OpenGL view) that we designed the
    game for a certain screen size (the iPad retina screen) and once again, we want
    our game screen to resize to match the screen on the device (`ResolutionPolicy::EXACT_FIT`).
  prefs: []
  type: TYPE_NORMAL
- en: Then we determine where to load our images from, based on the device's screen
    size. We have art for iPad retina, then for regular iPad which is shared by iPhone
    retina, and for the regular iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: We end by setting the scale factor based on the designed target.
  prefs: []
  type: TYPE_NORMAL
- en: Adding background music
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Still inside `AppDelegate.cpp`, we load the sound files we''ll use in the game,
    including a `background.mp3` (courtesy of Kevin MacLeod from [incompetech.com](http://incompetech.com)),
    which we load through the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We end by setting the effects'' volume down a tad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For background music volume, you must use `setBackgroundMusicVolume`. If you
    create some sort of volume control in your game, these are the calls you would
    make to adjust the volume based on the user's preference.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now back to `GameLayer.cpp`. If you take a look inside our `init` method, you
    will see that the game initializes by calling three methods: `createGameScreen`,
    `createPools`, and `createActions`.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll create all our screen elements inside the first method, and then create
    object pools so we don't instantiate any sprite inside the main loop; and we'll
    create all the main actions used in our game inside the `createActions` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'And as soon as the game initializes, we start playing the background music,
    with its `should loop` parameter set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We once again store the screen size for future reference, and we'll use a `_running`
    Boolean for game states.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the game now, you should only see the background image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initializing the game](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using sprite sheets in Cocos2d-x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A sprite sheet is a way to group multiple images together in one image file.
    In order to texture a sprite with one of these images, you must have the information
    of where in the sprite sheet that particular image is found (its rectangle).
  prefs: []
  type: TYPE_NORMAL
- en: 'Sprite sheets are often organized in two files: the image one and a data file
    that describes where in the image you can find the individual textures.'
  prefs: []
  type: TYPE_NORMAL
- en: I used `TexturePacker` to create these files for the game. You can find them
    inside the `ipad`, `ipadhd`, and `iphone` folders inside `Resources`. There is
    a `sprite_sheet.png` file for the image and a `sprite_sheet.plist` file that describes
    the individual frames inside the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the `sprite_sheet.png` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using sprite sheets in Cocos2d-x](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Batch drawing sprites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Cocos2d-x, sprite sheets can be used in conjunction with a specialized node,
    called `SpriteBatchNode`. This node can be used whenever you wish to use multiple
    sprites that share the same source image inside the same node. So you could have
    multiple instances of a `Sprite` class that uses a `bullet.png` texture for instance.
    And if the source image is a sprite sheet, you can have multiple instances of
    sprites displaying as many different textures as you could pack inside your sprite
    sheet.
  prefs: []
  type: TYPE_NORMAL
- en: With `SpriteBatchNode`, you can substantially reduce the number of calls during
    the rendering stage of your game, which will help when targeting less powerful
    systems, though not noticeably in more modern devices.
  prefs: []
  type: TYPE_NORMAL
- en: Let me show you how to create a `SpriteBatchNode`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating SpriteBatchNode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin implementing the `createGameScreen` method in `GameLayer.cpp`.
    Just below the lines that add the `bg` sprite, we instantiate our batch node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In order to create the batch node from a sprite sheet, we first load all the
    frame information described by the `sprite_sheet.plist` file into `SpriteFrameCache`.
    And then we create the batch node with the `sprite_sheet.png` file, which is the
    source texture shared by all sprites added to this batch node. (The background
    image is not part of the sprite sheet, so it's added separately before we add
    `_gameBatchNode` to GameLayer.)
  prefs: []
  type: TYPE_NORMAL
- en: Now we can start putting stuff inside `_gameBatchNode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the city:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then the trees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that here we create sprites by passing it a sprite frame name. The IDs
    for these frame names were loaded into `SpriteFrameCache` through our `sprite_sheet.plist`
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The screen so far is made up of two instances of `city_dark.png` tiling at
    the bottom of the screen, and two instances of `city_light.png` also tiling. One
    needs to appear on top of the other and for that we use the enumerated values
    declared in `GameLayer.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `addChild( Node, zOrder)` method to layer our sprites on top of each
    other, using different values for their `z` order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So for example, when we later add three sprites showing the `trees.png` sprite
    frame, we add them on top of all previous sprites using the highest value for
    z that we find in the enumerated list, which is `kForeground`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why go through the trouble of tiling the images and not using one large image
    instead, or combining some of them with the background image? Because I wanted
    to include the greatest number of images possible inside the one sprite sheet,
    and have that sprite sheet to be as small as possible, to illustrate all the clever
    ways you can use and optimize sprite sheets. This is not necessary in this particular
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We began creating the initial screen for our game. We are using a `SpriteBatchNode`
    to contain all the sprites that use images from our sprite sheet. So `SpriteBatchNode`
    behaves as any node does—as a container. And we can layer individual sprites inside
    the batch node by manipulating their `z` order.
  prefs: []
  type: TYPE_NORMAL
- en: Bitmap fonts in Cocos2d-x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cocos2d-x `Label` class has a static `create` method that uses bitmap images
    for the characters.
  prefs: []
  type: TYPE_NORMAL
- en: The bitmap image we are using here was created with the program GlyphDesigner,
    and in essence, it works just as a sprite sheet does. As a matter of fact, `Label`
    extends `SpriteBatchNode`, so it behaves just like a batch node.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have images for all individual characters you''ll need packed inside a
    PNG file (`font.png`), and then a data file (`font.fnt`) describing where each
    character is. The following screenshot shows how the font sprite sheet looks like
    for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bitmap fonts in Cocos2d-x](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The difference between `Label` and a regular `SpriteBatchNode` class is that
    the data file also feeds the `Label` object information on how to *write* with
    this font. In other words, how to space out the characters and lines correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Label` objects we are using in the game are instantiated with the name
    of the data file and their initial string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And the value for the label is changed through the `setString` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as with every other image in the game, we also have different versions
    of `font.fnt` and `font.png` in our `Resources` folders, one for each screen definition.
    `FileUtils` will once again do the heavy lifting of finding the correct file for
    the correct screen.
  prefs: []
  type: TYPE_NORMAL
- en: So now let's create the labels for our game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating bitmap font labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a bitmap font is somewhat similar to creating a batch node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with our `createGameScreen` method, add the following lines to the
    `score` label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And then add a label to display the energy level, and set its horizontal alignment
    to `Right`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line for an icon that appears next to the `_energyDisplay`
    label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created our first bitmap font object in Cocos2d-x. Now let's finish
    creating our game's sprites.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the final screen sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last sprites we need to create are the clouds, the bomb and shockwave, and
    our game state messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the `createGameScreen` method, add the clouds to the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `_bomb` sprite; players will *grow* when tapping the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then create the `_shockwave` sprite that appears after the `_bomb` goes off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the two messages that appear on the screen, one for our `intro`
    state and one for our `gameover` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a lot of new information regarding sprites in the previous code. So
    let''s go over it carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: We started by adding the clouds. We put the sprites inside a vector so we can
    move the clouds later. Notice that they are also part of our batch node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next comes the bomb sprite and our first new call:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this we are telling the framework to create antialiased copies of this
    texture in diminishing sizes (mipmaps), since we are going to scale it down later.
    This is optional of course; sprites can be resized without first generating mipmaps,
    but if you notice loss of quality in your scaled sprites, you can fix that by
    creating mipmaps for their texture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The texture must have size values in so-called POT (power of 2: 2, 4, 8, 16,
    32, 64, 128, 256, 512, 1024, 2048, and so on). Textures in OpenGL must always
    be sized this way; when they are not, Cocos2d-x will do one of two things: it
    will either resize the texture in memory, adding transparent pixels until the
    image reaches a POT size, or stop the execution on an assert. With textures used
    for mipmaps, the framework will stop execution for non-POT textures.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: I add the `sparkle` and the `halo` sprites as children to the `_bomb` sprite.
    This will use the container characteristic of nodes to our advantage. When I grow
    the bomb, all its children will grow with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice too that I use a third parameter to `addChild` for `halo` and `sparkle`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This third parameter is an integer tag from yet another enumerated list declared
    in `GameLayer.h`. I can use this tag to retrieve a particular child from a sprite
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now have our game screen in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next come object pools.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating our object pools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pools are just vectors of objects. And here are the steps to create them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `createPools` method, we first create a pool for meteors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we create an object pool for health packs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll use the corresponding pool index to retrieve objects from the vectors
    as the game progresses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have a vector of invisible meteor sprites and a vector of invisible health
    sprites. We'll use their respective pool indices to retrieve these from the vector
    as needed as you'll see in a moment. But first we need to take care of actions
    and animations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With object pools, we reduce the number of instantiations during the main loop,
    and it allows us to never destroy anything that can be reused. But if you need
    to remove a child from a node, use `->removeChild` or `->removeChildByTag` if
    a tag is present.
  prefs: []
  type: TYPE_NORMAL
- en: Actions in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you remember, a node will store information about position, scale, rotation,
    visibility, and opacity of a node. And in Cocos2d-x, there is an `Action` class
    to change each one of these values over time, in effect animating these transformations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actions are usually created with a static method `create`. The majority of
    these actions are time-based, so usually the first parameter you need to pass
    an action is the time length for the action. So for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a `fadeout` action that will take one second to complete. You
    can run it on a sprite, or node, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Cocos2d-x has an incredibly flexible system that allows us to create any combination
    of actions and transformations to achieve any effect we desire.
  prefs: []
  type: TYPE_NORMAL
- en: You may, for instance, choose to create an action sequence (`Sequence`) that
    contains more than one action; or you can apply easing effects (`EaseIn`, `EaseOut`,
    and so on) to your actions. You can choose to repeat an action a certain number
    of times (`Repeat`) or forever (`RepeatForever`); and you can add callbacks to
    functions you want called once an action is completed (usually inside a `Sequence`
    action).
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating actions with Cocos2d-x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating actions with Cocos2d-x is a very simple process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `createActions` method, we will instantiate the actions we can use
    repeatedly in our game. Let''s create our first actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Actions can be combined in many different forms. Here, the retained `_swingHealth`
    action is a `RepeatForever` action of `Sequence` that will rotate the health sprite
    first one way, then the other, with `EaseInOut` wrapping the `RotateTo` action.
    `RotateTo` takes `1.2` seconds to rotate the sprite first to `-10` degrees and
    then to `10`. And the easing has a value of `2`, which I suggest you experiment
    with to get a sense of what it means visually. Next we add three more actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, another `Sequence`. This will fade out the sprite and call the `shockwaveDone`
    function, which is already implemented in the class and turns the `_shockwave`
    sprite invisible when called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last one is a `RepeatForever` action of a `RotateBy` action. In half a second,
    the sprite running this action will rotate `-90` degrees and will do that again
    and again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You just got your first glimpse of how to create actions in Cocos2d-x and how
    the framework allows for all sorts of combinations to accomplish any effect.
  prefs: []
  type: TYPE_NORMAL
- en: It may be hard at first to read through a `Sequence` action and understand what's
    happening, but the logic is easy to follow once you break it down into its individual
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: But we are not done with the `createActions` method yet. Next come sprite animations.
  prefs: []
  type: TYPE_NORMAL
- en: Animating a sprite in Cocos2d-x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key thing to remember is that an animation is just another type of action,
    one that changes the texture used by a sprite over a period of time.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create an animation action, you need to first create an `Animation`
    object. This object will store all the information regarding the different sprite
    frames you wish to use in the animation, the length of the animation in seconds,
    and whether it loops or not.
  prefs: []
  type: TYPE_NORMAL
- en: With this `Animation` object, you then create a `Animate` action. Let's take
    a look.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Animations are a specialized type of action that require a few extra steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the same `createActions` method, add the lines for the two animations
    we have in the game. First, we start with the animation that shows an explosion
    when a meteor reaches the city. We begin by loading the frames into an `Animation`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we use the `Animation` object inside a `Animate` action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The same steps are repeated to create the other explosion animation used when
    the player hits a meteor or a health pack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We created two instances of a very special kind of action in Cocos2d-x: `Animate`.
    Here is what we did:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we created an `Animation` object. This object holds the references to
    all the textures used in the animation. The frames were named in such a way that
    they could easily be concatenated inside a loop (`boom1`, `boom2`, `boom3`, and
    so on). There are 10 frames for the first animation and seven for the second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The textures (or frames) are `SpriteFrame` objects we grab from `SpriteFrameCache`,
    which as you remember, contains all the information from the `sprite_sheet.plist`
    data file. So the frames are in our sprite sheet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then when all frames are in place, we determine the delay of each frame by dividing
    the total amount of seconds we want the animation to last by the total number
    of frames.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setRestoreOriginalFrame` method is important here. If we set `setRestoreOriginalFrame`
    to `true`, then the sprite will revert to its original appearance once the animation
    is over. For example, if I have an explosion animation that will run on a meteor
    sprite, then by the end of the explosion animation, the sprite will revert to
    displaying the meteor texture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time for the actual action. `Animate` receives the `Animation` object as its
    parameter. (In the first animation, we shift the position of the sprite just before
    the explosion appears, so there is an extra `MoveBy` method.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And in both instances, I make a call to an `animationDone` callback already
    implemented in the class. It makes the calling sprite invisible:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We could have used the same method for both callbacks (`animationDone` and `shockwaveDone`)
    as they accomplish the same thing. But I wanted to show you a callback that receives
    as an argument, the node that made the call and one that did not. Respectively,
    these are `CallFuncN` and `CallFunc`, and were used inside the action sequences
    we just created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Time to make our game tick!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, we have our main elements in place and are ready to add the final bit
    of logic to run the game. But how will everything work?
  prefs: []
  type: TYPE_NORMAL
- en: We will use a system of countdowns to add new meteors and new health packs,
    as well as a countdown that will incrementally make the game harder to play.
  prefs: []
  type: TYPE_NORMAL
- en: On touch, the player will start the game if the game is not running, and also
    add bombs and explode them during gameplay. An explosion creates a shockwave.
  prefs: []
  type: TYPE_NORMAL
- en: On update, we will check against collision between our `_shockwave` sprite (if
    visible) and all our falling objects. And that's it. Cocos2d-x will take care
    of all the rest through our created actions and callbacks!
  prefs: []
  type: TYPE_NORMAL
- en: So let's implement our touch events first.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – handling touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Time to bring the player to our party:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to implement our `onTouchBegan` method. We''ll begin by handling the two
    game states, `intro` and `game over`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we check to see if the game is not running. If not, we check to see if
    any of our messages are visible. If `_introMessage` is visible, we hide it. If
    `_gameOverMessage` is visible, we stop all current sound effects and hide the
    message as well. Then we call a method called `resetGame,` which will reset all
    the game data (energy, score, and countdowns) to their initial values, and set
    `_running` to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next we handle the touches. But we only need to handle one each time so we
    use `->anyObject()` on `Set`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If `_bomb` is visible, it means it''s already growing on the screen. So on
    touch, we use the `stopAllActions()` method on the bomb and we use the `stopAllActions()`
    method on its children that we retrieve through our tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If `_bomb` is the right size, we start our `_shockwave`. If it isn't, we play
    a bomb failure sound effect; there is no explosion and `_shockwave` is not made
    visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we have an explosion, then the `_shockwave` sprite is set to `10` percent
    of the scale. It''s placed at the same spot as the bomb, and we run a couple of
    actions on it: we grow the `_shockwave` sprite to twice the scale the bomb was
    when it went off and we run a copy of `_shockwaveSequence` that we created earlier.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, if no `_bomb` is currently visible on screen, we create one. And we
    run clones of previously created actions on the `_bomb` sprite and its children.
    When `_bomb` grows, its children grow. But when the children rotate, the bomb
    does not: a parent changes its children, but the children do not change their
    parent.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just added part of the core logic of the game. It is with touches that the
    player creates and explodes bombs to stop meteors from reaching the city. Now
    we need to create our falling objects. But first, let's set up our countdowns
    and our game data.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – starting and restarting the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add the logic to start and restart the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the implementation for `resetGame`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the implementation of `stopGame`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With these methods we control gameplay. We start the game with default values
    through `resetGame()`, and we stop all actions with `stopGame()`.
  prefs: []
  type: TYPE_NORMAL
- en: Already implemented in the class is the method that makes the game more difficult
    as time progresses. If you take a look at the method (`increaseDifficulty`) you
    will see that it reduces the interval between meteors and reduces the time it
    takes for meteors to reach the ground.
  prefs: []
  type: TYPE_NORMAL
- en: All we need now is the `update` method to run the countdowns and check for collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – updating the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already have the code that updates the countdowns inside the update. If it's
    time to add a meteor or a health pack we do it. If it's time to make the game
    more difficult to play, we do that too.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to use an action for these timers: a `Sequence` action with
    a `Delay` action object and a callback. But there are advantages to using these
    countdowns. It''s easier to reset them and to change them, and we can take them
    right into our main loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So it''s time to add our main loop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do is check for collisions. So add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If `_shockwave` is visible, we check the distance between it and each sprite
    in `_fallingObjects` vector. If we hit any meteors, we increase the value of the
    `_shockwaveHits` property so we can award the player for multiple hits. Next we
    move the clouds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I chose not to use a `MoveTo` action for the clouds to show you the amount of
    code that can be replaced by a simple action. If not for Cocos2d-x actions, we
    would have to implement logic to move, rotate, swing, scale, and explode all our
    sprites!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And finally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We give the player an extra visual cue to when a bomb is ready to explode by
    changing its opacity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main loop is pretty straightforward when you don't have to worry about updating
    individual sprites, as our actions take care of that for us. We pretty much only
    need to run collision checks between our sprites, and to determine when it's time
    to throw something new at the player.
  prefs: []
  type: TYPE_NORMAL
- en: So now the only thing left to do is grab the meteors and health packs from the
    pools when their timers are up. So let's get right to it.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – retrieving objects from the pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just need to use the correct index to retrieve the objects from their respective
    vector:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve meteor sprites, we''ll use the `resetMeteor` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We grab the next available meteor from the pool, then we pick a random start
    and end `x` value for its `MoveTo` action. The meteor starts at the top of the
    screen and will move to the bottom towards the city, but the `x` value is randomly
    picked each time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We rotate the meteor inside a `RepeatForever` action, and we use `Sequence`
    to move the sprite to its target position and then call back `fallingObjectDone`
    when the meteor has reached its target. We finish by adding the new meteor we
    retrieved from the pool to the `_fallingObjects` vector so we can check collisions
    with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method to retrieve the health (`resetHealth`) sprites is pretty much the
    same, except that `swingHealth` action is used instead of rotate. You'll find
    that method already implemented in `GameLayer.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So in `resetGame` we set the timers, and we update them in the `update` method.
    We use these timers to add meteors and health packs to the screen by grabbing
    the next available one from their respective pool, and then we proceed to run
    collisions between an exploding bomb and these falling objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that in both `resetMeteor` and `resetHealth` we don''t add new sprites
    if too many are on screen already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This way the game does not get ridiculously hard, and we never run out of unused
    objects in our pools.
  prefs: []
  type: TYPE_NORMAL
- en: And the very last bit of logic in our game is our `fallingObjectDone` callback,
    called when either a meteor or a health pack has reached the ground, at which
    point it awards or punishes the player for letting sprites through.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you take a look at that method inside `GameLayer.cpp`, you will notice
    how we use `->getTag()` to quickly ascertain which type of sprite we are dealing
    with (the one calling the method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If it's a meteor, we decrease energy from the player, play a sound effect, and
    run the explosion animation; an autorelease copy of the `_groundHit` action we
    retained earlier, so we don't need to repeat all that logic every time we need
    to run this action.
  prefs: []
  type: TYPE_NORMAL
- en: If the item is a health pack, we increase the energy or give the player some
    points, play a nice sound effect, and hide the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Play the game!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve been coding like mad, and it''s finally time to run the game. But first,
    don''t forget to release all the items we retained. In `GameLayer.cpp`, add our
    destructor method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual game screen will now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Play the game!](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once again, you can refer to `4198_04_FINAL_PROJECT.zip` if you find any problems
    running the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take this to Android.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – running the game in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to deploy the game to Android:'
  prefs: []
  type: TYPE_NORMAL
- en: This time, there is no need to alter the manifest because the default settings
    are the ones we want. So, navigate to `proj.android` and then to the `jni` folder
    and open the `Android.mk` file in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the lines in `LOCAL_SRC_FILES` to read as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Follow the instructions from the `HelloWorld` and `AirHockey` examples to import
    the game into Eclipse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save it and run your application. This time, you can try out different size
    screens if you have the devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You just ran a universal app in Android. And nothing could have been simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a bonus, I''ve added another version of the game with an extra type of enemy
    to deal with: a UFO hell-bent on zapping the city! You may find this in `4198_04_BONUS_PROJECT.zip`.'
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – sprites and actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. A `SpriteBatchNode` can contain what types of elements?
  prefs: []
  type: TYPE_NORMAL
- en: Sprites using textures from two or more sprite sheets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sprites using the same source texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blank sprites.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sprites using textures from one sprite sheet and one other image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. In order to run an action nonstop, what do I need to use?
  prefs: []
  type: TYPE_NORMAL
- en: '`RepeatForever`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Repeat`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default behavior of an action is to run nonstop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Actions can't repeat forever.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. In order to animate a sprite so that it would move to a certain point on
    the screen and then fade out, what actions would I need?
  prefs: []
  type: TYPE_NORMAL
- en: A `Sequence` listing an `EaseIn` and `EaseOut` action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Sequence` listing a `FadeOut` and `MoveTo` action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Sequence` listing a `MoveTo` or `MoveBy` and a `FadeOut` action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Sequence` listing a `RotateBy` and `FadeOut` action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q4\. To create a sprite frame animation, what group of classes are absolutely
    essential?
  prefs: []
  type: TYPE_NORMAL
- en: '`Sprite`, `SpriteBatchNode`, and `EaseIn`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SpriteFrameCache`, `RotateBy`, and `ActionManager`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Sprite`, `Layer`, and `FadeOut`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SpriteFrame`, `Animation`, and `Animate`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my opinion, after nodes and all their derived objects, actions are the second
    best thing about Cocos2d-x. They are time savers and can quickly spice things
    up in any project with professional-looking animations. And I hope with the examples
    found in this chapter, and along with the ones found in the Cocos2d-x samples
    test project, you will be able to create any action you need with Cocos2d-x.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, I''ll introduce you to another simple way you can spice
    things up in your game: with particles!'
  prefs: []
  type: TYPE_NORMAL
