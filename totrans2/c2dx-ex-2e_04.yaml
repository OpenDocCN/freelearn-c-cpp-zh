- en: Chapter 4. Fun with Sprites – Sky Defense
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章.与精灵的乐趣 - 天空防御
- en: '*Time to build our second game! This time, you will get acquainted with the
    power of actions in Cocos2d-x. I''ll show you how an entire game could be built
    just by running the various action commands contained in Cocos2d-x to make your
    sprites move, rotate, scale, fade, blink, and so on. And you can also use actions
    to animate your sprites using multiple images, like in a movie. So let''s get
    started.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*是时候构建我们的第二个游戏了！这次，你将了解 Cocos2d-x 中动作的力量。我会向你展示如何仅通过运行 Cocos2d-x 中包含的各种动作命令来构建整个游戏，使你的精灵移动、旋转、缩放、淡入淡出、闪烁等。你还可以使用动作通过多个图像来动画化你的精灵，就像在电影中一样。所以，让我们开始吧。*'
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: How to optimize the development of your game with sprite sheets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用精灵表优化你的游戏开发
- en: How to use bitmap fonts in your game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在你的游戏中使用位图字体
- en: How easy it is to implement and run actions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和运行动作是多么简单
- en: How to scale, rotate, swing, move, and fade out a sprite
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何缩放、旋转、摆动、移动和淡出精灵
- en: How to load multiple `.png` files and use them to animate a sprite
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何加载多个 `.png` 文件并使用它们来动画化精灵
- en: How to create a universal game with Cocos2d-x
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Cocos2d-x 创建通用游戏
- en: The game – sky defense
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏 - 天空防御
- en: Meet our stressed-out city of...your name of choice here. It's a beautiful day
    when suddenly the sky begins to fall. There are meteors rushing toward the city
    and it is your job to keep it safe.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 来认识我们的压力山大的城市……这里填入你选择的名称。这是一个美好的日子，突然天空开始下落。流星正冲向城市，你的任务是保护它安全。
- en: The player in this game can tap the screen to start growing a bomb. When the
    bomb is big enough to be activated, the player taps the screen again to detonate
    it. Any nearby meteor will explode into a million pieces. The bigger the bomb,
    the bigger the detonation, and the more meteors can be taken out by it. But the
    bigger the bomb, the longer it takes to grow it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的玩家可以轻触屏幕开始生长一个炸弹。当炸弹足够大可以激活时，玩家再次轻触屏幕来引爆它。任何附近的流星都会爆炸成百万碎片。炸弹越大，爆炸越剧烈，可以击毁的流星越多。但炸弹越大，生长它所需的时间就越长。
- en: But it's not just bad news coming down. There are also health packs dropping
    from the sky and if you allow them to reach the ground, you'll recover some of
    your energy.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但坏消息不止这些。天空中还会掉落医疗包，如果你允许它们落到地面，你将恢复一些能量。
- en: The game settings
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏设置
- en: This is a universal game. It is designed for the iPad retina screen and it will
    be scaled down to fit all the other screens. The game will be played in landscape
    mode, and it will not need to support multitouch.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用游戏。它为 iPad retina 屏幕设计，并将缩放到适合所有其他屏幕。游戏将以横屏模式进行，且不需要支持多点触控。
- en: The start project
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始项目
- en: Go ahead and download the file `4198_04_START_PROJECT.zip` from this book's
    support page ([www.packtpub.com/support](http://www.packtpub.com/support)). When
    you uncompress the file, you will find the basic project already set up and ready
    for you to work on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请从本书的支持页面（[www.packtpub.com/support](http://www.packtpub.com/support)）下载文件 `4198_04_START_PROJECT.zip`。当你解压文件时，你会发现基本项目已经设置好，准备好供你工作。
- en: 'The steps involved in creating this project are similar to the ones I showed
    you in our previous game. The command line I used was:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此项目涉及的步骤与我们之前游戏中的类似。我使用的命令行是：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In Xcode you must set the **Devices** field in **Deployment Info** to **Universal**,
    and the **Device Family** field is set to **Universal**. And in `RootViewController.mm`,
    the supported interface orientation is set to **Landscape**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 中，你必须将 **Deployment Info** 中的 **Devices** 字段设置为 **Universal**，并将 **Device
    Family** 字段设置为 **Universal**。在 `RootViewController.mm` 中，支持的界面方向设置为 **Landscape**。
- en: The game we are going to build requires only one class, `GameLayer.cpp`, and
    you will find that the interface for this class already contains all the information
    it needs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的游戏只需要一个类，`GameLayer.cpp`，你会发现这个类的接口已经包含了它所需的所有信息。
- en: Also, some of the more trivial or old-news logic is already in place in the
    implementation file as well. But I'll go over this as we work on the game.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些更简单或过时的逻辑已经在实现文件中就位了。但我会随着我们游戏的发展来讲解这些。
- en: Adding screen support for a universal app
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为通用应用添加屏幕支持
- en: In the previous game, we targeted iPad size screens only. Now things get a bit
    more complicated as we add support for smaller screens in our universal game,
    as well as some of the most common Android screen sizes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个游戏中，我们只针对 iPad 尺寸的屏幕。现在事情变得有点复杂，因为我们在通用游戏中增加了对较小屏幕的支持，以及一些最常见的 Android 屏幕尺寸。
- en: 'So open `AppDelegate.cpp`. Inside the `applicationDidFinishLaunching` method,
    we now have the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开`AppDelegate.cpp`文件。在`applicationDidFinishLaunching`方法内部，我们现在有以下代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once again, we tell our `GLView` object (our OpenGL view) that we designed the
    game for a certain screen size (the iPad retina screen) and once again, we want
    our game screen to resize to match the screen on the device (`ResolutionPolicy::EXACT_FIT`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我们告诉我们的`GLView`对象（我们的OpenGL视图）我们为某个屏幕尺寸（iPad视网膜屏）设计了游戏，并且我们再次希望我们的游戏屏幕调整大小以匹配设备上的屏幕（`ResolutionPolicy::EXACT_FIT`）。
- en: Then we determine where to load our images from, based on the device's screen
    size. We have art for iPad retina, then for regular iPad which is shared by iPhone
    retina, and for the regular iPhone.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们根据设备的屏幕尺寸确定从哪里加载我们的图像。我们有iPad视网膜屏的美术资源，然后是普通iPad，它由iPhone视网膜屏共享，以及普通iPhone的美术资源。
- en: We end by setting the scale factor based on the designed target.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后根据设计的目标设置缩放因子。
- en: Adding background music
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加背景音乐
- en: 'Still inside `AppDelegate.cpp`, we load the sound files we''ll use in the game,
    including a `background.mp3` (courtesy of Kevin MacLeod from [incompetech.com](http://incompetech.com)),
    which we load through the command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在`AppDelegate.cpp`中，我们加载游戏中将使用的声音文件，包括一个`background.mp3`（由Kevin MacLeod从[incompetech.com](http://incompetech.com)提供），我们通过以下命令加载它：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We end by setting the effects'' volume down a tad:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后将音效的音量稍微调低：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For background music volume, you must use `setBackgroundMusicVolume`. If you
    create some sort of volume control in your game, these are the calls you would
    make to adjust the volume based on the user's preference.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于背景音乐的音量，您必须使用`setBackgroundMusicVolume`。如果您在游戏中创建某种音量控制，这些就是您根据用户的偏好调整音量的调用。
- en: Initializing the game
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化游戏
- en: 'Now back to `GameLayer.cpp`. If you take a look inside our `init` method, you
    will see that the game initializes by calling three methods: `createGameScreen`,
    `createPools`, and `createActions`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到`GameLayer.cpp`。如果您查看我们的`init`方法，您会看到游戏通过调用三个方法进行初始化：`createGameScreen`、`createPools`和`createActions`。
- en: We'll create all our screen elements inside the first method, and then create
    object pools so we don't instantiate any sprite inside the main loop; and we'll
    create all the main actions used in our game inside the `createActions` method.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第一个方法内部创建所有屏幕元素，然后创建对象池，这样我们就不需要在主循环中实例化任何精灵；我们将在`createActions`方法内部创建游戏中使用的所有主要动作。
- en: 'And as soon as the game initializes, we start playing the background music,
    with its `should loop` parameter set to `true`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏初始化完成后，我们开始播放背景音乐，并将其`should loop`参数设置为`true`：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We once again store the screen size for future reference, and we'll use a `_running`
    Boolean for game states.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次存储屏幕尺寸以供将来参考，并使用一个`_running`布尔值来表示游戏状态。
- en: 'If you run the game now, you should only see the background image:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行游戏，您应该只能看到背景图像：
- en: '![Initializing the game](img/00011.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![初始化游戏](img/00011.jpeg)'
- en: Using sprite sheets in Cocos2d-x
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Cocos2d-x中使用精灵图集
- en: A sprite sheet is a way to group multiple images together in one image file.
    In order to texture a sprite with one of these images, you must have the information
    of where in the sprite sheet that particular image is found (its rectangle).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵图集是将多个图像组合到一个图像文件中的方法。为了用这些图像之一纹理化精灵，您必须知道该图像在精灵图集中的位置信息（其矩形）。
- en: 'Sprite sheets are often organized in two files: the image one and a data file
    that describes where in the image you can find the individual textures.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵图集通常分为两个文件：一个是图像文件，另一个是数据文件，它描述了在图像中可以找到单个纹理的位置。
- en: I used `TexturePacker` to create these files for the game. You can find them
    inside the `ipad`, `ipadhd`, and `iphone` folders inside `Resources`. There is
    a `sprite_sheet.png` file for the image and a `sprite_sheet.plist` file that describes
    the individual frames inside the image.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`TexturePacker`为游戏创建了这些文件。您可以在`Resources`文件夹内的`ipad`、`ipadhd`和`iphone`文件夹中找到它们。有一个`sprite_sheet.png`文件用于图像，还有一个`sprite_sheet.plist`文件，它描述了图像中的单个帧。
- en: 'This is what the `sprite_sheet.png` file looks like:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`sprite_sheet.png`文件的外观：
- en: '![Using sprite sheets in Cocos2d-x](img/00012.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![在Cocos2d-x中使用精灵图集](img/00012.jpeg)'
- en: Batch drawing sprites
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量绘制精灵
- en: In Cocos2d-x, sprite sheets can be used in conjunction with a specialized node,
    called `SpriteBatchNode`. This node can be used whenever you wish to use multiple
    sprites that share the same source image inside the same node. So you could have
    multiple instances of a `Sprite` class that uses a `bullet.png` texture for instance.
    And if the source image is a sprite sheet, you can have multiple instances of
    sprites displaying as many different textures as you could pack inside your sprite
    sheet.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cocos2d-x 中，精灵图可以与一个专门的节点一起使用，称为 `SpriteBatchNode`。这个节点可以在你希望使用多个共享相同源图像的精灵时使用。所以你可以有多个
    `Sprite` 类的实例，例如使用 `bullet.png` 纹理。如果源图像是精灵图，你可以有多个精灵实例，显示尽可能多的不同纹理，就像你可以在精灵图中打包的那样。
- en: With `SpriteBatchNode`, you can substantially reduce the number of calls during
    the rendering stage of your game, which will help when targeting less powerful
    systems, though not noticeably in more modern devices.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `SpriteBatchNode`，你可以显著减少游戏渲染阶段的调用次数，这有助于针对性能较弱的系统，尽管在更现代的设备上并不明显。
- en: Let me show you how to create a `SpriteBatchNode`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我展示如何创建一个 `SpriteBatchNode`。
- en: Time for action – creating SpriteBatchNode
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建 SpriteBatchNode
- en: 'Let''s begin implementing the `createGameScreen` method in `GameLayer.cpp`.
    Just below the lines that add the `bg` sprite, we instantiate our batch node:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现 `GameLayer.cpp` 中的 `createGameScreen` 方法。在添加 `bg` 精灵的行下面，我们实例化我们的批处理节点：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In order to create the batch node from a sprite sheet, we first load all the
    frame information described by the `sprite_sheet.plist` file into `SpriteFrameCache`.
    And then we create the batch node with the `sprite_sheet.png` file, which is the
    source texture shared by all sprites added to this batch node. (The background
    image is not part of the sprite sheet, so it's added separately before we add
    `_gameBatchNode` to GameLayer.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从精灵图中创建批处理节点，我们首先将 `sprite_sheet.plist` 文件中描述的所有帧信息加载到 `SpriteFrameCache`
    中。然后我们使用 `sprite_sheet.png` 文件创建批处理节点，这是所有添加到该批处理节点的精灵共享的源纹理。（背景图像不是精灵图的一部分，所以我们将其单独添加，在我们将
    `_gameBatchNode` 添加到 GameLayer 之前。）
- en: Now we can start putting stuff inside `_gameBatchNode`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始将东西放入 `_gameBatchNode` 中。
- en: 'First, the city:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，是城市：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then the trees:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是树木：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that here we create sprites by passing it a sprite frame name. The IDs
    for these frame names were loaded into `SpriteFrameCache` through our `sprite_sheet.plist`
    file.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在这里我们通过传递精灵帧名称来创建精灵。这些帧名称的 ID 是通过我们的 `sprite_sheet.plist` 文件加载到 `SpriteFrameCache`
    中的。
- en: 'The screen so far is made up of two instances of `city_dark.png` tiling at
    the bottom of the screen, and two instances of `city_light.png` also tiling. One
    needs to appear on top of the other and for that we use the enumerated values
    declared in `GameLayer.h`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止的屏幕由两个实例的 `city_dark.png` 在屏幕底部拼接而成，以及两个实例的 `city_light.png` 也进行拼接。一个需要出现在另一个之上，为此我们使用在
    `GameLayer.h` 中声明的枚举值：
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We use the `addChild( Node, zOrder)` method to layer our sprites on top of each
    other, using different values for their `z` order.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `addChild(Node, zOrder)` 方法通过不同的 `z` 值将精灵层叠在一起。
- en: So for example, when we later add three sprites showing the `trees.png` sprite
    frame, we add them on top of all previous sprites using the highest value for
    z that we find in the enumerated list, which is `kForeground`.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，当我们后来添加三个显示 `trees.png` 精灵帧的精灵时，我们使用枚举列表中找到的最高 z 值将它们添加到所有之前的精灵之上，这个值是 `kForeground`。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Why go through the trouble of tiling the images and not using one large image
    instead, or combining some of them with the background image? Because I wanted
    to include the greatest number of images possible inside the one sprite sheet,
    and have that sprite sheet to be as small as possible, to illustrate all the clever
    ways you can use and optimize sprite sheets. This is not necessary in this particular
    game.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么费尽心机去拼接图像而不是使用一张大图，或者将其中一些与背景图像结合？因为我想在单个精灵图中包含尽可能多的图像，并使该精灵图尽可能小，以展示所有你可以使用和优化的精灵图方法。在这个特定的游戏中，这并不是必需的。
- en: '*What just happened?*'
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We began creating the initial screen for our game. We are using a `SpriteBatchNode`
    to contain all the sprites that use images from our sprite sheet. So `SpriteBatchNode`
    behaves as any node does—as a container. And we can layer individual sprites inside
    the batch node by manipulating their `z` order.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始创建游戏的初始屏幕。我们使用 `SpriteBatchNode` 来包含所有使用精灵表图片的精灵。所以 `SpriteBatchNode` 的行为就像任何节点一样——作为一个容器。我们可以通过操作它们的
    `z` 排序在批处理节点内层叠单个精灵。
- en: Bitmap fonts in Cocos2d-x
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cocos2d-x 中的位图字体
- en: The Cocos2d-x `Label` class has a static `create` method that uses bitmap images
    for the characters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x 的 `Label` 类有一个静态的 `create` 方法，它使用位图图像来显示字符。
- en: The bitmap image we are using here was created with the program GlyphDesigner,
    and in essence, it works just as a sprite sheet does. As a matter of fact, `Label`
    extends `SpriteBatchNode`, so it behaves just like a batch node.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的位图图像是用 GlyphDesigner 程序创建的，本质上，它就像精灵表一样工作。事实上，`Label` 扩展了 `SpriteBatchNode`，所以它的行为就像一个批处理节点。
- en: 'You have images for all individual characters you''ll need packed inside a
    PNG file (`font.png`), and then a data file (`font.fnt`) describing where each
    character is. The following screenshot shows how the font sprite sheet looks like
    for our game:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的所有单个字符的图像都打包在一个 PNG 文件（`font.png`）中，然后是一个描述每个字符位置的描述文件（`font.fnt`）。以下截图显示了我们的游戏中的字体精灵表：
- en: '![Bitmap fonts in Cocos2d-x](img/00013.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Cocos2d-x 中的位图字体](img/00013.jpeg)'
- en: The difference between `Label` and a regular `SpriteBatchNode` class is that
    the data file also feeds the `Label` object information on how to *write* with
    this font. In other words, how to space out the characters and lines correctly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Label` 和常规 `SpriteBatchNode` 类之间的区别在于数据文件还向 `Label` 对象提供了如何使用此字体*书写*的信息。换句话说，如何正确地分配字符和行。'
- en: 'The `Label` objects we are using in the game are instantiated with the name
    of the data file and their initial string value:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在游戏中使用的 `Label` 对象是用数据文件名和它们的初始字符串值实例化的：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And the value for the label is changed through the `setString` method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 标签的值通过 `setString` 方法更改：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Just as with every other image in the game, we also have different versions
    of `font.fnt` and `font.png` in our `Resources` folders, one for each screen definition.
    `FileUtils` will once again do the heavy lifting of finding the correct file for
    the correct screen.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就像游戏中每张图片一样，我们在 `Resources` 文件夹中也有不同版本的 `font.fnt` 和 `font.png`，每个屏幕定义一个。`FileUtils`
    将再次承担寻找正确文件的重任，以适应正确的屏幕。
- en: So now let's create the labels for our game.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为我们的游戏创建标签。
- en: Time for action – creating bitmap font labels
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建位图字体标签
- en: Creating a bitmap font is somewhat similar to creating a batch node.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建位图字体与创建批处理节点有些相似。
- en: 'Continuing with our `createGameScreen` method, add the following lines to the
    `score` label:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续使用 `createGameScreen` 方法，向 `score` 标签添加以下行：
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And then add a label to display the energy level, and set its horizontal alignment
    to `Right`:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后添加一个标签来显示能量等级，并将其水平对齐设置为 `Right`：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following line for an icon that appears next to the `_energyDisplay`
    label:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `_energyDisplay` 标签旁边出现的图标添加以下行：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*What just happened?*'
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just created our first bitmap font object in Cocos2d-x. Now let's finish
    creating our game's sprites.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在 Cocos2d-x 中创建了第一个位图字体对象。现在让我们完成创建游戏精灵。
- en: Time for action – adding the final screen sprites
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 添加最终屏幕精灵
- en: The last sprites we need to create are the clouds, the bomb and shockwave, and
    our game state messages.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要创建的精灵是云、炸弹和冲击波，以及我们的游戏状态消息。
- en: 'Back to the `createGameScreen` method, add the clouds to the screen:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `createGameScreen` 方法，将云添加到屏幕上：
- en: '[PRE14]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the `_bomb` sprite; players will *grow* when tapping the screen:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `_bomb` 精灵；玩家在触摸屏幕时会*增长*：
- en: '[PRE15]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then create the `_shockwave` sprite that appears after the `_bomb` goes off:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建 `_shockwave` 精灵，它在 `_bomb` 爆炸后出现：
- en: '[PRE16]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, add the two messages that appear on the screen, one for our `intro`
    state and one for our `gameover` state:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加屏幕上出现的两条消息，一条用于我们的 `intro` 状态，另一条用于 `gameover` 状态：
- en: '[PRE17]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*What just happened?*'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'There is a lot of new information regarding sprites in the previous code. So
    let''s go over it carefully:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中关于精灵有很多新的信息。所以让我们仔细地过一遍：
- en: We started by adding the clouds. We put the sprites inside a vector so we can
    move the clouds later. Notice that they are also part of our batch node.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先添加了云。我们将精灵放入一个向量中，以便以后可以移动云。注意，它们也是我们批处理节点的一部分。
- en: 'Next comes the bomb sprite and our first new call:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是炸弹精灵和我们的第一个新调用：
- en: '[PRE18]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this we are telling the framework to create antialiased copies of this
    texture in diminishing sizes (mipmaps), since we are going to scale it down later.
    This is optional of course; sprites can be resized without first generating mipmaps,
    but if you notice loss of quality in your scaled sprites, you can fix that by
    creating mipmaps for their texture.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这种方法，我们告诉框架创建该纹理的逐级细节（mipmaps）的逐级减小尺寸的抗锯齿副本，因为我们稍后将要将其缩小。当然，这是可选的；精灵可以在不首先生成mipmaps的情况下调整大小，但如果您注意到缩放精灵时质量下降，您可以通过为它们的纹理创建mipmaps来修复这个问题。
- en: Note
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The texture must have size values in so-called POT (power of 2: 2, 4, 8, 16,
    32, 64, 128, 256, 512, 1024, 2048, and so on). Textures in OpenGL must always
    be sized this way; when they are not, Cocos2d-x will do one of two things: it
    will either resize the texture in memory, adding transparent pixels until the
    image reaches a POT size, or stop the execution on an assert. With textures used
    for mipmaps, the framework will stop execution for non-POT textures.'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 纹理必须具有所谓的POT（2的幂：2、4、8、16、32、64、128、256、512、1024、2048等等）的大小值。OpenGL中的纹理必须始终以这种方式进行尺寸设置；如果不是这样，Cocos2d-x将执行以下两种操作之一：它将在内存中调整纹理的大小，添加透明像素，直到图像达到POT大小，或者停止执行并抛出断言。对于用于mipmaps的纹理，框架将停止执行非POT纹理。
- en: I add the `sparkle` and the `halo` sprites as children to the `_bomb` sprite.
    This will use the container characteristic of nodes to our advantage. When I grow
    the bomb, all its children will grow with it.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将`sparkle`和`halo`精灵作为子节点添加到`_bomb`精灵中。这将利用节点的容器特性为我们带来优势。当我放大炸弹时，所有子节点也会随之放大。
- en: 'Notice too that I use a third parameter to `addChild` for `halo` and `sparkle`:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，我还为`halo`和`sparkle`的`addChild`方法使用了第三个参数：
- en: '[PRE19]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This third parameter is an integer tag from yet another enumerated list declared
    in `GameLayer.h`. I can use this tag to retrieve a particular child from a sprite
    as follows:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个第三个参数是从`GameLayer.h`中声明的另一个枚举列表中的整数标签。我可以使用这个标签来检索从精灵中特定的子节点，如下所示：
- en: '[PRE20]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We now have our game screen in place:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置了游戏屏幕：
- en: '![What just happened?](img/00014.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/00014.jpeg)'
- en: Next come object pools.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是对象池。
- en: Time for action – creating our object pools
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——创建我们的对象池
- en: 'The pools are just vectors of objects. And here are the steps to create them:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 池只是对象的向量。以下是创建它们的步骤：
- en: 'Inside the `createPools` method, we first create a pool for meteors:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`createPools`方法内部，我们首先为流星创建一个池：
- en: '[PRE21]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then we create an object pool for health packs:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们为健康包创建一个对象池：
- en: '[PRE22]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We'll use the corresponding pool index to retrieve objects from the vectors
    as the game progresses.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着游戏的进行，我们将使用相应的池索引从向量中检索对象。
- en: '*What just happened?*'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We now have a vector of invisible meteor sprites and a vector of invisible health
    sprites. We'll use their respective pool indices to retrieve these from the vector
    as needed as you'll see in a moment. But first we need to take care of actions
    and animations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个不可见的流星精灵向量和一个不可见的健康精灵向量。我们将使用它们各自的池索引在需要时从向量中检索这些精灵，正如您一会儿将看到的。但首先我们需要处理动作和动画。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With object pools, we reduce the number of instantiations during the main loop,
    and it allows us to never destroy anything that can be reused. But if you need
    to remove a child from a node, use `->removeChild` or `->removeChildByTag` if
    a tag is present.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象池，我们在主循环中减少了实例化的数量，并且它允许我们永远不会销毁可以重用的任何东西。但如果您需要从节点中移除一个子节点，请使用`->removeChild`或`->removeChildByTag`（如果存在标签）。
- en: Actions in a nutshell
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作概述
- en: If you remember, a node will store information about position, scale, rotation,
    visibility, and opacity of a node. And in Cocos2d-x, there is an `Action` class
    to change each one of these values over time, in effect animating these transformations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，节点将存储有关位置、缩放、旋转、可见性和不透明度的信息。在Cocos2d-x中，有一个`Action`类可以随时间改变这些值中的每一个，从而实现这些转换的动画。
- en: 'Actions are usually created with a static method `create`. The majority of
    these actions are time-based, so usually the first parameter you need to pass
    an action is the time length for the action. So for instance:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 动作通常使用静态方法`create`创建。这些动作中的大多数都是基于时间的，所以通常您需要传递给动作的第一个参数是动作的时间长度。例如：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This creates a `fadeout` action that will take one second to complete. You
    can run it on a sprite, or node, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`渐隐`动作，它将在一秒钟内完成。您可以在精灵或节点上运行它，如下所示：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Cocos2d-x has an incredibly flexible system that allows us to create any combination
    of actions and transformations to achieve any effect we desire.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x 有一个非常灵活的系统，允许我们创建任何组合的动作和变换，以实现我们想要的任何效果。
- en: You may, for instance, choose to create an action sequence (`Sequence`) that
    contains more than one action; or you can apply easing effects (`EaseIn`, `EaseOut`,
    and so on) to your actions. You can choose to repeat an action a certain number
    of times (`Repeat`) or forever (`RepeatForever`); and you can add callbacks to
    functions you want called once an action is completed (usually inside a `Sequence`
    action).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以选择创建一个包含多个动作的动作序列（`Sequence`）；或者你可以对你的动作应用缓动效果（`EaseIn`、`EaseOut` 等）。你可以选择重复一个动作一定次数（`Repeat`）或无限重复（`RepeatForever`）；你还可以添加回调函数，以便在动作完成后调用（通常在
    `Sequence` 动作内部）。
- en: Time for action – creating actions with Cocos2d-x
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候进行动作了——使用 Cocos2d-x 创建动作
- en: 'Creating actions with Cocos2d-x is a very simple process:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cocos2d-x 创建动作是一个非常简单的过程：
- en: 'Inside our `createActions` method, we will instantiate the actions we can use
    repeatedly in our game. Let''s create our first actions:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `createActions` 方法中，我们将实例化我们可以在游戏中重复使用的动作。让我们创建我们的第一个动作：
- en: '[PRE25]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Actions can be combined in many different forms. Here, the retained `_swingHealth`
    action is a `RepeatForever` action of `Sequence` that will rotate the health sprite
    first one way, then the other, with `EaseInOut` wrapping the `RotateTo` action.
    `RotateTo` takes `1.2` seconds to rotate the sprite first to `-10` degrees and
    then to `10`. And the easing has a value of `2`, which I suggest you experiment
    with to get a sense of what it means visually. Next we add three more actions:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动作可以以许多不同的形式组合。在这里，保留的 `_swingHealth` 动作是一个 `Sequence` 的 `RepeatForever` 动作，它将首先以一个方向旋转健康精灵，然后以另一个方向旋转，`EaseInOut`
    包裹着 `RotateTo` 动作。`RotateTo` 需要 `1.2` 秒来首先将精灵旋转到 `-10` 度，然后旋转到 `10` 度。缓动函数的值为
    `2`，我建议你尝试一下，以了解它在视觉上的意义。接下来我们再添加三个动作：
- en: '[PRE26]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, another `Sequence`. This will fade out the sprite and call the `shockwaveDone`
    function, which is already implemented in the class and turns the `_shockwave`
    sprite invisible when called.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，另一个 `Sequence`。这将使精灵淡出并调用 `shockwaveDone` 函数，该函数已经在类中实现，并在调用时将 `_shockwave`
    精灵变为不可见。
- en: The last one is a `RepeatForever` action of a `RotateBy` action. In half a second,
    the sprite running this action will rotate `-90` degrees and will do that again
    and again.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个是 `RotateBy` 动作的 `RepeatForever` 动作。在半秒内，执行此动作的精灵将旋转 `-90` 度，并且会不断重复这样做。
- en: '*What just happened?*'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You just got your first glimpse of how to create actions in Cocos2d-x and how
    the framework allows for all sorts of combinations to accomplish any effect.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到了如何在 Cocos2d-x 中创建动作，以及框架如何允许进行各种组合以实现任何效果。
- en: It may be hard at first to read through a `Sequence` action and understand what's
    happening, but the logic is easy to follow once you break it down into its individual
    parts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 起初阅读 `Sequence` 动作并理解其工作原理可能有些困难，但一旦将其分解为各个部分，逻辑就很容易理解了。
- en: But we are not done with the `createActions` method yet. Next come sprite animations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还没有完成 `createActions` 方法。接下来是精灵动画。
- en: Animating a sprite in Cocos2d-x
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Cocos2d-x 中动画精灵
- en: The key thing to remember is that an animation is just another type of action,
    one that changes the texture used by a sprite over a period of time.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '需要记住的关键点是，动画只是另一种类型的动作，它会在一段时间内改变精灵使用的纹理。 '
- en: In order to create an animation action, you need to first create an `Animation`
    object. This object will store all the information regarding the different sprite
    frames you wish to use in the animation, the length of the animation in seconds,
    and whether it loops or not.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个动画动作，你首先需要创建一个 `Animation` 对象。该对象将存储有关你希望在动画中使用的不同精灵帧的所有信息，动画的长度（以秒为单位），以及它是否循环。
- en: With this `Animation` object, you then create a `Animate` action. Let's take
    a look.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 `Animation` 对象，然后创建一个 `Animate` 动作。让我们看看。
- en: Time for action – creating animations
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候进行动作了——创建动画
- en: 'Animations are a specialized type of action that require a few extra steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是一种特殊类型的动作，需要一些额外的步骤：
- en: 'Inside the same `createActions` method, add the lines for the two animations
    we have in the game. First, we start with the animation that shows an explosion
    when a meteor reaches the city. We begin by loading the frames into an `Animation`
    object:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个 `createActions` 方法中，添加游戏中的两个动画的代码行。首先，我们从当流星到达城市时显示爆炸动画的动画开始。我们首先将帧加载到
    `Animation` 对象中：
- en: '[PRE27]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we use the `Animation` object inside a `Animate` action:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在 `Animate` 动作中使用 `Animation` 对象：
- en: '[PRE28]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The same steps are repeated to create the other explosion animation used when
    the player hits a meteor or a health pack.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相同的步骤被重复使用以创建其他爆炸动画，当玩家击中流星或健康包时使用。
- en: '[PRE29]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*What just happened?*'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'We created two instances of a very special kind of action in Cocos2d-x: `Animate`.
    Here is what we did:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Cocos2d-x 中创建了两种非常特殊的行为实例：`Animate`。以下是我们的操作步骤：
- en: First, we created an `Animation` object. This object holds the references to
    all the textures used in the animation. The frames were named in such a way that
    they could easily be concatenated inside a loop (`boom1`, `boom2`, `boom3`, and
    so on). There are 10 frames for the first animation and seven for the second.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个 `Animation` 对象。该对象持有动画中使用的所有纹理的引用。帧被命名为，以便它们可以在循环中轻松连接（`boom1`、`boom2`、`boom3`
    等等）。第一个动画有 10 帧，第二个有 7 帧。
- en: The textures (or frames) are `SpriteFrame` objects we grab from `SpriteFrameCache`,
    which as you remember, contains all the information from the `sprite_sheet.plist`
    data file. So the frames are in our sprite sheet.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理（或帧）是我们从 `SpriteFrameCache` 中获取的 `SpriteFrame` 对象，如您所记得，它包含来自 `sprite_sheet.plist`
    数据文件的所有信息。因此，帧在我们的精灵图中。
- en: Then when all frames are in place, we determine the delay of each frame by dividing
    the total amount of seconds we want the animation to last by the total number
    of frames.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后当所有帧都就绪后，我们通过将动画所需的总秒数除以总帧数来确定每帧的延迟。
- en: The `setRestoreOriginalFrame` method is important here. If we set `setRestoreOriginalFrame`
    to `true`, then the sprite will revert to its original appearance once the animation
    is over. For example, if I have an explosion animation that will run on a meteor
    sprite, then by the end of the explosion animation, the sprite will revert to
    displaying the meteor texture.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRestoreOriginalFrame` 方法在这里很重要。如果我们把 `setRestoreOriginalFrame` 设置为 `true`，那么动画结束后精灵将恢复到其原始外观。例如，如果我有一个将在流星精灵上运行的爆炸动画，那么在爆炸动画结束时，精灵将恢复显示流星纹理。'
- en: Time for the actual action. `Animate` receives the `Animation` object as its
    parameter. (In the first animation, we shift the position of the sprite just before
    the explosion appears, so there is an extra `MoveBy` method.)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是时候进行实际操作了。`Animate` 接收 `Animation` 对象作为其参数。（在第一个动画中，我们在爆炸出现之前移动精灵的位置，因此有一个额外的
    `MoveBy` 方法。）
- en: 'And in both instances, I make a call to an `animationDone` callback already
    implemented in the class. It makes the calling sprite invisible:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这两种情况下，我调用了类中已经实现的一个 `animationDone` 回调。这使得调用精灵变得不可见：
- en: '[PRE30]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We could have used the same method for both callbacks (`animationDone` and `shockwaveDone`)
    as they accomplish the same thing. But I wanted to show you a callback that receives
    as an argument, the node that made the call and one that did not. Respectively,
    these are `CallFuncN` and `CallFunc`, and were used inside the action sequences
    we just created.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们本可以使用相同的方法为两个回调（`animationDone` 和 `shockwaveDone`）进行操作，因为它们完成的是相同的事情。但我想要展示一个接收节点作为参数的回调，这个节点进行了调用，另一个没有。分别是
    `CallFuncN` 和 `CallFunc`，它们被用于我们刚刚创建的动作序列中。
- en: Time to make our game tick!
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候让我们的游戏开始跳动！
- en: Okay, we have our main elements in place and are ready to add the final bit
    of logic to run the game. But how will everything work?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经将主要元素放置到位，并准备好添加运行游戏的最后一点逻辑。但这一切将如何运作呢？
- en: We will use a system of countdowns to add new meteors and new health packs,
    as well as a countdown that will incrementally make the game harder to play.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用倒计时系统来添加新的流星和新的健康包，以及一个逐渐使游戏更难玩的倒计时。
- en: On touch, the player will start the game if the game is not running, and also
    add bombs and explode them during gameplay. An explosion creates a shockwave.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在触摸时，如果游戏未运行，玩家将开始游戏，并在游戏过程中添加炸弹并爆炸它们。爆炸会产生冲击波。
- en: On update, we will check against collision between our `_shockwave` sprite (if
    visible) and all our falling objects. And that's it. Cocos2d-x will take care
    of all the rest through our created actions and callbacks!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新时，我们将检查我们的 `_shockwave` 精灵（如果可见）与所有下落物体之间的碰撞。就这样。Cocos2d-x 将通过我们创建的动作和回调来处理所有其余的事情！
- en: So let's implement our touch events first.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现我们的触摸事件。
- en: Time for action – handling touches
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 处理触摸事件
- en: 'Time to bring the player to our party:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候把玩家带到我们的派对上了：
- en: 'Time to implement our `onTouchBegan` method. We''ll begin by handling the two
    game states, `intro` and `game over`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候实现我们的`onTouchBegan`方法了。我们首先处理两个游戏状态，`intro`和`game over`：
- en: '[PRE31]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here we check to see if the game is not running. If not, we check to see if
    any of our messages are visible. If `_introMessage` is visible, we hide it. If
    `_gameOverMessage` is visible, we stop all current sound effects and hide the
    message as well. Then we call a method called `resetGame,` which will reset all
    the game data (energy, score, and countdowns) to their initial values, and set
    `_running` to `true`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们检查游戏是否没有运行。如果没有运行，我们检查我们的消息是否可见。如果`_introMessage`是可见的，我们就隐藏它。如果`_gameOverMessage`是可见的，我们就停止所有当前音效并隐藏该消息。然后我们调用一个名为`resetGame`的方法，它将所有游戏数据（能量、得分和倒计时）重置为其初始值，并将`_running`设置为`true`。
- en: 'Next we handle the touches. But we only need to handle one each time so we
    use `->anyObject()` on `Set`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们处理触摸。但我们每次只需要处理一个，所以我们使用`Set`上的`->anyObject()`：
- en: '[PRE32]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If `_bomb` is visible, it means it''s already growing on the screen. So on
    touch, we use the `stopAllActions()` method on the bomb and we use the `stopAllActions()`
    method on its children that we retrieve through our tags:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`_bomb`是可见的，这意味着它已经在屏幕上生长了。所以当触摸时，我们在炸弹上使用`stopAllActions()`方法，并且使用`stopAllActions()`方法在其子项上，这些子项是通过我们的标签检索到的：
- en: '[PRE33]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If `_bomb` is the right size, we start our `_shockwave`. If it isn't, we play
    a bomb failure sound effect; there is no explosion and `_shockwave` is not made
    visible.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`_bomb`的大小正确，我们就开始我们的`_shockwave`。如果它不正确，我们就播放一个炸弹故障音效；没有爆炸，并且`_shockwave`不会被显示出来。
- en: 'If we have an explosion, then the `_shockwave` sprite is set to `10` percent
    of the scale. It''s placed at the same spot as the bomb, and we run a couple of
    actions on it: we grow the `_shockwave` sprite to twice the scale the bomb was
    when it went off and we run a copy of `_shockwaveSequence` that we created earlier.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有爆炸，那么`_shockwave`精灵的缩放设置为`10`%。它放置在炸弹相同的地点，并且我们对它执行几个动作：我们将`_shockwave`精灵的缩放增加到爆炸时炸弹的两倍，并运行我们之前创建的`_shockwaveSequence`的副本。
- en: 'Finally, if no `_bomb` is currently visible on screen, we create one. And we
    run clones of previously created actions on the `_bomb` sprite and its children.
    When `_bomb` grows, its children grow. But when the children rotate, the bomb
    does not: a parent changes its children, but the children do not change their
    parent.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果屏幕上没有可见的`_bomb`，我们就创建一个。然后我们在`_bomb`精灵及其子项上运行之前创建的动作的克隆。当`_bomb`生长时，其子项也会生长。但是当子项旋转时，炸弹不会：父项改变其子项，但子项不会改变它们的父项。
- en: '*What just happened?*'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just added part of the core logic of the game. It is with touches that the
    player creates and explodes bombs to stop meteors from reaching the city. Now
    we need to create our falling objects. But first, let's set up our countdowns
    and our game data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加了游戏核心逻辑的一部分。玩家通过触摸创建和爆炸炸弹来阻止陨石到达城市。现在我们需要创建我们的下落物体。但首先，让我们设置我们的倒计时和游戏数据。
- en: Time for action – starting and restarting the game
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候开始和重新开始游戏了
- en: Let's add the logic to start and restart the game.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加开始和重新开始游戏的逻辑。
- en: 'Let''s write the implementation for `resetGame`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来编写`resetGame`函数的实现：
- en: '[PRE34]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, add the implementation of `stopGame`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`stopGame`的实现：
- en: '[PRE35]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*What just happened?*'
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: With these methods we control gameplay. We start the game with default values
    through `resetGame()`, and we stop all actions with `stopGame()`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些方法我们控制游戏玩法。我们通过`resetGame()`使用默认值开始游戏，并通过`stopGame()`停止所有动作。
- en: Already implemented in the class is the method that makes the game more difficult
    as time progresses. If you take a look at the method (`increaseDifficulty`) you
    will see that it reduces the interval between meteors and reduces the time it
    takes for meteors to reach the ground.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 类中已经实现了随着时间推移使游戏更难的方法。如果你看看这个方法（`increaseDifficulty`），你会看到它减少了陨石之间的间隔，并减少了陨石到达地面的时间。
- en: All we need now is the `update` method to run the countdowns and check for collisions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要`update`方法来运行倒计时和检查碰撞。
- en: Time for action – updating the game
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候更新游戏了
- en: We already have the code that updates the countdowns inside the update. If it's
    time to add a meteor or a health pack we do it. If it's time to make the game
    more difficult to play, we do that too.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`update`函数内部有了更新倒计时的代码。如果时间到了，我们需要添加陨石或医疗包，我们就这么做。如果时间到了，我们需要让游戏更难玩，我们也这么做。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is possible to use an action for these timers: a `Sequence` action with
    a `Delay` action object and a callback. But there are advantages to using these
    countdowns. It''s easier to reset them and to change them, and we can take them
    right into our main loop.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一个动作来处理这些计时器：一个 `Sequence` 动作和一个 `Delay` 动作对象以及一个回调。但使用这些倒计时有一些优点。重置它们和更改它们更容易，并且我们可以直接将它们带入我们的主循环。
- en: 'So it''s time to add our main loop:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是添加我们的主循环的时候了：
- en: 'What we need to do is check for collisions. So add the following code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的是检查碰撞。所以添加以下代码：
- en: '[PRE36]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If `_shockwave` is visible, we check the distance between it and each sprite
    in `_fallingObjects` vector. If we hit any meteors, we increase the value of the
    `_shockwaveHits` property so we can award the player for multiple hits. Next we
    move the clouds:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `_shockwave` 是可见的，我们检查它和 `_fallingObjects` 向量中每个精灵之间的距离。如果我们击中任何流星，我们就增加
    `_shockwaveHits` 属性的值，这样我们就可以奖励玩家多次击中。接下来我们移动云朵：
- en: '[PRE37]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I chose not to use a `MoveTo` action for the clouds to show you the amount of
    code that can be replaced by a simple action. If not for Cocos2d-x actions, we
    would have to implement logic to move, rotate, swing, scale, and explode all our
    sprites!
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我选择不使用 `MoveTo` 动作来展示云朵，以显示可以由简单动作替换的代码量。如果不是因为 Cocos2d-x 动作，我们就必须实现移动、旋转、摆动、缩放和爆炸所有精灵的逻辑！
- en: 'And finally:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后：
- en: '[PRE38]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We give the player an extra visual cue to when a bomb is ready to explode by
    changing its opacity.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过改变炸弹准备爆炸时的不透明度，给玩家一个额外的视觉提示。
- en: '*What just happened?*'
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The main loop is pretty straightforward when you don't have to worry about updating
    individual sprites, as our actions take care of that for us. We pretty much only
    need to run collision checks between our sprites, and to determine when it's time
    to throw something new at the player.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不需要担心更新单个精灵时，主循环相当简单，因为我们的动作会为我们处理这些。我们基本上只需要运行精灵之间的碰撞检测，并确定何时向玩家投掷新的东西。
- en: So now the only thing left to do is grab the meteors and health packs from the
    pools when their timers are up. So let's get right to it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们唯一要做的就是当计时器结束时从池中抓取流星和健康包。让我们直接开始吧。
- en: Time for action – retrieving objects from the pool
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 从对象池中检索对象
- en: 'We just need to use the correct index to retrieve the objects from their respective
    vector:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要使用正确的索引从各自的向量中检索对象：
- en: 'To retrieve meteor sprites, we''ll use the `resetMeteor` method:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检索流星精灵，我们将使用 `resetMeteor` 方法：
- en: '[PRE39]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We grab the next available meteor from the pool, then we pick a random start
    and end `x` value for its `MoveTo` action. The meteor starts at the top of the
    screen and will move to the bottom towards the city, but the `x` value is randomly
    picked each time.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从对象池中获取下一个可用的流星，然后为它的 `MoveTo` 动作随机选择一个起始和结束的 `x` 值。流星从屏幕顶部开始，将移动到底部向城市方向，但每次随机选择
    `x` 值。
- en: We rotate the meteor inside a `RepeatForever` action, and we use `Sequence`
    to move the sprite to its target position and then call back `fallingObjectDone`
    when the meteor has reached its target. We finish by adding the new meteor we
    retrieved from the pool to the `_fallingObjects` vector so we can check collisions
    with it.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在一个 `RepeatForever` 动作中旋转流星，并使用 `Sequence` 将精灵移动到目标位置，然后在流星达到目标时调用 `fallingObjectDone`
    回调。我们通过将我们从池中检索到的新流星添加到 `_fallingObjects` 向量中来完成，这样我们就可以检查与它的碰撞。
- en: The method to retrieve the health (`resetHealth`) sprites is pretty much the
    same, except that `swingHealth` action is used instead of rotate. You'll find
    that method already implemented in `GameLayer.cpp`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索健康 (`resetHealth`) 精灵的方法基本上是相同的，只是使用 `swingHealth` 动作代替旋转。你会在 `GameLayer.cpp`
    中找到该方法已经实现。
- en: '*What just happened?*'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: So in `resetGame` we set the timers, and we update them in the `update` method.
    We use these timers to add meteors and health packs to the screen by grabbing
    the next available one from their respective pool, and then we proceed to run
    collisions between an exploding bomb and these falling objects.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `resetGame` 中我们设置计时器，并在 `update` 方法中更新它们。我们使用这些计时器通过从各自的池中获取下一个可用的对象来将流星和健康包添加到屏幕上，然后我们继续运行爆炸炸弹和这些下落对象之间的碰撞。
- en: 'Notice that in both `resetMeteor` and `resetHealth` we don''t add new sprites
    if too many are on screen already:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `resetMeteor` 和 `resetHealth` 中，如果屏幕上已经有很多精灵，我们不会添加新的精灵：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This way the game does not get ridiculously hard, and we never run out of unused
    objects in our pools.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这样游戏就不会变得荒谬地困难，我们也不会在我们的对象池中耗尽未使用的对象。
- en: And the very last bit of logic in our game is our `fallingObjectDone` callback,
    called when either a meteor or a health pack has reached the ground, at which
    point it awards or punishes the player for letting sprites through.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中最后一点逻辑是我们的`fallingObjectDone`回调，当流星或健康包到达地面时调用，此时它根据玩家是否让精灵通过而奖励或惩罚玩家。
- en: 'When you take a look at that method inside `GameLayer.cpp`, you will notice
    how we use `->getTag()` to quickly ascertain which type of sprite we are dealing
    with (the one calling the method):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看`GameLayer.cpp`中的那个方法时，你会注意到我们如何使用`->getTag()`来快速确定我们正在处理哪种类型的精灵（调用该方法的那个）：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If it's a meteor, we decrease energy from the player, play a sound effect, and
    run the explosion animation; an autorelease copy of the `_groundHit` action we
    retained earlier, so we don't need to repeat all that logic every time we need
    to run this action.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一颗流星，我们就减少玩家的能量，播放音效，并运行爆炸动画；我们保留的`_groundHit`动作的一个autorelease副本，这样我们就不需要在每次需要运行这个动作时重复所有逻辑。
- en: If the item is a health pack, we increase the energy or give the player some
    points, play a nice sound effect, and hide the sprite.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目是健康包，我们就增加能量或给玩家一些分数，播放一个好听的声音效果，并隐藏精灵。
- en: Play the game!
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩这个游戏！
- en: 'We''ve been coding like mad, and it''s finally time to run the game. But first,
    don''t forget to release all the items we retained. In `GameLayer.cpp`, add our
    destructor method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们疯狂地编码，现在终于到了运行游戏的时候。但首先，别忘了释放我们保留的所有项目。在`GameLayer.cpp`中，添加我们的析构函数方法：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The actual game screen will now look something like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的游戏屏幕现在看起来可能像这样：
- en: '![Play the game!](img/00015.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![玩这个游戏！](img/00015.jpeg)'
- en: Once again, you can refer to `4198_04_FINAL_PROJECT.zip` if you find any problems
    running the code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，如果你在运行代码时遇到任何问题，可以参考`4198_04_FINAL_PROJECT.zip`。
- en: Now, let's take this to Android.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其带到Android上。
- en: Time for action – running the game in Android
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候在Android上运行游戏了。
- en: 'Follow these steps to deploy the game to Android:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将游戏部署到Android：
- en: This time, there is no need to alter the manifest because the default settings
    are the ones we want. So, navigate to `proj.android` and then to the `jni` folder
    and open the `Android.mk` file in a text editor.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，没有必要修改清单文件，因为默认设置就是我们想要的。所以，导航到`proj.android`，然后到`jni`文件夹，在文本编辑器中打开`Android.mk`文件。
- en: 'Edit the lines in `LOCAL_SRC_FILES` to read as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`LOCAL_SRC_FILES`中的行，使其如下所示：
- en: '[PRE43]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Follow the instructions from the `HelloWorld` and `AirHockey` examples to import
    the game into Eclipse.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照从`HelloWorld`和`AirHockey`示例中的说明，将游戏导入Eclipse。
- en: Save it and run your application. This time, you can try out different size
    screens if you have the devices.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行你的应用程序。这次，如果你有设备，你可以尝试不同的屏幕尺寸。
- en: '*What just happened?*'
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: You just ran a universal app in Android. And nothing could have been simpler.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚在Android上运行了一个通用应用。这再简单不过了。
- en: 'As a bonus, I''ve added another version of the game with an extra type of enemy
    to deal with: a UFO hell-bent on zapping the city! You may find this in `4198_04_BONUS_PROJECT.zip`.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 作为奖励，我添加了游戏的另一个版本，增加了额外的敌人类型来处理：一个一心想要电击城市的UFO！你可以在`4198_04_BONUS_PROJECT.zip`中找到它。
- en: Pop quiz – sprites and actions
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验 - 精灵和动作
- en: Q1\. A `SpriteBatchNode` can contain what types of elements?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. `SpriteBatchNode`可以包含哪些类型的元素？
- en: Sprites using textures from two or more sprite sheets.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用来自两个或更多精灵图的纹理的精灵。
- en: Sprites using the same source texture.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同源纹理的精灵。
- en: Blank sprites.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空精灵。
- en: Sprites using textures from one sprite sheet and one other image.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用来自一个精灵图和另一个图像的纹理的精灵。
- en: Q2\. In order to run an action nonstop, what do I need to use?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 为了持续运行一个动作，我需要使用什么？
- en: '`RepeatForever`.'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RepeatForever`。'
- en: '`Repeat`.'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Repeat`。'
- en: The default behavior of an action is to run nonstop.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动作默认的行为是持续运行。
- en: Actions can't repeat forever.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动作不能永远重复。
- en: Q3\. In order to animate a sprite so that it would move to a certain point on
    the screen and then fade out, what actions would I need?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 为了使精灵移动到屏幕上的某个点然后淡出，我需要哪些动作？
- en: A `Sequence` listing an `EaseIn` and `EaseOut` action.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个列出`EaseIn`和`EaseOut`动作的`Sequence`。
- en: A `Sequence` listing a `FadeOut` and `MoveTo` action.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个列出`FadeOut`和`MoveTo`动作的`Sequence`。
- en: A `Sequence` listing a `MoveTo` or `MoveBy` and a `FadeOut` action.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个列出`MoveTo`或`MoveBy`和`FadeOut`动作的`Sequence`。
- en: A `Sequence` listing a `RotateBy` and `FadeOut` action.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个列出`RotateBy`和`FadeOut`动作的`Sequence`。
- en: Q4\. To create a sprite frame animation, what group of classes are absolutely
    essential?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 要创建一个精灵帧动画，哪些类组是绝对必要的？
- en: '`Sprite`, `SpriteBatchNode`, and `EaseIn`.'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Sprite`, `SpriteBatchNode`, 和 `EaseIn`.'
- en: '`SpriteFrameCache`, `RotateBy`, and `ActionManager`.'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SpriteFrameCache`, `RotateBy`, 和 `ActionManager`.'
- en: '`Sprite`, `Layer`, and `FadeOut`.'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Sprite`, `Layer`, 和 `FadeOut`.'
- en: '`SpriteFrame`, `Animation`, and `Animate`.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SpriteFrame`, `Animation`, 和 `Animate`.'
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In my opinion, after nodes and all their derived objects, actions are the second
    best thing about Cocos2d-x. They are time savers and can quickly spice things
    up in any project with professional-looking animations. And I hope with the examples
    found in this chapter, and along with the ones found in the Cocos2d-x samples
    test project, you will be able to create any action you need with Cocos2d-x.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，在节点及其所有派生对象之后，动作是 Cocos2d-x 的第二大优点。它们是节省时间的工具，并且可以快速为任何项目增添专业外观的动画。我希望通过本章中的示例，以及
    Cocos2d-x 样本测试项目中的示例，您将能够使用 Cocos2d-x 创建您需要的任何动作。
- en: 'In the next chapter, I''ll introduce you to another simple way you can spice
    things up in your game: with particles!'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将向您介绍另一种简单的方法，您可以用它来为您的游戏增添活力：使用粒子效果！
