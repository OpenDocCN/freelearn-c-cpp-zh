<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Get Your Hands Dirty &#x2013; What You Need to Know"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Get Your Hands Dirty – What You Need to Know</h1></div></div></div><p>Game development can often be a tedious process to bear. In many instances, the amount of time spent on writing a specific chunk of code, implementing a certain set of features, or revising an old code that you or someone else had written shows very few results that can be immediately appreciated; which is why you may at some point see a game developer's face light up in instant joy when a flashier segment of their project sees the light of day. Seeing your game actually come to life and begin changing before your very eyes is the reason most of our fellow game developers do what they do. Those moments make writing tons of code that show little stimulating results possible.</p><p>So, now that we have our game structure ready, it's time to focus on the fun, flashy parts!</p><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The game of choice for our first project and its history</li><li class="listitem" style="list-style-type: disc">Building the game we've chosen</li><li class="listitem" style="list-style-type: disc">Common game programming elements</li><li class="listitem" style="list-style-type: disc">Additional SFML elements needed to complete our project</li><li class="listitem" style="list-style-type: disc">Building helper elements for all our game projects</li><li class="listitem" style="list-style-type: disc">Effective debugging and common problem solving in games</li></ul></div><div class="section" title="Introducing snake"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Introducing snake</h1></div></div></div><p>If right<a id="id55" class="indexterm"/> now you're imagining building a game with <span class="emphasis"><em>Solid Snake</em></span> wearing his trademark bandana, we're not quite there yet, although the eagerness to do so is understandable. However, if you pictured something like the following, you're right on point:</p><div class="mediaobject"><img src="graphics/4284_03_01.jpg" alt="Introducing snake"/></div><p>First <a id="id56" class="indexterm"/>published by <span class="emphasis"><em>Gremlin</em></span> in 1976 under the name "Blockade", the snake concept is one of the most famous game types of all time. Countless ports have been written for this type of mechanic, such as <span class="emphasis"><em>Surround</em></span> by <span class="emphasis"><em>Atari</em></span> in 1978 and <span class="emphasis"><em>Worm</em></span> by <span class="emphasis"><em>Peter Trefonas</em></span>. Pretty much any platform that crosses one's mind has a port of snake on it, even including the early monochrome <span class="emphasis"><em>Nokia</em></span> phones, such as the <span class="emphasis"><em>3310</em></span> and <span class="emphasis"><em>6110</em></span>. The graphics changed from port to port and improved with time. However, the main idea and the rules remained the same ever since its humble beginnings:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The snake can move in four total directions: up, down, left, and right</li><li class="listitem" style="list-style-type: disc">Eating an apple makes the snake grow in length</li><li class="listitem" style="list-style-type: disc">You cannot touch the walls or your own body, otherwise the game is over</li></ul></div><p>Other things may vary depending on which version of the game you play, such as the score you receive for eating an apple, the amount of lives you have, the speed at which the snake moves, the size of the playing field, obstacles, and so on.</p></div></div>
<div class="section" title="Game design decisions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Game design decisions</h1></div></div></div><p>Certain <a id="id57" class="indexterm"/>versions of snake run differently; however, for the sake of paying homage to the classical approach, we will be implementing a snake that moves based on a <span class="strong"><strong>grid</strong></span>, as illustrated next:</p><div class="mediaobject"><img src="graphics/4284_03_02.jpg" alt="Game design decisions"/></div><p>Taking<a id="id58" class="indexterm"/> this approach makes it easier to later check for collision between the snake segments and the apple. Grid movement basically means updating at a static rate. This can be achieved by utilizing a fixed time-step, which we covered back in <a class="link" href="ch02.html" title="Chapter 2. Give It Some Structure – Building the Game Framework">Chapter 2</a>, <span class="emphasis"><em>Give It Some Structure – Building the Game Framework</em></span>.</p><p>The outside area symbolizes the boundaries of the game, which in the case of a grid-based movement would be in the range of <span class="emphasis"><em>[1;Width-1]</em></span> and <span class="emphasis"><em>[1;Height-1]</em></span>. If the snake head isn't within that range, it's safe to say that the player has crashed into a wall. All the grid segments here are 16px by 16px big; however, that can be adjusted at any time.</p><p>Unless the player runs out of lives, we want to cut the snake at the point of intersection if its head collides with its body and decrease the amount of lives left. This adds a little variety to the game without being too unbalanced.</p><p>Lastly, you've probably already picked up on the fact that we're using very simplistic graphical representations of what a snake is in this game. This is done mainly to keep things simple for now, as well as to add the charm of a classic to the mix. It wouldn't be terribly complicated to use sprites for this, however, let's not worry about that just yet.</p></div>
<div class="section" title="Implementing the snake structure"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Implementing the snake structure</h1></div></div></div><p>Let's<a id="id59" class="indexterm"/> now create the two files we'll be working with: <code class="literal">Snake.h</code> and <code class="literal">Snake.cpp</code>. Prior to actually developing the snake class, a definition of some data types and structures is in order. We can begin by actually defining the structure that our apple eating serpent will be made out of, right in the snake header file:</p><div class="informalexample"><pre class="programlisting">struct SnakeSegment{
    SnakeSegment(int x, int y) : position(x,y){}
    sf::Vector2i position;
};</pre></div><p>As you <a id="id60" class="indexterm"/>can tell, it's a very simple structure that contains a single member, which is an <span class="emphasis"><em>integer vector</em></span> representing the position of the segment on the grid. The constructor here is utilized to set the position of the segment through an <span class="emphasis"><em>initializer list</em></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>Before <a id="id61" class="indexterm"/>moving past this point, make sure you're competent with the <span class="strong"><strong>Standard Template Library</strong></span> and the data containers it provides. We will specifically be using <code class="literal">std::vector</code> for our needs.</p></div></div><p>We now have the segment type defined, so let's get started on actually storing the snake somewhere. For beginner purposes, <code class="literal">std::vector</code> will do nicely! Before going too far with that, here's a neat little trick for curing our code of "long-line-itus":</p><div class="informalexample"><pre class="programlisting">using SnakeContainer = std::vector&lt;SnakeSegment&gt;;</pre></div><p>As you should already know from your <span class="emphasis"><em>C/C++</em></span> background, <code class="literal">using</code> is a neat little keyword that allows the user to define aliases for the known data types. By using our clean new definitions together with the <code class="literal">auto</code> keyword, we're preventing a scenario like the following from ever happening:</p><div class="informalexample"><pre class="programlisting">std::vector&lt;SnakeSegment&gt;::iterator someIterator = ...</pre></div><p>It's a simple matter of convenience and is completely optional to use, however, we will be equipping this useful tool all the way through this book.</p><p>One last type we need to define before beginning to really work on the snake class, is the direction enumeration:</p><div class="informalexample"><pre class="programlisting">enum class Direction{ None, Up, Down, Left, Right };</pre></div><p>Once again, it's nothing too fancy. The snake has four directions it can move in. We also have a possibility of it standing still, in which case we can just set the direction to <code class="literal">NONE</code>.</p></div>
<div class="section" title="The snake class"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>The snake class</h1></div></div></div><p>Before <a id="id62" class="indexterm"/>designing any object, one must ask oneself what it needs. In our case, the snake needs to have a direction to move towards. It also needs to have lives, keep track of the score, its speed, whether it lost or not, and whether it lost or not. Lastly, we're going to store a rectangle shape that will represent every segment of the snake. When all these are addressed, the header of the snake class would look <a id="id63" class="indexterm"/>something like the following:</p><div class="informalexample"><pre class="programlisting">class Snake{
public:
    Snake(int l_blockSize);
    ~Snake();

    // Helper methods.
    void SetDirection(Direction l_dir);
    Direction GetDirection();
    int GetSpeed();
    sf::Vector2i GetPosition();
    int GetLives();
    int GetScore();
    void IncreaseScore();
    bool HasLost();

    void Lose(); // Handle losing here.
    void ToggleLost();

    void Extend(); // Grow the snake.
    void Reset(); // Reset to starting position.

    void Move(); // Movement method.
    void Tick(); // Update method.
    void Cut(int l_segments); // Method for cutting snake.
    void Render(sf::RenderWindow&amp; l_window);
private:
    void CheckCollision(); // Checking for collisions.

    SnakeContainer m_snakeBody; // Segment vector.
    int m_size; // Size of the graphics.
    Direction m_dir; // Current direction.
    int m_speed; // Speed of the snake.
    int m_lives; // Lives.
    int m_score; // Score.
    bool m_lost; // Losing state.
    sf::RectangleShape m_bodyRect; // Shape used in rendering.
};</pre></div><p>Note that we're using our new type alias for the snake segment vector. This doesn't look that helpful just yet, but it's about to be, really soon.</p><p>As you can see, our class has a few methods defined that are designed to split up the functionality, such as <code class="literal">Lose()</code>, <code class="literal">Extend()</code>, <code class="literal">Reset()</code>, and <code class="literal">CheckCollision()</code>. This will increase code re-usability as well as readability. Let's begin actually implementing these methods:</p><div class="informalexample"><pre class="programlisting">Snake::Snake(int l_blockSize){
    m_size = l_blockSize;
    m_bodyRect.setSize(sf::Vector2f(m_size - 1, m_size - 1));
    Reset();
}
Snake::~Snake(){}</pre></div><p>The<a id="id64" class="indexterm"/> constructor is pretty straightforward. It takes one argument, which is the size of our graphics. This value gets stored for later use and the member of type <code class="literal">sf::RectangleShape</code> gets its size adjusted based on it. The subtraction of one pixel from the size is a very simple way of maintaining that the snake segments appear visually slightly separated, as illustrated here:</p><div class="mediaobject"><img src="graphics/4284_03_03.jpg" alt="The snake class"/></div><p>The constructor also calls the <code class="literal">Reset()</code> method on the last line. A comment in the header file states that this method is responsible for moving the snake into its starting position. Let's make that happen:</p><div class="informalexample"><pre class="programlisting">void Snake::Reset(){
    m_snakeBody.clear();

    m_snakeBody.push_back(SnakeSegment(5,7));
    m_snakeBody.push_back(SnakeSegment(5,6));
    m_snakeBody.push_back(SnakeSegment(5,5));

    SetDirection(Direction::None); // Start off still.
    m_speed = 15;
    m_lives = 3;
    m_score = 0;
    m_lost = false;
}</pre></div><p>This chunk of code will be called every time a new game begins. First, it will clear the snake segment vector from the previous game. After that, some snake segments will get added. Because of our implementation, the first element in the vector is always going to be the head. The coordinates for the snake pieces are hardcoded for now, just to keep it simple.</p><p>Now we<a id="id65" class="indexterm"/> have a three-piece snake. The first thing we do now is set its direction to <code class="literal">None</code>. We want no movement to happen until a player presses a key to move the snake. Next, we set up some arbitrary values for the speed, the lives, and the starting score. These can be adjusted to your liking later. We also set the <code class="literal">m_lost</code> flag to <code class="literal">false</code> in order to signify a new round taking place.</p><p>Before moving on to more difficult to implement methods, let's quickly cover all the helper ones:</p><div class="informalexample"><pre class="programlisting">void Snake::SetDirection(Direction l_dir){ m_dir = l_dir; }
Direction Snake::GetDirection(){ return m_dir; }
int Snake::GetSpeed(){ return m_speed; }

sf::Vector2i Snake::GetPosition(){
   return (!m_snakeBody.empty() ?
      m_snakeBody.front().position : sf::Vector2i(1,1));
}

int Snake::GetLives(){ return m_lives; }
int Snake::GetScore(){ return m_score; }

void Snake::IncreaseScore(){ m_score += 10; }
bool Snake::HasLost(){ return m_lost; }
void Snake::Lose(){ m_lost = true; }
void Snake::ToggleLost(){ m_lost = !m_lost; }</pre></div><p>These methods are fairly simple. Having descriptive names helps a lot. Let's take a look at the <code class="literal">Extend</code> method now:</p><div class="informalexample"><pre class="programlisting">void Snake::Extend(){
  if (m_snakeBody.empty()){ return; }
  SnakeSegment&amp; tail_head = 
    m_snakeBody[m_snakeBody.size() - 1];

  if(m_snakeBody.size() &gt; 1){
    SnakeSegment&amp; tail_bone = 
      m_snakeBody[m_snakeBody.size() - 2];

    if(tail_head.position.x == tail_bone.position.x){
      if(tail_head.position.y &gt; tail_bone.position.y){
        m_snakeBody.push_back(SnakeSegment(
          tail_head.position.x, tail_head.position.y + 1));
      } else {
        m_snakeBody.push_back(SnakeSegment(
          tail_head.position.x, tail_head.position.y - 1));
      }
    } else if(tail_head.position.y == tail_bone.position.y){
      if(tail_head.position.x &gt; tail_bone.position.x){
        m_snakeBody.push_back(SnakeSegment(
          tail_head.position.x + 1, tail_head.position.y));
      } else {
        m_snakeBody.push_back(SnakeSegment(
          tail_head.position.x - 1, tail_head.position.y));
      }
    }
  } else {
    if(m_dir == Direction::Up){
      m_snakeBody.push_back(SnakeSegment(
        tail_head.position.x, tail_head.position.y + 1));
    } else if (m_dir == Direction::Down){
      m_snakeBody.push_back(SnakeSegment(
        tail_head.position.x, tail_head.position.y - 1));
    } else if (m_dir == Direction::Left){
      m_snakeBody.push_back(SnakeSegment(
        tail_head.position.x + 1, tail_head.position.y));
    } else if (m_dir == Direction::Right){
      m_snakeBody.push_back(SnakeSegment(
        tail_head.position.x - 1, tail_head.position.y));
    }
  }
}</pre></div><p>This<a id="id66" class="indexterm"/> preceding method is the one responsible for actually growing out our snake when it touches an apple. The first thing we did was create a reference to the <span class="emphasis"><em>last</em></span> element in the segment vector, called <code class="literal">tail_head</code>. We have a fairly large <span class="emphasis"><em>if-else statement</em></span> chunk of code next, and both cases of it require access to the last element, so it's a good idea to create the reference now in order to prevent duplicated code.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>The <code class="literal">std::vector</code> container overloads the <span class="strong"><strong>bracket operator</strong></span> in order to support<a id="id67" class="indexterm"/> random access via a numeric index. It being similar to an array enables us to reference the last element by simply using an index of <code class="literal">size() - 1</code>. The random access speed is also constant, regardless of the number of elements in this container, which is what makes the <code class="literal">std::vector</code> a good choice for this project.</p></div></div><p>Essentially, it comes down to two cases: either the snake is longer than one segment or it's not. If it does have more than one piece, we create another reference, called <code class="literal">tail_bone</code>, which <a id="id68" class="indexterm"/>points to the <span class="emphasis"><em>next to last</em></span> element. This is needed in order to determine where a new piece of the snake should be placed upon extending it, and the way we check for that is by comparing the <code class="literal">position.x</code> and <code class="literal">position.y</code> values of the <code class="literal">tail_head</code> and <code class="literal">tail_bone</code> segments. If the x values are the same, it's safe to say that the difference between the two pieces is on the y axis and vice versa. Consider the following illustration, where the orange rectangle is <code class="literal">tail_bone</code> and the red rectangle is <code class="literal">tail_head</code>:</p><div class="mediaobject"><img src="graphics/4284_03_04.jpg" alt="The snake class"/></div><p>Let's take the example that's facing left and analyze it: <code class="literal">tail_bone</code> and <code class="literal">tail_head</code> have the same <span class="emphasis"><em>y</em></span> coordinate, and the <span class="emphasis"><em>x</em></span> coordinate of <code class="literal">tail_head</code> is greater than that of <code class="literal">tail_bone</code>, so the next segment will be added at the same coordinates as <code class="literal">tail_head</code>, except the x value will be increased by one. Because the <code class="literal">SnakeSegment</code> constructor is conveniently overloaded to accept coordinates, it's easy to perform this simple math at the same time as pushing the segment onto the back of our vector.</p><p>In the case of there only being one segment in the vector, we simply check the direction of our snake and perform the same math as we did before, except that this time it's based on which way the head is facing. The preceding illustration applies to this as well, where the orange rectangle is the head and the red rectangle is the piece that's about to be added. If it's facing left, we increase the <span class="emphasis"><em>x</em></span> coordinate by one while leaving <span class="emphasis"><em>y</em></span> the same. Subtracting from x happens if it's facing right, and so on. Take your time to analyze this picture and associate it with the previous code.</p><p>Of course, none<a id="id69" class="indexterm"/> of this would matter if our snake didn't move. That's exactly what is being handled in the update method, which in our case of a <span class="emphasis"><em>fixed time-step</em></span> is referred to as a "tick":</p><div class="informalexample"><pre class="programlisting">void Snake::Tick(){
    if (m_snakeBody.empty()){ return; }
    if (m_dir == Direction::None){ return; }
    Move();
    CheckCollision();
}</pre></div><p>The first two lines in the method are used to check if the snake should be moved or not, based on its size and direction. As mentioned earlier, the <code class="literal">Direction::None</code> value is used specifically for the purpose of keeping it still. The snake movement is contained entirely within the <code class="literal">Move</code> method:</p><div class="informalexample"><pre class="programlisting">void Snake::Move(){
   for (int i = m_snakeBody.size() - 1; i &gt; 0; --i){
      m_snakeBody[i].position = m_snakeBody[i - 1].position;
   }
   if (m_dir == Direction::Left){
      --m_snakeBody[0].position.x;
   } else if (m_dir == Direction::Right){
      ++m_snakeBody[0].position.x;
   } else if (m_dir == Direction::Up){
      --m_snakeBody[0].position.y;
   } else if (m_dir == Direction::Down){
      ++m_snakeBody[0].position.y;
   }
}</pre></div><p>We start by iterating over the vector <span class="emphasis"><em>backwards</em></span>. This is done in order to achieve an <span class="emphasis"><em>inchworm</em></span> effect of sorts. It is possible to do it without iterating over the vector in reverse as well, however, this serves the purpose of simplicity and makes it easier to understand how the game works. We're also utilizing the <span class="emphasis"><em>random access operator</em></span> again to use numeric indices instead of the vector <span class="emphasis"><em>iterators</em></span> for the same reasons. Consider the following illustration:</p><div class="mediaobject"><img src="graphics/4284_03_05.jpg" alt="The snake class"/></div><p>We have<a id="id70" class="indexterm"/> a set of segments in their positions before we call the <code class="literal">tick</code> method, which can be referred to as the "beginning state". As we begin iterating over our vector backwards, we start with the segment #3. In our <code class="literal">for</code> loop, we check if the index is equal to <code class="literal">0</code> or not in order to determine if the current segment is the front of the snake. In this case, it's not, so we set the position of segment #3 to be the <span class="emphasis"><em>same</em></span> as the segment #2. The preceding illustration shows the piece to be, sort of, in between the two positions, which is only done for the purpose of being able to see both of them. In reality, segment #3 is sitting right on top of segment #2.</p><p>After the same process is applied again to the second part of the snake, we move on to its head. At this point, we simply move it across one space in the axis that corresponds to its facing direction. The same idea applies here as it did in the illustration before this one, but the sign is reversed. Since in our example, the snake is facing right, it gets moved to the coordinates <span class="emphasis"><em>(x+1;y)</em></span>. Once that is done, we have successfully moved our snake by one space.</p><p>One last thing our tick does is call the <code class="literal">CheckCollision()</code> method. Let's take a look at its implementation:</p><div class="informalexample"><pre class="programlisting">void Snake::CheckCollision(){
   if (m_snakeBody.size() &lt; 5){ return; }
   SnakeSegment&amp; head = m_snakeBody.front();
   for(auto itr = m_snakeBody.begin() + 1; 
      itr != m_snakeBody.end(); ++itr)
   {
      if(itr-&gt;position == head.position){
         int segments = m_snakeBody.end() - itr;
         Cut(segments);
         break;
      }
   }
}</pre></div><p>First, there's no need to check for a collision unless we have over four segments. Understanding certain scenarios of your game and putting in checks to not waste resources is an important part of game development. If we have over four segments of our snake, we<a id="id71" class="indexterm"/> create a reference to the head again, because in any case of collision, that's the first part that would hit another segment. There is no need to check for a collision between all of its parts twice. We also skip an iteration for the head of the snake, since there's obviously no need to check if it's colliding with itself.</p><p>The basic way we check for a collision in this grid-based game is essentially by comparing the position of the head to the position of the current segment represented by our iterator. If both positions are the same, the head is intersecting with the body. The way we resolve this was briefly covered in the <span class="emphasis"><em>Game design decisions</em></span> section of this chapter. The snake has to be cut at the point of collision until the player runs out of lives. We do this by first obtaining an integer value of the segment count between the end and the segment being hit. STL is fairly flexible with its iterators, and since the memory in the case of using a vector is all laid out contiguously, we can simply subtract our current iterator from the last element in the vector to obtain this value. This is done in order to know how many elements to remove from the back of the snake up until the point of intersection. We then invoke the method that is responsible for cutting the snake. Also, since there can only be one collision at a time, we break out of the <code class="literal">for</code> loop to not waste any more clock cycles.</p><p>Let's take a look at the <code class="literal">Cut</code> method:</p><div class="informalexample"><pre class="programlisting">void Snake::Cut(int l_segments){
   for (int i = 0; i &lt; l_segments; ++i){
      m_snakeBody.pop_back();
   }
   --m_lives;
   if (!m_lives){ Lose(); return; }
}</pre></div><p>At this point, it's as simple as looping a certain amount of times based on the <code class="literal">l_segments</code> value and popping the elements from the back of the vector. This effectively slices through the snake.</p><p>The rest of the code simply decreases the amount of lives left, checks if it's at zero, and calls the <code class="literal">Lose()</code> method if there are no more lives.</p><p>Phew! That's quite a bit of code. One thing still remains, however, and that is rendering our square serpent to the screen:</p><div class="informalexample"><pre class="programlisting">void Snake::Render(sf::RenderWindow&amp; l_window){
   if (m_snakeBody.empty()){ return; }

   auto head = m_snakeBody.begin();
   m_bodyRect.setFillColor(sf::Color::Yellow);
   m_bodyRect.setPosition(head-&gt;position.x * m_size,
      head-&gt;position.y * m_size);
   l_window.draw(m_bodyRect);

   m_bodyRect.setFillColor(sf::Color::Green);
   for(auto itr = m_snakeBody.begin() + 1;
      itr != m_snakeBody.end(); ++itr)
   {
      m_bodyRect.setPosition(itr-&gt;position.x * m_size, 
         itr-&gt;position.y * m_size);
      l_window.draw(m_bodyRect);
   }
}</pre></div><p>Quite<a id="id72" class="indexterm"/> similarly to a lot of the methods we've implemented here, there's a need to iterate over each segment. The head itself is drawn outside of the loop in order to avoid unnecessary checks. We set the position of our <code class="literal">sf::RectangleShape</code> that graphically represents a snake segment to its grid position multiplied by the <code class="literal">m_size</code> value in order to obtain the pixel coordinates on the screen. Drawing the rectangle is the last step of implementing the snake class in its entirety!</p></div>
<div class="section" title="The World class"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>The World class</h1></div></div></div><p>Our<a id="id73" class="indexterm"/> snake can now move and collide with itself. While functional, this doesn't make a really exciting game. Let's give it some boundaries and something to munch on to increase the score by introducing the <code class="literal">World</code> class.</p><p>While it's possible to just make separate objects for everything we talk about in here, this project is simple enough to allow certain aspects of itself to be nicely contained within a single class that can manage them without too much trouble. This class takes care of everything to do with keeping the game boundaries, as well as maintaining the apple the player will be trying to grab. </p><p>Let's take a look at the class header:</p><div class="informalexample"><pre class="programlisting">class World{
public:
    World(sf::Vector2u l_windSize);
    ~World();

    int GetBlockSize();

    void RespawnApple();

    void Update(Snake&amp; l_player);
    void Render(sf::RenderWindow&amp; l_window);
private:
    sf::Vector2u m_windowSize;
    sf::Vector2i m_item;
    int m_blockSize;

    sf::CircleShape m_appleShape;
    sf::RectangleShape m_bounds[4];
};</pre></div><p>As you<a id="id74" class="indexterm"/> can see from the preceding code, this class also keeps track of how big the objects in the game are. Aside from that, it simply retains four rectangles for the boundary graphics, a circle for drawing the apple, and an integer vector to keep track of the apple's coordinates, which is named <code class="literal">m_item</code>. Let's start implementing the constructor:</p><div class="informalexample"><pre class="programlisting">World::World(sf::Vector2u l_windSize){
  m_blockSize = 16;

  m_windowSize = l_windSize;
  RespawnApple();
  m_appleShape.setFillColor(sf::Color::Red);
  m_appleShape.setRadius(m_blockSize / 2);

  for(int i = 0; i &lt; 4; ++i){
    m_bounds[i].setFillColor(sf::Color(150,0,0));
    if(!((i + 1) % 2)){
      m_bounds[i].setSize(sf::Vector2f(m_windowSize.x,
        m_blockSize));
    } else {
      m_bounds[i].setSize(sf::Vector2f(m_blockSize,
        m_windowSize.y));
    }
    if(i &lt; 2){
      m_bounds[i].setPosition(0,0);
    } else {
      m_bounds[i].setOrigin(m_bounds[i].getSize());
      m_bounds[i].setPosition(sf::Vector2f(m_windowSize));
    }
  }
}

World::~World(){}</pre></div><p>Up until the complex looking <code class="literal">for</code> loops, we simply initialize some member values from the local constructor variables, set the color and radius of the apple circle, and call the <code class="literal">RespawnApple()</code> method in order to place it somewhere on the grid.</p><p>The<a id="id75" class="indexterm"/> first <code class="literal">for</code> loop just iterates four times for each of the four sides of the game screen in order to set up a red rectangle wall on each side. It sets a dark red color for the rectangle fill and proceeds with checking the index value. First, we determine if the index is an even or an odd value by checking it with the following expression: <code class="literal">if(!((i + 1) % 2)){...</code>. This is done in order to know how big each wall has to be on a specific axis. Because it has to be as large as one of the screen dimensions, we simply make the other one as large as all the other graphics on the screen, which is represented by the <code class="literal">m_blockSize</code> value.</p><p>The last <code class="literal">if</code> statement checks if the index is below two. If it is, we're working with the top-left corner, so we simply set the position of the rectangle to (0,0). Since the origin of all the rectangle-based drawables in SFML is always the top-left corner, we don't need to worry about that in this case. However, if the index is 2 or higher, we set the origin to the size of the rectangle, which effectively makes it the bottom right corner. Afterwards, we set the position of the rectangle to be the same as the size of the screen, which puts the shape all the way down to the bottom right corner. You can simply set all the coordinates and origins by hand, but this approach makes the initialization of the basic features more automated. It may be hard to see the use for it now, but in more complicated projects this kind of thinking will come in handy, so why not start now?</p><p>Since we have our walls, let's take a look at how one might go about re-spawning the apple:</p><div class="informalexample"><pre class="programlisting">void World::RespawnApple(){
    int maxX = (m_windowSize.x / m_blockSize) - 2;
    int maxY = (m_windowSize.y / m_blockSize) - 2;
    m_item = sf::Vector2i(
        rand() % maxX + 1, rand() % maxY + 1);
    m_appleShape.setPosition(
        m_item.x * m_blockSize,
        m_item.y * m_blockSize);
}</pre></div><p>The first thing we must do is determine the boundaries within which the apple can be spawned. We do so by defining two values: <code class="literal">maxX</code> and <code class="literal">maxY</code>. These are set to the window size divided by the block size, which gives us the number of spaces in the grid, from which we must then subtract 2. This is due to the fact that the grid indices begin with 0, not 1, and because we don't want to spawn the apple within the right or bottom walls.</p><p>The next step is to actually generate the random values for the apple coordinates. We use our pre-calculated values here and set the <span class="emphasis"><em>lowest</em></span> possible random value to <code class="literal">1</code>, because we don't want anything spawning in the top wall or the left wall. Since the coordinates of the apple are now available, we can set the <code class="literal">m_appleShape</code> graphic's position in pixel coordinates by multiplying the grid coordinates by the size of all our graphics.</p><p>Let's <a id="id76" class="indexterm"/>actually make all these features come to life by implementing the update method:</p><div class="informalexample"><pre class="programlisting">void World::Update(Snake&amp; l_player){
    if(l_player.GetPosition() == m_item){
        l_player.Extend();
        l_player.IncreaseScore();
        RespawnApple();
    }

    int gridSize_x = m_windowSize.x / m_blockSize;
    int gridSize_y = m_windowSize.y / m_blockSize;

    if(l_player.GetPosition().x &lt;= 0 ||
        l_player.GetPosition().y &lt;= 0 ||
        l_player.GetPosition().x &gt;= gridSize_x – 1 ||
        l_player.GetPosition().y &gt;= gridSize_y - 1)
    {
            l_player.Lose();
    }
}</pre></div><p>First, we check if the player's position is the same as that of the apple. If it is, we have a collision and the snake gets extended, the score increases, and the apple gets re-spawned. Next, we determine our grid size and check if the player coordinates are anywhere outside of the designated boundaries. If that's the case, we call the <code class="literal">Lose()</code> method to illustrate the collision with the wall and give the player a "game over". </p><p>In order to not keep the player blind, we must display the boundaries of the game, as well as the main point of interest - the apple. Let's draw everything on screen:</p><div class="informalexample"><pre class="programlisting">void World::Render(sf::RenderWindow&amp; l_window){
    for(int i = 0; i &lt; 4; ++i){
        l_window.draw(m_bounds[i]);
    }
    l_window.draw(m_appleShape);
}</pre></div><p>All we have to do is iterate four times and draw each of the four respective boundaries. Then we draw the apple, which concludes our interest in this method.</p><p>One more thing to point out is that the other classes might need to know how big the graphics need to be, and for this reason, let's implement a simple method for obtaining that value:</p><div class="informalexample"><pre class="programlisting">int World::GetBlockSize(){ return m_blockSize; }</pre></div><p>This<a id="id77" class="indexterm"/> concludes the <code class="literal">World</code> class.</p></div>
<div class="section" title="Time to integrate"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Time to integrate</h1></div></div></div><p>Much like <a id="id78" class="indexterm"/>how a hammer is useless without someone using it, so are our two classes without being properly adopted by the <code class="literal">Game</code> class. Since we didn't write all that code just to practise typing, let's work on putting all the pieces together. First, we need to actually add two new members to the <code class="literal">Game</code> class, and you might already have guessed what they are:</p><div class="informalexample"><pre class="programlisting">class Game{
...
private:
...
    World m_world;
    Snake m_snake;
};</pre></div><p>Next, let's initialize these members. Since both of them have constructors that take arguments, it's the time for <span class="emphasis"><em>initializer list</em></span>:</p><div class="informalexample"><pre class="programlisting">Game::Game(): m_window("Snake", sf::Vector2u(800, 600)),m_snake(m_world.GetBlockSize()),m_world(sf::Vector2u(800,600))
{
    ...
}</pre></div><p>Next, we need to process some input. As you may recall from the previous chapters, utilizing events for live input is really delayed and should never be used for anything else but checking for key presses that aren't time sensitive. Luckily, SFML provides means of obtaining the real-time state of the keyboard through the <code class="literal">sf::Keyboard</code> class. It only contains the static functions and is never meant to be initialized. One of those functions is exactly what we need here: <code class="literal">isKeyPressed(sf::Keyboard::Key)</code>. The sole argument that it takes is the actual key you want to check the state of, which can be obtained through the use of the <code class="literal">sf::Keyboard::Key</code> enumeration, as follows:</p><div class="informalexample"><pre class="programlisting">if(sf::Keyboard::isKeyPressed(sf::Keyboard::Up) 
   &amp;&amp; m_snake.GetDirection() != Direction::Down)
{
   m_snake.SetDirection(Direction::Up);
} else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Down) 
   &amp;&amp; m_snake.GetDirection() != Direction::Up)
{
   m_snake.SetDirection(Direction::Down);
} else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Left) 
   &amp;&amp; m_snake.GetDirection() != Direction::Right)
{
   m_snake.SetDirection(Direction::Left);
} else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Right) 
   &amp;&amp; m_snake.GetDirection() != Direction::Left)
{
   m_snake.SetDirection(Direction::Right);
}</pre></div><p>Something <a id="id79" class="indexterm"/>we don't want the snake to do is to go in the direction that is opposite to its current one. At any given time, there should only be three directions it can go in, and the use of the <code class="literal">GetDirection()</code> method ensures that we don't send the snake in reverse, essentially eating itself. If we have the proper combination of input and its current direction, it's safe to adjust its direction through the use of the <code class="literal">SetDirection()</code> method.</p><p>Let's get things moving by updating both our classes:</p><div class="informalexample"><pre class="programlisting">void Game::Update(){
...
    float timestep = 1.0f / m_snake.GetSpeed();

    if(m_elapsed &gt;= timestep){
        m_snake.Tick();
        m_world.Update(m_snake);
        m_elapsed -= timestep;
        if(m_snake.HasLost()){
            m_snake.Reset();
        }
    }
...
}</pre></div><p>As mentioned previously, we're using <span class="emphasis"><em>fixed time-step</em></span> here, which incorporates the snake speed in order to update the appropriate amount of times per second. This is also where we check if the player has lost the game and reset the snake if he has.</p><p>We're really close now. Time to draw everything on screen:</p><div class="informalexample"><pre class="programlisting">void Game::Render(){
    m_window.BeginDraw();
    // Render here.
    m_world.Render(*m_window.GetRenderWindow());
    m_snake.Render(*m_window.GetRenderWindow());

    m_window.EndDraw();
}</pre></div><p>Much like before, we simply invoke the <code class="literal">Render</code> methods of both our classes and pass in a reference to <code class="literal">sf::RenderWindow</code>. With that, our game is actually playable! Upon successful<a id="id80" class="indexterm"/> compilation and execution of our project, we should end up with something looking like this following image:</p><div class="mediaobject"><img src="graphics/4284_03_06.jpg" alt="Time to integrate"/></div><p>The snake will be still at first, until one of the four arrow keys is pressed. Once it does start moving, it will be able to eat the apple and grow by one segment, collide with its own tail and lose it twice before it dies, and end the game if the player crashes into a wall. The core version of our game is complete! Pat yourself on the back, as you just created your first game.</p></div>
<div class="section" title="Hunting bugs"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Hunting bugs</h1></div></div></div><p>As proud<a id="id81" class="indexterm"/> and satisfied as you may be with your first project, nothing is ever perfect. If you've spent some time actually playing the game, you may have noticed an odd event when quickly mashing the buttons, looking something like this:</p><div class="mediaobject"><img src="graphics/4284_03_07.jpg" alt="Hunting bugs"/></div><p>The image represents the difference between two sequential updates. It seems that earlier it was facing the right direction and then it's facing left and missing its tail. What happened? Try to figure it out on your own before continuing, as it perfectly illustrates the experience of fixing game flaws.</p><p>Playing <a id="id82" class="indexterm"/>around with it some more reveals certain details that narrow down our problem. Let's break down what happens when a player starts mashing keys quickly:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The snake is facing right.</li><li class="listitem" style="list-style-type: disc">Any arrow key other than the left or right is pressed.</li><li class="listitem" style="list-style-type: disc">The direction of the snake gets set to something else, let's say up.</li><li class="listitem" style="list-style-type: disc">The right key is pressed before the game has a chance to update.</li><li class="listitem" style="list-style-type: disc">Since the snake's direction is no longer set to right or left, <code class="literal">if</code> statement in the input handler is satisfied and sets the direction to left. </li><li class="listitem" style="list-style-type: disc">The game updates the snake and moves it left by one space. The head collides with its tail and it gets cut off.</li></ul></div><p>Yes, it seems that our direction checking is flawed and causes this bug. Once again, spend some time trying to think of a way to fix this before moving on.</p></div>
<div class="section" title="Fixing bugs"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Fixing bugs</h1></div></div></div><p>Let's discuss <a id="id83" class="indexterm"/>the several approaches that might be used in a situation like this. First, the programmer might think about putting a flag somewhere that remembers if the direction has already been set for the current iteration and gets reset afterwards. This would prevent the bug we're experiencing, but would also lock down the number of times a player can interact with the snake. Let's say it moves once a second. That would mean that if you press a key at the beginning of that second, you wouldn't be able to change your mind and hit another key quickly to rectify your wrong decision before the snake moves. That's no good. Let's move on to a new idea.</p><p>Another approach may be to keep track of the original direction before any changes were made to that <span class="emphasis"><em>iteration</em></span>. Then, once the update method gets called, we could check if the original direction, before any changes were made, is the opposite of the newest direction that we've received. If it is, we could simply ignore it and move the snake in the direction before any changes were made. This would fix the bug and not present us with a new one, but it comes with keeping track of one more variable and might get confusing. Imagine that in the future you're presented with a similar bug or a request for a feature that needs you to keep track of another variable on top of this one. Imagine that happens one more time, then another. Very soon, your checking statement might look a little something like this:</p><div class="informalexample"><pre class="programlisting">if(var1 != something &amp;&amp; var2 == something &amp;&amp; var3 == true &amp;&amp; var4 == !var3 ...)</pre></div><p>Now that is what we call a mess. On top of that, imagine you have to check the same variables<a id="id84" class="indexterm"/> four times for four different conditions. It quickly becomes apparent that this is a bad design and it shouldn't be used by anyone with intentions of ever showing their code to another person.</p><p>You may ask how we can rectify our problem then. Well, we could simply not rely on the use of a variable in the snake class to determine its direction, and instead implement a method that looks at its structure and spits out the direction it's facing, as shown next:</p><div class="informalexample"><pre class="programlisting">Direction Snake::GetPhysicalDirection(){
    if(m_snakeBody.size() &lt;= 1){
        return Direction::None;
    }

    SnakeSegment&amp; head = m_snakeBody[0];
    SnakeSegment&amp; neck = m_snakeBody[1];

    if(head.position.x == neck.position.x){
        return (head.position.y &gt; neck.position.y ? Direction::Down : Direction::Up);
    } else if(head.position.y == neck.position.y){
        return (head.position.x &gt; neck.position.x ? Direction::Right : Direction::Left);
    }

    return Direction::None;
}</pre></div><p>First, we check if the snake is <span class="emphasis"><em>1</em></span> segment long or less; in this case, it doesn't matter which direction it's facing as it wouldn't eat itself if it only had a head, and it wouldn't even have a direction if there are no segments in the vector at all. Assuming it's longer than one segment, we obtain two references: the head and the neck, which is the second piece of the snake right after the head. Then, we simply check the positions of both of them and determine the direction the snake is facing using the same logic as before, while implementing the snake class, as illustrated in the following image:</p><div class="mediaobject"><img src="graphics/4284_03_08.jpg" alt="Fixing bugs"/></div><p>This <a id="id85" class="indexterm"/>will return a proper direction that won't be altered unless the snake moves, so let's adjust our input handling code to cater to these changes:</p><div class="informalexample"><pre class="programlisting">if(sf::Keyboard::isKeyPressed(sf::Keyboard::Up) &amp;&amp; m_snake.GetPhysicalDirection() != Direction::Down)
{
    m_snake.SetDirection(Direction::Up);
} else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Down) &amp;&amp; m_snake.GetPhysicalDirection() != Direction::Up)
{
    m_snake.SetDirection(Direction::Down);
} else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Left) &amp;&amp; m_snake.GetPhysicalDirection() != Direction::Right)
{
    m_snake.SetDirection(Direction::Left);
} else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Right) &amp;&amp; m_snake.GetPhysicalDirection() != Direction::Left)
{
    m_snake.SetDirection(Direction::Right);
}</pre></div><p>Voila! No more of our snake turning inside out.</p><p>There's one more fault with the game that didn't get addressed here on purpose. Try to find it and fix it in order to practise resolving problems like this in the future. </p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>Hint: It has to do with how many segments the snake has when the game starts. </p></div></div><p>If you want to do this one fairly, do your best not to reference the code of the finished project that came with this book, as that has it fixed already.</p></div>
<div class="section" title="Going the extra mile"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Going the extra mile</h1></div></div></div><p>A functional game is far from a fully finished product. Sure, we have everything we wanted in<a id="id86" class="indexterm"/> the beginning, but it still leaves things to be desired, such as keeping track of the score and showing how many lives we have. At first, your main instinct might be to just add a bit of text somewhere on the screen that simply prints the number of lives you have left. You may even be tempted to do as little as simply printing it out in the console window. If that's the case, the purpose of this part is to change your way of thinking by introducing something that we will be using and improving over the course of this book: the textbox.</p><p>If that name doesn't really mean anything to you, simply imagine a chat window on any given communication application, such as <span class="emphasis"><em>MSN Messenger</em></span> or <span class="emphasis"><em>Skype</em></span>. Whenever a new message is added, it's added to the bottom as the older messages are moved up. The window holds a certain number of messages that are visible at one time. That's not only useful for the purpose of the game printing a casual message, but can also be used for debugging. Let's start by writing our header, as usual:</p><div class="informalexample"><pre class="programlisting">using MessageContainer = std::vector&lt;std::string&gt;;

class Textbox{
public:
    Textbox();
    Textbox(int l_visible, int l_charSize, int l_width, sf::Vector2f l_screenPos);
    ~Textbox();

    void Setup(int l_visible, int l_charSize, int l_width, sf::Vector2f l_screenPos);
    void Add(std::string l_message);
    void Clear();

    void Render(sf::RenderWindow&amp; l_wind);
private:
    MessageContainer m_messages;
    int m_numVisible;

    sf::RectangleShape m_backdrop;
    sf::Font m_font;
    sf::Text m_content;
};</pre></div><p>We begin by defining the data type for the container of all the messages. In this case, we went with <code class="literal">std::vector</code> again, simply because that's the more familiar choice at this point. Just to make it look better and more readable, we've added a rectangle shape as one of the members of the class that will be used as a backdrop. On top of that, we have introduced a new data type: <code class="literal">sf::Text</code>. This is a drawable type that represents any typed characters or strings of characters, and can be adjusted in size, font, and color, as well as transformed, much like any other drawable in SFML.</p><p>Let's<a id="id87" class="indexterm"/> start implementing our fancy new feature:</p><div class="informalexample"><pre class="programlisting">Textbox::Textbox(){
    Setup(5,9,200,sf::Vector2f(0,0));
}

Textbox::Textbox(int l_visible, int l_charSize, 
int l_width, sf::Vector2f l_screenPos){
    Setup(l_visible, l_charSize, l_width, l_screenPos);
}

Textbox::~Textbox(){ Clear(); }</pre></div><p>As you can see, it has two constructors, one of which can be used to initialize some default values and the other that allows customization by passing in some values as arguments. The first argument is the number of lines that are visible in the textbox. It is followed by the character size in pixels, the width of the entire textbox in pixels, and float vector that represents the position on the screen where it should be drawn at. All that these constructors do is invoke the <code class="literal">Setup</code> method and pass all these arguments to it, so let's take a look at it:</p><div class="informalexample"><pre class="programlisting">void Textbox::Setup(int l_visible, int l_charSize, int l_width, sf::Vector2f l_screenPos)
{
    m_numVisible = l_visible;

    sf::Vector2f l_offset(2.0f, 2.0f);

    m_font.loadFromFile("arial.ttf");
    m_content.setFont(m_font);
    m_content.setString("");
    m_content.setCharacterSize(l_charSize);
    m_content.setColor(sf::Color::White);
    m_content.setPosition(l_screenPos + l_offset);

    m_backdrop.setSize(sf::Vector2f(
        l_width, (l_visible * (l_charSize * 1.2f))));
    m_backdrop.setFillColor(sf::Color(90,90,90,90));
    m_backdrop.setPosition(l_screenPos);
}</pre></div><p>Aside from initializing its member values, this method defines an offset float vector that will be used to space the text appropriately and provide some padding from the top-left corner. It also sets up our <code class="literal">sf::Text </code>member by first creating a font to which it's bound, setting the initial string to nothing, setting up the character size and color, and setting its position on the screen to the provided position argument with the proper offset factored in. Additionally, it sets up the size of the backdrop by using the width that was provided and multiplying <a id="id88" class="indexterm"/>the number of visible lines by the result of the multiplication of the character size and a constant floating point value of 1.2, in order to account for spacing between the lines.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>From time to time, it does simply come down to playing with code to seeing what really works. Finding certain numeric constants that work in all cases is one of the situations where it's just a matter of testing in order to determine the correct value. Don't be afraid to try out new things and see what works.</p></div></div><p>Since we're utilizing a vector to store our messages, adding a new one or removing them all is as simple as using the <code class="literal">push_back </code>and <code class="literal">clear </code>methods:</p><div class="informalexample"><pre class="programlisting">void Textbox::Add(std::string l_message){
    m_messages.push_back(l_message);
    if(m_messages.size() &lt; 6){ return; }
    m_messages.erase(m_messages.begin());
}

void Textbox::Clear(){ m_messages.clear(); }</pre></div><p>In the case of adding a new message, checking whether we have more of them than we can see would be a good idea. Having something around that we're not going to see or need ever again is wasteful, so the very first message that is definitely out of sight at that time is removed from the message container.</p><p>We're very close to actually finishing this neat feature. The only thing left now is drawing it, which, as always, is taken care of by the <code class="literal">Render</code> method:</p><div class="informalexample"><pre class="programlisting">void Textbox::Render(sf::RenderWindow&amp; l_wind){
  std::string l_content;

  for(auto &amp;itr : m_messages){
    l_content.append(itr+"\n");
  }

  if(l_content != ""){
    m_content.setString(l_content);
    l_wind.draw(m_backdrop);
    l_wind.draw(m_content);
  }
}</pre></div><p>The code begins with <code class="literal">std::string</code> being set up to hold all the visible messages on the screen. Afterwards, it's as simple as looping over the message vector and appending the text of each message to our local <code class="literal">std::string</code> variable with a new line symbol at the end. Lastly, after<a id="id89" class="indexterm"/> checking the local variable and making sure it isn't empty, we must set our <code class="literal">m_content</code> member of type <code class="literal">sf::Text</code> to hold the string we've been pushing our messages to and draw both the background and the text on the screen. That's all there is to the <code class="literal">Textbox</code> class.</p><p>After adding an instance of <code class="literal">Textbox</code> as a member to our game class, we can start setting it up:</p><div class="informalexample"><pre class="programlisting">Game::Game() ... {
...
    m_textbox.Setup(5,14,350,sf::Vector2f(225,0));
...
    m_textbox.Add("Seeded random number generator with: " + std::to_string(time(NULL)));
}</pre></div><p>After passing some constant values to the <code class="literal">Setup </code>method of our <code class="literal">m_textbox </code>member, we immediately start using it right there in the constructor by actually outputting our first message. Let's finish integrating it fully by making one last adjustment to the <code class="literal">Game::Render()</code> method:</p><div class="informalexample"><pre class="programlisting">void Game::Render(){
    m_window.BeginDraw();
    // Render here.
    m_world.Render(*m_window.GetRenderWindow());
    m_snake.Render(*m_window.GetRenderWindow());
    m_textbox.Render(*m_window.GetRenderWindow());

    m_window.EndDraw();
}</pre></div><p>It's the same as both the classes we've implemented before this, except that the text box is now the last thing we draw, which means it will be displayed over everything else. After adding more messages to the game to be printed and compiling our project, we should end up with something like this:</p><div class="mediaobject"><img src="graphics/4284_03_09.jpg" alt="Going the extra mile"/></div><p>This text box, in its most basic form, is the last addition to our snake game that we will be covering in this book. Feel free to play around with it and see what else you can come up with to<a id="id90" class="indexterm"/> spice up the game!</p></div>
<div class="section" title="Common mistakes"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Common mistakes</h1></div></div></div><p>A <a id="id91" class="indexterm"/>fairly common thing people often forget is the following line:</p><div class="informalexample"><pre class="programlisting">srand(time(nullptr));</pre></div><p>If you notice, the numbers being generated are exactly the same each time you launch the game-chances are that you haven't seeded the random number generator or you haven't provided a proper seed. It's recommended to always use a unix timestamp, as shown.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>The use of this particular random function should be restricted to something that isn't related to security and cryptography. Using it in combination with the modulus operator can produce incredibly non-uniform results due to the introduced bias.</p></div></div><p>Another fairly common problem is the programmers' choice of the data container to hold their structures. Let's take the following for example:</p><div class="informalexample"><pre class="programlisting">using SnakeContainer = std::vector&lt;SnakeSegment&gt;;</pre></div><p>This defines the type of our <code class="literal">SnakeContainer</code>. If you've compiled the code we've written, you will notice that it runs fairly smoothly. Now consider this next line of code:</p><div class="informalexample"><pre class="programlisting">Using SnakeContainer = std::deque&lt;SnakeSegment&gt;;</pre></div><p>Because of the way these two containers are implemented in STL, nothing else changes in our code, so feel free to try to change the data type of your <code class="literal">SnakeContainer</code> from <code class="literal">std::vector</code> to <code class="literal">std::deque</code>. After compiling and running the project, you will definitely pick up on the hit on performance. Why is that happening? Well, even though <code class="literal">std::vector</code> and <code class="literal">std::deque</code> can be used basically in the same way, they're fundamentally different under the hood. The vector offers the certainty of its elements being contiguous in memory, while the double ended queue does not. There are also differences in performances, depending on where the most inserts and removals are done. If you're unsure about which container to use, make sure to either look it up or benchmark it yourself. Never just blindly assume, unless performance isn't the main concern to you.</p><p>Lastly, on a more open-ended note, don't be afraid to play with, modify, change, hack, or otherwise alter any piece of code that you see. The biggest mistake you can make is the mistake of not learning by breaking and fixing things. Consider the code we've written as only a push in the right direction and not a specific recipe. If understanding something better<a id="id92" class="indexterm"/> means you have to break it first, so be it.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Summary</h1></div></div></div><p>Game development is a great journey to embark on. You had taken your first and second steps earlier, but now you have boarded the plane with your first, fully functional game in the bag. You are now officially a game developer! Where will this plane of opportunity take you and how long will it be there for? All of that is entirely up to you. While you're still not in the air, however, we will do our best to inspire you and show you all the different places to go to and the wonderful experiences to be had there. One thing is definitely for sure, however, and that is that this is not the end. If your enthusiasm has led you this far, there's only one direction to head to, and that's forward.</p><p>A lot was covered in this chapter, and now it's impossible to say that you haven't gotten your hands dirty while paying homage to one of the all time arcade classics. In the next chapter, we will take on input handling and event management in order to provide flexibility and fluent means of interaction between you and your application, all while introducing our brand new project for the next few chapters. There's still a lot to learn and many lines of code to write, so don't spend too much time hesitating to proceed onto the next chapter. A brand new adventure is waiting to unfold. See you there!</p></div></body></html>