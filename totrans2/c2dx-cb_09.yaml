- en: Chapter 9. Controlling Physics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 控制物理
- en: 'The following topics will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using the physics engine
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用物理引擎
- en: Detecting collisions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: Using joints
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关节
- en: Changing gravity by using the acceleration sensor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加速度传感器改变重力
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Physics is really important for games. Players need to simulate real-world
    situations. You can add physical realism to your game by using a physics engine.
    As you know, there are two famous physics engines: Box2D and Chipmunk. In Cocos2d-x
    version 2.x, you have to use these physics engines. However, it is pretty difficult
    to use them. Since Cocos2d-x version 3.x, Cocos2d-x has a useful physics engine
    wrapped in Chipmunk. Therefore, the physics engine is no longer a concern for
    us as it is scalable and CPU friendly. In this chapter, you will learn how to
    use the physics engine easily in your game.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 物理对于游戏来说非常重要。玩家需要模拟现实世界的情况。你可以通过使用物理引擎来给你的游戏增加物理真实感。正如你所知，有两个著名的物理引擎：Box2D和Chipmunk。在Cocos2d-x
    2.x版本中，你必须使用这些物理引擎。然而，使用它们相当困难。自从Cocos2d-x 3.x版本以来，Cocos2d-x已经包含了一个封装在Chipmunk中的有用物理引擎。因此，物理引擎不再是我们的担忧，因为它可扩展且CPU友好。在本章中，你将学习如何在游戏中轻松使用物理引擎。
- en: Using the physics engine
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用物理引擎
- en: What should you do when you realize that your game needs to simulate real-world
    situations? You know that the answer is to use a physics engine. When you start
    using a physics engine, you have to use some new classes and methods. In this
    recipe, you will learn how to use the basic physics engine in Cocos2d-x.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你意识到你的游戏需要模拟现实世界的情况时，你应该怎么做？你知道答案是使用物理引擎。当你开始使用物理引擎时，你必须使用一些新的类和方法。在本菜谱中，你将学习如何在Cocos2d-x中使用基本的物理引擎。
- en: How to do it...
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Firstly, you have to create the physics world in your scene. You can create
    it by using the following code:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你必须在场景中创建一个物理世界。你可以通过以下代码来创建它：
- en: '[PRE0]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, you have to add the physics bodies in the physics world. A physics body
    is not visible. It is a physical shape such as a square or a circle or a more
    complex shape. Here, let's create a square shape. You have to create it and set
    it to the sprite to be visible.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你必须向物理世界中添加物理体。物理体是不可见的。它是一个物理形状，如正方形、圆形或更复杂的形状。在这里，让我们创建一个正方形形状。你必须创建它并将其设置为精灵以使其可见。
- en: '[PRE1]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finally, you have to run the preceding code. You can then see the sprite falling
    and bouncing on the ground.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你必须运行前面的代码。然后你可以看到精灵在地面上下落和弹跳。
- en: How it works...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Firstly, you have to create the physics world in the scene by using the `Scene::createWithPhysics`
    method. In this way, you can use the physics engine in your game.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你必须使用`Scene::createWithPhysics`方法在场景中创建物理世界。这样，你就可以在游戏中使用物理引擎。
- en: Next, you have to create the wall upside down and from the left to the right
    on the screen edge. If you remove this wall and run the code, the sprite object
    will be falling forever. You can create an edge box by using the `PhysicsBody::createEdgeBox`
    method with this size and material setting. In this case, the wall will be of
    the same size as the screen. The material setting is specified as `PhysicsMaterial(0.1f,
    1.0f, 0.0f)`. This means that the density is `1.0f`, restitution is `1.0f`, and
    friction is `0.0f`. Let's try to change this parameter and check it in the given
    situation.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你必须创建一个倒置的墙，从屏幕边缘的左侧到右侧。如果你移除这个墙并运行代码，精灵对象将永远下落。你可以通过使用`PhysicsBody::createEdgeBox`方法以及这个大小和材料设置来创建一个边缘框。在这种情况下，墙的大小将与屏幕相同。材料设置指定为`PhysicsMaterial(0.1f,
    1.0f, 0.0f)`。这意味着密度是`1.0f`，恢复系数是`1.0f`，摩擦系数是`0.0f`。让我们尝试改变这个参数，并在给定的情况下检查它。
- en: Finally, you can create the physics body with the sprite. In this case, the
    sprite is circular in shape. So, you need to use the `PhysicsBody::createCircle`
    method to create the circular physics body. Then, add the physics body to the
    sprite by using the `Sprite::setPhysicsBody` method.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以使用精灵创建物理体。在这种情况下，精灵是圆形的。因此，你需要使用`PhysicsBody::createCircle`方法来创建圆形物理体。然后，使用`Sprite::setPhysicsBody`方法将物理体添加到精灵中。
- en: 'Cocos2d-x has a lot of physics body shapes as listed in the following table:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cocos2d-x有很多物理体形状，如下表所示：
- en: '| Shape | Description |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 形状 | 描述 |'
- en: '| --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| PhysicsShapeCircle | Solid circle shape |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| PhysicsShapeCircle | 实心圆形形状 |'
- en: '| PhysicsShapePolygon | Solid polygon shape |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| PhysicsShapePolygon | 实心多边形形状 |'
- en: '| PhysicsShapeBox | Solid box shape |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| PhysicsShapeBox | 实心矩形形状 |'
- en: '| PhysicsShapeEdgeSegment | Segment shape |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| PhysicsShapeEdgeSegment | 段形 |'
- en: '| PhysicsShapeEdgePolygon | Hollow polygon shape |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| PhysicsShapeEdgePolygon | 空心多边形形状 |'
- en: '| PhysicsShapeEdgeBox | Hollow box shape |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| PhysicsShapeEdgeBox | 空心矩形形状 |'
- en: '| PhysicsShapeEdgeChain | To connect many edges |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| PhysicsShapeEdgeChain | 用于连接多个边缘 |'
- en: There's more…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Then, you can get a `PhysicsWorld` instance by using the `Scene::getPhysicsWorld`
    method. In this recipe, we set `PhysicsWorld::DEBUGDRAW_ALL` to the physics world.
    That's why you can see that the edges of all physics objects are red lines. When
    you release your game, you will have to remove this setting.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过使用 `Scene::getPhysicsWorld` 方法来获取一个 `PhysicsWorld` 实例。在这个示例中，我们将 `PhysicsWorld::DEBUGDRAW_ALL`
    设置为物理世界。这就是为什么你可以看到所有物理对象边缘都是红色线条。当你发布你的游戏时，你必须移除这个设置。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![There''s more…](img/B0561_09_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/B0561_09_01.jpg)'
- en: 'Further, you can set the original gravity value to `PhysicsWorld`. For example,
    you can change the gravity when the device was tilted. The following code is how
    to change the gravity:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以将原始重力值设置为 `PhysicsWorld`。例如，你可以在设备倾斜时更改重力。以下是如何更改重力的代码：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The above code is against the force of the earth's gravity. The default gravity
    value is `Vec2(0, -98.0f)`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与地球重力相反。默认重力值是 `Vec2(0, -98.0f)`。
- en: Detecting collisions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: When a collision between physics objects occurs, you want to take action against
    the physics bodies, for example, showing an explosion and showing a particle.
    In this recipe, you learn how to detect a collision in the physics world.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当物理对象之间发生碰撞时，你想要对物理体采取行动，例如显示爆炸和显示粒子。在这个示例中，你将学习如何检测物理世界中的碰撞。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Firstly, you have to create the event listener in the `init` method as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你必须在 `init` 方法中创建事件监听器，如下所示：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, you have to set the contact test bit mask to the physics bodies that
    you want to check the collisions for. In this recipe, you set the wall body and
    the sprite body as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你必须设置你想要检查碰撞的物理体的接触测试位掩码。在这个示例中，你设置了墙壁体和精灵体，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You can detect a collision in the physics world by using the `EventListenerPhysicsContact`
    class. It will receive all the contact callbacks in the physics world. If you
    set the `onContactBegin` method in this listener, you can catch the collision
    of the physics bodies. You can get two physics shapes from the parameter''s `PhysicsContact`
    instance in the `onContactBegin` method by using the `getShapeA`, `getShapeB`,
    and `getBody` method as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `EventListenerPhysicsContact` 类在物理世界中检测碰撞。它将接收物理世界中所有的接触回调。如果你在这个监听器中设置了
    `onContactBegin` 方法，你可以捕获物理体的碰撞。你可以在 `onContactBegin` 方法中使用 `getShapeA`、`getShapeB`
    和 `getBody` 方法从参数的 `PhysicsContact` 实例中获取两个物理形状，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `onContactBegin` method returns true or false. If it returns true, the two
    physics bodies will collide. If it returns false, there will not be a collision
    response. So, you decide to check the type of collision of the two bodies any
    way.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`onContactBegin` 方法返回 true 或 false。如果返回 true，两个物理体将发生碰撞。如果返回 false，则不会有碰撞响应。所以，你可以决定以任何方式检查两个体的碰撞类型。'
- en: The `setContactTestBitmask` method has a parameter to contact the test bit mask.
    This mask defines which categories of bodies cause intersection notifications
    with this physics body. When two bodies share the same space, each body's category
    mask is tested against the other body's contact mask by performing a logical AND
    operation. If either comparison results in a non-zero value, the `PhysicsContact`
    object is created and passed to the physics world's delegate. For best performance,
    only set bits in the contacts mask for the interactions you need. The bitmask
    is an integer number. The default value is `0x00000000` (all bits cleared).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`setContactTestBitmask` 方法有一个参数用于接触测试位掩码。这个掩码定义了哪些类型的物体与这个物理体发生交叉通知。当两个物体共享相同的空间时，每个物体的类别掩码通过执行逻辑与操作与另一个物体的接触掩码进行比较。如果任一比较结果不为零，则创建
    `PhysicsContact` 对象并将其传递给物理世界的代理。为了获得最佳性能，只为需要的交互设置接触掩码中的位。位掩码是一个整数。默认值是 `0x00000000`（所有位清除）。'
- en: '`PhysicsContact` has some other events as listed in the following table:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`PhysicsContact` 有一些其他事件，如下表所示：'
- en: '| Event | Description |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `onContactBegin` | Called when two shapes start to contact |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `onContactBegin` | 当两个形状开始接触时调用 |'
- en: '| `onContactPreSolve` | Two shapes are touching |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `onContactPreSolve` | 两个形状正在接触 |'
- en: '| `onContactPostSolve` | Two shapes'' collision responses have been processed
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `onContactPostSolve` | 已处理两个形状的碰撞响应 |'
- en: '| `onContactSeparate` | Called when two shapes separate |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `onContactSeparate` | 当两个形状分离时调用 |'
- en: Using joints
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关节
- en: Joints are used to connect two physics bodies to each other. Then, you can create
    a complex shape to join some shapes. In addition, you can create objects such
    as a gear or a motor to use joints. Cocos2d-x has many different types of joints.
    In this recipe, we explain a typical joint type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关节用于将两个物理体连接在一起。然后，你可以创建一个复杂形状来连接一些形状。此外，你可以创建齿轮或电机等对象来使用关节。Cocos2d-x 有很多不同类型的关节。在这个菜谱中，我们解释了一种典型的关节类型。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will create a method that creates a physics object. That''s why you have
    to create multiple physics objects. This method is called **makeSprite**. You
    have to add the following code in `HelloWorld.h`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个创建物理对象的方法。这就是为什么你必须创建多个物理对象的原因。这个方法被称为 **makeSprite**。你必须在 `HelloWorld.h`
    中添加以下代码：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You have to add the following code in `HelloWorld.cpp`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在 `HelloWorld.cpp` 中添加以下代码：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In this recipe, we explain `PhysicsJointGear`. This joint works to keep the
    angular velocity ratio of a pair of bodies.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们解释了 `PhysicsJointGear`。这个关节的作用是保持一对物体的角速度比。
- en: 'Firstly, you have to add the following code in `HelloWorld.h`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你必须在 `HelloWorld.h` 中添加以下代码：
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Secondly, you have to add the `onEnter` method to create a gear joint by using
    two physics objects and the `PhysicsJointGear` class in `HelloWorld.cpp`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，你必须在 `HelloWorld.cpp` 中添加 `onEnter` 方法，通过使用两个物理对象和 `PhysicsJointGear` 类来创建齿轮关节：
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, you have to be able to touch physics objects. Add in `HellowWorld.h`,
    the following code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你必须能够触摸物理对象。在 `HellowWorld.h` 中添加以下代码：
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, add to the `HelloWorld::onEnter` method in `HelloWorld.cpp`, the following
    code:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，在 `HelloWorld.cpp` 中的 `HelloWorld::onEnter` 方法中添加以下代码：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, you write the executing codes in three touch methods as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你按照以下方式在三个触摸方法中编写执行代码：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, you will run and test the gear joint by touching the physics objects.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你将通过触摸物理对象来运行和测试齿轮关节。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Firstly, you have to fix gear objects on the wall, as gear objects will drop
    to the floor if they are not fixed. To fix them, you use the `PhysicsJointPin`
    class.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你必须将齿轮对象固定在墙上，因为如果它们没有被固定，齿轮对象会掉到地板上。为了固定它们，你使用 `PhysicsJointPin` 类。
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, you create a gear joint by using the `PhysicsJointGear` class. In the
    `PhysicsJointGear::construct` method, you specify two physics bodies, namely phase
    value and ratio value. The phase value is the initial angular offset of the two
    bodies. The ratio value is the gear ratio. If the ratio value is `2.0f`, one axis
    will be rotated twice and the other axis will be rotated once.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你使用 `PhysicsJointGear` 类创建齿轮关节。在 `PhysicsJointGear::construct` 方法中，你指定两个物理体，即相位值和比值。相位值是两个物体的初始角偏移量。比值是齿轮比。如果比值是
    `2.0f`，一个轴将旋转两次，另一个轴将旋转一次。
- en: '[PRE15]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You were able to create the gear joint in Step 2\. However, you cannot move
    this gear. That's why you enable the touching of the screen and the moving of
    the physics objects. In the `onTouchBegan` method, we check the physics object
    in the touch area. If the object didn't exist in the touch location, it returns
    `false`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在第二步中能够创建齿轮关节。然而，你不能移动这个齿轮。这就是为什么你启用屏幕触摸和物理对象的移动。在 `onTouchBegan` 方法中，我们检查触摸区域中的物理对象。如果对象在触摸位置不存在，它返回
    `false`。
- en: '[PRE16]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the object existed in the touch location, get the physics body from the physics
    shape. Then, create a node on the touch location and add a physics body to this
    node. This node is used in the `onTouchMoved` method.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对象存在于触摸位置，从物理形状中获取物理体。然后，在触摸位置创建一个节点，并将物理体添加到这个节点上。这个节点用于 `onTouchMoved` 方法。
- en: '[PRE17]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To add force to this object, add `PhysicsJointPin` by using `touchBody` and
    the touch `location`. Then, set the force by using the `setMaxForce` method.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要给这个对象添加力，使用 `touchBody` 和触摸 `location` 添加 `PhysicsJointPin`。然后，使用 `setMaxForce`
    方法设置力。
- en: '[PRE18]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `onTouchMoved` method, move the touch node as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onTouchMoved` 方法中，按照以下方式移动触摸节点：
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `onTouchEnded` method, remove the touch node as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onTouchEnded` 方法中，按照以下方式移除触摸节点：
- en: '[PRE20]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There's more…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Cocos2d-x has a lot of joints. Each joint has a different task as given in
    the following table:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x 有很多关节。每个关节都有不同的任务，如下表所示：
- en: '| Joint | Description |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 关节 | 描述 |'
- en: '| --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PhysicsJointFixed` | A fixed joint connects the two bodies together at a
    reference point. Fixed joints are useful for creating complex shapes that can
    be broken apart later. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `PhysicsJointFixed` | 固定关节在参考点上连接两个物体。固定关节对于创建可以稍后拆分的复杂形状非常有用。 |'
- en: '| `PhysicsJointLimit` | A limit joint imposes the maximum distance between
    the two bodies. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `PhysicsJointLimit` | 极限关节在两个物体之间施加最大距离限制。 |'
- en: '| `PhysicsJointPin` | Allowing two bodies to independently rotate around the
    pin |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `PhysicsJointPin` | 允许两个物体独立绕销轴旋转 |'
- en: '| `PhysicsJointDistance` | Jointing two bodies with a fixed distance |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `PhysicsJointDistance` | 使用固定距离连接两个物体 |'
- en: '| `PhysicsJointSpring` | Connecting two bodies with a spring |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `PhysicsJointSpring` | 使用弹簧连接两个物体 |'
- en: '| `PhysicsJointRotarySpring` | Like a spring joint which rotates |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `PhysicsJointRotarySpring` | 类似于可以旋转的弹簧关节 |'
- en: '| `PhysicsJointRotaryLimit` | Like a limit joint which rotates |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `PhysicsJointRotaryLimit` | 类似于可以旋转的极限关节 |'
- en: '| `PhysicsJointRatchet` | Like a socket wrench |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `PhysicsJointRatchet` | 类似于扳手 |'
- en: '| `PhysicsJointGear` | Keeps the angular velocity ratio of a pair of bodies
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `PhysicsJointGear` | 保持一对物体的角速度比 |'
- en: '| `PhysicsJointMotor` | Keeps the relative angular velocity of a pair of bodies
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `PhysicsJointMotor` | 保持一对物体的相对角速度 |'
- en: 'This is difficult to explain by text. So, you should check the cpp-tests application
    that was provided by Cocos2d-x. You run the cpp-tests application and select `Node::Physics`
    from the menu. You can check the following image:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这很难用文字解释。所以，你应该检查 Cocos2d-x 提供的 cpp-tests 应用程序。你运行 cpp-tests 应用程序并从菜单中选择 `Node::Physics`。你可以检查以下图片：
- en: '![There''s more…](img/B0561_09_02.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/B0561_09_02.jpg)'
- en: Then, you can touch or drag these physics objects, so, you can see each joint's
    working.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以触摸或拖动这些物理对象，因此，你可以看到每个关节的工作情况。
- en: Changing gravity by using the acceleration sensor
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过使用加速度传感器改变重力
- en: A game with a physics engine will often change the direction of gravity by tilting
    the device. By doing so, it is possible to add realism in the game. In this recipe,
    you can change the direction of gravity by using an acceleration sensor.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 带有物理引擎的游戏通常会通过倾斜设备来改变重力的方向。这样做可以在游戏中增加现实感。在这个菜谱中，你可以通过使用加速度传感器来改变重力的方向。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To avoid screen rotation, you have to change some code and settings. Firstly,
    you should set **Device Orientation** to only **Landscape Right** as shown in
    the following image:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免屏幕旋转，你必须更改一些代码和设置。首先，你应该将 **设备方向** 设置为仅 **横向右**，如图所示：
- en: '![Getting ready](img/B0561_09_03.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/B0561_09_03.jpg)'
- en: Secondly, you change the `shouldAutorotate` method's return value to false in
    `RootViewController.mm`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你需要在 `RootViewController.mm` 中将 `shouldAutorotate` 方法的返回值更改为 false。
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'You check the acceleration sensor value in `HelloWorld.cpp` as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `HelloWorld.cpp` 中检查加速度传感器值，如下所示：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you tilt the device, you can get the changing acceleration `x` and `y` values.
    At this time, we have 100 times the value of the x-axis and y-axis. That's why
    the value of acceleration is pretty small for using gravity.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你倾斜设备，你可以获取变化的加速度 `x` 和 `y` 值。此时，x 轴和 y 轴的值是 100 倍。这就是为什么加速度的值对于使用重力来说非常小。
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While rotating the device, the home button is at the right, then it is the home
    position. At this time, the acceleration y value is negative. While rotating,
    if the home button is at the left side; the acceleration y value is positive.
    While rotating, if it is in the portrait position, then the acceleration x value
    is positive. Or, while rotating, if it is upside down, then the acceleration x
    value is negative. Then, to change gravity by using the acceleration sensor value,
    you can realize real gravity in your game.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在旋转设备时，如果主页按钮在右侧，那么它就是主页位置。此时，加速度 y 值是负的。在旋转时，如果主页按钮在左侧；加速度 y 值是正的。在旋转时，如果处于纵向位置，那么加速度
    x 值是正的。或者，在旋转时，如果颠倒，那么加速度 x 值是负的。然后，通过使用加速度传感器值来改变重力，你可以在游戏中实现真实重力。
