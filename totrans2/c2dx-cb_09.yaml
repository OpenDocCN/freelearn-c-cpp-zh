- en: Chapter 9. Controlling Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the physics engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting collisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using joints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing gravity by using the acceleration sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Physics is really important for games. Players need to simulate real-world
    situations. You can add physical realism to your game by using a physics engine.
    As you know, there are two famous physics engines: Box2D and Chipmunk. In Cocos2d-x
    version 2.x, you have to use these physics engines. However, it is pretty difficult
    to use them. Since Cocos2d-x version 3.x, Cocos2d-x has a useful physics engine
    wrapped in Chipmunk. Therefore, the physics engine is no longer a concern for
    us as it is scalable and CPU friendly. In this chapter, you will learn how to
    use the physics engine easily in your game.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the physics engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What should you do when you realize that your game needs to simulate real-world
    situations? You know that the answer is to use a physics engine. When you start
    using a physics engine, you have to use some new classes and methods. In this
    recipe, you will learn how to use the basic physics engine in Cocos2d-x.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, you have to create the physics world in your scene. You can create
    it by using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, you have to add the physics bodies in the physics world. A physics body
    is not visible. It is a physical shape such as a square or a circle or a more
    complex shape. Here, let's create a square shape. You have to create it and set
    it to the sprite to be visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, you have to run the preceding code. You can then see the sprite falling
    and bouncing on the ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, you have to create the physics world in the scene by using the `Scene::createWithPhysics`
    method. In this way, you can use the physics engine in your game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you have to create the wall upside down and from the left to the right
    on the screen edge. If you remove this wall and run the code, the sprite object
    will be falling forever. You can create an edge box by using the `PhysicsBody::createEdgeBox`
    method with this size and material setting. In this case, the wall will be of
    the same size as the screen. The material setting is specified as `PhysicsMaterial(0.1f,
    1.0f, 0.0f)`. This means that the density is `1.0f`, restitution is `1.0f`, and
    friction is `0.0f`. Let's try to change this parameter and check it in the given
    situation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you can create the physics body with the sprite. In this case, the
    sprite is circular in shape. So, you need to use the `PhysicsBody::createCircle`
    method to create the circular physics body. Then, add the physics body to the
    sprite by using the `Sprite::setPhysicsBody` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Cocos2d-x has a lot of physics body shapes as listed in the following table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Shape | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| PhysicsShapeCircle | Solid circle shape |'
  prefs: []
  type: TYPE_TB
- en: '| PhysicsShapePolygon | Solid polygon shape |'
  prefs: []
  type: TYPE_TB
- en: '| PhysicsShapeBox | Solid box shape |'
  prefs: []
  type: TYPE_TB
- en: '| PhysicsShapeEdgeSegment | Segment shape |'
  prefs: []
  type: TYPE_TB
- en: '| PhysicsShapeEdgePolygon | Hollow polygon shape |'
  prefs: []
  type: TYPE_TB
- en: '| PhysicsShapeEdgeBox | Hollow box shape |'
  prefs: []
  type: TYPE_TB
- en: '| PhysicsShapeEdgeChain | To connect many edges |'
  prefs: []
  type: TYPE_TB
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Then, you can get a `PhysicsWorld` instance by using the `Scene::getPhysicsWorld`
    method. In this recipe, we set `PhysicsWorld::DEBUGDRAW_ALL` to the physics world.
    That's why you can see that the edges of all physics objects are red lines. When
    you release your game, you will have to remove this setting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![There''s more…](img/B0561_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Further, you can set the original gravity value to `PhysicsWorld`. For example,
    you can change the gravity when the device was tilted. The following code is how
    to change the gravity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The above code is against the force of the earth's gravity. The default gravity
    value is `Vec2(0, -98.0f)`.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a collision between physics objects occurs, you want to take action against
    the physics bodies, for example, showing an explosion and showing a particle.
    In this recipe, you learn how to detect a collision in the physics world.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, you have to create the event listener in the `init` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you have to set the contact test bit mask to the physics bodies that
    you want to check the collisions for. In this recipe, you set the wall body and
    the sprite body as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can detect a collision in the physics world by using the `EventListenerPhysicsContact`
    class. It will receive all the contact callbacks in the physics world. If you
    set the `onContactBegin` method in this listener, you can catch the collision
    of the physics bodies. You can get two physics shapes from the parameter''s `PhysicsContact`
    instance in the `onContactBegin` method by using the `getShapeA`, `getShapeB`,
    and `getBody` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `onContactBegin` method returns true or false. If it returns true, the two
    physics bodies will collide. If it returns false, there will not be a collision
    response. So, you decide to check the type of collision of the two bodies any
    way.
  prefs: []
  type: TYPE_NORMAL
- en: The `setContactTestBitmask` method has a parameter to contact the test bit mask.
    This mask defines which categories of bodies cause intersection notifications
    with this physics body. When two bodies share the same space, each body's category
    mask is tested against the other body's contact mask by performing a logical AND
    operation. If either comparison results in a non-zero value, the `PhysicsContact`
    object is created and passed to the physics world's delegate. For best performance,
    only set bits in the contacts mask for the interactions you need. The bitmask
    is an integer number. The default value is `0x00000000` (all bits cleared).
  prefs: []
  type: TYPE_NORMAL
- en: '`PhysicsContact` has some other events as listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `onContactBegin` | Called when two shapes start to contact |'
  prefs: []
  type: TYPE_TB
- en: '| `onContactPreSolve` | Two shapes are touching |'
  prefs: []
  type: TYPE_TB
- en: '| `onContactPostSolve` | Two shapes'' collision responses have been processed
    |'
  prefs: []
  type: TYPE_TB
- en: '| `onContactSeparate` | Called when two shapes separate |'
  prefs: []
  type: TYPE_TB
- en: Using joints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joints are used to connect two physics bodies to each other. Then, you can create
    a complex shape to join some shapes. In addition, you can create objects such
    as a gear or a motor to use joints. Cocos2d-x has many different types of joints.
    In this recipe, we explain a typical joint type.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will create a method that creates a physics object. That''s why you have
    to create multiple physics objects. This method is called **makeSprite**. You
    have to add the following code in `HelloWorld.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to add the following code in `HelloWorld.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we explain `PhysicsJointGear`. This joint works to keep the
    angular velocity ratio of a pair of bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, you have to add the following code in `HelloWorld.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Secondly, you have to add the `onEnter` method to create a gear joint by using
    two physics objects and the `PhysicsJointGear` class in `HelloWorld.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you have to be able to touch physics objects. Add in `HellowWorld.h`,
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add to the `HelloWorld::onEnter` method in `HelloWorld.cpp`, the following
    code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you write the executing codes in three touch methods as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, you will run and test the gear joint by touching the physics objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, you have to fix gear objects on the wall, as gear objects will drop
    to the floor if they are not fixed. To fix them, you use the `PhysicsJointPin`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, you create a gear joint by using the `PhysicsJointGear` class. In the
    `PhysicsJointGear::construct` method, you specify two physics bodies, namely phase
    value and ratio value. The phase value is the initial angular offset of the two
    bodies. The ratio value is the gear ratio. If the ratio value is `2.0f`, one axis
    will be rotated twice and the other axis will be rotated once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You were able to create the gear joint in Step 2\. However, you cannot move
    this gear. That's why you enable the touching of the screen and the moving of
    the physics objects. In the `onTouchBegan` method, we check the physics object
    in the touch area. If the object didn't exist in the touch location, it returns
    `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the object existed in the touch location, get the physics body from the physics
    shape. Then, create a node on the touch location and add a physics body to this
    node. This node is used in the `onTouchMoved` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To add force to this object, add `PhysicsJointPin` by using `touchBody` and
    the touch `location`. Then, set the force by using the `setMaxForce` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `onTouchMoved` method, move the touch node as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `onTouchEnded` method, remove the touch node as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cocos2d-x has a lot of joints. Each joint has a different task as given in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Joint | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `PhysicsJointFixed` | A fixed joint connects the two bodies together at a
    reference point. Fixed joints are useful for creating complex shapes that can
    be broken apart later. |'
  prefs: []
  type: TYPE_TB
- en: '| `PhysicsJointLimit` | A limit joint imposes the maximum distance between
    the two bodies. |'
  prefs: []
  type: TYPE_TB
- en: '| `PhysicsJointPin` | Allowing two bodies to independently rotate around the
    pin |'
  prefs: []
  type: TYPE_TB
- en: '| `PhysicsJointDistance` | Jointing two bodies with a fixed distance |'
  prefs: []
  type: TYPE_TB
- en: '| `PhysicsJointSpring` | Connecting two bodies with a spring |'
  prefs: []
  type: TYPE_TB
- en: '| `PhysicsJointRotarySpring` | Like a spring joint which rotates |'
  prefs: []
  type: TYPE_TB
- en: '| `PhysicsJointRotaryLimit` | Like a limit joint which rotates |'
  prefs: []
  type: TYPE_TB
- en: '| `PhysicsJointRatchet` | Like a socket wrench |'
  prefs: []
  type: TYPE_TB
- en: '| `PhysicsJointGear` | Keeps the angular velocity ratio of a pair of bodies
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PhysicsJointMotor` | Keeps the relative angular velocity of a pair of bodies
    |'
  prefs: []
  type: TYPE_TB
- en: 'This is difficult to explain by text. So, you should check the cpp-tests application
    that was provided by Cocos2d-x. You run the cpp-tests application and select `Node::Physics`
    from the menu. You can check the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/B0561_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then, you can touch or drag these physics objects, so, you can see each joint's
    working.
  prefs: []
  type: TYPE_NORMAL
- en: Changing gravity by using the acceleration sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A game with a physics engine will often change the direction of gravity by tilting
    the device. By doing so, it is possible to add realism in the game. In this recipe,
    you can change the direction of gravity by using an acceleration sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To avoid screen rotation, you have to change some code and settings. Firstly,
    you should set **Device Orientation** to only **Landscape Right** as shown in
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B0561_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Secondly, you change the `shouldAutorotate` method's return value to false in
    `RootViewController.mm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You check the acceleration sensor value in `HelloWorld.cpp` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you tilt the device, you can get the changing acceleration `x` and `y` values.
    At this time, we have 100 times the value of the x-axis and y-axis. That's why
    the value of acceleration is pretty small for using gravity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: While rotating the device, the home button is at the right, then it is the home
    position. At this time, the acceleration y value is negative. While rotating,
    if the home button is at the left side; the acceleration y value is positive.
    While rotating, if it is in the portrait position, then the acceleration x value
    is positive. Or, while rotating, if it is upside down, then the acceleration x
    value is negative. Then, to change gravity by using the acceleration sensor value,
    you can realize real gravity in your game.
  prefs: []
  type: TYPE_NORMAL
