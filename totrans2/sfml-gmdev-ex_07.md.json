["```cpp\n|type|~id|x|y|\nBACKGROUND Bg1\nSIZE 63 32\nGRAVITY 512\nDEFAULT_FRICTION 0.8 0\nNEXTMAP map2.map\n|PLAYER 0 512\n|ENEMY Rat 128 512\nTILE 0 0 25\nTILE 1 0 26 WARP\n...\n```", "```cpp\n|id|name|friction x|friction y|deadly\n0 Grass 0.8 0 0\n1 Dirt 0.8 0 0\n2 Stone 0.8 0 0\n3 Brick 0.8 0 0\n4 Brick_Red 0.8 0 0\n5 Rock 0.8 0 0\n6 Icy_Rock 0.6 0 0\n7 Spikes 1.0 0 1\n8 Ice 0.25 0 0\n```", "```cpp\nenum Sheet{Tile_Size = 32, Sheet_Width = 256, Sheet_Height = 256};\n```", "```cpp\nusing TileID = unsigned int;\n```", "```cpp\nstruct TileInfo{\n  TileInfo(SharedContext* l_context, \n    const std::string& l_texture = \"\", TileID l_id = 0)\n    : m_context(l_context), m_id(0), m_deadly(false)\n  {\n    TextureManager* tmgr = l_context->m_textureManager;\n    if (l_texture == \"\"){ m_id = l_id; return; }\n    if (!tmgr->RequireResource(l_texture)){ return; }\n    m_texture = l_texture;\n    m_id = l_id;\n    m_sprite.setTexture(*tmgr->GetResource(m_texture));\n    sf::IntRect tileBoundaries(m_id %\n     (Sheet::Sheet_Width / Sheet::Tile_Size) * Sheet::Tile_Size,\n     m_id/(Sheet::Sheet_Height/Sheet::Tile_Size)*Sheet::Tile_Size,\n     Sheet::Tile_Size,Sheet::Tile_Size);\n    m_sprite.setTextureRect(tileBoundaries);\n  }\n\n  ~TileInfo(){\n    if (m_texture == \"\"){ return; }\n    m_context->m_textureManager->ReleaseResource(m_texture);\n  }\n\n  sf::Sprite m_sprite;\n\n  TileID m_id;\n  std::string m_name;\n  sf::Vector2f m_friction;\n  bool m_deadly;\n\n  SharedContext* m_context;\n  std::string m_texture;\n};\n```", "```cpp\nstruct Tile{\n    TileInfo* m_properties;\n    bool m_warp; // Is the tile a warp.\n    // Other flags unique to each tile.\n};\n```", "```cpp\nusing TileMap = std::unordered_map<TileID,Tile*>;\nusing TileSet = std::unordered_map<TileID,TileInfo*>;\n```", "```cpp\nclass Map{\npublic:\n  Map(SharedContext* l_context, BaseState* l_currentState);\n  ~Map();\n  Tile* GetTile(unsigned int l_x, unsigned int l_y);\n  TileInfo* GetDefaultTile();\n  float GetGravity()const;\n  unsigned int GetTileSize()const;\n  const sf::Vector2u& GetMapSize()const;\n  const sf::Vector2f& GetPlayerStart()const;\n  void LoadMap(const std::string& l_path);\n  void LoadNext();\n  void Update(float l_dT);\n  void Draw();\nprivate:\n  // Method for converting 2D coordinates to 1D ints.\n  unsigned int ConvertCoords(unsigned int l_x, unsigned int l_y);\n  void LoadTiles(const std::string& l_path);\n  void PurgeMap();\n  void PurgeTileSet();\n\n  TileSet m_tileSet;\n  TileMap m_tileMap;\n  sf::Sprite m_background;\n  TileInfo m_defaultTile;\n  sf::Vector2u m_maxMapSize;\n  sf::Vector2f m_playerStart;\n  unsigned int m_tileCount;\n  unsigned int m_tileSetCount;\n  float m_mapGravity;\n  std::string m_nextMap;\n  bool m_loadNextMap;\n  std::string m_backgroundTexture;\n  BaseState* m_currentState;\n  SharedContext* m_context;\n};\n```", "```cpp\nMap::Map(SharedContext* l_context, BaseState* l_currentState)\n    :m_context(l_context), m_defaultTile(l_context), m_maxMapSize(32, 32), m_tileCount(0), m_tileSetCount(0),m_mapGravity(512.f), m_loadNextMap(false),m_currentState(l_currentState)\n{\n    m_context->m_gameMap = this;\n    LoadTiles(\"tiles.cfg\");\n}\n```", "```cpp\nMap::~Map(){\n    PurgeMap();\n    PurgeTileSet();\n    m_context->m_gameMap = nullptr;\n}\n```", "```cpp\nTile* Map::GetTile(unsigned int l_x, unsigned int l_y){\n  auto itr = m_tileMap.find(ConvertCoords(l_x,l_y));\n  return(itr != m_tileMap.end() ? itr->second : nullptr);\n}\n```", "```cpp\nunsigned int Map::ConvertCoords(const unsigned int& l_x, const unsigned int& l_y)\n{\n    return (l_x * m_maxMapSize.x) + l_y; // Row-major.\n}\n```", "```cpp\nvoid Map::Update(float l_dT){\n  if(m_loadNextMap){\n    PurgeMap();\n    m_loadNextMap = false;\n    if(m_nextMap != \"\"){\n      LoadMap(\"media/maps/\"+m_nextMap);\n    } else {\n      m_currentState->GetStateManager()->\n        SwitchTo(StateType::GameOver);\n    }\n    m_nextMap = \"\";\n  }\n  sf::FloatRect viewSpace = m_context->m_wind->GetViewSpace();\n  m_background.setPosition(viewSpace.left, viewSpace.top);\n}\n```", "```cpp\nvoid Map::Draw(){\n  sf::RenderWindow* l_wind = m_context->m_wind->GetRenderWindow();\n  l_wind->draw(m_background);\n  sf::FloatRect viewSpace = m_context->m_wind->GetViewSpace();\n\n  sf::Vector2i tileBegin(\n    floor(viewSpace.left / Sheet::Tile_Size),\n    floor(viewSpace.top / Sheet::Tile_Size));\n  sf::Vector2i tileEnd(\n    ceil((viewSpace.left + viewSpace.width) / Sheet::Tile_Size),\n    ceil((viewSpace.top + viewSpace.height) / Sheet::Tile_Size));\n\n  unsigned int count = 0;\n  for(int x = tileBegin.x; x <= tileEnd.x; ++x){\n    for(int y = tileBegin.y; y <= tileEnd.y; ++y){\n      if(x < 0 || y < 0){ continue; }\n      Tile* tile = GetTile(x,y);\n      if (!tile){ continue; }\n      sf::Sprite& sprite = tile->m_properties->m_sprite;\n      sprite.setPosition(x * Sheet::Tile_Size,\n        y * Sheet::Tile_Size);\n      l_wind->draw(sprite);\n      ++count;\n    }\n  }\n}\n```", "```cpp\nvoid Map::PurgeMap(){\n  m_tileCount = 0;\n  for (auto &itr : m_tileMap){\n    delete itr.second;\n  }\n  m_tileMap.clear();\n  m_context->m_entityManager->Purge();\n\n  if (m_backgroundTexture == \"\"){ return; }\n  m_context->m_textureManager->ReleaseResource(m_backgroundTexture);\n  m_backgroundTexture = \"\";\n}\n```", "```cpp\nvoid Map::PurgeTileSet(){\n  for (auto &itr : m_tileSet){\n    delete itr.second;\n  }\n  m_tileSet.clear();\n  m_tileSetCount = 0;\n}\n```", "```cpp\nvoid Map::LoadTiles(const std::string& l_path){\n  std::ifstream file;\n  file.open(Utils::GetWorkingDirectory() + l_path);\n  if (!file.is_open()){\n    std::cout << \"! Failed loading tile set file: \"<< l_path << std::endl;\n    return;\n  }\n  std::string line;\n  while(std::getline(file,line)){\n    if (line[0] == '|'){ continue; }\n    std::stringstream keystream(line);\n    int tileId;\n    keystream >> tileId;\n    if (tileId < 0){ continue; }\n    TileInfo* tile = new TileInfo(m_context,\"TileSheet\",tileId);\n    keystream >> tile->m_name >> tile->m_friction.x >> tile->m_friction.y >> tile->m_deadly;\n    if(!m_tileSet.emplace(tileId,tile).second){\n      // Duplicate tile detected!\n      std::cout << \"! Duplicate tile type: \"<< tile->m_name << std::endl;\n      delete tile;\n    }\n  }\n  file.close();\n}\n```", "```cpp\nif(type == \"TILE\"){\n  int tileId = 0;\n  keystream >> tileId;\n  if (tileId < 0){ std::cout << \"! Bad tile id: \" << tileId << std::endl;\n    continue;\n  }\n  auto itr = m_tileSet.find(tileId);\n  if (itr == m_tileSet.end()){\n    std::cout << \"! Tile id(\" << tileId<< \") was not found in tileset.\" << std::endl;\n    continue;\n  }\n  sf::Vector2i tileCoords;\n  keystream >> tileCoords.x >> tileCoords.y;\n  if (tileCoords.x>m_maxMapSize.x || tileCoords.y>m_maxMapSize.y)\n  {\n    std::cout << \"! Tile is out of range: \" <<tileCoords.x << \" \" << tileCoords.y << std::endl;\n    continue;\n  }\n  Tile* tile = new Tile();\n  // Bind properties of a tile from a set.\n  tile->m_properties = itr->second;\n  if(!m_tileMap.emplace(ConvertCoords(\n    tileCoords.x,tileCoords.y),tile).second)\n  {\n    // Duplicate tile detected!\n    std::cout << \"! Duplicate tile! : \" << tileCoords.x << \"\" << tileCoords.y << std::endl;\n    delete tile;\n    tile = nullptr;\n    continue;\n  }\n  std::string warp;\n  keystream >> warp;\n  tile->m_warp = false;\n  if(warp == \"WARP\"){ tile->m_warp = true; }\n} else if ...\n```", "```cpp\n} else if(type == \"BACKGROUND\"){\n  if (m_backgroundTexture != \"\"){ continue; }\n  keystream >> m_backgroundTexture;\n  if (!m_context->m_textureManager->RequireResource(m_backgroundTexture))\n  {\n    m_backgroundTexture = \"\";\n    continue;\n  }\n  sf::Texture* texture = m_context->m_textureManager->GetResource(m_backgroundTexture);\n  m_background.setTexture(*texture);\n  sf::Vector2f viewSize = m_currentState->GetView().getSize();\n  sf::Vector2u textureSize = texture->getSize();\n  sf::Vector2f scaleFactors;\n  scaleFactors.x = viewSize.x / textureSize.x;\n  scaleFactors.y = viewSize.y / textureSize.y;\n  m_background.setScale(scaleFactors);\n} else if ...\n```", "```cpp\n} else if(type == \"SIZE\"){\n    keystream >> m_maxMapSize.x >> m_maxMapSize.y;\n} else if(type == \"GRAVITY\"){\n    keystream >> m_mapGravity;\n} else if(type == \"DEFAULT_FRICTION\"){\n    keystream >> m_defaultTile->m_friction.x >> m_defaultTile->m_friction.y;\n} else if(type == \"NEXTMAP\"){\n    keystream >> m_nextMap;\n}\n```", "```cpp\nvoid Map::LoadNext(){ m_loadNextMap = true; }\n```", "```cpp\nenum class EntityType{ Base, Enemy, Player };\n```", "```cpp\nenum class EntityState{\n    Idle, Walking, Jumping, Attacking, Hurt, Dying\n};\n```", "```cpp\nclass EntityManager;\nclass EntityBase{\nfriend class EntityManager;\npublic:\n  EntityBase(EntityManager* l_entityMgr);\n  virtual ~EntityBase();\n  ... // Getters and setters.\n  void Move(float l_x, float l_y);\n  void AddVelocity(float l_x, float l_y);\n  void Accelerate(float l_x, float l_y);\n  void SetAcceleration(float l_x, float l_y);\n  void ApplyFriction(float l_x, float l_y);\n  virtual void Update(float l_dT);\n  virtual void Draw(sf::RenderWindow* l_wind) = 0;\nprotected:\n  // Methods.\n  void UpdateAABB();\n  void CheckCollisions();\n  void ResolveCollisions();\n  // Method for what THIS entity does TO the l_collider entity.\n  virtual void OnEntityCollision(EntityBase* l_collider,bool l_attack) = 0;\n  // Data members.\n  std::string m_name;\n  EntityType m_type;\n  unsigned int m_id; // Entity id in the entity manager.\n  sf::Vector2f m_position; // Current position.\n  sf::Vector2f m_positionOld; // Position before entity moved.\n  sf::Vector2f m_velocity; // Current velocity.\n  sf::Vector2f m_maxVelocity; // Maximum velocity.\n  sf::Vector2f m_speed; // Value of acceleration.\n  sf::Vector2f m_acceleration; // Current acceleration.\n  sf::Vector2f m_friction; // Default friction value.\n  TileInfo* m_referenceTile; // Tile underneath entity.\n  sf::Vector2f m_size; // Size of the collision box.\n  sf::FloatRect m_AABB; // The bounding box for collisions.\n  EntityState m_state; // Current entity state.\n  // Flags for remembering axis collisions.\n  bool m_collidingOnX;\n  bool m_collidingOnY;\n\n  Collisions m_collisions;\n  EntityManager* m_entityManager;\n};\n```", "```cpp\nif(m_AABB.intersects(SomeRectangle){...}\n```", "```cpp\nEntityBase::EntityBase(EntityManager* l_entityMgr)\n  :m_entityManager(l_entityMgr), m_name(\"BaseEntity\"),\n  m_type(EntityType::Base), m_referenceTile(nullptr),\n  m_state(EntityState::Idle), m_id(0),\n  m_collidingOnX(false), m_collidingOnY(false){}\n```", "```cpp\nvoid EntityBase::SetPosition(const float& l_x, const float& l_y){\n    m_position = sf::Vector2f(l_x,l_y);\n    UpdateAABB();\n}\nvoid EntityBase::SetPosition(const sf::Vector2f& l_pos){\n    m_position = l_pos;\n    UpdateAABB();\n}\nvoid EntityBase::SetSize(const float& l_x, const float& l_y){\n    m_size = sf::Vector2f(l_x,l_y);\n    UpdateAABB();\n}\nvoid EntityBase::SetState(const EntityState& l_state){\n    if(m_state == EntityState::Dying){ return; }\n    m_state = l_state;\n}\n```", "```cpp\nvoid EntityBase::Move(float l_x, float l_y){\n  m_positionOld = m_position;\n  m_position += sf::Vector2f(l_x,l_y);\n  sf::Vector2u mapSize = m_entityManager->GetContext()->m_gameMap->GetMapSize();\n  if(m_position.x < 0){\n    m_position.x = 0;\n  } else if(m_position.x > (mapSize.x + 1) * Sheet::Tile_Size){\n    m_position.x = (mapSize.x + 1) * Sheet::Tile_Size;\n  }\n\n  if(m_position.y < 0){\n    m_position.y = 0;\n  } else if(m_position.y > (mapSize.y + 1) * Sheet::Tile_Size){\n    m_position.y = (mapSize.y + 1) * Sheet::Tile_Size;\n    SetState(EntityState::Dying);\n  }\n\n  UpdateAABB();\n}\n```", "```cpp\nvoid EntityBase::AddVelocity(float l_x, float l_y){\n  m_velocity += sf::Vector2f(l_x,l_y);\n  if(abs(m_velocity.x) > m_maxVelocity.x){\n    if(m_velocity.x < 0){ m_velocity.x = -m_maxVelocity.x; }\n    else { m_velocity.x = m_maxVelocity.x; }\n  }\n\n  if(abs(m_velocity.y) > m_maxVelocity.y){\n    if(m_velocity.y < 0){ m_velocity.y = -m_maxVelocity.y; }\n    else { m_velocity.y = m_maxVelocity.y; }\n  }\n}\n```", "```cpp\nvoid EntityBase::Accelerate(float l_x, float l_y){\n    m_acceleration += sf::Vector2f(l_x,l_y);\n}\n```", "```cpp\nvoid EntityBase::ApplyFriction(float l_x, float l_y){\n  if(m_velocity.x != 0){\n    if(abs(m_velocity.x) - abs(l_x) < 0){ m_velocity.x = 0; }\n    else {\n      if(m_velocity.x < 0){ m_velocity.x += l_x; }\n      else { m_velocity.x -= l_x; }\n    }\n  }\n\n  if(m_velocity.y != 0){\n    if (abs(m_velocity.y) - abs(l_y) < 0){ m_velocity.y = 0; }\n    else {\n      if(m_velocity.y < 0){ m_velocity.y += l_y; }\n      else { m_velocity.y -= l_y; }\n    }\n  }\n}\n```", "```cpp\nvoid EntityBase::Update(float l_dT){\n  Map* map = m_entityManager->GetContext()->m_gameMap;\n  float gravity = map->GetGravity();\n  Accelerate(0,gravity);\n  AddVelocity(m_acceleration.x * l_dT, m_acceleration.y * l_dT);\n  SetAcceleration(0.0f, 0.0f);\n  sf::Vector2f frictionValue;\n  if(m_referenceTile){\n    frictionValue = m_referenceTile->m_friction;\n    if(m_referenceTile->m_deadly){ SetState(EntityState::Dying); }\n  } else if(map->GetDefaultTile()){\n    frictionValue = map->GetDefaultTile()->m_friction;\n  } else {\n    frictionValue = m_friction;\n  }\n\n  float friction_x = (m_speed.x * frictionValue.x) * l_dT;\n  float friction_y = (m_speed.y * frictionValue.y) * l_dT;\n  ApplyFriction(friction_x, friction_y);\n  sf::Vector2f deltaPos = m_velocity * l_dT;\n  Move(deltaPos.x, deltaPos.y);\n  m_collidingOnX = false;\n  m_collidingOnY = false;\n  CheckCollisions();\n  ResolveCollisions();\n}\n```", "```cpp\nvoid EntityBase::UpdateAABB(){\n  m_AABB = sf::FloatRect(m_position.x - (m_size.x / 2),m_position.y - m_size.y, m_size.x, m_size.y);\n}\n```", "```cpp\nsf::FloatRect r1;\nsf::FloatRect r2;\nif(r1.intersects(r2)){ ... }\n```", "```cpp\n...\nsf::FloatRect intersection;\nif(r1.intersects(r2,intersection)){ ... }\n```", "```cpp\nstruct CollisionElement{\n  CollisionElement(float l_area, TileInfo* l_info,const sf::FloatRect& l_bounds):m_area(l_area), m_tile(l_info), m_tileBounds(l_bounds){}\n  float m_area;\n  TileInfo* m_tile;\n  sf::FloatRect m_tileBounds;\n};\n\nusing Collisions = std::vector<CollisionElement>;\n```", "```cpp\nbool SortCollisions(const CollisionElement& l_1,const CollisionElement& l_2);\n```", "```cpp\nbool SortCollisions(const CollisionElement& l_1,const CollisionElement& l_2)\n{ return l_1.m_area > l_2.m_area; }\n```", "```cpp\nvoid EntityBase::CheckCollisions(){\n  Map* gameMap = m_entityManager->GetContext()->m_gameMap;\n  unsigned int tileSize = gameMap->GetTileSize();\n  int fromX = floor(m_AABB.left / tileSize);\n  int toX = floor((m_AABB.left + m_AABB.width) / tileSize);\n  int fromY = floor(m_AABB.top / tileSize);\n  int toY = floor((m_AABB.top + m_AABB.height) / tileSize);\n\n  for(int x = fromX; x <= toX; ++x){\n    for(int y = fromY; y <= toY; ++y){\n      Tile* tile = gameMap->GetTile(x,y);\n      if (!tile){ continue; }\n      sf::FloatRect tileBounds(x * tileSize, y * tileSize,\n        tileSize,tileSize);\n      sf::FloatRect intersection;\n      m_AABB.intersects(tileBounds,intersection);\n      float area = intersection.width * intersection.height;\n\n      CollisionElement e(area, tile->m_properties, tileBounds);\n      m_collisions.emplace_back(e);\n      if(tile->m_warp && m_type == EntityType::Player){\n        gameMap->LoadNext();\n      }\n    }\n  }\n}\n```", "```cpp\nvoid EntityBase::ResolveCollisions(){\n  if(!m_collisions.empty()){\n    std::sort(m_collisions.begin(),m_collisions.end(), SortCollisions);\n    Map* gameMap = m_entityManager->GetContext()->m_gameMap;\n    unsigned int tileSize = gameMap->GetTileSize();\n    for (auto &itr : m_collisions){\n      if (!m_AABB.intersects(itr.m_tileBounds)){ continue; }\n      float xDiff = (m_AABB.left + (m_AABB.width / 2)) -(itr.m_tileBounds.left + (itr.m_tileBounds.width / 2));\n      float yDiff = (m_AABB.top + (m_AABB.height / 2)) -(itr.m_tileBounds.top + (itr.m_tileBounds.height / 2));\n      float resolve = 0;\n      if(abs(xDiff) > abs(yDiff)){\n        if(xDiff > 0){\n          resolve = (itr.m_tileBounds.left + tileSize) –m_AABB.left;\n        } else {\n          resolve = -((m_AABB.left + m_AABB.width) –itr.m_tileBounds.left);\n        }\n        Move(resolve, 0);\n        m_velocity.x = 0;\n        m_collidingOnX = true;\n      } else {\n        if(yDiff > 0){\n          resolve = (itr.m_tileBounds.top + tileSize) –\n            m_AABB.top;\n        } else {\n          resolve = - ((m_AABB.top + m_AABB.height) –itr.m_tileBounds.top);\n        }\n        Move(0,resolve);\n        m_velocity.y = 0;\n        if (m_collidingOnY){ continue; }\n        m_referenceTile = itr.m_tile;\n        m_collidingOnY = true;\n      }\n    }\n    m_collisions.clear();\n  }\n  if(!m_collidingOnY){ m_referenceTile = nullptr; }\n}\n```", "```cpp\nusing EntityContainer = std::unordered_map<unsigned int,EntityBase*>;\nusing EntityFactory = std::unordered_map<EntityType, std::function<EntityBase*(void)>>;\nusing EnemyTypes = std::unordered_map<std::string,std::string>;\n```", "```cpp\nclass EntityManager{\npublic:\n  EntityManager(SharedContext* l_context,unsigned int l_maxEntities);\n  ~EntityManager();\n\n  int Add(const EntityType& l_type,const std::string& l_name = \"\");\n  EntityBase* Find(unsigned int l_id);\n  EntityBase* Find(const std::string& l_name);\n  void Remove(unsigned int l_id);\n\n  void Update(float l_dT);\n  void Draw();\n\n  void Purge();\n\n  SharedContext* GetContext();\nprivate:\n  template<class T>\n  void RegisterEntity(const EntityType& l_type){\n    m_entityFactory[l_type] = [this]() -> EntityBase*\n    {\n      return new T(this);\n    };\n  }\n\n  void ProcessRemovals();\n  void LoadEnemyTypes(const std::string& l_name);\n  void EntityCollisionCheck();\n\n  EntityContainer m_entities;\n  EnemyTypes m_enemyTypes;\n  EntityFactory m_entityFactory;\n  SharedContext* m_context;\n  unsigned int m_idCounter;\n  unsigned int m_maxEntities;\n\n  std::vector<unsigned int> m_entitiesToRemove;\n};\n```", "```cpp\nEntityManager::EntityManager(SharedContext* l_context,unsigned int l_maxEntities):m_context(l_context),m_maxEntities(l_maxEntities), m_idCounter(0)\n{\n    LoadEnemyTypes(\"EnemyList.list\");\n    RegisterEntity<Player>(EntityType::Player);\n    RegisterEntity<Enemy>(EntityType::Enemy);\n}\nEntityManager::~EntityManager(){ Purge(); }\n```", "```cpp\nint EntityManager::Add(const EntityType& l_type,const std::string& l_name)\n{\n  auto itr = m_entityFactory.find(l_type);\n  if (itr == m_entityFactory.end()){ return -1; }\n  EntityBase* entity = itr->second();\n  entity->m_id = m_idCounter;\n  if (l_name != \"\"){ entity->m_name = l_name; }\n  m_entities.emplace(m_idCounter,entity);\n  if(l_type == EntityType::Enemy){\n    auto itr = m_enemyTypes.find(l_name);\n    if(itr != m_enemyTypes.end()){\n      Enemy* enemy = (Enemy*)entity;\n      enemy->Load(itr->second);\n    }\n  }\n\n  ++m_idCounter;\n  return m_idCounter - 1;\n}\n```", "```cpp\nEntityBase* EntityManager::Find(const std::string& l_name){\n  for(auto &itr : m_entities){\n    if(itr.second->GetName() == l_name){\n      return itr.second;\n    }\n  }\n  return nullptr;\n}\n```", "```cpp\nEntityBase* EntityManager::Find(unsigned int l_id){\n  auto itr = m_entities.find(l_id);\n  if (itr == m_entities.end()){ return nullptr; }\n  return itr->second;\n}\n```", "```cpp\nvoid EntityManager::Remove(unsigned int l_id){\n    m_entitiesToRemove.emplace_back(l_id);\n}\n```", "```cpp\nvoid EntityManager::Update(float l_dT){\n  for(auto &itr : m_entities){\n    itr.second->Update(l_dT);\n  }\n  EntityCollisionCheck();\n  ProcessRemovals();\n}\n```", "```cpp\nvoid EntityManager::Draw(){\n  sf::RenderWindow* wnd = m_context->m_wind->GetRenderWindow();\n  sf::FloatRect viewSpace = m_context->m_wind->GetViewSpace();\n\n  for(auto &itr : m_entities){\n    if (!viewSpace.intersects(itr.second->m_AABB)){ continue; }\n    itr.second->Draw(wnd);\n  }\n}\n```", "```cpp\nvoid EntityManager::Purge(){\n  for (auto &itr : m_entities){\n    delete itr.second;\n  }\n  m_entities.clear();\n  m_idCounter = 0;\n}\n```", "```cpp\nvoid EntityManager::ProcessRemovals(){\n  while(m_entitiesToRemove.begin() != m_entitiesToRemove.end()){\n    unsigned int id = m_entitiesToRemove.back();\n    auto itr = m_entities.find(id);\n    if(itr != m_entities.end()){\n      std::cout << \"Discarding entity: \"<< itr->second->GetId() << std::endl;\n      delete itr->second;\n      m_entities.erase(itr);\n    }\n    m_entitiesToRemove.pop_back();\n  }\n}\n```", "```cpp\nvoid EntityManager::EntityCollisionCheck(){\n  if (m_entities.empty()){ return; }\n  for(auto itr = m_entities.begin();\n    std::next(itr) != m_entities.end(); ++itr)\n  {\n    for(auto itr2 = std::next(itr);\n      itr2 != m_entities.end(); ++itr2)\n    {\n      if(itr->first == itr2->first){ continue; }\n\n      // Regular AABB bounding box collision.\n      if(itr->second->m_AABB.intersects(itr2->second->m_AABB)){\n        itr->second->OnEntityCollision(itr2->second, false);\n        itr2->second->OnEntityCollision(itr->second, false);\n      }\n\n      EntityType t1 = itr->second->GetType();\n      EntityType t2 = itr2->second->GetType();\n      if (t1 == EntityType::Player || t1 == EntityType::Enemy){\n        Character* c1 = (Character*)itr->second;\n        if (c1->m_attackAABB.intersects(itr2->second->m_AABB)){\n          c1->OnEntityCollision(itr2->second, true);\n        }\n      }\n\n      if (t2 == EntityType::Player || t2 == EntityType::Enemy){\n        Character* c2 = (Character*)itr2->second;\n        if (c2->m_attackAABB.intersects(itr->second->m_AABB)){\n          c2->OnEntityCollision(itr->second, true);\n        }\n      }\n    }\n  }\n}\n```", "```cpp\n|Name|CharFile|\nRat Rat.char\n```", "```cpp\nvoid EntityManager::LoadEnemyTypes(const std::string& l_name){\n  std::ifstream file;\n  ... // Opening the file.\n  while(std::getline(file,line)){\n    if (line[0] == '|'){ continue; }\n    std::stringstream keystream(line);\n    std::string name;\n    std::string charFile;\n    keystream >> name >> charFile;\n    m_enemyTypes.emplace(name,charFile);\n  }\n  file.close();\n}\n```", "```cpp\nclass Character : public EntityBase{\nfriend class EntityManager;\npublic:\n  Character(EntityManager* l_entityMgr);\n  virtual ~Character();\n  void Move(const Direction& l_dir);\n  void Jump();\n  void Attack();\n  void GetHurt(const int& l_damage);\n  void Load(const std::string& l_path);\n  virtual void OnEntityCollision(\n    EntityBase* l_collider, bool l_attack) = 0;\n  virtual void Update(float l_dT);\n  void Draw(sf::RenderWindow* l_wind);\nprotected:\n  void UpdateAttackAABB();\n  void Animate();\n  SpriteSheet m_spriteSheet;\n  float m_jumpVelocity;\n  int m_hitpoints;\n  sf::FloatRect m_attackAABB;\n  sf::Vector2f m_attackAABBoffset;\n};\n```", "```cpp\nCharacter::Character(EntityManager* l_entityMgr)\n  :EntityBase(l_entityMgr), \n  m_spriteSheet(m_entityManager->GetContext()->m_textureManager),\n  m_jumpVelocity(250), m_hitpoints(5)\n{ m_name = \"Character\"; }\n```", "```cpp\nvoid Character::Move(const Direction& l_dir){\n  if (GetState() == EntityState::Dying){ return; }\n  m_spriteSheet.SetDirection(l_dir);\n  if (l_dir == Direction::Left){ Accelerate(-m_speed.x, 0); }\n  else { Accelerate(m_speed.x, 0); }\n  if (GetState() == EntityState::Idle){\n    SetState(EntityState::Walking);\n  }\n}\n```", "```cpp\nvoid Character::Jump(){\n  if (GetState() == EntityState::Dying || GetState() == EntityState::Jumping || GetState() == EntityState::Hurt)\n  {\n    return;\n  }\n  SetState(EntityState::Jumping);\n  AddVelocity(0, -m_jumpVelocity);\n}\n```", "```cpp\nvoid Character::Attack(){\n  if (GetState() == EntityState::Dying ||\n    GetState() == EntityState::Jumping ||\n    GetState() == EntityState::Hurt ||\n    GetState() == EntityState::Attacking)\n  {\n    return;\n  }\n  SetState(EntityState::Attacking);\n}\n```", "```cpp\nvoid Character::GetHurt(const int& l_damage){\n  if (GetState() == EntityState::Dying ||\n    GetState() == EntityState::Hurt)\n  {\n    return;\n  }\n  m_hitpoints = (m_hitpoints - l_damage > 0 ?\n    m_hitpoints - l_damage : 0);\n  if (m_hitpoints){ SetState(EntityState::Hurt); }\n  else { SetState(EntityState::Dying); }\n}\n```", "```cpp\nName Player\nSpritesheet Player.sheet\nHitpoints 5\nBoundingBox 20 26\nDamageBox -5 0 26 26\nSpeed 1024 128\nJumpVelocity 250\nMaxVelocity 200 1024\n```", "```cpp\nvoid Character::Load(const std::string& l_path){\n  std::ifstream file;\n  ...\n  while(std::getline(file,line)){\n    ...\n    std::string type;\n    keystream >> type;\n    if(type == \"Name\"){\n      keystream >> m_name;\n    } else if(type == \"Spritesheet\"){\n      std::string path;\n      keystream >> path;\n      m_spriteSheet.LoadSheet(\"media/SpriteSheets/\" + path);\n    } else if(type == \"Hitpoints\"){\n      keystream >> m_hitpoints;\n    } else if(type == \"BoundingBox\"){\n      sf::Vector2f boundingSize;\n      keystream >> boundingSize.x >> boundingSize.y;\n      SetSize(boundingSize.x, boundingSize.y);\n    } else if(type == \"DamageBox\"){\n      keystream >> m_attackAABBoffset.x >> m_attackAABBoffset.y \n        >> m_attackAABB.width >> m_attackAABB.height;\n    } else if(type == \"Speed\"){\n      keystream >> m_speed.x >> m_speed.y;\n    } else if(type == \"JumpVelocity\"){\n      keystream >> m_jumpVelocity;\n    } else if(type == \"MaxVelocity\"){\n      keystream >> m_maxVelocity.x >> m_maxVelocity.y;\n    } else {\n      std::cout << \"! Unknown type in character file: \"\n        << type << std::endl;\n    }\n  }\n  file.close();\n}\n```", "```cpp\nvoid Character::UpdateAttackAABB(){\n  m_attackAABB.left = \n    (m_spriteSheet.GetDirection() == Direction::Left ? \n    (m_AABB.left - m_attackAABB.width) - m_attackAABBoffset.x\n    : (m_AABB.left + m_AABB.width) + m_attackAABBoffset.x);\n  m_attackAABB.top = m_AABB.top + m_attackAABBoffset.y;\n}\n```", "```cpp\nvoid Character::Animate(){\n  EntityState state = GetState();\n\n  if(state == EntityState::Walking && m_spriteSheet.\n    GetCurrentAnim()->GetName() != \"Walk\")\n  {\n    m_spriteSheet.SetAnimation(\"Walk\",true,true);\n  } \n  else if(state == EntityState::Jumping && m_spriteSheet.\n    GetCurrentAnim()->GetName() != \"Jump\")\n  {\n    m_spriteSheet.SetAnimation(\"Jump\",true,false);\n  }\n  else if(state == EntityState::Attacking && m_spriteSheet.\n    GetCurrentAnim()->GetName() != \"Attack\")\n  {\n    m_spriteSheet.SetAnimation(\"Attack\",true,false);\n  } else if(state == EntityState::Hurt && m_spriteSheet.\n    GetCurrentAnim()->GetName() != \"Hurt\")\n  {\n    m_spriteSheet.SetAnimation(\"Hurt\",true,false);\n  }\n  else if(state == EntityState::Dying && m_spriteSheet.\n    GetCurrentAnim()->GetName() != \"Death\")\n  {\n    m_spriteSheet.SetAnimation(\"Death\",true,false);\n  }\n  else if(state == EntityState::Idle && m_spriteSheet.\n    GetCurrentAnim()->GetName() != \"Idle\")\n  {\n    m_spriteSheet.SetAnimation(\"Idle\",true,true);\n  }\n}\n```", "```cpp\nvoid Character::Update(float l_dT){\n  EntityBase::Update(l_dT);\n  if(m_attackAABB.width != 0 && m_attackAABB.height != 0){\n    UpdateAttackAABB();\n  }\n  if(GetState() != EntityState::Dying && GetState() !=\n    EntityState::Attacking && GetState() != EntityState::Hurt)\n  {\n    if(abs(m_velocity.y) >= 0.001f){\n      SetState(EntityState::Jumping);\n    } else if(abs(m_velocity.x) >= 0.1f){\n      SetState(EntityState::Walking);\n    } else {\n      SetState(EntityState::Idle);\n    }\n  } else if(GetState() == EntityState::Attacking ||\n    GetState() == EntityState::Hurt)\n  {\n    if(!m_spriteSheet.GetCurrentAnim()->IsPlaying()){\n      SetState(EntityState::Idle);\n    }\n  } else if(GetState() == EntityState::Dying){\n    if(!m_spriteSheet.GetCurrentAnim()->IsPlaying()){\n      m_entityManager->Remove(m_id);\n    }\n  }\n  Animate();\n  m_spriteSheet.Update(l_dT);\n  m_spriteSheet.SetSpritePosition(m_position);\n}\n```", "```cpp\nvoid Character::Draw(sf::RenderWindow* l_wind){\n    m_spriteSheet.Draw(l_wind);\n}\n```", "```cpp\nclass Player : public Character{\npublic:\n  Player(EntityManager* l_entityMgr);\n  ~Player();\n\n  void OnEntityCollision(EntityBase* l_collider, bool l_attack);\n  void React(EventDetails* l_details);\n};\n```", "```cpp\nPlayer::Player(EntityManager* l_entityMgr)\n  : Character(l_entityMgr)\n{\n  Load(\"Player.char\");\n  m_type = EntityType::Player;\n\n  EventManager* events = m_entityManager->\n    GetContext()->m_eventManager;\n  events->AddCallback<Player>(StateType::Game,\n    \"Player_MoveLeft\", &Player::React, this);\n  events->AddCallback<Player>(StateType::Game,\n    \"Player_MoveRight\", &Player::React, this);\n  events->AddCallback<Player>(StateType::Game,\n    \"Player_Jump\", &Player::React, this);\n  events->AddCallback<Player>(StateType::Game,\n    \"Player_Attack\", &Player::React, this);\n}\n```", "```cpp\nPlayer::~Player(){\n    EventManager* events = m_entityManager->GetContext()->m_eventManager;\n    events->RemoveCallback(GAME,\"Player_MoveLeft\");\n    events->RemoveCallback(GAME,\"Player_MoveRight\");\n    events->RemoveCallback(GAME,\"Player_Jump\");\n    events->RemoveCallback(GAME,\"Player_Attack\");\n}\n```", "```cpp\nvoid Player::OnEntityCollision(EntityBase* l_collider,\n  bool l_attack)\n{\n  if (m_state == EntityState::Dying){ return; }\n  if(l_attack){\n    if (m_state != EntityState::Attacking){ return; }\n    if (!m_spriteSheet.GetCurrentAnim()->IsInAction()){ return; }\n    if (l_collider->GetType() != EntityType::Enemy &&\n      l_collider->GetType() != EntityType::Player)\n    {\n      return;\n    }\n    Character* opponent = (Character*)l_collider;\n    opponent->GetHurt(1);\n    if(m_position.x > opponent->GetPosition().x){\n      opponent->AddVelocity(-32,0);\n    } else {\n      opponent->AddVelocity(32,0);\n    }\n  } else {\n    // Other behavior.\n  }\n}\n```", "```cpp\n#pragma once\n#include \"Character.h\"\n\nclass Enemy : public Character{\npublic:\n    Enemy(EntityManager* l_entityMgr);\n    ~Enemy();\n\n    void OnEntityCollision(EntityBase* l_collider, bool l_attack);\n    void Update(float l_dT);\nprivate:\n    sf::Vector2f m_destination;\n    bool m_hasDestination;\n};\n```", "```cpp\nEnemy::Enemy(EntityManager* l_entityMgr)\n  :Character(l_entityMgr), m_hasDestination(false)\n{\n  m_type = EntityType::Enemy;\n}\nEnemy::~Enemy(){}\n```", "```cpp\nvoid Enemy::OnEntityCollision(EntityBase* l_collider,\n  bool l_attack)\n{\n  if (m_state == EntityState::Dying){ return; }\n  if (l_attack){ return; }\n  if (l_collider->GetType() != EntityType::Player){ return; }\n  Character* player = (Character*)l_collider;\n  SetState(EntityState::Attacking);\n  player->GetHurt(1);\n  if(m_position.x > player->GetPosition().x){\n    player->AddVelocity(-m_speed.x,0);\n    m_spriteSheet.SetDirection(Direction::Left);\n  } else {\n    player->AddVelocity(m_speed.y,0);\n    m_spriteSheet.SetDirection(Direction::Right);\n  }\n}\n```", "```cpp\nvoid Enemy::Update(float l_dT){\n  Character::Update(l_dT);\n\n  if (m_hasDestination){\n    if (abs(m_destination.x - m_position.x) < 16){\n      m_hasDestination = false;\n      return;\n    }\n    if (m_destination.x - m_position.x > 0){\n      Move(Direction::Right);\n    } else { Move(Direction::Left); }\n    if (m_collidingOnX){ m_hasDestination = false; }\n    return;\n  }\n  int random = rand() % 1000 + 1;\n  if (random != 1000){ return; }\n  int newX = rand() % 65 + 0;\n  if (rand() % 2){ newX = -newX; }\n  m_destination.x = m_position.x + newX;\n  if (m_destination.x < 0){ m_destination.x = 0; }\n  m_hasDestination = true;\n}\n```", "```cpp\n} else if(type == \"PLAYER\"){\n  if (playerId != -1){ continue; }\n  // Set up the player position here.\n  playerId = entityMgr->Add(EntityType::Player);\n  if (playerId < 0){ continue; }\n  float playerX = 0; float playerY = 0;\n  keystream >> playerX >> playerY;\n  entityMgr->Find(playerId)->SetPosition(playerX,playerY);\n  m_playerStart = sf::Vector2f(playerX, playerY);\n} else if(type == \"ENEMY\"){\n  std::string enemyName;\n  keystream >> enemyName;\n  int enemyId = entityMgr->Add(EntityType::Enemy, enemyName);\n  if (enemyId < 0){ continue; }\n  float enemyX = 0; float enemyY = 0;\n  keystream >> enemyX >> enemyY;\n  entityMgr->Find(enemyId)->SetPosition(enemyX, enemyY);\n} ...\n```", "```cpp\nclass Map;\nstruct SharedContext{\n  SharedContext():\n    m_wind(nullptr),\n    m_eventManager(nullptr),\n    m_textureManager(nullptr),\n    m_entityManager(nullptr),\n    m_gameMap(nullptr){}\n\n  Window* m_wind;\n  EventManager* m_eventManager;\n  TextureManager* m_textureManager;\n  EntityManager* m_entityManager;\n  Map* m_gameMap;\n  DebugOverlay m_debugOverlay;\n};\n```", "```cpp\nclass Game{\npublic:\n    ...\nprivate:\n    ...\n    EntityManager m_entityManager;\n};\n```", "```cpp\nclass State_Game : public BaseState{\npublic:\n    ...\nprivate:\n    ...\n    Map* m_gameMap;\n};\n```", "```cpp\nvoid State_Game::OnCreate(){\n    ...\n    sf::Vector2u size = m_stateMgr->GetContext()->m_wind->GetWindowSize();\n    m_view.setSize(size.x,size.y);\n    m_view.setCenter(size.x/2,size.y/2);\n    m_view.zoom(0.6f);\n    m_stateMgr->GetContext()->m_wind->GetRenderWindow()->setView(m_view);\n\n    m_gameMap = new Map(m_stateMgr->GetContext(), this);\n    m_gameMap->LoadMap(\"media/Maps/map1.map\");\n}\n```", "```cpp\nvoid State_Game::OnDestroy(){\n    ...\n    delete m_gameMap;\n    m_gameMap = nullptr;\n}\n```", "```cpp\nvoid State_Game::Update(const sf::Time& l_time){\n  SharedContext* context = m_stateMgr->GetContext();\n  EntityBase* player = context->m_entityManager->Find(\"Player\");\n  if(!player){\n    std::cout << \"Respawning player...\" << std::endl;\n    context->m_entityManager->Add(EntityType::Player,\"Player\");\n    player = context->m_entityManager->Find(\"Player\");\n    player->SetPosition(m_gameMap->GetPlayerStart());\n  } else {\n    m_view.setCenter(player->GetPosition());\n    context->m_wind->GetRenderWindow()->setView(m_view);\n  }\n\n  sf::FloatRect viewSpace = context->m_wind->GetViewSpace();\n  if(viewSpace.left <= 0){\n    m_view.setCenter(viewSpace.width / 2,m_view.getCenter().y);\n    context->m_wind->GetRenderWindow()->setView(m_view);\n  } else if (viewSpace.left + viewSpace.width >\n    (m_gameMap->GetMapSize().x + 1) * Sheet::Tile_Size)\n  {\n    m_view.setCenter(((m_gameMap->GetMapSize().x + 1) *\n      Sheet::Tile_Size) - (viewSpace.width / 2),\n      m_view.getCenter().y);\n    context->m_wind->GetRenderWindow()->setView(m_view);\n  }\n\n  m_gameMap->Update(l_time.asSeconds());\n  m_stateMgr->GetContext()->\n    m_entityManager->Update(l_time.asSeconds());\n}\n```"]