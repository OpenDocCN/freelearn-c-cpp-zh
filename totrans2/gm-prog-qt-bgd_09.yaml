- en: Chapter 9. Qt Quick Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。Qt Quick基础
- en: '*In this chapter, you are going to be introduced to a technology called Qt
    Quick that allows us to implement resolution-independent user interfaces with
    lots of eye-candy, animations, and effects that can be combined with regular Qt
    code that implements the logic of the application. You will learn the basics of
    the QML declarative language that forms the foundation of Qt Quick. Using this
    language, you can define fancy graphics and animations, make use of particle engines,
    and structure your code using finite state machines. Pure QML code can be complemented
    with JavaScript or C++ logic in a manner similar to what you have learned in the
    previous chapter. By the end of this chapter, you should have enough knowledge
    to quickly implement fantastic 2D games with custom graphics, moving elements,
    and lots of visual special effects.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在本章中，你将了解到一种名为Qt Quick的技术，它允许我们实现具有许多视觉效果的分辨率无关的用户界面，这些效果可以与实现应用程序逻辑的常规Qt代码结合使用。你将学习QML表达性语言的基础，它是Qt
    Quick的基础。使用这种语言，你可以定义复杂的图形和动画，利用粒子引擎，并使用有限状态机来结构化你的代码。纯QML代码可以通过与JavaScript或C++逻辑类似的方式补充，正如你在上一章中学到的。到本章结束时，你应该具备足够的知识，可以快速实现具有自定义图形、移动元素和大量视觉特效的出色2D游戏。*'
- en: Fluid user interfaces
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流体用户界面
- en: So far, we have been looking at graphical user interfaces as a set of panels
    embedded one into another. This is well-reflected in the world of desktop utility
    programs composed of windows and subwindows containing mostly static content scattered
    throughout a large desktop area where the user can use a mouse pointer to move
    windows around or adjust their size. However, this design doesn't correspond well
    with modern user interfaces that often try to minimize the area they occupy (because
    of either a small display size like with embedded and mobile devices or to avoid
    obscuring the main display panel like in games), at the same time providing rich
    content with a lot of moving or dynamically resizing items. Such user interfaces
    are often called "fluid" to signify that they are not formed as a number of separate
    different screens, but rather contain dynamic content and layout where one screen
    fluently transforms into another. Part of Qt 5 is the Qt Quick (Qt User Interface
    Creation Kit) module, which provides a runtime to create rich applications with
    fluid user interfaces. It builds upon a two-dimensional hardware accelerated canvas
    that contains a hierarchy of interconnected items.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将图形用户界面视为一组嵌套在一起的面板。这在由窗口和子窗口组成的桌面实用程序世界中得到了很好的体现，这些窗口和子窗口主要包含静态内容，散布在广阔的桌面区域中，用户可以使用鼠标指针移动窗口或调整它们的大小。然而，这种设计与现代用户界面不太相符，现代用户界面通常试图最小化它们所占用的区域（因为嵌入式和移动设备的小屏幕尺寸，或者为了避免在游戏中遮挡主显示面板），同时提供丰富的内容，包含许多移动或动态调整大小的项目。这类用户界面通常被称为“流体”，以表明它们不是由多个不同的屏幕组成，而是包含动态内容和布局，其中一屏可以流畅地转换成另一屏。Qt
    5的一部分是Qt Quick（Qt用户界面创建工具包）模块，它提供了一个运行时来创建具有流体用户界面的丰富应用程序。它建立在包含层次结构中相互连接项的二维硬件加速画布之上。
- en: Declarative UI programming
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达性UI编程
- en: Although it is technically possible to use Qt Quick by writing C++ code, the
    module is accompanied by a dedicated programming language called **QML** (**Qt
    Modeling Language**). QML is an easy to read and understand declarative language
    that describes the world as a hierarchy of components that interact and relate
    to one another. It uses a JSON-like syntax and allows us to use imperative JavaScript
    expressions as well as dynamic property bindings. So, what is a declarative language,
    anyway?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上可以使用C++代码编写Qt Quick，但该模块附带了一种称为**QML**（**Qt建模语言**）的专用编程语言。QML是一种易于阅读和理解的表达性语言，它将世界描述为由相互交互和关联的组件组成的层次结构。它使用类似JSON的语法，并允许我们使用命令式JavaScript表达式以及动态属性绑定。那么，什么是表达性语言呢？
- en: Declarative programming is one of the programming paradigms that dictates that
    the program describes the logic of the computation without specifying how this
    result should be obtained. In contrast to imperative programming, where the logic
    is expressed as a list of explicit steps forming an algorithm that directly modifies
    the intermediate program state, a declarative approach focuses on what the ultimate
    result of the operation should be.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式编程是一种编程范式，它规定程序描述计算的逻辑，而不指定如何获得这种结果。与命令式编程相反，在命令式编程中，逻辑以一系列显式步骤的形式表达为一个算法，该算法直接修改中间程序状态，声明式方法侧重于操作最终结果应该是什么。
- en: We use QML by creating one or more QML documents where we define hierarchies
    of objects. Each document is composed of two sections.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个或多个 QML 文档来使用 QML，在这些文档中我们定义对象的层次结构。每个文档由两个部分组成。
- en: You can follow every example we explain in Qt Creator by creating a new Qt Quick
    UI project and placing the presented code in the QML file created for you. The
    details about using this project type will be described in a later section of
    this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建一个新的 Qt Quick UI 项目，并将展示的代码放入为你创建的 QML 文件中，来在 Qt Creator 中跟随我们解释的每个示例。关于使用此项目类型的详细信息将在本章的后续部分描述。
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you can''t see a **Qt Quick UI** project in the Creator''s wizard, you have
    to enable a plugin called `QmlProjectManager` by choosing the **About Plugins**
    entry from the Creator''s **Help** menu, then scrolling down to the **QtQuick**
    section, and making sure the **QmlProjectManager** entry is checked. If it is
    not, check it and restart Creator:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法在 Creator 的向导中看到 **Qt Quick UI** 项目，你必须通过从 Creator 的 **帮助** 菜单中选择 **关于插件**
    项来启用名为 `QmlProjectManager` 的插件，然后滚动到 **QtQuick** 部分，并确保 **QmlProjectManager**
    项被选中。如果没有选中，请选中它并重新启动 Creator：
- en: '![Declarative UI programming](img/8874OS_09_29.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![声明式 UI 编程](img/8874OS_09_29.jpg)'
- en: 'The first section contains a series of `import` statements that define the
    range of components that can be used in a particular document. In its simplest
    form, each statement consists of the `import` keyword followed by the module URI
    (name) and the module version to import. The following statement imports the `QtQuick`
    module in version 2.1:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个部分包含一系列 `import` 语句，这些语句定义了可以在特定文档中使用的组件范围。在其最简单的形式中，每个语句由 `import` 关键字后跟要导入的模块
    URI（名称）和模块版本组成。以下语句导入了版本 2.1 的 `QtQuick` 模块：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second section contains a definition of a hierarchy of objects. Each object
    declaration consists of two parts. First, you have to specify the type of the
    object and then follow it with the detailed definition enclosed in braces. Since
    the detailed definition can be empty, the simplest object declaration is similar
    to the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个部分包含一个对象层次结构的定义。每个对象声明由两部分组成。首先，你必须指定对象类型，然后跟随着用大括号括起来的详细定义。由于详细定义可以是空的，因此最简单的对象声明类似于以下内容：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This declares an instance of the `Item` element, which is the most basic Qt
    Quick element and represents an abstract item of the user interface without any
    visual appearance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个 `Item` 元素的实例，这是最基础的 Qt Quick 元素，它代表用户界面中的一个抽象项，没有任何视觉外观。
- en: Element properties
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素属性
- en: 'Each element type in QML defines a number of properties. Values for these properties
    can be set as part of the detailed definition of an object. The `Item` type brings
    a number of properties for specifying the geometry of an item:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: QML 中的每个元素类型都定义了一组属性。这些属性的值可以作为对象详细定义的一部分来设置。`Item` 类型提供了一些属性来指定项的几何形状：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Item` is a very interesting and useful element, but since it is totally transparent,
    we will now focus on its descendant type that draws a filled rectangle. This type
    is called `Rectangle`. It has a number of additional properties, among them, the
    `color` property for specifying the fill color of the rectangle. To define a red
    square, we could write the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item` 是一个非常有趣和有用的元素，但由于它是完全透明的，我们将现在关注其子类型，该子类型绘制一个填充矩形。这种类型被称为 `Rectangle`。它有许多额外的属性，其中之一是用于指定矩形填充颜色的
    `color` 属性。为了定义一个红色方块，我们可以编写以下代码：'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The problem with this code is that if we ever decide to change the size of
    the square, we will have to update values for the two properties separately. However,
    we can use the power of the declarative approach and specify one of the properties
    as a relation to the other properties:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于，如果我们决定更改方块的大小，我们必须分别更新两个属性的值。然而，我们可以利用声明式方法的力量，将其中一个属性指定为与其他属性的关系：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is called **property** **binding**. It differs from a regular value assignment
    and binds the value of height to the value of width. Whenever width changes, height
    will reflect that change in its own value.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**属性绑定**。它与常规的值赋值不同，将高度值绑定到宽度值。每当宽度发生变化时，高度值会反映这种变化。
- en: 'Note that the order of statements in the definition does not matter as you
    declare relations between properties. The following declaration is semantically
    identical to the previous one:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在定义中语句的顺序并不重要，因为你在声明属性之间的关系。以下声明与上一个声明在语义上是相同的：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can bind a property not only to a value of another property, but also to
    any JavaScript statement that returns a value. For example, we can declare rectangle
    color to be dependent on the proportions between the width and the height of the
    element by using a ternary conditional expression operator:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以绑定一个属性到另一个属性的值，还可以绑定到任何返回值的JavaScript语句。例如，我们可以通过使用三元条件表达式运算符来声明矩形颜色取决于元素的宽度和高度的比例：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Whenever `width` or `height` of the object changes, the statement bound to the
    `color` property will be re-evaluated and if `width` of the rectangle is larger
    than its `height`, the rectangle will become `red`; otherwise, it will be `blue`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象的`width`或`height`发生变化时，绑定到`color`属性的语句将被重新评估，如果矩形的`width`大于其`height`，则矩形将变为红色；否则，它将是蓝色。
- en: 'Property binding statements can also contain function calls. We can extend
    the `color` declaration to use a different color if the rectangle is a square
    by using a custom function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定语句也可以包含函数调用。我们可以扩展`color`声明，如果矩形是正方形，则使用自定义函数来使用不同的颜色：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'QML does its best to determine when the function value may change, but it is
    not omnipotent. For our last function, it can easily determine that the function
    result depends on the values of the `width` and `height` properties, so it will
    re-evaluate the binding if either of the two values change. However, in some cases,
    it can''t know that a function might return a different value next time it is
    called, and in such situations, the statement will not be re-evaluated. Consider
    the following function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: QML尽力确定函数值何时可能发生变化，但它并非万能。对于我们的最后一个函数，它可以很容易地确定函数结果依赖于`width`和`height`属性的值，因此如果这两个值中的任何一个发生变化，它将重新评估绑定。然而，在某些情况下，它无法知道函数在下一次调用时可能会返回不同的值，在这种情况下，该语句将不会被重新评估。考虑以下函数：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Binding the `color` property to the result of that function will not work properly.
    QML will only call this function once when the object is initialized, and it will
    never call it again. This is because it has no way of knowing that the value of
    this function depends on the current time. Later, we will see how to overcome
    this with a bit of imperative code and a timer.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将`color`属性绑定到该函数的结果将不会正常工作。QML仅在对象初始化时调用此函数一次，并且它永远不会再次调用。这是因为它无法知道该函数的值依赖于当前时间。稍后，我们将看到如何通过一点命令式代码和一个计时器来克服这个问题。
- en: Group properties
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组属性
- en: 'The `Rectangle` element allows us to define not only the fill color but also
    the outline size and color. This is done by using the `border.width` and `border.color`
    properties. You can see they have a common prefix followed by a dot. This means
    these properties are subproperties of a property group `border`. There are two
    ways to bind values to these properties. The first approach is to use the dot
    notation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle`元素不仅允许我们定义填充颜色，还可以定义轮廓大小和颜色。这是通过使用`border.width`和`border.color`属性来完成的。你可以看到它们有一个共同的前缀，后面跟着一个点。这意味着这些属性是属性组`border`的子属性。有两种方法可以将值绑定到这些属性。第一种方法是使用点表示法：'
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'An alternative approach, which is especially useful if you want to set a large
    number of subproperties in a single group, is to use brackets to enclose definitions
    in a group:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，如果你想在单个组中设置大量子属性，特别有用，是使用括号来包围组中的定义：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Object hierarchies
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象层次结构
- en: 'We said that QML is about defining object hierarchies. You do this in the simplest
    way possible–by putting one object declaration into another object''s declaration.
    To create a button-like object containing a rounded frame with some text inside,
    we''ll combine a `Rectangle` item with a `Text` item:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过，QML是关于定义对象层次结构的。你可以以最简单的方式做到这一点——通过将一个对象声明放入另一个对象的声明中。为了创建一个包含圆角框架和一些文本的按钮样式的对象，我们将结合一个`Rectangle`元素和一个`Text`元素：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can use a semicolon instead of newlines to separate statements in QML in
    order to have a more compact object definition at the cost of decreased readability.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用分号而不是换行符来在 QML 中分隔语句，以获得更紧凑的对象定义，但会牺牲可读性。
- en: 'Running this code produces a result similar to the following diagram:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生与以下图示类似的结果：
- en: '![Object hierarchies](img/8874OS_09_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![对象层次结构](img/8874OS_09_01.jpg)'
- en: As we can see, it does not look good–the frame is not big enough to hold the
    text and so it flows outside the frame. Moreover, the text is positioned incorrectly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这看起来并不好——框架不够大，无法容纳文本，因此文本流出了框架之外。此外，文本的位置也不正确。
- en: Unlike widgets where a child widget is clipped to its parent's geometry, Qt
    Quick items can be positioned outside their parents.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与子小部件被剪裁到其父几何形状的 widgets 不同，Qt Quick 项目可以定位在其父元素之外。
- en: Since we didn't specify the *x* and *y* coordinates of the text, they are set
    to their default value, which is `0`. As a result, the text is pinned to the top-left
    corner of the frame and flows outside the right edge of the frame.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有指定文本的 *x* 和 *y* 坐标，它们被设置为默认值，即 `0`。因此，文本被固定在框架的左上角，并流出了框架的右边缘。
- en: 'To correct this behavior, we can bind the width of the frame to the width of
    the text. To do this in the property binding for the rectangle width, we have
    to specify that we want to use the width of the text object. QML provides a pseudo-property
    called `id` to allow the programmer to name objects. Let''s provide an ID for
    the `Text` element and bind the width of the outside object to the width of the
    text, and also do the same for the height. At the same time, let''s reposition
    the text a little to provide padding for the four pixels between the frame and
    the text itself:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正这种行为，我们可以将框架的宽度绑定到文本的宽度。为此，在矩形宽度的属性绑定中，我们必须指定我们想要使用文本对象的宽度。QML 提供了一个名为 `id`
    的伪属性，允许程序员命名对象。让我们为 `Text` 元素提供一个 ID，并将外部对象的宽度绑定到文本的宽度，同时也要对高度做同样的绑定。同时，让我们稍微重新定位文本，为框架和文本本身之间的四个像素提供填充：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see in the following image, such code works, but it is still problematic:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图像所示，这样的代码可以工作，但仍然存在问题：
- en: '![Object hierarchies](img/8874OS_09_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![对象层次结构](img/8874OS_09_02.jpg)'
- en: 'If you set empty text to the internal element, the rectangle width and height
    will drop to `8`, which does not look good. It will also look bad if the text
    is very long:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将空文本设置到内部元素中，矩形宽度和高度将降至 `8`，这看起来并不好。如果文本非常长，看起来也会很糟糕：
- en: '![Object hierarchies](img/8874OS_09_03.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![对象层次结构](img/8874OS_09_03.jpg)'
- en: 'Let''s complicate matters even more and add an icon to the button by adding
    another child element to the rectangle. Qt Quick provides an `Image` type to display
    images, so let''s use it to position our icon on the left side of the text:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步复杂化问题，通过向矩形添加另一个子元素来给按钮添加一个图标。Qt Quick 提供了一个 `Image` 类型来显示图像，所以让我们用它来将图标定位在文本的左侧：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this code, we used the `Math.max` function available in JavaScript to calculate
    the height of the button, and we modified definitions of the *y* properties of
    the internal objects to center them vertically in the button. The source property
    of `Image` contains the URL of a file containing the image to be shown in the
    item.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用了 JavaScript 中可用的 `Math.max` 函数来计算按钮的高度，并修改了内部对象的 *y* 属性的定义，以在按钮中垂直居中。`Image`
    的源属性包含要显示在项目中的图像的文件 URL。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The URL can point not only to a local file, but also to a remote HTTP resource.
    In such an event, if the remote machine is reachable, the file will be fetched
    from the remote server automatically.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: URL 可以指向本地文件，也可以指向远程 HTTP 资源。在这种情况下，如果远程机器可访问，文件将自动从远程服务器获取。
- en: 'The result of the code can be seen in the following image:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的结果可以在以下图像中看到：
- en: '![Object hierarchies](img/8874OS_09_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![对象层次结构](img/8874OS_09_04.jpg)'
- en: 'Calculating the positions of each internal element as well as the size of the
    button frame is becoming complicated. Fortunately, we don''t have to do it since
    Qt Quick provides a much better way of managing item geometry by attaching certain
    points of some objects to points of another object. These points are called anchor
    lines. The following anchor lines are available to each Qt Quick item:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 计算每个内部元素的位置以及按钮框架的大小变得越来越复杂。幸运的是，我们不必这样做，因为 Qt Quick 通过将某些对象的某些点附着到另一个对象的点上，提供了一种更好的管理项目几何形状的方法。这些点被称为锚线。以下锚线对每个
    Qt Quick 项目都是可用的：
- en: '![Object hierarchies](img/8874OS_09_05.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![对象层次结构](img/8874OS_09_05.jpg)'
- en: 'You can establish bindings between anchor lines to manage relative positioning
    of items. Each anchor line is represented by two properties–one that can be bound
    to something and another to bind from. Anchors to bind to are regular properties
    of the object. They can serve as binding arguments for properties defined in an
    anchors property group. Therefore, to bind the "left" anchor of the current object
    to the "right" anchor of the object `otherObject`, one would write:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以建立锚点线之间的绑定来管理项目的相对位置。每个锚点线由两个属性表示——一个可以绑定到某物，另一个可以绑定从某物绑定。要绑定的锚点是对象的常规属性。它们可以作为在锚点属性组中定义的属性的绑定参数。因此，要将当前对象的
    "left" 锚点绑定到 `otherObject` 对象的 "right" 锚点，可以编写如下代码：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In addition to specifying an arbitrary number of anchor bindings, we can also
    set margins for each of the anchors (or for all of them at once) to offset the
    two bound anchor lines. Using anchors, we can simplify the previous button definition:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定任意数量的锚点绑定之外，我们还可以为每个锚点（或所有锚点）设置边距，以偏移两个绑定的锚点线。使用锚点，我们可以简化之前的按钮定义：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see the `button` ID is not used anymore. Instead, we use parent, which
    is a property that always points to the item's parent.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `button` ID 已经不再使用了。取而代之的是，我们使用 `parent`，这是一个始终指向项目父项的属性。
- en: Time for action – creating a button component
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建按钮组件
- en: As an exercise, let's try to use what you've learned so far to create a more
    complete and better working button component. The button is to have a rounded
    shape with a nice background and should hold definable text and an icon. The button
    should look good for different texts and icons.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，让我们尝试使用到目前为止所学的内容来创建一个更完整且更好的按钮组件。按钮应具有圆角形状和漂亮的背景，并应包含可定义的文本和图标。按钮应适用于不同的文本和图标。
- en: 'Start by creating a new project in Qt Creator. Choose **Qt Quick UI** as the
    project type. When asked for the component set, choose the lowest available version
    of Qt Quick:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 Qt Creator 中创建一个新的项目。选择 **Qt Quick UI** 作为项目类型。当被问及组件集时，选择 Qt Quick 的最低可用版本：
- en: '![Time for action – creating a button component](img/8874OS_09_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 创建按钮组件](img/8874OS_09_06.jpg)'
- en: At this point, you should end up with a project containing two files–one with
    a QML project extension, which is your project management file, and the other
    with the QML extension, which is your main user interface file. You can see that
    both files contain QML definitions. That is because Qt Creator manages Qt Quick
    projects using QML itself (you'll notice it imports the `QmlProject` module).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该有一个包含两个文件的项目——一个带有 QML 项目扩展名的文件，这是你的项目管理文件，另一个带有 QML 扩展名的文件，这是你的主要用户界面文件。你可以看到这两个文件都包含
    QML 定义。这是因为 Qt Creator 使用 QML 本身来管理 Qt Quick 项目（你会注意到它导入了 `QmlProject` 模块）。
- en: The QML document that was created for us contains a "Hello World" example code,
    which we can use as a starting point in our Qt Quick experiments. If you go to
    the **Projects** pane and look at the **Run Configuration** for the project, you
    will notice that it uses something called QML Scene to run your project. This
    configuration invokes an external application called `qmlscene` that is able to
    load and display an arbitrary QML document. If you run the example code, you should
    see a white window with some text centered in it. If you click anywhere in the
    window, the application will close.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们创建的 QML 文档包含一个 "Hello World" 示例代码，我们可以将其作为 Qt Quick 实验的起点。如果你转到 **项目** 面板并查看项目的
    **运行配置**，你会注意到它使用了一个名为 QML Scene 的东西来运行你的项目。此配置调用一个名为 `qmlscene` 的外部应用程序，该程序能够加载并显示任意
    QML 文档。如果你运行示例代码，你应该看到一个带有一些居中文本的白色窗口。如果你在窗口的任何地方点击，应用程序将关闭。
- en: Let's start by creating the button frame. Replace the `Text` item with a `Rectangle`
    item. You can see that the text is centered in the window by using a `centerIn`
    anchor binding that we didn't mention before. This is one of two special anchors
    that are provided for convenience to avoid having to write too much code. Using
    `centerIn` is equivalent to setting both `horizontalCenter` and `verticalCenter`.
    The other convenience binding is `fill`, which makes one item occupy the whole
    area of another item (similar to setting the left, right, top, and bottom anchors
    to their respective anchor lines in the destination item).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建按钮框架。将`Text`项目替换为`Rectangle`项目。你可以看到，通过使用我们之前未提及的`centerIn`锚点绑定，文本被居中显示在窗口中。这是两个特殊锚点之一，提供便利以避免编写过多的代码。使用`centerIn`相当于设置`horizontalCenter`和`verticalCenter`。另一个便利绑定是`fill`，它使一个项目占据另一个项目的整个区域（类似于将左、右、上、下锚点设置为目的地项目中的相应锚点线）。
- en: 'Let''s give a basic look and feel to the button panel by setting some of its
    basic properties. This time, instead of setting a solid color for the button,
    we will declare the background to be a linear gradient. Replace the `Text` definition
    with the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过设置一些基本属性来给按钮面板一个基本的样式。这次，我们不会为按钮设置纯色，而是声明背景为线性渐变。将`Text`定义替换为以下代码：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After running the project, you should see a result similar to the following
    image:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目后，你应该看到以下类似的结果图像：
- en: '![Time for action – creating a button component](img/8874OS_09_07.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![执行动作 – 创建按钮组件](img/8874OS_09_07.jpg)'
- en: '*What just happened?*'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We bound a `Gradient` element to the gradient property and defined two `GradientStop`
    elements as its children, where we specified two colors to blend between. `Gradient`
    does not inherit from `Item` and thus is not a visual Qt Quick element. Instead,
    it is just an object that serves as a data holder for the gradient definition.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个`Gradient`元素绑定到渐变属性，并定义了两个`GradientStop`元素作为其子元素，其中我们指定了两种颜色进行混合。`Gradient`不继承自`Item`，因此不是一个视觉Qt
    Quick元素。相反，它只是一个作为渐变定义数据持有者的对象。
- en: The `Item` type has a property called `children` that contains a list of visual
    children (`Item` instances) of an item and another property called `resources`,
    which contains a list of non-visual objects (such as `Gradient` or `GradientStop`)
    for an item. Normally, you don't need to use these properties when adding visual
    or non-visual objects to an item as the item will automatically assign child objects
    to appropriate properties. Note that in our code, the `Gradient` object is not
    a child object of the `Rectangle`; it is just assigned to its `gradient` property.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item`类型有一个名为`children`的属性，包含一个项目视觉子项（`Item`实例）的列表，还有一个名为`resources`的属性，包含一个项目非视觉对象（如`Gradient`或`GradientStop`）的列表。通常，在向项目添加视觉或非视觉对象时，你不需要使用这些属性，因为项目会自动将子对象分配到适当的属性中。请注意，在我们的代码中，`Gradient`对象不是`Rectangle`的子对象；它只是被分配到其`gradient`属性。'
- en: Time for action – adding button content
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行动作 – 添加按钮内容
- en: 'The next step is to add text and an icon to the button. We will do this by
    using another item type called `Row`, as shown:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是向按钮添加文本和图标。我们将通过使用另一种项目类型`Row`来完成此操作，如下所示：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You''ll get the following output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![Time for action – adding button content](img/8874OS_09_08.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![执行动作 – 添加按钮内容](img/8874OS_09_08.jpg)'
- en: '*What just happened?*'
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: '`Row` is one out of four positioner types (the others being `Column`, `Grid`,
    and `Flow`) that spreads its children in a horizontal row. It makes it possible
    to position a series of items without using anchors. `Row` has a spacing property
    that dictates how much space to leave between items.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Row`是四种位置器类型之一（其他为`Column`、`Grid`和`Flow`），它将子项水平展开。这使得在不使用锚点的情况下定位一系列项目成为可能。`Row`有一个间距属性，用于指定项目之间应留多少空间。'
- en: Time for action – sizing the button properly
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行动作 – 正确设置按钮大小
- en: 'Our current panel definition still doesn''t behave well when it comes to sizing
    the button. If the button content is very small (for example, the icon doesn''t
    exist or the text is very short), the button will not look good. Typically, push
    buttons enforce a minimum size–if the content is smaller than a specified size,
    the button will be expanded to the minimum size allowed. Another problem is that
    the user might want to override the width or height of the item. In such cases,
    the content of the button should not overflow past the border of the button. Let''s
    fix these two issues by replacing the `width` and `height` property bindings with
    the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的面板定义在调整按钮大小时仍然表现不佳。如果按钮内容非常小（例如，图标不存在或文本非常短），按钮看起来将不会很好。通常，按钮强制执行最小尺寸–如果内容小于指定的尺寸，按钮将扩展到允许的最小尺寸。另一个问题是用户可能想要覆盖项的宽度和高度。在这种情况下，按钮的内容不应超出按钮的边界。让我们通过用以下代码替换`width`和`height`属性绑定来修复这两个问题：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*What just happened?*'
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `implicitWidth` and `implicitHeight` properties can contain the desired
    size the item wants to have. It's a direct equivalent of `sizeHint()` from the
    widget world. By using these two properties instead of `width` and `height` (which
    are bound to `implicitWidth` and `implicitHeight` by default), we allow the user
    of our component to override those implicit values. When this happens and the
    user does not set the width or height big enough to contain the icon and text
    of the button, we prevent the content from crossing the boundaries of the parent
    item by setting the `clip` property to `true`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`implicitWidth`和`implicitHeight`属性可以包含项目希望拥有的所需大小。它是从小部件世界中的`sizeHint()`的直接等价物。通过使用这两个属性而不是`width`和`height`（默认情况下它们绑定到`implicitWidth`和`implicitHeight`），我们允许组件的使用者覆盖这些隐式值。当这种情况发生且用户没有设置足够宽或高以包含图标和按钮文本时，我们通过将`clip`属性设置为`true`来防止内容超出父项的边界。'
- en: Time for action – making the button a reusable component
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 将按钮制作成可重用组件
- en: So far, we have been working on a single button. Adding another button by copying
    the code, changing the identifiers of all components, and setting different bindings
    to properties are very tedious tasks. Instead, we can make our button item a real
    component, that is, a new QML type that can be instantiated on demand as many
    times as required.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理单个按钮。通过复制代码、更改所有组件的标识符以及将不同的绑定设置到属性上，添加另一个按钮是非常繁琐的任务。相反，我们可以将我们的按钮项制作成一个真正的组件，即一个新的QML类型，可以根据需要实例化，所需次数不限。
- en: 'First, position the text cursor right before the bracket opening of the definition
    of the button and press *Alt* + *Enter* on the keyboard to open the refactoring
    menu, like in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将文本光标定位在按钮定义的大括号开括号之前，然后在键盘上按*Alt* + *Enter*以打开重构菜单，如下截图所示：
- en: '![Time for action – making the button a reusable component](img/8874OS_09_09.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 将按钮制作成可重用组件](img/8874OS_09_09.jpg)'
- en: 'From the menu, choose **Move Component into Separate File**. In the popup,
    type in a name for the new type (for example, `Button`) and accept the dialog
    by clicking on the **OK** button:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从菜单中选择**将组件移动到单独的文件**。在弹出的对话框中，输入新类型的名称（例如，`按钮`）并通过点击**确定**按钮接受对话框：
- en: '![Time for action – making the button a reusable component](img/8874OS_09_10.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 将按钮制作成可重用组件](img/8874OS_09_10.jpg)'
- en: '*What just happened?*'
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'You can see that we have a new file called `Button.qml` in the project, which
    contains everything the button item used to have. The main file was simplified
    to something similar the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到项目中有一个名为`Button.qml`的新文件，它包含按钮项曾经拥有的所有内容。主文件被简化为以下类似的内容：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`Button` has become a component–a definition of a new type of element that
    can be used the same way as element types imported into QML. Remember that QML
    component names as well as names of files representing them need to begin with
    a capital letter! If you name a file "button.qml" instead of "Button.qml", then
    you will not be able to use "Button" as a component name, and trying to use "button"
    instead will result in an error message. This works both ways–every QML file starting
    with a capital letter can be treated as a component definition. We will talk more
    about components later.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button` 已经成为一个组件——一个新类型元素的定义，它可以像导入 QML 的元素类型一样使用。记住，QML 组件名称以及代表它们的文件名称需要以大写字母开头！如果你将文件命名为
    "button.qml" 而不是 "Button.qml"，那么你将无法使用 "Button" 作为组件名称，尝试使用 "button" 代替将会导致错误信息。这同样适用于两种情况——每个以大写字母开头的
    QML 文件都可以被视为组件定义。我们稍后会更多地讨论组件。'
- en: Event handlers
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理器
- en: Qt Quick is meant to be used for creating user interfaces that are highly interactive.
    It offers a number of elements for taking input events from the user.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 旨在用于创建高度交互的用户界面。它提供了一些元素，用于从用户那里获取输入事件。
- en: Mouse input
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鼠标输入
- en: The simplest of all of them is `MouseArea`. It defines a transparent rectangle
    that exposes a number of properties and signals related to mouse input. Commonly
    used signals include clicked, pressed, and released. Let's do a couple of exercises
    to see how the element can be used.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些中，最简单的是 `MouseArea`。它定义了一个透明的矩形，暴露了与鼠标输入相关的多个属性和信号。常用的信号包括 clicked、pressed
    和 released。让我们做一些练习，看看这个元素如何使用。
- en: Time for action – making the button clickable
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始行动——使按钮可点击
- en: Thus far, our component only looks like a button. The next task is to make it
    respond to mouse input. As you may have guessed, this is done by using the `MouseArea`
    item.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的组件看起来就像一个按钮。接下来的任务是让它能够响应鼠标输入。正如你可能猜到的，这是通过使用 `MouseArea` 元素来实现的。
- en: 'Add a `MouseArea` child item to the button and use anchors to make it fill
    the whole area of the button. Call the element `buttonMouseArea`. Put the following
    code in the body of the item:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个 `MouseArea` 子项添加到按钮中，并使用锚点使其填充按钮的整个区域。将此元素命名为 `buttonMouseArea`。将以下代码放入项的主体中：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In addition to this, set the following declaration in the button object just
    after its ID is declared:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，在按钮对象的 ID 声明之后设置以下声明：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To test the modification, add the following code at the end of the button object
    definition, just before the closing bracket:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试修改，在按钮对象定义的末尾添加以下代码，就在闭合括号之前：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then, run the program and click on the button. You'll see your message printed
    to the Creator's console. Congratulations!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行程序并点击按钮。你会在 Creator 的控制台中看到你的消息被打印出来。恭喜你！
- en: '*What just happened?*'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: With a signal `clicked()` statement, we declared that the button object emits
    a signal called clicked. With the `MouseArea` item, we defined a rectangular area
    (covering the whole button) that reacts to mouse events. Then, we defined `onClicked`,
    which is a signal handler. For every signal an object has, a script can be bound
    to a handler named like the signal and prefixed with "on"; hence, for the clicked
    signal, the handler is called `onClicked` and for `valueChanged` it is called
    `onValueChanged`. In this particular case, we have two handlers defined–one for
    the button where we write a simple statement to the console, and the other for
    the `MouseArea` element where we call the button's signal function effectively
    emitting that signal.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `clicked()` 信号语句，我们声明按钮对象会发出一个名为 clicked 的信号。通过 `MouseArea` 元素，我们定义了一个矩形区域（覆盖整个按钮），该区域会响应鼠标事件。然后，我们定义了
    `onClicked`，这是一个信号处理器。对于对象拥有的每个信号，都可以将一个脚本绑定到以信号名命名并以 "on" 为前缀的处理程序；因此，对于 clicked
    信号，处理程序被命名为 `onClicked`，而对于 `valueChanged`，它被命名为 `onValueChanged`。在这种情况下，我们定义了两个处理程序——一个用于按钮，我们在控制台写入一个简单的语句，另一个用于
    `MouseArea` 元素，我们调用按钮的信号函数，从而有效地发出该信号。
- en: '`MouseArea` has even more features, so now let''s try putting them to the right
    use to make our button more feature-rich.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`MouseArea` 有更多功能，所以现在让我们尝试正确使用它们，使我们的按钮功能更丰富。'
- en: Time for action – visualizing button states
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始行动——可视化按钮状态
- en: 'Currently, there is no visual reaction to clicking on the button. In the real
    world, the button has some depth and when you push it and look at it from above,
    its contents seems to shift a little toward the right and downward. Let''s mimic
    this behavior by making use of the pressed property `MouseArea` has, which denotes
    whether the mouse button is currently being pressed (note that the pressed property
    is different from the pressed signal that was mentioned earlier). The content
    of the button is represented by the `Row` element, so add the following statements
    inside its definition:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，点击按钮没有视觉反应。在现实世界中，按钮有一定的深度，当你按下它并从上方看时，其内容似乎会稍微向右和向下移动。让我们通过利用`MouseArea`具有的按下属性来模拟这种行为，该属性表示鼠标按钮是否当前被按下（注意，按下属性与前面提到的按下信号不同）。按钮的内容由`Row`元素表示，因此在其定义内添加以下语句：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can also make the text change color when the mouse cursor hovers over the
    button. For this, we have to do two things. First, let''s enable receiving hover
    events on the `MouseArea` by settings its `hoverEnabled` property:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使文本在鼠标光标悬停在按钮上时改变颜色。为此，我们必须做两件事。首先，让我们通过设置`hoverEnabled`属性来启用`MouseArea`接收悬停事件：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When this property is set, `MouseArea` will be setting its `containsMouse`
    property to `true` whenever it detects the mouse cursor over its own area. We
    can use this value to set the text color:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当此属性被设置时，`MouseArea`将在检测到鼠标光标在其自身区域上方时，将它的`containsMouse`属性设置为`true`。我们可以使用这个值来设置文本颜色：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*What just happened?*'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'In the last exercise, we learned to use some properties and signals from `MouseArea`
    to make the button component more interactive. However, the element is much richer
    in features. In particular, if hover events are enabled, you can get the current
    mouse position in the item''s local coordinate system through the `mouseX` and
    `mouseY` properties that return values. The cursor position can also be reported
    by handling the `positionChanged` signal. Speaking of signals, most `MouseArea`
    signals carry a `MouseEvent` object as their argument. This argument is called
    `mouse` and contains useful information about the current state of the mouse,
    including its position and buttons currently pressed:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们学习了如何使用`MouseArea`的一些属性和信号来使按钮组件更加交互式。然而，这个元素的功能要丰富得多。特别是，如果启用了悬停事件，你可以通过返回值的`mouseX`和`mouseY`属性在项目的局部坐标系中获取当前鼠标位置。通过处理`positionChanged`信号也可以报告光标位置。说到信号，大多数`MouseArea`信号都携带一个`MouseEvent`对象作为它们的参数。这个参数被称为`mouse`，并包含有关鼠标当前状态的有用信息，包括其位置和当前按下的按钮：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Time for action – notifying the environment about button states
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 通知环境按钮状态
- en: We have added some code to make the button look more natural by changing its
    visual aspects. Now, let's extend the button programming interface so that developers
    can use more features of the button.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一些代码，通过改变其视觉外观使按钮看起来更自然。现在，让我们扩展按钮编程接口，以便开发者可以使用更多按钮功能。
- en: 'The first thing we can do is make button colors definable by introducing some
    new properties for the button. Let''s put the highlighted code at the beginning
    of the button component definition:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一件事是为按钮引入一些新的属性，使其颜色可定义。让我们将高亮代码放在按钮组件定义的开始部分：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we''ll use the new definitions for the background gradient:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用新的背景渐变定义：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now for the text color:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于文本颜色：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Also, please notice that we used the `pressed` property of `MouseArea` to detect
    whether a mouse button is currently being pressed on the area. We can equip our
    button with a similar property. Add the following code to the `Button` component:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们使用了`MouseArea`的`pressed`属性来检测当前是否在区域上按下鼠标按钮。我们可以给我们的按钮配备一个类似的属性。将以下代码添加到`Button`组件中：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*What just happened?*'
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: The first set of changes introduced four new properties defining four colors
    that we later used in statements defining gradient and text colors for the button.
    In QML, you can define new properties for objects with the `property` keyword.
    The keyword should be followed by the property type and property name. QML understands
    many property types, the most common being int, real, string, font, and color.
    Property definitions can contain an optional default value for the property preceded
    with a colon. The situation is different with the pressed property definition.
    You can see that for the property type, the definition contains the word alias.
    It is not a property type, but rather an indicator that the property is really
    an alias to another property–each time the pressed property of the button is accessed,
    the value of the `buttonMouseArea.pressed` property is returned, and every time
    the property is changed, it is the mouse area's property that really gets changed.
    With a regular property declaration, you can provide any valid expression as the
    default value because the expression is bound to the property. With a property
    alias, it is different–the value is mandatory and has to be pointing to an existing
    property of the same or an other object. You can treat property aliases in a similar
    way as references in C++.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组更改引入了四个新属性，定义了四种颜色，我们后来在定义按钮渐变和文本颜色时使用了这些颜色。在QML中，你可以使用`property`关键字为对象定义新属性。关键字后面应跟属性类型和属性名称。QML理解许多属性类型，最常见的是int、real、string、font和color。属性定义可以包含一个可选的默认值，该值以冒号开头。对于`pressed`属性定义，情况则不同。对于属性类型，定义中包含单词alias。它不是一个属性类型，而是一个指示符，表示该属性实际上是另一个属性的别名——每次访问按钮的`pressed`属性时，都会返回`buttonMouseArea.pressed`属性的值，每次属性值改变时，实际上是鼠标区域的属性被真正改变。使用常规属性声明时，你可以提供任何有效的表达式作为默认值，因为表达式绑定到属性上。使用属性别名时，情况则不同——值是强制性的，并且必须指向相同或另一个对象的现有属性。你可以将属性别名视为C++中的引用。
- en: 'Consider the following two definitions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个定义：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At first glance, they are similar as they point to the same property and therefore,
    the values returned for the properties are the same. However, the properties are
    really very different, which becomes apparent if you try to modify their values:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，它们很相似，因为它们指向相同的属性，因此返回的属性值是相同的。然而，这些属性实际上非常不同，如果你尝试修改它们的值，这一点就会变得明显：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first property actually has an expression bound to it, so assigning `7`
    to `foo` simply releases the binding and assigns the value `7` to the `foo` property,
    leaving `someobject.prop` with its original value. The second statement, however,
    acts like a C++ reference; therefore, assigning a new value applies the modification
    to the someobject.prop property the alias is really pointing to.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性实际上有一个表达式绑定到它，所以将`7`赋值给`foo`只是释放了绑定，并将值`7`赋给`foo`属性，而`someobject.prop`保持其原始值。然而，第二个语句却像C++引用一样操作；因此，赋值新值将修改别名真正指向的`someobject.prop`属性。
- en: 'Speaking of properties, there is an easy way to react when a property value
    is modified. For each existing property, there is a handler available that is
    executed whenever the property value is modified. The handler name is `on` followed
    by the property name, then followed by the word `Changed`, all in camel case–thus,
    for a foo property, it becomes `onFooChanged` and for `topColor`, it becomes `onTopColorChanged`.
    To log the current press state of the button to the console, all we need to do
    is implement the property change handler for this property:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 说到属性，当属性值被修改时，有一个简单的方法可以做出反应。对于每个现有属性，都有一个处理程序可用，每当属性值被修改时都会执行该处理程序。处理程序名称是`on`后跟属性名称，然后是单词`Changed`，全部使用驼峰式命名法——因此，对于foo属性，它变为`onFooChanged`，对于`topColor`，它变为`onTopColorChanged`。要将按钮当前的按下状态记录到控制台，我们只需要实现此属性的属性更改处理程序：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Touch input
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸输入
- en: As mentioned earlier, `MouseArea` is the simplest of input event elements. Nowadays,
    more and more devices have touch capabilities and Qt Quick can handle them, as
    well. Currently, we have three ways of handling touch input.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`MouseArea`是输入事件元素中最简单的。如今，越来越多的设备具有触摸功能，Qt Quick也能处理它们。目前，我们有三种处理触摸输入的方法。
- en: First of all, we can keep using `MouseArea` as simple touch events are also
    reported as mouse events; therefore, tapping and sliding a finger on the screen
    is supported out-of-the-box. The following exercise works on touch-capable devices,
    as well, when using mouse as input.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以继续使用 `MouseArea`，因为简单的触摸事件也被报告为鼠标事件；因此，点击和滑动手指在屏幕上是支持的。以下练习在触摸设备上使用鼠标作为输入时也有效。
- en: Time for action – dragging an item around
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间 - 拖动项目
- en: 'Create a new `Qt Quick UI` project. Modify the default code by discarding the
    existing child items and adding a circle instead:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `Qt Quick UI` 项目。通过丢弃现有的子项目并添加一个圆形来修改默认代码：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, use the `drag` property of `MouseArea` to enable moving the circle by
    touch (or mouse):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `MouseArea` 的 `drag` 属性来通过触摸（或鼠标）启用移动圆形：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Then, you can start the application and begin moving the circle around.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以启动应用程序并开始移动圆形。
- en: '*What just happened?*'
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: A circle was created by defining a rectangle with its height equal to width,
    making it a square and rounding the borders to half the side length. The `drag`
    property can be used to tell `MouseArea` to manage a given item's position using
    input events flowing into the area element. We denote the item to be dragged by
    using the target subproperty. You can use other subproperties to control the axis
    the item is allowed to move along or constrain the move to a given area. An important
    thing to remember is that the item being dragged cannot be anchored for the axis
    on which the drag is requested; otherwise, the item will respect the anchor and
    not the drag. We didn't anchor our circle item at all since we want it to be draggable
    along both axes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义一个高度等于宽度的矩形来创建一个圆形，使其成为正方形，并将边框圆滑到边长的一半。`drag` 属性可以用来告诉 `MouseArea` 使用输入事件管理给定项目在区域元素中的位置。我们使用目标子属性来表示要拖动的项目。你可以使用其他子属性来控制项目允许移动的轴或限制移动到给定区域。要记住的一个重要事情是，正在拖动的项目不能在请求拖动的轴上锚定；否则，项目将尊重锚点而不是拖动。我们没有将我们的圆形项目锚定，因为我们希望它可以在两个轴上拖动。
- en: The second approach to handling touch input in Qt Quick applications is to use
    `PinchArea`, which is an item similar to `MouseArea`, but rather than dragging
    an item around, it allows you to rotate or scale it using two fingers (with a
    so called "pinch" gesture), as shown. Be aware that `PinchArea` reacts only to
    touch input, so to test the example you will need a real touch capable device.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 Qt Quick 应用程序中触摸输入的第二种方法是使用 `PinchArea`，它是一个类似于 `MouseArea` 的项目，但它不是拖动项目，而是允许你使用两个手指（所谓的“捏合”手势）旋转或缩放它，如图所示。请注意，`PinchArea`
    只对触摸输入做出反应，因此要测试示例，你需要一个真正的触摸设备。
- en: '![What just happened?](img/8874OS_09_11.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/8874OS_09_11.jpg)'
- en: Time for action – rotating and scaling a picture by pinching
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间 - 通过捏合旋转和缩放图片
- en: 'Start a new `Qt Quick UI` project. In the QML file, delete everything but the
    external item. Then, add an image to the UI and make it centered in its parent:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的 `Qt Quick UI` 项目。在 QML 文件中，删除除外部项目之外的所有内容。然后，向 UI 添加一个图像并将其居中在其父元素中：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we will add a `PinchArea` element. This kind of item can be used in two
    ways–either by manually implementing signal handlers `onPinchStarted`, `onPinchUpdated`,
    and `onPinchFinished` to have total control over the functionality of the gesture
    or by using a simplified interface similar to the drag property of `MouseArea`.
    Since the simplified interface does exactly what we want, there is no need to
    handle pinch events manually. Let''s add the following declaration to the file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个 `PinchArea` 元素。这类项目可以用两种方式使用——要么通过手动实现信号处理程序 `onPinchStarted`、`onPinchUpdated`
    和 `onPinchFinished` 以完全控制手势的功能，要么通过使用类似于 `MouseArea` 拖动属性的简化界面。由于简化界面正好符合我们的需求，因此无需手动处理捏合事件。让我们将以下声明添加到文件中：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You''ll get an output similar to the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个类似于以下截图的输出：
- en: '![Time for action – rotating and scaling a picture by pinching](img/8874OS_09_12.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![操作时间 - 通过捏合旋转和缩放图片](img/8874OS_09_12.jpg)'
- en: '*What just happened?*'
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Our simple application loads an image and centers it in the view. Then, there
    is a `PinchArea` item filling the view area that is told to operate on the image
    object. We define the range of the scaling and rotating of the item. The rest
    is left to the `PinchArea` item itself. If you start interacting with the application,
    you will see the item rotate and scale. What really happens behind the scenes
    is that `PinchArea` modifies the values of the two properties each Qt Quick item
    has–`rotation` and `scale`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的应用程序加载一张图片并将其在视图中居中。然后，有一个`PinchArea`项目填充视图区域，它被指示对图像对象进行操作。我们定义了项目缩放和旋转的范围。其余的由`PinchArea`项目本身处理。如果你开始与应用程序交互，你会看到项目旋转和缩放。实际上幕后发生的事情是`PinchArea`修改了每个Qt
    Quick项目所拥有的两个属性值——`rotation`和`scale`。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`PinchArea` can also control the dragging of the item with `pinch.dragAxis`,
    just like `MouseArea` does with drag, but for simplicity, we didn''t use this
    part of the API. Feel free to experiment with it in your own code.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`PinchArea`也可以通过`pinch.dragAxis`控制项目的拖动，就像`MouseArea`通过拖动一样，但为了简单起见，我们没有使用这个API的部分。请随意在自己的代码中实验它。'
- en: Have a go hero – rotating and scaling with a mouse
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄般的旋转和缩放——使用鼠标
- en: 'Of course, you don''t have to use `PinchArea` to rotate or scale an item. Properties
    controlling those aspects are regular properties that you can read and write at
    any time. Try replacing `PinchArea` with `MouseArea` to obtain a result similar
    to what we just did by modifying the scale and rotation properties as a result
    of receiving mouse events–when the user drags the mouse while pressing the left
    button, the image is scaled and when the user does the same while pressing the
    right button, the image is rotated. You can control which buttons trigger mouse
    events by manipulating the `acceptedButtons` property (setting it to `Qt.LeftButton|Qt.RightButton`
    will cause both buttons to trigger events). The button that triggers the event
    is reported in the event object (which is called `mouse`) through its `button`
    property, and the list of all buttons currently pressed is available in the `button`
    property:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不必使用`PinchArea`来旋转或缩放项目。控制这些方面的属性是常规属性，你可以在任何时候读取和写入它们。尝试用`MouseArea`替换`PinchArea`，通过修改缩放和旋转属性作为接收鼠标事件的结果来获得类似的效果——当用户按住左键拖动鼠标时，图像被缩放；当用户按住右键做同样的事情时，图像被旋转。你可以通过操作`acceptedButtons`属性来控制哪些按钮触发鼠标事件（将`acceptedButtons`设置为`Qt.LeftButton|Qt.RightButton`将导致两个按钮都触发事件）。触发事件的按钮通过事件对象的`button`属性报告（称为`mouse`），所有当前按下的按钮列表都可在`button`属性中找到：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you manage to do the task, try replacing `MouseArea` with `PinchArea` again,
    but then instead of using the `pinch` property, handle events manually to obtain
    the same effect (the event object is called `pinch` and has a number of properties
    you can play with).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完成了这个任务，尝试再次用`PinchArea`替换`MouseArea`，但这次不是使用`pinch`属性，而是手动处理事件以获得相同的效果（事件对象称为`pinch`，并且有许多你可以操作的属性）。
- en: A third approach to handling touch input is by using the `MultiPointTouchArea`
    item. It provides a low-level interface to gestures by reporting each touch point
    separately. It can be used to create custom high-level gesture handlers similar
    to `PinchArea`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 处理触摸输入的第三种方法是使用`MultiPointTouchArea`项目。它通过分别报告每个触摸点提供对手势的低级接口。它可以用来创建类似于`PinchArea`的自定义高级手势处理器。
- en: Keyboard input
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键盘输入
- en: So far, we've been dealing with pointer input, but user input is not just that–we
    can also handle keyboard input. This is quite simple and basically boils down
    to two easy steps.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理指针输入，但用户输入不仅仅是那样——我们还可以处理键盘输入。这相当简单，基本上归结为两个简单的步骤。
- en: 'First, you have to enable receiving keyboard events by stating that a particular
    item has keyboard focus:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须通过声明特定项目具有键盘焦点来启用接收键盘事件：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then, you can start handling events by writing handlers in a similar fashion
    as for mouse events. However, `Item` doesn't provide its own handler for manipulating
    keys that is a counterpart for `keyPressEvent` and `keyReleaseEvent` of `QWidget`.
    Instead, adequate handlers are provided by the `Keys` attached property.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过以类似处理鼠标事件的方式编写处理程序来开始处理事件。然而，`Item`没有提供自己的处理程序来操作键，这是`QWidget`的`keyPressEvent`和`keyReleaseEvent`的对应物。相反，`Keys`附加属性提供了适当的处理程序。
- en: Attached properties are provided by elements that are not used as stand-alone
    elements but instead provide properties to other objects by getting attached to
    them. This is a way of adding support for new properties without modifying the
    API of the original element (it doesn't add new properties through an **is-a**
    relation, but rather through a **has-a** one). Each object that references an
    attached property gets its own copy of the attaching object that then handles
    the extra properties. We will come back to attached properties later in this chapter.
    For now, you just need to remember that in certain situations, an element can
    obtain additional properties that are not part of its API.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 附加属性是由不作为独立元素使用的元素提供的，而是通过附加到其他对象来为它们提供属性。这是在不修改原始元素API的情况下添加对新属性支持的一种方式（它不是通过**is-a**关系添加新属性，而是通过**has-a**关系）。每个引用附加属性的对象都会获得一个附加对象的副本，然后处理额外的属性。我们将在本章的后面部分回到附加属性。现在，你只需要记住，在某些情况下，一个元素可以获取不属于其API的附加属性。
- en: 'Let''s go back to implementing event handlers for keyboard input. As we said
    earlier, each Item has a `Keys` attached property that allows us to install our
    own keyboard handlers. The basic two signals `Keys` adds to `Item` are pressed
    and released; therefore, we can implement the `onPressed` and `onReleased` handlers
    that have a `KeyEvent` argument providing similar information as `QKeyEvent` in
    the widget world. As an example, we can see an item that detects when a spacebar
    was pressed:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到实现键盘输入的事件处理器。正如我们之前所说的，每个Item都有一个名为`Keys`的附加属性，它允许我们安装自己的键盘处理器。`Keys`为`Item`添加的基本两个信号是按下和释放；因此，我们可以实现具有`KeyEvent`参数的`onPressed`和`onReleased`处理器，这些参数提供的信息与在控件世界中`QKeyEvent`类似。作为一个例子，我们可以看到一个检测空格键被按下的项目：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It might become problematic if you want to handle many different keys in the
    same item as the `onPressed` handler would likely contain a giant switch section
    with branches for every possible key. Fortunately, `Keys` offers more properties.
    Most of the commonly used keys (but not letters) have their own handlers that
    are called when the particular key is pressed. Thus, we can easily implement an
    item that takes a different color depending on which key was pressed last:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在同一个项目中处理许多不同的键，可能会出现问题，因为`onPressed`处理器可能包含一个巨大的switch部分，其中包含每个可能键的分支。幸运的是，`Keys`提供了更多的属性。大多数常用的键（但不是字母）都有自己的处理器，当特定键被按下时会被调用。因此，我们可以轻松实现一个项目，根据最后按下的键来改变不同的颜色：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Please note that there is still a single released signal even if a key has its
    own pressed signal.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使某个键有自己的按下信号，仍然只有一个释放信号。
- en: 'Now, consider another example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑另一个例子：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We would expect that when we press and hold the spacebar, we will see the text
    change from `0` to `1` and stay on that value until we release the key. If you
    run the example, you will see that instead, the number keeps incrementing as long
    as you hold down the key. This is because by default, the keys auto-repeat–when
    you hold the key, the operating system keeps sending a sequence of press-release
    events for the key (you can verify that by adding the `console.log()` statements
    to the `Keys.onPressed` and `Keys.onReleased` handlers). To counter this effect,
    you can either disable key repeats in your system (which will, of course, not
    work if someone installs your program on his or her own computer) or you can differentiate
    between auto-repeat and regular events. In Qt Quick, you can do this easily as
    each key event carries the appropriate information. Simply replace the handler
    from the last example with the following one:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计，当我们按下并保持空格键时，我们会看到文本从`0`变为`1`并保持在该值，直到我们释放键。如果你运行示例，你会看到相反的情况，数字会一直增加，只要你按住键。这是因为默认情况下，键会自动重复——当你按住键时，操作系统会持续发送一系列针对该键的按下-释放事件（你可以通过在`Keys.onPressed`和`Keys.onReleased`处理器中添加`console.log()`语句来验证这一点）。为了抵消这种效果，你可以禁用系统中的键重复（当然，如果有人在自己的计算机上安装了你的程序，这将不起作用）或者你可以区分自动重复和常规事件。在Qt
    Quick中，你可以轻松地做到这一点，因为每个键事件都携带适当的信息。只需用以下处理器替换最后一个示例中的处理器即可：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The event variable we use here is the name of the parameter of the `spacePressed`
    signal. As we cannot declare our own names for the parameters like we can do in
    C++, for each signal handler you will have to look up the name of the argument
    in the documentation, as shown:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的事件变量是`spacePressed`信号的参数名称。由于我们无法像在C++中那样为参数声明自己的名称，对于每个信号处理器，你将不得不在文档中查找参数的名称，如下所示：
- en: '![Keyboard input](img/8874OS_09_13.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![键盘输入](img/8874OS_09_13.jpg)'
- en: 'In standard C++ applications, we usually use the *Tab* key to navigate through
    focusable items. With games (and fluid user interfaces in general), it is more
    common to use arrow keys for item navigation. Of course, we can handle this situation
    by using the `Keys` attached property and adding `Keys.onRightPressed`, `Keys.onTabPressed`,
    and other signal handlers to each of our items where we want to modify the focus
    property of the desired item, but it would quickly clutter our code. Qt Quick
    comes to our help once again by providing a `KeyNavigation` attached property,
    which is meant to handle this specific situation and allows us to greatly simplify
    the needed code. Now, we can just specify which item should get into focus when
    a specific key is triggered:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的 C++ 应用程序中，我们通常使用 *Tab* 键在可聚焦项之间导航。在游戏（以及通用的流畅用户界面）中，更常见的是使用箭头键进行项目导航。当然，我们可以通过使用
    `Keys` 附加属性并为每个我们想要修改所需项目焦点属性的项添加 `Keys.onRightPressed`、`Keys.onTabPressed` 和其他信号处理程序来处理这种情况，但这会使我们的代码很快变得杂乱。Qt
    Quick 再次伸出援手，通过提供 `KeyNavigation` 附加属性来处理这种情况，该属性旨在处理这种特定情况，并允许我们极大地简化所需的代码。现在，我们只需指定在触发特定键时哪个项目应该获得焦点：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that we made the first item get into focus in the beginning by explicitly
    setting the focus property.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们通过显式设置焦点属性，使第一个项目在开始时获得焦点。
- en: Both the `Keys` and `KeyNavigation` attached properties have a way to define
    the order in which each of the mechanisms receive the events. This is handled
    by the priority property, which can be set to either `BeforeItem` or `AfterItem`.
    By default, `Keys` will get the event first (`BeforeItem`), then the internal
    event handling can take place and finally, `KeyNavigation` will have a chance
    of handling the event (`AfterItem`). Note that if the key is handled by one of
    the mechanisms, the event is accepted and the remaining mechanisms will not be
    able to handle that event.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Keys` 和 `KeyNavigation` 附加属性都有一种定义每个机制接收事件顺序的方法。这是通过优先级属性来处理的，它可以设置为 `BeforeItem`
    或 `AfterItem`。默认情况下，`Keys` 将首先接收到事件（`BeforeItem`），然后进行内部事件处理，最后 `KeyNavigation`
    将有机会处理该事件（`AfterItem`）。请注意，如果事件被其中一个机制处理，则事件被接受，其余的机制将无法处理该事件。'
- en: Have a go hero – practicing key-event propagation
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 练习关键事件传播
- en: As an exercise, you can expand our last example by building a larger array of
    items (you can use the `Grid` element to position them) and defining a navigation
    system that makes use of the `KeyNavigation` attached property. Have some of the
    items handle events themselves using the `Keys` attached property. See what happens
    when the same key is handled by both mechanisms. Try influencing the behavior
    using the priority property.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，您可以通过构建一个更大的项目数组（您可以使用 `Grid` 元素来定位它们）并定义一个利用 `KeyNavigation` 附加属性的导航系统来扩展我们的最后一个示例。让一些项目使用
    `Keys` 附加属性自行处理事件。看看当同一个键被两个机制处理时会发生什么。尝试使用优先级属性来影响行为。
- en: 'Apart from the attached properties we described, Qt Quick provides built-in
    elements for handling keyboard input. The two most basic types are `TextInput`
    and `TextEdit`, which are QML equivalents of `QLineEdit` and `QTextEdit`. The
    former are used for single-line text input, while the latter serve as its multi-line
    counterpart. They both offer cursor handling, undo-redo functionality, and text
    selections. You can validate text typed into `TextInput` by assigning a validator
    to the `validator` property. For example, to obtain an item where the user can
    input a dot-separated IP address, we could use the following declaration:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们描述的附加属性外，Qt Quick 还提供了处理键盘输入的内置元素。最基本的两类是 `TextInput` 和 `TextEdit`，它们是 `QLineEdit`
    和 `QTextEdit` 的 QML 等价物。前者用于单行文本输入，而后者作为其多行对应物。它们都提供光标处理、撤销-重做功能和文本选择。您可以通过将验证器分配给
    `validator` 属性来验证 `TextInput` 中输入的文本。例如，为了获得一个用户可以输入点分隔 IP 地址的项目，我们可以使用以下声明：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The regular expression only verifies the format of the address. The user can
    still insert bogus numbers. You should either do a proper check before using the
    address or provide a more complex regular expression that will constrain the range
    of numbers the user can enter.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式仅验证地址的格式。用户仍然可以插入无效的数字。您应该在使用地址之前进行适当的检查，或者提供一个更复杂的正则表达式，以限制用户可以输入的数字范围。
- en: 'One thing to remember is that neither `TextInput` nor `TextEdit` has any visual
    appearance (apart from the text and cursor they contain), so if you want to give
    the user some visual hint as to where the item is positioned, the easiest solution
    is to wrap it in a styled rectangle:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事情是，`TextInput` 和 `TextEdit` 都没有任何视觉外观（除了它们包含的文本和光标之外），所以如果你想给用户一些视觉提示，说明项目在哪里定位，最简单的解决方案是将它包裹在一个样式矩形中：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice the highlighted code–the `clip` property of `textInput`–is enabled such
    that by default, if the text entered in the box doesn't fit in the item, it will
    overflow it and remain visible outside the actual item. By enabling clipping,
    we explicitly say that anything that doesn't fit the item should not be drawn.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意高亮显示的代码——`textInput` 的 `clip` 属性被启用，这样默认情况下，如果输入框中的文本不适合项目，它将溢出到项目外并保持可见。通过启用裁剪，我们明确表示任何不适合项目的内容不应被绘制。
- en: '![Have a go hero – practicing key-event propagation](img/8874OS_09_14.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![英雄实践 – 练习关键事件传播](img/8874OS_09_14.jpg)'
- en: Using components in Qt Quick
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Qt Quick 中使用组件
- en: By now, you should be familiar with the very basics of QML and Qt Quick. Now,
    we can start combining what you know and fill the gaps with more information to
    build a functional Qt Quick application. Our target is going to be to display
    an analog clock.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经熟悉了 QML 和 Qt Quick 的基础知识。现在，我们可以开始结合你所知道的知识，并用更多信息来填补空白，构建一个功能性的
    Qt Quick 应用程序。我们的目标是显示一个模拟时钟。
- en: Time for action – a simple analog clock application
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践时间 – 一个简单的模拟时钟应用程序
- en: 'Create a new `Qt Quick UI` project. To create a clock, we will implement a
    component representing the clock needle and we will use instances of that component
    in the actual clock element. In addition to this, we will make the clock a reusable
    component; therefore, we will create it in a separate file and instantiate it
    from within `main.qml`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `Qt Quick UI` 项目。为了创建一个时钟，我们将实现一个代表时钟指针的组件，并在实际时钟元素中使用该组件的实例。除此之外，我们还将使时钟成为一个可重用的组件；因此，我们将它创建在一个单独的文件中，并在
    `main.qml` 内部实例化它：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, add the new QML file to the project and call it `Clock.qml`. Let''s start
    by declaring a circular clock plate:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将新的 QML 文件添加到项目中，并将其命名为 `Clock.qml`。让我们首先声明一个圆形时钟盘面：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you run the program now, you''ll see a plain gray circle hardly resembling
    a clock plate:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行程序，你会看到一个朴素的灰色圆圈，几乎不像是时钟盘面：
- en: '![Time for action – a simple analog clock application](img/8874OS_09_15.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![动手实践时间 – 一个简单的模拟时钟应用程序](img/8874OS_09_15.jpg)'
- en: 'The next step is to add marks dividing the plate into 12 sections. We can do
    this by putting the following declaration inside the `plate` object:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加将盘面分成12个部分的标记。我们可以通过在 `plate` 对象内部放置以下声明来完成此操作：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Running the program should now give the following result, looking much more
    like a clock plate:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行程序应该给出以下结果，看起来更像是一个时钟盘面：
- en: '![Time for action – a simple analog clock application](img/8874OS_09_16.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![动手实践时间 – 一个简单的模拟时钟应用程序](img/8874OS_09_16.jpg)'
- en: '*What just happened?*'
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: The code we just created introduces a couple of new features. Let's go through
    them one by one.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的代码引入了一些新功能。让我们逐一介绍它们。
- en: First of all, we used a new element called `Repeater`. It does exactly what
    its name says–it repeats items declared within it using a given model. For each
    entry in the model, it creates an instance of a component assigned to a property
    called `delegate` (the property name means that it contains an entity to which
    the caller delegates some responsibility, such as describing a component to be
    used as a stencil by the caller). `Item` declared in `Repeater` describes the
    delegate even though we cannot see it explicitly assigned to a property. This
    is because `delegate` is a default property of the `Repeater` type, which means
    anything unassigned to any property explicitly gets implicitly assigned to the
    default property of the type.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用了一个名为 `Repeater` 的新元素。它确实如其名所示——使用给定的模型重复其内部声明的项目。对于模型中的每个条目，它都会为名为 `delegate`
    的属性分配的组件创建一个实例（该属性名意味着它包含一个实体，调用者将一些责任委托给该实体，例如描述一个调用者用作模板的组件）。在 `Repeater` 中声明的
    `Item` 描述了委托，尽管我们无法明确看到它被分配给任何属性。这是因为 `delegate` 是 `Repeater` 类型的默认属性，这意味着任何未明确分配给任何属性的任何内容都将隐式地分配给类型的默认属性。
- en: The `Item` type also has a default property called `data`. It holds a list of
    elements that gets automatically split into two "sublists"–the list of the item's
    children (which creates the hierarchy of `Item` instances in Qt Quick) and another
    list called resources, which contains all "child" elements that do not inherit
    from `Item`. You have direct access to all three lists which means calling `children[2]`
    will return the third `Item` element declared in the item, and `data[5]` will
    return the sixth element declared in the `Item` regardless of whether the given
    element is a visual item (that inherits `Item`) or not.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item` 类型还有一个默认属性，称为 `data`。它包含一个元素列表，该列表会自动拆分为两个“子列表”——一个是项的子项列表（这创建了 Qt Quick
    中 `Item` 实例的层次结构）和另一个名为资源的列表，它包含所有不继承自 `Item` 的“子”元素。你可以直接访问这三个列表，这意味着调用 `children[2]`
    将返回在项中声明的第三个 `Item` 元素，而 `data[5]` 将返回在 `Item` 中声明的第六个元素，无论该元素是否为视觉项（继承自 `Item`）。'
- en: The model can be a number of things but in our case, it is simply a number denoting
    how many times the delegate should be repeated. The component to be repeated is
    a transparent item containing a rectangle. The item has a property declared called
    `hour` that has something called `index` bound to it. The latter is a property
    assigned by `Repeater` to each instance of the delegate component. The value it
    contains is the index of the instance in the `Repeater` object–since we have a
    model containing twelve elements, `index` will hold values within a range of `0`
    to `11`. The item can make use of the `index` property to customize instances
    created by `Repeater`. In this particular case, we use `index` to provide values
    for a `rotation` property and by multiplying the index by `30`, we get values
    starting from `0` for the first instance and ending at `330` for the last one.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 模型可以是许多事物，但就我们而言，它只是一个表示代理应该重复多少次的数字。要重复的组件是一个包含矩形的透明项。该项有一个名为 `hour` 的属性，它与
    `index` 绑定。后者是 `Repeater` 分配给代理组件每个实例的属性。它包含的值是实例在 `Repeater` 对象中的索引——由于我们有一个包含十二个元素的模型，`index`
    将在 `0` 到 `11` 的范围内持有值。项可以使用 `index` 属性来定制 `Repeater` 创建的实例。在这种情况下，我们使用 `index`
    为 `rotation` 属性提供值，并通过将索引乘以 `30`，我们得到从第一个实例的 `0` 开始，到最后一个实例的 `330` 结束的值。
- en: The `rotation` property brings us to the second most important subject–item
    transformations. Each item can be transformed in a number of ways, including rotating
    the item and scaling it in two-dimensional space as we already mentioned earlier.
    Another property called `transformOrigin` denotes the origin point around which
    scale and rotation are applied. By default, it points to `Item.Center`, which
    makes the item scale and rotate around its center, but we can change it to eight
    other values such as `Item.TopLeft` for the top-left corner or `Item.Right` for
    the middle of the right edge of the item. In the code we crafted, we rotate each
    item clockwise around its bottom edge. Each item is positioned horizontally in
    the middle of the plate using the `plate.width/2` expression and vertically at
    the top of the plate with the default width of `0` and the height of half the
    plate's height; thus, each item is a thin vertical line spanning from within the
    top to the center of the plate. Then, each item is rotated around the center of
    the plate (each item's bottom edge) by 30 degrees more than a previous item effectively
    laying items evenly on the plate.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotation` 属性引出了第二个最重要的主题——项的转换。每个项都可以以多种方式转换，包括旋转项和在二维空间中缩放，正如我们之前提到的。另一个名为
    `transformOrigin` 的属性表示应用缩放和旋转的原点。默认情况下，它指向 `Item.Center`，这使得项围绕其中心进行缩放和旋转，但我们可以将其更改为其他八个值，例如
    `Item.TopLeft` 用于顶左角或 `Item.Right` 用于项右侧边缘的中间。在我们的代码中，我们围绕每个项的底部边缘顺时针旋转。每个项使用
    `plate.width/2` 表达式在盘子的中间水平定位，并且垂直于盘子的顶部，默认宽度为 `0`，高度为盘子高度的一半；因此，每个项是贯穿顶部到盘子中心的细长垂直线。然后，每个项围绕盘子的中心（每个项的底部边缘）旋转，比前一个项多30度，从而有效地将项均匀地放置在盘子上。'
- en: Finally, each item has a gray `Rectangle` attached to the top edge (offset by
    `4`) and horizontally centered in the transparent parent. Transformations applied
    to an item influence the item's children similarly to what we have seen in Graphics
    View; thus, the effective rotation of the rectangle follows that of its parent.
    The height of the rectangle depends on the value of `hour`, which maps to the
    index of the item in `Repeater`. Here, you cannot use `index` directly as it is
    only visible within the top-most item of the delegate. That's why we create a
    real property called `hour` that can be referenced from within the whole delegate
    item hierarchy.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每个项目都有一个灰色的 `Rectangle` 附着在其顶部边缘（偏移量为 `4`），并在透明父元素中水平居中。应用于项目的变换会影响项目的子元素，类似于我们在
    Graphics View 中看到的；因此，矩形的实际旋转遵循其父元素的旋转。矩形的高度取决于 `hour` 的值，它映射到 `Repeater` 中项目的索引。在这里，你不能直接使用
    `index`，因为它仅在委托的最顶层项中可见。这就是为什么我们创建了一个真正的属性 `hour`，它可以从整个委托项层次结构中引用。
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want more control over item transformations, then we are happy to inform
    you that apart from rotation and scale properties, each item can be assigned an
    array of elements such as `Rotation`, `Scale`, and `Translate` to a property called
    `transform`, which are applied in order, one at a time. These types have properties
    for fine-grained control over the transformation. For instance, using `Rotation`
    you can implement rotation over any of the three axes and around a custom origin
    point (instead of being limited to nine predefined origin points as when using
    the `rotation` property of `Item`).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要对项目变换有更多的控制，那么我们很高兴地告诉你，除了旋转和缩放属性之外，每个项目还可以将 `Rotation`、`Scale` 和 `Translate`
    等元素数组分配给名为 `transform` 的属性，这些元素按顺序逐个应用。这些类型具有对变换进行精细控制的属性。例如，使用 `Rotation`，你可以实现沿任意三个轴的旋转以及围绕自定义原点的旋转（而不是像使用
    `Item` 的 `rotation` 属性那样限制在九个预定义的原点）。
- en: Time for action – adding needles to the clock
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践时间 – 向时钟添加指针
- en: 'The next step is to add the hour, minute, and second needles to the clock.
    Let''s start by creating a new component called `Needle` in a file called `Needle.qml`
    (remember that component names and files representing them need to start with
    a capital letter):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将小时、分钟和秒指针添加到时钟中。让我们首先在名为 `Needle.qml` 的文件中创建一个新的组件 `Needle`（记住，组件名称和表示它们的文件名需要以大写字母开头）：
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`Needle` is basically a rectangle anchored to the center of its parent by its
    bottom edge, which is also the item''s pivot. It also has `value` and `granularity`
    properties driving the rotation of the item, where `value` is the current value
    the needle shows and `granularity` is the number of different values it can display.
    Also, anti-aliasing for the needle is enabled as we want the tip of the needle
    nicely rounded. Having such a definition, we can use the component to declare
    the three needles inside the clock plate object:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Needle` 基本上是一个矩形，通过其底部边缘锚定到父元素的中心，这也是项目的旋转中心。它还具有 `value` 和 `granularity`
    属性，驱动项目的旋转，其中 `value` 是指针显示的当前值，而 `granularity` 是它可以显示的不同值的数量。此外，我们启用了指针的抗锯齿，因为我们希望指针的尖端圆润。有了这样的定义，我们可以使用该组件在时钟盘对象内部声明三个指针：'
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The three needles make use the of `hours`, `minutes`, and `seconds` properties
    of clock, so these need to be declared, as well:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 三个指针使用了时钟的 `hours`、`minutes` 和 `seconds` 属性，因此这些属性也需要声明：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'By assigning different values to the properties of `Clock` in `main.qml`, you
    can make the clock show a different time:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `main.qml` 中为 `Clock` 的属性分配不同的值，你可以使时钟显示不同的时间：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You''ll get an output as shown:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到如下所示的输出：
- en: '![Time for action – adding needles to the clock](img/8874OS_09_18.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![实践时间 – 向时钟添加指针](img/8874OS_09_18.jpg)'
- en: '*What just happened?*'
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Most `Needle` functionality is declared in the component itself, including geometry
    and transformations. Then, whenever we want to use the component, we declare an
    instance of `Needle` and optionally customize the `length` and `color` properties,
    as well as set its `value` and `granularity` to obtain the exact functionality
    we need.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 `Needle` 功能都在组件本身中声明，包括几何形状和变换。然后，无论何时我们想要使用该组件，我们都会声明一个 `Needle` 的实例，并可选择自定义
    `length` 和 `color` 属性，以及设置其 `value` 和 `granularity` 以获得我们需要的确切功能。
- en: Time for action – making the clock functional
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践时间 – 使时钟功能化
- en: 'The final step in creating a clock is to make it actually show the current
    time. In JavaScript, we can query the current time using the `Date` object:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 创建时钟的最终步骤是让它实际显示当前时间。在JavaScript中，我们可以使用`Date`对象查询当前时间：
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Therefore, the first thing that comes to mind is to use the preceding code
    to show the current time on the clock:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先想到的是使用前面的代码来显示时钟上的当前时间：
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This will indeed show the current time once you start the application, but
    the clock will not be updating itself as the time passes. This is because `new
    Date()` returns an object representing one particular moment in time (the date
    and time at the moment when the object was instantiated). What we need instead
    is to have the `currentDate` property updated with a new object created as the
    current time changes. To obtain this effect, we can use a `Timer` element that
    is an equivalent of `QTimer` in C++ and lets us periodically execute some code.
    Let''s modify the code to use a timer:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实会在你启动应用程序时显示当前时间，但时钟不会随着时间流逝而更新自己。这是因为`new Date()`返回一个表示特定时刻的对象（对象实例化的那一刻的日期和时间）。我们需要的相反，是让`currentDate`属性随着当前时间的改变而更新为新对象。为了获得这种效果，我们可以使用一个`Timer`元素，它是C++中`QTimer`的等价物，并允许我们定期执行一些代码。让我们修改代码以使用定时器：
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*What just happened?*'
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Based on the interval property, we can determine that the timer emits a `triggered`
    signal every 500 ms, causing `currentDate` to be updated with a new `Date` object
    representing the current time. The clock is also given a `running` property (pointing
    to its equivalent in the timer) that can control whether updates should be enabled.
    The timer is set to `repeat`; otherwise, it would trigger just once.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 根据间隔属性，我们可以确定定时器每500毫秒发出一个`triggered`信号，导致`currentDate`使用一个代表当前时间的新的`Date`对象更新。时钟还得到了一个`running`属性（指向定时器中的等效属性），可以控制是否启用更新。定时器被设置为`repeat`；否则，它只会触发一次。
- en: Dynamic objects
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态对象
- en: To briefly sum up what you have learned so far, we can say that you know how
    to create hierarchies of objects by declaring their instances and you also know
    how to program new types in separate files, making definitions available as components
    to be instantiated in other QML files. You can even use the `Repeater` element
    to declare a series of objects based on a common stencil.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 简要总结到目前为止你所学的，我们可以这样说：你知道如何通过声明实例来创建对象层次结构，你也知道如何在单独的文件中编程新类型，使定义作为组件在其他QML文件中实例化可用。你甚至可以使用`Repeater`元素根据一个共同的模板声明一系列对象。
- en: Using components in detail
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细使用组件
- en: 'We promised to give you more information about components and now is the time
    to do so. You already know the basics of creating components in separate files.
    Every QML file beginning with a capital letter is treated as a component definition.
    This definition can be used directly by other QML files residing in the same directory
    as the component definition. If you need to access a component definition from
    a file residing elsewhere, you will have to first import the module containing
    the component in the file where you want to use it. The definition of a module
    is very simple–it is just a relative path to the directory containing QML files.
    The path is constructed using dots as the separator. This means that if you have
    a file named `Baz.qml` in a directory called `Base/Foo/Bar` and you want to use
    the `Baz` component from within the `Base/Foo/Ham.qml` file, you will have to
    put the following import statement in `Ham.qml`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们承诺要给你更多关于组件的信息，现在是时候这样做。你已经知道如何在单独的文件中创建组件的基础知识。每个以大写字母开头的QML文件都被视为组件定义。这个定义可以直接由位于组件定义同一目录中的其他QML文件使用。如果你需要从位于其他位置的文件中访问组件定义，你将不得不首先在你想使用它的文件中导入包含该组件的模块。模块的定义非常简单——它只是包含QML文件的目录的相对路径。路径使用点作为分隔符。这意味着如果你有一个名为`Baz.qml`的文件位于名为`Base/Foo/Bar`的目录中，并且你想要在`Base/Foo/Ham.qml`文件中使用`Baz`组件，你必须在`Ham.qml`中放置以下导入语句：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you want to use the same component from within the `Base/Spam.qml` file,
    you will have to replace the import statement with:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在`Base/Spam.qml`文件中使用相同的组件，你必须将导入语句替换为：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Importing a module makes all its components available for use. You can then
    declare objects of types imported from a certain module.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 导入一个模块会使所有其组件可用。然后，你可以声明从某个模块导入的类型对象。
- en: Creating objects on request
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按需创建对象
- en: The problem with pre-declaring objects directly in a QML file is that you need
    to know up front how many objects you are going to need. More often than not,
    you will want to dynamically add and remove objects to your scene, for example,
    in an alien invasion game where as the player progresses, new alien saucers will
    be entering the game screen and other saucers will be getting shot down and destroyed.
    Also, the player's ship will be "producing" new bullets streaking in front of
    the ship, eventually running out of fuel or otherwise disappearing from the game
    scene. By putting a good amount of effort into the problem, you would be able
    to use `Repeater` to obtain this effect, but there is a better tool at hand.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QML 文件中直接预声明对象的问题在于，你需要事先知道你需要多少个对象。更常见的情况是，你将想要动态地向你的场景添加和删除对象，例如，在一个外星人入侵游戏中，随着玩家的进步，新的外星飞碟将进入游戏屏幕，其他飞碟将被击落并摧毁。此外，玩家的飞船将“生产”新的子弹，在飞船前方划过，最终耗尽燃料或以其他方式从游戏场景中消失。通过在解决这个问题上投入大量精力，你将能够使用
    `Repeater` 来获得这种效果，但手头还有更好的工具。
- en: QML offers us another element type called `Component`, which is another way
    to teach the engine about a new element type by declaring its contents in QML.
    There are basically two approaches to doing this.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: QML 为我们提供了另一种元素类型，称为 `Component`，这是通过在 QML 中声明其内容来向引擎介绍新元素类型的另一种方法。基本上有两种方法来做这件事。
- en: 'The first approach is to declare a `Component` element instance in the QML
    file and inline the definition of the new type directly inside the element:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是，在 QML 文件中声明一个 `Component` 元素实例，并将新类型的定义直接内联在元素内部：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Such code declares a component called `circleComponent` that defines a circle
    and exposes its `diameter`, `color`, and `border` properties.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码声明了一个名为 `circleComponent` 的组件，它定义了一个圆并公开了其 `diameter`、`color` 和 `border`
    属性。
- en: 'The other approach is to load the component definition from an existing QML
    file. QML exposes a special global object called `Qt`, which provides a set of
    interesting methods. One of the methods allows the caller to create a component
    passing the URL of an existing QML document:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是，从现有的 QML 文件中加载组件定义。QML 提供了一个特殊的全局对象 `Qt`，它提供了一套有趣的方法。其中一种方法允许调用者通过传递现有
    QML 文档的 URL 来创建组件：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'An interesting note is that `createComponent` can not only accept a local file
    path but also a remote URL, and if it understands the network scheme (for example,
    `http`), it will download the document automatically. In this case, you have to
    remember that it takes time to do that, so the component may not be ready immediately
    after calling `createComponent`. Since the current loading status is kept in the
    `status` property, you can connect to the `statusChanged` signal to be notified
    when this happens. A typical code path looks similar to the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的注意点是 `createComponent` 不仅接受本地文件路径，还可以接受远程 URL，如果它理解网络方案（例如，`http`），它将自动下载文档。在这种情况下，你必须记住这需要时间，因此组件可能在调用
    `createComponent` 后不会立即就绪。由于当前加载状态保存在 `status` 属性中，你可以连接到 `statusChanged` 信号以在发生这种情况时得到通知。一个典型的代码路径看起来类似于以下：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If the component definition is incorrect or the document cannot be retrieved,
    the status of the object will change to `Error`. In that case, you can make use
    of the `errorString()` method to see what the actual problem is:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件定义不正确或无法检索文档，对象的状态将变为 `Error`。在这种情况下，你可以使用 `errorString()` 方法来查看实际的问题是什么：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Once you are sure the component is ready, you can finally start creating objects
    from it. For this, the component exposes a method called `createObject`. In its
    simplest form, it accepts an object that is to become the parent of the newly
    born instance (similar to widget constructors accepting a pointer to a parent
    widget) and returns the new object itself so that you can assign it to some variable:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确认组件已准备就绪，你就可以开始从它创建对象了。为此，组件提供了一个名为 `createObject` 的方法。在其最简单的形式中，它接受一个将成为新生实例父对象的对象（类似于接受父小部件指针的控件构造函数）并返回新对象本身，以便你可以将其分配给某个变量：
- en: '[PRE63]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, you can start setting the object''s properties:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以开始设置对象的属性：
- en: '[PRE64]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A more complex invocation lets us do both these operations (create the object
    and set its properties) in a single call by passing a second parameter to `createObject`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的调用允许我们在单个调用中执行这两个操作（创建对象并设置其属性），通过将第二个参数传递给 `createObject`：
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The second parameter is an object (created here using JSON syntax) whose properties
    are to be applied to the object being created. The advantage of the latter syntax
    is that all property values are applied to the object as one atomic operation
    (just like usual when the item is declared in a QML document) instead of a series
    of separate operations, each of which sets the value for a single property, possibly
    causing an avalanche of change handler invocations in the object.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个对象（在此使用 JSON 语法创建），其属性将被应用到正在创建的对象上。这种语法的优点是，所有属性值都作为一个原子操作应用到对象上（就像在
    QML 文档中声明项目时那样），而不是一系列单独的操作，每个操作都为单个属性设置值，这可能会在对象中引发一系列更改处理程序的调用。
- en: After creation, the object becomes a first-class citizen of the scene, acting
    in the same way as items declared directly in the QML document. The only difference
    is that a dynamically created object can also be dynamically destructed by calling
    its `destroy()` method, which is an equivalent of calling `delete` on C++ objects.
    When speaking of destroying dynamic items, we have to point out that when you
    assign a result of `createObject` to a variable (like `circle`, in our example)
    and that variable goes out of scope, the item will not be released and garbage
    collected as its parent still holds a reference to it, preventing it from being
    recycled.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，该对象成为场景的一等公民，以与在 QML 文档中直接声明的项目相同的方式行事。唯一的区别是，动态创建的对象也可以通过调用其 `destroy()`
    方法来动态销毁，这在 C++ 对象中相当于调用 `delete`。当谈到销毁动态项目时，我们必须指出，当你将 `createObject` 的结果分配给一个变量（如我们示例中的
    `circle`）并且该变量超出作用域时，项目将不会被释放和垃圾回收，因为其父对象仍然持有对该对象的引用，从而阻止其被回收。
- en: We didn't mention this explicitly before, but we have already used inline component
    definitions earlier in this chapter when we introduced the `Repeater` element.
    The repeated item defined within the repeater is in fact not a real item, but
    a component definition that is instantiated as many times as needed by the repeater.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有明确提到这一点，但我们已经在本章介绍 `Repeater` 元素时使用过内联组件定义。在重复器内定义的重复项实际上不是一个真实的项目，而是一个组件定义，该定义会根据重复器的需要被实例化多次。
- en: Delaying item creation
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟项目创建
- en: 'Another recurring scenario is that you do know how many elements you are going
    to need, but the problem is that you cannot determine up front what type of elements
    they are going to be. At some point during the lifetime of your application, you
    will learn that information and will be able to instantiate an object. Until you
    gain the knowledge about the given component, you will need some kind of item
    placeholder where you will later put the real item. You can, of course, write
    some code to use the `createObject()` functionality of the component, but this
    is cumbersome. Fortunately, Qt Quick offers a nicer solution in the form of a
    `Loader` item. This item type is exactly what we described it to be–a temporary
    placeholder for a real item that will be loaded on demand from an existing component.
    You can put `Loader` in place of another item and when you need to create this
    item, one way is to set the URL of a component to the `source` property:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的场景是你知道你需要多少个元素，但问题是你不能提前确定它们的类型。在应用程序的生命周期中的某个时刻，你将了解到这些信息，并将能够实例化一个对象。在你获得有关给定组件的知识之前，你需要某种类型的项目占位符，你将在其中放置真实的项目。当然，你可以编写一些代码来使用组件的
    `createObject()` 功能，但这很麻烦。幸运的是，Qt Quick 提供了一个更好的解决方案，即 `Loader` 项目。这种项目类型正是我们描述的那样——一个临时占位符，用于按需从现有组件加载真实项目。你可以将
    `Loader` 放在另一个项目位置，当你需要创建此项目时，一种方法是将组件的 URL 设置为 `source` 属性：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Immediately afterwards, the magic begins and an instance of the component appears
    in the loader. If the `Loader` object has its size set explicitly (for example,
    by anchoring or setting the width and height), then the item will be resized to
    the size of the loader. If an explicit size is not set, then `Loader` will instead
    be resized to the size of the loaded element once the component is instantiated:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，魔法开始发挥作用，组件的一个实例出现在加载器中。如果 `Loader` 对象的大小被明确设置（例如，通过锚点或设置宽度和高度），则项目将被调整到加载器的大小。如果没有设置显式大小，那么一旦组件被实例化，`Loader`
    将会调整到加载元素的大小：
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the preceding situation, the loader has its size set explicitly so when its
    item is created, it will respect the anchors and sizes declared here.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一种情况下，加载器的大小被明确设置，因此当其项目被创建时，它将尊重此处声明的锚点和大小。
- en: Accessing your item's component functionality
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问项目组件功能
- en: 'Each item in Qt Quick is an instantiation of some kind of component. Each object
    has a `Component` attached property that offers two signals informing about important
    moments of the object''s life cycle. The first signal–`completed()`—is triggered
    after the object has been instantiated. If you provide a handler for the signal,
    you can perform some late initialization of the object after it has been fully
    instantiated. There are many use cases for this signal, starting with logging
    a message to the console:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick中的每个项目都是某种组件的实例化。每个对象都有一个附加的`Component`属性，它提供了两个信号，用于通知对象生命周期的关键时刻。第一个信号——`completed()`——在对象实例化后被触发。如果您为该信号提供处理程序，您可以在对象完全实例化后执行一些后期初始化。这个信号有很多用例，首先是向控制台记录消息：
- en: '[PRE68]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A more advanced use of this signal is to optimize performance by delaying expensive
    operations until the component is fully constructed:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 该信号的更高级用法是通过对延迟昂贵的操作直到组件完全构建来优化性能：
- en: '[PRE69]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: When items are created, they are added to their parent's `children` property.
    Thus, as items get created and destroyed, the value of that property is modified,
    triggering the `childrenChanged` signal. As this happens, we would like to reposition
    the item's children according to some algorithm. For that, we have an internal
    `QtObject` instance (representing a `QObject`) called `priv` where we can declare
    functions and properties that will not be visible outside the component definition.
    In there, we have a `layoutItems()` function that is called whenever the list
    of children is updated. This is fine if items are created or destroyed dynamically
    (for example, using the `Component.createObject()` function). However, as the
    root object is being constructed, it may have a number of child items declared
    directly in the document. There is no point in repositioning them over and over
    again as declarations are instantiated. Only when the list of objects is complete
    does it make sense to position the items. Therefore, we declare a Boolean property
    in the private object denoting whether the root item is fully constructed. Until
    it is, every time `layoutItems()` is called, it will exit immediately without
    doing any computations. When `Component.onCompleted` is called, we raise the flag
    and call `layoutItems()`, which computes the geometry of all child items declared
    statically in the document.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目被创建时，它们会被添加到其父级的`children`属性中。因此，随着项目的创建和销毁，该属性的值会发生变化，从而触发`childrenChanged`信号。当这种情况发生时，我们希望根据某种算法重新定位项目的子项。为此，我们有一个内部的`QtObject`实例（代表`QObject`），称为`priv`，在其中我们可以声明不会在组件定义外部可见的函数和属性。在那里，我们有一个`layoutItems()`函数，每当子项列表更新时都会被调用。如果项目是动态创建或销毁的（例如，使用`Component.createObject()`函数），这是可以的。然而，当根对象正在构建时，它可能直接在文档中声明了多个子项。在声明实例化时反复重新定位它们是没有意义的。只有当对象列表完整时，定位项目才有意义。因此，我们在私有对象中声明了一个布尔属性，表示根项是否已完全构建。在它完成之前，每次调用`layoutItems()`时，它将立即退出而不进行任何计算。当`Component.onCompleted`被调用时，我们设置标志并调用`layoutItems()`，该函数计算文档中声明的所有静态子项的几何形状。
- en: The other signal in the attached `Component` property is `destruction`. It is
    triggered right after the destruction process for the object starts when the component
    is still fully constructed. By handling that signal, you can perform actions such
    as saving the state of the object in persistent storage or otherwise cleaning
    the object up.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 附加的`Component`属性中的另一个信号是`destruction`。当组件仍然完全构建时，在对象销毁过程开始后立即触发。通过处理该信号，您可以执行诸如在持久存储中保存对象状态或以其他方式清理对象等操作。
- en: Imperative painting
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制性绘制
- en: Declaring graphical items is nice and easy but as programmers, we're more used
    to writing imperative code, and some things are easier expressed as an algorithm
    rather than as a description of the final result to be achieved. It is easy to
    use QML to encode a definition of a primitive shape such as a rectangle in a compact
    way–all we need is to mark the origin point of the rectangle, its width, height,
    and optionally, a color. Writing down a declarative definition of a complex shape
    consisting of many control points positioned in given absolute coordinates, possibly
    with an outline in some parts of it, maybe accompanied by an image or two, is
    still possible in language such as QML; however, this will result in a much more
    verbose and much less readable definition. This is a case where using an imperative
    approach might prove more effective. HTML (being a declarative language) already
    exposes a proven imperative interface for drawing different primitives called
    a `Canvas` that has been used in numerous Web applications. Fortunately, Qt Quick
    provides us with its own implementation of a `Canvas` interface similar to the
    one from the Web by letting us instantiate `Canvas` items. Such items can be used
    to draw straight and curved lines, simple and complex shapes, and graphs and graphic
    images. It can also add text, colors, shadows, gradients, and patterns. It can
    even perform low-level pixel operations. Finally, the output may be saved as an
    image file or serialized to a URL usable as source for an `Image` item. There
    are many tutorials and papers available out there on using an HTML canvas and
    they can usually be easily applied to a Qt Quick canvas, as well (the reference
    manual even includes a list of aspects you need to pay attention to when porting
    HTML canvas applications to a Qt Quick canvas), so here we will just give you
    the very basics of imperative drawing in Qt Quick.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 声明图形项既简单又容易，但作为程序员，我们更习惯于编写命令式代码，有些事情用算法表达比用达到最终结果的描述更容易。使用 QML 以紧凑的方式编码原始形状的定义，如矩形，很容易——我们只需要标记矩形的原点、宽度、高度，以及可选的颜色。在给定的绝对坐标中声明由许多控制点组成的复杂形状的定义，可能在其某些部分有轮廓，可能还伴随一些图像，在
    QML 这样的语言中仍然是可能的；然而，这将导致一个更加冗长且可读性更差的定义。这是一个使用命令式方法可能更有效的情况。HTML（作为一种声明性语言）已经暴露了一个用于绘制不同原语（称为
    `Canvas`）的经过验证的命令式接口，该接口已在许多 Web 应用程序中使用。幸运的是，Qt Quick 通过允许我们实例化 `Canvas` 元素为我们提供了类似
    Web 的 `Canvas` 接口的实现。这些项目可以用来绘制直线和曲线、简单和复杂的形状、图表和图形图像。它还可以添加文本、颜色、阴影、渐变和图案。它甚至可以执行低级像素操作。最后，输出可以保存为图像文件或序列化为可由
    `Image` 项目使用的 URL。关于使用 HTML 画布的许多教程和论文都可用，并且它们通常可以很容易地应用于 Qt Quick 画布（参考手册甚至包括在将
    HTML 画布应用程序移植到 Qt Quick 画布时需要注意的方面列表），因此在这里我们只给出 Qt Quick 中命令式绘图的非常基础的内容。
- en: Consider a game where the player's health is measured by the condition of his
    heart–the slower the beat, the more healthy the player is. We will use this kind
    of visualization as our exercise in practicing painting using the `Canvas` element.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个游戏，玩家的健康状态由他的心脏状况来衡量——心跳越慢，玩家就越健康。我们将使用这种可视化作为我们练习使用 `Canvas` 元素绘画的练习。
- en: Time for action – preparing Canvas for heartbeat visualization
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 准备画布以进行心跳可视化
- en: 'Let''s start with simple things by creating a Quick UI project based on the
    latest version of Qt Quick. Rename the QML file Creator made for us to `HeartBeat.qml`.
    Open the `qmlproject` file that was created with the project and change the `mainFile`
    property of the `Project` object to `HeartBeat.qml`. Then, you can close the `qmlproject`
    document and return to `HeartBeat.qml`. There, you can replace the original content
    with the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的事情开始，创建一个基于最新版 Qt Quick 的快速 UI 项目。将 Creator 为我们创建的 QML 文件重命名为 `HeartBeat.qml`。打开与项目一起创建的
    `qmlproject` 文件，并将 `Project` 对象的 `mainFile` 属性更改为 `HeartBeat.qml`。然后，你可以关闭 `qmlproject`
    文档，返回到 `HeartBeat.qml`。在那里，你可以用以下内容替换原始内容：
- en: '[PRE70]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: When you run the project, you will see... a blank window.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行项目时，你会看到一个空白窗口。
- en: '*What just happened?*'
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In the preceding code, we created a basic boilerplate code for using a canvas.
    First, we renamed the existing file to what we want our component to be called,
    and then we informed Creator that this document is to be executed when we run
    the project using `qmlscene`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个基本的模板代码，用于使用 canvas。首先，我们将现有的文件重命名为我们希望组件使用的名称，然后我们通知 Creator，当使用
    `qmlscene` 运行项目时，将执行此文档。
- en: Then, we created a `Canvas` instance with an implicit width and height set.
    There, we created a handler for the `paint` signal that is emitted whenever the
    canvas needs to be redrawn. The code placed there retrieves a context for the
    canvas, which can be thought of as an equivalent to the `QPainter` instance we
    used when drawing on Qt widgets. We inform the canvas that we want its 2D context,
    which gives us a way to draw in two dimensions. A 2D context is the only context
    currently present for the `Canvas` element, but you still have to identify it
    explicitly–similar to in HTML. Having the context ready, we tell it to clear the
    whole area of the canvas. This is different to the widget world in which when
    the `paintEvent` handler was called, the widget was already cleared for us and
    everything had to be redrawn from scratch. With `Canvas`, it is different; the
    previous content is kept by default so that you can draw over it if you want.
    Since we want to start with a clean sheet, we call `clearRect()` on the context.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个具有隐式宽度和高度的 `Canvas` 实例。在那里，我们创建了一个处理 `paint` 信号的处理器，该信号在画布需要重绘时发出。放置在那里的代码检索画布的上下文，这可以被视为我们在
    Qt 小部件上绘图时使用的 `QPainter` 实例的等效物。我们通知画布我们想要其 2D 上下文，这为我们提供了在二维中绘制的方式。2D 上下文是当前
    `Canvas` 元素唯一存在的上下文，但你仍然必须明确地识别它——类似于 HTML。有了上下文准备就绪，我们告诉它清除画布的整个区域。这与小部件世界不同，在
    `paintEvent` 处理器被调用时，小部件已经为我们清除，并且必须从头开始重绘一切。在 `Canvas` 中，情况不同；默认情况下保留以前的内容，以便你可以覆盖它。由于我们希望从一张干净的画布开始，我们在上下文中调用
    `clearRect()`。
- en: Time for action – drawing a heartbeat
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 – 绘制心电图
- en: We will extend our component now and implement its main functionality–drawing
    a heartbeat-like diagram.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将扩展我们的组件并实现其主要功能——绘制一个类似心电图的图形。
- en: 'Add the following property declarations to `canvas`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下属性声明添加到 `canvas` 中：
- en: '[PRE71]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Below, add a declaration for a timer that will drive the whole component:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，添加一个定时器的声明，该定时器将驱动整个组件：
- en: '[PRE72]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, define the handler for when the value of `arg` is modified:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义当 `arg` 的值被修改时的处理程序：
- en: '[PRE73]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, implement `func`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，实现 `func`：
- en: '[PRE74]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, modify `onPaint`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，修改 `onPaint`：
- en: '[PRE75]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then, you can run the code and see a heart beat-like diagram appear on the
    canvas:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以运行代码，并看到类似心电图的图形出现在画布上：
- en: '![Time for action – drawing a heartbeat](img/8874OS_09_19.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![动手实践 – 绘制心电图](img/8874OS_09_19.jpg)'
- en: '*What just happened?*'
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We added two kinds of properties to the element. By introducing `lineWidth`,
    we can manipulate the width of the line that visualizes the heartbeat. The `points`
    and `arg` variables are two helper variables that store an array of points already
    calculated and the function argument that was last evaluated. The function we
    are going to use is a periodic function that extends from `-Π` to `+Π`; thus,
    we initialize `arg` to `-Math.PI` and we store an empty array in points.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向元素添加了两种类型的属性。通过引入 `lineWidth`，我们可以操纵可视化心电图的线条宽度。`points` 和 `arg` 变量是两个辅助变量，它们存储已计算的点数数组和最后一次评估的函数参数。我们将要使用的函数是一个从
    `-Π` 到 `+Π` 的周期函数；因此，我们将 `arg` 初始化为 `-Math.PI`，并在 `points` 中存储一个空数组。
- en: Then, we added a timer that ticks in regular intervals, incrementing `arg` by
    1° until it reaches `+Π`, in which case it is reset to the initial value.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了一个定时器，以固定的时间间隔滴答作响，将 `arg` 增加 1°，直到它达到 `+Π`，在这种情况下，它将重置到初始值。
- en: Changes to `arg` are intercepted in the handler we implemented next. In there,
    we push a new item to the array of points. The value is calculated by the function
    `func`, which is quite complicated, but it is sufficient to say that it returns
    a value from within a range of `-1` to `+1`. The array of points is then compacted
    using `Array.slice()` so that at most, the last canvas.width items remain in the
    array. This is so we can plot one point for each pixel of the width of the canvas
    and we don't have to store any more data than required. At the end of the function,
    we invoke `requestPaint()`, which is an equivalent of `QWidget::update()` and
    schedules a call to paint.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现的下一个处理程序中，拦截对`arg`的更改。在那里，我们将一个新的项目推送到点的数组中。这个值是通过函数`func`计算的，该函数相当复杂，但可以简单地说它返回一个在`-1`到`+1`范围内的值。然后使用`Array.slice()`对点的数组进行压缩，这样数组中最多只保留`canvas.width`个最后一个元素。这样做是为了我们可以为画布宽度的每个像素绘制一个点，并且不需要存储比所需更多的数据。在函数的末尾，我们调用`requestPaint()`，它等同于`QWidget::update()`，并安排一个调用`paint`。
- en: That, in turn, calls our `onPaint`. There, after retrieving the context, we
    reset the canvas to its initial state and then calculate an array of points that
    is to be drawn again by using `slice()`. Then, we prepare the canvas by translating
    and scaling it in the vertical axis so that the origin is moved to half of the
    height of the canvas (that's the reason for calling `reset()` at the beginning
    of the procedure–to revert this transformation). After that, `beginPath()` is
    called to inform the context that we are starting to build a new path. Then, the
    path is built segment by segment by appending lines. Each value is multiplied
    by `canvas.height/2` so that values from the point array are scaled to the size
    of the item. The value is negated as the vertical axis of the canvas grows to
    the bottom and we want positive values to be above the origin line. After that,
    we set the width of the pen and draw the path by calling `stroke()`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来又调用了我们的`onPaint`。在那里，在检索上下文后，我们将画布重置为其初始状态，然后使用`slice()`计算一个要再次绘制的点的数组。然后，我们通过在垂直轴上平移和缩放画布来准备画布，以便将原点移动到画布高度的一半（这就是为什么在程序开始时调用`reset()`的原因——为了撤销这种转换）。之后，调用`beginPath()`来通知上下文我们开始构建一个新的路径。然后，通过逐段添加线条来构建路径。每个值都乘以`canvas.height/2`，以便将点数组的值缩放到项目的大小。由于画布的垂直轴增长到底部，我们希望正值在原点线上方，因此该值被取反。之后，我们设置笔的宽度并通过调用`stroke()`来绘制路径。
- en: Time for action – making the diagram more colorful
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使图表更加多彩
- en: The diagram serves its purpose, but it looks a bit dull. Add some shine to it
    by defining three new color properties in the canvas object–`color`, `topColor`,
    `bottomColor`–and setting their default values to `black`, `red`, and `blue`,
    respectively.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表完成了它的任务，但它看起来有点单调。通过在画布对象中定义三个新的颜色属性——`color`、`topColor`和`bottomColor`——并将它们的默认值分别设置为`black`、`red`和`blue`，来给它添加一些光泽。
- en: 'Since `points` and `arg` should not really be public properties that anyone
    can change behind our backs, we''ll correct it now. Declare a child element of
    the canvas of `QtObject` and set its ID to `priv`. Move declarations of `points`
    and `arg` inside that object. Move the `onArgChanged` handler there, as well:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`points`和`arg`实际上不应该成为任何人都可以随意更改的公共属性，我们现在就来修正这个问题。将`QtObject`画布的子元素声明为`priv`，并设置其ID为`priv`。将`points`和`arg`的声明移入该对象内部。同时，将`onArgChanged`处理程序也移入那里：
- en: '[PRE76]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Then, search through the whole code and prefix all occurrences of arg and points
    outside the newly declared object with `priv`, so that each of their invocations
    lead to the `priv` object.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在整个代码中搜索，并将所有新声明对象外部出现的`arg`和`points`的实例前缀为`priv`，这样每次调用都会指向`priv`对象。
- en: 'Then, let''s make use of the three colors we defined by extending `onPaint`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们利用我们通过扩展`onPaint`定义的三个颜色：
- en: '[PRE77]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Upon running the preceding code snippet, you get the following output:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码片段后，你会得到以下输出：
- en: '![Time for action – making the diagram more colorful](img/8874OS_09_20.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 使图表更加多彩](img/8874OS_09_20.jpg)'
- en: '*What just happened?*'
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: By moving the two properties inside the `priv` object, we have effectively hidden
    them from the external world as child objects of an object (such as `priv` being
    a child of `canvas`) are not accessible from outside the QML document that defines
    the object. This ensures that neither `points` nor `arg` can be modified from
    outside the `HeartBeat.qml` document.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将两个属性移动到`priv`对象内部，我们实际上已经将它们作为对象的子对象（例如`priv`是`canvas`的子对象）隐藏在外部世界，因为子对象在外部定义对象的QML文档中是不可访问的。这确保了`points`和`arg`都不能从`HeartBeat.qml`文档外部修改。
- en: The modifications to `onPaint` that we implemented are creating another path
    and using that path to fill an area using a gradient. The path is very similar
    to the original one, but it contains two additional points that are the first
    and last point drawn projected onto the horizontal axis. This makes sure the gradient
    fills the area properly. Please note that the canvas uses imperative code for
    drawing; therefore, the order of drawing the fill and the stroke matters–the fill
    has to be drawn first so that it doesn't obscure the stroke.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`onPaint`进行的修改是创建另一条路径，并使用该路径通过渐变填充一个区域。这条路径与原始路径非常相似，但它包含两个额外的点，即第一个和最后一个绘制到水平轴上的点。这确保了渐变能够正确填充区域。请注意，画布使用命令式代码进行绘制；因此，填充和描边的绘制顺序很重要——填充必须先绘制，以免遮挡描边。
- en: Qt Quick and C++
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Quick和C++
- en: Thus far, we have been using standard Qt Quick items or creating new ones by
    compositing existing element types in QML. But there is a lot more you can do
    if you interface QML and C++ using the technologies Qt has to offer. Essentially,
    QML runtime does not differ much in its design from Qt Script, which you read
    about in the previous chapter of this book. In the following paragraphs, you will
    learn how to gain access to objects living in one of the environments from within
    the other one, as well as how to extend QML with new modules and elements.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用标准的Qt Quick元素或通过在QML中组合现有元素类型来创建新的元素。但如果你使用Qt提供的技术将QML和C++接口，你还能做更多的事情。本质上，QML运行时在设计上与Qt
    Script没有太大区别，你可以在本书的前一章中了解到Qt Script。在接下来的段落中，你将学习如何从另一个环境中访问存在于一个环境中的对象，以及如何通过新的模块和元素扩展QML。
- en: Until now, all the example projects we did in this chapter were written with
    just QML and because of that, the project type we were choosing was Qt Quick UI,
    which let us quickly see the Qt Quick scene we modeled by interpreting it with
    the `qmlscene` tool. Now, we will want to add C++ to the equation and since C++
    is a compiled language, we will need to do some proper compilation to get things
    working. Therefore, we will be using the **Qt Quick Application** template.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在本章中进行的所有示例项目都是用QML编写的，因此我们选择的项目类型是Qt Quick UI，这让我们能够通过`qmlscene`工具解释它来快速查看我们建模的Qt
    Quick场景。现在，我们希望将C++添加到等式中，因为C++是一种编译型语言，我们需要进行一些适当的编译才能使一切正常工作。因此，我们将使用**Qt Quick应用程序**模板。
- en: Creating QML objects from C++
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从C++创建QML对象
- en: 'When you start a new project of such a type in Qt Creator, after you answer
    the question about the component set you would like to use (choose any of the
    Qt Quick 2.*x* options for a regular Qt Quick application), you will receive some
    boilerplate code–a `main.cpp` file containing the C++ part and `main.qml`, which
    contains the scene definition. Let''s have a look at the latter first:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Qt Creator中启动此类新项目时，在你回答关于你希望使用的组件集的问题（为常规Qt Quick应用程序选择任何Qt Quick 2.*x*选项）之后，你将收到一些样板代码——一个包含C++部分的`main.cpp`文件和包含场景定义的`main.qml`。让我们先看看后者：
- en: '[PRE78]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The code is a little bit different than before; just look at the highlighted
    parts. Instead of an `Item` root object, we now have a Window together with an
    `import` statement for a `QtQuick.Window` module. To understand why this is the
    case, we will have to understand the C++ code which invokes this QML document:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与之前略有不同；只需看看高亮部分。现在我们不再使用`Item`根对象，而是有一个窗口以及一个`QtQuick.Window`模块的`import`语句。要理解为什么会这样，我们需要了解调用此QML文档的C++代码：
- en: '[PRE79]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The source code is pretty simple. First, we instantiate an application object,
    just like for any other type of application. As we are not using Qt widgets, `QGuiApplication`
    is used instead of `QApplication`. The last line of the main function is also
    obvious–the application's event loop is started. Between those two lines, we can
    see an instance of `QQmlApplicationEngine` being created and fed with the URL
    of our QML document.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码相当简单。首先，我们实例化一个应用程序对象，就像任何其他类型的应用程序一样。由于我们不使用 Qt 小部件，因此使用 `QGuiApplication`
    而不是 `QApplication`。主函数的最后一行也很明显——启动应用程序的事件循环。在这两行之间，我们可以看到一个 `QQmlApplicationEngine`
    的实例被创建，并提供了我们 QML 文档的 URL。
- en: QML is driven by an engine implemented in `QQmlEngine` that is somewhat similar
    to `QScriptEngine`. `QQmlApplicationEngine` is a subclass of `QQmlEngine`, which
    provides a simple way of loading an application from a single QML file. This class
    does not create a root window to display our Qt Quick scene (QML applications
    don't have to necessarily be Qt Quick applications; they don't have to deal with
    the user interface at all), so it is the responsibility of the application to
    create a window if it wants to show a Qt Quick scene in it.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: QML 由 `QQmlEngine` 中实现的引擎驱动，这与 `QScriptEngine` 有一定的相似性。`QQmlApplicationEngine`
    是 `QQmlEngine` 的一个子类，它提供了一种简单的方法来从单个 QML 文件加载应用程序。这个类不会创建一个根窗口来显示我们的 Qt Quick
    场景（QML 应用程序不一定是 Qt Quick 应用程序；它们根本不需要处理用户界面），因此如果应用程序想要在其中显示 Qt Quick 场景，创建窗口的责任就由应用程序承担。
- en: An alternative fit for loading Qt Quick-based user interfaces would be to use
    `QQuickView` or its less convenient superclass–`QQuickWindow`, which inherit `QWindow`
    and are able to render Qt Quick scenes.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 加载基于 Qt Quick 的用户界面的另一种选择是使用 `QQuickView` 或其不太方便的超类 `QQuickWindow`，它们继承自 `QWindow`
    并能够渲染 Qt Quick 场景。
- en: 'You could then replace the `main.cpp` contents with the following code:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `main.cpp` 的内容替换为以下代码：
- en: '[PRE80]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Since `QQuickView` inherits `QWindow`, we can see that a window will be created
    to encompass the Qt Quick scene defined in `main.qml`. In such an event, you could
    replace the Window declaration with an `Item` similar to what we have seen in
    the earlier examples.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `QQuickView` 继承自 `QWindow`，我们可以看到将创建一个窗口来包含在 `main.qml` 中定义的 Qt Quick 场景。在这种情况下，你可以用类似我们在早期示例中看到的
    `Item` 替换窗口声明。
- en: Tip
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to combine a Qt Quick scene with a Qt widgets-based user interface,
    you can use `QQuickWidget` present in the `QtQuickWidgets` module (add `QT +=
    quickwidgets` to the project file to activate the module), which is similar to
    `QQuickView` and has a similar API, but instead of rendering the scene to a separate
    window, it renders it to a widget you can then put alongside other widgets.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将 Qt Quick 场景与基于 Qt 小部件的用户界面结合使用，可以使用 `QtQuickWidgets` 模块中提供的 `QQuickWidget`（将
    `QT += quickwidgets` 添加到项目文件以激活该模块），它与 `QQuickView` 类似，并且具有类似的 API，但它不是将场景渲染到单独的窗口中，而是渲染到你可以将其放置在其他小部件旁边的窗口中。
- en: The last way of creating QML objects is to use `QQmlComponent`. Contrary to
    the previous approaches, which had a `QQmlEngine` instance embedded in the object
    creating the QML object, we have to use a separate engine with the component method.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 QML 对象的最后一种方式是使用 `QQmlComponent`。与之前的方法不同，那些方法在创建 QML 对象的对象中嵌入了一个 `QQmlEngine`
    实例，我们必须使用一个单独的引擎和组件方法。
- en: '`QQmlComponent` is a wrapper around a QML component definition similar to the
    `Component` element on the QML side. It can create instances of that component
    with the `create()` method using a given `QQmlEngine` instance:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`QQmlComponent` 是围绕 QML 组件定义的一个包装器，类似于 QML 侧的 `Component` 元素。它可以使用给定的 `QQmlEngine`
    实例通过 `create()` 方法创建该组件的实例：'
- en: '[PRE81]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The object created is `QObject`, since that is the base class for all objects
    in QML. If the object represents a Qt Quick user interface, you can cast it to
    `QQuickItem` and use its methods to access Item''s functionality:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的对象是 `QObject`，因为它是 QML 中所有对象的基类。如果该对象代表一个 Qt Quick 用户界面，你可以将其转换为 `QQuickItem`
    并使用其方法来访问项的功能：
- en: '[PRE82]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`QQmlComponent` is the most "classic" way of instantiating QML objects. You
    can even use it to create additional objects in existing views:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`QQmlComponent` 是实例化 QML 对象最“经典”的方式。你甚至可以使用它来在现有视图中创建额外的对象：'
- en: '[PRE83]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'A variation on using `QQmlComponent` is to create an object in the QML engine
    asynchronously using the `QQmlIncubator` object. When creating complex objects,
    it takes time for them to instantiate and at times, it is desired to not block
    the control flow for too long by waiting for the operation to complete. In such
    cases, an incubator object can be used to schedule instantiation and continue
    the flow of the program. We can query the state of the incubator and when the
    object is constructed, we will be able to access it. The following code demonstrates
    how to use the incubator to instantiate an object and process pending events while
    waiting for the operation to complete:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `QQmlComponent` 的一个变体是使用 `QQmlIncubator` 对象异步地在 QML 引擎中创建一个对象。在创建复杂对象时，它们实例化需要时间，有时，为了避免等待操作完成而长时间阻塞控制流，我们希望使用孵化器对象来安排实例化并继续程序的流程。我们可以查询孵化器的状态，当对象构建完成后，我们将能够访问它。以下代码演示了如何使用孵化器实例化一个对象并在等待操作完成时处理挂起的事件：
- en: '[PRE84]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Pulling QML objects to C++
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 QML 对象拉到 C++
- en: In our terminology, pulling QML objects to C++ means that by using C++ code,
    we would like to gain access to objects living in the QML engine (for example,
    those declared in some QML file). Before we do that, it is important that we stress
    that in general, it is bad practice to try and pull objects from the QML engine.
    There are a few reasons for that, but we would like to stress just two of them.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的术语中，将 QML 对象拉到 C++ 意味着通过使用 C++ 代码，我们希望访问存在于 QML 引擎中的对象（例如，在某个 QML 文件中声明的那些）。在我们这样做之前，重要的是强调，通常尝试从
    QML 引擎中拉取对象是不良的做法。这有几个原因，但我们只想强调其中两个。
- en: First, if we assume the most common case, which is that the QML part of our
    application deals with a user interface in Qt Quick for the logic written in C++,
    then accessing QtQuick objects from C++ breaks the separation between logic and
    the presentation layer, which is one of the major principles in GUI programming.
    The second reason is that QML documents (and Qt Quick ones in particular) are
    often made by different people (designers) than those who implement the application
    logic (programmers). The user interface is prone to dynamic changes, relayouting
    up to a complete revamp. Heavy modifications of QML documents, such as adding
    or removing items from the design, would then have to be followed by adjusting
    the application logic to cope with those changes. This in turn needs recompilation
    of the whole application, which is cumbersome. In addition, if we allow a single
    application to have multiple user interfaces (skins), it might happen that because
    they are so different, it is impossible to decide upon a single set of common
    entities with hardcoded names that could be fetched from C++ and manipulated.
    Even if you managed to do that, such an application could crash easily if the
    rules were not strictly followed by designers.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们假设最常见的情况，即我们的应用程序的 QML 部分处理用 C++ 编写的逻辑的 Qt Quick 用户界面，那么从 C++ 访问 QtQuick
    对象会打破逻辑和表示层之间的分离，这是 GUI 编程中的一个主要原则。第二个原因是，QML 文档（尤其是 Qt Quick 的文档）通常是由不同于实现应用程序逻辑的人（设计师）制作的。用户界面容易受到动态变化的影响，重排甚至彻底翻新。对
    QML 文档的重度修改，如添加或删除设计中的项，随后需要调整应用程序逻辑以应对这些变化。这反过来又需要整个应用程序的重新编译，这是繁琐的。此外，如果我们允许一个应用程序有多个用户界面（皮肤），可能会发生这样的情况，因为它们如此不同，以至于不可能决定一个单一的具有硬编码名称的通用实体集合，可以从
    C++ 中检索并操作。即使你设法做到了，这样的应用程序也可能会因为设计师没有严格遵守规则而轻易崩溃。
- en: That said, we have to admit that there are cases when it does make sense to
    pull objects from QML to C++, and that is why we decided to familiarize you with
    the way to do it. One of the situations where such an approach is desired is when
    QML serves us as a way to quickly define a hierarchy of objects with properties
    of different objects linked through more or less complex expressions, allowing
    them to answer to changes taking place in the hierarchy.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们必须承认，在某些情况下，从 QML 拉取对象到 C++ 是有意义的，这就是我们决定让你熟悉这样做的方法的原因。这种方法被期望的一种情况是，当
    QML 作为一种快速定义具有不同对象属性并通过更多或更少的复杂表达式链接的对象层次结构的方式时，允许它们对层次结构中发生的变化做出响应。
- en: 'For example, if you create a `Qt Quick UI` project, among the files generated,
    you will find a `qmlproject` file containing the project definition expressed
    in QML itself, such as this one:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你创建一个 `Qt Quick UI` 项目，在生成的文件中，你会找到一个包含项目定义的 `qmlproject` 文件，这个定义是用 QML
    本身表达的，例如这个：
- en: '[PRE85]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: It contains project contents specified as a set of file selectors and additional
    properties such as the main project file or a list of directories of where to
    look for QML modules. It is very easy to specify such a project description in
    QML and after doing so and by getting a handle on the `Project` instance from
    C++, one can read the required information directly from the object and its properties
    as needed.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含项目内容，指定为一系列文件选择器和附加属性，如主项目文件或查找 QML 模块的目录列表。在 QML 中指定此类项目描述非常简单，在这样做并从 C++
    中获取 `Project` 实例的句柄后，可以直接从对象及其属性中读取所需的信息。
- en: '`Project` is considered a root object of this document. There are five ways
    to get access to a root object, based on how the document was actually loaded
    into the engine:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`Project` 被认为是该文档的根对象。根据文档实际加载到引擎中的方式，有五种方法可以获取对根对象的访问权限：'
- en: '`QQmlApplicationEngine::rootObjects()` if using `QQmlApplicationEngine`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用 `QQmlApplicationEngine`，则使用 `QQmlApplicationEngine::rootObjects()`
- en: '`QQuickView::rootObject()` if using `QQuickView`'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用 `QQuickView`，则使用 `QQuickView::rootObject()`
- en: '`QQuickWidget::rootObject()` if using `QQuickWidget`'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用 `QQuickWidget`，则使用 `QQuickWidget::rootObject()`
- en: '`QQmlComponent::create()` if using `QQmlComponent`'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用 `QQmlComponent`，则使用 `QQmlComponent::create()`
- en: '`QQmlIncubator::object()` if using `QQmlComponent` with `QQmlIncubator`'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用带有 `QQmlIncubator` 的 `QQmlComponent`，则使用 `QQmlIncubator::object()`
- en: As we noted earlier, after retrieving an object, you can downcast it to a proper
    type using `qobject_cast`. Alternatively, you can start using the object through
    the generic `QObject` interface–accessing properties with `property()` and `setProperty()`,
    running functions through `QMetaObject::invokeMethod()`, and connecting to signals
    as usual.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在检索到对象后，可以使用 `qobject_cast` 将其向下转换为适当的类型。或者，您可以通过通用的 `QObject` 接口开始使用该对象——使用
    `property()` 和 `setProperty()` 访问属性，通过 `QMetaObject::invokeMethod()` 运行函数，并像往常一样连接到信号。
- en: The use case provided is a valid and fair situation when you want to pull a
    view root object or a manually created object from the QML world into C++. Now,
    we are going to show you how to do the same for an object from an arbitrary depth
    of the object tree.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的使用场景是在您希望从 QML 世界中拉取视图根对象或手动创建的对象到 C++ 中的有效且公平的情况。现在，我们将向您展示如何对对象树任意深度的对象执行相同的操作。
- en: QML documents define object trees. We can ask Qt to traverse a `QObject` tree
    and return a single object or a list of objects in the tree matching specified
    criteria. The same approach can be implemented for QML object trees. There are
    two criteria that can be used when searching. First, we can search for objects
    inheriting from a given class. Then, we can search for objects matching a given
    value of the `objectName` property defined in `QObject`. To search the tree for
    objects, one uses a `findChild` template method.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: QML 文档定义对象树。我们可以要求 Qt 遍历一个 `QObject` 树，并返回匹配指定标准的单个对象或对象列表。相同的策略也可以用于 QML 对象树。在搜索时可以使用两个标准。首先，我们可以搜索继承自给定类的对象。然后，我们可以搜索匹配
    `QObject` 中定义的 `objectName` 属性给定值的对象。要搜索树中的对象，可以使用 `findChild` 模板方法。
- en: 'Consider a Qt Quick document defining a number of items:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个定义了多个项目的 Qt Quick 文档：
- en: '[PRE86]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'After gaining access to the root object using one of the methods described
    earlier, we can query the object tree for any of the colored shape items using
    the `objectName` values:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用前面描述的任何一种方法获取对根对象的访问权限后，我们可以使用 `objectName` 值查询对象树中的任何彩色形状项目：
- en: '[PRE87]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `findChild()` method requires us to pass a class pointer as the template
    argument. Without knowing what class actually implements a given type, it is safest
    to simply pass `QObject*` as, once again, we know all QML objects inherit this.
    It is more important what gets passed as the function argument value–it is the
    name of the object we want returned. Notice it is not `id` of the object, but
    the value of the `objectName` property. When the results get assigned to the variables,
    we verify whether items have been successfully found and if that is the case,
    the generic `QObject` API is used to set the width of the circle to that of the
    rectangle.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`findChild()` 方法要求我们传递一个类指针作为模板参数。在不了解实际实现给定类型的类的情况下，最安全的方法是简单地传递 `QObject*`，因为我们知道所有
    QML 对象都继承自它。更重要的是传递给函数参数的值——它是我们想要返回的对象的名称。注意，它不是对象的 `id`，而是 `objectName` 属性的值。当结果被分配给变量时，我们验证是否成功找到了项目，如果是这样，就使用通用的
    `QObject` API 将圆的宽度设置为矩形的宽度。'
- en: 'Let us stress this again: if you have to use this approach, limit it to the
    minimum. And always verify whether the returned item exists (is a non-null pointer);
    the QML document might change between subsequent compilations of the program,
    and items and their names existing in one version of the document might cease
    to exist in the next version.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次强调：如果你必须使用这种方法，请将其限制在最小范围内。并且始终验证返回的项目是否存在（不是空指针）；QML 文档可能在程序后续编译之间发生变化，文档中存在的一个版本中的项目和它们的名称可能在下一个版本中不再存在。
- en: Pushing C++ objects to QML
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 C++ 对象推送到 QML
- en: A much better approach is to cross the boundary in the other direction–by exporting
    objects from C++ to QML. This allows C++ developers to decide what API is available
    for the script. The choice of which API to use is left to QML developers. Separation
    between the application logic and the user interface is maintained.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是反向跨越边界——通过从 C++ 导出对象到 QML。这允许 C++ 开发者决定脚本可用的 API。选择使用哪个 API 的决定留给 QML
    开发者。应用程序逻辑和用户界面之间的分离得到保持。
- en: In the previous chapter, you learned to use Qt Script. We told you how to expose
    existing `QObject` instances to scripting through the use of the script engine's
    global object. We also discussed execution contexts, which provide layers of object
    visibility while calling functions. As already mentioned, QML has many similarities
    to that framework and in QML, a very similar approach is used to expose objects
    to the engine.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何使用 Qt Script。我们告诉你如何通过使用脚本引擎的全局对象将现有的 `QObject` 实例暴露给脚本。我们还讨论了执行上下文，它们在调用函数时提供对象可见性的层级。如前所述，QML
    与该框架有许多相似之处，在 QML 中，使用非常类似的方法将对象暴露给引擎。
- en: 'QML engines also use contexts to provide data scopes for the language. You
    can set properties on a context to make certain names resolve to given objects:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: QML 引擎也使用上下文为语言提供数据作用域。你可以在上下文中设置属性，使某些名称解析为给定的对象：
- en: '[PRE88]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: From this moment, `object` is visible within `context` under the name `foo`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个时刻起，`object` 在 `context` 中以 `foo` 的名称可见。
- en: 'Contexts can form hierarchies. On the top of the hierarchy resides a root context
    of the engine. Context properties are resolved from the bottom up, meaning that
    redefining a name in a child context shadows the name defined in the parent context.
    Let''s see an example:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文可以形成层次结构。在层次结构的顶部是引擎的根上下文。上下文属性是从下往上解析的，这意味着在子上下文中重新定义一个名称会覆盖父上下文中定义的名称。让我们看一个例子：
- en: '[PRE89]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We created instances of classes `A`, `B`, and `C` and assigned them to a `foo`
    property of different contexts forming a hierarchy of five contexts. Why five?
    When passing a `QQmlEngine` to a constructor of `QQmlContext`, the context created
    becomes a child of the engine''s root context. Therefore, we have four contexts
    we created ourselves and an additional context that always exists in the engine:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了类 `A`、`B` 和 `C` 的实例，并将它们分配给不同上下文的 `foo` 属性，形成五个上下文的层次结构。为什么是五个？当将 `QQmlEngine`
    传递给 `QQmlContext` 构造函数时，创建的上下文成为引擎根上下文的子上下文。因此，我们有四个我们自己创建的上下文和一个始终存在于引擎中的附加上下文：
- en: '![Pushing C++ objects to QML](img/8874OS_09_21.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![将 C++ 对象推送到 QML](img/8874OS_09_21.jpg)'
- en: Now, if we call foo from within `childContext1`, we will access object `B`,
    and when we call `foo` from `childContext2`, we will access `C`. If we call it
    from `childContext3`, then, since `foo` is not defined there, the call will propagate
    to `parentContext` and hence `A` will be accessed. In `rootContext`, the context
    foo will not be available at all.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们从 `childContext1` 内部调用 `foo`，我们将访问对象 `B`，当我们从 `childContext2` 调用 `foo`
    时，我们将访问 `C`。如果我们从 `childContext3` 调用它，那么，由于 `foo` 在那里没有定义，调用将传播到 `parentContext`，因此将访问
    `A`。在 `rootContext` 中，上下文 `foo` 完全不可用。
- en: In most cases, we will not be creating contexts ourselves and thus, the most
    common situation is when we will have control over just the root context since
    it always exists and is easily accessible. Therefore, this context will usually
    be used to register C++ objects. As the root engine context is an ancestor of
    all other contexts, an object registered there will be visible from any QML document.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们不会自己创建上下文，因此最常见的情况是我们将只控制根上下文，因为它始终存在且易于访问。因此，这个上下文通常用于注册 C++ 对象。由于根引擎上下文是所有其他上下文的祖先，在那里注册的对象将可以从任何
    QML 文档中看到。
- en: So what can we do with an exported object using QML? The object itself is accessible
    using the identifier given to it with the `setContextProperty()`. The identifier
    can be treated as the ID pseudo-property declared on objects in QML documents.
    Features that can be accessed from QML depend on the kind of object exported.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们使用 QML 导出的对象能做什么呢？对象本身可以通过使用 `setContextProperty()` 给定的标识符来访问。标识符可以被视为
    QML 文档中对象上声明的 ID 伪属性。可以从 QML 访问的功能取决于导出对象的类型。
- en: 'You can export two kinds of object. First, you can export a `QVariant` value
    that is then converted to an equivalent QML entity. The following table lists
    the most commonly used basic types:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以导出两种类型的对象。首先，您可以导出一个 `QVariant` 值，然后将其转换为等效的 QML 实体。以下表格列出了最常用的基本类型：
- en: '| Qt type | QML basic type |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| Qt 类型 | QML 基本类型 |'
- en: '| --- | --- |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `bool` | `bool` |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `bool` |'
- en: '| `unsigned int, int` | `int` |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned int, int` | `int` |'
- en: '| `double` | `double` |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `double` |'
- en: '| `float, qreal` | `real` |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `float, qreal` | `real` |'
- en: '| `QString` | `string` |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `QString` | `string` |'
- en: '| `QUrl` | `url` |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `QUrl` | `url` |'
- en: '| `QColor` | `color` |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `QColor` | `color` |'
- en: '| `QFont` | `font` |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `QFont` | `font` |'
- en: '| `QDate` | `date` |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `QDate` | `date` |'
- en: '| `QPoint, QPointF` | `point` |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `QPoint, QPointF` | `point` |'
- en: '| `QSize, QSizeF` | `size` |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `QSize, QSizeF` | `size` |'
- en: '| `QRect, QRectF` | `rect` |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| `QRect, QRectF` | `rect` |'
- en: 'It allows us to export a wide range of objects:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们导出广泛的对象：
- en: '[PRE90]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'And use them easily in QtQuick:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 并且可以轻松地在 QtQuick 中使用：
- en: '[PRE91]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This will give us the following output:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下输出：
- en: '![Pushing C++ objects to QML](img/8874OS_09_22.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![将 C++ 对象推送到 QML](img/8874OS_09_22.jpg)'
- en: 'In addition to the basic types, the QML engine provides automatic type conversions
    between special `QVariant` cases and JavaScript types–`QVariantList` is converted
    to JavaScript array and `QVariantMap` to a JavaScript object. This allows for
    an even more versatile approach. We can group all the weather information within
    a single JavaScript object by taking advantage of the `QVariantMap` conversion:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本类型外，QML 引擎还提供了在特殊 `QVariant` 情况和 JavaScript 类型之间的自动类型转换 – `QVariantList`
    转换为 JavaScript 数组，`QVariantMap` 转换为 JavaScript 对象。这允许我们采取更加灵活的方法。我们可以通过利用 `QVariantMap`
    转换来将所有天气信息组合在一个单一的 JavaScript 对象中：
- en: '[PRE92]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'As a result, we get better encapsulation on the QML side:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在 QML 端获得了更好的封装：
- en: '[PRE93]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: That's all fine and dandy in a world where weather conditions never change.
    In real life, however, one needs a way to handle situations where the data changes.
    We could, of course, re-export the map every time any of the values changed, but
    that would be very tedious.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个天气条件永远不会改变的世界上，这一切都很好，很顺利。然而，在现实生活中，人们需要一种处理数据变化情况的方法。当然，我们可以在任何值发生变化时重新导出地图，但这会很繁琐。
- en: Fortunately, the second kind of object that can be exported to QML comes to
    our rescue. Apart from `QVariant`, the engine can accept `QObject` instances as
    context property values. When exporting such an instance to QML, all the object's
    properties are exposed and all its slots become callable functions in the declarative
    environment. Handlers are made available for all the object's signals.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以导出到 QML 的第二种类型的对象也帮了我们一个大忙。除了 `QVariant` 之外，引擎还可以接受 `QObject` 实例作为上下文属性值。当将此类实例导出到
    QML 时，所有对象属性都会公开，并且所有槽都成为声明性环境中的可调用函数。所有对象信号都提供了处理程序。
- en: Time for action – self-updating car dashboard
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 自更新汽车仪表盘
- en: 'In the next exercise, we will implement a car dashboard that can be used in
    a racing game and will show a number of parameters such as current speed and motor
    revolutions per minute. The final result will look similar to the following image:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将实现一个赛车游戏可用的汽车仪表盘，并显示当前速度和每分钟发动机转速等参数。最终结果将类似于以下图片：
- en: '![Time for action – self-updating car dashboard](img/8874OS_09_23.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 自更新汽车仪表盘](img/8874OS_09_23.jpg)'
- en: We will start with the C++ part. Set up a new Qt Quick Application. Choose the
    most recent Qt Quick version for the Qt Quick component set. This will generate
    a main function for you that instantiates `QGuiApplication` and `QQmlApplicationEngine`
    and sets them up to load a QML document.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 C++ 部分开始。设置一个新的 Qt Quick 应用程序。为 Qt Quick 组件集选择最新的 Qt Quick 版本。这将为您生成一个主函数，该函数实例化
    `QGuiApplication` 和 `QQmlApplicationEngine` 并将它们设置为加载 QML 文档。
- en: 'Use the **File** menu to create **New file or Project** and create a new C++
    class. Call it `CarInfo` and choose `QWidget` as its base class. Why not `QObject`,
    you may ask? This is because our class will also be a widget, which will be used
    for modifying values of different parameters so that we may observe how they influence
    what the Qt Quick scene displays. In the class header, declare the following properties:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The properties are read-only and the `NOTIFY` clause defines signals emitted
    when respective property values change. Go ahead and implement the appropriate
    functions for each property. Apart from the getter, also implement a setter as
    a public slot. Here is an example for a property controlling the speed of the
    car:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: You should be able to follow the example for the remaining properties on your
    own.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to use the widget to tweak property values, design the user interface
    for it using a Qt Designer Form. It can something look like this:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – self-updating car dashboard](img/8874OS_09_24.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
- en: Make appropriate signal-slot connections in the widget so that modifying any
    of the widgets for a given parameter or using the setter slot directly updates
    all the widgets for that parameter.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of adding member variables to the `CarInfo` class for properties such
    as `speed`, `rpm`, `distance`, or `gear` you can operate directly on the widgets
    placed on the `ui` form so that, for example, a getter for the `distance` property
    will look like:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The setter would then be modified to:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You will then need to add `connect()` statements to the constructor to be sure
    that signals are propagated from the ui form:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Next, you can test your work by running the widget. To do this, you have to
    alter the main function to look as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Since we are using widgets, we have to replace `QGuiApplication` with `QApplication`
    and enable the widgets module by placing `QT += widgets` in the project file (remember
    to run `qmake` from the project's context menu afterwards). Make sure everything
    works as expected (that is, that moving sliders and changing spinbox values reflect
    the changes to widget properties) before moving on to the next step.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to add `QtQuick` to the equation, so let''s start by updating
    our main function to display our scene. Introduce the highlighted changes to the
    code:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The modifications create a view for our scene, export the `CarInfo` instance
    to the global context of the QML engine, and load and display the scene from a
    file located in a resource.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: It is important to first export all the objects and only then load the scene.
    This is because we want all the names to be already resolvable when the scene
    is being initialized so that they can be used right away. If we reversed the order
    of calls, we would get a number of warnings on the console about the identities
    being undefined.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can focus on the QML part. Look at the picture of the result we
    want to be shown at the beginning of the exercise. For the black background, we
    used a bitmap image created in a graphical editor (you can find the file in the
    materials for this book), but you can obtain a similar effect by composing three
    black rounded rectangles directly in `QtQuick`–the two outer parts are perfect
    circles and the inner module is a horizontally stretched ellipse.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以专注于QML部分。看看练习开始时我们想要显示的结果的图片。对于黑色背景，我们使用了一个在图形编辑器中创建的位图图像（你可以在本书的材料中找到该文件），但你也可以通过在`QtQuick`中直接组合三个黑色圆角矩形来获得类似的效果——两个外侧部分是完美的圆形，而内部模块是一个水平拉伸的椭圆。
- en: 'If you decide to use our background file (or make your own prettier image),
    you can put the following code into `main.qml`:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定使用我们的背景文件（或制作你自己的更漂亮的图像），你可以将以下代码放入`main.qml`：
- en: '[PRE101]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: What we do here is make the image our root item and create three items to serve
    as containers for different elements of the dashboard. The containers are all
    centered in the parent and we use a `horizontalCenterOffset` property to move
    the two outer items sideways. The values of the offset, as well as the widths,
    are calculated by trial and error to look good (note that all three containers
    are perfect squares). If instead of using our file, you settle for creating the
    three parts yourself using Qt Quick items, the containers will simply be anchored
    to the centers of the three black items.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是将图像作为根项目，并创建三个项目作为仪表盘不同元素的容器。这些容器都居中在父元素中，我们使用`horizontalCenterOffset`属性将两个外侧项目向侧面移动。偏移量以及宽度的值是通过试错来计算的，以看起来更好（注意，所有三个容器都是完美的正方形）。如果你不使用我们的文件，而是决定自己使用Qt
    Quick项目创建三个部分，容器将简单地锚定到三个黑色项目的中心。
- en: The dials look complicated, but in reality, they are very easy to implement
    and you have already learned everything you need to design them.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表盘看起来很复杂，但实际上，它们非常容易实现，你已经学到了设计它们所需的一切。
- en: 'Let''s start with the needle. Create a new QML document and call it `Needle.qml`.
    Open the file and place the following content:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从针开始。创建一个新的QML文档，并将其命名为`Needle.qml`。打开文件，并将以下内容放入其中：
- en: '[PRE102]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The document defines an item with four attributes–the length of the needle (defaults
    to 80% of the dial's radius), the color of the needle, `middleColor`, which stands
    for the color of the needle's fixing, and the size, which defines how wide the
    needle is. The code is self-explanatory. The item itself does not have any dimensions
    and onlys acts as an anchor for visual elements–the needle itself is a thin rectangle
    oriented vertically with a fixing 20 units from the end. The fixing is a circle
    of the same color as the needle with a smaller circle in the middle that uses
    a different fill color. The smaller radius of the inner circle is obtained by
    filling the outer circle with a 25% margin from each side.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 该文档定义了一个具有四个属性的项目——针的长度（默认为刻度盘半径的80%），针的颜色，`middleColor`，代表针固定处的颜色，以及大小，它定义了针的宽度。代码是自我解释的。该项目本身没有尺寸，仅作为视觉元素的锚点——针本身是一个垂直方向的细长矩形，从末端起固定20个单位。固定是一个与针颜色相同的圆圈，中间有一个使用不同填充颜色的较小圆圈。内圆的较小半径是通过从每侧填充25%的边距来获得的。
- en: As for the dials, we will put their code inline in the main file since we just
    have two of them and they differ a bit, so the overhead of creating a separate
    component with a well-designed set of properties would outweigh the benefits of
    having nicely encapsulated objects.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 至于仪表盘，由于我们只有两个，而且它们略有不同，所以创建一个具有精心设计的属性集的单独组件的开销将超过拥有良好封装对象的益处。
- en: 'If you think about what needs to be done to have the dial displayed and working,
    it seems the hardest thing is to layout the numbers nicely on the circle, so let''s
    start with that. Here is an implementation of a function for calculating the position
    along a circle circumference, based on the radius of the circle and angle (in
    degrees) where an item should be positioned:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑一下要完成仪表盘显示和工作的操作，似乎最难的事情是将数字整齐地布局在圆周上，所以让我们从这里开始。以下是一个基于圆的半径和角度（以度为单位）计算圆周上位置的功能实现：
- en: '[PRE103]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The function converts degrees to radians and returns the desired point. The
    function expects a width property to be available that helps to calculate the
    center of the circle and in case a radius was not given, serves as a means to
    calculate a feasible value for it.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将度数转换为弧度，并返回所需点。该函数期望有一个宽度属性可用，这有助于计算圆的中心，如果没有给出半径，则作为计算其可行值的手段。
- en: 'With such a function available, we can use the already familiar `Repeater`
    element to position items where we want them. Let''s put the function in `middleContainer`
    and declare the dial for car speed:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 有这样的函数可用，我们可以使用已经熟悉的`Repeater`元素来定位我们想要的位置。让我们将这个函数放入`middleContainer`中，并声明汽车速度的旋钮：
- en: '[PRE104]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'You might have noticed we used an element called `Label`. We created it to
    avoid having to set the same property values for all the texts we use in the user
    interface:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们使用了一个名为`Label`的元素。我们创建它是为了避免在用户界面中为所有使用的文本设置相同的属性值：
- en: '[PRE105]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The dial consists of a repeater that will create 12 elements. Each element is
    an item positioned using the earlier described function. The item has a label
    anchored to it that displays the given speed. We use `120+index*12*2` as the angle
    expression as we want "0" to be positioned at 120 degrees and each following item
    positioned 24 degrees further.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 旋钮由一个重复器组成，将创建12个元素。每个元素都是使用前面描述的函数定位的项目。项目有一个标签与之锚定，显示给定的速度。我们使用`120+index*12*2`作为角度表达式，因为我们希望“0”位于120度，每个后续项目再额外24度。
- en: The needle is given rotation based on the value read from the `carData` object.
    Since the angular distance between consecutive 20 kph labels is 24 degrees, the
    distance for one kph is 1.2 and thus we multiply `carData.speed` by that factor.
    Item rotation is calculated with 0 degrees "pointing right"; therefore, we add
    90 to the initial 120 degree offset of the first label to obtain starting coordinates
    matching those of the label system.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的旋转是基于从`carData`对象读取的值。由于连续20公里每小时标签之间的角度距离是24度，因此每公里每小时的距离是1.2，所以我们把`carData.speed`乘以这个系数。项目旋转是以0度“指向右”为基准计算的；因此，我们将第一个标签的初始120度偏移量加上90度，以获得与标签系统匹配的起始坐标。
- en: 'As you can see in the image, the speed dial contains small lines every 2 kph,
    with those divisible by 10 kph longer than others. We can use another `Repeater`
    to declare such ticks:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，速度旋钮每2公里每小时包含一条小线，那些可以被10公里每小时整除的线比其他线更长。我们可以使用另一个`Repeater`来声明这样的刻度：
- en: '[PRE106]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Finally, we can put a label for the dial:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以为旋钮添加一个标签：
- en: '[PRE107]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Make sure the label is declared before the dial needle, or give the needle a
    higher *z* value so that the label doesn't overpaint the needle.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在旋钮指针之前声明标签，或者给指针一个更高的*z*值，这样标签就不会覆盖指针。
- en: 'Next, repeat the process on your own for the left container by creating an
    RPM dial reading values from `carData.rpm`. The dial also displays the current
    gear of the car''s engine. Place the following code inside the `leftContainer`
    object definition:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过创建一个读取自`carData.rpm`的RPM旋钮，在自己的左侧容器中重复这个过程。旋钮也显示汽车发动机的当前档位。将以下代码放在`leftContainer`对象定义内部：
- en: '[PRE108]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The only part needing explanation is highlighted. It defines an array of gear
    labels starting with reverse, going through neutral, and then through five forward
    gears. The array is then indexed with the current gear and the text for that value
    is applied to the label. Notice that the value is incremented by 1, which means
    the 0th index of the array will be used when `carData.gear` is set to `1`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解释的唯一部分已经突出显示。它定义了一个从倒档开始，经过空档，然后是五个前进档位的档位标签数组。然后，该数组以当前档位进行索引，并将该值的文本应用于标签。请注意，值增加了1，这意味着当`carData.gear`设置为`1`时，将使用数组的0索引。
- en: We will not show how to implement the right container. You can do that easily
    yourself now with the use of the `Grid` positioner to lay out the labels and their
    values. To display the series of controls on the bottom of the right container
    (with texts `ABS`, `ESP`, `BRK`, and `CHECK`), you can use `Row` of `Label` instances.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会展示如何实现右侧容器。现在，你可以使用`Grid`定位器轻松地自己实现它，以布局标签及其值。要显示右侧容器底部的一系列控件（文本为`ABS`、`ESP`、`BRK`和`CHECK`），可以使用`Label`实例的`Row`。
- en: Now, start the program and begin moving the sliders on the widget. See how the
    Qt Quick scene follows the changes.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动程序并开始移动小部件上的滑块。看看Qt Quick场景是如何跟随变化的。
- en: '*What just happened?*'
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We have created a very simple `QObject` instance and exposed it as our "data
    model" to QML. The object has a number of properties that can receive different
    values. Changing a value results in emitting a signal, which in turn notifies
    the QML engine and causes bindings containing those properties to be reevaluated?
    As a result, our user interface gets updated.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个非常简单的 `QObject` 实例，并将其作为我们的“数据模型”暴露给 QML。该对象具有多个可以接收不同值的属性。更改值会导致发出信号，这反过来又会通知
    QML 引擎，并导致包含这些属性的绑定被重新评估？因此，我们的用户界面得到更新。
- en: The data interface between the QML and C++ worlds that we created is very simple
    and has a small number of properties. But as the amount of data we want to expose
    grows, the object can become cluttered. Of course, we can counter that effect
    by dividing it into multiple smaller objects each having separate responsibilities
    and then exporting all those objects to QML, but that is not always desirable.
    In our case, we can see that rpm and gear are properties of the engine sub-system
    so we could move them to a separate object; however, in reality, their values
    are tightly coupled with the speed of the car and to calculate the speed, we will
    need to know the values of those two parameters. But the speed also depends on
    other factors such as the slope of the road, so putting the speed into the engine
    sub-system object just doesn't seem right. Fortunately, there is a nice solution
    for that problem.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 QML 和 C++ 世界之间的数据接口非常简单，并且属性数量很少。但随着我们想要公开的数据量的增加，对象可能会变得杂乱。当然，我们可以通过将其分成多个具有单独职责的小对象来抵消这种效果，然后将所有这些对象导出到
    QML 中，但这并不总是理想的。在我们的情况下，我们可以看到 rpm 和 gear 是发动机子系统的属性，因此我们可以将它们移动到单独的对象中；然而，在现实中，它们的值与汽车的速度紧密相关，为了计算速度，我们需要知道这两个参数的值。但速度还取决于其他因素，例如道路的坡度，所以将速度放入发动机子系统对象中似乎并不合适。幸运的是，有一个很好的解决方案。
- en: Time for action – grouping engine properties
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 - 对发动机属性进行分组
- en: QML has a concept called grouped properties. These are properties of an object
    that contain a group of "sub-properties." You already know a number of them–the
    border property of the `Rectangle` element or the anchors property of the `Item`
    element, for example. Let's see how to define such properties for our exposed
    object.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: QML 有一个称为分组属性的概念。这些是一个对象的属性，包含了一组“子属性”。你已经知道其中的一些，例如 `Rectangle` 元素的边框属性或 `Item`
    元素的锚点属性。让我们看看如何为我们的公开对象定义这样的属性。
- en: 'Create a new `QObject`-derived class and call it `CarInfoEngine`. Move the
    property definitions of rpm and gear to that new `class.Add` the following property
    declaration to `CarInfo`:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的由 `QObject` 派生的类，并将其命名为 `CarInfoEngine`。将 rpm 和 gear 的属性定义移动到那个新类中，并在
    `CarInfo` 中添加以下属性声明：
- en: '[PRE109]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Implement the getter and the private field:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 实现获取器和私有字段：
- en: '[PRE110]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We are not going to use the signal right now; however, we had to declare it
    otherwise QML would complain we were binding expressions that depend on properties
    that are non-notifiable:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会使用这个信号；然而，我们必须声明它，否则 QML 会抱怨我们正在绑定依赖于非可通知属性的表达示：
- en: '[PRE111]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Initialize `m_engine` in the constructor of `CarInfo`:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CarInfo` 的构造函数中初始化 `m_engine`：
- en: '[PRE112]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Next, update the code of `CarInfo` to modify properties of `m_engine` whenever
    respective sliders on the widget are moved. Provide a link the other way, as well–if
    the property value is changed, update the user interface accordingly.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新 `CarInfo` 的代码，以便在部件上的相应滑块移动时修改 `m_engine` 的属性。也要提供反向链接，即如果属性值发生变化，相应地更新用户界面。
- en: 'Update the QML document and replace `carData.gear` with `carData.engine.gear`.
    Do the same for `carData.rpm` and `carData.engine.rpm`. You should end up with
    something along the lines of:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 QML 文档，将 `carData.gear` 替换为 `carData.engine.gear`。对 `carData.rpm` 和 `carData.engine.rpm`
    也做同样的处理。最终的结果应该是这样的：
- en: '[PRE113]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '*What just happened?*'
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Essentially, what we did is expose a property in `CarInfo` that is itself an
    object that exposes a set of properties. This object of the type `CarInfoEngine`
    is bound to the `CarInfo` instance it refers to.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们所做的是在 `CarInfo` 中公开了一个属性，该属性本身就是一个公开了一组属性的属性。这个类型为 `CarInfoEngine` 的对象绑定到了它所引用的
    `CarInfo` 实例上。
- en: Extending QML
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 QML
- en: Thus far, what we did was exposing to QML single objects created and initialized
    in C++. But we can do much more–the framework allows us to define new QML types.
    These can either be generic `QObject` derived QML elements or items specialized
    for Qt Quick. In this section, you will learn to do both.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Registering classes as QML elements
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with something simple–exposing the `CarInfo` type to QML so that
    instead of instantiating it in C++ and then exposing it in QML, we can directly
    declare the element in QML and still allow the changes made to the widget to be
    reflected in the scene.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a certain class (derived from `QObject`) instantiable in QML, all that
    is required is to register that class with the declarative engine using the `qmlRegisterType`
    template function. This function takes the class as its template parameter along
    a number of function arguments: the module `uri`, the major and minor version
    numbers, and the name of the QML type we are registering. The following call would
    register the class `FooClass` as the QML type `Foo`, available after importing
    `foo.bar.baz` in Version 1.0:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'You can place this invocation anywhere in your C++ code; just make sure this
    is before you try to load a QML document that might contain declarations of `Foo`
    objects. A typical place to put the function call is in the program''s main function:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Afterwards, you can start declaring objects of the type `Foo` in your documents.
    Just remember you have to import the respective module first:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Time for action – making CarInfo instantiable from QML
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will update the QML document to create an instance of `CarInfo` present
    in the CarInfo 1.0 module:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'As for registering `CarInfo`, it might be tempting to simply call `qmlRegisterType`
    on `CarInfo` and congratulate ourselves for a job well done:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'In general this would work (yes, it is as simple as that). However, at the
    time of writing, trying to instantiate any widget in a QML document as the child
    of some `QtQuick` item will lead to a crash (maybe at the time you are reading
    this text the issue will have already been resolved). To avoid this, we need to
    make sure that what we instantiate is not a widget. For that, we will use a proxy
    object that will forward our calls to the actual widget. Therefore, create a new
    class called `CarInfoProxy` derived from `QObject` and make it have the same properties
    as `CarInfo`, for example:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Declare one more property that will let us show and hide the widget on demand:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Then, we can place the widget as a member variable of the proxy so that it
    is created and destroyed alongside its proxy:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Next, implement the missing interface. For simplicity, we are showing you code
    for some of the properties. The others are similar so you can fill in the gaps
    on your own:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'You can see that we reuse the `CarInfoEngine` instance from the widget instead
    of duplicating it in the proxy class. Finally, we can register `CarInfoProxy`
    as `CarInfo`:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'If you run the code now, you will see it works–`CarInfo` has become a regular
    QML element. Because of this, its properties can be set and modified directly
    in the document, right? If you try setting the speed or the distance, it will
    work just fine. However, as soon as you try setting any of the properties grouped
    in the engine property, QML runtime will start complaining with a message similar
    to the following one:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行代码，你会看到它工作得很好——`CarInfo` 已经成为了一个常规的 QML 元素。正因为如此，它的属性可以直接在文档中设置和修改，对吧？如果你尝试设置速度或距离，它将正常工作。然而，一旦你尝试设置任何在引擎属性中分组的属性，QML
    运行时将开始抱怨，显示类似于以下的消息：
- en: '[PRE124]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: This is because the runtime does not understand the engine property–we declared
    it as `QObject` and yet we are using a property this class doesn't have. To avoid
    this issue, we have to teach the runtime about `CarInfoEngine`.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为运行时不理解引擎属性——我们将其声明为 `QObject`，但我们使用了一个这个类没有的属性。为了避免这个问题，我们必须教运行时关于 `CarInfoEngine`
    的知识。
- en: 'First, let''s update the property declaration macro to use `CarInfoEngine`
    instead of `QObject`:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新属性声明宏，使用 `CarInfoEngine` 而不是 `QObject`：
- en: '[PRE125]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'And the getter function itself, as well:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 以及获取函数本身：
- en: '[PRE126]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Then, we should teach the runtime about the type:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该教运行时关于类型的知识：
- en: '[PRE127]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '*What just happened?*'
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In this exercise, we let the QML runtime know about two new elements. One of
    them is `CarInfo`, which is a proxy to our widget class. We told the engine this
    is a full-featured class that is instantiable from QML. The other class, `CarInfoEngine`,
    also became known to QML; however, the difference is that every attempt to declare
    an object of this type in QML fails with a given warning message. There are other
    functions available for registering types in QML but they are rarely used, so
    we will not be describing them here. If you are curious about them, type in qmlRegister
    in the Index tab of Creator's **Help** pane.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们让 QML 运行时了解两个新元素。其中一个是 `CarInfo`，它是我们小部件类的代理。我们告诉引擎这是一个具有完整功能的类，可以从
    QML 中实例化。另一个类 `CarInfoEngine` 也被 QML 所知；然而，区别在于在 QML 中声明此类对象的每个尝试都会以给定的警告消息失败。QML
    中有其他用于注册类型的函数，但它们很少使用，所以我们不会在这里描述它们。如果你对此好奇，可以在 Creator 的 **帮助** 面板的索引选项卡中输入 `qmlRegister`。
- en: Custom Qt Quick items
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 Qt Quick 项目
- en: It is nice to be able to create new QML element types that can be used to provide
    dynamic data engines or some other type of non-visual objects; however, this chapter
    is about Qt Quick so it is time now to learn how to provide new types of items
    to Qt Quick.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 能够创建新的 QML 元素类型，这些类型可以用来提供动态数据引擎或其他类型的非视觉对象，这很好；然而，这一章是关于 Qt Quick 的，现在是时候学习如何向
    Qt Quick 提供新的项目类型了。
- en: The first question you should ask yourself is whether you really need a new
    type of item. Maybe you can achieve the same goal with already existing elements?
    Very often you can use vector or bitmap images to use custom shapes in your applications,
    or you can use Canvas to quickly draw the graphics you need directly in QML.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该问自己的第一个问题是你是否真的需要一个新类型的元素。也许你可以用已经存在的元素达到同样的目标？非常常见的是，你可以在应用程序中使用矢量或位图图像来使用自定义形状，或者你可以使用
    Canvas 在 QML 中直接快速绘制所需的图形。
- en: If you decide that you do require custom items, you will be doing that by implementing
    subclasses of `QQuickItem`, which is the base class for all items in Qt Quick.
    After creating the new type, you will always have to register it with QML using
    `qmlRegisterType`.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定你需要自定义项目，你将通过实现 `QQuickItem` 的子类来完成，这是 Qt Quick 中所有项目的基类。创建新类型后，你将始终需要使用
    `qmlRegisterType` 将其注册到 QML 中。
- en: OpenGL items
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenGL 项目
- en: To provide very fast rendering of its scene, Qt Quick uses a mechanism called
    scene-graph. The graph consists of a number of nodes of well-known types, each
    describing a primitive shape to be drawn. The framework makes use of knowledge
    of each of the primitives allowed and their parameters to find the most performance-wise
    optimal order in which items can be rendered. Rendering itself is done using OpenGL,
    and all the shapes are defined in terms of OpenGL calls.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供非常快速的场景渲染，Qt Quick 使用了一种称为场景图的机制。该图由多个已知类型的节点组成，每个节点描述一个要绘制的原始形状。框架利用对每个允许的原始形状及其参数的知识，找到渲染项目时性能最优的顺序。渲染本身使用
    OpenGL 进行，所有形状都使用 OpenGL 调用来定义。
- en: Providing new items for Qt Quick boils down to delivering a set of nodes that
    define the shape using terminology the graph understands. This is done by subclassing
    `QQuickItem` and implementing the pure virtual `updatePaintNode()` method, which
    is supposed to return a node that will tell the scene-graph how to render the
    item. The node will most likely be a describing a geometry (shape) with a material
    (color, texture) applied.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 为Qt Quick提供新项归结为提供一组节点，这些节点使用图形理解的术语定义形状。这是通过子类化`QQuickItem`并实现纯虚函数`updatePaintNode()`来完成的，该函数应该返回一个节点，告诉场景图如何渲染项。该节点很可能是描述一个应用了材质（颜色、纹理）的几何形状（形状）。
- en: Time for action – creating a regular polygon item
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建正多边形项
- en: 'Let''s learn about the scene-graph by delivering an item class for rendering
    convex regular polygons. We will draw the polygon using the OpenGL drawing mode
    called "triangle fan." It draws a set of triangles that all have a common vertex.
    Subsequent triangles are defined by the shared vertex, the vertex from the previous
    triangle, and the next vertex specified. Have a look at the diagram to see how
    to draw a hexagon as a triangle fan using 8 vertices as control points:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过提供一个用于渲染凸正多边形的项类来了解场景图。我们将使用称为“三角形扇”的OpenGL绘图模式来绘制多边形。它绘制了一组所有三角形都具有公共顶点的三角形。后续的三角形由共享顶点、前一个三角形的顶点和指定的下一个顶点定义。看看图解，了解如何使用8个控制点将六边形作为三角形扇绘制：
- en: '![Time for action – creating a regular polygon item](img/8874OS_09_25.jpg)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 创建正多边形项](img/8874OS_09_25.jpg)'
- en: The same method applies for any regular polygon. The first vertex defined is
    always the shared vertex occupying the center of the shape. The remaining points
    are positioned on the circumference of a bounding circle of the shape at equal
    angular distances. The angle is easily calculated by dividing the full angle by
    the number of sides. For a hexagon, this yields 60 degrees.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法适用于任何正多边形。定义的第一个顶点始终是占据形状中心的共享顶点。其余的点均匀地位于形状边界圆的圆周上。角度可以通过将完整角度除以边的数量来轻松计算。对于六边形，这会产生60度。
- en: 'Let''s get down to business and the subclass `QQuickItem`. We will give it
    a very simple interface:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始处理子类`QQuickItem`。我们将给它一个非常简单的接口：
- en: '[PRE128]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Our polygon is defined by the number of sides and fill color. We also get everything
    we inherited from `QQuickItem`, including the width and height of the item. Besides
    the obvious getters and setters for the properties, we define just one method–`updatePaintNode()`,
    which is responsible for building the scene-graph.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的正多边形由边的数量和填充颜色定义。我们还继承了从`QQuickItem`继承的所有内容，包括项的宽度和高度。除了明显的属性获取器和设置器之外，我们只定义了一个方法–`updatePaintNode()`，它负责构建场景图。
- en: 'Before we deal with updating graph nodes, let''s deal with the easy parts first.
    Implement the constructor as follows:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理更新图形节点之前，让我们先处理容易的部分。构造函数实现如下：
- en: '[PRE129]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: We make our polygon a hexagon by default. We also set a flag, `ItemHasContents`,
    which tells the scene-graph that the item is not fully transparent and should
    ask us how the item should be painted by calling `updatePaintNode()`. This is
    an early optimization to avoid having to prepare the whole infrastructure if the
    item would not be painting anything anyway.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 我们默认将我们的多边形设置为六边形。我们还设置了一个标志`ItemHasContents`，它告诉场景图项不是完全透明的，并且应该通过调用`updatePaintNode()`来询问我们项应该如何绘制。这是一个早期优化，以避免在项根本不会绘制任何内容的情况下准备整个基础设施。
- en: 'The setters are also quite easy to grasp:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 设置器也很容易理解：
- en: '[PRE130]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'A polygon has to have at least three sides; thus, we enforce this as a minimum,
    sanitizing the input value with `qMax`. After we change any of the properties
    that might influence the look of the item, we call `update()` to let Qt Quick
    know that the item needs to be rerendered. Let''s tackle `updatePaintNode()` now.
    We''ll disassemble it into smaller pieces so that it is easier for you to understand
    how the function works:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形至少需要有三条边；因此，我们通过`qMax`强制执行这个最小值，对输入值进行清理。在我们更改可能影响项外观的任何属性之后，我们调用`update()`让Qt
    Quick知道项需要重新渲染。现在让我们处理`updatePaintNode()`。我们将将其分解成更小的部分，这样你更容易理解函数的工作方式：
- en: '[PRE131]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'When the function is called, it might receive a node it returned during a previous
    call. Be aware the graph is free to delete all the nodes when it feels like it,
    so you should never rely on the node being there even if you returned a valid
    node during the previous run of the function:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时，它可能会收到在之前的调用中返回的节点。请注意，图可以自由删除所有节点，因此即使在函数的前一次运行中返回了一个有效的节点，您也不应该依赖于节点存在：
- en: '[PRE132]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The node we are going to return is a geometry node that contains information
    about the geometry and the material of the shape being drawn. We will be filling
    those variables as we go through the method:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要返回的节点是一个包含要绘制的形状的几何和材质信息的几何节点。我们将随着方法的进行填充这些变量：
- en: '[PRE133]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'As we already mentioned, the function is called with the previously returned
    node as the argument but we should be prepared for the node not being there and
    we should create it. Thus, if that is the case, we create a new `QSGGeometryNode`
    and a new `QSGGeometry` for it. The geometry constructor takes a so-called attribute
    set as its parameter, which defines a layout for data in the geometry. Most common
    layouts have been predefined:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，函数使用之前返回的节点作为参数调用，但我们应该准备好节点可能不存在的情况，并且应该创建它。因此，如果这种情况发生，我们将创建一个新的`QSGGeometryNode`以及为其创建一个新的`QSGGeometry`。几何构造函数接受一个所谓的属性集作为其参数，该参数定义了几何中数据的布局。大多数常见的布局已经被预定义：
- en: '| Attribute set | Usage | First attribute | Second attribute |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| 属性集 | 用途 | 第一个属性 | 第二个属性 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `Point2D` | `Solid colored shape` | `float x, y` | `-` |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| `Point2D` | `Solid colored shape` | `float x, y` | `-` |'
- en: '| `ColoredPoint2D` | `Per-vertex color` | `float x, y` | `uchar red, green,
    blue, alpha` |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| `ColoredPoint2D` | `Per-vertex color` | `float x, y` | `uchar red, green,
    blue, alpha` |'
- en: '| `TexturedPoint2D` | `Per-vertex texture coordinate` | `float x, y` | `float
    tx, float ty` |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| `TexturedPoint2D` | `Per-vertex texture coordinate` | `float x, y` | `float
    tx, float ty` |'
- en: We will be defining the geometry in terms of 2D points without any additional
    information attached to each point; therefore, we pass `QSGGeometry::defaultAttributes_Point2D()`
    to construct the layout we need. As you can see in the preceding table for that
    layout, each attribute consists of two floating point values denoting the *x*
    and *y* coordinates of a point.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用2D点来定义几何，每个点不附加任何额外信息；因此，我们传递`QSGGeometry::defaultAttributes_Point2D()`来构建我们需要的布局。正如您在前面的表中可以看到，该布局的每个属性由两个浮点值组成，表示一个点的*x*和*y*坐标。
- en: 'The second argument of the `QSGGeometry` constructor informs us about the number
    of vertices we will be using. The constructor will allocate as much memory as
    is needed to store the required number of vertices using the given attribute layout.
    After the geometry container is ready, we pass its ownership to the geometry node
    so that when the geometry node is destroyed, the memory for the geometry is freed
    as well. At this moment, we also mark that we are going to be rendering in the
    `GL_TRIANGLE_FAN` mode:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSGGeometry`构造函数的第二个参数告诉我们我们将使用多少个顶点。构造函数将根据给定的属性布局分配足够的内存来存储所需数量的顶点。在几何容器准备好后，我们将它的所有权传递给几何节点，以便当几何节点被销毁时，几何的内存也会被释放。在这个时候，我们还标记我们将以`GL_TRIANGLE_FAN`模式进行渲染：'
- en: '[PRE134]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The process is repeated for the material. We use `QSGFlatColorMaterial` as
    the whole shape is going to have one color that is set from `m_color`. Qt provides
    a number of predefined material types. For example, if we wanted to give each
    vertex a separate color, we would have used `QSGVertexColorMaterial` together
    with the `ColoredPoint2D` attribute layout:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程对材质重复进行。我们使用`QSGFlatColorMaterial`作为整个形状将有一个从`m_color`设置的单一颜色。Qt提供了一些预定义的材质类型。例如，如果我们想要给每个顶点一个单独的颜色，我们会使用`QSGVertexColorMaterial`与`ColoredPoint2D`属性布局一起：
- en: '[PRE135]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'This piece of code deals with a situation in which `oldNode` did contain a
    valid pointer to a node that was already initialized. In this case, we only need
    to make sure the geometry can hold as many vertices as we need in case the number
    of sides changed since the last time the function was executed:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码处理了`oldNode`确实包含了一个指向已经初始化的节点的有效指针的情况。在这种情况下，我们只需要确保几何可以容纳我们需要的顶点数量，以防自上次函数执行以来边的数量发生了变化：
- en: '[PRE136]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'This is repeated for the material. If the color differs, we reset it and tell
    the geometry node that the material needs to be updated by marking the `DirtyMaterial`
    flag:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于材质也是重复的。如果颜色不同，我们将重置它，并通过标记`DirtyMaterial`标志来告诉几何节点材质需要更新：
- en: '[PRE137]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Finally, we can set vertex data. First, we ask the geometry object to prepare
    a mapping for us from the allocated memory to a `QSGGeometry::Point2D` structure,
    which can be used to conveniently set data for each vertex. Then, actual calculations
    are performed using the equation for calculating points on a circle. The radius
    of the circle is taken as the smaller part of the width and height of the item
    so that the shape is centered in the item. As you can see on the diagram at the
    beginning of the exercise, the last point in the array has the same coordinates
    as the second point in the array to close the fan into a regular polygon:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以设置顶点数据。首先，我们要求几何对象为我们准备一个从分配的内存到`QSGGeometry::Point2D`结构的映射，这样我们可以方便地为每个顶点设置数据。然后，使用计算圆上点的方程进行实际计算。圆的半径取为项目宽度和高度的较小部分，以便形状在项目中居中。正如你在练习开始时的图中可以看到的，数组中的最后一个点与数组中的第二个点具有相同的坐标，以便将扇形闭合成一个正多边形：
- en: '[PRE138]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: At the very end, we mark the geometry as changed and return the node to the
    caller.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将几何标记为已更改，并将节点返回给调用者。
- en: '*What just happened?*'
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Rendering in Qt Quick can happen in a thread different than the main thread.
    By implementing `updatePaintNode()`, we performed synchronization between the
    GUI thread and the rendering thread. The function executing the main thread is
    blocked. Due to this reason, it is crucial that it executes as quickly as possible
    and doesn't do any unnecessary calculations as this directly influences performance.
    This is also the only place in your code where you can safely call functions from
    your item (such as reading properties) as well as interact with the scene-graph
    (creating and updating the nodes). Try not emitting any signals nor creating any
    objects from within this method as they will have affinity to the rendering thread
    rather than the GUI thread.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Quick中的渲染可以发生在主线程之外的线程。通过实现`updatePaintNode()`，我们在GUI线程和渲染线程之间进行了同步。执行主线程的函数被阻塞。由于这个原因，它必须尽可能快地执行，并且不要进行任何不必要的计算，因为这会直接影响性能。这也是你可以在代码中安全调用你的项目函数（如读取属性）以及与场景图（创建和更新节点）交互的唯一地方。尽量不要在这个方法中发出任何信号或创建任何对象，因为它们将具有与渲染线程而不是GUI线程的亲和力。
- en: 'Having said that, you can now register your class with QML and test it with
    the following QML document:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你现在可以将你的类注册到QML中，并使用以下QML文档进行测试：
- en: '[PRE139]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'This should give you a nice blue pentagon. If the shape looks aliased, you
    can enforce anti-aliasing on the window:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给你一个漂亮的蓝色五边形。如果形状看起来是锯齿状的，你可以在窗口上强制抗锯齿：
- en: '[PRE140]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Have a go hero – creating a supporting border for RegularPolygon
  id: totrans-581
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄 – 创建RegularPolygon的支持边框
- en: 'What is returned by `updatePaintNode()` might not just be a single `QSGGeometryNode`
    but also a larger tree of `QSGNode` items. Each node can have any number of child
    nodes. By returning a node that has two geometry nodes as children, you can draw
    two separate shapes in the item:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '`updatePaintNode()`返回的可能是单个`QSGGeometryNode`，也可能是一个更大的`QSGNode`项树。每个节点可以有任意数量的子节点。通过返回一个有两个几何节点作为子节点的节点，你可以在项目中绘制两个不同的形状：'
- en: '![Have a go hero – creating a supporting border for RegularPolygon](img/8874OS_09_26.jpg)'
  id: totrans-583
  prefs: []
  type: TYPE_IMG
  zh: '![尝试英雄 – 创建RegularPolygon的支持边框](img/8874OS_09_26.jpg)'
- en: 'As a challenge, extend `RegularPolygon` to draw not only the internal filled
    part of the polygon but also an edge that can be of a different color. You can
    draw the edge using the `GL_QUAD_STRIP` drawing mode. Coordinates of the points
    are easy to calculate–the points closer to the middle of the shape are the same
    points that form the shape itself. The remaining points also lie on a circumference
    of a circle that is slightly larger (by the width of the border). Therefore, you
    can use the same equations to calculate them. The `GL_QUAD_STRIP` mode renders
    quadrilaterals with every two vertices specified after the first four, composing
    a connected quadrilateral. The following diagram should give you a clear idea
    of what we are after:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 作为挑战，扩展`RegularPolygon`以绘制多边形的内部填充部分以及不同颜色的边。你可以使用`GL_QUAD_STRIP`绘制模式来绘制边。点的坐标很容易计算——靠近形状中间的点就是形成形状本身的点。其余的点也位于一个略微更大的圆的圆周上（边框的宽度）。因此，你可以使用相同的方程来计算它们。`GL_QUAD_STRIP`模式通过指定在第一个四个顶点之后的每两个顶点来渲染四边形，组成一个连接的四边形。以下图表应该能清楚地说明我们想要达到的效果：
- en: '![Have a go hero – creating a supporting border for RegularPolygon](img/8874OS_09_27.jpg)'
  id: totrans-585
  prefs: []
  type: TYPE_IMG
  zh: '![尝试英雄 – 创建RegularPolygon的支持边框](img/8874OS_09_27.jpg)'
- en: Painted items
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制的项目
- en: Implementing items in OpenGL is quite difficult–you need to come up with an
    algorithm of using OpenGL primitives to draw the shape you want, and then you
    also need to be skilled enough with OpenGL to build a proper scene graph node
    tree for your item. But there is another way–you can create items by painting
    them with `QPainter`. This comes at a cost of performance as behind the scenes,
    the painter draws on an indirect surface (a frame buffer object or an image) that
    is then converted to OpenGL texture and rendered on a quad by the scene-graph.
    Even considering that performance hit, it is often much simpler to draw the item
    using a rich and convenient drawing API than to spend hours doing the equivalent
    in OpenGL or by using Canvas.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中实现项目相当困难 – 你需要想出一个算法，使用OpenGL原语来绘制你想要的形状，然后你还需要足够熟练地使用OpenGL来为你的项目构建一个合适的场景图节点树。但还有另一种方法
    – 你可以通过使用`QPainter`来绘制项目。这会带来性能上的损失，因为幕后，画家在一个间接的表面（一个帧缓冲对象或一个图像）上绘制，然后场景图将其转换为OpenGL纹理并在四边形上渲染。即使考虑到这种性能损失，使用丰富且方便的绘图API来绘制项目通常比在OpenGL或使用Canvas上花费数小时做同样的事情要简单得多。
- en: To use that approach, we will not be subclassing `QQuickItem` directly but rather
    `QQuickPaintedItem`, which gives us the infrastructure needed to use the painter
    for drawing items.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种方法，我们不会直接子类化`QQuickItem`，而是`QQuickPaintedItem`，这为我们提供了使用画家绘制项目所需的基础设施。
- en: Basically, all we have to do, then, is implement the pure virtual `paint()`
    method that renders the item using the received painter. Let's see this put into
    practice and combine it with the skills we gained earlier.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们基本上需要做的就是实现纯虚`paint()`方法，该方法使用接收到的画家渲染项目。让我们看看这个实践，并将其与我们之前获得的技术结合起来。
- en: Time for action – creating an item for drawing outlined text
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建用于绘制轮廓文本的项目
- en: 'The goal of the current exercise is to be able to make the following QML code
    work:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 当前练习的目标是能够使以下QML代码工作：
- en: '[PRE141]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'And produce the following result:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个结果：
- en: '![Time for action – creating an item for drawing outlined text](img/8874OS_09_28.jpg)'
  id: totrans-594
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 创建用于绘制轮廓文本的项目](img/8874OS_09_28.jpg)'
- en: 'Start with an empty Qt project with the `core`, `gui`, and `quick` modules
    activated. Create a new class and call it `OutlineTextItemBorder`. Delete the
    implementation file as we are going to put all code into the header file. Place
    the following code into the class definition:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个激活了`core`、`gui`和`quick`模块的空Qt项目开始。创建一个新的类，并将其命名为`OutlineTextItemBorder`。删除实现文件，因为我们将要把所有代码放入头文件中。将以下代码放入类定义中：
- en: '[PRE142]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: You can see that `Q_PROPERTY` macros don't have the `READ` and `WRITE` keywords
    we've been using thus far. This is because we are taking a shortcut right now
    and we let `moc` produce code that will operate on the property by directly accessing
    the given class member. Normally, we would recommend against such an approach
    as without getters, the only way to access the properties is through the generic
    `property()` and `setProperty()` calls. However, in this case, we are not going
    to be exposing this class to the public in C++ so we won't need the setters, and
    we implement the getters ourselves, anyway. The nice thing about the `MEMBER`
    keyword is that if we also provide the `NOTIFY` signal, the generated code will
    emit that signal when the value of the property changes, which will make property
    bindings in QML work as expected. The rest of the class is pretty simple–we are,
    in fact, providing a class for defining a pen that is going to be used for stroking
    text, so implementing a method that returns the actual pen seems like a good idea.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`Q_PROPERTY`宏没有我们迄今为止使用的`READ`和`WRITE`关键字。这是因为我们现在正在走捷径，我们让`moc`生成代码，该代码将通过直接访问给定的类成员来操作属性。通常，我们不会推荐这种做法，因为没有getter，访问属性的唯一方法是通过通用的`property()`和`setProperty()`调用。然而，在这种情况下，我们不会将这个类公开在C++中，所以我们不需要设置器，我们仍然会实现getter。关于`MEMBER`关键字的好处是，如果我们还提供了`NOTIFY`信号，生成的代码将在属性值变化时发出该信号，这将使QML中的属性绑定按预期工作。类的其余部分相当简单
    – 实际上，我们正在提供一个用于定义将要用于描边文本的笔的类。实现一个返回实际笔的方法似乎是个好主意。
- en: 'The class will provide a grouped property for our main item class. Create a
    class called `OutlineTextItem` and derive it from `QQuickPaintedItem`, as follows:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 该类将为我们的主要项目类提供一个分组属性。创建一个名为`OutlineTextItem`的类，并从`QQuickPaintedItem`派生，如下所示：
- en: '[PRE143]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The interface defines properties for the text to be drawn, in addition to its
    color, font, and the grouped property for the outline data. Again, we use `MEMBER`
    to avoid having to manually implement getters and setters. Unfortunately, this
    makes our constructor code more complicated as we still need a way to run some
    code when any of the properties are modified. Implement the constructor using
    the following code:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义了要绘制的文本的属性，包括其颜色、字体以及轮廓数据的分组属性。同样，我们使用 `MEMBER` 以避免手动实现获取器和设置器。不幸的是，这使得我们的构造函数代码更加复杂，因为我们仍然需要一种方法在任何属性被修改时运行一些代码。使用以下代码实现构造函数：
- en: '[PRE144]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'We basically connect all the property change signals from both the object and
    its grouped property object to the same slot that is going to update the data
    for the item if any of its components are modified. We also call the same slot
    directly to prepare the initial state of the item. The slot can be implemented
    like this:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上将对象及其分组属性对象的所有属性更改信号连接到同一个槽，该槽将更新项目的数据，如果其任何组件被修改。我们还直接调用相同的槽来准备项目的初始状态。槽可以像这样实现：
- en: '[PRE145]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'At the beginning, the function resets a painter path object that serves as
    a backend for drawing outlined text and initializes it with the text drawn using
    the font set. Then, the slot calculates the bounding rect for the path using a
    function `shape()` that we will shortly see. Finally, it sets the calculated size
    as the size hint for the item and asks the item to repaint itself with the `update()`
    call:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，该函数重置了一个画家路径对象，该对象作为绘制带轮廓文本的后端，并使用设置的字体初始化它。然后，槽函数使用我们很快就会看到的 `shape()`
    函数计算路径的边界矩形。最后，它将计算出的尺寸设置为项目的尺寸提示，并通过 `update()` 调用请求项目重新绘制：
- en: '[PRE146]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The `shape()` function returns a new painter path that includes both the original
    path and its outline created with the `QPainterPathStroker` object. This is so
    that the width of the stroke is correctly taken into account when calculating
    the bounding rectangle. We use `controlPointRect()` to calculate the bounding
    rectangle as it is much faster than `boundingRect()` and returns an area greater
    or equal to the one `boundingRect()` would, which is okay for us.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '`shape()` 函数返回一个新的画家路径，它包括原始路径以及使用 `QPainterPathStroker` 对象创建的轮廓。这样做是为了在计算边界矩形时正确考虑笔触的宽度。我们使用
    `controlPointRect()` 来计算边界矩形，因为它比 `boundingRect()` 快得多，并且返回的面积大于或等于 `boundingRect()`
    会返回的面积，这对我们来说是可以接受的。'
- en: 'What remains is to implement the `paint()` routine itself:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作是实现 `paint()` 例程本身：
- en: '[PRE147]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The code is really simple–we bail out early if there is nothing to draw. Otherwise,
    we set up the painter using the pen and color obtained from the item's properties.
    We enable anti-aliasing and calibrate the painter coordinates with that of the
    bounding rectangle of the item. Finally, we draw the path on the painter.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单——如果没有东西要绘制，我们就会提前退出。否则，我们使用从项目属性中获得的笔和颜色设置画家。我们启用抗锯齿并使用项目的边界矩形校准画家坐标。最后，我们在画布上绘制路径。
- en: '*What just happened?*'
  id: totrans-610
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'During this exercise, we made use of the powerful API of Qt''s graphical engine
    to complement an existing set of Qt Quick items with a simple functionality. This
    is otherwise very hard to achieve using predefined Qt Quick elements and even
    harder to implement using OpenGL. We agreed to take a small performance hit in
    exchange for having to write just about a hundred lines of code to have a fully
    working solution. Remember to register the class with QML if you want to use it
    in your code:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次练习中，我们利用了 Qt 图形引擎强大的 API，通过简单的功能来补充现有的 Qt Quick 元素集。否则，使用预定义的 Qt Quick 元素来实现这一点非常困难，而使用
    OpenGL 实现则更加困难。我们同意为了只需编写大约一百行代码就能得到一个完全工作的解决方案，而牺牲一点性能。如果你想在代码中使用它，请记住将类注册到 QML
    中：
- en: '[PRE148]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Summary
  id: totrans-613
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have been familiarized with a declarative language called
    QML. The language is used to drive Qt Quick–a framework for highly dynamic and
    interactive content. You learned the basics of Qt Quick–how to create documents
    with a number of element types and how to create your own in QML or in C++. You
    also learned how to bind expressions to properties to automatically re-evaluate
    them. But so far, despite us talking about "fluid" and "dynamic" interfaces, you
    haven't seen much of that. Do not worry; in the next chapter, we will focus on
    animations in Qt Quick, as well as fancy graphics and applying what you learned
    in this chapter for creating nice looking and interesting games. So, read on!
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经熟悉了一种名为QML的声明性语言。这种语言用于驱动Qt Quick——一个用于高度动态和交互式内容的框架。你学习了Qt Quick的基础知识——如何使用多种元素类型创建文档，以及如何在QML或C++中创建自己的元素。你还学习了如何将表达式绑定到属性上，以便自动重新评估它们。但到目前为止，尽管我们谈论了“流畅”和“动态”的界面，你还没有看到很多这样的内容。不要担心；在下一章中，我们将专注于Qt
    Quick中的动画，以及一些花哨的图形，并将本章所学应用于创建看起来不错且有趣的游戏。所以，继续阅读吧！
