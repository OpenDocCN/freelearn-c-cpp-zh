- en: Chapter 9. Super Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。超级模型
- en: 'In the previous chapter, you created a framework to render OpenGL in 3D. At
    the very end of that chapter, we added a block of code that rendered a cube. In
    this chapter, you will learn how to create 3D objects in Open GL, first using
    code, and then using a 3D modeling program. In this chapter, we will cover the
    following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你创建了一个框架来在3D中渲染OpenGL。在那个章节的结尾，我们添加了一块代码，用来渲染一个立方体。在本章中，你将学习如何在OpenGL中创建3D对象，首先是通过代码，然后是通过3D建模程序。在本章中，我们将涵盖以下内容：
- en: '**Graphics cards**: 3D graphics cards are basically small computers that are
    optimized to render objects in 3D. We will take a quick look at how a graphics
    card does what it does best.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显卡**：3D显卡基本上是小型计算机，它们被优化来渲染3D对象。我们将快速了解一下显卡是如何做到它最擅长的事情的。'
- en: '**Vertices**: 3D objects are drawn by plotting points and telling OpenGL to
    use these points to create an object that can be rendered on the screen.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点**：3D对象是通过绘制点并告诉OpenGL使用这些点来创建一个可以在屏幕上渲染的对象来绘制的。'
- en: '**Triangles**: Triangles are used to create all 3D objects. You will learn
    about the relationship between vertices and triangles and how they are used to
    create simple objects.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三角形**：三角形被用来创建所有3D对象。你将了解顶点和三角形之间的关系以及它们是如何用来创建简单对象的。'
- en: '**Modeling**: Once you understand how to create simple 3D objects using code,
    you will also understand that you are going to need a more effective tool if you
    ever want to create anything complicated. This is where 3D modeling software comes
    in and saves the day.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建模**：一旦你了解了如何使用代码创建简单的3D对象，你也会明白，如果你想创建任何复杂的东西，你需要一个更有效的工具。这就是3D建模软件出现并拯救了局面。'
- en: Once you create a 3D model, you have to get the model into the game. We will
    create the code to load a 3D model into our game by reading the data that is created
    by the modeling software.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦创建了一个3D模型，你必须将模型放入游戏中。我们将通过读取建模软件生成的数据来创建代码，将3D模型加载到我们的游戏中。
- en: New Space
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新空间
- en: 'Until now, we have been working only in a two-dimensional space. This means
    that we were able create game objects with height and width. This works well because
    our computer screens are also two-dimensional. As we move into three-dimensional
    space, we need the ability to add another dimension to our objects: depth. As
    computer screens don''t physically have a third dimension in which to display
    pixels, this is all accomplished by mathematical wizardry!'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在二维空间中工作。这意味着我们能够创建具有高度和宽度的游戏对象。这很好，因为我们的计算机屏幕也是二维的。当我们进入三维空间时，我们需要给我们的对象添加另一个维度：深度。由于计算机屏幕在物理上没有第三个维度来显示像素，这一切都是通过数学魔法来实现的！
- en: 'In [Chapter 8](ch08.html "Chapter 8. Expanding Your Horizons"), *Expanding
    Your Horizons* we discussed several methods that have been used (and are still
    used) to simulate three-dimensions in a two-dimensional display:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章。拓展视野") *拓展视野* 中，我们讨论了几种在二维显示中模拟三维的方法：
- en: Objects that are farther away can be made to appear smaller than objects that
    are close
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离我们更远的对象可以显得比靠近我们的对象更小
- en: Objects that are farther away can be made to move more slowly than objects that
    are close
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离我们更远的对象可以显得比靠近我们的对象移动得更慢
- en: Lines that are parallel can be drawn to converge toward the center as they are
    farther away
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平行的线条可以画出向中心汇聚的趋势，随着它们离我们越来越远
- en: 'These three techniques have one major shortcoming: they all required the programmer
    to write code that makes each visual effect work. For example, the programmer
    has to make sure that objects that are receding from the player are constantly
    scaled down so that they become increasingly smaller.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种技术有一个主要的缺点：它们都要求程序员编写代码来使每个视觉效果工作。例如，程序员必须确保远离玩家的对象不断缩小，以便它们变得越来越小。
- en: In a true 3D game, the only thing that the programmer has to worry about is
    placing each object at the right coordinates in 3D space. A special graphics card
    takes care of performing all of the calculations to take care of size, speed,
    and parallax. This frees the programmer up from doing these calculations, but
    it actually adds a whole new set of requirements related to positing and rotating
    objects in three-dimensional space.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真正的3D游戏中，程序员唯一需要担心的是将每个对象放置在3D空间中的正确坐标。特殊的显卡负责执行所有与大小、速度和视差相关的计算。这使程序员从这些计算中解放出来，但实际上增加了与三维空间中定位和旋转对象相关的一整套新要求。
- en: A computer in a computer
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算机中的计算机
- en: 'The thing about what it takes for your computer to process your game. The computer
    must receive input from the player, interpret that input, and then apply the results
    to the game. Once the input is completed, the computer must handle the physics
    of the game: objects must be moved, collisions must happen, and explosions must
    ensue. Once the computer has completed updating all of the objects in the game,
    it must then render these results to the screen. Finally, in order to be convincing,
    all of this must occur at least 30 times a second and often 60 times a second!'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于你的计算机处理你的游戏所需的东西。计算机必须从玩家那里接收输入，解释那个输入，然后将结果应用于游戏。一旦输入完成，计算机必须处理游戏的物理：物体必须移动，碰撞必须发生，爆炸必须随之而来。一旦计算机更新了游戏中的所有物体，它必须将这些结果渲染到屏幕上。最后，为了让人信服，所有这些至少每秒发生30次，通常是每秒60次！
- en: It is truly amazing that computers can process this much information that quickly.
    In fact, if it were truly up to the central processing unit of your computer to
    accomplish this, then it wouldn't be able to keep up.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 真是令人惊讶，计算机可以如此快速地处理这么多信息。实际上，如果完全由你的计算机的中央处理器来完成这项工作，那么它将无法跟上。
- en: The 3D graphics card solves this problem by taking care of the rendering process
    so that the main CPU of your computer doesn't have to. All your CPU has to do
    is deliver the data and the graphics card takes care of the rest, allowing the
    main CPU to continue processing other things.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 3D显卡通过处理渲染过程来解决这个问题，这样你的计算机的主CPU就不必处理了。你的CPU只需提供数据，而显卡则处理其余部分，使主CPU可以继续处理其他事情。
- en: A modern 3D graphics card is really an entire computer system that lives on
    a silicon card inside your main computer. The graphics card is a computer inside
    your computer! The graphics card has its own input, output, and its own processor
    known as the graphics processing unit, or GPU. It also contains its own memory,
    often up to 4 gigabytes or more.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现代3D显卡实际上是一个完整的计算机系统，它位于你主计算机内部的硅芯片上。显卡就是你的计算机中的另一个计算机！显卡有自己的输入、输出，以及称为图形处理单元（GPU）的处理器。它还包含自己的内存，通常高达4GB或更多。
- en: 'The following diagram shows you the basic structure of a graphics card and
    how it processes information:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了显卡的基本结构和它如何处理信息：
- en: '![A computer in a computer](img/8199OS_09_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![计算机中的计算机](img/8199OS_09_01.jpg)'
- en: 'The preceding sequence that is depicted is known as the graphics pipeline.
    A detailed discussion of every step in the process is beyond the scope of our
    book, but it is good to have a basic understanding of the graphics pipeline, so
    here are the basics:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所描述的先前序列被称为图形管线。对过程中每一步的详细讨论超出了我们书籍的范围，但了解图形管线的基本知识是好的，所以这里有一些基础知识：
- en: '**Graphics bus**: In computer lingo, a bus is just a way to move data. Think
    of a bus as a freeway: the more lanes you have on our freeway, the faster the
    traffic can move. Inside your computer, the traffic is bits of data, and most
    modern graphics cards have 64 lanes (known as a 64-bit bus), which allows up to
    64-bits (or 8 bytes) of data to be moved simultaneously. The graphics bus receives
    its data directly from the CPU.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形总线**：在计算机术语中，总线只是移动数据的一种方式。将总线想象成高速公路：高速公路上的车道越多，交通就越快。在你的计算机内部，交通是数据位，而大多数现代显卡都有64条车道（称为64位总线），这允许同时移动多达64位（或8字节）的数据。图形总线直接从CPU接收其数据。'
- en: '**Graphics Processing Unit**: The GPU does all the work, and as you can see,
    there is a lot of work to do.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形处理单元**：GPU做所有的工作，正如你所看到的，有很多工作要做。'
- en: '**Transformation**: Each vertex, represented as a point in 3D space, must be
    properly positioned. There are several frames of reference to deal with. For example,
    local coordinates may describe how far a car''s tires are from its body, while
    global coordinates describe how far the car is from the upcoming cliff. All of
    the data must be transformed into a single frame of reference.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变换**：每个顶点，作为一个3D空间中的点，必须被正确放置。需要处理几个参考系。例如，局部坐标可能描述汽车轮胎与车身之间的距离，而全局坐标描述汽车与即将到来的悬崖之间的距离。所有数据都必须转换成单一的参考系。'
- en: '**Lighting**: Each vertex must be lit. This means applying light and color
    to each vertex and interpolating the light and color intensity from one vertex
    to another. In the same way that the sun lights our world, while fluorescent tubes
    light our offices, the GPU uses lighting data to correctly light the world of
    your game.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光照**：每个顶点都必须被照亮。这意味着将光和颜色应用到每个顶点，并从顶点之间插值光和颜色的强度。就像太阳照亮我们的世界，荧光灯照亮我们的办公室一样，GPU使用光照数据来正确照亮你的游戏世界。'
- en: '**Primitives**: These are the simple objects that are used to build more complicated
    objects. Similarly to a virtual Lego set, the GPU constructs everything in your
    game using triangles, rectangles, circles, cube, spheres, cones, and cylinders.
    We will learn more about this later in the chapter.'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本图形元素**：这些是用于构建更复杂对象的简单对象。类似于虚拟乐高积木套装，GPU使用三角形、矩形、圆形、立方体、球体、圆锥体和圆柱体来构建你在游戏中的所有内容。我们将在本章后面了解更多关于这方面的内容。'
- en: '**Projection**: Once the GPU has constructed a 3D model of the world, it must
    now create a 3D projection of the world onto 2D space (remember, your display
    only has two dimensions). This is similar to how the sun projects a 2D shadow
    of 3D objects.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投影**：一旦GPU构建了世界的3D模型，它现在必须将世界的3D投影到2D空间（记住，你的显示只有两个维度）。这类似于太阳如何将3D物体的2D影子投影出来。'
- en: '**Clipping**: Once the 3D scene has been projected into 2D space, some vertices
    will be behind other vertices, and, therefore, can''t actually be seen at this
    time. Clipping, or removing vertices that can''t be seen, removes these vertices
    from the data, streamlining the entire process.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**裁剪**：一旦3D场景被投影到2D空间，一些顶点将位于其他顶点之后，因此在这个时候实际上看不到。裁剪，或移除不可见的顶点，将这些顶点从数据中移除，简化了整个过程。'
- en: '**Rasterization**: We now have a 2D model that mathematically represents the
    current image that must be displayed onto the screen. Rasterization is the process
    of converting this virtual image into actual pixels that must be displayed on
    the screen.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光栅化**：我们现在有一个二维模型，它从数学上表示了必须显示在屏幕上的当前图像。光栅化是将这个虚拟图像转换为实际像素的过程，这些像素必须显示在屏幕上。'
- en: '**Shading**: This final process determines the actual color that must be applied
    to each pixel on the screen to correctly display the model that has been created
    in the earlier phases. Code can even be written to manipulate the process to create
    special visual effects. Code that modifies the shading process in the graphics
    pipeline is called a shader.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**着色**：这个最终过程决定了必须应用到屏幕上每个像素的实际颜色，以正确显示在早期阶段创建的模型。甚至可以编写代码来操纵这个过程以创建特殊视觉效果。在图形管线中修改着色过程的代码被称为着色器。'
- en: '**Render**: Of course, the reason that we do all of this is so that we can
    display our game on the computer screen. The final output of the graphics pipeline
    is a representation of the current screen in the render buffer. Now, all the CPU
    has to do is swap the data in the render buffer to the actual screen buffer, and
    the result is the next frame in your game!'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染**：当然，我们之所以做所有这些，是为了能在计算机屏幕上显示我们的游戏。图形管线的最终输出是渲染缓冲区中当前屏幕的表示。现在，CPU只需要将渲染缓冲区中的数据交换到实际屏幕缓冲区，结果就是你在游戏中看到的下一帧！'
- en: By the way, you will notice that behind the scenes (the big arrow in the preceding
    image) everything is supported by dedicated memory on the graphics card. All of
    the data is moved from the CPU to the memory of the graphics card, where it is
    manipulated and processed before being sent back to the CPU. This means that memory
    on the main computer doesn't have to be set aside to handle graphics processing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，你会在幕后（前一张图中的大箭头）注意到，所有这些操作都是由显卡上的专用内存支持的。所有数据都是从CPU移动到显卡内存中，在那里它被处理和加工，然后再发送回CPU。这意味着主计算机上的内存不需要为处理图形而预留。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is important to understand that the preceding diagram is a generic representation
    of the graphics pipeline. Specific hardware on various graphics cards may handle
    things differently, and the OpenGL and DirectX specifications are slightly different,
    but the preceding diagram is still the basic pipeline.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，前面的图是图形管线的通用表示。不同显卡上的特定硬件可能处理方式不同，OpenGL和DirectX规范也略有不同，但前面的图仍然是基本管线。
- en: Drawing your weapons
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拿出你的武器
- en: It's time for us to learn how to draw things in OpenGL. Whether you are drawing
    your weapons, an alien spacecraft, or a blade of grass, it all starts by with
    very simple shapes that are combined to make more complex shapes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候让我们学习如何在OpenGL中绘制东西了。无论你是在绘制你的武器、外星飞船还是一片草叶，一切都是从非常简单的形状开始的，这些形状组合起来形成更复杂的形状。
- en: Getting primitive
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取原始形状
- en: 'The most basic shapes that can be drawn in OpenGL are known as primitives.
    The primitives that can be drawn by OpenGL include:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中可以绘制的最基本形状被称为原始形状。OpenGL可以绘制的原始形状包括：
- en: '**Points**: As the name suggests, a point renders a single point and is defined
    by a single vertex.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点**：正如其名所示，点渲染一个单独的点，由一个顶点定义。'
- en: '**Lines**: A line is rendered as a line drawn between two vertices.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线条**：线条通过两个顶点之间的线条进行渲染。'
- en: '**Triangles**: A triangle is defined by three vertices and the three lines
    that pass from one vertex to the other.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三角形**：三角形由三个顶点和连接这些顶点的三条线定义。'
- en: '**Quads**: A quad is defined by four vertices and the four lines that pass
    from one vertex to the other. Technically, a quad is actually two triangles that
    have been joined together at the hypotenuse.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**四边形**：四边形由四个顶点和连接这些顶点的四条线定义。技术上讲，四边形实际上是两个在斜边处连接在一起的三角形。'
- en: 'That''s it, folks! Everything known to exist can be created from these four
    primitives. Extrapolating into 3D, there are these 3D primitives:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，朋友们！已知存在的所有事物都可以从这四种原始形状中创建出来。在三维中进行外推，这里有这些三维原始形状：
- en: A plane is a 2D extrusion of a line (okay, I know that a plane isn't really
    3D!)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面是线的二维拉伸（好吧，我知道平面实际上并不是三维的！）
- en: A pyramid is a 3D representation of a quad and four triangles
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金字塔是四边形和四个三角形的3D表示。
- en: A cube is the 3D extrusion of a quad
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立方体是四边形的3D拉伸。
- en: A sphere is a 3D construct based on a circle, which is created by lines (yes,
    lines, and the shorter each line, the more convincing the circle)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球体是一个基于圆的三维结构，它由线条（是的，线条，线条越短，圆越有说服力）构成。
- en: A cylinder is a 3D extrusion of a circle
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆柱体是圆的三维拉伸。
- en: The objects in the preceding list aren't actually defined as OpenGL primitives.
    However, many 3D modeling programs refer to them as primitives because they are
    the simplest 3D objects to create.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表中的对象实际上并没有定义为OpenGL原始形状。然而，许多3D建模程序将它们称为原始形状，因为它们是最简单的三维对象之一。
- en: Drawing primitives
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制原始形状
- en: 'In the previous chapter, we created a cube using the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用以下代码创建了一个立方体：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s learn about how this code actually works:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来了解这段代码是如何实际工作的：
- en: Any time that we want to draw something in OpenGL, we first start by clearing
    the render buffer. In other words, every frame is drawn from scratch. The `glClear`
    function clears the buffer so that we can start drawing to it.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当我们想在OpenGL中绘制某物时，我们首先从清除渲染缓冲区开始。换句话说，每一帧都是从零开始绘制的。`glClear`函数清除缓冲区，以便我们可以开始绘制。
- en: Before we start drawing objects, we want to tell OpenGL where to draw them.
    The `glTranslatef` command moves us to a certain point in 3D space from which
    we will start our drawing (actually, `glTranslatef` moves the camera, but the
    effect is the same).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始绘制对象之前，我们希望告诉OpenGL在哪里绘制它们。`glTranslatef`命令将我们移动到三维空间中的某个点，从这个点开始我们的绘制（实际上，`glTranslatef`移动了相机，但效果是相同的）。
- en: If we want to rotate our object, then we provide that information with the `glRotatef`
    function. Recall that the cube in the previous chapter slowly rotated.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想旋转我们的对象，那么我们使用`glRotatef`函数提供该信息。回想一下，上一章中的立方体缓慢地旋转。
- en: Just before we provide vertices to OpenGL, we need to tell OpenGL how to interpret
    these vertices. Are they single points? Lines? Triangles? In our case, we defined
    vertices for the six squares that will make the faces of our cube, so we specify
    `glBegin(GL_QUADS)` to let OpenGL know that we are going to be providing the vertices
    for each quad. There are several other possibilities that we will describe next.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们向OpenGL提供顶点之前，我们需要告诉OpenGL如何解释这些顶点。它们是单独的点？线条？三角形？在我们的例子中，我们为构成立方体面的六个正方形定义了顶点，因此我们指定`glBegin(GL_QUADS)`以让OpenGL知道我们将为每个四边形提供顶点。接下来我们将描述几种其他可能性。
- en: In OpenGL, you specify the properties for each vertex just before you define
    the vertex. For example, we use the `glColor3f` function to define the color for
    the next set of vertices that we define. Each succeeding vertex will be drawn
    in this specified color until we change the color with another call to `glColor3f`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 OpenGL 中，你在定义顶点之前指定每个顶点的属性。例如，我们使用 `glColor3f` 函数来定义我们定义的下一组顶点的颜色。后续的每个顶点都将用这个指定的颜色绘制，直到我们通过另一个
    `glColor3f` 调用更改颜色。
- en: Finally, we define each vertex for the quad. As a quad requires four vertices,
    the next four `glVertex3f` calls will define one quad. If you look closely at
    the code, you will notice that there are six groups of four vertex definitions
    (each preceded by a color definition), which all work together to create the six
    faces of our cube.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为四边形定义每个顶点。由于四边形需要四个顶点，接下来的四个 `glVertex3f` 调用将定义一个四边形。如果你仔细查看代码，你会注意到有六组四顶点定义（每组前面都有一个颜色定义），它们共同作用来创建我们立方体的六个面。
- en: Now that you understand how OpenGL draws quads, let's expand your knowledge
    by covering the other types of primitives.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 OpenGL 如何绘制四边形，让我们通过介绍其他类型的原语来扩展你的知识。
- en: Making your point
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达观点
- en: There is only one kind of point primitive.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一种点原语。
- en: Gl_Points
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gl_Points
- en: The `glBegin(GL_POINTS)` function call tells OpenGL that each following vertex
    is to be rendered as a single point. Points can even have texture mapped onto
    them, and these are known as **point sprites**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`glBegin(GL_POINTS)` 函数调用告诉 OpenGL，每个后续的顶点都应该被渲染为一个单独的点。点甚至可以映射上纹理，这些被称为 **点精灵**。'
- en: Points are actually generated as squares of pixels based on the size defined
    by the `GL_PROGRAM_POINT_SIZE` parameter of the `glEnable` function. The size
    defines the number of pixels that each side of the point takes up. The point's
    position is defined as the center of that square.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 点实际上是根据 `glEnable` 函数的 `GL_PROGRAM_POINT_SIZE` 参数定义的大小生成的像素方块。大小定义了点每边的像素数。点的位置被定义为该方块的中心。
- en: 'The point size must be greater than zero, or else an undefined behavior results.
    There is an implementation-defined range for point sizes, and the size given by
    either method is clamped to that range. Two additional OpenGL properties determine
    how points are rendered: `GL_POINT_SIZE_RANGE` (returns 2 floats), and `GL_POINT_SIZE_GRANULARITY`.
    This particular OpenGL implementation will clamp sizes to the nearest multiple
    of the granularity.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 点的大小必须大于零，否则会产生未定义的行为。点的大小有一个实现定义的范围，给定的大小将被夹到这个范围内。还有两个 OpenGL 属性决定了点如何被渲染：`GL_POINT_SIZE_RANGE`（返回
    2 个浮点数）和 `GL_POINT_SIZE_GRANULARITY`。这个特定的 OpenGL 实现将大小夹到最接近的粒度倍数。
- en: Getting in line
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排队
- en: There are three kinds of line primitives, based on different interpretations
    the vertex list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据顶点列表的不同解释，有三种类型的线原语。
- en: Gl_Lines
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gl_Lines
- en: When you call `glBegin(GL_LINES)`, every pair of vertices is interpreted as
    a single line. Vertices 1 and 2 are considered one line. Vertices 3 and 4 are
    considered another line. If the user specifies an odd number of vertices, then
    the extra vertex is ignored.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `glBegin(GL_LINES)` 时，每一对顶点被解释为一条单独的线。顶点 1 和 2 被视为一条线。顶点 3 和 4 被视为另一条线。如果用户指定了奇数个顶点，则额外的顶点将被忽略。
- en: Gl_Line_Strip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gl_Line_Strip
- en: When you call `glBegin(GL_LINES)`, the first vertex defines the start of the
    first line. Each vertex thereafter defines the end of the previous line and the
    start of the next line. This has the effect of chaining the lines together up
    to the last vertex in the list. Thus, if you pass *n* vertices, you will get *n-1*
    lines. If the user only specifies only one vertex, the drawing command is ignored.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `glBegin(GL_LINES)` 时，第一个顶点定义了第一条线的开始。之后的每个顶点定义了前一条线的结束和下一条线的开始。这会产生将线连接在一起直到列表中最后一个顶点的效果。因此，如果你传递
    *n* 个顶点，你会得到 *n-1* 条线。如果用户只指定了一个顶点，则绘制命令将被忽略。
- en: '![Gl_Line_Strip](img/8199OS_09_02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Gl_Line_Strip](img/8199OS_09_02.jpg)'
- en: Gl_Line_Loop
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gl_Line_Loop
- en: The call `glBegin(GL_LINE_LOOP)` works almost exactly like line strips, except
    that the first and last vertices are joined as a line. Thus, you get n lines for
    *n* input vertices. If the user only specifies one vertex, the drawing command
    is ignored. The line between the first and last vertices happens after all of
    the previous lines in the sequence.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`glBegin(GL_LINE_LOOP)` 调用几乎与线带完全一样，除了第一个和最后一个顶点被作为一条线连接。因此，对于 *n* 个输入顶点，你会得到
    *n* 条线。如果用户只指定了一个顶点，则绘制命令将被忽略。第一条和最后一条顶点之间的线发生在序列中的所有前一条线之后。'
- en: '![Gl_Line_Loop](img/8199OS_09_03.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Gl_Line_Loop](img/8199OS_09_03.jpg)'
- en: Triangulation
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三角剖分
- en: A triangle is a primitive formed by three vertices. There are three kinds of
    triangle primitives, based again on different interpretations of the vertex stream.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形是由三个顶点形成的原语。根据顶点流的不同的解释，有三种类型的三角形原语。
- en: Gl_Triangles
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gl_Triangles
- en: 'When you call `glBegin(GL_TRIANGLES)`, every three vertices define a triangle.
    Vertices 1, 2, and 3 form one triangle. Vertices 4, 5, and 6 form another triangle.
    If there are fewer than three vertices at the end of the list, they are ignored:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `glBegin(GL_TRIANGLES)` 时，每个三个顶点定义一个三角形。顶点 1、2 和 3 形成一个三角形。顶点 4、5 和 6 形成另一个三角形。如果列表末尾少于三个顶点，它们将被忽略：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Gl_Triangle_Strip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gl_Triangle_Strip
- en: 'When you call `glBegin(GL_TRIANGLE_STRIP)`, the first three vertices create
    the first triangle. Thereafter, the next two vertices create the next triangle,
    creating a group of adjacent triangles. A vertex stream of n length will generate
    *n-2* triangles:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `glBegin(GL_TRIANGLE_STRIP)` 时，前三个顶点创建第一个三角形。之后，接下来的两个顶点创建下一个三角形，形成一个相邻三角形组。长度为
    n 的顶点流将生成 *n-2* 个三角形：
- en: '![Gl_Triangle_Strip](img/8199OS_09_04.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Gl_Triangle_Strip](img/8199OS_09_04.jpg)'
- en: Gl_Triangle_Fan
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gl_Triangle_Fan
- en: 'When you call `glBegin(GL_TRIANGLE_FAN)`, the first vertex defines the point
    from which all other triangles are defined. Thereafter, each group of two vertices
    define a new triangle with the same apex as the first one, forming a fan. A vertex
    stream of *n* length will generate *n-2* triangles. Any leftover vertices will
    be ignored:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `glBegin(GL_TRIANGLE_FAN)` 时，第一个顶点定义了所有其他三角形定义的点。之后，每对两个顶点定义一个新的三角形，其顶点与第一个三角形相同，形成一个扇形。长度为
    *n* 的顶点流将生成 *n-2* 个三角形。任何剩余的顶点都将被忽略：
- en: '![Gl_Triangle_Fan](img/8199OS_09_05.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![Gl_Triangle_Fan](img/8199OS_09_05.jpg)'
- en: Being square
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成方形
- en: A quad is a quadrilateral, having four sides. Don't get confused and think that
    all quads are either squares or rectangles. Any shape with four sides is a quad.
    The four vertices are expected to be in the same plane and failure to do so can
    lead to undefined results. A quad is typically constructed as a pair of triangles,
    which can lead to artifacts (unanticipated glitches in the image).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 四边形是一个四边形，有四条边。不要混淆，认为所有四边形都是正方形或矩形。任何有四条边的形状都是四边形。预期的四个顶点应在同一平面上，否则可能导致未定义的结果。四边形通常由一对三角形组成，这可能导致伪影（图像中的意外故障）。
- en: Gl_Quads
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gl_Quads
- en: 'When you call `glBegin(GL_QUADS)`, each set of four vertices defines a quad.
    Vertices 1 to 4 form one quad, while vertices 5 to 8 form another. The vertex
    list must be a number of vertices divisible by 4 to work:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `glBegin(GL_QUADS)` 时，每组四个顶点定义一个四边形。顶点 1 到 4 形成一个四边形，而顶点 5 到 8 形成另一个。顶点列表必须是
    4 的倍数才能正常工作：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Gl_Quad_Strip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gl_Quad_Strip
- en: 'Similarly to triangle strips, a quad strip uses adjacent edges to form the
    next quad. In the case of quads, the third and fourth vertices of one quad are
    used as the edge of the next quad. So, vertices 1 to 4 define the first quad,
    while 5 to 6 extend the next quad. A vertex list of *n* length will generate *(n
    - 2)/2* quads:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于三角形带，四边形带使用相邻边来形成下一个四边形。在四边形的情况下，一个四边形的第三和第四个顶点用作下一个四边形的边。因此，顶点 1 到 4 定义了第一个四边形，而
    5 到 6 扩展了下一个四边形。长度为 *n* 的顶点列表将生成 *(n - 2)/2* 个四边形：
- en: '![Gl_Quad_Strip](img/8199OS_09_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Gl_Quad_Strip](img/8199OS_09_06.jpg)'
- en: Saving face
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存面子
- en: All of the primitives that we discussed are created by creating multiple shapes
    that are glued together, more or less. OpenGL needs to know which face of a shape
    is facing the camera, and this is determined by the winding order. As you can't
    see both the front and back of a primitive, OpenGL uses facing to decide which
    side must be rendered.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所讨论的所有原语都是通过创建多个粘合在一起的多边形来创建的，或多或少。OpenGL 需要知道形状的哪个面朝向相机，这由绕序决定。由于你无法看到原语的前后两面，OpenGL
    使用朝向来决定必须渲染哪一侧。
- en: In general, OpenGL takes care of the winding order so that all of the shapes
    in a particular list have consistent facing. If you, as a coder, try to take care
    of facing manually, you are actually second-guessing OpenGL.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，OpenGL 负责处理绕序，以确保特定列表中的所有形状都有一致的朝向。如果你作为程序员尝试手动处理朝向，你实际上是在质疑 OpenGL。
- en: Back to Egypt
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到埃及
- en: 'As we have already demonstrated the code to draw a cube, let''s try something
    even more interesting: a **pyramid**. A pyramid is constructed by four triangles
    with a square on the bottom. So, the simplest way to create a pyramid is to create
    four `GL_TRIANGLE` primitives and one `GL_QUAD` primitive:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们已经演示了绘制立方体的代码，让我们尝试一些更有趣的东西：一个**金字塔**。金字塔是由底部的正方形和四个三角形构成的。因此，创建金字塔的最简单方法就是创建四个`GL_TRIANGLE`原语和一个`GL_QUAD`原语：
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A modeling career
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模职业
- en: When you consider the amount of code that is required to create even the most
    basic shapes, you might despair of ever coding a complicated 3D game! Fortunately,
    there are better tools available to create 3D objects. 3D modeling software allows
    a 3D modeler to create 3D object similar to how an artist uses drawing software
    to create 2D images.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑到创建甚至最基本的形状所需的代码量时，你可能会对编写复杂的3D游戏感到绝望！幸运的是，有更好的工具可以创建3D对象。3D建模软件允许3D建模师创建与艺术家使用绘图软件创建2D图像相似的三维对象。
- en: 'The process of getting 3D objects into our game typically has three steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将3D对象导入我们的游戏的过程通常有三个步骤：
- en: Creating the 3D object in a 3D modeling tool.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在3D建模工具中创建3D对象。
- en: Exporting the model as a data file.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型导出为数据文件。
- en: Loading the data file into our game.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据文件加载到我们的游戏中。
- en: Blending in
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合操作
- en: There are many popular tools that are used by professionals to create 3D models.
    Two of the most popular ones are 3D Max and Maya. However, these tools are also
    relatively expensive. It turns out that there is a very capable 3D modeling tool
    called **Blender** that is available for free. We will install Blender and then
    learn how to use it to create 3D models for our game.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多流行的工具被专业人士用来创建3D模型。其中最受欢迎的两个是3D Max和Maya。然而，这些工具也相对昂贵。结果发现，有一个非常强大的免费3D建模工具叫做**Blender**。我们将安装Blender，然后学习如何使用它来为我们的游戏创建3D模型。
- en: 'Blender is a 3D modeling and animation suite that is perfect for beginners
    who want to try 3D modeling. Blender is open-source software created by Blender
    Organization, and it is available at no cost (although Blender Organization will
    be glad to accept your donations). Install Blender on your computer using the
    following steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Blender是一个适合想要尝试3D建模的初学者的3D建模和动画套件。Blender是由Blender组织创建的开源软件，并且免费提供（尽管Blender组织将很高兴接受你的捐赠）。按照以下步骤在您的计算机上安装Blender：
- en: Go to [http://www.Blender.Org](http://www.Blender.Org) and hit *Enter*.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[http://www.Blender.Org](http://www.Blender.Org)并按*Enter*。
- en: Click the **Download** link at the top of the page.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面顶部的**下载**链接。
- en: Download the files that are compatible with your computer. For my 64-bit Windows
    computer, I made the selection circled in the following screenshot:![Blending
    in](img/8199OS_09_07.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载与您的计算机兼容的文件。对于我的64位Windows计算机，我在以下截图中的圆圈中做了选择：![混合操作](img/8199OS_09_07.jpg)
- en: Once Blender is downloaded, run the installer program and accept all of the
    default values to install Blender on your computer.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Blender后，运行安装程序并接受所有默认值以在您的计算机上安装Blender。
- en: Blender overview
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blender概述
- en: 'Once you have installed Blender on your computer, open it up and you should
    see something like the following screen:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在你的计算机上安装了Blender，打开它，你应该会看到以下屏幕：
- en: '![Blender overview](img/8199OS_09_08.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Blender概述](img/8199OS_09_08.jpg)'
- en: Don't let the complexity of the screen scare you. Blender has a lot of features
    that you will learn with time, and they have tried to put many of the features
    right at your fingertips (well, mouse tips). They have even created a model of
    a cube for you so that you can get started right away.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让屏幕的复杂性吓到你。Blender有很多功能，你会在使用过程中逐渐学会，他们甚至尝试将许多功能直接放在你的指尖（或者说鼠标指尖）。他们甚至为你创建了一个立方体模型，让你可以立即开始。
- en: The middle of the screen is where the action takes place. This is the 3D view.
    The grid gives you a reference, but is not part of the model. In the preceding
    screenshot, the only model is the cube.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕中间是动作发生的地方。这是3D视图。网格为你提供了一个参考，但它不是模型的一部分。在上面的截图中，唯一的模型是立方体。
- en: The panels surrounding the middle offer a host of options to create and manipulate
    your objects. We won't have time to cover most of these, but there are many tutorials
    available online.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 中间周围的面板提供了创建和操作对象的各种选项。我们不会有时间涵盖这些选项中的大部分，但网上有很多教程可供参考。
- en: Building your spaceship
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建你的宇宙飞船
- en: Just like we did in the 2D portion of the book, we are going to build a simple
    3D spaceship so that we can fly it around in our universe. As I am a programmer
    and not a modeler, it will be a ridiculously simple space ship. Let's build it
    out of a cylinder.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在书的2D部分所做的那样，我们将构建一个简单的3D宇宙飞船，这样我们就可以在我们的宇宙中飞来飞去。由于我是一个程序员而不是建模师，这将是一个极其简单的宇宙飞船。让我们用圆柱体来构建它。
- en: 'To build our space ship, we first want to get rid of the cube. Use your right
    mouse button to select the cube. You can tell that it is selected because it will
    have three arrows coming from it:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们的宇宙飞船，我们首先想要移除立方体。使用你的右鼠标按钮选择立方体。你可以通过它发出的三个箭头来判断它是否被选中：
- en: '![Building your spaceship](img/8199OS_09_09.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![建造你的宇宙飞船](img/8199OS_09_09.jpg)'
- en: Now press the *Delete* key on your keyboard, and the cube will disappear.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按下键盘上的*删除*键，立方体就会消失。
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are like me, you will try and try to use the left mouse button to select
    objects. However, Blender uses the right mouse button to select objects!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，你会尝试并尝试使用左鼠标按钮来选择物体。然而，Blender使用右鼠标按钮来选择物体！
- en: 'You will probably notice two other objects in the 3D View:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在3D视图中注意到另外两个物体：
- en: '![Building your spaceship](img/8199OS_09_10.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![建造你的宇宙飞船](img/8199OS_09_10.jpg)'
- en: The object in the preceding image represents the camera. This is not a part
    of your game object, but rather it represents the angle of the camera as viewed
    from inside Blender. You can hide this by right-clicking on it and pressing *H*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前一张图片中的物体代表相机。这不是你的游戏物体的一部分，而是代表从Blender内部看到的相机角度。你可以通过右键点击它并按*H*来隐藏它。
- en: '![Building your spaceship](img/8199OS_09_11.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![建造你的宇宙飞船](img/8199OS_09_11.jpg)'
- en: The object in the preceding image represents the light source. This is not a
    part of your game object, but rather it represents the light source that Blender
    is using. You can hide this by right-clicking on it and pressing *H*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前一张图片中的物体代表光源。这不是你的游戏物体的一部分，而是代表Blender使用的光源。你可以通过右键点击它并按*H*来隐藏它。
- en: 'Now, let''s create that cylinder. Locate the **Create** tab in the left panel
    and use your left mouse button to click on it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建那个圆柱体。在左侧面板中找到**创建**标签，并使用你的左鼠标按钮点击它：
- en: '![Building your spaceship](img/8199OS_09_12.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![建造你的宇宙飞船](img/8199OS_09_12.jpg)'
- en: 'Next, click on the cylinder button. Blender will create a cylinder in the 3D
    view:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击圆柱体按钮。Blender将在3D视图中创建一个圆柱体：
- en: '![Building your spaceship](img/8199OS_09_13.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![建造你的宇宙飞船](img/8199OS_09_13.jpg)'
- en: Notice the three arrows. These indicate that the cylinder is the selected object.
    The arrows are used to move, size, and rotate objects, but we won't be doing any
    of that today.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到三个箭头。这些指示圆柱体是选中的物体。箭头用于移动、调整大小和旋转物体，但我们今天不会做这些。
- en: You should also notice a circle with a concentric dashed circle inside the cylinder.
    This indicates the origin of the object, which is the point around which the object
    will move, size, and rotate.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该注意到圆柱体内部有一个同心虚线圆圈。这表示物体的原点，即物体将围绕这个点移动、调整大小和旋转的点。
- en: 'There are many more things that we would do if we were modeling a real object.
    As this is a coding book and not a modeling book, we won''t do those things, but
    here are some ideas for future study:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在建模一个真实物体，我们还会做很多其他的事情。由于这是一本编程书而不是建模书，我们不会做那些事情，但这里有一些未来学习的一些想法：
- en: We could continue creating more and more objects and use them to build a much
    more complex spaceship
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以继续创建更多的物体，并使用它们来构建一个更加复杂的宇宙飞船
- en: We could use textures and materials to give our spaceship a skin
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用纹理和材质来给我们的宇宙飞船一个皮肤
- en: Exporting the object
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出物体
- en: 'In order to bring the spaceship into our game, we must first export the object
    into a data file that can be read into the game. There are many different formats
    that we could use, but for this game, we will use the `.obj` export type. To export
    the object, perform the following action:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将宇宙飞船带入我们的游戏，我们必须首先将物体导出为一个可以被游戏读取的数据文件。我们可以使用很多不同的格式，但为了这个游戏，我们将使用`.obj`导出类型。要导出物体，执行以下操作：
- en: Click the **File** command, then click **Export**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**文件**命令，然后点击**导出**。
- en: Choose **Wavefront (.obj)** as the file type.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Wavefront (.obj)**作为文件类型。
- en: In the next screen, select the location for your export (preferably the location
    of your source code for the game) and name it `ship.obj`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕中，选择你的导出位置（最好是游戏源代码的位置）并将其命名为`ship.obj`。
- en: Click the **Export OBJ** button on the right-hand side of the screen.![Exporting
    the object](img/8199OS_09_14.jpg)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕右侧的**导出OBJ**按钮。![导出对象](img/8199OS_09_14.jpg)
- en: Congratulations! You are now one step away from bringing this object into your
    game.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在离将这个对象带入你的游戏只有一步之遥了。
- en: Getting loaded
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正在加载
- en: 'The `.obj` file is simply a text file that stores all of the vertices and other
    data that is used to render this object in OpenGL. The following screenshot shows
    the `ship.obj` file opened in Notepad:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`.obj`文件只是一个文本文件，它存储了所有用于在OpenGL中渲染此对象的顶点和其他数据。以下截图显示了在记事本中打开的`ship.obj`文件：'
- en: '![Getting loaded](img/8199OS_09_15.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![正在加载](img/8199OS_09_15.jpg)'
- en: '`#`: This defines a comment'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#`：这定义了一个注释'
- en: '`v`: This defines a vertex'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v`：这定义了一个顶点'
- en: '`vt`: This defines a texture coordinate'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vt`：这定义了一个纹理坐标'
- en: '`vn`: This defines a normal'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vn`：这定义了一个法线'
- en: '`f`: This defines a face'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`：这定义了一个面'
- en: 'We will now write the code to load this data into our game. Open the SpaceRacer3D
    project into Visual Studio. Then add the following headers:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写代码将此数据加载到我们的游戏中。将SpaceRacer3D项目打开到Visual Studio中。然后添加以下头文件：
- en: '[PRE4]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is what the loader is doing:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是加载器正在做的事情：
- en: 'The loader accepts for parameters (one input and three output):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器接受参数（一个输入和三个输出）：
- en: A filename.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文件名。
- en: A pointer to an array of vertices.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向顶点数组的指针。
- en: A pointer to an array of uvs.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向uvs数组的指针。
- en: A pointer to an array of normal vectors.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向法向量数组的指针。
- en: Three vectors (a type of array in C++) are created to hold the data that is
    parsed from the file. One to hold the vertices, one to hold the uvs, and one to
    hold the normals. A fourth vector is created to pair each vertex with a uv coordinate.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了三个向量（C++中数组的一种类型）来存储从文件中解析出的数据。一个用于存储顶点，一个用于存储uvs，一个用于存储法线。还创建了一个第四个向量，用于将每个顶点与一个uv坐标配对。
- en: Three temporary vectors are created to use as input buffers as the data is read.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了三个临时向量作为输入缓冲区，以便在读取数据时使用。
- en: The `fbx` file is now read. The program looks for the flags that indicate what
    type of data is being read. For our purposes now, we are only concerned with the
    vertex data.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在正在读取`fbx`文件。程序寻找指示正在读取的数据类型的标志。对于我们现在的目的，我们只关心顶点数据。
- en: When each piece of data is read, it is put into the appropriate vector.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当读取每条数据时，它会被放入适当的向量中。
- en: The vectors are returned so that they can be processed by the program.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量被返回，以便程序可以处理它们。
- en: Simple enough, eh? But, there's a lot of code because parsing is always fun!
    The most important data that is extracted from the model for our purposes is the
    array of vertices.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 简单到足以吗？但是，代码量很大，因为解析总是很有趣！对于我们来说，从模型中提取的最重要数据是顶点数组。
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We haven't discussed uvs and normal vectors because I don't want to this to
    be a whole book on modeling. Uvs are used to add textures to an object. as we
    didn't add any textures, we won't have uv data. Normal vectors tell OpenGL which
    side of an object is facing out. This data is used to properly render and light
    an object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论uvs和法向量，因为我不想让这本书变成一本关于建模的书。Uvs用于给对象添加纹理。由于我们没有添加任何纹理，所以不会有uv数据。法向量告诉OpenGL对象的哪个面是朝外的。这些数据用于正确渲染和照亮对象。
- en: In the next chapter, we will use this loader to load our model into the game.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用这个加载器将我们的模型加载到游戏中。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We covered a lot of ground in this chapter. You learned how to create 3D objects
    in code using OpenGL. At the same time, you learned that you don't really create
    3D objects in code! Instead, real games use models that have been created in special
    3D modeling software, such as Blender.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们覆盖了很多内容。你学习了如何使用OpenGL在代码中创建3D对象。同时，你也了解到实际上你并不是在代码中创建3D对象！相反，真正的游戏使用的是在特殊的3D建模软件（如Blender）中创建的模型。
- en: Even as a coder, it is useful to learn a little bit about using software, such
    as Blender, but you will eventually want to find artists and modelers who really
    know now to use these tools to their full extent. You can even find 3D models
    online and integrate them into your game.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 即使作为一个程序员，学习一些关于使用软件（如Blender）的知识也是有用的，但最终你将想要找到真正知道如何充分利用这些工具的艺术家和建模师。你甚至可以在网上找到3D模型并将它们集成到你的游戏中。
- en: To close things out, we learned how to load 3D models into our. Spend a few
    days playing around with Blender and see what you can come up with, and then on
    to the next chapter!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一切，我们学习了如何将3D模型加载到我们的。花几天时间在Blender中玩玩，看看你能想出什么，然后继续下一章！
