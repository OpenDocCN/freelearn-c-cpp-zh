- en: Chapter 8. Metaprogramming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。元编程
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Using type "vector of types"
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型“类型向量”
- en: Manipulating a vector of types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作类型向量
- en: Getting a function's result type at compile time
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时获取函数的结果类型
- en: Making a higher-order metafunction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建高阶元函数
- en: Evaluating metafunctions lazily
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性评估元函数
- en: Converting all the tuple elements to strings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有元组元素转换为字符串
- en: Splitting tuples
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解元组
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is devoted to some cool and hard to understand metaprogramming
    methods. These methods are not for everyday use, but they will be a real help
    in the development of generic libraries.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于一些酷且难以理解的元编程方法。这些方法不是日常使用，但它们将在通用库的开发中提供实际帮助。
- en: '[Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"), *Compile-time Tricks*,
    already covered the basics of metaprogramming. Reading it is recommended for better
    understanding. In this chapter we''ll go deeper and see how multiple types can
    be packed into a single tuple like type. We''ll make functions for manipulating
    collections of types, we''ll see how types of compile-time collections can be
    changed, and how compile-time tricks can be mixed with runtime. All this is metaprogramming.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章。编译时技巧")，*编译时技巧*已经涵盖了元编程的基础。阅读它以更好地理解。在本章中，我们将更深入地探讨如何将多个类型打包到一个单一的元组类型中。我们将创建用于操作类型集合的函数，我们将看到编译时集合的类型如何改变，以及编译时技巧如何与运行时混合。所有这些都是元编程。'
- en: Fasten your seat belts and get ready, here we go!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 系好安全带，准备就绪，我们出发了！
- en: Using type "vector of types"
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型“类型向量”
- en: 'There are situations when it would be great to work with all the template parameters
    as if they were in a container. Imagine that we are writing something such as
    `Boost.Variant`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，如果我们能像在容器中一样处理所有模板参数，那将非常棒。想象一下，我们正在编写像`Boost.Variant`这样的东西：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And the preceding code is where all the following interesting tasks start to
    happen:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 而前面的代码是所有以下有趣任务开始发生的地方：
- en: How can we remove constant and volatile qualifiers from all the types?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何从所有类型中移除常量和易失性限定符？
- en: How can we remove duplicate types?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何移除重复的类型？
- en: How can we get the sizes of all the types?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何获取所有类型的大小？
- en: How can we get the maximum size of the input parameters?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何获取输入参数的最大大小？
- en: All these tasks can be easily solved using `Boost.MPL`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些任务都可以轻松地使用`Boost.MPL`解决。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A basic knowledge of [Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"),
    *Compile-time Tricks*, is required for this recipe. Gather your courage before
    reading—there will be a lot of metaprogramming in this recipe.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个配方，需要具备[第4章](ch04.html "第4章。编译时技巧")*编译时技巧*的基本知识。在阅读之前鼓起勇气——这个配方中会有很多元编程。
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: We have already seen how a type can be manipulated at compile time. Why can't
    we go further and combine multiple types in an array and perform operations for
    each element of that array?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何在编译时操作类型。为什么我们不能更进一步，将多个类型组合到一个数组中，并对该数组的每个元素执行操作？
- en: 'First of all, let''s pack all the types in one of the `Boost.MPL` types containers:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将所有类型打包到`Boost.MPL`类型容器中的一个：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s make our example less abstract and see how it will work if we specify
    types:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使我们的例子不那么抽象，看看如果我们指定类型，它会如何工作：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can check everything at compile time. Let''s assert that types is not empty:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在编译时检查一切。让我们断言类型不为空：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also check that, for example, the `non_defined` types is still at the
    index `4` position:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以检查，例如，`non_defined`类型仍然位于索引`4`的位置：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And that the last type is still `std::string`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以及最后一个类型仍然是`std::string`：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, when we are sure that types really contain all the types passed to our
    variant structure, we can do some transformations. We''ll start with removing
    constant and volatile qualifiers:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们确信类型确实包含传递给我们的变体结构的所有类型时，我们可以进行一些转换。我们将从移除常量和易失性限定符开始：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we remove the duplicate types:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们移除重复的类型：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can now check that the vector contains only `5` types:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以检查这个向量只包含`5`种类型：
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next step is to compute sizes:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是计算大小：
- en: '[PRE9]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final step is getting the maximum size:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是获取最大大小：
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can assert that the maximum size of the type is equal to the declared size
    of the structure, which must be the largest one in our example:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以断言类型的最大大小等于结构的声明大小，这必须是我们例子中的最大值：
- en: '[PRE11]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `boost::mpl::vector` class is a compile-time container that holds types.
    To be more precise, it is a type that holds types. We don't make instances of
    it; instead we are just using it in typedefs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::mpl::vector` 类是一个编译时容器，用于存储类型。更准确地说，它是一个存储类型的类型。我们不会为其创建实例；相反，我们只是在typedef中使用它。'
- en: 'Unlike the STL containers, the `Boost.MPL` containers have no member methods.
    Instead, methods are declared in a separate header. So to use some methods we
    need to:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与STL容器不同，`Boost.MPL` 容器没有成员方法。相反，方法是在单独的头文件中声明的。因此，为了使用某些方法，我们需要：
- en: Include the correct header
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含正确的头文件
- en: Call that method, usually by specifying the container as the first parameter
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用该方法，通常通过指定容器作为第一个参数
- en: 'Here is another example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These methods should be familiar to you. We have already seen metafunctions
    in [Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"), *Compile-time Tricks*.
    By the way, we are also using some metafunctions (such as `boost::is_same`) from
    the familiar `Boost.TypeTraits` library.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法你应该很熟悉。我们已经在[第4章](ch04.html "第4章。编译时技巧")，*编译时技巧*中看到了元函数。顺便说一下，我们还在使用一些来自熟悉的
    `Boost.TypeTraits` 库的元函数（例如 `boost::is_same`）。
- en: So, in step 3, step 4, and step 5 we are just calling metafunctions for our
    container type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第3步、第4步和第5步中，我们只是调用我们容器类型的元函数。
- en: The hardest part is coming up!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最难的部分即将到来！
- en: 'Remember, placeholders are widely used with the `boost::bind` and `Boost.Asio`
    libraries. `Boost.MPL` has them too and they are required for combining the metafunctions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，占位符在 `boost::bind` 和 `Boost.Asio` 库中被广泛使用。`Boost.MPL` 也有它们，并且它们是组合元函数所必需的：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `boost::mpl::_1` is a placeholder and the whole expression means "for
    each type in types, do `boost::remove_cv<>::type` and push back that type to the
    resulting vector. Return the resulting vector via `::type`".
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`boost::mpl::_1` 是一个占位符，整个表达式意味着“对于类型中的每个类型，执行 `boost::remove_cv<>::type`
    并将那个类型推回到结果向量中。通过 `::type` 返回结果向量”。
- en: 'Let''s move to step 7\. Here, we specify a comparison metafunction for `boost::mpl::unique`
    using the `boost::is_same<boost::mpl::_1, boost::mpl::_2>` template parameter,
    where `boost::mpl::_1` and `boost::mpl::_2` are placeholders. You may find it
    similar to `boost::bind(std::equal_to(), _1, _2)`, and the whole expression in
    step 7 is similar to the following pseudo code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到第7步。在这里，我们使用 `boost::is_same<boost::mpl::_1, boost::mpl::_2>` 模板参数指定 `boost::mpl::unique`
    的比较元函数，其中 `boost::mpl::_1` 和 `boost::mpl::_2` 是占位符。你可能觉得它与 `boost::bind(std::equal_to(),
    _1, _2)` 类似，第7步中的整个表达式类似于以下伪代码：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There is something interesting, which is required for better understanding,
    in step 9\. In the preceding code `sizes_types` is not a vector of values, but
    rather a vector of integral constants—types representing numbers. The `sizes_types`
    typedef is actually the following type:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9步中，有一些有趣的内容，这对于更好地理解是必需的。在先前的代码中，`sizes_types` 不是一个值的向量，而是一个整型常量的向量——代表数字的类型。`sizes_types`
    typedef 实际上是以下类型：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The final step should be clear now. It just gets the maximum element from the
    `sizes_types` typedef.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步现在应该很清晰了。它只是从 `sizes_types` typedef 中获取最大元素。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can use the `Boost.MPL` metafunctions in any place where typedefs are allowed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何允许使用typedef的地方使用 `Boost.MPL` 元函数。
- en: There's more...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Boost.MPL` library usage results in longer compilation time, but gives
    you the ability to do everything you want with types. It does not add runtime
    overhead and won't add even a single instruction to the binary. C++11 has no `Boost.MPL`
    classes, and `Boost.MPL` does not use features of C++11, such as the variadic
    templates. This makes the `Boost.MPL` compilation time longer on C++11 compilers,
    but makes it usable on C++03 compilers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Boost.MPL` 库会导致编译时间更长，但它让你能够使用类型做任何你想做的事情。它不会增加运行时开销，甚至不会在二进制文件中增加一条指令。C++11没有
    `Boost.MPL` 类，`Boost.MPL` 也不使用C++11的特性，如变长模板。这使得在C++11编译器上 `Boost.MPL` 的编译时间更长，但使其在C++03编译器上可用。
- en: See also
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See [Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"), *Compile-time Tricks,*
    for the basics of metaprogramming
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见[第4章](ch04.html "第4章。编译时技巧")，*编译时技巧*，了解元编程的基础
- en: The *Manipulating a vector of types* recipe will give you even more information
    on metaprogramming and the `Boost.MPL` library
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*操作类型向量* 的配方将为您提供更多关于元编程和 `Boost.MPL` 库的信息'
- en: See the official `Boost.MPL` documentation for more examples and full references
    at [http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/in](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/in)[dex.html](http://dex.html)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅官方 `Boost.MPL` 文档以获取更多示例和完整参考，请访问 [http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/in](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/in)[dex.html](http://dex.html)
- en: Manipulating a vector of types
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作类型向量
- en: 'The task of this recipe will be to modify the content of one `boost::mpl::vector`
    function depending on the content of a second `boost::mpl::vector` function. We''ll
    be calling the second vector as the vector of modifiers and each of those modifiers
    can have the following type:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的任务将是根据第二个 `boost::mpl::vector` 函数的内容修改一个 `boost::mpl::vector` 函数的内容。我们将调用第二个向量作为修饰符向量，并且每个修饰符都可以有以下的类型：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So where shall we start?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们应该从哪里开始呢？
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A basic knowledge of `Boost.MPL` is required. Reading the *Using type "vector
    of types"* recipe and [Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"),
    *Compile-time Tricks,* may help.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 需要基本了解 `Boost.MPL`。阅读 *使用类型 "类型向量"* 配方和 [第4章](ch04.html "第4章。编译时技巧")，*编译时技巧*
    可能有所帮助。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: This recipe is similar to the previous one, but it also uses conditional compile-time
    statements. Get ready, it won't be easy!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方与上一个配方类似，但它还使用了条件编译时语句。准备好，这不会容易！
- en: 'We shall start with headers:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该从头文件开始：
- en: '[PRE17]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s put all the metaprogramming magic inside the structure, for simpler
    re-use:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将所有元编程魔法放入结构中，以便于更简单的重用：
- en: '[PRE18]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is a good idea to check that the passed vectors have the same size:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查传入的向量是否具有相同的大小是一个好主意：
- en: '[PRE19]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let''s take care of modifying the metafunction:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们处理修改元函数：
- en: '[PRE20]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And the final step:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步：
- en: '[PRE21]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now run some tests and make sure that our metafunction works correctly:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以运行一些测试，确保我们的元函数工作正确：
- en: '[PRE22]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In step 3 we assert that the sizes are equal, but we do it in an unusual way.
    The `boost::mpl::size<Types>::type` metafunction actually returns the integral
    constant `struct boost::mpl::long_<4>`, so in a static assertion we actually compare
    two types, not two numbers. This can be rewritten in a more familiar way:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们断言大小相等，但我们以一种不寻常的方式进行。`boost::mpl::size<Types>::type` 元函数实际上返回整数常量 `struct
    boost::mpl::long_<4>`，因此在静态断言中，我们实际上比较的是两种类型，而不是两个数字。这可以以更熟悉的方式重写：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the `typename` keyword we use. Without it the compiler won't be able
    to decide if `::type` is actually a type or some variable. Previous recipes did
    not require it, because parameters for the metafunction were fully known at the
    point where we were using them. But in this recipe, the parameter for the metafunction
    is a template.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用的 `typename` 关键字。没有它，编译器将无法决定 `::type` 实际上是一个类型还是某个变量。之前的配方不需要它，因为我们在使用元函数参数时，参数是完全已知的。但在这个配方中，元函数的参数是一个模板。
- en: 'We''ll take a look at step 5, before taking care of step 4\. In step 5, we
    provide the `Types`, `Modifiers`, and `binary_operator_t` parameters from step
    4 to the `boost::mpl::transform` metafunction. This metafunction is rather simple—for
    each passed vector it takes an element and passes it to a third parameter—a binary
    metafunction. If we rewrite it in pseudo code, it will look like the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理第4步之前，我们先看看第5步。在第5步中，我们将第4步中的 `Types`、`Modifiers` 和 `binary_operator_t` 参数传递给
    `boost::mpl::transform` 元函数。这个元函数相当简单——对于每个传入的向量，它取一个元素并将其传递给第三个参数——一个二元元函数。如果我们用伪代码重写它，它将看起来像以下这样：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Step 4 may make someone's head hurt. At this step we are writing a metafunction
    that will be called for each pair of types from the `Types` and `Modifiers` vectors
    (see the preceding pseudo code). As we already know, `boost::mpl::_2` and `boost::mpl::_1`
    are placeholders. In this recipe, `_1` is a placeholder for a type from the `Types`
    vector and `_2` is a placeholder for a type from the `Modifiers` vector.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步可能会让人头疼。在这一步，我们正在编写一个元函数，它将为 `Types` 和 `Modifiers` 向量中的每一对类型调用（参见前面的伪代码）。正如我们已经知道的，`boost::mpl::_2`
    和 `boost::mpl::_1` 是占位符。在这个配方中，`_1` 是 `Types` 向量中类型的占位符，而 `_2` 是 `Modifiers` 向量中类型的占位符。
- en: 'So the whole metafunction works like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所以整个元函数就是这样工作的：
- en: Compares the second parameter passed to it (via `_2`) with an `unsigned` type
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将传递给它的第二个参数（通过 `_2`）与 `unsigned` 类型进行比较
- en: If the types are equal, makes the first parameter passed to it (via `_1`) `unsigned`
    and returns that type
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型相等，则将传递给它的第一个参数（通过 `_1`）转换为 `unsigned` 并返回该类型
- en: Otherwise, compares the second parameter passed to it (via `_2`) with a constant
    type
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，将传递给它的第二个参数（通过`_2`）与一个常量类型进行比较
- en: If the types are equal, makes the first parameter passed to it (via `_1`) constant
    and returns that type
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型相等，则将其传递给它的第一个参数（通过`_1`）设为常量并返回该类型
- en: Otherwise, returns the first parameter passed to it (via `_1`)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，返回传递给它的第一个参数（通过`_1`）
- en: 'We need to be very careful while constructing this metafunction. Additional
    care should be taken so as to not call `::type` at the end of it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建这个元函数时，我们需要非常小心。还应该特别注意，不要在它的末尾调用`::type`：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we call `::type`, the compiler will attempt to evaluate the binary operator
    at this point and this will lead to a compilation error. In pseudo code, such
    an attempt would look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`::type`，编译器将尝试在此处评估二元运算符，这将导致编译错误。在伪代码中，这样的尝试将看起来像这样：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Working with metafunctions requires some practice. Even your humble servant
    cannot write some functions correctly at the first attempt (second and third attempts
    are also not good though). Do not be afraid to experiment!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元函数需要一些练习。即使是你的谦卑仆人也无法在第一次尝试就正确编写一些函数（第二次和第三次尝试也不是很好）。不要害怕实验！
- en: 'The `Boost.MPL` library is not a part of C++11 and does not use C++11 features,
    but it can be used with C++11 variadic templates:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.MPL`库不是C++11的一部分，也不使用C++11特性，但它可以与C++11变长模板一起使用：'
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As always, metafunctions won't add a single instruction to the resulting binary
    file and do not make performance worse. However, by using them you can make your
    code more tuned to a specific situation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，元函数不会向生成的二进制文件添加任何指令，并且不会降低性能。然而，通过使用它们，你可以使你的代码更适应特定的情况。
- en: See also
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Read this chapter from the beginning to get more simple examples of `Boost.MPL`
    usage
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本章的开始阅读，以获取更多`Boost.MPL`使用的简单示例
- en: See [Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"), *Compile-time Tricks*,
    especially the *Selecting an optimal operator for a template parameter* recipe,
    which contains code similar to the `binary_operator_t` metafunction
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第4章](ch04.html "第4章。编译时技巧")，*编译时技巧*，特别是*为模板参数选择最佳运算符*配方，其中包含类似于`binary_operator_t`元函数的代码
- en: The official documentation for `Boost.MPL` has more examples and a full table
    of contents at [http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.MPL`的官方文档有更多示例和完整的目录表，请参阅[http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html)'
- en: Getting a function's result type at compile time
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编译时获取函数的结果类型
- en: 'Many features were added to C++11 to simplify the metaprogramming. One such
    feature is the alternative function syntax. It allows deducing the result type
    of a template function. Here is an example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: C++11添加了许多功能以简化元编程。为了接近替代函数语法，必须用C++03编写大量代码。
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It allows us to write generic functions more easily and work in difficult situations:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许我们更容易地编写泛型函数并在困难的情况下工作：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: But Boost has a lot of functions like these and it does not require C++11 to
    work.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但Boost有很多这样的函数，并且不需要C++11即可工作。
- en: How is that possible and how can we make a C++03 version of the `my_function_cpp11`
    function?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这怎么可能，以及我们如何创建`my_function_cpp11`函数的C++03版本？
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A basic knowledge of C++ and templates is required for this recipe.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，需要具备基本的C++和模板知识。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: C++11 greatly simplifies metaprogramming. A lot of code must be written in C++03
    to make something close to the alternative functions syntax.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: C++11极大地简化了元编程。为了接近替代函数语法，必须用C++03编写大量代码。
- en: 'We''ll need to include the following header:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包含以下头文件：
- en: '[PRE30]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we need to make a metafunction in the `result_of` namespace for any types:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为任何类型在`result_of`命名空间中创建一个元函数：
- en: '[PRE31]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And specialize it for types `s1`, and `s2`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并针对类型`s1`和`s2`进行专门化：
- en: '[PRE32]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we are ready to write the `my_function_cpp03` function:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好编写`my_function_cpp03`函数：
- en: '[PRE33]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That''s it! Now we can use this function almost like a C++11 one:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们可以几乎像使用C++11函数一样使用这个函数：
- en: '[PRE34]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main idea of this recipe is that we can make a special metafunction that
    will deduce the resulting type. Such a technique can be seen all through the Boost
    libraries, for example, in the `Boost.Variants` implementation of `boost::get<>`
    or in almost any function from `Boost.Fusion`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的主要思想是我们可以制作一个特殊的元函数，该元函数将推导出结果类型。这种技术可以在整个 Boost 库中看到，例如在 `Boost.Variants`
    的 `boost::get<>` 实现中，或者在 `Boost.Fusion` 的几乎所有函数中。
- en: Now, let's move through this step by step. The `result_of` namespace is just
    a kind of tradition, but you can use your own and it won't matter. The `boost::common_type<>`
    metafunction deduces a type common to several types, so we use it as a general
    case. We also added two template specializations of the `my_function_cpp03` structures
    for the `s1` and `s2` types.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一步一步地来。`result_of` 命名空间只是一种传统，但你可以使用自己的，这不会有什么影响。`boost::common_type<>`
    元函数推导出几个类型共有的类型，所以我们将其用作一般情况。我们还为 `s1` 和 `s2` 类型添加了 `my_function_cpp03` 结构的两个模板特化。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The disadvantage of writing metafunctions in C++03 is that sometimes we are
    required to write a lot of code. Compare the amount of code for `my_function_cpp11`
    and `my_function_cpp03` including the `result_of` namespace to see the difference.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++03 中编写元函数的缺点是，有时我们可能需要编写大量的代码。比较 `my_function_cpp11` 和 `my_function_cpp03`
    包括 `result_of` 命名空间的代码量，以查看差异。
- en: 'When the metafunction is ready, we can deduce the resulting type without C++11,
    so writing `my_function_cpp03` will be as easy as a pie:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当元函数准备好后，我们可以在不使用 C++11 的情况下推导出结果类型，因此编写 `my_function_cpp03` 将会像做饼一样简单：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: This technique does not add runtime overhead but it may slow down compilation
    a little bit. You can use it with C++11 compilers as well.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术不会增加运行时开销，但它可能会稍微减慢编译速度。你也可以使用 C++11 编译器。
- en: See also
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The recipes *Enabling the usage of templated functions for integral types*,
    *Disabling templated functions' usage for real types*, and *Selecting an optimal
    operator for a template parameter* from [Chapter 4](ch04.html "Chapter 4. Compile-time
    Tricks"), *Compile-time Tricks*, will give you much more information about `Boost.TypeTraits`
    and metaprogramming.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从第 4 章（[Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"），“编译时技巧”）的“启用整数类型的模板函数使用”、“禁用实数类型的模板函数使用”和“为模板参数选择最佳运算符”等食谱中，你可以获得更多关于
    `Boost.TypeTraits` 和元编程的信息。
- en: Consider the official documentation of `Boost.Typetraits` for more information
    about ready metafunctions at [http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于已准备好的元函数的信息，请参考 `Boost.Typetraits` 的官方文档：[http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html)
- en: Making a higher-order metafunction
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作一个高阶元函数
- en: 'Functions that accept other functions as an input parameter or functions that
    return other functions are called higher-order functions. For example, the following
    functions are higher-order:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接受其他函数作为输入参数或返回其他函数的函数称为高阶函数。例如，以下函数是高阶的：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We have already seen higher-order metafunctions in the recipes *Using type "vector
    of types"* and *Manipulating a vector of types* from this chapter, where we used
    `boost::transform`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章的“使用类型 '类型向量'”和“操作类型向量”的食谱中看到了高阶元函数，其中我们使用了 `boost::transform`。
- en: 'In this recipe, we''ll try to make our own higher-order metafunction named
    `coalesce`, which accepts two types and two metafunctions. The `coalesce` metafunction
    applies the first type-parameter to the first metafunction and compares the resulting
    type with the `boost::mpl::false_ type` metafunction. If the resulting type is
    the `boost::mpl::false_ type` metafunction, it returns the result of applying
    the second type-parameter to the second metafunction, otherwise, it returns the
    first result type:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将尝试制作一个名为 `coalesce` 的高阶元函数，它接受两种类型和两个元函数。`coalesce` 元函数将第一个类型参数应用于第一个元函数，并将结果类型与
    `boost::mpl::false_ type` 元函数进行比较。如果结果类型是 `boost::mpl::false_ type` 元函数，它将返回将第二个类型参数应用于第二个元函数的结果，否则，它将返回第一个结果类型：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe (and chapter) is a tricky one. Reading this chapter from the beginning
    is highly recommended.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱（和章节）有点棘手。强烈建议从本章开始阅读。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: The `Boost.MPL` metafunctions are actually structures, which can be easily passed
    as a template parameter. The hard part is to do it correctly.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.MPL`元函数实际上是结构，可以很容易地作为模板参数传递。困难的部分是正确地做到这一点。'
- en: 'We''ll need the following headers to write a higher-order metafunction:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以下头文件来编写高阶元函数：
- en: '[PRE38]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next step is to evaluate our functions:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是评估我们的函数：
- en: '[PRE39]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we need to choose the correct result type:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要选择正确的结果类型：
- en: '[PRE40]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'That''s it! we have completed a higher-order metafunction! Now we can use it,
    just like that:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样！我们已经完成了一个高阶元函数！现在我们可以像这样使用它：
- en: '[PRE41]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main problem with writing the higher-order metafunctions is taking care
    of the placeholders. That's why we should not call `Func1<Param1>::type` directly.
    Instead, we shall use the `boost::apply` metafunction, which accepts one function
    and up to five parameters that will be passed to this function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 编写高阶元函数的主要问题是处理占位符。这就是为什么我们不应该直接调用`Func1<Param1>::type`。相反，我们应该使用`boost::apply`元函数，它接受一个函数和最多五个参数，这些参数将被传递给该函数。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can configure `boost::mpl::apply` to accept even more parameters, defining
    the `BOOST_MPL_LIMIT_METAFUNCTION_ARITY` macro to the required amount of parameters,
    for example, to 6.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置`boost::mpl::apply`以接受更多的参数，将`BOOST_MPL_LIMIT_METAFUNCTION_ARITY`宏定义为所需的参数数量，例如，为6。
- en: There's more...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++11 has nothing close to the `Boost.MPL` library to apply a metafunction.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: C++11没有与`Boost.MPL`库类似的库来应用元函数。
- en: See also
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the official documentation, especially the *Tutorial* section, for more
    information about `Boost.MPL` at [http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅官方文档，特别是*教程*部分，以获取有关`Boost.MPL`的更多信息，请访问[http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html)
- en: Evaluating metafunctions lazily
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惰性评估元函数
- en: Lazy evaluation means that the function won't be called until we really need
    its result. Knowledge of this recipe is highly recommended for writing good metafunctions.
    The importance of lazy evaluation will be shown in the following example.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值意味着函数只有在真正需要其结果时才会被调用。了解这个配方对于编写良好的元函数非常重要。惰性求值的重要性将在以下示例中展示。
- en: 'Imagine that we are writing a metafunction that accepts a function, a parameter,
    and a condition. The resulting type of that function must be a `fallback` type
    if the condition is `false` otherwise the result will be as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们正在编写一个接受函数、参数和条件的元函数。如果条件为`false`，该函数的结果类型必须是`fallback`类型，否则结果如下：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And the preceding code is the place where we cannot live without lazy evaluation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 而前面的代码是我们不能没有惰性求值的地方。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Reading [Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"), *Compile-time
    Tricks*, is highly recommended. However, a good knowledge of metaprogramming should
    be enough.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读第4章[Chapter 4](ch04.html "Chapter 4. Compile-time Tricks")，*编译时技巧*，强烈推荐。然而，对元编程的良好了解应该足够了。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will see how this recipe is essential for writing good metafunctions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到这个配方对于编写良好的元函数是至关重要的：
- en: 'We''ll need the following headers:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以下头文件：
- en: '[PRE43]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The beginning of the function is simple:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的开始很简单：
- en: '[PRE44]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But we should be careful here:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但我们在这里要小心：
- en: '[PRE45]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Additional care must be taken when evaluating an expression:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在评估表达式时必须格外小心：
- en: '[PRE46]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'That''s it! Now we are free to use it like this:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样！现在我们可以像这样自由地使用它：
- en: '[PRE47]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The main idea of this recipe is that we should not execute the metafunction
    if the condition is `false`. Because when the condition is `false`, there is a
    chance that the metafunction for that type won''t work:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的核心思想是，如果条件为`false`，我们不应该执行元函数。因为当条件为`false`时，该类型的元函数可能不起作用：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So, how do we evaluate a metafunction lazily?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何惰性评估一个元函数呢？
- en: 'The compiler won''t look inside the metafunction if there is no access to the
    metafunction''s internal types or values. In other words, the compiler will try
    to compile the metafunction when we try to get one of its members via `::`. This
    can be a call to `::type` or `::value`. That is what an incorrect version of `apply_if`
    looks like:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有访问元函数的内部类型或值，编译器不会查看元函数。换句话说，当我们尝试通过`::`获取其成员时，编译器将尝试编译元函数。这就是`apply_if`的错误版本的样子：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This differs from our example, where we did not call `::type` at step 3 and
    implemented step 4 using `eval_if_c`, which calls `::type` only for one of its
    parameters. The `boost::mpl::eval_if_c` metafunction is implemented like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的示例不同，在步骤3我们没有调用`::type`，而是使用`eval_if_c`实现了步骤4，它只为其中一个参数调用`::type`。`boost::mpl::eval_if_c`元函数是这样实现的：
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Because `boost::mpl::eval_if_c` calls `::type` for a success condition and
    `fallback` may have no `::type`, we were required to wrap `fallback` into the
    `boost::mpl::identity`. `boost::mpl::identity` class. This class is a very simple
    but useful structure that returns its template parameter via a `::type` call:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`boost::mpl::eval_if_c`在成功条件下调用`::type`，而`fallback`可能没有`::type`，所以我们被要求将`fallback`包装进`boost::mpl::identity`类。`boost::mpl::identity`类是一个非常简单但有用的结构，它通过`::type`调用返回其模板参数：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There's more...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As we previously mentioned, C++11 has no classes of `Boost.MPL`, but we can
    use `std::common_type<T>` with a single argument just like `boost::mpl::identity<T>`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，C++11没有`Boost.MPL`的类，但我们可以像`boost::mpl::identity<T>`一样使用`std::common_type<T>`的单个参数。
- en: Just as always, metafunctions do not add a single line to the output binary
    file. So you can use metafunctions as many times as you want. The more you do
    at compile-time, the less will remain for runtime.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 就像往常一样，元函数不会向输出二进制文件中添加任何行。因此，你可以多次使用元函数。你编译时做得越多，运行时剩下的就越少。
- en: See also
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `boost::mpl::identity` type can be used to disable **Argument Dependent
    Lookup** (**ADL**) for template functions. See the sources of `boost::implicit_cast`
    in the `<boost/implicit_cast.hpp>` header.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::mpl::identity`类型可以用来禁用模板函数的**参数依赖查找**（**ADL**）。参见`<boost/implicit_cast.hpp>`头文件中`boost::implicit_cast`的源代码。'
- en: 'Reading this chapter from the beginning and the official documentation for
    `Boost.MPL` may help: [http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始阅读这一章和`Boost.MPL`的官方文档可能会有所帮助：[http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html)
- en: Converting all the tuple elements to strings
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有元组元素转换为字符串
- en: This recipe and the next one are devoted to a mix of compile time and runtime
    features. We'll be using the `Boost.Fusion` library to see what it can do.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱和下一个菜谱都是关于编译时间和运行时特性的混合。我们将使用`Boost.Fusion`库来看看它能做什么。
- en: Remember that we were talking about tuples and arrays in the first chapter.
    Now we want to write a single function that can stream elements of tuples and
    arrays to strings.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在第一章中讨论了元组和数组。现在我们想要编写一个单一函数，该函数可以将元组和数组的元素流式传输到字符串中。
- en: '![Converting all the tuple elements to strings](img/4880OS_08_01.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![将所有元组元素转换为字符串](img/4880OS_08_01.jpg)'
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should be aware of the `boost::tuple` and `boost::array` classes and of
    the `boost::lexical_cast` function.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该了解`boost::tuple`和`boost::array`类以及`boost::lexical_cast`函数。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We already know almost all the functions and classes that will be used in this
    recipe. We just need to gather all of them together.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经几乎知道了在这个菜谱中将要使用的所有函数和类。我们只需要将它们全部聚集在一起。
- en: 'We need to write a functor that converts any type to a string:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要编写一个将任何类型转换为字符串的函数：
- en: '[PRE52]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And this is the tricky part of the code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码的棘手之处在于：
- en: '[PRE53]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'That''s all! Now we can convert anything we want to a string:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这些！现在我们可以将任何东西转换成字符串：
- en: '[PRE54]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The preceding example will output the following:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的示例将输出以下内容：
- en: '[PRE55]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main problem with the `stringize` function is that neither `boost::tuple`
    nor `std::pair` have `begin()` or `end()` methods, so we cannot call `std::for_each`.
    And this is where `Boost.Fusion` steps in.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`stringize`函数的主要问题在于`boost::tuple`和`std::pair`都没有`begin()`或`end()`方法，因此我们无法调用`std::for_each`。这正是`Boost.Fusion`介入的地方。'
- en: The `Boost.Fusion` library contains lots of terrific algorithms that can manipulate
    structures at compile time.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Fusion`库包含许多出色的算法，可以在编译时操作结构。'
- en: The `boost::fusion::for_each` function iterates through elements in sequence
    and applies a functor to each of the elements.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::fusion::for_each`函数按顺序遍历元素，并将一个函数应用于每个元素。'
- en: 'Note that we have included:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经包含了：
- en: '[PRE56]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is required because, by default, `Boost.Fusion` works only with its own
    classes.`Boost.Fusion` has its own tuple class, `boost::fusion::vector`, which
    is quite close to `boost::tuple`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为默认情况下，`Boost.Fusion`只与其自己的类一起工作。`Boost.Fusion`有自己的元组类，`boost::fusion::vector`，它与`boost::tuple`非常相似：
- en: '[PRE57]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: But `boost::fusion::vector` is not as simple as `boost::tuple`. We'll see the
    difference in the *Splitting tuples* recipe.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one fundamental difference between `boost::fusion::for_each` and `std::for_each`.
    The `std::for_each` function contains a loop inside it and determinates at runtime,
    how many iterations will be done. However, `boost::fusion::for_each` knows the
    iteration count at compile time and fully unrolls the loop, generating the following
    code for `stringize(tup2)`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: C++11 contains no `Boost.Fusion` classes. All the methods of `Boost.Fusion`
    are very effective. They do as much as possible at compile time and have some
    very advanced optimizations.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Splitting tuples* recipe will give more information about the true power
    of `Boost.Fusion`
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official documentation for `Boost.Fusion` contains some interesting examples
    and full references which can be found at [http://www.boost.org/doc/libs/1_53_0/libs/fusion/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/fusion/doc/html/index.html)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting tuples
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show a tiny piece of the `Boost.Fusion` library's abilities.
    We'll be splitting a single tuple into two tuples, one with arithmetic types and
    the other with all the other types.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Splitting tuples](img/4880OS_08_02.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires knowledge of `Boost.MPL`, placeholders, and `Boost.Tuple`.
    Read the following recipes from [Chapter 1](ch01.html "Chapter 1. Starting to
    Write Your Application"), *Starting to Write Your Application*, *Combining multiple
    values into one* for more information about tuples and *Reordering parameters
    of a function* for information about placeholders. Reading this chapter from the
    beginning is recommended.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is possibly one of the hardest recipes in this chapter. Result types will
    be determined at compile time and values for those types will be filled at runtime.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement that mix, we''ll need the following headers:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we are ready to make a function that returns non-arithmetic types:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And a function that returns arithmetic types:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'That''s it! Now we are capable of doing the following tasks:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind `Boost.Fusion` is that the compiler knows the structure layout
    at compile time and whatever the compiler knows at compile time, we can change
    at the same time. `Boost.Fusion` allows us to modify different sequences, add
    and remove fields, and change field types. This is what we did in step 2 and step
    3; we removed the non-required fields from the tuple.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a very close look at `get_arithmetics`. First of all its result
    type is deduced using the following construction:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This should be familiar to us. We saw something like this in the *Getting a
    function's result type at compile time* recipe in this chapter. The `Boost.MPL`
    placeholder `boost::mpl::_1` should also be familiar.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s move inside the function and we''ll see the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Remember that the compiler knows all the types of `seq` at compile time. This
    means that `Boost.Fusion` can apply metafunctions to different elements of `seq`
    and get the metafunction results for them. This also means that `Boost.Fusion`
    will be capable of copying required fields from the old structure to the new one.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，编译器在编译时知道 `seq` 的所有类型。这意味着 `Boost.Fusion` 可以将元函数应用于 `seq` 的不同元素，并为它们获取元函数的结果。这也意味着
    `Boost.Fusion` 将能够从旧结构复制所需的字段到新结构中。
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: However, `Boost.Fusion` tries not to copy fields if at all possible.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Boost.Fusion` 尽可能避免复制字段。
- en: The code in step 3 is very similar to the code in step 2, but it has a negated
    predicate for removing non-required types.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 步中的代码与第 2 步中的代码非常相似，但它有一个取反的谓词来移除非必需的类型。
- en: Our functions can be used with any type supported by `Boost.Fusion` and not
    just with `boost::fusion::vector`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能可以与 `Boost.Fusion` 支持的任何类型一起使用，而不仅仅是 `boost::fusion::vector`。
- en: There's more...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can use `Boost.MPL` functions for the `Boost.Fusion` containers. You just
    need to include `#include <boost/fusion/include/mpl.hpp>`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Boost.MPL` 函数处理 `Boost.Fusion` 容器。您只需包含 `#include <boost/fusion/include/mpl.hpp>`
    即可：
- en: '[PRE65]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have used `boost::fusion::result_of::value_at_c` instead of `boost::fusion::result_of::at_c`
    because `boost::fusion::result_of::at_c` returns the exact type that will be used
    as a return type in the `boost::fusion::at_c` call, which is a reference. `boost::fusion::result_of::value_at_c`
    returns type without a reference.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `boost::fusion::result_of::value_at_c` 而不是 `boost::fusion::result_of::at_c`，因为
    `boost::fusion::result_of::at_c` 返回在 `boost::fusion::at_c` 调用中将用作返回类型的精确类型，这是一个引用。`boost::fusion::result_of::value_at_c`
    返回不带引用的类型。
- en: The `Boost.Fusion` and `Boost.MPL` libraries are not a part of C++11\. `Boost.Fusion`
    is extremely fast. It has many optimizations. All the metafunctions that you use
    with it will be evaluated at compile time.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Fusion` 和 `Boost.MPL` 库不是 C++11 的一部分。`Boost.Fusion` 非常快。它有许多优化。您与之一起使用的所有元函数都将被编译时评估。'
- en: It is worth mentioning that we saw only a tiny part of the `Boost.Fusion` abilities.
    A separate book could be written about it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们只看到了 `Boost.Fusion` 能力的一小部分。关于它可能可以写一本书。
- en: See also
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Good tutorials and full documentation for `Boost.Fusion` is available at the
    Boost site [http://www.boost.org/doc/libs/1_53_0/libs/fusion/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/fusion/doc/html/index.html)
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `Boost.Fusion` 的良好教程和完整文档可在 Boost 网站上找到 [http://www.boost.org/doc/libs/1_53_0/libs/fusion/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/fusion/doc/html/index.html)
- en: You may also wish to see the official documentation for `Boost.MPL` at [http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html)
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以查看 `Boost.MPL` 的官方文档 [http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html)
