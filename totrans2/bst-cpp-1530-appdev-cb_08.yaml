- en: Chapter 8. Metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using type "vector of types"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating a vector of types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a function's result type at compile time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a higher-order metafunction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating metafunctions lazily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting all the tuple elements to strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is devoted to some cool and hard to understand metaprogramming
    methods. These methods are not for everyday use, but they will be a real help
    in the development of generic libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"), *Compile-time Tricks*,
    already covered the basics of metaprogramming. Reading it is recommended for better
    understanding. In this chapter we''ll go deeper and see how multiple types can
    be packed into a single tuple like type. We''ll make functions for manipulating
    collections of types, we''ll see how types of compile-time collections can be
    changed, and how compile-time tricks can be mixed with runtime. All this is metaprogramming.'
  prefs: []
  type: TYPE_NORMAL
- en: Fasten your seat belts and get ready, here we go!
  prefs: []
  type: TYPE_NORMAL
- en: Using type "vector of types"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are situations when it would be great to work with all the template parameters
    as if they were in a container. Imagine that we are writing something such as
    `Boost.Variant`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And the preceding code is where all the following interesting tasks start to
    happen:'
  prefs: []
  type: TYPE_NORMAL
- en: How can we remove constant and volatile qualifiers from all the types?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we remove duplicate types?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we get the sizes of all the types?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we get the maximum size of the input parameters?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these tasks can be easily solved using `Boost.MPL`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A basic knowledge of [Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"),
    *Compile-time Tricks*, is required for this recipe. Gather your courage before
    reading—there will be a lot of metaprogramming in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen how a type can be manipulated at compile time. Why can't
    we go further and combine multiple types in an array and perform operations for
    each element of that array?
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s pack all the types in one of the `Boost.MPL` types containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s make our example less abstract and see how it will work if we specify
    types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can check everything at compile time. Let''s assert that types is not empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also check that, for example, the `non_defined` types is still at the
    index `4` position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And that the last type is still `std::string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when we are sure that types really contain all the types passed to our
    variant structure, we can do some transformations. We''ll start with removing
    constant and volatile qualifiers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we remove the duplicate types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now check that the vector contains only `5` types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to compute sizes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step is getting the maximum size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can assert that the maximum size of the type is equal to the declared size
    of the structure, which must be the largest one in our example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `boost::mpl::vector` class is a compile-time container that holds types.
    To be more precise, it is a type that holds types. We don't make instances of
    it; instead we are just using it in typedefs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the STL containers, the `Boost.MPL` containers have no member methods.
    Instead, methods are declared in a separate header. So to use some methods we
    need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the correct header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call that method, usually by specifying the container as the first parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These methods should be familiar to you. We have already seen metafunctions
    in [Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"), *Compile-time Tricks*.
    By the way, we are also using some metafunctions (such as `boost::is_same`) from
    the familiar `Boost.TypeTraits` library.
  prefs: []
  type: TYPE_NORMAL
- en: So, in step 3, step 4, and step 5 we are just calling metafunctions for our
    container type.
  prefs: []
  type: TYPE_NORMAL
- en: The hardest part is coming up!
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, placeholders are widely used with the `boost::bind` and `Boost.Asio`
    libraries. `Boost.MPL` has them too and they are required for combining the metafunctions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, `boost::mpl::_1` is a placeholder and the whole expression means "for
    each type in types, do `boost::remove_cv<>::type` and push back that type to the
    resulting vector. Return the resulting vector via `::type`".
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move to step 7\. Here, we specify a comparison metafunction for `boost::mpl::unique`
    using the `boost::is_same<boost::mpl::_1, boost::mpl::_2>` template parameter,
    where `boost::mpl::_1` and `boost::mpl::_2` are placeholders. You may find it
    similar to `boost::bind(std::equal_to(), _1, _2)`, and the whole expression in
    step 7 is similar to the following pseudo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There is something interesting, which is required for better understanding,
    in step 9\. In the preceding code `sizes_types` is not a vector of values, but
    rather a vector of integral constants—types representing numbers. The `sizes_types`
    typedef is actually the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The final step should be clear now. It just gets the maximum element from the
    `sizes_types` typedef.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the `Boost.MPL` metafunctions in any place where typedefs are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Boost.MPL` library usage results in longer compilation time, but gives
    you the ability to do everything you want with types. It does not add runtime
    overhead and won't add even a single instruction to the binary. C++11 has no `Boost.MPL`
    classes, and `Boost.MPL` does not use features of C++11, such as the variadic
    templates. This makes the `Boost.MPL` compilation time longer on C++11 compilers,
    but makes it usable on C++03 compilers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"), *Compile-time Tricks,*
    for the basics of metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Manipulating a vector of types* recipe will give you even more information
    on metaprogramming and the `Boost.MPL` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the official `Boost.MPL` documentation for more examples and full references
    at [http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/in](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/in)[dex.html](http://dex.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating a vector of types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The task of this recipe will be to modify the content of one `boost::mpl::vector`
    function depending on the content of a second `boost::mpl::vector` function. We''ll
    be calling the second vector as the vector of modifiers and each of those modifiers
    can have the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So where shall we start?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A basic knowledge of `Boost.MPL` is required. Reading the *Using type "vector
    of types"* recipe and [Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"),
    *Compile-time Tricks,* may help.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is similar to the previous one, but it also uses conditional compile-time
    statements. Get ready, it won't be easy!
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall start with headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s put all the metaprogramming magic inside the structure, for simpler
    re-use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is a good idea to check that the passed vectors have the same size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s take care of modifying the metafunction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And the final step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now run some tests and make sure that our metafunction works correctly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In step 3 we assert that the sizes are equal, but we do it in an unusual way.
    The `boost::mpl::size<Types>::type` metafunction actually returns the integral
    constant `struct boost::mpl::long_<4>`, so in a static assertion we actually compare
    two types, not two numbers. This can be rewritten in a more familiar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice the `typename` keyword we use. Without it the compiler won't be able
    to decide if `::type` is actually a type or some variable. Previous recipes did
    not require it, because parameters for the metafunction were fully known at the
    point where we were using them. But in this recipe, the parameter for the metafunction
    is a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll take a look at step 5, before taking care of step 4\. In step 5, we
    provide the `Types`, `Modifiers`, and `binary_operator_t` parameters from step
    4 to the `boost::mpl::transform` metafunction. This metafunction is rather simple—for
    each passed vector it takes an element and passes it to a third parameter—a binary
    metafunction. If we rewrite it in pseudo code, it will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 may make someone's head hurt. At this step we are writing a metafunction
    that will be called for each pair of types from the `Types` and `Modifiers` vectors
    (see the preceding pseudo code). As we already know, `boost::mpl::_2` and `boost::mpl::_1`
    are placeholders. In this recipe, `_1` is a placeholder for a type from the `Types`
    vector and `_2` is a placeholder for a type from the `Modifiers` vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the whole metafunction works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Compares the second parameter passed to it (via `_2`) with an `unsigned` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the types are equal, makes the first parameter passed to it (via `_1`) `unsigned`
    and returns that type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, compares the second parameter passed to it (via `_2`) with a constant
    type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the types are equal, makes the first parameter passed to it (via `_1`) constant
    and returns that type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, returns the first parameter passed to it (via `_1`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to be very careful while constructing this metafunction. Additional
    care should be taken so as to not call `::type` at the end of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call `::type`, the compiler will attempt to evaluate the binary operator
    at this point and this will lead to a compilation error. In pseudo code, such
    an attempt would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with metafunctions requires some practice. Even your humble servant
    cannot write some functions correctly at the first attempt (second and third attempts
    are also not good though). Do not be afraid to experiment!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Boost.MPL` library is not a part of C++11 and does not use C++11 features,
    but it can be used with C++11 variadic templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As always, metafunctions won't add a single instruction to the resulting binary
    file and do not make performance worse. However, by using them you can make your
    code more tuned to a specific situation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read this chapter from the beginning to get more simple examples of `Boost.MPL`
    usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"), *Compile-time Tricks*,
    especially the *Selecting an optimal operator for a template parameter* recipe,
    which contains code similar to the `binary_operator_t` metafunction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official documentation for `Boost.MPL` has more examples and a full table
    of contents at [http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a function's result type at compile time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many features were added to C++11 to simplify the metaprogramming. One such
    feature is the alternative function syntax. It allows deducing the result type
    of a template function. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It allows us to write generic functions more easily and work in difficult situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: But Boost has a lot of functions like these and it does not require C++11 to
    work.
  prefs: []
  type: TYPE_NORMAL
- en: How is that possible and how can we make a C++03 version of the `my_function_cpp11`
    function?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A basic knowledge of C++ and templates is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++11 greatly simplifies metaprogramming. A lot of code must be written in C++03
    to make something close to the alternative functions syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to include the following header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to make a metafunction in the `result_of` namespace for any types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And specialize it for types `s1`, and `s2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we are ready to write the `my_function_cpp03` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it! Now we can use this function almost like a C++11 one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main idea of this recipe is that we can make a special metafunction that
    will deduce the resulting type. Such a technique can be seen all through the Boost
    libraries, for example, in the `Boost.Variants` implementation of `boost::get<>`
    or in almost any function from `Boost.Fusion`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move through this step by step. The `result_of` namespace is just
    a kind of tradition, but you can use your own and it won't matter. The `boost::common_type<>`
    metafunction deduces a type common to several types, so we use it as a general
    case. We also added two template specializations of the `my_function_cpp03` structures
    for the `s1` and `s2` types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The disadvantage of writing metafunctions in C++03 is that sometimes we are
    required to write a lot of code. Compare the amount of code for `my_function_cpp11`
    and `my_function_cpp03` including the `result_of` namespace to see the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the metafunction is ready, we can deduce the resulting type without C++11,
    so writing `my_function_cpp03` will be as easy as a pie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This technique does not add runtime overhead but it may slow down compilation
    a little bit. You can use it with C++11 compilers as well.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipes *Enabling the usage of templated functions for integral types*,
    *Disabling templated functions' usage for real types*, and *Selecting an optimal
    operator for a template parameter* from [Chapter 4](ch04.html "Chapter 4. Compile-time
    Tricks"), *Compile-time Tricks*, will give you much more information about `Boost.TypeTraits`
    and metaprogramming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the official documentation of `Boost.Typetraits` for more information
    about ready metafunctions at [http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a higher-order metafunction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions that accept other functions as an input parameter or functions that
    return other functions are called higher-order functions. For example, the following
    functions are higher-order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We have already seen higher-order metafunctions in the recipes *Using type "vector
    of types"* and *Manipulating a vector of types* from this chapter, where we used
    `boost::transform`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll try to make our own higher-order metafunction named
    `coalesce`, which accepts two types and two metafunctions. The `coalesce` metafunction
    applies the first type-parameter to the first metafunction and compares the resulting
    type with the `boost::mpl::false_ type` metafunction. If the resulting type is
    the `boost::mpl::false_ type` metafunction, it returns the result of applying
    the second type-parameter to the second metafunction, otherwise, it returns the
    first result type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe (and chapter) is a tricky one. Reading this chapter from the beginning
    is highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Boost.MPL` metafunctions are actually structures, which can be easily passed
    as a template parameter. The hard part is to do it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need the following headers to write a higher-order metafunction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to evaluate our functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to choose the correct result type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it! we have completed a higher-order metafunction! Now we can use it,
    just like that:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main problem with writing the higher-order metafunctions is taking care
    of the placeholders. That's why we should not call `Func1<Param1>::type` directly.
    Instead, we shall use the `boost::apply` metafunction, which accepts one function
    and up to five parameters that will be passed to this function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can configure `boost::mpl::apply` to accept even more parameters, defining
    the `BOOST_MPL_LIMIT_METAFUNCTION_ARITY` macro to the required amount of parameters,
    for example, to 6.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++11 has nothing close to the `Boost.MPL` library to apply a metafunction.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the official documentation, especially the *Tutorial* section, for more
    information about `Boost.MPL` at [http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating metafunctions lazily
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy evaluation means that the function won't be called until we really need
    its result. Knowledge of this recipe is highly recommended for writing good metafunctions.
    The importance of lazy evaluation will be shown in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we are writing a metafunction that accepts a function, a parameter,
    and a condition. The resulting type of that function must be a `fallback` type
    if the condition is `false` otherwise the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: And the preceding code is the place where we cannot live without lazy evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading [Chapter 4](ch04.html "Chapter 4. Compile-time Tricks"), *Compile-time
    Tricks*, is highly recommended. However, a good knowledge of metaprogramming should
    be enough.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see how this recipe is essential for writing good metafunctions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The beginning of the function is simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But we should be careful here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additional care must be taken when evaluating an expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it! Now we are free to use it like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main idea of this recipe is that we should not execute the metafunction
    if the condition is `false`. Because when the condition is `false`, there is a
    chance that the metafunction for that type won''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: So, how do we evaluate a metafunction lazily?
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler won''t look inside the metafunction if there is no access to the
    metafunction''s internal types or values. In other words, the compiler will try
    to compile the metafunction when we try to get one of its members via `::`. This
    can be a call to `::type` or `::value`. That is what an incorrect version of `apply_if`
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This differs from our example, where we did not call `::type` at step 3 and
    implemented step 4 using `eval_if_c`, which calls `::type` only for one of its
    parameters. The `boost::mpl::eval_if_c` metafunction is implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `boost::mpl::eval_if_c` calls `::type` for a success condition and
    `fallback` may have no `::type`, we were required to wrap `fallback` into the
    `boost::mpl::identity`. `boost::mpl::identity` class. This class is a very simple
    but useful structure that returns its template parameter via a `::type` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we previously mentioned, C++11 has no classes of `Boost.MPL`, but we can
    use `std::common_type<T>` with a single argument just like `boost::mpl::identity<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Just as always, metafunctions do not add a single line to the output binary
    file. So you can use metafunctions as many times as you want. The more you do
    at compile-time, the less will remain for runtime.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `boost::mpl::identity` type can be used to disable **Argument Dependent
    Lookup** (**ADL**) for template functions. See the sources of `boost::implicit_cast`
    in the `<boost/implicit_cast.hpp>` header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reading this chapter from the beginning and the official documentation for
    `Boost.MPL` may help: [http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting all the tuple elements to strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe and the next one are devoted to a mix of compile time and runtime
    features. We'll be using the `Boost.Fusion` library to see what it can do.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we were talking about tuples and arrays in the first chapter.
    Now we want to write a single function that can stream elements of tuples and
    arrays to strings.
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting all the tuple elements to strings](img/4880OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should be aware of the `boost::tuple` and `boost::array` classes and of
    the `boost::lexical_cast` function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already know almost all the functions and classes that will be used in this
    recipe. We just need to gather all of them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to write a functor that converts any type to a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And this is the tricky part of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s all! Now we can convert anything we want to a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding example will output the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main problem with the `stringize` function is that neither `boost::tuple`
    nor `std::pair` have `begin()` or `end()` methods, so we cannot call `std::for_each`.
    And this is where `Boost.Fusion` steps in.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.Fusion` library contains lots of terrific algorithms that can manipulate
    structures at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::fusion::for_each` function iterates through elements in sequence
    and applies a functor to each of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we have included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is required because, by default, `Boost.Fusion` works only with its own
    classes.`Boost.Fusion` has its own tuple class, `boost::fusion::vector`, which
    is quite close to `boost::tuple`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: But `boost::fusion::vector` is not as simple as `boost::tuple`. We'll see the
    difference in the *Splitting tuples* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one fundamental difference between `boost::fusion::for_each` and `std::for_each`.
    The `std::for_each` function contains a loop inside it and determinates at runtime,
    how many iterations will be done. However, `boost::fusion::for_each` knows the
    iteration count at compile time and fully unrolls the loop, generating the following
    code for `stringize(tup2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: C++11 contains no `Boost.Fusion` classes. All the methods of `Boost.Fusion`
    are very effective. They do as much as possible at compile time and have some
    very advanced optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Splitting tuples* recipe will give more information about the true power
    of `Boost.Fusion`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official documentation for `Boost.Fusion` contains some interesting examples
    and full references which can be found at [http://www.boost.org/doc/libs/1_53_0/libs/fusion/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/fusion/doc/html/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show a tiny piece of the `Boost.Fusion` library's abilities.
    We'll be splitting a single tuple into two tuples, one with arithmetic types and
    the other with all the other types.
  prefs: []
  type: TYPE_NORMAL
- en: '![Splitting tuples](img/4880OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires knowledge of `Boost.MPL`, placeholders, and `Boost.Tuple`.
    Read the following recipes from [Chapter 1](ch01.html "Chapter 1. Starting to
    Write Your Application"), *Starting to Write Your Application*, *Combining multiple
    values into one* for more information about tuples and *Reordering parameters
    of a function* for information about placeholders. Reading this chapter from the
    beginning is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is possibly one of the hardest recipes in this chapter. Result types will
    be determined at compile time and values for those types will be filled at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement that mix, we''ll need the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we are ready to make a function that returns non-arithmetic types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And a function that returns arithmetic types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it! Now we are capable of doing the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind `Boost.Fusion` is that the compiler knows the structure layout
    at compile time and whatever the compiler knows at compile time, we can change
    at the same time. `Boost.Fusion` allows us to modify different sequences, add
    and remove fields, and change field types. This is what we did in step 2 and step
    3; we removed the non-required fields from the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a very close look at `get_arithmetics`. First of all its result
    type is deduced using the following construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This should be familiar to us. We saw something like this in the *Getting a
    function's result type at compile time* recipe in this chapter. The `Boost.MPL`
    placeholder `boost::mpl::_1` should also be familiar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s move inside the function and we''ll see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the compiler knows all the types of `seq` at compile time. This
    means that `Boost.Fusion` can apply metafunctions to different elements of `seq`
    and get the metafunction results for them. This also means that `Boost.Fusion`
    will be capable of copying required fields from the old structure to the new one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: However, `Boost.Fusion` tries not to copy fields if at all possible.
  prefs: []
  type: TYPE_NORMAL
- en: The code in step 3 is very similar to the code in step 2, but it has a negated
    predicate for removing non-required types.
  prefs: []
  type: TYPE_NORMAL
- en: Our functions can be used with any type supported by `Boost.Fusion` and not
    just with `boost::fusion::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use `Boost.MPL` functions for the `Boost.Fusion` containers. You just
    need to include `#include <boost/fusion/include/mpl.hpp>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have used `boost::fusion::result_of::value_at_c` instead of `boost::fusion::result_of::at_c`
    because `boost::fusion::result_of::at_c` returns the exact type that will be used
    as a return type in the `boost::fusion::at_c` call, which is a reference. `boost::fusion::result_of::value_at_c`
    returns type without a reference.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.Fusion` and `Boost.MPL` libraries are not a part of C++11\. `Boost.Fusion`
    is extremely fast. It has many optimizations. All the metafunctions that you use
    with it will be evaluated at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that we saw only a tiny part of the `Boost.Fusion` abilities.
    A separate book could be written about it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Good tutorials and full documentation for `Boost.Fusion` is available at the
    Boost site [http://www.boost.org/doc/libs/1_53_0/libs/fusion/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/fusion/doc/html/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may also wish to see the official documentation for `Boost.MPL` at [http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html](http://www.boost.org/doc/libs/1_53_0/libs/mpl/doc/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
