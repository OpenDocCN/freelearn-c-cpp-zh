- en: Chapter 14. Dialogs, Controls, and Page Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we look into the implementation of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom dialogs**: The `Dialog` class is intended to be inherited by subclasses
    and equipped with controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controls**: The `Control` class and its subclasses. There are controls for
    edit fields, check boxes, radio buttons, list boxes, and combo boxes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Converters**: Between strings and other values. For instance, when the user
    inputs text that represents a numerical value, it is possible to add a converter
    that converts the text to a value, or gives an error message if the text does
    not hold a valid value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Page Setup**: Where we extend the `Dialog` class. The dialog is used when
    setting page settings for a document of the `StandardDocument` class. It handles
    information for headers, footers, and margins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Dialog` class handles a set of **controls**, which are added to the dialog
    by the `AddControl` method. For a subclass of the `Dialog` class, refer to `PageSetupDialog`
    in the last section of this chapter. The Dialog class provides a modal dialog,
    which means that all other windows in the application become disabled until the
    dialog is closed.
  prefs: []
  type: TYPE_NORMAL
- en: The user may navigate between controls with the ***Tab*** key and between radio
    buttons in the same group with the arrow keys. They can also use mnemonics to
    access controls.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dialog.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dialogMap` field is used by `DialogProc` to look up the dialog receiving
    the messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Dialog` class is a subclass of `Window` even though it calls the default
    `Window` constructor, which does not call the Win32 API function `CreateWindowEx`.
    Instead, `DoModal` collects information about the dialog and its controls and
    calls the Win32 API function `DialogBoxIndirectParam`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As the name implies, `DoModal` disables its parent window for as long as the
    dialog is visible. That is, until the user closes the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor deletes all controls, which implies that a subclass to `Dialog`
    should add dynamically allocated controls to the dialog without deleting them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `AddControl` method assigns an identity number to the control and adds it
    to `idMap`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `OnSize` function is called each time the user changes the size of the dialog,
    it iterates through the controls and adjusts their size so that they keep their
    size relative to the size of the dialog client area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When the user presses the ***Return*** key `OnReturn` is called, and when they
    press the ***Esc*** key `OnEscape` is called. Their default behavior is to close
    the dialog and return control to `DoModal` with 1 and 0 as the return code; 1
    is interpreted as `true` and 0 as `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `OnControlInit` method is intended to be overridden by subclasses and is
    called when the dialog is being initialized (when it receives the `WM_INITDIALOG`
    message).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TryClose` method is intended to be overridden by subclasses and its default
    behavior is to return `true`. The `OnClose` method is called when the user tries
    to close the dialog, and its default behavior is to call `TryClose` and close
    the dialog if it returns `true`, in which case `OnDestroy` is also called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Each control is assigned an identity number when added to the dialog, which
    is mapped to a pointer to the control in `idMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The dialog has a header text, top-left position, font, regular style, and extended
    style, which are stored by the constructor and used by `DoModal` in the `DialogBoxIndirectParam`
    call. However, the size of the dialog is not a constructor parameter; instead,
    the size is based on the control dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `leftMargin`, `maxWidth`, `topMargin`, and `maxHeight` fields are used
    when calculating the size of the dialog. The idea is that its size will be adjusted
    so that the left and right margins as well as the top and bottom margins for the
    closest control are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The first control is not assigned the identity number of 0, since it will cause
    confusion when handling messages if the control with identity 0 is a push button.
    Instead, we initialize `currentId` with 1000, and decrease its value with each
    new control. It is necessary to decrease the value in order for the ***Tab***
    key to work correctly in the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When the dialog is initialized (by receiving the `WM_INITDIALOG` message),
    its size is stored in `originalClientSize` to be used by `OnSize` when calculating
    the size of the controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DialogProc` method is called every time the dialog receives a message.
    Unlike `WindowProc`, it will return `TRUE` if the message has been handled and
    does not need further processing. Moreover, it will not call `DefWindowProc` at
    the end; instead it will return `FALSE` if the message has not been handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Dialog.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The default dialog font is set to 12-point Times New Roman.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor calls the `Window` constructor, which sets the parent window
    pointer and does nothing else. That is, it does not call the Win32 API function
    `CreateWindowEx`. The `header`, `topLeft`, `style`, `extendedStyle`, and `font`
    fields are stored to be used by `DoModal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DoModal` function makes the dialog enter the modal state. That is, its
    parent window becomes disabled until the dialog is destroyed. But, it first loads
    information to `infoList`. The `AddValue` method is a template method of the `InfoList`
    class and adds values of different types to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to add the value `1` in order to set the version of the dialog
    template we want to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `0xFFFF` value indicates that we want to work with the extended dialog
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The next word is intended for a help identity; however, we do not use it so
    we just set it to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then comes the extended and regular style. Besides the style sent to the constructor,
    we set the dialog to have a caption, a system menu, a modal frame, and a font.
    Due to the `DS_SETFONT` flag, we will later add information about the dialog font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The next value is the number of controls in the dialog, which is given by the
    size of `idMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The top-left position is given by the `topLeft` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The size of the client area of the dialog is set by `maxWidth`, `leftMargin`,
    `maxHeight`, and `topMargin`, which has been calculated in `AddControl`. The width
    of the client area is the maximum width of the control set plus its left margin.
    In this way, we adjust the dialog to hold the controls with equal left and right
    margins as well as top and bottom margins to the closest control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next two zeros indicate that we do not want to use a menu and that we use
    the default dialog `Windows` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we set the header of the dialog. The `AddString` method is an `InfoList`
    template method that adds the string with a terminating 0 to the information list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we set the font of the dialog. We extract the `LOGFONT` structure
    of the `Font` class and extract its size (`lfHeight`), whether it is bold (`lfWeight`)
    or italics, its character set (which is 0 since we do not use it), and the font
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When the dialog information has been added to the information list, we call
    `AddControlInfo` for each control in order for the control information to be added
    to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When the list has been fully loaded, we allocate a global buffer and load it
    with the list. The `ToBuffer` method copies the list into the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We need the handle to the parent window, if present, and then we create the
    dialog by calling the Win32 API function `DialogBoxIndirectParam`, which will
    not return until the user closes the dialog. The last parameter is a pointer to
    the `Dialog` object that will be sent with the `WM_INITDIALOG` message. The return
    value stored in `result` is the second parameter to an `EndDialog` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We return `true` if the result value does not equal 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If the global buffer allocation does not succeed, we return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor iterates through `idMap` and deletes each control of the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddControl` method adds a control to the dialog. If it is the first control
    to be added (`idMap` is empty), `leftMargin` and `topMargin` are set to the top-left
    corner of the control, and `maxWidth` and `maxHeight` are set to the top-left
    corner plus the control width or height. However, if it is not, the first control
    we need to compare is its top-left corner and size, with the current values, in
    order to find the margins and maximum size of the control set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The identity number of the control is set to `currentId`, which is returned
    and decreased:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnSize` method compares the new size of the client area with its original
    size. The ratio between them is stored in `factorPair`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The controls of `idMap` are iterated and the original size of each control is
    multiplied with `factorPair`, the ratio between the new and original client area
    size. In this way, the control will keep their sizes relative to the size of the
    dialog client area when the user changes the dialog size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnReturn` method is called when the user presses the ***Return*** key,
    `OnEscape` is called when they press the ***Esc*** key, and `OnClose` is called
    when they close the dialog. The default behavior is to call `TryClose` and, if
    it returns `true`, call the Win32 API function `EndDialog`, which causes the `DialogBoxIndirectParam`
    call in `DoModal` to return the integer value given as the second parameter to
    `EndDialog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DialogProc` method is called each time the dialog receives a message.
    The first parameter is a handle to the dialog, which is mapped to a `Dialog` pointer
    by `dialogMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WM_INITDIALOG` case is called when the dialog is created, but before it
    becomes visible. When the dialog was created by the `DialogBoxIndirectParam` method,
    the last parameter was a pointer to the encapsulating `Dialog` object. That pointer
    is given in the `longParam` parameter, it is translated into a pointer to `Dialog`,
    and added to `dialogMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The Win32 API window handle of the dialog is assigned to `dialogHandle`, the
    original size of the client area is calculated and stored in `originalClientSize`,
    and `OnDialogInit` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'For each control in the dialog, its window handle is set by calling the Win32
    API function `GetDlgItem`, which takes the dialog window handle and the control
    identity number, set by `AddControl`. Similar to the original client size of the
    dialog, the original size and position of the controls are also stored. Finally,
    `OnControlInit` is called for each control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the message is handled, `TRUE` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WM_SIZE` case is sent to the dialog each time its size has been changed.
    The width and height are stored in the lower and upper word of the `longParam`
    parameter. The `OnSize` method is called in order to handle the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WM_CLOSE` case is called when the user tries to close the dialog. The
    `OnClose` method is called to handle the message, which may or may not close the
    dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WM_DESTROY` case is called when the dialog is being destroyed. Unlike
    `WM_CLOSE`, there is no way to prevent the dialog from being destroyed. Since
    `WM_DESTROY` is the last message sent to the dialog, the dialog is removed from
    `dialogMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WM_COMMAND` case is sent to the dialog when the user has performed some
    action with one of the controls. In cases where the action involves a control,
    its identity number is stored in the lower word of `wordParam`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If the identity number is `IDOK` or `IDCANCEL`, the user has pressed the ***Return***
    or ***Esc*** key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If the identity number is not `IDOK` or `IDCANCEL`, we look up the control
    with `idMap` and the notification code in the higher word of `wordParam`. The
    notification code may have the same value as `IDOK` or `IDCANCEL`, which is why
    we use this somewhat cumbersome construction to handle the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When a control gains or loses input focus, `OnGainFocus` or `OnLoseFocus` is
    called; when they change the input text of a text field, `OnChange` is called;
    when they change the selection of a combo box, list box, or multiple list box,
    `OnSelect` is called; and when they click on a push button, checkbox, or radio
    button, `OnClick` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'When the command message has been handled, there is no need to further process
    it. Therefore, we return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If the message has not been handled, we returns `false` in order for the message
    to be further processed by the Windows system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the Small Windows control hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controls](img/B05475_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Control.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor sends the parent window pointer to the `Window` constructer
    and stores the other values until it is added to the dialog information list by
    `AddControlInfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods are intended to be overridden by subclasses and are by
    default empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The rectangle holding the original size and position is set by `Dialog` when
    it receives the `MW_INITDIALOG` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Each control has an identity number, given by `AddControl` in `Dialog`. It
    has a regular style; the extended style is always 0\. The style, top-left corner
    and control size, class name, and control text are added to the information list
    when `DoModal` in `Dialog` calls `AddControlInfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**Control.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor calls `AddControl` for its parent dialog to add the control
    to the dialog and to receive the control''s identity number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddControlInfo` method, which is called by `DoModal` in `Dialog`, adds
    the information of the control. First, we need to align the information list with
    the size of a double word (4 bytes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The help identity and extended style are always 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The style is extended with the child and visible flags, indicating that the
    control is a child window of the dialog and that it becomes visible when the dialog
    becomes visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The top-left corner and size of the control are given in **dialog** **units**,
    which are based on the dialog font and are translated into device units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The control identity number is given in order to identify the control when
    the user performs some action, such as clicking on a button or selecting a list
    item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Each control has a class name, which is button, list, combo, static (label),
    or edit (text field), and text, which is the text of a text field or the label
    of a box or button, but is ignored for list and combo boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it is possible to send extra data with the control. However, we pass
    on that opportunity and just send 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The button controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four kinds of button controls: group box, push button, checkbox,
    and radio button. The checkbox and radio button can be checked; the `Check` and
    `IsChecked` methods are defined in `ButtonControl`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ButtonControl.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '**ButtonControl.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We send the `BM_SETCHECK` message to a check, a checkbox, or a radio button
    and the `BM_GETCHECK` message to find out whether it is checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: A group box is quite simple; it encapsulates a set of other controls and has
    no functionality besides its graphical appearance.
  prefs: []
  type: TYPE_NORMAL
- en: '**GroupBox.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '**GroupBox.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `clickListener` constructor parameter is a listener called when the user
    clicks on the button. The `OnClick` method is overridden from `Control`.
  prefs: []
  type: TYPE_NORMAL
- en: '**PushButton.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '**PushButton.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: A checkbox works independently of other checkboxes. The `checkPtr` parameter
    is a pointer to a `Boolean` value set to `true` or `false`, depending on whether
    the checkbox is checked.
  prefs: []
  type: TYPE_NORMAL
- en: '**CheckBox.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '**CheckBox.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnControlInit` method is overridden from `Control` and checks the box
    in accordance with the value that `checkPtr` points at. `OnClick` is also overridden
    from `Control` and sets the value to `true` if the box is checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: A radio button is intended to work in a group with other radio buttons, with
    exactly one button checked at the time. When the user checks one button in the
    group, it gets checked and the previously checked box get unchecked. Each radio
    button in the group has a zero-based index; `indexPtr` points to an integer value,
    common to all radio buttons in the group, which is set to the index of the button
    currently checked.
  prefs: []
  type: TYPE_NORMAL
- en: '**RadioButton.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '**RadioButton.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor sends the group and tab stop styles to the `Control` constructor
    if the index is 0, since the first button is the first button in the group. All
    buttons in the group will not be accessed by the ***Tab*** key, but only the first
    button. The `group` style indicates that the button starts a group and all additional
    radio buttons are considered members of the group, until another button with the
    `group` style is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The radio button is checked if it has the same index as the value that `indexPtr`
    points at, and the value is set to the index of the button that is checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: List controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two kinds of list box: single list box and multiple list box. The
    single list box selects exactly one item at a time, and the multiple list box
    selects one or several (or none at all) items at the same time. The constructor
    takes a string list that is loaded to the list box by `LoadList`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ListControl.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '**ListControl.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LoadList` method adds the item text in `textList` to the (single or multiple)
    list box by calling the `LB_ADDSTRING` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: A (single) list box is a box holding a list of visible items, as opposed to
    a combo box where the items are dropped down. If necessary, the list can be scrolled.
    Only one item can be selected at a time, as opposed to the multiple list. Similar
    to the radio box group, the constructor takes the `indexPtr` pointer pointing
    at an integer value holding the zero-based index of the currently selected item.
    Moreover, the constructor also takes a string list that is loaded into the list
    box by `LoadList` in `ListControl`.
  prefs: []
  type: TYPE_NORMAL
- en: '**ListBox.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '**ListBox.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We send the `LB_SETCURSEL` message to select an item and `LB_GETCURSEL` to
    get the index of the currently selected item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: A multiple list box is a list box where the user can select more than one value,
    or no value at all; therefore, the `indexSetPtr` parameter is a pointer to a set
    of indexes rather than a pointer to one index.
  prefs: []
  type: TYPE_NORMAL
- en: '**MultipleListBox.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '**MultipleListBox.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user selects 0 or several values in the multiple list, we iterate
    through the indexes and send the `LB_SETSEL` message for each index with a `Boolean`
    value indicating whether its item will be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'When checking which values are currently selected, we send the `LB_GETSEL`
    message for each index and add the indexes of the selected items to the set, which
    is then returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Combo box
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A combo box is a drop-down list of items, from which the user can select one.
    The functionality of a combo box is equal to a list box, only their graphical
    appearance differs. Moreover, the functionality is also equivalent to a radio
    button group. Similar to `ListBox` and `Radiobutton`, the constructor takes the
    `indexPtr` parameter, which is a pointer to an integer value, holding the zero-based
    index of the item currently selected.
  prefs: []
  type: TYPE_NORMAL
- en: '**ComboBox.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '**ComboBox.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CB_ADDSTRING` message loads the combo box with items, `CB_SETCURSEL` sets
    the selected item, and `CB_GETCURSEL` returns the index of the selected item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Label
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A label is a displayed text that often serves as a prompt to a text field; it
    has no functionality besides its graphical appearance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Label.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '**Label.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The TextField class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TextField` class is a template for a text field; it takes the type of the
    value stored in the text field; an integer base for octal, decimal, or hexadecimal
    integers (ignored for non-integer types); and a converter of the `Converter` class
    in the next section, which converts between values and text. The constructor's
    `valuePtr` parameter is a pointer to the value to be edited in the text field.
  prefs: []
  type: TYPE_NORMAL
- en: '**TextField.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnControlInit` method is called when the text field has been created.
    It converts the value to the text displayed in the text field. The `OnLoseFocus`
    method is called when the user leaves the text field and converts its text to
    a value of the template type if the text is valid. If it is not valid, the text
    field is set to the text converted from the latest valid value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The Win32 API function `GetWindowText` gets the text of the text field and
    `SetWindowText` sets its text. We need to convert from a zero-terminated character
    pointer string to a `String` object by calling the `String` constructor, and from
    a `String` object to a zero-terminated character pointer by calling the `c_str`
    method of the `String` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'When the text field has been initialized, the `ValueToText` method of the `Converter`
    class is called to convert the value pointed to by `valuePtr` to the text displayed
    in the text field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'When the text field loses input focus, the text is evaluated by the `Check`
    method in order to decide whether it is suitable to be converted to a value. If
    it is suitable, the `ValueToText` method is called to do the actual converting,
    and then the text is loaded to the text field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Converters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Converter` class is a template class intended to be specialized by type.
    Its task is to convert values between the template type and the `String` objects.
    The `Check` variable takes a string and returns `true` if it holds a valid value,
    `TextToValue` converts a text to a value, and `ValueToText` converts a value to
    a text.
  prefs: []
  type: TYPE_NORMAL
- en: '**Converter.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Signed integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Small Windows comes equipped with a set of predefined converters, which are
    specializations of `Converter`. One of these handles signed integer values of
    the type `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Converter.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '**Converter.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'When checking whether the given string holds a valid integer value, we create
    an `IStringStream` object (the generic version of the Standard C++ class `istringstream`,
    with `TCHAR` instead of `char`) initialized with the trimmed text (initial and
    terminating white spaces are removed). Then, we read the text into an integer
    variable with the base parameter and test whether the stream has reached end-of-file
    (`eof`). If it has, all characters of the text have been read, which implies that
    the text holds a valid integer value and `true` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The conversion from a string to an integer is similar to `Check`, which we
    covered earlier, with the difference that we return the integer value assuming
    that `Check` has confirmed that the text holds a valid integer value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'When converting an integer to a string, we use the `OStringStream` method (the
    generic version of `ostringstream`), write the value to the stream, and return
    the stream converted to a string by `str`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unsigned integers work in the same way as signed integers, the only difference
    is that `int` has been replaced by `unsigned` `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Converter.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '**Converter.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Double values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Double values ignore the base parameter and do not use the `setbase` manipulator;
    otherwise, the test and conversions work in the same way as in integer cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Converter.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '**Converter.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The string case is trivial, since a string can always be converted to another
    string.
  prefs: []
  type: TYPE_NORMAL
- en: '**Converter.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Rational numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **rational** **number** is a number that can be expressed as a fraction of
    two integers, where the second integer is non-zero. We do not really use rational
    numbers in this section or complex numbers in the next section, in our applications.
    They are included only to demonstrate the converter, and they are implemented
    in the Appendix at the end of the book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Converter.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: When checking whether the text holds a valid rational number, we simply create
    an object of the `Rational` class. If the constructor accepts the text without
    throwing a `NotaRationalNumber` exception, we return `true`. If it throws the
    exception, the text is not acceptable and we return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Converter.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'When converting a string to a rational number, we create and return a `Rational`
    object, assuming that `Check` has confirmed that the text holds a valid rational
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: When converting a rational number to a string we call the `String` conversion
    operator of the `Rational` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Complex numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A complex number is the sum *z = x + yi* of a real number *x* and a real number
    *y* multiplied by the **imaginary** **unit** *i*, which is the solution of the
    equation *x* ² + 1 = 0\. The specialization of `Converter` with regard to the
    `Complex` class is similar to the `Rational` specialization.
  prefs: []
  type: TYPE_NORMAL
- en: '**Converter.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '**Converter.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Page setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final section describes page setup functionality, divided into the `PageSetupInfo`
    class, which handles page setup information, the `PageSetupDialog`, which is a
    subclass of `Dialog` displayed for the user to input page setup information, and
    the `Template` function, which translates code input by the user in the **Page
    Setup** dialog to actual values.
  prefs: []
  type: TYPE_NORMAL
- en: Page setup information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `PageSetupInfo` class holds information about the page: portrait or landscape
    orientation, the margins, the text and font of the header and footer, whether
    the header and footer will be present on the first page, and whether the pages
    will be enclosed by a frame.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PageSetupInfo.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '**PageSetupInfo.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The default constructor initializes the default member values by calling `PageSetupInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The default constructor and assignment operator copy the member values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The equality operators compare all the fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Page setup information can be written to, or read from, a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The Page Setup dialog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PageSetupDialog` class is a part of Small Windows and is displayed by the
    `StandardDocument` framework when the user selects the **Page Setup** menu item.
    The word processor earlier in this book gives an example. The `PageSetupDialog`
    class is a subclass of `Dialog` and provides the user with the possibility to
    input the information in `PageSetupInfo`. Note that the header and footer text
    can be annotated with blocks of code, explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Page Setup dialog](img/B05475_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PageSetupDialog.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Each push button has its own listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The page setup information is pointed at by `infoPtr`, which is modified when
    the user changes the state of the controls. There is also `backupInfo`, in case
    the user cancels the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '**PageSetupDialog.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor sets the pointer `infoPtr` to point at the page setup information.
    The information is also stored in `backupInfo`, which will be used if the user
    cancels the dialog; refer to `OnCancel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Each control gives the **Page Setup** dialog (`this`) as its parent dialog,
    which means that the controls will be deleted by the dialog''s destructor. This
    implies that we do need to keep track of the controls in order to delete them
    manually. Actually, we will not delete them manually as it would result in dangling
    pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we give a pointer as a reference for the value of the top margin.
    This value will be modified when the user changes the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the `TextField` case, we give a pointer to a reference of the `HeaderFirst`
    value, which is a `Boolean` value. It will be modified when the user checks the
    box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnHeaderFont` listener is called when the user presses the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnHeaderFont` and `OnFooterFont` methods display font dialogs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnOk` and `OnCancel` methods terminate the dialog. The `OnCancel` method
    also copies the backup information that was stored by the constructor at the beginning,
    since no new information will be returned when the user cancels the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The Template function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the user inputs text in the header and footer fields in the **Page Setup**
    dialog, they can insert code in the text, which needs to be translated into valid
    values. The code is shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| %P | Path with suffix | `C:\Test\Test.wrd` |'
  prefs: []
  type: TYPE_TB
- en: '| %p | Path without suffix | `C:\Test\Test` |'
  prefs: []
  type: TYPE_TB
- en: '| %F | File with suffix | `Test.wrd` |'
  prefs: []
  type: TYPE_TB
- en: '| %f | File without suffix | Test |'
  prefs: []
  type: TYPE_TB
- en: '| %N | Total number of pages | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| %n | Current page | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| %c | Current Copy | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| %D | Date with full month | January 1, 2016 |'
  prefs: []
  type: TYPE_TB
- en: '| %d | Date with abbreviated month | Jan 1, 2016 |'
  prefs: []
  type: TYPE_TB
- en: '| %T | Time with seconds | 07:08:09 |'
  prefs: []
  type: TYPE_TB
- en: '| %t | Time without seconds | 07:08 |'
  prefs: []
  type: TYPE_TB
- en: '| %% | Percent character | % |'
  prefs: []
  type: TYPE_TB
- en: The task of the `Template` function is to replace the code with valid values.
    It takes the `templateText` string with template code and returns the text with
    the code replaced by valid values. It needs the current copy and page number as
    well as the total number of pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the `Page %n out of %N` text can be translated to **Page 3 out
    of 5** and `File: %F, date: %d` can be translated to **File: Text.txt, date: Dec
    31, 2016**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Template.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '**Template.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by replacing the `c`, `n`, and `N` code with the number of copies
    and the current and total pages. The numerical values are translated into strings
    by `to_String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The file of the path is its text after the last backslash (**\**) and the suffix
    is its text after the last dot (**.**). If there is no backslash, the file is
    the same as the path; if there is no dot, the path and file without the suffix
    is the same as the file and path with the suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The current date and time are obtained by calling the Standard C functions
    `time` and `localtime_s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'The current time with and without seconds and the current date with whole and
    abbreviated month names are written to string output streams. The `setw` manipulator
    makes sure that two characters are always written, `setfill` fills with zeros
    if necessary, and `ios::right` writes the value in a right-aligned manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to replace each instance of `%%` with `%`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked into custom dialogs, controls, converters, and the
    Page Setup dialog. The only remaining part of the book is the implementation of
    the rational and complex classes.
  prefs: []
  type: TYPE_NORMAL
