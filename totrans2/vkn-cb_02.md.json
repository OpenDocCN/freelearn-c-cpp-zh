["```cpp\ndesired_extensions.emplace_back( VK_KHR_SURFACE_EXTENSION_NAME ); \ndesired_extensions.emplace_back( \n#ifdef VK_USE_PLATFORM_WIN32_KHR \n  VK_KHR_WIN32_SURFACE_EXTENSION_NAME \n\n#elif defined VK_USE_PLATFORM_XCB_KHR \n  VK_KHR_XCB_SURFACE_EXTENSION_NAME \n\n#elif defined VK_USE_PLATFORM_XLIB_KHR \n  VK_KHR_XLIB_SURFACE_EXTENSION_NAME \n#endif \n); \n\nreturn CreateVulkanInstance( desired_extensions, application_name, instance );\n\n```", "```cpp\nstruct WindowParameters { \n#ifdef VK_USE_PLATFORM_WIN32_KHR \n  HINSTANCE          HInstance; \n  HWND               HWnd; \n#elif defined VK_USE_PLATFORM_XLIB_KHR \n  Display          * Dpy; \n  Window             Window; \n#elif defined VK_USE_PLATFORM_XCB_KHR \n  xcb_connection_t * Connection; \n  xcb_window_t       Window; \n#endif \n};\n\n```", "```cpp\n#ifdef VK_USE_PLATFORM_WIN32_KHR \n\nVkWin32SurfaceCreateInfoKHR surface_create_info = { \n  VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR, \n  nullptr, \n  0, \n  window_parameters.HInstance, \n  window_parameters.HWnd \n}; \n\nVkResult result = vkCreateWin32SurfaceKHR( instance, &surface_create_info, nullptr, &presentation_surface );\n\n```", "```cpp\n#elif defined VK_USE_PLATFORM_XLIB_KHR \n\nVkXlibSurfaceCreateInfoKHR surface_create_info = { \n  VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR, \n  nullptr, \n  0, \n  window_parameters.Dpy, \n  window_parameters.Window \n}; \n\nVkResult result = vkCreateXlibSurfaceKHR( instance, &surface_create_info, nullptr, &presentation_surface );\n\n```", "```cpp\n#elif defined VK_USE_PLATFORM_XCB_KHR \n\nVkXcbSurfaceCreateInfoKHR surface_create_info = { \n  VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR, \n  nullptr, \n  0, \n  window_parameters.Connection, \n  window_parameters.Window \n}; \n\nVkResult result = vkCreateXcbSurfaceKHR( instance, &surface_create_info, nullptr, &presentation_surface ); \n\n#endif\n\n```", "```cpp\nif( (VK_SUCCESS != result) || \n    (VK_NULL_HANDLE == presentation_surface) ) { \n  std::cout << \"Could not create presentation surface.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nstd::vector<VkQueueFamilyProperties> queue_families; \nif( !CheckAvailableQueueFamiliesAndTheirProperties( physical_device, queue_families ) ) { \n  return false; \n}\n\n```", "```cpp\nfor( uint32_t index = 0; index < static_cast<uint32_t>(queue_families.size()); ++index ) { \n  VkBool32 presentation_supported = VK_FALSE; \n  VkResult result = vkGetPhysicalDeviceSurfaceSupportKHR( physical_device, index, presentation_surface, &presentation_supported ); \n  if( (VK_SUCCESS == result) && \n      (VK_TRUE == presentation_supported) ) { \n    queue_family_index = index; \n    return true; \n  } \n} \nreturn false;\n\n```", "```cpp\ndesired_extensions.emplace_back( VK_KHR_SWAPCHAIN_EXTENSION_NAME ); \n\nreturn CreateLogicalDevice( physical_device, queue_infos, desired_extensions, desired_features, logical_device );\n\n```", "```cpp\nuint32_t present_modes_count = 0; \nVkResult result = VK_SUCCESS; \n\nresult = vkGetPhysicalDeviceSurfacePresentModesKHR( physical_device, presentation_surface, &present_modes_count, nullptr ); \nif( (VK_SUCCESS != result) || \n    (0 == present_modes_count) ) { \n  std::cout << \"Could not get the number of supported present modes.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nstd::vector<VkPresentModeKHR> present_modes( present_modes_count ); \nresult = vkGetPhysicalDeviceSurfacePresentModesKHR( physical_device, presentation_surface, &present_modes_count, &present_modes[0] ); \nif( (VK_SUCCESS != result) || \n  (0 == present_modes_count) ) { \n  std::cout << \"Could not enumerate present modes.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nfor( auto & current_present_mode : present_modes ) { \n  if( current_present_mode == desired_present_mode ) { \n    present_mode = desired_present_mode; \n    return true; \n  } \n} \n\nstd::cout << \"Desired present mode is not supported. Selecting default FIFO mode.\" << std::endl; \nfor( auto & current_present_mode : present_modes ) { \n  if( current_present_mode == VK_PRESENT_MODE_FIFO_KHR ) { \n    present_mode = VK_PRESENT_MODE_FIFO_KHR; \n    return true; \n  } \n}\n\n```", "```cpp\nVkResult result = vkGetPhysicalDeviceSurfaceCapabilitiesKHR( physical_device, presentation_surface, &surface_capabilities ); \n\nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not get the capabilities of a presentation surface.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nnumber_of_images = surface_capabilities.minImageCount + 1; \nif( (surface_capabilities.maxImageCount > 0) && \n    (number_of_images > surface_capabilities.maxImageCount) ) { \n  number_of_images = surface_capabilities.maxImageCount; \n} \nreturn true;\n\n```", "```cpp\nif( 0xFFFFFFFF == surface_capabilities.currentExtent.width ) { \n  size_of_images = { 640, 480 }; \n\n  if( size_of_images.width < surface_capabilities.minImageExtent.width ) { \n    size_of_images.width = surface_capabilities.minImageExtent.width; \n  } else if( size_of_images.width > surface_capabilities.maxImageExtent.width ) { \n    size_of_images.width = surface_capabilities.maxImageExtent.width; \n  } \n\n  if( size_of_images.height < surface_capabilities.minImageExtent.height ) { \n    size_of_images.height = surface_capabilities.minImageExtent.height; \n  } else if( size_of_images.height > surface_capabilities.maxImageExtent.height ) { \n    size_of_images.height = surface_capabilities.maxImageExtent.height; \n  } \n} else { \n  size_of_images = surface_capabilities.currentExtent; \n} \nreturn true;\n\n```", "```cpp\nimage_usage = desired_usages & surface_capabilities.supportedUsageFlags; \n\nreturn desired_usages == image_usage;\n\n```", "```cpp\nif( surface_capabilities.supportedTransforms & desired_transform ) { \n  surface_transform = desired_transform; \n} else { \n  surface_transform = surface_capabilities.currentTransform; \n}\n\n```", "```cpp\nuint32_t formats_count = 0; \nVkResult result = VK_SUCCESS; \n\nresult = vkGetPhysicalDeviceSurfaceFormatsKHR( physical_device, presentation_surface, &formats_count, nullptr ); \nif( (VK_SUCCESS != result) || \n    (0 == formats_count) ) { \n  std::cout << \"Could not get the number of supported surface formats.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nstd::vector<VkSurfaceFormatKHR> surface_formats( formats_count ); \nresult = vkGetPhysicalDeviceSurfaceFormatsKHR( physical_device, presentation_surface, &formats_count, &surface_formats[0] ); \nif( (VK_SUCCESS != result) || \n    (0 == formats_count) ) { \n  std::cout << \"Could not enumerate supported surface formats.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nif( (1 == surface_formats.size()) && \n    (VK_FORMAT_UNDEFINED == surface_formats[0].format) ) { \n  image_format = desired_surface_format.format; \n  image_color_space = desired_surface_format.colorSpace; \n  return true; \n}\n\n```", "```cpp\nfor( auto & surface_format : surface_formats ) { \n  if( (desired_surface_format.format == surface_format.format) && \n      (desired_surface_format.colorSpace == surface_format.colorSpace) ) { \n    image_format = desired_surface_format.format; \n    image_color_space = desired_surface_format.colorSpace; \n    return true; \n  } \n}\n\n```", "```cpp\nfor( auto & surface_format : surface_formats ) { \n  if( (desired_surface_format.format == surface_format.format) ) { \n    image_format = desired_surface_format.format; \n    image_color_space = surface_format.colorSpace; \n    std::cout << \"Desired combination of format and colorspace is not supported. Selecting other colorspace.\" << std::endl; \n    return true; \n  } \n}\n\n```", "```cpp\nimage_format = surface_formats[0].format; \nimage_color_space = surface_formats[0].colorSpace; \nstd::cout << \"Desired format is not supported. Selecting available format - colorspace combination.\" << std::endl; \nreturn true;\n\n```", "```cpp\nVkSwapchainCreateInfoKHR swapchain_create_info = { \n  VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR, \n  nullptr, \n  0, \n  presentation_surface, \n  image_count, \n  surface_format.format, \n  surface_format.colorSpace, \n  image_size, \n  1, \n  image_usage, \n  VK_SHARING_MODE_EXCLUSIVE, \n  0, \n  nullptr, \n  surface_transform, \n  VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR, \n  present_mode, \n  VK_TRUE, \n  old_swapchain \n}; \n\nVkResult result = vkCreateSwapchainKHR( logical_device, &swapchain_create_info, nullptr, &swapchain ); \nif( (VK_SUCCESS != result) || \n    (VK_NULL_HANDLE == swapchain) ) { \n  std::cout << \"Could not create a swapchain.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE != old_swapchain ) { \n  vkDestroySwapchainKHR( logical_device, old_swapchain, nullptr ); \n  old_swapchain = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nuint32_t images_count = 0; \nVkResult result = VK_SUCCESS; \n\nresult = vkGetSwapchainImagesKHR( logical_device, swapchain, &images_count, nullptr ); \nif( (VK_SUCCESS != result) || \n    (0 == images_count) ) { \n  std::cout << \"Could not get the number of swapchain images.\" << std::endl; \n  return false; \n}\n\n```", "```cpp\nswapchain_images.resize( images_count ); \nresult = vkGetSwapchainImagesKHR( logical_device, swapchain, &images_count, &swapchain_images[0] ); \nif( (VK_SUCCESS != result) || \n  (0 == images_count) ) { \n  std::cout << \"Could not enumerate swapchain images.\" << std::endl; \n  return false; \n} \n\nreturn true;\n\n```", "```cpp\nVkPresentModeKHR desired_present_mode; \nif( !SelectDesiredPresentationMode( physical_device, presentation_surface, VK_PRESENT_MODE_MAILBOX_KHR, desired_present_mode ) ) { \n  return false; \n}\n\n```", "```cpp\nVkSurfaceCapabilitiesKHR surface_capabilities; \nif( !GetCapabilitiesOfPresentationSurface( physical_device, presentation_surface, surface_capabilities ) ) { \n  return false; \n} \n\nuint32_t number_of_images; \nif( !SelectNumberOfSwapchainImages( surface_capabilities, number_of_images ) ) { \n  return false; \n} \n\nVkExtent2D image_size; \nif( !ChooseSizeOfSwapchainImages( surface_capabilities, image_size ) ) { \n  return false; \n} \nif( (0 == image_size.width) || \n    (0 == image_size.height) ) { \n  return true; \n} \n\nVkImageUsageFlags image_usage; \nif( !SelectDesiredUsageScenariosOfSwapchainImages( surface_capabilities, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, image_usage ) ) { \n  return false; \n} \n\nVkSurfaceTransformFlagBitsKHR surface_transform; \nSelectTransformationOfSwapchainImages( surface_capabilities, VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR, surface_transform ); \n\nVkFormat image_format; \nVkColorSpaceKHR image_color_space; \nif( !SelectFormatOfSwapchainImages( physical_device, presentation_surface, { VK_FORMAT_R8G8B8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR }, image_format, image_color_space ) ) { \n  return false; \n}\n\n```", "```cpp\nif( !CreateSwapchain( logical_device, presentation_surface, number_of_images, { image_format, image_color_space }, image_size, image_usage, surface_transform, desired_present_mode, old_swapchain, swapchain ) ) { \n  return false; \n} \n\nif( !GetHandlesOfSwapchainImages( logical_device, swapchain, swapchain_images ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkResult result; \n\nresult = vkAcquireNextImageKHR( logical_device, swapchain, 2000000000, semaphore, fence, &image_index ); \nswitch( result ) { \n  case VK_SUCCESS: \n  case VK_SUBOPTIMAL_KHR: \n    return true; \ndefault: \n  return false; \n}\n\n```", "```cpp\nstruct PresentInfo { \n  VkSwapchainKHR  Swapchain; \n  uint32_t        ImageIndex; \n};\n\n```", "```cpp\nVkPresentInfoKHR present_info = { \n  VK_STRUCTURE_TYPE_PRESENT_INFO_KHR, \n  nullptr, \n  static_cast<uint32_t>(rendering_semaphores.size()), \n  rendering_semaphores.size() > 0 ? &rendering_semaphores[0] : nullptr, \n  static_cast<uint32_t>(swapchains.size()), \n  swapchains.size() > 0 ? &swapchains[0] : nullptr, \n  swapchains.size() > 0 ? &image_indices[0] : nullptr, \n  nullptr \n};  \n\nresult = vkQueuePresentKHR( queue, &present_info ); \nswitch( result ) { \ncase VK_SUCCESS: \n  return true; \ndefault: \n  return false; \n}\n\n```", "```cpp\nif( swapchain ) { \n  vkDestroySwapchainKHR( logical_device, swapchain, nullptr ); \n  swapchain = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nif( presentation_surface ) { \n  vkDestroySurfaceKHR( instance, presentation_surface, nullptr ); \n  presentation_surface = VK_NULL_HANDLE; \n}\n\n```"]