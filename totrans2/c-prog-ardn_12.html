<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Playing with Max 6 Framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Playing with Max 6 Framework</h1></div></div></div><p>This chapter will teach us some tips and techniques that we can use with the Max 6 graphical programming framework and Arduino boards.</p><p>We introduced this amazing framework in <a class="link" href="ch06.html" title="Chapter 6. Sensing the World – Feeling with Analog Inputs">Chapter 6</a>, <span class="emphasis"><em>Sense the World – Feeling with Analog Inputs</em></span>, while we learned about Arduino analog input handling. Reading the previous chapter is a requirement to better understand and learn the techniques developed in this chapter. I even suggest you read the Max 6 introduction part again.</p><p>In this chapter, we will learn how to send data to Arduino from Max 6. We will also describe how we can handle and parse the data being received from Arduino.</p><p>Arduino adds a lot of features to your Max 6 programs. Indeed, it provides a way to plug Max 6 into the real physical world. Through two examples, we are going to understand a nice way of working with Arduino, the computer and most advanced programming framework ever.</p><p>Let's go.</p><div class="section" title="Communicating easily with Max 6 – the [serial] object"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec83"/>Communicating easily with Max 6 – the [serial] object</h1></div></div></div><p>As we already <a id="id1410" class="indexterm"/>discussed in <a class="link" href="ch06.html" title="Chapter 6. Sensing the World – Feeling with Analog Inputs">Chapter 6</a>, <span class="emphasis"><em>Sensing the World – Feeling with Analog Inputs</em></span>, the easiest way to exchange data between your computer running a Max 6 patch and your Arduino board is via the serial port. The USB connector of our Arduino boards includes the FTDI integrated circuit <a id="id1411" class="indexterm"/>EEPROM FT-232 that converts the RS-232 plain old serial standard to USB.</p><p>We are going to use again our basic USB connection between Arduino and our computer in order to exchange data here.</p><div class="section" title="The [serial] object"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec182"/>The [serial] object</h2></div></div></div><p>We have to <a id="id1412" class="indexterm"/>remember the <code class="literal">[serial]</code> object's features. It provides a way to send and receive data from a serial port. To do this, there is a basic patch including <a id="id1413" class="indexterm"/>basic blocks. We are going to improve it progressively all along this subchapter.</p><p>The <code class="literal">[serial]</code> object is like a buffer we have to poll as much as we need. If messages are sent from Arduino to the serial port of the computer, we have to ask the <code class="literal">[serial]</code> object to pop them out. We are going to do this in the following pages.</p><div class="mediaobject"><img src="graphics/7584_12_001.jpg" alt="The [serial] object"/></div><p>You can find it in the <code class="literal">Chapter12</code> folder; the patch is named<a id="id1414" class="indexterm"/> <code class="literal">serialObject.maxpat</code>.</p><p>Of course, this chapter is also a pretext for me to give you some of my tips and tricks in Max 6 itself. Take them and use them; they will make your patching life easier.</p></div><div class="section" title="Selecting the right serial port"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec183"/>Selecting the right serial port</h2></div></div></div><p>In <a class="link" href="ch06.html" title="Chapter 6. Sensing the World – Feeling with Analog Inputs">Chapter 6</a>, <span class="emphasis"><em>Sense the World – Feeling with Analog Inputs</em></span>, we used the message <code class="literal">(print)</code> sent <a id="id1415" class="indexterm"/>to <code class="literal">[serial]</code> in order to list all the serial ports available on the <a id="id1416" class="indexterm"/>computer. Then we checked the Max window. That was not the smartest solution. Here, we are going to design a better one.</p><p>We have to remember the<a id="id1417" class="indexterm"/> <code class="literal">[loadbang]</code> object. It fires a bang, that is, a <code class="literal">(print)</code> message to the following object as soon as the patch is loaded. It is useful to set things up and initialize some values as we could inside our <code class="literal">setup()</code> block in our Arduino board's firmware.</p><p>Here, we do that in order to fill the serial port selector menu. When the <code class="literal">[serial]</code> object receives the <code class="literal">(print)</code> message, it pops out a list of all the serial ports available on the computer from its right outlet prepended by the word <code class="literal">port</code>. We then process the result by using <code class="literal">[route port]</code> that only parses lists prepended with the word <code class="literal">port</code>.</p><p>The <code class="literal">[t]</code> object is an abbreviation of<a id="id1418" class="indexterm"/> <code class="literal">[trigger]</code>. This object sends the incoming message to many locations, as is written in the documentation, if you assume the use of the following arguments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">b</code> means bang</li><li class="listitem" style="list-style-type: disc"><code class="literal">f</code> means float number</li><li class="listitem" style="list-style-type: disc"><code class="literal">i</code> means integer</li><li class="listitem" style="list-style-type: disc"><code class="literal">s</code> means symbol</li><li class="listitem" style="list-style-type: disc"><code class="literal">l</code> means list (that is, at least one element)</li></ul></div><p>We can also use constants as arguments and as soon as the input is received, the constant will be sent as it is.</p><p>At last, the <code class="literal">[trigger]</code> output messages in a particular order: from the rightmost outlet to the leftmost one.</p><p>So here we take the list of serial ports being received from the <code class="literal">[route]</code> object; we send the <code class="literal">clear</code> message to the<a id="id1419" class="indexterm"/> <code class="literal">[umenu]</code> object (the list menu on the left side) in order to clear the whole list. Then the list of serial ports is sent as a list (because of the first argument) to <code class="literal">[iter]</code>. <code class="literal">[iter]</code> <a id="id1420" class="indexterm"/>splits a list into its individual elements.</p><p>
<code class="literal">[prepend]</code> <a id="id1421" class="indexterm"/>adds a message in front of the incoming input message.</p><p>That means the global process sends messages to the <code class="literal">[umenu]</code> object<a id="id1422" class="indexterm"/> similar to the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">append <code class="literal">xxxxxx</code></li><li class="listitem" style="list-style-type: disc">append <code class="literal">yyyyyy</code></li></ul></div><p>Here <code class="literal">xxxxxx</code> and <code class="literal">yyyyyy</code> are the serial ports that are available.</p><p>This <a id="id1423" class="indexterm"/>creates the serial port selector menu by filling the list with the names of the serial ports. This is one of the typical ways to create some helpers, in this case the menu, in our patches using UI elements.</p><p>As soon as you <a id="id1424" class="indexterm"/>load this patch, the menu is filled, and you only have to choose the right serial port you want to use. As soon as you select one element in the menu, the number of the element in the list is fired to its leftmost outlet. We prepend this number by port and send that to <code class="literal">[serial]</code>, setting it up to the right-hand serial port.</p></div><div class="section" title="Polling system"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec184"/>Polling system</h2></div></div></div><p>One of the most used <a id="id1425" class="indexterm"/>objects in Max 6 to send regular bangs in order to trigger <a id="id1426" class="indexterm"/>things or count time is <code class="literal">[metro]</code>.</p><p>We have to use one argument at least; this is the time between two bangs in milliseconds.</p><p>Banging the <code class="literal">[serial]</code> object makes it pop out the values contained in its buffer.</p><p>If we want to send data continuously from Arduino and process them with Max 6, activating the <code class="literal">[metro]</code> object<a id="id1427" class="indexterm"/> is required. We then send a regular bang and can have an update of all the inputs read by Arduino inside our Max 6 patch.</p><p>Choosing a value between 15 ms and 150 ms is good but depends on your own needs.</p><p>Let's now see how we can read, parse, and select useful data being received from Arduino.</p></div></div></div>
<div class="section" title="Parsing and selecting data coming from Arduino"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec84"/>Parsing and selecting data coming from Arduino</h1></div></div></div><p>First, I want to <a id="id1428" class="indexterm"/>introduce <a id="id1429" class="indexterm"/>you to a helper firmware inspired by the <span class="emphasis"><em>Arduino2Max</em></span> page on the Arduino website but updated and optimized a bit by me. It provides a way to read all the inputs on your Arduino, to pack all the data read, and to send them to our Max 6 patch through the <code class="literal">[serial]</code> object.</p><div class="section" title="The readAll firmware"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec185"/>The readAll firmware</h2></div></div></div><p>The following code is<a id="id1430" class="indexterm"/> the firmware. You can find it in <code class="literal">Chapter12/ReadAll</code>:</p><div class="informalexample"><pre class="programlisting">int val = 0;

void setup()
{
  Serial.begin(9600);
  pinMode(13,INPUT);
}

void loop()
{ 
  // Check serial buffer for characters incoming
  if (Serial.available() &gt; 0){         

    // If an 'r' is received then read all the pins
    if (Serial.read() == 'r') {       

      // Read and send analog pins 0-5 values
      for (int pin= 0; pin&lt;=5; pin++){      
        val = analogRead(pin);
        sendValue (val);
      }

      // Read and send digital pins 2-13 values
      for (int pin= 2; pin&lt;=13; pin++){     
        val = digitalRead(pin);
        sendValue (val);
      }

      Serial.println();// Carriage return to mark end of data flow. 
      delay (5);     // prevent buffer overload

    }

  }
}

void sendValue (int val){
  Serial.print(val);
  Serial.write(32);  // add a space character after each value sent
}</pre></div><p>For starters, we<a id="id1431" class="indexterm"/> begin the serial communication at 9600 bauds in the <code class="literal">setup()</code> block.</p><p>As usual with serial communication handling, we check if there is something in the serial buffer of Arduino at first by using the<a id="id1432" class="indexterm"/> <code class="literal">Serial.available()</code> function. If something is available, we check if it is the character <code class="literal">r</code>. Of course, we can use any other character. <code class="literal">r</code> here stands for read, which is basic. If an <code class="literal">r</code> is received, it triggers the read of both analog and digital ports. Each value (the <code class="literal">val</code> variable) is passed to the<a id="id1433" class="indexterm"/> <code class="literal">sendValue()</code>function; this basically prints the value into the serial port and adds a space character in order to format things a bit to provide an easier parsing by Max 6. We could easily adapt this code to only read some inputs and not all. We could also remove the <code class="literal">sendValue()</code> function and find another way of packing data.</p><p>At the end, we <a id="id1434" class="indexterm"/>push a carriage return to the serial port by using <code class="literal">Serial.println()</code>. This creates a separator between each pack of data that is sent.</p><p>Now, let's improve our Max 6 patch to handle this pack of data being received from Arduino.</p></div><div class="section" title="The ReadAll Max 6 patch"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec186"/>The ReadAll Max 6 patch</h2></div></div></div><p>The following <a id="id1435" class="indexterm"/>screenshot is the <code class="literal">ReadAll</code> Max patch that provides a way to communicate with our Arduino:</p><div class="mediaobject"><img src="graphics/7584_12_002.jpg" alt="The ReadAll Max 6 patch"/></div><p>You can find this patch in the <code class="literal">Chapter12</code> folder. It is named<a id="id1436" class="indexterm"/> <code class="literal">ReadAll.maxpat</code>.</p><p>We added a <a id="id1437" class="indexterm"/>couple of more things to the basic building blocks in the previous patch.</p><div class="section" title="Requesting data from Arduino"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec149"/>Requesting data from Arduino</h3></div></div></div><p>First, we will see<a id="id1438" class="indexterm"/> a <code class="literal">[t b b]</code> object. It is also a trigger, ordering <a id="id1439" class="indexterm"/>bangs provided by the <code class="literal">[metro]</code> object. Each bang<a id="id1440" class="indexterm"/> received triggers another bang to another <code class="literal">[trigger]</code> object, then another one to the <code class="literal">[serial]</code> object itself.</p><p>The <code class="literal">[t 13 r]</code> object can seem tricky. It just triggers a character <code class="literal">r</code> and then the integer <code class="literal">13</code>. The character <code class="literal">r</code> is sent to <code class="literal">[spell]</code> that converts it to ASCII code and then sends the result to <code class="literal">[serial]</code>. <code class="literal">13</code> is the ASCII code for a carriage return.</p><p>This structure provides a way to fire the character <code class="literal">r</code> to the <code class="literal">[serial]</code> object, which means to Arduino, each time that the metro bangs. As we already see in the firmware, it triggers Arduino to read all its inputs, then to pack the data, and then to send the pack to the serial port for the Max 6 patch.</p><p>To<a id="id1441" class="indexterm"/> summarize what the metro triggers at each bang, we <a id="id1442" class="indexterm"/>can <a id="id1443" class="indexterm"/>write this sequence:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Send the character <code class="literal">r</code> to Arduino.</li><li class="listitem">Send a carriage return to Arduino.</li><li class="listitem">Bang the <code class="literal">[serial]</code> object.</li></ol></div><p>This triggers Arduino to send back all its data to the Max patch.</p></div><div class="section" title="Parsing the received data"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec150"/>Parsing the received data</h3></div></div></div><p>Under the <code class="literal">[serial]</code> object, we <a id="id1444" class="indexterm"/>can see a new structure beginning <a id="id1445" class="indexterm"/>with the <code class="literal">[sel 10 13]</code> object. This is an abbreviation for the <code class="literal">[select]</code> object. This object selects an incoming message and fires a bang to the specific output if the message equals the argument corresponding to the specific place of that output. Basically, here we select <code class="literal">10</code> or <code class="literal">13</code>. The last output pops the incoming message out if that one doesn't equal any argument.</p><p>Here, we don't want to consider a new line feed (ASCII code <code class="literal">10</code>). This is why we put it as an argument, but we don't do anything if that's the one that has been selected. It is a nice trick to avoid having this message trigger anything and even to not have it from the right output of <code class="literal">[select]</code>.</p><p>Here, we send all the messages received from Arduino, except <code class="literal">10</code> or <code class="literal">13</code>, to the <code class="literal">[zl group 78]</code> object. The latter is a powerful list for processing many features. The <code class="literal">group</code> argument makes it easy to group the messages received in a list. The last argument is to make sure we don't have too many elements in the list. As soon as <code class="literal">[zl group]</code> is triggered by a bang <span class="emphasis"><em>or</em></span> the list length reaches the length argument value, it pops out the whole list from its left outlet.</p><p>Here, we "accumulate" all the messages received from Arduino, and as soon as a carriage return is sent (remember we are doing that in the last rows of the <code class="literal">loop()</code> block in the firmware), a bang is sent and all the data is passed to the next object.</p><p>We currently have a big list with all the data inside it, with each value being separated from the other by a space character (the famous ASCII code 32 we added in the last function of the firmware).</p><p>This list is passed to the <code class="literal">[itoa]</code> object. <span class="strong"><strong>itoa</strong></span>
<a id="id1446" class="indexterm"/> stands for <span class="emphasis"><em>integer to ASCII</em></span>. This object converts integers to ASCII characters.</p><p>The <code class="literal">[fromsymbol]</code> object<a id="id1447" class="indexterm"/> converts a symbol to a list of messages.</p><p>Finally, after<a id="id1448" class="indexterm"/> this <code class="literal">[fromsymbol]</code> object<a id="id1449" class="indexterm"/> we <a id="id1450" class="indexterm"/>have our big list of values separated by spaces and totally readable.</p><p>We then have to unpack the list. <code class="literal">[unpack]</code> is a very useful object that provides a way to cut a list of messages into individual messages. We can notice here that we implemented exactly the opposite process in the Arduino firmware while we packed each value into a big message.</p><p>
<code class="literal">[unpack]</code> takes as many arguments as we want. It requires knowing about the exact number of elements in the list sent to it. Here we send 12 values from Arduino, so we put 12 <code class="literal">i</code> arguments. <code class="literal">i</code> stands for <span class="emphasis"><em>integer</em></span>. If we send a float, <code class="literal">[unpack]</code> would cast it as an integer. It is important to know this. Too many students are stuck with troubleshooting this in particular.</p><p>We are only playing with the integer here. Indeed, the ADC of Arduino provides data from 0 to 1023 and the digital input provides 0 or 1 only.</p><p>We attached a number box to each output of the <code class="literal">[unpack]</code> object<a id="id1451" class="indexterm"/> in order to display each value.</p><p>Then we used a <code class="literal">[change]</code> object. This latter is a nice object. When it receives a value, it passes it to its output only if it is different from the previous value received. It provides an effective way to avoid sending the same value each time when it isn't required.</p><p>Here, I chose the argument <code class="literal">-1</code> because this is not a value sent by the Arduino firmware, and I'm sure that the<a id="id1452" class="indexterm"/> first element sent will be parsed.</p><p>So we now <a id="id1453" class="indexterm"/>have all our values available. We can use them for different jobs.</p><p>But I propose to use a smarter way, and this will also introduce a new concept.</p></div><div class="section" title="Distributing received data and other tricks"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec151"/>Distributing received data and other tricks</h3></div></div></div><p>Let's introduce <a id="id1454" class="indexterm"/>here some other tricks to<a id="id1455" class="indexterm"/> improve our patching style.</p><div class="section" title="Cordless trick"><div class="titlepage"><div><div><h4 class="title"><a id="ch12lvl4sec39"/>Cordless trick</h4></div></div></div><p>We often have to <a id="id1456" class="indexterm"/>use <a id="id1457" class="indexterm"/>some data in our patches. The same data has to feed more than one object.</p><p>A good way to avoid messy patches with a lot of cord and wires everywhere is to use the <code class="literal">[send]</code> and <code class="literal">[receive]</code> objects. These objects can be abbreviated with <code class="literal">[s]</code> and <code class="literal">[r]</code>, and they generate communication buses and provide a wireless way to communicate inside our patches.</p><div class="mediaobject"><img src="graphics/7584_12_003.jpg" alt="Cordless trick"/></div><p>These<a id="id1458" class="indexterm"/> three structures are equivalent.</p><p>The <a id="id1459" class="indexterm"/>first one is a basic cord. As soon as we send data from the upper number box, it is transmitted to the one at the other side of the cord.</p><p>The second one generates a data bus named <code class="literal">busA</code>. As soon as you send data into <code class="literal">[send busA]</code>, each <code class="literal">[receive busA]</code> object in your patch will pop out that data.</p><p>The third example is the same as the second one, but it generates another bus named <code class="literal">busB</code>.</p><p>This is a good way to distribute data.</p><p>I often use this for my master clock, for instance. I have one and only one master clock banging a clock to <code class="literal">[send masterClock]</code>, and wherever I need to have that clock, I use <code class="literal">[receive masterClock]</code> and it provides me with the data I need.</p><p>If you check the global patch, you can see that we distribute data to the structures at the bottom of the patch. But these structures could also be located elsewhere. Indeed, one of the strengths of any visual programming framework such as Max 6 is the fact that you can visually organize every part of your code exactly as you want in your patcher. And please, do that as much as you can. This will help you to support and maintain your patch all through your long development months.</p><div class="mediaobject"><img src="graphics/7584_12_004.jpg" alt="Cordless trick"/></div><p>Check the<a id="id1460" class="indexterm"/> previous screenshot. I could have linked the <code class="literal">[r A1]</code> object at the top left <a id="id1461" class="indexterm"/>corner to the <code class="literal">[p process03]</code> object directly. But maybe this will be more readable if I keep the process chains separate. I often work this way with Max 6.</p><p>This is one of the multiple tricks I teach in my Max 6 course. And of course, I introduced the <code class="literal">[p]</code> object, that is the <code class="literal">[patcher]</code> abbreviation.</p><p>Let's check a couple of tips before we continue with some good examples involving Max 6 and Arduino.</p></div><div class="section" title="Encapsulation and subpatching"><div class="titlepage"><div><div><h4 class="title"><a id="ch12lvl4sec40"/>Encapsulation and subpatching</h4></div></div></div><p>When you <a id="id1462" class="indexterm"/>open <a id="id1463" class="indexterm"/>Max 6 and go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New Patcher</strong></span>, it <a id="id1464" class="indexterm"/>opens a blank patcher. The latter, if you recall, is the place where you put all the objects. There is another good feature named <span class="strong"><strong>subpatching</strong></span>
<a id="id1465" class="indexterm"/>. With this feature, you can create new patchers inside patchers, and embed patchers inside patchers as well.</p><p>A patcher contained inside another one is also named a subpatcher.</p><p>Let's see how it works with the patch named <code class="literal">ReadAllCutest.maxpat</code>.</p><div class="mediaobject"><img src="graphics/7584_12_005.jpg" alt="Encapsulation and subpatching"/></div><p>There are four new objects replacing the whole<a id="id1466" class="indexterm"/> structures <a id="id1467" class="indexterm"/>we designed before.</p><p>These objects are subpatchers. If you double-click on them in <span class="strong"><strong>patch lock mode</strong></span>
<a id="id1468" class="indexterm"/> or if you push the <span class="emphasis"><em>command</em></span> key (or <span class="emphasis"><em>Ctrl</em></span> for Windows), double-click on them in <span class="strong"><strong>patch edit mode</strong></span>
<a id="id1469" class="indexterm"/> and you'll open them. Let's see what is there inside them.</p><div class="mediaobject"><img src="graphics/7584_12_006.jpg" alt="Encapsulation and subpatching"/></div><p>The <code class="literal">[requester]</code> subpatcher<a id="id1470" class="indexterm"/> contains the same architecture that we <a id="id1471" class="indexterm"/>designed before, but you can see the brown <span class="strong"><strong>1</strong></span> and <span class="strong"><strong>2</strong></span> <a id="id1472" class="indexterm"/>objects and another blue <span class="strong"><strong>1</strong></span> object. These are inlets and outlets. Indeed, they are required if you want your subpatcher to be able to communicate with the patcher that contains it. Of course, we could use the <code class="literal">[send]</code> and <code class="literal">[receive]</code> objects for this purpose too. We are going to see that in the following pages.</p><p>The position of these inlets and outlets in your subpatcher matters. Indeed, if you move the <span class="strong"><strong>1</strong></span> object to the right of the <span class="strong"><strong>2</strong></span> object, the numbers get swapped! And the different inlets in the upper patch get swapped too. You have to be careful about that. But again, you can organize them exactly as you want and need.</p><p>Check the next screenshot:</p><div class="mediaobject"><img src="graphics/7584_12_006b.jpg" alt="Encapsulation and subpatching"/></div><p>And now, check the <a id="id1473" class="indexterm"/>root patcher containing this subpatcher. It <a id="id1474" class="indexterm"/>automatically inverts the inlets, keeping things relevant.</p><div class="mediaobject"><img src="graphics/7584_12_006c.jpg" alt="Encapsulation and subpatching"/></div><p>Let's now <a id="id1475" class="indexterm"/>have a<a id="id1476" class="indexterm"/> look at the other <a id="id1477" class="indexterm"/>subpatchers:</p><div class="mediaobject"><img src="graphics/7584_12_007.jpg" alt="Encapsulation and subpatching"/><div class="caption"><p>The [p portHandler] subpatcher</p></div></div><div class="mediaobject"><img src="graphics/7584_12_008.jpg" alt="Encapsulation and subpatching"/><div class="caption"><p>The [p dataHandler] subpatcher</p></div></div><div class="mediaobject"><img src="graphics/7584_12_009.jpg" alt="Encapsulation and subpatching"/><div class="caption"><p>The [p dataDispatcher] subpatcher</p></div></div><p>In the last figure, we <a id="id1478" class="indexterm"/>can see only one inlet and no outlets. Indeed, we <a id="id1479" class="indexterm"/>just encapsulated the global data dispatcher system inside the subpatcher. And this latter generates its data buses with <code class="literal">[send]</code> objects. This is an example where we don't need and even don't want to use outlets. Using outlets would be messy because we would have to link each element requesting this or that value from Arduino with a lot of cords.</p><p>In order to create a subpatcher<a id="id1480" class="indexterm"/>, you only have to type <code class="literal">n</code> to create a new object, and type <code class="literal">p</code>, a space, and the name of your subpatcher.</p><p>While I designed these examples, I used something that works faster than creating a subpatcher, copying and pasting the structure on the inside, removing the structure from the outside, and adding inlets and outlets.</p><p>This feature is <a id="id1481" class="indexterm"/>named <a id="id1482" class="indexterm"/>encapsulate and is part of the <span class="strong"><strong>Edit</strong></span> menu of Max 6.</p><p>You have to select the part of the patch you want to encapsulate inside a subpatcher, then click on <span class="strong"><strong>Encapsulate</strong></span>, and voilà! You have just created a subpatcher including your structures that are connected to inlets and outlets in the correct order.</p><div class="mediaobject"><img src="graphics/7584_12_010.jpg" alt="Encapsulation and subpatching"/><div class="caption"><p>Encapsulate and de-encapsulate features</p></div></div><p>You can also de-encapsulate a subpatcher. It would follow the opposite process of removing the subpatcher and popping out the whole structure that was inside directly outside.</p><p>Subpatching helps to keep things well organized and readable.</p><p>We can imagine that we have to design a whole patch with a lot of wizardry and tricks inside it. This one is a processing unit, and as soon as we know what it does, after having finished it, <span class="emphasis"><em>we don't want to know how it does it</em></span> but only <span class="emphasis"><em>use it</em></span>.</p><p>This provides a nice abstraction level by keeping some processing units closed inside boxes and not messing the main patch.</p><p>You can copy and paste the subpatchers. This is a powerful way to quickly duplicate process units if you need to. But each subpatcher is totally independent of the others. This means that if you need to modify one because you want to update it, you'd have to do that individually in each subpatcher of your patch.</p><p>This can be really hard.</p><p>Let me introduce you to the last pure Max 6 concept now named abstractions<a id="id1483" class="indexterm"/> before I go further with Arduino.</p></div><div class="section" title="Abstractions and reusability"><div class="titlepage"><div><div><h4 class="title"><a id="ch12lvl4sec41"/>Abstractions and reusability</h4></div></div></div><p>Any patch created and <a id="id1484" class="indexterm"/>saved can be used as a new object<a id="id1485" class="indexterm"/> in another patch. We can do this by creating a new object by typing <code class="literal">n</code> in a patcher; then we just have to type the name of our previously created and saved patch.</p><p>A patch used in this way is called an <span class="strong"><strong>abstraction</strong></span>.</p><p>In order to call a patch as an abstraction in a patcher, the patch has to be in the Max 6 <span class="emphasis"><em>path</em></span> in order to be found by it. You can check the path known by Max 6 by going to <span class="strong"><strong>Options</strong></span> | <span class="strong"><strong>File Preferences</strong></span>. Usually, if you put the main patch in a folder and the other patches you want to use as abstractions in that same folder, Max 6 finds them.</p><p>The concept of abstraction in Max 6 itself is very powerful because it provides <span class="strong"><strong>reusability</strong></span>.</p><p>Indeed, imagine you need and have a lot of small (or big) patch structures that you are using every day, every time, and in almost every project. You can put them into a specific folder on your disk included in your Max 6 path and then you can call (we say <span class="emphasis"><em>instantiate</em></span>) them in every patch you are designing.</p><p>Since each patch using it has only a reference to the one patch that was instantiated itself, you just need to improve your abstraction; each time you load a patch using it, the patch will have up-to-date abstractions loaded inside it.</p><p>It is really easy to maintain all through the development months or years.</p><p>Of course, if you totally change the abstraction to fit with a dedicated project/patch, you'll have some problems using it with other patches. You have to be careful to maintain even short documentation of your abstractions.</p><p>Let's now continue by describing some good examples with Arduino.</p></div></div></div></div>
<div class="section" title="Creating a sound-level meter with LEDs"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec85"/>Creating a sound-level meter with LEDs</h1></div></div></div><p>This small <a id="id1486" class="indexterm"/>project is a typical example of a Max 6/Arduino <a id="id1487" class="indexterm"/>hardware and software collaboration.</p><p>Max can easily listen for sounds and convert them from the analog to the digital domain.</p><p>We are going to build a small sound level visualizer using Arduino, some LEDs, and Max 6.</p><div class="section" title="The circuit"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec187"/>The circuit</h2></div></div></div><p>We are going to use the same <a id="id1488" class="indexterm"/>circuit we designed in <a class="link" href="ch08.html" title="Chapter 8. Designing Visual Output Feedback">Chapter 8</a>, <span class="emphasis"><em>Designing Visual Output Feedbacks</em></span>, while we multiplexed LEDs with a daisy chain of shift registers of the type 595.</p><p>The following figure shows the circuit:</p><div class="mediaobject"><img src="graphics/7584_12_011.jpg" alt="The circuit"/><div class="caption"><p>Our double series of eight LEDs</p></div></div><div class="mediaobject"><img src="graphics/7584_12_012.jpg" alt="The circuit"/><div class="caption"><p>Our double series of eight LEDs</p></div></div><p>The basic <a id="id1489" class="indexterm"/>idea is to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use each series of eight LEDs for each sound channel (left and right)</li><li class="listitem" style="list-style-type: disc">Display the sound level all along the LED series</li></ul></div><p>For each channel, the greater the number of LEDs switched on, the higher the sound level.</p><p>Let's now check how we can handle this in Max 6 first.</p></div><div class="section" title="The Max 6 patch for calculating sound levels"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec188"/>The Max 6 patch for calculating sound levels</h2></div></div></div><p>Have a look<a id="id1490" class="indexterm"/> at <a id="id1491" class="indexterm"/>the following figure showing the<a id="id1492" class="indexterm"/> <code class="literal">SoundLevelMeters</code> patch:</p><div class="mediaobject"><img src="graphics/7584_12_013.jpg" alt="The Max 6 patch for calculating sound levels"/><div class="caption"><p>Generating sounds and measuring sound levels</p></div></div><p>We are using the MSP part of the Max 6 framework here that is related to sound signals. We have two sources (named <code class="literal">source 1</code> and <code class="literal">source 2</code>) in the patch. Each one generates two signals. I connected each one to one of the <code class="literal">[selector~ ]</code> objects.</p><p>Those latter<a id="id1493" class="indexterm"/> are switches for signals. The source<a id="id1494" class="indexterm"/> selector at the top left provides a way to switch between <code class="literal">source 1</code> and <code class="literal">source 2</code>.</p><p>I won't describe the cheap wizardry of sound sources; it would involve having a knowledge of synthesis and that would be out of the scope of this topic.</p><p>Then, we have a connection between each <code class="literal">[selector~ ]</code> output and a small symbol like a speaker. This is related to the sound output of your audio interface.</p><p>I also used the <code class="literal">[meter~]</code> object to display the level of each channel.</p><p>At last, I added a <code class="literal">[flonum]</code> object to display the current value of the level each time.</p><p>These are the numbers we are going to send to Arduino.</p><p>Let's add the serial communication building blocks we already described.</p><div class="mediaobject"><img src="graphics/7584_12_014.jpg" alt="The Max 6 patch for calculating sound levels"/><div class="caption"><p>Sending data to Arduino</p></div></div><p>We have <a id="id1495" class="indexterm"/>our serial communication setup ready.</p><p>We also <a id="id1496" class="indexterm"/>have the <code class="literal">[zmap 0. 1. 0 255]</code> objects. These take a value intended to be between <code class="literal">0. 1</code>, as was set up in the arguments, and scale it to the range <code class="literal">0 255</code>. This provides a byte of data for each channel.</p><p>We are using two data buses to send a value from each channel to a<a id="id1497" class="indexterm"/> <code class="literal">[pak]</code> object. The latter collects the incoming messages and creates a list with them. The difference between <code class="literal">[pack]</code> <a id="id1498" class="indexterm"/>and <code class="literal">[pak]</code> is that <code class="literal">[pak]</code> sends data as soon as it receives a message in one of its inputs, not only when it receives a message of its left input, as with <code class="literal">[pack]</code>.</p><p>Thus, we have lists of messages that are popped out from the computer to Arduino as soon as the level values change.</p></div><div class="section" title="The firmware for reading bytes"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec189"/>The firmware for reading bytes</h2></div></div></div><p>Let's see how to <a id="id1499" class="indexterm"/>handle this in Arduino:</p><div class="informalexample"><pre class="programlisting">#include &lt;ShiftOutX.h&gt;
#include &lt;ShiftPinNo.h&gt;

int CLOCK_595 = 4;    // first 595 clock pin connecting to pin 4
int LATCH_595 = 3;    // first 595 latch pin connecting to pin 3
int DATA_595 = 2;     // first 595 serial data input pin connecting to pin 2

int SR_Number = 2;    // number of shift registers in the chain

// instantiate and enabling the shiftOutX library with our circuit parameters
shiftOutX regGroupOne(LATCH_595, DATA_595, CLOCK_595, MSBFIRST, SR_Number);

// random groove machine variables
int counter = 0;
byte LeftChannel = B00000000 ;  // store left channel Leds infos
byte RightChannel = B00000000 ; // store right channel Leds infos

void setup() {
  // NO MORE setup for each digital pin of the Arduino
  // EVERYTHING is made by the library :-)
}

void loop(){ 

  if (Serial.available() &gt; 0) {
    LeftChannel = (byte)Serial.parseInt();
    RightChannel = (byte)Serial.parseInt();


    unsigned short int data; // declaring the data container as a very local variable
    data = ( LeftChannel &lt;&lt; 8 ) | RightChannel; // aggregating the 2 read bytes
    shiftOut_16(DATA_595, CLOCK_595, MSBFIRST, data);  // pushing the whole data to SRs

    // make a short pause before changing LEDs states
    delay(2);
  }
}</pre></div><p>This is the same firmware as the one in <a class="link" href="ch08.html" title="Chapter 8. Designing Visual Output Feedback">Chapter 8</a>, <span class="emphasis"><em>Designing Visual Output Feedback</em></span>, except here we are pitreading real values and not generating random ones.</p><p>We are <a id="id1500" class="indexterm"/>doing that with <code class="literal">Serial.parseInt()</code> in the <code class="literal">Serial.available()</code> test.</p><p>This means that as soon as the data is in the Arduino serial buffer, we'll read it. Actually, we are reading two values and storing them, after a byte conversion, in <code class="literal">LeftChannel</code> and <code class="literal">RightChannel</code>.</p><p>We then process the data to the shift register to light the LEDs according to the value sent by the Max 6 patch.</p><p>Let's take another example of playing with sound files and a distance sensor.</p></div></div>
<div class="section" title="Pitch shift effect controlled by hand"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec86"/>Pitch shift effect controlled by hand</h1></div></div></div><p>
<span class="strong"><strong>Pitch shifting</strong></span>
<a id="id1501" class="indexterm"/> is a well-known effect in all fields related to sound processing. It changes the pitch of an incoming sound. Here we are going to implement a very cheap pitch shifter with Max 6, but we will focus on how to control this sound effect. We will control it by moving our hand over a distance sensor.</p><p>We are going to use the same circuit as the one in <a class="link" href="ch06.html" title="Chapter 6. Sensing the World – Feeling with Analog Inputs">Chapter 6</a>, <span class="emphasis"><em>Sense the World – Feeling with Analog Inputs</em></span>.</p><div class="section" title="The circuit with the sensor and the firmware"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec190"/>The circuit with the sensor and the firmware</h2></div></div></div><p>The following circuit shows the <a id="id1502" class="indexterm"/>Arduino board connected to a sensor:</p><div class="mediaobject"><img src="graphics/7584_12_015.jpg" alt="The circuit with the sensor and the firmware"/><div class="caption"><p>The Sharp distance sensor connected to Arduino</p></div></div><p>The firmware is <a id="id1503" class="indexterm"/>almost the same too. I removed the part about the distance calculation because, indeed, we don't care about the distance itself.</p><p>The ADC of Arduino provides a resolution of 10 bits, which will give numbers from 0 to 1023. We are going to use this value to calibrate our system.</p><p>The following code is the firmware. You can find it in the <code class="literal">Chapter12/PitchShift</code> folder:</p><div class="informalexample"><pre class="programlisting">int sensorPin = 0;           // pin number where the SHARP GP2Y0A02YK is connected
int sensorValue = 0 ;        // storing the value measured from 0 to 1023

void setup() {
  Serial.begin(9600);
}

void loop(){
  sensorValue = analogRead(sensorPin); // read/store the value from sensor
  Serial.println(sensorValue);
 
  delay(20);    
}</pre></div><p>As soon as<a id="id1504" class="indexterm"/> Arduino runs this firmware, it sends values to the serial port.</p></div><div class="section" title="The patch for altering the sound and parsing Arduino messages"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec191"/>The patch for altering the sound and parsing Arduino messages</h2></div></div></div><p>I cannot describe the <a id="id1505" class="indexterm"/>whole <a id="id1506" class="indexterm"/>pitch shifter itself. By the way, you can open the related subpatch to see how it has been designed. Everything is open.</p><div class="mediaobject"><img src="graphics/7584_12_017.jpg" alt="The patch for altering the sound and parsing Arduino messages"/><div class="caption"><p>The pitch shifter controlled by your hand over the distance sensor</p></div></div><p>As we <a id="id1507" class="indexterm"/>described before, we have to choose the right serial port and then bang the <code class="literal">[serial]</code> object in order to make it pop out the values in its buffer.</p><p>Here, we are <a id="id1508" class="indexterm"/>using the <code class="literal">[scale]</code> object<a id="id1509" class="indexterm"/>. It is similar to<a id="id1510" class="indexterm"/> <code class="literal">[zmap]</code>, which we already used, because it maps a range to another one but it can also work with inverted range and doesn't clip values.</p><p>Here, I'm mapping values being received from the ADC of Arduino from 0 to 1023 to something fitting our need from 12.0 to 0.5.</p><p>If we place our hand close to the sensor, the distance is small, and if we move our hand further away, the distance changes and the effect is modulated.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec87"/>Summary</h1></div></div></div><p>This chapter taught us how to deal with Arduino using Max 6.</p><p>We learnt a bit more about some usual techniques in Max 6, and we practiced some concepts previously learnt in this book. Obviously, there is more to learn in Max 6, and I'd like to give you some good pointers for better learning.</p><p>Firstly, I'd suggest you read <span class="emphasis"><em>all</em></span> the tutorials, beginning with those about Max, then about MSP, and then about digital sound, and at last about Jitter if you are interested in visuals and OpenGL. That sounds obvious but I still have two or three persons a day asking me where to begin Max 6 from. The answer is: tutorials.</p><p>Then, I'd suggest you design a small system. Less is definitely more. A small system provides easy ways to maintain, modify, and support. Using comments is also a nice way to quickly remember what you tried to do in this or that part.</p><p>Lastly, patching a bit everyday is the real key to success. It takes time, but don't we want to become masters?</p></div></body></html>