["```cpp\n//Not real code, just an example! \nvoid InputManager:Update(void) \n{ \nint controllerCount = GetControllerCount(); \nif(controllerCount > m_currentControllerCount) \n{ \n  m_currentControllerCount = controllerCount; \n  Object* pObj = ObjectManager::CreatePlayer(controllerCount); \n  GameLogic::SetDifficulty(controllerCount); \n  //player position is the camera location for the screen \n  Graphics::SetScreenCount(controllerCount, pObj->pos); \n\n  } \n} \n\n```", "```cpp\nvoid RepositionComponent::Update(float /*dt*/) \n{ \n  M5Vec2 windowSize = M5App::GetResolution(); \n  m_pObj->pos.x = windowSize.x * m_xScale; \n  m_pObj->pos.y = windowSize.y * m_yScale; \n} \n\n```", "```cpp\nclass Observer \n{ \npublic: \n  virtual ~Observer(void) {} \n  virtual void Update(float currentHealth, float maxHealth) = 0; \n}; \n\n```", "```cpp\nclass Subject \n{ \npublic: \n  virtual ~Subject(void) {} \n  virtual void RegisterObserver(Observer* pToAdd)      = 0; \n  virtual void UnregisterObserver(Observer* pToRemove) = 0; \n  virtual void Notify(void)                            = 0; \n}; \n\n```", "```cpp\nclass Player: public Subject \n{ \npublic: \n  Player(float maxHealth); \n  void AdjustHealth(float health); \n  virtual void RegisterObserver(Observer* pToAdd); \n  virtual void UnregisterObserver(Observer* pToRemove); \n  virtual void Notify(void); \nprivate: \n  typedef std::vector<Observer*> ObserverVec; \n\n  float       m_maxHealth; \n  float       m_health; \n  ObserverVec m_observers; \n}; \n\n```", "```cpp\nPlayer::Player(float maxHealh): \n  m_maxHealth(maxHealth), \n  m_health(maxHealth) \n{ \n} \n\n```", "```cpp\nvoid Player::RegisterObserver(Observer* pToAdd) \n{ \n  ObserverVec::iterator itor; \n  itor = std::find(m_observers.begin(), \n                    m_observers.end(), \n                    pToAdd); \n\n  assert(itor == m_observers.end()); \n  m_observers.push_back(pToAdd); \n} \n\n```", "```cpp\nvoid Player::UnregisterObserver(Observer* pToRemove) \n{ \n  ObserverVec::iterator itor; \n  itor = std::find(m_observers.begin(), \n                    m_observers.end(), \n                    pToRemove); \n\n  if (itor != m_observers.end()) \n  { \n    std::swap(*itor, *(--m_observers.end())); \n    m_observers.pop_back(); \n  } \n} \n\n```", "```cpp\nvoid Player::Notify(void) \n{ \n  size_t size = m_observers.size(); \n  for (size_t i = 0; i < size; ++i) \n    m_observers[i]->Update(m_health, m_maxHealth); \n} \n\n```", "```cpp\nvoid Player::AdjustHealth(float adjustHealth) \n{ \n  m_health += adjustHealth; \n  Notify(); \n} \n\n```", "```cpp\n//Used to quit the game when the \"game\", when the player's health \n//is less than or equal to 0 \nclass StageLogic : public Observer \n{ \npublic: \n  StageLogic (Subject* pSubject); \n  bool IsQuitting(void) const; \n  ~StageLogic(void); \n  virtual void Update(float currentHealth, float maxHealth); \nprivate: \n  bool     m_isQuitting; \n  Subject* m_pSubject; \n}; \n\n//Used to Color the player health bar based on the how full it is \nclass PlayerHealthBar : public Observer \n{ \npublic: \n  PlayerHealthBar(Subject* pSubject); \n  ~PlayerHealthBar(void); \n  void Display(void) const; \n  virtual void Update(float currentHealth, float maxHealth); \nprivate: \n  float       m_percent; \n  std::string m_color; \n  Subject*    m_pSubject; \n}; \n\n//Used to Display the health of the player as a value \nclass PlayerDisplay : public Observer \n{ \npublic: \n  PlayerDisplay(Subject* pSubject); \n  ~PlayerDisplay(void); \n  void Display(void) const; \n  virtual void Update(float currentHealth, float maxHealth); \nprivate: \n  float    m_health; \n  Subject* m_pSubject; \n}; \n\n```", "```cpp\nPlayerDisplay::PlayerDisplay(Subject* pSubject): \n  m_health(0.0f), \n  m_pSubject (pSubject) \n{ \n  m_pSubject ->RegisterObserver(this); \n} \n\nPlayerDisplay::~PlayerDisplay(void) \n{ \n  m_pSubject ->UnregisterObserver(this); \n} \n\n```", "```cpp\nvoid PlayerHealthBar::Update(float currentHealth, float maxHealth) \n{ \n  m_percent = (currentHealth / maxHealth) * 100.f; \n\n  if (m_percent >= 75.0f) \n    m_color = \"Green\"; \n  else if (m_percent < 75.0f && m_percent > 35.0f) \n    m_color = \"Yellow\"; \n else \n    m_color = \"Red\"; \n\n} \n\n```", "```cpp\nint main(void) \n{ \n  //Our value to decrement by \n  const float DECREMENT       = -1.0f; \n  const float STARTING_HEALTH =  5.0f; \n\n  //creating our objects \n  Player          player(STARTING_HEALTH); \n  PlayerDisplay   display(&player); \n  PlayerHealthBar bar(&player); \n  StageLogic      stageLogic(&player); \n\n  //Set the initial values to print \n  player.Notify(); \n\n  //loop until player is dead \n  while (!stageLogic.IsQuitting()) \n  { \n    display.Display(); \n    bar.Display(); \n    player.AdjustHealth(DECREMENT); \n  } \n\n  return 0; \n} \n\n```", "```cpp\n  //Alternate code without Observer pattern \n   while (!stageLogic.IsQuitting()) \n  { \n     display.SetHeath(player.getHealth()); \n     display.Display(); \n\n     bar.setHealth(player.getHealth(), player.getMaxHealth()); \n     bar.Display(); \n\n     player.AdjustHealth(DECREMENT); \n\n     stageLogic.SetQuit(player.GetHealth() <= 0); \n  } \n\n```", "```cpp\n//Now the update method takes a pointer to the subject \nclass Observer \n{ \npublic: \n  virtual ~Observer(void) {} \n  //Pull version of the Observer Pattern \n  virtual void Update(Subject* pSubject) = 0; \n}; \n\n//Example of an Observer Update method that pulls data \nvoid PlayerHealthBar::Update(Subject* pSubject) \n{ \n  //Make sure we have a Player \n  Player* pPlayer = dynamic_cast<Player*>(pSubject); \n  if(pPlayer == 0) \n    return; \n\n  m_percent = (pPlayer->GetHealth() / pPlayer->GetMaxHealth()); \n   m_percent *= 100.f; \n\n  if (m_percent >= 75.0f) \n    m_color = \"Green\"; \n  else if (m_percent < 75.0f && m_percent > 35.0f) \n    m_color = \"Yellow\"; \n else \n    m_color = \"Red\"; \n} \n\n```"]