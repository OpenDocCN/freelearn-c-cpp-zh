- en: Chapter 1. It's Alive! It's Alive! – Setup and First Program
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。它活着！它活着！——设置和第一个程序
- en: The proud feeling of building something is a powerful one. Coupled with the
    thrill of exploration, it hardly makes it difficult to narrow down why most of
    our fellow game developers do what they do. Although creation is a major force
    in this process, failure governs it, much like any other subject. Sooner or later,
    all of us will be placed in a situation where a brick wall not only derails the
    development of a given project, but maybe even kills the motivation to work on
    it. Having a good resource to fall back on is crucial during those times, especially
    for new developers who are just now getting their hands dirty, and that's where
    we come in. Our goal is to pass on the experience in the most hands-on approach
    by developing real projects during the course of this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 建造某物的自豪感是一种强大的感觉。结合探索的刺激，几乎很难缩小我们大多数游戏开发者为何这样做的原因。虽然创造是这个过程的主要力量，但失败支配着它，就像任何其他学科一样。迟早，我们都会处于一个砖墙不仅阻碍了特定项目的开发，甚至可能扼杀工作动机的情况。在这些时候，有一个好的资源可以依靠是至关重要的，尤其是对于刚开始动手的新开发者来说，这就是我们介入的地方。我们的目标是通过对本书过程中开发真实项目来以最实际的方法传授经验。
- en: 'In this chapter, we''re going to be covering:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Setting up SFML on your machine and IDE
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的机器和IDE上设置SFML
- en: Flow of an average SFML application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均SFML应用程序的流程
- en: Opening and managing windows
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开和管理窗口
- en: Basics of rendering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染基础
- en: The purpose of this chapter is to ease you into the process of developing games
    using **Simple and Fast Multimedia Library** (**SFML**). Let's get started by
    first tackling the setup process!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是帮助您轻松地进入使用**简单快速多媒体库**（**SFML**）开发游戏的过程。让我们先从设置过程开始！
- en: What is SFML?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是SFML？
- en: Before we start throwing terms and code your way, it's only fair we talk a little
    bit about the choice library for this book. As its title clearly states, SFML
    is a library, which speeds up and eases the process of developing applications
    that rely on extensive use of media content, such as video, text, still images,
    audio, and animation for interactivity, and we will be focusing on a specific
    category of those applications, that is, video games. It provides an easy to use
    **application** **programming interface** (**API**), compiles and runs out of
    the box on Windows, Linux, and Mac OS X, and is supported by multiple languages,
    such as C, .NET, C++, Java, Ruby, Python, and Go, just to name a few. Unofficial
    ports for certain mobile devices do exist out there, however official releases
    for mobile platforms are still in the works. It's also open source, so one can
    always go and look at the source code if one is so inclined. In this book, we
    will be focusing solely on development for the *Windows* platform using *C++11*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向您抛出术语和代码之前，公平起见，我们应该稍微谈谈本书选择的库。正如其标题清楚地表明的那样，SFML是一个库，它加快并简化了开发依赖于大量使用媒体内容的应用程序的过程，例如视频、文本、静态图像、音频和动画以实现交互性，我们将专注于这些应用程序的特定类别，即视频游戏。它提供了一个易于使用的**应用程序****编程接口**（**API**），在Windows、Linux和Mac
    OS X上无需安装即可编译和运行，并支持多种语言，如C、.NET、C++、Java、Ruby、Python和Go等，仅举几例。虽然某些移动设备存在非官方的端口，但官方移动平台的发布仍在进行中。它也是开源的，所以如果有人愿意，总可以去查看源代码。在本书中，我们将专注于使用**C++11**在**Windows**平台上进行开发。
- en: 'For convenience, SFML is split into five modules, which are independent of
    one another and can be included on a need-to-use basis:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，SFML被分为五个模块，这些模块相互独立，可以根据需要使用：
- en: '**System**: A core module, which defines most basic data structures, provides
    access to threads, clocks, user data streams, and other essentials.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统**：一个核心模块，定义了大多数基本数据结构，提供对线程、时钟、用户数据流和其他基本功能的访问。'
- en: '**Window**: This module provides a means of creating and managing a window,
    gathering user input and events, as well as using SFML alongside OpenGL.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**窗口**：此模块提供创建和管理窗口、收集用户输入和事件以及与OpenGL一起使用SFML的方法。'
- en: '**Graphics**: Everything left to be desired graphically after fully utilizing
    the window module falls back on the graphics module. It deals with everything
    concerning two-dimensional rendering.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形**：在充分利用窗口模块后，所有剩余的图形需求都由图形模块处理。它处理所有与二维渲染相关的内容。'
- en: '**Audio**: Anything to do with playing music, sounds, audio streams, or recording
    audio is handled by this module.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频**：与播放音乐、声音、音频流或录音相关的一切都由这个模块处理。'
- en: '**Network**: The last but definitely not the least interesting module that
    covers sending data to other computers as well as working with a few networking
    protocols.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：最后一个但绝对是最有趣的模块，它涵盖了向其他计算机发送数据以及使用一些网络协议。'
- en: Each one of these modules is compiled in a separate library (.lib) with specific
    postfixes that signify whether the library is being linked *statically* or *dynamically*,
    as well as if it's being built in *debug* or *release* mode. Linking a library
    statically simply means that it gets included in the executable, as opposed to
    dynamic linking, where `.dll` files are required to be present in order for the
    application to run. The latter situation reduces the overall size of the application
    by relying on the library being present on the machine that runs it. It also means
    that the library can be upgraded without the need to alter the application, which
    can be useful when fixing bugs. Static linking, on the other hand, allows your
    code to be executed in environments that are more limited.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这样的模块都编译在一个单独的库（.lib）中，该库具有特定的后缀，表示库是**静态**链接还是**动态**链接，以及是否在**调试**或**发布**模式下构建。静态链接库意味着它被包含在可执行文件中，与动态链接相反，动态链接需要`.dll`文件存在于应用程序运行时。后一种情况通过依赖于运行它的机器上存在的库来减少应用程序的整体大小。这也意味着库可以升级而无需修改应用程序，这在修复错误时非常有用。另一方面，静态链接允许你的代码在更受限的环境中执行。
- en: It's also important to make sure that your application is being built in a mode
    that's suitable for the situation. Debug mode applications are bloated with additional
    information that is useful when you're hunting down flaws in your programs. This
    makes the application run considerably slower and shouldn't be used for any other
    purposes than testing. When building your project in release mode, tons of different
    optimizations are also turned on, which not only provides a smaller executable
    footprint, but also a much faster running speed. This should be the mode an application
    is compiled in, if it is to be released for any kind of use other than debugging.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的应用程序以适合情况的模式构建也很重要。调试模式的应用程序包含大量有用的额外信息，这些信息在查找程序中的缺陷时非常有用。这使得应用程序运行速度明显减慢，不应用于除测试以外的任何目的。当以发布模式构建你的项目时，也会开启大量的不同优化，这不仅提供了更小的可执行文件大小，还提供了更快的运行速度。如果应用程序要用于除调试以外的任何目的，则应该以这种模式编译。
- en: 'Each module is named according to the format `sfml-module[-s][-d].lib`. For
    example, the file name of a graphics library that is being linked statically and
    compiled in debug mode would look like this: `sfml-graphics-s-d.lib`. When linking
    dynamically or compiling in release mode, the postfixes need to be omitted. SFML
    also requires the `SFML_STATIC` macro to be defined when linking statically, which
    we will cover shortly when setting up our first project.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都按照格式`sfml-module[-s][-d].lib`命名。例如，一个静态链接并编译在调试模式下的图形库的文件名可能看起来像这样：`sfml-graphics-s-d.lib`。当动态链接或编译在发布模式下时，后缀需要被省略。SFML还要求在静态链接时定义`SFML_STATIC`宏，我们将在设置第一个项目时简要介绍。
- en: An important thing to keep in mind about the separate libraries is that they
    still have dependencies. Window, graphics, audio, and network libraries are dependent
    on the system library, which has to be linked to for any SFML application to compile
    and run. The graphics library is also dependent on the window library, so all
    three have to be linked to if an application does any drawing. The audio and networking
    libraries only depend on the system library.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关于单独的库，需要记住的一个重要事情是它们仍然有依赖关系。窗口、图形、音频和网络库依赖于系统库，任何SFML应用程序要编译和运行都必须链接到系统库。图形库也依赖于窗口库，所以如果应用程序进行任何绘图，所有三个库都必须链接。音频和网络库只依赖于系统库。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since version *2.2*, when linking SFML statically, its dependencies must also
    be linked to the project. These dependencies vary between major versions 2.2 and
    2.3, so we're going to stick with the newest version, that is, 2.3\. The graphics
    library requires `opengl32.lib`, `freetype.lib`, and `jpeg.lib` libraries. The
    window library depends on `opengl32.lib`, `winmm.lib`, and `gdi32.lib`. Linking
    to the system library only requires the `winmm.lib` library, while `sfml-network-s.lib`
    relies on `ws2_32.lib` in order to work. Lastly, the sound library depends on
    `openal32.lib`, `flac.lib`, `vorbisenc.lib`, `vorbisfile.lib`, `vorbis.lib`, and
    `ogg.lib`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 *2.2* 开始，当静态链接 SFML 时，其依赖项也必须链接到项目中。这些依赖项在 2.2 和 2.3 主要版本之间有所不同，因此我们将坚持使用最新版本，即
    2.3。图形库需要 `opengl32.lib`、`freetype.lib` 和 `jpeg.lib` 库。窗口库依赖于 `opengl32.lib`、`winmm.lib`
    和 `gdi32.lib`。仅链接到系统库只需要 `winmm.lib` 库，而 `sfml-network-s.lib` 需要依赖 `ws2_32.lib`
    才能工作。最后，声音库依赖于 `openal32.lib`、`flac.lib`、`vorbisenc.lib`、`vorbisfile.lib`、`vorbis.lib`
    和 `ogg.lib`。
- en: 'Each one of these five modules has a corresponding header that must be included
    to utilize its functionality. For example, including the graphics header would
    look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个模块中的每一个都有一个相应的头文件，必须包含以利用其功能。例如，包含图形头文件将看起来像这样：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It is also possible to avoid including the entire module header by specifying
    the actual header that is desired within a module:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定模块中所需的实际头文件，也可以避免包含整个模块头文件：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This gives you a chance to include only the parts that are absolutely necessary.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你有机会只包含绝对必要的部分。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's best practice to use forward slashes when including libraries. Different
    operating systems do not recognize paths that have a backslash in them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含库时使用正斜杠是一种最佳实践。不同的操作系统无法识别包含反斜杠的路径。
- en: SFML licensing
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFML 许可协议
- en: 'Whenever you''re utilizing a library of any sorts for your project, it''s important
    to know what you can and cannot use it for. SFML is licensed under the zlib/libpng
    license, which is far from being restrictive. It allows anyone to use SFML for
    any purposes, even commercial applications, as well as alter and re-distribute
    it, given that the credit for writing the original software is left unchanged
    and the product is marked as an altered source. Giving credit for using the original
    software isn''t required, but it would be appreciated. For more information, visit:
    [http://opensource.org/licenses/Zlib](http://opensource.org/licenses/Zlib).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你为项目使用何种类型的库，了解你可以用它做什么以及不能做什么都很重要。SFML 在 zlib/libpng 许可协议下授权，这远非限制性。它允许任何人出于任何目的使用
    SFML，包括商业应用，以及修改和重新分发它，前提是保留原始软件的作者信用不变，并且产品标记为修改过的源代码。对于使用原始软件的信用并不强制要求，但会表示感谢。更多信息，请访问：[http://opensource.org/licenses/Zlib](http://opensource.org/licenses/Zlib)。
- en: Resources and installation
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源和安装
- en: 'You can download the latest stable pre-built version of the library at: [http://www.sfml-dev.org/download.php](http://www.sfml-dev.org/download.php).
    It is also possible for you to get the latest Git revision and compile it yourself
    from here: [https://github.com/LaurentGomila/SFML](https://github.com/LaurentGomila/SFML).
    The former option is easier and recommended for beginners. You have to wait for
    major versions to be released, however they''re more stable. To build SFML yourself,
    you will need to use CMake, which is a tool used to generate solutions or g++
    Makefiles, depending on the software that will be used to compile it. The official
    SFML website provides tutorials on building it yourself at: [http://www.sfml-dev.org/tutorials](http://www.sfml-dev.org/tutorials).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在：[http://www.sfml-dev.org/download.php](http://www.sfml-dev.org/download.php)
    下载库的最新稳定预构建版本。你也可以从这里获取最新的 Git 修订版并自行编译：[https://github.com/LaurentGomila/SFML](https://github.com/LaurentGomila/SFML)。前一种选项更容易，也推荐给初学者。然而，你必须等待主要版本发布，尽管它们更稳定。要自行构建
    SFML，你需要使用 CMake，这是一个用于生成解决方案或 g++ Makefiles 的工具，具体取决于编译它的软件。官方 SFML 网站提供了关于如何自行构建的教程：[http://www.sfml-dev.org/tutorials](http://www.sfml-dev.org/tutorials)。
- en: After either obtaining the pre-built version of SFML or compiling it yourself,
    it's a good idea to move it somewhere more permanent, hopefully with a short path.
    It's not unusual to dedicate a directory somewhere on your local drive that will
    hold SFML and potentially other libraries, which can be linked to quickly and
    at all times. This becomes useful when dealing with several versions of the same
    library as well. For the rest of this book, we will assume the location of our
    SFML library and header directories to be at `C:\libs\SFML-2.3`, consequently
    being `C:\libs\SFML-2.3\lib` and `C:\libs\SFML-2.3\include`. These directories
    have to be set up correctly in your compiler of choice for the project to build.
    We will be using Microsoft Visual Studio 2013 throughout the course of this book,
    however instructions on setting up projects for Code::Blocks can be found in the
    tutorials section of the SFML website.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取到SFML的预构建版本或自己编译它之后，将其移动到一个更永久的位置是个好主意，希望路径尽可能短。在本地驱动器上为SFML和其他库分配一个目录以供快速链接和随时使用并不罕见。当处理同一库的多个版本时，这也很有用。在本书的其余部分，我们将假设我们的SFML库和头文件目录位于`C:\libs\SFML-2.3`，因此库目录为`C:\libs\SFML-2.3\lib`，头文件目录为`C:\libs\SFML-2.3\include`。这些目录必须在您选择的编译器中正确设置，以便项目可以构建。在本书的整个过程中，我们将使用Microsoft
    Visual Studio 2013，然而，有关为Code::Blocks设置项目的说明可以在SFML网站上的教程部分找到。
- en: Setting up a Microsoft Visual Studio project
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Microsoft Visual Studio项目
- en: 'Create a new solution in your IDE. It can be a Win32 application or a console
    application, which is not really relevant, although a nice console window is often
    useful for debug purposes. I always go with the Empty Project option to avoid
    any auto-generated code. After that''s done, let''s prepare our project to use
    SFML:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的IDE中创建一个新的解决方案。它可以是一个Win32应用程序或控制台应用程序，这实际上并不重要，尽管一个漂亮的控制台窗口通常对调试很有用。我总是选择空项目选项以避免任何自动生成的代码。完成这些后，让我们准备我们的项目以使用SFML：
- en: Navigate to the **VC++ Directories** underneath **Configuration Properties**
    by right clicking on our project and selecting **Properties**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击我们的项目并选择**属性**，导航到**配置属性**下的**VC++ 目录**。
- en: Only two fields are of any concern to us, the **Include Directories** and **Library
    Directories**. Make sure the paths to the SFML library and include directories
    are provided for both **Debug** and **Release** configurations.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们来说，只有两个字段是关注的重点，即**包含目录**和**库目录**。确保为**调试**和**发布**配置都提供了SFML库和包含目录的路径。
- en: When linking SFML *statically*, the **Preprocessor** section underneath **C/C++**
    is where you need to define the `SFML_STATIC` macro.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当静态链接SFML时，需要在**C/C++**下的**预处理器**部分定义`SFML_STATIC`宏。
- en: Next is the **Additional Library Directories** in **General** underneath **Linker**.
    Make sure that it also points to the SFML library directory in both debug and
    release configurations.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是**链接器**下的**通用**部分的**附加库目录**。确保它也指向SFML库目录，在调试和发布配置中都要如此。
- en: 'Lastly, we need to set up the project dependencies by editing the **Additional
    Dependencies** field in the **Input** section underneath **Linker**. It would
    look something like this for the debug configuration when using statically linked
    libraries: `sfml-graphics-s-d.lib; sfml-window-s-d.lib; sfml-system-s-d.lib; opengl32.lib;
    freetype.lib; jpeg.lib; winmm.lib; gdi32.lib;`'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要通过编辑**链接器**下的**输入**部分的**附加依赖项**字段来设置项目依赖项。当使用静态链接库时，调试配置看起来可能如下所示：`sfml-graphics-s-d.lib;
    sfml-window-s-d.lib; sfml-system-s-d.lib; opengl32.lib; freetype.lib; jpeg.lib;
    winmm.lib; gdi32.lib;`
- en: Remember that we need to include the system library because of library dependencies.
    Also note the use of `-s` and `-d` postfixes. Make sure both debug and release
    configurations are set up and that the release configuration omits the `-d` postfix.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，由于库依赖性，我们需要包含系统库。同时注意使用`-s`和`-d`后缀。确保调试和发布配置都已设置，并且发布配置省略了`-d`后缀。
- en: Opening a window
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开一个窗口
- en: 'As you probably know, drawing something on screen requires a window to be present.
    Luckily, SFML allows us to easily open and manage our very own window! Let''s
    start out as usual by adding a file to our project, named `Main.cpp`. This will
    be the entry point to our application. The bare bones of a basic application look
    like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，在屏幕上绘制东西需要一个窗口存在。幸运的是，SFML允许我们轻松打开和管理我们自己的窗口！让我们像往常一样，通过向我们的项目添加一个名为`Main.cpp`的文件开始。这将是我们的应用程序的入口点。一个基本应用程序的骨架如下所示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that we''ve already included the SFML graphics header. This will provide
    us with everything needed to open a window and draw to it, so without further
    ado, let''s take a look at the code that opens our window:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经包含了SFML图形头文件。这将为我们提供打开窗口和绘制所需的一切，所以无需多言，让我们看看打开我们窗口的代码：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: SFML uses the sf *namespace*, so we have to prefix its data types, enumerations,
    and static class members with an "`sf::`".
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: SFML使用sf *命名空间*，因此我们必须在它的数据类型、枚举和静态类成员前加上前缀"`sf::`"。
- en: 'The first thing we did here is declare and initialize our window instance of
    type `RenderWindow`. In this case, we used its constructor, however it is possible
    to leave it blank and utilize its `create` method later on by passing in the exact
    same arguments, of which it can take as little as two: an `sf::videoMode` and
    an `std::string` title for the window. The video mode''s constructor takes two
    arguments: the inner window width and height. There is a third optional argument
    that sets color depth in bits per pixel. It defaults to 32, which is more than
    enough for good rendering fitting our purposes, so let''s not lose sleep over
    that now.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们首先声明并初始化我们的`RenderWindow`类型的窗口实例。在这种情况下，我们使用了它的构造函数，然而也可以留空并在稍后通过传递完全相同的参数来利用它的`create`方法，这些参数中至少需要两个：一个`sf::videoMode`和一个用于窗口的`std::string`标题。视频模式的构造函数需要两个参数：内部窗口的宽度和高度。还有一个可选的参数用于设置每像素的位数，默认为32位，这对于良好的渲染已经足够，所以现在不必为此烦恼。
- en: After the instance of our window is created, we enter a while loop that utilizes
    one of our window methods to check if it's still open, `isOpen`. This effectively
    creates our game loop, which is a central piece of all of our code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的窗口实例创建之后，我们进入一个while循环，使用我们的窗口方法之一来检查它是否仍然打开，即`isOpen`。这实际上创建了我们游戏循环，这是我们代码的核心部分。
- en: 'Let''s take a look at a diagram of a typical game:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个典型游戏的示意图：
- en: '![Opening a window](img/B04284_01_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![打开窗口](img/B04284_01_01.jpg)'
- en: The purpose of a game loop is to check for events and input, update our game
    world between frames, which means moving the player, enemies, checking for changes,
    and so on, and finally draw everything on the screen. This process needs to be
    repeated many times a second until the window is closed. The amount of times varies
    from application to application, sometimes going as high as thousands of iterations
    per second. [Chapter 2](ch02.html "Chapter 2. Give It Some Structure – Building
    the Game Framework"), *Give It Some Structure - Building the Game Framework* will
    cover managing and capping the frame rate of our applications as well as making
    the game run at constant speeds.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环的目的是检查事件和输入，在帧之间更新我们的游戏世界，这意味着移动玩家、敌人、检查变化等，最后在屏幕上绘制一切。这个过程需要每秒重复多次，直到窗口关闭。次数因应用程序而异，有时每秒高达数千次迭代。[第二章](ch02.html
    "第二章. 给它一些结构 - 构建游戏框架")，“给它一些结构 - 构建游戏框架”将涵盖管理并限制应用程序的帧率以及使游戏以恒定速度运行。
- en: Most applications need to have a way to check if a window has been closed, resized,
    or moved. That's where event processing comes in. SFML provides an event class
    that we can use to store our event information. During each *iteration* of our
    game loop, we need to check for the events that took place by utilizing the `pollEvent`
    method of our window instance and process them. In this case, we're only interested
    in the event that gets dispatched when a mouse clicks on the close window button.
    We can check if the public member `type` of class `Event` matches the proper enumeration
    member, in this case it's `sf::Event::Closed`. If it does, we can call the `close`
    method of our window instance and our program will terminate.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都需要一种方法来检查窗口是否已关闭、调整大小或移动。这就是事件处理的作用。SFML提供了一个事件类，我们可以用它来存储我们的事件信息。在游戏循环的每次*迭代*中，我们需要通过使用窗口实例的`pollEvent`方法来检查发生的事件并处理它们。在这种情况下，我们只对当鼠标点击关闭窗口按钮时触发的事件感兴趣。我们可以检查类`Event`的公共成员`type`是否与适当的枚举成员匹配，在这种情况下是`sf::Event::Closed`。如果是，我们可以调用窗口实例的`close`方法，我们的程序将终止。
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Events must be processed in all SFML applications. Without the event loop polling
    events, the window will become unresponsive, since it not only provides the event
    information to the user, but also gives the window itself a way to handle its
    internal events as well, which is a necessity for it to react to being moved or
    resized.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有 SFML 应用程序中必须处理事件。如果没有事件循环轮询事件，窗口将变得无响应，因为它不仅向用户提供事件信息，而且还为窗口本身提供了一种处理其内部事件的方式，这对于它能够对移动或调整大小做出反应是必要的。
- en: 'After all of that is done, it''s necessary to clear the window from the previous
    iteration. Failing to do so would result in everything we draw on it stacking
    and creating a mess. Imagine the screen is a whiteboard and you want to draw something
    new on it after someone else already scribbled all over it. Instead of grabbing
    the eraser, however, we need to call the `clear` method of our window instance,
    which takes a `sf::Color` data type as an argument and defaults to the color black
    if an argument isn''t provided. The screen can be cleared to any of its enumerated
    colors that the `sf::Color` class provides as static members or we can pass an
    instance of `sf::Color`, which has a constructor that takes *unsigned integer*
    values for individual color channels: red, green, blue, and optionally alpha.
    The latter gives us a way to explicitly specify the color of our desired range,
    like so:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些之后，清除前一次迭代的窗口是必要的。如果不这样做，我们将在其上绘制的所有内容都会堆叠并造成混乱。想象一下屏幕是一块白板，你想要在别人在上面乱涂乱画之后在上面绘制新的东西。然而，我们不需要拿橡皮擦，而是需要调用我们的窗口实例的
    `clear` 方法，该方法接受一个 `sf::Color` 数据类型作为参数，如果没有提供参数，则默认为黑色。屏幕可以被清除为 `sf::Color` 类提供的任何枚举颜色，该类作为静态成员提供，或者我们可以传递一个
    `sf::Color` 实例，该实例的构造函数接受单个颜色通道的 *无符号整数* 值：红色、绿色、蓝色，以及可选的 alpha。后者为我们提供了一个明确指定所需颜色范围的方法，如下所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, we call the `window.display()` method to show everything that was drawn.
    This utilizes a technique known as double buffering, which is standard in games
    nowadays. Basically, anything that is drawn isn't drawn on the screen instantly,
    but instead to a hidden buffer which then gets copied to our window once `display`
    is called. Double buffering is used to prevent graphical artifacts, such as tearing,
    which occurs due to video card drivers pulling from the frame buffer while it's
    still being written to, resulting in a partially drawn image being displayed.
    Calling the `display` method is mandatory and cannot be avoided, otherwise the
    window will show up as a static square with no changes taking place.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `window.display()` 方法来显示所有绘制的内容。这利用了一种称为双缓冲的技术，这在当今的游戏中是标准的。基本上，任何绘制的内容都不会立即绘制到屏幕上，而是绘制到一个隐藏的缓冲区中，然后在调用
    `display` 后将缓冲区的内容复制到我们的窗口中。双缓冲用于防止图形伪影，如撕裂，这是由于显卡驱动程序在帧缓冲区仍在写入时从中提取导致的，结果是一个部分绘制的图像被显示出来。调用
    `display` 方法是强制性的，不能避免，否则窗口将显示为一个静态的正方形，没有任何变化发生。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember to include SFML library `.dll` files in the same directory as your
    executable relies, provided the application has been dynamically linked.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果应用程序是动态链接的，则必须在可执行文件依赖的同一目录中包含 SFML 库 `.dll` 文件。
- en: Upon compilation and execution of the code, we will find ourselves with a blank
    console window and a black *640x480 px* window sitting over it, fewer than 20
    lines of code, and an open window. Not very exciting, but it's still better than
    *E.T.* for *Atari 2600*. Let's draw something on the screen!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译和执行代码后，我们将发现自己有一个空白的控制台窗口和一个黑色的 *640x480 px* 窗口坐在它上面，少于 20 行代码，并且一个打开的窗口。这并不令人兴奋，但仍然比
    *Atari 2600* 上的 *E.T.* 要好。让我们在屏幕上画些东西吧！
- en: Basics of SFML drawing
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFML 绘图基础
- en: 'Much like in kindergarten, we will start with basic shapes and make our way
    up to more complex types. Let''s work on rendering a rectangle shape by first
    declaring it and setting it up:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就像幼儿园一样，我们将从基本形状开始，逐步过渡到更复杂的类型。让我们通过首先声明它并设置它来绘制一个矩形形状：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`sf::RectangleShape` is a derived class of `sf::Shape` that inherits from `sf::Drawable`,
    which is an abstract base class that all entities must inherit from and implement
    its virtual methods in order to be able to be drawn on screen. It also inherits
    from `sf::Transformable`, which provides all the necessary functionality in order
    to move, scale, and rotate an entity. This relationship allows our rectangle to
    be transformed, as well as rendered to the screen. In its constructor, we''ve
    introduced a new data type: `sf::Vector2f`. It''s essentially just a struct of
    two *floats*, x and y, that represent a point in a two-dimensional universe, not
    to be confused with the `std::vector`, which is a data container.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::RectangleShape` 是 `sf::Shape` 的一个派生类，它继承自 `sf::Drawable`，这是一个抽象基类，所有实体都必须继承并实现其虚拟方法才能在屏幕上绘制。它还继承自
    `sf::Transformable`，这提供了移动、缩放和旋转实体的所有必要功能。这种关系允许我们的矩形进行变换，并且可以在屏幕上渲染。在其构造函数中，我们引入了一个新的数据类型：`sf::Vector2f`。它本质上只是一个包含两个
    *float* 的结构，x 和 y，代表二维宇宙中的一个点，不要与 `std::vector` 混淆，后者是一个数据容器。'
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'SFML provides a few other vector types for integers and unsigned integers:
    `sf::Vector2i` and `sf::Vector2u`. The actual `sf::Vector2` class is templated,
    so any primitive data type can be used with it like so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SFML 为整数和无符号整数提供了一些其他向量类型：`sf::Vector2i` 和 `sf::Vector2u`。实际的 `sf::Vector2`
    类是模板化的，因此可以使用任何原始数据类型与之一起使用，如下所示：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The rectangle constructor takes a single argument of `sf::Vector2f` which represents
    the size of the rectangle in pixels and is optional. On the second line, we set
    the fill color of the rectangle by providing one of SFML''s predefined colors
    this time. Lastly, we set the position of our shape by calling the `setPosition`
    method and passing its position in pixels alongside the *x* and *y* axis, which
    in this case is the centre of our window. There is only one more thing missing
    until we can draw the rectangle:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形构造函数接受一个 `sf::Vector2f` 类型的单个参数，它表示矩形的像素大小，这是可选的。在第二行，我们通过提供 SFML 的预定义颜色之一来设置矩形的填充颜色。最后，我们通过调用
    `setPosition` 方法并传入其位置（以像素为单位）以及 *x* 和 *y* 轴来设置我们形状的位置，在这种情况下是窗口的中心。在我们能够绘制矩形之前，只剩下一件事要做：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This line goes right before we call `window.display();` and is responsible
    for bringing our shape to the screen. Let''s run our revised application and take
    a look at the result:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码就在我们调用 `window.display();` 之前，负责将我们的形状带到屏幕上。让我们运行我们的修改后的应用程序并查看结果：
- en: '![Basics of SFML drawing](img/B04284_01_02.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![SFML 绘图基础](img/B04284_01_02.jpg)'
- en: 'Now we have a red square drawn on the screen, but it''s not quite centered.
    This is because the default origin of any `sf::Transformable`, which is just a
    2D point that represents the global position of the object, is at the local coordinates
    *(0,0)*, which is the top left corner. In this case, it means that the top left
    corner of this rectangle is set to the position of the screen centre. That can
    easily be resolved by calling the `setOrigin` method and passing in the desired
    local coordinates of our shape that will represent the new origin, which we want
    to be right in the middle:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们屏幕上画了一个红色方块，但它并不完全居中。这是因为任何 `sf::Transformable` 的默认原点，它只是一个代表对象全局位置的二维点，位于局部坐标
    *(0,0)*，即左上角。在这种情况下，这意味着这个矩形的左上角被设置为屏幕中心的位置。这可以通过调用 `setOrigin` 方法并传入我们形状的所需局部坐标来轻松解决，我们希望新的原点正好在中间：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the size of a shape is unknown for whatever reason, the rectangle class
    provides a nice method `getSize`, which returns a *float vector* containing the
    size:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因不知道形状的大小，矩形类提供了一个很好的方法 `getSize`，它返回一个包含大小的 *float 向量*：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now our shape is sitting happily in the very middle of the black screen. The
    entire segment of code that makes this possible looks a little something like
    this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的形状正快乐地坐在黑色屏幕的正中间。使这一切成为可能的整个代码段看起来有点像这样：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Drawing images in SFML
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 SFML 中绘制图像
- en: 'In order to draw an image on screen, we need to become familiar with two classes:
    `sf::Texture` and `sf::Sprite`. A texture is essentially just an image that lives
    on the graphics card for the purpose of making it fast to draw. Any given picture
    on your hard drive can be turned into a texture by loading it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在屏幕上绘制图像，我们需要熟悉两个类：`sf::Texture` 和 `sf::Sprite`。纹理本质上只是一个图像，它位于图形卡上，目的是使其绘制更快。任何硬盘上的图片都可以通过加载它来转换成纹理：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `loadFromFile` method returns a Boolean value, which serves as a simple
    way of handling loading errors, such as the file not being found. If you have
    a console window open along with your SFML window, you will notice some information
    being printed out in case the texture loading did fail:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadFromFile` 方法返回一个布尔值，这提供了一种简单的方式来处理加载错误，例如文件未找到。如果你同时打开了控制台窗口和 SFML 窗口，你将注意到在纹理加载失败的情况下会打印出一些信息：'
- en: '**Failed to load image "filename.png". Reason : Unable to open file**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**无法加载图像 "filename.png"。原因：无法打开文件**'
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Unless a full path is specified in the `loadFromFile` method, it will be interpreted
    as relative to the working directory. It's important to note that while the working
    directory is usually the same as the executable's when launching it by itself,
    compiling and running your application in an IDE (Microsoft Visual Studio in our
    case) will often set it to the project directory instead of the debug or release
    folders. Make sure to put the resources you're trying to load in the same directory
    where your `.vcxproj` project file is located if you've provided a relative path.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `loadFromFile` 方法中未指定完整路径，它将被解释为相对于工作目录。重要的是要注意，虽然当单独启动时，工作目录通常与可执行文件相同，但在
    IDE（在我们的例子中是 Microsoft Visual Studio）中编译和运行应用程序时，它通常设置为项目目录而不是调试或发布文件夹。如果你提供了相对路径，请确保将你要加载的资源放在与你的
    `.vcxproj` 项目文件相同的目录中。
- en: It's also possible to load your textures from memory, custom input streams,
    or `sf::Image` utility classes, which help store and manipulate image data as
    raw pixels, which will be covered more broadly in later chapters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以从内存、自定义输入流或 `sf::Image` 工具类中加载你的纹理，这些工具类帮助存储和操作图像数据作为原始像素，这将在后面的章节中更广泛地介绍。
- en: What is a sprite?
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是精灵？
- en: 'A sprite, much like the `sf::Shape` derivatives we''ve worked with so far,
    is a `sf::Drawable` object, which in this case represents a `sf::Texture` and
    also supports a list of transformations, both physical and graphical. Think of
    it as a simple rectangle with a texture applied to it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵，就像我们迄今为止所使用的 `sf::Shape` 派生类一样，是一个 `sf::Drawable` 对象，在这种情况下代表一个 `sf::Texture`，并且支持一系列变换，包括物理变换和图形变换。把它想象成一个简单应用了纹理的矩形：
- en: '![What is a sprite?](img/B04284_01_03.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![什么是精灵？](img/B04284_01_03.jpg)'
- en: '`sf::Sprite` provides the means of rendering a texture, or a part of it, on
    screen, as well as means of transforming it, which makes the sprite dependent
    on the use of textures. Since `sf::Texture` isn''t a lightweight object, `sf::Sprite`
    comes in for performance reasons to use the pixel data of a texture it''s bound
    to, which means that as long as a sprite is using the texture it''s bound to,
    the texture has to be alive in memory and can only be de-allocated once it''s
    no longer being used. After we have our texture set up, it''s really easy to set
    up the sprite and draw it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`sf::Sprite` 提供了在屏幕上渲染纹理或其一部分的手段，以及变换它的手段，这使得精灵依赖于纹理的使用。由于 `sf::Texture` 不是一个轻量级对象，`sf::Sprite`
    出于性能原因使用它所绑定纹理的像素数据，这意味着只要精灵在使用它所绑定的纹理，该纹理就必须在内存中保持活跃，并且只能在不再使用时才能被释放。在我们设置好纹理之后，设置精灵并绘制它就变得非常简单：'
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It''s optional to pass the texture by reference to the sprite constructor.
    The texture it''s bound to can be changed at any time by using the `setTexture`
    method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将纹理通过引用传递给精灵构造函数是可选的。可以通过使用 `setTexture` 方法在任意时刻更改它所绑定的纹理：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since `sf::Sprite`, just like `sf::Shape`, inherits from `sf::Transformable`,
    we have access to the same methods of manipulating and obtaining origin, position,
    scale, and rotation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `sf::Sprite`，就像 `sf::Shape` 一样，继承自 `sf::Transformable`，我们可以访问相同的方法来操作和获取原点、位置、缩放和旋转。
- en: 'It''s time to apply all the knowledge we''ve gained so far and write a basic
    application that utilizes it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候应用我们迄今为止所获得的所有知识，并编写一个利用这些知识的基本应用程序了：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The code above will produce a sprite bouncing around the window, reversing
    in direction every time it hits the window boundaries. Error checking for loading
    the texture is omitted in this case in order to keep the code shorter. The two
    `if` statements after the event handling portion in the main loop are responsible
    for checking the current position of our sprite and updating the direction of
    the increment value represented by a plus or minus sign, since you can only go
    towards the positive or negative end on a single axis. Remember that the origin
    of a shape by default is its top-left corner, as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生一个在窗口周围弹跳的精灵，每次撞击窗口边界时都会改变方向。为了使代码更短，省略了加载纹理的错误检查。在主循环的事件处理部分之后的两条`if`语句负责检查精灵的当前位置并更新表示正负号的增量值的方向，因为你可以沿着单轴的正负端移动。记住，形状的默认原点是左上角，如这里所示：
- en: '![What is a sprite?](img/B04284_01_04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![什么是精灵？](img/B04284_01_04.jpg)'
- en: Because of this, we must either compensate for the entire width and height of
    a shape when checking if it's out-of-bounds on the bottom or the right side, or
    make sure its origin is in the middle. In this case, we do the latter and either
    add or subtract half of the texture's size from the mushroom's position to check
    if it is still within our desired space. If it's not, simply invert the sign of
    the increment float vector on the axis that is outside the screen and voila! We
    have bouncing!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，在检查形状是否超出底部或右侧边界时，我们必须补偿形状的整个宽度和高度，或者确保其原点位于中间。在这种情况下，我们选择后者，并从蘑菇的位置添加或减去纹理大小的一半来检查它是否仍然在我们希望的空间内。如果不是，只需将轴上超出屏幕的增量浮点向量的符号取反，voila！我们就有了反弹效果！
- en: '![What is a sprite?](img/B04284_01_05.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![什么是精灵？](img/B04284_01_05.jpg)'
- en: 'For extra credit, feel free to play around with the `sf::Sprite`''s `setColor`
    method, which can be used to tint a sprite with a desired color, as well as make
    it transparent, by adjusting the fourth argument of the `sf::Color` type, which
    corresponds to the alpha channel:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外加分，你可以随意尝试使用`sf::Sprite`的`setColor`方法，它可以用来用所需颜色着色精灵，并通过调整`sf::Color`类型的第四个参数（对应于alpha通道）使其透明：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Common mistakes
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见错误
- en: 'Oftentimes, new users of SFML attempt to do something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，SFML的新用户会尝试做一些类似这样的事情：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When attempting to draw the returned sprite, a white square pops out where the
    sprite is supposed to be located. What happened? Well, take a look back at the
    section where we covered textures. The texture needs to be within scope as long
    as it's being used by a sprite because it stores a pointer to the texture instance.
    From the example above, we can see that it is *statically allocated*, so when
    the function returns, the texture that got allocated on the stack is now out of
    scope and gets popped. Poof. Gone. Now the sprite is pointing to an invalid resource
    that it cannot use and instead draws a white rectangle. Now this is not to say
    that you can't just allocate memory on the heap instead by making a new call,
    but that's not the point of this example. The point to take away from this is
    that proper resource management is paramount when it comes to any application,
    so pay attention to the life span of your resources. In [Chapter 6](ch06.html
    "Chapter 6. Set It in Motion! – Animating and Moving around Your World"), *Set
    It in Motion! – Animating and Moving around Your World*, we will cover designing
    your own resource manager and automatically dealing with situations like this.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试绘制返回的精灵时，在精灵应该所在的位置出现了一个白色方块。发生了什么？好吧，回顾一下我们讨论纹理的部分。只要精灵在使用纹理，纹理就必须在作用域内，因为它存储了对纹理实例的指针。从上面的例子中，我们可以看到它是**静态分配的**，所以当函数返回时，在栈上分配的纹理现在超出了作用域，并被弹出。Poof。消失了。现在精灵指向了一个它无法使用的无效资源，并绘制了一个白色矩形。现在这并不是说你可以通过调用新函数在堆上分配内存，但这不是本例的重点。从这个例子中我们可以吸取的教训是，在处理任何应用程序时，适当的资源管理至关重要，因此请注意你资源的生命周期。在[第6章](ch06.html
    "第6章。启动！ – 动画和在世界中移动")中，我们将讨论设计自己的资源管理器并自动处理此类情况。
- en: Another common mistake is keeping too many texture instances around. A single
    texture can be used by as many sprites as one's heart desires. `sf::Texture` is
    not a lightweight object at all, where it's possible to keep tons of `sf::Sprite`
    instances using the same texture and still achieve great performance. Reloading
    textures is also expensive for the graphics card, so keeping as few textures as
    possible is one of the things you really need to remember if you want your application
    to run fast. That's the idea behind using tile sheets, which are just large textures
    with small images packed within them. This grants better performance, since instead
    of keeping around hundreds of texture instances and loading files one by one,
    we get to simply load a single texture and access any desired tile by specifying
    the area to read from. That will also receive more attention in later chapters.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的错误是保留过多的纹理实例。一个纹理可以被尽可能多的精灵使用。`sf::Texture` 并非一个轻量级对象，你可以使用相同的纹理来创建大量的
    `sf::Sprite` 实例，同时仍然获得良好的性能。对于显卡来说，重新加载纹理也是昂贵的，因此尽可能少地保留纹理是如果你想让应用程序运行得更快的话，你需要真正记住的事情之一。这就是使用瓦片图集的思路，它只是包含在其中的小图像的大纹理。这提供了更好的性能，因为我们不需要保留数百个纹理实例并逐个加载文件，我们只需加载单个纹理，通过指定读取区域来访问任何所需的瓦片。这一点将在后面的章节中进一步讨论。
- en: 'Using unsupported image formats or format options is another fairly common
    issue. It''s always best to consult the official website for the most up to date
    information on file format support. A short list can be found here: [http://www.sfml-dev.org/documentation/2.2/classsf_1_1Image.php#a9e4f2aa8e36d0cabde5ed5a4ef80290b](http://www.sfml-dev.org/documentation/2.2/classsf_1_1Image.php#a9e4f2aa8e36d0cabde5ed5a4ef80290b)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不受支持的图像格式或格式选项是另一个相当常见的问题。始终最好查阅官方网站以获取有关文件格式支持的最新信息。一个简短的列表可以在这里找到：[http://www.sfml-dev.org/documentation/2.2/classsf_1_1Image.php#a9e4f2aa8e36d0cabde5ed5a4ef80290b](http://www.sfml-dev.org/documentation/2.2/classsf_1_1Image.php#a9e4f2aa8e36d0cabde5ed5a4ef80290b)
- en: 'Finally, the `LNK2019` errors deserve a mention. It doesn''t matter how many
    times a guide, tutorial, or book mentions how to properly set up and link your
    project to any given library. Nothing is perfect in this world, especially not
    a human being. Your IDE output may get flooded by messages that look something
    like this when trying to compile your project:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要提一下 `LNK2019` 错误。无论指南、教程或书籍多少次提到如何正确设置和链接你的项目到任何给定的库，在这个世界上没有什么是完美的，尤其是人类。当你尝试编译项目时，你的
    IDE 输出可能会被类似以下的消息淹没：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Do not panic, and please, don't make a new forum post somewhere posting hundreds
    of lines of code. You simply forgot to include all the required additional dependencies
    in the linker input. Revisit the part where we covered setting up the project
    for use with SFML and make sure that everything is correct there. Also, remember
    that you need to include libraries that other libraries are dependent on. For
    example, the system library always has to be included, the window library has
    to be included if the graphics module is being used, and so on. Statically linked
    libraries require their dependencies to be linked as well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不要慌张，并且请，不要在某个论坛上发一个包含数百行代码的新帖子。你只是忘记在链接器输入中包含所有必需的附加依赖项。回顾我们介绍如何使用 SFML 设置项目的部分，并确保那里一切都正确。此外，请记住，你需要包含其他库所依赖的库。例如，系统库始终需要包含，如果使用图形模块，则需要包含窗口库，等等。静态链接库需要链接它们的依赖项。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A lot of ground has been covered in this chapter. Some of it may be a little
    bit difficult to grasp at first if you're just starting, but don't be discouraged
    just yet. Applying this knowledge practically is the key to understanding it better.
    It's important that you are competent with everything that has been introduced
    so far before proceeding onto the next chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。如果你是初学者，其中一些内容可能一开始有点难以理解，但请不要气馁。将这一知识应用到实践中是更好地理解它的关键。在继续到下一章之前，确保你对到目前为止所介绍的一切都感到自信。
- en: If you can truly look throughout this chapter and say with utmost confidence
    that you're ready to move forward, we would like to congratulate you on taking
    your first major step towards becoming a successful SFML game developer! Why stop
    there? In the next chapter, we will be covering a better way to structure code
    for our first game project. On top of that, time management will be introduced
    and we'll practically apply everything covered so far by building a major chunk
    of your first, fully functional game. There's a lot of work ahead of us, so get
    the lead out! Your software isn't going to write itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的能通读这一章，并且充满信心地说你已经准备好向前迈进，我们想恭喜你迈出了成为成功的SFML游戏开发者的重要第一步！为什么就此止步呢？在下一章中，我们将介绍一种更好的方法来构建我们的第一个游戏项目的代码结构。除此之外，我们还将引入时间管理，并通过构建你第一个完整功能游戏的主要部分来实际应用到目前为止所涵盖的所有内容。我们面前还有大量的工作要做，所以赶快行动起来！你的软件不会自己写出来。
