- en: Chapter 3. If, Else, and Switch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。If，Else和Switch
- en: In the previous chapter, we discussed the importance of memory and how it can
    be used to store data inside a computer. We spoke about how memory is reserved
    for your program using variables, and how we can include different types of information
    in our variables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了内存的重要性以及如何使用它来在计算机内部存储数据。我们讲述了如何使用变量为程序保留内存，以及我们如何在变量中包含不同类型的信息。
- en: 'In this chapter, we will talk about how to control the flow of our program
    and how we can change what code gets executed by branching the code using control
    flow statements. Here, we''ll discuss the different types of control flow, as
    follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何控制程序的流程以及我们如何通过使用控制流语句来改变执行哪些代码。在这里，我们将讨论不同类型的控制流，如下所示：
- en: If statements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: If语句
- en: How to check whether things are equal using the `==` operator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`==`运算符检查相等性
- en: Else statements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Else语句
- en: How to test for inequalities (that is, how to check whether one number is greater
    or smaller than another using the operators >, >=, <, <=, and !=)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何测试不等式（即，如何使用运算符>，>=，<，<=和!=检查一个数字是否大于或小于另一个）
- en: Using logical operators (such as not (!), and (&&), or (||))
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用逻辑运算符（如not (!)，and (&&)，or (||))
- en: Our first example project with Unreal Engine
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用虚幻引擎的第一个示例项目
- en: 'Branching in more than two ways:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多于两种方式的分支：
- en: The else if statement
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ElseIf语句
- en: The switch statement
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Switch语句
- en: Branching
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支
- en: 'The computer code we wrote in [Chapter 2](part0022_split_000.html#KVCC2-dd4a3f777fc247568443d5ffb917736d
    "Chapter 2. Variables and Memory"), *Variables and Memory* went in one direction:
    straight down. Sometimes, we might want to be able to skip parts of the code.
    We might want the code to be able to branch in more than one direction. Schematically,
    we can represent this in the following manner:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](part0022_split_000.html#KVCC2-dd4a3f777fc247568443d5ffb917736d "第2章。变量和内存")中编写的计算机代码，“变量和内存”是单向的：直接向下。有时，我们可能希望能够跳过代码的一部分。我们可能希望代码能够以多于一个方向分支。从图解的角度来看，我们可以用以下方式表示：
- en: '![Branching](img/00035.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![分支](img/00035.jpeg)'
- en: A flowchart
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 流程图
- en: In other words, we want the option to not run certain lines of code under certain
    conditions. The preceding figure is called a flowchart. According to this flowchart,
    if and only if we are hungry, then we will go prepare a sandwich, eat it, and
    then go and rest on the couch. If we are not hungry, then there is no need to
    make a sandwich, so we will simply rest on the couch.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们希望在特定条件下不运行某些代码行。前面的图称为流程图。根据这个流程图，如果我们饿了，那么我们将准备三明治，吃掉它，然后去沙发上休息。如果我们不饿，那么没有必要做三明治，所以我们只需在沙发上休息。
- en: We'll use flowcharts in this book only sometimes, but in UE4, you can even use
    flowcharts to program your game (using something called blueprints).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中只会偶尔使用流程图，但在UE4中，你甚至可以使用流程图来编写你的游戏（使用称为蓝图的东西）。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This book is about C++ code, so we will always transform our flowcharts into
    actual C++ code in this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是关于C++代码的，因此在这本书中，我们将始终将我们的流程图转换为实际的C++代码。
- en: Controlling the flow of your program
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制程序的流程
- en: Ultimately, what we want is the code to branch in one way under certain conditions.
    Code commands that change which line of code gets executed next are called control
    flow statements. The most basic control flow statement is the `if` statement.
    To be able to code `if` statements, we first need a way to check the value of
    a variable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们希望代码在特定条件下以某种方式分支。改变下一行代码执行顺序的代码命令被称为控制流语句。最基本的控制流语句是`if`语句。为了能够编写`if`语句，我们首先需要一种检查变量值的方法。
- en: So, to start, let's introduce the `==` symbol, which is used to check the value
    of a variable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，让我们介绍`==`符号，它用于检查变量的值。
- en: The == operator
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`==`运算符'
- en: 'In order to check whether two things are equal in C++, we need to use not one
    but two equal signs (`==`) one after the other, as shown here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在C++中检查两个事物是否相等，我们需要使用不是一条而是两条连续的等号(`==`)，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you run the preceding code, you will notice that the output is this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你会注意到输出如下：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In C++, 1 means true, and 0 means false. If you want the words true or false
    to appear instead of 1 and 0, you can use the `boolalpha` stream manipulator in
    the `cout` line of code, as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，1表示真，0表示假。如果你想用true或false代替1和0，你可以在`cout`代码行的`boolalpha`流操作符中使用，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `==` operator is a type of comparison operator. The reason why C++ uses
    `==` to check for equality and not just `=` is that we already used up the `=`
    symbol for the assignment operator! (see the *More on variables* section in [Chapter
    2](part0022_split_000.html#KVCC2-dd4a3f777fc247568443d5ffb917736d "Chapter 2. Variables
    and Memory"), *Variables and Memory*). If we use a single `=` sign, C++ will assume
    that we want to overwrite `x` with `y`, not compare them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`==` 操作符是一种比较操作符。C++ 使用 `==` 来检查相等性而不是仅仅使用 `=` 的原因是因为我们已经在赋值操作符上使用了 `=` 符号了！（参见[第2章](part0022_split_000.html#KVCC2-dd4a3f777fc247568443d5ffb917736d
    "第2章。变量和内存")中的*更多关于变量*部分，*变量和内存*)。如果我们使用单个 `=` 符号，C++ 会假设我们想要将 `x` 覆盖为 `y`，而不是比较它们。'
- en: Coding if statements
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 if 语句
- en: 'Now that we have the double equals sign under our belt, let''s code the flowchart.
    The code for the preceding flowchart figure is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了双等号，让我们编写流程图。前面流程图代码如下：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This is the first time we are using a `bool` variable! A `bool` variable either
    holds the value `true` or the value `false`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次使用 `bool` 变量！一个 `bool` 变量要么持有 `true` 的值，要么持有 `false` 的值。
- en: First, we start with a `bool` variable called `isHungry` and just set it to
    `true`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从一个名为 `isHungry` 的 `bool` 变量开始，并将其设置为 `true`。
- en: 'Then, we use an `if` statement, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 if 语句，如下所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The if statement acts like a guard on the block of code below it. (Remember
    that a block of code is a group of code encased within `{` and `}`.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语句就像是对其下代码块的一个守护者。（记住，一个代码块是一组被 `{` 和 `}` 包围的代码。）
- en: '![Coding if statements](img/00036.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![编写 if 语句](img/00036.jpeg)'
- en: You can only read the code between { and } if `isHungry==true`
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 `isHungry == true` 时，你才能读取 `{` 和 `}` 之间的代码。
- en: You can only get at the code inside the curly braces when `isHungry == true`.
    Otherwise, you will be denied access and forced to skip over that entire block
    of code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 `isHungry == true` 时，你才能访问花括号内的代码。否则，你将无法访问，并被迫跳过整个代码块。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'We an achieve the same effect by simply writing the following line of code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地写下以下代码行来达到相同的效果：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This can be used as an alternative for the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用作以下内容的替代：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The reason people might use the `if( isHungry )` form is to avoid the possibility
    of making mistakes. Writing `if( isHungry = true )` by accident will set `isHungry`
    to true every time the `if` statement is hit! To avoid this possibility, we can
    just write `if( isHungry )` instead. Alternatively, some (wise) people use what
    are called Yoda conditions to check an if statement: `if( true == isHungry )`.
    The reason we write the `if` statement in this way is that, if we accidentally
    write `if( true = isHungry )`, this will generate a compiler error, catching the
    mistake.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可能使用 `if( isHungry )` 形式的原因是为了避免出错的可能性。不小心写成 `if( isHungry = true )` 将会在每次
    `if` 语句被执行时将 `isHungry` 设置为 `true`！为了避免这种可能性，我们只需写 `if( isHungry )`。或者，有些人（明智的人）使用所谓的
    Yoda 条件来检查 if 语句：`if( true == isHungry )`。我们这样写 if 语句的原因是，如果我们不小心写成 `if( true
    = isHungry )`，这将生成编译器错误，捕捉到这个错误。
- en: 'Try to run this code segment to see what I mean:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这段代码来理解我的意思：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following lines show the output of the preceding lines of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的行显示了前面代码行的输出：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The line of code that has `(x = y)` overwrites the previous value of `x` (which
    was 4) with the value of `y` (which is 5). Although we were trying to check whether
    `x` equals `y`, what happened in the previous statement was that `x` was assigned
    the value of `y`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `(x = y)` 的代码行将 `x` 的前一个值（它是 4）覆盖为 `y` 的值（它是 5）。尽管我们试图检查 `x` 是否等于 `y`，但在前面的语句中发生的情况是
    `x` 被赋值为 `y` 的值。
- en: Coding else statements
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 else 语句
- en: The `else` statement is used to have our code do something in the case that
    the `if` portion of the code does not run.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `isHungry == true` 时，我们使用 `else` 语句来让我们的代码在代码的 `if` 部分不运行的情况下执行某些操作。
- en: 'For example, say we have something else that we''d like to do in case we are
    not hungry, as shown in the following code snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们还有其他事情要做，假设我们不是很饿，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are a few important things that you need to remember about the `else`
    keyword, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `else` 关键字，你需要记住以下几点重要事项：
- en: An `else` statement must always immediately follow after an `if` statement.
    You can't have any extra lines of code between the end of the if block and the
    corresponding else block.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else` 语句必须始终紧随 `if` 语句之后。在 if 块的末尾和相应的 else 块之间不能有任何额外的代码行。'
- en: You can never go into both the if and the corresponding else blocks. It's always
    one or the other.![Coding else statements](img/00037.jpeg)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你永远不能同时进入if和相应的else块。总是只有一个。![编码else语句](img/00037.jpeg)
- en: The else statement is the way you will go if `isHungry` is not equal to true
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`isHungry`不等于true时，else语句是你会采取的方式
- en: You can think of the `if`/`else` statements as a guard diverting people to either
    the left or the right. Each person will either go towards the food (when `isHungry==true`),
    or they will go away from the food (when `isHungry==false`).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把`if`/`else`语句看作是一个守卫，将人们引向左边或右边。每个人要么走向食物（当`isHungry==true`时），要么远离食物（当`isHungry==false`时）。
- en: Testing for inequalities using other comparison operators (>, >=, <, <=, and
    !=)
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用其他比较运算符（`>`, `>=`, `<`, `<=`, 和 `!=`）测试不等式
- en: 'Other logical comparisons can be easily done in C++. The > and < symbols mean
    just what they do in math. They are the greater than (>) and less than (<) symbols,
    respectively. >= has the same meaning as the ≥ symbol in math. <= is the C++ code
    for ≤. Since there isn''t a ≤ symbol on the keyboard, we have to write it using
    two characters in C++. `!=` is how we say "not equal to" in C++. So, for example,
    say we have the following lines of code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其他逻辑比较也可以在C++中轻松完成。`>`和`<`符号在数学中的含义就是它们所表示的。它们分别是大于（`>`）和小于（`<`）符号。`>=`的含义与数学中的`≥`符号相同。`<=`是C++中`≤`的代码。由于键盘上没有`≤`符号，我们不得不在C++中使用两个字符来表示它。`!=`是我们在C++中表示“不等于”的方式。例如，如果我们有以下几行代码：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can ask the computer whether `x > y` or `x < y` as shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这里所示那样询问计算机`x > y`或`x < y`：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We need the brackets around the comparisons of x and y because of something
    known as operator precedence. If we don't have the brackets, C++ will get confused
    between the << and < operators. It's weird and you will better understand this
    later, but you need C++ to evaluate the (x < y) comparison before you output the
    result (<<). There is an excellent table available for reference at [http://en.cppreference.com/w/cpp/language/operator_precedence](http://en.cppreference.com/w/cpp/language/operator_precedence).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在x和y的比较周围加上括号，这是因为有一个叫做运算符优先级的东西。如果我们没有括号，C++会在`<<`和`<`运算符之间感到困惑。这很奇怪，你稍后会更好地理解这一点，但你需要C++在输出结果（`<<`）之前先评估`(x
    < y)`的比较。有一个优秀的表格可供参考，链接为[http://en.cppreference.com/w/cpp/language/operator_precedence](http://en.cppreference.com/w/cpp/language/operator_precedence)。
- en: Using logical operators
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用逻辑运算符
- en: 'Logical operators allow you to do more complex checks, rather than checking
    for a simple equality or inequality. Say, for example, the condition to gain entry
    into a special room requires the player to have both the red and green keycards.
    We want to check whether two conditions hold true at the same time. To do this
    type of complex logic statement checks, there are three additional constructs
    that we need to learn: the *not* (`!`), *and* (`&&`), and *or* (`||`) operators.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符允许你进行更复杂的检查，而不仅仅是检查简单的相等或不等。例如，要进入一个特殊房间，玩家需要同时拥有红色和绿色的钥匙卡。我们想要检查两个条件是否同时为真。为了进行这种复杂的逻辑语句检查，我们需要学习三个额外的结构：*not*（`!`）、*and*（`&&`）和*or*（`||`）运算符。
- en: The Not (!) operator
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非（`!`）运算符
- en: 'The `!` operator is handy to reverse the value of a `boolean` variable. Take
    an example of the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`!`运算符可以用来反转布尔变量的值。以下是一个示例代码：'
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `if` statement here checks whether or not you are wearing socks. Then, you
    are issued a command to get some socks on. The `!` operator reverses the value
    of whatever is in the `boolean` variable to be the opposite value.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`if`语句检查你是否穿了袜子。然后，你会接到一个命令去拿一些袜子。`!`运算符将布尔变量中的值反转为其相反值。
- en: 'We use something called a truth table to show all the possible results of using
    the `!` operator on a `boolean` variable, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用所谓的真值表来显示对布尔变量使用`!`运算符的所有可能结果，如下所示：
- en: '| wearingSocks | !wearingSocks |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| wearingSocks | !wearingSocks |'
- en: '| --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| true | false |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| true | false |'
- en: '| false | true |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| false | true |'
- en: So, when `wearingSocks` has the value true, `!wearingSocks` has the value `false`
    and vice versa.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当`wearingSocks`的值为true时，`!wearingSocks`的值为`false`，反之亦然。
- en: Exercises
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: What do you think will be the value of `!!wearingSocks` when the value of `wearingSocks`
    is true?
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`wearingSocks`的值为true时，你认为`!!wearingSocks`的值会是什么？
- en: What is the value of `isVisible` after the following code is run?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码运行后，`isVisible`的值是多少？
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Solution
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: If `wearingSocks` is true, then `!wearingSocks` is false. Therefore, `!!wearingSocks`
    becomes true again. It's like saying *I am not not hungry*. Not not is a double
    negative, so this sentence means that I am actually hungry.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`wearingSocks`为真，则`!wearingSocks`为假。因此，`!!wearingSocks`再次变为真。这就像说*我不饿*。双重否定是“不不”，所以这句话的意思是我实际上饿了。
- en: The answer to the second question is false. `hidden` was true, so `!hidden`
    is false. false then gets saved into the `isVisible` variable.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个问题的答案是假的。`hidden`为真，所以`!hidden`为假。假随后被保存到`isVisible`变量中。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `!` operator is sometimes colloquially known as bang. The preceding bang
    bang operation (`!!`) is a double negative and a double logical inversion. If
    you bang-bang a `bool` variable, there is no net change to the variable. If you
    bang-bang an `int` variable, it becomes a simple `bool` variable(`true` or `false`).
    If the `int` value is greater than zero, it is reduced to a simple `true`. If
    the `int` value is 0 already, it is reduced to a simple `false`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`!`运算符有时被俗称为感叹号。前面的双感叹号运算符(`!!`)是双重否定和双重逻辑反转。如果你对一个`bool`变量进行双感叹号操作，变量没有净变化。如果你对一个`int`变量进行双感叹号操作，它变成一个简单的`bool`变量（`true`或`false`）。如果`int`值大于零，它将简化为`true`。如果`int`值已经是0，它将简化为`false`。'
- en: The And (&&) operator
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与（&&）运算符
- en: 'Say, we only want to run a section of the code if two conditions are true.
    For example, we are only dressed if we are wearing both socks and clothes. You
    can use the following code to checks this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想在两个条件都为真时运行代码段。例如，如果我们穿着袜子并且穿着衣服，我们才算穿衣服。你可以使用以下代码来检查这一点：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Or (||) operator
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 或（||）运算符
- en: We sometimes want to run a section of the code if either one of the variables
    is `true`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时希望如果任何一个变量为`true`，就运行代码段。
- en: 'So, for example, say the player wins a certain bonus if he finds either a special
    star in the level or the time that he takes to complete the level is less than
    60 seconds, in which case you can use the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果玩家在关卡中找到特殊星星或完成关卡的时间少于60秒，他将获得一定的奖励，在这种情况下，你可以使用以下代码：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our first example with Unreal Engine
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们第一个虚幻引擎的示例
- en: We need to get started with Unreal Engine.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要开始使用虚幻引擎。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'A word of warning: when you open your first Unreal project, you will find that
    the code looks very complicated. Don''t get discouraged. Simply focus on the highlighted
    parts. Throughout your career as a programmer, you will often have to deal with
    very large code bases containing sections that you do not understand. However,
    focusing on the parts that you do understand will make this section productive.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个警告：当你打开你的第一个虚幻项目时，你会发现代码看起来非常复杂。不要气馁。只需关注突出显示的部分。在你作为程序员的整个职业生涯中，你将经常不得不处理包含你不懂的部分的非常大的代码库。然而，关注你理解的部分将使这部分工作变得富有成效。
- en: 'Open the **Unreal Engine Launcher** app (which has the blue-colored UE4 icon
    ![Our first example with Unreal Engine](img/00038.jpeg)). Select **Launch Unreal
    Engine 4.4.3**, as shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**虚幻引擎启动器**应用程序（具有蓝色UE4图标 ![我们的第一个虚幻引擎示例](img/00038.jpeg)）。选择**启动虚幻引擎4.4.3**，如下截图所示：
- en: '![Our first example with Unreal Engine](img/00039.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个虚幻引擎示例](img/00039.jpeg)'
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the **Launch** button is grayed out, you need to go to the **Library** tab
    and download an engine (~3 GB).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**启动**按钮变灰，你需要转到**库**选项卡并下载一个引擎（约3 GB）。
- en: Once the engine is launched (which might take a few seconds), you will be in
    the **Unreal Project Browser** screen (black-colored UE4 icon ![Our first example
    with Unreal Engine](img/00040.jpeg)), as shown in the following screenshot.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动引擎（可能需要几秒钟），你将进入**虚幻项目浏览器**屏幕（黑色UE4图标 ![我们的第一个虚幻引擎示例](img/00040.jpeg)），如下截图所示。
- en: Now, select the **New Project** tab in the UE4 project browser. Scroll down
    until you reach **Code Puzzle**. This is one of the simpler projects that doesn't
    have too much code, so it's good to start with. We'll go to the 3D projects later.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在UE4项目浏览器中选择**新建项目**选项卡。向下滚动，直到到达**代码拼图**。这是几个较简单的项目之一，代码不多，所以是一个好的开始。我们稍后会进入3D项目。
- en: '![Our first example with Unreal Engine](img/00041.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个虚幻引擎示例](img/00041.jpeg)'
- en: 'Here are a few things to make a note of in this screen:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上，这里有几点需要注意：
- en: Be sure you're in the **New Project** tab
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你处于**新建项目**选项卡
- en: When you click on **Code Puzzle**, make sure that it is the one with the **C++**
    icon at the right, not **Blueprint Puzzle**
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你点击**代码拼图**时，确保它右边有**C++**图标，而不是**蓝图拼图**
- en: Enter a name for your project, `Puzzle`, in the **Name** box (this is important
    for the example code I will give you to work on later)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**名称**框中输入你的项目名称，`Puzzle`（这对于我稍后提供的示例代码非常重要）
- en: If you want to change the storage folder (to a different drive), click the down
    arrow so that the folder appears. Then, name the directory where you want to store
    your project.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要更改存储文件夹（到不同的驱动器），点击下箭头，以便文件夹出现。然后，命名你想要存储项目的目录。
- en: After you've done all this, select **Create Project**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，选择**创建项目**。
- en: Visual Studio 2013 will open with the code of your project.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2013将打开你的项目代码。
- en: Press *Ctrl*+*F5* to build and launch the project.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Ctrl*+*F5*构建并启动项目。
- en: 'Once the project compiles and runs, you should see the Unreal Editor, as shown
    in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目编译并运行，你应该会看到如以下截图所示的虚幻引擎编辑器：
- en: '![Our first example with Unreal Engine](img/00042.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![使用虚幻引擎的第一个示例](img/00042.jpeg)'
- en: Looks complicated? Oh boy, it sure is! We'll explore some of the functionality
    in the toolbars at the side later. For now, just select **Play** (marked in yellow),
    as shown in the preceding screenshot.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很复杂吗？哦，确实如此！我们稍后会在侧边的工具栏中探索一些功能。现在，只需选择**播放**（如前一张截图所示，标记为黄色）。
- en: 'This launches the game. This is how it should look:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动游戏。它应该看起来像这样：
- en: '![Our first example with Unreal Engine](img/00043.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![使用虚幻引擎的第一个示例](img/00043.jpeg)'
- en: Now, try clicking on the blocks. As soon as you click on a block, it turns orange,
    and this increases your score.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试点击这些方块。一旦点击一个方块，它就会变成橙色，这会增加你的分数。
- en: What we're going to do is find the section that does this and change the behavior
    a little.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要找到执行此操作的代码段，并稍作修改其行为。
- en: Find and open the `PuzzleBlock.cpp` file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 查找并打开`PuzzleBlock.cpp`文件。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In Visual Studio, the list of files in the project is located inside the **Solution
    Explorer**. If your **Solution Explorer** is hidden, simply click on **View**/**Solution
    Explorer** from the menu at the top.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，项目中的文件列表位于**解决方案资源管理器**内。如果你的**解决方案资源管理器**被隐藏，只需从顶部菜单点击**视图**/**解决方案资源管理器**。
- en: 'Inside this file, scroll down to the bottom, where you''ll find a section that
    begins with the following words:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，向下滚动到底部，你会找到一个以以下词开始的代码段：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Our first example with Unreal Engine](img/00044.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![使用虚幻引擎的第一个示例](img/00044.jpeg)'
- en: '`APuzzleBlock` is the class name, and `BlockClicked` is the function name.
    Whenever a puzzle block gets clicked on, the section of code from the starting
    { to the ending } is run. Hopefully, exactly how this happens will make more sense
    later.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`APuzzleBlock`是类名，`BlockClicked`是函数名。每当拼图块被点击时，从起始{到结束}的代码段就会运行。希望这会在稍后变得更加清晰。'
- en: It's kind of like an `if` statement in a way. If a puzzle piece is clicked on,
    then this group of the code is run for that puzzle piece.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它有点像`if`语句。如果一个拼图块被点击，那么这个代码块就会为该拼图块运行。
- en: We're going to walk through the steps to make the blocks flip colors when they
    are clicked on (so, a second click will change the color of the block from orange
    back to blue).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步讲解如何使方块在被点击时改变颜色（因此，第二次点击会将方块的颜色从橙色变回蓝色）。
- en: 'Perform the following steps with the utmost care:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤请务必小心操作：
- en: 'Open `PuzzleBlock.h` file. After line 25 (which has this code):'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PuzzleBlock.h`文件。在行25（包含以下代码）之后：
- en: '[PRE18]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Insert the following code after the preceding lines of code:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码行之后插入以下代码：
- en: '[PRE19]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, open `PuzzleBlock.cpp` file. After line 40 (which has this code):'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`PuzzleBlock.cpp`文件。在行40（包含以下代码）之后：
- en: '[PRE20]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Insert the following code after the preceding lines:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码行之后插入以下代码：
- en: '[PRE21]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, in `PuzzleBlock.cpp`, replace the contents of the `void APuzzleBlock::BlockClicked`
    section of code (line 44) with the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`PuzzleBlock.cpp`中，将`void APuzzleBlock::BlockClicked`代码段的内容（第44行）替换为以下代码：
- en: '[PRE22]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Only replace inside the `void APuzzleBlock::BlockClicked (UPrimitiveComponent*
    ClickedComp)`statement.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在`void APuzzleBlock::BlockClicked (UPrimitiveComponent* ClickedComp)`语句内部替换。
- en: Do not replace the line that starts with `void APuzzleBlock::BlockClicked`.
    You might get an error (if you haven't named your project Puzzle). You've been
    warned.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 不要替换以`void APuzzleBlock::BlockClicked`开头的行。如果你没有将项目命名为Puzzle，可能会出现错误（警告过你了）。
- en: 'So, let''s analyze this. This is the first line of code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们分析一下。这是第一行代码：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This line of code simply flips the value of `bIsActive`. `bIsActive` is a `bool`
    variable (it is created in `APuzzleBlock.h`). If `bIsActive` is true, `!bIsActive`
    will be false. So, whenever this line of code is hit (which happens with a click
    on any block), the `bIsActive` value is reversed (from `true` to `false` or from
    `false` to `true`).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码只是翻转了 `bIsActive` 的值。`bIsActive` 是一个 `bool` 变量（它在 `APuzzleBlock.h` 中创建）。如果
    `bIsActive` 为真，则 `!bIsActive` 将为假。所以，每当执行此行代码时（这发生在点击任何块上），`bIsActive` 的值就会反转（从
    `true` 到 `false` 或从 `false` 到 `true`）。
- en: 'Let''s consider the next block of code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑下一块代码：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are simply changing the block color. If `bIsActive` is true, then the block
    becomes orange. Otherwise, the block turns blue.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是改变了块的颜色。如果 `bIsActive` 为真，则块变为橙色。否则，块变为蓝色。
- en: Exercise
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: By now, you should notice that the best way to get better at programming is
    by doing it. You have to practice programming a lot to get significantly better
    at it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该注意到，提高编程技能的最佳方式就是实际编程。你必须大量练习编程，才能显著提高编程技能。
- en: Create two integer variables, called x and y, and read them in from the user.
    Write an `if`/`else` statement pair that prints the name of the bigger-valued
    variable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个整数变量，称为 x 和 y，并从用户那里读取它们。编写一个 `if`/`else` 语句对，打印较大值的变量名。
- en: Solution
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: 'The solution of the preceding exercise is shown in the following block of code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面练习的解答如下所示：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't type a letter when `cin` expects a number. `cin` can fail and give a bad
    value to your variable if that happens.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `cin` 期望一个数字时，不要输入字母。如果发生这种情况，`cin` 可能会失败，并给变量一个错误值。
- en: Branching code in more than two ways
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多于两种方式的分支代码
- en: 'In the previous sections, we were only able to make the code branch in one
    of the two ways. In pseudocode, we had the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们只能使代码以两种方式之一分支。在模拟代码中，我们有以下代码：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Pseudocode is *fake code*. Writing pseudocode is a great way to brainstorm and
    plan out your code, especially if you are not quite used to C++.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟代码是 *假代码*。编写模拟代码是头脑风暴和规划代码的绝佳方式，尤其是如果你还不习惯 C++。
- en: This code is a little bit like a metaphorical fork in the road, with only one
    of two directions to choose from.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有点像一条道路上的比喻性分叉，只有两个方向可以选择。
- en: 'Sometimes, we might want to branch the code in more than just two directions.
    We might want the code to branch in three ways, or even more. For example, say
    the direction in which the code goes depends on what item the player is currently
    holding. The player can be holding one of three different items: a coin, key,
    or sand dollar. And C++ allows that! In fact, in C++, you can branch in any number
    of directions as you wish.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能想要代码分支超过两个方向。我们可能希望代码以三种方式分支，甚至更多。例如，假设代码的走向取决于玩家当前持有的物品。玩家可以持有三种不同的物品之一：硬币、钥匙或沙币。C++
    允许这样做！实际上，在 C++ 中，你可以按需以任意数量的方向分支。
- en: The else if statement
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`else if` 语句'
- en: 'The `else if` statement is a way to code in more than just two possible branch
    directions. In the following code example, the code will go in one of the three
    different ways, depending on whether the player is holding the `Coin`, `Key`,
    or `Sanddollar` objects:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`else if` 语句是一种在超过两个可能的分支方向上进行编码的方式。在以下代码示例中，代码将根据玩家是否持有 `Coin`、`Key` 或 `Sanddollar`
    对象而以三种不同的方式之一执行。'
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the preceding code only goes in one of the three separate ways! In
    an `if`, `else if`, and `else if` series of checks, we will only ever go into
    one of the blocks of code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码只会在三种不同的方式中的一种。在 `if`、`else if` 和 `else if` 系列检查中，我们只会进入一个代码块。
- en: '![The else if statement](img/00045.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![The else if statement](img/00045.jpeg)'
- en: Exercise
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Use C++ program to answer the questions that follow. Be sure to try these exercises
    in order to gain fluency with these equality operators.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C++ 程序回答以下问题。务必尝试这些练习，以便熟练掌握这些相等运算符。
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Write some new lines of code at the spot that says (`// *** Write new...`):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在指出 (`// *** Write new...`) 的位置编写一些新的代码行：
- en: Check whether `x` and `y` are equal. If they are equal, print `x and y are equal`.
    Otherwise, print `x and y are not equal`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `x` 和 `y` 是否相等。如果它们相等，打印 `x and y are equal`。否则，打印 `x and y are not equal`。
- en: 'An exercise on inequalities: check whether `x` is greater than `y`. If it is,
    print `x is greater than y`. Otherwise, print `y is greater than x`.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个关于不等式的练习：检查 `x` 是否大于 `y`。如果是，打印 `x is greater than y`。否则，打印 `y is greater
    than x`。
- en: Solution
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解答
- en: 'To evaluate equality, insert the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要评估相等性，请插入以下代码：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To check which value is greater insert the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查哪个值更大，请插入以下代码：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The switch statement
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`switch` 语句'
- en: The `switch` statement allows your code to branch in multiple ways. What the
    `switch` statement will do is look at the value of a variable, and depending on
    its value, the code will go in a different direction.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句允许你的代码以多种方式分支。`switch` 语句将要执行的操作是查看变量的值，并根据其值，代码将走向不同的方向。'
- en: 'We''ll also introduce the `enum` construct here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在这里介绍 `enum` 构造：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Switches are like coin sorters. When you drop 25 cent into the coin sorter,
    it finds its way into the 25 cent pile. Similarly, a `switch` statement will simply
    allow the code to jump down to the appropriate section. The example of sorting
    the coins is shown in the following figure:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 就像硬币分类器。当你投入25美分的硬币时，它会找到其所属的25美分堆。同样，`switch` 语句将简单地允许代码跳转到适当的部分。以下图表展示了分类硬币的示例：'
- en: '![The switch statement](img/00046.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![switch 语句](img/00046.jpeg)'
- en: 'The code inside the `switch` statement will continue to run (line by line)
    until the `break;` statement is hit. The `break` statement jumps you out of the
    `switch` statement. Take a look at the following diagram to understand how the
    switch works:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句内部的代码将继续运行（逐行），直到遇到 `break;` 语句。`break` 语句会跳出 `switch` 语句。请查看以下图表以了解
    `switch` 的工作原理：'
- en: '![The switch statement](img/00047.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![switch 语句](img/00047.jpeg)'
- en: First, the `Food` variable is inspected. What value does it have? In this case,
    it has `Fish` inside it.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查 `Food` 变量。它有什么值？在这种情况下，它包含 `Fish`。
- en: The `switch` command jumps down to the correct case label. (If there is no matching
    case label, the switch will just be skipped).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`switch` 命令会跳转到正确的案例标签。（如果没有匹配的案例标签，`switch` 将会被跳过）。'
- en: The `cout` statement is run, and `Here fishy fishy fishy` appears on the console.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行了 `cout` 语句，控制台上出现了“Here fishy fishy fishy”。
- en: After inspecting the variable and printing the user response, the break statement
    is hit. This makes us stop running lines of code in the switch and exit the switch.
    The next line of code that is run is just what would otherwise have been the next
    line of code in the program if the switch had not been there at all (after the
    closing curly brace of the switch statement). It is the print statement at the
    bottom, which says "End of switch".
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查变量并打印用户响应后，执行了 `break` 语句。这使得我们停止在 `switch` 中运行代码行，并退出 `switch`。接下来运行的代码行只是如果没有
    `switch` 的话，程序中原本应该运行的下一行代码（在 `switch` 语句的闭合花括号之后）。这是底部的打印语句，它说“switch 结束”。
- en: Switch versus if
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`switch` 与 `if` 的比较'
- en: Switches are like the `if` / `else if` / `else` chains from earlier. However,
    switches can generate code faster than `if` / `else if` / `else if` / `else` chains.
    Intuitively, switches only jump to the appropriate section of the code to execute.
    If / else if / else chains might involve more complicated comparisons (including
    logical comparisons), which might take more CPU time. The main reason you will
    use the `if` statements is to do more with your own custom comparisons inside
    the brackets.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 与 `if` / `else if` / `else` 链的比较。然而，`switch` 可以比 `if` / `else if`
    / `else if` / `else` 链更快地生成代码。直观地说，`switch` 只会跳转到代码的适当部分以执行。`if` / `else if` /
    `else` 链可能涉及更复杂的比较（包括逻辑比较），这可能会占用更多的 CPU 时间。你将使用 `if` 语句的主要原因是在括号内进行更多自定义的比较。'
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'An enum is really an int. To verify this, print the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举实际上是一个整型。为了验证这一点，请打印以下代码：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You will see the integer values of the enum—just so you know.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到枚举的整数值——仅此而已。
- en: 'Sometimes, programmers want to group multiple values under the same switch
    `case` label. Say, we have an `enum`, object as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，程序员想要在同一个 `switch` `case` 标签下分组多个值。比如说，我们有一个如下所示的 `enum` 对象：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A programmer wants to group all the greens together, so he writes a `switch`
    statement as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序员想要将所有绿色蔬菜放在一起，因此他编写了以下 `switch` 语句：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, `Zucchini` falls through and executes the same code as `Broccoli`.
    The non-green vegetables are in the `default` case label. To prevent a fall through,
    you have to remember to insert an explicit `break` statement after each `case`
    label.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Zucchini` 会穿透并执行与 `Broccoli` 相同的代码。非绿色蔬菜在 `default` 案例标签中。为了防止穿透，你必须记得在每个
    `case` 标签后插入显式的 `break` 语句。
- en: 'We can write another version of the same switch that does not let Zucchini
    fall through, by the explicit use of the keyword `break` in the switch:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`switch`中显式使用关键字`break`来编写一个不允许西葫芦掉过的相同`switch`版本：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that it is good programming practice to `break` the `default` case as well,
    even though it is the last `case` listed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，良好的编程实践是即使它是列出的最后一个`case`，也应该`break`掉`default`情况。
- en: Exercise
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Complete the following program, which has an `enum` object with a series of
    mounts to choose from. Write a `switch` statement that prints the following messages
    for the mount selected:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下程序，该程序有一个`enum`对象，其中包含一系列可供选择骑乘的坐骑。编写一个`switch`语句，为选定的坐骑打印以下消息：
- en: '| Horse | The steed is valiant and mighty |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 马匹 | 骑手英勇而强大|'
- en: '| Mare | This mare is white and beautiful |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 骆马 | 这匹骆马又白又美丽|'
- en: '| Mule | You are given a mule to ride. You resent that. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 骆驼 | 你被分配了一匹骆驼来骑。你对此感到不满。|'
- en: '| Sheep | Baa! The sheep can barely support your weight. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 羊群 | 咩！羊群几乎承受不住你的重量。|'
- en: '| Chocobo | Chocobo! |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 马儿 | 马儿！|'
- en: Remember, an `enum` object is really an `int` statement. The first entry in
    an `enum` object is by default 0, but you can give the `enum` object any starting
    value you wish using the = operator. Subsequent values in the `enum` object are
    `ints` arranged in order.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`enum`对象实际上是一个`int`声明。`enum`对象中的第一个条目默认为0，但你可以使用`=`运算符给`enum`对象赋予任何你想要的起始值。`enum`对象中的后续值是按顺序排列的`int`。
- en: Tip
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Bit-shifted enum**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**位移后的枚举**'
- en: 'A common thing to do in an `enum` object is to assign a bit-shifted value to
    each entry:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在`enum`对象中，一个常见的做法是为每个条目分配一个位移后的值：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The bit-shifted values should be able to combine the window properties. This
    is how the assignment will look:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 位移后的值应该能够组合窗口属性。这是赋值将如何看起来：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Checking which `WindowProperties` have been set involves a check using `bitwise
    AND`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 检查哪些`WindowProperties`已被设置涉及到使用`位与`的检查：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Bit shifting is a technique that is slightly beyond the scope of this text,
    but I've included this tip just so you know about it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算是一种稍微超出本文范围的技术，但我包括这个提示只是为了让你知道。
- en: Solution
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The solution of the preceding exercise is shown in the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个练习的解决方案如下所示：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned how to branch the code. Branching makes it possible
    for the code to go in a different direction instead of going straight down.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何分支代码。分支使得代码能够走向不同的方向，而不是直接向下执行。
- en: In the next chapter, we will move on to a different kind of control flow statement
    that will allow you to go back and repeat a line of code a certain number of times.
    The sections of code that repeat will be called loops.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续介绍另一种类型的控制流语句，这将允许你返回并重复一行代码一定次数。重复的代码段将被称为循环。
