<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Getting Physical – Box2D</h1></div></div></div><p class="calibre6">
<em class="calibre8">It's time to tackle physics! Cocos2d-x comes bundled with Box2D and Chipmunk. These are so-called 2D physics engines – the first written in C++ and the second in C. Chipmunk has a more recent Objective-C port but Cocos2d-x must use the original one written in C for portability.</em>
</p><p class="calibre6">
<em class="calibre8">We'll be using Box2D for the examples in this book. The next two games I'll show you will be developed with that engine, starting with a simple pool game to illustrate all the main points about using Box2D in your projects.</em>
</p><p class="calibre6">In this chapter, you will learn:</p><div><ul class="itemizedlist"><li class="listitem">How to set up and run a Box2D simulation</li><li class="listitem">How to create bodies</li><li class="listitem">How to use the debug draw feature to quickly test your concepts</li><li class="listitem">How to use collision filters and listeners</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec111" class="calibre1"/>Building a Box2D project with Cocos2d-x</h1></div></div></div><p class="calibre6">With<a id="id288" class="calibre1"/> version 3.x of the framework, we no longer <a id="id289" class="calibre1"/>need to specify that we want to use a physics engine. The projects add these APIs by default. So, all you need in order to create a Box2D project is to create a regular Cocos2d-x project as we've been doing with the examples so far.</p><p class="calibre6">There is, however, one extra step you need to perform if you wish to use something called a debug draw in your project. So let's set that up now.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec112" class="calibre1"/>Time for action – using debug draw in your Box2D project</h1></div></div></div><p class="calibre6">Let's <a id="id290" class="calibre1"/>start by creating the project. In my machine, I created a game called MiniPool in my desktop. Here are the steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open Terminal and enter the following command:<div><pre class="programlisting">cocos new MiniPool -p com.rengelbert.MiniPool -l cpp -d /Users/rengelbert/Desktop/MiniPool</pre></div></li><li class="listitem" value="2">Open the new project in Xcode.</li><li class="listitem" value="3">Now navigate to the <code class="email">Tests</code> folder inside the Cocos2d-x framework folder. This can be found in <code class="email">tests/cpp-tests/Classes</code>. Then open the <code class="email">Box2DTestBed</code> folder.</li><li class="listitem" value="4">Drag<a id="id291" class="calibre1"/> the files <code class="email">GLES-Render.h</code> and <code class="email">GLES-Render.cpp</code> to your project in Xcode.</li><li class="listitem" value="5">You can also open the <code class="email">Box2dTest.cpp</code> class in the test folder <code class="email">Box2DTest</code>, as we're going to copy and paste a few of the methods from there.</li><li class="listitem" value="6">In the <code class="email">HelloWorldScene.h</code> header file, leave the includes in place, but change the class declarations to match these:<div><pre class="programlisting">class HelloWorld : public cocos2d::Layer {
public:
    virtual ~HelloWorld();
    HelloWorld();
    
   static cocos2d::Scene* scene();
    
    void initPhysics();
    void update(float dt);
    virtual void draw(Renderer *renderer, const Mat4 &amp;transform, uint32_t flags) override;
    
private:
   GLESDebugDraw * _debugDraw;
    b2World* world;
    Mat4 _modelViewMV;
    void onDraw();
    CustomCommand _customCommand;
};</pre></div></li><li class="listitem" value="7">Then add this <code class="email">include</code> statement at the top:<div><pre class="programlisting">#include "GLES-Render.h"</pre></div></li><li class="listitem" value="8">Then, in the <code class="email">HelloWorldScene.cpp</code> implementation file, replace the lines between the <code class="email">using namespace CocosDenshion</code> and <code class="email">HelloWorld::scene</code> methods with these:<div><pre class="programlisting">#define PTM_RATIO 32

HelloWorld::HelloWorld()
{
    this-&gt;initPhysics();
    scheduleUpdate();
}

HelloWorld::~HelloWorld()
{
    delete world;
    world = nullptr;
    
    delete _debugDraw;
   _debugDraw = nullptr;
}

void HelloWorld::initPhysics() {

    b2Vec2 gravity;
    gravity.Set(0.0f, -10.0f);
    world = new b2World(gravity);

    // Do we want to let bodies sleep?
    world-&gt;SetAllowSleeping(true);
    world-&gt;SetContinuousPhysics(true);

    _debugDraw = new (std::nothrow) GLESDebugDraw( PTM_RATIO );
    world-&gt;SetDebugDraw(_debugDraw);

    uint32 flags = 0;
    flags += b2Draw::e_shapeBit;
    //        flags += b2Draw::e_jointBit;
    //        flags += b2Draw::e_aabbBit;
    //        flags += b2Draw::e_pairBit;
    //        flags += b2Draw::e_centerOfMassBit;
    _debugDraw-&gt;SetFlags(flags);

}
void HelloWorld::update(float dt)
{
    world-&gt;Step(dt, 8, 1);
    
}</pre></div></li><li class="listitem" value="9">Now comes the<a id="id292" class="calibre1"/> implementation of the <code class="email">draw</code> methods. You can copy and paste most of this code from the <code class="email">Box2DTest</code> folder:<div><pre class="programlisting">void GameLayer::draw(Renderer *renderer, const Mat4 &amp;transform, uint32_t flags)
{
   //
    // IMPORTANT:
    // This is only for debug purposes
    // It is recommended to disable it
    //
   Layer::draw(renderer, transform, flags);
  GL::enableVertexAttribs( cocos2d::GL::VERTEX_ATTRIB_FLAG_POSITION );
    auto director = Director::getInstance();
    CCASSERT(nullptr != director, "Director is null when setting matrix stack");
    director-&gt;pushMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
    
    _modelViewMV = director-&gt;getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
    
    _customCommand.init(_globalZOrder);
    _customCommand.func = CC_CALLBACK_0(GameLayer::onDraw, this);
    renderer-&gt;addCommand(&amp;_customCommand);
    
    director-&gt;popMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);

}

void GameLayer::onDraw()
{
   auto director = Director::getInstance();
   Mat4 oldMV;
    oldMV = director-&gt;getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
    director-&gt;loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, _modelViewMV);
    _world-&gt;DrawDebugData();
    director-&gt;loadMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW, oldMV);
}</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec92" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">The <code class="email">GLES-Render</code> class is necessary to use the debug draw feature in Box2D. This will draw<a id="id293" class="calibre1"/> all the elements from the simulation on the screen. The debug draw object is created inside the <code class="email">initPhysics</code> method alongside the Box2D simulation (<code class="email">b2World</code>). We'll go over that logic in a moment.</p><p class="calibre6">As the comment inside the <code class="email">draw</code> method states, the debug draw feature should be switched off once you're done developing your game. So all the lines pertaining to that object as well as the <code class="email">draw</code> method should be commented out when you're ready for a release version.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec113" class="calibre1"/>So what is a physics engine?</h1></div></div></div><p class="calibre6">The famous Isaac Newton said, <em class="calibre8">every action has a reaction</em>. Right after he said, <em class="calibre8">who the hell threw that apple?</em>
</p><p class="calibre6">So <a id="id294" class="calibre1"/>far in our games, we have covered very simple collision systems, basically only ever checking to see if simple shapes (circles and rectangles) overlapped each other. The reactions from these collisions were also very simple in our games so far: with vector inversions or simply by making things disappear once they touch. With Box2D, you get way more!</p><p class="calibre6">Box2D is a very robust collision detection engine and can certainly be used just for that purpose. But the simulation will also process and return a bunch of information derived from the collisions and the interactions between bodies, meaning how the objects should behave, based on their shapes, mass, and all the forces at play in the simulation.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec93" class="calibre1"/>Meeting Box2D</h2></div></div></div><p class="calibre6">At the <a id="id295" class="calibre1"/>core of the engine, you have the <code class="email">b2World</code> object. This is the <a id="id296" class="calibre1"/>simulation. You fill the world with <code class="email">b2Body</code> objects, and then you step through the simulation with <code class="email">b2World-&gt;Step()</code>. And you take the results of the simulation and display them to the user through your sprites, by grabbing a <code class="email">b2Body</code> object's position and rotation and applying them to a sprite.</p><p class="calibre6">The debug draw object allows you to see the simulation without using any sprites. Sort of like a version of our test project from <a class="calibre1" title="Chapter 6. Quick and Easy Sprite – Victorian Rush Hour" href="part0087_split_000.html#page">Chapter 6</a>, <em class="calibre8">Quick and Easy Sprite – Victorian Rush Hour</em>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec94" class="calibre1"/>Meeting the world</h2></div></div></div><p class="calibre6">Most<a id="id297" class="calibre1"/> of the time, the physics simulation will mean the creation of a <code class="email">b2World</code> object. Note, however, that you <em class="calibre8">can</em> get interesting results managing more than one <code class="email">world</code> object in the same game, for multiple views for instance. But that's for another book.</p><p class="calibre6">In our simplified basic project, the world is created like this:</p><div><pre class="programlisting">b2Vec2 gravity;
gravity.Set(0.0f, -10.0f);
world = new b2World(gravity);

// Do we want to let bodies sleep?
world-&gt;SetAllowSleeping(true);
world-&gt;SetContinuousPhysics(true);

_debugDraw = new (std::nothrow) GLESDebugDraw( PTM_RATIO );
world-&gt;SetDebugDraw(_debugDraw);

uint32 flags = 0;
flags += b2Draw::e_shapeBit;
//        flags += b2Draw::e_jointBit;
//        flags += b2Draw::e_aabbBit;
//        flags += b2Draw::e_pairBit;
//        flags += b2Draw::e_centerOfMassBit;
_debugDraw-&gt;SetFlags(flags);</pre></div><p class="calibre6">Box2D has <a id="id298" class="calibre1"/>its own vector structure, <code class="email">b2Vec2</code>, and we use it here to create the world's gravity. The <code class="email">b2World</code> object receives that as its parameter. A simulation does not always require gravity, of course; in that case, the argument will be a <code class="email">(0, 0)</code> vector.</p><p class="calibre6">
<code class="email">SetAllowSleeping</code> means if objects are not moving and therefore not generating derived data, skip checking for derived data from those objects.</p><p class="calibre6">
<code class="email">SetContinuousPhysics</code> means we have some fast objects in our hands, which we'll later point out to the simulation, so it can pay extra attention for collisions.</p><p class="calibre6">Then we create the debug draw object. This is optional, as I said before. The flags indicate what you wish to see in the drawing. In the code we saw before, we only want to see the shapes of the objects.</p><p class="calibre6">Then comes <code class="email">PTM_RATIO</code>, the defined constant we passed as a parameter to the debug draw. Box2D uses meters instead of pixels for a variety of reasons that are really entirely unnecessary for anyone to know. Except for one reason, <strong class="calibre7">pixel to meter</strong> (<strong class="calibre7">PTM</strong>), so every pixel position<a id="id299" class="calibre1"/> value used in the game will be divided by this ratio constant. If the result from this division ever gets above 10 or below 0.1, increase or decrease the value for <code class="email">PTM_RATIO</code> accordingly.</p><p class="calibre6">You have some leeway, of course. By all means, play with this value once your game is completed, and pay special attention to the subtle differences in speed (another common value for this ratio is 100).</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec95" class="calibre1"/>Running the simulation</h2></div></div></div><p class="calibre6">As I<a id="id300" class="calibre1"/> said before, you use the <code class="email">Step</code> method to run the simulation, usually inside your main loop, though not necessarily:</p><div><pre class="programlisting">world-&gt;Step(dt, 8, 1);</pre></div><p class="calibre6">You need to pass it the time step, here represented by the delta time in the main loop. Then pass the number of velocity iterations and position iterations in the step. This basically means how many times velocity and position will be processed inside a step.</p><p class="calibre6">In the<a id="id301" class="calibre1"/> previous example, I'm using the default values from the Box2D template in Cocos2d-x. Usually, a fixed time step is better than the delta, and a higher value for position iteration may be necessary if things move really fast in your game. But always remember to play with these values, aiming at finding the lowest possible ones.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec96" class="calibre1"/>No Ref objects in Box2D</h2></div></div></div><p class="calibre6">Box2D <a id="id302" class="calibre1"/>does not use <code class="email">Ref</code> objects. So, no memory management! Remember to get rid of all the Box2D objects through <code class="email">delete</code> and not <code class="email">release</code>. If you knew it already... well, you remember:</p><div><pre class="programlisting">HelloWorld::~HelloWorld(){
    delete world;
    world = nullptr;
    
    delete _debugDraw;
   _debugDraw = nullptr;
}</pre></div><div><h3 class="title2"><a id="note15" class="calibre1"/>Note</h3><p class="calibre6">As I mentioned before, C++11 introduces smart pointers, which are memory managed, meaning you <em class="calibre8">don't</em> have to delete these objects yourself. However, the topic of shared pointers is beyond the scope of this book, and using unique pointers in this chapter would add way too many lines that had nothing to do with Box2D. And although smart pointers are amazing, their syntax and usage is, well, let's say very "C++ish".</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec97" class="calibre1"/>Meeting the bodies</h2></div></div></div><p class="calibre6">The <code class="email">b2Body</code> object is the thing you'll spend most of your time dealing with inside a Box2D<a id="id303" class="calibre1"/> simulation. You have three main types of <code class="email">b2Bodies</code>: dynamic, static, and <a id="id304" class="calibre1"/>kinematic. The first two are of greater importance and are the ones we'll use in our game.</p><p class="calibre6">Bodies are created by combining a body definition with a body fixture. The body definition is a structure that holds information about type, position, velocity, and angle, among other things. The fixture holds information about the shape, including its density, elasticity, and friction.</p><p class="calibre6">So, to create a circle that is 40 pixels wide, you would use the following:</p><div><pre class="programlisting">b2BodyDef bodyDef;
bodyDef.type = b2_dynamicBody;
//or make it static bodyDef.type = b2_staticBody;
b2Body * body = world-&gt;CreateBody(&amp;bodyDef);

//create circle shape
b2CircleShape  circle;
circle.m_radius = 20.0/PTM_RATIO;
    
//define fixture
b2FixtureDef fixtureDef;
fixtureDef.shape = &amp;circle;
fixtureDef.density = 1;
fixtureDef.restitution = 0.7;
fixtureDef.friction = 0.4;

body-&gt;CreateFixture(&amp;fixtureDef);</pre></div><p class="calibre6">To <a id="id305" class="calibre1"/>create a box that is 40 pixels wide, you would use <a id="id306" class="calibre1"/>this:</p><div><pre class="programlisting">//create body
b2BodyDef bodyDef;
bodyDef.type = b2_dynamicBody;
b2Body * body = world-&gt;CreateBody(&amp;bodyDef);

//define shape
b2PolygonShape box;
box.SetAsBox(20 /PTM_RATIO, 20 / PTM_RATIO);

//Define fixture
b2FixtureDef fixtureDef;
fixtureDef.shape = &amp;box;
fixtureDef.density = 2;
fixtureDef.restitution = 0;
body-&gt;CreateFixture(&amp;fixtureDef);</pre></div><p class="calibre6">Note that you use the <code class="email">world</code> object to create the bodies. And also note that boxes are created with half their desired width and height.</p><p class="calibre6">Density, friction, and restitution all have default values, so you don't always need to set these.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec114" class="calibre1"/>Our game – MiniPool</h1></div></div></div><p class="calibre6">Our <a id="id307" class="calibre1"/>game consists of sixteen balls (circles), one cue (box), and a pool table made out of six lines (edges) and six pockets (circles). This is all there is to it as far as the Box2D simulation is concerned.</p><p class="calibre6">Download the final project from this book's <strong class="calibre7">Support</strong> page if you wish to follow along with the final code. Box2D is a complex API and it will be best to review and expose the logic rather than work on it by doing a lot of typing. So there will be no start project to work from <a id="id308" class="calibre1"/>this time. You may choose any manner to add files from the finished project to the one we started when I showed you how to set up the debug draw object. The final game will look like this:</p><div><img src="img/00030.jpeg" alt="Our game – MiniPool" class="calibre9"/></div><p class="calibre10"> </p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec98" class="calibre1"/>Game settings</h2></div></div></div><p class="calibre6">This is <a id="id309" class="calibre1"/>a portrait-orientation-only game, with no screen rotation allowed, and universal application. The game is designed for the regular iPhone (320 x 480) and its resolution size is set to <code class="email">kResolutionShowAll</code>. This will show borders around the main screen in devices that do not match the 1.5 screen ratio of the iPhone.</p><div><pre class="programlisting">//in AppDelegate.cpp
auto screenSize = glview-&gt;getFrameSize();
auto designSize = Size(320, 480);
    
glview-&gt;setDesignResolutionSize(designSize.width, designSize.height, ResolutionPolicy::SHOW_ALL);
std::vector&lt;std::string&gt; searchPaths;
   if (screenSize.width &gt; 640) {
      searchPaths.push_back("ipadhd");
      director-&gt;setContentScaleFactor(1280/designSize.width);
   } else if (screenSize.width &gt; 320) {
      searchPaths.push_back("ipad");
      director-&gt;setContentScaleFactor(640/designSize.width);
   } else {
      searchPaths.push_back("iphone");
      director-&gt;setContentScaleFactor(320/designSize.width);
   }
   auto fileUtils = FileUtils::getInstance();
   fileUtils-&gt;setSearchPaths(searchPaths);</pre></div><p class="calibre6">Note that I use<a id="id310" class="calibre1"/> the iPhone's dimensions to identify larger screens. So the iPad and the iPhone retina are considered to be two times 320 x 480 and the retina iPad is considered to be four times 320 x 480.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec99" class="calibre1"/>Sprite plus b2Body equal to b2Sprite</h2></div></div></div><p class="calibre6">The<a id="id311" class="calibre1"/> most common way to work with <code class="email">b2Body</code> objects in Cocos2d-x is to combine them with sprites. In the games I'll show you, I created a class called <code class="email">b2Sprite</code> that extends sprite with the addition of a <code class="email">_body</code> member property that points to its very own <code class="email">b2Body</code>. I also add a few helper methods to deal with our pesky <code class="email">PTM_RATIO</code>. Feel free to add as many of these as you think necessary.</p><p class="calibre6">
<code class="email">b2Body</code> objects have an incredibly helpful property called <code class="email">userData</code>. You can store anything you wish inside it and the bodies will carry it with them throughout the simulation. So, what most developers do is that they store inside the body's <code class="email">userData</code> property a reference to the instance of sprite wrapping it. So <code class="email">b2Sprite</code> knows about its body, and the body knows about its <code class="email">b2Sprite</code>.</p><div><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre6">As a matter of fact, composition is key when working with Box2D. So, when designing your games, make sure every object knows of every other object or can get to them quickly. This will help immensely.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec100" class="calibre1"/>Creating the pool table</h2></div></div></div><p class="calibre6">In<a id="id312" class="calibre1"/> the debug draw view, this is what the table looks like:</p><div><img src="img/00031.jpeg" alt="Creating the pool table" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">All the <a id="id313" class="calibre1"/>elements seen here are created inside the <code class="email">initPhysics</code> method in <code class="email">GameLayer.cpp</code>. The table has no visual representation other than the background image we use in the game. So there are no sprites attached to the individual pockets, for example.</p><p class="calibre6">The <code class="email">pocket</code> bodies are created inside a <code class="email">for</code> loop, with the best algorithm I could come up with to distribute them correctly on screen. This logic is found in the <code class="email">initPhysics</code> method, so let's take a look at that and see how our first <code class="email">b2Body</code> objects are created:</p><div><pre class="programlisting">b2Body * pocket;
b2CircleShape circle;
float startX = _screenSize.width * 0.07;
float startY = _screenSize.height * 0.92f;
for (int i = 0; i &lt; 6; i++) {
   bodyDef.type = b2_staticBody;
   if (i &lt; 3) {
      bodyDef.position.Set(startX/PTM_RATIO,
(startY - i * (_screenSize.height * 0.84f * 0.5f))/PTM_RATIO);

    } else {
        bodyDef.position.Set(
        (startX + _screenSize.width * 0.85f)/PTM_RATIO,
        (startY - (i-3) * (_screenSize.height * 0.84f * 0.5f))/PTM_RATIO);
    }
    pocket = _world-&gt;CreateBody(&amp;bodyDef);
    fixtureDef.isSensor = true;
    circle.m_radius = (float) (1.5 * BALL_RADIUS) / PTM_RATIO;
    fixtureDef.shape = &amp;circle;

    pocket-&gt;CreateFixture(&amp;fixtureDef);
    auto pocketData = new b2Sprite(this, kSpritePocket);
    pocket-&gt;SetUserData(pocketData);
}</pre></div><p class="calibre6">The <code class="email">pocket</code> bodies are static bodies and we determine in their fixture definition that they should behave like sensors:</p><div><pre class="programlisting">fixtureDef.isSensor = true;</pre></div><p class="calibre6">This <a id="id314" class="calibre1"/>switches off all the physics from an object and turns it into a collision hot spot. A sensor serves only to determine if something is touching it or not.</p><div><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre6">It's almost always best to ignore Box2D sensors and use your own sprites or points in your collision logic. One neat feature in sensors is that they make it very easy to determine when something has just ceased touching them, as you'll see once we cover contact listeners.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec101" class="calibre1"/>Creating edges</h2></div></div></div><p class="calibre6">If a shape<a id="id315" class="calibre1"/> can only be hit on one side, an edge is probably what you need. Here is how we create edges in our game:</p><div><pre class="programlisting">b2BodyDef tableBodyDef;
tableBodyDef.position.Set(0, 0);
b2Body* tableBody = _world-&gt;CreateBody(&amp;tableBodyDef);

// Define the table edges
b2EdgeShape tableBox;

// bottom edge
tableBox.Set(b2Vec2(_screenSize.width * 0.14f/PTM_RATIO, _screenSize.height * 0.09f/PTM_RATIO),
b2Vec2(_screenSize.width * 0.86f/PTM_RATIO, _screenSize.height * 0.09f/PTM_RATIO));
tableBody-&gt;CreateFixture(&amp;tableBox,0);

// top edge
tableBox.Set(b2Vec2(_screenSize.width * 0.14f/PTM_RATIO, _screenSize.height * 0.91f/PTM_RATIO),
    b2Vec2(_screenSize.width * 0.86f/PTM_RATIO, _screenSize.height * 0.91f/PTM_RATIO));
tableBody-&gt;CreateFixture(&amp;tableBox,0);</pre></div><p class="calibre6">So the same <code class="email">b2Body</code> object can have as many edges as you need. You set an edge with its start and end points (in this case, the <code class="email">b2Vec2</code> structures) and add it as a fixture to the body, with a density of <code class="email">0</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec102" class="calibre1"/>Creating the ball objects</h2></div></div></div><p class="calibre6">In the game, there is a class called <code class="email">Ball</code> that extends <code class="email">b2Sprite</code>, used for both the target balls and<a id="id316" class="calibre1"/> the cue ball. These objects are also created inside the <code class="email">initPhysics</code> method. Here is the basic configuration of that object:</p><div><pre class="programlisting">//create Box2D body
b2BodyDef bodyDef;
bodyDef.type = b2_dynamicBody;

_body = _game-&gt;getWorld()-&gt;CreateBody(&amp;bodyDef);
_body-&gt;SetLinearDamping(1.2f);
_body-&gt;SetAngularDamping(0.2f);

//create circle shape
b2CircleShape  circle;
circle.m_radius = BALL_RADIUS/PTM_RATIO;

//define fixture
b2FixtureDef fixtureDef;
fixtureDef.shape = &amp;circle;
fixtureDef.density = 5;
fixtureDef.restitution = 0.7f;

//add collision filters so only white ball can be hit by cue
if (_type == kSpriteBall) {
    fixtureDef.filter.categoryBits = 0x0010;
} else if (_type == kSpritePlayer) {
//white ball is tracked as bullet by simulation
    _body-&gt;SetBullet(true);
    fixtureDef.filter.categoryBits = 0x0100;
}

//set sprite texture
switch (_color) {
    case kColorBlack:
        this-&gt;initWithSpriteFrameName("ball_black.png");
        break;
    case kColorRed:
        this-&gt;initWithSpriteFrameName("ball_red.png");
        break;
    case kColorYellow:
        this-&gt;initWithSpriteFrameName("ball_yellow.png");
        break;
    case kColorWhite:
        this-&gt;initWithSpriteFrameName("ball_white.png");
        break;
}

_body-&gt;CreateFixture(&amp;fixtureDef);
//store the b2Sprite as the body's userData
_body-&gt;SetUserData(this);</pre></div><p class="calibre6">The <code class="email">friction</code> fixture property involves the reaction of two touching surfaces (two bodies). In<a id="id317" class="calibre1"/> this case, we want to create "friction" with the table surface, which is not a body at all. So what we need to use instead is <strong class="calibre7">damping</strong>. This <a id="id318" class="calibre1"/>will apply a similar effect to friction, but without the need for an extra surface. Damping can be applied to the linear velocity vector of a body as follows:</p><div><pre class="programlisting">_body-&gt;SetLinearDamping(1.2);</pre></div><p class="calibre6">And to the angular velocity as follows:</p><div><pre class="programlisting">_body-&gt;SetAngularDamping(0.2);</pre></div><p class="calibre6">Also, the white ball is set to be a bullet:</p><div><pre class="programlisting">_body-&gt;SetBullet(true);</pre></div><p class="calibre6">This will make the simulation pay extra attention to this object in terms of collision. We could make all balls in the game behave as bullets, but this is not only unnecessary (something revealed through testing) but also not very processing-friendly.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch08lvl2sec103" class="calibre1"/>Creating collision filters</h2></div></div></div><p class="calibre6">In the <code class="email">ball</code> object, there is a <code class="email">filter</code> property inside the fixture definition that we use to mask <a id="id319" class="calibre1"/>collisions. Meaning we determine what bodies can collide with each other. The cue ball receives a different value for <code class="email">categoryBits</code> than the other balls.</p><div><pre class="programlisting">fixtureDef.filter.categoryBits = 0x0100;</pre></div><p class="calibre6">When we create the cue body, we set a <code class="email">maskBits</code> property in its fixture definition as follows:</p><div><pre class="programlisting">fixtureDef.filter.maskBits = 0x0100;</pre></div><p class="calibre6">We set this to the same value as the white ball's <code class="email">categoryBits</code>.</p><p class="calibre6">The result of all this? Now the cue can only hit bodies with the same <code class="email">categoryBits</code>, which here means the cue can only collide with the white ball.</p><p class="calibre6">It is possible to add more than one category to a mask with a bitwise <code class="email">|</code> option, as seen here:</p><div><pre class="programlisting">fixtureDef.filter.maskBits = 0x0100 | 0x0010;</pre></div><p class="calibre6">Or to collide with everything except the cue ball, for instance, as seen in the following line:</p><div><pre class="programlisting">fixtureDef.filter.maskBits = 0xFFFF &amp; ~0x0100;</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_7"><a id="ch08lvl2sec104" class="calibre1"/>Creating the cue</h2></div></div></div><p class="calibre6">The cue<a id="id320" class="calibre1"/> ball also extends <code class="email">b2Sprite</code>, and its body is set as a box.</p><div><pre class="programlisting">//create body
b2BodyDef bodyDef;
bodyDef.type = b2_dynamicBody;

_body = _game-&gt;getWorld()-&gt;CreateBody(&amp;bodyDef);
_body-&gt;SetLinearDamping(8);
_body-&gt;SetAngularDamping(5);

//Define shape
b2PolygonShape box;
box.SetAsBox(BALL_RADIUS * 21 /PTM_RATIO, BALL_RADIUS * 0.2 / PTM_RATIO);

//Define fixture
b2FixtureDef fixtureDef;
fixtureDef.shape = &amp;box;
fixtureDef.filter.maskBits = 0x0100;
fixtureDef.density = 10;
fixtureDef.restitution = 1;
_body-&gt;CreateFixture(&amp;fixtureDef);
_body-&gt;SetUserData(this);</pre></div><p class="calibre6">It has very high damping values because, in the rare occasions when the player misses the cue ball, the cue will not fly off the screen but halt a few pixels from the white ball.</p><p class="calibre6">If we wanted to create the cue ball as a trapezium or a triangle, we would need to give the <code class="email">b2PolygonShape</code> option the vertices we want. Here's an example of this:</p><div><pre class="programlisting">b2Vec2 vertices[3];
vertices[0].Set(0.0f, 0.0f);
vertices[1].Set(1.0f, 0.0f);
vertices[2].Set(0.0f, 1.0f);
int32 count = 3;

b2PolygonShape triangle;
triangle.Set(vertices, count);</pre></div><p class="calibre6">And the vertices must be added counterclockwise to the array. Meaning, if we add the top vertex of the triangle first, the next vertex must be the one to the left.</p><p class="calibre6">Once all the elements are in place, the debug draw looks like this:</p><div><img src="img/00032.jpeg" alt="Creating the cue" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_8"><a id="ch08lvl2sec105" class="calibre1"/>Creating a contact listener</h2></div></div></div><p class="calibre6">Besides <a id="id321" class="calibre1"/>collision filters, one other feature in Box2D that helps with collision management is the creation of a contact listener.</p><p class="calibre6">Inside the <code class="email">initPhysics</code> method, we create the <code class="email">world</code> object like this:</p><div><pre class="programlisting">b2Vec2 gravity;
gravity.Set(0.0f, 0.0f);
_world = new b2World(gravity);

_world-&gt;SetAllowSleeping(true);
_world-&gt;SetContinuousPhysics(true);
_collisionListener = new CollisionListener();
_world-&gt;SetContactListener(_collisionListener);</pre></div><p class="calibre6">Our <code class="email">CollisionListener</code> class extends the Box2D <code class="email">b2ContactListener</code> class, and it must implement<a id="id322" class="calibre1"/> at least one of the following methods:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">void BeginContact(b2Contact* contact);</code></li><li class="listitem"><code class="email">void EndContact(b2Contact* contact);</code></li><li class="listitem"><code class="email">void PreSolve(b2Contact* contact, const b2Manifold* oldManifold);</code></li><li class="listitem"><code class="email">void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse);</code></li></ul></div><p class="calibre6">These events are all related to a contact (collision) and are fired at different stages of a contact.</p><div><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre6">Sensor objects can only ever fire the <code class="email">BeginContact</code> and <code class="email">EndContact</code> events.</p></div><p class="calibre6">In our game, we implement two of these methods. The first is:</p><div><pre class="programlisting">void CollisionListener::BeginContact(b2Contact* contact) {
    b2Body * bodyA = contact-&gt;GetFixtureA()-&gt;GetBody();
    b2Body * bodyB = contact-&gt;GetFixtureB()-&gt;GetBody();

    b2Sprite * spriteA = (b2Sprite *) bodyA-&gt;GetUserData();
    b2Sprite * spriteB = (b2Sprite *) bodyB-&gt;GetUserData();
    
    if (spriteA &amp;&amp; spriteB) {
        //track collision between balls and pockets
        if (spriteA-&gt;getType() == kSpritePocket) {
            spriteB-&gt;setVisible(false);
        } else if (spriteB-&gt;getType() == kSpritePocket) {
            spriteA-&gt;setVisible(false);
        } else if (spriteA-&gt;getType() == kSpriteBall &amp;&amp;
            spriteB-&gt;getType() == kSpriteBall) {
            if (spriteA-&gt;mag() &gt; 10 || spriteB-&gt;mag() &gt; 10) {
            SimpleAudioEngine::getInstance()-&gt;playEffect("ball.wav");
            }
        } else if ((spriteA-&gt;getType() == kSpriteBall &amp;&amp;
                    spriteB-&gt;getType() == kSpritePlayer) ||
                    (spriteB-&gt;getType() == kSpriteBall &amp;&amp;
                    spriteA-&gt;getType() == kSpritePlayer)) {
            if (spriteA-&gt;mag() &gt; 10 || spriteB-&gt;mag() &gt; 10) {
               SimpleAudioEngine::getInstance()-&gt;playEffect("ball.wav");
            }
        }
    }
}</pre></div><p class="calibre6">You can <a id="id323" class="calibre1"/>see now how important the <code class="email">userData</code> property is. We can quickly access sprites attached to the bodies listed in the <code class="email">b2Contact</code> object through the <code class="email">userData</code> property.</p><p class="calibre6">Besides that, all our sprites have a <code class="email">_type</code> property that behaves like identifying tags in our logic. Note that you could certainly use the Cocos2d-x tags for that, but I find that at times, if you can combine the <code class="email">Sprite</code> tags with their <code class="email">_type</code> value, you may produce interesting sorting logic.</p><p class="calibre6">So, in <code class="email">BeginContact</code>, we track the collisions between balls and pockets. But we also track collision between balls. In the first case, the balls are turned invisible when they touch the pockets. And, in the second case, we play a sound effect whenever two balls touch each other, but only if they are at a certain speed (we determine that through a <code class="email">b2Sprite</code> helper method that retrieves the squared magnitude of a sprite's velocity vector).</p><p class="calibre6">The other method in our listener is:</p><div><pre class="programlisting">void CollisionListener::PreSolve(b2Contact* contact, const b2Manifold* oldManifold)  {
    
    b2Body * bodyA = contact-&gt;GetFixtureA()-&gt;GetBody();
    b2Body * bodyB = contact-&gt;GetFixtureB()-&gt;GetBody();
    
    b2Sprite * spriteA = (b2Sprite *) bodyA-&gt;GetUserData();
    b2Sprite * spriteB = (b2Sprite *) bodyB-&gt;GetUserData();
    
        
    if (spriteA &amp;&amp; spriteB) {
        
    //track collision between player and cue ball
        if (spriteA-&gt;getType() == kSpriteCue &amp;&amp; spriteA-&gt;mag() &gt; 2) {
            if (spriteB-&gt;getType() == kSpritePlayer &amp;&amp; spriteA-&gt;isVisible()) {
                SimpleAudioEngine::getInstance()-&gt;playEffect("hit.wav");
                spriteA-&gt;setVisible(false);
                spriteB-&gt;getGame()-&gt;setCanShoot(false);
            }
        } else if (spriteB-&gt;getType() == kSpriteCue &amp;&amp; spriteA-&gt;mag()&gt; 2) {
            if (spriteA-&gt;getType() == kSpritePlayer &amp;&amp; spriteB-&gt;isVisible()) {
                SimpleAudioEngine::getInstance()-&gt;playEffect("hit.wav");
                spriteB-&gt;setVisible(false);
                spriteA-&gt;getGame()-&gt;setCanShoot(false);
            }
        } 
    
    }
}</pre></div><p class="calibre6">Here, we<a id="id324" class="calibre1"/> listen to a collision before its reactions are calculated. If there is a collision between the cue and white ball, we play a sound effect and we hide the cue.</p><div><h3 class="title2"><a id="note17" class="calibre1"/>Note</h3><p class="calibre6">If you want to force your own logic to the collision reaction and override Box2D on this, you should do so in the <code class="email">PreSolve</code> method. In this game, however, we could have added all this collision logic to the <code class="email">BeginContact</code> method and it would work just as well.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_9"><a id="ch08lvl2sec106" class="calibre1"/>The game controls</h2></div></div></div><p class="calibre6">In the<a id="id325" class="calibre1"/> game, the player must click on the white ball and then drag his or her finger to activate the cue ball. The farther the finger gets from the white ball, the more powerful the shot will be.</p><p class="calibre6">So let's add the events to handle user input.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec115" class="calibre1"/>Time for action – adding the touch events</h1></div></div></div><p class="calibre6">We'll <a id="id326" class="calibre1"/>deal with <code class="email">onTouchBegan</code> first.</p><div><ol class="orderedlist"><li class="listitem" value="1">In the <code class="email">onTouchBegan</code> method, we start by updating the game state:<div><pre class="programlisting">bool GameLayer::onTouchBegan(Touch * touch, Event * event) {

    if (!_running) return true;
    
    if (_gameState == kGameOver) {
        if (_gameOver-&gt;isVisible()) _gameOver-&gt;setVisible(false);
        resetGame();
        return true;
    }</pre></div></li><li class="listitem" value="2">Next, we check on the value of <code class="email">_canShoot</code>. This returns <code class="email">true</code> if the white ball is not moving.<div><pre class="programlisting">if (!_canShoot) return true;</pre></div></li><li class="listitem" value="3">Next, we determine whether the touch is landing on the white ball. If it is, we start the game if it is not currently running yet and we make our timer visible. Here's the code to do this:<div><pre class="programlisting">if (touch) {
        
    auto tap = touch-&gt;getLocation();
    auto playerPos = _player-&gt;getPosition();
    float diffx = tap.x - playerPos.x;
    float diffy = tap.y - playerPos.y;
    float diff = pow(diffx, 2) + pow(diffy, 2);
    if (diff &lt; pow(BALL_RADIUS * 4, 2)) {
        if (_gameState != kGamePlay) {
            _gameState = kGamePlay;
            if (_intro-&gt;isVisible()) _intro-&gt;setVisible(false);
            _timer-&gt;setVisible(true);
        }
    }
}</pre></div><p class="calibre13">Note that we use a larger radius for the white ball in our logic (four times larger). This is because we don't want the target area to be too small, since this game will run on both iPhones and iPads. We want the player to comfortably hit the white ball with his or her finger.</p></li><li class="listitem" value="4">We <a id="id327" class="calibre1"/>store where in the ball the point lies. This way, the player can hit the ball at different spots, causing it to move at different angles:<div><pre class="programlisting">//make point lie within ball
if (diff &gt; pow(BALL_RADIUS * 2, 2)) {
    float angle = atan2(diffy, diffx);
    _cueStartPoint = Vec2(
            playerPos.x + BALL_RADIUS * 0.8f * cos(angle),
            playerPos.y + BALL_RADIUS * 0.8f * sin(angle));
} else {
    _cueStartPoint = playerPos;
}</pre></div><p class="calibre13">Since we made the white ball a much larger target for our <code class="email">touch</code> event, now we must make sure the actual point picked by the player lies within the ball. So we may have to make some adjustments here.</p></li><li class="listitem" value="5">We pass the point to our <code class="email">LineContainer</code> object and we prepare the cue body to be used, as follows:<div><pre class="programlisting">_lineContainer-&gt;setBallPoint(_cueStartPoint);
_cue-&gt;getBody()-&gt;SetLinearVelocity(b2Vec2(0,0));
_cue-&gt;getBody()-&gt;SetAngularVelocity(0.0);
_touch = touch;</pre></div><p class="calibre13">We once again have a <code class="email">LineContainer</code> node so we can draw a dashed line between the cue and the spot on the ball where the cue will hit. This serves as a visual aid for the player to prepare his or her shot. The visual aid effect is demonstrated here:</p><div><img src="img/00033.jpeg" alt="Time for action – adding the touch events" class="calibre9"/></div><p class="calibre14"> </p></li><li class="listitem" value="6">In <code class="email">onTouchMoved</code>, we only need to move the cue body based on the position of the player's finger. So we calculate the distance between the moving touch and the <a id="id328" class="calibre1"/>white ball. If the cue body is still too close to the ball, we set its <code class="email">body</code> object to <code class="email">sleep</code> and its <code class="email">texture</code> object to <code class="email">invisible</code>.<div><pre class="programlisting">void GameLayer::onTouchMoved(Touch * touch, Event * event) {
   if (touch &amp;&amp; touch == _touch) {
         Point tap = touch-&gt;getLocation();
         float diffx = tap.x - _player-&gt;getPositionX();
         float diffy = tap.y - _player-&gt;getPositionY();
         if (pow(diffx,2) + pow(diffy,2) &lt; pow(BALL_RADIUS * 2,2)) {
            _usingCue = false;
            _lineContainer-&gt;setDrawing(false);
            _cue-&gt;setVisible(false);
           _cue-&gt;getBody()-&gt;SetAwake(false);
         } else {
           _usingCue = true;
           _cue-&gt;setVisible(true);
           _lineContainer-&gt;setDrawing(true);
          placeCue(tap);
          _cue-&gt;getBody()-&gt;SetAwake(true);
         }
   }
}</pre></div></li><li class="listitem" value="7">Otherwise, we awaken the body and call the <code class="email">placeCue</code> method as follows:<div><pre class="programlisting">void GameLayer::placeCue(Point position) {
    float diffx = _cueStartPoint.x - position.x;
    float diffy = _cueStartPoint.y - position.y;
    
    float angle = atan2(diffy, diffx);
   float distance = sqrt(pow (diffx, 2) + pow(diffy, 2));
    
    _pullBack = distance * 0.5f;
    Point cuePosition = Vec2(
        _cueStartPoint.x - (BALL_RADIUS * 21 + _pullBack) * cos(angle),
        _cueStartPoint.y - (BALL_RADIUS * 21 + _pullBack) * sin(angle)
    );
    
    _cue-&gt;getBody()-&gt;SetTransform(
        b2Vec2(cuePosition.x/PTM_RATIO, cuePosition.y/PTM_RATIO), 
        angle);

    _lineContainer-&gt;setCuePoint(Vec2(
        _cueStartPoint.x - ( _pullBack) * cos(angle),
     _cueStartPoint.y - ( _pullBack) * sin(angle)));
}</pre></div><p class="calibre13">This method then calculates the angle and position of the cue body and transforms<a id="id329" class="calibre1"/> the cue's <code class="email">b2Body</code> method accordingly. The <code class="email">SetTransform</code> option of a <code class="email">b2Body</code> method takes care of both its position and angle.</p></li><li class="listitem" value="8">Finally, in <code class="email">onTouchEnded</code>, we let go of the cue body as follows:<div><pre class="programlisting">void GameLayer::onTouchEnded(Touch* touch, Event* event) {
    
    if (_usingCue &amp;&amp; _touch) {
        auto cueBody = _cue-&gt;getBody();
        float angle = cueBody-&gt;GetAngle();
        
        //release cue!
        cueBody-&gt;ApplyLinearImpulse(
            b2Vec2 (_pullBack * cos(angle) * SHOT_POWER,
            _pullBack * sin(angle) * SHOT_POWER),
            cueBody-&gt;GetWorldCenter());
    }
    
    _usingCue = false;
    _touch = nullptr;
    _lineContainer-&gt;setDrawing(false);
}</pre></div><p class="calibre13">We use <code class="email">ApplyLinearImpulse</code>. This method receives a vector for the impulse to be applied and the position on the body where this impulse should be applied.</p><p class="calibre13">The <code class="email">_pullback</code> variable stores the information of how far the cue body was from the ball when the player released the cue body. The farther it was, the strongest the shot will be.</p></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec107" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We added the <code class="email">touch</code> events that allow the player to hit the white ball with the cue body. The process is a very simple one. We first need to make sure the player is touching the white ball; then we move the cue body as the player drags his or her finger. Finally, when the touch is released, we make the cue spring towards the white ball with <code class="email">ApplyLinearImpulse</code>.</p><p class="calibre6">We may also move a body in Box2D by using <code class="email">SetLinearVelocity</code> or <code class="email">ApplyForce</code>, each with<a id="id330" class="calibre1"/> subtle and not-so-subtle differences. I recommend that you play around with these.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec108" class="calibre1"/>The main loop</h2></div></div></div><p class="calibre6">As I<a id="id331" class="calibre1"/> showed you before, the simulation only requires that you call its <code class="email">Step()</code> method inside the main loop. Box2D takes care of all of its side of the bargain.</p><p class="calibre6">What remains usually is the rest of the game logic: scoring, game states, and updating your sprites to match the <code class="email">b2Bodies</code> method.</p><p class="calibre6">It's important to call the <code class="email">update</code> method of each ball and cue. This is what our <code class="email">b2Sprite update</code> method looks like:</p><div><pre class="programlisting">void b2Sprite::update(float dt) {
    if (_body &amp;&amp; this-&gt;isVisible()) {
        this-&gt;setPositionX(_body-&gt;GetPosition().x * PTM_RATIO);
        this-&gt;setPositionY(_body-&gt;GetPosition().y * PTM_RATIO);
        this-&gt;setRotation(_RADIANS_TO_DEGREES(-1 * _body-&gt;GetAngle()));
    }
}</pre></div><p class="calibre6">All you need to do is make sure the <code class="email">Sprite</code> method matches the information in the <code class="email">b2Body</code> object. And make sure that you convert meters back to pixels when you do so.</p><p class="calibre6">So let's add our main loop.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec116" class="calibre1"/>Time for action – adding the main loop</h1></div></div></div><p class="calibre6">It's inside <a id="id332" class="calibre1"/>our main loop that we update our <code class="email">b2World</code> object.</p><div><ol class="orderedlist"><li class="listitem" value="1">Start by updating the simulation as follows:<div><pre class="programlisting">void GameLayer::update(float dt) {
    
   if (!_running) return;
   if (_gameState == kGameOver) return;
    _world-&gt;Step(dt, 10, 10);</pre></div></li><li class="listitem" value="2">Next, we need to determine if the game has finished by checking on the number of balls currently in play. We use the following for that:<div><pre class="programlisting">//track invisible objects
for (auto ball : _balls) {
   if (!ball-&gt;isVisible() &amp;&amp; ball-&gt;getInPlay()) {
        ball-&gt;setInPlay(false);
        ball-&gt;hide();
        //count down balls
        _ballsInPlay--;
        SimpleAudioEngine::getInstance()-&gt;playEffect("drop.wav");
        if (_ballsInPlay == 0) {
            _gameState = kGameOver;
            _gameOver-&gt;setVisible(true);
        }
    } else {
        ball-&gt;update(dt);
    }
}</pre></div></li><li class="listitem" value="3">Next, we continue to update the sprites as follows:<div><pre class="programlisting">if (!_cue-&gt;isVisible())  {
    _cue-&gt;hide();
} else {
    _cue-&gt;update(dt);
}
if (!_player-&gt;isVisible()) {
    _player-&gt;reset();
    _player-&gt;setVisible(true);
    SimpleAudioEngine::getInstance()-&gt;playEffect("whitedrop.wav");
}
_player-&gt;update(dt);</pre></div></li><li class="listitem" value="4">And we also determine when it's time to allow the player a new shot. I decided to only let that happen if the white ball has stopped. And the quickest way to determine that is to check on its vector. Here's how:<div><pre class="programlisting">//check to see if player ball is slow enough for a new shot
if (_player-&gt;mag() &lt; 0.5f &amp;&amp; !_canShoot) {
    _player-&gt;getBody()-&gt;SetLinearVelocity(b2Vec2_zero);
    _player-&gt;getBody()-&gt;SetAngularVelocity(0);
    _canShoot = true;
}</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec109" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We added our main loop. This will update the Box2D simulation and then it's up to us to take care of positioning our sprites based on the resulting information.</p><div><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre6">One very important aspect of Box2D is understanding what can be changed inside a <code class="email">b2World::Step</code> call and what can't.</p><p class="calibre6">For instance, a body cannot be made inactive (<code class="email">b2Body::SetActive</code>) or be destroyed (<code class="email">b2World::DestroyBody</code>) inside a step. You will need to check on conditions outside the step to make these changes. For instance, in our game, we check<a id="id333" class="calibre1"/> to see if the ball sprites are visible or not, and if not then we set their bodies as inactive. And all this is done <em class="calibre8">after</em> the call to <code class="email">b2World::Step</code>.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec110" class="calibre1"/>Adding a timer to our game</h2></div></div></div><p class="calibre6">In <a id="id334" class="calibre1"/>MiniPool, we count the number of seconds it takes the player to clear the table. Let me show you how to do that.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec117" class="calibre1"/>Time for action – creating a timer</h1></div></div></div><p class="calibre6">We create <a id="id335" class="calibre1"/>timers in pretty much the same way we create our main loop.</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we add a second scheduled event by adding this line to our <code class="email">GameLayer</code> constructor:<div><pre class="programlisting">this-&gt;schedule(CC_SCHEDULE_SELECTOR(GameLayer::ticktock), 1.5f);</pre></div></li><li class="listitem" value="2">With this, we create a separate timer that will run the <code class="email">ticktock</code> method every <code class="email">1.5</code> seconds (I decided in the end that <code class="email">1.5</code> seconds looked better).</li><li class="listitem" value="3">The method keeps updating the value of the <code class="email">_time</code> property and displaying it in the <code class="email">_timer</code> label.<div><pre class="programlisting">void GameLayer::ticktock(float dt) {
    if (_gameState == kGamePlay) {
        _time++;
        _timer-&gt;setString(std::to_string(_time));
    }
}</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec111" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We added a timer to our game by scheduling a second update—specifying the time interval we wanted—using the <code class="email">schedule</code> method.</p><p class="calibre6">If you wish to remove a timer, all you need to do is call the <code class="email">unschedule(SEL_SCHEDULE selector)</code> method of nodes anywhere in your class.</p><p class="calibre6">Now, let's take our Box2D game to Android.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec118" class="calibre1"/>Time for action – running the game in Android</h1></div></div></div><p class="calibre6">Follow<a id="id336" class="calibre1"/> these steps to deploy a Box2D game to Android:</p><div><ol class="orderedlist"><li class="listitem" value="1">Open the <code class="email">Android.mk</code> file in a text editor (you'll find it in the folder <code class="email">proj.android/jni</code>).</li><li class="listitem" value="2">Edit the lines in <code class="email">LOCAL_SRC_FILES</code> to read:<div><pre class="programlisting">LOCAL_SRC_FILES := hellocpp/main.cpp \
                   ../../Classes/AppDelegate.cpp \
                  ../../Classes/GLES-Render.cpp \
                   ../../Classes/b2Sprite.cpp \
                   ../../Classes/Ball.cpp \
                   ../../Classes/CollisionListener.cpp \
                   ../../Classes/Cue.cpp \
                   ../../Classes/LineContainer.cpp \
                   ../../Classes/GameLayer.cpp </pre></div></li><li class="listitem" value="3">Open the manifest file and set the app orientation to <code class="email">portrait</code>.</li><li class="listitem" value="4">Import the game into Eclipse and wait till all classes are compiled.</li><li class="listitem" value="5">Build and run your application.</li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec112" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">That was it. There is no difference between building a game that uses Box2D and one that does not. The Box2D API is already included in the <code class="email">make</code> file, in the line where the classes in the external folder are imported.</p><p class="calibre6">And, of course, you don't need to add the <code class="email">GLES-Render</code> class in your final project.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec113" class="calibre1"/>Have a go hero</h2></div></div></div><p class="calibre6">A few changes to make gameplay more interesting could be: add a limit to the number of times the white ball can hit a pocket; and another option is to have the timer work as a countdown one, so the player has a limited time to clear the table before time runs out.</p><p class="calibre6">Also, this game could do with a few animations. An <code class="email">Action</code> method to scale down and fade out a ball when it hits a pocket would look very nice.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec114" class="calibre1"/>Pop quiz</h2></div></div></div><p class="calibre6">Q1. What is the main object in a Box2D simulation?</p><div><ol class="orderedlist"><li class="listitem" value="1"><code class="email">b2Universe</code>.</li><li class="listitem" value="2"><code class="email">b2d</code>.</li><li class="listitem" value="3"><code class="email">b2World</code>.</li><li class="listitem" value="4"><code class="email">b2Simulation</code>.</li></ol><div></div><p class="calibre6">Q2. A <code class="email">b2Body</code> object can be of which type?</p><div><ol class="orderedlist"><li class="listitem" value="1"><code class="email">b2_dynamicBody</code>, <code class="email">b2_sensorBody</code>, <code class="email">b2_liquidBody</code>.</li><li class="listitem" value="2"><code class="email">b2_dynamicBody</code>, <code class="email">b2_staticBody</code>, <code class="email">b2_kinematicBody</code>.</li><li class="listitem" value="3"><code class="email">b2_staticBody</code>, <code class="email">b2_kinematicBody</code>, <code class="email">b2_debugBody</code>.</li><li class="listitem" value="4"><code class="email">b2_kinematicBody</code>, <code class="email">b2_transparentBody</code>, <code class="email">b2_floatingBody</code>.</li></ol><div></div><p class="calibre6">Q3. Which of the following list of properties can be set in a fixture definition?</p><div><ol class="orderedlist"><li class="listitem" value="1">Density, friction, restitution, shape.</li><li class="listitem" value="2">Position, density, bullet state.</li><li class="listitem" value="3">Angular damping, active state, friction.</li><li class="listitem" value="4">Linear damping, restitution, fixed rotation.</li></ol><div></div><p class="calibre6">Q4. If two bodies have the same unique value for their <code class="email">maskBits</code> property in their fixture definition, this means:</p><div><ol class="orderedlist"><li class="listitem" value="1">The two bodies can never collide.</li><li class="listitem" value="2">The two bodies will only trigger begin contact events.</li><li class="listitem" value="3">The two bodies can only collide with each other.</li><li class="listitem" value="4">The two bodies will only trigger end contact events.</li></ol><div></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec119" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">Nowadays, it seems like everybody in the world has played or will play a physics-based game at some point in their lives. Box2D is by far the most popular engine in the casual games arena. The commands you learned here can be found in pretty much every port of the engine, including a JavaScript one that is growing in popularity as we speak.</p><p class="calibre6">Setting up the engine and getting it up and running is remarkably simple—perhaps too much so. A lot of testing and value tweaking goes into developing a Box2D game and pretty soon you learn that keeping the engine performing as you wish is the most important skill to master when developing physics-based games. Picking the right values for friction, density, restitution, damping, time step, PTM ratio, and so on can make or break your game.</p><p class="calibre6">In the next chapter, we'll continue to use Box2D, but we'll focus on what else Cocos2d-x can do to help us organize our games.</p></div></body></html>