<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Fun with Sprites – Sky Defense</h1></div></div></div><p class="calibre6">
<em class="calibre8">Time to build our second game! This time, you will get acquainted with the power of actions in Cocos2d-x. I'll show you how an entire game could be built just by running the various action commands contained in Cocos2d-x to make your sprites move, rotate, scale, fade, blink, and so on. And you can also use actions to animate your sprites using multiple images, like in a movie. So let's get started.</em>
</p><p class="calibre6">In this chapter, you will learn:</p><div><ul class="itemizedlist"><li class="listitem">How to optimize the development of your game with sprite sheets</li><li class="listitem">How to use bitmap fonts in your game</li><li class="listitem">How easy it is to implement and run actions</li><li class="listitem">How to scale, rotate, swing, move, and fade out a sprite</li><li class="listitem">How to load multiple <code class="email">.png</code> files and use them to animate a sprite</li><li class="listitem">How to create a universal game with Cocos2d-x</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec47" class="calibre1"/>The game – sky defense</h1></div></div></div><p class="calibre6">Meet our<a id="id122" class="calibre1"/> stressed-out city of...your name of choice here. It's a beautiful day when suddenly the sky begins to fall. There are meteors rushing toward the city and it is your job to keep it safe.</p><p class="calibre6">The player in this game can tap the screen to start growing a bomb. When the bomb is big enough to be activated, the player taps the screen again to detonate it. Any nearby meteor will explode into a million pieces. The bigger the bomb, the bigger the detonation, and the more meteors can be taken out by it. But the bigger the bomb, the longer it takes to grow it.</p><p class="calibre6">But it's not just bad news coming down. There are also health packs dropping from the sky and if you allow them to reach the ground, you'll recover some of your energy.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec44" class="calibre1"/>The game settings</h2></div></div></div><p class="calibre6">This is a<a id="id123" class="calibre1"/> universal game. It is designed for the iPad retina screen and it will be scaled down to fit all the other screens. The game will be played in landscape mode, and it will not need to support multitouch.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec45" class="calibre1"/>The start project</h2></div></div></div><p class="calibre6">Go <a id="id124" class="calibre1"/>ahead and download the file <code class="email">4198_04_START_PROJECT.zip</code> from this book's support page (<a class="calibre1" href="http://www.packtpub.com/support">www.packtpub.com/support</a>). When you uncompress the file, you will find the basic project already set up and ready for you to work on.</p><p class="calibre6">The steps involved in creating this project are similar to the ones I showed you in our previous game. The command line I used was:</p><div><pre class="programlisting">
<strong class="calibre7">cocos new SkyDefense -p com.rengelbert.SkyDefense -l cpp -d /Users/rengelbert/Desktop/SkyDefense</strong>
</pre></div><p class="calibre6">In Xcode you must set the <strong class="calibre7">Devices</strong> field in <strong class="calibre7">Deployment Info</strong> to <strong class="calibre7">Universal</strong>, and the <strong class="calibre7">Device Family</strong> field is set to <strong class="calibre7">Universal</strong>. And in <code class="email">RootViewController.mm</code>, the supported interface orientation is set to <strong class="calibre7">Landscape</strong>.</p><p class="calibre6">The game we are going to build requires only one class, <code class="email">GameLayer.cpp</code>, and you will find that the interface for this class already contains all the information it needs.</p><p class="calibre6">Also, some of the more trivial or old-news logic is already in place in the implementation file as well. But I'll go over this as we work on the game.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec46" class="calibre1"/>Adding screen support for a universal app</h2></div></div></div><p class="calibre6">In<a id="id125" class="calibre1"/> the previous game, we targeted iPad size screens only. Now things get a bit more complicated as we add support for smaller screens in our universal game, as well as some of the most common Android screen sizes.</p><p class="calibre6">So open <code class="email">AppDelegate.cpp</code>. Inside the <code class="email">applicationDidFinishLaunching</code> method, we now have the following code:</p><div><pre class="programlisting">auto screenSize = glview-&gt;getFrameSize();
auto designSize = Size(2048, 1536);
glview-&gt;setDesignResolutionSize(designSize.width, designSize.height,  ResolutionPolicy::EXACT_FIT);
std::vector&lt;std::string&gt; searchPaths;
if (screenSize.height &gt; 768) {
   searchPaths.push_back("ipadhd");
   director-&gt;setContentScaleFactor(1536/designSize.height);
} else if (screenSize.height &gt; 320) {
   searchPaths.push_back("ipad");
   director-&gt;setContentScaleFactor(768/designSize.height);
} else {
   searchPaths.push_back("iphone");
   director-&gt;setContentScaleFactor(380/designSize.height);
}
auto fileUtils = FileUtils::getInstance();
fileUtils-&gt;setSearchPaths(searchPaths);</pre></div><p class="calibre6">Once<a id="id126" class="calibre1"/> again, we tell our <code class="email">GLView</code> object (our OpenGL view) that we designed the game for a certain screen size (the iPad retina screen) and once again, we want our game screen to resize to match the screen on the device (<code class="email">ResolutionPolicy::EXACT_FIT</code>).</p><p class="calibre6">Then we determine where to load our images from, based on the device's screen size. We have art for iPad retina, then for regular iPad which is shared by iPhone retina, and for the regular iPhone.</p><p class="calibre6">We end by setting the scale factor based on the designed target.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch04lvl2sec47" class="calibre1"/>Adding background music</h2></div></div></div><p class="calibre6">Still<a id="id127" class="calibre1"/> inside <code class="email">AppDelegate.cpp</code>, we load the sound files we'll use in the game, including a <code class="email">background.mp3</code> (courtesy of Kevin MacLeod from <a class="calibre1" href="http://incompetech.com">incompetech.com</a>), which we load through the command:</p><div><pre class="programlisting">
<strong class="calibre7">auto audioEngine = SimpleAudioEngine::getInstance();</strong>
<strong class="calibre7">audioEngine-&gt;preloadBackgroundMusic(fileUtils-&gt;fullPathForFilename("background.mp3").c_str());</strong>
</pre></div><p class="calibre6">We end by setting the effects' volume down a tad:</p><div><pre class="programlisting">//lower playback volume for effects
audioEngine-&gt;setEffectsVolume(0.4f);</pre></div><p class="calibre6">For background music volume, you must use <code class="email">setBackgroundMusicVolume</code>. If you create some sort of volume control in your game, these are the calls you would make to adjust the volume based on the user's preference.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch04lvl2sec48" class="calibre1"/>Initializing the game</h2></div></div></div><p class="calibre6">Now<a id="id128" class="calibre1"/> back to <code class="email">GameLayer.cpp</code>. If you take a look inside our <code class="email">init</code> method, you will see that the game initializes by calling three methods: <code class="email">createGameScreen</code>, <code class="email">createPools</code>, and <code class="email">createActions</code>.</p><p class="calibre6">We'll create all our screen elements inside the first method, and then create object pools so we don't instantiate any sprite inside the main loop; and we'll create all the main actions used in our game inside the <code class="email">createActions</code> method.</p><p class="calibre6">And as soon as the game initializes, we start playing the background music, with its <code class="email">should loop</code> parameter set to <code class="email">true</code>:</p><div><pre class="programlisting">SimpleAudioEngine::getInstance()-  &gt;playBackgroundMusic("background.mp3", true);</pre></div><p class="calibre6">We once<a id="id129" class="calibre1"/> again store the screen size for future reference, and we'll use a <code class="email">_running</code> Boolean for game states.</p><p class="calibre6">If you run the game now, you should only see the background image:</p><div><img src="img/00011.jpeg" alt="Initializing the game" class="calibre9"/></div><p class="calibre10"> </p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec48" class="calibre1"/>Using sprite sheets in Cocos2d-x</h1></div></div></div><p class="calibre6">A<a id="id130" class="calibre1"/> sprite sheet is a way to group multiple images together in<a id="id131" class="calibre1"/> one image file. In order to texture a sprite with one of these images, you must have the information of where in the sprite sheet that particular image is found (its rectangle).</p><p class="calibre6">Sprite sheets are often organized in two files: the image one and a data file that describes where in the image you can find the individual textures.</p><p class="calibre6">I used <code class="email">TexturePacker</code> to create these files for the game. You can find them inside the <code class="email">ipad</code>, <code class="email">ipadhd</code>, and <code class="email">iphone</code> folders inside <code class="email">Resources</code>. There is a <code class="email">sprite_sheet.png</code> file for the image and a <code class="email">sprite_sheet.plist</code> file that describes the individual frames inside the image.</p><p class="calibre6">This is what the <code class="email">sprite_sheet.png</code> file looks like:</p><div><img src="img/00012.jpeg" alt="Using sprite sheets in Cocos2d-x" class="calibre9"/></div><p class="calibre10"> </p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec49" class="calibre1"/>Batch drawing sprites</h2></div></div></div><p class="calibre6">In <a id="id132" class="calibre1"/>Cocos2d-x, sprite sheets can be used in conjunction <a id="id133" class="calibre1"/>with a specialized node, called <code class="email">SpriteBatchNode</code>. This node can be used whenever you wish to use multiple sprites that share the same source image inside the same node. So you could have multiple instances of a <code class="email">Sprite</code> class that uses a <code class="email">bullet.png</code> texture for instance. And if the source image is a sprite sheet, you can have multiple instances of sprites displaying as many different textures as you could pack inside your sprite sheet.</p><p class="calibre6">With <code class="email">SpriteBatchNode</code>, you can substantially reduce the number of calls during the rendering stage of your game, which will help when targeting less powerful systems, though not noticeably in more modern devices.</p><p class="calibre6">Let me show you how to create a <code class="email">SpriteBatchNode</code>.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec49" class="calibre1"/>Time for action – creating SpriteBatchNode</h1></div></div></div><p class="calibre6">Let's begin<a id="id134" class="calibre1"/> implementing the <code class="email">createGameScreen</code> method in <code class="email">GameLayer.cpp</code>. Just below the lines that add the <code class="email">bg</code> sprite, we instantiate our batch node:</p><div><pre class="programlisting">void GameLayer::createGameScreen() {

  //add bg
  auto bg = Sprite::create("bg.png");
  ...

  SpriteFrameCache::getInstance()-&gt;
  addSpriteFramesWithFile("sprite_sheet.plist");
  
  _gameBatchNode = SpriteBatchNode::create("sprite_sheet.png");
  this-&gt;addChild(_gameBatchNode);</pre></div><p class="calibre6">In order<a id="id135" class="calibre1"/> to create the batch node from a sprite sheet, we first load all the frame information described by the <code class="email">sprite_sheet.plist</code> file into <code class="email">SpriteFrameCache</code>. And then we create the batch node with the <code class="email">sprite_sheet.png</code> file, which is the source texture shared by all sprites added to this batch node. (The background image is not part of the sprite sheet, so it's added separately before we add <code class="email">_gameBatchNode</code> to GameLayer.)</p><p class="calibre6">Now we can start putting stuff inside <code class="email">_gameBatchNode</code>.</p><div><ol class="orderedlist"><li class="listitem" value="1">First, the city:<div><pre class="programlisting">for (int i = 0; i &lt; 2; i++) {
  auto sprite = Sprite::createWithSpriteFrameName ("city_dark.png");
    sprite-&gt;setAnchorPoint(Vec2(0.5,0));
  sprite-&gt;setPosition(_screenSize.width * (0.25f + i *  0.5f),0));
  _gameBatchNode-&gt;addChild(sprite, kMiddleground);
  
  sprite = Sprite::createWithSpriteFrameName("city_light.png");
  sprite-&gt;setAnchorPoint(Vec2(0.5,0));
  sprite-&gt;setPosition(Vec2(_screenSize.width * (0.25f + i *  0.5f),
  _screenSize.height * 0.1f));
  _gameBatchNode-&gt;addChild(sprite, kBackground);
}</pre></div></li><li class="listitem" value="2">Then the trees:<div><pre class="programlisting">//add trees
for (int i = 0; i &lt; 3; i++) {
  auto sprite = Sprite::createWithSpriteFrameName("trees.png");
  sprite-&gt;setAnchorPoint(Vec2(0.5f, 0.0f));
  sprite-&gt;setPosition(Vec2(_screenSize.width * (0.2f + i * 0.3f),0));
  _gameBatchNode-&gt;addChild(sprite, kForeground);

}</pre></div><p class="calibre13">Notice that here we create sprites by passing it a sprite frame name. The IDs for these frame names were loaded into <code class="email">SpriteFrameCache</code> through our <code class="email">sprite_sheet.plist</code> file.</p></li><li class="listitem" value="3">The <a id="id136" class="calibre1"/>screen so far is made up of two instances of <code class="email">city_dark.png</code> tiling at the bottom of the screen, and two instances of <code class="email">city_light.png</code> also tiling. One needs to appear on top of the other and for that we use the enumerated values declared in <code class="email">GameLayer.h</code>:<div><pre class="programlisting">enum {
  kBackground,
  kMiddleground,
  kForeground
};</pre></div></li><li class="listitem" value="4">We use the <code class="email">addChild( Node, zOrder)</code> method to layer our sprites on top of each other, using different values for their <code class="email">z</code> order.<p class="calibre13">So for example, when we later add three sprites showing the <code class="email">trees.png</code> sprite frame, we add them on top of all previous sprites using the highest value for z that we find in the enumerated list, which is <code class="email">kForeground</code>.</p></li></ol><div></div><div><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre6">Why go through the trouble of tiling the images and not using one large image instead, or combining some of them with the background image? Because I wanted to include the greatest number of images possible inside the one sprite sheet, and have that sprite sheet to be as small as possible, to illustrate all the clever ways you can use and optimize sprite sheets. This is not necessary in this particular game.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec50" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We began creating the initial screen for our game. We are using a <code class="email">SpriteBatchNode</code> to contain all the sprites that use images from our sprite sheet. So <code class="email">SpriteBatchNode</code> behaves as any node does—as a container. And we can layer individual sprites inside the batch node by manipulating their <code class="email">z</code> order.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec50" class="calibre1"/>Bitmap fonts in Cocos2d-x</h1></div></div></div><p class="calibre6">The <a id="id137" class="calibre1"/>Cocos2d-x <code class="email">Label</code> class has a static <code class="email">create</code> method that uses bitmap images for the characters.</p><p class="calibre6">The bitmap image we are using here was created with the program GlyphDesigner, and in essence, it works just as a sprite sheet does. As a matter of fact, <code class="email">Label</code> extends <code class="email">SpriteBatchNode</code>, so it behaves just like a batch node.</p><p class="calibre6">You have images for all individual characters you'll need packed inside a PNG file (<code class="email">font.png</code>), and then a data file (<code class="email">font.fnt</code>) describing where each character is. The following screenshot shows how the font sprite sheet looks like for our game:</p><div><img src="img/00013.jpeg" alt="Bitmap fonts in Cocos2d-x" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">The <a id="id138" class="calibre1"/>difference between <code class="email">Label</code> and a regular <code class="email">SpriteBatchNode</code> class is that the data file also feeds the <code class="email">Label</code> object information on how to <em class="calibre8">write</em> with this font. In other words, how to space out the characters and lines correctly.</p><p class="calibre6">The <code class="email">Label</code> objects we are using in the game are instantiated with the name of the data file and their initial string value:</p><div><pre class="programlisting">_scoreDisplay = Label::createWithBMFont("font.fnt", "0");</pre></div><p class="calibre6">And the value for the label is changed through the <code class="email">setString</code> method:</p><div><pre class="programlisting">_scoreDisplay-&gt;setString("1000");</pre></div><div><h3 class="title2"><a id="note07" class="calibre1"/>Note</h3><p class="calibre6">Just as with every other image in the game, we also have different versions of <code class="email">font.fnt</code> and <code class="email">font.png</code> in our <code class="email">Resources</code> folders, one for each screen definition. <code class="email">FileUtils</code> will once again do the heavy lifting of finding the correct file for the correct screen.</p></div><p class="calibre6">So now let's create the labels for our game.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec51" class="calibre1"/>Time for action – creating bitmap font labels</h1></div></div></div><p class="calibre6">Creating a<a id="id139" class="calibre1"/> bitmap font is somewhat<a id="id140" class="calibre1"/> similar to creating a batch node.</p><div><ol class="orderedlist"><li class="listitem" value="1">Continuing with our <code class="email">createGameScreen</code> method, add the following lines to the <code class="email">score</code> label:<div><pre class="programlisting">_scoreDisplay = Label::createWithBMFont("font.fnt", "0");
_scoreDisplay-&gt;setAnchorPoint(Vec2(1,0.5));
_scoreDisplay-&gt;setPosition(Vec2 (_screenSize.width * 0.8f, _screenSize.height * 0.94f));
this-&gt;addChild(_scoreDisplay);</pre></div><p class="calibre13">And then add a label to display the energy level, and set its horizontal alignment to <code class="email">Right</code>:</p><div><pre class="programlisting">_energyDisplay = Label::createWithBMFont("font.fnt", "100%", TextHAlignment::RIGHT);
_energyDisplay-&gt;setPosition(Vec2 (_screenSize.width * 0.3f, _screenSize.height * 0.94f));
this-&gt;addChild(_energyDisplay);</pre></div></li><li class="listitem" value="2">Add the following line <a id="id141" class="calibre1"/>for<a id="id142" class="calibre1"/> an icon that appears next to the <code class="email">_energyDisplay</code> label:<div><pre class="programlisting">auto icon = Sprite::createWithSpriteFrameName("health_icon.png");
icon-&gt;setPosition( Vec2(_screenSize. width * 0.15f,  _screenSize.height * 0.94f) );
_gameBatchNode-&gt;addChild(icon, kBackground);</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec51" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We just created our first bitmap font object in Cocos2d-x. Now let's finish creating our game's sprites.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec52" class="calibre1"/>Time for action – adding the final screen sprites</h1></div></div></div><p class="calibre6">The last <a id="id143" class="calibre1"/>sprites we need to create are the clouds, the bomb and shockwave, and our game state messages.</p><div><ol class="orderedlist"><li class="listitem" value="1">Back to the <code class="email">createGameScreen</code> method, add the clouds to the screen:<div><pre class="programlisting">for (int i = 0; i &lt; 4; i++) {
  float cloud_y = i % 2 == 0 ? _screenSize.height * 0.4f : _screenSize.height * 0.5f;
  auto cloud = Sprite::createWithSpriteFrameName("cloud.png");
  cloud-&gt;setPosition(Vec2 (_screenSize.width * 0.1f + i * _screenSize.width * 0.3f,  cloud_y));
  _gameBatchNode-&gt;addChild(cloud, kBackground);
  _clouds.pushBack(cloud);
}</pre></div></li><li class="listitem" value="2">Create the <code class="email">_bomb</code> sprite; players will <em class="calibre8">grow</em> when tapping the screen:<div><pre class="programlisting">_bomb = Sprite::createWithSpriteFrameName("bomb.png");
_bomb-&gt;getTexture()-&gt;generateMipmap();
_bomb-&gt;setVisible(false);

auto size = _bomb-&gt;getContentSize();

//add sparkle inside bomb sprite
auto sparkle = Sprite::createWithSpriteFrameName("sparkle.png");
sparkle-&gt;setPosition(Vec2(size.width * 0.72f, size.height *  0.72f));
_bomb-&gt;addChild(sparkle, kMiddleground, kSpriteSparkle);

//add halo inside bomb sprite
auto halo = Sprite::createWithSpriteFrameName ("halo.png");
halo-&gt;setPosition(Vec2(size.width * 0.4f, size.height *  0.4f));
_bomb-&gt;addChild(halo, kMiddleground, kSpriteHalo);
_gameBatchNode-&gt;addChild(_bomb, kForeground);</pre></div></li><li class="listitem" value="3">Then<a id="id144" class="calibre1"/> create the <code class="email">_shockwave</code> sprite that appears after the <code class="email">_bomb</code> goes off:<div><pre class="programlisting">_shockWave = Sprite::createWithSpriteFrameName("shockwave.png");
_shockWave-&gt;getTexture()-&gt;generateMipmap();
_shockWave-&gt;setVisible(false);
_gameBatchNode-&gt;addChild(_shockWave);</pre></div></li><li class="listitem" value="4">Finally, add the two messages that appear on the screen, one for our <code class="email">intro</code> state and one for our <code class="email">gameover</code> state:<div><pre class="programlisting">_introMessage = Sprite::createWithSpriteFrameName("logo.png");
_introMessage-&gt;setPosition(Vec2 (_screenSize.width * 0.5f, _screenSize.height * 0.6f));
_introMessage-&gt;setVisible(true);
this-&gt;addChild(_introMessage, kForeground);

_gameOverMessage = Sprite::createWithSpriteFrameName ("gameover.png");
_gameOverMessage-&gt;setPosition(Vec2 (_screenSize.width * 0.5f, _screenSize.height * 0.65f));
_gameOverMessage-&gt;setVisible(false);
this-&gt;addChild(_gameOverMessage, kForeground);</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec52" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">There is a lot of new information regarding sprites in the previous code. So let's go over it carefully:</p><div><ul class="itemizedlist"><li class="listitem">We started by adding the clouds. We put the sprites inside a vector so we can move the clouds later. Notice that they are also part of our batch node.</li><li class="listitem">Next comes the bomb sprite and our first new call:<div><pre class="programlisting">_bomb-&gt;getTexture()-&gt;generateMipmap();</pre></div></li><li class="listitem">With this we are telling the framework to create antialiased copies of this texture in diminishing sizes (mipmaps), since we are going to scale it down later. This is optional of course; sprites can be resized without first generating mipmaps, but if <a id="id145" class="calibre1"/>you notice loss of quality in your scaled sprites, you can fix that by creating mipmaps for their texture.<div><h3 class="title2"><a id="note08" class="calibre1"/>Note</h3><p class="calibre6">The texture must have size values in so-called POT (power of 2: 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, and so on). Textures in OpenGL must always be sized this way; when they are not, Cocos2d-x will do one of two things: it will either resize the texture in memory, adding transparent pixels until the image reaches a POT size, or stop the execution on an assert. With textures used for mipmaps, the framework will stop execution for non-POT textures.</p></div></li><li class="listitem">I add the <code class="email">sparkle</code> and the <code class="email">halo</code> sprites as children to the <code class="email">_bomb</code> sprite. This will use the container characteristic of nodes to our advantage. When I grow the bomb, all its children will grow with it.</li><li class="listitem">Notice too that I use a third parameter to <code class="email">addChild</code> for <code class="email">halo</code> and <code class="email">sparkle</code>:<div><pre class="programlisting">bomb-&gt;addChild(halo, kMiddleground, kSpriteHalo);</pre></div></li><li class="listitem">This third parameter is an integer tag from yet another enumerated list declared in <code class="email">GameLayer.h</code>. I can use this tag to retrieve a particular child from a sprite as follows:<div><pre class="programlisting">auto halo = (Sprite *)  bomb-&gt;getChildByTag(kSpriteHalo);</pre></div></li></ul></div><p class="calibre6">We now have our game screen in place:</p><div><img src="img/00014.jpeg" alt="What just happened?" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">Next come object pools.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec53" class="calibre1"/>Time for action – creating our object pools</h1></div></div></div><p class="calibre6">The<a id="id146" class="calibre1"/> pools are just vectors of objects. And here are the steps to create them:</p><div><ol class="orderedlist"><li class="listitem" value="1">Inside the <code class="email">createPools</code> method, we first create a pool for meteors:<div><pre class="programlisting">void GameLayer::createPools() {
  int i;
  _meteorPoolIndex = 0;
  for (i = 0; i &lt; 50; i++) {
  auto sprite = Sprite::createWithSpriteFrameName("meteor.png");
  sprite-&gt;setVisible(false);
  _gameBatchNode-&gt;addChild(sprite, kMiddleground, kSpriteMeteor);
  _meteorPool.pushBack(sprite);
}</pre></div></li><li class="listitem" value="2">Then we create an object pool for health packs:<div><pre class="programlisting">_healthPoolIndex = 0;
for (i = 0; i &lt; 20; i++) {
  auto sprite = Sprite::createWithSpriteFrameName("health.png");
  sprite-&gt;setVisible(false);
  sprite-&gt;setAnchorPoint(Vec2(0.5f, 0.8f));
  _gameBatchNode-&gt;addChild(sprite, kMiddleground, kSpriteHealth);
  _healthPool.pushBack(sprite);
}</pre></div></li><li class="listitem" value="3">We'll use the corresponding pool index to retrieve objects from the vectors as the game progresses.</li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec53" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We now have a vector of invisible meteor sprites and a vector of invisible health sprites. We'll use their respective pool indices to retrieve these from the vector as needed as you'll see in a moment. But first we need to take care of actions and animations.</p><div><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre6">With object pools, we reduce the number of instantiations during the main loop, and it allows us to never destroy anything that can be reused. But if you need to remove a child from a node, use <code class="email">-&gt;removeChild</code> or <code class="email">-&gt;removeChildByTag</code> if a tag is present.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec54" class="calibre1"/>Actions in a nutshell</h1></div></div></div><p class="calibre6">If you <a id="id147" class="calibre1"/>remember, a node will store information about position, scale, rotation, visibility, and opacity of a node. And in Cocos2d-x, there is an <code class="email">Action</code> class to change each one of these values over time, in effect animating these transformations.</p><p class="calibre6">Actions are usually created with a static method <code class="email">create</code>. The majority of these actions are time-based, so usually the first parameter you need to pass an action is the time length for the action. So for instance:</p><div><pre class="programlisting">auto fadeout = FadeOut::create(1.0f);</pre></div><p class="calibre6">This creates a <code class="email">fadeout</code> action that will take one second to complete. You can run it on a sprite, or node, as follows:</p><div><pre class="programlisting">mySprite-&gt;runAction(fadeout);</pre></div><p class="calibre6">Cocos2d-x has an incredibly flexible system that allows us to create any combination of actions and transformations to achieve any effect we desire.</p><p class="calibre6">You may, for instance, choose to create an action sequence (<code class="email">Sequence</code>) that contains more than one action; or you can apply easing effects (<code class="email">EaseIn</code>, <code class="email">EaseOut</code>, and so on) to your actions. You can choose to repeat an action a certain number of times (<code class="email">Repeat</code>) or forever (<code class="email">RepeatForever</code>); and you can add callbacks to functions you want called once an action is completed (usually inside a <code class="email">Sequence</code> action).</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec55" class="calibre1"/>Time for action – creating actions with Cocos2d-x</h1></div></div></div><p class="calibre6">Creating<a id="id148" class="calibre1"/> actions with Cocos2d-x is a very simple process:</p><div><ol class="orderedlist"><li class="listitem" value="1">Inside<a id="id149" class="calibre1"/> our <code class="email">createActions</code> method, we will instantiate the actions we can use repeatedly in our game. Let's create our first actions:<div><pre class="programlisting">void GameLayer::createActions() {
 //swing action for health drops
 auto easeSwing = Sequence::create(
 EaseInOut::create(RotateTo::create(1.2f, -10), 2),
 EaseInOut::create(RotateTo::create(1.2f, 10), 2),
 nullptr);//mark the end of a sequence with a nullptr
 _swingHealth = RepeatForever::create( (ActionInterval *) easeSwing );
 _swingHealth-&gt;retain();</pre></div></li><li class="listitem" value="2">Actions can be combined in many different forms. Here, the retained <code class="email">_swingHealth</code> action is a <code class="email">RepeatForever</code> action of <code class="email">Sequence</code> that will rotate the health sprite first one way, then the other, with <code class="email">EaseInOut</code> wrapping the <code class="email">RotateTo</code> action. <code class="email">RotateTo</code> takes <code class="email">1.2</code> seconds to rotate the sprite first to <code class="email">-10</code> degrees and then to <code class="email">10</code>. And the easing has a value of <code class="email">2</code>, which I suggest you experiment with to get a sense of what it means visually. Next we add three more<a id="id150" class="calibre1"/> actions:<div><pre class="programlisting">//action sequence for shockwave: fade out, callback when  //done
_shockwaveSequence = Sequence::create(
  FadeOut::create(1.0f),
  CallFunc::create(std::bind(&amp;GameLayer::shockwaveDone, this)), nullptr);
_shockwaveSequence-&gt;retain();

//action to grow bomb
_growBomb = ScaleTo::create(6.0f, 1.0);
_growBomb-&gt;retain();

//action to rotate sprites
auto rotate = RotateBy::create(0.5f ,  -90);
_rotateSprite = RepeatForever::create( rotate );
_rotateSprite-&gt;retain();</pre></div></li><li class="listitem" value="3">First, another <code class="email">Sequence</code>. This will fade out the sprite and call the <code class="email">shockwaveDone</code> function, which is already implemented in the class and turns <a id="id151" class="calibre1"/>the <code class="email">_shockwave</code> sprite invisible when called.</li><li class="listitem" value="4">The last one is a <code class="email">RepeatForever</code> action of a <code class="email">RotateBy</code> action. In half a second, the sprite running this action will rotate <code class="email">-90</code> degrees and will do that again and again.</li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec54" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">You just got your first glimpse of how to create actions in Cocos2d-x and how the framework allows for all sorts of combinations to accomplish any effect.</p><p class="calibre6">It may be hard at first to read through a <code class="email">Sequence</code> action and understand what's happening, but the logic is easy to follow once you break it down into its individual parts.</p><p class="calibre6">But we are not done with the <code class="email">createActions</code> method yet. Next come sprite animations.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec56" class="calibre1"/>Animating a sprite in Cocos2d-x</h1></div></div></div><p class="calibre6">The key <a id="id152" class="calibre1"/>thing to remember is that an animation is just another<a id="id153" class="calibre1"/> type of action, one that changes the texture used by a sprite over a period of time.</p><p class="calibre6">In order to create an animation action, you need to first create an <code class="email">Animation</code> object. This object will store all the information regarding the different sprite frames you wish to use in the <a id="id154" class="calibre1"/>animation, the length of the animation in seconds, and whether it loops or not.</p><p class="calibre6">With <a id="id155" class="calibre1"/>this <code class="email">Animation</code> object, you then create a <code class="email">Animate</code> action. Let's take a look.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec57" class="calibre1"/>Time for action – creating animations</h1></div></div></div><p class="calibre6">Animations<a id="id156" class="calibre1"/> are a specialized type of action<a id="id157" class="calibre1"/> that require a few extra steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Inside the same <code class="email">createActions</code> method, add the lines for the two animations we have in the game. First, we start with the animation that shows an explosion when a meteor reaches the city. We begin by loading the frames into an <code class="email">Animation</code> object:<div><pre class="programlisting">auto animation = Animation::create();
int i;
for(i = 1; i &lt;= 10; i++) {
  auto name = String::createWithFormat("boom%i.png", i);
  auto frame = SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName(name-&gt;getCString());
  animation-&gt;addSpriteFrame(frame);
}</pre></div></li><li class="listitem" value="2">Then we use the <code class="email">Animation</code> object inside a <code class="email">Animate</code> action:<div><pre class="programlisting">animation-&gt;setDelayPerUnit(1 / 10.0f);
animation-&gt;setRestoreOriginalFrame(true);
_groundHit = 
  Sequence::create(
    MoveBy::create(0, Vec2(0,_screenSize.height * 0.12f)),
    Animate::create(animation),
   CallFuncN::create(CC_CALLBACK_1(GameLayer::animationDone, this)), nullptr);
_groundHit-&gt;retain();</pre></div></li><li class="listitem" value="3">The same steps are repeated to create the other explosion animation used when the player hits a meteor or a health pack.<div><pre class="programlisting">animation = Animation::create();
for(int i = 1; i &lt;= 7; i++) {
 auto name = String::createWithFormat("explosion_small%i.png", i);
 auto frame = SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName(name-&gt;getCString());
 animation-&gt;addSpriteFrame(frame);
}

animation-&gt;setDelayPerUnit(0.5 / 7.0f);
animation-&gt;setRestoreOriginalFrame(true);
_explosion = Sequence::create(
     Animate::create(animation),
   CallFuncN::create(CC_CALLBACK_1(GameLayer::animationDone, this)), nullptr);
_explosion-&gt;retain();</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec55" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We created<a id="id158" class="calibre1"/> two instances of a very special kind<a id="id159" class="calibre1"/> of action in Cocos2d-x: <code class="email">Animate</code>. Here is what we did:</p><div><ul class="itemizedlist"><li class="listitem">First, we created an <code class="email">Animation</code> object. This object holds the references to all the textures used in the animation. The frames were named in such a way that they could easily be concatenated inside a loop (<code class="email">boom1</code>, <code class="email">boom2</code>, <code class="email">boom3</code>, and so on). There are 10 frames for the first animation and seven for the second.</li><li class="listitem">The textures (or frames) are <code class="email">SpriteFrame</code> objects we grab from <code class="email">SpriteFrameCache</code>, which as you remember, contains all the information from the <code class="email">sprite_sheet.plist</code> data file. So the frames are in our sprite sheet.</li><li class="listitem">Then when all frames are in place, we determine the delay of each frame by dividing the total amount of seconds we want the animation to last by the total number of frames.</li><li class="listitem">The <code class="email">setRestoreOriginalFrame</code> method is important here. If we set <code class="email">setRestoreOriginalFrame</code> to <code class="email">true</code>, then the sprite will revert to its original appearance once the animation is over. For example, if I have an explosion animation that will run on a meteor sprite, then by the end of the explosion animation, the sprite will revert to displaying the meteor texture.</li><li class="listitem">Time for the actual action. <code class="email">Animate</code> receives the <code class="email">Animation</code> object as its parameter. (In the first animation, we shift the position of the sprite just before the explosion appears, so there is an extra <code class="email">MoveBy</code> method.)</li><li class="listitem">And in both instances, I make a call to an <code class="email">animationDone</code> callback already implemented in the class. It makes the calling sprite invisible:<div><pre class="programlisting">void GameLayer::animationDone (Node* pSender) {
  pSender-&gt;setVisible(false);
}</pre></div><div><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre6">We could have used the same method for both callbacks (<code class="email">animationDone</code> and <code class="email">shockwaveDone</code>) as they accomplish the same thing. But I wanted to show you a callback that receives as an argument, the node that made the call and one that did not. Respectively, these are <code class="email">CallFuncN</code> and <code class="email">CallFunc</code>, and were used inside the action sequences we just created.</p></div></li></ul></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec58" class="calibre1"/>Time to make our game tick!</h1></div></div></div><p class="calibre6">Okay, we have <a id="id160" class="calibre1"/>our main elements in place and are ready to add the final bit of logic to run the game. But how will everything work?</p><p class="calibre6">We will use a system of countdowns to add new meteors and new health packs, as well as a countdown that will incrementally make the game harder to play.</p><p class="calibre6">On touch, the player will start the game if the game is not running, and also add bombs and explode them during gameplay. An explosion creates a shockwave.</p><p class="calibre6">On update, we will check against collision between our <code class="email">_shockwave</code> sprite (if visible) and all our falling objects. And that's it. Cocos2d-x will take care of all the rest through our created actions and callbacks!</p><p class="calibre6">So let's implement our touch events first.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec59" class="calibre1"/>Time for action – handling touches</h1></div></div></div><p class="calibre6">Time to<a id="id161" class="calibre1"/> bring the player to our party:</p><div><ol class="orderedlist"><li class="listitem" value="1">Time to implement our <code class="email">onTouchBegan</code> method. We'll begin by handling the two game states, <code class="email">intro</code> and <code class="email">game over</code>:<div><pre class="programlisting">bool GameLayer::onTouchBegan (Touch * touch, Event * event){

  //if game not running, we are seeing either intro or  //gameover
  if (!_running) {
    //if intro, hide intro message
    if (_introMessage-&gt;isVisible()) {
      _introMessage-&gt;setVisible(false);

      //if game over, hide game over message 
    } else if (_gameOverMessage-&gt;isVisible()) {
      SimpleAudioEngine::getInstance()-&gt;stopAllEffects();
      _gameOverMessage-&gt;setVisible(false);
      
    }
    
    this-&gt;resetGame();
    return true;
  }</pre></div></li><li class="listitem" value="2">Here we check to see if the game is not running. If not, we check to see if any of our messages are visible. If <code class="email">_introMessage</code> is visible, we hide it. If <code class="email">_gameOverMessage</code> is visible, we stop all current sound effects and hide the message as well. Then we call a method called <code class="email">resetGame,</code> which will reset all the game data (energy, score, and countdowns) to their initial values, and set <code class="email">_running</code> to <code class="email">true</code>.</li><li class="listitem" value="3">Next we <a id="id162" class="calibre1"/>handle the touches. But we only need to handle one each time so we use <code class="email">-&gt;anyObject()</code> on <code class="email">Set</code>:<div><pre class="programlisting">auto touch = (Touch *)pTouches-&gt;anyObject();

if (touch) {
  
  //if bomb already growing...
  if (_bomb-&gt;isVisible()) {
    //stop all actions on bomb, halo and sparkle
    _bomb-&gt;stopAllActions();
    auto child = (Sprite *) _bomb-&gt;getChildByTag(kSpriteHalo);
    child-&gt;stopAllActions();
    child = (Sprite *) _bomb-&gt;getChildByTag(kSpriteSparkle);
    child-&gt;stopAllActions();
    
    //if bomb is the right size, then create shockwave
    if (_bomb-&gt;getScale() &gt; 0.3f) {
      _shockWave-&gt;setScale(0.1f);
      _shockWave-&gt;setPosition(_bomb-&gt;getPosition());
      _shockWave-&gt;setVisible(true);
      _shockWave-&gt;runAction(ScaleTo::create(0.5f, _bomb-&gt;getScale() * 2.0f));
      _shockWave-&gt;runAction(_shockwaveSequence-&gt;clone());
      SimpleAudioEngine::getInstance()-&gt;playEffect("bombRelease.wav");

    } else {
      SimpleAudioEngine::getInstance()-&gt;playEffect("bombFail.wav");
    }
    _bomb-&gt;setVisible(false);
    //reset hits with shockwave, so we can count combo hits
    _shockwaveHits = 0;
  
 //if no bomb currently on screen, create one
 } else {
    Point tap = touch-&gt;getLocation();
    _bomb-&gt;stopAllActions();
    _bomb-&gt;setScale(0.1f);
    _bomb-&gt;setPosition(tap);
    _bomb-&gt;setVisible(true);
    _bomb-&gt;setOpacity(50);
    _bomb-&gt;runAction(_growBomb-&gt;clone());
    
     auto child = (Sprite *) _bomb-&gt;getChildByTag(kSpriteHalo);
     child-&gt;runAction(_rotateSprite-&gt;clone());
     child = (Sprite *) _bomb-&gt;getChildByTag(kSpriteSparkle);
     child-&gt;runAction(_rotateSprite-&gt;clone());
  }
}</pre></div></li><li class="listitem" value="4">If <code class="email">_bomb</code> is<a id="id163" class="calibre1"/> visible, it means it's already growing on the screen. So on touch, we use the <code class="email">stopAllActions()</code> method on the bomb and we use the <code class="email">stopAllActions()</code> method on its children that we retrieve through our tags:<div><pre class="programlisting">child = (Sprite *) _bomb-&gt;getChildByTag(kSpriteHalo);
child-&gt;stopAllActions();
child = (Sprite *) _bomb-&gt;getChildByTag(kSpriteSparkle);
child-&gt;stopAllActions();</pre></div></li><li class="listitem" value="5">If <code class="email">_bomb</code> is the right size, we start our <code class="email">_shockwave</code>. If it isn't, we play a bomb failure sound effect; there is no explosion and <code class="email">_shockwave</code> is not made visible.</li><li class="listitem" value="6">If we have an explosion, then the <code class="email">_shockwave</code> sprite is set to <code class="email">10</code> percent of the scale. It's placed at the same spot as the bomb, and we run a couple of actions on it: we grow the <code class="email">_shockwave</code> sprite to twice the scale the bomb was when it went off and we run a copy of <code class="email">_shockwaveSequence</code> that we created earlier.</li><li class="listitem" value="7">Finally, if no <code class="email">_bomb</code> is currently visible on screen, we create one. And we run clones of previously created actions on the <code class="email">_bomb</code> sprite and its children. When <code class="email">_bomb</code> grows, its children grow. But when the children rotate, the bomb does not: a parent changes its children, but the children do not change their parent.</li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec56" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We just added part of the core logic of the game. It is with touches that the player creates and explodes bombs to stop meteors from reaching the city. Now we need to create our falling objects. But first, let's set up our countdowns and our game data.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec60" class="calibre1"/>Time for action – starting and restarting the game</h1></div></div></div><p class="calibre6">Let's add the <a id="id164" class="calibre1"/>logic to start and restart the game.</p><div><ol class="orderedlist"><li class="listitem" value="1">Let's <a id="id165" class="calibre1"/>write the implementation for <code class="email">resetGame</code>:<div><pre class="programlisting">void GameLayer::resetGame(void) {
    _score = 0;
    _energy = 100;
    
    //reset timers and "speeds"
    _meteorInterval = 2.5;
    _meteorTimer = _meteorInterval * 0.99f;
    _meteorSpeed = 10;//in seconds to reach ground
    _healthInterval = 20;
    _healthTimer = 0;
    _healthSpeed = 15;//in seconds to reach ground
    
    _difficultyInterval = 60;
    _difficultyTimer = 0;
    
    _running = true;
    
    //reset labels
    _energyDisplay-&gt;setString(std::to_string((int) _energy) + "%");
    _scoreDisplay-&gt;setString(std::to_string((int) _score));
}</pre></div></li><li class="listitem" value="2">Next, add<a id="id166" class="calibre1"/> the<a id="id167" class="calibre1"/> implementation of <code class="email">stopGame</code>:<div><pre class="programlisting">void GameLayer::stopGame() {
    
    _running = false;
    
    //stop all actions currently running
    int i;
    int count = (int) _fallingObjects.size();
    
    for (i = count-1; i &gt;= 0; i--) {
        auto sprite = _fallingObjects.at(i);
        sprite-&gt;stopAllActions();
        sprite-&gt;setVisible(false);
        _fallingObjects.erase(i);
    }
    if (_bomb-&gt;isVisible()) {
        _bomb-&gt;stopAllActions();
        _bomb-&gt;setVisible(false);
        auto child = _bomb-&gt;getChildByTag(kSpriteHalo);
        child-&gt;stopAllActions();
        child = _bomb-&gt;getChildByTag(kSpriteSparkle);
        child-&gt;stopAllActions();
    }
    if (_shockWave-&gt;isVisible()) {
        _shockWave-&gt;stopAllActions();
        _shockWave-&gt;setVisible(false);
    }
    if (_ufo-&gt;isVisible()) {
        _ufo-&gt;stopAllActions();
        _ufo-&gt;setVisible(false);
        auto ray = _ufo-&gt;getChildByTag(kSpriteRay);
        ray-&gt;stopAllActions();
        ray-&gt;setVisible(false);
    }
}</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec57" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">With these methods we control gameplay. We start the game with default values through <code class="email">resetGame()</code>, and we stop all actions with <code class="email">stopGame()</code>.</p><p class="calibre6">Already<a id="id168" class="calibre1"/> implemented in the class is the method that makes the <a id="id169" class="calibre1"/>game more difficult as time progresses. If you take a look at the method (<code class="email">increaseDifficulty</code>) you will see that it reduces the interval between meteors and reduces the time it takes for meteors to reach the ground.</p><p class="calibre6">All we need now is the <code class="email">update</code> method to run the countdowns and check for collisions.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec61" class="calibre1"/>Time for action – updating the game</h1></div></div></div><p class="calibre6">We already <a id="id170" class="calibre1"/>have the code that updates the countdowns inside the update. If it's time to add a meteor or a health pack we do it. If it's time to make the game more difficult to play, we do that too.</p><div><h3 class="title2"><a id="note11" class="calibre1"/>Note</h3><p class="calibre6">It is possible to use an action for these timers: a <code class="email">Sequence</code> action with a <code class="email">Delay</code> action object and a callback. But there are advantages to using these countdowns. It's easier to reset them and to change them, and we can take them right into our main loop.</p></div><p class="calibre6">So it's time to add our main loop:</p><div><ol class="orderedlist"><li class="listitem" value="1">What we need to do is check for collisions. So add the following code:<div><pre class="programlisting">if (_shockWave-&gt;isVisible()) {
 count = (int) _fallingObjects.size();
 for (i = count-1; i &gt;= 0; i--) {
   auto sprite =  _fallingObjects.at(i);
   diffx = _shockWave-&gt;getPositionX() - sprite-&gt;getPositionX();
   diffy = _shockWave-&gt;getPositionY() - sprite-&gt;getPositionY();
   if (pow(diffx, 2) + pow(diffy, 2) &lt;= pow(_shockWave-&gt;getBoundingBox().size.width * 0.5f, 2)) {
    sprite-&gt;stopAllActions();
    sprite-&gt;runAction( _explosion-&gt;clone());
    SimpleAudioEngine::getInstance()-&gt;playEffect("boom.wav");
    if (sprite-&gt;getTag() == kSpriteMeteor) {
      _shockwaveHits++;
      _score += _shockwaveHits * 13 + _shockwaveHits * 2;
    }
    //play sound
    _fallingObjects.erase(i);
  }
 }
 _scoreDisplay-&gt;setString(std::to_string(_score));
}</pre></div></li><li class="listitem" value="2">If <code class="email">_shockwave</code> is <a id="id171" class="calibre1"/>visible, we check the distance between it and each sprite in <code class="email">_fallingObjects</code> vector. If we hit any meteors, we increase the value of the <code class="email">_shockwaveHits</code> property so we can award the player for multiple hits. Next we move the clouds:<div><pre class="programlisting">//move clouds
for (auto sprite : _clouds) {
  sprite-&gt;setPositionX(sprite-&gt;getPositionX() + dt * 20);
  if (sprite-&gt;getPositionX() &gt; _screenSize.width + sprite-&gt;getBoundingBox().size.width * 0.5f)
    sprite-&gt;setPositionX(-sprite-&gt;getBoundingBox().size.width * 0.5f);
}</pre></div></li><li class="listitem" value="3">I chose not to use a <code class="email">MoveTo</code> action for the clouds to show you the amount of code that can be replaced by a simple action. If not for Cocos2d-x actions, we would have to implement logic to move, rotate, swing, scale, and explode all our sprites!</li><li class="listitem" value="4">And finally:<div><pre class="programlisting">if (_bomb-&gt;isVisible()) {
   if (_bomb-&gt;getScale() &gt; 0.3f) {
      if (_bomb-&gt;getOpacity() != 255)
         _bomb-&gt;setOpacity(255);
   }
}</pre></div></li><li class="listitem" value="5">We give the player an extra visual cue to when a bomb is ready to explode by changing its opacity.</li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec58" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">The main loop is pretty straightforward when you don't have to worry about updating individual sprites, as our actions take care of that for us. We pretty much only need to run collision checks between our sprites, and to determine when it's time to throw something new at the player.</p><p class="calibre6">So now the only thing left to do is grab the meteors and health packs from the pools when their timers are up. So let's get right to it.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec62" class="calibre1"/>Time for action – retrieving objects from the pool</h1></div></div></div><p class="calibre6">We just<a id="id172" class="calibre1"/> need to use the correct index to retrieve the objects from their respective vector:</p><div><ol class="orderedlist"><li class="listitem" value="1">To retrieve meteor sprites, we'll use the <code class="email">resetMeteor</code> method:<div><pre class="programlisting">void GameLayer::resetMeteor(void) {
   //if too many objects on screen, return
    if (_fallingObjects.size() &gt; 30) return;
    
    auto meteor = _meteorPool.at(_meteorPoolIndex);
      _meteorPoolIndex++;
    if (_meteorPoolIndex == _meteorPool.size()) 
      _meteorPoolIndex = 0;
      int meteor_x = rand() % (int) (_screenSize.width * 0.8f) + _screenSize.width * 0.1f;
   int meteor_target_x = rand() % (int) (_screenSize.width * 0.8f) + _screenSize.width * 0.1f;
    
    meteor-&gt;stopAllActions();
    meteor-&gt;setPosition(Vec2(meteor_x, _screenSize.height + meteor-&gt;getBoundingBox().size.height * 0.5));
  
    //create action
    auto  rotate = RotateBy::create(0.5f ,  -90);
    auto  repeatRotate = RepeatForever::create( rotate );
    auto  sequence = Sequence::create (
               MoveTo::create(_meteorSpeed, Vec2(meteor_target_x, _screenSize.height * 0.15f)),
               CallFunc::create(std::bind(&amp;GameLayer::fallingObjectDone, this, meteor) ), nullptr);    
  meteor-&gt;setVisible ( true );
  meteor-&gt;runAction(repeatRotate);
  meteor-&gt;runAction(sequence);
 _fallingObjects.pushBack(meteor);
}</pre></div></li><li class="listitem" value="2">We grab the next available meteor from the pool, then we pick a random start and end <code class="email">x</code> value for its <code class="email">MoveTo</code> action. The meteor starts at the top of the screen and will move to the bottom towards the city, but the <code class="email">x</code> value is randomly picked each time.</li><li class="listitem" value="3">We rotate the meteor inside a <code class="email">RepeatForever</code> action, and we use <code class="email">Sequence</code> to move the sprite to its target position and then call back <code class="email">fallingObjectDone</code> when the meteor has reached its target. We finish by adding the new meteor we retrieved from the pool to the <code class="email">_fallingObjects</code> vector so we can check collisions with it.</li><li class="listitem" value="4">The method to retrieve the health (<code class="email">resetHealth</code>) sprites is pretty much the same, except that <code class="email">swingHealth</code> action is used instead of rotate. You'll find that method already implemented in <code class="email">GameLayer.cpp</code>.</li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec59" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">So <a id="id173" class="calibre1"/>in <code class="email">resetGame</code> we set the timers, and we update them in the <code class="email">update</code> method. We use these timers to add meteors and health packs to the screen by grabbing the next available one from their respective pool, and then we proceed to run collisions between an exploding bomb and these falling objects.</p><p class="calibre6">Notice that in both <code class="email">resetMeteor</code> and <code class="email">resetHealth</code> we don't add new sprites if too many are on screen already:</p><div><pre class="programlisting">if (_fallingObjects-&gt;size() &gt; 30) return;</pre></div><p class="calibre6">This way the game does not get ridiculously hard, and we never run out of unused objects in our pools.</p><p class="calibre6">And the very last bit of logic in our game is our <code class="email">fallingObjectDone</code> callback, called when either a meteor or a health pack has reached the ground, at which point it awards or punishes the player for letting sprites through.</p><p class="calibre6">When you take a look at that method inside <code class="email">GameLayer.cpp</code>, you will notice how we use <code class="email">-&gt;getTag()</code> to quickly ascertain which type of sprite we are dealing with (the one calling the method):</p><div><pre class="programlisting">if (pSender-&gt;getTag() == kSpriteMeteor) {</pre></div><p class="calibre6">If it's a meteor, we decrease energy from the player, play a sound effect, and run the explosion animation; an autorelease copy of the <code class="email">_groundHit</code> action we retained earlier, so we don't need to repeat all that logic every time we need to run this action.</p><p class="calibre6">If the item is a health pack, we increase the energy or give the player some points, play a nice sound effect, and hide the sprite.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec63" class="calibre1"/>Play the game!</h1></div></div></div><p class="calibre6">We've been<a id="id174" class="calibre1"/> coding like mad, and it's finally time to run the game. But first, don't forget to release all the items we retained. In <code class="email">GameLayer.cpp</code>, add our destructor method:</p><div><pre class="programlisting">GameLayer::~GameLayer () {
    
    //release all retained actions
    CC_SAFE_RELEASE(_growBomb);
    CC_SAFE_RELEASE(_rotateSprite);
    CC_SAFE_RELEASE(_shockwaveSequence);
    CC_SAFE_RELEASE(_swingHealth);
    CC_SAFE_RELEASE(_groundHit);
    CC_SAFE_RELEASE(_explosion);
    CC_SAFE_RELEASE(_ufoAnimation);
    CC_SAFE_RELEASE(_blinkRay);
    
    _clouds.clear();
    _meteorPool.clear();
    _healthPool.clear();
    _fallingObjects.clear();
}</pre></div><p class="calibre6">The <a id="id175" class="calibre1"/>actual game screen will now look something like this:</p><div><img src="img/00015.jpeg" alt="Play the game!" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">Once again, you can refer to <code class="email">4198_04_FINAL_PROJECT.zip</code> if you find any problems running the code.</p><p class="calibre6">Now, let's take this to Android.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec64" class="calibre1"/>Time for action – running the game in Android</h1></div></div></div><p class="calibre6">Follow<a id="id176" class="calibre1"/> these steps to deploy the game to Android:</p><div><ol class="orderedlist"><li class="listitem" value="1">This time, there is no need to alter the manifest because the default settings are the ones we want. So, navigate to <code class="email">proj.android</code> and then to the <code class="email">jni</code> folder and open the <code class="email">Android.mk</code> file in a text editor.</li><li class="listitem" value="2">Edit the lines in <code class="email">LOCAL_SRC_FILES</code> to read as follows:<div><pre class="programlisting">LOCAL_SRC_FILES := hellocpp/main.cpp \
                   ../../Classes/AppDelegate.cpp \
                   ../../Classes/GameLayer.cpp </pre></div></li><li class="listitem" value="3">Follow the instructions from the <code class="email">HelloWorld</code> and <code class="email">AirHockey</code> examples to import the game into Eclipse.</li><li class="listitem" value="4">Save it<a id="id177" class="calibre1"/> and run your application. This time, you can try out different size screens if you have the devices.</li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec60" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">You just ran a universal app in Android. And nothing could have been simpler.</p><p class="calibre6">As a bonus, I've added another version of the game with an extra type of enemy to deal with: a UFO hell-bent on zapping the city! You may find this in <code class="email">4198_04_BONUS_PROJECT.zip</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec61" class="calibre1"/>Pop quiz – sprites and actions</h2></div></div></div><p class="calibre6">Q1. A <code class="email">SpriteBatchNode</code> can contain what types of elements?</p><div><ol class="orderedlist"><li class="listitem" value="1">Sprites using textures from two or more sprite sheets.</li><li class="listitem" value="2">Sprites using the same source texture.</li><li class="listitem" value="3">Blank sprites.</li><li class="listitem" value="4">Sprites using textures from one sprite sheet and one other image.</li></ol><div></div><p class="calibre6">Q2. In order to run an action nonstop, what do I need to use?</p><div><ol class="orderedlist"><li class="listitem" value="1"><code class="email">RepeatForever</code>.</li><li class="listitem" value="2"><code class="email">Repeat</code>.</li><li class="listitem" value="3">The default behavior of an action is to run nonstop.</li><li class="listitem" value="4">Actions can't repeat forever.</li></ol><div></div><p class="calibre6">Q3. In order to animate a sprite so that it would move to a certain point on the screen and then fade out, what actions would I need?</p><div><ol class="orderedlist"><li class="listitem" value="1">A <code class="email">Sequence</code> listing an <code class="email">EaseIn</code> and <code class="email">EaseOut</code> action.</li><li class="listitem" value="2">A <code class="email">Sequence</code> listing a <code class="email">FadeOut</code> and <code class="email">MoveTo</code> action.</li><li class="listitem" value="3">A <code class="email">Sequence</code> listing a <code class="email">MoveTo</code> or <code class="email">MoveBy</code> and a <code class="email">FadeOut</code> action.</li><li class="listitem" value="4">A <code class="email">Sequence</code> listing a <code class="email">RotateBy</code> and <code class="email">FadeOut</code> action.</li></ol><div></div><p class="calibre6">Q4. To create a sprite frame animation, what group of classes are absolutely essential?</p><div><ol class="orderedlist"><li class="listitem" value="1"><code class="email">Sprite</code>, <code class="email">SpriteBatchNode</code>, and <code class="email">EaseIn</code>.</li><li class="listitem" value="2"><code class="email">SpriteFrameCache</code>, <code class="email">RotateBy</code>, and <code class="email">ActionManager</code>.</li><li class="listitem" value="3"><code class="email">Sprite</code>, <code class="email">Layer</code>, and <code class="email">FadeOut</code>.</li><li class="listitem" value="4"><code class="email">SpriteFrame</code>, <code class="email">Animation</code>, and <code class="email">Animate</code>.</li></ol><div></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec65" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">In my opinion, after nodes and all their derived objects, actions are the second best thing about Cocos2d-x. They are time savers and can quickly spice things up in any project with professional-looking animations. And I hope with the examples found in this chapter, and along with the ones found in the Cocos2d-x samples test project, you will be able to create any action you need with Cocos2d-x.</p><p class="calibre6">In the next chapter, I'll introduce you to another simple way you can spice things up in your game: with particles!</p></div></body></html>