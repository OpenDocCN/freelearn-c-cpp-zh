<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Making an Entire 2D Game"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Making an Entire 2D Game</h1></div></div></div><p>In this chapter, we will finally make our first game. In fact, we will build two games, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We will build our first game, an Asteroid clone game, by improving our actual application of SFML</li><li class="listitem" style="list-style-type: disc">Our next game will be a Tetris clone game</li></ul></div><p>We will also learn some skills such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Entity models</li><li class="listitem" style="list-style-type: disc">Board management</li></ul></div><p>We are all fans of old school games, so let's get loaded to create some of them right away. In addition, each of these two games has a completely different architecture. It's really interesting as far as the learning process is concerned.</p><div class="section" title="Turning our application to an Asteroid clone"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Turning our application to an Asteroid clone</h1></div></div></div><p>
<span class="strong"><strong>Asteroid</strong></span> is an arcade "shoot 'em up" game created in 1979 by Atari Inc., and is considered a classic. The player<a id="id153" class="indexterm"/> controls a spaceship in an asteroid field with some flying saucers appearing on the screen from time to time, attacking it. The goal <a id="id154" class="indexterm"/>of this game is to destroy all the asteroids and saucers by shooting at them. Each level increases the number of asteroids in the field, and the game becomes harder and harder.</p><p>To build this game, we<a id="id155" class="indexterm"/> will use our actual application as a base, but we need to<a id="id156" class="indexterm"/> add a lot of things to it.</p><div class="section" title="The Player class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>The Player class</h2></div></div></div><p>The player is represented as <a id="id157" class="indexterm"/>a spaceship. The spaceship has the ability to rotate left and right, to shoot, and the spaceship can also give itself a boost. The player can also send the ship into hyperspace, causing it to disappear and reappear in a random location on the screen, at the risk of self-destructing or appearing on top of an asteroid.</p><p>The player starts <a id="id158" class="indexterm"/>with three lives, and on every 10,000 points, a new life is won. If the player crashes into something, it will be destroyed and the player will lose one life. It will reappear at the starting point, that is, the middle of the screen.</p></div><div class="section" title="The levels"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>The levels</h2></div></div></div><p>Each level starts with some big <a id="id159" class="indexterm"/>asteroids in random places that are drifting in various directions. Each level will have an increased number of asteroids. This number is<a id="id160" class="indexterm"/> four for the first level and eleven starting from the fifth level.</p><p>The board is a bit special <a id="id161" class="indexterm"/>because it's a Euclidean torus (see the definition <a id="id162" class="indexterm"/>on Wikipedia for more detail: <a class="ulink" href="http://en.wikipedia.org/wiki/Torus">http://en.wikipedia.org/wiki/Torus</a>). The top and the bottom of the screen wrap to meet each other, as do the left and right sides, except that the top right meets the bottom left, and vice versa. The level is finished when there are no more meteors on the screen.</p></div><div class="section" title="The enemies"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>The enemies</h2></div></div></div><p>There are two <a id="id163" class="indexterm"/>kinds of enemies: meteors and flying saucers. Both of them <a id="id164" class="indexterm"/>can destroy you if you crash into them, and both add some points when you destroy them by shooting at them.</p></div><div class="section" title="The meteors"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>The meteors</h2></div></div></div><p>There are three types of meteors. Each one<a id="id165" class="indexterm"/> has its own size, speed, and a points number that differs from the others. Here is a table that summarizes the different meteors' properties:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Size</p>
</th><th style="text-align: left" valign="bottom">
<p>Big</p>
</th><th style="text-align: left" valign="bottom">
<p>Medium</p>
</th><th style="text-align: left" valign="bottom">
<p>Small</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Speed</p>
</td><td style="text-align: left" valign="top">
<p>Slow</p>
</td><td style="text-align: left" valign="top">
<p>Medium</p>
</td><td style="text-align: left" valign="top">
<p>Fast</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Split</p>
</td><td style="text-align: left" valign="top">
<p>2~3 medium</p>
</td><td style="text-align: left" valign="top">
<p>2~3 smalls</p>
</td><td style="text-align: left" valign="top">
<p>-</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Base Points</p>
</td><td style="text-align: left" valign="top">
<p>20</p>
</td><td style="text-align: left" valign="top">
<p>60</p>
</td><td style="text-align: left" valign="top">
<p>100</p>
</td></tr></tbody></table></div><p>Each time a meteor is hit, it is split into a smaller meteor, except for the small ones. The big meteors are also those that represent the<a id="id166" class="indexterm"/> starting meteor field of each level.</p></div><div class="section" title="The flying saucers"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>The flying saucers</h2></div></div></div><p>Time to time! A flying saucer appears and tries to disturb the player. There are two saucers, a big one, which does<a id="id167" class="indexterm"/> nothing apart from moving, and a small one, that shoots at the player. The higher the score of the <a id="id168" class="indexterm"/>player, the higher is the chance that a small saucer appears instead of a big one. Starting from 40,000, only small saucers<a id="id169" class="indexterm"/> appear. In addition, the more points the player has, the higher is the precision of the saucers.</p></div></div></div>
<div class="section" title="Modifying our application"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Modifying our application</h1></div></div></div><p>Now that we have all the information required to build our game, let's start to change it. The first step is<a id="id170" class="indexterm"/> to change our world to a Euclidean torus with a fixed size. Here is a representation of a torus taken from the Wikipedia page:</p><div class="mediaobject"><img src="graphics/8477OS_03_04.jpg" alt="Modifying our application"/></div><p>To do this, we will need some information from inside the game, such as the world size. We will add the information inside the <code class="literal">Game</code> class as two integer values, <code class="literal">height</code> and <code class="literal">width</code>:</p><div class="informalexample"><pre class="programlisting">const int _x, const _y;</pre></div><p>We will initialize them with the constructor. So now, we need parameters for this class:</p><div class="informalexample"><pre class="programlisting">Game(int x=800, int y=600);</pre></div><p>We will need to change our constructor implementation a bit, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">Game::Game(int x, int y) : _window(sf::VideoMode(x,y),"03_Asteroid"),x(x),y(y){
     _player.setPosition(100,100);
}</pre></div><p>Okay, now we can choose<a id="id171" class="indexterm"/> the size of the world, but how do we make it a torus? In reality, it's not complicated. We only need to check the position of each entity after moving them; and if they are out of the world, we correct their positions.</p><p>Let's try this with the player, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">void Game::update(sf::Time deltaTime)
{
  _player.update(deltaTime);
  sf::Vector2f player_pos = _player.getPosition();
  if(player_pos.x &lt; 0){
    player_pos.x = _x;
    player_pos.y = _y - player_pos.y;
  } else if (player_pos.x &gt; _x){
    player_pos.x = 0;
    player_pos.y = _y - player_pos.y;
  }
  if(player_pos.y &lt; 0)
  player_pos.y = _y;
  else if(player_pos.y &gt; _y)
  player_pos.y = 0;
  _player.setPosition(player_pos);
}</pre></div><p>As you can see here, firstly, we call the <code class="literal">update()</code> method on the player, and then we correct its position if it's out of the world range. We now have an infinite world.</p><p>The <code class="literal">Player::getPosition()</code> method used is as follows:</p><div class="informalexample"><pre class="programlisting">const sf::Vector2f&amp; Player::getPosition()const{return _ship.getPosition();}</pre></div><p>The only sad thing with this is that we modify the player's position inside the <code class="literal">Game</code> class. It will be better if the player could manage its position itself, isn't it? Wrong! If you think a bit about this, you will understand that the player doesn't care about the world's shape. It's the world's work to be able to adapt the position of its entity, not the contrary.</p><p>Here we have two options: keep our code as it is or establish a more flexible system. If we quickly think about what will be required for the managements of the meteors and saucers, the second option seems best. So let's build a more flexible system.</p><p>In game development, there are two major design patterns that answer to this. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The hierarchical entity system</li><li class="listitem" style="list-style-type: disc">The entity component system</li></ul></div><p>Each of these patterns answer the problem in a different way. We will see them right after the world class.</p><div class="section" title="The World class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>The World class</h2></div></div></div><p>All our logic is actually<a id="id172" class="indexterm"/> made in the <code class="literal">Game</code> class. This is a good way, but we can do better. If we think about it, the <code class="literal">Game</code> class has to not only process events, create the window, and delegate other classes to the pause and menu systems, but also perform all the entity management.</p><p>To be more explicit, the game doesn't have to manage any entity, but can create a world and populate it. Then, all the work is done by the world class.</p><p>The world is a container of entities but also of sounds effects. It has a specific size, shape, and rules (such as physics). It can also be displayed on screen. Finally, the class looks similar to the following code snippet:</p><div class="informalexample"><pre class="programlisting">class World : public sf::Drawable
{
  public:
  World(const World&amp;) = delete;
  World&amp; operator=(const World&amp;) = delete;
  World(float x,float y);
  ~World();
  void add(Entity* entity);
  void clear();
  bool isCollide(const Entity&amp; other);
  int size();
 
  void add(Configuration::Sounds sound_id);
 
  const std::list&lt;Entity*&gt; getEntities()const;
  int getX()const;
  int getY()const;
  void update(sf::Time deltaTime);
  private:
  std::list&lt;Entity*&gt;  _entities; 
  std::list&lt;Entity*&gt;  _entities_tmp;

  std::list&lt;std::unique_ptr&lt;sf::Sound&gt;&gt; _sounds;
  virtual void draw(sf::RenderTarget&amp; target, sf::RenderStates 
  states) const override;

  const int _x;
  const int _y;
};</pre></div><p>Like the other classes, we make the <code class="literal">World</code> class non-replicable. We add some functions to add an entity to the world, and some functions to remove them all as well. Because it's possible to have some sounds in the world, we also add a method to add them. It takes an ID from the <code class="literal">Configuration</code> class, exactly like the IDs for <code class="literal">Textures</code>. We also add some functions to get information such as the number of entities, the size of the world, and so on.</p><p>Now if we take a look at the attributes, we can see two containers for the entities. This is a trick that will make our lives easier. I will explain it in the implementation. The other container is for <code class="literal">sf::Sound</code> that can be added to the world. I will also explain it in the implementation.</p><p>Now, take a look at the<a id="id173" class="indexterm"/> implementation. This class is a bit long, and some functions have been reduced to not take a lot of space in this chapter:</p><div class="informalexample"><pre class="programlisting">World::World(float x,float y): _x(x),_y(y){}
World::~World(){clear();}</pre></div><p>There is no difficulty in these functions. The constructor simply sets the size of the world, and the destructor clears it; as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">void World::add(Entity* entity) {
    _entities_tmp.push_back(entity);
}</pre></div><p>This is another simple function, but we don't add an entity directly to the <code class="literal">_entites</code> container. Instead, we add it to a temporary container that contains only the entities created during a particular time frame. The reason for doing this will be explained in the <code class="literal">update()</code> function:</p><div class="informalexample"><pre class="programlisting">void World::clear()
{
  for(Entity* entity :_entities)
  delete entity;
  _entities.clear();
  for(Entity* entity :_entities_tmp)
  delete entity;
  _entities_tmp.clear();
  _sounds.clear();
}</pre></div><p>Here, we clean the entire world by deleting all its entities and sounds. Because we use raw pointers for the entities, we need to delete them explicitly unlike <code class="literal">sf::Sound</code>:</p><div class="informalexample"><pre class="programlisting">void World::add(Configuration::Sounds sound_id)
{
  std::unique_ptr&lt;sf::Sound&gt; sound(new sf::Sound(Configuration::sounds.get(sound_id)));
  sound-&gt;setAttenuation(0);
  sound-&gt;play();
  _sounds.emplace_back(std::move(sound));
}</pre></div><p>This function creates a <code class="literal">sf::Sound</code> parameter from a <code class="literal">sf::SoundBuffer</code> parameter contained in the <code class="literal">Configuration</code> class, initialize it, and play it. Because each <code class="literal">sf::Sounds</code> has its own thread, the <code class="literal">sf::Sound::play()</code> parameter will not interrupt our main thread. And then, we store it in the appropriate container: </p><div class="informalexample"><pre class="programlisting">bool World::isCollide(const Entity&amp; other)
{
    for(Entity* entity_ptr : _entities)
        if(other.isCollide(*entity_ptr))
            return true;
    return false;
}</pre></div><p>The <code class="literal">World::isCollide()</code> function is a helper to check whether an entity is colliding with another one. This will be used to place the meteors at the beginning of the game:</p><div class="informalexample"><pre class="programlisting">int World::size(){return _entities.size() + _entities_tmp.size();}
int World::getX()const{return _x;}
int World::getY()const {return _y;}
const std::list&lt;Entity*&gt; World::getEntities()const {return _entities;}</pre></div><p>These functions are pretty simple. There <a id="id174" class="indexterm"/>are just some getters. The only thing that is particular is <code class="literal">size()</code> because it returns the total number of entities:</p><div class="informalexample"><pre class="programlisting">void World::update(sf::Time deltaTime)
{
  if(_entities_tmp.size() &gt; 0)
  _entities.merge(_entities_tmp);
  for(Entity* entity_ptr : _entities)
  {
    Entity&amp; entity = *entity_ptr; 
    entity.update(deltaTime);    
    sf::Vector2f pos = entity.getPosition();
    if(pos.x &lt; 0)
    {
      pos.x = _x;
      pos.y = _y - pos.y;
    } else if (pos.x &gt; _x) {
      pos.x = 0;
      pos.y = _y - pos.y;
    }
    if(pos.y &lt; 0)
    pos.y = _y;
    else if(pos.y &gt; _y)
    pos.y = 0;
    entity.setPosition(pos);
  }
  const auto end = _entities.end();
  for(auto it_i = _entities.begin(); it_i != end; ++it_i)
  {
    Entity&amp; entity_i = **it_i;
    auto it_j = it_i;
    it_j++;
    for(; it_j != end;++it_j)
    {
      Entity&amp; entity_j = **it_j;
      if(entity_i.isAlive() and entity_i.isCollide(entity_j))
      entity_i.onDestroy();
      if(entity_j.isAlive() and entity_j.isCollide(entity_i))
      entity_j.onDestroy();
    }
  }
  for(auto it = _entities.begin(); it != _entities.end();)
  {
    if(not (*it)-&gt;isAlive())
    {
      delete *it;
      it = _entities.erase(it);
    }
    else
    ++it;
  }
  _sounds.remove_if([](const std::unique_ptr&lt;sf::Sound&gt;&amp; sound) -&gt; bool {
    return sound-&gt;getStatus() != sf::SoundSource::Status::Playing;
  });
}</pre></div><p>This function is a<a id="id175" class="indexterm"/> bit more complicated than the previous version of it. Let's explain it in detail:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We merge the entities' container together into the main container.</li><li class="listitem">We update all entities, and then verify that their positions are correct. If this is not the case, we correct them.</li><li class="listitem">We check the collision between all the entities and dead entities are removed.</li><li class="listitem">Sounds that have been played are removed from the container.</li></ol></div><p>In the update and collision loops, some entities can create others. That's the reason for the <code class="literal">_entities_tmp</code> container. In this way, we are sure that our iterator is not broken at any time, and we do not update/collide entities that have not experienced a single frame, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">void World::draw(sf::RenderTarget&amp; target, sf::RenderStates states) const
{
  for(Entity* entity : _entities)
  target.draw(*entity,states);
}</pre></div><p>This function is simple, and forwards its job to all the entities. As you can see, the <code class="literal">World</code> class is not really complicated, and<a id="id176" class="indexterm"/> manages any kind of entities and all sounds. By doing this, we can remove a lot of tasks from the <code class="literal">Game</code> class, and delegate it to the <code class="literal">World</code> class.</p></div><div class="section" title="The hierarchical entity system"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>The hierarchical entity system</h2></div></div></div><p>This system is the<a id="id177" class="indexterm"/> most intuitive. Each kind of entity is a different class in your code, and all of them are extended from a common virtual class, most of the time <a id="id178" class="indexterm"/>called <span class="strong"><strong>Entity</strong></span>. All the logic is made inside the class in the <code class="literal">Entity::update()</code> function. For our project, the hierarchical tree could be similar to the following figure:</p><div class="mediaobject"><img src="graphics/8477OS_03_01.jpg" alt="The hierarchical entity system"/></div><p>As you can see, there are <a id="id179" class="indexterm"/>several abstraction layers. For this project, and because we don't have a lot of different kind of entities, we will use this solution.</p></div><div class="section" title="The entity component system"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>The entity component system</h2></div></div></div><p>This is a totally different <a id="id180" class="indexterm"/>approach. Instead of having each type of entity represented as a class, there is only one class: entity. To this entity, we attach some property such as the position, ability to be draw, a gun, and whatever you want. This system is really powerful, and is a great solution in video games, but is also difficult to build. I will not get into more detail about this system, because I will come back to it in the next chapter. So even if we don't use it right now, don't be frustrated, we will build and use it in the next project.</p></div></div>
<div class="section" title="Designing our game"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Designing our game</h1></div></div></div><p>Now that we have chosen the entity component system approach and created a world that will be <a id="id181" class="indexterm"/>populated by them, let's think about the needs. Following table summarizes the needs:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Entity</p>
</th><th style="text-align: left" valign="bottom">
<p>Parent</p>
</th><th style="text-align: left" valign="bottom">
<p>Specificities</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Entity</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>This can move</p>
<p>This can be drawn</p>
<p>This can collide with another entity</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Player</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Entity</p>
</td><td style="text-align: left" valign="top">
<p>This can shoot</p>
<p>This is controlled by inputs</p>
<p>This can collide with everything except the one it shoots</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Enemy</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Entity</p>
</td><td style="text-align: left" valign="top">
<p>This can be destroyed by shooting</p>
<p>This gets the player some points when destroyed by shooting</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Saucer</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Enemy</p>
</td><td style="text-align: left" valign="top">
<p>This has a bigger chance to spawn a small saucer when the point number increases</p>
<p>This can collide with everything except saucer shoots</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">BigSaucer</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Saucer</p>
</td><td style="text-align: left" valign="top">
<p>This has a special skin</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SmallSaucer</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Saucer</p>
</td><td style="text-align: left" valign="top">
<p>This can shoot the <code class="literal">Player</code> entity</p>
<p>This has a special skin</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Meteors</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Enemy</p>
</td><td style="text-align: left" valign="top">
<p>This can collide with everything except other meteors</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">BigMeteor</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Meteors</p>
</td><td style="text-align: left" valign="top">
<p>This splits into some <code class="literal">MediumMeteor</code> when destroyed</p>
<p>This has a special skin</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">MediumMeteor</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Meteors</p>
</td><td style="text-align: left" valign="top">
<p>This splits into <code class="literal">SmallMetors</code> when destroyed</p>
<p>This has a special skin</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SmallMeteor</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Meteors</p>
</td><td style="text-align: left" valign="top">
<p>This has a special skin</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Shoot</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Entity</p>
</td><td style="text-align: left" valign="top">
<p>This lives for a specific time</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ShootPlayer</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Shoot</p>
</td><td style="text-align: left" valign="top">
<p>This can only collide with enemies</p>
<p>This has a specific skin</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ShootSaucer</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Shoot</p>
</td><td style="text-align: left" valign="top">
<p>This can collide with <code class="literal">Meteor</code> and <code class="literal">Player</code>
</p>
<p>This has a special skin</p>
</td></tr></tbody></table></div><p>Now that we have all the<a id="id182" class="indexterm"/> information needed for each class, let's build them. The final result will look similar to the following:</p><div class="mediaobject"><img src="graphics/8477OS_03_05.jpg" alt="Designing our game"/></div><div class="section" title="Prepare the collisions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Prepare the collisions</h2></div></div></div><p>In this project we will use a simple collision detection: collision between circles. As just said this is very basic and can be improved a lot, but is sufficient for now. Take a look to the class:</p><div class="informalexample"><pre class="programlisting">class Collision
{
  public:
    Collision() = delete;
    Collision(const Collision&amp;) = delete;
    Collision&amp; operator=(const Collision&amp;) = delete;
    static bool circleTest(const sf::Sprite&amp; first, const sf::Sprite&amp; second);
};</pre></div><p>The is no member here, and the class can't be instantiate. The aim of the class is to group some helper function used by other classes. So here, only one collision test is describe that take two <code class="literal">sf::Sprite</code> as parameters. Take a look to the implementation.</p><div class="informalexample"><pre class="programlisting">bool Collision::circleTest(const sf::Sprite&amp; first, const sf::Sprite&amp; second)
{
  sf::Vector2f first_rect(first.getTextureRect().width,
  first.getTextureRect().height);
  first_rect.x *= first.getScale().x;
  first_rect.y *= first.getScale().y;

  sf::Vector2f second_rect(second.getTextureRect().width, 
  second.getTextureRect().height);
  second_rect.x *= second.getScale().x;
  second_rect.y *= second.getScale().y;

  float radius1 = (first_rect.x + first_rect.y) / 4;
  float radius2 = (second_rect.x + second_rect.y) / 4;
  float xd = first.getPosition().x - second.getPosition().x;
  float yd = first.getPosition().y - second.getPosition().y;

  return std::sqrt(xd * xd + yd * yd) &lt;= radius1 + radius2;
}</pre></div><p>The function first computes the radius for each of the sprite. Then it checks if the distance between the two sprites (computed using the Pythagoras theorem) is less than the sum of the tow radius. If it's verify, then there is no collision, on the other side, there is one, even if we don't exactly know the exact point.</p></div><div class="section" title="The Entity class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>The Entity class</h2></div></div></div><p>To build our system, we need the<a id="id183" class="indexterm"/> base class, so let's start with the <code class="literal">Entity</code> class:</p><div class="informalexample"><pre class="programlisting">class Entity :  public sf::Drawable
{
  public:
//Constructors
  Entity(const Entity&amp;) = delete;
  Entity&amp; operator=(const Entity&amp;) = delete;
  Entity(Configuration::Textures tex_id,World&amp; world);
  virtual ~Entity();
 
//Helpers
  virtual bool isAlive()const;
 
  const sf::Vector2f&amp; getPosition()const;
  template&lt;typename ... Args&gt;
  void setPosition(Args&amp;&amp; ... args);
  virtual bool isCollide(const Entity&amp; other)const = 0;
 
//Updates
  virtual void update(sf::Time deltaTime) = 0;
  virtual void onDestroy();

  protected:
  sf::Sprite _sprite;
  sf::Vector2f _impulse;
  World&amp; _world;
  bool _alive;

  private :
  virtual void draw(sf::RenderTarget&amp; target, sf::RenderStates 
  states) const override;
};</pre></div><p>Let's discuss this class step by step:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Firstly, we make the class noncopyable.</li><li class="listitem">Then we make the destructor virtual. This is a really important point because the <code class="literal">Entity</code> class will be used as a polymorphic class. So we need to set the destructor as virtual to be able to destruct the real object and not only it's <code class="literal">Entity</code> base.</li><li class="listitem">We also define <a id="id184" class="indexterm"/>some helper functions to know if the entity is alive and also to set/get its position. The code is the same as we have in the <code class="literal">Player</code> class. We also define some virtual methods that will be overridden in other classes.</li><li class="listitem">The virtual function <code class="literal">onDestroy()</code> is important. Its goal is to execute some code before the destruction on the entity by shooting it or whatever. For example, the ability of a <code class="literal">Meteor</code> entity to be split will be put in this function, and so will all kind of sounds caused by the destruction of the object.</li></ol></div><p>Now take a look to the implementation of the <code class="literal">Entity</code> class:</p><div class="informalexample"><pre class="programlisting">Entity::Entity(Configuration::Textures tex_id,World&amp; world) : _world(world),_alive(true)
{
  sf::Texture&amp; texture = Configuration::textures.get(tex_id);
  _sprite.setTexture(texture);
  _sprite.setOrigin(texture.getSize().x/2.f,texture.getSize().y/2.f);
}</pre></div><p>The constructor sets the texture to the internal <code class="literal">sf::Sprite</code> function, and then center the origin of it. We also set the world of the entity, and the alive value:</p><div class="informalexample"><pre class="programlisting">const sf::Vector2f&amp; Entity::getPosition()const {return _sprite.getPosition();}
void Entity::draw(sf::RenderTarget&amp; target, sf::RenderStates states) const {target.draw(_sprite,states);}</pre></div><p>These two functions are the exact same as those in the <code class="literal">Player</code> class. So no surprises here:</p><div class="informalexample"><pre class="programlisting">bool Entity::isAlive()const {return _alive;}
void Entity::onDestroy(){_alive = false;}</pre></div><p>These two functions are new. It's simply a helper function. <code class="literal">IsAlive()</code> is used to know if an entity have to be removed from the world, and the <code class="literal">onDestroy()</code> function is a method that will be called when a collision is detected with another <code class="literal">Entity</code>. Nothing complicated for now.</p></div><div class="section" title="The Player class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>The Player class</h2></div></div></div><p>Now that we have<a id="id185" class="indexterm"/> the <code class="literal">Entity</code> class, let's change the <code class="literal">Player</code> class to extend it from <code class="literal">Entity</code>:</p><div class="informalexample"><pre class="programlisting">class Player : public Entity , public ActionTarget&lt;int&gt;
{
  public:
  Player(const Player&amp;) = delete;
  Player&amp; operator=(const Player&amp;) = delete;
  Player(World&amp; world);

  virtual bool isCollide(const Entity&amp; other)const;
  virtual void update(sf::Time deltaTime);
  void processEvents();
  void shoot();
  void goToHyperspace();
  virtual void onDestroy();

  private:
  bool _isMoving;
  int _rotation;
  sf::Time _timeSinceLastShoot;
}</pre></div><p>As you can see, we removed all the functions and attributes related to the position and the display. The <code class="literal">Entity</code> class already does it for us. And now the implementation of this class is as follows:</p><div class="informalexample"><pre class="programlisting">Player::Player(World&amp; world) : Entity(Configuration::Textures::Player,world),ActionTarget(Configuration::player_inputs),_isMoving(false),_rotation(0)
{
  //bind ..     
  bind(Configuration::PlayerInputs::Shoot,[this](const sf::Event&amp;){
    shoot();
  });
  bind(Configuration::PlayerInputs::Hyperspace,[this](const sf::Event&amp;){
    goToHyperspace();
  });
}</pre></div><p>Here we remove all the code that initializes the <code class="literal">_sprite</code> function, and delegate the job to the <code class="literal">Entity</code> constructor. We also add two new abilities, to shoot and to go to hyperspace:</p><div class="informalexample"><pre class="programlisting">bool Player::isCollide(const Entity&amp; other)const
{
  if(dynamic_cast&lt;const ShootPlayer*&gt;(&amp;other) == nullptr) {
    return Collision::circleTest(_sprite,other._sprite);
  }
  return false;
}</pre></div><p>We set the default behavior of the collision. We need to know the real type of the <code class="literal">Entity</code> as a parameter. To do this we use the virtual table lookup by trying to convert the <code class="literal">Entity</code> class to a specific pointer type. If this is not possible, <code class="literal">nullptr</code> is returned by <code class="literal">dynamic_cast()</code>. There are other approaches to do this, such as double dispatch. But the one used here is the simplest and easy to understand but is a slow operation. Once the real type of entity is known, the collision test is made. In this project, the hit box of each entity is the circle<a id="id186" class="indexterm"/> inscribed in its sprite. This is a pretty good approximation:</p><div class="informalexample"><pre class="programlisting">void Player::shoot()
{
  if(_timeSinceLastShoot &gt; sf::seconds(0.3))
  {
    _world.add(new ShootPlayer(*this));
    _timeSinceLastShoot = sf::Time::Zero;
  }
}</pre></div><p>This function creates a <code class="literal">ShootPlayer</code> instance and adds it to the world. Because we don't want that the player to create a shoot in every frame, we add a timer that is updated in the <code class="literal">Player::update()</code> method, as shown:</p><div class="informalexample"><pre class="programlisting">void Player::goToHyperspace()
{
  _impulse = sf::Vector2f(0,0);
  setPosition(random(0,_world.getX()),random(0,_world.getY()));
  _world.add(Configuration::Sounds::Jump);
}</pre></div><p>This method teleports the player to a random place in the world. It also removes all the impulsion, so the player will not continue to move in its previous direction after a teleportation:</p><div class="informalexample"><pre class="programlisting">void Player::update(sf::Time deltaTime)
{
  float seconds = deltaTime.asSeconds();
  _timeSinceLastShoot += deltaTime;
  if(_rotation != 0)
  {
    float angle = _rotation*250*seconds;
    _sprite.rotate(angle);
  }
 
  if(_isMoving)
  {
    float angle = _sprite.getRotation() / 180 * M_PI - M_PI / 2;
    _impulse += sf::Vector2f(std::cos(angle),std::sin(angle)) * 300.f * 
    seconds;
  }
  _sprite.move(seconds * _impulse);
}</pre></div><p>This method updates the position and the rotation of a <code class="literal">Player</code> according to the different action made by the user. It also updates the time since the last shoot to be able to shoot again.</p><div class="informalexample"><pre class="programlisting">void Player::onDestroy()
{
  Entity::onDestroy();
  Configuration::lives--;
  _world.add(Configuration::Sounds::Boom);
}</pre></div><p>To better understand the <code class="literal">Entity::onDestroy()</code> method, remember that this function is called before the destruction (and the call of the destructor) of an <code class="literal">Entity</code> instance when a collision occurs. So here we call the <code class="literal">onDestroy()</code> function of the <code class="literal">Entity</code> base of the class, and then do the<a id="id187" class="indexterm"/> special things of the player, such as reduce the number of lives, set the player value to <code class="literal">nullptr</code>, and finally, add an explosion sound to the world. The other methods of the <code class="literal">Player</code> class have not changed.</p></div><div class="section" title="The Enemy class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>The Enemy class</h2></div></div></div><p>We will now create<a id="id188" class="indexterm"/> the Enemy class as we have already described, in the table at the beginning of the <code class="literal">Design our game part</code>:</p><div class="informalexample"><pre class="programlisting">class Enemy : public Entity
{
  public:
  Enemy(const Enemy&amp;) = delete;
  Enemy&amp; operator=(const Enemy&amp;) = delete;
  Enemy(Configuration::Textures tex_id,World&amp; world);

  virtual int getPoints()const = 0;
  virtual void onDestroy();
};</pre></div><p>This class is pretty small because it doesn't need a lot of new logic compared to the <code class="literal">Player</code> class. We only need to briefly specify the <code class="literal">onDestroy()</code> method by adding points to the global score of the game. So we create a <code class="literal">getPoints()</code> method that will simply return the number of points for an enemy.</p><div class="informalexample"><pre class="programlisting">Enemy::Enemy(Configuration::Textures tex_id,World&amp; world) : 
  Entity(tex_id,world)
{
  float angle = random(0.f,2.f*M_PI);
  _impulse = sf::Vector2f(std::cos(angle),std::sin(angle));
}</pre></div><p>The constructor simply initializes the <code class="literal">_impulse</code> vector to a random one, but with the length as <code class="literal">1</code>. This vector will be multiplied by the speed of the <code class="literal">Saucers</code>/<code class="literal">Meteor</code> entity in their respective constructors:</p><div class="informalexample"><pre class="programlisting">void Enemy::onDestroy()
{
  Entity::onDestroy();
  Configuration::addScore(getPoints());
}</pre></div><p>This method simply calls the <code class="literal">onDestroy()</code> function from the <code class="literal">Entity</code> base of the object, and then adds the<a id="id189" class="indexterm"/> points won by destroying the object.</p></div><div class="section" title="The Saucer class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>The Saucer class</h2></div></div></div><p>Now that we have the <code class="literal">Enemy</code> class made, we can build the <code class="literal">Saucer</code> base class corresponding to<a id="id190" class="indexterm"/> our expectations:</p><div class="informalexample"><pre class="programlisting">class Saucer : public Enemy
{
  public:
  Saucer(const Saucer&amp;) = delete;
  Saucer&amp; operator=(const Saucer&amp;) = delete;
  using Enemy::Enemy;

  virtual bool isCollide(const Entity&amp; other)const;
  virtual void update(sf::Time deltaTime);
  virtual void onDestroy();
  static void newSaucer(World&amp; world);
};</pre></div><p>This class is pretty simple; we just have to specify the method already built in the <code class="literal">Entity</code> and <code class="literal">Enemy</code> class. Because the class will not specify the constructor, we use the using-declaration to refer to the one from <code class="literal">Enemy</code>. Here, we introduce a new function, <code class="literal">newSaucer()</code>. This function will randomly create a saucer depending on the player's score and add it to the world.</p><p>Now, take a look to the implementation of this class:</p><div class="informalexample"><pre class="programlisting">bool Saucer::isCollide(const Entity&amp; other)const
{
  if(dynamic_cast&lt;const ShootSaucer*&gt;(&amp;other) == nullptr) {
    return Collision::circleTest(_sprite,other._sprite);
  }
  return false;
}</pre></div><p>The same technique as in <code class="literal">Player::isCollide()</code> is used here, so no surprises. We specify this function in the <code class="literal">Saucer</code> base class because the collisions are the same for any of the saucers. It avoids code duplication as follows:</p><div class="informalexample"><pre class="programlisting">void Saucer::update(sf::Time deltaTime)
{
  float seconds = deltaTime.asSeconds();
  Entity* near = nullptr;
  float near_distance = 300;
  for(Entity* entity_ptr : _world.getEntities())
  {
    if(entity_ptr != this and(dynamic_cast&lt;const 
      Meteor*&gt;(entity_ptr) or dynamic_cast&lt;const 
        ShootPlayer*&gt;(entity_ptr)))
    {
      float x = getPosition().x - entity_ptr-&gt;getPosition().x;
      float y = getPosition().y - entity_ptr-&gt;getPosition().y;
      float dist = std::sqrt(x*x + y*y);
      if(dist &lt; near_distance) {
 
           near_distance = dist;
           near = entity_ptr;
     }
  }
}
if(near != nullptr) 
{
  sf::Vector2f pos = near-&gt;getPosition() - getPosition();
  float angle_rad = std::atan2(pos.y,pos.x);
  _impulse -= 
    sf::Vector2f(std::cos(angle_rad),std::sin(angle_rad)) * 300.f 
      * seconds;
} else {
  sf::Vector2f pos = Configuration::player-&gt;getPosition() - 
    getPosition();
  float angle_rad = std::atan2(pos.y,pos.x);
  _impulse += 
    sf::Vector2f(std::cos(angle_rad),std::sin(angle_rad)) * 100.f 
      * seconds;
  }
_sprite.move(seconds * _impulse);
}</pre></div><p>This function is <a id="id191" class="indexterm"/>pretty long but not really complicated. It manages the movement of the saucer. Let's explain it step by step:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We look for the nearest object of the saucer into which it may crash.</li><li class="listitem">If there is an object found too close, we add an impulse to the saucer in the opposite direction of this object. The goal is to avoid a crash.</li><li class="listitem">Let's now continue with the other functions.<div class="informalexample"><pre class="programlisting">void Saucer::onDestroy()
{
    Enemy::onDestroy();
    _world.add(Configuration::Sounds::Boom2);
}</pre></div></li><li class="listitem">This function is simple. We simply call the <code class="literal">onDestroy()</code> method from the <code class="literal">Enemy</code> base of the class, and then add an explosion sound to the world:<div class="informalexample"><pre class="programlisting">void Saucer::newSaucer(World&amp; world)
{
  Saucer* res = nullptr;
  if(book::random(0.f,1.f) &gt; Configuration::getScore()/ 40000.f)
  res = new BigSaucer(world);
  else
  res = new SmallSaucer(world);
  res-&gt;setPosition(random(0,1)*world.getX(),random(0.f,(float)world.getY()));
  world.add(res);
}</pre></div></li><li class="listitem">As previously mentioned, this function creates a saucer randomly and adds it to the world. The more the points the player has, the greater the chance to create a <code class="literal">SmallSaucer</code> entity. When the score reaches 40,000 <code class="literal">SmallSaucer</code> is created as explained in the description of the game.</li></ol></div><p>Now that we have created the <code class="literal">Saucer</code> base class, let's make the <code class="literal">SmallSaucer</code> class. I'll not explain the <code class="literal">BigSaucer</code> class<a id="id192" class="indexterm"/> because this is the same as the <code class="literal">SmallSaucer</code> class but simpler (no shooting), as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">class SmallSaucer : public Saucer
{
  public :
  SmallSaucer(World&amp; world);
  virtual int getPoints()const;
  virtual void update(sf::Time deltaTime);
  private:
  sf::Time_timeSinceLastShoot;
};</pre></div><p>Because we know the skin of the <code class="literal">SmallSaucer</code> entity, we don't need the texture ID as a parameter, so we remove it from the constructor parameter. We also add an attribute to the class that will store the elapsed time since the last shoot was made, as in <code class="literal">Player</code> entity.</p><p>Now take a look at the implementation:</p><div class="informalexample"><pre class="programlisting">SmallSaucer::SmallSaucer(World&amp; world) : Saucer(Configuration::Textures::SmallSaucer,world)
{
  _timeSinceLastShoot = sf::Time::Zero;
  _world.add(Configuration::Sounds::SaucerSpawn2);
  _impulse *= 400.f;
}</pre></div><p>This constructor is simple because a great part of the job is already done in the base of the class. We just initialize the impulsion and add a sound to the world when the saucer appears. This will alert the player of the enemy and add some fun to the game:</p><div class="informalexample"><pre class="programlisting">int SmallSaucer::getPoints()const {return 200;}</pre></div><p>This function simply<a id="id193" class="indexterm"/> sets the number of points that are won when the <code class="literal">SmallSaucer</code> entity is destroyed:</p><div class="informalexample"><pre class="programlisting">void SmallSaucer::update(sf::Time deltaTime)
{
  Saucer::update(deltaTime);
  _timeSinceLastShoot += deltaTime;
  if(_timeSinceLastShoot &gt; sf::seconds(1.5))
  {
    if(Configuration::player != nullptr)
    _world.add(new ShootSaucer(*this));
    _timeSinceLastShoot = sf::Time::Zero;
  }
}</pre></div><p>This function is fairly simple. Firstly, we just move the saucer by calling the <code class="literal">update()</code> function from the <code class="literal">Saucer</code> base, then shoot the player as soon as we can, and that's all. </p><p>Here is a screenshot of the saucer behavior:</p><div class="mediaobject"><img src="graphics/8477OS_03_06.jpg" alt="The Saucer class"/></div></div><div class="section" title="The Meteor class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>The Meteor class</h2></div></div></div><p>Now it's time to build the main <a id="id194" class="indexterm"/>enemies of the game: the meteors. We will start by the virtual <code class="literal">Meteor</code> class. Here is its definition:</p><div class="informalexample"><pre class="programlisting">class Meteor : public Enemy
{
  public:
  Meteor(const Meteor&amp;) = delete;
  Meteor&amp; operator=(const Meteor&amp;) = delete;
  using Enemy::Enemy;

  virtual bool isCollide(const Entity&amp; other)const;
  virtual void update(sf::Time deltaTime);
};</pre></div><p>As you can see, this class is very short. We only specify the collision rules and the update function that will manage its move. Now, take a look at its implementation:</p><div class="informalexample"><pre class="programlisting">bool Meteor::isCollide(const Entity&amp; other)const
{
  if(dynamic_cast&lt;const Meteor*&gt;(&amp;other) == nullptr) {
    return Collision::circleTest(_sprite,other._sprite);
  }
  return false;
}</pre></div><p>The collisions are tested with all <code class="literal">Entity</code> except the <code class="literal">Meteors</code> as it was specified. Here again, we use the <code class="literal">circleTest()</code> function to test the collision with the other objects:</p><div class="informalexample"><pre class="programlisting">void Meteor::update(sf::Time deltaTime)
{
  float seconds = deltaTime.asSeconds();
  _sprite.move(seconds * _impulse);
}</pre></div><p>This function couldn't be more simple. We only move the <code class="literal">meteor</code> entity by computing the distance traveled since the last frame. There is nothing complicated to do here because a meteor is straight all the time, so there is no change in its direction.</p><p>Now that we have the base of all the meteors, let's make the big one. I will not explain the others because the logic is the same. The following code snippet explains it:</p><div class="informalexample"><pre class="programlisting">class BigMeteor : public Meteor
{
  public :
  BigMeteor(World&amp; world);
  virtual int getPoints()const;
  virtual void onDestroy();
};</pre></div><p>You can see this class is also very concise. We only need to define the constructor, the number of points earned, and the destruction. And now, the implementation of this class is as follows:</p><div class="informalexample"><pre class="programlisting">BigMeteor::BigMeteor(World&amp; world) : Meteor((Configuration::Textures)random(Configuration::Textures::BigMeteor1,Configuration::Textures::BigMeteor4),world)
{
  _impulse *= 100.f;
}</pre></div><p>The constructor is not <a id="id195" class="indexterm"/>difficult, but the choice of the texture ID is. Because there are several textures possible for a <code class="literal">BigMeteor</code>, we choose one of them randomly, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">int BigMeteor::getPoints()const {return 20;h}
void BigMeteor::onDestroy()
{
  Meteor::onDestroy();
  int nb = book::random(2,3);
  for(int i=0;i&lt;nb;++i)
  {
    MediumMeteor* meteor = new MediumMeteor(_world);
    meteor-&gt;setPosition(getPosition());
    _world.add(meteor);
  }
  _world.add(Configuration::Sounds::Explosion1);
}</pre></div><p>This method is the most important one. It creates some other meteors when a big one is destroyed, and adds them to the world. We also add an explosion sound for more fun during the game.</p></div><div class="section" title="The Shoot class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>The Shoot class</h2></div></div></div><p>Now that all the enemies<a id="id196" class="indexterm"/> are made, let's build the last entity class, the <code class="literal">Shoot</code>. A Shoot is very simple. It's nothing but an entity that goes straight, and lives only for a specific time:</p><div class="informalexample"><pre class="programlisting">class Shoot : public Entity
{
  public:
  Shoot(const Shoot&amp;) = delete;
  Shoot&amp; operator=(const Shoot&amp;) = delete;
  using Entity::Entity;
  virtual void update(sf::Time deltaTime);
  protected:
  sf::Time _duration;
};</pre></div><p>Nothing surprising here, we only add a <code class="literal">_duration</code> attribute that will store the elapsed time since the creation of the <code class="literal">Shoot</code> class. Now, the implementation of the update function is as follows:</p><div class="informalexample"><pre class="programlisting">void Shoot::update(sf::Time deltaTime)
{
  float seconds = deltaTime.asSeconds();
  _sprite.move(seconds * _impulse);
  _duration -= deltaTime;
  if(_duration &lt; sf::Time::Zero)
  _alive = false;
}</pre></div><p>This function moves the shoot and adjusts the <code class="literal">_duration</code> attribute by removing the elapsed time. If the shoot live time reaches zero, we set it to dead, and the world will do the rest.</p><p>Now, let's build the <code class="literal">ShootPlayer</code> class:</p><div class="informalexample"><pre class="programlisting">class ShootPlayer : public Shoot
{
  public :
  ShootPlayer(const ShootPlayer&amp;) = delete;
  ShootPlayer&amp; operator=(const ShootPlayer&amp;) = delete;
  ShootPlayer(Player&amp; from);

  virtual bool isCollide(const Entity&amp; other)const;
};</pre></div><p>As you can see, the constructor has changed here. There is no more a <code class="literal">World</code> instance as a parameter apart from the source that creates the shoot. Let's take a look at the implementation to better understand the reason for this:</p><div class="informalexample"><pre class="programlisting">ShootPlayer::ShootPlayer(Player&amp; from) : Shoot(Configuration::Textures::ShootPlayer,from._world)
{
  _duration = sf::seconds(5);
  float angle = from._sprite.getRotation() / 180 * M_PI - M_PI / 2;
  _impulse = sf::Vector2f(std::cos(angle),std::sin(angle)) * 500.f;
  setPosition(from.getPosition());
  _sprite.setRotation(from._sprite.getRotation());
  _world.add(Configuration::Sounds::LaserPlayer);
}</pre></div><p>As you can see, the world instance is copied from the source. Moreover, the initial position of the bullet is set to the position of the <code class="literal">Player</code> class when it is created. We also rotate the bullet as needed, and set its direction. I will not explain the collision function because there is nothing new compared to the previously explained functions.</p><p>The <code class="literal">ShootSaucer</code> class<a id="id197" class="indexterm"/> uses the same logic as the <code class="literal">ShootPlayer</code> class, but there is a change. The accuracy of the saucers changes with the number of points of the player. So we need to add a bit of randomness. Let's take a look to the constructor:</p><div class="informalexample"><pre class="programlisting">ShootSaucer::ShootSaucer(SmallSaucer&amp; from) : Shoot(Configuration::Textures::ShootSaucer,from._world)
{
  _duration = sf::seconds(5); 
  sf::Vector2f pos = Configuration::player-&gt;getPosition() - from.getPosition();
  float accuracy_lost = book::random(-1.f,1.f)*M_PI/((200+Configuration::getScore())/100.f);
  float angle_rad = std::atan2(pos.y,pos.x) + accuracy_lost;
  float angle_deg = angle_rad * 180 / M_PI;

  _impulse = sf::Vector2f(std::cos(angle_rad),std::sin(angle_rad)) * 500.f;
  setPosition(from.getPosition());
  _sprite.setRotation(angle_deg + 90);
  _world.add(Configuration::Sounds::LaserEnemy);
}</pre></div><p>Let's explain this function step by step:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We compute the direction vector of the bullet.</li><li class="listitem">We add to it a little loss of accuracy depending of the current score.</li><li class="listitem">We set the <code class="literal">_impulsion</code> vector depending on the computed direction.</li><li class="listitem">We set the position and the rotation of the sprite as needed.</li><li class="listitem">And finally, we release it to the world.</li></ol></div><p>Now that all the classes <a id="id198" class="indexterm"/>have been made, you will be able to play the game. The final result should look like this:</p><div class="mediaobject"><img src="graphics/8477OS_03_02.jpg" alt="The Shoot class"/></div><p>Pretty nice, isn't it?</p></div></div>
<div class="section" title="Building a Tetris clone"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Building a Tetris clone</h1></div></div></div><p>Now that we've created a complete game, let's build another one, a <span class="strong"><strong>Tetris</strong></span> clone. This game is simpler than the previous one and will take less time to build, but is still very interesting. In fact, the internal architecture of this game is really different from the others. This is due to<a id="id199" class="indexterm"/> the kind of game that it is: a puzzle. The aim of the game is to fill lines of a grid with pieces made of four squares. Each time a line in completed, it's destroyed, and points are<a id="id200" class="indexterm"/> added to the player. Because this is a different kind of game, there are several implications as there is no player or no enemies in this game, only pieces and a board (grid). For this game, I will focus on the game logic only. So I will not reuse the previously made classes such as <code class="literal">Action</code>, <code class="literal">ActionMap</code>, <code class="literal">ActionTarget</code>, <code class="literal">Configuration</code>, and <code class="literal">ResourceManager</code> to be more concise. Of course, you can use them to improve the proposed source code.</p><p>So, to build this game we will need to build some classes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Game</code>: This class will be very similar to the <code class="literal">Game</code> class from the previous project and will manage the rendering</li><li class="listitem" style="list-style-type: disc"><code class="literal">Board</code>: This class will manage all the logic of the game</li><li class="listitem" style="list-style-type: disc"><code class="literal">Piece</code>: This class will represent all the different kinds of tetrimino (pieces formed by four squares)</li><li class="listitem" style="list-style-type: disc"><code class="literal">Stats</code>: This class will be used to show different information to the player</li></ul></div><p>The final game will look like<a id="id201" class="indexterm"/> the following screenshot:</p><div class="mediaobject"><img src="graphics/8477OS_03_03.jpg" alt="Building a Tetris clone"/></div><p>Now that we know how to structure a game, we will directly think about the need of each class.</p><div class="section" title="The Stats class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>The Stats class</h2></div></div></div><p>This class will be used to display the game information to the player such as the level, the number of rows, and the score. We will also use this class to display the <span class="strong"><strong>Game Over</strong></span> message if it's needed. Because this<a id="id202" class="indexterm"/> class will display some information to the screen and can be put anywhere on the render space, we will extend it from <code class="literal">sf::Drawable</code> and <code class="literal">sf::Transformable</code>. Here is the header of this class:</p><div class="informalexample"><pre class="programlisting">class Stats : public sf::Transformable,public sf::Drawable
{
  public:
  Stats();
  void addLines(int lines);
  unsigned int getLvl()const;
  void gameOver();

  private:
  virtual void draw(sf::RenderTarget&amp; target,sf::RenderStates states=sf::RenderStates::Default) const override;

  unsigned int _nbRows;
  unsigned int _nbScore;
  unsigned int _nbLvl;
  bool _isGameOver;

  sf::Text _textRows;
  sf::Text _textScore;
  sf::Text _textLvl;
  sf::Text _textGameOver;
  sf::Font _font;
};</pre></div><p>There is no real surprise for this class. We have some <code class="literal">sf::Text</code> that will be used to display information, and their values as numbers. We also add the point calculation to this class with the <code class="literal">addLines()</code> function.</p><p>As previously mentioned, for the Tetris game, we need to focus on the game logic, so we are not going to use any manager for the font.</p><p>Now take a look at the implementation of this class:</p><div class="informalexample"><pre class="programlisting">constexpr int  FONT_SIZE 24;
Stats::Stats() : _nbRows(0), _nbScore(0), _nbLvl(0), _isGameOver(false)
{
  _font.loadFromFile("media/fonts/trs-million.ttf");
  _textRows.setFont(_font);
  _textRows.setString("rows : 0");
  _textRows.setCharacterSize(FONT_SIZE);
  _textRows.setPosition(0,0);

  _textScore.setFont(_font);
  _textScore.setString("score : 0");
  _textScore.setCharacterSize(FONT_SIZE);
  _textScore.setPosition(0,FONT_SIZE + 1);

  _textLvl.setFont(_font);
  _textLvl.setString("lvl : 0");
  _textLvl.setCharacterSize(FONT_SIZE);
  _textLvl.setPosition(0,(FONT_SIZE + 1)*2);

  _textGameOver.setFont(_font);
  _textGameOver.setString("Game Over");
  _textGameOver.setCharacterSize(72);
  _textGameOver.setPosition(0,0);
}</pre></div><p>The constructor of the class<a id="id203" class="indexterm"/> set all the attributes to no surprise:</p><div class="informalexample"><pre class="programlisting">void Stats::gameOver(){_isGameOver = true;}</pre></div><p>Here again, there are no surprises. We just assigned the <code class="literal">_isGameOver</code> value to true:</p><div class="informalexample"><pre class="programlisting">void Stats::addLines(int lines)
{
  if(lines &gt; 0)
  {
    _nbRows += lines;
    _textRows.setString("rows : "+std::to_string(_nbRows));
    _textScore.setString("score : "+std::to_string(_nbScore));
    switch (lines)
    {
      case 1 : _nbScore += 40 * (_nbLvl+1);break;
      case 2 : _nbScore += 100 * (_nbLvl+1);break;
      case 3 : _nbScore += 300 * (_nbLvl+1);break;
      case 4 : _nbScore += 1200 * (_nbLvl+1);break;
      default :break;
    }
    _nbLvl = _nbRows / 10;
    _textLvl.setString("lvl : "+std::to_string(_nbLvl));
  }
}</pre></div><p>This function is a bit more interesting. Its aim is to add points to the global score depending on the number of lines completed. It also corrects the drawable text value and the level. Because a piece is composed of four squares, the maximum number of lines that can be suppressed with one piece is the number four. So in the switch statement, we only need to check these four possibilities:</p><div class="informalexample"><pre class="programlisting">unsigned int Stats::getLvl()const{return _nbLvl;}
void Stats::draw(sf::RenderTarget&amp; target, sf::RenderStates states) const
{
  if(not _isGameOver)
  {
    states.transform *= getTransform();
    target.draw(_textRows,states);
    target.draw(_textScore,states);
    target.draw(_textLvl,states);
  }
  else
  target.draw(_textGameOver,states);
}</pre></div><p>As all the other <code class="literal">sf::Drawable::draw()</code> functions, this function draws the object on the screen. If the game is complete, we print the <span class="strong"><strong>Game Over</strong></span> message, in other cases, we print the game score, number of <a id="id204" class="indexterm"/>completed rows, and the current level.</p><p>In conclusion, this class is very simple and its job is to display all the game information on the screen.</p></div><div class="section" title="The Piece class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>The Piece class</h2></div></div></div><p>Now, let's build the first important class of this game, the <code class="literal">Piece</code> class. In Tetris, there are seven different tetrimino. I will not build <a id="id205" class="indexterm"/>seven different classes but only one. The idea is to show you another way to make your entities.</p><p>But, what is a piece exactly? If you think about it, you will find that a piece can be represented as an array of numbers. Moreover, a piece can be rotated. There are three ways to do this: calculate the rotation at runtime, pre-calculate the rotation at the startup or predefine them in the code. Because in our game, each piece is known when we create the game, we will choose the last way: hard code all the rotation. It could look bad, but in reality it's not, and it will simplify a lot our implementation as you will see later in this chapter, but keep in mind that it's not a fantastic idea to hard code items in every game. </p><p>Now let's take a look at the class:</p><div class="informalexample"><pre class="programlisting">class Piece
{
  public:
  static const unsigned short int NB_ROTATIONS = 4; //&lt; number of rotations
  static const unsigned short int MATRIX_SIZE = 4; //&lt; size of the matrix
  static const unsigned int PIVOT_Y = 1;
  static const unsigned int PIVOT_X = 2;
  enum TetriminoTypes {O=0,I,S,Z,L,J,T,SIZE}; //&lt; different kind of pieces
  static const sf::Color TetriminoColors[TetriminoTypes::SIZE]; //&lt; different colors for each kind of piece
  static const char TetriminoPieces[TetriminoTypes::SIZE][NB_ROTATIONS][MATRIX_SIZE][MATRIX_SIZE];//&lt; store all the different shapes

  Piece(const Piece&amp;) = delete;
  Piece&amp; operator=(const Piece&amp;) = delete;
  Piece(TetriminoTypes type,short int rotation); 
  TetriminoTypes getType()const;
  void setRotation(short int rotation); //&lt; set the rotation
  short int getRotation()const;
  void setPosition(int x,int y);//&lt; set the position in the
  //board

  int getPosX()const;
  int getPosY()const;
  sf::Time getTimeSinceLastMove()const;

  private:
  const TetriminoTypes _type; //&lt; the piece type
  short int _rotation; //&lt; the piece rotation
  int _positionX; //&lt; position in the board
  int _positionY;//&lt; position in the board
  sf::Clock _clockSinceLastMove;
};</pre></div><p>This class is a bit long. Let's explain it step by step:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will define some constant variables that will be used for configuration purposes.</li><li class="listitem">We will define an <code class="literal">enum</code> function with all the different tetrimino pieces.</li><li class="listitem">We will define an array of color. Each cell will represent the color of a tetrimino previously defined in the <code class="literal">enum</code> function.</li><li class="listitem">The next line is particular. This defines all the different tetrimino rotations. Because each piece is a<a id="id206" class="indexterm"/> 2D array, we also need this information.</li><li class="listitem">The other functions are more common: constructor, getter, and setter.</li><li class="listitem">We will define some private attributes that store the state of the piece.</li></ol></div><p>Now is the funny part, the implementation of all of this. Because of the choices made, the implementation will differ a lot with the previous entity in the <span class="strong"><strong>Asteroid</strong></span> game:</p><div class="informalexample"><pre class="programlisting">const sf::Color Piece::TetriminoColors[Piece::TetriminoTypes::SIZE]= {
  sf::Color::Blue,
  sf::Color::Red,
  sf::Color::Green,
  sf::Color::Cyan,
  sf::Color::Magenta,
  sf::Color::White,
  sf::Color(195,132,58)
}</pre></div><p>This array stores<a id="id207" class="indexterm"/> all the different colors for each tetrimino defined by the <code class="literal">TetriminoTypes</code> enum:</p><div class="informalexample"><pre class="programlisting">const char Piece::TetriminoPieces[Piece::TetriminoTypes::SIZE][Piece::NB_ROTATIONS][Piece::MATRIX_SIZE][Piece::MATRIX_SIZE] = {
    { // O
        {
            {0,0,0,0},
            {0,1,2,0},
            {0,1,1,0},
            {0,0,0,0}
        },
        //...
        {
            {0,0,0,0},
            {0,1,2,0},
            {0,1,1,0},
            {0,0,0,0}
        }
    },
    {//I
        {
            {0,0,0,0},
            {1,1,2,1},
            {0,0,0,0},
            {0,0,0,0}
        },
        {
            {0,0,1,0},
            {0,0,2,0},
            {0,0,1,0},
            {0,0,1,0}
        },
        {
            {0,0,0,0},
            {1,1,2,1},
            {0,0,0,0},
            {0,0,0,0}
        },
        {
            {0,0,1,0},
            {0,0,2,0},
            {0,0,1,0},
            {0,0,1,0}
        } 
    },
    //...
};</pre></div><p>At first glance, this is a very special array but turns out it's not really. In fact, each different piece is defined in the first cell of the array, the second cell represents all the different rotations of this piece and the rest is the representation of the piece rotation as a 2D array. The <code class="literal">0</code> value represents empty, <code class="literal">2</code> represents the center of the piece, and <code class="literal">1</code> represents the other piece<a id="id208" class="indexterm"/> of the tetrimino. I've not put all the code because it is pretty long, but you can take a look at it if needed at <code class="literal">03_Simple_2D_game/Tetris/src/SFML-Book/Piece.cpp</code>.</p><div class="informalexample"><pre class="programlisting">Piece::Piece(TetriminoTypes type,short int rotation) : _type(type), _rotation(rotation), _positionX(0), _positionY(0) {assert(rotation &gt;= 0 and rotation &lt; NB_ROTATIONS);}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>The <code class="literal">assert</code> function is a<a id="id209" class="indexterm"/> macro that will raise an error and exit the program if the expression such as parameter is false. You can remove it by adding <code class="literal">#define NDEBUG</code> to your code/compiler option to disable this function.</p><p>The <code class="literal">assert()</code> function is useful to do checks in the<a id="id210" class="indexterm"/> debug mode only. Use it when you want to be sure that a specific case is respected at run time.</p></div></div><p>The constructor of the <code class="literal">Piece</code> class is simple, but we can easily send wrong parameter values to it. So I decided to show you the assert functionality, as follows:</p><div class="informalexample"><pre class="programlisting">Piece::TetriminoTypes Piece::getType()const {return _type;}

short int Piece::getRotation()const {return _rotation;}

int Piece::getPosX()const {return _positionX;}

int Piece::getPosY()const {return _positionY;}
sf::Time Piece::getTimeSinceLastMove()const {return _clockSinceLastMove.getElapsedTime();}

void Piece::setRotation(short int rotation)
{
  assert(rotation &gt;= 0 and rotation &lt; NB_ROTATIONS);
  _rotation = rotation;
  _clockSinceLastMove.restart();
}

void Piece::setPosition(int x,int y)
{
  _positionX = x;
  _positionY = y;
  _clockSinceLastMove.restart();
}</pre></div><p>All of these functions are getters and setters, and they are simple. The only particular thing is the <code class="literal">setPosition</code>/<code class="literal">Rotation()</code> functions because it also resets the internal clock. Since the clock stores the time <a id="id211" class="indexterm"/>since the last movement of the piece, in reality it should not sock you.</p></div><div class="section" title="The Board class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>The Board class</h2></div></div></div><p>Now, that all the pieces are made, let's build the class that will manage them, the <span class="strong"><strong>Board</strong></span>.</p><p>This class will be<a id="id212" class="indexterm"/> represented as a grid (array) that stores colors (piece). So internally, this class is nothing but an array of integers. Each cell will store the kind of piece because the kind of piece determines its color (see the <code class="literal">Piece</code> class). Now take a look at the header of this class:</p><div class="informalexample"><pre class="programlisting">class Board : public sf::Transformable,public sf::Drawable {
  public:
  static const int DEFAULT_BOARD_COLUMNS = 10; 
  static const int DEFAULT_BOARD_LINE = 20;
  static const int DEFAULT_CELL_X = 24;
  static const int DEFAULT_CELL_Y = 24;

  Board(int columns=DEFAULT_BOARD_COLUMNS,int 
    line=DEFAULT_BOARD_LINE,int cell_x=DEFAULT_CELL_X,int 
      cell_y=DEFAULT_CELL_Y);
  ~Board();

  void spawn(Piece&amp; piece);
  bool move(Piece&amp; piece, int delta_x,int delta_y);
  bool isFallen(const Piece&amp; piece);
  void drop(Piece&amp; piece);
  bool rotateLeft(Piece&amp; piece);
  bool rotateRight(Piece&amp; piece);
  bool isGameOver();
  int clearLines(const Piece&amp; piece); //&lt; clear all possible lines

  private:
  bool rotate(Piece&amp; piece,int rotation);
  void draw(const Piece&amp; piece);
  void clear(const Piece&amp; piece);
  virtual void draw(sf::RenderTarget&amp; target,sf::RenderStates 
    states=sf::RenderStates::Default) const override; 
  void flood(const Piece&amp; piece,int value);
 
        void flood(int grid_x,int grid_y,int piece_x,int piece_y,Piece::Tetrimino_Types type,int rotation,bool visited[][Piece::MATRIX_SIZE],int value);
        void flood(int grid_x,int grid_y,int piece_x,int piece_y,Piece::Tetrimino_Types type,int rotation,bool visited[][Piece::MATRIX_SIZE],bool&amp; flag);
                                                 
        void clearLine(int y); //&lt; clear a line
                                                      
        const int _columns;
        const int _lines;
        const int _cellX;
        const int _cellY;
                                                                 
        bool _isGameOver;
                                                          
        sf::VertexArray _grid;//&lt; grid borders
        int* _gridContent;//&lt; lines * columns
};</pre></div><p>In the Board class we firstly define some configuration variable. This class is drawable and transformable, so we extend it from the corresponding SFML class. Then we create the constructor that take the size of the board as parameters and some methods to add, move and manage a Piece. We also add some private methods that will help use to in the implementation of the publics, and we store the size of the board internally, such as the grid. Because the size is not known at compile time, we need to build the grid at runtime, so the grid is a pointer to an array. We also add a sf::VertexArray that will contain the graphical grid to display on the screen.</p><p>Now that the class has been explained, let's implement it.</p><div class="informalexample"><pre class="programlisting">constexpr int  CELL_EMPTY -1;
Board::Board(int columns,int lines,int cell_x,int cell_y): _columns(columns),_lines(lines),_cellX(cell_x),_cellY(cell_y), _gridContent(nullptr),_isGameOver(false)
{
    _gridContent = new int[_lines*_columns];
    std::memset(_gridContent,CELL_EMPTY,_lines*_columns*sizeof(int));

    sf::Color gridColor(55,55,55);
    _grid = sf::VertexArray(sf::Lines,(_lines+1+_columns+1)*2);
    for(int i=0;i&lt;=_lines;++i)
    {
        _grid[i*2] = sf::Vertex(sf::Vector2f(0,i*_cellY));
        _grid[i*2+1] = sf::Vertex(sf::Vector2f(_columns*_cellX,i*_cellY));

        _grid[i*2].color = gridColor;
        _grid[i*2+1].color = gridColor;
    }

    for(int i=0;i&lt;=columns;++i)
    {
        _grid[(_lines+1)*2 + i*2] = sf::Vertex(sf::Vector2f(i*_cellX,0));
        _grid[(_lines+1)*2 + i*2+1] = sf::Vertex(sf::Vector2f(i*_cellX,_lines*_cellY));

        _grid[(_lines+1)*2 + i*2].color = gridColor;
        _grid[(_lines+1)*2 + i*2+1].color = gridColor;
    }
}</pre></div><p>The constructor initialize all the attributes but also create the grids content and border. Because the grid content and border are a one dimension arrays, we need to make some trick to access to the right cell instead of using the usual "[][]" operator.</p><div class="informalexample"><pre class="programlisting">Board::~Board() {delete _gridContent;}

void Board::draw(sf::RenderTarget&amp; target, sf::RenderStates states) const
{
    states.transform *= getTransform();

    for(int y=0; y&lt;_lines; ++y)
        for(int x=0; x&lt;_columns; ++x) {
            if(_gridContent[y*_columns + x] != CELL_EMPTY) {
                sf::RectangleShape rectangle(sf::Vector2f(_cellX,_cellY));
                rectangle.setFillColor(Piece::TetriminoColors[_gridContent[y*_columns + x]]);
                rectangle.setPosition(x*_cellX,y*_cellY);
                target.draw(rectangle,states);
            }
        }
    target.draw(_grid,states);
}</pre></div><p>The draw method is not complex. For each cell, there is some data in it, we construct a rectangle of the right size at the right place, with the right color, and display it. And then we display the grid border.</p><div class="informalexample"><pre class="programlisting">void Board::spawn(Piece&amp; piece)
{
    piece.setPosition(_columns/2,0);
    for(int x=0;x&lt;_columns;++x)
        if(_gridContent[x] != CELL_EMPTY) {
            _isGameOver = true;
            break;
        }
    draw(piece);
}</pre></div><p>This function simply sets the initial position of a piece on the board, and adds it to the grid. It also checks if the game is over or not, by the following code snippet:</p><div class="informalexample"><pre class="programlisting">bool Board::move(Piece&amp; piece, int delta_x, int delta_y)
{
  delta_x += piece.getPosX();
  delta_y + piece.getPosY();
  clear(piece);
  bool visited[Piece::MATRIX_SIZE][Piece::MATRIX_SIZE] = {{false}};
  bool movable = true
  flood(delta_x,delta_y, (int)Piece::PIVOT_X,(int)Piece::PIVOT_Y,
  piece.getType(),piece.getRotation(),
  visisted, movable);
  if (movable)
  piece.setPosition(delta_x,delta_y);
  draw(piece);
  return movable;
}</pre></div><p>This function is a bit more<a id="id213" class="indexterm"/> complicated, so let's explain it step by step:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will delete the <code class="literal">Piece</code> class from the board so that it doesn't collide with itself.</li><li class="listitem">We will check if we can move the piece and set its new position if we can.</li><li class="listitem">We will read the piece to the board</li></ol></div><p>The flood algorithm will be explained later:</p><div class="informalexample"><pre class="programlisting">bool Board::isFallen(const Piece&amp; piece)
{
  clear(piece);
  bool vision[Piece::MATRIX_SIZE][Piece::MATRIX_SIZE] = {{false}};
  bool fallen = true;
  flood(piece.getPosX(),piece.getPosY()+1
  (int)Piece::PIVOT_X,(int)Piece::PIVOT_Y,
  piece.getType(),piece.getRotation(),
  visited,fallen);
  draw(piece)
  return fallen;
}</pre></div><p>This functionality works as the previously mentioned function with just one exception. It only checks if the piece can move down and not in all directions, as shown in the previous code snippet:</p><div class="informalexample"><pre class="programlisting">void Board::drop(Piece&amp; piece) {while(move(piece,0,1));}</pre></div><p>This function is a special <a id="id214" class="indexterm"/>action that moves the piece as we can to the down. This is a special action in the Tetris game, called "Hard drop".</p><div class="informalexample"><pre class="programlisting">bool Board::rotateLeft(Piece&amp; piece)
{
  int rotation = piece.getRotation();
  if(rotation &gt; 0)
  --rotation;
  else
  rotation = Piece::NB_ROTATIONS - 1;
  return rotate(piece,rotation);
}

bool Board::rotateRight(Piece&amp; piece)
{
  int rotation = piece.getRotation();
  if(rotation &lt; Piece::NB_ROTATIONS -1)
  ++rotation;
  else
  rotation = 0;
  return rotate(piece,rotation);
}</pre></div><p>These two functions rotate the piece to a specific direction. As there are only four different rotations (<code class="literal">NB_ROTATIONS</code>), we need to adjust the new rotation value using a circular check:</p><div class="informalexample"><pre class="programlisting">bool Board::isGameOver(){return _isGameOver;}
bool Board::rotate(Piece&amp; piece,int rotation)
{
  assert(rotation &gt;= 0 and rotation &lt; Piece::NB_ROTATIONS);
  clear(piece);
  bool visited[Piece::MATRIX_SIZE][Piece::MATRIX_SIZE] = {{false}};
  bool rotable = true;
  flood((int)piece.getPosX(),(int)piece.getPosY(),
  (int)Piece::PIVOT_X,(int)Piece::PIVOT_Y,
  piece.getType(),rotation,
  visited,rotable);
  if(rotable)
  piece.setRotation(rotation);
  draw(piece);
  return rotable;
}</pre></div><p>Like the other functions, this<a id="id215" class="indexterm"/> one checks whether we can rotate a piece or not, and return the value. This function does not change the content of the grid:</p><div class="informalexample"><pre class="programlisting">void Board::draw(const Piece&amp; piece){flood(piece,piece.getType());}
void Board::clear(const Piece&amp; piece){flood(piece,CELL_EMPTY);}</pre></div><p>These two functions are<a id="id216" class="indexterm"/> very close. Each one modifies the grid with a specific value, to set or remove a piece from the internal grid:</p><div class="informalexample"><pre class="programlisting">void Board::flood(const Piece&amp; piece,int value)
{
  bool visited[Piece::MATRIX_SIZE][Piece::MATRIX_SIZE] = {{false}};
  flood((int)piece.getPosX(),
  (int)piece.getPosY(),(int)Piece::PIVOT_X,
  (int)Piece::PIVOT_Y,
  piece.getType(),piece.getRotation(),
  visited,value);
}

void Board::flood(int grid_x,int grid_y,int piece_x,int piece_y,Piece::TetriminoTypes type,int rotation,bool visited[][Piece::MATRIX_SIZE],int value)
{
  if(piece_x &lt; 0 or piece_x &gt;= Piece::MATRIX_SIZE
  or piece_y &lt; 0 or piece_y &gt; Piece::MATRRIX_SIZE Pieces[type][rotation][piece_y][piece_x] == 0)
  return;
visited[piece_y][piece_x] = true;
  _gridContent[grid_y*_columns + grid_x] = value;
  flood(grid_x, grid_y-1, piece_x, piece_y-1, type, rotation, visited, value);
  flood(grid_x+1, grid_y, piece_x+1, piece_y, type, rotation, visited, value);
  flood(grid_x, grid_y+1, piece_x, piece_y+1, type, rotation, visited, value);
  flood(grid_x-1, grid_y, piece_x-1, piece_y, type, rotation, visited, value);
}

void Board::flood(int grid_x,int grid_y,int piece_x,int piece_y,Piece::TetriminoTypes type,int rotation,bool visited[][Piece::MATRIX_SIZE],bool&amp; flag)
{
  if(piece_x &lt; 0 or piece_x &gt;= Piece::MATRIX_SIZE
  or piece_y &lt; 0 or piece_y &gt;= Piece::MATRIX_SIZE
  or visited[piece_y][piece_x] == true
  or Piece::TetriminoPieces[type][rotation][piece_y][piece_x] == 0)
  return;
  visited[piece_y][piece_x] = true;
  if(grid_x &lt; 0 or grid_x &gt;= (int)_columns
  or grid_y &lt; 0 or grid_y &gt;= (int)_lines
  or _gridContent[grid_y*_columns + grid_x] != CELL_EMPTY) {
    flag = false;
    return;
  }
  flood(grid_x, grid_y-1, piece_x, piece_y-1, type, rotation, visited, flag);
  flood(grid_x+1, grid_y, piece_x+1, piece_y, type, rotation, visited, flag);
  flood(grid_x, grid_y+1, piece_x, piece_y+1, type, rotation, visited, flag);
  flood(grid_x-1, grid_y, piece_x-1, piece_y, type, rotation, visited, flag);
}</pre></div><p>This <code class="literal">flood</code> function is an implementation of the <code class="literal">flood</code> algorithm. It allows us to fill the array with a value, depending <a id="id217" class="indexterm"/>of another array. The second array is the shape to fill in the first one. In our case, the first array is the grid, and the second the piece, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">void Board::clearLine(int yy)
{
  assert(yy &lt; _lines);
  for(int y=yy; y&gt;0; --y)
  for(int x=0; x&lt;_columns; ++x)
  _gridContent[y*_columns + x] = _gridContent[(y-1)*_columns + x];
}
int Board::clearLines(const Piece&amp; piece)
{
  int nb_delete = 0;
  clear(piece);
  for(int y=0; y&lt;_lines; ++y)
  {
    int x =0;
    for(;_gridContent[y*_columns + x] != CELL_EMPTY and x&lt;_columns; ++x);
    if(x == _columns) {
      clearLine(y);
      ++nb_delete;
    }
  }
  draw(piece);
  return nb_delete;
}</pre></div><p>This function simply removes all the completed lines, and lowers all the upper lines to simulate gravity.</p><p>Now, the <code class="literal">board</code> class is made, and we <a id="id218" class="indexterm"/>have all that we need to build the game. So let's do it.</p></div><div class="section" title="The Game class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec49"/>The Game class</h2></div></div></div><p>The <code class="literal">Game</code> class is very similar to the<a id="id219" class="indexterm"/> <code class="literal">Game</code> class from Asteroid. Its purpose is the same and all the internal logic is similar as well, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">class Game
{
  public:
  Game(); //&lt; constructor
  void run(int minimum_frame_per_seconds);

  private:
  void processEvents();//&lt; Process events
  void update(sf::Time deltaTime); //&lt; do some updates
  void render();//&lt; draw all the stuff
  void newPiece();

  sf::RenderWindow _window; //&lt; the window used to display the game
  std::unique_ptr&lt;Piece&gt; _currentPiece; //&lt; the current piece
  Board _board; //&lt; the game board
  Stats _stats; //&lt; stats printer
  sf::Time _nextFall;
};</pre></div><p>As you can see, we don't change the logic of the <code class="literal">Game</code> class, but we add it some private functions and attributes to correspond to the different kind of games. A window is still required, but we add the current piece reference, the board (that replaces the world), and a stats printer. We also need a way to store the next fall of a piece.</p><p>Now take a look at the implementation of this class:</p><div class="informalexample"><pre class="programlisting">Game::Game() : _window(sf::VideoMode(800, 600),"SFML Tetris"),_board()
{
  rand_init()
  _board.setPosition(10,10);
  _stats.setPosition(300,10);
  newPiece();
}</pre></div><p>The constructor initializes the different attributes of the class, and sets the position of the different drawable object. It also<a id="id220" class="indexterm"/> creates the first piece to start the game. We don't manage any menu here:</p><div class="informalexample"><pre class="programlisting">void Game::run(int minimum_frame_per_seconds)
{
  sf::Clock clock;
  sf::Time timeSinceLastUpdate;
  sf::Time TimePerFrame = sf::seconds(1.f/minimum_frame_per_seconds);
  while (_window.isOpen())
  {
    processEvents();
    timeSinceLastUpdate = clock.restart();
    while (timeSinceLastUpdate &gt; TimePerFrame)
    {
      timeSinceLastUpdate -= TimePerFrame;
      update(TimePerFrame);
    }
    update(timeSinceLastUpdate);
    render();
  }
}
void Game::processEvents()
{
  sf::Event event;
  while(_window.pollEvent(event))
  {
    if (event.type == sf::Event::Closed)//Close window
    _window.close();
    else if (event.type == sf::Event::KeyPressed) //keyboard input
    {
      if (event.key.code == sf::Keyboard::Escape) {
        _window.close();
      } else if (event.key.code == sf::Keyboard::Down) {
        _board.move(*_currentPiece,0,1);
      } else if (event.key.code == sf::Keyboard::Up) {
        _board.move(*_currentPiece,0,-1);
      } else if (event.key.code == sf::Keyboard::Left) {
        _board.move(*_currentPiece,-1,0);
      } else if (event.key.code == sf::Keyboard::Right) {
        _board.move(*_currentPiece,1,0);
      } else if (event.key.code == sf::Keyboard::Space) {
        _board.drop(*_currentPiece);
        newPiece();
      } else if (event.key.code == sf::Keyboard::S) {
        _board.rotateRight(*_currentPiece);
      } else if (event.key.code == sf::Keyboard::D) {
        _board.rotateLeft(*_currentPiece);
      }
    }
  }
}
void Game::update(sf::Time deltaTime)
{
  if(not _board.isGameOver())
  {
  _stats.addLines(_board.clearLines(*_currentPiece));
  _nextFall += deltaTime;
  if((not _board.isFallen(*_currentPiece)) and (_currentPiece-&gt;getTimeSinceLastMove() &gt; sf::seconds(1.f)))
  newPiece();
  sf::Time max_time = sf::seconds(std::max(0.1,0.6-0.005*_stats.getLvl()));
  while(_nextFall &gt; max_time)
  {
    _nextFall -= max_time;
    _board.move(*_currentPiece,0,1);
  }
    } else {
      _stats.gameOver();
    }
}</pre></div><p>This function is not complicated but is interesting, because all the logic of the game is here. Let's see this in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is to clear lines and update the score.</li><li class="listitem">Then, we will check whether we need to spawn another piece or not</li><li class="listitem">We will calculate the<a id="id221" class="indexterm"/> time needed by the current level to force a movement downward and apply it if necessary.</li><li class="listitem">Of course, if the game is over, we don't do all this stuff, but tell the stats printer that the game is over:<div class="informalexample"><pre class="programlisting">void Game::render()
{
  _window.clear();
  if(not _board.isGameOver())
  _window.draw(_board);
  _window.draw(_stats);
  _window.display();
}</pre></div></li><li class="listitem">Here again, there is nothing new. We just draw all that can be drawn depending on the situation:<div class="informalexample"><pre class="programlisting">void Game::newPiece()
{
  _currentPiece.reset(new Piece((Piece::TetriminoTypes)random(0,Piece::TetriminoTypes::SIZE-1),0));
  _board.spawn(*_currentPiece);
}</pre></div></li><li class="listitem">This last function creates a piece at random, and adds it to the grid, which will set its default position.</li></ol></div><p>And here we are. The game is finished!</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Summary</h1></div></div></div><p>As you surely noticed, there are some common points with the previous game we made, but not a lot. The main idea of showing you this game, is that there is no "super technique" that will work in every kind of game. You have to adapt your internal architecture and logic depending on the kind of game you want to build. I hope you understand that.</p><p>In the next chapter, you will learn how to use a physics engine, and add it in the Tetris game to build a new kind of game.</p></div></body></html>