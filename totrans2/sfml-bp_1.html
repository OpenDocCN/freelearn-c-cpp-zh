<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Preparing the Environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Preparing the Environment</h1></div></div></div><p>Through this book, I will try to teach you some elements to build video games using the SFML library. Each chapter will cover a different topic, and will require knowledge from the previous one.</p><p>In this first chapter, we will cover basics points needed for the future such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing a compiler for C++11</li><li class="listitem" style="list-style-type: disc">Installing CMake</li><li class="listitem" style="list-style-type: disc">Installing SFML 2.2</li><li class="listitem" style="list-style-type: disc">Building a minimal SFML project</li></ul></div><p>Before getting started, let's talk about each technology and why we will use them.</p><div class="section" title="C++11"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>C++11</h1></div></div></div><p>The C++ programming language is a very powerful tool and has really great performance, but it is<a id="id0" class="indexterm"/> also really complex, even after years of practice. It allows us to program at both a low and high level. It's useful to make some optimizations on our program such as having the ability to directly manipulate memory. Building software utilizing C++ libraries allows<a id="id1" class="indexterm"/> us to work at a higher level and when performance is crucial, at a low level. Moreover, the C/C++ compilers are very efficient at optimizing code. The result is that, right now, C++ is the most powerful language in terms of speed, and thanks to the zero cost abstraction, you are not paying for what you don't use, or for the abstraction you are provided.</p><p>I'll try to use this language in a modern way, using the object-oriented approach. Sometimes, I'll bypass this approach to use the C way for optimizations. So do not be shocked to see some "old school code". Moreover, all the main compilers now support the standard language released in 2011, so we can use it everywhere without any trouble. This version adds some really useful features in the language that will be used in this book, such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Keywords are one such important feature. The following are a few of them:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">auto</code>: This automatically<a id="id2" class="indexterm"/> detects the type of the new variable. It is really useful for the instantiation of iterators. The auto keyword already existed in the past, but has been deprecated for a long time, and its meaning has now changed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">nullptr</code>: This is a new keyword introducing a strong type for the old NULL value. You can always use NULL, but it's preferable to use <code class="literal">nullptr</code>, which is any pointer type with 0 as the value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">override</code> and <code class="literal">final</code>: These two keywords already exist in some languages such as Java. These are simple indications not only for the compiler but also for the programmer, but don't specify what they indicate. Don't hesitate to use them. You can take a look to the documentation of them here <a class="ulink" href="http://en.cppreference.com/w/cpp/language/override">http://en.cppreference.com/w/cpp/language/override</a> and <a class="ulink" href="http://en.cppreference.com/w/cpp/language/final">http://en.cppreference.com/w/cpp/language/final</a>.</li></ul></div></li><li class="listitem" style="list-style-type: disc">The range-based <code class="literal">for</code> loops is a new kind of loop in the language <code class="literal">foreach</code>. Moreover, you can use the new <code class="literal">auto</code> keyword to reduce your code drastically. The following syntax is very simple:<div class="informalexample"><pre class="programlisting">for(auto&amp; var : table){...}.</pre></div><p>In this example, <code class="literal">table</code> is a container (vector and list) and <code class="literal">var</code> is a reference to the stored variable. Using <code class="literal">&amp;</code> allows us to modify the variable contained inside the table and avoids copies.</p></li><li class="listitem" style="list-style-type: disc">C++11 introduces the smart pointers. There are multiple pointers corresponding to their different possible utilizations. Take a look at the official documentation, this which is really interesting. The main idea is to manage the memory and delete the object created at runtime when no more reference on it exists, so that you do not have to delete it yourself or ensure that no double free corruptions are made. A smart pointer created on the stack has the advantages of being both fast and automatically deleted when the method / code block ends. But it is important to know that a strong use of this pointer, more especially <code class="literal">shared_ptr</code>, will reduce the execution speed of your program, so use them carefully.</li><li class="listitem" style="list-style-type: disc">The lambda expression or anonymous function is a new type introduced with a particular syntax. You can now create functions, for example, as a parameter of another function. This is really useful for callback. In the past, functor was used to achieve this kind of comportment. An example of functor and lambda is as follows:<div class="informalexample"><pre class="programlisting">class Func(){ void operator()(){/* code here */}};
auto f = [](){/* code here*/};</pre></div></li><li class="listitem" style="list-style-type: disc">If you already know the use of the variadics function with the ellipse operator (<code class="literal">...</code>), this notion should trouble you, as the usage of it is different. The variadics template is just the amelioration of template with any number of parameters using the ellipse operator. A good example for this is the tuple class. A tuple contains any number of values of any type known at compile time. Without the variadics template, it was not really possible to build this class, but now it is really easy. By the way, the tuple class was introduced in C++11. There<a id="id3" class="indexterm"/> are several other features, such as threads, pair, and so on.</li></ul></div></div></div>
<div class="section" title="SFML"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>SFML</h1></div></div></div><p>
<span class="strong"><strong>SFML</strong></span> stands for <span class="strong"><strong>Simple and Fast Multimedia Library</strong></span>. This is a framework written in C++ and is based on OpenGL for its graphical rendering part. This name describes its aim pretty well, that is, to have a user-friendly interface (API), to deliver high performance, and to be as portable as possible. The SFML library<a id="id4" class="indexterm"/> is divided into five modules, which are compiled in a separated file:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>System</strong></span>: This is the main module, and is required by all others. It provides clocks, threads, and two<a id="id5" class="indexterm"/> or three dimensions with all their logics (mathematics operations).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Window</strong></span>: This module<a id="id6" class="indexterm"/> allows the application to interact with the user by managing windows and the inputs from the mouse, keyboard, and joystick.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Graphics</strong></span>: This module allows<a id="id7" class="indexterm"/> the user to use all the graphical basic elements such as textures, shapes, texts, colors, shaders, and more.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Audio</strong></span>: This module allows the<a id="id8" class="indexterm"/> user to use some sound. Thanks to this, we will be able to play some themes, music, and sounds.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Network</strong></span>: This module manages<a id="id9" class="indexterm"/> not only socket and type safe transfers but also HTTP and FTP protocols. It's also very useful to communicate between different programs.</li></ul></div><p>Each module used by our programs will need to be linked to them at compile time. We don't need to link them all if it's not necessary. This book will cover each module, but not all the SFML classes. I recommend you take a look at the SFML documentation at <a class="ulink" href="http://www.sfml-dev.org/documentation.php">http://www.sfml-dev.org/documentation.php</a>, as it's very<a id="id10" class="indexterm"/> interesting and complete. Every module and class is well described in different sections.</p><p>Now that the main technologies have been presented, let's install all that we need to use them.</p></div>
<div class="section" title="Installation of a C++11 compiler"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Installation of a C++11 compiler</h1></div></div></div><p>As mentioned previously, we <a id="id11" class="indexterm"/>will use C++11, so we need a compiler for it. For<a id="id12" class="indexterm"/> each operating system, there are several options; choose the one you prefer.</p><div class="section" title="For Linux users"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>For Linux users</h2></div></div></div><p>If you are a Linux user, you probably already have GCC/G++ installed. In this case, check whether your version is <a id="id13" class="indexterm"/>4.8 or later. Otherwise, you can<a id="id14" class="indexterm"/> install GCC/G++ (version 4.8+) or Clang (version 3.4+) using your favorite packet manager. Under Debian based distribution (such as Ubuntu and Mint), use the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo apt-get install gcc g++ clang -y</strong></span>
</pre></div></div><div class="section" title="For Mac users"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>For Mac users</h2></div></div></div><p>If you are a Mac user, you <a id="id15" class="indexterm"/>can use Clang (3.4+). This is<a id="id16" class="indexterm"/> the default compiler under Mac OS X.</p></div><div class="section" title="For Windows users"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>For Windows users</h2></div></div></div><p>Finally, if you are a Windows user, you can use Visual Studio (2013), Mingw-gcc (4.8+), or Clang (3.4+) by downloading <a id="id17" class="indexterm"/>them. I suggest <a id="id18" class="indexterm"/>you not use Visual Studio, because it's not 100 percent standard compliant, even for the C99, and instead use another IDE such as Code::Blocks (see the following paragraph).</p></div><div class="section" title="For all users"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>For all users</h2></div></div></div><p>I assume that in both cases, you have been able to install a compiler and configure your system to use it (by adding it to the system path). If you have not been able to do this, another solution is to install an IDE like Code::Blocks, which has the advantage of being installed with a <a id="id19" class="indexterm"/>default compiler, is compatible with C++11, and doesn't require any system configuration.</p><p>I will choose the IDE option with Code::Blocks for the rest of the book, because it does not depend on a specific<a id="id20" class="indexterm"/> operating system and everyone will be able to navigate. You can download it at <a class="ulink" href="http://www.codeblocks.org/downloads/26">http://www.codeblocks.org/downloads/26</a>. The installation is really easy; you just have to follow the wizard.</p></div></div>
<div class="section" title="Installing CMake"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Installing CMake</h1></div></div></div><p>CMake is a really useful tool that manages the build process in any operating system and in a compiler-independent<a id="id21" class="indexterm"/> manner. This configuration is really simple. We will need it to build the SFML (if you choose this installation solution) and to build all the future projects of this book. Using CMake gives us a cross-platform solution. We will need version 2.8<a id="id22" class="indexterm"/> or later of CMake. Currently, the last stable version is 3.0.2.</p><div class="section" title="For Linux users"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>For Linux users</h2></div></div></div><p>If you use a Linux <a id="id23" class="indexterm"/>system, you can install CMake and its GUI using <a id="id24" class="indexterm"/>your packet manager. For example, under Debian, use this command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo apt-get install cmake cmake-gui -y</strong></span>
</pre></div></div><div class="section" title="For other operating systems"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>For other operating systems</h2></div></div></div><p>You can download the<a id="id25" class="indexterm"/> CMake binary for your system at <a class="ulink" href="http://www.cmake.org/download/">http://www.cmake.org/download/</a>. Follow the wizard, and that's it. CMake is now installed and ready to be used.</p></div></div>
<div class="section" title="Installing SFML 2.2"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Installing SFML 2.2</h1></div></div></div><p>There are two ways to get the SFML library. The easier way is to download the prebuilt version, which <a id="id26" class="indexterm"/>can be found at <a class="ulink" href="http://sfml-dev.org/download/sfml/2.2/">http://sfml-dev.org/download/sfml/2.2/</a>, but ensure that the<a id="id27" class="indexterm"/> version you download is compatible with your compiler.</p><p>The second option is to<a id="id28" class="indexterm"/> compile the library yourself. This option is preferable to the previous one to avoid any trouble.</p><div class="section" title="Building SFML yourself"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Building SFML yourself</h2></div></div></div><p>Compiling SFML is not as<a id="id29" class="indexterm"/> difficult as we might think, and is within the reach of everyone. First of all, we will need to install some dependencies.</p><div class="section" title="Installing dependencies"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Installing dependencies</h3></div></div></div><p>SFML depends on a few<a id="id30" class="indexterm"/> libraries. Before starting to compile it, make sure that you have all the dependencies installed along with their development files. Here is the list of dependencies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">pthread</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">opengl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">xlib</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">xrandr</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">freetype</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">glew</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">jpeg</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">sndfile</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">openal</code></li></ul></div></div><div class="section" title="Linux"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Linux</h3></div></div></div><p>On Linux, we will need to<a id="id31" class="indexterm"/> install the development versions of each of these libraries. The exact names of the packages depend on each distribution, but here is the command line for Debian:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo apt-get install libglu1-mesa-dev freeglut3-dev mesa-common-dev libxrandr-dev libfreetype6-dev libglew-dev libjpeg-dev libsndfile1-dev libopenal-dev -y</strong></span>
</pre></div></div><div class="section" title="Other operating systems"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Other operating systems</h3></div></div></div><p>On Windows and Mac OS X, all the<a id="id32" class="indexterm"/> needed dependencies are provided directly with SFML, so you don't have to download or install anything. Compilation will work out of the box.</p></div><div class="section" title="Compilation of SFML"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Compilation of SFML</h3></div></div></div><p>As mentioned<a id="id33" class="indexterm"/> previously, the SFML compilation is really simple. We just need to use CMake, by following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download<a id="id34" class="indexterm"/> the source code at <a class="ulink" href="http://sfml-dev.org/download/sfml/2.2/">http://sfml-dev.org/download/sfml/2.2/</a> and extract it.</li><li class="listitem">Open CMake and specify the source code directory and the build directory. By convention, the build directory is called <code class="literal">build</code> and is at the root level of the source directory.</li><li class="listitem">Press the <span class="strong"><strong>Configure</strong></span> button, and select <span class="strong"><strong>Code::Blocks</strong></span> with the right option for your system.<p>Under Linux, choose <span class="strong"><strong>Unix Makefiles</strong></span>. It should look like this:</p><div class="mediaobject"><img src="graphics/8477OS_01_01.jpg" alt="Compilation of SFML"/></div><p>Under<a id="id35" class="indexterm"/> Windows, choose <span class="strong"><strong>MinGW Makefiles</strong></span>. It should look like this:</p><div class="mediaobject"><img src="graphics/8477OS_01_02.jpg" alt="Compilation of SFML"/></div></li><li class="listitem">And finally, press <a id="id36" class="indexterm"/>the <span class="strong"><strong>Generate</strong></span> button. You'll have an output like this:<div class="mediaobject"><img src="graphics/8477OS_01_03.jpg" alt="Compilation of SFML"/></div></li></ol></div><p>Now the Code::Blocks file is built, and can be found in your build directory. Open it with Code::Blocks <a id="id37" class="indexterm"/>and click on the <span class="strong"><strong>Build</strong></span> button. All the binary files will be built and put in the <code class="literal">build/lib</code> directory. At this point, you have several files with an extension that depend on your system. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">libsfml-system</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">libsfml-window</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">libsfml-graphics</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">libsfml-audio</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">libsfml-network</code></li></ul></div><p>Each file corresponds to a different SFML module that will be needed to run our future games.</p><p>Now it's time to configure our system to be able to find them. All that we need to do is add the <code class="literal">build/lib</code> directory to our system path.</p><div class="section" title="Linux"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec01"/>Linux</h4></div></div></div><p>To compile in Linux, first <a id="id38" class="indexterm"/>open a terminal and run the following<a id="id39" class="indexterm"/> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd /your/path/to/SFML-2.2/build</strong></span>
</pre></div><p>The following command will install the binary files under <code class="literal">/usr/local/lib/</code> and the headers files in <code class="literal">/usr/local/include/SFML/</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo make install</strong></span>
</pre></div><p>By default, <code class="literal">/usr/local/</code> is in your<a id="id40" class="indexterm"/> system path, so no more<a id="id41" class="indexterm"/> manipulations are required.</p></div><div class="section" title="Windows"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec02"/>Windows</h4></div></div></div><p>On Windows, you will <a id="id42" class="indexterm"/>need to add to your system path, the <code class="literal">/build/lib/</code> directory, as<a id="id43" class="indexterm"/> follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to the <span class="strong"><strong>Advanced</strong></span> tab in <span class="strong"><strong>System Properties</strong></span>, and click on the <span class="strong"><strong>Environment Variables</strong></span> button:<div class="mediaobject"><img src="graphics/8477OS_01_04.jpg" alt="Windows"/></div></li><li class="listitem">Then, select <span class="strong"><strong>Path</strong></span> in the <span class="strong"><strong>System variables</strong></span> table and click on the <span class="strong"><strong>Edit...</strong></span> button:<div class="mediaobject"><img src="graphics/8477OS_01_05.jpg" alt="Windows"/></div></li><li class="listitem">Now edit<a id="id44" class="indexterm"/> the <span class="strong"><strong>Variable value</strong></span><a id="id45" class="indexterm"/> input text, add <code class="literal">;C:\your\path\to\SFML-2.2\build\lib</code>, and then validate it by clicking on <span class="strong"><strong>OK</strong></span> in all the open windows:<div class="mediaobject"><img src="graphics/8477OS_01_06.jpg" alt="Windows"/></div></li></ol></div><p>At this point, your <a id="id46" class="indexterm"/>system is configured to find the SFML <code class="literal">dll</code> <a id="id47" class="indexterm"/>modules.</p></div></div></div><div class="section" title="Code::Blocks and SFML"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Code::Blocks and SFML</h2></div></div></div><p>Now that your system is configured to find the SFML binary files, it's time for us to configure Code::Blocks and <a id="id48" class="indexterm"/>finally test whether everything is fine<a id="id49" class="indexterm"/> with your fresh installation. To do so, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run Code::Blocks, go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Project</strong></span>, and then choose <span class="strong"><strong>Console Application</strong></span>.</li><li class="listitem">Click on <span class="strong"><strong>GO</strong></span>.</li><li class="listitem">Choose <span class="strong"><strong>C++</strong></span> as the programming language, and follow the instructions until the project is created. A default <code class="literal">main.cpp</code> file is now created with a typical <code class="literal">Hello world</code> program. Try to build and run it to check whether your compiler is correctly detected.<div class="mediaobject"><img src="graphics/8477OS_01_07.jpg" alt="Code::Blocks and SFML"/></div></li></ol></div><p>If everything works <a id="id50" class="indexterm"/>correctly, you will have a new<a id="id51" class="indexterm"/> window created that has a <code class="literal">Hello world!</code> message, as follows:</p><div class="mediaobject"><img src="graphics/8477OS_01_08.jpg" alt="Code::Blocks and SFML"/></div><p>If you have this output, everything is fine. In any other case, make sure you have followed all the steps for the installations.</p><p>Now we will<a id="id52" class="indexterm"/> configure Code::Blocks to find the SFML library, and ask it to link with our program at the end of the compilation. To do this, perform<a id="id53" class="indexterm"/> the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to <span class="strong"><strong>Project</strong></span> | <span class="strong"><strong>Build options</strong></span> and select your project at the root level (not debug or release).</li><li class="listitem">Go to <span class="strong"><strong>Search directories</strong></span>. Here we have to add the path where the compiler and the linker can find the SFML.</li><li class="listitem">For the compiler, add your SFML folder.</li><li class="listitem">For the linker, add the <code class="literal">build/lib</code> folder, as follows:<div class="mediaobject"><img src="graphics/8477OS_01_09.jpg" alt="Code::Blocks and SFML"/></div></li></ol></div><p>Now we need to<a id="id54" class="indexterm"/> ask the linker which libraries our project needs. All our future SFML projects will need the System, Window, and Graphics modules, so<a id="id55" class="indexterm"/> we will add them:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to the <span class="strong"><strong>Linker settings</strong></span> tab.</li><li class="listitem">Add <code class="literal">-lsfml-system</code>, <code class="literal">-lsfml-window</code> and <code class="literal">-lsfml-graphics</code> in the <span class="strong"><strong>Other linker options</strong></span> column.</li><li class="listitem">Now click on <span class="strong"><strong>OK</strong></span>.<div class="mediaobject"><img src="graphics/8477OS_01_10.jpg" alt="Code::Blocks and SFML"/></div></li></ol></div><p>Good news, all the<a id="id56" class="indexterm"/> configurations are now finished. We will eventually need to add a library to the<a id="id57" class="indexterm"/> linker in the future (audio, network), but that's it.</p></div><div class="section" title="A minimal example"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>A minimal example</h2></div></div></div><p>It's now time for us to test the SFML<a id="id58" class="indexterm"/> with a very basic example. This application will show us the window as in the following screenshot:</p><div class="mediaobject"><img src="graphics/8477OS_01_11.jpg" alt="A minimal example"/></div><p>The following <a id="id59" class="indexterm"/>code snippet brings about this window:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>int</strong></span> main(<span class="strong"><strong>int</strong></span> argc,<span class="strong"><strong>char</strong></span>* argv[])
{
    sf::RenderWindow window(sf::VideoMode(400, 
400),"01_Introduction");
    window.setFramerateLimit(60);

    //create a circle
    sf::CircleShape circle(150);
    circle.setFillColor(sf::Color::Blue);
    circle.setPosition(10, 20);

    //game loop
    <span class="strong"><strong>while</strong></span> (window.isOpen())
    {
       //manage the events
        sf::Event event;
        <span class="strong"><strong>while</strong></span>(window.pollEvent(event))
        {
            <span class="strong"><strong>if</strong></span> ((event.type == sf::Event::Closed)
                <span class="strong"><strong>or</strong></span> (event.type == sf::Event::KeyPressed and 
event.key.code == sf::Keyboard::Escape))
                window.close(); //close the window
        }
        window.clear(); //clear the windows to black
        window.draw(circle); //draw the circle
        window.display(); //display the result on screen
    }
    <span class="strong"><strong>return</strong></span> 0;
}</pre></div><p>All that this application does is to create a window with a width and height of 400 pixels and its title is <code class="literal">01_Introduction</code>. Then a blue circle with a radius of 150 pixels is created, and is drawn while the window is open. Finally, the user events are checked on each loop. Here we verify if the close event has been asked (close the button or click <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>F4</em></span>), or if the user has pressed the <span class="emphasis"><em>Esc</em></span> button on his keyboard. In both case, we close the window, that will result to the program exit.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Summary</h1></div></div></div><p>In this chapter we covered which technologies we will use and why to use them. We also learned the installation of the C++11 compiler on different environments, we learned about installing CMake and how this will help us build the SFML projects in this book. Then we installed SFML 2.2, and followed on to build a very basic SFML application.</p><p>In the next chapter we will gain knowledge on how to structure a game, manage user inputs, and keep trace of our resources.</p></div></body></html>