- en: Chapter 10. Can I Click This? – GUI Fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章.我能点击这个吗？——GUI基础
- en: What do humans and machines really have in common, in the non-Turing sense of
    the word? It seems like the everyday life of an average human nowadays is almost
    synonymous with operating the large number of contraptions our species has created,
    yet most of us don't even speak the same language as the devices we use, which
    creates a need for some kind of translation. Now it's not as if we can't learn
    how to speak to machines directly, but it's simply too tedious and time-consuming
    as our brains work in a completely different way to a common processor. A gray
    area exists in which relatively intuitive actions performed by humans can also
    be understood and interpreted by machines without the need for ever getting involved
    with the underlying complexities - the means of interfacing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在非图灵意义上，人类和机器真正有什么共同之处？如今，普通人的日常生活几乎与操作我们物种创造的大量装置同义，然而，我们中的大多数人甚至不说我们使用的设备的语言，这产生了对某种翻译的需求。现在并不是我们不能学会如何直接与机器交流，但鉴于我们的大脑与通用处理器完全不同的工作方式，这太繁琐、太耗时了。存在一个灰色区域，其中人类执行的相对直观的动作也可以被机器理解和解释，而无需涉及任何底层复杂性——即接口的方式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Implementation of core data types for all GUI elements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现所有GUI元素的核心数据类型
- en: Utilizing SFML's render textures to achieve GUI layering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用SFML的渲染纹理实现GUI分层
- en: Laying down the fundamentals of smooth and responsive GUI interactions by using
    stylistic attributes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用风格属性来奠定平滑和响应式GUI交互的基础
- en: There is quite a bit of ground to cover so let's get started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多内容要覆盖，让我们开始吧！
- en: Use of copyrighted resources
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版权资源的使用
- en: 'Before we begin, it''s only fair to credit the true creators of the fonts and
    images used in the next two chapters:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，公正起见，我们应该感谢下一两章中使用的字体和图像的真正创作者：
- en: '*Fantasy UI Elements* by *Ravenmore* at [http://dycha.net/](http://dycha.net/)
    under the CC-BY 3.0 license:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由*Ravenmore*在[http://dycha.net/](http://dycha.net/)提供的*Fantasy UI Elements*，根据CC-BY
    3.0许可：
- en: '[http://opengameart.org/content/fantasy-ui-elements-by-ravenmore](http://opengameart.org/content/fantasy-ui-elements-by-ravenmore)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://opengameart.org/content/fantasy-ui-elements-by-ravenmore](http://opengameart.org/content/fantasy-ui-elements-by-ravenmore)'
- en: '*Vegur font* by *Arro* under the CC0 license (public domain):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由*Arro*设计的*Vegur字体*，根据CC0许可（公共领域）：
- en: '[http://www.fontspace.com/arro/vegur](http://www.fontspace.com/arro/vegur)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.fontspace.com/arro/vegur](http://www.fontspace.com/arro/vegur)'
- en: 'More information about all of the licenses that apply to these resources can
    be found here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些资源所适用的所有许可证的更多信息，请在此处查找：
- en: '[http://creativecommons.org/publicdomain/zero/1.0/](http://creativecommons.org/publicdomain/zero/1.0/)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://creativecommons.org/publicdomain/zero/1.0/](http://creativecommons.org/publicdomain/zero/1.0/)'
- en: '[http://creativecommons.org/licenses/by/3.0/](http://creativecommons.org/licenses/by/3.0/)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://creativecommons.org/licenses/by/3.0/](http://creativecommons.org/licenses/by/3.0/)'
- en: What is a GUI?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是GUI？
- en: A GUI, short for **Graphical User Interface**, is a visual intermediary between
    the user and a piece of software which serves as a control mechanism for digital
    devices or computer programs. Using this type of interface is faster and easier
    than relying on text-based controls, such as typing commands.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GUI，即**图形用户界面**，是用户与软件之间的视觉中介，它作为数字设备或计算机程序的控制系统。使用此类界面比依赖基于文本的控制（如输入命令）更快、更简单。
- en: 'Before any code is written, we need to outline the desired features of our
    GUI system, which is going to consist of three major components:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，我们需要概述我们GUI系统的预期功能，该系统将包括三个主要组件：
- en: '**Element**: Every GUI surface that is drawn onto the screen'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素**：绘制到屏幕上的每个GUI表面'
- en: '**Interface**: A special kind of element that serves as a container for other
    elements and can be moved around as well as scrolled'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：一种特殊类型的元素，用作其他元素的容器，并且可以移动以及滚动'
- en: '**Manager**: The class that is in charge of keeping GUI interfaces in line
    and behaving'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理器**：负责保持GUI界面一致性和行为的类'
- en: All of the elements in this system need to be able to adapt to a different state
    when they are hovered over by a mouse or clicked on. Style-sets also need to be
    applied to different states, resulting in interfaces becoming responsive. Lastly,
    you must be able to load the interfaces from files at runtime and tie them to
    code based on an event or a set of events taking place within them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的所有元素都需要能够适应不同的状态，当鼠标悬停或点击时。样式集也需要应用于不同的状态，从而使界面变得响应。最后，你必须能够在运行时从文件中加载界面，并根据它们内部发生的事件或一系列事件将它们与代码绑定。
- en: GUI style
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GUI样式
- en: 'Unifying the way styles are applied and used on GUI surfaces is crucial if
    you need customization and flexibility. To put it simply, modifying and applying
    every single stylistic attribute of every possible type of element manually would
    be a nightmare and any kind of code re-use would be impossible. This calls for
    a custom data type that can be used all across the board: the `GUI_Style` structure.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 统一在GUI表面上应用和使用的样式方式对于需要定制和灵活性至关重要。简单来说，手动修改和应用每种可能类型元素的所有样式属性将是一场噩梦，任何代码重用都将变得不可能。这需要一种可以在整个系统中使用的自定义数据类型：`GUI_Style`结构。
- en: 'First things first, any and all GUI elements should be able to support the
    three following states:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，任何和所有的GUI元素都应该能够支持以下三种状态：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Although these states are not only meant for graphical purposes, each one of
    them is also defined as a set of visual properties in order to simulate interaction
    and fluidity, represented by a set of style attributes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些状态不仅用于图形目的，但每个状态也被定义为一系列视觉属性，以模拟交互和流畅性，这些属性由一系列样式属性表示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'An element or interface can alter every single one of these properties and
    adjust itself to look completely different based on the state it''s in. If they
    are not defined, the default values set in the constructor take precedence, as
    shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个元素或界面可以改变这些属性中的每一个，并根据其状态调整自身以看起来完全不同。如果没有定义，构造函数中设置的默认值将优先，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'All of this is useless if we don''t have drawable objects to modify, so let''s
    fix that:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有可绘制对象来修改，所有这一切都是无用的，所以让我们解决这个问题：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This basic structure will be a part of every single element and interface allowing
    them to be represented by any combination of these four drawable elements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基本结构将成为每个单独的元素和界面的组成部分，使它们能够通过这四种可绘制元素的任意组合来表示。
- en: Expansion of utility functions
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展实用函数
- en: 'In order to keep things simple and easy to read, it''s always a good idea to
    create utility-type functions out of any code that is going to be used frequently.
    When dealing with interface de-serialization, many elements have to read in parameters
    that have spaces in them. Our solution to this problem is to put the string in
    double quotes and define an inline function to read the data. The perfect spot
    for that is in the `Utilities.h` file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情简单易读，总是从将被频繁使用的任何代码中创建实用类型函数是一个好主意。在处理界面反序列化时，许多元素必须读取包含空格的参数。我们解决这个问题的方法是将字符串放在双引号中并定义一个内联函数来读取数据。这个完美的位置是在`Utilities.h`文件中：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A word is loaded from the string stream object into the string provided as an
    argument. Its first character is checked to see if it is a double quote. If it
    is, a `while` loop keeps reading in words and appends them to the argument string
    until either its last character is a double quote or the end of the stream is
    reached.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单词从字符串流对象加载到提供的字符串参数中。检查其第一个字符是否为双引号。如果是，则使用`while`循环继续读取单词并将它们追加到参数字符串中，直到其最后一个字符是双引号或达到流末尾。
- en: Following that, all of the double quotes in the string are erased.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，字符串中的所有双引号都被删除。
- en: Font management
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字体管理
- en: 'Before we start to build the structure of our graphical user interface, we
    need a way to manage and handle the loading and unloading of fonts automatically,
    just like we did with textures. The effort we put into the resource manager written
    back in [Chapter 6](ch06.html "Chapter 6. Set It in Motion! – Animating and Moving
    around Your World"), *Set It in Motion! – Animating and Moving around Your World*,
    is about to pay off. In order to manage fonts, all we need to do is create a `FontManager.h`
    file and write the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建图形用户界面的结构之前，我们需要一种方法来自动管理和处理字体的加载和卸载，就像我们处理纹理一样。我们在[第6章](ch06.html "第6章。启动！
    – 动画和移动你的世界")中编写的资源管理器的努力，*启动！ – 动画和移动你的世界*，即将得到回报。为了管理字体，我们只需要创建一个`FontManager.h`文件并编写以下代码：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This defines the font resource configuration file in the constructor, as well
    as the specific way of loading font files using the `Load` method. The resource
    manager class that we implemented earlier makes this process very simple, so let's
    keep going!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这在构造函数中定义了字体资源配置文件，以及使用`Load`方法加载字体文件的具体方式。我们之前实现的资源管理器使这个过程非常简单，所以让我们继续吧！
- en: The core of all elements
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有元素的核心
- en: The `GUI_Element` class is the core of every single element and interface. It
    provides key functionality that higher level objects rely on, as well as enforcing
    the implementation of necessary methods, which leads to several distinctive element
    types.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`GUI_Element`类是每个元素和界面的核心。它提供了高层对象所依赖的关键功能，并强制实现必要的方法，这导致了几个独特的元素类型。'
- en: 'A definition of the different element types is a good place to start:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 定义不同元素类型的好地方是：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Each element has to hold different styles it can switch to, based on its state.
    The `unordered_map` data structure suits our purposes pretty well:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素必须持有它可以根据其状态切换的不同样式。`unordered_map`数据结构非常适合我们的目的：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A forward declaration of the owner class is also necessary to prevent cross-inclusion:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止交叉包含，对拥有者类的向前声明也是必要的：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we can begin shaping the `GUI_Element` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以开始塑造`GUI_Element`类：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The most essential part of any GUI element is how it responds to events. This
    is where the magic of pure-virtual methods comes in. Style application methods,
    however, are not purely virtual. An element doesn't handle its style any differently
    to a default element.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 任何GUI元素最基本的部分是它如何响应用件。这就是纯虚方法的魔力所在。然而，样式应用方法并不是纯虚的。元素在处理其样式时并不比默认元素有所不同。
- en: Every element also needs to have a name, a position, a set of styles for every
    possible state, a visual component that can be drawn, a type and state identifiers,
    and a pointer to an owner class. It also needs to keep track of whether it needs
    to be re-drawn, its active status, and a flag that denotes whether it is a control
    or not. These properties are represented by a set of private data members of the
    `GUI_Element` class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素也需要一个名称、一个位置、每个可能状态的一组样式、一个可以绘制的视觉组件、一个类型和状态标识符，以及指向一个拥有者类的指针。它还需要跟踪是否需要重新绘制、其活动状态以及一个表示它是否是控件的标志。这些属性由`GUI_Element`类的私有数据成员集合表示。
- en: With a rough idea of this structure hammered out, let's shape the finer details
    of the element class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构的大致想法已经确定之后，让我们塑造元素类的更详细细节。
- en: Implementing the GUI element class
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现GUI元素类
- en: 'The class we''re about to begin implementing is a cornerstone of every single
    interface and element. It will define how our GUI system behaves. With that in
    mind, let''s start by taking a look at the constructor, as we have quite a bit
    to initialize:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将开始实现的类是每个界面和元素的基础。它将定义我们的GUI系统如何行为。考虑到这一点，让我们首先看看构造函数，因为我们有很多东西需要初始化：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The element name, type, and a pointer to the owner class arguments are taken
    in and passed to the appropriate data members. Other additional flags are also
    initialized to the default values. There''s nothing out of the ordinary so far.
    Let''s take a look at how this class is destroyed:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 元素名称、类型以及指向拥有者类的指针被接收并传递到适当的数据成员。其他附加标志也被初始化为默认值。到目前为止，没有什么异常之处。让我们看看这个类是如何被销毁的：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since there is no dynamic memory allocation going on anywhere in this class,
    releasing resources is also fairly simple. The method for that specific purpose
    is simply invoked here. It looks a little like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个类中没有任何动态内存分配，因此释放资源也很简单。为此目的的方法只是在这里简单调用。它看起来有点像这样：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We only have to concern ourselves with those textures and fonts that are required
    by the element itself, so each style is iterated over and its resources are released
    by the respective methods, which all look similar to the one shown:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要关注元素本身所需的那些纹理和字体，因此每个样式都会被迭代，并且通过相应的方法释放其资源，这些方法看起来都与展示的类似：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If a font is released, the only difference is the manager that is being used.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果释放了字体，唯一的不同之处在于所使用的管理器。
- en: 'Speaking of styles, we need to have a regulated way of modifying them. The
    `UpdateStyle` method takes care of that job:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 说到样式，我们需要有一种规范的方式来修改它们。`UpdateStyle`方法负责这项工作：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Two arguments are expected by this method: the state being modified and a style
    structure that will be used to replace the existing structure. While overwriting
    the relevant style is as simple as using the assignment operator, some resource
    management has to take place before that happens. We need to know if the style
    being replaced requires different resources to the other one. If it does, the
    older textures and fonts are released, while the new ones are reserved by using
    two more helper methods which both look something like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法期望两个参数：正在修改的状态和一个将用于替换现有结构的样式结构。虽然使用赋值运算符覆盖相关样式很简单，但在那之前必须进行一些资源管理。我们需要知道被替换的样式是否需要与其他样式不同的资源。如果是，则释放旧的纹理和字体，而新的则通过使用两个看起来类似的辅助方法进行预留：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The font equivalent for this method uses a different manager but is otherwise
    identical.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的字体等效使用不同的管理器，但其他方面相同。
- en: 'Once the style is overwritten, we check if the state being modified is the
    same state as the element. If so, this particular element is marked to be re-drawn
    via the `SetRedraw` method, and its style is applied via the `ApplyStyle` method,
    which is what we''ll take a look at next:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦样式被覆盖，我们会检查正在修改的状态是否与元素的状态相同。如果是，这个特定的元素将通过`SetRedraw`方法标记为需要重新绘制，并且其样式将通过`ApplyStyle`方法应用，这是我们接下来要查看的内容：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This chunk of code is responsible for connecting the style of an element to
    its visual representation. It first invokes a few helper methods which help us
    break down the code into smaller, more manageable chunks. The owner interface
    needs to be alerted afterwards because any modification of the element style may
    result in size changes. If the element is not an interface control and isn't its
    own owner, the `AdjustContentSize` method of the `GUI_Interface` class is called,
    with the `this` keyword passed in as an argument. We will get to implement it
    soon.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码负责将元素的样式与其视觉表示连接起来。它首先调用几个辅助方法，帮助我们将代码分解成更小、更易于管理的块。之后，需要通知所有者接口，因为任何元素样式的修改可能会导致尺寸变化。如果元素不是接口控件并且不是它自己的所有者，则调用`GUI_Interface`类的`AdjustContentSize`方法，并将`this`关键字作为参数传递。我们很快就会实现它。
- en: 'Let''s take a look at the first helper method, which deals with text style:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一个辅助方法，它处理文本样式：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A different font, color, and character size can be applied to the text for each
    distinct style that an element can have. The text's origin also needs to be re-calculated
    every time this happens because these attributes can be manipulated at any point.
    The position of the text is then updated with the padding value of the current
    style being factored in.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为元素具有的每种不同样式应用不同的字体、颜色和字符大小。每次这些属性被操作时，文本的原始位置也需要重新计算，因为这些属性可以在任何点上被操作。然后，文本的位置会根据当前样式的填充值进行更新。
- en: 'Background style application follows the same basic idea:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 背景样式应用遵循相同的基本思想：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This shows how we add support for the background image and solid elements. Both
    of these elements are adjusted by applying the visual attributes of a current
    style and having their positions re-set.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了我们如何添加对背景图像和实心元素的支持。这两个元素都通过应用当前样式的视觉属性并重新设置其位置进行调整。
- en: 'Finally, the glyph of an element is altered in the same fashion:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，元素的符号以相同的方式被改变：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, let''s take a look at the changing element states:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看元素状态的变化：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The element must be marked for re-drawing if its state is changed as different
    states may have style elements that are also different. That, however, is only
    done if the state provided as an argument does not match the current state, which
    is done to conserve resources.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素的状态发生变化，必须将其标记为重新绘制，因为不同的状态可能具有不同的样式元素。然而，这只有在提供的状态参数与当前状态不匹配时才会进行，这样做是为了节省资源。
- en: 'Setting the element position also deserves some attention:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 设置元素位置也值得注意：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since all elements are owned by a container structure, their positions must
    also honor the padding of those containers. Once the element position is set,
    the padding of the container interface is obtained. If the element position on
    either axis is less than that padding, the position is set to be at least as far
    away from the edge as the interface allows it to be.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有元素都属于一个容器结构，因此它们的定位也必须尊重这些容器的填充。一旦元素的定位被设置，容器接口的填充就会被获取。如果元素在任一轴上的定位小于该填充，则定位将被设置为至少与边缘一样远，这是接口允许的最小距离。
- en: 'Here''s an important bit of code that can make or break interactions with any
    GUI surface:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一段重要的代码，它可以决定与任何GUI表面的交互是否成功：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `IsInside` method is used to determine whether a certain point in space
    is inside an element. Calculating intersections using its normal position yields
    incorrect results because of its relativity to its owner. Instead, it uses a `GetGlobalPosition`
    method to fetch the element's position in screen space, as opposed to local space,
    in the render texture of the owner interface. With a bit of basic bounding box
    collision magic, it then determines if a point provided as an argument is within
    the element, based on the size of its current style.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsInside` 方法用于确定空间中的某个点是否在元素内部。由于它与所有者的相对位置，使用其正常位置计算交集会产生错误的结果。相反，它使用 `GetGlobalPosition`
    方法从所有者接口的渲染纹理中获取元素的位置，而不是局部空间。然后，通过一点基本的边界框碰撞魔法，它根据元素当前样式的尺寸确定提供的点是否在元素内部。'
- en: 'Obtaining global positions of elements can be done like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 获取元素的全局位置可以这样做：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Firstly, the element's local position is grabbed. The method then determines
    if this element has an owner and if does not own itself. If it does, the fetched
    position is simply the final result and is returned. Otherwise, the owner's global
    position is obtained through the use of this very method and added to the local
    position. Furthermore, if the element is not a control type, the horizontal and
    vertical scroll values are subtracted from its position in order to honor interface
    scrolling.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，获取元素的局部位置。然后，该方法确定该元素是否有所有者以及它是否不属于自己。如果有，获取的位置就是最终结果并返回。否则，通过使用此方法获取所有者的全局位置，并将其添加到局部位置。此外，如果元素不是控件类型，则从其位置中减去水平和垂直滚动值，以尊重接口滚动。
- en: 'To cap things off, here are a few setters and getters that are not straightforward:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一些不是那么直接的设置器和获取器：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the methods `SetActive` and `SetText`. Whenever an element is modified,
    we must set its re-draw flag to `true`, otherwise it won't be updated until another
    event requires it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `SetActive` 和 `SetText` 方法。每当元素被修改时，我们必须将其重绘标志设置为 `true`，否则它将不会更新，直到另一个事件需要它。
- en: Defining GUI events
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义GUI事件
- en: Providing fluid interactivity with the interface and a painless way of associating
    changes with actions inside your application may be the most important criterion
    to separate good GUI systems from bad ones. As we are already learning SFML, we
    can use the SFML method and omit events.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与接口提供流畅的交互以及将更改与应用程序内部的操作关联起来的简便方式可能是区分良好GUI系统和不良GUI系统的最重要的标准。既然我们已经在学习SFML，我们可以使用SFML方法并省略事件。
- en: 'Firstly, we have to define all the possible events that could take place in
    an interface. Create a `GUI_Event.h` file and construct an enumeration, as shown
    here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须定义在接口中可能发生的所有可能的事件。创建一个 `GUI_Event.h` 文件并构建一个枚举，如下所示：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We must also define a custom structure in the same file that is used to hold
    event information:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在同一个文件中定义一个自定义结构，用于存储事件信息：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first thing to talk about here is the structure. It should be possible to
    merely use `sf::Vector2f` here. That would work fine under most circumstances
    but, a few lines below that, you see the importance of `ClickCoordinates`. Based
    on the type of event we're going to be working with, it's going to need to store
    different data in the `GUI_Event` structure. By using a *union* inside this structure,
    we're going to avoid allocating additional memory, but that comes at a price.
    Unions cannot have members that have member functions, virtual functions, or are
    derivatives of other classes. It is because of this restriction that we are forced
    to define our own `struct` that holds two *floats* and represents a point.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里首先要讨论的是结构。在这里仅仅使用`sf::Vector2f`应该是可能的。在大多数情况下，这会工作得很好，但在那几行下面，你会看到`ClickCoordinates`的重要性。根据我们将要处理的事件类型，它需要在`GUI_Event`结构中存储不同的数据。通过在这个结构内部使用一个*联合*，我们将避免分配额外的内存，但这也有代价。联合不能有成员函数、虚函数或派生自其他类的成员。正是因为这个限制，我们被迫定义自己的`struct`，它包含两个*浮点数*并代表一个点。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The boost library could potentially be useful in a situation like this as it
    provides `boost::variant`, which is a type-safe union container that doesn't have
    these limitations. It also has little or no overhead.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，boost库可能是有用的，因为它提供了`boost::variant`，这是一个类型安全的联合容器，没有这些限制。它还有很少或没有开销。
- en: The actual event structure holds an event type that is used to determine which
    member of the union is active, as well as names of the element and interface the
    event originated from. If you have a good eye for detail, you may have asked yourself
    by now why we're using `const char*` data types instead of `std::string`. Simplifying
    data types of data members is another sign that this structure will be incorporated
    into a union. Unfortunately, `std::string` falls into the same trap as `sf::Vector2f`
    and cannot be used in a union without extra work.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的事件结构包含一个事件类型，用于确定联合中哪个成员是活动的，以及事件起源的元素和接口的名称。如果你对细节有很好的洞察力，你现在可能已经问过自己为什么我们使用`const
    char*`数据类型而不是`std::string`。简化数据成员的数据类型是另一个迹象，表明这个结构将被纳入联合。不幸的是，`std::string`陷入了与`sf::Vector2f`相同的陷阱，不能在没有额外工作的前提下用于联合。
- en: The interface class
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口类
- en: An interface, in its simplest meaning, is a container of elements. It's a window
    that can be moved around and scrolled and has all of the same features and event
    hooks as a regular element. Efficiency is also a great concern, as dealing with
    lots of elements in a single window is a definite possibility. Those problems
    can be dealt with by carefully designing a way of drawing elements at the appropriate
    time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接口，在最简单的意义上，是一个元素的容器。它是一个可以移动和滚动的窗口，具有与常规元素相同的特性和事件钩子。效率也是一个很大的关注点，因为在单个窗口中处理大量元素是肯定可能发生的。这些问题可以通过精心设计在适当时间绘制元素的方式来解决。
- en: 'The way we want our interfaces to draw content is by using three separate textures
    for different purposes, as shown below:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望接口绘制内容的方式是使用三个不同的纹理，用于不同的目的，如下所示：
- en: '![The interface class](img/B04284_10_01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![接口类](img/B04284_10_01.jpg)'
- en: The **background** layer is used for drawing backdrop elements
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景**层用于绘制背景元素'
- en: The **content** layer is where all of the elements of the interface are drawn
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容**层是绘制接口所有元素的地方'
- en: The **controls** layer hosts elements such as scrollbars that manipulate the
    content layer and don't need to be scrolled
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控件**层托管如滚动条等元素，这些元素操作内容层且不需要滚动'
- en: 'With the design details out of the way, element storage deserves some attention.
    As it happens, the `std::unordered_map` structure serves this purpose well:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 设计细节确定后，元素存储值得注意。碰巧的是，`std::unordered_map`结构很好地服务于这个目的：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, a forward declaration of the owner class is needed to prevent cross-inclusion:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要一个所有者类的声明来防止交叉包含：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'All of this brings us to the `GUI_Interface` class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都带我们来到了`GUI_Interface`类：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the declarations of `friend` classes. Both the `GUI_Element` and `GUI_Manager`
    need to have access to private and protected members of this class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`friend`类的声明。`GUI_Element`和`GUI_Manager`都需要访问这个类的私有和受保护成员。
- en: For now, let's only focus on the private members and leave the public ones for
    the implementation section of this chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们只关注私有成员，并将公共成员留给本章的实现部分。
- en: In addition to having an element container, an interface also defines the amount
    of padding it has that elements most honor, a pointer to its parent class if it
    has one, as well as the manager class and a set of textures that represent its
    different layers. The rest of the data members, as well as the omitted methods,
    can't be fully understood unless we talk about implementation details, so let's
    get right to it!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拥有元素容器外，界面还定义了元素必须遵守的填充量，如果有的话，指向其父类的一个指针，以及管理类和一组代表其不同层的纹理。除非我们讨论实现细节，否则无法完全理解其余的数据成员以及省略的方法，所以让我们直接进入正题！
- en: Implementing the interface class
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现界面类
- en: 'A nice place to start, as always, is with the class constructor:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，一个不错的起点是类构造函数：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Quite a lot of data members are initialized through the initializer list here.
    Firstly, the parent class `GUI_Element` needs to know the name, type, and owner
    of the interface. One of the `GUI_Interface` arguments is its name, which gets
    passed to the `GUI_Element` constructor. The type is, of course, set to `Window`,
    and the `this` keyword is passed in as the owner of the interface. Additionally,
    the parent of the interface is initialized to its default value `nullptr` and
    a pointer to the `GUI_Manager` class is stored inside the `m_guiManager` data
    member.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过初始化列表初始化了很多数据成员。首先，父类 `GUI_Element` 需要知道界面的名字、类型和所有者。`GUI_Interface` 的一个参数是其名字，它被传递给
    `GUI_Element` 构造函数。类型当然设置为 `Window`，而 `this` 关键字作为界面的所有者传递。此外，界面的父类被初始化为其默认值 `nullptr`，并将指向
    `GUI_Manager` 类的指针存储在 `m_guiManager` 数据成员中。
- en: After the data member initialization, we enter the constructor's body, in which
    three `sf::RenderTexture` objects are allocated dynamically. These are the textures
    that are used to render the background, content, and control layers of an interface.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据成员初始化之后，我们进入构造函数的主体，其中动态分配了三个 `sf::RenderTexture` 对象。这些是用于渲染界面背景、内容和控制层的纹理。
- en: 'Next, let''s take a look at freeing up all of these resources in the destructor:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看在析构函数中释放所有这些资源：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The three texture instances, of course, have to be deleted, as well as every
    single element that still resides in the element container at the time of destruction.
    Afterwards, the element container is cleared.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这三个纹理实例也必须被删除，以及所有在销毁时仍然存在于元素容器中的单个元素。之后，元素容器被清空。
- en: 'Setting the position of an interface is slightly more complex, so let''s take
    a look:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 设置界面的位置稍微复杂一些，所以让我们来看看：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Firstly, the `SetPosition` method of the parent class is invoked in order to
    adjust the actual position. There is no need to fix what isn't broken. Next, the
    three sprites that represent the background, content, and control layers have
    their positions adjusted as well. Lastly, you set up the title bar. The solid
    background shape's position is set to be right above the interface, while the
    text of the visual component is used as a title and adjusted to take the same
    position as the title bar background, except with text padding included.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，调用父类的 `SetPosition` 方法来调整实际位置。没有必要修复没有损坏的东西。接下来，调整代表背景、内容和控制层的三个精灵的位置。最后，你设置标题栏。实心背景形状的位置被设置为在界面之上，而视觉组件的文本用作标题，并调整到与标题栏背景相同的位置，只是增加了文本填充。
- en: 'Empty windows aren''t very useful or entertaining, so let''s provide a way
    in which elements can be added to them:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 空的窗口并不很有用或有趣，所以让我们提供一种方法，通过这种方法可以将元素添加到它们中：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It is important to avoid name clashes so check the name provided as the second
    argument against the element container in order to prevent duplicates. If none
    are found, a `CreateElement` method of the `GUI_Manager` class is used to create
    an element of the relevant type on the heap and return its memory address. After
    verifying that it has indeed been created, the element's name and owner properties
    are set before it gets inserted into the element container. The interface then
    sets two flags to re-draw the content and control layers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 避免名称冲突很重要，所以需要将提供的第二个参数中的名称与元素容器进行核对，以防止重复。如果没有找到任何重复项，就使用 `GUI_Manager` 类的
    `CreateElement` 方法在堆上创建相关类型的元素，并返回其内存地址。在确认确实创建之后，设置元素的名字和所有者属性，然后将其插入到元素容器中。然后界面设置两个标志以重新绘制内容和控制层。
- en: 'Any interface needs to have a way to provide access to its elements. That''s
    where the `GetElement` method comes in:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 任何界面都需要一种提供对其元素访问的方法。这就是 `GetElement` 方法的作用所在：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It simply locates the element in the `std::unordered_map` using its find method
    and returns it. If the element isn't found, `nullptr` is returned instead. Easy.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是使用其查找方法在 `std::unordered_map` 中定位元素并返回它。如果找不到元素，则返回 `nullptr`。很简单。
- en: 'Next, we need to have a way to remove elements from interfaces:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法从界面中移除元素：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Following the same example as the `GetElement` method, the element is first
    located inside the container. The dynamic memory is then de-allocated by using
    the `delete` operator and the element itself is removed from the container. The
    interface is marked to re-draw its content and control layers and the `AdjustContentSize`
    method is invoked to re-size the content texture, if needed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 按照与 `GetElement` 方法相同的示例，首先在容器内定位元素。然后使用 `delete` 操作符释放动态内存，并将元素本身从容器中移除。界面被标记为重新绘制其内容和控制层，如果需要，调用
    `AdjustContentSize` 方法来调整内容纹理的大小。
- en: 'We need to override the original `IsInside` method because interfaces occupy
    additional space due to their title bars, as shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要覆盖原始的 `IsInside` 方法，因为界面由于标题栏的存在而占用额外的空间，如下所示：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The parent class method is invoked first to determine if `l_point` is inside
    the space an interface is occupying. If not, the result of the title bar bounding
    box's `contains` method is returned to determine if `l_point` is inside that.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先调用父类方法以确定 `l_point` 是否在界面占用的空间内。如果不是，则返回标题栏边界框的 `contains` 方法的结果以确定 `l_point`
    是否在该区域内。
- en: 'Next is shown the de-serialization portion of the code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来展示的是代码的反序列化部分：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: All interfaces first read in the element padding *x* and *y* values, as well
    as the state and title parameters. It then uses the `ReadQuotedText` utility function
    which we defined earlier to read in the actual title of the interface. Based on
    the strings read in, it then sets the `m_movable` and `m_showTitleBar` flags to
    reflect those values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所有界面首先读取元素的填充 *x* 和 *y* 值，以及状态和标题参数。然后使用我们之前定义的 `ReadQuotedText` 工具函数来读取界面的实际标题。根据读取的字符串，它随后设置
    `m_movable` 和 `m_showTitleBar` 标志以反映这些值。
- en: 'Now comes the fun part. Let''s define what happens when an interface is clicked:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分。让我们定义当界面被点击时会发生什么：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Firstly, we invoke one of the private helper methods responsible for removing
    focus from all of the `Textfield` GUI elements. This will be covered in more depth
    later. Another problem is dragging, when a click is detected in an interface.
    If the mouse position is in the title bar area and the interface itself is movable,
    we set the `m_beingMoved` flag to `true` to indicate interface dragging.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用负责从所有 `Textfield` GUI 元素中移除焦点的私有辅助方法之一。这将在稍后进行更深入的讨论。另一个问题是当在界面中检测到点击时发生的拖动。如果鼠标位置在标题栏区域，并且界面本身是可移动的，我们将
    `m_beingMoved` 标志设置为 `true` 以指示界面拖动。
- en: In a case of it just being a regular click anywhere else within the interface
    boundaries, we first set up an event that is going to be dispatched, indicating
    that a click has happened. The type is set to `Click`, the interface name is copied
    as a *c string*, and the mouse coordinates are also set up. The `AddEvent` method
    of the `GUI_Manager` class is invoked with our newly created event as an argument.
    This first event indicates that a click happened within the interface itself and
    not in any particular element.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只是界面边界内的常规点击，我们首先设置一个将要分发的事件，表示发生了点击。类型设置为 `Click`，界面名称被复制为 *c 字符串*，并且也设置了鼠标坐标。使用我们新创建的事件作为参数调用
    `GUI_Manager` 类的 `AddEvent` 方法。这个第一个事件表明点击发生在界面本身，而不是任何特定的元素中。
- en: 'That is quickly followed by a loop that iterates over every single element
    in the interface. Their `IsInside` method is called to determine whether the click
    that took place was also within any of the elements. If so, the `OnClick` method
    of that particular element is invoked with the mouse position passed in as an
    argument. The same event that was set up before the loop is then slightly modified
    to contain the name of the element and is fired again, indicating that the click
    also affects it. The interface''s state is then changed to `CLICKED`. The result
    of this is quite appealing to the eye:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这很快就会跟着一个循环，该循环遍历界面中的每一个单独的元素。它们的`IsInside`方法被调用以确定发生的点击是否也位于任何元素内部。如果是这样，那个特定元素的`OnClick`方法就会调用，并将鼠标位置作为参数传入。然后，在循环之前设置的同一次事件被稍微修改，包含元素的名称，并再次触发，表示点击也影响了它。随后，界面的状态被更改为`CLICKED`。这种结果看起来相当吸引人：
- en: '![Implementing the interface class](img/B04284_10_02.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![实现界面类](img/B04284_10_02.jpg)'
- en: 'Next, let''s take a look at the opposite side of clicking—the `OnRelease` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看点击的相反面——`OnRelease`方法：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Just like before, an event is set up and fired, indicating that a release happened
    within this specific interface. Every element is then iterated over and their
    states are checked. If the element is in a `Clicked` state, its `OnRelease` method
    is called and another event is fired, indicating the release of the left mouse
    button within that element. The state of the interface is then set to `Neutral`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，设置了一个事件并触发，表示在这个特定界面内发生了释放。然后，每个元素都会被迭代，并检查它们的状态。如果元素处于`Clicked`状态，它的`OnRelease`方法会被调用，并再次触发一个事件，表示在该元素内释放了左鼠标按钮。随后，界面的状态被设置为`Neutral`。
- en: 'An interface also needs to deal with text being entered:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 界面还需要处理输入的文本：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method is going to be invoked whenever an SFML event `sf::Event::TextEntered`
    is received by our window. Each element is iterated over until we find one that
    is of the type `Textfield` and is currently in a `Clicked` state. The backspace
    key being pressed is handled by having the last character of our element's text
    attribute trimmed. Note that we're returning from the method in multiple places
    in order to avoid several `Textfield` elements receiving the same text that is
    being entered.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的窗口接收到SFML事件`sf::Event::TextEntered`时，这个方法将会被调用。每个元素都会被迭代，直到我们找到一个类型为`Textfield`且当前处于`Clicked`状态的元素。按下的退格键通过从我们元素文本属性中剪除最后一个字符来处理。请注意，我们在方法中的多个地方返回，以避免多个`Textfield`元素接收到相同的输入文本。
- en: Lastly, we need to check the boundaries of the character value that has been
    received. Any characters below ID `32` or above `126` are reserved for other purposes
    and we're not interested in those. If a regular letter or number is typed in,
    we want to update our text attribute by adding that character to it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要检查接收到的字符值的边界。任何低于ID `32`或高于`126`的字符都保留用于其他目的，我们对此不感兴趣。如果输入的是常规字母或数字，我们希望通过将这个字符添加到它来更新我们的文本属性。
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The full table of ASCII characters can be found here: [http://www.asciitable.com/](http://www.asciitable.com/)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII字符的完整表可以在这里找到：[http://www.asciitable.com/](http://www.asciitable.com/)
- en: 'Since we''re on the subject of handling text field elements, let''s take a
    look at a method that we used before when handling a `Click` event:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们正在处理文本字段元素的处理，让我们看看在处理`Click`事件时我们之前使用过的一个方法：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When handling text fields, it's important to bear in mind that they lose focus
    every time a mouse is left-clicked. If that wasn't so, we would end up with text
    entered across multiple textboxes, and that is no good. Making a text field lose
    focus is as simple as constructing a `Release` event and sending it to every `Textfield`
    element that an interface possesses.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文本字段时，重要的是要记住，每次鼠标左键被点击时，它们都会失去焦点。如果不是这样，我们最终会在多个文本框中输入文本，这是不可取的。使文本字段失去焦点就像构造一个`Release`事件并将其发送到界面拥有的每个`Textfield`元素一样简单。
- en: 'The next two methods are grouped together due to their similarities:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个方法因为它们的相似性而被组合在一起：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'An event is constructed including the mouse coordinates when the mouse hovers
    over an interface, as opposed to when the mouse leaves the interface area as in
    the `OnLeave` method. `OnHover` and `OnLeave` are only called once per event as
    they do not deal with elements. That job is left to the `Update` method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标悬停在界面上时，构建一个包含鼠标坐标的事件，而不是在`OnLeave`方法中鼠标离开界面区域时。`OnHover`和`OnLeave`在每个事件中只调用一次，因为它们不处理元素。这项工作留给了`Update`方法：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After the mouse position is obtained, the `m_beingMoved` flag is checked to
    determine whether or not an interface is currently being dragged. If it is, and
    the saved position of the mouse is different to where the mouse is currently located,
    that difference is calculated and the interface''s location is adjusted based
    on it. With that out of the way, let''s take a look at the omitted chunk of code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得鼠标位置后，检查`m_beingMoved`标志以确定界面是否当前正在拖动。如果是，并且保存的鼠标位置与当前鼠标位置不同，则计算这个差异并根据它调整界面的位置。处理完这些后，让我们看看省略的代码块：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We begin by checking if the current element needs to be re-drawn. The relevant
    flag for re-drawing the entire interface is set to `true` if one is encountered,
    while taking into account whether it's a control element or not.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查当前元素是否需要重新绘制。如果遇到一个需要重新绘制整个界面的相关标志被设置为`true`，同时考虑到它是否是一个控制元素。
- en: When iterating over the list of all elements, their active status is checked.
    If an element is active, it gets updated. If the interface currently isn't being
    moved and the mouse is inside both the interface and the element, but not the
    title bar, the element's current state is checked. A `Hover` event needs to be
    dispatched and the `OnHover` method needs to be called if the element's current
    state is `Neutral`. However, if the mouse is not over the element, or the current
    interface's state is `Focused`, a `Leave` event is created and submitted, along
    with the `OnLeave` method being invoked.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当遍历所有元素的列表时，会检查它们的活动状态。如果一个元素处于活动状态，它将被更新。如果当前界面没有被移动，并且鼠标在界面和元素内部，但不在标题栏上，则检查元素当前的状态。如果元素当前状态为`Neutral`，则需要分发一个`Hover`事件并调用`OnHover`方法。然而，如果鼠标不在元素上，或者当前界面的状态是`Focused`，则创建一个`Leave`事件并将其提交，同时调用`OnLeave`方法。
- en: 'Now, let''s bring all of this hard work to the screen and render the interface:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将所有这些辛勤工作带到屏幕上并渲染界面：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is quite simple, thanks to our design involving three different render
    textures. In order to draw an interface successfully, the sprites for the background,
    content, and control layers have to be drawn in that specific order. If the `m_showTitleBar`
    flag is set to `true`, the title background must also be drawn along with the
    text.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，多亏了我们的设计涉及三个不同的渲染纹理。为了成功绘制界面，背景、内容和控制层的精灵必须按照特定的顺序绘制。如果`m_showTitleBar`标志设置为`true`，则标题背景也必须与文本一起绘制。
- en: 'Whereas the `Update` method does most of the work, moving interfaces requires
    a bit more preparation. Let''s begin by defining two helper methods for movement,
    starting with the one used to initiate the process:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Update`方法做了大部分工作，但移动界面需要更多的准备。让我们从定义两个用于移动的辅助方法开始，首先是用于启动过程的那个：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If the conditions to move an interface are met, this method is invoked in order
    to save the mouse position at the point where dragging began.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足移动界面的条件，则调用此方法以在拖动开始时保存鼠标位置。
- en: 'We also have a simple line of code to stop interface movement:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个简单的代码行来停止界面移动：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Since interfaces are quite different from normal GUI elements, they have to
    define their own way of obtaining their global position, as shown here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于界面与普通GUI元素有很大不同，它们必须定义自己的方式来获取它们的全局位置，如下所示：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When it obtains its actual position, it needs to follow through the chain of
    parent interfaces and sum all of their positions. A `while` loop serves as a nice
    way of doing this; the final position is returned when it concludes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当它获得其实际位置时，它需要遍历父界面的链并求和它们的所有位置。一个`while`循环是一个很好的做法；当循环结束时返回最终位置。
- en: 'The style application of an interface also differs from the usual element types.
    Let''s take a look:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 界面的样式应用也不同于常规元素类型。让我们看看：
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `ApplyStyle` method is invoked first because the parent class does a great
    job of setting up most of the visual components correctly. The background elements
    then need to be changed to have positions with absolute zero values because interfaces
    render these drawables to a texture and not to a screen. Regardless of the position
    of the interface, the positions of these elements will not change.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先调用`ApplyStyle`方法，因为父类在正确设置大多数视觉组件方面做得很好。然后需要将背景元素的位置更改为绝对零值，因为界面将这些可绘制元素渲染到纹理上而不是屏幕上。无论界面的位置如何，这些元素的位置都不会改变。
- en: Next, the title bar background is set up to match the size of the interface
    on the *x* axis and should have a height of 16 pixels on the *y* axis. This hardcoded
    value can be tweaked at any time. Its position is then set to be right above the
    interface. The fill color of the title background is defined by the element color
    property of its style.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置标题栏背景以匹配界面在*x*轴上的大小，并且在*y*轴上应有16像素的高度。这个硬编码的值可以在任何时候进行调整。其位置被设置为正好位于界面之上。标题背景的填充颜色由其样式的元素颜色属性定义。
- en: The last four lines set up the position of the title bar text and glyph. The
    position of the title bar background is summed together with the relevant padding
    to obtain the final position of these two attributes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后四行设置了标题栏文本和图标的定位。标题栏背景的定位与相关填充量相加，以获得这两个属性的最终位置。
- en: 'Rendering time! Let''s draw all of these visuals onto their respective textures,
    starting with the background layer:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染时间！让我们将这些视觉元素绘制到它们各自的纹理上，从背景层开始：
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Firstly, a check is made in order to be sure that the background texture is
    the same size as the current style dictates. If it isn't, the texture is recreated
    with the correct size.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进行一次检查以确保背景纹理的大小与当前样式规定的大小相同。如果不相同，则使用正确的大小重新创建纹理。
- en: The next line is extremely important for good looking results. At first glance,
    it simply clears the texture to the color black. If you look closely, however,
    you will notice that it has four arguments instead of three. The last argument
    is the **alpha channel**, or the transparency value for the color. The texture
    cleared to black appears as a large black square, and that's not what we want.
    Instead, we want it to be completely empty before drawing elements to it, which
    is what the alpha value of *0* will do.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行对于获得良好外观的结果至关重要。乍一看，它只是将纹理清除为黑色。然而，如果你仔细观察，你会发现它有四个参数而不是三个。最后一个参数是**alpha通道**，或颜色的透明度值。清除为黑色的纹理看起来像一个大黑方块，这并不是我们想要的。相反，我们希望它在绘制元素之前完全为空，这正是*0*的alpha值所做到的。
- en: Next, the `ApplyStyle` method is invoked in order to adjust the visual parts
    of the interface to match the current style. The background solid and the background
    image are then drawn onto the background texture. The texture's `display` method
    *must* be called in order to show all of the changes made to it, just like the
    render window.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用`ApplyStyle`方法以调整界面的视觉部分以匹配当前样式。然后，将背景固体和背景图像绘制到背景纹理上。为了显示对其所做的所有更改，必须调用纹理的`display`方法，就像渲染窗口一样。
- en: Lastly, the background sprite is bound to the background texture and its visible
    area is cropped to the interface size in order to prevent overflow. The redraw
    flag is set to `false` to indicate that this process is complete.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将背景精灵绑定到背景纹理上，并将其可视区域裁剪到界面大小，以防止溢出。重绘标志被设置为`false`以指示此过程已完成。
- en: 'A very similar process also needs to occur for the content layer:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内容层也需要发生一个非常类似的过程：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The content texture is checked for dimensions. The only difference here is that
    we're keeping a manual track of its size in the `m_contentSize` float vector,
    which will be covered later.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 检查内容纹理的尺寸。这里唯一的区别是我们正在手动跟踪其大小在`m_contentSize`浮点向量中，这将在稍后介绍。
- en: After the texture is cleared, we iterate over all of the elements inside the
    interface and check whether they are active or a control element. If all of these
    conditions are satisfied, the element's style is applied and it is rendered onto
    the content texture, which gets passed in as the argument of the `Draw` method.
    Its re-draw flag is then set to `false`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在清除纹理之后，我们遍历界面内的所有元素，检查它们是否处于活动状态或是一个控件元素。如果所有这些条件都满足，元素的样式就会被应用，并将其渲染到传入`Draw`方法的内容纹理上，其重绘标志随后被设置为`false`。
- en: 'After displaying the texture and binding it to a relevant sprite, it too gets
    cropped, except that, this time, we use the `m_scrollHorizontal` and `m_scrollVertical`
    data members as the first two arguments in order to account for scrolling. Consider
    the following illustration:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示纹理并将其绑定到相关精灵之后，它也会被裁剪，但这次，我们使用`m_scrollHorizontal`和`m_scrollVertical`数据成员作为前两个参数，以便考虑滚动。请考虑以下插图：
- en: '![Implementing the interface class](img/B04284_10_03.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![实现界面类](img/B04284_10_03.jpg)'
- en: 'Scrolling an interface means moving the cropped rectangle across the content
    texture. The `m_contentRedraw` flag then gets set to `false` to signify that the
    re-draw process has concluded. It leaves us with a result that looks like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动界面意味着将裁剪的矩形在内容纹理上移动。然后`m_contentRedraw`标志被设置为`false`，以表示重绘过程已结束。这让我们得到了如下结果：
- en: '![Implementing the interface class](img/B04284_10_04.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![实现界面类](img/B04284_10_04.jpg)'
- en: 'The final layer of the interface follows an almost identical path:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 界面的最后一层遵循几乎相同的路径：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The main difference here is that the texture is aiming to match the size of
    the current style, just like the background layer. Only the control elements are
    drawn this time.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于纹理旨在匹配当前样式的大小，就像背景层一样。这次只绘制了控制元素。
- en: 'The subject of interface scrolling keeps popping up, so let''s take a look
    at how it is done:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 界面滚动的主题不断出现，所以让我们看看它是如何实现的：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Both the horizontal and vertical adjustment methods take in a percentage value
    that tells the interface how much it should be scrolled. The actual amount of
    pixels an interface should be offset by is calculated by first dividing the difference
    of its content size on the relevant axis and the size of the interface itself
    by a hundred, and multiplying the result by the percentage argument. The texture
    rectangle is then obtained to maintain the proper width and height of the content
    area, which is then re-set with the scroll values as the first two arguments.
    This effectively simulates the scroll sensation of an interface.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 水平和垂直调整方法都接受一个百分比值，告诉界面它应该滚动多少。界面应该偏移的实际像素量是通过首先将相关轴上内容大小与其自身大小的差值除以一百，然后将结果乘以百分比参数来计算的。然后获取纹理矩形以保持内容区域的适当宽度和高度，然后使用滚动值作为前两个参数重新设置。这有效地模拟了界面的滚动感觉。
- en: 'Adding, removing, or manipulating different elements inside an interface may
    alter its size. Here''s a method to solve those problems:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在界面内部添加、删除或操作不同的元素可能会改变其大小。这里有一个解决这些问题的方法：
- en: '[PRE54]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Before examining it in depth, I can show you that, inside the class definition,
    this method looks like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨它之前，我可以向你展示，在类定义内部，这个方法看起来是这样的：
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Its only argument has a default value of `nullptr`, which enables the method
    to detect size changes with or without a reference element.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它的唯一参数有一个默认值`nullptr`，这使得方法能够在有或没有引用元素的情况下检测大小变化。
- en: If an element is provided as an argument, which usually happens when one is
    added to an interface, its bottom-right corner coordinates are calculated using
    its position and size. If these coordinates are somewhere outside of the content
    size boundaries, the content size is adjusted to be larger and the control redraw
    flag is set to `true` because the physical dimensions of the sliders will be changing.
    The method then returns in order to prevent the rest of the logic from being executed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了一个元素作为参数，这通常发生在将其添加到界面中时，其右下角坐标将使用其位置和大小来计算。如果这些坐标位于内容大小边界之外，则内容大小将被调整以更大，并且控制重绘标志被设置为`true`，因为滑动条的物理尺寸将会改变。然后方法返回，以防止执行其余逻辑。
- en: Without a reference element, a float vector is set up to keep track of the farthest
    point within the interface texture, the original value of which is the interface
    size. Every active non-control element is then iterated over and checked to see
    if it exceeds the furthest point in the texture, which simply gets overwritten
    on a relevant axis. If an element is found that pokes outside of these boundaries,
    its bottom-right corner position is stored and the control layer is marked for
    re-drawing. The content size itself is set to the farthest corner of the interface
    after all of the elements have been checked.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参考元素，浮点向量被设置来跟踪界面纹理内的最远点，其原始值是界面大小。然后，遍历每个活动的非控件元素，检查它是否超过了纹理中的最远点，这只是在相关轴上简单地被覆盖。如果找到一个超出这些边界的元素，它的右下角位置将被存储，并且控件层将被标记为需要重绘。在检查所有元素之后，内容大小被设置为界面的最远角。
- en: This final code snippet concludes the interface class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的代码片段结束了界面类的编写。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Just as a book without binding is simply a stack of papers, the code we've written
    doesn't become what it needs to be unless it is properly incorporated and managed.
    The groundwork we've laid down in this chapter will aid us greatly in implementing
    a fully functional GUI system but it only represents all the pieces being laid
    out.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如没有装订的书只是一摞纸张一样，我们编写的代码如果不被正确地整合和管理，就不会成为它需要成为的样子。我们在本章中打下的基础将极大地帮助我们实现一个完全功能的GUI系统，但它只代表了所有部件的布局。
- en: So far, we have covered the basic design of GUI elements and windows, as well
    as implementing quite a few useful features that different types of elements can
    use. While that is a lot of code, we're not quite done yet. In the next chapter,
    we will be bringing all of the pieces we worked on together, as well as creating
    actual GUI elements. See you there!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了GUI元素和窗口的基本设计，以及实现了许多不同类型元素可以使用的有用功能。虽然代码量已经不少，但我们还没有完成。在下一章中，我们将把所有我们已经工作的部分整合在一起，以及创建实际的GUI元素。那里见！
