<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Expanding Space"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Expanding Space</h1></div></div></div><p>Now that you know how to build your 3D world, it is time to do stuff! As we are building a space racing game, we need to be able to move our space ship around. We will also put some obstacles in the game so that we have something to race against. In this chapter, you will learn about the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Placing game objects</strong></span>: We will take some 3D objects, load them into our game, and place them in 3D space.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Transformations</strong></span>: We need to learn how to move in 3D. Moving in 2D was easy. In 3D, we have another dimension, and we will now also want to account for rotation as we move around.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Point of view</strong></span>: We will learn how the point of view affects how we play the game. Do you want to be in the pilot's seat or just outside the ship?</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Collisions</strong></span>: We performed some collision detection in our 2D game. Collision detection in 3D is more complicated because we now have to consider all three spatial dimensions in our checks.</li></ul></div><div class="section" title="Creation 101"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec58"/>Creation 101</h1></div></div></div><p>Our first task is to load our world. We need a few basic components. First, we need a universe. This<a id="id588" class="indexterm"/> universe will contain stars, asteroids, and our space ship. Open up SpaceRacer3D and let's get coding!</p><div class="section" title="Preparing the project"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec153"/>Preparing the project</h2></div></div></div><p>Before we get going, we will need to move some code over from our 2D project. Copy the following files <a id="id589" class="indexterm"/>and settings from RoboRacer2D to SpaceRacer3D:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Copy <code class="literal">Input.cpp</code> and <code class="literal">Input.h</code>—we will use these classes to handle user input.</li><li class="listitem">Copy <code class="literal">Sprite.cpp</code>, <code class="literal">Sprite.h</code>, <code class="literal">SOIL.h</code>, and <code class="literal">SOIL.lib</code>—we will use them to support the user interface in the next chapter. You may need to remove the line <code class="literal">#include "stdafx.h"</code> from <code class="literal">Sprite.cpp</code>.</li><li class="listitem">Copy <code class="literal">fmodex.dll</code>—we need this for audio support.</li><li class="listitem">Copy the <a id="id590" class="indexterm"/>settings from the project <code class="literal">Configuration Properties/C/C++/General/Additional Include Directories</code> setting—this is necessary to provide access to FMOD library:<div class="mediaobject"><img src="graphics/8199OS_10_04.jpg" alt="Preparing the project"/></div></li><li class="listitem">Copy the settings from the project <code class="literal">Configuration Properties/Linker/Input/ Additional Dependencies</code> setting—this is necessary to provide access to the OpenGL, FMOD, and SOIL libraries:<div class="mediaobject"><img src="graphics/8199OS_10_05.jpg" alt="Preparing the project"/></div></li><li class="listitem">Copy the settings from the project Configuration Properties/Linker/ General/Additional Library Directories setting—this is also necessary to provide access to FMOD library:<div class="mediaobject"><img src="graphics/8199OS_10_01a.jpg" alt="Preparing the project"/></div></li></ol></div></div><div class="section" title="Loading game objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec154"/>Loading game objects</h2></div></div></div><p>In the previous <a id="id591" class="indexterm"/>chapter, we learned how to create 3D objects<a id="id592" class="indexterm"/> in Blender and export them as <code class="literal">obj</code> files. We then added code to our project to load the <code class="literal">obj</code> data. Now, we will use that code to load some models into our game.</p><p>We are going to load four models into our game: the space ship, and three asteroids. The idea will be to race through the asteroid field. As our loader holds the model data as three arrays (vertices, uvs, and normals), we will create a model class that defines these arrays and then use this class for each model that we want to load into the game.</p><div class="section" title="The Model class header"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec37"/>The Model class header</h3></div></div></div><p>Create a <a id="id593" class="indexterm"/>new class and header file named <code class="literal">Model.cpp</code> and <code class="literal">Model.h</code>, respectively. Open <code class="literal">Model.h</code>. First, let's get the header set up:</p><div class="informalexample"><pre class="programlisting">#pragma once
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include "LoadObj.h"
#include "glut.h"</pre></div><p>We need to <a id="id594" class="indexterm"/>use some constants defined in <code class="literal">math.h</code>, so we need to add a preprocessor directive. Add <code class="literal">_USE_MATH_DEFINES</code> to <code class="literal">Configuration Properties/C/C++/Preprocessor/Preprocessor Definitions</code>. Also, notice that we include <code class="literal">LoadObj.h</code> because we will load the model from inside this class. Now, let's create the class:</p><div class="informalexample"><pre class="programlisting">class Model
{
  
  public:
  
  struct Color
  {
    Color()
    {
      r = 0.0f;
      g = 0.0f;
      b = 0.0f;
    }
    Color(const float p_r, const float p_g, const float p_b)
    {
      r = p_r;
      g = p_g;
      b = p_b;
    }
    float r;
    float g;
    float b;
  };
};</pre></div><p>We will be using color a lot, so we are defining a <code class="literal">struct</code> to hold the <code class="literal">r</code>, <code class="literal">g</code>, and <code class="literal">b</code> values to make things more convenient. Now, for our methods we use the following code:</p><div class="informalexample"><pre class="programlisting"> Model(const char* p_filepath, const Color p_color);
 ~Model();
 void Update(const float p_deltaTime);
 void Render();
 void SetPosition(const float p_x, const float p_y, const float p_z);
 void SetPosition(const Vec3 p_position);
 const Vec3 GetPosition() const;
 void SetHeading(const float p_x, const float p_y, const float p_z);
 void SetHeading(const Vec3 p_heading);
 const Vec3 GetHeading() const;
 void SetColor(const float p_red, const float p_green, const float p_blue);
 void SetColor(const Color p_color);
 void SetBaseRotation(const float p_x, const float p_y, const float p_z);
 void SetBaseRotation(const Vec3 p_rotation);
 const Vec3 GetBaseRotation() const;
 void SetHeadingRotation(const float p_x, const float p_y, const float p_z);
 void SetHeadingRotation(const Vec3 p_rotation);
 const Vec3 GetHeadingRotation() const;
 void SetVelocity(const float p_velocity);
 const float GetVelocity() const;
 const bool IsShip();
 void IsShip(const bool p_IsShip);
 const bool IsVisible() const { return m_isVisible; };
 void IsVisible(const bool p_isVisible) { m_isVisible = p_isVisible; };
};</pre></div><p>Here is a<a id="id595" class="indexterm"/> short description of each method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Model</code> is the constructor. It takes a filename and a color. As our models are simple shapes, we will use color to give them some pizzazz.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SetPosition</code> and <code class="literal">GetPosition</code> manage the object's position in world space.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SetHeading</code> and <code class="literal">GetHeading</code> manage the direction the object is heading.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SetColor</code> and <code class="literal">GetColor</code> manage the objects color.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SetBaseRotation</code> and <code class="literal">GetBaseRotation</code> manage any local rotation applied to the object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SetHeadingRotation</code> and <code class="literal">GetHeadingRotation</code> manage the orientation of the object in world space.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SetVelocity</code> and <code class="literal">GetVelocity</code> manage the speed of the object.</li></ul></div><p>Now, for<a id="id596" class="indexterm"/> the variables, we use the following code:</p><div class="informalexample"><pre class="programlisting">m_vertices;
 std::vectorm_normals;
 Vec3 m_position;
 Vec3 m_heading;
 Vec3 m_baseRotation;
 Vec3 m_headingRotation;
 Color m_color;
 Primitive m_primitive;
 float m_velocity;
 
 bool m_isVisible;
 bool m_loaded;
 bool m_IsShip;

 float m_radius;
 bool m_collideable;</pre></div><p>These are self-explanatory because they directly correspond to the methods described previously. This header is a good structure for everything that we will need to do to place objects in our world and move them around.</p></div><div class="section" title="Implementing the Model class"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec38"/>Implementing the Model class</h3></div></div></div><p>Now let's<a id="id597" class="indexterm"/> implement the class. Open <code class="literal">Model.cpp</code> and let's get started. First, we implement the header, constructor, and destructor:</p><div class="informalexample"><pre class="programlisting">#include "Model.h"

Model::Model(const char* p_filepath, const Color p_color)
{
 m_filepath = p_filepath;
 m_loaded = LoadObj(m_filepath, m_vertices, m_normals, m_primitive);
 SetPosition(0.0f, 0.0f, 0.0f);
 SetHeading(0.0f, 0.0f, 0.0f);
 SetHeadingRotation(0.0f, 0.0f, 0.0f);
 SetBaseRotation(0.0f, 0.0f, 0.0f);
 IsShip(false);
 SetVelocity(0.0f);
 SetColor(p_color.r, p_color.g, p_color.b);
 SetRadius(1.0f);
 IsCollideable(true);
 IsVisible(true);
}
Model::~Model()
{
 m_vertices.clear();
 m_normals.clear();
}</pre></div><p>The constructor sets everything up. Notice that we call <code class="literal">LoadObj</code> from the constructor to actually load the object into the class. The results will be stored into member arrays <code class="literal">m_vertices</code> and <code class="literal">m_normals</code>. <code class="literal">m_primitive</code> will hold an enum telling us whether this object is defined by quads or triangles. The remaining variables are set to default values. These can be defined at any time in the game by using the appropriate <code class="literal">accessor</code> method:</p><div class="informalexample"><pre class="programlisting">float Deg2Rad(const float p_degrees)
{
  return p_degrees * (M_PI / 180.0f);

}</pre></div><p>
<code class="literal">Deg2Rad</code> is a helper function that will convert degrees to radians. As we move the ship around, we keep track of the heading angle in degrees, but we often need to use radians in OpenGL functions:</p><div class="informalexample"><pre class="programlisting">void Model::Update(const float p_deltaTime)
{
 Vec3 targetRotation = GetHeadingRotation();
 Vec3 currentPosition = GetPosition();
 Vec3 targetPosition = GetPosition();

 float distance = m_velocity * p_deltaTime;
 Vec3 deltaPosition;

 deltaPosition.y = cos(Deg2Rad(targetRotation.z)) * distance;
 deltaPosition.x = -sin(Deg2Rad(targetRotation.z)) * distance;
 deltaPosition.z = sin(Deg2Rad(targetRotation.x)) * distance;

 targetPosition.x += deltaPosition.x;
 targetPosition.y += deltaPosition.y;
 targetPosition.z += deltaPosition.z;
 SetPosition(targetPosition);
}</pre></div><p>The <code class="literal">Update</code> function updates the position of the object based on the object's velocity. Finally, we <a id="id598" class="indexterm"/>update <code class="literal">m_heading</code>, which will be used to orient the world camera during the render. Then update the object's position in world space:</p><div class="informalexample"><pre class="programlisting">void Model::Render()
{
 if (IsVisible())
 {
  glRotatef(-m_baseRotation.x, 1.0f, 0.0f, 0.0f);
  glRotatef(-m_baseRotation.y, 0.0f, 1.0f, 0.0f);
  glRotatef(-m_baseRotation.z, 0.0f, 0.0f, 1.0f);

  Vec3 targetRotation = GetHeadingRotation();
  Vec3 currentPosition = GetPosition();

  if (m_IsShip)
  {
   glPushMatrix();
   glLoadIdentity();
   glRotatef(targetRotation.x, 1.0f, 0.0f, 0.0f);
   glRotatef(targetRotation.y, 0.0f, 1.0f, 0.0f);
   glRotatef(targetRotation.z, 0.0f, 0.0f, 1.0f);
   GLfloat matrix[16];
   glGetFloatv(GL_MODELVIEW_MATRIX, matrix);
   glPopMatrix();
   glTranslatef(currentPosition.x, currentPosition.y, currentPosition.z);
   glMultMatrixf(matrix);
  }

  switch (m_primitive)
  {
  case Primitive::Quads:
   glBegin(GL_QUADS);
   break;
  case Primitive::Triangles:
   glBegin(GL_TRIANGLES);
   break;
  }
  glColor3f(m_color.r, m_color.g, m_color.b);
  for (unsigned int i = 0; i &lt; m_vertices.size(); i++)
  {
   if (m_IsShip)
   {
    glVertex3f(m_vertices[i].x, m_vertices[i].y, m_vertices[i].z);
   }
   else
   {
    glVertex3f(m_vertices[i].x + m_position.x, m_vertices[i].y + m_position.y, m_vertices[i].z + m_position.z);
   }
  }
  glEnd();
 }
}</pre></div><p>The <code class="literal">Render</code> function takes care of rendering this particular object. The setup for the world matrix <a id="id599" class="indexterm"/>will happen in the game code. Then each object in the game will be rendered.</p><p>Remember the camera? The camera is a virtual object that is used to view the scene. In our case, the camera is the ship. Wherever the ship goes, the camera will go. Whatever the ship points at, the camera will point at.</p><p>Now for the real mind-blower; OpenGL doesn't really have a camera. That is, there really isn't a camera that you move around in the scene. Instead, the camera is always located at coordinates (<span class="strong"><strong>0.0, 0.0, 0.0</strong></span>), or the world's origin. This means that our ship will always be located at the origin. Instead of moving the ship, we will actually move the other objects in the opposite direction. When we turn the ship, we will actually rotate the world in the opposite direction.</p><p>Now look at the code for the <code class="literal">Render</code> function:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we use <code class="literal">glRotate</code> to rotate everything the object's base rotation. This comes in useful if we need to orient the object. For example, the cylinder that we modeled in the previous chapter is standing up, and it works better in the game lying on its side. You will see later that we apply a 90 degree rotation to the cylinder to achieve this.</li><li class="listitem" style="list-style-type: disc">Next, we have to decide whether we are going to render quads or triangles. When Blender exports a model, it exports it as either quads or triangles. The loader figures out whether a model is defined as quads or triangles and stores the result in <code class="literal">m_primitive</code>. We then use that to determine whether this particular object must be rendered using triangles or quads.</li><li class="listitem" style="list-style-type: disc">We use <code class="literal">glColor</code> to set the color of the object. At this point we haven't assigned any textures to our models, so color gives us a simple way to give each object a personality.</li></ul></div><p>Now for the<a id="id600" class="indexterm"/> real work! We need to draw each vertex of the object in world space. To do this, we loop through each point in the vertices array, and we use <code class="literal">glVertex3f</code> to place each point.</p><p>The catch is this; the points in the vertices array are in local coordinates. If we drew every object using these points, then they would all be drawn at the origin. You will recall that we want to place each object in the game relative to the ship. So, we draw the ship at the origin, and we draw every other object in the game based on the position of the ship. We move the universe, not the ship.</p><div class="mediaobject"><img src="graphics/8199OS_10_01.jpg" alt="Implementing the Model class"/></div><p>When the ship moves, the entire coordinate system moves with it. Actually, the coordinate system stays put and the entire universe moves past it!</p><div class="mediaobject"><img src="graphics/8199OS_10_02.jpg" alt="Implementing the Model class"/></div><p>If we happen to be rendering the ship, we just draw it using its local coordinates and it is rendered at the origin. All of the other objects<a id="id601" class="indexterm"/> are drawn at a distance away from the ship based on the ships position.</p><p>Now, for the rest of the class implementation, use the following code:</p><div class="informalexample"><pre class="programlisting">void Model::SetPosition(const float p_x, const float p_y, const float p_z)
{
  m_position.x = p_x;
  m_position.y = p_y;
  m_position.z = p_z;
}

void Model::SetPosition(const Vec3 p_position)
{
  m_position.x = p_position.x;
  m_position.y = p_position.y;
  m_position.z = p_position.z;
}

const Vec3 Model::GetPosition() const
{
  return m_position;
}</pre></div><p>These methods set and retrieve the object's position. The position is changed based on the object's velocity in the <code class="literal">Update</code> method:</p><div class="informalexample"><pre class="programlisting">void Model::SetHeading(const float p_x, const float p_y, const float p_z)
{
  m_heading.x = p_x;
  m_heading.y = p_y;
  m_heading.z = p_z;
}

void Model::SetHeading(const Vec3 p_heading)
{
  m_heading.x = p_heading.x;
  m_heading.y = p_heading.y;
  m_heading.z = p_heading.z;
}
const Vec3 Model::GetHeading() const
{
  return m_heading;
}</pre></div><p>These <a id="id602" class="indexterm"/>methods set and retrieve the object's heading. The heading is changed based on the object's heading rotations in the <code class="literal">Update</code> method. Heading is the direction that the ship is headed in, and is used to rotate the world so that the ship appears to be heading in the correct direction:</p><div class="informalexample"><pre class="programlisting">void Model::SetColor(const float p_red, const float p_green, const float p_blue)
{
  m_color.r = p_red;
  m_color.g = p_green;
  m_color.b = p_blue;
}

void Model::SetColor(const Color p_color)
{
  m_color.r = p_color.r;
  m_color.g = p_color.g;
  m_color.b = p_color.b;
}</pre></div><p>These methods are used to manage the object's color:</p><div class="informalexample"><pre class="programlisting">void Model::SetVelocity(const float p_velocity)
{
  m_velocity = p_velocity;
}

const float Model::GetVelocity() const
{
  return m_velocity;
}</pre></div><p>These <a id="id603" class="indexterm"/>methods are used to manage the object's velocity. The velocity is set in the game code during the input phase:</p><div class="informalexample"><pre class="programlisting">void Model::SetBaseRotation(const float p_x, const float p_y, const float p_z)
{
  m_baseRotation.x = p_x;
  m_baseRotation.y = p_y;
  m_baseRotation.z = p_z;
}

void Model::SetBaseRotation(const Vec3 p_rotation)
{
  m_baseRotation.x = p_rotation.x;
  m_baseRotation.y = p_rotation.y;
  m_baseRotation.z = p_rotation.z;
}

const Vec3 Model::GetBaseRotation() const
{
  return m_baseRotation;
}</pre></div><p>These methods are used to manage the object's base rotation. The base rotation is used to rotate the object in local space:</p><div class="informalexample"><pre class="programlisting">void Model::SetHeadingRotation(const float p_x, const float p_y, const float p_z)
{
  m_headingRotation.x = p_x;
  m_headingRotation.y = p_y;
  m_headingRotation.z = p_z;
}

void Model::SetHeadingRotation(const Vec3 p_rotation)
{
  m_headingRotation.x = p_rotation.x;
  m_headingRotation.y = p_rotation.y;
  m_headingRotation.z = p_rotation.z;
}

const Vec3 Model::GetHeadingRotation() const
{
  return m_headingRotation;
}</pre></div><p>These methods are used to manage the object's heading rotation. The heading rotation is used to <a id="id604" class="indexterm"/>rotate the world around the object so that the object appears to be heading in a particular direction. Only one object (the ship) will have a heading rotation. Another way to think about this is that the heading rotation is the rotation of the camera, which in our game is attached to the ship.</p></div><div class="section" title="Modifying the game code"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec39"/>Modifying the game code</h3></div></div></div><p>Now it's time to <a id="id605" class="indexterm"/>modify our game code so that it can load and manipulate game models. Open <code class="literal">SpaceRacer3D.cpp</code>.</p><p>We'll start by adding the appropriate headers. At the top of the code, modify the header definitions so that they look like the following code:</p><div class="informalexample"><pre class="programlisting">#include &lt;windows.h&gt;
#include "Model.h"
#include "Sprite.h"
#include "Input.h"
#include "glut.h"</pre></div><p>Notice that we have added <code class="literal">Model.h</code> to load our models. We also included <code class="literal">Sprite.h</code> and <code class="literal">Input.h</code> from RoboRacer2D so that we can use those classes in our new game when necessary.</p><p>Now, we need to define some global variables to manage model loading. Just under any global variables that are already defined, add the following code:</p><div class="informalexample"><pre class="programlisting">Model* ship;
std::vector&lt;Model*&gt; asteroids;</pre></div><p>These variables defined pointers to our game objects. As the ship is kind of special, we give it its own pointer. We want to be able to have an arbitrary number of asteroids; we set up a vector (a nice dynamic array) of pointers called asteroids.</p><p>Move down to the <code class="literal">StartGame</code> function, which we use to initialize all of our game models. Modify the <code class="literal">StartGame</code> function to look like the following code:</p><div class="informalexample"><pre class="programlisting">void StartGame()
{
 //Ship
 Model::Color c(0.0f, 0.0f, 1.0f);
 ship = new Model("ship.obj", c);
 Vec3 rotation(90.0f, 0.0f, 0.0f);
 ship-&gt;SetBaseRotation(rotation);
 ship-&gt;IsShip(true);
 ship-&gt;SetVelocity(1.0f);

 //Asteroid 1
 c.r = 1.0f;
 c.g = 0.0f;
 c.b = 0.0f;
 Model* asteroid = new Model("asteroid.obj", c);
 Vec3 position(0.0f, 0.0f, -10.0f);
 asteroid-&gt;SetPosition(position);
 asteroids.push_back(asteroid);

 //Asteroid 2
 c.r = 0.0f;
 c.g = 1.0f;
 c.b = 0.0f;
 asteroid = new Model("asteroid.obj", c);
 position.x = 5.0f;
 position.y = 0.0f;
 position.z = -15.0f;
 asteroid-&gt;SetPosition(position);
 asteroids.push_back(asteroid);

 //Asteroid 3
 c.r = 0.0f;
 c.g = 1.0f;
 c.b = 1.0f;
 asteroid = new Model("asteroid.obj", c);
 position.x = 5.0f;
 position.y = 5.0f;
 position.z = -20.0f;
 asteroid-&gt;SetPosition(position);
 asteroids.push_back(asteroid);
}</pre></div><p>We are <a id="id606" class="indexterm"/>going to create one object for the ship and three asteroids. For each object, we first define a color, then we create a new <code class="literal">Model</code> passing the filename of the object and the color. The <code class="literal">Model</code> class will load the object file exported from Blender.</p><p>Notice that we set the ship to be the camera with the <code class="literal">IsCamera(true)</code> call. We also attach the ship as the camera for every game object using the <code class="literal">AttachCamera(ship)</code> call.</p><p>We also set a position for each object. This will set the position in world space. This way we don't end up drawing every object at the origin!</p><p>Each asteroid is put in the asteroids array using the <code class="literal">push.back</code> method.</p><p>Now, we move to the <code class="literal">Update</code> function. Modify the <code class="literal">Update</code> function so that it looks like the following code:</p><div class="informalexample"><pre class="programlisting">void Update(const float p_deltaTime)
{
  
  ship-&gt;Update(p_deltaTime);
  
  for (unsigned int i = 0; i &lt; asteroids.size(); i++)
  {
    asteroids[i]-&gt;Update(p_deltaTime);
  }
}</pre></div><p>The update<a id="id607" class="indexterm"/> simply calls the <code class="literal">Update</code> method for every object in the game. As always, the update is based on the amount of time that has passed in the game, so we pass in <code class="literal">p_deltaTime</code>.</p><p>Now on to the <code class="literal">Render</code> function. Replace the existing code with the following code:</p><div class="informalexample"><pre class="programlisting">void Render()
{
 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 glMatrixMode(GL_MODELVIEW);
 glLoadIdentity();

 for (unsigned int i = 0; i &lt; asteroids.size(); i++)
 {
  asteroids[i]-&gt;Render();
 }
 ship-&gt;Render();
 SwapBuffers(hDC);
}</pre></div><p>The rendering<a id="id608" class="indexterm"/> code is the real workhorse of the game. First, we set up the render call for this frame, then we call the <code class="literal">Render</code> method for each game object:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GlClear</code>: This clears the render buffer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">GlMatrixMode</code>: This sets the model to the model view. All translations and rotations are applied to the in the model view.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glLoadIdentity()</code>: This resets the matrix.</li><li class="listitem" style="list-style-type: disc">Next, we<a id="id609" class="indexterm"/> call the <code class="literal">Render</code> method for each object in the game.</li><li class="listitem" style="list-style-type: disc">Finally, we call <code class="literal">SwapBuffers</code>, which actually renders the scene to the screen.</li></ul></div><p>Congratulations! If you run the game now, you should see the ship and the three asteroids off in the distance. As we set the velocity of the ship to 1.0, you should also see the ship slowly moving past the asteroids. However, we don't have any way to control the ship yet because we haven't implemented any input.</p><div class="mediaobject"><img src="graphics/8199OS_10_06.jpg" alt="Modifying the game code"/></div></div></div></div></div>
<div class="section" title="Taking control"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec59"/>Taking control</h1></div></div></div><p>We now have a framework to load and render game objects. But, we don't have any way to move <a id="id610" class="indexterm"/>our ship! The good news is that we already wrote an input class for RoboRacer2D, and we can reuse that code here.</p><div class="section" title="Implementing input"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec155"/>Implementing input</h2></div></div></div><p>Earlier in the<a id="id611" class="indexterm"/> chapter, I had you copy the <code class="literal">Input</code> class from RoboRacer2D into the source folder for SpaceRacer3D. Now, we have to simply wire it into our game code.</p><p>Open SpaceRacer3D. First, we need to include the input header. Add the following line of code to the headers:</p><div class="informalexample"><pre class="programlisting">#include "Input.h"</pre></div><p>We also need to create a global pointer to manage the <code class="literal">Input</code> class. Add the following line just below the model pointers:</p><div class="informalexample"><pre class="programlisting">Input* m_input;</pre></div><p>Next, we need to create an instance of the <code class="literal">Input</code> class. Add the following line of code to the top of the <code class="literal">StartGame</code> function:</p><div class="informalexample"><pre class="programlisting">m_input = new Input(hWnd);</pre></div><p>Now, we have<a id="id612" class="indexterm"/> to create a function to handle our input. Add the following function just above the <code class="literal">Update</code> method:</p><div class="informalexample"><pre class="programlisting">void ProcessInput(const float p_deltaTime)
{
 Vec3 rotation;
 m_input-&gt;Update(p_deltaTime);
 Input::Command command = m_input-&gt;GetCommand();
 switch (command)
 {
 case Input::CM_STOP:
 {
  if (ship-&gt;GetVelocity() &gt; 0.0f)
  {
   ship-&gt;SetVelocity(0.0f);
  }
  else
  {
   ship-&gt;SetVelocity(1.0f);
  }
 }
 break;
 case Input::CM_DOWN:
 {
  rotation = ship-&gt;GetHeadingRotation();
  rotation.x += -1.0f;
  if (rotation.x &lt; 0.0f)
  {
   rotation.x = 359.0f;
  }
  if (rotation.x &lt; 359.0f &amp;&amp; rotation.x &gt; 180.0f)
  {
   if (rotation.x &lt; 315.0f)
   {
    rotation.x = 315.0f;
   }
  }
  ship-&gt;SetHeadingRotation(rotation);
 }
 break;
 case Input::CM_UP:
 {
  rotation = ship-&gt;GetHeadingRotation();
  rotation.x += 1.0f;
  if (rotation.x &gt; 359.0f)
  {
   rotation.x = 0.0f;
  }
  if (rotation.x &gt; 0.0f &amp;&amp; rotation.x &lt; 180.0f)
  {
   if (rotation.x &gt; 45.0f)
   {
    rotation.x = 45.0f;
   }
  }
  ship-&gt;SetHeadingRotation(rotation);
 }
 break;
 case Input::CM_LEFT:
 {
  rotation = ship-&gt;GetHeadingRotation();
  rotation.z += 1.0f;
  if (rotation.z &gt; 359.0f)
  {
   rotation.z = 0.0f;
  }
  if (rotation.z &gt; 0.0f &amp;&amp; rotation.z &lt; 180.0f)
  {
   if (rotation.z &gt; 45.0f)
   {
    rotation.z = 45.0f;
   }
  }
  ship-&gt;SetHeadingRotation(rotation);
 }
 break;
 case Input::CM_RIGHT:
 {
  rotation = ship-&gt;GetHeadingRotation();
  rotation.z += -1.0f;
  if (rotation.z &lt; 0.0f)
  {
   rotation.z = 359.0f;
  }
  if (rotation.z &lt; 359.0f &amp;&amp; rotation.z &gt; 180.0f)
  {
   if (rotation.z &lt; 315.0f)
   {
    rotation.z = 315.0f;
   }
  }
  ship-&gt;SetHeadingRotation(rotation);
 }
 break;
 }
}</pre></div><p>This code <a id="id613" class="indexterm"/>handles keyboard input. You will recall from RoboRacer2D that we mapped virtual commands to the following keys:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CM_STOP</code>: This is the spacebar. We use the spacebar as a toggle to both start and stop the ship. If the ship is stopped, pressing the spacebar sets the velocity. If the ship's velocity is greater than zero, then pressing the spacebar sets the velocity to zero.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CM_UP</code>: This is both the up arrow and the <span class="emphasis"><em>W </em></span>key. Pressing either of these keys changes the heading rotation so that the ship moves up.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CM_DOWN</code>: This is both the down arrow and the <span class="emphasis"><em>S</em></span> key. Pressing either of these keys changes the heading rotation so that the ship moves down.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CM_LEFT</code>: This is both the left arrow and the <span class="emphasis"><em>A</em></span> key. Pressing either of these keys changes the heading rotation so that the ship moves left.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CM_RIGHT</code>: This is both the right arrow and the <span class="emphasis"><em>D</em></span> key. Pressing either of these keys changes the heading rotation so that the ship moves up.</li></ul></div><p>Every directional command works by retrieving the current heading angle and changing the appropriate component of the heading vector by one degree. The heading angle is used by each object's <code class="literal">Update</code> method to calculate a heading vector, which is used to point the camera in the <code class="literal">Render</code> method.</p><p>Finally, we need to call <code class="literal">HandleInput</code> from the games <code class="literal">Update</code> function. Add the following line of code to the top of the <code class="literal">Update</code> method, before the object update calls. We want to handle input first and then call each object's update method:</p><div class="informalexample"><pre class="programlisting">ProcessInput(p_deltaTime);</pre></div><p>That's it! Pat <a id="id614" class="indexterm"/>yourself on the back and run the game. You can now use the keyboard to control the ship and navigate through your universe.</p></div></div>
<div class="section" title="Asteroid slalom"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec60"/>Asteroid slalom</h1></div></div></div><p>It's now time to implement the final feature of this chapter. We are going to implement a slalom race <a id="id615" class="indexterm"/>with a twist. In a typical slalom, the point is to race around each obstacle without touching it. To keep things simple, we are going to race through each asteroid. If you successfully pass through each asteroid, you win the race.</p><div class="section" title="Setting up collision detection"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec156"/>Setting up collision detection</h2></div></div></div><p>In order to determine whether you have passed through an asteroid, we have to implement <a id="id616" class="indexterm"/>some 3D collision detection. There are many types of collision detection, but we are going to keep it simple and implement spherical collision detection.</p><p>Spherical collision detection is a simple check to see whether the center of two 3D objects are within a certain distance of each other. As our asteroids are spheres, this will be a pretty accurate indication as to whether we have collided with one. The ship, however, is not a sphere, so this technique isn't perfect.</p><p>Let's start our collision detection coding by adding the appropriate methods to the <code class="literal">Model</code> class. Open <code class="literal">Model.h</code> and add the following methods:</p><div class="informalexample"><pre class="programlisting">const bool IsCollideable();
void IsCollideable(const bool collideable);
const bool CollidedWith(Model* target);
const Vec3 GetCenter() const;
void SetRadius(const float p_radius);
const float GetRadius() const;</pre></div><p>Here is how we will use each method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">IsCollideable</code> is used to either get or set the <code class="literal">m_collideable</code> flag. Objects are set to collide by default. All of the objects in our game are set to collide so that we can detect if the ship has hit an asteroid. However, it is very common to have some objects in a game that you don't collide with. If you set <code class="literal">IsCollideable(false)</code>, then collision detection will be ignored.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CollidedWith</code> is the method that performs the actual collision detection.</li><li class="listitem" style="list-style-type: disc"><code class="literal">GetCenter</code> is a helper function that calculates the center point of the object in world space.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SetRadius</code> and <code class="literal">GetRadius</code> are help functions to manage the collision radius for the object.</li></ul></div><p>We also need to add two variables to track the radius and collision<a id="id617" class="indexterm"/>:</p><div class="informalexample"><pre class="programlisting"> float m_radius;
 bool m_collideable;</pre></div><p>Now, open <code class="literal">Model.cpp</code> and add the following code to implement the collision methods.</p><p>First, we need to define the radius in the constructor. Add the following line of code to the constructor:</p><div class="informalexample"><pre class="programlisting"> SetRadius(1.0f);
 IsCollideable(true);</pre></div><p>Now add the following methods:</p><div class="informalexample"><pre class="programlisting">const bool Model::IsCollideable()
{
  return m_collideable;
}

void Model::IsCollideable(const bool p_collideable)
{
  m_collideable = p_collideable;
}

const bool Model::CollidedWith(Model* p_target)
{
  if (p_target-&gt;IsCollideable() &amp;&amp; this-&gt;IsCollideable())
  {
    const Vec3 p1 = this-&gt;GetCenter();
    const Vec3 p2 = p_sprite-&gt;GetCenter();
    
    float y = p2.y - p1.y;
    float x = p2.x - p1.x;
    float z = p2.z - p1.z;
    float d = x*x + y*y + z*z;
    
    float r1 = this-&gt;GetRadius() * this-&gt;GetRadius();
    float r2 = p_sprite-&gt;GetRadius() * p_sprite-&gt;GetRadius();
    
    if (d &lt;= r1 + r2)
    {
      return true;
    }
  }
  return false;
}

const Vec3 Model::GetCenter() const
{
 Vec3 center;
 center = GetPosition();
 if (m_IsShip)
 {
  center.z = -m_position.y;
  center.x = m_position.x;
  center.y = m_position.z;
 }
 return center;
}

void Model::SetRadius(const float p_radius)
{
  m_radius = p_radius;
}

const float Model::GetRadius() const
{
  return m_radius;
}</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">IsCollideable</code> and the override are used to either get whether the object can be<a id="id618" class="indexterm"/> collided with or get the state of the collision flag.</li><li class="listitem" style="list-style-type: disc"><code class="literal">GetCenter</code> returns the current position of the object. As we modeled all of our objects with the object origin at the center, returning the position also returns the center of the object. A more sophisticated algorithm would use the bounding size of the object to calculate the center.</li><li class="listitem" style="list-style-type: disc"><code class="literal">GetRadius</code> and <code class="literal">SetRadius</code> manage the radius, which is required for the collision check code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CollidedWith</code> is the method that performs all the work. After checking that both the current object and the target objects can collide, then the method performs the following actions:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Gets<a id="id619" class="indexterm"/> the center point of the two objects</li><li class="listitem" style="list-style-type: disc">Calculates the distance in 3D between the two centers</li><li class="listitem" style="list-style-type: disc">Checks to see whether the distance is less than the sum of the two radii. If so, the objects have collided:</li></ul></div><div class="mediaobject"><img src="graphics/8199OS_10_03.jpg" alt="Setting up collision detection"/></div></li></ul></div><p>If you are astute, you will notice that this collision detection is very similar to the collision detection used in RoboRacer2D. We simply added the z dimension to the equations.</p></div><div class="section" title="Turning on collision"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec157"/>Turning on collision</h2></div></div></div><p>Now, we will <a id="id620" class="indexterm"/>implement the collision code in our game. Open <code class="literal">SpaceRacer3D.cpp</code> and add the following function just before the <code class="literal">Update</code> function:</p><div class="informalexample"><pre class="programlisting">void CheckCollisions()
{
 bool collision = false;
 for (int i = 0; i &lt; asteroids.size(); i++)
 {
  Model* item = asteroids[i];
  collision = ship-&gt;CollidedWith(item);
  if (collision)
  {
   item-&gt;IsCollideable(false);
   item-&gt;IsVisible(false);
   score++;
   asteroidsHit++;
  }
 }
}</pre></div><p>This method<a id="id621" class="indexterm"/> performs the following actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It defines a collision flag.</li><li class="listitem" style="list-style-type: disc">It iterates through all of the asteroids.</li><li class="listitem" style="list-style-type: disc">It checks to see whether the asteroid has collided with the ship.</li><li class="listitem" style="list-style-type: disc">If the asteroid has collided with the ship, we set <code class="literal">IsCollideable</code> for the asteroid to <code class="literal">false</code>. This stops the collision from occurring multiple times as the ship passes through the asteroid. For our game, we only need to collide with each asteroid once, so this is sufficient.</li></ul></div><p>We need to wire the collision into the <code class="literal">Update</code> function. Add the following line to the Update method just after the <code class="literal">HandleInput</code> call:</p><div class="informalexample"><pre class="programlisting">HandleCollisions();</pre></div><p>That's it. We have now implemented basic collision detection!</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec61"/>Summary</h1></div></div></div><p>We covered a lot of code in this chapter. You implemented a simple, yet effective framework to create and manage 3D objects in the game. This class included necessary features to load the model, position the model in 3D space, and check for collisions.</p><p>We also implemented input and collision detection in the game to create a modified slalom race, requiring you to navigate through each asteroid.</p><p>In the next chapter, we will implement a user interface and scoring system to make this a more complete game.</p></div></body></html>