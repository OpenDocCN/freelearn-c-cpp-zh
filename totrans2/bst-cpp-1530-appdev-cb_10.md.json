["```cpp\n    #include <boost/config.hpp>\n    ```", "```cpp\n    #ifdef BOOST_HAS_INT128\n    ```", "```cpp\n    typedef boost::int128_type int_t;\n    typedef boost::uint128_type uint_t;\n\n    inline int_t mul(int_t v1, int_t v2, int_t v3) {\n        return v1 * v2 * v3;\n    }\n    ```", "```cpp\n    #else // BOOST_NO_LONG_LONG\n\n    #ifdef BOOST_NO_LONG_LONG\n    #error \"This code requires at least int64_t support\"\n    #endif\n    ```", "```cpp\n    struct int_t { boost::long_long_type hi, lo; };\n    struct uint_t { boost::ulong_long_type hi, lo; };\n\n    inline int_t mul(int_t v1, int_t v2, int_t v3) {\n        // Some hand written math\n        // ...\n    }\n\n    #endif // BOOST_NO_LONG_LONG\n    ```", "```cpp\nboost::long_long_type \nboost::ulong_long_type \n```", "```cpp\nboost::int128_type\nboost::uint128_type\n```", "```cpp\n    #include <boost/config.hpp>\n    ```", "```cpp\n    #if !defined(BOOST_NO_RTTI) \\\n        && !defined(BOOST_NO_CXX11_HDR_TYPEINDEX)\n\n    #include <typeindex>\n    using std::type_index;\n\n    template <class T>\n    type_index type_id() {\n        return typeid(T);\n    }\n    ```", "```cpp\n    #else\n\n    #include <cstring>\n\n    struct type_index {\n        const char* name_;\n\n        explicit type_index(const char* name)\n            : name_(name)\n        {}\n    };\n\n    inline bool operator == (const type_index& v1, \n        const type_index& v2) \n    {\n        return !std::strcmp(v1.name_, v2.name_);\n    }\n\n    inline bool operator != (const type_index& v1, \n        const type_index& v2) \n    {\n        // '!!' to supress warnings\n        return !!std::strcmp(v1.name_, v2.name_);\n    }\n    ```", "```cpp\n    #include <boost/current_function.hpp>\n\n    template <class T>\n    inline type_index type_id() {\n        return type_index(BOOST_CURRENT_FUNCTION);\n    }\n    #endif\n    ```", "```cpp\n        assert(type_id<unsigned int>() == type_id<unsigned>());\n        assert(type_id<double>() != type_id<long double>());\n    ```", "```cpp\ntype_index type_id() [with T = double]\n\n```", "```cpp\n    #include <boost/config.hpp>\n    ```", "```cpp\n    #include <boost/variant.hpp>\n    #include <boost/blank.hpp>\n    #include <string>\n    ```", "```cpp\n    #ifndef BOOST_NO_CXX11_EXTERN_TEMPLATE\n\n    extern template class boost::variant<\n        boost::blank,\n        int,\n        std::string,\n        double\n    >;\n\n    #endif\n    ```", "```cpp\n    // Header with 'extern template'\n    #include \"header.hpp\"\n\n    #ifndef BOOST_NO_CXX11_EXTERN_TEMPLATE\n    template class boost::variant<\n        boost::blank,\n        int,\n        std::string,\n        double\n    >;\n    #endif\n    ```", "```cpp\n    #include <boost/config.hpp>\n    ```", "```cpp\n    #if !defined(BOOST_NO_CXX11_CONSTEXPR) \\\n        && !defined(BOOST_NO_CXX11_HDR_ARRAY)\n\n    template <class T>\n    constexpr int get_size(const T& val) {\n        return val.size() * sizeof(typename T::value_type);\n    }\n    ```", "```cpp\n    #else\n    #error \"This code requires C++11 constexpr and std::array\"\n    #endif\n    ```", "```cpp\n    std::array<short, 5> arr;\n    assert(get_size(arr) == 5 * sizeof(short));\n\n    unsigned char data[get_size(arr)];\n    ```", "```cpp\ntemplate <class T, T Value>\nstruct integral_constant {\n    BOOST_STATIC_CONSTEXPR T value = Value;\n\n    BOOST_CONSTEXPR operator T() const {\n        return this->value;\n    }\n};\n```", "```cpp\nchar array[integral_constant<int, 10>()];\n```", "```cpp\n    #include <boost/config.hpp>\n    class move_nothrow {\n        // Some class class members go here\n        // ...\n    public:\n        move_nothrow() BOOST_NOEXCEPT {}\n        move_nothrow(move_nothrow&&) BOOST_NOEXCEPT\n            // : members initialization\n            // ...\n        {}\n\n        move_nothrow& operator=(move_nothrow&&) BOOST_NOEXCEPT {\n            // Implementation\n            // ...\n            return *this;\n        }\n\n        move_nothrow(const move_nothrow&);\n        move_nothrow& operator=(const move_nothrow&);\n    };\n    ```", "```cpp\n        std::vector<move_nothrow> v(10);\n        v.push_back(move_nothrow());\n    ```", "```cpp\n    /usr/include/c++/4.7/bits/stl_construct.h:77: undefined reference to `move_nothrow::move_nothrow(move_nothrow const&)'\n    ```", "```cpp\n// In header file\nint foo() BOOST_NOEXCEPT;\n\n// In source file\nint foo() BOOST_NOEXCEPT {\n    return 0;\n}\n```", "```cpp\n    #include <boost/config.hpp>\n    ```", "```cpp\n    #if defined(MY_LIBRARY_LINK_DYNAMIC)\n    # if defined(MY_LIBRARY_COMPILATION)\n    #   define MY_LIBRARY_API BOOST_SYMBOL_EXPORT\n    # else\n    #   define MY_LIBRARY_API BOOST_SYMBOL_IMPORT\n    # endif\n    #else\n    # define MY_LIBRARY_API\n    #endif\n    ```", "```cpp\n    int MY_LIBRARY_API foo();\n    class MY_LIBRARY_API bar { \n    public:\n        /* ... */ \n        int meow() const;\n    };\n    ```", "```cpp\n    #include <stdexcept>\n    struct BOOST_SYMBOL_VISIBLE bar_exception\n        : public std::exception \n    {};\n    ```", "```cpp\n    #define MY_LIBRARY_COMPILATION\n    #include \"my_library.hpp\"\n    ```", "```cpp\n    int MY_LIBRARY_API foo() {\n        // Implementation\n        // ...\n        return 0;\n    }\n    int bar::meow() const {\n        throw bar_exception();\n    }\n    ```", "```cpp\n    #include \"../my_library/my_library.hpp\"\n    #include <cassert>\n\n    int main() {\n        assert(foo() == 0);\n        bar b;\n        try {\n            b.meow();\n            assert(false);\n        } catch (const bar_exception&) {}\n    }\n    ```", "```cpp\n# if defined(MY_LIBRARY_COMPILATION)\n#   define MY_LIBRARY_API BOOST_SYMBOL_EXPORT\n# else\n#   define MY_LIBRARY_API BOOST_SYMBOL_IMPORT\n# endif\n```", "```cpp\n    #include <boost/version.hpp>\n    #include <boost/lexical_cast.hpp>\n    ```", "```cpp\n    #if (BOOST_VERSION >= 105200)\n    int to_int(const char* str, std::size_t length) {\n        return boost::lexical_cast<int>(str, length);\n    }\n    ```", "```cpp\n    #else\n    int to_int(const char* str, std::size_t length) {\n        return boost::lexical_cast<int>(\n            std::string(str, length)\n        );\n    }\n    #endif\n    ```", "```cpp\n    assert(to_int(\"10000000\", 3) == 100);\n    ```"]