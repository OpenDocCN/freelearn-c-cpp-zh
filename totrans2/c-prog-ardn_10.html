<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Some Advanced Techniques"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Some Advanced Techniques</h1></div></div></div><p>In this chapter, we are going to learn different techniques that can be used either together or independently. Each technique developed here is a new tool for your future or current projects. We are going to use EEPROMs to provide Arduino boards with a small memory system that is readable and writable. </p><p>We are also going to test communications between the Arduino boards themselves, use GPS modules, make our boards autonomous, and more.</p><div class="section" title="Data storage with EEPROMs"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Data storage with EEPROMs</h1></div></div></div><p>Until now, <a id="id1160" class="indexterm"/>we <a id="id1161" class="indexterm"/>learned and used the Arduino boards as totally electricity dependent devices. Indeed, they need current in order to execute tasks compiled in our firmware.</p><p>As we noticed, when we switch them off, every living variable and data is lost. Fortunately, the firmware isn't.</p><div class="section" title="Three native pools of memory on the Arduino boards"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec153"/>Three native pools of memory on the Arduino boards</h2></div></div></div><p>The Arduino boards<a id="id1162" class="indexterm"/> based on the ATmega168 chipset own three different pools of memory:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Flash memory</li><li class="listitem" style="list-style-type: disc">SRAM</li><li class="listitem" style="list-style-type: disc">EEPROM</li></ul></div><p>The <a id="id1163" class="indexterm"/>flash memory<a id="id1164" class="indexterm"/> is also named program space. This is the place where our firmware is stored.</p><p>The <span class="strong"><strong>SRAM</strong></span> <a id="id1165" class="indexterm"/>stands for <span class="strong"><strong>Static</strong></span> <span class="strong"><strong>Random</strong></span> <span class="strong"><strong>Access</strong></span> <span class="strong"><strong>Memory</strong></span>
<a id="id1166" class="indexterm"/> and is the place where the running firmware stores, reads, and manipulates variables.</p><p>The <span class="strong"><strong>EEPROM</strong></span> <a id="id1167" class="indexterm"/>stands for <span class="strong"><strong>Electrically</strong></span> <span class="strong"><strong>Erasable</strong></span> <span class="strong"><strong>Programmable</strong></span> <span class="strong"><strong>Read-Only</strong></span> <span class="strong"><strong>Memory</strong></span>. It is the place where we, programmers, can store things for long-term purposes. This<a id="id1168" class="indexterm"/> is the place where our firmware sits, and anything in the EEPROM isn't erased should the board be switched off.</p><p>ATmega168 <a id="id1169" class="indexterm"/>has:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">16000 bytes of Flash (2000 bytes are used for the bootloader)</li><li class="listitem" style="list-style-type: disc">1024 bytes of SRAM</li><li class="listitem" style="list-style-type: disc">512 bytes of EEPROM</li></ul></div><p>Here we won't discuss the fact that we have to take care of the memory while programming; we will do that in the last chapter of this book <a class="link" href="ch13.html" title="Chapter 13. Improving your C Programming and Creating Libraries">Chapter 13</a>, <span class="emphasis"><em>Improving your C Programming and Creating Libraries</em></span>.</p><p>The interesting part here is the EEPROM space. It allows us to store data on the Arduino and we didn't even know that until now. Let's test the EEPROM native library.</p><div class="section" title="Writing and reading with EEPROM core library"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec126"/>Writing and reading with EEPROM core library</h3></div></div></div><p>Basically, this<a id="id1170" class="indexterm"/> example <a id="id1171" class="indexterm"/>doesn't require any wiring. We are going to use the internal EEPROM of 512 bytes. Here is some code that reads all the bytes of the EEPROM and prints it to the computer's Serial Monitor:</p><div class="informalexample"><pre class="programlisting">#include &lt;EEPROM.h&gt;

// start reading from the first byte (address 0) of the EEPROM
int address = 0;
byte value;

void setup()
{
  // initialize serial and wait for port to open:
  Serial.begin(9600);
}

void loop()
{
  // read a byte from the current address of the EEPROM
  value = EEPROM.read(address);
  
  Serial.print(address);
  Serial.print("\t");
  Serial.print(value, DEC);
  Serial.println();
  
  // advance to the next address of the EEPROM
  address = address + 1;
  
  // there are only 512 bytes of EEPROM, from 0 to 511, so if we're
  // on address 512, wrap around to address 0
  if (address == 512)
    address = 0;
    
  delay(500);
}</pre></div><p>This<a id="id1172" class="indexterm"/> code<a id="id1173" class="indexterm"/> is in the public domain and provided as an example for the EEPROM library. You can find it in your <code class="literal">examples</code> folder in the <span class="strong"><strong>File</strong></span> menu of the Arduino IDE, under the folder <span class="strong"><strong>Examples</strong></span> | <span class="strong"><strong>EEPROM</strong></span>.</p><p>At first, we include the library itself. Then we define a variable for storing the current read address. We initialize it at 0, the beginning of the memory register. We also define a variable as a byte type.</p><p>In the <code class="literal">setup()</code> function, we initialize the serial communication. In <code class="literal">loop()</code>, we read the byte at the current address and store it in the variable <code class="literal">value</code>. Then we print the result to the serial port. Notice the <code class="literal">\t</code> value in the second <code class="literal">Serial.print()</code> statement. This stands for tabulation (as in the <span class="emphasis"><em>Tab</em></span> key on a computer keyboard). This writes tabulation to the serial port between the current address printed and the value itself in order to make things more readable.</p><p>We advance to the next address. We check if the address equals 512, if that is the case, we restart the address counter to 0 and so on.</p><p>We add a small delay. We can write bytes in the same way using <code class="literal">EEPROM.write(addr, val);</code> where <code class="literal">addr</code> is the address where you want to write the value <code class="literal">val</code>.</p><p>Be careful, these are bytes (8 bits = 256 possible values). Read and write operations are quite easy on the internal EEPROM, so let's see how it goes with external EEPROMs wired by an I2C connection.</p></div></div><div class="section" title="External EEPROM wiring"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec154"/>External EEPROM wiring</h2></div></div></div><p>There are a lot of cheap <a id="id1174" class="indexterm"/>EEPROM components available in electronics markets. We are going to use the classic 24LC256, an EEPROM implementing I2C for read/write operations and providing 256 kilobits (32 kilobytes) of memory space.</p><p>You can find it at <a id="id1175" class="indexterm"/>Sparkfun: <a class="ulink" href="https://www.sparkfun.com/products/525">https://www.sparkfun.com/products/525</a>. Here is how we can wire its bigger cousin <a id="id1176" class="indexterm"/>24LC1025 (1024k bytes) using I2C:</p><div class="mediaobject"><img src="graphics/7584_10_001.jpg" alt="External EEPROM wiring"/><div class="caption"><p>A 24LC256 EEPROM wired to the Arduino via I2C communication</p></div></div><p>The corresponding diagram is the one shown as follows:</p><div class="mediaobject"><img src="graphics/7584_10_002.jpg" alt="External EEPROM wiring"/><div class="caption"><p>A 24LC256 EEPROM wired to the Arduino via I2C communication</p></div></div><p>Let's <a id="id1177" class="indexterm"/>describe the EEPROM.</p><p>
<span class="strong"><strong>A0</strong></span>, <span class="strong"><strong>A1</strong></span>, and <span class="strong"><strong>A2</strong></span> are chip address inputs. <span class="strong"><strong>+V</strong></span> and <span class="strong"><strong>0V</strong></span> are <span class="strong"><strong>5V</strong></span> and ground. WP is the write protect pin. If it is wired to ground, we can write to the EEPROM. If it is wired to 5V, we cannot.</p><p>SCL and SDA are the two wires involved in the I2C communication and are wired to <span class="strong"><strong>SDA</strong></span> / <span class="strong"><strong>SCL</strong></span>. <span class="strong"><strong>SDA</strong></span>
<a id="id1178" class="indexterm"/> stands for <span class="strong"><strong>Serial</strong></span> <span class="strong"><strong>Data</strong></span> <span class="strong"><strong>Line</strong></span> and <a id="id1179" class="indexterm"/>
<span class="strong"><strong>SCL</strong></span> stands for <span class="strong"><strong>Serial</strong></span> <span class="strong"><strong>Clock</strong></span> <span class="strong"><strong>Line</strong></span>. Be careful about the SDA/SCL pins. The following depends on your board:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Arduino UNO before R3 and Ethernet's I2C pins are A4 (SDA) and A5 (SCL)</li><li class="listitem" style="list-style-type: disc">Mega2560, <a id="id1180" class="indexterm"/>pins 20 (SDA) and 21 (SCL)</li><li class="listitem" style="list-style-type: disc">Leonardo, pin 2 (SDA) and pin 3 (SCL)</li><li class="listitem" style="list-style-type: disc">Due Pins, pins 20 (SDA) and 21 (SCL) and also another one SDA1 and SCL1</li></ul></div></div><div class="section" title="Reading and writing to the EEPROM"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec155"/>Reading and writing to the EEPROM</h2></div></div></div><p>The <a id="id1181" class="indexterm"/>underlying <a id="id1182" class="indexterm"/>library that we can use for I2C purposes is <code class="literal">Wire</code>. You can find it directly in the Arduino core. This library takes care of the raw bits, but we have to look at it more closely.</p><p>The <code class="literal">Wire</code> library takes care of many things for us. Let's check the code in the folder <code class="literal">Chapter10/readWriteI2C</code>:</p><div class="informalexample"><pre class="programlisting">#include &lt;Wire.h&gt;

void eepromWrite(byte address, byte source_addr, byte data) {
  Wire.beginTransmission(address);
  Wire.write(source_addr);
  Wire.write(data);
  Wire.endTransmission();
}

byte eepromRead(int address, int source_addr) {
  Wire.beginTransmission(address);
  Wire.write(source_addr);
  Wire.endTransmission();

  Wire.requestFrom(address, 1);
  if(Wire.available())
    return Wire.read();
  else
    return 0xFF;
}

void setup() {
  Wire.begin();
  Serial.begin(9600);

  for(int i = 0; i &lt; 10; i++) {
    eepromWrite(B01010000, i, 'a'+i);
    delay(100);
  }

  Serial.println("Bytes written to external EEPROM !");
}

void loop() {
  for(int i = 0; i &lt; 10; i++) {
    byte val = eepromRead(B01010000, i);
    Serial.print(i);
    Serial.print("\t");
    Serial.print(val);
    Serial.print("\n");
    delay(1000);
  }
}</pre></div><p>We<a id="id1183" class="indexterm"/> include the <code class="literal">Wire</code> library<a id="id1184" class="indexterm"/> at first. Then we define 2 functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">eepromWrite()</code><a id="id1185" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">eepromRead()</code><a id="id1186" class="indexterm"/></li></ul></div><p>These functions write and read bytes to and from the external EEPROM using the <code class="literal">Wire</code> library.</p><p>The <code class="literal">Setup()</code> function instantiates the <code class="literal">Wire</code> and the <code class="literal">Serial</code> communication. Then using a <code class="literal">for</code> loop, we write data to a specific address. This data is basically a character 'a' plus a number. This structure writes characters from a to a + 9 which means 'j'. This is an example to show how we can store things quickly, but of course we could have written more meaningful data.</p><p>We then print a message to the Serial Monitor in order to tell the user that Arduino has finished writing to the EEPROM.</p><p>In the <code class="literal">loop()</code> function, we then read the EEPROM. It is quite similar to the EEPROM library.</p><p>Obviously, we still haven't spoken about addresses. Here is an I2C message format:</p><div class="mediaobject"><img src="graphics/7584_10_003.jpg" alt="Reading and writing to the EEPROM"/><div class="caption"><p>An I2C message</p></div></div><p>
<code class="literal">Wire</code> library <a id="id1187" class="indexterm"/>takes<a id="id1188" class="indexterm"/> care of <span class="strong"><strong>Start</strong></span> <span class="strong"><strong>Bit</strong></span> and <span class="strong"><strong>Acknowledge</strong></span> <span class="strong"><strong>Bit</strong></span>. The control code is fixed and you can change the <span class="strong"><strong>Chip</strong></span> <span class="strong"><strong>Select</strong></span> <span class="strong"><strong>Bits</strong></span> by wiring <span class="strong"><strong>A0</strong></span>, <span class="strong"><strong>A1</strong></span>, and <span class="strong"><strong>A2</strong></span> pins to ground or +V. That means there are 8 possibilities of addresses from 0 to 7.</p><p>1010000 1010001… until 1010111. 1010000 binary means 0x50 in hexadecimal, and 1010111 means 0x57.</p><p>In our case, we wired <span class="strong"><strong>A0</strong></span>, <span class="strong"><strong>A1</strong></span>, and <span class="strong"><strong>A2</strong></span> to ground, then the EEPROM address on the I2C bus is 0x50. We could use more than one on the I2C bus, but only if we need more storage capacity. Indeed, we would have to address the different devices inside our firmware.</p><p>We could now imagine storing many things on that EEPROM space, from samples for playing PCM audio to, eventually, huge lookup tables or whatever requiring more memory than available on Arduino itself.</p></div></div></div>
<div class="section" title="Using GPS modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Using GPS modules</h1></div></div></div><p>
<span class="strong"><strong>GPS</strong></span> <a id="id1189" class="indexterm"/>stands for <span class="strong"><strong>Global</strong></span> <span class="strong"><strong>Positioning</strong></span> <span class="strong"><strong>System</strong></span>. This system is based on satellite constellations.</p><p>Basically, a receiver that receives signals from at least 4 satellites embedded with a special atomic clock can, by calculating propagation time of these signals between them and itself, calculate precisely its tri-dimensional position. That sounds magical; it is just trigonometric.</p><p>We won't get <a id="id1190" class="indexterm"/>into the details of this process; instead focus on the parsing of data coming from the GPS modules. You can get more information from Wikipedia: <a class="ulink" href="http://en.wikipedia.org/wiki/Global_Positioning_System">http://en.wikipedia.org/wiki/Global_Positioning_System</a>.</p><div class="section" title="Wiring the Parallax GPS receiver module"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec156"/>Wiring the Parallax GPS receiver module</h2></div></div></div><p>The Parallax GPS <a id="id1191" class="indexterm"/>Receiver is based on the PMB-248 specification and provides a very easy way to add position detection to the Arduino with its small footprint and low cost.</p><div class="mediaobject"><img src="graphics/7584_10_004.jpg" alt="Wiring the Parallax GPS receiver module"/><div class="caption"><p>The Parallax GPS Receiver: small footprint and accurate</p></div></div><p>It provides standard raw NMEA01823 strings or even specific user-requested data via the serial command interface. It can track 12 satellites and even WAAS (system only available in USA and Hawaii for helping the GPS Signal calculation).</p><p>NMEA0183 <a id="id1192" class="indexterm"/>is a <a id="id1193" class="indexterm"/>combined hardware and logic specification for communication between marine electronic devices such as sonars, anemometers, and many others including GPS. A great description of this protocol can be found here: <a class="ulink" href="http://aprs.gids.nl/nmea/">http://aprs.gids.nl/nmea/</a>. </p><p>The module provides current time, date, latitude, longitude, altitude speed, and travel direction/heading, among other data.</p><p>We can write data to the GPS modules in order to request specific strings. However, if we pull the <span class="strong"><strong>/RAW</strong></span> pin low, some strings are automatically transmitted by the modules. These strings are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">$GPGGA: Global Positioning System Fix Data</li><li class="listitem" style="list-style-type: disc">$GPGSV: GPS satellites in view</li><li class="listitem" style="list-style-type: disc">$GPGSA: GPS DOP and active satellites</li><li class="listitem" style="list-style-type: disc">$GPRMC: Recommended minimum specific GPS/Transit data</li></ul></div><p>This data has to be grabbed by the Arduino and eventually used. Let's check the wiring first:</p><div class="mediaobject"><img src="graphics/7584_10_005.jpg" alt="Wiring the Parallax GPS receiver module"/><div class="caption"><p>The Parallax GPS Receiver wired to the Arduino in automatic mode by pulling low the /RAW pin</p></div></div><p>The wiring is quite easy.</p><p>Yes, the <a id="id1194" class="indexterm"/>Parallax GPS Receiver only consumes one data pin: digital pin 0. Let's stop here for two seconds. Didn't we talk about the fact that we cannot use the USB port for serial monitoring and pins 0 and 1 for other serial feature at the same time on Arduino?</p><p>With serial communication using Rx/Tx 2 wires, serial software implementation can be full duplex.</p><p>In our case, the GPS device sends data to the Arduino Rx pin. This pin (digital pin 0) is wired to the USB Rx pin. At the same time, the Arduino sends data to the computer using the USB Tx pin that is wired to digital pin 1.</p><p>Is there a problem in our case here? No. We just have to take care of interferences. We must not send data from the computer via USB to the Arduino because it already receives data on its serial pin 0 from the GPS device. This is the only thing we have to be careful of.</p><p>The <code class="literal">Serial.write()</code> function <a id="id1195" class="indexterm"/>will write to digital pin 1, and the USB Tx digital pin 1 isn't wired to anything. Therefore, no problem, data will be sent to the USB. The <code class="literal">Serial.read()</code> function<a id="id1196" class="indexterm"/> reads from digital pin 0 and USB and we don't send anything from the computer to USB, so it can read digital pin 0 without any problem.</p><p>We pull the /RAW pin to low. In this mode, the device pops data out to the Arduino automatically; I mean, without having to request it.</p></div><div class="section" title="Parsing GPS location data"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec157"/>Parsing GPS location data</h2></div></div></div><p>Before building any<a id="id1197" class="indexterm"/> firmware that will be able to use GPS data, we have to know a bit more about what the device is able to transmit.</p><p>We can read the datasheet of the GPS device at: <a class="ulink" href="http://www.rcc.ryerson.ca/media/2008HCLParallaxGPSReceiverModuledatasheet.pdf">http://www.rcc.ryerson.ca/media/2008HCLParallaxGPSReceiverModuledatasheet.pdf</a>.</p><p>Here is an example of data that can be transmitted:</p><p>
<code class="literal">$GPRMC,220516,A,5133.82,N,00042.24,W,173.8,231.8,130694,004.2,W*70</code>
</p><p>
<code class="literal">$GPRMC</code> defines the type of information sequence sent. The comma is a separator that separates each data field.</p><p>Here is the meaning of each field:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">UTC time of fix</li><li class="listitem">Data status (<code class="literal">A</code> means valid position and <code class="literal">V</code> means warning)</li><li class="listitem">Latitude of the fix</li><li class="listitem">North or South latitude</li><li class="listitem">Longitude of the fix</li><li class="listitem">East or West longitude</li><li class="listitem">Speed over ground (in knots)</li><li class="listitem">Track made good in degrees</li><li class="listitem">UTC date of fix</li><li class="listitem">Magnetic variation in degrees</li><li class="listitem">East or West magnetic variation</li><li class="listitem">Checksum</li></ol></div><p>As soon as we <a id="id1198" class="indexterm"/>know what data is sent, we can code a parser in our firmware. Here is a possible firmware. You can find it in folder <code class="literal">Chapter10/locateMe</code>:</p><div class="informalexample"><pre class="programlisting">int rxPin = 0;                    // RX PIN
int byteGPS = -1;                 // Current read byte
char line[300] = "";              // Buffer
char commandGPR[7] = "$GPRMC";    // String related to messages

int counter=0;
int correctness=0;
int lineCounter=0;
int index[13];

void setup() {

  pinMode(rxPin, INPUT);
  Serial.begin(4800);

  // Clear buffer
  for (int i=0;i&lt;300;i++){       
    line[i]=' ';
  }   
}


void loop() {

  byteGPS = Serial.read();         // Read a byte from the serial port

  // Test if the port is empty
  if (byteGPS == -1) {           
    delay(100);
  }

  else {  // if it isn't empty

    line[lineCounter] = byteGPS;   // put data read in the buffer
    lineCounter++;

    Serial.print(byteGPS);   // print data read to the serial monitor

    // Test if the transmission is finished
    // if it is finished, we begin to parse !
    if (byteGPS==13){                    

      counter=0;
      correctness=0;

      // Test if the received command starts by $GPR
      // If it does, increase correctness counter
      for (int i=1;i&lt;7;i++){
        if (line[i]==commandGPR[i-1]){
          correctness++;
        }
      }


      if(correctness==6){
        // We are sure command is okay here.

        //
        for (int i=0;i&lt;300;i++){

          // store position of "," separators
          if (line[i]==','){    
            index[counter]=i;
            counter++;
          }

          // store position of "*" separator meaning the last byte
          if (line[i]=='*'){    // ... and the "*"
            index[12]=i;
            counter++;
          }
        }

        // Write data to serial monitor on the computer
        Serial.println("");
        Serial.println("");
        Serial.println("---------------");
        for (int i=0;i&lt;12;i++){
          switch(i){
          case 0 :
            Serial.print("Time in UTC (HhMmSs): ");
            break;
          case 1 :
            Serial.print("Status (A=OK,V=KO): ");
            break;
          case 2 :
            Serial.print("Latitude: ");
            break;
          case 3 :
            Serial.print("Direction (N/S): ");
            break;
          case 4 :
            Serial.print("Longitude: ");
            break;
          case 5 :
            Serial.print("Direction (E/W): ");
            break;
          case 6 :
            Serial.print("Velocity in knots: ");
            break;
          case 7 :
            Serial.print("Heading in degrees: ");
            break;
          case 8 :
            Serial.print("Date UTC (DdMmAa): ");
            break;
          case 9 :
            Serial.print("Magnetic degrees: ");
            break;
          case 10 :
            Serial.print("(E/W): ");
            break;
          case 11 :
            Serial.print("Mode: ");
            break;
          case 12 :
            Serial.print("Checksum: ");
            break;
          }
          for (int j=index[i];j&lt;(index[i+1]-1);j++){
            Serial.print(line[j+1]);
          }
          Serial.println("");
        }
        Serial.println("---------------");
      }

      // Reset the buffer
      lineCounter=0;                    
      for (int i=0;i&lt;300;i++){
        line[i]=' ';             
      }                 
    }   }
}</pre></div><p>Let's explain<a id="id1199" class="indexterm"/> the code a bit. At first, I'm defining several variables:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">rxPin</code> is the digital input where the GPS device is wired</li><li class="listitem" style="list-style-type: disc"><code class="literal">byteGPS</code> is the latest byte read from the GPS using serial communication</li><li class="listitem" style="list-style-type: disc"><code class="literal">line</code> is a buffer array</li><li class="listitem" style="list-style-type: disc"><code class="literal">commandGPR</code> is a string related to messages we want to parse</li><li class="listitem" style="list-style-type: disc"><code class="literal">counter</code> is the index of the index array</li><li class="listitem" style="list-style-type: disc"><code class="literal">correctness</code> stores the validity of the message</li><li class="listitem" style="list-style-type: disc"><code class="literal">lineCounter</code> is a counter keeping track of the buffer position of the data</li><li class="listitem" style="list-style-type: disc"><code class="literal">index</code> stores the position of each of the separators in the GPS data string (",")</li></ul></div><p>In the <code class="literal">setup()</code> function, we first define digital pin 0 as an input, and then start the serial communication with a rate of 4800 baud as required by serial interface of the Parallax GPS Receiver (remember to always check your date sheets). Then, we are clearing our <code class="literal">line</code> array buffer by filling it with a space character.</p><p>In the <code class="literal">loop()</code> function, we begin by reading byte from serial input, the digital pin being 0. If the port isn't empty, we enter it in the second part of the <code class="literal">if</code> conditional test defined by the <code class="literal">else</code> block. If it is empty, we just wait for 100 ms then try to read it again.</p><p>At first, the parsing begins by putting the data read in the line buffer at this particular index of the array: <code class="literal">lineCounter</code>. Then, we increment the latter in order to store the data received.</p><p>We then print the data read as a raw line to the USB port. It is at this moment that the Serial Monitor can receive and display it as the raw data row we quoted before as an example.</p><p>Then, we <a id="id1200" class="indexterm"/>test the data itself, comparing it to 13. If it equals 13, it means data communication is finished and we can begin to parse.</p><p>We reset the <code class="literal">counter</code> and <code class="literal">correctness</code> variables and check if the first 6 characters in the buffer equals <code class="literal">$GPRMC</code>. For each match, we increment the <code class="literal">correctness</code> variable.</p><p>This is a classic pattern. Indeed, if all the tests are true, it means <code class="literal">correctness</code> equals <code class="literal">6</code> at the end. Then we just have to check if <code class="literal">correctness</code> equals <code class="literal">6</code> to see if all the tests have been true, and if the first 6 characters equals <code class="literal">$GPRMC</code>.</p><p>If this is the case, we can be sure we have a correct NMEA raw sequence of the type <code class="literal">$GPRMC</code>, and we can start to actually parse the payload part of the data.</p><p>At first, we split our raw string by storing the position in the string of each comma separator. We then do the same with the last part separator, the "*" character. At this point, we are able to distinguish which character belongs to which part of the string, I mean, which part of the raw message.</p><p>It is a loop between each value of the raw message, and we test each value using a switch/case structure in order to display the correct sentence introducing each value of the GPS Data message.</p><p>The most tricky part, finally, is the last <code class="literal">for()</code> loop. We don't start as usual. Indeed, we start the <code class="literal">j</code> index in the loop using the array <code class="literal">index</code> at the specific position <code class="literal">i</code>.</p><p>Here is a small schematic showing indexes around the raw message:</p><div class="mediaobject"><img src="graphics/7584_10_006.jpg" alt="Parsing GPS location data"/><div class="caption"><p>Progressively parsing each part of the message according to each separator</p></div></div><p>We increment progressively according to each separator's position, and we display each value. This is one way of parsing and using location data using a GPS module. This data can be used in many ways, depending on your purpose. I like data visualization, and I made small projects for students with a GPS module grabbing location every 30s while walking in the street and writing it on an EEPROM. Then, I used this data to make some graphs. One I liked a <a id="id1201" class="indexterm"/>lot is the following:</p><div class="mediaobject"><img src="graphics/7584_10_007.jpg" alt="Parsing GPS location data"/><div class="caption"><p>Data visualization designed with Processing from a data set provided by a GPS Arduino module</p></div></div><p>Each line is a timestamp. The size of the line represents the time we spent between two measures of my Arduino-based GPS module. The longer the line is, the more time I spent at this step of the travel.</p><p>Your question <a id="id1202" class="indexterm"/>could be: How did you supply power to your Arduino + GPS module walking in the street?</p><p>Now, let's check how we can make the Arduino autonomous using batteries.</p></div></div>
<div class="section" title="Arduino, battery, and autonomy"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Arduino, battery, and autonomy</h1></div></div></div><p>The Arduino boards <a id="id1203" class="indexterm"/>can supply power in two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A USB wire from a computer</li><li class="listitem" style="list-style-type: disc">An external power supply</li></ul></div><p>We already used USB for supplying power to the Arduino since the beginning of the section. This is a pretty nice way to begin (and even to make a great project). This is easy and works for many purposes.</p><p>We can also use an external power supply when we need more autonomy and mobility with our Arduino devices.</p><p>In any case, we have to keep in mind that both our Arduino and our circuits wired to it need power. Usually, the Arduino consumption is no more than 50mA. Add some LEDs and you'll see the consumption increase.</p><p>Let's check some cases of real use.</p><div class="section" title="Classic cases of USB power supplying"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec158"/>Classic cases of USB power supplying</h2></div></div></div><p>Why and when would we use a USB power supply?</p><p>Obviously, if we need our computer connected to our Arduino for data communication purposes, we can naturally supply power to the Arduino through the USB.</p><p>This is the main reason for using a USB power supply.</p><p>There are also some cases where we cannot have a lot of power sockets. Sometimes, there are many constraints in installation design projects and we don't have a lot of power sockets. This is also one case of supplying power using the USB.</p><p>Basically, the first thing to bear in mind before using power supplied by the USB port is the global consumption amount of our circuit.</p><p>Indeed, as we have already learned, the maximum current a USB port can provide is around 500mA. Be sure you don't exceed this value. Above this limit of consumption, things become totally unpredictable and some computers can even reboot while some others can disable all <a id="id1204" class="indexterm"/>USB ports. We have to keep that in mind.</p></div><div class="section" title="Supplying external power"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec159"/>Supplying external power</h2></div></div></div><p>There are two <a id="id1205" class="indexterm"/>different ways to supply power to an Arduino-based system. We can state the two main power supplies as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Batteries</li><li class="listitem" style="list-style-type: disc">Power adapters</li></ul></div><div class="section" title="Supplying with batteries"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec127"/>Supplying with batteries</h3></div></div></div><p>If we remember <a id="id1206" class="indexterm"/>correctly, the Arduino Uno and Mega for instance can operate on an external power supply of 6 V to 20 V. For stable use, the recommended range is 7 V to 12 V. 9 V is an ideal voltage.</p><p>In order to set the board to external power supply, you have to take care of the power jumper. We have to put it on the external power supply side, named EXT. This setup is for the Arduino Diecimilla and older the Arduino boards:</p><div class="mediaobject"><img src="graphics/7584_10_008.jpg" alt="Supplying with batteries"/><div class="caption"><p>The power supply jumper put on the EXT side, meaning set up to external power supply</p></div></div><p>Let's check the basic<a id="id1207" class="indexterm"/> wiring with a 9 V battery:</p><div class="mediaobject"><img src="graphics/7584_10_009.jpg" alt="Supplying with batteries"/><div class="caption"><p>A 9V battery wired to an Arduino board UNO R3</p></div></div><p>This simple <a id="id1208" class="indexterm"/>wiring provides a way to supply power to the Arduino board. If you plug some other circuits to the Arduino, the battery through the Arduino will feed them.</p><p>There are also some other types of batteries that we can use. Coin cell batteries are a nice way to save space while supplying power externally:</p><div class="mediaobject"><img src="graphics/7584_10_010.jpg" alt="Supplying with batteries"/><div class="caption"><p>A classic coin cell battery</p></div></div><p>There are many <a id="id1209" class="indexterm"/>type of coin cell holders to use this type of battery in our circuits. Usually, coin cell batteries provide 3.6 V at 110 mAh. If this cannot supply power to the Arduino Uno, it can easily supply the Arduino Pro Mini working at a voltage of 3.3 V:</p><div class="mediaobject"><img src="graphics/7584_10_011.jpg" alt="Supplying with batteries"/><div class="caption"><p>Arduino Pro Mono</p></div></div><p>The Arduino Pro Mini board is really interesting as it can be embedded in many circuits that need to be discrete and sometimes hidden in walls for digital art installations or put into a small plastic box that can be carried in a pocket when they are used as a mobile tool.</p><p>We can also use polymer lithium-ion batteries. I used them a couple of times for an autonomous device project.</p><p>However, we can have some projects that require more power.</p></div></div><div class="section" title="Power adapter for Arduino supply"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec160"/>Power adapter for Arduino supply</h2></div></div></div><p>For projects<a id="id1210" class="indexterm"/> requiring <a id="id1211" class="indexterm"/>more power, we have to use an external power supply. The setup of the Arduino stays the same as with batteries. The off-the-shelf Arduino adapter has to meet some requirements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">DC adapter (No AC adapter here!)</li><li class="listitem" style="list-style-type: disc">Output voltage between 9V and 12V DC</li><li class="listitem" style="list-style-type: disc">Able to output a minimum current of 250mA but aim at 500mA at least or preferably 1A</li><li class="listitem" style="list-style-type: disc">Must have a centre positive 2.1mm power plug</li></ul></div><p>Here are the<a id="id1212" class="indexterm"/> patterns you have to look for on your adapter before plugging <a id="id1213" class="indexterm"/>in the Arduino.</p><p>First, the center of the connector has to be the positive part; check out the following diagram. You should see that on an Arduino-compatible adapter:</p><div class="mediaobject"><img src="graphics/7584_10_012.jpg" alt="Power adapter for Arduino supply"/><div class="caption"><p>The symbol showing the center positive plug</p></div></div><p>Then, the voltage and current characteristics. This has to show something like: OUTPUT: 12 VDC 1 A. This is an example; 12 VDC and 5 A is also fine. Don't forget that current is only driven by what's there in your circuit. A power adapter that puts out a higher current will not harm your circuit, because a circuit will only draw what it needs.</p><p>A lot of adapters are available in the market and can be used with our Arduino boards.</p></div><div class="section" title="How to calculate current consumption"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec161"/>How to calculate current consumption</h2></div></div></div><p>In order to calculate <a id="id1214" class="indexterm"/>current in your circuit, you have to use Ohm's law as described in the first chapter of this book.</p><p>When you check the datasheet of a component, like an LED, you can see that the current passed through it.</p><p>Let's check the RGB LED Common Cathode with this datasheet: <a class="ulink" href="https://www.sparkfun.com/datasheets/Components/YSL-R596CR3G4B5C-C10.pdf">https://www.sparkfun.com/datasheets/Components/YSL-R596CR3G4B5C-C10.pdf</a>
</p><p>We can see a forward current of 20 mA and a peak forward current of 30 mA. If we have five LEDs like that switched on at the maximum brightness (that is red, blue, and green lighted up), we have: 5 x (20 + 20 + 20) = 300 mA needed for normal use and even peaks would consume 5 x (30 + 30 + 30) = 450 mA.</p><p>This is in the case where all LEDs are fully switched on at the same time.</p><p>You must have understood the strategy we already used in power supply cycling, switching on each LED one after the other in quick succession. This provides a way to reduce the power consumption and also allow some projects to use a lot of LEDs without requiring an external power adapter.</p><p>I won't describe <a id="id1215" class="indexterm"/>the calculations for each case here, but you'd have to refer to electricity rules to precisely calculate the consumption.</p><p>By experience, there is nothing better than your voltmeter and Ampere meter, the former measuring voltage between two points and the latter measuring current at some points along the circuit.</p><p>I'd suggest that you make some calculations to be sure to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Not override the Arduino capacity per pins</li><li class="listitem" style="list-style-type: disc">Not override USB 450mA limit, in case you use a USB power supply</li></ul></div><p>Then, after that, begin to wire and measure at the same time with voltmeter and Ampere meter.</p><p>At last, a classic reference for most of the Arduino boards is available at this page: <a class="ulink" href="http://playground.arduino.cc/Main/ArduinoPinCurrentLimitations">http://playground.arduino.cc/Main/ArduinoPinCurrentLimitations</a>.</p><p>We can find the limitations for current consumption for each part of the Arduino.</p></div></div>
<div class="section" title="Drawing on gLCDs"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec74"/>Drawing on gLCDs</h1></div></div></div><p>Drawing is <a id="id1216" class="indexterm"/>always<a id="id1217" class="indexterm"/> fun. Drawing and handling LCD displays instead of LEDs matrices is really interesting too, because we have devices with high-density points we can switch on and off easily.</p><p>LCDs exist in many types. The two main types are the character and graphical type.</p><p>We are talking about the graphical type here, especially those based on the KS0108 graphics-only controller used in many regular gLCD devices.</p><p>We are going to use a nice library that is available on Google. It has code by Michael Margolis and Bill Perry, and it is named <code class="literal">glcd-arduino</code>. This library is licensed under the GNU Lesser GPL.</p><p>Let's download it here: <a class="ulink" href="http://code.google.com/p/glcd-arduino/downloads/list">http://code.google.com/p/glcd-arduino/downloads/list</a>. Download the most recent version.</p><p>Unzip it, put it in the place where all your libraries are, and restart or start your Arduino IDE.</p><p>You should now see a lot of examples related to the gLCD library.</p><p>We won't check all the nice features and functions provided by this library here, but you can check this page on the Arduino website: <a class="ulink" href="http://playground.arduino.cc/Code/GLCDks0108">http://playground.arduino.cc/Code/GLCDks0108</a>.</p><div class="section" title="Wiring the device"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec162"/>Wiring the device</h2></div></div></div><p>We are going to check the <a id="id1218" class="indexterm"/>wiring of a KS0108 based gLCD type Panel B:</p><div class="mediaobject"><img src="graphics/7584_10_013.jpg" alt="Wiring the device"/><div class="caption"><p>A lot of wires wiring the gLCD to Arduino and the potentiometer to adjust LCD contrast</p></div></div><p>The corresponding electrical diagram is as follows:</p><div class="mediaobject"><img src="graphics/7584_10_014.jpg" alt="Wiring the device"/><div class="caption"><p>KS0108 based gLCD type Panel B wired to an Arduino Uno R3</p></div></div><p>These are a lot of <a id="id1219" class="indexterm"/>wires. Of course, we can multiply things. We can also use an Arduino MEGA and keep using the other digital pin available for other purposes, but that is not the point here. Let's check some of the functions of this powerful library.</p></div><div class="section" title="Demoing the library"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec163"/>Demoing the library</h2></div></div></div><p>Take the example <a id="id1220" class="indexterm"/>named <code class="literal">GLCDdemo</code>. It shows you almost all the functions available in the library.</p><p>There is very good PDF documentation provided with the library. It explains each available method. You can find it in the <code class="literal">library</code> folder in the <code class="literal">doc</code> subfolder:</p><div class="mediaobject"><img src="graphics/7584_10_015.jpg" alt="Demoing the library"/><div class="caption"><p>The documentation of gLCD-Arduino showing the screen coordinates system</p></div></div><p>At first, we have to<a id="id1221" class="indexterm"/> include <code class="literal">glcd.h</code> in order to use the library. Then, we have to include some other headers, in this example, fonts and bitmap in order to use the font typographic methods and the bitmap objects too.</p></div><div class="section" title="Some useful method's families"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec164"/>Some useful method's families</h2></div></div></div><p>I'd suggest ordering learning methods into three parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Global GLCD methods</li><li class="listitem" style="list-style-type: disc">Drawing methods</li><li class="listitem" style="list-style-type: disc">Text methods</li></ul></div><div class="section" title="Global GLCD methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec128"/>Global GLCD methods</h3></div></div></div><p>The first is the<a id="id1222" class="indexterm"/> <code class="literal">init()</code> function<a id="id1223" class="indexterm"/>. This <a id="id1224" class="indexterm"/>one initializes the library and has to be called before any other gLCD methods.</p><p>The<a id="id1225" class="indexterm"/> <code class="literal">SetDisplayMode()</code> function<a id="id1226" class="indexterm"/> is useful because it sets up the use of the LCD as normal (writing in black over white background) or inverted. White just means not black. The real color depends on the backlight color, of course.</p><p>The<a id="id1227" class="indexterm"/> <code class="literal">ClearScreen()</code> function <a id="id1228" class="indexterm"/>erases the screen, filling it with white background in normal mode, or black in inverted mode.</p><p>The<a id="id1229" class="indexterm"/> <code class="literal">ReadData()</code> <a id="id1230" class="indexterm"/>and<a id="id1231" class="indexterm"/> <code class="literal">WriteData()</code> functions <a id="id1232" class="indexterm"/>are really raw methods that get and set the byte of data at particular coordinates.</p></div><div class="section" title="Drawing methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec129"/>Drawing methods</h3></div></div></div><p>These are a set of functions<a id="id1233" class="indexterm"/> dedicated to drawing on the screen.</p><p>The set of constants are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GLCD.Width</code> is the display width in pixels</li><li class="listitem" style="list-style-type: disc"><code class="literal">GLCD.Height</code> is the display height in pixels</li><li class="listitem" style="list-style-type: disc"><code class="literal">GLCD.Right</code> is the last pixel column at the right (equals GLCD.Width – 1)</li><li class="listitem" style="list-style-type: disc"><code class="literal">GLCD.Bottom</code> is the last pixel row at the bottom (equals GLCD. Height – 1)</li><li class="listitem" style="list-style-type: disc"><code class="literal">GLCD.CenterX</code> and <code class="literal">GLCD.CenterY</code> are the coordinates of the pixel in the middle</li></ul></div><p>Basically, you can draw by moving the graphics cursor and by drawing primitive shapes:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Function</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GotoXY()</code>
<a id="id1234" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Moves the<a id="id1235" class="indexterm"/> cursor to specific coordinates</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DrawVLine()</code>
<a id="id1236" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Draws a <a id="id1237" class="indexterm"/>vertical line from a point to another point in the same pixel column but above or below the initial point</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DrawHLine()</code>
<a id="id1238" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Works the same <a id="id1239" class="indexterm"/>
<a id="id1240" class="indexterm"/>as <code class="literal">DrawVLine()</code> but on the same pixel row</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DrawLine()</code>
<a id="id1241" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Draws a line between two coordinates</p>
</td></tr></tbody></table></div><p>Some other, more complex shapes can be drawn too:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Functions</p>
</th><th style="text-align: left" valign="bottom">
<p>Descriptions</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DrawRect()</code>
<a id="id1242" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Draws a<a id="id1243" class="indexterm"/> rectangle from a point when provided with a width and height.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">FillRect()</code>
<a id="id1244" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Works the same<a id="id1245" class="indexterm"/> as <code class="literal">DrawRect()</code>, but by filling the rectangle shape with black (or white) pixels.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DrawRoundRect()</code>
<a id="id1246" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Draws a nice<a id="id1247" class="indexterm"/> rectangle with rounded corners.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DrawCircle()</code> and<a id="id1248" class="indexterm"/> <code class="literal">FillCircle()</code>
<a id="id1249" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Draws a <a id="id1250" class="indexterm"/>circle from coordinates <a id="id1251" class="indexterm"/>and a radius, and a circle filled with black (or white) pixels.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DrawBitmap()</code>
<a id="id1252" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Draws a whole <a id="id1253" class="indexterm"/>bitmap at a particular position on the screen. It uses a pointer to that bitmap in memory.</p>
</td></tr></tbody></table></div><p>With this set of functions, you can basically draw anything you want.</p></div><div class="section" title="Text methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec130"/>Text methods</h3></div></div></div><p>These are a set of<a id="id1254" class="indexterm"/> functions dedicated to typography on the screen:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Functions</p>
</th><th style="text-align: left" valign="bottom">
<p>Descriptions</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SelectFont()</code>
<a id="id1255" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>At first, this <a id="id1256" class="indexterm"/>chooses the font to be used in the next functions calls.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SetFontColor()</code>
<a id="id1257" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Chooses the <a id="id1258" class="indexterm"/>color.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SetTextMode()</code>
<a id="id1259" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Chooses <a id="id1260" class="indexterm"/>a scrolling direction.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CursorTo()</code>
<a id="id1261" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Moves the<a id="id1262" class="indexterm"/> cursor to a specific column and row. The column calculation uses the width of the widest character.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CursorToXY()</code>
<a id="id1263" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Moves the <a id="id1264" class="indexterm"/>cursor to particular pixel coordinate.</p>
</td></tr></tbody></table></div><p>One important feature to know about, is the fact that Arduino's print functions can be used with gLCD library; <code class="literal">GLCD.print()</code> works fine, for instance. There are also a couple of other functions available that can be found on the official website.</p><p>At last, I'd suggest you to test the example named <code class="literal">life</code>. This is based on the John Conway's Game of Life. This is a nice example of what you can do and implement some nice and useful logic.</p><p>Drawing on gLCD is nice, but we could also use a small module handling VGA.</p></div></div></div>
<div class="section" title="Using VGA with the Gameduino Shield"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec75"/>Using VGA with the Gameduino Shield</h1></div></div></div><p>Gameduino <a id="id1265" class="indexterm"/>is an Arduino Shield. This is the first one we are using here in this book. Basically, a shield is a PCB (printed circuit board) that can be plugged to another PCB, here our Arduino.</p><p>Arduino Shields<a id="id1266" class="indexterm"/> are pre-made circuits including components and <a id="id1267" class="indexterm"/>sometimes processors too. They add features to our Arduino board by handling some specific tasks.</p><p>Here, the Gameduino will add VGA drawing abilities to our Arduino that can't be done on its own.</p><p>The Gameduino adds a VGA port, a mini-jack for the sound, and also includes an FPGA Xilling Spartan3A. FPGA Xilling Spartan3A can process graphical data faster than the Arduino itself. Arduino can control this graphical hardware driver by SPI interface.</p><p>Let's see how it works:</p><div class="mediaobject"><img src="graphics/7584_10_016.jpg" alt="Using VGA with the Gameduino Shield"/><div class="caption"><p>The Gameduino controller Arduino Shield</p></div></div><p>Arduino Shields<a id="id1268" class="indexterm"/> can be <a id="id1269" class="indexterm"/>plugged in Arduino boards directly. Check the following screenshot:</p><div class="mediaobject"><img src="graphics/7584_10_017.jpg" alt="Using VGA with the Gameduino Shield"/><div class="caption"><p>The Gameduino plugged in the Arduino board</p></div></div><p>Here are some <a id="id1270" class="indexterm"/>characteristics of the Gameduino:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Video output is 400 x 300 pixels in 512 colors</li><li class="listitem" style="list-style-type: disc">All color processed internally at 15 bit precision</li><li class="listitem" style="list-style-type: disc">Compatible with any standard VGA monitor (800 x 600 @ 72 Hz)</li><li class="listitem" style="list-style-type: disc">Background graphics (512 x 512 pixel character, 256 characters)</li><li class="listitem" style="list-style-type: disc">Foreground graphics (sprite 16 x 16 abilities, transparency, rotate/flip, and sprite collision detection)</li><li class="listitem" style="list-style-type: disc">Audio output as stereo; 12-bit frequency synthesizer</li><li class="listitem" style="list-style-type: disc">64 independent voices at 10 to 8000 hz</li><li class="listitem" style="list-style-type: disc">Sample playback channel</li></ul></div><p>The underlying concept is to plug it in the Arduino and to control it using our Arduino firmware with the library taking care of all SPI communication between the Arduino and Gameduino.</p><p>We cannot describe all the examples right here in this book, but I want to point you in the right direction. At first, the official website: <a class="ulink" href="http://excamera.com/sphinx/gameduino/">http://excamera.com/sphinx/gameduino/</a>.</p><p>You can find the library here: <a class="ulink" href="http://excamera.com/files/gameduino/synth/sketches/Gameduino.zip">http://excamera.com/files/gameduino/synth/sketches/Gameduino.zip</a>.</p><p>You can also check and use the quick reference poster here: <a class="ulink" href="http://excamera.com/files/gameduino/synth/doc/gen/poster.pdf">http://excamera.com/files/gameduino/synth/doc/gen/poster.pdf</a>.</p><p>For your information, I'm currently designing a piece on digital art installation based on this shield. I intend to describe it on my own website <a class="ulink" href="http://julienbayle.net">http://julienbayle.net</a> and the whole schematics will be provided too.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec76"/>Summary</h1></div></div></div><p>In this first, advanced chapter, we learned a bit more about how to deal with new concrete concepts such as storing data on non-volatile memories (internal and external EEPROM), use GPS module receivers, draw on graphical LCD, and use a nice Arduino Shield named Gameduino to add new features and power to our Arduino. This allowed it to display a VGA signal and also to produce audio. We also learned the use of Arduino as a very portable and mobile device, autonomous from the power supply point of view.</p><p>In the next chapter, we are going to talk about networking concepts. Creating and using networks are usual ways of communication today. We will describe wired and wireless network use with our Arduino projects in the next chapter.</p></div></body></html>