["```cpp\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<map version=\"1.0\" orientation=\"orthogonal\" width=\"20\" height=\"15\" tilewidth=\"32\" tileheight=\"32\">\n    <layer name=\"Tile Layer 1\" width=\"20\" height=\"15\">\n        <data encoding=\"base64\" compression=\"zlib\">\n          eJxjYBgFo2AUjIKhAQAEsAAB\n        </data>\n    </layer>\n</map>\n```", "```cpp\n<data encoding=\"base64\" compression=\"zlib\">\n  eJxjYBgFo2AUjIKhAQAEsAAB\n</data>\n```", "```cpp\n <data encoding=\"base64\">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n</data>\n```", "```cpp\n<tileset firstgid=\"1\" name=\"blocks1\" tilewidth=\"32\" tileheight=\"32\" spacing=\"2\" margin=\"2\">\n  <image source=\"assets/blocks1.png\" width=\"614\" height=\"376\"/>\n</tileset>\n```", "```cpp\nclass Levelâ€©{\n  public:\n\n  Level();\n  ~Level() {}\n\n  void update();\n  void render();\n};\n```", "```cpp\nstruct Tileset\n{\n  int firstGridID;\n  int tileWidth;\n  int tileHeight;\n  int spacing;\n  int margin;\n  int width;\n  int height;\n  int numColumns;\n  std::string name;\n};\n```", "```cpp\nprivate:\n\n  std::vector<Tileset> m_tilesets;\n```", "```cpp\nstd::vector<Tileset>* getTilesets() \n{ \n    return &m_tilesets;  \n}\n```", "```cpp\nclass Layer\n{\n  public:\n\n  virtual void render() = 0;\n  virtual void update() = 0;\n\n  protected:\n\n  virtual ~Layer() {}\n};\n```", "```cpp\nstd::vector<Layer*> m_layers;\n```", "```cpp\nstd::vector<Layer*>* getLayers() \n{ \n    return &m_layers; \n}\n```", "```cpp\nvoid Level::render()\n{\n  for(int i = 0; i < m _layers.size(); i++)\n  {\n    m_layers[i]->render();\n  }\n}\nvoid Level::update()\n{\n  for(int i = 0; i < m_layers.size(); i++)\n  {\n    m_layers[i]->update();\n  }\n}\n```", "```cpp\nclass TileLayer : public Layer\n{\n  public:\n\n    TileLayer(int tileSize, const std::vector<Tileset> &tilesets);\n\n    virtual void update();\n    virtual void render();\n\n    void setTileIDs(const std::vector<std::vector<int>>& data)  \n    {  \n        m_tileIDs = data;  \n    }\n\n    void setTileSize(int tileSize)  \n    {  \n        m_tileSize = tileSize;  \n    }\n\n    Tileset getTilesetByID(int tileID);\n\n  private:\n\n    int m_numColumns;\n    int m_numRows;\n    int m_tileSize;\n\n    Vector2D m_position;\n    Vector2D m_velocity;\n\n    const std::vector<Tileset> &m_tilesets;\n\n    std::vector<std::vector<int>> m_tileIDs;\n};\n```", "```cpp\nClass LevelParser\n{\n  public:\n\n    Level* parseLevel(const char* levelFile);\n\n  private:\n\n    void parseTilesets(TiXmlElement* pTilesetRoot,std::vector<Tileset>* pTilesets);\n\n    void parseTileLayer(TiXmlElement* pTileElement,std::vector<Layer*> *pLayers, const std::vector<Tileset>*pTilesets);\n\n    int m_tileSize;\n    int m_width;\n    int m_height;\n};\n```", "```cpp\nprivate:\n\n  friend class LevelParser;\n  Level();\n```", "```cpp\nLevel* LevelParser::parseLevel(const char *levelFile)\n{\n    // create a TinyXML document and load the map XML\n    TiXmlDocument levelDocument;\n    levelDocument.LoadFile(levelFile);\n\n    // create the level object\n    Level* pLevel = new Level();\n\n    // get the root node \n    TiXmlElement* pRoot = levelDocument.RootElement();\n\n    pRoot->Attribute(\"tilewidth\", &m_tileSize);\n    pRoot->Attribute(\"width\", &m_width);\n    pRoot->Attribute(\"height\", &m_height);\n\n    // parse the tilesets\n    for(TiXmlElement* e = pRoot->FirstChildElement(); e != NULL; e = e->NextSiblingElement())\n    {\n      if(e->Value() == std::string(\"tileset\"))\n      {\n         parseTilesets(e, pLevel->getTilesets());\n      }\n    }\n\n    // parse any object layers\n    for(TiXmlElement* e = pRoot->FirstChildElement(); e != NULL; e = e->NextSiblingElement())\n    {\n      if(e->Value() == std::string(\"layer\"))\n      {\n        parseTileLayer(e, pLevel->getLayers(), pLevel->getTilesets());\n      }\n    }\n\n    return pLevel;\n}\n```", "```cpp\n// get the root node \nTiXmlElement* pRoot = levelDocument.RootElement();\n```", "```cpp\n<map version=\"1.0\" orientation=\"orthogonal\" width=\"60\" height=\"15\" tilewidth=\"32\" tileheight=\"32\">\n```", "```cpp\npRoot->Attribute(\"tilewidth\", &m_tileSize);\npRoot->Attribute(\"width\", &m_width);\npRoot->Attribute(\"height\", &m_height);\n```", "```cpp\n// parse the tilesets\nfor(TiXmlElement* e = pRoot->FirstChildElement(); e != NULL; e = e->NextSiblingElement())\n{\n  if(e->Value() == std::string(\"tileset\"))\n  {\n    parseTilesets(e, pLevel->getTilesets());\n  }\n}\n```", "```cpp\n// parse any object layers\nfor(TiXmlElement* e = pRoot->FirstChildElement(); e != NULL; e = e->NextSiblingElement())\n{\n  if(e->Value() == std::string(\"layer\"))\n  {\n    parseTileLayer(e, pLevel->getLayers(), pLevel->getTilesets());\n  }\n}\n\nreturn pLevel;\n}\n```", "```cpp\nvoid LevelParser::parseTilesets(TiXmlElement* pTilesetRoot, std::vector<Tileset>* pTilesets)\n{\n  // first add the tileset to texture manager\n    TheTextureManager::Instance()->load(pTilesetRoot->FirstChildElement()->Attribute(\"source\"), pTilesetRoot->Attribute(\"name\"), TheGame::Instance()->getRenderer());\n\n  // create a tileset object\n  Tileset tileset;\n  pTilesetRoot->FirstChildElement()->Attribute(\"width\", &tileset.width);\n  pTilesetRoot->FirstChildElement()->Attribute(\"height\", &tileset.height);\n  pTilesetRoot->Attribute(\"firstgid\", &tileset.firstGridID);\n  pTilesetRoot->Attribute(\"tilewidth\", &tileset.tileWidth);\n  pTilesetRoot->Attribute(\"tileheight\", &tileset.tileHeight);\n  pTilesetRoot->Attribute(\"spacing\", &tileset.spacing);\n  pTilesetRoot->Attribute(\"margin\", &tileset.margin);\n  tileset.name = pTilesetRoot->Attribute(\"name\");\n\n  tileset.numColumns = tileset.width / (tileset.tileWidth + tileset.spacing);\n\n  pTilesets->push_back(tileset);\n}\n```", "```cpp\n<tileset firstgid=\"1\" name=\"blocks1\" tilewidth=\"32\" tileheight=\"32\"spacing=\"2\" margin=\"2\">\n  <image source=\"blocks1.png\" width=\"614\" height=\"376\"/>\n</tileset>\n```", "```cpp\nvoid LevelParser::parseTileLayer(TiXmlElement* pTileElement, std::vector<Layer*> *pLayers, const std::vector<Tileset>* pTilesets)\n{\n  TileLayer* pTileLayer = new TileLayer(m_tileSize, *pTilesets);\n\n    // tile data\n  std::vector<std::vector<int>> data;\n\n  std::string decodedIDs;\n  TiXmlElement* pDataNode;\n\n  for(TiXmlElement* e = pTileElement->FirstChildElement(); e != NULL; e = e->NextSiblingElement())\n  {\n    if(e->Value() == std::string(\"data\"))\n    {\n      pDataNode = e;\n    }\n  }\n\n  for(TiXmlNode* e = pDataNode->FirstChild(); e != NULL; e = e->NextSibling())\n  {\n    TiXmlText* text = e->ToText();\n    std::string t = text->Value();\n    decodedIDs = base64_decode(t);\n  }\n\n    // uncompress zlib compression\n  uLongf numGids = m_width * m_height * sizeof(int);\n  std::vector<unsigned> gids(numGids);\n  uncompress((Bytef*)&gids[0], &numGids,(const Bytef*)decodedIDs.c_str(), decodedIDs.size());\n\n  std::vector<int> layerRow(m_width);\n\n  for(int j = 0; j < m_height; j++)\n  {\n    data.push_back(layerRow);\n  }\n\n  for(int rows = 0; rows < m_height; rows++)\n  {\n    for(int cols = 0; cols < m_width; cols++)\n    {\n      data[rows][cols] = gids[rows * m_width + cols];\n    }\n  }\n\n  pTileLayer->setTileIDs(data);\n\n  pLayers->push_back(pTileLayer);\n}\n```", "```cpp\nTileLayer* pTileLayer = new TileLayer(m_tileSize, *pTilesets);\n```", "```cpp\n// tiledata\nstd::vector<std::vector<int>> data;\n\nstd::string decodedIDs;\nTiXmlElement* pDataNode;\n```", "```cpp\nfor(TiXmlElement* e = pTileElement->FirstChildElement(); e != NULL; e = e->NextSiblingElement())\n{\n    if(e->Value() == std::string(\"data\"))\n    {\n      pDataNode = e;\n    }\n}\n```", "```cpp\nfor(TiXmlNode* e = pDataNode->FirstChild(); e != NULL; e = e->NextSibling())\n{\n  TiXmlText* text = e->ToText();\n  std::string t = text->Value();\n  decodedIDs = base64_decode(t);\n}\n```", "```cpp\n// uncompress zlib compression\nuLongf sizeofids = m_width * m_height * sizeof(int);\n\nstd::vector<int> ids(m_width * m_height);\n\nuncompress((Bytef*)&ids[0], &sizeofids,(const Bytef*)decodedIDs.c_str(), decodedIDs.size());\n```", "```cpp\nstd::vector<int> layerRow(m_width);\nfor(int j = 0; j < m_height; j++)\n{\n  data.push_back(layerRow);\n}\n```", "```cpp\nfor(int rows = 0; rows < m_height; rows++)\n{\n  for(int cols = 0; cols < m_width; cols++)\n  {\n    data[rows][cols] = ids[rows * m_width + cols];\n  }\n}\n```", "```cpp\nTileLayer::TileLayer(int tileSize, const std::vector<Tileset> &tilesets) : m_tileSize(tileSize), m_tilesets(tilesets), m_position(0,0), m_velocity(0,0)\n{\n  m_numColumns = (TheGame::Instance()->getGameWidth() / m_tileSize);\n  m_numRows = (TheGame::Instance()->getGameHeight() / m_tileSize);\n}\n```", "```cpp\nint getGameWidth() const  \n{  \n  return m_gameWidth;  \n}\nint getGameHeight() const  \n{  \n  return m_gameHeight;  \n}\n```", "```cpp\nvoid TileLayer::update()\n{\n  m_position += m_velocity;\n}\n```", "```cpp\nvoid TileLayer::render()\n{\n  int x, y, x2, y2 = 0;\n\n  x = m_position.getX() / m_tileSize;\n  y = m_position.getY() / m_tileSize;\n\n  x2 = int(m_position.getX()) % m_tileSize;\n  y2 = int(m_position.getY()) % m_tileSize;\n\n  for(int i = 0; i < m_numRows; i++)\n  {\n    for(int j = 0; j < m_numColumns; j++)\n    {\n        int id = m_tileIDs[i][j + x];\n\n          if(id == 0)\n          {\n            continue;\n          }\n\n        Tileset tileset = getTilesetByID(id);\n\n        id--;\n\n        TheTextureManager::Instance()->drawTile(tileset.name, 2, 2, (j * m_tileSize) - x2, (i * m_tileSize) - y2, m_tileSize, m_tileSize, (id - (tileset.firstGridID - 1)) / tileset.numColumns, (id - (tileset.firstGridID - 1)) % tileset.numColumns, TheGame::Instance()->getRenderer());\n    }\n  }\n}\n```", "```cpp\nvoid TextureManager::drawTile(std::string id, int margin, int spacing, int x, int y, int width, int height, int currentRow, int currentFrame, SDL_Renderer *pRenderer)\n{\n  SDL_Rect srcRect;\n  SDL_Rect destRect;\n  srcRect.x = margin + (spacing + width) * currentFrame;\n  srcRect.y = margin + (spacing + height) * currentRow;\n  srcRect.w = destRect.w = width;\n  srcRect.h = destRect.h = height;\n  destRect.x = x;\n  destRect.y = y;\n\n  SDL_RenderCopyEx(pRenderer, m_textureMap[id], &srcRect,&destRect, 0, 0, SDL_FLIP_NONE);\n}\n```", "```cpp\nfor(int i = 0; i < m_numRows; i++)\n{\n  for(int j = 0; j < m_numColumns; j++)\n  {\n    int id = m_tileIDs[i][j + x];\n\n    if(id == 0)\n    {\n      continue;\n    }\n\n    Tilesettileset = getTilesetByID(id);\n\n    id--;\n\n    TheTextureManager::Instance()->drawTile(tileset.name,tileset.margin, tileset.spacing, (j * m_tileSize) - x2, (i *m_tileSize) - y2, m_tileSize, m_tileSize, (id -(tileset.firstGridID - 1)) / tileset.numColumns, (id -(tileset.firstGridID - 1)) % tileset.numColumns,TheGame::Instance()->getRenderer());\n  }\n}\n```", "```cpp\nfor(int i = 0; i < m_numRows; i++)\n{\n  for(int j = 0; j < m_numColumns; j++)\n{\n```", "```cpp\nm_numColumns = (TheGame::Instance()->getGameWidth() / m_tileSize);\nm_numRows = (TheGame::Instance()->getGameHeight() / m_tileSize);\n```", "```cpp\nint id = m_tileIDs[i + y][j + x];\n```", "```cpp\nif(id == 0)\n{\n  continue;\n}\n```", "```cpp\nTileset tileset = getTilesetByID(id);\n```", "```cpp\nTileset TileLayer::getTilesetByID(int tileID)\n{\n  for(int i = 0; i < m_tilesets.size(); i++)\n  {\n    if( i + 1 <= m_tilesets.size() - 1)\n    {\n      if(tileID >= m_tilesets[i].firstGridID&&tileID < m_tilesets[i + 1].firstGridID)\n      {\n        return m_tilesets[i];\n      }\n    }\n    else\n    {\n      return m_tilesets[i];\n    }\n  }\n\n  std::cout << \"did not find tileset, returning empty tileset\\n\";\n  Tileset t;\n  return t;\n}\n```", "```cpp\nid--;\n\nTheTextureManager::Instance()->drawTile(tileset.name, \n  tileset.margin, tileset.spacing, (j * m_tileSize) - x2, (i * \n  m_tileSize) - y2, m_tileSize, m_tileSize, (id - \n  (tileset.firstGridID - 1)) / tileset.numColumns, (id - \n  (tileset.firstGridID - 1)) % tileset.numColumns, \n    TheGame::Instance()->getRenderer());\n  }\n}\n```", "```cpp\ntileset.margin, tileset.spacing\n```", "```cpp\n(j * m_tileSize) - x2, (i * m_tileSize) - y2\n```", "```cpp\nm_tileSize, m_tileSize,\n```", "```cpp\n(id - (tileset.firstGridID - 1)) / tileset.numColumns, \n(id - (tileset.firstGridID - 1)) % tileset.numColumns,\n```", "```cpp\nbool PlayState::onEnter()\n{\n  LevelParser levelParser;\n  pLevel = levelParser.parseLevel(\"assets/map1.tmx\");\n\n  std::cout << \"entering PlayState\\n\";\n  return true;\n}\n```", "```cpp\nvoid PlayState::render()\n{\n  pLevel->render();\n}\n```", "```cpp\nint x, y, x2, y2 = 0;\n\nx = m_position.getX() / m_tileSize;\ny = m_position.getY() / m_tileSize;\n\nx2 = int(m_position.getX()) % m_tileSize;\ny2 = int(m_position.getY()) % m_tileSize;\n```", "```cpp\nx2 = int(m_position.getX()) % m_tileSize;\ny2 = int(m_position.getY()) % m_tileSize;\n```", "```cpp\n(j * m_tileSize) - x2, (i * m_tileSize) - y2\n```", "```cpp\nvoid TileLayer::update()\n{\n  m_position += m_velocity;\n  m_velocity.setX(1);\n}\n```", "```cpp\nvoid PlayState::update()\n{\n  pLevel->update();\n}\n```", "```cpp\n<objectgroup name=\"Object Layer 1\" width=\"60\" height=\"15\">\n  <object name=\"Helicopter1\" type=\"Player\" x=\"32\" y=\"32\" width=\"32 height=\"32\">\n    <properties>\n      <property name=\"numFrames\" value=\"4\"/>\n      <property name=\"textureHeight\" value=\"55\"/>\n      <property name=\"textureID\" value=\"helicopter\"/>\n      <property name=\"textureWidth\" value=\"128\"/>\n    </properties>\n  </object>\n</objectgroup>\n```", "```cpp\n<properties>\n  <property name=\"helicopter\" value=\"helicopter.png\"/>\n</properties>\n```", "```cpp\nclass ObjectLayer : public Layer\n{\n  public:\n  virtual void update();\n  virtual void render();\n\n  std::vector<GameObject*>* getGameObjects()  \n  {  \n    return &m_gameObjects;  \n  }\n\n  private:\n\n  std::vector<GameObject*> m_gameObjects;\n};\n```", "```cpp\nvoid ObjectLayer::update()\n{\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    m_gameObjects[i]->update();\n  }\n\n}\nvoid ObjectLayer::render()\n{\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    m_gameObjects[i]->draw();\n  }\n}\n```", "```cpp\nvoid parseTextures(TiXmlElement* pTextureRoot);\n\nvoid parseObjectLayer(TiXmlElement* pObjectElement,std::vector<Layer*> *pLayers);\n```", "```cpp\n// we must parse the textures needed for this level, which have been added to properties\nfor(TiXmlElement* e = pProperties->FirstChildElement(); e != NULL;e = e->NextSiblingElement())\n{\n  if(e->Value() == std::string(\"property\"))\n  {\n  parseTextures(e);\n  }\n}\n```", "```cpp\n// parse any object layers\nfor(TiXmlElement* e = pRoot->FirstChildElement(); e != NULL; e = e->NextSiblingElement())\n{\n  if(e->Value() == std::string(\"objectgroup\") || e->Value() == std::string(\"layer\"))\n  {\n    if(e->FirstChildElement()->Value() == std::string(\"object\"))\n    {\n      parseObjectLayer(e, pLevel->getLayers());\n    }\n    else if(e->FirstChildElement()->Value() == std::string(\"data\"))\n    {\n      parseTileLayer(e, pLevel->getLayers(), pLevel->getTilesets());\n    }\n  }\n}\n```", "```cpp\nvoid LevelParser::parseTextures(TiXmlElement* pTextureRoot)\n{\n  TheTextureManager::Instance()->load(pTextureRoot->Attribute(\"value\"), pTextureRoot->Attribute(\"name\"), TheGame::Instance()->getRenderer());\n}\n```", "```cpp\nvoid LevelParser::parseObjectLayer(TiXmlElement* pObjectElement, std::vector<Layer*> *pLayers)\n{\n    // create an object layer\n  ObjectLayer* pObjectLayer = new ObjectLayer();\n\n  std::cout << pObjectElement->FirstChildElement()->Value();\n\n  for(TiXmlElement* e = pObjectElement->FirstChildElement(); e != NULL; e = e->NextSiblingElement())\n    {\n      std::cout << e->Value();\n      if(e->Value() == std::string(\"object\"))\n      {\n        int x, y, width, height, numFrames, callbackID, animSpeed;\n        std::string textureID;\n\n        // get the initial node values type, x and y\n        e->Attribute(\"x\", &x);\n        e->Attribute(\"y\", &y);\n        GameObject* pGameObject = TheGameObjectFactory::Instance()->create(e->Attribute(\"type\"));\n\n        // get the property values\n        for(TiXmlElement* properties = e->FirstChildElement(); properties != NULL; properties = properties->NextSiblingElement())\n        {\n          if(properties->Value() == std::string(\"properties\"))\n          {\n            for(TiXmlElement* property = properties->FirstChildElement(); property != NULL; property = property->NextSiblingElement())\n            {\n              if(property->Value() == std::string(\"property\"))\n              {\n                if(property->Attribute(\"name\") == std::string(\"numFrames\"))\n                  {\n                    property->Attribute(\"value\", &numFrames);\n                  }\n                else if(property->Attribute(\"name\") == std::string(\"textureHeight\"))\n                {\n                  property->Attribute(\"value\", &height);\n                }\n                else if(property->Attribute(\"name\") == std::string(\"textureID\"))\n                {\n                  textureID = property->Attribute(\"value\");\n                }\n                else if(property->Attribute(\"name\") == std::string(\"textureWidth\"))\n                {\n                  property->Attribute(\"value\", &width);\n                }\n                else if(property->Attribute(\"name\") == std::string(\"callbackID\"))\n                {\n                  property->Attribute(\"value\", &callbackID);\n                }\n                else if(e->Attribute(\"name\") == std::string(\"animSpeed\"))\n                {\n                  property->Attribute(\"value\", &animSpeed);\n                }\n              }\n            }\n          }\n        }\n        pGameObject->load(newLoaderParams(x, y, width, height, textureID, numFrames, callbackID, animSpeed));\n      pObjectLayer->getGameObjects()->push_back(pGameObject);\n    }\n  }\n\n  pLayers->push_back(pObjectLayer);\n}\n```", "```cpp\nif(property->Attribute(\"name\") == std::string(\"numFrames\"))\n{\n  property->Attribute(\"value\", &numFrames);\n}\n```", "```cpp\npGameObject->load(new LoaderParams(x,y,width,height,textureID,numFrames,callbackID, animSpeed));\n```", "```cpp\npObjectLayer->getGameObjects()->push_back(pGameObject);\n```", "```cpp\npLayers->push_back(pObjectLayer);\n```"]