["```cpp\n#include <string>\n\ntemplate <class T>\nstd::size_t test_default() {\n    // Constants\n    const std::size_t ii_max = 20000000;\n    const std::string s(\n        \"Long long long string that \"\n        \"will be used in tests to compare \"\n        \"speed of equality comparisons.\"\n    );\n\n    // Making some data, that will be \n    // used in comparisons\n    const T data[] = {\n        T(s),\n        T(s + s),\n        T(s + \". Whooohooo\"),\n        T(std::string(\"\"))\n    };\n\n    const std::size_t data_dimensions = sizeof(data) / sizeof(data[0]);\n    std::size_t matches = 0u;\n    for (std::size_t ii = 0; ii < ii_max; ++ii) {\n        for (std::size_t i = 0; i < data_dimensions; ++i) {\n            for (std::size_t j = 0; j < data_dimensions; ++j) {\n                if (data[i] == data[j]) {\n                    ++ matches;\n                }\n            }\n        }\n    }\n\n    return matches;\n}\n```", "```cpp\n    #include <boost/functional/hash.hpp>\n    ```", "```cpp\n    struct string_hash_fast {\n        typedef std::size_t comp_type;\n\n        const comp_type     comparison_;\n        const std::string   str_;\n\n        explicit string_hash_fast(const std::string& s)\n            : comparison_(\n                boost::hash<std::string>()(s)\n            )\n            , str_(s)\n        {}\n    };\n    ```", "```cpp\n    inline bool operator == (const string_hash_fast& s1, \n        const string_hash_fast& s2) \n    {\n        return s1.comparison_ == s2.comparison_ \n            && s1.str_ == s2.str_;\n    }\n\n    inline bool operator != (const string_hash_fast& s1, \n        const string_hash_fast& s2) \n    {\n        return !(s1 == s2);\n    }\n    ```", "```cpp\n    #include <iostream>\n    int main(int argc, char* argv[]) {\n        if (argc < 2) {\n            assert(\n                test_default<string_hash_fast>()\n                ==\n                test_default<std::string>()\n            );\n            return 0;\n        }\n\n        switch (argv[1][0]) {\n        case 'h':\n            std::cout << \"HASH matched: \"\n                      << test_default<string_hash_fast>();\n            break;\n\n        case 's':\n            std::cout << \"STD matched: \"\n                      << test_default<std::string>();\n            break;\n\n        default:\n            assert(false);\n            return -2;\n        }\n    }\n    ```", "```cpp\nboost::hash<std::string>()(s)\n```", "```cpp\nreturn s1.comparison_ == s2.comparison_ && s1.str_ == s2.str_;\n```", "```cpp\n// Must be in namespace of string_hash_fast class\ninline std::size_t hash_value(const string_hash_fast& v) {\n    return v.comparison_;\n}\n```", "```cpp\n    #include <boost/unordered_set.hpp>\n    void example() {\n        boost::unordered_set<std::string> strings;\n\n        strings.insert(\"This\");\n        strings.insert(\"is\");\n        strings.insert(\"an\");\n        strings.insert(\"example\");\n\n        assert(strings.find(\"is\") != strings.cend());\n    }\n    ```", "```cpp\ntemplate <class T>\nvoid output_example() {\n    T strings;\n\n    strings.insert(\"CZ\"); strings.insert(\"CD\");\n    strings.insert(\"A\"); strings.insert(\"B\");\n    std::copy(\n        strings.begin(),\n        strings.end(),\n        std::ostream_iterator<std::string>(std::cout, \"  \")\n    );\n}\n```", "```cpp\nboost::unordered_set<std::string> : B  A  CD  CZ\nstd::set<std::string> : A  B  CD  CZ\n```", "```cpp\n$ TIME=\"%E\" time ./unordered s\n\nSTD matched: 20000000\n\n0:31.39\n\n$ TIME=\"%E\" time ./unordered h\n\nHASH matched: 20000000\n\n0:26.93\n\n```", "```cpp\ntemplate <class T>\nstd::size_t test_default() {\n    // Constants\n    const std::size_t ii_max = 20000000;\n    const std::string s(\"Test string\");\n\n    T map;\n\n    for (std::size_t ii = 0; ii < ii_max; ++ii) {\n        map[s + boost::lexical_cast<std::string>(ii)] = ii;\n    }\n\n    // Inserting once more\n    for (std::size_t ii = 0; ii < ii_max; ++ii) {\n        map[s + boost::lexical_cast<std::string>(ii)] = ii;\n    }\n\n    return map.size();\n}\n```", "```cpp\nstruct my_type {\n    int         val1_;\n    std::string val2_;\n};\n```", "```cpp\ninline bool operator == (const my_type& v1, const my_type& v2) {\n    return v1.val1_ == v2.val1_ && v1.val2_ == v2.val2_;}\n```", "```cpp\nstd::size_t hash_value(const my_type& v) {\n    std::size_t ret = 0u;\n\n    boost::hash_combine(ret, v.val1_);\n    boost::hash_combine(ret, v.val2_);\n    return ret;\n}\n```", "```cpp\ntemplate <class T>\ninline void hash_combine(std::size_t& seed, const T& v)\n{\n    std::hash<T> hasher;\n    seed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n}\n```", "```cpp\n    #include <boost/bimap.hpp>\n    #include <boost/bimap/multiset_of.hpp>\n    ```", "```cpp\n        typedef boost::bimap<\n            std::string,\n            boost::bimaps::multiset_of<std::size_t>\n        > name_id_type;\n\n        name_id_type name_id;\n    ```", "```cpp\n        // Inserting keys <-> values\n        name_id.insert(name_id_type::value_type(\n            \"John Snow\", 1\n        ));\n\n        name_id.insert(name_id_type::value_type(\n            \"Vasya Pupkin\", 2\n        ));\n\n        name_id.insert(name_id_type::value_type(\n            \"Antony Polukhin\", 3\n        ));\n\n        // Same person as \"Antony Polukhin\"\n        name_id.insert(name_id_type::value_type(\n            \"Anton Polukhin\", 3\n        ));\n    ```", "```cpp\n        std::cout << \"Left:\\n\";\n        typedef name_id_type::left_const_iterator  left_const_iterator;\n        for (left_const_iterator it = name_id.left.begin(),\n             iend = name_id.left.end();\n             it!= iend;\n             ++it)\n        {\n            std::cout << it->first << \" <=> \" << it->second \n                << '\\n';\n        }\n    ```", "```cpp\n        std::cout << \"\\nRight:\\n\";\n        typedef name_id_type::right_const_iterator right_const_iterator;\n        for (right_const_iterator it = name_id.right.begin(),\n             iend = name_id.right.end();\n             it!= iend;\n             ++it)\n        {\n            std::cout << it->first << \" <=> \" << it->second \n                << '\\n';\n        }\n    ```", "```cpp\n        assert(\n            name_id.find(name_id_type::value_type(\n                \"Anton Polukhin\", 3\n            )) != name_id.end()\n        );\n    ```", "```cpp\n    Left:\n    Anton Polukhin <=> 3\n    Antony Polukhin <=> 3\n    John Snow <=> 1\n    Vasya Pupkin <=> 2\n\n    Right:\n    1 <=> John Snow\n    2 <=> Vasya Pupkin\n    3 <=> Antony Polukhin\n    3 <=> Anton Polukhin\n    ```", "```cpp\n    typedef boost::bimap<\n        std::string,\n        boost::bimaps::multiset_of<std::size_t>\n    > name_id_type;\n```", "```cpp\n#include <boost/bimap/unordered_set_of.hpp>\n#include <boost/bimap/unordered_multiset_of.hpp>\n\ntypedef boost::bimap<\n    boost::bimaps::unordered_set_of<std::string>, \n    boost::bimaps::unordered_multiset_of<std::size_t> \n> hash_name_id_type;\n```", "```cpp\n#include <boost/bimap/set_of.hpp>\n\ntypedef boost::bimap<\n    boost::bimaps::set_of<std::string>, \n    boost::bimaps::multiset_of<std::size_t> \n> name_id_type;\n```", "```cpp\n// name_id.left\nstd::map<std::string, std::size_t> key1; \n\n// name_id.right\nstd::multimap<std::size_t, std::string> key2; \n```", "```cpp\nstruct person {\n    std::size_t     id_;\n    std::string     name_;\n    unsigned int    height_;\n    unsigned int    weight_;\n    person(std::size_t id, const std::string& name, unsigned int height, unsigned int weight)\n        : id_(id)\n        , name_(name)\n        , height_(height)\n        , weight_(weight)\n    {}\n};\n\ninline bool operator < (const person& p1, const person& p2) {\n    return p1.name_ < p2.name_;\n}\n```", "```cpp\n    #include <boost/multi_index_container.hpp>\n    #include <boost/multi_index/ordered_index.hpp>\n    #include <boost/multi_index/hashed_index.hpp>\n    #include <boost/multi_index/identity.hpp>\n    #include <boost/multi_index/member.hpp>\n    ```", "```cpp\n        typedef boost::multi_index::multi_index_container<\n            person,\n            boost::multi_index::indexed_by<\n                // names are unique\n                boost::multi_index::ordered_unique<\n                    boost::multi_index::identity<person>\n                >,\n                // IDs are not unique, but we do not need then //ordered\n                boost::multi_index::hashed_non_unique<\n                    boost::multi_index::member<\n                        person, std::size_t, &person::id_\n                    >\n                >,\n                // Height may not be unique, but must be sorted\n                boost::multi_index::ordered_non_unique<\n                    boost::multi_index::member<\n                        person, unsigned int, &person::height_\n                    >\n                >,\n                // Weight may not be unique, but must be sorted\n                boost::multi_index::ordered_non_unique<\n                    boost::multi_index::member<\n                        person, unsigned int, &person::weight_\n                    >\n                >\n            > // closing for `boost::multi_index::indexed_by<\n        > indexes_t;\n    ```", "```cpp\n        indexes_t persons;\n\n        // Inserting values\n        persons.insert(person(1, \"John Snow\", 185, 80));\n        persons.insert(person(2, \"Vasya Pupkin\", 165, 60));\n        persons.insert(person(3, \"Antony Polukhin\", 183, 70));\n        // Same person as \"Antony Polukhin\"\n        persons.insert(person(3, \"Anton Polukhin\", 182, 70));\n    ```", "```cpp\n    template <std::size_t IndexNo, class Indexes>\n    void print(const Indexes& persons) {\n        std::cout << IndexNo << \":\\n\";\n\n        typedef typename Indexes::template nth_index<\n                IndexNo\n        >::type::const_iterator const_iterator_t;\n\n        for (const_iterator_t it = persons.template get<IndexNo>().begin(),\n             iend = persons.template get<IndexNo>().end();\n             it != iend;\n             ++it)\n        {\n            const person& v = *it;\n            std::cout \n                << v.name_ << \", \" \n                << v.id_ << \", \" \n                << v.height_ << \", \" \n                << v.weight_ << '\\n'\n            ;\n        }\n\n        std::cout << '\\n';\n    }\n    ```", "```cpp\n        print<0>(persons);\n        print<1>(persons);\n        print<2>(persons);\n        print<3>(persons);\n    ```", "```cpp\n        assert(persons.get<1>().find(2)->name_ == \"Vasya Pupkin\");\n        assert(\n            persons.find(person(\n                77, \"Anton Polukhin\", 0, 0\n            )) != persons.end()\n        );\n\n        // Won' compile\n        //assert(persons.get<0>().find(\"John Snow\")->id_ == 1);\n    ```", "```cpp\n    0:\n    Anton Polukhin, 3, 182, 70\n    Antony Polukhin, 3, 183, 70\n    John Snow, 1, 185, 80\n    Vasya Pupkin, 2, 165, 60\n\n    1:\n    John Snow, 1, 185, 80\n    Vasya Pupkin, 2, 165, 60\n    Anton Polukhin, 3, 182, 70\n    Antony Polukhin, 3, 183, 70\n\n    2:\n    Vasya Pupkin, 2, 165, 60\n    Anton Polukhin, 3, 182, 70\n    Antony Polukhin, 3, 183, 70\n    John Snow, 1, 185, 80\n\n    3:\n    Vasya Pupkin, 2, 165, 60\n    Antony Polukhin, 3, 183, 70\n    Anton Polukhin, 3, 182, 70\n    John Snow, 1, 185, 80\n    ```", "```cpp\n  boost::multi_index::ordered_unique<\n    boost::multi_index::identity<person>\n  >\n```", "```cpp\n    boost::multi_index::hashed_non_unique<\n      boost::multi_index::member<\n         person, std::size_t, &person::id_\n      >\n    >\n```", "```cpp\n    typedef typename Indexes::template nth_index<\n            IndexNo\n    >::type::const_iterator const_iterator_t;\n```", "```cpp\n    typedef indexes_t::nth_index<0>::type::const_iterator const_iterator_t;\n```", "```cpp\n    for (const_iterator_t it = persons.template get<IndexNo>().begin(),\n         iend = persons.template get<IndexNo>().end();\n         it != iend;\n         ++it)\n    {\n        const person& v = *it;\n        // ...\n```", "```cpp\n    for (const_iterator_t it = persons.get<0>().begin(),\n         iend = persons.get<0>().end();\n         it != iend;\n         ++it)\n    {\n        const person& v = *it;\n        // ...\n```", "```cpp\n    #include <boost/pool/pool_alloc.hpp>\n    #include <boost/container/slist.hpp>\n    ```", "```cpp\n    typedef boost::fast_pool_allocator<int> allocator_t;\n    typedef boost::container::slist<int, allocator_t> slist_t;\n    ```", "```cpp\n    template <class ListT>\n    void test_lists() {\n        typedef ListT list_t;\n\n        // Inserting 1000000 zeros\n        list_t  list(1000000, 0);\n        for (int i = 0; i < 1000; ++i) {\n            list.insert(list.begin(), i);\n        }\n\n        // Searching for some value\n        typedef typename list_t::iterator iterator;\n        iterator it = std::find(list.begin(), list.end(), 777);\n        assert(it != list.end());\n\n        // Erasing some values\n        for (int i = 0; i < 100; ++i) {\n            list.pop_front();\n        }\n\n        // Iterator still valid and points to same value\n        assert(it != list.end());\n        assert(*it == 777);\n\n        // Inserting more values\n        for (int i = -100; i < 10; ++i) {\n            list.insert(list.begin(), i);\n        }\n\n        // Iterator still valid and points to same value\n        assert(it != list.end());\n        assert(*it == 777);\n\n        list_specific(list, it);\n    }\n    ```", "```cpp\n    void list_specific(slist_t& list, slist_t::iterator it) {\n        typedef slist_t::iterator iterator;\n\n        // Erasing element 776\n        assert( *(++iterator(it)) == 776);\n        assert(*it == 777);\n        list.erase_after(it);\n        assert(*it == 777);\n        assert( *(++iterator(it)) == 775);\n\n        // Freeing memory\n        boost::singleton_pool<\n            boost::pool_allocator_tag,\n            sizeof(int)\n        >::release_memory();\n    }\n\n    #include <list>\n    typedef std::list<int> stdlist_t;\n\n    void list_specific(stdlist_t& list, stdlist_t::iterator it) {\n        typedef stdlist_t::iterator iterator;\n\n        // Erasing element 776\n        ++it;\n        assert( *it == 776);\n        it = list.erase(it);\n        assert(*it == 775);\n    }\n    ```", "```cpp\n    boost::singleton_pool<\n        boost::pool_allocator_tag,\n        sizeof(int)\n    >::release_memory();\n```", "```cpp\n$TIME=\"Runtime=%E RAM=%MKB\" time ./slist_and_pool l\n\nstd::list: Runtime=0:00.05 RAM=32440KB\n\n$ TIME=\"Runtime=%E RAM=%MKB\" time ./slist_and_pool s\n\nslist_t:   Runtime=0:00.02 RAM=17564KB\n\n```", "```cpp\n    #include <boost/container/flat_set.hpp>\n    ```", "```cpp\n        boost::container::flat_set<int> set;\n    ```", "```cpp\n        set.reserve(4096);\n    ```", "```cpp\n        for (int i = 0; i < 4000; ++i) {\n            set.insert(i);\n        }\n    ```", "```cpp\n        // 5.1\n        assert(set.lower_bound(500) - set.lower_bound(100) == 400);\n\n        // 5.2\n        set.erase(0);\n\n        // 5.3\n        set.erase(5000);\n\n        // 5.4\n        assert(std::lower_bound(set.cbegin(), set.cend(), 900000) == set.cend());\n\n        // 5.5\n        assert(\n            set.lower_bound(100) + 400 \n            == \n            set.find(500)\n        );\n    ```"]