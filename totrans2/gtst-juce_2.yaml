- en: Chapter 2. Building User Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 构建用户界面
- en: 'This chapter covers the JUCE `Component` class, which is the main building
    block for creating a **Graphical User Interface** (**GUI**) in JUCE. In this chapter
    we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 JUCE 的 `Component` 类，这是在 JUCE 中创建 **图形用户界面**（**GUI**）的主要构建块。在本章中，我们将涵盖以下主题：
- en: Creating buttons, sliders, and other components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建按钮、滑块和其他组件
- en: 'Responding to user interaction and changes: broadcasters and listeners'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应用户交互和变化：广播器和监听器
- en: Using other component types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其他组件类型
- en: Specifying colors and using drawing operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定颜色和使用绘图操作
- en: By the end of this chapter, you will be able to create a basic GUI and perform
    fundamental drawing operations within a component. You will also have the skills
    required to design and build more complex interfaces.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够创建一个基本的 GUI 并在组件内执行基本的绘图操作。您还将具备设计和构建更复杂界面的技能。
- en: Creating buttons, sliders, and other components
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建按钮、滑块和其他组件
- en: 'The JUCE `Component` class is the base class that provides the facility to
    draw on the screen and intercept user interaction from pointing devices, touch-screen
    interaction, and keyboard input. The JUCE distribution includes a wide range of
    `Component` subclasses, many of which you may have encountered by exploring the
    JUCE Demo application in [Chapter 1](ch01.html "Chapter 1. Installing JUCE and
    the Introjucer Application"), *Installing JUCE and the Introjucer Application*.
    The JUCE coordinate system is hierarchical, starting at the computer''s screen
    (or screens) level. This is shown in the following diagram:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE 的 `Component` 类是提供在屏幕上绘制和拦截来自指针设备、触摸屏交互和键盘输入的用户交互的基础类。JUCE 发行版包括广泛的 `Component`
    子类，其中许多您可能在探索 [第一章](ch01.html "第一章 安装 JUCE 和 Introjucer 应用程序") 中的 JUCE 示例应用程序时已经遇到，*安装
    JUCE 和 Introjucer 应用程序*。JUCE 坐标系统是分层的，从计算机屏幕（或屏幕）级别开始。以下图示展示了这一点：
- en: '![Creating buttons, sliders, and other components](img/3316_02_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![创建按钮、滑块和其他组件](img/3316_02_01.jpg)'
- en: Each on-screen window contains a single **parent** component within which other
    **child** components (or **subcomponents**) are placed (each of which may contain
    further child components). The top-left of the computer screen is coordinate (0,
    0) with each top-left of the content of JUCE windows being at an offset from this.
    Each component then has its own local coordinates where its top-left starts at
    (0, 0) too.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个屏幕上的窗口包含一个 **父** 组件，其中放置了其他 **子** 组件（或 **子组件**）（每个可能包含进一步的子组件）。计算机屏幕的左上角坐标为（0，0），JUCE
    窗口内容的左上角都从这个坐标偏移。每个组件都有自己的局部坐标，其左上角也始于（0，0）。
- en: In most cases you will deal with the components' coordinates relative to their
    parent components, but JUCE provides simple mechanisms to convert these values
    to be relative to other components or the main screen (that is, global coordinates).
    Notice in the preceding diagram that a window's top-left position does not include
    the title bar area.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您将处理组件相对于其父组件的坐标，但 JUCE 提供了简单的机制将这些值转换为相对于其他组件或主屏幕（即全局坐标）。注意在前面的图中，窗口的左上角位置不包括标题栏区域。
- en: You will now create a simple JUCE application that includes some fundamental
    component types. As the code for this project is going to be quite simple, we
    will write all our code into the header file (`.h`). This is not recommended for
    real-world projects except for quite small classes (or where there are other good
    reasons), but this will keep all the code in one place as we go through it. Also,
    we will split up the code into the `.h` and `.cpp` files later in the chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您将创建一个简单的 JUCE 应用程序，其中包含一些基本组件类型。由于这个项目的代码将会非常简单，我们将所有代码都写入头文件（`.h`）。这虽然在现实世界的项目中并不推荐，除非是相当小的类（或者有其他很好的理由），但这样可以将所有代码放在一个地方，便于我们进行操作。此外，我们将在本章的后面将代码拆分为
    `.h` 和 `.cpp` 文件。
- en: 'Create a new JUCE project using the Introjucer application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Introjucer 应用程序创建一个新的 JUCE 项目：
- en: Choose menu item **File** | **New Project…**
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择菜单项 **文件** | **新建项目…**
- en: Select **Create a Main.cpp file and a basic window** from the **Files to Auto-Generate**
    menu.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **自动生成文件** 菜单中选择 **创建 Main.cpp 文件和一个基本窗口**。
- en: Choose where to save the project and name it `Chapter02_01`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择保存项目的地方，并将其命名为 `Chapter02_01`。
- en: Click on the **Create…** button
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建…** 按钮
- en: Navigate to the **Files** panel.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **文件** 面板。
- en: Right-click on the file `MainComponent.cpp`, choose **Delete** from the contextual
    menu, and confirm.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击文件`MainComponent.cpp`，从上下文菜单中选择**删除**，并确认。
- en: Choose menu item **File** | **Save Project**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择菜单项**文件** | **保存项目**。
- en: Open the project in your **Integrated Development Environment** (**IDE**), either
    Xcode or Visual Studio.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的**集成开发环境**（**IDE**）中打开项目，无论是Xcode还是Visual Studio。
- en: 'Navigate to the `MainComponent.h` file in your IDE. The most important part
    of this file should look similar to this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的IDE中导航到`MainComponent.h`文件。此文件最重要的部分应该看起来类似于以下内容：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, we have removed the actual code from the autogenerated project by
    removing the `.cpp` file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们已经通过删除`.cpp`文件从自动生成项目中移除了实际代码。
- en: 'First let''s make an empty window. We will remove some of the elements to simplify
    the code and add a function body for the constructor. Change the declaration of
    the `MainContentComponent` class shown as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个空窗口。我们将删除一些元素以简化代码，并为构造函数添加一个函数体。将`MainContentComponent`类的声明更改如下：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Build and run the application, there should be an empty window named **MainWindow**
    in the center of the screen. Our JUCE application will create a window and place
    an instance of our `MainContentComponent` class as its content (that is, excluding
    the title bar). Notice our `MainContentComponent` class inherits from the `Component`
    class and therefore has access to a range of functions implemented by the `Component`
    class. The first of these is the `setSize()` function, which sets the width and
    height of our component.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，屏幕中央应该有一个名为**MainWindow**的空窗口。我们的JUCE应用程序将创建一个窗口，并将我们的`MainContentComponent`类的实例作为其内容（即不包括标题栏）。注意我们的`MainContentComponent`类继承自`Component`类，因此可以访问`Component`类实现的一系列函数。其中第一个是`setSize()`函数，它设置我们组件的宽度和高度。
- en: Adding child components
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加子组件
- en: 'Building user interfaces using components generally involves combining other
    components to produce composite user interfaces. The easiest way to do this is
    to include member variables in which to store the **child** components in the
    **parent** component class. For each child component that we wish to add, there
    are five basic steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件构建用户界面通常涉及组合其他组件以生成复合用户界面。这样做最简单的方法是在父组件类中包含成员变量，用于存储**子**组件。对于我们要添加的每个子组件，有五个基本步骤：
- en: Creating a member variable in which to store the new component.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个成员变量以存储新组件。
- en: Allocating a new component (either using static or dynamic memory allocation).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个新的组件（无论是使用静态还是动态内存分配）。
- en: Adding the component as a child of the parent component.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件添加为父组件的子组件。
- en: Making the child component visible.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使子组件可见。
- en: Setting the child component's size and position within the parent component.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置子组件在父组件中的大小和位置。
- en: 'First, we will create a button; change the code shown as follows. The preceding
    numbered steps are illustrated in the code comments:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个按钮；将代码更改为如下。前面的编号步骤在代码注释中说明：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The important parts of the preceding code are:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的重要部分是：
- en: An instance of the JUCE `TextButton` class was added to the `private` section
    of our class. This button will be statically allocated.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在类的`private`部分添加了一个JUCE `TextButton`类的实例。此按钮将被静态分配。
- en: The button is initialized in the constructor's initializer list using a string
    that sets the text that will appear on the button.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮在构造函数的初始化列表中使用一个字符串初始化，该字符串设置将在按钮上显示的文本。
- en: A call to the component function `addAndMakeVisible()` is passed as a pointer
    to our button instance. This adds the child component to the parent component
    hierarchy and makes the component visible on screen.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对组件函数`addAndMakeVisible()`的调用作为按钮实例的指针传递。这会将子组件添加到父组件层次结构中，并在屏幕上使组件可见。
- en: 'The component function `resized()` is overridden to position our button with
    an inset of 10 pixels within the parent component (this is achieved by using component
    functions `getWidth()` and `getHeight()` to discover the size of the parent component).
    This call to the `resized()` function is triggered when the parent component is
    resized, which in this case happens when we call the `setSize()` function in the
    constructor. The arguments to the `setSize()` function are in the order: width
    and height. The arguments to the `setBounds()` function are in the order: left,
    top, width, and height.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件函数 `resized()` 被重写以在父组件内部定位我们的按钮，距离边缘10像素（这是通过使用组件函数 `getWidth()` 和 `getHeight()`
    来发现父组件的大小实现的）。当父组件被调整大小时，会触发对 `resized()` 函数的调用，在这种情况下，当我们在构造函数中调用 `setSize()`
    函数时发生。`setSize()` 函数的参数顺序是：宽度然后是高度。`setBounds()` 函数的参数顺序是：左、上、宽度和高度。
- en: Build and run the application. Notice that the button responds as the mouse
    pointer hovers over the button and when the button is clicked, although the button
    doesn't yet do anything.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。注意按钮在鼠标指针悬停时响应，并且在按钮被点击时，尽管按钮还没有做任何事情。
- en: 'Generally, this is the most convenient method of positioning and resizing child
    components, even though in this example we could have easily set all the sizes
    in the constructor. The real power of this technique is illustrated when the parent
    component becomes resizable. The easiest way to do that here is to enable the
    resizing of the window itself. To do this, navigate to the `Main.cpp` file (which
    contains the boilerplate code to set up the basic application) and add the following
    highlighted line to the `MainWindow` constructor:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是定位和调整子组件大小最方便的方法，尽管在这个例子中我们可以在构造函数中轻松设置所有大小。这项技术的真正威力在于父组件变得可调整大小时。在这里，最简单的方法是启用窗口本身的调整大小。为此，导航到
    `Main.cpp` 文件（其中包含设置基本应用程序的样板代码）并将以下突出显示的行添加到 `MainWindow` 构造函数中：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Build and run the application and notice that the window now has a corner resizer
    in the bottom-right. The important thing here is that the button automatically
    resizes as the window size changes due to the way we implemented this above. In
    the call to the `setResizable()` function, the first argument sets whether the
    window is resizable and the second argument sets whether this is via a corner
    resizer (`true`) or allowing the border of the window to be dragged to resize
    the window (`false`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，注意窗口现在在右下角有一个角落调整大小控件。这里重要的是按钮会随着窗口大小的变化而自动调整大小，这是由于我们上面实现的方式。在调用
    `setResizable()` 函数时，第一个参数设置窗口是否可调整大小，第二个参数设置这是否通过角落调整大小控件（`true`）或允许拖动窗口边框来调整窗口大小（`false`）。
- en: Child components may be positioned proportionally rather than with absolute
    or offset values. One way of achieving this is through the `setBoundsRelative()`
    function. In the following example you will add a slider control and a label to
    the component.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 子组件可以按比例定位，而不是使用绝对值或偏移值。实现这一点的其中一种方法是通过 `setBoundsRelative()` 函数。在以下示例中，你将在组件中添加一个滑动控件和一个标签。
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, each child component is 90 percent of the width of the parent
    component and positioned five percent of the parent''s width from the left. Each
    child component is 25 percent of the height of the parent, and the three components
    are distributed top to bottom with the button five percent of the parent''s height
    from the top. Build and run the application, and notice that resizing the window
    automatically and smoothly, updates the sizes and position of the child components.
    The window should look similar to the following screenshot. In the next section
    you will intercept and respond to user interaction:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个子组件的宽度是父组件宽度的90%，并且从左边开始定位在父组件宽度的5%。每个子组件的高度是父组件高度的25%，三个组件从上到下分布，按钮从顶部开始距离父组件高度的5%。构建并运行应用程序，注意窗口自动且平滑地调整大小，更新子组件的大小和位置。窗口应类似于以下截图。在下一节中，你将拦截并响应用户交互：
- en: '![Adding child components](img/3316_02_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![添加子组件](img/3316_02_02.jpg)'
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册以直接将文件通过电子邮件发送给您。
- en: Responding to user interaction and changes
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应用户交互和变化
- en: 'Create a new Introjucer project named `Chapter02_02` with a basic window; this
    time retain all of the auto-generated files. We will now split the code from the
    previous section into the `MainComponent.h` and `MainComponent.cpp` files. The
    `MainComponent.h` file should look as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter02_02` 的新 Introjucer 项目，包含一个基本窗口；这次保留所有自动生成的文件。现在，我们将上一节中的代码拆分为
    `MainComponent.h` 和 `MainComponent.cpp` 文件。`MainComponent.h` 文件应如下所示：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `MainComponent.cpp` file should look as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainComponent.cpp` 文件应如下所示：'
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Broadcasters and listeners
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广播器和监听器
- en: 'Although the `Slider` class already contains a text box that displays the slider''s
    value, it will be useful to examine how this communication works within JUCE.
    In the next example we will:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然滑块类已经包含一个显示滑块值的文本框，但检查这种通信如何在 JUCE 中工作将是有用的。在下一个示例中，我们将：
- en: Remove the text box from the slider
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从滑块中移除文本框
- en: Make the slider's value appear in the label
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使滑块的值出现在标签中
- en: Enable the slider to be zeroed by clicking on the button
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击按钮使滑块能够归零
- en: 'To achieve this, JUCE uses the **observer** pattern widely throughout the library
    to enable objects to communicate. In particular, the `Component` class and the
    `Component` subclasses use this to notify your code when a user interface item
    has been clicked, their content has been changed, and so on. In JUCE, these are
    generally known as **listeners** (the observers) and **broadcasters** (the subjects
    of the observers). JUCE also makes extensive use of multiple inheritance. One
    area in JUCE where multiple inheritance is particularly useful is through the
    use of the broadcaster and listener systems. Generally, a JUCE class that supports
    broadcasting its state changes has a nested class called `Listener`. Thus, the
    `Slider` class has the `Slider::Listener` class and the `Label` class has the
    `Label::Listener` class. (These are often represented by classes with similar
    names to help support older IDEs, for example, `SliderListener` and `LabelListener`
    are equivalent.) The `TextButton` class is in fact a subclass of the more generic
    `Button` class; therefore, its listener class is `Button::Listener`. Each of these
    listener classes will contain a declaration of at least one **pure virtual function**
    . This will require our derived class to implement these functions. Listener classes
    may contain other regular virtual functions, meaning they may be implemented optionally.
    To implement these functions, first add listener classes for the button and slider
    as public base classes of our `MainContentComponent` class in the `MainComponent.h`
    file shown as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，JUCE 在整个库中广泛使用 **观察者** 模式，以使对象能够进行通信。特别是，`Component` 类及其子类使用它来通知您的代码当用户界面项被点击、内容发生变化等情况。在
    JUCE 中，这些通常被称为 **监听器**（观察者）和 **广播器**（观察者的主题）。JUCE 还大量使用多重继承。在 JUCE 中，多重继承特别有用的一处是通过使用广播器和监听器系统。通常，支持广播其状态变化的
    JUCE 类有一个嵌套类称为 `Listener`。因此，`Slider` 类有 `Slider::Listener` 类，而 `Label` 类有 `Label::Listener`
    类。（这些通常通过具有类似名称的类来表示，以帮助支持旧 IDE，例如，`SliderListener` 和 `LabelListener` 是等效的。）`TextButton`
    类实际上是更通用的 `Button` 类的子类；因此，其监听器类是 `Button::Listener`。每个这些监听器类都将包含至少一个 **纯虚函数**
    的声明。这将要求我们的派生类实现这些函数。监听器类可能包含其他常规虚函数，这意味着它们可以可选实现。要实现这些函数，首先在 `MainComponent.h`
    文件中将按钮和滑块的监听器类作为 `MainContentComponent` 类的公共基类添加，如下所示：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Each of our user interface listeners here requires us to implement one function
    to respond to its changes. These are the `buttonClicked()` and `sliderValueChanged()`
    functions. Add these to the `public` section of our class declaration:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里的每个用户界面监听器都需要我们实现一个函数来响应其变化。这些是 `buttonClicked()` 和 `sliderValueChanged()`
    函数。将这些函数添加到我们的类声明中的 `public` 部分：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The full listing to use for the `MainComponent.cpp` file is shown as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 `MainComponent.cpp` 文件的完整列表如下所示：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The two calls to add the listeners using the `addListener()` function, pass
    the `this` pointer (a pointer to our `MainContentComponent` instance). This adds
    our `MainContentComponent` instance as a listener to both the slider and the button
    respectively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`addListener()`函数添加监听器的两次调用，传递`this`指针（指向我们的`MainContentComponent`实例的指针）。这会将我们的`MainContentComponent`实例分别作为监听器添加到滑块和按钮。
- en: 'Although there is only one instance of each type of component, the preceding
    example shows the recommend way to check which component broadcasted a change,
    in cases where there may be many similar components (such as banks of buttons
    or sliders). This technique is to check the value of the pointer received by the
    listener function and whether this matches the address of one of the member variables.
    There is one thing to note on the coding style here. You may prefer to write the
    `if()` statement with the arguments swapped over as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每种类型的组件只有一个实例，但前面的示例展示了在可能存在许多类似组件（如按钮组或滑块）的情况下，检查哪个组件广播了更改的推荐方法。这种技术是检查监听函数收到的指针值，并判断它是否与某个成员变量的地址匹配。在此处编码风格上有一点需要注意。你可能更喜欢将`if()`语句的参数交换过来，如下所示：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: However, the style used throughout this book is employed to cause a deliberate
    compiler error if you mistype the "`==`" operator as a single "`=`" character.
    This should help avoid bugs that might be introduced by this mistake.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本书中使用的样式是为了在错误地将"`==`"运算符误写为单个"`=`"字符时产生故意的编译器错误。这应该有助于避免由这种错误引入的bug。
- en: Components that store some kind of value such as sliders and labels may, of
    course, have their state set programmatically. In this case, you can control whether
    its listeners are notified of the change or not (you can also customize whether
    this is transmitted **synchronously** or **asynchronously**). This is the purpose
    of the `sendNotification` value (which is an enumerated constant) in the calls
    to the `Slider::setValue()` and `Label::setText()` functions as in the preceding
    code snippet. Also, you should notice that the call to the `Slider::setValue()`
    function in the constructor is made *after* the class has been registered as a
    listener. This ensures that all the components are configured correctly from the
    start while minimizing the duplication of code. This code makes use of the `String`
    class to pass text to the label, to convert text to numerical values, and vice
    versa. The `String` class will be explored in more detail in the next chapter,
    but for now, we will limit the usage of the `String` class to these basic operations.
    The text box is removed from the slider by initializing the slider in the initializer
    list with a slider style and text box style. In this case, the initializer `slider1
    (Slider::LinearHorizontal`, `Slider::NoTextBox)` specifies a horizontal slider
    and that no text box should be attached.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 存储某种类型值（如滑块和标签）的组件当然可以以编程方式设置其状态。在这种情况下，你可以控制其监听器是否通知更改（你也可以自定义这是**同步**还是**异步**传输）。这是`sendNotification`值（一个枚举常量）在调用`Slider::setValue()`和`Label::setText()`函数（如前面的代码片段所示）中的目的。此外，你应该注意到在构造函数中对`Slider::setValue()`函数的调用是在类注册为监听器之后进行的。这确保了所有组件从开始就配置正确，同时最大限度地减少了代码的重复。此代码使用`String`类将文本传递给标签，将文本转换为数值，反之亦然。`String`类将在下一章中更详细地探讨，但到目前为止，我们将限制`String`类的使用仅限于这些基本操作。通过在初始化列表中使用滑块样式和文本框样式初始化滑块，从滑块中移除文本框。在这种情况下，初始化器`slider1
    (Slider::LinearHorizontal, Slider::NoTextBox)`指定了一个水平滑块，并且不应附加文本框。
- en: 'Finally, should we want to set the value of the slider to something specific;
    we can make the label editable and transmit any changes typed into the label to
    the slider. Make another new Introjucer project and name it `Chapter02_03`. Add
    the `Label::Listener` class to the base classes of our `MainContentComponent`
    class in the header file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们想将滑块的值设置为特定值，我们可以使标签可编辑，并将输入到标签中的任何更改传输到滑块。创建一个新的Introjucer项目，并将其命名为`Chapter02_03`。在头文件中将`Label::Listener`类添加到我们的`MainContentComponent`类的基类中：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the `Label::Listener` function that responds to the label changes, also
    in the header file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中添加响应标签变化的`Label::Listener`函数：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Update the constructor in the `MainComponent.cpp` file to further configure
    the label:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`MainComponent.cpp`文件中的构造函数以进一步配置标签：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, the label is set to be editable with a single click and our class registers
    itself as a listener for the label. Lastly, add the implementation for the `labelTextChanged()`
    function to the `MainComponent.cpp` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，标签被设置为单次点击可编辑，并且我们的类将自己注册为标签的监听器。最后，将 `labelTextChanged()` 函数的实现添加到 `MainComponent.cpp`
    文件中：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Build and run the application to test this functionality. There are some problems:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序以测试此功能。存在一些问题：
- en: The slider correctly clips values typed into the label that are outside the
    range of the slider, but the text in the label still remains if these values are
    outside the range
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑块正确地剪辑了输入到标签中的超出滑块范围的值，但如果这些值超出范围，标签中的文本仍然保留
- en: The label allows non-numerical characters to be typed in (although these are
    usefully resolved to zero)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签允许输入非数值字符（尽管这些字符被有用地解析为零）
- en: Filtering data entry
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤数据输入
- en: 'The first issue mentioned above is straightforward, and this is to convert
    the slider''s value back to text and use this to set the label content. This time
    we use the `dontSendNotification` value, because we want to avoid an infinite
    loop whereby each component would broadcast a message that causes a change that
    would in turn cause a message to be broadcasted and so on:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述提到的问题之一是直接的，那就是将滑块的值转换回文本，并使用这个文本来设置标签内容。这次我们使用 `dontSendNotification` 值，因为我们想避免无限循环，其中每个组件都会广播一个消息，导致变化，进而导致消息被广播，如此循环：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The second issue requires a filter to allow only certain characters. Here,
    you need access to the label''s internal `TextEditor` object. To do this, you
    could create a custom label class by inheriting from the `Label` class and implementing
    the `editorShown()` virtual function. Add this small class to the `MainComponent.h`
    file above the `MainContentComponent` class declaration (although to reuse this
    class across a number of components in your application, it may be better to place
    this code in a separate file):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题需要一个过滤器来只允许某些字符。在这里，你需要访问标签的内部 `TextEditor` 对象。为此，你可以通过从 `Label` 类继承并实现
    `editorShown()` 虚拟函数来创建一个自定义的标签类。将这个小的类添加到 `MainComponent.h` 文件中，在 `MainContentComponent`
    类声明之上（虽然为了在应用程序中的多个组件中重用这个类，可能将此代码放在一个单独的文件中会更好）：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Because the text editor is just about to be shown, this function is called
    by the label, and at that point you can set the text editor''s input restrictions
    using its `setInputRestrictions()` function. The two arguments are: length and
    allowable characters. The zero length means there is no restriction on length
    and the allowable characters in this case include all the digits, the minus sign
    and the period. (In fact you could omit the minus sign to disallow negative numbers
    and omit the period if you wanted to allow integer values only.) To use this class
    in place of the built-in `Label` class simply replace this class name in the member
    variable list for our `MainContentComponent` class as shown highlighted:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因为文本编辑器即将显示，这个功能是通过标签调用的，在那个时刻你可以使用文本编辑器的 `setInputRestrictions()` 函数来设置文本编辑器的输入限制。这两个参数是：长度和允许的字符。零长度表示没有长度限制，在这种情况下允许的字符包括所有数字、负号和点号。（实际上，你可以省略负号以禁止负数，如果你想只允许整数，可以省略点号。）要使用这个类代替内置的
    `Label` 类，只需在我们的 `MainContentComponent` 类的成员变量列表中替换这个类名，如下所示，高亮显示：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Hopefully, by this point you can see that JUCE classes provide a useful range
    of core functionality while allowing customizations with relative ease.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到这一点，你能够看出 JUCE 类提供了一系列有用的核心功能，同时允许相对容易地进行自定义。
- en: Using other component types
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他组件类型
- en: 'There are many other built-in component types and variations on the sliders
    and buttons already seen. In the previous section we used the default horizontal
    slider, but the `Slider` class is very flexible, as illustrated by the Widget
    demo page of the JUCE Demo application. The sliders can adopt a rotary-type control,
    have minimum and maximum ranges, and warp the numerical track to adopt non-linear
    behavior. Similarly, buttons can adopt different styles such as toggle buttons,
    buttons that use images, and so on. The following example illustrates a toggle-type
    button that changes the style of two sliders. Create a new Introjucer project
    named `Chapter02_04`, and use the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经看到的滑块和按钮之外，还有很多其他的内置组件类型和变体。在前一节中，我们使用了默认的水平滑块，但`Slider`类非常灵活，正如JUCE演示应用程序的Widget演示页面所示。滑块可以采用旋转式控制，具有最小和最大范围，并且可以扭曲数值轨迹以采用非线性行为。同样，按钮可以采用不同的样式，例如切换按钮、使用图像的按钮等。以下示例说明了更改两个滑块样式的切换类型按钮。创建一个新的Introjucer项目，命名为`Chapter02_04`，并使用以下代码：
- en: '**MainComponent.h**:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MainComponent.h**:'
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**MainComponent.cpp**:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MainComponent.cpp**:'
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This example uses a `ToggleButton` object and checks its toggle state in the
    `buttonClicked()` function using the `getToggleState()` function. One obvious
    customization yet to be discussed is changing the colors of the various elements
    within the built-in components. This will be covered in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用`ToggleButton`对象，并在`buttonClicked()`函数中使用`getToggleState()`函数检查其切换状态。尚未讨论的一个明显的自定义选项是更改内置组件内部各种元素的颜色。这将在下一节中介绍。
- en: Specifying colors
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定颜色
- en: 'Colors in JUCE are handled by the `Colour` and `Colours` classes (*note the
    British spelling of these two class names*):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE中的颜色由`Colour`和`Colours`类处理（*注意这两个类名的英国拼写*）：
- en: The `Colour` class stores a 32-bit color with 8-bit alpha, red, green, and blue
    values (**ARGB**). A `Colour` object may be initialized from other formats (for
    example, using floating point values, or values in the **HSV** format).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Colour`类存储一个32位颜色，具有8位alpha、红色、绿色和蓝色值（**ARGB**）。一个`Colour`对象可以从其他格式初始化（例如，使用浮点值或**HSV**格式的值）。'
- en: The `Colour` class includes a number of utilities for creating new colors from
    existing ones, for example, by modifying the alpha channel, changing only the
    brightness or finding a suitable contrasting color.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Colour`类包括从现有颜色创建新颜色的许多实用工具，例如，通过修改alpha通道、仅更改亮度或找到合适的对比颜色。'
- en: The `Colours` class is a collection of static `Colour` instances (for example,
    `Colour::red`, `Colour::cyan`). These are based broadly on the naming scheme of
    colors in the **HyperText Markup Language** (**HTML**) standard.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Colours`类是一组静态`Colour`实例的集合（例如，`Colour::red`，`Colour::cyan`）。这些基于**超文本标记语言**（**HTML**）标准中的颜色命名方案。'
- en: 'For example, the following code snippet illustrates several different ways
    of creating the same "red" color:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段说明了创建相同“红色”颜色的几种不同方法：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Component classes employ an ID system to refer to the various colors they use
    for different purposes (background, border, text, and so on). To use these colors
    to change the appearance of a component, the `Component::setColour()` function
    is used:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 组件类使用ID系统来引用它们用于不同目的的各种颜色（背景、边框、文本等）。要使用这些颜色来更改组件的外观，请使用`Component::setColour()`函数：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For example, to change the color of a slider''s thumb (which is the draggable
    part), the ID is the `Slider::thumbColourId` constant (this too changes the fill
    color that represents the slider''s value when the slider style is set to the
    `Slider::LinearBar` constant). You can test this in the `Chapter02_04` project
    by adding the following highlighted lines to the constructor:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要更改滑块的拇指颜色（即可拖动的部分），ID是`Slider::thumbColourId`常量（这也改变了当滑块样式设置为`Slider::LinearBar`常量时表示滑块值的填充颜色）。您可以在`Chapter02_04`项目中通过在构造函数中添加以下突出显示的行来测试此功能：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The final look of this application showing both types of slider is shown in
    the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此应用程序的最终外观，显示了两种类型的滑块：
- en: '![Specifying colors](img/3316_02_03.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![指定颜色](img/3316_02_03.jpg)'
- en: Component color IDs
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件颜色ID
- en: 'Many built-in components define their own color ID constants; the most useful
    are:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 许多内置组件定义了自己的颜色ID常量；最有用的是：
- en: '`Slider::backgroundColourId`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slider::backgroundColourId`'
- en: '`Slider::thumbColourId`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slider::thumbColourId`'
- en: '`Slider::trackColourId`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slider::trackColourId`'
- en: '`Slider::rotarySliderFillColourId`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slider::rotarySliderFillColourId`'
- en: '`Slider::rotarySliderOutlineColourId`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slider::rotarySliderOutlineColourId`'
- en: '`Slider::textBoxTextColourId`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slider::textBoxTextColourId`'
- en: '`Slider::textBoxBackgroundColourId`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slider::textBoxBackgroundColourId`'
- en: '`Slider::textBoxHighlightColourId`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slider::textBoxHighlightColourId`'
- en: '`Slider::textBoxOutlineColourId`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slider::textBoxOutlineColourId`'
- en: '`Label::backgroundColourId`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Label::backgroundColourId`'
- en: '`Label::textColourId`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Label::textColourId`'
- en: '`Label::outlineColourId`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Label::outlineColourId`'
- en: '`ToggleButton::textColourId`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToggleButton::textColourId`'
- en: '`TextButton::buttonColourId`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextButton::buttonColourId`'
- en: '`TextButton::buttonOnColourId`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextButton::buttonOnColourId`'
- en: '`TextButton::textColourOffId`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextButton::textColourOffId`'
- en: '`TextButton::textColourOnId`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextButton::textColourOnId`'
- en: Each of these enumerated constants is defined in the class in which they are
    used. There are many others for each of the component types.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些枚举常量在每个它们被使用的类中定义。对于每种组件类型，还有很多其他的。
- en: Setting colors using the LookAndFeel class
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LookAndFeel类设置颜色
- en: 'If you have many controls and want to set unified colors for all of them, then
    it is likely to be more convenient to set the color at some other point in the
    component hierarchy. This is one purpose of the JUCE `LookAndFeel` class. This
    was seen briefly in [Chapter 1](ch01.html "Chapter 1. Installing JUCE and the
    Introjucer Application"), *Installing JUCE and the Introjucer Application* where
    the different styles of the various widgets can be selected by using a different
    look and feel. If this is to be a global change across the whole application then
    the best place to put this change is likely to be in the initialization code.
    To try this, remove the following two lines of code from your project, which were
    added in the previous step:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多控件并且想要为它们设置统一的颜色，那么在组件层次结构中的其他某个点设置颜色可能更方便。这是JUCE `LookAndFeel`类的一个目的。这在[第1章](ch01.html
    "第1章。安装JUCE和Introjucer应用程序")中简要提到，*安装JUCE和Introjucer应用程序*，其中可以通过使用不同的外观和感觉来选择各种小部件的不同样式。如果这要在整个应用程序中进行全局更改，那么最佳位置可能是在初始化代码中放置此更改。为了尝试这样做，从你的项目中删除以下两行代码，这些代码是在上一步中添加的：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Navigate to the `Main.cpp` file. Now add the following lines to the `initialise()`
    function (*again notice the British spelling*).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`Main.cpp`文件。现在将以下行添加到`initialise()`函数中（*再次注意英国拼写*）。
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It should be clear that an extended list of colors could be configured at this
    point to customize the application''s appearance. Another technique, that again
    uses the `LookAndFeel` class, is to inherit from the default `LookAndFeel` class
    and update colors in this derived class. Setting a particular look and feel for
    a component affects all child components in its hierarchy. Therefore, this method
    would allow you to set colors selectively in different parts of an application.
    A solution that uses this method is shown as follows, with the important parts
    highlighted:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很明显，此时可以配置一个扩展的颜色列表来定制应用程序的外观。另一种技术，同样使用`LookAndFeel`类，是从默认的`LookAndFeel`类继承并更新这个派生类中的颜色。为组件设置特定的外观和感觉会影响其层次结构中的所有子组件。因此，这种方法将允许你在应用程序的不同部分有选择地设置颜色。以下是一个使用此方法的解决方案示例，其中重要的部分被突出显示：
- en: '**The MainComponent.h file**:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**主组件头文件**：'
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `MainComponent.cpp` file only the constructor needs updating:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainComponent.cpp`文件中，只需更新构造函数：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we create a nested class `AltLookAndFeel` that is based on the default
    `LookAndFeel` class. This is defined as a nested class, because we need to only
    refer to it from within a `MainContentComponent` instance. It might be more appropriate
    to define this class outside the `MainContentComponent` class if the `AltLookAndFeel`
    becomes a more extended class or needs to be reused by other component classes
    that we write.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个基于默认`LookAndFeel`类的嵌套类`AltLookAndFeel`。这是因为我们只需要从`MainContentComponent`实例内部引用它。如果`AltLookAndFeel`成为一个更广泛的类或者需要被我们编写的其他组件类重用，那么在`MainContentComponent`类外部定义这个类可能更合适。
- en: In the `AltLookAndFeel` constructor, we set the color of the slider thumb. Finally,
    we set the look and feel for the `MainContentComponent` class in its constructor.
    There are clearly many other possible techniques using this handful of tools,
    and the exact approach is heavily dependent on the specific application features
    being developed. It is important to note that the `LookAndFeel` class not only
    deals with colors, but also more broadly enables you to configure the exact way
    in which certain user interface elements are drawn. Not only can you change the
    color of the slider thumb, you can change its radius (by overriding the `LookAndFeel::getSliderThumbRadius()`
    function) or even change its shape altogether (by overriding the `LookAndFeel::drawLinearSliderThumb()`
    function).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AltLookAndFeel`构造函数中，我们设置了滑块的拇指颜色。最后，我们在其构造函数中为`MainContentComponent`类设置了外观和感觉。显然，使用这少量工具还有许多其他可能的技巧，而且具体的方法很大程度上取决于正在开发的具体应用程序功能。需要注意的是，`LookAndFeel`类不仅处理颜色，而且更广泛地允许你配置某些用户界面元素绘制的确切方式。你不仅可以更改滑块的拇指颜色，还可以通过重写`LookAndFeel::getSliderThumbRadius()`函数来更改其半径，或者甚至完全更改其形状（通过重写`LookAndFeel::drawLinearSliderThumb()`函数）。
- en: Using drawing operations
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用绘图操作
- en: Although it is advisable to use the built-in components if possible, there are
    occasions where you may need or wish to create a completely new custom component.
    This may be to perform some specific drawing tasks or a unique user interface
    item. JUCE also handles this elegantly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在可能的情况下使用内置组件是明智的，但有时你可能需要或希望创建一个全新的自定义组件。这可能是为了执行某些特定的绘图任务或独特的用户界面项目。JUCE也优雅地处理了这一点。
- en: 'First, create a new Introjucer project and name it `Chapter02_05`. To perform
    drawing tasks in a component, you should override the `Component::paint()` function.
    Change the contents of the `MainComponent.h` file to:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的Introjucer项目，并将其命名为`Chapter02_05`。要在组件中执行绘图任务，你应该重写`Component::paint()`函数。将`MainComponent.h`文件的内容更改为：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Change the contents of the `MainComponent.cpp` file to:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MainComponent.cpp`文件的内容更改为：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Build and run the application to see the resulting empty window filled with
    a blue color.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，以查看结果为蓝色的空窗口。
- en: 'The `paint()` function is called when the component needs to redraw itself.
    This might be due to the component having been resized (which of course you can
    try out using the corner resizer), or specific calls to invalidate the display
    (for example, the component displays visual representation of a value and this
    is no longer the currently stored value). The `paint()` function is passed a reference
    to a `Graphics` object. It is this `Graphics` object that you instruct to perform
    your drawing tasks. The `Graphics::fillAll()` function used in the code above
    should be self-explanatory: it fills the entire component with the specified color.
    The `Graphics` object can draw rectangles, ellipses, rounded rectangles, lines
    (in various styles), curves, text (with numerous shortcuts for fitting or truncating
    text within particular areas) and images.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件需要重新绘制自身时，会调用`paint()`函数。这可能是因为组件已被调整大小（当然，你可以通过角调整器尝试），或者对无效化显示的特定调用（例如，组件显示值的视觉表示，而这个值不再是当前存储的值）。`paint()`函数传递一个对`Graphics`对象的引用。正是这个`Graphics`对象，你指示它执行你的绘图任务。上述代码中使用的`Graphics::fillAll()`函数应该是自解释的：它使用指定的颜色填充整个组件。`Graphics`对象可以绘制矩形、椭圆、圆角矩形、线条（以各种样式）、曲线、文本（具有在特定区域内适应或截断文本的多个快捷方式）和图像。
- en: 'The next example illustrates drawing a collection of random rectangles using
    random colors. Change the `paint()` function in the `MainComponent.cpp` file to:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例说明了使用随机颜色绘制一组随机矩形的操作。将`MainComponent.cpp`文件中的`paint()`函数更改为：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This makes use of multiple calls to the JUCE random number generator class `Random`.
    This is a convenient class that allows the generation of pseudo-random integers
    and floating-point numbers. You can make your own instance of a `Random` object
    (which is recommend if your application uses random numbers in multiple threads),
    but here we simply take a copy of a reference to a global "system" `Random` object
    (using the `Random::getSystemRandom()` function) and use it multiple times. Here,
    we fill the component with a blue background and generate 20 rectangles. The color
    is generated from randomly generated floating point ARGB values. The call to the
    `Graphics::setColour()` function sets the current drawing color that will be employed
    by subsequent drawing commands. A randomly generated rectangle is also created
    by first choosing width and height (each being a maximum value of one-quarter
    of the parent component's width and height respectively). Then the position of
    the rectangle is randomly selected; again this is done using the parent component's
    width and height but this time subtracting the width and height of our random
    rectangle to ensure its right and bottom edges are not off-screen. As mentioned
    previously, the `paint()` function is called each time the component needs to
    be redrawn. This means we will get a completely new set of random rectangles as
    the component is resized.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这利用了JUCE随机数生成器类的多次调用`Random`。这是一个方便的类，允许生成伪随机整数和浮点数。你可以创建自己的`Random`对象实例（如果你的应用程序在多个线程中使用随机数，则建议这样做），但在这里我们只是复制一个全局“系统”`Random`对象的引用（使用`Random::getSystemRandom()`函数）并多次使用它。在这里，我们用蓝色背景填充组件并生成20个矩形。颜色是从随机生成的浮点ARGB值生成的。调用`Graphics::setColour()`函数设置后续绘图命令将使用的当前绘图颜色。通过首先选择宽度和高度（每个都是父组件宽度和高度的1/4的最大值）来创建一个随机生成的矩形。然后随机选择矩形的位置；再次使用父组件的宽度和高度，但这次减去随机矩形的宽度和高度，以确保其右下角不在屏幕外。如前所述，每当组件需要重绘时都会调用`paint()`函数。这意味着当组件大小调整时，我们将得到一组全新的随机矩形。
- en: 'Changing the drawing command to `fillEllipse()` rather than `fillRect()` draws
    a collection of ellipses instead. Lines can be drawn in various ways. Change the
    `paint()` function as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将绘图命令更改为`fillEllipse()`而不是`fillRect()`将绘制一系列椭圆。线条可以以各种方式绘制。如下更改`paint()`函数：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Here, we choose a random line thickness (between one and six pixels wide)
    before the `for()` loop and use it for each line. The start and end positions
    of the lines are also randomly generated. To draw a continuous line there are
    a number of options, you could:**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**在这里，我们在`for()`循环之前选择一个随机的线宽（介于1到6像素之间），并用于每条线。线的起始和结束位置也是随机生成的。要绘制连续的线，有几种选择，你可以：**'
- en: '**store the last end point of the line and use this as the start point of the
    next line; or**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储线的最后一个端点并将其用作下一条线的起点；或者**'
- en: '**use a JUCE `Path` object to build a series of line drawing commands and draw
    the path in one pass.**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用JUCE `Path`对象构建一系列线条绘制命令，并在一次遍历中绘制路径。**'
- en: '**The first solution would be something like this:**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一种解决方案可能如下所示：**'
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**The second option is slightly different; in particular, each of the lines
    that make up the path must be same color:**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二种选项略有不同；特别是，构成路径的每条线都必须是相同的颜色：**'
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '****Here the path is created before the `for()` loop and each iteration of
    the loop adds a line segment to the path. These two approaches to line drawing
    clearly suit different applications. The path drawing technique is heavily customizable,
    in particular:****'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '****在这里，路径是在`for()`循环之前创建的，循环的每次迭代都会向路径添加一个线段。这两种线条绘制方法显然适用于不同的应用。路径绘制技术高度可定制，特别是：****'
- en: '****The joints at the corners of the line segments can be customized with the
    `PathStrokeType` class (for example, to make the corners slightly rounded).****'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****线段的角点可以使用`PathStrokeType`类进行自定义（例如，使角略微圆润）。****'
- en: '****The lines need not be straight: they can be Bezier curves.****'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****线条不一定是直的：它们可以是贝塞尔曲线。****'
- en: '****The path may include other fundamental shapes such as rectangles, ellipses,
    stars, arrows and so on.****'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****路径可能包括其他基本形状，如矩形、椭圆、星星、箭头等。****'
- en: '****In addition to these line drawing commands, there are accelerated functions
    specifically for drawing horizontal and vertical lines (that is, non-diagonal).
    These are the `Graphics::drawVerticalLine()` and `Graphics::drawHorizontalLine()`
    functions.****'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '****除了这些线绘制命令之外，还有专门用于绘制水平和垂直线（即非对角线）的加速函数。这些是`Graphics::drawVerticalLine()`和`Graphics::drawHorizontalLine()`函数。****'
- en: '****Intercepting mouse activity****'
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '****拦截鼠标活动****'
- en: '****To help your component respond to mouse interaction, the `Component` class
    has six important callback functions that you can override:****'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '****为了帮助您的组件响应用户的鼠标交互，`Component`类有六个重要的回调函数，您可以重写它们：****'
- en: '****`mouseEnter()`: Called when the mouse pointer enters the bounds of this
    component and the mouse buttons are *up*.****'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`mouseEnter()`: 当鼠标指针进入此组件的边界且鼠标按钮处于*抬起*状态时调用。****'
- en: '****`mouseMove()`: Called when the mouse pointer moves within the bounds of
    this component and the mouse buttons are *up*. A `mouseEnter()` callback will
    always have been received first.****'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`mouseMove()`: 当鼠标指针在此组件的边界内移动且鼠标按钮处于*抬起*状态时调用。`mouseEnter()`回调总是先被接收到。****'
- en: '****`mouseDown()`: Called when one or more mouse buttons are pressed while
    the mouse pointer is over this component. A `mouseEnter()` callback will always
    have been received first and it is highly likely one or more `mouseMove()` callbacks
    will have been received too.****'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`mouseDown()`: 当鼠标指针在此组件上方按下一个或多个鼠标按钮时调用。在调用`mouseEnter()`回调之前，总会先接收到一个回调，并且很可能还会接收到一个或多个`mouseMove()`回调。****'
- en: '****`mouseDrag()`: Called when the mouse pointer is moved following a `mouseDown()`
    callback on this component. The position of the mouse pointer may be outside the
    bounds of the component.****'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`mouseDrag()`: 当鼠标指针在`mouseDown()`回调后在此组件上移动时调用。鼠标指针的位置可能位于组件的边界之外。****'
- en: '****`mouseUp()`: Called when the mouse button is released following a `mouseDown()`
    callback on this component (the mouse pointer will not necessarily be over this
    component at this time).****'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`mouseUp()`: 当在`mouseDown()`回调后释放鼠标按钮时调用（此时鼠标指针不一定在组件上）。****'
- en: '****`mouseExit()`: Called when the mouse pointer leaves the bounds of this
    component when the mouse buttons are *up* and after a `mouseUp()` callback if
    the user has clicked on this component (even if the mouse pointer exited the bounds
    of this component some time ago).****'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`mouseExit()`: 当鼠标指针在鼠标按钮*抬起*状态下离开此组件的边界，并且在用户点击此组件后（即使鼠标指针在一段时间前已经离开了此组件的边界）接收到`mouseUp()`回调时调用。****'
- en: '****In each of these cases, the callbacks are passed a reference to a `MouseEvent`
    object that can provide information about the current state of the mouse (where
    it was at the time of the event, when the event occurred, which modifier keys
    on the keyboard were down, which mouse buttons were down, and so on). In fact,
    although these classes and function names refer to the "mouse" this system can
    handle multi-touch events and the `MouseEvent` object can be ask which "finger"
    was involved in such cases (for example, on the iOS platform).****'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '****在这些情况下，回调函数会传递一个指向`MouseEvent`对象的引用，该对象可以提供有关鼠标当前状态的信息（事件发生时鼠标的位置、事件发生的时间、键盘上的哪些修改键被按下、哪些鼠标按钮被按下等等）。实际上，尽管这些类和函数名称指的是“鼠标”，但此系统可以处理多点触控事件，并且`MouseEvent`对象可以询问在这种情况下涉及的是哪个“手指”（例如，在iOS平台上）。****'
- en: '****To experiment with these callbacks, create a new Introjucer project and
    name it `Chapter02_06`. Use the following code for this project.****'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '****为了实验这些回调函数，创建一个新的Introjucer项目，并将其命名为`Chapter02_06`。为此项目使用以下代码。****'
- en: '****The `MainComponent.h` file declares the class with its various member functions
    and data:****'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '****`MainComponent.h`文件声明了具有其各种成员函数和数据的类：****'
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '****The `MainComponent.cpp` file should contain the following code. First,
    add the constructor and the `paint()` function. The `paint()` function draws a
    yellow circle at the mouse position and some text showing the current phase of
    the mouse interaction:****'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '****`MainComponent.cpp`文件应包含以下代码。首先，添加构造函数和`paint()`函数。`paint()`函数在鼠标位置绘制一个黄色圆圈，并显示当前鼠标交互阶段的文本：****'
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '****Then add the mouse event callbacks and our `handleMouse()` function described
    as follows. We store the coordinates of the mouse callbacks with reference to
    our component and store a `String` object based on the type of callback (mouse
    down, up, move, and so on). Because the storage of the coordinates is the same
    in each case, we use the `handleMouse()` function, which stores the coordinates
    from the `MouseEvent` object in our class member variables `x` and `y`, and pass
    this `MouseEvent` object from the callbacks. To ensure that the component redraws
    itself, we must call the `Component::repaint()` function.****'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '****然后添加鼠标事件回调和以下描述的我们的 `handleMouse()` 函数。我们根据我们的组件存储鼠标回调的坐标，并根据回调类型（鼠标按下、释放、移动等）存储一个
    `String` 对象。由于每种情况下坐标的存储都是相同的，我们使用 `handleMouse()` 函数，该函数将 `MouseEvent` 对象的坐标存储在我们的类成员变量
    `x` 和 `y` 中，并将此 `MouseEvent` 对象从回调中传递。为了确保组件重新绘制，我们必须调用 `Component::repaint()`
    函数。****'
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '****As shown in the following screenshot, the result is a yellow circle that
    sits under our mouse pointer and a text message in the center of the window that
    gives feedback as to the type of mouse event most recently received:****'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '****如图所示，结果是位于我们的鼠标指针下的黄色圆圈和窗口中心的一个文本消息，该消息提供有关最近接收到的鼠标事件类型的反馈：****'
- en: '****![Intercepting mouse activity](img/3316_02_04.jpg)**** ****# Configuring
    complex component arrangements'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '****![拦截鼠标活动](img/3316_02_04.jpg)**** ****# 配置复杂的组件布局'
- en: JUCE makes it straightforward to create custom components either by combining
    several built-in components or through providing an effective means of interacting
    with pointing devices combined with a range of fundamental drawing commands. In
    addition to this, the Introjucer application provides a graphical editor for laying
    out custom components. This will then autogenerate the code required to rebuild
    this interface in your application. Create a new Introjucer project as earlier,
    with a basic window, and name it `Chapter02_07`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE 使创建自定义组件变得简单，无论是通过组合几个内置组件，还是通过提供一种与指针设备交互的有效方法，并结合一系列基本绘图命令。除此之外，Introjucer
    应用程序还提供了一个图形编辑器，用于布局自定义组件。然后它会自动生成重建此界面所需的应用程序代码。像之前一样创建一个新的 Introjucer 项目，包含一个基本窗口，并将其命名为
    `Chapter02_07`。
- en: 'Switch to the **Files** panel, right-click (on the Mac, press *control* and
    click) on the **Source** folder in the hierarchy, and select **Add New GUI Component…**
    from the contextual menu, as shown in the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 **文件** 面板，在层次结构中的 **源** 文件夹上右键单击（在 Mac 上，按 *control* 并单击），然后从上下文菜单中选择 **添加新
    GUI 组件…**，如图所示：
- en: '![Configuring complex component arrangements](img/3316_02_05.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![配置复杂的组件布局](img/3316_02_05.jpg)'
- en: 'You will be asked to name the header file, which also names the corresponding
    `.cpp` file. Name the header file `CustomComponent.h`. When you select a `.cpp`
    file created in this way, you are offered several ways of editing the file. In
    particular you can add child components, add drawing commands, or you can edit
    the code directly. Select the `CustomComponent.cpp` file, as shown in the following
    screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被要求命名头文件，该文件也命名了相应的 `.cpp` 文件。将头文件命名为 `CustomComponent.h`。当您选择以这种方式创建的 `.cpp`
    文件时，您将获得几种编辑文件的方式。特别是您可以添加子组件，添加绘图命令，或者您可以直接编辑代码。选择如图所示的 `CustomComponent.cpp`
    文件：
- en: '![Configuring complex component arrangements](img/3316_02_06.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![配置复杂的组件布局](img/3316_02_06.jpg)'
- en: 'In the **Subcomponents** panel, you can right-click on the grid to add one
    of the several built-in component types. Add in a few buttons and sliders. Each
    of these can be edited when selected using the properties on the right-hand side
    of the window. What is particularly useful here is the ability to set complex
    rules about the positioning of the components relative to each other and the parent
    component. Some of the options for this are visible in the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **子组件** 面板中，您可以在网格上右键单击以添加几种内置组件类型之一。添加几个按钮和滑块。选择任何一个组件时，都可以使用窗口右侧的属性进行编辑。这里特别有用的是能够设置关于组件相对于彼此和父组件位置复杂规则的能力。以下截图显示了此选项的一些示例：
- en: '![Configuring complex component arrangements](img/3316_02_07.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![配置复杂的组件布局](img/3316_02_07.jpg)'
- en: Because the Introjucer application generates C++ code, it should be clear that
    these options are clearly available programmatically. For some tasks, especially
    complex GUIs, using the GUI editor may be more convenient. It is also a useful
    way of discovering features available in the various component classes and the
    corresponding code to enable and control these features.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Introjucer 应用程序生成 C++ 代码，应该很清楚这些选项可以通过编程方式明确获得。对于某些任务，尤其是复杂的 GUI，使用 GUI 编辑器可能更方便。这也是发现各种组件类中可用的功能和启用/控制这些功能的相应代码的有用方式。
- en: 'Before opening the project in your IDE, select the **Class** panel (using the
    tab to the left of the **Subcomponents** tab) and change the **class name** from
    `NewComponent` to `CustomComponent` (to match the filenames of the code). Save
    the Introjucer project and open its IDE project for your platform. You need make
    only a few minor modifications to load this auto-generated code into your `MainContentComponent`
    class. Change the `MainComponent.h` file as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在在你的 IDE 中打开项目之前，选择 **类** 面板（使用位于 **子组件** 选项卡左侧的选项卡），并将 **类名** 从 `NewComponent`
    更改为 `CustomComponent`（以匹配代码的文件名）。保存 Introjucer 项目并打开其 IDE 项目。你需要对 `MainContentComponent`
    类进行仅少数几个小的修改，才能将此自动生成的代码加载进去。按照以下方式更改 `MainComponent.h` 文件：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, change the `MainComponent.cpp` file to:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 `MainComponent.cpp` 文件更改为：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This allocates a `CustomComponent` object and makes it fill the bounds of the
    `MainContentComponent` object. Build and run the application, and you should see
    whatever user interface you designed in the Introjucer application''s GUI editor.
    The Introjucer application takes special control of the source files for these
    autogenerated GUI controls. Take a look in the `CustomComponent.h` and `CustomComponent.cpp`
    files. There will be some code you recognize from earlier in this chapter (one
    major difference is that the Introjucer application generates code to allocate
    the subcomponent classes dynamically, rather than using static allocation as we
    have done here). You must be very careful when editing code in these autogenerated
    GUI files, because loading the project back into the Introjucer application may
    overwrite some of your changes (which doesn''t happen with regular code files).
    The Introjucer application identifies areas where you *may* make changes using
    specially tagged opening and closing comments. For example, this is the end of
    a typical autogenerated component constructor:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将分配一个 `CustomComponent` 对象，并使其填充 `MainContentComponent` 对象的边界。构建并运行应用程序，你应该在
    Introjucer 应用程序的 GUI 编辑器中看到你设计的任何用户界面。Introjucer 应用程序对这些自动生成的 GUI 控件的源文件进行特殊控制。查看
    `CustomComponent.h` 和 `CustomComponent.cpp` 文件。你将看到一些在本章早期部分出现过的代码（一个主要区别是，Introjucer
    应用程序生成代码以动态分配子组件类，而不是像我们在这里所做的那样使用静态分配）。在编辑这些自动生成的 GUI 文件中的代码时，你必须非常小心，因为将项目重新加载到
    Introjucer 应用程序可能会覆盖一些你的更改（这不会在常规代码文件中发生）。Introjucer 应用程序使用特殊标记的开头和结尾注释来识别你可以进行修改的区域。例如，这是一个典型的自动生成组件构造函数的结尾：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You *may* make changes and add code in between the opening `[UserPreSize]` tag
    and closing `[/UserPreSize]` tag and between the opening `[Constructor]` tag and
    closing `[/Constructor]` tag. In fact you can make edits between any of these
    opening and closing tags *but not anywhere else*. Doing so risks your changes
    being deleted if and when the Introjucer project is next saved to disk. This applies
    if you add another build target, add another GUI component, add other files to
    the Introjucer project, and where you explicitly save the project in the Introjucer
    application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `[UserPreSize]` 开头标签和 `[UserPreSize]` 结束标签之间，以及 `[Constructor]` 开头标签和 `[Constructor]`
    结束标签之间进行修改和添加代码。实际上，你可以在这些开头和结束标签之间进行编辑，但**不能在其他任何地方**。这样做可能会在下次将 Introjucer 项目保存到磁盘时删除你的更改。这适用于你添加另一个构建目标、添加另一个
    GUI 组件、将其他文件添加到 Introjucer 项目中，以及你在 Introjucer 应用程序中明确保存项目的情况。
- en: Other component types
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他组件类型
- en: 'JUCE comprises a wide range of other component types for particular tasks.
    Many of these will be familiar, as similar controls are available within many
    operating systems and other GUI frameworks. In particular:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: JUCE 包含用于特定任务的广泛其他组件类型。其中许多将很熟悉，因为许多操作系统和其他 GUI 框架中都提供了类似的控件。特别是：
- en: '**Buttons**: There are several button types, including buttons that can be
    created using image files and other shapes (for example, `ImageButton`, and `ShapeButton`
    classes); there is a `ToolbarButton` class that can be used to create toolbars.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按钮**: 有几种按钮类型，包括可以使用图像文件和其他形状创建的按钮（例如，`ImageButton`和`ShapeButton`类）；还有一个`ToolbarButton`类，可以用来创建工具栏。'
- en: '**Menus**: There is a `PopupMenu` class (for issuing commands) and a `ComboBox`
    class (for selecting items).'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**菜单**: 有一个`PopupMenu`类（用于发布命令）和一个`ComboBox`类（用于选择项目）。'
- en: '**Layout**: There are various classes for organizing other components including
    a `TabbedComponent` class (for creating tabbed pages), a `ViewPort` class (for
    creating scrollable content), a `TableListBox` class (for creating tables), and
    a `TreeView` class (for organizing content in to a hierarchical structure).'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局**: 有各种类用于组织其他组件，包括一个`TabbedComponent`类（用于创建标签页），一个`ViewPort`类（用于创建可滚动内容），一个`TableListBox`类（用于创建表格），以及一个`TreeView`类（用于将内容组织成层次结构）。'
- en: '**File browsers**: There are various ways of displaying and accessing file
    directory structures including the `FileChooser`, `FileNameComponent`, and `FileTreeComponent`
    classes.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件浏览器**: 有多种方式显示和访问文件目录结构，包括`FileChooser`、`FileNameComponent`和`FileTreeComponent`类。'
- en: '**Text editors**: There is a general-purpose `TextEditor` class, and a `CodeEditorComponent`
    for displaying and editing code.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本编辑器**: 有一个通用的`TextEditor`类，以及一个`CodeEditorComponent`用于显示和编辑代码。'
- en: 'Most of source code for these components can be found in `juce/modules/juce_gui_basics`
    with some additional classes being found in `juce/modules/juce_gui_extra`. All
    classes are documented in the online documentation. An alphabetical list of all
    classes can be found here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件的大部分源代码可以在`juce/modules/juce_gui_basics`中找到，一些额外的类可以在`juce/modules/juce_gui_extra`中找到。所有类都在在线文档中有文档说明。所有类的字母顺序列表可以在这里找到：
- en: '[http://www.juce.com/api/annotated.html](http://www.juce.com/api/annotated.html)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.juce.com/api/annotated.html](http://www.juce.com/api/annotated.html)'
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter you should be familiar with the principles of building
    user interfaces in JUCE both programmatically and via the Introjucer application.
    This chapter has shown you how to create and use JUCE's built-in components, how
    to construct custom components, and how to perform fundamental drawing operations
    on-screen. You should read the online documentation for each class introduced
    during this chapter. You should also examine the code bundle for this book that
    contains each of the examples developed in this chapter. The code in this bundle
    also includes more inline comments for each of the examples. The next chapter
    covers a range of non-GUI classes although many of these will be useful for managing
    some elements of user interface functionality.****
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该熟悉在JUCE中通过编程和通过Introjucer应用程序构建用户界面的原则。本章向您展示了如何创建和使用JUCE的内置组件，如何构建自定义组件，以及如何在屏幕上执行基本的绘图操作。你应该阅读本章介绍的所有类的在线文档。你还应该检查本书的代码包，其中包含本章开发的每个示例。此代码包还包括每个示例的更多内联注释。下一章将涵盖一系列非GUI类，尽管其中许多对于管理用户界面功能的一些元素将很有用。****
