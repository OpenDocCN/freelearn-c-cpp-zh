- en: Chapter 2. Building User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the JUCE `Component` class, which is the main building
    block for creating a **Graphical User Interface** (**GUI**) in JUCE. In this chapter
    we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating buttons, sliders, and other components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Responding to user interaction and changes: broadcasters and listeners'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using other component types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying colors and using drawing operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create a basic GUI and perform
    fundamental drawing operations within a component. You will also have the skills
    required to design and build more complex interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Creating buttons, sliders, and other components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JUCE `Component` class is the base class that provides the facility to
    draw on the screen and intercept user interaction from pointing devices, touch-screen
    interaction, and keyboard input. The JUCE distribution includes a wide range of
    `Component` subclasses, many of which you may have encountered by exploring the
    JUCE Demo application in [Chapter 1](ch01.html "Chapter 1. Installing JUCE and
    the Introjucer Application"), *Installing JUCE and the Introjucer Application*.
    The JUCE coordinate system is hierarchical, starting at the computer''s screen
    (or screens) level. This is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating buttons, sliders, and other components](img/3316_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each on-screen window contains a single **parent** component within which other
    **child** components (or **subcomponents**) are placed (each of which may contain
    further child components). The top-left of the computer screen is coordinate (0,
    0) with each top-left of the content of JUCE windows being at an offset from this.
    Each component then has its own local coordinates where its top-left starts at
    (0, 0) too.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases you will deal with the components' coordinates relative to their
    parent components, but JUCE provides simple mechanisms to convert these values
    to be relative to other components or the main screen (that is, global coordinates).
    Notice in the preceding diagram that a window's top-left position does not include
    the title bar area.
  prefs: []
  type: TYPE_NORMAL
- en: You will now create a simple JUCE application that includes some fundamental
    component types. As the code for this project is going to be quite simple, we
    will write all our code into the header file (`.h`). This is not recommended for
    real-world projects except for quite small classes (or where there are other good
    reasons), but this will keep all the code in one place as we go through it. Also,
    we will split up the code into the `.h` and `.cpp` files later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new JUCE project using the Introjucer application:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose menu item **File** | **New Project…**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Create a Main.cpp file and a basic window** from the **Files to Auto-Generate**
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose where to save the project and name it `Chapter02_01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create…** button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **Files** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the file `MainComponent.cpp`, choose **Delete** from the contextual
    menu, and confirm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose menu item **File** | **Save Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the project in your **Integrated Development Environment** (**IDE**), either
    Xcode or Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the `MainComponent.h` file in your IDE. The most important part
    of this file should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we have removed the actual code from the autogenerated project by
    removing the `.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s make an empty window. We will remove some of the elements to simplify
    the code and add a function body for the constructor. Change the declaration of
    the `MainContentComponent` class shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the application, there should be an empty window named **MainWindow**
    in the center of the screen. Our JUCE application will create a window and place
    an instance of our `MainContentComponent` class as its content (that is, excluding
    the title bar). Notice our `MainContentComponent` class inherits from the `Component`
    class and therefore has access to a range of functions implemented by the `Component`
    class. The first of these is the `setSize()` function, which sets the width and
    height of our component.
  prefs: []
  type: TYPE_NORMAL
- en: Adding child components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Building user interfaces using components generally involves combining other
    components to produce composite user interfaces. The easiest way to do this is
    to include member variables in which to store the **child** components in the
    **parent** component class. For each child component that we wish to add, there
    are five basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a member variable in which to store the new component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocating a new component (either using static or dynamic memory allocation).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the component as a child of the parent component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making the child component visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting the child component's size and position within the parent component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we will create a button; change the code shown as follows. The preceding
    numbered steps are illustrated in the code comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The important parts of the preceding code are:'
  prefs: []
  type: TYPE_NORMAL
- en: An instance of the JUCE `TextButton` class was added to the `private` section
    of our class. This button will be statically allocated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The button is initialized in the constructor's initializer list using a string
    that sets the text that will appear on the button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A call to the component function `addAndMakeVisible()` is passed as a pointer
    to our button instance. This adds the child component to the parent component
    hierarchy and makes the component visible on screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The component function `resized()` is overridden to position our button with
    an inset of 10 pixels within the parent component (this is achieved by using component
    functions `getWidth()` and `getHeight()` to discover the size of the parent component).
    This call to the `resized()` function is triggered when the parent component is
    resized, which in this case happens when we call the `setSize()` function in the
    constructor. The arguments to the `setSize()` function are in the order: width
    and height. The arguments to the `setBounds()` function are in the order: left,
    top, width, and height.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build and run the application. Notice that the button responds as the mouse
    pointer hovers over the button and when the button is clicked, although the button
    doesn't yet do anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, this is the most convenient method of positioning and resizing child
    components, even though in this example we could have easily set all the sizes
    in the constructor. The real power of this technique is illustrated when the parent
    component becomes resizable. The easiest way to do that here is to enable the
    resizing of the window itself. To do this, navigate to the `Main.cpp` file (which
    contains the boilerplate code to set up the basic application) and add the following
    highlighted line to the `MainWindow` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the application and notice that the window now has a corner resizer
    in the bottom-right. The important thing here is that the button automatically
    resizes as the window size changes due to the way we implemented this above. In
    the call to the `setResizable()` function, the first argument sets whether the
    window is resizable and the second argument sets whether this is via a corner
    resizer (`true`) or allowing the border of the window to be dragged to resize
    the window (`false`).
  prefs: []
  type: TYPE_NORMAL
- en: Child components may be positioned proportionally rather than with absolute
    or offset values. One way of achieving this is through the `setBoundsRelative()`
    function. In the following example you will add a slider control and a label to
    the component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, each child component is 90 percent of the width of the parent
    component and positioned five percent of the parent''s width from the left. Each
    child component is 25 percent of the height of the parent, and the three components
    are distributed top to bottom with the button five percent of the parent''s height
    from the top. Build and run the application, and notice that resizing the window
    automatically and smoothly, updates the sizes and position of the child components.
    The window should look similar to the following screenshot. In the next section
    you will intercept and respond to user interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding child components](img/3316_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to user interaction and changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Introjucer project named `Chapter02_02` with a basic window; this
    time retain all of the auto-generated files. We will now split the code from the
    previous section into the `MainComponent.h` and `MainComponent.cpp` files. The
    `MainComponent.h` file should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MainComponent.cpp` file should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Broadcasters and listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although the `Slider` class already contains a text box that displays the slider''s
    value, it will be useful to examine how this communication works within JUCE.
    In the next example we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the text box from the slider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the slider's value appear in the label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable the slider to be zeroed by clicking on the button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To achieve this, JUCE uses the **observer** pattern widely throughout the library
    to enable objects to communicate. In particular, the `Component` class and the
    `Component` subclasses use this to notify your code when a user interface item
    has been clicked, their content has been changed, and so on. In JUCE, these are
    generally known as **listeners** (the observers) and **broadcasters** (the subjects
    of the observers). JUCE also makes extensive use of multiple inheritance. One
    area in JUCE where multiple inheritance is particularly useful is through the
    use of the broadcaster and listener systems. Generally, a JUCE class that supports
    broadcasting its state changes has a nested class called `Listener`. Thus, the
    `Slider` class has the `Slider::Listener` class and the `Label` class has the
    `Label::Listener` class. (These are often represented by classes with similar
    names to help support older IDEs, for example, `SliderListener` and `LabelListener`
    are equivalent.) The `TextButton` class is in fact a subclass of the more generic
    `Button` class; therefore, its listener class is `Button::Listener`. Each of these
    listener classes will contain a declaration of at least one **pure virtual function**
    . This will require our derived class to implement these functions. Listener classes
    may contain other regular virtual functions, meaning they may be implemented optionally.
    To implement these functions, first add listener classes for the button and slider
    as public base classes of our `MainContentComponent` class in the `MainComponent.h`
    file shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of our user interface listeners here requires us to implement one function
    to respond to its changes. These are the `buttonClicked()` and `sliderValueChanged()`
    functions. Add these to the `public` section of our class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The full listing to use for the `MainComponent.cpp` file is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The two calls to add the listeners using the `addListener()` function, pass
    the `this` pointer (a pointer to our `MainContentComponent` instance). This adds
    our `MainContentComponent` instance as a listener to both the slider and the button
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there is only one instance of each type of component, the preceding
    example shows the recommend way to check which component broadcasted a change,
    in cases where there may be many similar components (such as banks of buttons
    or sliders). This technique is to check the value of the pointer received by the
    listener function and whether this matches the address of one of the member variables.
    There is one thing to note on the coding style here. You may prefer to write the
    `if()` statement with the arguments swapped over as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: However, the style used throughout this book is employed to cause a deliberate
    compiler error if you mistype the "`==`" operator as a single "`=`" character.
    This should help avoid bugs that might be introduced by this mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Components that store some kind of value such as sliders and labels may, of
    course, have their state set programmatically. In this case, you can control whether
    its listeners are notified of the change or not (you can also customize whether
    this is transmitted **synchronously** or **asynchronously**). This is the purpose
    of the `sendNotification` value (which is an enumerated constant) in the calls
    to the `Slider::setValue()` and `Label::setText()` functions as in the preceding
    code snippet. Also, you should notice that the call to the `Slider::setValue()`
    function in the constructor is made *after* the class has been registered as a
    listener. This ensures that all the components are configured correctly from the
    start while minimizing the duplication of code. This code makes use of the `String`
    class to pass text to the label, to convert text to numerical values, and vice
    versa. The `String` class will be explored in more detail in the next chapter,
    but for now, we will limit the usage of the `String` class to these basic operations.
    The text box is removed from the slider by initializing the slider in the initializer
    list with a slider style and text box style. In this case, the initializer `slider1
    (Slider::LinearHorizontal`, `Slider::NoTextBox)` specifies a horizontal slider
    and that no text box should be attached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, should we want to set the value of the slider to something specific;
    we can make the label editable and transmit any changes typed into the label to
    the slider. Make another new Introjucer project and name it `Chapter02_03`. Add
    the `Label::Listener` class to the base classes of our `MainContentComponent`
    class in the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `Label::Listener` function that responds to the label changes, also
    in the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the constructor in the `MainComponent.cpp` file to further configure
    the label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the label is set to be editable with a single click and our class registers
    itself as a listener for the label. Lastly, add the implementation for the `labelTextChanged()`
    function to the `MainComponent.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the application to test this functionality. There are some problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The slider correctly clips values typed into the label that are outside the
    range of the slider, but the text in the label still remains if these values are
    outside the range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The label allows non-numerical characters to be typed in (although these are
    usefully resolved to zero)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering data entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first issue mentioned above is straightforward, and this is to convert
    the slider''s value back to text and use this to set the label content. This time
    we use the `dontSendNotification` value, because we want to avoid an infinite
    loop whereby each component would broadcast a message that causes a change that
    would in turn cause a message to be broadcasted and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The second issue requires a filter to allow only certain characters. Here,
    you need access to the label''s internal `TextEditor` object. To do this, you
    could create a custom label class by inheriting from the `Label` class and implementing
    the `editorShown()` virtual function. Add this small class to the `MainComponent.h`
    file above the `MainContentComponent` class declaration (although to reuse this
    class across a number of components in your application, it may be better to place
    this code in a separate file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the text editor is just about to be shown, this function is called
    by the label, and at that point you can set the text editor''s input restrictions
    using its `setInputRestrictions()` function. The two arguments are: length and
    allowable characters. The zero length means there is no restriction on length
    and the allowable characters in this case include all the digits, the minus sign
    and the period. (In fact you could omit the minus sign to disallow negative numbers
    and omit the period if you wanted to allow integer values only.) To use this class
    in place of the built-in `Label` class simply replace this class name in the member
    variable list for our `MainContentComponent` class as shown highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, by this point you can see that JUCE classes provide a useful range
    of core functionality while allowing customizations with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: Using other component types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many other built-in component types and variations on the sliders
    and buttons already seen. In the previous section we used the default horizontal
    slider, but the `Slider` class is very flexible, as illustrated by the Widget
    demo page of the JUCE Demo application. The sliders can adopt a rotary-type control,
    have minimum and maximum ranges, and warp the numerical track to adopt non-linear
    behavior. Similarly, buttons can adopt different styles such as toggle buttons,
    buttons that use images, and so on. The following example illustrates a toggle-type
    button that changes the style of two sliders. Create a new Introjucer project
    named `Chapter02_04`, and use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MainComponent.h**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**MainComponent.cpp**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This example uses a `ToggleButton` object and checks its toggle state in the
    `buttonClicked()` function using the `getToggleState()` function. One obvious
    customization yet to be discussed is changing the colors of the various elements
    within the built-in components. This will be covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Colors in JUCE are handled by the `Colour` and `Colours` classes (*note the
    British spelling of these two class names*):'
  prefs: []
  type: TYPE_NORMAL
- en: The `Colour` class stores a 32-bit color with 8-bit alpha, red, green, and blue
    values (**ARGB**). A `Colour` object may be initialized from other formats (for
    example, using floating point values, or values in the **HSV** format).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Colour` class includes a number of utilities for creating new colors from
    existing ones, for example, by modifying the alpha channel, changing only the
    brightness or finding a suitable contrasting color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Colours` class is a collection of static `Colour` instances (for example,
    `Colour::red`, `Colour::cyan`). These are based broadly on the naming scheme of
    colors in the **HyperText Markup Language** (**HTML**) standard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following code snippet illustrates several different ways
    of creating the same "red" color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Component classes employ an ID system to refer to the various colors they use
    for different purposes (background, border, text, and so on). To use these colors
    to change the appearance of a component, the `Component::setColour()` function
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to change the color of a slider''s thumb (which is the draggable
    part), the ID is the `Slider::thumbColourId` constant (this too changes the fill
    color that represents the slider''s value when the slider style is set to the
    `Slider::LinearBar` constant). You can test this in the `Chapter02_04` project
    by adding the following highlighted lines to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The final look of this application showing both types of slider is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specifying colors](img/3316_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Component color IDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many built-in components define their own color ID constants; the most useful
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Slider::backgroundColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slider::thumbColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slider::trackColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slider::rotarySliderFillColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slider::rotarySliderOutlineColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slider::textBoxTextColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slider::textBoxBackgroundColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slider::textBoxHighlightColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slider::textBoxOutlineColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Label::backgroundColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Label::textColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Label::outlineColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ToggleButton::textColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextButton::buttonColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextButton::buttonOnColourId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextButton::textColourOffId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextButton::textColourOnId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these enumerated constants is defined in the class in which they are
    used. There are many others for each of the component types.
  prefs: []
  type: TYPE_NORMAL
- en: Setting colors using the LookAndFeel class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have many controls and want to set unified colors for all of them, then
    it is likely to be more convenient to set the color at some other point in the
    component hierarchy. This is one purpose of the JUCE `LookAndFeel` class. This
    was seen briefly in [Chapter 1](ch01.html "Chapter 1. Installing JUCE and the
    Introjucer Application"), *Installing JUCE and the Introjucer Application* where
    the different styles of the various widgets can be selected by using a different
    look and feel. If this is to be a global change across the whole application then
    the best place to put this change is likely to be in the initialization code.
    To try this, remove the following two lines of code from your project, which were
    added in the previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the `Main.cpp` file. Now add the following lines to the `initialise()`
    function (*again notice the British spelling*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be clear that an extended list of colors could be configured at this
    point to customize the application''s appearance. Another technique, that again
    uses the `LookAndFeel` class, is to inherit from the default `LookAndFeel` class
    and update colors in this derived class. Setting a particular look and feel for
    a component affects all child components in its hierarchy. Therefore, this method
    would allow you to set colors selectively in different parts of an application.
    A solution that uses this method is shown as follows, with the important parts
    highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The MainComponent.h file**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MainComponent.cpp` file only the constructor needs updating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a nested class `AltLookAndFeel` that is based on the default
    `LookAndFeel` class. This is defined as a nested class, because we need to only
    refer to it from within a `MainContentComponent` instance. It might be more appropriate
    to define this class outside the `MainContentComponent` class if the `AltLookAndFeel`
    becomes a more extended class or needs to be reused by other component classes
    that we write.
  prefs: []
  type: TYPE_NORMAL
- en: In the `AltLookAndFeel` constructor, we set the color of the slider thumb. Finally,
    we set the look and feel for the `MainContentComponent` class in its constructor.
    There are clearly many other possible techniques using this handful of tools,
    and the exact approach is heavily dependent on the specific application features
    being developed. It is important to note that the `LookAndFeel` class not only
    deals with colors, but also more broadly enables you to configure the exact way
    in which certain user interface elements are drawn. Not only can you change the
    color of the slider thumb, you can change its radius (by overriding the `LookAndFeel::getSliderThumbRadius()`
    function) or even change its shape altogether (by overriding the `LookAndFeel::drawLinearSliderThumb()`
    function).
  prefs: []
  type: TYPE_NORMAL
- en: Using drawing operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it is advisable to use the built-in components if possible, there are
    occasions where you may need or wish to create a completely new custom component.
    This may be to perform some specific drawing tasks or a unique user interface
    item. JUCE also handles this elegantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new Introjucer project and name it `Chapter02_05`. To perform
    drawing tasks in a component, you should override the `Component::paint()` function.
    Change the contents of the `MainComponent.h` file to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the contents of the `MainComponent.cpp` file to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the application to see the resulting empty window filled with
    a blue color.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `paint()` function is called when the component needs to redraw itself.
    This might be due to the component having been resized (which of course you can
    try out using the corner resizer), or specific calls to invalidate the display
    (for example, the component displays visual representation of a value and this
    is no longer the currently stored value). The `paint()` function is passed a reference
    to a `Graphics` object. It is this `Graphics` object that you instruct to perform
    your drawing tasks. The `Graphics::fillAll()` function used in the code above
    should be self-explanatory: it fills the entire component with the specified color.
    The `Graphics` object can draw rectangles, ellipses, rounded rectangles, lines
    (in various styles), curves, text (with numerous shortcuts for fitting or truncating
    text within particular areas) and images.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example illustrates drawing a collection of random rectangles using
    random colors. Change the `paint()` function in the `MainComponent.cpp` file to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This makes use of multiple calls to the JUCE random number generator class `Random`.
    This is a convenient class that allows the generation of pseudo-random integers
    and floating-point numbers. You can make your own instance of a `Random` object
    (which is recommend if your application uses random numbers in multiple threads),
    but here we simply take a copy of a reference to a global "system" `Random` object
    (using the `Random::getSystemRandom()` function) and use it multiple times. Here,
    we fill the component with a blue background and generate 20 rectangles. The color
    is generated from randomly generated floating point ARGB values. The call to the
    `Graphics::setColour()` function sets the current drawing color that will be employed
    by subsequent drawing commands. A randomly generated rectangle is also created
    by first choosing width and height (each being a maximum value of one-quarter
    of the parent component's width and height respectively). Then the position of
    the rectangle is randomly selected; again this is done using the parent component's
    width and height but this time subtracting the width and height of our random
    rectangle to ensure its right and bottom edges are not off-screen. As mentioned
    previously, the `paint()` function is called each time the component needs to
    be redrawn. This means we will get a completely new set of random rectangles as
    the component is resized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the drawing command to `fillEllipse()` rather than `fillRect()` draws
    a collection of ellipses instead. Lines can be drawn in various ways. Change the
    `paint()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Here, we choose a random line thickness (between one and six pixels wide)
    before the `for()` loop and use it for each line. The start and end positions
    of the lines are also randomly generated. To draw a continuous line there are
    a number of options, you could:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**store the last end point of the line and use this as the start point of the
    next line; or**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**use a JUCE `Path` object to build a series of line drawing commands and draw
    the path in one pass.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The first solution would be something like this:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**The second option is slightly different; in particular, each of the lines
    that make up the path must be same color:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '****Here the path is created before the `for()` loop and each iteration of
    the loop adds a line segment to the path. These two approaches to line drawing
    clearly suit different applications. The path drawing technique is heavily customizable,
    in particular:****'
  prefs: []
  type: TYPE_NORMAL
- en: '****The joints at the corners of the line segments can be customized with the
    `PathStrokeType` class (for example, to make the corners slightly rounded).****'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****The lines need not be straight: they can be Bezier curves.****'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****The path may include other fundamental shapes such as rectangles, ellipses,
    stars, arrows and so on.****'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****In addition to these line drawing commands, there are accelerated functions
    specifically for drawing horizontal and vertical lines (that is, non-diagonal).
    These are the `Graphics::drawVerticalLine()` and `Graphics::drawHorizontalLine()`
    functions.****'
  prefs: []
  type: TYPE_NORMAL
- en: '****Intercepting mouse activity****'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '****To help your component respond to mouse interaction, the `Component` class
    has six important callback functions that you can override:****'
  prefs: []
  type: TYPE_NORMAL
- en: '****`mouseEnter()`: Called when the mouse pointer enters the bounds of this
    component and the mouse buttons are *up*.****'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`mouseMove()`: Called when the mouse pointer moves within the bounds of
    this component and the mouse buttons are *up*. A `mouseEnter()` callback will
    always have been received first.****'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`mouseDown()`: Called when one or more mouse buttons are pressed while
    the mouse pointer is over this component. A `mouseEnter()` callback will always
    have been received first and it is highly likely one or more `mouseMove()` callbacks
    will have been received too.****'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`mouseDrag()`: Called when the mouse pointer is moved following a `mouseDown()`
    callback on this component. The position of the mouse pointer may be outside the
    bounds of the component.****'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`mouseUp()`: Called when the mouse button is released following a `mouseDown()`
    callback on this component (the mouse pointer will not necessarily be over this
    component at this time).****'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`mouseExit()`: Called when the mouse pointer leaves the bounds of this
    component when the mouse buttons are *up* and after a `mouseUp()` callback if
    the user has clicked on this component (even if the mouse pointer exited the bounds
    of this component some time ago).****'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****In each of these cases, the callbacks are passed a reference to a `MouseEvent`
    object that can provide information about the current state of the mouse (where
    it was at the time of the event, when the event occurred, which modifier keys
    on the keyboard were down, which mouse buttons were down, and so on). In fact,
    although these classes and function names refer to the "mouse" this system can
    handle multi-touch events and the `MouseEvent` object can be ask which "finger"
    was involved in such cases (for example, on the iOS platform).****'
  prefs: []
  type: TYPE_NORMAL
- en: '****To experiment with these callbacks, create a new Introjucer project and
    name it `Chapter02_06`. Use the following code for this project.****'
  prefs: []
  type: TYPE_NORMAL
- en: '****The `MainComponent.h` file declares the class with its various member functions
    and data:****'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '****The `MainComponent.cpp` file should contain the following code. First,
    add the constructor and the `paint()` function. The `paint()` function draws a
    yellow circle at the mouse position and some text showing the current phase of
    the mouse interaction:****'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '****Then add the mouse event callbacks and our `handleMouse()` function described
    as follows. We store the coordinates of the mouse callbacks with reference to
    our component and store a `String` object based on the type of callback (mouse
    down, up, move, and so on). Because the storage of the coordinates is the same
    in each case, we use the `handleMouse()` function, which stores the coordinates
    from the `MouseEvent` object in our class member variables `x` and `y`, and pass
    this `MouseEvent` object from the callbacks. To ensure that the component redraws
    itself, we must call the `Component::repaint()` function.****'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '****As shown in the following screenshot, the result is a yellow circle that
    sits under our mouse pointer and a text message in the center of the window that
    gives feedback as to the type of mouse event most recently received:****'
  prefs: []
  type: TYPE_NORMAL
- en: '****![Intercepting mouse activity](img/3316_02_04.jpg)**** ****# Configuring
    complex component arrangements'
  prefs: []
  type: TYPE_NORMAL
- en: JUCE makes it straightforward to create custom components either by combining
    several built-in components or through providing an effective means of interacting
    with pointing devices combined with a range of fundamental drawing commands. In
    addition to this, the Introjucer application provides a graphical editor for laying
    out custom components. This will then autogenerate the code required to rebuild
    this interface in your application. Create a new Introjucer project as earlier,
    with a basic window, and name it `Chapter02_07`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the **Files** panel, right-click (on the Mac, press *control* and
    click) on the **Source** folder in the hierarchy, and select **Add New GUI Component…**
    from the contextual menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring complex component arrangements](img/3316_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will be asked to name the header file, which also names the corresponding
    `.cpp` file. Name the header file `CustomComponent.h`. When you select a `.cpp`
    file created in this way, you are offered several ways of editing the file. In
    particular you can add child components, add drawing commands, or you can edit
    the code directly. Select the `CustomComponent.cpp` file, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring complex component arrangements](img/3316_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the **Subcomponents** panel, you can right-click on the grid to add one
    of the several built-in component types. Add in a few buttons and sliders. Each
    of these can be edited when selected using the properties on the right-hand side
    of the window. What is particularly useful here is the ability to set complex
    rules about the positioning of the components relative to each other and the parent
    component. Some of the options for this are visible in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring complex component arrangements](img/3316_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because the Introjucer application generates C++ code, it should be clear that
    these options are clearly available programmatically. For some tasks, especially
    complex GUIs, using the GUI editor may be more convenient. It is also a useful
    way of discovering features available in the various component classes and the
    corresponding code to enable and control these features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before opening the project in your IDE, select the **Class** panel (using the
    tab to the left of the **Subcomponents** tab) and change the **class name** from
    `NewComponent` to `CustomComponent` (to match the filenames of the code). Save
    the Introjucer project and open its IDE project for your platform. You need make
    only a few minor modifications to load this auto-generated code into your `MainContentComponent`
    class. Change the `MainComponent.h` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the `MainComponent.cpp` file to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This allocates a `CustomComponent` object and makes it fill the bounds of the
    `MainContentComponent` object. Build and run the application, and you should see
    whatever user interface you designed in the Introjucer application''s GUI editor.
    The Introjucer application takes special control of the source files for these
    autogenerated GUI controls. Take a look in the `CustomComponent.h` and `CustomComponent.cpp`
    files. There will be some code you recognize from earlier in this chapter (one
    major difference is that the Introjucer application generates code to allocate
    the subcomponent classes dynamically, rather than using static allocation as we
    have done here). You must be very careful when editing code in these autogenerated
    GUI files, because loading the project back into the Introjucer application may
    overwrite some of your changes (which doesn''t happen with regular code files).
    The Introjucer application identifies areas where you *may* make changes using
    specially tagged opening and closing comments. For example, this is the end of
    a typical autogenerated component constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You *may* make changes and add code in between the opening `[UserPreSize]` tag
    and closing `[/UserPreSize]` tag and between the opening `[Constructor]` tag and
    closing `[/Constructor]` tag. In fact you can make edits between any of these
    opening and closing tags *but not anywhere else*. Doing so risks your changes
    being deleted if and when the Introjucer project is next saved to disk. This applies
    if you add another build target, add another GUI component, add other files to
    the Introjucer project, and where you explicitly save the project in the Introjucer
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Other component types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JUCE comprises a wide range of other component types for particular tasks.
    Many of these will be familiar, as similar controls are available within many
    operating systems and other GUI frameworks. In particular:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Buttons**: There are several button types, including buttons that can be
    created using image files and other shapes (for example, `ImageButton`, and `ShapeButton`
    classes); there is a `ToolbarButton` class that can be used to create toolbars.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Menus**: There is a `PopupMenu` class (for issuing commands) and a `ComboBox`
    class (for selecting items).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layout**: There are various classes for organizing other components including
    a `TabbedComponent` class (for creating tabbed pages), a `ViewPort` class (for
    creating scrollable content), a `TableListBox` class (for creating tables), and
    a `TreeView` class (for organizing content in to a hierarchical structure).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File browsers**: There are various ways of displaying and accessing file
    directory structures including the `FileChooser`, `FileNameComponent`, and `FileTreeComponent`
    classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text editors**: There is a general-purpose `TextEditor` class, and a `CodeEditorComponent`
    for displaying and editing code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of source code for these components can be found in `juce/modules/juce_gui_basics`
    with some additional classes being found in `juce/modules/juce_gui_extra`. All
    classes are documented in the online documentation. An alphabetical list of all
    classes can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.juce.com/api/annotated.html](http://www.juce.com/api/annotated.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the end of this chapter you should be familiar with the principles of building
    user interfaces in JUCE both programmatically and via the Introjucer application.
    This chapter has shown you how to create and use JUCE's built-in components, how
    to construct custom components, and how to perform fundamental drawing operations
    on-screen. You should read the online documentation for each class introduced
    during this chapter. You should also examine the code bundle for this book that
    contains each of the examples developed in this chapter. The code in this bundle
    also includes more inline comments for each of the examples. The next chapter
    covers a range of non-GUI classes although many of these will be useful for managing
    some elements of user interface functionality.****
  prefs: []
  type: TYPE_NORMAL
