<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Audio Adrenaline"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Audio Adrenaline</h1></div></div></div><p>This is the final chapter on the 2D game that we have been working on. Although our Robo Racer 2D game is almost complete, there is one element that we have yet to include to make it a complete game. Unless you like silent movies, you have probably noticed that we don't have any audio in this game. Most games depend on audio, and ours is no exception. In this chapter, we will cover audio and a few other housekeeping items.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Audio formats</strong></span>: It is important to understand how audio is represented in computers and how it is used in games. We will discuss sample rates and bits and help you understand how audio works.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Audio engine</strong></span>: We need some kind of audio engine to integrate audio into our game. We will discuss FMOD, a very popular engine that allows you to easily integrate audio using C++.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>SFX</strong></span>: Sound effects play a huge role in most games and, we will add sound effects to our game to bring it to life.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Music</strong></span>: Most games utilize some kind of music. Music is handled in a different way than sound effects, and you will learn the differences between the two.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Final housekeeping</strong></span>: On a final note, for our game, we have left the game shutdown for this chapter. We have not been good programmers in that we have not properly released the objects in our game. We will learn why it is important to do so, and how to do it.</li></ul></div><div class="section" title="Bits and bytes"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Bits and bytes</h1></div></div></div><p>Audio is inherently<a id="id386" class="indexterm"/> an analog experience. Sound is created as compressed waves travel through the air and interact with our ear drums. Until recently, the techniques used to reproduce audio were also strictly audio as well. For example, a microphone records sound similarly to how our ears do by capturing changes in air pressure and converting them to electrical impulses. Speakers do the reverse by converting the electrical signals back into waves of air pressure.</p><p>Computers, on the other hand, are digital. Computers convert audio samples into bits and bytes by taking samples of the audio. To keep it simple, let's consider a system where the current frequency of the sound wave (that is, how fast the wave is moving) is captured as a 16 bit (2 byte) number. It turns out that a 16 bit number can capture numbers in a range from 0 to 65,536. Each sample of the sound wave must be encoded as a number in this range. Also, as <a id="id387" class="indexterm"/>we actually capture two samples each time (for stereo sound), we need 4 bytes to capture each sample.</p><p>The next important factor is how often you sample the sound. The range of audio frequencies run roughly from 20 to 20,000 Hz (<span class="emphasis"><em>Hz = cycles per second</em></span>). A very smart person named Nyquist figured out that we have to sample audio at twice the frequency to accurately capture the wave. This means that we have to capture at least 40,000 samples each second to accurately capture a sound. Conversely, we have to play the sound back at the same frequency. This is why audio on compact discs are sampled at 44,100 Hz.</p><p>You should be able to see by now that it is going to take a lot of disk space and a lot of memory to work with sound. A one minute piece of audio will take about 10 MB of storage! This means that the same audio would require 10 MB of memory if we were to load the entire audio file at once.</p><p>You may wonder how modern games function at all. The music scores of some games are measured in hours, not minutes. Similarly, there may be hundreds or even thousands of sound effects, not to mention voice, which is also recorded as audio.</p><div class="section" title="A sound by any other name"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec105"/>A sound by any other name</h2></div></div></div><p>There are<a id="id388" class="indexterm"/> many formats that audio files can be stored in. We will deal with two common formats that are used in games: WAV files and MP3 files. A WAV file stores the audio data in an uncompressed format.</p><p>Although WAV files can be used for all of your audio, they are typically used for sound effects. Sound effects are typically very short, often less than 1 second. This means that the size of the file is going to be relatively small because the audio file is very short.</p><p>While sound effects are often saved as WAV files, music, typically, is not. This is because the length of music tends to be much longer than the length of sound effects. Loading a music file into memory that is three-to-five minutes long would take an exorbitant amount of memory.</p><p>There are two main techniques that are used to deal with larger audio files. First, data compression can be used to make the audio files smaller. One of the most common audio formats that provides data compression is the MP3 format. Using mathematical trickery, MP3 files store the sound data in less space without sacrificing any sound quality.</p><p>The second technique that is used to handle large files is streaming. Instead of loading the entire sound file into memory, the file is sent a piece at a time as a continuous stream of data, which is<a id="id389" class="indexterm"/> then played in the game.</p><p>There are some limitations to streaming. First, the transfer of data from a hard drive or another storage device is much slower that the transfer of data from memory. Streamed audio can suffer from lag, which is the amount of time that it takes for a sound to play from the time that the sound was triggered to play in code.</p><p>Lag is more critical for sound effects than it is for music. This is because a particular sound effect often coincides with something that just happened in the game. It would be disconcerting if the sound of a bullet occurred a half second after the bullet was fired! Music, on the other hand, often starts and runs for several minutes. A small lag in the start of the music can often be overlooked.</p></div><div class="section" title="Making noise"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec106"/>Making noise</h2></div></div></div><p>Going into <a id="id390" class="indexterm"/>a full-blown course on creating sounds and music is, of course, beyond the scope of this book. However, I did want to give you a few resources to get you started.</p><p>The first question you may ask is where to find sounds. There are literally thousands of sites on the Web that provide sounds and music that can be used in games. Many charge a fee, while a few offer free audio.</p><p>One thing to keep in mind is that <span class="emphasis"><em>royalty-free</em></span> doesn't necessarily mean free. Royalty-free audio means that once you obtain a license to use the audio, you won't have to pay any additional fees to use the music.</p><p>So, here's my big tip. Every site that I have found charges a small fee for both sound effects and music. But there is one way that I have found to obtain sounds for free using the <a id="id391" class="indexterm"/>
<span class="strong"><strong>Unity Asset Store</strong></span>. Go to <a class="ulink" href="http://unity3d.com">http://unity3d.com</a> and<a id="id392" class="indexterm"/> install the free version of Unity. Once you have started Unity, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new project by clicking <span class="strong"><strong>Create New Project </strong></span>tab from the <span class="strong"><strong>Unity Project Wizard</strong></span>. Click <span class="strong"><strong>Browse</strong></span> and navigate to or create a folder to store your project in. Then click <span class="strong"><strong>Select Folder</strong></span>.</li><li class="listitem">Once Unity loads the project, click <span class="strong"><strong>Window</strong></span> and then <span class="strong"><strong>Asset Store</strong></span> from the menu.</li><li class="listitem">When the <span class="strong"><strong>Asset Store</strong></span> window appears, enter a relevant search term (for example, music or SFX) in the <span class="strong"><strong>Search Asset Store</strong></span> text box and press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">Browse the results for free assets. Click on any listing for more details. If you find something that you like, click the <span class="strong"><strong>Download</strong></span> link.</li><li class="listitem">Once<a id="id393" class="indexterm"/> Unity has downloaded the asset, the <span class="strong"><strong>Importing Package</strong></span> screen will appear titled. Click the <span class="strong"><strong>Import</strong></span> button.</li><li class="listitem">You can now exit Unity and navigate to the folder where you created the new project. Then navigate inside the <code class="literal">Assets</code> folder. From here, it depends on the structure of the package that you imported, but if you browse around, you should be able to locate the audio files.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip46"/>Tip</h3><p>In fact, we are<a id="id394" class="indexterm"/> using a musical piece titled Jolly Bot provided by Robson Cozendey (<a class="ulink" href="http://www.cozendey.com">www.cozendey.com</a>). We also found a great SFX package from.</p></div></div></li><li class="listitem">You can now copy the audio files into your project!<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip47"/>Tip</h3><p>As you browse around for audio files, you will run across some files with the <code class="literal">ogg</code> extension. This is a common audio format similar to MP3. However, the engine that we will use does not support ogg files, so you will need to convert them to MP3 files. Audacity, which is described next, will allow you to convert audio files from one format to another.</p></div></div></li></ol></div><p>You may find that you want to edit or mix your audio files. Or, you may need to convert your audio files from one format to another. The best free tool that I found to work with audio is <span class="strong"><strong>Audacity</strong></span>, and you can download it at <a class="ulink" href="http://audacity.sourceforge.net/">http://audacity.sourceforge.net/</a>. Audacity is <a id="id395" class="indexterm"/>a full-featured audio mixer that will allow you to play, edit, and convert audio files.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip48"/>Tip</h3><p>To export files to the MP3 format, you will need a copy of <span class="strong"><strong>LAME</strong></span> installed on your system. You <a id="id396" class="indexterm"/>can download LAME from <a class="ulink" href="http://lame.buanzo.org/#lamewindl">http://lame.buanzo.org/#lamewindl</a>.</p></div></div></div></div></div>
<div class="section" title="Revving up your engine"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec41"/>Revving up your engine</h1></div></div></div><p>Now that you have a better understanding of how audio works in your computer, it's time to write some code to bring audio into your game. We generally don't work with audio directly. Instead, there are audio engines that do all of the hard work for us, and one of the most popular ones is <span class="strong"><strong>FMOD</strong></span>.</p><p>FMOD is a<a id="id397" class="indexterm"/> C and C++ API that allows us to load, manage, and play audio sources. FMOD is free to use for student and independent projects, so it is the perfect audio engine for our game. To use FMOD, you will have to go to the FMOD website, download the appropriate version of the API, and install it on your system:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To download FMOD, go<a id="id398" class="indexterm"/> to <a class="ulink" href="http://www.FMOD.org/download/">http://www.FMOD.org/download/</a>.</li><li class="listitem">There several downloads to choose from. Scroll down to the <span class="strong"><strong>FMOD Ex Programmer's API,</strong></span> and click the <span class="strong"><strong>Download</strong></span> button for Windows.</li><li class="listitem">You will have to locate the exe file that you just downloaded and install it. Make a note of the folder that FMOD is installed in.</li><li class="listitem">Once you have downloaded FMOD, you will have to incorporate it into the game project. Start by opening the <code class="literal">RoboRacer2D</code> project.</li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip49"/>Tip</h3><p>I'm sure that you would like to see<a id="id399" class="indexterm"/> the full documentation for the <span class="strong"><strong>FMOD API</strong></span>. If you installed FMOD in the default location, you will find the documentation at <code class="literal">C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\documentation</code>. The main documentation is found in the file fmodex.chm.</p></div></div><p>Now, it's time to set up our game to use FMOD. Similar to most third-party libraries, there are three steps to hooking things up:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Accessing the <code class="literal">.dll</code> file.</li><li class="listitem">Linking to the library.</li><li class="listitem">Point to the include files.</li></ol></div><p>Let' walk through this process.</p><div class="section" title="Accessing the FMOD .dll file"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec107"/>Accessing the FMOD .dll file</h2></div></div></div><p>There are<a id="id400" class="indexterm"/> several <code class="literal">.dll</code> files that are included with FMOD, and it is important to use the correct file. The following table summarizes the dll files that come with FMOD and their associated library file:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Dll</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Library</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fmodex.dll</code>
</p>
</td><td style="text-align: left" valign="top">
<p>32 bit FMOD API</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">fmodex_vc.lib</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fmodexL.dll</code>
</p>
</td><td style="text-align: left" valign="top">
<p>32 bit FMOD API with debug logging</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">fmodexL_vc.lib</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fmodex64.dll</code>
</p>
</td><td style="text-align: left" valign="top">
<p>64 bit FMOD API</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">fmodex64_vc.lib</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fmodexL64.dll</code>
</p>
</td><td style="text-align: left" valign="top">
<p>64 bit FMOD API with debug logging</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">fmodexL64_vc.lib</code>
</p>
</td></tr></tbody></table></div><p>It's up to you to decide whether or not to use the 32-bit or 64-bit versions of the library. The debug versions of the library write logging information out to a file. You can find more information in the documentation.</p><p>We are going to use the 32-bit file in our game. There are several places where we can place the file, but the simplest method is to simply copy the <code class="literal">.dll</code> file into our project:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Navigate to <code class="literal">C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\api</code>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip50"/>Tip</h3><p>The preceding path assumes that you used the default install location. You may have to modify the path if you chose another location.</p></div></div></li><li class="listitem">Copy <code class="literal">fmodex.dll</code> to the project folder that contains the <code class="literal">RoboRacer2D</code> source code.</li></ol></div></div><div class="section" title="Linking to the library"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec108"/>Linking to the library</h2></div></div></div><p>The next step is to tell Visual Studio that we want to access the FMOD library. This is done by adding<a id="id401" class="indexterm"/> the library to the project properties:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right-click on the project and choose <span class="strong"><strong>Properties</strong></span>.</li><li class="listitem">Open the <span class="strong"><strong>Linker</strong></span> branch under <span class="strong"><strong>Configuration Properties</strong></span> and click on <span class="strong"><strong>Input</strong></span>.<div class="mediaobject"><img src="graphics/8199OS_07_01.jpg" alt="Linking to the library"/></div></li><li class="listitem">Click in<a id="id402" class="indexterm"/> the <span class="strong"><strong>Addition Dependencies</strong></span> entry, then click the drop-down arrow and choose <span class="strong"><strong>&lt;Edit…&gt;</strong></span>.</li><li class="listitem">Add <code class="literal">fmodex_vc.lib</code> to the list of dependencies.<div class="mediaobject"><img src="graphics/8199OS_07_02.jpg" alt="Linking to the library"/></div></li><li class="listitem">Click <span class="strong"><strong>OK</strong></span> to<a id="id403" class="indexterm"/> close the <code class="literal">Additional Dependencies</code> window.</li><li class="listitem">Click <span class="strong"><strong>OK</strong></span> to close the <code class="literal">Property Pages</code> window.</li></ol></div><p>Now, we have to tell Visual Studio where to find the library:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right-click on the project and choose <span class="strong"><strong>Properties</strong></span>.<div class="mediaobject"><img src="graphics/8199OS_07_03.jpg" alt="Linking to the library"/></div></li><li class="listitem">Open the <span class="strong"><strong>Linker</strong></span> branch<a id="id404" class="indexterm"/> under <span class="strong"><strong>Configuration Properties</strong></span> and click on <span class="strong"><strong>General</strong></span>.</li><li class="listitem">Click in the <span class="strong"><strong>Additional Library Directories</strong></span> entry, then click the drop-down arrow and choose <span class="strong"><strong>&lt;Edit…&gt;</strong></span>:<div class="mediaobject"><img src="graphics/8199OS_07_04.jpg" alt="Linking to the library"/></div></li><li class="listitem">Click<a id="id405" class="indexterm"/> on the <span class="strong"><strong>New Line</strong></span> icon, and then click the ellipses (<span class="strong"><strong>…</strong></span>) that appear.</li><li class="listitem">Navigate to <code class="literal">C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\api\lib</code> and click <span class="strong"><strong>Select Folder</strong></span>.</li><li class="listitem">Click on <span class="strong"><strong>OK</strong></span> to close the <span class="strong"><strong>Additional Library Directories</strong></span> window.</li><li class="listitem">Click on <span class="strong"><strong>OK</strong></span> to close the <span class="strong"><strong>Property Pages</strong></span> window.</li></ol></div></div><div class="section" title="Point to the include files"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec109"/>Point to the include files</h2></div></div></div><p>Whenever you use third-party code, you generally have to include C++ header files in your code. Sometimes, we just copy the relevant header files into the project folder (for example, this is what we did with <code class="literal">SOIL.h</code>).</p><p>With larger <a id="id406" class="indexterm"/>code bases, such as FMOD, we point Visual Studio to the location where the header files are installed:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right-click on the project and choose <span class="strong"><strong>Properties</strong></span>.<div class="mediaobject"><img src="graphics/8199OS_07_05.jpg" alt="Point to the include files"/></div></li><li class="listitem">Open<a id="id407" class="indexterm"/> the <span class="strong"><strong>C/C++</strong></span> branch under <span class="strong"><strong>Configuration Properties</strong></span> and click on <span class="strong"><strong>General</strong></span>.</li><li class="listitem">Click on the <span class="strong"><strong>Additional Include Directories</strong></span> entry, then click the drop-down arrow, and choose <span class="strong"><strong>&lt;Edit…&gt;</strong></span>.<div class="mediaobject"><img src="graphics/8199OS_07_06.jpg" alt="Point to the include files"/></div></li><li class="listitem">Click the <a id="id408" class="indexterm"/><span class="strong"><strong>New Line</strong></span> icon, and then click the ellipses (<span class="strong"><strong>…</strong></span>) that appear.</li><li class="listitem">Navigate to <code class="literal">C:\Program Files (x86)\FMOD SoundSystem\FMOD Programmers API Windows\api\inc</code> and click <span class="strong"><strong>Select Folder</strong></span>.</li><li class="listitem">Click <span class="strong"><strong>OK</strong></span> to close the <span class="strong"><strong>Additional Include Directories</strong></span> window.</li><li class="listitem">Click <span class="strong"><strong>OK</strong></span> to close the <span class="strong"><strong>Property Pages</strong></span> window.</li></ol></div><p>The final step is to include the header files into our program. Open <code class="literal">RoboRacer2D.cpp</code> and add the following line to include the header file:</p><div class="informalexample"><pre class="programlisting">#include "fmod.hpp"</pre></div><p>You are finally ready to use our audio engine!</p></div></div>
<div class="section" title="Initializing FMOD"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec42"/>Initializing FMOD</h1></div></div></div><p>The first code <a id="id409" class="indexterm"/>that we need to add is the code that will initialize the audio engine. Just like we must initialize OpenGL, the code will set up FMOD and check to see if there are any errors along the way.</p><p>Open <code class="literal">RoboRacer2D.cpp</code> and add the following code to the variable declarations area:</p><div class="informalexample"><pre class="programlisting">FMOD::System* audiomgr;</pre></div><p>Then add the following function:</p><div class="informalexample"><pre class="programlisting">bool InitFmod()
{
  FMOD_RESULT result;
  result = FMOD::System_Create(&amp;audiomgr);
  if (result != FMOD_OK)
  {
    return false;
  }
  result = audiomgr-&gt;init(50, FMOD_INIT_NORMAL, NULL);
  if (result != FMOD_OK)
  {
    return false;
  }
  return true;
}</pre></div><p>This function <a id="id410" class="indexterm"/>creates the FMOD system and initializes it:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we define a variable to catch FMOD error codes</li><li class="listitem" style="list-style-type: disc">The <code class="literal">System_Create</code> call creates the engine and stores the results in <code class="literal">audiomgr</code></li><li class="listitem" style="list-style-type: disc">We then initialize FMOD with 50 virtual channels, normal mode, and</li></ul></div><p>Finally, we need call the <code class="literal">InitAudio</code> function. Modify the <code class="literal">GameLoop</code> function, adding the highlighted line:</p><div class="informalexample"><pre class="programlisting">void GameLoop(const float p_deltatTime)
{
  if (m_gameState == GameState::GS_Splash)
  {
    <span class="strong"><strong>InitFmod();</strong></span>
    BuildFont();
    LoadTextures();
    m_gameState = GameState::GS_Loading;
  }
  Update(p_deltatTime);
  Render();
}</pre></div><div class="section" title="Virtual channels"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec110"/>Virtual channels</h2></div></div></div><p>The most significant feature that FMOD provides for us is <span class="strong"><strong>virtual channels</strong></span>. Each sound that you play has <a id="id411" class="indexterm"/>to have its own channel to play on. The number <a id="id412" class="indexterm"/>of physical channels to play audio varies from device to device. Early sound cards could only handle two to four channels of sound at a time. Modern sound cards may be able to handle eight, sixteen, or even more.</p><p>It used to be up to the developer to make sure that the number of sounds playing at any one time did not exceed the number of channels on the hardware. If the game triggered a new sound and no channel was available, then the sound wouldn't play. This led to choppy, unpredictable audio.</p><p>Fortunately, FMOD handles all of this for us. FMOD uses virtual channels, and allows you to decide how many virtual channels you want to use. Behind the scenes, FMOD decides which virtual channels need to be assigned to a hardware channel at any given time.</p><p>In our code example, we initialized FMOD with 50 virtual channels. This is actually way more that we will use in this game, but it wouldn't be outrageous for a full game. When considering how many virtual channels to assign, you should think about how many audio sources will be loaded at any particular time. These sounds won't all be playing at one time, just available to play.</p></div><div class="section" title="Channel priority"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec111"/>Channel priority</h2></div></div></div><p>FMOD can't make your hardware play more simultaneous sounds than it has physical sound channels, so you may wonder why you would ever assign more virtual channels than there<a id="id413" class="indexterm"/> are hardware channels.</p><p>The first answer to<a id="id414" class="indexterm"/> this question is that you really don't know how many hardware channels will be available on the system where a player is actually playing your game. The use of virtual channels takes this concern away from you.</p><p>The second answer is that virtual channels allow you to design your audio as if you really had 50 (or 100) channels available to you. FMOD then takes care of managing those channels behind the scenes.</p><p>So, what happens if your game needs to play a ninth sound and there are only eight physical channels? FMOD uses a priority system to decide which of the current eight channels is no longer needed. For example, channel seven may be assigned to a sound effect that is no longer playing. FMOD then assigns channel seven to the new sound that wants to play.</p><p>If all physical channels are actually playing a sound right now and FMOD needs to play a new sound, then it chooses the channel with the lowest priority, stops playing the sound on that channel, and<a id="id415" class="indexterm"/> plays the new sound. Factors that determine<a id="id416" class="indexterm"/> priority include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How long ago the sound was triggered</li><li class="listitem" style="list-style-type: disc">Whether a sound is set to loop continuously</li><li class="listitem" style="list-style-type: disc">The priority assigned by the programmer using the <code class="literal">Channel:setPriority</code> or <code class="literal">Sound::setDefaults</code> functions</li><li class="listitem" style="list-style-type: disc">In 3D sound, how far away the sound is</li><li class="listitem" style="list-style-type: disc">The current volume of the sound</li></ul></div><p>So, you can still end up with sounds that drop out if your sound design exceeds the number of simultaneous, physical channels. But FMOD does its best to limit the impact this will have.</p></div></div>
<div class="section" title="Bleeps and bloops"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Bleeps and bloops</h1></div></div></div><p>Imagine watching a move that has no sound. As the main character runs down the alley, there are no footsteps. There is no swishing sound as his arms rub his jacket. There is no screech as a car <a id="id417" class="indexterm"/>comes to a halt just before hitting him.</p><p>A movie without sound would be pretty boring, and so would most games. Sounds bring games to life. The best sound design is one where the player doesn't actually realize there is a sound design. This means crafting sound effects and music in a way that complement the game without being obnoxious.</p><div class="section" title="Sound effects"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec112"/>Sound effects</h2></div></div></div><p>Sound effects generally correspond to some event or action that is happening in the game. A particular sound often corresponds to something that the player can see, but sound effects may also occur for something that the player cannot see, perhaps just round the corner.</p><p>Let's add our first<a id="id418" class="indexterm"/> sound effects to the game. We'll keep it simple and add the following sounds:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A rolling sound as Robo moves across the screen</li><li class="listitem" style="list-style-type: disc">A sound when Robo jumps up or jumps down</li><li class="listitem" style="list-style-type: disc">A happy<a id="id419" class="indexterm"/> sound when he collides with an oil can</li><li class="listitem" style="list-style-type: disc">A not-so-happy sound when he collides with a water bottle</li></ul></div><div class="section" title="Setting up the sounds"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec26"/>Setting up the sounds</h3></div></div></div><p>We'll start by<a id="id420" class="indexterm"/> setting up some variables to act as pointers to our sounds. Open <code class="literal">RoboRacer2D.cpp</code> and add the following code in the variable declarations section:</p><div class="informalexample"><pre class="programlisting">FMOD::Sound* sfxWater;
FMOD::Sound* sfxOilcan;
FMOD::Sound* sfxJump; 
FMOD::Sound* sfxMovement;
FMOD::Channel* chMovement;</pre></div><p>We have three pointers to sound and one pointer to a channel. We only need one channel pointer because only one sound (<code class="literal">sfxMovement</code>) will be a looping sound. Looping sounds need a persistent channel pointer while one-shot sounds do not.</p><p>Next, we will load these sounds. Add the following function to <code class="literal">RoboRacer2D.cpp</code>:</p><div class="informalexample"><pre class="programlisting">const bool LoadAudio()
{
  FMOD_RESULT result;
  result = audiomgr-&gt; createSound ("resources/oil.wav", FMOD_DEFAULT, 0, &amp;sfxOilcan);
  result = audiomgr-&gt; createSound ("resources/water.wav", FMOD_DEFAULT, 0, &amp;sfxWater);
  result = audiomgr-&gt; createSound ("resources/jump.wav", FMOD_DEFAULT, 0, &amp;sfxJump);
  result = audiomgr-&gt;createSound("resources/movement.wav", FMOD_LOOP_NORMAL | FMOD_2D | FMOD_HARDWARE, 0, &amp;sfxMovement);
  result = audiomgr-&gt;playSound(FMOD_CHANNEL_FREE, sfxMovement, true, &amp;chMovement);
return true; }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip51"/>Tip</h3><p>You can download these sounds from the book's website or you can replace them with your own. Just be sure that you are using very short sounds for oil, water, and jump because they are intended to play quickly.</p></div></div><p>This function loads our three sound effects files into the audio system.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">createSound</code> function allocates memory for the sound and sets the FMOD properties for the sound.</li><li class="listitem" style="list-style-type: disc"><code class="literal">FMOD_DEFAULT</code> sets up the following FMOD properties:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">FMOD_LOOP_OFF</code>: The sound plays once and does not loop</li><li class="listitem" style="list-style-type: disc"><code class="literal">FMOD_2D</code>: This is a 2D sound</li><li class="listitem" style="list-style-type: disc"><code class="literal">FMOD_HARDWARE</code>: This uses the hardware features of the device to handle audio</li></ul></div></li><li class="listitem" style="list-style-type: disc">The result variable catches return value. In production games, you would test this each time to make sure that the sound had successfully loaded (we leave those error checks off here to save space).</li><li class="listitem" style="list-style-type: disc">Notice that we call <code class="literal">playSound</code> on the movement SFX. We are going to start this sound, assign it to the next free hardware channel (<code class="literal">FMOD_CHANNEL_FREE</code>), but tell FMOD to immediately pause it (thus the <code class="literal">true</code> parameter). When we want to play the sound, we will play it, and when we want it to stop, we will pause it.</li><li class="listitem" style="list-style-type: disc">We will call <code class="literal">playSound</code> on the other SFX as needed. As they are not looping sounds, we do not have to manage their paused state.</li></ul></div><p>Notice that<a id="id421" class="indexterm"/> we set <code class="literal">sfxJump</code>, <code class="literal">sfxOilcan</code>, and <code class="literal">sfxWater</code> to use the <code class="literal">FMOD_DEFAULT</code> settings. However, we will need <code class="literal">sfxMovement</code> to loop, so we had to set its setting flags individually.</p><p>There are several flags that you can use to set the properties of a sound, and you can use the OR operator (<code class="literal">|</code>) to combine flags:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">FMOD_HARDWARE</code>: This uses the device hardware to handle the audio.</li><li class="listitem" style="list-style-type: disc"><code class="literal">FMOD_SOFTWARE</code>: This uses FMOD's software emulation to handle the audio (slower, but could give access to features not supported by the device).</li><li class="listitem" style="list-style-type: disc"><code class="literal">FMOD_2D</code>: This is a 2D sound. This is the format we will use for this game!</li><li class="listitem" style="list-style-type: disc"><code class="literal">FMOD_3D</code>: This is a 3D sound. 3D sounds can be placed in 3D space and appear to have both distance (for example, the sound gets softer as it is further away) and position (left, right, in front of, behind).</li><li class="listitem" style="list-style-type: disc"><code class="literal">FMOD_LOOP_OFF</code>: The sound plays once and does not loop.</li><li class="listitem" style="list-style-type: disc"><code class="literal">FMOD_LOOP_NORMAL</code>: The sound plays and then starts over again, looping indefinitely.</li></ul></div><p>There are many other flags that can be set. Take a look at the FMOD documentation for additional details.</p><p>Now that <a id="id422" class="indexterm"/>we have a function to load our sounds, we have to wire it into the initialization for the game. Modify the <code class="literal">GameLoop</code> function, adding the following highlighted line:</p><div class="informalexample"><pre class="programlisting">void GameLoop(const float p_deltatTime)
{
  if (m_gameState == GameState::GS_Splash)
  {
    InitFmod();
<span class="strong"><strong>    LoadAudio();</strong></span>
    BuildFont();
    LoadTextures();
    m_gameState = GameState::GS_Loading;
  }
  Update(p_deltatTime);
  Render();
}</pre></div></div><div class="section" title="Playing sounds"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec27"/>Playing sounds</h3></div></div></div><p>Now, we<a id="id423" class="indexterm"/> need to trigger the sound effects at the appropriate time. Let's start with Robo's movement SFX. Basically, we want to play this sound any time Robo is actually moving.</p><p>We are going to modify the <code class="literal">CM_STOP</code>, <code class="literal">CM_LEFT</code>, and <code class="literal">CM_RIGHT</code> cases in the <code class="literal">ProcessInput</code> function. Update the code inserting the highlighted lines indicated as follows:</p><div class="informalexample"><pre class="programlisting">case Input::Command::CM_STOP:
player-&gt;SetVelocity(0.0f);
background-&gt;SetVelocity(0.0f);
<span class="strong"><strong>chMovement-&gt;setPaused(true);</strong></span>
break;

case Input::Command::CM_LEFT:
if (player == robot_right)
{
  robot_right-&gt;IsActive(false);
  robot_right-&gt;IsVisible(false);
  robot_left-&gt;SetPosition(robot_right-&gt;GetPosition());
  robot_left-&gt;SetValue(robot_right-&gt;GetValue());
}
player = robot_left;
player-&gt;IsActive(true);
player-&gt;IsVisible(true);
player-&gt;SetVelocity(-50.0f);
background-&gt;SetVelocity(50.0f);
<span class="strong"><strong>chMovement-&gt;setPaused(false);</strong></span>
break;

case Input::Command::CM_RIGHT:
if (player == robot_left)
{
  robot_left-&gt;IsActive(false);
  robot_left-&gt;IsVisible(false);
  robot_right-&gt;SetPosition(robot_left-&gt;GetPosition());
  robot_right-&gt;SetValue(robot_left-&gt;GetValue());
}
player = robot_right;
player-&gt;IsActive(true);
player-&gt;IsVisible(true);
player-&gt;SetVelocity(50.0f);
background-&gt;SetVelocity(-50.0f);
<span class="strong"><strong>chMovement-&gt;setPaused(false);</strong></span>
break;</pre></div><p>Remember, we <a id="id424" class="indexterm"/>already loaded <code class="literal">sfxMovement</code> and assigned it to a virtual channel (<code class="literal">chMovement</code>), then told it to start playing as a paused sound. Actually, in FMOD, you pause and play the channel, not the sound. So, all we have to do now is call <code class="literal">chMovement-&gt;setPaused(true)</code> when Robo is moving and <code class="literal">chMovement-&gt;setPaused(false)</code> when he is not moving.</p><p>Now, we need to handle the oil and water pickups. These can both be handled in the <code class="literal">CheckCollisions</code> function. Modify <code class="literal">CheckCollisions</code> by adding the following highlighted lines of code:</p><div class="informalexample"><pre class="programlisting">void CheckCollisions()
{
  if (player-&gt;IntersectsCircle(pickup))
  {
<span class="strong"><strong>    FMOD::Channel* channel;</strong></span>
<span class="strong"><strong>    audiomgr-&gt;playSound(FMOD_CHANNEL_FREE, sfxOilcan, false, &amp;channel);</strong></span>
    pickup-&gt;IsVisible(false);
    pickup-&gt;IsActive(false);
    player-&gt;SetValue(player-&gt;GetValue() + pickup-&gt;GetValue());
    pickupSpawnTimer = 0.0f;
    pickupsReceived++;
  }
  
  if (player-&gt;IntersectsRect(enemy))
  {
<span class="strong"><strong>    FMOD::Channel* channel;</strong></span>
<span class="strong"><strong>    audiomgr-&gt;playSound(FMOD_CHANNEL_FREE, sfxWater, false, &amp;channel);</strong></span>
    enemy-&gt;IsVisible(false);
    enemy-&gt;IsActive(false);
    player-&gt;SetValue(player-&gt;GetValue() + enemy-&gt;GetValue());
    enemySpawnTimer = 0.0f;
  }
}</pre></div><p>Finally, we <a id="id425" class="indexterm"/>will add a sound effect for Robo when he jumps up or jumps down. These changes will be applied to the <code class="literal">CM_UP</code> and <code class="literal">CM_DOWN</code> cases in the <code class="literal">ProcessInput</code> function. Modify the existing code with the following highlighted lines:</p><div class="informalexample"><pre class="programlisting">case Input::Command::CM_UP:
{
  <span class="strong"><strong>FMOD::Channel* channel;</strong></span>
<span class="strong"><strong>  audiomgr-&gt;playSound(FMOD_CHANNEL_FREE, sfxJump, false, &amp;channel);</strong></span>
  player-&gt;Jump(Sprite::SpriteState::UP);
}
break;

case Input::Command::CM_DOWN:
{
  <span class="strong"><strong>FMOD::Channel* channel;</strong></span>
<span class="strong"><strong>  audiomgr-&gt;playSound(FMOD_CHANNEL_FREE, sfxJump, false, &amp;channel);</strong></span>
  player-&gt;Jump(Sprite::SpriteState::DOWN);
}
break;</pre></div><p>These sound effects are one-shot sounds. When they are done playing, we don't need to worry about them any more until it is time to play them again. For this type of sound, we create a channel (<code class="literal">FMOD::channel* channel</code>), then call <code class="literal">playSound</code> using:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">FMOD_CHANNEL_FREE</code>: This lets FMOD pick the next available hardware sound channel.</li><li class="listitem" style="list-style-type: disc">Sound pointer: <code class="literal">sfxWater</code> for the water bottle, <code class="literal">sfxOilcan</code> for the oil, and <code class="literal">sfxJump</code> for the jump SFX.</li><li class="listitem" style="list-style-type: disc"><code class="literal">false</code>: Don't pause the sound!</li><li class="listitem" style="list-style-type: disc"><code class="literal">&amp;channel</code>: This is the virtual channel handle. Notice that this is just a local variable. We don't need to store this anywhere for one-shot SFX.</li></ul></div><p>That's it! If <a id="id426" class="indexterm"/>you play the game now, the four SFX should trigger according to our design.</p></div></div><div class="section" title="UI feedback"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec113"/>UI feedback</h2></div></div></div><p>So far, we created sound effects to respond to events and actions in the game. Sound effects are also <a id="id427" class="indexterm"/>used to provide feedback from the user interface. For example, when the player clicks a button, there should be some kind of audio <a id="id428" class="indexterm"/>that plays so that the player immediately knows that the click was registered.</p><p>Fortunately, we already trap each time the user has clicked a UI button, so it's easy to trigger a sound each time it happens. Let's start by adding a new sound pointer. In <code class="literal">RoboRacer2D.cpp</code>, add the following line to the variable declarations:</p><div class="informalexample"><pre class="programlisting">FMOD::Sound* sfxButton;</pre></div><p>Then add the following code to <code class="literal">LoadAudio</code>:</p><div class="informalexample"><pre class="programlisting">result = audiomgr-&gt;createSound("resources/button.wav", FMOD_DEFAULT, 0, &amp;sfxButton);</pre></div><p>Finally, add the following highlighted lines of code to the <code class="literal">CM_UI</code> case in <code class="literal">ProcessInput</code>:</p><div class="informalexample"><pre class="programlisting">case Input::Command::CM_UI:
<span class="strong"><strong>FMOD::Channel* channel;</strong></span>
if (pauseButton-&gt;IsClicked())
{
<span class="strong"><strong>  audiomgr-&gt;playSound(FMOD_CHANNEL_FREE, sfxButton, false, &amp;channel);</strong></span>
  pauseButton-&gt;IsClicked(false);
  pauseButton-&gt;IsVisible(false);
  pauseButton-&gt;IsActive(false);
  
  resumeButton-&gt;IsClicked(false);
  resumeButton-&gt;IsVisible(true);
  resumeButton-&gt;IsActive(true);
  m_gameState = GS_Paused;
}

if (resumeButton-&gt;IsClicked())
{
<span class="strong"><strong>  audiomgr-&gt;playSound(FMOD_CHANNEL_FREE, sfxButton, false, &amp;channel);</strong></span>
  resumeButton-&gt;IsClicked(false);
  resumeButton-&gt;IsVisible(false);
  resumeButton-&gt;IsActive(false);
  
  pauseButton-&gt;IsClicked(false);
  pauseButton-&gt;IsVisible(true);
  pauseButton-&gt;IsActive(true);
  m_gameState = GS_Running;
}

if (playButton-&gt;IsClicked())
{
<span class="strong"><strong>  audiomgr-&gt;playSound(FMOD_CHANNEL_FREE, sfxButton, false, &amp;channel);</strong></span>
  playButton-&gt;IsClicked(false);
  exitButton-&gt;IsActive(false);
  playButton-&gt;IsActive(false);
  creditsButton-&gt;IsActive(false);
  m_gameState = GameState::GS_Running;
}

if (creditsButton-&gt;IsClicked())
{
<span class="strong"><strong>  audiomgr-&gt;playSound(FMOD_CHANNEL_FREE, sfxButton, false, &amp;channel);</strong></span>
  creditsButton-&gt;IsClicked(false);
  exitButton-&gt;IsActive(false);
  playButton-&gt;IsActive(false);
  creditsButton-&gt;IsActive(false);
  m_gameState = GameState::GS_Credits;
}

if (exitButton-&gt;IsClicked())
{
<span class="strong"><strong>  audiomgr-&gt;playSound(FMOD_CHANNEL_FREE, sfxButton, false, &amp;channel);</strong></span>
  playButton-&gt;IsClicked(false);
  exitButton-&gt;IsActive(false);
  playButton-&gt;IsActive(false);
  creditsButton-&gt;IsActive(false);
  PostQuitMessage(0);
}

if (menuButton-&gt;IsClicked())
{
<span class="strong"><strong>  audiomgr-&gt;playSound(FMOD_CHANNEL_FREE, sfxButton, false, &amp;channel);</strong></span>
  menuButton-&gt;IsClicked(false);
  menuButton-&gt;IsActive(false);
  m_gameState = GameState::GS_Menu;
}

if (continueButton-&gt;IsClicked())
{
<span class="strong"><strong>  audiomgr-&gt;playSound(FMOD_CHANNEL_FREE, sfxButton, false, &amp;channel);</strong></span>
  continueButton-&gt;IsClicked(false);
  continueButton-&gt;IsActive(false);
  m_gameState = GameState::GS_Running;
}

if (replayButton-&gt;IsClicked())
{
<span class="strong"><strong>  audiomgr-&gt;playSound(FMOD_CHANNEL_FREE, sfxButton, false, &amp;channel);</strong></span>
  replayButton-&gt;IsClicked(false);
  replayButton-&gt;IsActive(false);
  exitButton-&gt;IsActive(false);
  RestartGame();
  m_gameState = GameState::GS_Running;
}
break;</pre></div><p>At this<a id="id429" class="indexterm"/> point, when you run the game you will now hear an <a id="id430" class="indexterm"/>SFX each time a button is clicked.</p></div></div>
<div class="section" title="The sound of music"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec44"/>The sound of music</h1></div></div></div><p>We now turn to the audio soundtrack for our game. Just like a movie soundtrack, the music that is played during a game sets the tone for the game. Many games have huge, orchestrated productions, while others have synthesized or 8-bit music.</p><p>As we have<a id="id431" class="indexterm"/> already discussed, music files are handled in a different manner from sound effects. This is because sound effects are usually very short sounds that can be best stored as wav files. Music files tend to be much longer, and are stored as MP3 files because the data can be compressed, taking less storage and less memory.</p><p>We are going to add a single music track to our game. To keep things simple, we will tell the track to loop so that it runs continuously throughout the game.</p><p>We will start by adding a sound pointer. Open <code class="literal">RoboRacer2D.cpp</code> and add the following line of code to the variable declarations:</p><div class="informalexample"><pre class="programlisting">FMOD::Sound* musBackground;</pre></div><p>Next, go to the <code class="literal">LoadAudio</code> function and add the following line:</p><div class="informalexample"><pre class="programlisting">result = audiomgr-&gt;createSound("resources/jollybot.mp3", FMOD_LOOP_NORMAL | FMOD_2D | FMOD_HARDWARE, 0, &amp;musBackground);
FMOD::Channel* channel;
result = audiomgr-&gt;playSound(FMOD_CHANNEL_FREE, musBackground, false, &amp;channel);</pre></div><p>Notice that we use <code class="literal">createStream</code> instead of <code class="literal">createSound</code> to load our music file. As music is so much longer than sound effects, music is streamed from storage rather than loaded directly into memory.</p><p>We want the sound track to start when the game starts, so we start playing the music in right after it is loaded using <code class="literal">playSound</code>.</p><p>That's all there is to it! Our game is now enhanced by a vibrant soundscape.</p></div>
<div class="section" title="Cleaning up the house"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Cleaning up the house</h1></div></div></div><p>We have a pretty <a id="id432" class="indexterm"/>complete game. Sure, it's not going to set any records or make anyone rich, but if this is your first game, then congratulations!</p><p>We have been remiss in one area: good programming dictates that any time we create an object, we delete it when we are done using it. Up to now, you may be wondering if we were ever going to do this! Well, now is the time.</p><p>We made a placeholder for all of these operations in the <code class="literal">EndGame</code> function. Now, we will add the necessary<a id="id433" class="indexterm"/> code to properly release our resources.</p><div class="section" title="Release sprites"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec114"/>Release sprites</h2></div></div></div><p>Let's start by <a id="id434" class="indexterm"/>clearing out our sprites. It is important to<a id="id435" class="indexterm"/> remember that when we remove any resource, we need to make sure that it is also releasing its own resources. This is the purpose of the class destructor. Let's use the <code class="literal">Sprite</code> class as an example. Open <code class="literal">Sprite.cpp</code> and you should see a destructor defined using the following code:</p><div class="informalexample"><pre class="programlisting">Sprite::~Sprite()
{
  for (int i = 0; i &lt; m_textureIndex; i++)
  {
    glDeleteTextures(1, &amp;m_textures[i]);
  }
  delete[] m_textures;
  m_textures = NULL;
}</pre></div><p>We first want to release all of the textures in the <code class="literal">m_textures</code> array. Then we use <code class="literal">delete[]</code> to release the <code class="literal">m_textures</code> array. It is also good programming practice to set the variable to <code class="literal">NULL</code> once an object has been deleted.</p><p>The <code class="literal">Sprite</code> destructor will be called when we call <code class="literal">delete</code> on a sprite object. So, the first thing we need to add to <code class="literal">EndGame</code> is a <code class="literal">delete</code> operation for each sprite that was created for our game. Add the following lines of code to the <code class="literal">EndGame</code> function:</p><div class="informalexample"><pre class="programlisting">delete robot_left;
delete robot_right;
delete robot_right_strip;
delete robot_left_strip;
delete background;
delete pickup;
delete enemy;
delete pauseButton;
delete resumeButton;
delete splashScreen;
delete menuScreen;
delete creditsScreen;
delete playButton;
delete creditsButton;
delete exitButton;
delete menuButton;
delete nextLevelScreen;
delete continueButton;
delete gameOverScreen;
delete replayButton;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip52"/>Tip</h3><p>If you look<a id="id436" class="indexterm"/> closely, you will notice that we<a id="id437" class="indexterm"/> did not delete the player object. This is because player was only used as a pointer to sprites that had already been created. Put another way, we never used player to create a new Sprite. A good rule of thumb is that there should be exactly one delete for every new.</p></div></div></div><div class="section" title="Release input"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec115"/>Release input</h2></div></div></div><p>Our next system<a id="id438" class="indexterm"/> to shut down is the input system. First, let's<a id="id439" class="indexterm"/> complete the <code class="literal">Input</code> destructor. Add the highlighted code to the destructor in the <code class="literal">Input</code> class:</p><div class="informalexample"><pre class="programlisting">Input::~Input()
{
  <span class="strong"><strong>delete[] m_uiElements;</strong></span>
<span class="strong"><strong>  m_uiElements = NULL;</strong></span>
}</pre></div><p>We have to delete the <code class="literal">uiElements</code> array, which was an array of pointers to the sprites that were part of the input system. Note that we did not delete the actual sprites here because they were not created by the input system.</p><p>Now, add the following line of code to <code class="literal">EndGame</code>:</p><div class="informalexample"><pre class="programlisting">delete inputManager;</pre></div></div><div class="section" title="Releasing fonts"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec116"/>Releasing fonts</h2></div></div></div><p>Add this<a id="id440" class="indexterm"/> line to release the display lists we used to store<a id="id441" class="indexterm"/> our fonts:</p><div class="informalexample"><pre class="programlisting">KillFont();</pre></div></div><div class="section" title="Releasing audio"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec117"/>Releasing audio</h2></div></div></div><p>Our final<a id="id442" class="indexterm"/> cleanup is the audio system. Add the following lines<a id="id443" class="indexterm"/> of code to <code class="literal">EndGame</code>:</p><div class="informalexample"><pre class="programlisting">sfxWater-&gt;release();
sfxOilcan-&gt;release();
sfxJump-&gt;release();
sfxMovement-&gt;release();
sfxButton-&gt;release();
musBackground-&gt;release();
audiomgr-&gt;release(); </pre></div><p>Congratulations! Your house is all cleaned up.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Summary</h1></div></div></div><p>We covered a lot of material in this chapter, and in the process, we completed our 2D game. You learned a little about how audio is represented in the computer. Then we installed the FMOD API and learned how to integrate it into our project. Finally, we used FMOD to set up and play sound effects and music in our game.</p><p>This chapter completes our discussion of game programming in 2D. As you should now be aware, there is a lot more to completing a game than using the OpenGL library. Remember, OpenGL is a rendering library. We had to write our own class to handle input and we used a third-party class to handle audio.</p><p>In the next chapter, we begin our foray into the world of 3D programming!</p></div></body></html>