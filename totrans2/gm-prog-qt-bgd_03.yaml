- en: Chapter 3. Qt GUI Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*This chapter will help you learn how to use Qt to develop applications with
    a graphical user interface using the Qt Creator IDE. We will get familiar with
    the core Qt functionality, property system, and the signals and slots mechanism
    that we will later use to create complex systems such as games. We will also cover
    the various actions and resource system of Qt. By the end of this chapter, you
    will be able to write your own programs that communicate with the user through
    windows and widgets.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Windows and dialogs
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic skill that you need to learn is creating windows, showing them
    on a screen, and managing their content.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Qt project
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step to develop an application with Qt Creator is to create a project
    using one of the templates provided by the editor.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a Qt Desktop project
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you first start Qt Creator, you will see a welcome screen. From the **File**
    menu, choose **New File or Project**. There are a number of project types to choose
    from. follow the given steps for creating a Qt Desktop project:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: For a widget-based application, choose the **Applications** group and the **Qt
    Gui Application** template:![Time for action – creating a Qt Desktop project](img/8874OS_03_01.jpg)
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to choose a name and location for your new project:![Time for
    action – creating a Qt Desktop project](img/8874OS_03_02.jpg)
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to create a simple tic-tac-toe game, so we will name our project
    `tictactoe` and provide a nice location for it.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a common directory where you put all your projects, you can tick
    the **Use as default project location** checkbox for Creator to remember the location
    and suggest it the next time when you start a new project.
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you click on **Next**, you will be presented with a window that lets you
    choose one or more of the defined compilation kits for the project. Proceed to
    the next step without changing anything. You will be presented with the option
    of creating the first widget for your project. Fill in the data as shown in the
    following screenshot:![Time for action – creating a Qt Desktop project](img/8874OS_03_03.jpg)
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on **Next** and **Finish**.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creator created a new subdirectory in the directory that you previously chose
    for the location of the project and where you put a number of files. Two of these
    files (`tictactoewidget.h` and `tictactoewidget.cpp`) implement the `TicTacToeWidget`
    class as the subclass of `QWidget`. The third file called `main.cpp` contains
    code for the entry point of the application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This file creates an instance of the `QApplication` class and feeds it with
    standard arguments to the `main()` function. Then, it instantiates our `TicTacToeWidget`
    class, calls its `show` method, and finally returns a value returned by the `exec`
    method of the application object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '`QApplication` is a singleton class that manages the whole application. In
    particular, it is responsible for processing events that come from within the
    application or from external sources. For events to be processed, an event loop
    needs to be running. The loop waits for incoming events and dispatches them to
    proper routines. Most things in Qt are done through events—input handling, redrawing,
    receiving data over the network, triggering timers, and so on. This is the reason
    we say that Qt is an event-oriented framework. Without an active event loop, nothing
    would function properly. The `exec` call in `QApplication` (or to be more specific,
    in its base class—`QCoreApplication`) is responsible for entering the main event
    loop of the application. The function does not return until your application requests
    the event loop to be terminated. When this eventually happens, the `main` function
    returns and your application ends.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The final file that was generated is called `tictactoe.pro` and is the project
    configuration file. It contains all the information that is required to build
    your project using the tools Qt provides. Let''s analyze this file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first two lines enable Qt's `core`, `gui`, and `widgets` modules. The next
    two lines specify that your project file describes an application (as opposed
    to, for example, a library) and declares the name of the target that is executable
    to be `tictactoe`. The last two lines add files that Creator generated for us
    to build the process.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: What we have now is a complete minimal Qt GUI project. To build and run it,
    simply choose the **Run** entry from the **Build** drop-down menu or click on
    the green triangle icon on the left-hand side of the Qt Creator window. After
    a while, you should see a window pop up. Since we didn't add anything to the window,
    it is blank.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Adding child widgets to a window
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After we managed to get a blank window on screen, the next step is to add some
    content to it. To do this, you need to create widgets and tell Qt to position
    them in the window. The basic way to do this is to provide a parent to a widget.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'In Qt, we group objects (such as widgets) into parent-child relationships.
    This scheme is defined in the superclass of `QWidget`—`QObject`, which is the
    most important class in Qt, and we will cover it in more detail later in this
    chapter. What is important now is that each object can have a parent object and
    an arbitrary number of children. In the case of widgets, there is a rule that
    a child occupies a subarea of its parent. If it doesn''t have a parent, then it
    becomes a top-level window that can usually be dragged around, resized, and closed.
    We can set a parent for an object in two ways. One way is to call the `setParent`
    method defined in `QObject` that accepts a `QObject` pointer. Because of the rule
    mentioned earlier, `QWidget` wants to have other widgets as parents, so the method
    is overloaded in `QWidget` to accept a `QWidget` pointer. The other way is to
    pass a pointer to the parent object to the `QWidget` constructor of the child
    object. If you look at the code of the widget that was generated by Creator, you
    will notice that the constructor also accepts a pointer to a widget as its last
    (optional) argument:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It then passes that pointer to the constructor of its base class. Therefore,
    it is important that you always remember to create a constructor for your widgets
    that accepts a pointer to a `QWidget` instance and passes it up the inheritance
    tree. All standard Qt widgets also behave this way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Managing widget content
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Making a widget display as part of its parent is not enough to make a good user
    interface. You also need to set its position and size and react to the changes
    that happen to its content and to the content of its parent widget. In Qt, we
    do this using a mechanism called layouts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Layouts allow us to arrange the content of a widget, making sure that its space
    is used efficiently. When we set a layout on a widget, we can start adding widgets
    and even other layouts, and the mechanism will resize and reposition them according
    to the rules that we specify. When something happens in the user interface that
    influences how widgets should be displayed (for example, the button text is replaced
    with longer text, which makes the button require more space to show its content;
    if not, one of the widgets gets hidden), the layout is triggered again, which
    recalculates all positions and sizes and updates widgets as necessary.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt comes with a predefined set of layouts that are derived from the `QLayout`
    class, but you can also create your own. Those that we already have at our disposal
    are `QHBoxLayout` and `QVBoxLayout`, which position items horizontally and vertically;
    `QGridLayout`, which arranges items in a grid so that an item can span across
    columns or rows; and `QFormLayout`, which creates two columns of items with item
    descriptions in one column and item content in the other. There is also `QStackedLayout`,
    which is rarely used directly and which makes one of the items assigned to it
    possess all the available space. You can see the most common layouts in action
    in the following figure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing widget content](img/8874OS_03_04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'To use a layout, we need to create an instance of it and pass a pointer to
    a widget that we want it to manage. Then, we can start adding widgets to the layout:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can even move widgets further from each other by setting spacing on the
    layout and setting custom margins on the layout:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After building and running this code, you see two buttons that are evenly distributed
    in their parent space. Note that, even though we didn't explicitly pass the parent
    widget pointer, adding a widget to a layout makes it reparent the newly added
    widget to the widget that the layout manages. Resizing the parent horizontally
    would also cause buttons to resize again, covering all the space available. However,
    if you resize `parentWidget` vertically, buttons will change their position but
    not their height.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because each widget has an attribute called a size policy, which decides
    how a widget is to be resized by a layout. You can set separate size policies
    for horizontal and vertical directions. A button has a vertical size policy of
    `Fixed`, which means that the height of the widget will not change from the default
    height regardless of how much space there is available. The following are the
    available size policies:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '`Ignore`: In this, the default size of the widget is ignored and the widget
    can freely grow and shrink'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fixed`: In this, the default size is the only allowed size of the widget'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Preferred`: In this, the default size is the desired size, but both smaller
    and bigger sizes are acceptable'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Minimum`: In this, the default size is the smallest acceptable size for the
    widget, but the widget can be made larger without hurting its functionality'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Maximum`: In this, the default size is the largest size of the widget and
    the widget can be shrunk (even to nothing) without hurting its functionality'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Expanding`: In this, the default size is the desired size; a smaller size
    (even zero) is acceptable but the widget is able to increase its usefulness when
    more and more space is assigned to it'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MinimumExpanding`: This is a combination of `Minimum` and `Expanding`—the
    widget is greedy in terms of space and it cannot be made smaller than its default
    size'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we determine the default size? The answer is by the size returned by
    the `sizeHint` virtual method. For layouts, the size is calculated based on the
    sizes and size policies of their child widgets and nested layouts. For basic widgets,
    the value returned by `sizeHint` depends on the content of the widget. In the
    case of a button, if it holds a line of text and an icon, `sizeHint` will return
    the size that is required to fully encompass the text, icon, some space between
    them, the button frame, and the padding between the frame and content itself.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – implementing a tic-tac-toe game board
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now create a widget that implements a game board for tic-tac-toe using
    buttons.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `tictactoewidget.h` file in Creator and update it by adding the highlighted
    code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our additions create a list that can hold pointers to instances of the `QPushButton`
    class, which is the most commonly used button class in Qt. It will represent our
    game board. We have to teach the compiler to understand the classes that we use;
    thus, we add a forward declaration of the `QPushButton` class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create a method that will help us create all the buttons
    and use a layout to manage their geometries. Go to the header file again and add
    a `void setupBoard();` declaration in the `private` section of the class. To quickly
    implement a freshly declared method, we can ask Qt Creator to create the skeleton
    code for us by positioning the text cursor just before after the method declaration
    (before the semicolon), pressing *Alt* + *Enter* on the keyboard, and choosing
    **Add definition in tictactoewidget.cpp** from the pop-up.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It also works the other way around. You can write the method body first and
    then position the cursor on the method signature, press *Alt* + *Enter*, and choose
    **Add public declaration** from the quick fix menu. There are also various other
    context-dependent fixes that are available in Creator.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Because in the header file we only forward-declared `QPushButton`, we now need
    to provide a full class definition for it by including an appropriate header file.
    In Qt, all classes are declared in the header files that are called exactly the
    same as the classes themselves. Thus, to include a header file for `QPushButton`,
    we need to add a `#include <QPushButton>` line to the implementation file. We
    are also going to use the `QGridLayout` class to manage the space in our widget,
    so we need `#include <QGridLayout>` as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From now on, this book will not remind you about adding the `include` directives
    to your source code—you will have to take care of this by yourself. This is really
    easy, just remember that to use a Qt class, you need to include a file named after
    that class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the code to the body of the `setupBoard` method. First, let''s
    create a layout that will hold our buttons:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we can start adding buttons to the layout:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code creates a loop over rows and columns of the board. In each iteration,
    it creates an instance of the `QPushButton` class and sets the button's size policy
    to `Minimum`/`Minimum` so that when we resize the widget, buttons also get resized.
    A button is assigned a single space as its content so that it gets the correct
    initial size. Then, we add the button to the layout in `row` and `column`. At
    the end, we store the pointer to the button in the list that was declared earlier.
    This lets us reference any of the buttons later on. They are stored in the list
    in such an order that the first three buttons of the first row are stored first,
    then the buttons from the second row, and finally those from the last row.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do is to tell our widget that `gridLayout` is going to manage
    its size:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Alternatively, we might have passed this as a parameter to the layout's constructor.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have code that will prepare our board, we need to have it invoked
    somewhere. A good place to do this is the class constructor:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, build and run the program.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should get a window containing nine buttons positioned in a grid-like fashion.
    If you start resizing the window, the buttons are going to be resized as well.
    This is because we set a grid layout with three columns and three rows that evenly
    distributes widgets in the managed area, as shown in the following figure:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/8874OS_03_05.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: 'While we''re here, add another `public` method to the class and name it `initNewGame`.
    We will use this method to clear the board when a new game is started. The body
    of the method should look as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed that although we created a number of objects in `setupBoard`
    using the `new` operator, we didn't destroy those objects anywhere (for example,
    in the destructor). This is because of the way the memory is managed by Qt. Qt
    doesn't do any garbage collecting (as Java does), but it has this nice feature
    related to `QObject` parent-child hierarchies. The rule is that whenever a `QObject`
    instance is destroyed, it also deletes all its children. Since both the layout
    object and the buttons are the children of the `TicTacToeWidget` instance, they
    will all be deleted when the main widget is destroyed. This is another reason
    to set parents to the objects that we create—if we do this, we don't have to care
    about explicitly freeing any memory.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Qt meta-objects
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the special functionality that Qt offers revolves around the `QObject`
    class and the meta-object paradigm that we will take a closer look at now. The
    paradigm says that with every `QObject` subclass, there is a special object associated
    that contains information about that class. It allows us to make runtime queries
    to learn useful things about the class—the class name, superclass, constructors,
    methods, fields, enumerations, and so on. The meta-object is generated for the
    class at compile time when three conditions are met:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The class is a descendant of `QObject`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It contains a special `Q_OBJECT` macro in a private section of its definition
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code of the class is preprocessed by a special **Meta-Object Compiler** (**moc**)
    tool
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can comply to the first two conditions ourselves by writing proper code for
    the class just like Qt Creator does when we create a class derived from `QObject`.
    The last condition is met automatically when you use a tool chain that comes with
    Qt (and Qt Creator) to build your project. Then, it is enough to make sure that
    the file containing the class definition is added to the `HEADERS` variable of
    the project file and Qt will take care of the rest. What really happens is that
    moc generates some code for us that is later compiled in the main program.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: All features discussed in this section of the chapter require a meta-object
    for the class. Therefore, it is essential to make sure that the three conditions
    I mentioned are met if you want a class to use any of those features.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To trigger functionality as a response to something that happens in an application,
    Qt uses a mechanism of signals and slots. This is based on connecting a notification
    (which we call a **signal**) about a change of state in some object with a function
    or method (called a **slot**) that is executed when such a notification arises.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots can be used with all classes that inherit `QObject`. A signal
    can be connected to a slot, member function, or functor (which includes a regular
    global function). When an object emits a signal, any of these entities that are
    connected to that signal will be called. A signal can also be connected to another
    signal in which case, emitting the first signal will make the other signal be
    emitted as well. You can connect any number of slots to a single signal and any
    number of signals to a single slot.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'A signal slot connection is defined by the following four attributes:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: An object that changes its state (sender)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A signal in the sender object
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object that contains the function to be called (receiver)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A slot in the receiver
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To declare a signal, we put its declaration, that is, a regular member function
    declaration in a special class scope called signals. However, we don't implement
    such a function—this will be done automatically by moc. To declare a slot, we
    put the declaration in the class scope of either public slots, protected slots,
    or private slots. Slots are regular methods and can be called directly in code
    just like any other method. Contrary to signals, we need to provide bodies for
    slot methods.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample class implementing some signals and slots looks like as shown in the
    following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Signals and slots can be connected and disconnected dynamically using the `connect()`
    and `disconnect()` statements.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The classic `connect` statement looks as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This statement establishes a connection between `SIGNAL` of the `spinBox` object
    called `valueChanged` that carries an `int` parameter and a `setValue` slot in
    the `dial` object that accepts an `int` parameter. It is forbidden to put variable
    names or values in a `connect` statement. You can only make a connection between
    a signal and slot that have matching signatures, which means that they accept
    the same types of arguments (any type casts are not allowed, and type names have
    to match exactly) with the exception that the slot can omit an arbitrary number
    of last arguments. Therefore, the following `connect` statement is valid:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is because the parameter of the `valueChanged` signal can be discarded
    before `clear` is called. However, the following statement is invalid:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is nowhere to get the value that is to be passed to `setText`, so such
    a connection will fail.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important that you wrap signal and slot signatures into the `SIGNAL` and
    `SLOT` macros and that when you specify signatures, you only pass argument types
    and not values or variable names. Otherwise, the connection will fail.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Since Qt 5, there are a couple of different connect syntax available that don't
    require a meta-object for the class implementing the slot. The `QObject` legacy
    is still a requirement though, and the meta-object is still required for the class
    that emits the signal.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'The first additional syntax that we can use is the one where we pass a pointer
    to the signal method and a pointer to the slot method instead of wrapping signatures
    in the `SIGNAL` and `SLOT` macros:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this situation, the slot can be any member function of any `QObject` subclass
    that has argument types that match the signal or such that can be converted to
    match the signal. This means that you can, for example, connect a signal carrying
    a double value with a slot taking an int parameter:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important aspect is that you cannot freely mix meta-object-based and function-pointer-based
    approaches. If you decide to use pointers to member methods in a particular connection,
    you have to do that for both the signal and the slot.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even go a step further and have a signal connected to a standalone function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you use C++11, the function can also be a lambda expression in which case,
    it is possible to write the body of the slot directly in the `connect` statement:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is especially useful if you want to invoke a slot with a fixed argument
    value that can''t be carried by a signal because it has less arguments. A solution
    is to invoke the slot from a lambda function (or a standalone function):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A function can even be replaced with a function object (functor). To do this,
    we create a class for which we overload the call operator that is compatible with
    the signal that we wish to connect to, as shown in the following snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is often a nice way to execute a slot with an additional parameter that
    is not carried by the signal, as this is much cleaner than using a lambda expression.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: There are some aspects of signals and slots that we have not covered here. We
    will come back to them later when we deal with multithreading.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – making signal-slot connections
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. For which of the following do you have to provide your own implementation?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: A signal
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A slot
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. Which of the following statements are valid?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`connect(sender, SIGNAL(textEdited(QString)), receiver, SLOT(setText("foo")))`'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`connect(sender, SIGNAL(toggled(bool)), receiver, SLOT(clear()));`'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`connect(sender, SIGNAL(valueChanged(7)), receiver, SLOT(setValue(int)));`'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`connect(sender, &QPushButton::clicked, receiver, &QLineEdit::clear);`'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Time for action – functionality of a tic-tac-toe board
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to implement a function that will be called upon by clicking on any
    of the nine buttons on the board. It has to change the text of the button that
    was clicked on—either `X` or `O`—based on which player made the move; then, it
    has to check whether the move resulted in winning the game by the player (or a
    draw if no more moves are possible), and if the game ended, it should emit an
    appropriate signal, informing the environment about the event.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks on a button, the `clicked()` signal is emitted. Connecting
    this signal to a custom slot lets us implement the mentioned functionality, but
    since the signal doesn''t carry any parameters, how do we tell which button caused
    the slot to be triggered? We could connect each button to a separate slot but
    that''s an ugly solution. Fortunately, there are two ways of working around this
    problem. When a slot is invoked, a pointer to the object that caused the signal
    to be sent is accessible through a special method in `QObject` called `sender()`.
    We can use that pointer to find out which of the nine buttons stored in the board
    list is the one that caused the signal to fire:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'While `sender()` is a useful call, we should try to avoid it in our own code
    as it breaks some principles of object-oriented programming. Moreover, there are
    situations where calling this function is not safe. A better way is to use a dedicated
    class called `QSignalMapper`, which lets us achieve a similar result without using
    `sender()` directly. Modify the `setupBoard()` method in `TicTacToeWidget` as
    follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we first created an instance of `QSignalMapper` and passed a pointer to
    the board widget as its parent so that the mapper is deleted when the widget is
    deleted. Then, when we create buttons, we "teach" the mapper that each of the
    buttons has a number associated with it—the first button will have the number
    `0`, the second one will be bound to the number `1`, and so on. By connecting
    the `clicked()` signal from the button to mapper's `map()` slot, we tell the mapper
    to do its magic upon receiving that signal. What the mapper will do is that it
    will then find the mapping of the sender of the signal and emit another signal—`mapped()`—with
    the mapped number as its parameter. This allows us to connect to that signal with
    a slot (`handleButtonClick`) that takes the index of the button in the board list.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to implement the slot itself (remember to declare it in the
    header file!). However, before we do that, let''s add a useful enum and a few
    helper methods to the class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This enum lets us specify information about players in the game. We can use
    it immediately to mark whose move it is now. To do so, add a private field to
    the class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, add the two public methods to manipulate the value of this field:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last method emits a signal, so we have to add the signal declaration to
    the class definition along with another signal that we are going to use:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we only emit the `currentPlayerChanged` signal when the current player
    really changes. You always have to pay attention that you don't emit a "changed"
    signal when you set a value to a field to the same value that it had before the
    function was called. Users of your classes expect that if a signal is called changed,
    it is emitted when the value really changes. Otherwise, this can lead to an infinite
    loop in signal emissions if you have two objects that connect their value setters
    to the other object's changed signal.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s declare the `handleButtonClick` slot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And then implement it in the `.cpp` file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we first retrieve a pointer to the button based on its index. Then, we
    check whether the button contains any text—if so, then this means that it doesn't
    participate in the game anymore, so we return from the method so that the player
    can pick another field in the board. Next, we set the current player's mark on
    the button. Then, we check whether the player has won the game, passing it the
    row (`index / 3`) and column (`index % 3`) index of the current move. If the game
    didn't end, we switch the current player and return. Otherwise, we emit a `gameOver()`
    signal, telling our environment who won the game. The `checkWinCondition()` method
    returns `Player1`, `Player2`, or `Draw` if the game has ended and `Invalid` otherwise.
    We will not show the implementation of this method here as it is quite complex.
    Try implementing it on your own and if you encounter problems, you can see the
    solution in the code bundle that accompanies this book.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from signals and slots, Qt meta-objects also give programmers an ability
    to use the so-called properties that are essentially named attributes that can
    be assigned values of a particular type. They are useful to express important
    features of an object—like text of a button, size of a widget, player names in
    games, and so on.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a property
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a property, we first need to declare it in a private section of a
    class that inherits `QObject` using a special `Q_PROPERTY` macro, which lets Qt
    know how to use the property. A minimal declaration contains the type of the property,
    its name, and information about a method name that is used to retrieve a value
    of the property. For example, the following code declares a property of the type
    `double` that is called `height` and uses a method called `height` to read the
    property value:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The getter method has to be declared and implemented as usual. Its prototype
    has to comply with these rules: it has to be a public method that returns a value
    or constant reference of a type of the property, and it can''t take any input
    parameters and the method itself has to be constant. Typically, a property will
    manipulate a private member variable of the class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Such a property is practically useless because there is no way to change its
    value. Luckily, we can extend the declaration to include the information about
    how to write a value to the property:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Again, we have to declare and implement `setHeight` so that it behaves as the
    setter method for the property—it needs to be a public method that takes a value
    or constant reference of the type of the property and returns void:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Property setters are good candidates for public slots so that you can easily
    manipulate property values using signals and slots.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about some of the other extensions to `Q_PROPERTY` declarations
    in the later chapters of this book.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Using a property
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two ways in which you can access properties. One is of course, to
    use getter and setter methods that we declared with `READ` and `WRITE` keywords
    in the `Q_PROPERTY` macro—this will naturally work since they are regular C++
    methods.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The other way is to use facilities offered by `QObject` and the meta-object
    system. They allow to us access properties by name using two methods that accept
    property names as strings. A generic property getter (which returns the property
    value) is a method called `property`. Its setter counterpart (that takes the value
    and returns void) is `setProperty`. Since we can have properties with different
    data types, what is the data structure that is used by those two methods that
    hold values for different kinds of properties? Qt has a special class for this
    called `QVariant`, which behaves a lot like a C union in the way that it can store
    values of different types. There are a couple of advantages to using a union though—the
    three most important are that you can ask the object what type of data it currently
    holds, you can convert some of the types to other types (for example, a string
    to an integer), and you can teach it to operate on your own custom types.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding properties to the board class
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this exercise, we will be adding a useful property to the board class. The
    property is going to hold information about the player who should make the next
    move. The type of the property is going to be the `TicTacToeWidget::Player` enumeration
    that we created earlier. For the getter and the setter methods, we are going to
    use the two functions that we created earlier: `currentPlayer()` and `setCurrentPlayer()`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the header file for our class and modify the class definition as shown
    in the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*What just happened?*'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we want to use an enumeration as a type of a property, we have to inform
    Qt's meta-object system about the enum. This is done with the `Q_ENUMS` macro.
    Then, we declare a property called `currentPlayer` and mark our two existing methods
    as getter and setter for the property. We also use the `NOTIFY` keyword to mark
    `currentPlayerChanged` as a signal that is sent to inform about a change in the
    value of the property. We won't be using this extra information in our small game,
    and we don't require `currentPlayer` to be a property at all, but it is always
    a good idea to try and find good candidates for properties and expose them because
    some day, someone might want to use our class in a way we hadn't predicted and
    a particular property might become useful.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Designing GUIs
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have coded all the user interfaces manually by writing C++ code that
    instantiates widgets, arranges them in layouts, and connects signals to slots.
    It is not that hard for simple widgets, but becomes tedious and time-consuming
    when the UI becomes more and more complex. Fortunately, Qt provides tools to do
    all this in a more pleasant way. Instead of writing C++ code, we can create forms
    using a graphical tool by dragging and dropping widgets on a canvas, applying
    layouts to them, and even establishing signal-slot connections using the point-and-click
    technique. Later during the compilation, such forms will get converted into C++
    code for us and will be ready for applying onto a widget.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The tool is called Qt Designer and is integrated with Qt Creator. To use it,
    select **New File** or **Project** from the **File** menu and choose the **Qt
    Designer Form Class** template available after selecting Qt in the **Files and
    Classes** section of the dialog box. You get to choose a template for the form
    and configure details such as the names of the files to create. In the end, three
    files will get created—two of them implement a C++ class derived from `QWidget`
    or one of its subclasses and the last one contains data for the form itself.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'After closing the wizard, we are taken to Qt Creator''s **Design** mode that
    looks as shown in the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing GUIs](img/8874OS_03_06.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: The **Design** mode consists of four major parts that are marked on the preceding
    figure with numbers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The area marked as **1** is the main worksheet. It contains a graphical representation
    of the form being designed where you can move widgets around, compose them into
    layouts, and see how they react. It also allows further manipulation of the form
    using the point-and-click method that we will learn later.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The second area **2** is the widget box. It contains a list of available types
    of widget that are arranged into groups containing items with a related or similar
    functionality. Over the list, you can see a box that lets you filter widgets that
    are displayed in the list to only show those that match the entered expression.
    In the beginning of the list, there are also items that are not really widgets—one
    group contains layouts and the other one contains so-called spacers, which are
    a way to push other items away from each other.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of the widget box is to add widgets to the form in the worksheet.
    You can do that by grabbing a widget from the list with the mouse, dragging it
    to the canvas, and releasing the mouse button. The widget will appear in the form
    and can be further manipulated with further tools in Creator's Design mode.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The next area **3**, which we are going to talk about, is situated on the right-hand
    side of the window and consists of two parts. At the top of the figure, you can
    see Object Inspector. It presents the parent-child relationship of all widgets
    that are currently present in the edited form. Each line contains the name of
    the object and the name of its class as seen by the meta-object system. If you
    click on an entry, a corresponding widget in the form gets selected (and vice
    versa).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The lower part of the figure shows the property editor. You can use it to change
    the values of all the properties that each object has. Properties are grouped
    by their classes that they have been declared in, starting from `QObject` (the
    base class implementing properties), which declares only one but an important
    property—`objectName`. Following `QObject`, there are properties declared in `QWidget`,
    which is a direct descendant of `QObject`. They are mainly related to the geometry
    and layout policies of the widget. Lower in the list, you can find properties
    that come from further derivations of `QWidget`. If you prefer a pure alphabetical
    order where properties are not grouped by their class, you can switch the view
    using a pop-up menu that becomes available after you click on the wrench icon
    positioned over the property list; however, once you get familiar with the hierarchy
    of Qt classes, it will be much easier to navigate the list when it is sorted by
    a class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a closer look at the property editor, you can see that some of them
    have arrows beneath them that reveal new rows when clicked. These are composed
    properties where the complete property value is determined from more than one
    subproperty values; for example, if there is a property called `geometry` that
    defines a rectangle, it can be expanded to show four subproperties: `x`, `y`,
    `width`, and `height`. Another thing that you should quickly notice is that some
    property names are displayed in bold. This means that the property value was modified
    and is different from the default value for this property. This lets you quickly
    find those properties that you have modified.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The last group of functionality **4** that we will explain now is the one positioned
    in the lower part of the window. By default, you will see two tabs—**Action Editor**
    and **Signal/Slot Editor**. They allow us to create helper entities such as actions
    for the menus and toolbars or signal-slot connections between widgets using a
    clean tabular interface.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: What was described here is the basic tool layout. If you don't like it, you
    can invoke the context menu from the main worksheet, uncheck the **Locked** entry,
    and rearrange all the windows to your liking or even close the ones you currently
    don't need.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – designing the game configuration dialog
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will use Qt Designer forms to build a simple game configuration dialog
    that will let us choose names for our players.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'First, invoke the new file dialog from the menu and choose to create a new
    **Qt Designer Form Class** as shown in the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – designing the game configuration dialog](img/8874OS_03_07.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: 'In the window that appears, choose **Dialog with Buttons Bottom**:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – designing the game configuration dialog](img/8874OS_03_08.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: Adjust the class name to `ConfigurationDialog`, leave the rest of the settings
    at their default values, and complete the wizard.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag and drop two labels and two line edits on the form, position them roughly
    in a grid, double-click on each of the labels, and adjust their captions to receive
    a result similar to the following figure:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – designing the game configuration dialog](img/8874OS_03_09.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Select the first line to edit and look at the property editor. Find a property
    called `objectName` and change it to `player1Name`. Do the same for the other
    line and call it `player2Name`. Then, click on some empty space in the form and
    choose the **Layout in a grid** entry in the upper toolbar. You should see the
    widgets snap into place—that's because you have just applied a layout to the form.
    When you're done, open the **Tools** menu, go to the **Form Editor** submenu,
    and choose the **Preview** entry.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can see a new window open that looks exactly like the form we just designed.
    You can resize the window and interact with the objects inside to monitor the
    behavior of the layouts and widgets. What really happened here is that Qt Creator
    built a real window for us based on the description that we provided in all the
    areas of the design mode. Without any compilation, in a blink of an eye we received
    a fully working window with all the layouts working and all the properties adjusted
    to our liking. This is a very important tool so make sure to use it often to verify
    that your layouts are controlling all the widgets as you intended them to—it is
    much faster than compiling and running the whole application just to check whether
    the widgets stretch or squeeze properly. It's all possible thanks to Qt's meta-object
    system.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – polishing the dialog
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the GUI itself works as we intended it to, we can focus on giving the
    dialog some more polish.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Accelerators and label buddies
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we are going to do is add accelerators to our widgets. These
    are keyboard shortcuts that, when activated, cause particular widgets to gain
    keyboard focus or perform a predetermined action (for example, toggle a checkbox
    or push a button). Accelerators are usually marked by underlining them, as shown
    in the following figure:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![Accelerators and label buddies](img/8874OS_03_10.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: We will set accelerators to our line edits so that when the user activates an
    accelerator for the first field, it will gain focus. Through this we can enter
    the name of the first player, and similarly, when the accelerator for the second
    line edit is triggered, we can start typing in the name for the second player.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Start by selecting the label on the left-hand side of the first line edit. Press
    *F2* or double-click on the label (alternatively, find the text property of the
    label in the property editor and activate its value field). This enables us to
    change the text of the label. Navigate using cursor keys so that the text cursor
    is placed before the character `1` and type the `&` character. This character
    marks the character directly after it as an accelerator for the widget. For widgets
    that are composed of both text and the actual functionality (for example, a button),
    this is enough to make accelerators work. However, since `QLineEdit` does not
    have any text associated with it, we have to use a separate widget for that. This
    is why we have set the accelerator on the label. Now, we need to associate the
    label with the line edit so that the activation of the label's accelerator will
    forward it to the widget of our choice. This is done by setting a so-called buddy
    for the label. You can do this in code using the `setBuddy` method of the `QLabel`
    class or using Creator's form designer. Since we're already in the Design mode,
    we'll use the latter approach. For that, we need to activate a dedicated mode
    in the form designer.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Look at the upper part of Creator's window; directly above the form, you will
    find a toolbar containing a couple of icons. Click on the one labeled **Edit buddies**
    or just press *F5* on your keyboard. Now, move the mouse cursor over the label,
    press the mouse button, and drag from the label towards the line edit. When you
    drag the label over the line edit, you'll see a graphical visualization of a connection
    being set between the label and the line edit. If you release the button now,
    the association will be made permanent. You should notice that when such an association
    is made, the ampersand character (`&`) vanishes from the label and the character
    behind it gets an underscore. Repeat this for the other label and corresponding
    line edit. Now, you can preview the form again and check whether accelerators
    work as expected.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The tab order
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you're previewing the form, you can check another aspect of the UI design.
    Start by pressing the *Tab* key and see how the focus moves from widget to widget.
    There is a good chance that the focus will start jumping back and forth between
    buttons and line edits instead of a linear progress from top to bottom (which
    is an intuitive order for this particular dialog). To check and modify the order
    of focus, leave the preview and switch to the tab order editing mode by clicking
    on the icon called Edit Tab Order in the toolbar.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'This mode associates a box with a number to each focusable widget. By clicking
    on the rectangle in the order you wish the widgets to gain focus, you can reorder
    values, thus reordering focus. Now, make it so that the order is as shown in the
    following figure:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![The tab order](img/8874OS_03_11.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: Enter the preview again and check whether the focus changes according to what
    you've set.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When deciding about the tab order, it is good to consider which fields in the
    dialog are mandatory and which are optional. It is a good habit to allow the user
    to tab through all the mandatory fields first, then to the dialog confirmation
    button (for example, one that says **OK** or **Accept**), and then cycle through
    all the optional fields. Thanks to this, the user will be able to quickly fill
    all the mandatory fields and accept the dialog without the need to cycle through
    all the optional fields that the user wants to leave at their default values.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last thing we are going to do right now is make sure that the signal-slot
    connections are set up properly. To do this, switch to the signal-slot editor
    mode by pressing *F4* or choosing **Edit Signals/Slots** from the toolbar. The
    **Dialog with Buttons Bottom** widget template predefines two connections for
    us, which should now become visible in the main canvas area:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![Signals and slots](img/8874OS_03_12.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: The `QDialog` class that implements dialogs in Qt has two useful slots—`accept()`
    and `reject()`—which inform the caller whether the action represented by the dialog
    was accepted or not. For our convenience, these slots should already be connected
    to the respective `accepted()` and `rejected()` signals from the group of buttons
    (which is an instance of the `QDialogButtonBox` class) that by default, contain
    the **OK** and **Cancel** buttons. If you click on any of them signal `accepted()`
    or respectively, `rejected()` will be emitted by the box.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can add some more connections to make our dialog more functional.
    Let's make it such that the button to accept the dialog is only enabled when neither
    of the two line edits is empty (that is, when both the fields contain player names).
    While we will implement the logic itself later, we can now make connections to
    a slot that will perform the task.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Since no such slot exists by default, we need to inform the form editor that
    such a slot will exist at the time when the application is compiled. To do this,
    we need to switch back to the default mode of the form editor by pressing *F3*
    or choosing **Edit Widgets** from the toolbar. Then, you can invoke the form''s
    context menu and choose **Change signals/slots**. A window will pop up such as
    the one shown in the following figure that lists the available signals and slots:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![Signals and slots](img/8874OS_03_13.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **+** button in the **Slots** group and create a slot called `updateOKButtonState()`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Signals and slots](img/8874OS_03_14.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: Then, accept the dialog and go back to the **Signals/Slots** mode. Create a
    new connection by grabbing one of the line edits with your mouse. When you move
    the cursor outside the widget, you will notice a red line following your pointer.
    If the line encounters a valid target, the line will change to an arrow and the
    target object will be highlighted. The form itself can also be a target (or a
    source); in this case, the line will end with a ground mark (two short horizontal
    lines).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: When you release the mouse button, a window will pop up, listing all the signals
    of the source object and all the slots of the target object. Choose the `textChanged(QString)`
    signal. Note that when you do this, some of the available slots will disappear.
    This is because the tool only allows us to choose from slots that are compatible
    with the highlighted signal. Select our newly created slot and accept the dialog.
    Repeat the same for the other line edit.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: What we have done here is that we've created two connections that will trigger
    when the text of either of the two line edits is changed. They will execute a
    slot that doesn't exist yet—by "creating" the slot, we only declared our intention
    to implement it in a `QDialog` subclass that was also created for us. You can
    now go ahead and save the form.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We performed a number of tasks that make our form follow standard behaviors
    known from many applications—this makes form navigation easy and shows the user
    which actions can be undertaken and which are currently not available.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Using designer forms
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you open the form in a text editor (for example, by switching to the Creator's
    **Edit** pane), you will notice that it is really an XML file. So how do we use
    this file?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: As part of the build process, Qt calls a special tool called **User Interface
    Compiler** (**uic**) that reads the file and generates a C++ class that contains
    a `setupUi()` method. This method accepts a pointer to a widget and contains code,
    which instantiates all the widgets, sets their properties, and establishes signal-slot
    connections, and it is our responsibility to call it to prepare the GUI. The class
    itself, which is named after your form (that is after the value of the `objectName`
    property of the form object) with a `Ui` namespace prepended to it (for example,
    `Ui::MyForm`) is not derived from a widget class but is rather meant to be used
    with one. There are basically three ways of doing this.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Direct approach
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most basic way to use a Qt Designer form is to instantiate a widget and
    the form object and to call `setupUi` on the widget, like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This approach has a number of flaws. First of all, it creates a potential memory
    leak of the `ui` object (remember, it is not `QObject`, so you can''t set a parent
    to it so that it''s deleted when the parent is deleted). Second, since all the
    widgets of the form are variables of the `ui` object that is not tied to the widget
    object, it breaks encapsulation, which is one of the most important paradigms
    of object-oriented programming. However, there is a situation when such a construct
    is acceptable. This is when you create a simple short-lived modal dialog. You
    surely need to remember that to show regular widgets, we have been using the `show()`
    method. This is fine for non-modal widgets, but for modal dialogs you should instead
    call the `exec()`method that is defined in the `QDialog` class. This is a blocking
    method that doesn''t return until the dialog is closed. This allows us to modify
    the code so that it becomes:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Since we're creating objects on the stack, the compiler will take care of deleting
    them when the local scope ends.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The multiple-inheritance approach
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second way of using Designer forms is to create a class derived from both
    `QWidget` (or one of its subclasses) and the form class itself. We can then call
    `setupUi` from the constructor:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This way, we keep the encapsulation as our class inherits fields and methods
    from the `Ui` class, and we can call any of them directly from within the class
    code while restricting access from the outside world by using private inheritance.
    The drawback of this approach is that we pollute the class namespace, for example,
    if we had a name object in `Ui::MyForm`, we wouldn't be able to create a `name`
    method in `Widget`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The single inheritance approach
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fortunately, we can work around this using the composition instead of inheritance.
    We can derive our widget class only from `QWidget` and instead of also subclassing
    `Ui::MyForm`, we can make an instance of it a private member of the new class:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: At the cost of having to manually create and destroy the instance of `Ui::MyForm`,
    we can have the additional benefit of containing all variables and code of the
    form in a dedicated object, which prevents the aforementioned namespace pollution.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: This is the recommended way of using Designer forms, and it's also the default
    mode of operation when you tell Qt Creator to generate a Designer form class for
    you.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – the logic of the dialog
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it is time to make our game settings dialog work. Earlier, we declared
    a signal-slot connection but now the slot itself needs to be implemented.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the form class generated by Creator. If you''re still in the Design mode,
    you can quickly jump to the respective form class file using the *Shift* + *F4*
    keyboard shortcut. Create a public slots section of the class and declare a `void
    updateOKButtonState()` slot. Open the refactorization menu (*Alt* + *Enter*) and
    ask Creator to create the skeleton implementation of the slot for you. Fill the
    function body with the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code retrieves player names and checks whether either of them is empty.
    Then, it asks the button box that currently contains the **OK** and **Cancel**
    buttons to give a pointer to the button that accepts the dialog. Then, we set
    the button''s disabled state based on whether both player names contain valid
    values or not. The button state also needs to be updated when we first create
    the dialog, so add invocation of `updateOKButtonState()` to the constructor of
    the dialog:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The next thing to do is to allow to store and read player names from outside
    the dialog—since the `ui` component is private, there is no access to it from
    outside the class code. This is a common situation and one that Qt is also compliant
    with. Each data field in almost every Qt class is private and may contain accessors
    (a getter and optionally a setter), which are public methods that allow to read
    and store values for data fields. Our dialog has two such fields—the names for
    the two players. At this point, we should note that they are good candidates for
    properties so at the end, we'll declare them as such. But first, let's start by
    implementing the accessors.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Setter methods in Qt are usually named using the lowercase pattern, for example,
    `set` followed by the name of the property with the first letter converted to
    uppercase. In our situation, the two setters will be called `setPlayer1Name` and
    s`etPlayer2Name` and they will both accept `QString` and return `void`. Declare
    them in the class header as shown in the following code snippet:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Implement their bodies in the `.cpp` file:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Getter methods in Qt are usually called the same as the property that they
    are related to—`player1Name` and `player2Name`. Put the following code in the
    header file:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Put the following code in the implementation file:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The only thing left to do now is to declare the properties. Add the highlighted
    lines to the class declaration:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Our dialog is now ready. You can test it by creating an instance of it in `main()`
    and calling `show()` or `exec()`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: An application's main window
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already have two major components in our game—the game board and configuration
    dialog. Now, we will need to bind them together. To do this, we will use another
    important component—the `QMainWindow` class. A "main window" represents the control
    center of an application. It can contain menus, toolbars, docking widgets, a status
    bar, and the actual widget content called a "central widget", as presented in
    the following diagram:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![An application''s main window](img/8874OS_03_15.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: The central widget part doesn't need any extra explanation—it is a regular widget
    like any other. We will also not focus on dock widgets or the status bar here.
    They are useful components but they are so easy to master that you can learn about
    them yourself. Instead, we will spend some time mastering menus and toolbars.
    You have surely seen and used toolbars and menus in many applications and you
    know how important they are for good user experience.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: The main hero shared by both these concepts is a class called `QAction`, which
    represents a functionality that can be invoked by a user. A single action can
    have more than one incarnation—it can be an entry in a menu (the `QMenu` instances),
    a toolbar (`QToolBar`), button, or keyboard shortcut (`QShortcut`). Manipulating
    the action (for example, changing its text) causes all its incarnations to update.
    For example, if you have a **Save** entry in the menu (with a keyboard shortcut
    bound to it), a Save icon in the toolbar, and maybe also a **Save** button somewhere
    else in your user interface and you want to disallow saving the document (for
    example, a map in your dungeons and dragons game level editor) because its contents
    haven't changed since the document was last loaded. In this case, if, the menu
    entry, toolbar icon, and button are all linked to the same `QAction` instance
    then, once you set the `enabled` property of the action to `false`, all the three
    entities will become disabled as well. This is an easy way to keep different parts
    of your application in sync—if you disable an action object, you can be sure that
    all entries that trigger the functionality represented by the action are also
    disabled. Actions can be instantiated in code or created graphically using **Action
    Editor** in Qt Creator. An action can have different pieces of data associated
    with it—a text, tooltip, status bar tip, icons, and others that are less often
    used. All these are used by incarnations of your actions.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: The Qt resource system
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While speaking of icons, there is an important feature in Qt that you should
    learn. A natural way of creating icons is by loading images from the filesystem.
    The problem with this is that you have to install a bunch of files together with
    your application and you need to always know where they are located to be able
    to provide paths to access them. This is difficult but fortunately, Qt has a solution
    to this—it allows you to embed arbitrary files (such as images for icons) directly
    in the application that is executable. This is done by preparing resource files
    that are later compiled in the binary. Fortunately, Qt Creator provides a graphical
    tool for this as well.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – the main window of the application
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new **Qt** **Designer Form Class** application. As a template, choose
    **Main Window**. Accept the default values for the rest of the wizard.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an action using the action editor and enter the following values in
    the dialog:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – the main window of the application](img/8874OS_03_16.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: 'Now, create another action and fill it with the values shown in the following
    screenshot:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – the main window of the application](img/8874OS_03_17.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: We want our game to look nice, so we will provide icons for the actions and
    we will embed images for them in our application using the resource system. Create
    a new file and make it **Qt Resource File**. Call it `resources.qrc`. Click on
    the **Add** button and choose **Add Prefix**. Change the value for the prefix
    to `/`. Then, click on the **Add** button again and choose **Add Files**. Find
    appropriate images for your actions and add them to the resource file. A dialog
    will appear asking whether you want to copy the files to the project directory.
    Agree by choosing **Copy**.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – the main window of the application](img/8874OS_03_18.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: Now, edit the actions again in the Action Editor and choose icons for them.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added a resource file to our project. In that resource file, we created entries
    for a number of images. Each of the images is put under a `/` prefix, which stands
    for the root node of the artificial filesystem that we create. Each entry in a
    resource file can be accessed directly from the manually written code as a file
    with a special name. This name is assembled from three components. First comes
    a colon character (`:`), which identifies the resource filesystem. This is followed
    by a prefix (for example, `/`) and a full path of the entry in the resource (for
    example, `exit.png`). This makes an image called `exit.png` accessible through
    the `:/exit.png` path. When we build the project, the file will be transformed
    into a C data array code and integrated with the application binary. Having prepared
    the resource file, we used images embedded there as icons for our actions.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to add these actions to a menu and toolbar.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding a pull-down menu
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a menu for the window, double-click on the **Type Here** text on
    the top of the form and replace the text with `&File`. Then, drag the **New Game**
    action from the action editor over the newly created menu but do not drop it there
    yet. The menu should open now and you can drag the action so that a red bar appears
    in the submenu in the position where you want the menu entry to appear—now you
    can release the mouse button to create the entry. Afterwards, open the menu again
    by clicking on **File** and choose **Add Separator**. Then, repeat the drag-and-drop
    operation for the **Quit** action to insert a menu entry for it just below the
    separator in the **File** menu, as shown in the following figure:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – adding a pull-down menu](img/8874OS_03_19.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using graphical tools, we created a menu for our program and added a number
    of actions (that were automatically transformed into menu items) to that menu.
    Each menu entry received some text and an icon specified by the action that was
    dropped in the menu.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create submenus, first create a menu entry by clicking on the **Type Here**
    line and entering the submenu name. Then, drag and hover an action over such a
    submenu. After a short time, a submenu will pop up and you will be able to drop
    your action there to create an entry in the second-level menu.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a toolbar
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a toolbar, invoke the context menu on the form and choose **Add Tool
    Bar**. Then, drag the **New Game** action over the toolbar and drop it there.
    Open a context menu for the toolbar and choose **Append Separator**. Then, drag
    the **Quit** action from the Action Editor and drop it in the toolbar behind the
    separator. The following figure presents the final layout that you should have
    now:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – creating a toolbar](img/8874OS_03_20.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating toolbars is very similar to creating menus. You first create the container
    (the toolbar) and then drag-and-drop actions from the action editor. You can even
    drag an action from the menu bar and drop it on the toolbar and vice versa!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – filling in the central widget
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add two labels in the main window area—one at the top for the first player
    name and one at the bottom of the form for the second player name—and then change
    their `objectName` property to `player1` and `player2`, respectively. Clear their
    text property so that they don''t display anything. Then, drag **Widget** from
    the widget box, drop it between the two labels'' and set its object name to `gameBoard`.
    Invoke the context menu on the widget that you just dropped and choose **Promote
    to**. This allows us to substitute a widget in the form with another class; in
    our case, we will want to replace the empty widget with our game board. Fill the
    dialog that has just appeared with the values shown in the following figure:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – filling in the central widget](img/8874OS_03_21.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: Then, click on the button labeled **Add** and then **Promote** to close the
    dialog and confirm the promotion. You will not notice any changes in the form
    because the replacement only takes place during compilation. Now, apply a vertical
    layout on the form so that the labels and the empty widget snap into place.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all widget types are directly available in the form designer. Sometimes,
    we need to use widget classes that will only be created in the project that is
    being built. The simplest way to be able to put custom widgets on a form is to
    ask the designer to replace class names with some of the objects when C++ code
    for the form is to be generated. By promoting an object to a different class,
    we saved a lot of work trying to otherwise fit our game board into the user interface.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – putting it all together
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The visual part of the game is ready and what remains is to complete the logic
    of the main window and put all the pieces together. Add a public slot to the class
    and call it `startNewGame`. In the class constructor, connect the **New Game**
    action''s triggered signal to this slot and connect the application''s quit slot
    to the other action:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `qApp` special macro represents a pointer to the application object instance,
    so the preceding code will call the `quit()` slot on the `QApplication` object
    created in `main()`, which in turn will eventually cause the application to end.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the `startNewGame` slot as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this slot, we create the settings dialog and show it to the user, forcing
    him to enter player names. If the dialog was canceled, we abandon the creation
    of a new game. Otherwise, we ask the dialog for player names and set them on appropriate
    labels. Finally, we initialize the board and enable it so that users can interact
    with it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'While writing a turn-based board game, it is a good idea to always clearly
    mark whose turn it is now to make a move. We will do this by marking the moving
    player''s name in bold. There is already a signal in the board class that tells
    us that a valid move was made, which we can react to in order to update the labels.
    Let''s add an appropriate code into the constructor of the main window class:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now for the slot itself; let add a private slot''s section to the class and
    declare the slot there:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we can implement it:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In addition to the slot being called after a signal is emitted, we can also
    use it to set the initial data for the labels when the game is starting. Since
    all the slots are also regular methods, we can simply call `updateNameLabels()`
    from `startNewGame()`—go ahead and invoke `updateNameLabels()` at the end of `startNewGame()`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing that needs to be done is to handle the situation when the game
    ends. Connect the `gameOver()` signal from the board to a new slot in the main
    window class. Implement the slot as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*What just happened?*'
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our code does two things. First, it disables the board so that players can
    no longer interact with it. Second, it checks who won the game, assembles the
    message (we will learn more about `QString` in the next chapter), and shows it
    using a static method `QMessageBox::information()` that shows a modal dialog containing
    the message and a button that allows us to close the dialog. The last thing that
    remains is to update the `main()` function in order to create an instance of our
    `MainWindow` class:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, you can run your first Qt game.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – extending the game
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an additional exercise, you can try to modify the code we have written in
    this chapter to allow playing the game on boards bigger than 3 x 3\. Let the user
    decide about the size of the board (you can modify the game options dialog for
    that and use `QSlider` and `QSpinBox` to allow the user to choose the size of
    the board) and you can then instruct `TicTacToeWidget` to build the board based
    on the size it gets. Remember to adjust the game winning logic! If at any point
    you run into a dead end and do not know which classes and functions to use, consult
    the reference manual.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To quickly find the documentation for a class (or any other page in the docs),
    switch to the **Help** pane, choose **Index** from the drop-down list on top of
    the sidebar, and type in the search term, such as `QAction`. Also, the *F1* key
    is very helpful for browsing the manual. Position the mouse pointer or text cursor
    in the code editor over the name of a class, function, or object and press *F1*
    on your keyboard. By doing this, Qt Creator will happily show you the available
    help information on the chosen subject.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – using widgets
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Q1\. A method that returns the preferred size of a widget is called:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '`preferredSize`'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sizeHint`'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`defaultSize`'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. What is the name of a Qt class that can carry values for any property?
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '`QVariant`'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QUnion`'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QPropertyValue`'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. What is the purpose of the `QAction` object?
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: It represents a functionality that a user can invoke in the program.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It holds a key sequence to move the focus on a widget.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a base class for all forms generated using Qt Designer.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create simple graphical user interfaces
    with Qt. We went through two approaches—creating user interface classes by writing
    all the code directly and designing the user interface with a graphical tool that
    generates most of the code for us. There is no telling which of the two approaches
    is better; each of them is better in some areas and worse in others. In general,
    you should prefer using Qt Designer forms to write code directly because it's
    faster and less prone to errors as most of the code is generated. However, if
    you want to retain more control over the code or your GUI is highly dynamic, writing
    all the code yourself will be easier, especially when you gain enough experience
    with Qt to avoid common pitfalls and learn to use advanced programming constructs.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how the heart of Qt—the meta-object system—works. You should
    now be able to create simple user interfaces and fill them with logic by connecting
    signals to slots—predefined ones as well as custom ones that you now know how
    to define and fill with code.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Qt contains many widget types but I didn't introduce them to you one by one.
    There is a really nice explanation of many widget types in the Qt manual called
    *Qt Widget Gallery*, which shows most of them in action.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: If you have any doubts about using any of those widgets, you can check the example
    code and also look up the appropriate class in the Qt reference manual to learn
    more about them.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些小部件的任何使用有疑问，你可以查看示例代码，并在 Qt 参考手册中查找相应的类，以了解更多关于它们的信息。
- en: Using Qt is much more than just dragging-and-dropping widgets on forms and providing
    some code to glue the pieces together. In the next chapter, you will learn about
    some of the most useful functionalities that Qt has to offer; they do not relate
    to showing graphics on screen, but rather let you manipulate various kind of data.
    This is essential for any game that is more complicated than a simple tic-tac-toe.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Qt 远不止在表单上拖放小部件并提供一些代码来将这些部件粘合在一起。在下一章中，你将了解 Qt 提供的一些最实用的功能；它们与在屏幕上显示图形无关，而是让你能够操作各种类型的数据。这对于比简单的井字棋更复杂的任何游戏来说都是必不可少的。
