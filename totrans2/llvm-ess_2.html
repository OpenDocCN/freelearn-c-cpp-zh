<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Building LLVM IR</h1></div></div></div><p class="calibre7">A high level programming language<a id="id49" class="calibre1"/> facilitates human interaction with the target machine. Most of the popular high level languages today have certain basic elements such as variables, loops, if-else decision making statements, blocks, functions, and so on. A variable holds value of data types; a basic block gives an idea of the scope of the variable. An if-else decision statement helps in selection of a path of code. A function makes a block of code reusable. High level languages may vary in type checking, type casting, variable declarations, complex data types, and so on. However, almost every other language has the basic building blocks listed earlier in this section.</p><p class="calibre7">A language may have its own parser which tokenizes the statement and extracts meaningful information such as identifier, its data type; a function name, its declaration, definition and calls; a loop condition, and so on. This meaningful information may be stored in a data structure where the flow of the code can be easily retrieved. <strong class="calibre2">Abstract Syntax Tree</strong> (<strong class="calibre2">AST</strong>)<a id="id50" class="calibre1"/> is a popular tree representation of the source code. The AST's can be used for further transformation and analysis.</p><p class="calibre7">A language parser<a id="id51" class="calibre1"/> can be written in various ways with various tools such as <code class="email">lex</code>, <code class="email">yacc</code>, and so on, or can even be handwritten. Writing an efficient parser is an art in itself. But this is not what we intend to cover in this chapter. We would like to focus more on LLVM IR and how a high-level language after parsing can be converted to LLVM IR using LLVM libraries.</p><p class="calibre7">This chapter will cover how to construct basic working LLVM sample code, which includes the following:</p><div><ul class="itemizedlist"><li class="listitem">Creating an LLVM module</li><li class="listitem">Emitting a function in a module</li><li class="listitem">Adding a block to a function</li><li class="listitem">Emitting a global variable</li><li class="listitem">Emitting a return statement</li><li class="listitem">Emitting function arguments</li><li class="listitem">Emitting a simple arithmetic statement in a basic block</li><li class="listitem">Emitting if-else condition IR</li><li class="listitem">Emitting LLVM IR for loops</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec12" class="calibre1"/>Creating an LLVM module</h1></div></div></div><p class="calibre7">In the previous chapter, we <a id="id52" class="calibre1"/>got an idea as to how an LLVM IR looks. In LLVM, a module represents a single unit of code that is to be processed together. An LLVM module class is the top-level container for all other LLVM IR objects. The LLVM module contains global variables, functions, data layout, host triples, and so on. Let's create a simple LLVM module.</p><p class="calibre7">LLVM provides <code class="email">Module()</code> constructor for creating a module. The first argument is the name of the module. The second argument is <code class="email">LLVMContext</code>. Let's get these arguments in the main function and create a module as demonstrated here:</p><div><pre class="programlisting">static LLVMContext &amp;Context = getGlobalContext();
static Module *ModuleOb = new Module("my compiler", Context);</pre></div><p class="calibre7">For these functions to work, we need to include certain header files:</p><div><pre class="programlisting">#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
using namespace llvm;
static LLVMContext &amp;Context = getGlobalContext();
static Module *ModuleOb = new Module("my compiler", Context);

int main(int argc, char *argv[]) {
  ModuleOb-&gt;dump();
  return 0;
}</pre></div><p class="calibre7">Put this code in a file, let's say <code class="email">toy.cpp</code> and compile it:</p><div><pre class="programlisting">
<strong class="calibre2">$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy</strong>
<strong class="calibre2">$ ./toy</strong>
</pre></div><p class="calibre7">The output will be as follows:</p><div><pre class="programlisting">
<strong class="calibre2">; ModuleID = 'my compiler'</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec13" class="calibre1"/>Emitting a function in a module</h1></div></div></div><p class="calibre7">Now that <a id="id53" class="calibre1"/>we have <a id="id54" class="calibre1"/>created a module, the next step is to emit a function. LLVM has an <code class="email">IRBuilder</code> class that is used to generate LLVM IR and print it using the <code class="email">dump</code> function of the Module object. LLVM provides the class <code class="email">llvm::Function</code> to create a function and <code class="email">llvm::FunctionType()</code> to associate a return type for the function. Let's assume that our <code class="email">foo()</code> function returns an integer type.</p><div><pre class="programlisting">Function *createFunc(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
  FunctionType *funcType = llvm::FunctionType::get(Builder.getInt32Ty(), false);
  Function *fooFunc = llvm::Function::Create(
      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);
  return fooFunc;
}</pre></div><p class="calibre7">Finally, call function <code class="email">verifyFunction()</code> on <code class="email">fooFunc</code>. This function performs a variety of consistency checks on the generated code, to determine if our compiler is doing everything right.</p><div><pre class="programlisting">int main(int argc, char *argv[]) {
  static IRBuilder&lt;&gt; Builder(Context);
  <strong class="calibre2">Function *fooFunc = createFunc(Builder, "foo");</strong>
  <strong class="calibre2">verifyFunction(*fooFunc);</strong>
  ModuleOb-&gt;dump();
  return 0;
}</pre></div><p class="calibre7">Add the <code class="email">IR/IRBuilder.h</code>, <code class="email">IR/DerivedTypes.h</code> and <code class="email">IR/Verifier.h</code> file in include section.</p><p class="calibre7">The overall <a id="id55" class="calibre1"/>code<a id="id56" class="calibre1"/> is as follows:</p><div><pre class="programlisting">#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Verifier.h"
#include &lt;vector&gt;
using namespace llvm;

static LLVMContext &amp;Context = getGlobalContext();
static Module *ModuleOb = new Module("my compiler", Context);

<strong class="calibre2">Function *createFunc(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {</strong>
<strong class="calibre2">  FunctionType *funcType = llvm::FunctionType::get(Builder.getInt32Ty(), false);</strong>
<strong class="calibre2">  Function *fooFunc = llvm::Function::Create(</strong>
<strong class="calibre2">      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);</strong>
<strong class="calibre2">  return fooFunc;</strong>
<strong class="calibre2">}</strong>

int main(int argc, char *argv[]) {
  static IRBuilder&lt;&gt; Builder(Context);
  Function *fooFunc = createFunc(Builder, "foo");
  verifyFunction(*fooFunc);
  ModuleOb-&gt;dump();
  return 0;
}</pre></div><p class="calibre7">Compile<a id="id57" class="calibre1"/> the <code class="email">toy.cpp</code> with the same options as stated <a id="id58" class="calibre1"/>earlier:</p><div><pre class="programlisting">
<strong class="calibre2">$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy</strong>
</pre></div><p class="calibre7">The output will be as follows:</p><div><pre class="programlisting">
<strong class="calibre2">$ ./toy</strong>
<strong class="calibre2">; ModuleID = 'my compiler'</strong>

<strong class="calibre2">declare i32 @foo()</strong>
</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec14" class="calibre1"/>Adding a block to a function</h1></div></div></div><p class="calibre7">A function consists<a id="id59" class="calibre1"/> of basic blocks. A basic block has an entry point. A <a id="id60" class="calibre1"/>basic block consists of a number of IR instructions, the last instruction being a terminator instruction. It has single exit point. LLVM provides the <code class="email">BasicBlock</code> class to create and handle basic blocks. A basic block might have an entry point as its label, which indicates where to insert the next instructions. We can use the <code class="email">IRBuilder</code> object to hold these new basic block IR.</p><div><pre class="programlisting">BasicBlock *createBB(Function *fooFunc, std::string Name) {
  return BasicBlock::Create(Context, Name, fooFunc);
}</pre></div><p class="calibre7">The overall code is as follows:</p><div><pre class="programlisting">#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Verifier.h"
#include &lt;vector&gt;
using namespace llvm;

static LLVMContext &amp;Context = getGlobalContext();
static Module *ModuleOb = new Module("my compiler", Context);

Function *createFunc(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
  FunctionType *funcType = llvm::FunctionType::get(Builder.getInt32Ty(), false);
  Function *fooFunc = llvm::Function::Create(
      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);
  return fooFunc;
}

<strong class="calibre2">BasicBlock *createBB(Function *fooFunc, std::string Name) {</strong>
<strong class="calibre2">  return BasicBlock::Create(Context, Name, fooFunc);</strong>
<strong class="calibre2">}</strong>

int main(int argc, char *argv[]) {
  static IRBuilder&lt;&gt; Builder(Context);
  Function *fooFunc = createFunc(Builder, "foo");
  BasicBlock *entry = createBB(fooFunc, "entry");
  Builder.SetInsertPoint(entry);
  verifyFunction(*fooFunc);
  ModuleOb-&gt;dump();
  return 0;
}</pre></div><p class="calibre7">Compile<a id="id61" class="calibre1"/> the <code class="email">toy.cpp</code> <a id="id62" class="calibre1"/>file:</p><div><pre class="programlisting">
<strong class="calibre2">$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy</strong>
</pre></div><p class="calibre7">The output will be as follows:</p><div><pre class="programlisting">; ModuleID = 'my compiler'

define i32 @foo() {
entry:
}</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec15" class="calibre1"/>Emitting a global variable</h1></div></div></div><p class="calibre7">Global variables <a id="id63" class="calibre1"/>have visibility of all the functions within a given module. LLVM provides the <code class="email">GlobalVariable</code> class to create global variables and set its properties such as linkage type, alignment, and so on. The <code class="email">Module</code> class has the method <code class="email">getOrInsertGlobal()</code> to create a global variable. It takes two arguments—the first is the name of the variable and the second is the data type of the variable.</p><p class="calibre7">As global variables are part of a module, we create global variables after creating the module. Insert the following code just after creating the module in <code class="email">toy.cpp</code>:</p><div><pre class="programlisting">GlobalVariable *createGlob(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
  ModuleOb-&gt;getOrInsertGlobal(Name, Builder.getInt32Ty());
  GlobalVariable *gVar = ModuleOb-&gt;getNamedGlobal(Name);
  gVar-&gt;setLinkage(GlobalValue::CommonLinkage);
  gVar-&gt;setAlignment(4);
  return gVar;
}</pre></div><p class="calibre7">
<strong class="calibre2">Linkage</strong> <a id="id64" class="calibre1"/>is what <a id="id65" class="calibre1"/>determines if multiple declarations of the same object refer to the same object, or to separate ones. The LLVM reference manual cites the following types of Linkages:</p><div><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/></colgroup><tbody class="calibre16"><tr class="calibre17"><td valign="top" class="calibre18">
<p class="calibre19">
<code class="literal">ExternalLinkage</code>
</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">Externally<a id="id66" class="indexterm"/> visible function.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre18">
<p class="calibre19">
<code class="literal">AvailableExternallyLinkage</code>
</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">Available<a id="id67" class="indexterm"/> for inspection, not emission.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre18">
<p class="calibre19">
<code class="literal">LinkOnceAnyLinkage</code>
</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">Keep<a id="id68" class="indexterm"/> one copy of function when linking (inline)</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre18">
<p class="calibre19">
<code class="literal">LinkOnceODRLinkage</code>
</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">Same, but<a id="id69" class="indexterm"/> only replaced by something equivalent.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre18">
<p class="calibre19">
<code class="literal">WeakAnyLinkage</code>
</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">Keep one<a id="id70" class="indexterm"/> copy of named function when linking (weak)</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre18">
<p class="calibre19">
<code class="literal">WeakODRLinkage</code>
</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">Same, but <a id="id71" class="indexterm"/>only replaced by something equivalent.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre18">
<p class="calibre19">
<code class="literal">AppendingLinkage</code>
</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">Special <a id="id72" class="indexterm"/>purpose, only applies to global arrays.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre18">
<p class="calibre19">
<code class="literal">InternalLinkage</code>
</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">Rename<a id="id73" class="indexterm"/> collisions when linking (static functions).</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre18">
<p class="calibre19">
<code class="literal">PrivateLinkage</code>
</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">Like <a id="id74" class="indexterm"/>internal, but omit from symbol table.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre18">
<p class="calibre19">
<code class="literal">ExternalWeakLinkage</code>
</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">
<code class="literal">ExternalWeak</code> linkage<a id="id75" class="indexterm"/> description.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre18">
<p class="calibre19">
<code class="literal">CommonLinkage</code>
</p>
</td><td valign="top" class="calibre18">
<p class="calibre19">Tentative<a id="id76" class="indexterm"/> definitions</p>
</td></tr></tbody></table></div><p class="calibre7">Alignment gives information about address alignment. An alignment must be a power of <code class="email">2</code>. If not specified explicitly, it is set by the target. The maximum alignment is <code class="email">1 &lt;&lt; 29</code>.</p><p class="calibre7">The <a id="id77" class="calibre1"/>overall code is as follows:</p><div><pre class="programlisting">#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Verifier.h"
#include &lt;vector&gt;
using namespace llvm;

static LLVMContext &amp;Context = getGlobalContext();
static Module *ModuleOb = new Module("my compiler", Context);

Function *createFunc(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
  FunctionType *funcType = llvm::FunctionType::get(Builder.getInt32Ty(), false);
  Function *fooFunc = llvm::Function::Create(
      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);
  return fooFunc;
}

BasicBlock *createBB(Function *fooFunc, std::string Name) {
  return BasicBlock::Create(Context, Name, fooFunc);
}

<strong class="calibre2">GlobalVariable *createGlob(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {</strong>
<strong class="calibre2">  ModuleOb-&gt;getOrInsertGlobal(Name, Builder.getInt32Ty());</strong>
<strong class="calibre2">  GlobalVariable *gVar = ModuleOb-&gt;getNamedGlobal(Name);</strong>
<strong class="calibre2">  gVar-&gt;setLinkage(GlobalValue::CommonLinkage);</strong>
<strong class="calibre2">  gVar-&gt;setAlignment(4);</strong>
<strong class="calibre2">  return gVar;</strong>
<strong class="calibre2">}</strong>

int main(int argc, char *argv[]) {
  static IRBuilder&lt;&gt; Builder(Context);
  GlobalVariable *gVar = createGlob(Builder, "x");
  Function *fooFunc = createFunc(Builder, "foo");
  BasicBlock *entry = createBB(fooFunc, "entry");
  Builder.SetInsertPoint(entry);
  verifyFunction(*fooFunc);
  ModuleOb-&gt;dump();
  return 0;
}</pre></div><p class="calibre7">Compile the <code class="email">toy.cpp</code>:</p><div><pre class="programlisting">
<strong class="calibre2">$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy</strong>
</pre></div><p class="calibre7">The output will be as follows:</p><div><pre class="programlisting">; ModuleID = 'my compiler'

@x = common global i32, align 4

define i32 @foo() {
entry:
}</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec16" class="calibre1"/>Emitting a return statement</h1></div></div></div><p class="calibre7">A function might<a id="id78" class="calibre1"/> return a value or it may return void. Here in our example, we have defined that our function returns an integer. Let's assume that our function returns <code class="email">0</code>. The first step is to get a <code class="email">0</code> value, which can be done using the <code class="email">Constant</code> class.</p><div><pre class="programlisting">Builder.CreateRet(Builder.getInt32(0));</pre></div><p class="calibre7">The overall code is as follows:</p><div><pre class="programlisting">#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Verifier.h"
#include &lt;vector&gt;
using namespace llvm;

static LLVMContext &amp;Context = getGlobalContext();
static Module *ModuleOb = new Module("my compiler", Context);

Function *createFunc(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
  FunctionType *funcType = llvm::FunctionType::get(Builder.getInt32Ty(), false);
  Function *fooFunc = llvm::Function::Create(
      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);
  return fooFunc;
}

BasicBlock *createBB(Function *fooFunc, std::string Name) {
  return BasicBlock::Create(Context, Name, fooFunc);
}

GlobalVariable *createGlob(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
  ModuleOb-&gt;getOrInsertGlobal(Name, Builder.getInt32Ty());
  GlobalVariable *gVar = ModuleOb-&gt;getNamedGlobal(Name);
  gVar-&gt;setLinkage(GlobalValue::CommonLinkage);
  gVar-&gt;setAlignment(4);
  return gVar;
}

int main(int argc, char *argv[]) {
  static IRBuilder&lt;&gt; Builder(Context);
  GlobalVariable *gVar = createGlob(Builder, "x");
  Function *fooFunc = createFunc(Builder, "foo");
  BasicBlock *entry = createBB(fooFunc, "entry");
  Builder.SetInsertPoint(entry);
<strong class="calibre2">  Builder.CreateRet(Builder.getInt32(0));</strong>
  verifyFunction(*fooFunc);
  ModuleOb-&gt;dump();
  return 0;
}</pre></div><p class="calibre7">Compile<a id="id79" class="calibre1"/> <code class="email">toy.cpp</code> file</p><div><pre class="programlisting">
<strong class="calibre2">$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy</strong>
</pre></div><p class="calibre7">The output will be as follows:</p><div><pre class="programlisting">; ModuleID = 'my compiler'

@x = common global i32, align 4

define i32 @foo() {
entry:
  ret i32 0
}</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec160" class="calibre1"/>Emitting function arguments</h1></div></div></div><p class="calibre7">A function takes arguments that have their own data type. For simplification, assume that our function has all the arguments of i32 type (integer 32 bit).</p><p class="calibre7">For example, we will consider that two arguments, a and b, are passed to the
function. We will store these two arguments in a vector:</p><div><pre class="programlisting">
 <strong class="calibre2">static std::vector &lt;std::string&gt; FunArgs;</strong>
 FunArgs.push_back("a");
 FunArgs.push_back("b");
</pre></div><p class="calibre7">The next step is to specify that the function will have two arguments. This can be done by passing the Integer argument to the <code class="email">functiontype</code>.</p><div><pre class="programlisting">Function *createFunc(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
<strong class="calibre2">  std::vector&lt;Type *&gt; Integers(FunArgs.size(), Type::getInt32Ty(Context));</strong>
  FunctionType *funcType =
      llvm::FunctionType::get(Builder.getInt32Ty(), Integers, false);
  Function *fooFunc = llvm::Function::Create(
      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);
  return fooFunc;
}</pre></div><p class="calibre7">The last step is to set the names of the function arguments. This can be done by <code class="email">Function</code> argument iterator in a loop, as shown:</p><div><pre class="programlisting">
<strong class="calibre2">void setFuncArgs(Function *fooFunc, std::vector&lt;std::string&gt; FunArgs) {</strong>
<strong class="calibre2">  unsigned Idx = 0;</strong>
<strong class="calibre2">  Function::arg_iterator AI, AE;</strong>
<strong class="calibre2">  for (AI = fooFunc-&gt;arg_begin(), AE = fooFunc-&gt;arg_end(); AI != AE;</strong>
<strong class="calibre2">       ++AI, ++Idx)</strong>
<strong class="calibre2">    AI-&gt;setName(FunArgs[Idx]);</strong>
<strong class="calibre2">}</strong>
</pre></div><p class="calibre7">The overall code is <a id="id80" class="calibre1"/>as follows:</p><div><pre class="programlisting">#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Verifier.h"
#include &lt;vector&gt;
using namespace llvm;

static LLVMContext &amp;Context = getGlobalContext();
static Module *ModuleOb = new Module("my compiler", Context);
<strong class="calibre2">static std::vector&lt;std::string&gt; FunArgs;</strong>

Function *createFunc(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
<strong class="calibre2">  std::vector&lt;Type *&gt; Integers(FunArgs.size(), Type::getInt32Ty(Context));</strong>
  FunctionType *funcType =
      llvm::FunctionType::get(Builder.getInt32Ty(), <strong class="calibre2">Integers</strong>, false);
  Function *fooFunc = llvm::Function::Create(
      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);
  return fooFunc;
}

<strong class="calibre2">void setFuncArgs(Function *fooFunc, std::vector&lt;std::string&gt; FunArgs) {</strong>
<strong class="calibre2">  unsigned Idx = 0;</strong>
<strong class="calibre2">  Function::arg_iterator AI, AE;</strong>
<strong class="calibre2">  for (AI = fooFunc-&gt;arg_begin(), AE = fooFunc-&gt;arg_end(); AI != AE;</strong>
<strong class="calibre2">       ++AI, ++Idx)</strong>
<strong class="calibre2">    AI-&gt;setName(FunArgs[Idx]);</strong>
<strong class="calibre2">}</strong>

BasicBlock *createBB(Function *fooFunc, std::string Name) {
  return BasicBlock::Create(Context, Name, fooFunc);
}

GlobalVariable *createGlob(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
  ModuleOb-&gt;getOrInsertGlobal(Name, Builder.getInt32Ty());
  GlobalVariable *gVar = ModuleOb-&gt;getNamedGlobal(Name);
  gVar-&gt;setLinkage(GlobalValue::CommonLinkage);
  gVar-&gt;setAlignment(4);
  return gVar;
}

int main(int argc, char *argv[]) {
<strong class="calibre2">  FunArgs.push_back("a");</strong>
<strong class="calibre2">  FunArgs.push_back("b");</strong>
  static IRBuilder&lt;&gt; Builder(Context);
  GlobalVariable *gVar = createGlob(Builder, "x");
  Function *fooFunc = createFunc(Builder, "foo");
<strong class="calibre2">  setFuncArgs(fooFunc, FunArgs);</strong>
  BasicBlock *entry = createBB(fooFunc, "entry");
  Builder.SetInsertPoint(entry);
  Builder.CreateRet(Builder.getInt32(0));
  verifyFunction(*fooFunc);
  ModuleOb-&gt;dump();
  return 0;
}</pre></div><p class="calibre7">Compile<a id="id81" class="calibre1"/> the <code class="email">toy.cpp</code> file:</p><div><pre class="programlisting">
<strong class="calibre2">$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core` -o toy</strong>
</pre></div><p class="calibre7">The output will be as follows:</p><div><pre class="programlisting">
<strong class="calibre2">; ModuleID = 'my compiler'</strong>

<strong class="calibre2">@x = common global i32, align 4</strong>

<strong class="calibre2">define i32 @foo(i32 %a, i32 %b) {</strong>
<strong class="calibre2">entry:</strong>
<strong class="calibre2">  ret i32 0</strong>
<strong class="calibre2">}</strong>
</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec17" class="calibre1"/>Emitting a simple arithmetic statement in a basic block</h1></div></div></div><p class="calibre7">A basic block<a id="id82" class="calibre1"/> consists of a list of <a id="id83" class="calibre1"/>instructions. For example, an instruction can be a simple statement performing tasks based on some simple arithmetic instruction. We will see how the LLVM API can be used to emit arithmetic instructions.</p><p class="calibre7">For example, if we want to multiply first argument a with integer value <code class="email">16</code>, we will create a constant integer value <code class="email">16</code> with the following API:</p><div><pre class="programlisting">
<strong class="calibre2">Value *constant = Builder.getInt32(16);</strong>
</pre></div><p class="calibre7">We already have a from the function argument list:</p><div><pre class="programlisting">
<strong class="calibre2">Value *Arg1 = fooFunc-&gt;arg_begin();</strong>
</pre></div><p class="calibre7">LLVM provides a rich list of API's to create binary operations. You can go through the <code class="email">include/llvm/IR/IRBuild.h</code> file for more details on the APIs.</p><div><pre class="programlisting">Value *createArith(IRBuilder&lt;&gt; &amp;Builder, Value *L, Value *R) {
  return Builder.CreateMul(L, R, "multmp");
}</pre></div><div><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre7">Note that for demo purposes, the preceding function returns multiplication. We leave it to the readers to make this function more flexible to return any binary operations. You can explore more binary operations in <code class="email">include/llvm/IR/IRBuild.h</code>.</p></div><p class="calibre7">The whole code now looks as follows:</p><div><pre class="programlisting">#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Verifier.h"
#include &lt;vector&gt;
using namespace llvm;

static LLVMContext &amp;Context = getGlobalContext();
static Module *ModuleOb = new Module("my compiler", Context);
static std::vector&lt;std::string&gt; FunArgs;

Function *createFunc(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
  std::vector&lt;Type *&gt; Integers(FunArgs.size(), Type::getInt32Ty(Context));
  FunctionType *funcType =
      llvm::FunctionType::get(Builder.getInt32Ty(), Integers, false);
  Function *fooFunc = llvm::Function::Create(
      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);
  return fooFunc;
}

void setFuncArgs(Function *fooFunc, std::vector&lt;std::string&gt; FunArgs) {

  unsigned Idx = 0;
  Function::arg_iterator AI, AE;
  for (AI = fooFunc-&gt;arg_begin(), AE = fooFunc-&gt;arg_end(); AI != AE;
       ++AI, ++Idx)
    AI-&gt;setName(FunArgs[Idx]);
}

BasicBlock *createBB(Function *fooFunc, std::string Name) {
  return BasicBlock::Create(Context, Name, fooFunc);
}

GlobalVariable *createGlob(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
  ModuleOb-&gt;getOrInsertGlobal(Name, Builder.getInt32Ty());
  GlobalVariable *gVar = ModuleOb-&gt;getNamedGlobal(Name);
  gVar-&gt;setLinkage(GlobalValue::CommonLinkage);
  gVar-&gt;setAlignment(4);
  return gVar;
}

<strong class="calibre2">Value *createArith(IRBuilder&lt;&gt; &amp;Builder, Value *L, Value *R) {</strong>
<strong class="calibre2">  return Builder.CreateMul(L, R, "multmp");</strong>
<strong class="calibre2">}</strong>

int main(int argc, char *argv[]) {
  FunArgs.push_back("a");
  FunArgs.push_back("b");
  static IRBuilder&lt;&gt; Builder(Context);
  GlobalVariable *gVar = createGlob(Builder, "x");
  Function *fooFunc = createFunc(Builder, "foo");
  setFuncArgs(fooFunc, FunArgs);
  BasicBlock *entry = createBB(fooFunc, "entry");
  Builder.SetInsertPoint(entry);
<strong class="calibre2">  Value *Arg1 = fooFunc-&gt;arg_begin();</strong>
<strong class="calibre2">  Value *constant = Builder.getInt32(16);</strong>
<strong class="calibre2">  Value *val = createArith(Builder, Arg1, constant);</strong>
  Builder.CreateRet(val);
  verifyFunction(*fooFunc);
  ModuleOb-&gt;dump();
  return 0;
}</pre></div><p class="calibre7">Compile the <a id="id84" class="calibre1"/>following<a id="id85" class="calibre1"/> program:</p><div><pre class="programlisting">
<strong class="calibre2">$ clang++ -O3 toy.cpp `llvm-config --cxxflags --ldflags  --system-libs --libs core` -o toy</strong>
</pre></div><p class="calibre7">The output will be as follows:</p><div><pre class="programlisting">; ModuleID = 'my compiler'

@x = common global i32, align 4

define i32 @foo(i32 %a, i32 %b) {
entry:
  %multmp = mul i32 %a, 16
  ret i32 %multmp
}</pre></div><p class="calibre7">Did you notice the return value? We returned the multiplication instead of constant 0.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>Emitting if-else condition IR</h1></div></div></div><p class="calibre7">An <strong class="calibre2">if-else</strong> statement has a<a id="id86" class="calibre1"/> condition expression and two code paths to execute, depending on the condition evaluating to true or false. The condition expression is generally a comparison statement. Let's emit a condition statement at the start of the block. For example, let the condition be like <code class="email">a&lt;100</code>.</p><div><pre class="programlisting"> Value *val2 = Builder.getInt32(100);
 Value *Compare = Builder.CreateICmpULT(val, val2, "cmptmp"); </pre></div><p class="calibre7">On compilation, we get following output:</p><div><pre class="programlisting">; ModuleID = 'my compiler'

@x = common global i32, align 4

define i32 @foo(i32 %a, i32 %b) {
entry:
  %multmp = mul i32 %a, 16
  %cmptmp = icmp ult i32 %multmp, 100
  
  ret i32 %multmp
}</pre></div><p class="calibre7">The next step is to define the then and else block expressions, which will be executed depending on the result of condition expression "<code class="email">booltmp</code>". Here, an important concept of <a id="id87" class="calibre1"/>
<strong class="calibre2">PHI</strong> instruction <a id="id88" class="calibre1"/>comes into picture. A phi instruction takes various values coming from different basic blocks and decides which value to assign depending on the condition expression.</p><p class="calibre7">Two separate basic blocks "<code class="email">ThenBB</code>" and "<code class="email">ElseBB</code>" will be created. Let's say that the then expression is 'add 1 to a' and else expression is 'add 2 to a'.</p><p class="calibre7">A third block will represent the merge block, which contains the instructions to be executed at the merging of the then and else blocks. These blocks need to be pushed into the function <code class="email">foo()</code>.</p><p class="calibre7">For reusability, we create <code class="email">BasicBlock</code> and <code class="email">Value</code> containers as follows:</p><div><pre class="programlisting">typedef SmallVector&lt;BasicBlock *, 16&gt; BBList;
typedef SmallVector&lt;Value *, 16&gt; ValList;</pre></div><div><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre7">Note that <code class="email">SmallVector&lt;&gt;</code> is vector container wrapper provided by LLVM for simplicity.</p></div><p class="calibre7">We also push some of the values in a <code class="email">Value*</code> list to process them in the if-else block, as follows:</p><div><pre class="programlisting"> Value *Condtn = Builder.CreateICmpNE(Compare, Builder.getInt32(0),
 "ifcond");
 ValList VL;
 VL.push_back(Condtn);
 VL.push_back(Arg1);</pre></div><p class="calibre7">We create three basic blocks and push them in container, as follows:</p><div><pre class="programlisting">  BasicBlock *ThenBB = createBB(fooFunc, "then");
  BasicBlock *ElseBB = createBB(fooFunc, "else");
  BasicBlock *MergeBB = createBB(fooFunc, "ifcont");
  BBList List;
  List.push_back(ThenBB);
  List.push_back(ElseBB);
  List.push_back(MergeBB);</pre></div><p class="calibre7">We finally create a function to emit the if-else block:</p><div><pre class="programlisting">Value *createIfElse(IRBuilder&lt;&gt; &amp;Builder, BBList List, ValList VL) {
  Value *Condtn = VL[0];
  Value *Arg1 = VL[1];
  BasicBlock *ThenBB = List[0];
  BasicBlock *ElseBB = List[1];
  BasicBlock *MergeBB = List[2];
  Builder.CreateCondBr(Condtn, ThenBB, ElseBB);

  Builder.SetInsertPoint(ThenBB);
  Value *ThenVal = Builder.CreateAdd(Arg1, Builder.getInt32(1), "thenaddtmp");
  Builder.CreateBr(MergeBB);

  Builder.SetInsertPoint(ElseBB);
  Value *ElseVal = Builder.CreateAdd(Arg1, Builder.getInt32(2), "elseaddtmp");
  Builder.CreateBr(MergeBB);

  unsigned PhiBBSize = List.size() - 1;
  Builder.SetInsertPoint(MergeBB);
  PHINode *Phi = Builder.CreatePHI(Type::getInt32Ty(getGlobalContext()), PhiBBSize, "iftmp");
  Phi-&gt;addIncoming(ThenVal, ThenBB);
  Phi-&gt;addIncoming(ElseVal, ElseBB);

  return Phi;
}</pre></div><p class="calibre7">Overall <a id="id89" class="calibre1"/>code:</p><div><pre class="programlisting">#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Verifier.h"
#include &lt;vector&gt;
using namespace llvm;

static LLVMContext &amp;Context = getGlobalContext();
static Module *ModuleOb = new Module("my compiler", Context);
static std::vector&lt;std::string&gt; FunArgs;
<strong class="calibre2">typedef SmallVector&lt;BasicBlock *, 16&gt; BBList;</strong>
<strong class="calibre2">typedef SmallVector&lt;Value *, 16&gt; ValList;</strong>

Function *createFunc(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
  std::vector&lt;Type *&gt; Integers(FunArgs.size(), Type::getInt32Ty(Context));
  FunctionType *funcType =
      llvm::FunctionType::get(Builder.getInt32Ty(), Integers, false);
  Function *fooFunc = llvm::Function::Create(
      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);
  return fooFunc;
}

void setFuncArgs(Function *fooFunc, std::vector&lt;std::string&gt; FunArgs) {

  unsigned Idx = 0;
  Function::arg_iterator AI, AE;
  for (AI = fooFunc-&gt;arg_begin(), AE = fooFunc-&gt;arg_end(); AI != AE;
       ++AI, ++Idx)
    AI-&gt;setName(FunArgs[Idx]);
}

BasicBlock *createBB(Function *fooFunc, std::string Name) {
  return BasicBlock::Create(Context, Name, fooFunc);
}

GlobalVariable *createGlob(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
  ModuleOb-&gt;getOrInsertGlobal(Name, Builder.getInt32Ty());
  GlobalVariable *gVar = ModuleOb-&gt;getNamedGlobal(Name);
  gVar-&gt;setLinkage(GlobalValue::CommonLinkage);
  gVar-&gt;setAlignment(4);
  return gVar;
}

Value *createArith(IRBuilder&lt;&gt; &amp;Builder, Value *L, Value *R) {
  return Builder.CreateMul(L, R, "multmp");
}

<strong class="calibre2">Value *createIfElse(IRBuilder&lt;&gt; &amp;Builder, BBList List, ValList VL) {</strong>
<strong class="calibre2">  Value *Condtn = VL[0];</strong>
<strong class="calibre2">  Value *Arg1 = VL[1];</strong>
<strong class="calibre2">  BasicBlock *ThenBB = List[0];</strong>
<strong class="calibre2">  BasicBlock *ElseBB = List[1];</strong>
<strong class="calibre2">  BasicBlock *MergeBB = List[2];</strong>
<strong class="calibre2">  Builder.CreateCondBr(Condtn, ThenBB, ElseBB);</strong>

<strong class="calibre2">  Builder.SetInsertPoint(ThenBB);</strong>
<strong class="calibre2">  Value *ThenVal = Builder.CreateAdd(Arg1, Builder.getInt32(1), "thenaddtmp");</strong>
<strong class="calibre2">  Builder.CreateBr(MergeBB);</strong>

<strong class="calibre2">  Builder.SetInsertPoint(ElseBB);</strong>
<strong class="calibre2">  Value *ElseVal = Builder.CreateAdd(Arg1, Builder.getInt32(2), "elseaddtmp");</strong>
<strong class="calibre2">  Builder.CreateBr(MergeBB);</strong>

<strong class="calibre2">  unsigned PhiBBSize = List.size() - 1;</strong>
<strong class="calibre2">  Builder.SetInsertPoint(MergeBB);</strong>
<strong class="calibre2">  PHINode *Phi = Builder.CreatePHI(Type::getInt32Ty(getGlobalContext()), PhiBBSize, "iftmp");</strong>
<strong class="calibre2">  PhiBBSize, "iftmp");</strong>
<strong class="calibre2">  Phi-&gt;addIncoming(ThenVal, ThenBB);</strong>
<strong class="calibre2">  Phi-&gt;addIncoming(ElseVal, ElseBB);</strong>

<strong class="calibre2">  return Phi;</strong>
<strong class="calibre2">}</strong>

int main(int argc, char *argv[]) {
  FunArgs.push_back("a");
  FunArgs.push_back("b");
  static IRBuilder&lt;&gt; Builder(Context);
  GlobalVariable *gVar = createGlob(Builder, "x");
  Function *fooFunc = createFunc(Builder, "foo");
  setFuncArgs(fooFunc, FunArgs);
  BasicBlock *entry = createBB(fooFunc, "entry");
  Builder.SetInsertPoint(entry);
  Value *Arg1 = fooFunc-&gt;arg_begin();
  Value *constant = Builder.getInt32(16);
  Value *val = createArith(Builder, Arg1, constant);

<strong class="calibre2">  Value *val2 = Builder.getInt32(100);</strong>
<strong class="calibre2">  Value *Compare = Builder.CreateICmpULT(val, val2, "cmptmp");</strong>
<strong class="calibre2">  Value *Condtn = Builder.CreateICmpNE(Compare, Builder.getInt32(0), "ifcond");</strong>

<strong class="calibre2">  ValList VL;</strong>
<strong class="calibre2">  VL.push_back(Condtn);</strong>
<strong class="calibre2">  VL.push_back(Arg1);</strong>

<strong class="calibre2">  BasicBlock *ThenBB = createBB(fooFunc, "then");</strong>
<strong class="calibre2">  BasicBlock *ElseBB = createBB(fooFunc, "else");</strong>
<strong class="calibre2">  BasicBlock *MergeBB = createBB(fooFunc, "ifcont");</strong>
<strong class="calibre2">  BBList List;</strong>
<strong class="calibre2">  List.push_back(ThenBB);</strong>
<strong class="calibre2">  List.push_back(ElseBB);</strong>
<strong class="calibre2">  List.push_back(MergeBB);</strong>

<strong class="calibre2">  Value *v = createIfElse(Builder, List, VL);</strong>

  Builder.CreateRet(v);
  verifyFunction(*fooFunc);
  ModuleOb-&gt;dump();
  return 0;
}</pre></div><p class="calibre7">After <a id="id90" class="calibre1"/>compiling, the output looks like the following:</p><div><pre class="programlisting">; ModuleID = 'my compiler'

@x = common global i32, align 4

define i32 @foo(i32 %a, i32 %b) {
entry:
  %multmp = mul i32 %a, 16
  %cmptmp = icmp ult i32 %multmp, 100
  %ifcond = icmp ne i1 %cmptmp, i32 0
  br i1 %ifcond, label %then, label %else

then:                                             ; preds = %entry
  %thenaddtmp = add i32 %a, 1
  br label %ifcont

else:                                             ; preds = %entry
  %elseaddtmp = add i32 %a, 2
  br label %ifcont

ifcont:                                           ; preds = %else, %then
  %iftmp = phi i32 [ %thenaddtmp, %then ], [ %elseaddtmp, %else ]
  ret i32 %iftmp
}</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec19" class="calibre1"/>Emitting LLVM IR for loop</h1></div></div></div><p class="calibre7">Similar to the if-else<a id="id91" class="calibre1"/> statement, loops can also be emitted using LLVM <a id="id92" class="calibre1"/>API's, with slight modification of the code. For example, we want to have LLVM IR for the following Loops:</p><div><pre class="programlisting">for(i=1; i&lt; b; i++)  {body}</pre></div><p class="calibre7">The loop has induction variable <code class="email">i</code>, which has some initial value that updates after each iteration. The induction variable is updated after each iteration by a step value that is <code class="email">1</code> in the preceding example. Then there is a loop ending condition. In the preceding example, '<code class="email">i=1</code>' is the initial value, '<code class="email">i&lt;b</code>' is the end condition of the loop, and '<code class="email">i++</code>' is the step value by which the induction variable '<code class="email">i</code>' is incremented after every iteration of the loop.</p><p class="calibre7">Before writing <a id="id93" class="calibre1"/>a function to create a loop, some <code class="email">Value</code> and <code class="email">BasicBlock</code> need<a id="id94" class="calibre1"/> to be pushed into a list, as follows:</p><div><pre class="programlisting">Function::arg_iterator AI = fooFunc-&gt;arg_begin();
  Value *Arg1 = AI++;
  Value *Arg2 = AI;
  Value *constant = Builder.getInt32(16);
  Value *val = createArith(Builder, Arg1, constant);
  ValList VL;
  VL.push_back(Arg1);

  BBList List;
  BasicBlock *LoopBB = createBB(fooFunc, "loop");
  BasicBlock *AfterBB = createBB(fooFunc, "afterloop");
  List.push_back(LoopBB);
  List.push_back(AfterBB);

  Value *StartVal = Builder.getInt32(1);</pre></div><p class="calibre7">Let's create a function for the emitting loop:</p><div><pre class="programlisting">PHINode *createLoop(IRBuilder&lt;&gt; &amp;Builder, BBList List, ValList VL,
                    Value *StartVal, Value *EndVal) {
  BasicBlock *PreheaderBB = Builder.GetInsertBlock();
  Value *val = VL[0];
  BasicBlock *LoopBB = List[0];
  Builder.CreateBr(LoopBB);
  Builder.SetInsertPoint(LoopBB);
  PHINode *IndVar = Builder.CreatePHI(Type::getInt32Ty(Context), 2, "i");
  IndVar-&gt;addIncoming(StartVal, PreheaderBB);
  Builder.CreateAdd(val, Builder.getInt32(5), "addtmp");
  Value *StepVal = Builder.getInt32(1);
  Value *NextVal = Builder.CreateAdd(IndVar, StepVal, "nextval");
  Value *EndCond = Builder.CreateICmpULT(IndVar, EndVal, "endcond");
  EndCond = Builder.CreateICmpNE(EndCond, Builder.getInt32(0), "loopcond");
  BasicBlock *LoopEndBB = Builder.GetInsertBlock();
  BasicBlock *AfterBB = List[1];
  Builder.CreateCondBr(EndCond, LoopBB, AfterBB);
  Builder.SetInsertPoint(AfterBB);
  IndVar-&gt;addIncoming(NextVal, LoopEndBB);
  return IndVar;
}</pre></div><p class="calibre7">Consider the following lines of code:</p><div><pre class="programlisting">IndVar-&gt;addIncoming(StartVal, PreheaderBB);…
IndVar-&gt;addIncoming(NextVal, LoopEndBB);</pre></div><p class="calibre7">
<code class="email">IndVar</code> is a PHI node, which has two incoming values from two blocks—startval from the Preheader block (<code class="email">i=1</code>), and <code class="email">Nextval</code> from the LoopEnd block.</p><p class="calibre7">The overall code <a id="id95" class="calibre1"/>is as <a id="id96" class="calibre1"/>follows:</p><div><pre class="programlisting">#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Verifier.h"
#include &lt;vector&gt;
using namespace llvm;

typedef SmallVector&lt;BasicBlock *, 16&gt; BBList;
typedef SmallVector&lt;Value *, 16&gt; ValList;

static LLVMContext &amp;Context = getGlobalContext();
static Module *ModuleOb = new Module("my compiler", Context);
static std::vector&lt;std::string&gt; FunArgs;

Function *createFunc(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
  std::vector&lt;Type *&gt; Integers(FunArgs.size(), Type::getInt32Ty(Context));
  FunctionType *funcType =
      llvm::FunctionType::get(Builder.getInt32Ty(), Integers, false);
  Function *fooFunc = llvm::Function::Create(
      funcType, llvm::Function::ExternalLinkage, Name, ModuleOb);
  return fooFunc;
}

void setFuncArgs(Function *fooFunc, std::vector&lt;std::string&gt; FunArgs) {

  unsigned Idx = 0;
  Function::arg_iterator AI, AE;
  for (AI = fooFunc-&gt;arg_begin(), AE = fooFunc-&gt;arg_end(); AI != AE;
       ++AI, ++Idx)
    AI-&gt;setName(FunArgs[Idx]);
}

BasicBlock *createBB(Function *fooFunc, std::string Name) {
  return BasicBlock::Create(Context, Name, fooFunc);
}

GlobalVariable *createGlob(IRBuilder&lt;&gt; &amp;Builder, std::string Name) {
  ModuleOb-&gt;getOrInsertGlobal(Name, Builder.getInt32Ty());
  GlobalVariable *gVar = ModuleOb-&gt;getNamedGlobal(Name);
  gVar-&gt;setLinkage(GlobalValue::CommonLinkage);
  gVar-&gt;setAlignment(4);
  return gVar;
}

Value *createArith(IRBuilder&lt;&gt; &amp;Builder, Value *L, Value *R) {
  return Builder.CreateMul(L, R, "multmp");
}

<strong class="calibre2">Value *createLoop(IRBuilder&lt;&gt; &amp;Builder, BBList List, ValList VL,</strong>
<strong class="calibre2">                    Value *StartVal, Value *EndVal) {</strong>
<strong class="calibre2">  BasicBlock *PreheaderBB = Builder.GetInsertBlock();</strong>
<strong class="calibre2">  Value *val = VL[0];</strong>
<strong class="calibre2">  BasicBlock *LoopBB = List[0];</strong>
<strong class="calibre2">  Builder.CreateBr(LoopBB);</strong>
<strong class="calibre2">  Builder.SetInsertPoint(LoopBB);</strong>
<strong class="calibre2">  PHINode *IndVar = Builder.CreatePHI(Type::getInt32Ty(Context), 2, "i");</strong>
<strong class="calibre2">  IndVar-&gt;addIncoming(StartVal, PreheaderBB);</strong>
<strong class="calibre2">  Value *Add = Builder.CreateAdd(val, Builder.getInt32(5), "addtmp");</strong>
<strong class="calibre2">  Value *StepVal = Builder.getInt32(1);</strong>
<strong class="calibre2">  Value *NextVal = Builder.CreateAdd(IndVar, StepVal, "nextval");</strong>
<strong class="calibre2">  Value *EndCond = Builder.CreateICmpULT(IndVar, EndVal, "endcond");</strong>
<strong class="calibre2">  EndCond = Builder.CreateICmpNE(EndCond, Builder.getInt32(0), "loopcond");</strong>
<strong class="calibre2">  BasicBlock *LoopEndBB = Builder.GetInsertBlock();</strong>
<strong class="calibre2">  BasicBlock *AfterBB = List[1];</strong>
<strong class="calibre2">  Builder.CreateCondBr(EndCond, LoopBB, AfterBB);</strong>
<strong class="calibre2">  Builder.SetInsertPoint(AfterBB);</strong>
<strong class="calibre2">  IndVar-&gt;addIncoming(NextVal, LoopEndBB);</strong>
<strong class="calibre2">  return Add;</strong>
<strong class="calibre2">}</strong>

int main(int argc, char *argv[]) {
  FunArgs.push_back("a");
  FunArgs.push_back("b");
  static IRBuilder&lt;&gt; Builder(Context);
  GlobalVariable *gVar = createGlob(Builder, "x");
  Function *fooFunc = createFunc(Builder, "foo");
  setFuncArgs(fooFunc, FunArgs);
  BasicBlock *entry = createBB(fooFunc, "entry");
  Builder.SetInsertPoint(entry);
<strong class="calibre2">  Function::arg_iterator AI = fooFunc-&gt;arg_begin();</strong>
<strong class="calibre2">  Value *Arg1 = AI++;</strong>
<strong class="calibre2">  Value *Arg2 = AI;</strong>
<strong class="calibre2">  Value *constant = Builder.getInt32(16);</strong>
<strong class="calibre2">  Value *val = createArith(Builder, Arg1, constant);</strong>
<strong class="calibre2">  ValList VL;</strong>
<strong class="calibre2">  VL.push_back(Arg1);</strong>

<strong class="calibre2">  BBList List;</strong>
<strong class="calibre2">  BasicBlock *LoopBB = createBB(fooFunc, "loop");</strong>
<strong class="calibre2">  BasicBlock *AfterBB = createBB(fooFunc, "afterloop");</strong>
<strong class="calibre2">  List.push_back(LoopBB);</strong>
<strong class="calibre2">  List.push_back(AfterBB);</strong>

<strong class="calibre2">  Value *StartVal = Builder.getInt32(1);</strong>
<strong class="calibre2">  Value *Res = createLoop(Builder, List, VL, StartVal, Arg2);</strong>

  Builder.CreateRet(Res);
  verifyFunction(*fooFunc);
  ModuleOb-&gt;dump();
  return 0;
}</pre></div><p class="calibre7">After <a id="id97" class="calibre1"/>compiling <a id="id98" class="calibre1"/>the program, we get the following output:</p><div><pre class="programlisting">; ModuleID = 'my compiler'

@x = common global i32, align 4

define i32 @foo(i32 %a, i32 %b) {
entry:
  %multmp = mul i32 %a, 16
  br label %loop

loop:                                             ; preds = %loop, %entry
  %i = phi i32 [ 1, %entry ], [ %nextval, %loop ]
  %addtmp = add i32 %a, 5
  %nextval = add i32 %i, 1
  %endcond = icmp ult i32 %i, %b
  %loopcond = icmp ne i1 %endcond, i32 0
  br i1 %loopcond, label %loop, label %afterloop

afterloop:                                        ; preds = %loop
  ret i32 %addtmp
}</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec20" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, you learned how to create simple LLVM IR using rich libraries provided by LLVM. Remember that LLVM IR is an intermediate representation. The high-level programming languages are converted to LLVM IR using the custom parser, which breaks down the code into atomic pieces such as variables, functions, function return type, function arguments, if-else conditions, loops, pointers, array, and so on. These atomic elements can be stored into custom data structures and then those data structures can be used to emit LLVM IR, as demonstrated in this chapter.</p><p class="calibre7">In the parser phase, syntactic analysis can be done, while lexical analysis and type checking can be done in an intermediate stage after parsing and before emitting IR.</p><p class="calibre7">In practical usage, one would hardly find the IR being emitted in a hard-coded way as demonstrated in this chapter. Instead, a language is parsed and represented in an Abstract Syntax Tree. The tree is then used to emit LLVM IR with the help of the LLVM library, as shown earlier. The LLVM community has provided an excellent tutorial for writing a parser and emitting LLVM IR. You can visit <a class="calibre1" href="http://llvm.org/docs/tutorial/">http://llvm.org/docs/tutorial/</a> for the same.</p><p class="calibre7">In the next chapter, we will see how to emit some complex data structures such as array, pointers. Also, we will go through some examples from Clang, the frontend for C/C++, and understand how semantic Analysis is done.</p></div></body></html>