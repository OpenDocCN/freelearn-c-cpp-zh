["```cpp\nenum class StateType{\n    Intro = 1, MainMenu, Game, Paused, GameOver, Credits\n};\n```", "```cpp\nvoid Game::Update(){\n  switch(m_state){\n    case(StateType::Intro):\n      UpdateIntro();\n      break;\n    case(StateType::Game):\n      UpdateGame();\n      break;\n    case(StateType::MainMenu):\n      UpdateMenu();\n      break;\n    ...\n  }\n}\n```", "```cpp\nvoid Game::Render(){\n  switch(m_state){\n    case(StateType::Intro):\n      DrawIntro();\n      break;\n    case(StateType::Game):\n      DrawGame();\n      break;\n    case(StateType::MainMenu):\n      DrawMenu();\n      break;\n    ...\n  }\n}\n```", "```cpp\nenum StateType{\n    Intro = 1, Intro_MainMenu, MainMenu, Game, MainMenu_Game\n    Paused, GameOver, MainMenu_GameOver, Credits, MainMenu_Credits\n    ...\n    // Crying in the corner.\n};\n```", "```cpp\nclass StateManager;\n\nclass BaseState{\n  friend class StateManager;\npublic:\n  BaseState(StateManager* l_stateManager)\n    :m_stateMgr(l_stateManager),m_transparent(false),\n    m_transcendent(false){}\n  virtual ~BaseState(){}\n\n  virtual void OnCreate() = 0;\n  virtual void OnDestroy() = 0;\n\n  virtual void Activate() = 0;\n  virtual void Deactivate() = 0;\n\n  virtual void Update(const sf::Time& l_time) = 0;\n  virtual void Draw() = 0;\n\n  void SetTransparent(const bool& l_transparent){\n    m_transparent = l_transparent;\n  }\n  bool IsTransparent()const{ return m_transparent; }\n  void SetTranscendent(const bool& l_transcendence){\n    m_transcendent = l_transcendence;\n  }\n  bool IsTranscendent()const{ return m_transcendent; }\n  StateManager* GetStateManager(){ return m_stateMgr; }\nprotected:\n  StateManager* m_stateMgr;\n  bool m_transparent;\n  bool m_transcendent;\n};\n```", "```cpp\nenum class StateType{\n    Intro = 1, MainMenu, Game, Paused, GameOver, Credits\n};\n```", "```cpp\nstruct SharedContext{\n    SharedContext():m_wind(nullptr),m_eventManager(nullptr){}\n    Window* m_wind;\n    EventManager* m_eventManager;\n};\n```", "```cpp\nusing StateContainer = std::vector<std::pair<StateType, BaseState*>>;\n```", "```cpp\nusing TypeContainer = std::vector<StateType>;\n```", "```cpp\nusing StateFactory = std::unordered_map<StateType, std::function<BaseState*(void)>>;\n```", "```cpp\nclass StateManager{\npublic:\n    StateManager(SharedContext* l_shared);\n    ~StateManager();\n\n    void Update(const sf::Time& l_time);\n    void Draw();\n\n    void ProcessRequests();\n\n    SharedContext* GetContext();\n    bool HasState(const StateType& l_type);\n\n    void SwitchTo(const StateType& l_type);\n    void Remove(const StateType& l_type);\nprivate:\n    // Methods.\n    void CreateState(const StateType& l_type);\n    void RemoveState(const StateType& l_type);\n\n    template<class T>\n    void RegisterState(const StateType& l_type){...}\n\n    // Members.\n    SharedContext* m_shared;\n    StateContainer m_states;\n    TypeContainer m_toRemove;\n    StateFactory m_stateFactory;\n};\n```", "```cpp\ntemplate<class T>\nvoid RegisterState(const StateType& l_type){\n    m_stateFactory[l_type] = [this]() -> BaseState*\n    {\n        return new T(this);\n    };\n}\n```", "```cpp\nStateManager::StateManager(SharedContext* l_shared): m_shared(l_shared)\n{\n    RegisterState<State_Intro>(StateType::Intro);\n    RegisterState<State_MainMenu>(StateType::MainMenu);\n    RegisterState<State_Game>(StateType::Game);\n    RegisterState<State_Paused>(StateType::Paused);\n}\n```", "```cpp\nStateManager::~StateManager(){\n    for (auto &itr : m_states){\n        itr.second->OnDestroy();\n        delete itr.second;\n    }\n}\n```", "```cpp\nvoid StateManager::Draw(){\n  if (m_states.empty()){ return; }\n  if (m_states.back().second->IsTransparent() && m_states.size() > 1)\n  {\n    auto itr = m_states.end();\n    while (itr != m_states.begin()){\n      if (itr != m_states.end()){\n        if (!itr->second->IsTransparent()){\n          break;\n        }\n      }\n      --itr;\n    }\n    for (; itr != m_states.end(); ++itr){\n      itr->second->Draw();\n    }\n  } else {\n    m_states.back().second->Draw();\n  }\n}\n```", "```cpp\nvoid StateManager::Update(const sf::Time& l_time){\n  if (m_states.empty()){ return; }\n  if (m_states.back().second->IsTranscendent() && m_states.size() > 1)\n  {\n    auto itr = m_states.end();\n    while (itr != m_states.begin()){\n      if (itr != m_states.end()){\n        if (!itr->second->IsTranscendent()){\n          break;\n        }\n      }\n      --itr;\n    }\n    for (; itr != m_states.end(); ++itr){\n      itr->second->Update(l_time);\n    }\n  } else {\n    m_states.back().second->Update(l_time);\n  }\n}\n```", "```cpp\nSharedContext* StateManager::GetContext(){ return m_shared; }\n\nbool StateManager::HasState(const StateType& l_type){\n  for (auto itr = m_states.begin();\n    itr != m_states.end(); ++itr)\n  {\n    if (itr->first == l_type){\n      auto removed = std::find(m_toRemove.begin(),\n        m_toRemove.end(), l_type);\n      if (removed == m_toRemove.end()){ return true; }\n      return false;\n    }\n  }\n  return false;\n}\n```", "```cpp\nvoid StateManager::Remove(const StateType& l_type){\n     m_toRemove.push_back(l_type);\n}\n```", "```cpp\nvoid StateManager::ProcessRequests(){\n    while (m_toRemove.begin() != m_toRemove.end()){\n        RemoveState(*m_toRemove.begin());\n        m_toRemove.erase(m_toRemove.begin());\n    }\n}\n```", "```cpp\nvoid StateManager::SwitchTo(const StateType& l_type){\n  m_shared->m_eventManager->SetCurrentState(l_type);\n  for (auto itr = m_states.begin();\n    itr != m_states.end(); ++itr)\n  {\n    if (itr->first == l_type){\n      m_states.back().second->Deactivate();\n      StateType tmp_type = itr->first;\n      BaseState* tmp_state = itr->second;\n      m_states.erase(itr);\n      m_states.emplace_back(tmp_type, tmp_state);\n      tmp_state->Activate();\n      return;\n    }\n  }\n\n  // State with l_type wasn't found.\n  if (!m_states.empty()){ m_states.back().second->Deactivate(); }\n  CreateState(l_type);\n  m_states.back().second->Activate();\n}\n```", "```cpp\nvoid StateManager::CreateState(const StateType& l_type){\n    auto newState = m_stateFactory.find(l_type);\n    if (newState == m_stateFactory.end()){ return; }\n    BaseState* state = newState->second();\n    m_states.emplace_back(l_type, state);\n    state->OnCreate();\n}\n```", "```cpp\nvoid StateManager::RemoveState(const StateType& l_type){\n  for (auto itr = m_states.begin();itr != m_states.end(); ++itr)\n  {\n    if (itr->first == l_type){\n      itr->second->OnDestroy();\n      delete itr->second;\n      m_states.erase(itr);\n      return;\n    }\n  }\n}\n```", "```cpp\nusing CallbackContainer = std::unordered_map<std::string, std::function<void(EventDetails*)>>;\nenum class StateType;\nusing Callbacks = std::unordered_map<StateType, CallbackContainer>;\n```", "```cpp\nCallbacks m_callbacks;\n```", "```cpp\nStateType m_currentState;\n```", "```cpp\ntemplate<class T>\nbool AddCallback(StateType l_state, const std::string& l_name,void(T::*l_func)(EventDetails*), T* l_instance)\n{\n    auto itr = m_callbacks.emplace(l_state, CallbackContainer()).first;\n    auto temp = std::bind(l_func, l_instance,std::placeholders::_1);\n    return itr->second.emplace(l_name, temp).second;\n}\n```", "```cpp\nbool RemoveCallback(StateType l_state, const std::string& l_name){\n    auto itr = m_callbacks.find(l_state);\n    if (itr == m_callbacks.end()){ return false; }\n    auto itr2 = itr->second.find(l_name);\n    if (itr2 == itr->second.end()){ return false; }\n    itr->second.erase(l_name);\n    return true;\n}\n```", "```cpp\nvoid EventManager::Update(){\n  ...\n  if (bind->m_events.size() == bind->c){\n    auto stateCallbacks = m_callbacks.find(m_currentState);\n    auto otherCallbacks = m_callbacks.find(StateType(0));\n\n    if (stateCallbacks != m_callbacks.end()){\n      auto callItr = stateCallbacks->second.find(bind->m_name);\n      if (callItr != stateCallbacks->second.end()){\n        // Pass in information about events.\n        callItr->second(&bind->m_details);\n      }\n    }\n\n    if (otherCallbacks != m_callbacks.end()){\n      auto callItr = otherCallbacks->second.find(bind->m_name);\n      if (callItr != otherCallbacks->second.end()){\n        // Pass in information about events.\n        callItr->second(&bind->m_details);\n      }\n    }\n  }\n  ...\n}\n```", "```cpp\nWindow_close 0:0\nFullscreen_toggle 5:89\nIntro_Continue 5:57\nMouse_Left 9:0\nKey_Escape 5:36\nKey_P 5:15\n```", "```cpp\n...\n#include \"StateManager.h\"\n...\nclass Game{\npublic:\n    ...\n    void LateUpdate();\nprivate:\n    ...\n    StateManager m_stateManager;\n};\n```", "```cpp\nGame::Game(): m_window(\"Chapter 5\", sf::Vector2u(800, 600)), m_stateManager(&m_context)\n{\n    ...\n    m_context.m_wind = &m_window;\n    m_context.m_eventManager = m_window.GetEventManager();\n    m_stateManager.SwitchTo(StateType::Intro);\n}\n```", "```cpp\nvoid Game::Update(){\n    m_window.Update();\n    m_stateManager.Update(m_elapsed);\n}\nvoid Game::Render(){\n    m_window.BeginDraw();\n    m_stateManager.Draw();\n    m_window.EndDraw();\n}\nvoid Game::LateUpdate(){\n    m_stateManager.ProcessRequests();\n    RestartClock();\n}\n```", "```cpp\n#include \"Game.h\"\n\nvoid main(int argc, void** argv[]){\n    // Program entry point.\n    Game game;\n    while(!game.GetWindow()->IsDone()){\n        game.Update();\n        game.Render();\n        game.LateUpdate();\n    }\n}\n```", "```cpp\nclass State_Intro : public BaseState{\npublic:\n    ...\n    void Continue(EventDetails* l_details);\nprivate:\n    sf::Texture m_introTexture;\n    sf::Sprite m_introSprite;\n    sf::Text m_text;\n    float m_timePassed;\n};\n```", "```cpp\n#include \"State_Intro.h\"\n#include \"StateManager.h\"\n```", "```cpp\nvoid State_Intro::OnCreate(){\n  m_timePassed = 0.0f;\n\n  sf::Vector2u windowSize = m_stateMgr->GetContext()->\n    m_wind->GetRenderWindow()->getSize();\n\n  m_introTexture.loadFromFile(\"intro.png\");\n  m_introSprite.setTexture(m_introTexture);\n  m_introSprite.setOrigin(m_introTexture.getSize().x / 2.0f,\n    m_introTexture.getSize().y / 2.0f);\n\n  m_introSprite.setPosition(windowSize.x / 2.0f, 0);\n\n  m_font.loadFromFile(\"arial.ttf\");\n  m_text.setFont(m_font);\n  m_text.setString({ \"Press SPACE to continue\" });\n  m_text.setCharacterSize(15);\n  sf::FloatRect textRect = m_text.getLocalBounds();\n  m_text.setOrigin(textRect.left + textRect.width / 2.0f,\n    textRect.top + textRect.height / 2.0f);\n  m_text.setPosition(windowSize.x / 2.0f, windowSize.y / 2.0f);\n\n  EventManager* evMgr = m_stateMgr->\n    GetContext()->m_eventManager;\n  evMgr->AddCallback(StateType::Intro,\"Intro_Continue\",\n    &State_Intro::Continue,this);\n}\n```", "```cpp\nvoid State_Intro::OnDestroy(){\n    EventManager* evMgr = m_stateMgr->GetContext()->m_eventManager;\n    evMgr->RemoveCallback(StateType::Intro,\"Intro_Continue\");\n}\n```", "```cpp\nvoid State_Intro::Update(const sf::Time& l_time){\n  if(m_timePassed < 5.0f){ // Less than five seconds.\n    m_timePassed += l_time.asSeconds();\n    m_introSprite.setPosition(m_introSprite.getPosition().x,\n      m_introSprite.getPosition().y + (48 * l_time.asSeconds()));\n  }\n}\n```", "```cpp\nvoid State_Intro::Draw(){\n    sf::RenderWindow* window = m_stateMgr->GetContext()->m_wind->GetRenderWindow();\n\n    window->draw(m_introSprite);\n    if(m_timePassed >= 5.0f){\n        window->draw(m_text);\n    }\n}\n```", "```cpp\nvoid State_Intro::Continue(){\n    if(m_timePassed >= 5.0f){\n        m_stateMgr->SwitchTo(StateType::MainMenu);\n        m_stateMgr->Remove(StateType::Intro);\n    }\n}\n```", "```cpp\nvoid State_Intro::Activate(){}\nvoid State_Intro::Deactivate(){}\n```", "```cpp\nclass State_MainMenu : public BaseState{\npublic:\n    ...\n    void MouseClick(EventDetails* l_details);\nprivate:\n    sf::Text m_text;\n\n    sf::Vector2f m_buttonSize;\n    sf::Vector2f m_buttonPos;\n    unsigned int m_buttonPadding;\n\n    sf::RectangleShape m_rects[3];\n    sf::Text m_labels[3];\n};\n```", "```cpp\nvoid State_MainMenu::OnCreate(){\n  m_font.loadFromFile(\"arial.ttf\");\n  m_text.setFont(m_font);\n  m_text.setString(sf::String(\"MAIN MENU:\"));\n  m_text.setCharacterSize(18);\n\n  sf::FloatRect textRect = m_text.getLocalBounds();\n  m_text.setOrigin(textRect.left + textRect.width / 2.0f,\n    textRect.top + textRect.height / 2.0f);\n\n  m_text.setPosition(400,100);\n\n  m_buttonSize = sf::Vector2f(300.0f,32.0f);\n  m_buttonPos = sf::Vector2f(400,200);\n  m_buttonPadding = 4; // 4px.\n\n  std::string str[3];\n  str[0] = \"PLAY\";\n  str[1] = \"CREDITS\";\n  str[2] = \"EXIT\";\n\n  for(int i = 0; i < 3; ++i){\n    sf::Vector2f buttonPosition(m_buttonPos.x,m_buttonPos.y + \n      (i * (m_buttonSize.y + m_buttonPadding)));\n    m_rects[i].setSize(m_buttonSize);\n    m_rects[i].setFillColor(sf::Color::Red);\n\n    m_rects[i].setOrigin(m_buttonSize.x / 2.0f,\n      m_buttonSize.y / 2.0f);\n    m_rects[i].setPosition(buttonPosition);\n\n    m_labels[i].setFont(m_font);\n    m_labels[i].setString(sf::String(str[i]));\n    m_labels[i].setCharacterSize(12);\n\n    sf::FloatRect rect = m_labels[i].getLocalBounds();\n    m_labels[i].setOrigin(rect.left + rect.width / 2.0f,\n      rect.top + rect.height / 2.0f);\n\n    m_labels[i].setPosition(buttonPosition);\n  }\n\n  EventManager* evMgr = m_stateMgr->\n    GetContext()->m_eventManager;\n  evMgr->AddCallback(StateType::MainMenu,\"Mouse_Left\",\n    &State_MainMenu::MouseClick,this);\n}\n```", "```cpp\nvoid State_MainMenu::OnDestroy(){\n    EventManager* evMgr = m_stateMgr->GetContext()->m_eventManager;\n    evMgr->RemoveCallback(StateType::MainMenu,\"Mouse_Left\");\n}\n```", "```cpp\nvoid State_MainMenu::Activate(){\n    if(m_stateMgr->HasState(StateType::Game) && m_labels[0].getString() == \"PLAY\")\n    {\n        m_labels[0].setString(sf::String(\"RESUME\"));\n        sf::FloatRect rect = m_labels[0].getLocalBounds();\n        m_labels[0].setOrigin(rect.left + rect.width / 2.0f,rect.top + rect.height / 2.0f);\n    }\n}\n```", "```cpp\nvoid State_MainMenu::MouseClick(EventDetails* l_details){\n  sf::Vector2i mousePos = l_details->m_mouse;\n\n  float halfX = m_buttonSize.x / 2.0f;\n  float halfY = m_buttonSize.y / 2.0f;\n  for(int i = 0; i < 3; ++i){\n    if(mousePos.x >= m_rects[i].getPosition().x - halfX &&\n      mousePos.x <= m_rects[i].getPosition().x + halfX &&\n      mousePos.y >= m_rects[i].getPosition().y - halfY &&\n      mousePos.y <= m_rects[i].getPosition().y + halfY)\n    {\n      if(i == 0){\n        m_stateMgr->SwitchTo(StateType::Game);\n      } else if(i == 1){\n        // Credits state.\n      } else if(i == 2){\n        m_stateMgr->GetContext()->m_wind->Close();\n      }\n    }\n  }\n}\n```", "```cpp\nvoid State_MainMenu::Draw(){\n    sf::RenderWindow* window = m_stateMgr->GetContext()->m_wind->GetRenderWindow();\n    window->draw(m_text);\n    for(int i = 0; i < 3; ++i){\n        window->draw(m_rects[i]);\n        window->draw(m_labels[i]);\n    }\n}\n```", "```cpp\nclass State_Game : public BaseState{\npublic:\n    ...\n    void MainMenu(EventDetails* l_details);\n    void Pause(EventDetails* l_details);\nprivate:\n    sf::Texture m_texture;\n    sf::Sprite m_sprite;\n    sf::Vector2f m_increment;\n};\n```", "```cpp\nvoid State_Game::OnCreate(){\n    m_texture.loadFromFile(\"Mushroom.png\");\n    m_sprite.setTexture(m_texture);\n    m_sprite.setPosition(0,0);\n    m_increment = sf::Vector2f(400.0f,400.0f);\n\n    EventManager* evMgr = m_stateMgr->GetContext()->m_eventManager;\n    evMgr->AddCallback(StateType::Game,\"Key_Escape\",&State_Game::MainMenu,this);\n    evMgr->AddCallback(StateType::Game,\"Key_P\",&State_Game::Pause,this);\n}\n```", "```cpp\nvoid State_Game::OnDestroy(){\n    EventManager* evMgr = m_stateMgr->GetContext()->m_eventManager;\n    evMgr->RemoveCallback(StateType::GAME,\"Key_Escape\");\n    evMgr->RemoveCallback(StateType::GAME,\"Key_P\");\n}\n```", "```cpp\nvoid State_Game::Update(const sf::Time& l_time){\n  sf::Vector2u l_windSize = m_stateMgr->GetContext()->\n    m_wind->GetWindowSize();\n  sf::Vector2u l_textSize = m_texture.getSize();\n\n  if((m_sprite.getPosition().x > l_windSize.x - \n    l_textSize.x && m_increment.x > 0) ||\n    (m_sprite.getPosition().x < 0 && m_increment.x < 0))\n  {\n      m_increment.x = -m_increment.x;\n  }\n\n  if((m_sprite.getPosition().y > l_windSize.y -\n    l_textSize.y && m_increment.y > 0) ||\n    (m_sprite.getPosition().y < 0 && m_increment.y < 0))\n  {\n      m_increment.y = -m_increment.y;\n  }\n\n  m_sprite.setPosition(m_sprite.getPosition().x + \n    (m_increment.x * l_time.asSeconds()), \n    m_sprite.getPosition().y + \n    (m_increment.y * l_time.asSeconds()));\n}\n```", "```cpp\nvoid State_Game::Draw(){\n    m_stateMgr->GetContext()->m_wind->GetRenderWindow()->draw(m_sprite);\n}\n```", "```cpp\nvoid State_Game::MainMenu(EventDetails* l_details){ \n    m_stateMgr->SwitchTo(StateType::MAIN_MENU); \n}\n\nvoid State_Game::Pause(EventDetails* l_details){ \n    m_stateMgr->SwitchTo(StateType::PAUSED); \n}\n```", "```cpp\nclass State_Paused : public BaseState{\npublic:\n    ...\n    void Unpause(EventDetails* l_details);\nprivate:\n    sf::Text m_text;\n    sf::RectangleShape m_rect;\n};\n```", "```cpp\nvoid State_Paused::OnCreate(){\n    SetTransparent(true); // Set our transparency flag.\n    m_font.loadFromFile(\"arial.ttf\");\n    m_text.setFont(m_font);\n    m_text.setString(sf::String(\"PAUSED\"));\n    m_text.setCharacterSize(14);\n    m_text.setStyle(sf::Text::Bold);\n\n    sf::Vector2u windowSize = m_stateMgr->GetContext()->m_wind->GetRenderWindow()->getSize();\n\n    sf::FloatRect textRect = m_text.getLocalBounds();\n    m_text.setOrigin(textRect.left + textRect.width / 2.0f,textRect.top + textRect.height / 2.0f);\n    m_text.setPosition(windowSize.x / 2.0f, windowSize.y / 2.0f);\n\n    m_rect.setSize(sf::Vector2f(windowSize));\n    m_rect.setPosition(0,0);\n    m_rect.setFillColor(sf::Color(0,0,0,150));\n\n    EventManager* evMgr = m_stateMgr->GetContext()->m_eventManager;\n    evMgr->AddCallback(StateType::Paused,\"Key_P\",&State_Paused::Unpause,this);\n}\n```", "```cpp\nvoid State_Paused::OnDestroy(){\n    EventManager* evMgr = m_stateMgr->GetContext()->m_eventManager;\n    evMgr->RemoveCallback(StateType::Paused,\"Key_P\");\n}\n```", "```cpp\nvoid State_Paused::Draw(){\n    sf::RenderWindow* wind = m_stateMgr->GetContext()->m_wind->GetRenderWindow();\n    wind->draw(m_rect);\n    wind->draw(m_text);\n}\n```", "```cpp\nvoid State_Paused::Unpause(EventDetails* l_details){ \n    m_stateMgr->SwitchTo(StateType::Game); \n}\n```", "```cpp\nm_eventManager->AddCallback(StateType(0),\"Fullscreen_toggle\",\n    &Window::ToggleFullscreen,this);\nm_eventManager->AddCallback(StateType(0),\"Window_close\",\n    &Window::Close,this);\n```"]