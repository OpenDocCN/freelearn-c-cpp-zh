<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Hit and Run</h1></div></div></div><p>You've already come a long way since beginning the book at the first chapter! You have managed to render moving images to the screen and control their movement. You are well on your way toward creating a great game. The next step is to code the interactions between various objects in the game.</p><p>This chapter will explain how to implement collision detection. Collision detection determines how objects interact with each other when they are in the same location. Topics will include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Boundary detection</strong>: When an object reaches the top, bottom, left, or right edge of the screen, what should happen? There are a surprising number of choices and you get to choose what to do.</li><li class="listitem" style="list-style-type: disc"><strong>Collision detection</strong>: There are various scenarios that we often need to check to determine whether two objects have hit each other. We will cover circular and rectangular collision detection algorithms. We will also discuss when each type of collision detection is appropriate to use.</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Out of bounds!</h1></div></div></div><p>If you run our current game, you will notice that the robot will go off the screen if you allow him to continue moving to the left or right. When he reaches the edge of the screen, he will keep on moving until he is no longer visible. If you reverse his direction and make him move the same number of steps now, he will reappear on the screen.</p><p>Whenever an object reaches the edge of the screen, we often want it to do something special, such as stopping, or turning around. The code that determines when an object has reached a screen <a id="id271" class="indexterm"/>edge is known as <strong>boundary checking</strong>. There are many possibilities for what we can do when an object reaches a boundary:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Stop the object</li><li class="listitem" style="list-style-type: disc">Allow the object to continue past the border (and therefore, disappear)</li><li class="listitem" style="list-style-type: disc">Allow the object to continue past the border and reappear at the opposite border (ever played the arcade version of Asteroids?)</li><li class="listitem" style="list-style-type: disc">Scroll the camera and the screen along with the object (aka Mario)</li><li class="listitem" style="list-style-type: disc">Allow the object to rebound off the border (ever played Breakout?)</li></ul></div><p>As our Robo is<a id="id272" class="indexterm"/> controlled by the player, we will simply force him to stop moving when he has reached the edge of the screen.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Getting anchored</h2></div></div></div><p>In order to implement boundary checking, you must first know the exact anchor point of the image. Technically, the anchor point could be anywhere, but the two most common locations are the top-left corner and the center of the image.</p><p>First, let's see<a id="id273" class="indexterm"/> what happens if we just ignore the anchor point. Open the <strong>RoboRacer2D</strong> project and then open <code class="literal">RoboRacer2D.cpp</code>.</p><p>Insert the following function:</p><div><pre class="programlisting">void CheckBoundaries(Sprite* p_sprite)
{
  if (p_sprite-&gt;GetPosition().x &lt; 0)
  {
    p_sprite-&gt;SetVelocity(0.0f);
  }
  else if (p_sprite-&gt;GetPosition().x &gt; screen_width)
  {
    p_sprite-&gt;SetVelocity(0.0f);
  }
}</pre></div><p>Here is what this code is doing for us:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The function accepts a sprite as its parameter</li><li class="listitem" style="list-style-type: disc">The function first checks to see whether the <code class="literal">x</code> position of the sprite is less than <code class="literal">0</code>, where <code class="literal">0</code> is the <code class="literal">x</code> coordinate of the far-left edge of the screen</li><li class="listitem" style="list-style-type: disc">The function then checks to see whether the <code class="literal">x</code> position of the sprite is greater than the screen width, where <code class="literal">screen_width</code> is the <code class="literal">x</code> coordinate of the far-right edge of the screen</li><li class="listitem" style="list-style-type: disc">If either check is <code class="literal">true</code>, the sprite's velocity is set to <code class="literal">0</code>, effectively stopping the sprite in its tracks</li></ul></div><p>Now, add the highlighted line of code to the <code class="literal">Update</code> function right after <code class="literal">ProcessInput</code> in <code class="literal">RoboRacer2D.cpp</code>:</p><div><pre class="programlisting">inputManager-&gt;Update(p_deltaTime);
ProcessInput();
<strong>CheckBoundaries(player);</strong>
</pre></div><p>This simply <a id="id274" class="indexterm"/>calls the <code class="literal">CheckBoundaries</code> function that we just created and passes in the <code class="literal">player</code> object.</p><p>Now, run the program. Move Robo until he reaches the far left of the screen. Then run him to the far right of the screen. Does anything seem wrong about the way we have implemented our boundary checking?</p><div><div><h3 class="title"><a id="tip38"/>Tip</h3><p>Ignore the way the background scrolls off to the side. We'll fix this shortly.</p></div></div><p>
<strong>Problem 1</strong>: Robo doesn't seem to hit the boundary on the left.</p><p>The following screenshot shows you what happens if you allow Robo to go to the far left of the screen. He appears to stop just before reaching the edge. Although you can't see it in the following screenshot, there is a shadow that always extends to the left edge of the robot. It is the left edge of the shadow that is being detected as the edge of the image.</p><p>It turns out that the default anchor point for images loaded by our image loading routine is, in fact, the upper-left corner.</p><div><img src="img/8199OS_05_01.jpg" alt="Getting anchored"/></div><p>
<strong>Problem 2</strong>: Robo <a id="id275" class="indexterm"/>moves completely off the screen to the right.</p><p>The following screenshot shows you what occurs if you allow Robo to continue traveling to the right. Now that you understand that the anchor point is at the upper-left, you may already understand what is happening.</p><p>As the boundary checking is based on the <code class="literal">x</code> coordinate of the sprite, by the time the upper-left hand corner exceeds the screen width, the entire sprite has already moved off the screen. The grayscale image of the robot shows us where his actual position would be if we could see him:</p><div><img src="img/8199OS_05_02.jpg" alt="Getting anchored"/></div><p>
<strong>Problem 3</strong>: Once <a id="id276" class="indexterm"/>Robo reaches the far left or far right of the screen, he gets stuck. Changing his direction seems to have no effect!</p><p>This problem is known<a id="id277" class="indexterm"/> as <strong>embedding</strong>. Here is what has happened:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We continued check Robo's position until his <em>x</em> coordinate exceeded a threshold.</li><li class="listitem" style="list-style-type: disc">Once he exceeded that threshold, we set his velocity to <code class="literal">0</code>.</li><li class="listitem" style="list-style-type: disc">Now that Robo's <em>x</em> coordinate exceeds that threshold, it will always exceed that threshold. Any attempt to move him in the opposite direction will trigger the boundary check, which will discover that Robo's <em>x</em> coordinate still exceeds the threshold and his velocity will be set to <code class="literal">0</code>.</li></ul></div><p>The solution is to set Robo's position to the other side of threshold as soon as we discover he has crossed it. We will add this correction, but first we have to understand collision rectangles.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Collision rectangles</h2></div></div></div><p>Take a look at the following image of Robo. The solid rectangle represents the boundaries of the texture. The dotted rectangle represents the area that we actually want to consider<a id="id278" class="indexterm"/> for boundary and collision detection. This is known as the <strong>collision rectangle</strong>.</p><div><img src="img/8199OS_05_03.jpg" alt="Collision rectangles"/></div><p>Comparing the two rectangles, here is what we would have to do to convert the texture rectangle to be the collision rectangle:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add about 34 pixels to the left texture boundary</li><li class="listitem" style="list-style-type: disc">Subtract about 10 pixels from the right texture boundary</li><li class="listitem" style="list-style-type: disc">Both the top and right boundaries require no adjustment</li></ul></div><p>Let's enhance the sprite class by adding functionality to define a collision rectangle.</p><p>Open <code class="literal">Sprite.h</code> and add the following member variable:</p><div><pre class="programlisting">Rect m_collision;</pre></div><p>Then add the two accessor methods:</p><div><pre class="programlisting">const Rect GetCollisionRect() const;
void SetCollisionRectOffset(const Rect p_rect) { m_collision = p_rect; }</pre></div><p>The implementation for <code class="literal">GetCollisionRect</code> is a little more complex, so we will put that code into <code class="literal">Sprite.cpp</code>:</p><div><pre class="programlisting">const Sprite::Rect Sprite::GetCollisionRect() const
{
  Rect rect;
  rect.left = m_position.x + m_collision.left;
  rect.right = m_position.x + m_size.width + m_collision.right;
  rect.top = m_position.y + m_collision.top;
  rect.bottom = m_position.y + m_size.height + m_collision.bottom;
  
  return rect;
}</pre></div><p>Here's what we are doing:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">m_collision</code>: This will hold four offset values. These values will represent a number that must be added to the texture's bounding rectangle to get to the collision rectangle that we desire.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SetCollisionRectOffset</code>: This accepts a <code class="literal">Rect</code> parameter that contains the four offsets—top, bottom, left, and right—that must be added to the top, bottom, left, and right of the texture boundaries to create the collision rectangle.</li><li class="listitem" style="list-style-type: disc"><code class="literal">GetCollisionRect</code>: This returns the collision rectangle that we can actually use when checking boundaries and checking for collisions. This is calculated by adding the width and height to the sprite's current anchor point (the top-left corner), and then adjusting it by the values in <code class="literal">m_collision</code>.</li></ul></div><p>Note that <code class="literal">GetCollisionRect</code> is dynamic; it always returns the current collision rectangle<a id="id279" class="indexterm"/> based on the sprite's current position. Thus, we are returning the actual top, bottom, left, and right boundaries that need to be checked at any moment in the game.</p><p>If you look closely at the design, you should be able to see that if no collision rectangle is defined, <code class="literal">GetCollisionRect</code> will return a collision rectangle determined by the texture's rectangle. Therefore, this new design allows us to use the texture rectangle as the collision rectangle by default. On the other hand, if we want to specify our own collision rectangle, we can do so using <code class="literal">SetCollisionRectOffset</code>.</p><p>Just to be safe, we will want to initialize m_collision by adding the following lines to the constructor:</p><div><pre class="programlisting">m_collision.left = 0.0f;
m_collision.right = 0.0f;
m_collision.top = 0.0f;
m_collision.bottom = 0.0f;</pre></div><p>Now that we have the code to support a collision rectangle, we need to define the collision rectangle for the robot's sprites. Go to the <code class="literal">LoadTextures</code> function in <code class="literal">RoboRacer2D.cpp</code> and add the following highlighted lines just before the <code class="literal">return true</code> line of code:</p><div><pre class="programlisting">
<strong>Sprite::Rect collision;</strong>
<strong>collision.left = 34.0f;</strong>
<strong>collision.right = -10.0f;</strong>
<strong>collision.top = 0.0f;</strong>
<strong>collision.bottom = 0.0f;</strong>
<strong>robot_left-&gt;SetCollisionRectOffset(collision);</strong>
<strong>robot_right-&gt;SetCollisionRectOffset(collision);</strong>

return true;</pre></div><p>Remember, only add the preceding code that is highlighted. The last line of the code is shown to provide context.</p><p>We are now <a id="id280" class="indexterm"/>going to rewrite our boundary detection function to take advantage of the collision rectangle. Along the way we will solve all three of the problems that we encountered in our first attempt. The current code uses the anchor point of the image, which doesn't accurately reflect the actual boundaries that we want to check. The new code will use the collision rect. Replace the <code class="literal">CheckBoundaries</code> function in RoboRacer2D with the following code:</p><div><pre class="programlisting">void CheckBoundaries(Sprite* p_sprite)
{
  Sprite::Rect check = p_sprite-&gt;GetCollisionRect();
  
  if (check.left &lt; 0.0f)
  {
    p_sprite-&gt;SetVelocity(0.0f);
  }
  else if (check.right &gt; screen_width)
  {
    p_sprite-&gt;SetVelocity(0.0f);
  }
}</pre></div><p>This code uses the collision rectangle defined for the sprite that is being checked. As we already discussed earlier, <code class="literal">GetCollisionRect</code> returns the top, bottom, left, and right boundaries for us based on the current position of the sprite. This greatly simplifies our code! Now, we just check to see whether the left edge of the sprite is less than zero or whether the right edge of the sprite is greater than zero, and we're done!</p><div><img src="img/8199OS_05_04.jpg" alt="Collision rectangles"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Embedding</h2></div></div></div><p>Hurrah! Robo now successfully stops at the edge of the screen (only the right-hand side is shown in the preceding image). But boo! He still gets stuck! As we mentioned earlier, this problem<a id="id281" class="indexterm"/> is called embedding. If we zoom in, we can see what's going on:</p><div><img src="img/8199OS_05_05.jpg" alt="Embedding"/></div><p>The vertical line represents the edge of the screen. By the time Robo has stopped, his right edge has already exceeded the right edge of the screen, so we stop him. Unfortunately, even if we try to turn him around to go in the other direction, the <code class="literal">CheckBoundaries</code> function will check on the very next frame, before Robo has a chance to start <a id="id282" class="indexterm"/>moving back:</p><div><img src="img/8199OS_05_06.jpg" alt="Embedding"/></div><p>According to the boundary check, the right edge of Robo is still beyond the right edge of the screen, so once again Robo's velocity is set to zero. Robo is stopped before he can even take a step!</p><p>Here is the solution; as soon as we detect that Robo has exceeded the boundary, we set his velocity to zero and we reposition Robo to just the other side of the boundary:</p><div><img src="img/8199OS_05_07.jpg" alt="Embedding"/></div><p>Now, Robo will be able to move as long as he goes in the other direction.</p><p>To implement this <a id="id283" class="indexterm"/>change, we are once again going to change the <code class="literal">CheckBoundaries</code> function:</p><div><pre class="programlisting">void CheckBoundaries(Sprite* p_sprite)
{
  Sprite::Rect check = p_sprite-&gt;GetCollisionRect();
<strong>  float offset;</strong>
  float x;
  float y;
  
  if (check.left &lt; 0.0f)
  {
    p_sprite-&gt;SetVelocity(0.0f);
    <strong>offset = check.left;</strong>
<strong>    x = p_sprite-&gt;GetPosition().x - offset;</strong>
<strong>    y = p_sprite-&gt;GetPosition().y;</strong>
<strong>    p_sprite-&gt;SetPosition(x, y);</strong>
  }
  else if (check.right &gt; screen_width)
  {
    p_sprite-&gt;SetVelocity(0.0f);
    <strong>offset = screen_width - check.right;</strong>
<strong>    x = p_sprite-&gt;GetPosition().x + offset;</strong>
<strong>    y = p_sprite-&gt;GetPosition().y;</strong>
<strong>    p_sprite-&gt;SetPosition(x, y);</strong>
  }
  if (check.top &lt; 0.0f)
  {
    p_sprite-&gt;SetVelocity(0.0f);
    <strong>offset = check.top;</strong>
<strong>    y = p_sprite-&gt;GetPosition().y - offset;</strong>
<strong>    x = p_sprite-&gt;GetPosition().x;</strong>
<strong>    p_sprite-&gt;SetPosition(x, y);</strong>
  }
  else if (check.bottom &gt; screen_height)
  {
    p_sprite-&gt;SetVelocity(0.0f);
    <strong>offset = screen_height - check.bottom;</strong>
<strong>    y = p_sprite-&gt;GetPosition().y + offset;</strong>
<strong>    x = p_sprite-&gt;GetPosition().x;</strong>
<strong>    p_sprite-&gt;SetPosition(x, y);</strong>
  }
}</pre></div><p>The highlighted<a id="id284" class="indexterm"/> lines show the added code. Basically, we perform the following actions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calculate how far past the boundary Robo has gone</li><li class="listitem" style="list-style-type: disc">Adjust his position by that much so that he is now positioned right at the boundary</li></ul></div><p>You'll notice that we also filled out the function to handle the top and bottom boundaries so that the boundary checking can be used for any sprite travelling in any direction.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Fixing the background</h2></div></div></div><p>Now that we have Robo moving the way we want him to, two new problems have cropped up<a id="id285" class="indexterm"/> for the background image:</p><div><ol class="orderedlist arabic"><li class="listitem">When Robo stops, the background keeps scrolling.</li><li class="listitem">When the background image ends at either the right or the left, it slides off the screen and we are left with a black background.</li></ol></div><p>Before we continue on with collision detection, let's fix the background. First, we will add the following function to <code class="literal">RoboRacer2D.cpp</code>:</p><div><pre class="programlisting">void CheckBackground()
{
  float leftThreshold = 0.0f;
  float rightThreshold = -(background-&gt;GetSize().width - screen_width);
  if (background-&gt;GetPosition().x &gt; 0)
  {
    background-&gt;SetPosition(0.0f, background-&gt;GetPosition().y);
  }
  else if (background-&gt;GetPosition().x &lt; rightThreshold)
  {
    background-&gt;SetPosition(rightThreshold, background-&gt;GetPosition().y);
  }
}</pre></div><p>This code is very similar to the boundary checking code. If the background anchor point moves far enough to the left to expose the right edge of the texture, it will be reset. If the background anchor point moves far enough to the right to expose the left edge of the texture, it will be reset.</p><p>Now, add the<a id="id286" class="indexterm"/> highlighted line of code to the <code class="literal">Update</code> function right after the call to <code class="literal">CheckBoundaries</code> in <code class="literal">RoboRacer2D.cpp</code>:</p><div><pre class="programlisting">inputManager-&gt;Update(p_deltaTime);
ProcessInput();
CheckBoundaries(player);
<strong>CheckBackground();</strong>
</pre></div><p>The background should now run from edge to edge. Play the game and take a coffee break. You deserve it!</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Collideables</h1></div></div></div><p>There are<a id="id287" class="indexterm"/> many times that we may want to check and see whether objects in the game have collided with each other. We may want to see whether the player has struck an obstacle or an enemy. We may have objects that the player can pick up, often<a id="id288" class="indexterm"/> called <strong>pickups</strong> <a id="id289" class="indexterm"/>or <strong>powerups</strong>.</p><p>Collectively, objects in the game that can collide with other objects are known as collideables. When we created our <code class="literal">Sprite</code> class, we actually it designed for this. Looking at the class constructor, you will notice that member variable <code class="literal">m_isCollideable</code> is set to <code class="literal">false</code>. When we write our collision detection code, we will ignore objects that have <code class="literal">m_isCollideable</code> set to <code class="literal">false</code>. If we want to allow an object to collide with other objects, we have to make sure to set <code class="literal">m_collideable</code> to <code class="literal">true</code>.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Ready to score</h2></div></div></div><p>To keep our design simple, we are going to create one enemy and one pickup. Running into an enemy <a id="id290" class="indexterm"/>will subtract points from the player's score, while running into the pickup will increase the player's score. We will add some additional code to the sprite class to support this feature.</p><p>First, let's add some new member variables. Declare a new variable in <code class="literal">Sprite.h</code>:</p><div><pre class="programlisting">int m_value;</pre></div><p>Then add the following methods:</p><div><pre class="programlisting">void SetValue(const int p_value) { m_value = p_value; }
const int GetValue() const { return m_value; }</pre></div><p>With these changes, every sprite will have an intrinsic value. If the value is positive, then it is a reward. If the value is negative, then it is a penalty.</p><p>Don't forget <a id="id291" class="indexterm"/>to initialize <code class="literal">m_value</code> to zero in the <code class="literal">Sprite</code> class constructor!</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec72"/>A friend indeed</h2></div></div></div><p>Let's add<a id="id292" class="indexterm"/> the sprite for our pickup. In this case, the pickup is a can of oil to keep Robo's joints working smoothly.</p><p>Add the following sprite definitions to RoboRacer2D:</p><div><pre class="programlisting">Sprite* pickup;</pre></div><p>Now, we will set up the sprite. Add the following code to <code class="literal">LoadTextures</code>:</p><div><pre class="programlisting">pickup = new Sprite(1);
pickup-&gt;SetFrameSize(26.0f, 50.0f);
pickup-&gt;SetNumberOfFrames(1);
pickup-&gt;AddTexture("resources/oil.png");
pickup-&gt;IsVisible(false);
pickup-&gt;IsActive(false);
pickup-&gt;SetValue(50);</pre></div><p>This code is essentially the same code that we used to create all of our sprites. One notable difference is that we use the new <code class="literal">SetValue</code> method to add a value to the sprite. This represents how many points the player will earn for the collection of this pickup.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Time to spawn</h2></div></div></div><p>Note that <a id="id293" class="indexterm"/>we have set the sprite as inactive and invisible. Now, we will write a function to randomly spawn the pickup. First, we need to add two more C++ headers. In <code class="literal">RoboRacer2D.cpp</code> add the following headers:</p><div><pre class="programlisting">#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;</pre></div><p>We need <code class="literal">stdlib</code> for the <code class="literal">rand</code> function and <code class="literal">time</code> to give us a value to seed the random generator.</p><div><div><h3 class="title"><a id="tip39"/>Tip</h3><p>Random numbers are generated from internal tables. In order to guarantee that a different random number is chosen each time the program is started, you first seed the random number generator with a value that is guaranteed to be different each time you start the program. As the time that the program is started will always be different, we often use time as the seed.</p></div></div><p>Next, we need a timer. Declare the following variables in <code class="literal">RoboRacer2D.cpp</code>:</p><div><pre class="programlisting">float pickupSpawnThreshold;
float pickupSpawnTimer;</pre></div><p>The threshold will be the number of seconds that we want to pass before a pickup is spawned. The <a id="id294" class="indexterm"/>timer will start and zero and count up to that number of seconds.</p><p>Let's initialize these values in the <code class="literal">StartGame</code> function. The <code class="literal">StartGame</code> function is also a great place to seed our random number generator. Add the following three lines of code to the end of <code class="literal">StartGame</code>:</p><div><pre class="programlisting">srand(time(NULL));
pickupSpawnThreshold = 15.0f;
pickupSpawnTimer = 0.0f;</pre></div><p>The first line seeds the random number generator by passing in an integer representing the current time. The next line sets a spawn threshold of <code class="literal">15</code> seconds. The third line sets the spawn timer to <code class="literal">0</code>.</p><p>Now, let's create a function to spawn our pickups. Add the following code to <code class="literal">RoboRacer2D.cpp</code>:</p><div><pre class="programlisting">void SpawnPickup(float p_DeltaTime)
{
  if (pickup-&gt;IsVisible() == false)
  {
    pickupSpawnTimer += p_DeltaTime;
    if (pickupSpawnTimer &gt; pickupSpawnThreshold)
    {
      float marginX = pickup-&gt;GetSize().width;
      float marginY = pickup-&gt;GetSize().height;
      float spawnX = (rand() % (int)(screen_width - (marginX * 2))) + marginX;
      float spawnY = screen_height - ((rand() % (int)(player-&gt;GetSize().height - (marginY * 1.5))) + marginY);
      pickup-&gt;SetPosition(spawnX, spawnY);
      pickup-&gt;IsVisible(true);
      pickup-&gt;IsActive(true);
      pickupSpawnTimer = 0.0f;
    }
  }
}</pre></div><p>This code does the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It checks to make sure that the pickup is not already on the screen</li><li class="listitem" style="list-style-type: disc">If there is no pickup, then the spawn timer is incremented</li><li class="listitem" style="list-style-type: disc">If the spawn timer exceeds the spawn threshold, the pickup is spawned at a random position somewhere within the width of the screen and within the vertical reach of Robo</li></ul></div><p>Don't get too<a id="id295" class="indexterm"/> worried about the particular math being used. Your algorithm to position the pickup could be completely different. The key here is that a single pickup will be generated within Robo's reach.</p><p>Make sure to add a call to <code class="literal">SpawnPickup</code> in the <code class="literal">Update</code> function as well as a line to update the pickup:</p><div><pre class="programlisting">if (m_gameState == GS_Running)
{
  background-&gt;Update(p_deltaTime);
  robot_left-&gt;Update(p_deltaTime);
  robot_right-&gt;Update(p_deltaTime);
  robot_left_strip-&gt;Update(p_deltaTime);
  robot_right_strip-&gt;Update(p_deltaTime);
  
  pause-&gt;Update(p_deltaTime);
  resume-&gt;Update(p_deltaTime);
  
  <strong>pickup-&gt;Update(p_deltaTime);</strong>
<strong>  SpawnPickup(p_deltaTime);</strong>
}</pre></div><p>We also need to add a line to <code class="literal">Render</code> to render the pickup:</p><div><pre class="programlisting">void Render()
{
  glClear(GL_COLOR_BUFFER_BIT);
  glLoadIdentity();
  
  background-&gt;Render();
  robot_left-&gt;Render();
  robot_right-&gt;Render();
  robot_left_strip-&gt;Render();
  robot_right_strip-&gt;Render();
  
  pause-&gt;Render();
  resume-&gt;Render();
  
  <strong>pickup-&gt;Render();</strong>
  SwapBuffers(hDC);
}</pre></div><p>If you run <a id="id296" class="indexterm"/>the game right now, then an oil can should be spawned about five seconds after the game starts.</p><div><div><h3 class="title"><a id="tip40"/>Tip</h3><p>The current code has one flaw. It could potentially spawn the pickup right on top of Robo. Once we implement collision detection, the result will be that Robo immediately picks up the oil can. This will happen so quickly that you won't even see it happen. In the name of keeping it simple, we will live with this particular flaw.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Circular collision detection</h1></div></div></div><p>One way to detect collision is to see how far each of the objects are from each other's center. This is<a id="id297" class="indexterm"/> known as circular collision detection because it treats each object as if it is bound by a circle, and uses the radius of that circle to determine whether the objects are close enough to collide.</p><p>Take a look at the following diagram:</p><div><img src="img/8199OS_05_08.jpg" alt="Circular collision detection"/></div><p>The circles on the left are not colliding, while the circles on the right are colliding. For the non-colliding circles, the distance (<em>d</em>) between the center points of the two circles is greater than the sum of the two radii (<em>r1 + r2</em>). For the colliding circles, the distance (<em>d</em>) between the two centers is less than the sum of the two radii (<em>r1 + r2</em>). We can use this knowledge to test any two objects for collision based on the radii of the circles and the distance<a id="id298" class="indexterm"/> between the objects center point.</p><p>So, how do we use this information?</p><div><ol class="orderedlist arabic"><li class="listitem">We will know <strong>r1</strong> and <strong>r2</strong> because we set them when we create the sprite.</li><li class="listitem">We will calculate two legs of a right-triangle using the <em>x</em> and <em>y</em> coordinates for the center of each circle.</li><li class="listitem">We will calculate <em>d</em>, the distance between two center points, using a variant of the <strong>Pythagorean Theorem</strong>.</li></ol></div><p>It will probably hurt your brain a little, but I'd like to refresh your memory one tenet of basic geometry.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec74"/>The Pythagorean Theorem</h2></div></div></div><p>The<a id="id299" class="indexterm"/> Pythagorean Theorem allows <a id="id300" class="indexterm"/>us to find the distance between any two points in a two-dimensional space if we know the lengths of the line segments that form a right-angle between the points.</p><div><img src="img/8199OS_05_09.jpg" alt="The Pythagorean Theorem"/></div><p>
<em>a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></em>
</p><p>In our <a id="id301" class="indexterm"/>case, we are trying to<a id="id302" class="indexterm"/> calculate the distance (c) between the two points.</p><p>A little algebra will transform this equation to:</p><div><img src="img/81990S_05_11.jpg" alt="The Pythagorean Theorem"/></div><p>It is computationally expensive to perform the square root. A nice mathematical trick will actually allow us to perform our collision detection without calculating the square root.</p><p>If we were to use square roots to do this calculation, here is what that might look like:</p><div><pre class="programlisting">c = sqrt(a * a + b * b);
if (c &lt;= r1 + r2) return true;</pre></div><p>Although this would work, there is a nice little mathematical trick that allows us to accomplish this test without taking the square root. Take a look at this:</p><div><pre class="programlisting">c = a * a + b * b;
if (c&lt;= r1 * r1 + r2 * r2) return true;</pre></div><p>It turns out that we can just keep everything in the equation at the power of 2 and the comparison<a id="id303" class="indexterm"/> still works. This is because we<a id="id304" class="indexterm"/> are only interested in the relative comparison between the distance and the sum of the radii, not the absolute mathematical values.</p><div><div><h3 class="title"><a id="tip41"/>Tip</h3><p>If the math we presented here boggles your brain, then don't worry too much. Circular collision detection is so common that the math to detect it is generally already built into the game engine that you will use. However, I wanted you to take a little look under the hood. After all, game programming is inherently mathematical, and the more you understand the math, the better you will be at coding.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Adding the circular collision code</h2></div></div></div><p>Now, it's time to modify <code class="literal">Sprite.h</code> to add support for the circular collision detection. First, we need to<a id="id305" class="indexterm"/> add some member variables to hold the center point and radius. Add these two properties to <code class="literal">Sprite.h</code>:</p><div><pre class="programlisting">float m_radius;
Point m_center;</pre></div><p>Then add the following methods declarations:</p><div><pre class="programlisting">void SetRadius(const GLfloat p_radius) { m_radius = p_radius; }
const float GetRadius() const { return m_radius; }
void SetCenter(const Point p_center) { m_center = p_center; }
const Point GetCenter() const;
const bool IntersectsCircle(const Sprite* p_sprite) const;</pre></div><p>These methods allow us to set and retrieve the center point and radius of the sprite. The <code class="literal">GetCenter</code> method is more than one line, so we will implement it in <code class="literal">Sprite.cpp</code>:</p><div><pre class="programlisting">const Sprite::Point Sprite::GetCenter() const
{
  Point center;
  center.x = this-&gt;GetPosition().x + m_center.x;
  center.y = this-&gt;GetPosition().y + m_center.y;

  return center;
}</pre></div><p>An important point to note here is that <code class="literal">m_center</code> represents an <code class="literal">x</code> and <code class="literal">y</code> offset from the sprite's anchor point. So, to return the center point we will add <code class="literal">m_center</code> to the current position of the sprite and this will give us the current center point of the sprite exactly where it is in the game.</p><p>We now need to <a id="id306" class="indexterm"/>add the code to perform the collision detection. Add the following code to <code class="literal">Sprite.cpp</code>:</p><div><pre class="programlisting">const bool Sprite::IntersectsCircle(const Sprite* p_sprite) const
{
 if (this-&gt;IsCollideable() &amp;&amp; p_sprite-&gt;IsCollideable() &amp;&amp; this-&gt;IsActive() &amp;&amp; p_sprite-&gt;IsActive())
 {
  const Point p1 = this-&gt;GetCenter();
  const Point p2 = p_sprite-&gt;GetCenter();
  float y = p2.y - p1.y;
  float x = p2.x - p1.x;
  float d = x*x + y*y;
  float r1 = this-&gt;GetRadius() * this-&gt;GetRadius();
  float r2 = p_sprite-&gt;GetRadius() * p_sprite-&gt;GetRadius();
  if (d &lt;= r1 + r2)
  {
   return true;
  }
 }
 return false;
}</pre></div><p>As we have already explained the use of the Pythagorean Theorem, this code should actually seem a little familiar to you. Here is what we are doing:</p><p>The function accepts one sprite to compare with itself.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we check to make sure both sprites are collideable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">p1</code> and <code class="literal">p2</code> represent the two centers.</li><li class="listitem" style="list-style-type: disc"><code class="literal">x</code> and <code class="literal">y</code> represent the lengths of the <em>a</em> and <em>b</em> sides of a right-angled triangle. Notice that the calculation is simply the difference between the <code class="literal">x</code> and <code class="literal">y</code> position of each sprite, respectively.</li><li class="listitem" style="list-style-type: disc"><code class="literal">r1</code> and <code class="literal">r2</code> are the radii of the two circles (left as a power of 2).</li><li class="listitem" style="list-style-type: disc"><code class="literal">d</code> is the distance between the two centers (left as a power of 2).</li><li class="listitem" style="list-style-type: disc">If <code class="literal">d</code> is <a id="id307" class="indexterm"/>less than or equal to the sum of the two radii, then the circles are intersecting.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec76"/>Why use circular collision detection?</h2></div></div></div><p>As we discussed many times, textures are represented as rectangles. In fact, we will take advantage<a id="id308" class="indexterm"/> of this when we cover rectangular collision detection later in the chapter. The following figure illustrates how rectangular and circular collision detection differ (the relative sizes are exaggerated to make a point):</p><div><img src="img/8199OS_05_10.jpg" alt="Why use circular collision detection?"/></div><p>The sprites on the left are colliding using a rectangular bounding box. The sprites on the right are colliding using a bounding circle. In general, using a bounding circle is visually more convincing when we are dealing with rounder shapes.</p><div><div><h3 class="title"><a id="tip42"/>Tip</h3><p>I'll admit the difference in this example is not that big. You could get away with rectangular or circular collision detection in this example. The round nature of the oil can made it a good candidate for circular collision detection. Circular collision detection is really essential if the two objects that are colliding are actually circles (that is, two balls colliding).</p></div></div><p>With the code that we developed, we need to define the center and radius for any sprites that will use circular collision detection. Add the following code to the <code class="literal">LoadTextures</code> function in <code class="literal">RoboRacer.cpp</code>:</p><div><pre class="programlisting">Sprite::Point center;
float radius;

center.x = robot_right-&gt;GetSize().width / 2.0f;
center.y = robot_right-&gt;GetSize().height / 2.0f;
radius = (center.x + center.y) / 2.0f;

robot_right-&gt;SetCenter(center);
robot_right-&gt;SetRadius(radius);
robot_left-&gt;SetCenter(center);
robot_left-&gt;SetRadius(radius);

center.x = pickup-&gt;GetSize().width / 2.0f;
float yOffset = (pickup-&gt;GetSize().height / 4.0f) * 3.0f;
center.y = yOffset;
pickup-&gt;SetCenter(center);
radius = pickup-&gt;GetSize().width / 2.0f;
pickup-&gt;SetRadius(radius);</pre></div><p>Don't get too<a id="id309" class="indexterm"/> worried about the exact values that we are using here. We are basically setting up a bounding circle for Robo and the oil can that match the preceding figure. Robo's bounding circle is set to the middle of the robot, while the oil can's circle is set to the bottom half of the texture.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Wiring in the collision detection</h2></div></div></div><p>We are now<a id="id310" class="indexterm"/> going to add a new function that will perform all of our collision detection. Add the following function to <code class="literal">RoboRacer2D.cpp</code>:</p><div><pre class="programlisting">void CheckCollisions()
{
 if (player-&gt;IntersectsCircle(pickup))
 {
  pickup-&gt;IsVisible(false);
  pickup-&gt;IsActive(false);
  player-&gt;SetValue(player-&gt;GetValue() + pickup-&gt;GetValue());
  pickupSpawnTimer = 0.0f;
 }
}</pre></div><p>The purpose of this code is to check to see whether the player has collided with the pickup:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the call to <code class="literal">player-&gt;IntersectsCircle(pickup)</code> returns <code class="literal">true</code>, then the player has collided with the pickup</li><li class="listitem" style="list-style-type: disc">The pickup is deactivated and made invisible</li><li class="listitem" style="list-style-type: disc">The pickup's value is added to the player's value (this will be the base for scoring in a future chapter)</li><li class="listitem" style="list-style-type: disc">The spawn timer is reset</li></ul></div><p>We have two <a id="id311" class="indexterm"/>small details left. First, you must add a call to <code class="literal">CheckCollisions</code> to the <code class="literal">Update</code> function:</p><div><pre class="programlisting">if (m_gameState == GS_Running)
{
  background-&gt;Update(p_deltaTime);
  robot_left-&gt;Update(p_deltaTime);
  robot_right-&gt;Update(p_deltaTime);
  robot_left_strip-&gt;Update(p_deltaTime);
  robot_right_strip-&gt;Update(p_deltaTime);
  
  pause-&gt;Update(p_deltaTime);
  resume-&gt;Update(p_deltaTime);
  
  pickup-&gt;Update(p_deltaTime);
  SpawnPickup(p_deltaTime);
  
  <strong>CheckCollisions();</strong>
}</pre></div><p>Secondly, you need to make the player and pickup <code class="literal">collideable</code>. Add these three lines to the bottom of <code class="literal">LoadTextures</code> just before the return statement:</p><div><pre class="programlisting">robot_left-&gt;IsCollideable(true);
robot_right-&gt;IsCollideable(true);
pickup-&gt;IsCollideable(true);</pre></div><p>Now, the real fun starts! Play the game and when the oil can spawns, and use Robo to pick it up. Five seconds later another oil can spawns. The fun never ends!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Rectangular collision detection</h1></div></div></div><p>Now, we are <a id="id312" class="indexterm"/>going to learn how to implement rectangular collision detection. It turns out that both Robo and our enemy (a water bottle) are very rectangular, making rectangular collision detection the best choice.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec78"/>The enemy within</h2></div></div></div><p>Let's introduce our Robo's enemy—a bottle of water to rust his gears. The code for this is included next.</p><p>Add the<a id="id313" class="indexterm"/> following sprite definition to <code class="literal">RoboRacer2D</code>:</p><div><pre class="programlisting">Sprite* enemy;</pre></div><p>Now, we will setup the sprite. Add the following code to <code class="literal">LoadTextures</code>:</p><div><pre class="programlisting">enemy = new Sprite(1);
enemy-&gt;SetFrameSize(32.0f, 50.0f);
enemy-&gt;SetNumberOfFrames(1);
enemy-&gt;AddTexture("resources/water.png");
enemy-&gt;IsVisible(false);
enemy-&gt;IsActive(false);
enemy-&gt;SetValue(-50);
enemy-&gt;IsCollideable(true);</pre></div><p>This code is essentially the same code that we used to create all of our sprites. One notable difference is that we use the new <code class="literal">SetValue</code> method to add a negative value to the sprite. This is how many points the player will lose if they hit this enemy. We also make sure that we set the enemy to be collideable.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec79"/>Spawning the enemy</h2></div></div></div><p>Just like the<a id="id314" class="indexterm"/> pickups, we need to spawn our enemies. We could use the same code as the pickups, but I thought it would be nicer if our enemies worked on a different timer.</p><p>Declare the following variables in <code class="literal">RoboRacer2D.cpp</code>:</p><div><pre class="programlisting">float enemySpawnThreshold;
float enemySpawnTimer;</pre></div><p>The threshold will be the amount of seconds that we want to pass before an enemy is spawned. The timer will start and zero and count up to that number of seconds.</p><p>Let's initialize these values in the <code class="literal">StartGame</code> function. Add the following two lines of code to the end of <code class="literal">StartGame</code>:</p><div><pre class="programlisting">enemySpawnThreshold = 7.0f;
enemySpawnTimer = 0.0f;</pre></div><p>We set a spawn threshold of 7 seconds, and set the spawn timer to 0.</p><p>Now, let's create<a id="id315" class="indexterm"/> a function to spawn our enemies. Add the following code to <code class="literal">RoboRacer2D.cpp</code>:</p><div><pre class="programlisting">void SpawnEnemy(float p_DeltaTime)
{
  if (enemy-&gt;IsVisible() == false)
  {
    enemySpawnTimer += p_DeltaTime;
    if (enemySpawnTimer &gt;enemySpawnThreshold)
    {
      float marginX = enemy-&gt;GetSize().width;
      float marginY = enemy-&gt;GetSize().height;
      float spawnX = (rand() % (int)(screen_width - (marginX * 2))) + marginX;
      float spawnY = screen_height - ((rand() % (int)(player-&gt;GetSize().height - (marginY * 2))) + marginY);
      enemy-&gt;SetPosition(spawnX, spawnY);
      enemy-&gt;IsVisible(true);
      enemy-&gt;IsActive(true);
    }
  }
}</pre></div><p>This code does the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It checks to make sure that the enemy is not already on the screen</li><li class="listitem" style="list-style-type: disc">If there is no enemy, then the spawn timer is incremented</li><li class="listitem" style="list-style-type: disc">If the spawn timer exceeds the spawn threshold, the enemy is spawned at a random position somewhere within the width of the screen and within the vertical reach of Robo</li></ul></div><p>Don't get too worried about the particular math being used. Your algorithm to position the enemy can be completely different. The key here is that a single enemy will be generated within Robo's path.</p><p>Make sure to add a call to <code class="literal">SpawnEnemy</code> in the <code class="literal">Update</code> function as well as a line to update the enemy:</p><div><pre class="programlisting">if (m_gameState == GS_Running)
{
  background-&gt;Update(p_deltaTime);
  robot_left-&gt;Update(p_deltaTime);
  robot_right-&gt;Update(p_deltaTime);
  robot_left_strip-&gt;Update(p_deltaTime);
  robot_right_strip-&gt;Update(p_deltaTime);
  
  pause-&gt;Update(p_deltaTime);
  resume-&gt;Update(p_deltaTime);
  
  pickup-&gt;Update(p_deltaTime);
  SpawnPickup(p_deltaTime);
  
  <strong>enemy-&gt;Update(p_deltaTime);</strong>
<strong>  SpawnEnemy(p_deltaTime);</strong>
  
  CheckCollisions();
  
}</pre></div><p>We also<a id="id316" class="indexterm"/> need to add a line to <code class="literal">Render</code> to render the enemy:</p><div><pre class="programlisting">void Render()
{
  glClear(GL_COLOR_BUFFER_BIT);
  glLoadIdentity();
  
  background-&gt;Render();
  robot_left-&gt;Render();
  robot_right-&gt;Render();
  robot_left_strip-&gt;Render();
  robot_right_strip-&gt;Render();
  
  pause-&gt;Render();
  resume-&gt;Render();
  
  pickup-&gt;Render();
  <strong>enemy-&gt;Render();</strong>
  SwapBuffers(hDC);
}</pre></div><p>If you run the<a id="id317" class="indexterm"/> game right now, then a water bottle should be spawned about seven seconds after the game starts.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec80"/>Adding the rectangular collision code</h2></div></div></div><p>As we have mentioned several times, all sprites are essentially rectangles. Visually, if any border of these rectangles overlap, we can assume that the two sprites have collided.</p><p>We are going <a id="id318" class="indexterm"/>to add a function to our <code class="literal">Sprite</code> class that determines whether two rectangles are intersecting. Open <code class="literal">Sprite.h</code> and add the following method declaration:</p><div><pre class="programlisting">const bool IntersectsRect(const Sprite*p_sprite) const;</pre></div><p>Now, let's add the implementation to <code class="literal">Sprite.cpp</code>:</p><div><pre class="programlisting">const bool Sprite::IntersectsRect(const Sprite* p_sprite) const
{
 if (this-&gt;IsCollideable() &amp;&amp; p_sprite-&gt;IsCollideable() &amp;&amp; this-&gt;IsActive() &amp;&amp; p_sprite-&gt;IsActive()) 
 {
  const Rect recta = this-&gt;GetCollisionRect();
  const Rect rectb = p_sprite-&gt;GetCollisionRect();
  if (recta.left &gt;= rectb.left &amp;&amp; recta.left &lt;= rectb.right &amp;&amp; recta.top &gt;= rectb.top &amp;&amp; recta.top &lt;= rectb.bottom)
  {
   return true;
  }
  else if (recta.right &gt;= rectb.left &amp;&amp; recta.right &lt;= rectb.right &amp;&amp; recta.top &gt;= rectb.top &amp;&amp; recta.top &lt;= rectb.bottom)
  {
   return true;
  }
  else if (recta.left &gt;= rectb.left &amp;&amp; recta.right &lt;= rectb.right &amp;&amp; recta.top &lt; rectb.top &amp;&amp; recta.bottom &gt; rectb.bottom)
  {
   return true;
  }
  else if (recta.top &gt;= rectb.top &amp;&amp; recta.bottom &lt;= rectb.bottom &amp;&amp; recta.left &lt; rectb.left &amp;&amp; recta.right &gt; rectb.right)
  {
   return true;
  }
  else if (rectb.left &gt;= recta.left &amp;&amp; rectb.left &lt;= recta.right &amp;&amp;
   rectb.top &gt;= recta.top &amp;&amp; rectb.top &lt;= recta.bottom)
  {
   return true;
  }
  else if (rectb.right &gt;= recta.left &amp;&amp; rectb.right &lt;= recta.right &amp;&amp; rectb.top &gt;= recta.top &amp;&amp; rectb.top &lt;= recta.bottom)
  {
   return true;
  }
  else if (rectb.left &gt;= recta.left &amp;&amp; rectb.right &lt;= recta.right &amp;&amp; rectb.top &lt; recta.top &amp;&amp; rectb.bottom &gt; recta.bottom)
  {
   return true;
  }
  else if (recta.top &gt;= rectb.top &amp;&amp; recta.bottom &lt;= rectb.bottom &amp;&amp; recta.left &lt; rectb.left &amp;&amp; recta.right &gt; rectb.right)
  {
   return true;
  }
  else if (rectb.top &gt;= recta.top &amp;&amp; rectb.bottom &lt;= recta.bottom &amp;&amp; rectb.left &lt; recta.left &amp;&amp; rectb.right &gt; recta.right)
  {
   return true;
  }
 }
 return false;
}</pre></div><p>Here's how<a id="id319" class="indexterm"/> this code works:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This function looks really complicated, but it is really only doing a few things.</li><li class="listitem" style="list-style-type: disc">The function accepts a sprite parameter.</li><li class="listitem" style="list-style-type: disc">We set <code class="literal">recta</code> to be the collision rectangle of the sprite that called the <code class="literal">IntersectsRect</code> method and set <code class="literal">rectb</code> to be the collision rectangle of the sprite that was passed in.</li><li class="listitem" style="list-style-type: disc">We then test every possible combination of the position of the vertices in of <code class="literal">recta</code> to those of <code class="literal">rectb</code>. If any test is <code class="literal">true</code>, then we return <code class="literal">true</code>. Otherwise we return <code class="literal">false</code>.</li></ul></div><p>The following <a id="id320" class="indexterm"/>figure illustrates some of the ways that two rectangles could interact:</p><div><img src="img/8199OS_05_12.jpg" alt="Adding the rectangular collision code"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec81"/>Wiring continued</h2></div></div></div><p>We have<a id="id321" class="indexterm"/> already wired in the collision check using <code class="literal">CheckCollisions</code>. We just need to add the following code to <code class="literal">CheckCollisions</code> to the check whether the player is colliding with an enemy:</p><div><pre class="programlisting">if (player-&gt;IntersectsRect(enemy))
{
  enemy-&gt;IsVisible(false);
  enemy-&gt;IsActive(false);
  enemy-&gt;SetValue(player-&gt;GetValue() + enemy-&gt;GetValue());
  enemySpawnTimer = 0.0f;
}</pre></div><p>Now, the real fun starts! Play the game and when the water can enemy spawns make sure Robo avoids it! If you collide with an enemy, you will lose points (as the value of enemy is set to a negative number). Until we implement a visible score, you may want to write the score out to the console.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Summary</h1></div></div></div><p>I'm sure you can now understand that most games would not be possible without collision detection. Collision detection allows objects in the game to interact with each other. We used collision detection to get pickups and detect whether we ran into an enemy.</p><p>We also discussed the essential task of boundary checking. Boundary checking is a special form of collision detection that checks to see whether an object has reached the screen boundaries. Another type of boundary checking is used to manage the scene background.</p><p>In the next chapter, we will wrap up the game by adding some finishing touches, including a heads-up display!</p></div></body></html>