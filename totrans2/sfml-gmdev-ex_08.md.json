["```cpp\nusing ComponentType = unsigned int;\n#define N_COMPONENT_TYPES 32\n\nenum class Component{\n Position = 0, SpriteSheet, State, Movable, Controller, Collidable\n};\n\nenum class System{\n Renderer = 0, Movement, Collision, Control, State, SheetAnimation\n};\n```", "```cpp\nclass C_Base{\npublic:\n  C_Base(const Component& l_type): m_type(l_type){}\n  virtual ~C_Base(){}\n\n  Component GetType(){ return m_type; }\n\n  friend std::stringstream& operator >>(\n    std::stringstream& l_stream, C_Base& b)\n  {\n    b.ReadIn(l_stream);\n    return l_stream;\n  }\n\n  virtual void ReadIn(std::stringstream& l_stream) = 0;\nprotected:\n  Component m_type;\n};\n```", "```cpp\nclass C_Position : public C_Base{\npublic:\n  C_Position(): C_Base(Component::Position), m_elevation(0){}\n  ~C_Position(){}\n\n  void ReadIn(std::stringstream& l_stream){\n    l_stream >> m_position.x >> m_position.y >> m_elevation;\n  }\n\n  const sf::Vector2f& GetPosition(){ return m_position; }\n  const sf::Vector2f& GetOldPosition(){ return m_positionOld; }\n  unsigned int GetElevation(){ return m_elevation; }\n\n  void SetPosition(float l_x, float l_y){\n    m_positionOld = m_position;\n    m_position = sf::Vector2f(l_x,l_y);\n  }\n\n  void SetPosition(const sf::Vector2f& l_vec){\n    m_positionOld = m_position;\n    m_position = l_vec;\n  }\n\n  void SetElevation(unsigned int l_elevation){\n    m_elevation = l_elevation;\n  }\n\n  void MoveBy(float l_x, float l_y){\n    m_positionOld = m_position;\n    m_position += sf::Vector2f(l_x,l_y);\n  }\n\n  void MoveBy(const sf::Vector2f& l_vec){\n    m_positionOld = m_position;\n    m_position += l_vec;\n  }\n\nprivate:\n  sf::Vector2f m_position;\n  sf::Vector2f m_positionOld;\n  unsigned int m_elevation;\n};\n```", "```cpp\n#include <stdint.h>\n\nusing Bitset = uint32_t;\nclass Bitmask{\npublic:\n  Bitmask() : bits(0){}\n  Bitmask(const Bitset& l_bits) : bits(l_bits){}\n\n  Bitset GetMask() const{ return bits; }\n  void SetMask(const Bitset& l_value){ bits = l_value; }\n\n  bool Matches(const Bitmask& l_bits, \n    const Bitset& l_relevant = 0)const\n  {\n    return(l_relevant ?\n      ((l_bits.GetMask() & l_relevant) == (bits & l_relevant))\n      :(l_bits.GetMask() == bits));\n  }\n\n  bool GetBit(const unsigned int& l_pos)const{\n    return ((bits&(1 << l_pos)) != 0);\n  }\n  void TurnOnBit(const unsigned int& l_pos){\n    bits |= 1 << l_pos;\n  }\n  void TurnOnBits(const Bitset& l_bits){\n    bits |= l_bits;\n  }\n  void ClearBit(const unsigned int& l_pos){\n    bits &= ~(1 << l_pos);\n  }\n  void ToggleBit(const unsigned int& l_pos){\n    bits ^= 1 << l_pos;\n  }\n\n  void Clear(){ bits = 0; }\nprivate:\n  Bitset bits;\n};\n```", "```cpp\nusing EntityId = unsigned int;\n\nusing ComponentContainer = std::vector<C_Base*>;\nusing EntityData = std::pair<Bitmask,ComponentContainer>;\nusing EntityContainer = std::unordered_map<EntityId,EntityData>;\nusing ComponentFactory = std::unordered_map<\n  Component,std::function<C_Base*(void)>>;\n```", "```cpp\nclass SystemManager;\nclass EntityManager{\npublic:\n  EntityManager(SystemManager* l_sysMgr,\n    TextureManager* l_textureMgr);\n  ~EntityManager();\n\n  int AddEntity(const Bitmask& l_mask);\n  int AddEntity(const std::string& l_entityFile);\n  bool RemoveEntity(const EntityId& l_id);\n\n  bool AddComponent(const EntityId& l_entity,\n    const Component& l_component);\n\n  template<class T>\n  T* GetComponent(const EntityId& l_entity,\n    const Component& l_component){ ... }\n\n  bool RemoveComponent(const EntityId& l_entity,\n    const Component& l_component);\n  bool HasComponent(const EntityId& l_entity,\n    const Component& l_component);\n\n  void Purge();\nprivate:\n  template<class T>\n  void AddComponentType(const Component& l_id){\n    m_cFactory[l_id] = []()->C_Base* { return new T(); };\n  }\n\n  // Data members\n  unsigned int m_idCounter;\n  EntityContainer m_entities;\n  ComponentFactory m_cFactory;\n\n  SystemManager* m_systems;\n  TextureManager* m_textureManager;\n};\n```", "```cpp\ntemplate<class T>\nT* GetComponent(const EntityId& l_entity,\n  const Component& l_component)\n{\n  auto itr = m_entities.find(l_entity);\n  if (itr == m_entities.end()){ return nullptr; }\n  // Found the entity.\n  if (!itr->second.first.GetBit((unsigned int)l_component))\n  {\n    return nullptr;\n  }\n  // Component exists.\n  auto& container = itr->second.second;\n  auto component = std::find_if(container.begin(),container.end(),\n    [&l_component](C_Base* c){\n      return c->GetType() == l_component;\n    });\n  return (component != container.end() ?\n    dynamic_cast<T*>(*component) : nullptr);\n}\n```", "```cpp\nEntityManager::EntityManager(SystemManager* l_sysMgr, \n  TextureManager* l_textureMgr): m_idCounter(0), \n  m_systems(l_sysMgr), m_textureManager(l_textureMgr)\n{\n  AddComponentType<C_Position>(Component::Position);\n  AddComponentType<C_SpriteSheet>(Component::SpriteSheet);\n  AddComponentType<C_State>(Component::State);\n  AddComponentType<C_Movable>(Component::Movable);\n  AddComponentType<C_Controller>(Component::Controller);\n  AddComponentType<C_Collidable>(Component::Collidable);\n}\n\nEntityManager::~EntityManager(){ Purge(); }\n```", "```cpp\nint EntityManager::AddEntity(const Bitmask& l_mask){\n  unsigned int entity = m_idCounter;\n  if (!m_entities.emplace(entity,\n    EntityData(0,ComponentContainer())).second)\n  { return -1; }\n  ++m_idCounter;\n  for(unsigned int i = 0; i < N_COMPONENT_TYPES; ++i){\n    if(l_mask.GetBit(i)){ AddComponent(entity,(Component)i); }\n  }\n  // Notifying the system manager of a modified entity.\n  m_systems->EntityModified(entity,l_mask);\n  m_systems->AddEvent(entity,(EventID)EntityEvent::Spawned);\n  return entity;\n}\n```", "```cpp\nbool EntityManager::RemoveEntity(const EntityId& l_id){\n  auto itr = m_entities.find(l_id);\n  if (itr == m_entities.end()){ return false; }\n  // Removing all components.\n  while(itr->second.second.begin() != itr->second.second.end()){\n    delete itr->second.second.back();\n    itr->second.second.pop_back();\n  }\n  m_entities.erase(itr);\n  m_systems->RemoveEntity(l_id);\n  return true;\n}\n```", "```cpp\nbool EntityManager::AddComponent(const EntityId& l_entity, \n  const Component& l_component)\n{\n  auto itr = m_entities.find(l_entity);\n  if (itr == m_entities.end()){ return false; }\n  if (itr->second.first.GetBit((unsigned int)l_component))\n  {\n    return false;\n  }\n  // Component doesn't exist.\n  auto itr2 = m_cFactory.find(l_component);\n  if (itr2 == m_cFactory.end()){ return false; }\n  // Component type does exist.\n  C_Base* component = itr2->second();\n  itr->second.second.emplace_back(component);\n  itr->second.first.TurnOnBit((unsigned int)l_component);\n  // Notifying the system manager of a modified entity.\n  m_systems->EntityModified(l_entity,itr->second.first);\n  return true;\n}\n```", "```cpp\nbool EntityManager::RemoveComponent(const EntityId& l_entity,\n  const Component& l_component)\n{\n  auto itr = m_entities.find(l_entity);\n  if (itr == m_entities.end()){ return false; }\n  // Found the entity.\n  if (!itr->second.first.GetBit((unsigned int)l_component))\n  {\n    return false;\n  }\n  // Component exists.\n  auto& container = itr->second.second;\n  auto component = std::find_if(container.begin(),container.end(),\n    [&l_component](C_Base* c){\n      return c->GetType() == l_component;\n    });\n  if (component == container.end()){ return false; }\n  delete (*component);\n  container.erase(component);\n  itr->second.first.ClearBit((unsigned int)l_component);\n\n  m_systems->EntityModified(l_entity, itr->second.first);\n  return true;\n}\n```", "```cpp\nbool EntityManager::HasComponent(const EntityId& l_entity,\n  const Component& l_component)\n{\n  auto itr = m_entities.find(l_entity);\n  if (itr == m_entities.end()){ return false; }\n  return itr->second.first.GetBit((unsigned int)l_component);\n}\n```", "```cpp\nvoid EntityManager::Purge(){\n  m_systems->PurgeEntities();\n  for(auto& entity : m_entities){\n    for(auto &component : entity.second.second){delete component;}\n    entity.second.second.clear();\n    entity.second.first.Clear();\n  }\n  m_entities.clear();\n  m_idCounter = 0;\n}\n```", "```cpp\nName Player\nAttributes 63\n|Component|ID|Individual attributes|\nComponent 0 0 0 1\n...\n```", "```cpp\nint EntityManager::AddEntity(const std::string& l_entityFile){\n  int EntityId = -1;\n\n  std::ifstream file;\n  file.open(Utils::GetWorkingDirectory() +\n    \"media/Entities/\" + l_entityFile + \".entity\");\n  if (!file.is_open()){\n    std::cout << \"! Failed to load entity: \"\n      << l_entityFile << std::endl;\n    return -1;\n  }\n  std::string line;\n  while(std::getline(file,line)){\n    if (line[0] == '|'){ continue; }\n    std::stringstream keystream(line);\n    std::string type;\n    keystream >> type;\n    if(type == \"Name\"){\n\n    } else if(type == \"Attributes\"){\n      if (EntityId != -1){ continue; }\n      Bitset set = 0;\n      Bitmask mask;\n      keystream >> set;\n      mask.SetMask(set);\n      EntityId = AddEntity(mask);\n      if(EntityId == -1){ return -1; }\n    } else if(type == \"Component\"){\n      if (EntityId == -1){ continue; }\n      unsigned int c_id = 0;\n      keystream >> c_id;\n      C_Base* component = GetComponent<C_Base>\n        (EntityId,(Component)c_id);\n      if (!component){ continue; }\n      keystream >> *component;\n      if(component->GetType() == Component::SpriteSheet){\n        C_SpriteSheet* sheet = (C_SpriteSheet*)component;\n        sheet->Create(m_textureManager);\n      }\n    }\n  }\n  file.close();\n  return EntityId;\n}\n```", "```cpp\nenum class EntityEvent{ \n  Spawned, Despawned, Colliding_X, Colliding_Y, \n  Moving_Left, Moving_Right, Moving_Up, Moving_Down,\n  Elevation_Change, Became_Idle, Began_Moving\n};\n```", "```cpp\nusing EventID = unsigned int;\n\nclass EventQueue{\npublic:\n  void AddEvent(const EventID& l_event){m_queue.push(l_event);}\n\n  bool ProcessEvents(EventID& l_id){\n    if (m_queue.empty()){ return false; }\n    l_id = m_queue.front();\n    m_queue.pop();\n    return true;\n  }\n\n  void Clear(){ while(!m_queue.empty()){ m_queue.pop(); }}\nprivate:\n  std::queue<EventID> m_queue;\n};\n```", "```cpp\nusing EntityList = std::vector<EntityId>;\nusing Requirements = std::vector<Bitmask>;\n```", "```cpp\nclass SystemManager;\nclass S_Base{\npublic:\n  S_Base(const System& l_id, SystemManager* l_systemMgr);\n  virtual ~S_Base();\n\n  bool AddEntity(const EntityId& l_entity);\n  bool HasEntity(const EntityId& l_entity);\n  bool RemoveEntity(const EntityId& l_entity);\n\n  System GetId();\n\n  bool FitsRequirements(const Bitmask& l_bits);\n  void Purge();\n\n  virtual void Update(float l_dT) = 0;\n  virtual void HandleEvent(const EntityId& l_entity,\n    const EntityEvent& l_event) = 0;\nprotected:\n  System m_id;\n  Requirements m_requiredComponents;\n  EntityList m_entities;\n\n  SystemManager* m_systemManager;\n};\n```", "```cpp\n#include \"System_Manager.h\"\n```", "```cpp\nS_Base::S_Base(const System& l_id, SystemManager* l_systemMgr) \n    : m_id(l_id), m_systemManager(l_systemMgr){}\n\nS_Base::~S_Base(){ Purge(); }\n```", "```cpp\nbool S_Base::AddEntity(const EntityId& l_entity){\n  if (HasEntity(l_entity)){ return false; }\n  m_entities.emplace_back(l_entity);\n  return true;\n}\n```", "```cpp\nbool S_Base::HasEntity(const EntityId& l_entity){\n  return std::find(m_entities.begin(),\n    m_entities.end(), l_entity) != m_entities.end();\n}\n```", "```cpp\nbool S_Base::RemoveEntity(const EntityId& l_entity){\n  auto entity = std::find_if(m_entities.begin(), m_entities.end(),\n    [&l_entity](EntityId& id){ return id = l_entity; });\n  if (entity == m_entities.end()){ return false; }\n  m_entities.erase(entity);\n  return true;\n}\n```", "```cpp\nbool S_Base::FitsRequirements(const Bitmask& l_bits){\n  return std::find_if(m_requiredComponents.begin(),\n    m_requiredComponents.end(), [&l_bits](Bitmask& b){\n      return b.Matches(l_bits, b.GetMask());\n    }) != m_requiredComponents.end();\n}\n```", "```cpp\nvoid S_Base::Purge(){ m_entities.clear(); }\n```", "```cpp\nclass Observer{\npublic:\n    virtual ~Observer(){}\n    virtual void Notify(const Message& l_message) = 0;\n};\n```", "```cpp\nusing MessageType = unsigned int;\nstruct TwoFloats{ float m_x; float m_y; };\n\nstruct Message{\n    Message(const MessageType& l_type) : m_type(l_type){}\n\n    MessageType m_type;\n    int m_sender;\n    int m_receiver;\n\n    union{\n        TwoFloats m_2f;\n        bool m_bool;\n        int m_int;\n    };\n};\n```", "```cpp\nusing ObserverContainer = std::vector<Observer*>;\n```", "```cpp\nclass Communicator{\npublic:\n  ~Communicator(){ m_observers.clear(); }\n\n  bool AddObserver(Observer* l_observer){\n    if (HasObserver(l_observer)){ return false; }\n    m_observers.emplace_back(l_observer);\n    return true;\n  }\n\n  bool RemoveObserver(Observer* l_observer){\n    auto observer = std::find_if(m_observers.begin(),\n      m_observers.end(), [&l_observer](Observer* o){\n        return o == l_observer; });\n    if (observer == m_observers.end()){ return false; }\n    m_observers.erase(observer);\n    return true;\n  }\n\n  bool HasObserver(const Observer* l_observer){\n    return (std::find_if(m_observers.begin(), m_observers.end(),\n      [&l_observer](Observer* o){\n        return o == l_observer;\n      }) != m_observers.end());\n  }\n\n  void Broadcast(const Message& l_msg){\n    for(auto& itr : m_observers){ itr->Notify(l_msg); }\n  }\n\nprivate:\n  ObserverContainer m_observers;\n};\n```", "```cpp\nclass S_Base : public Observer{ ... }\n```", "```cpp\nusing Subscribtions = std::unordered_map<\n  EntityMessage,Communicator>;\n```", "```cpp\nclass MessageHandler{\npublic:\n  bool Subscribe(const EntityMessage& l_type\n    Observer* l_observer)\n  {\n    return m_communicators[l_type].AddObserver(l_observer);\n  }\n\n  bool Unsubscribe(const EntityMessage& l_type,\n    Observer* l_observer)\n  {\n    return m_communicators[l_type].RemoveObserver(l_observer);\n  }\n\n  void Dispatch(const Message& l_msg){\n    auto itr = m_communicators.find(\n      (EntityMessage)l_msg.m_type);\n    if (itr == m_communicators.end()){ return; }\n    itr->second.Broadcast(l_msg);\n  }\nprivate:\n  Subscriptions m_communicators;\n};\n```", "```cpp\nenum class EntityMessage{ \n    Move, Is_Moving, State_Changed, Direction_Changed,\n    Switch_State, Attack_Action, Dead\n};\n```", "```cpp\nusing SystemContainer = std::unordered_map<System,S_Base*>;\nusing EntityEventContainer = std::unordered_map<\n  EntityId,EventQueue>;\n```", "```cpp\nclass EntityManager;\nclass SystemManager{\npublic:\n  SystemManager();\n  ~SystemManager();\n\n  void SetEntityManager(EntityManager* l_entityMgr);\n  EntityManager* GetEntityManager();\n  MessageHandler* GetMessageHandler();\n\n  template<class T>\n  T* GetSystem(const System& l_system){...}\n\n  void AddEvent(const EntityId& l_entity, const EventID& l_event);\n\n  void Update(float l_dT);\n  void HandleEvents();\n  void Draw(Window* l_wind, unsigned int l_elevation);\n\n  void EntityModified(const EntityId& l_entity,\n    const Bitmask& l_bits);\n  void RemoveEntity(const EntityId& l_entity);\n\n  void PurgeEntities();\n  void PurgeSystems();\nprivate:\n  SystemContainer m_systems;\n  EntityManager* m_entityManager;\n  EntityEventContainer m_events;\n  MessageHandler m_messages;\n};\n```", "```cpp\ntemplate<class T>\nT* GetSystem(const System& l_system){\n  auto itr = m_systems.find(l_system);\n  return(itr != m_systems.end() ?\n    dynamic_cast<T*>(itr->second) : nullptr);\n}\n```", "```cpp\n#include \"Entity_Manager.h\"\n```", "```cpp\nSystemManager::SystemManager(): m_entityManager(nullptr){\n  m_systems[System::State] = new S_State(this);\n  m_systems[System::Control] = new S_Control(this);\n  m_systems[System::Movement] = new S_Movement(this);\n  m_systems[System::Collision] = new S_Collision(this);\n  m_systems[System::SheetAnimation] = new S_SheetAnimation(this);\n  m_systems[System::Renderer] = new S_Renderer(this);\n}\n\nSystemManager::~SystemManager(){\n  PurgeSystems();\n}\n```", "```cpp\nvoid SystemManager::SetEntityManager(EntityManager* l_entityMgr){\n    if(!m_entityManager){ m_entityManager = l_entityMgr; }\n}\n```", "```cpp\nEntityManager* SystemManager::GetEntityManager(){\n    return m_entityManager;\n}\n\nMessageHandler* SystemManager::GetMessageHandler(){\n    return &m_messages;\n}\n```", "```cpp\nvoid SystemManager::AddEvent(const EntityId& l_entity, const EventID& l_event)\n{\n    m_events[l_entity].AddEvent(l_event);\n}\n```", "```cpp\nvoid SystemManager::Update(float l_dT){\n  for(auto &itr : m_systems){\n    itr.second->Update(l_dT);\n  }\n  HandleEvents();\n}\n```", "```cpp\nvoid SystemManager::HandleEvents(){\n  for(auto &event : m_events){\n    EventID id = 0;\n    while(event.second.ProcessEvents(id)){\n      for(auto &system : m_systems)\n      {\n        if(system.second->HasEntity(event.first)){\n          system.second->HandleEvent(event.first,(EntityEvent)id);\n        }\n      }\n    }\n  }\n}\n```", "```cpp\nvoid SystemManager::Draw(Window* l_wind,\n  unsigned int l_elevation)\n{\n  auto itr = m_systems.find(System::Renderer);\n  if (itr == m_systems.end()){ return; }\n  S_Renderer* system = (S_Renderer*)itr->second;\n  system->Render(l_wind, l_elevation);\n}\n```", "```cpp\nvoid SystemManager::EntityModified(const EntityId& l_entity,\n  const Bitmask& l_bits)\n{\n  for(auto &s_itr : m_systems){\n    S_Base* system = s_itr.second;\n    if(system->FitsRequirements(l_bits)){\n      if(!system->HasEntity(l_entity)){\n        system->AddEntity(l_entity);\n      }\n    } else {\n      if(system->HasEntity(l_entity)){\n        system->RemoveEntity(l_entity);\n      }\n    }\n  }\n}\n```", "```cpp\nvoid SystemManager::RemoveEntity(const EntityId& l_entity){\n  for(auto &system : m_systems){\n    system.second->RemoveEntity(l_entity);\n  }\n}\n```", "```cpp\nvoid SystemManager::PurgeEntities(){\n  for(auto &system : m_systems){\n    system.second->Purge();\n  }\n}\n```", "```cpp\nvoid SystemManager::PurgeSystems(){\n  for (auto &system : m_systems){\n    delete system.second;\n  }\n  m_systems.clear();\n}\n```", "```cpp\nclass C_Drawable : public C_Base{\npublic:\n  C_Drawable(const Component& l_type) : C_Base(l_type){}\n  virtual ~C_Drawable(){}\n\n  virtual void UpdatePosition(const sf::Vector2f& l_vec) = 0;\n  virtual const sf::Vector2u& GetSize() = 0;\n  virtual void Draw(sf::RenderWindow* l_wind) = 0;\nprivate:\n\n};\n```", "```cpp\nclass C_SpriteSheet : public C_Drawable{\npublic:\n    ...\nprivate:\n    SpriteSheet* m_spriteSheet;\n    std::string m_sheetName;\n};\n```", "```cpp\nC_SpriteSheet(): C_Drawable(Component::SpriteSheet),\n    m_spriteSheet(nullptr){}\n\n~C_SpriteSheet(){\n    if(m_spriteSheet){ delete m_spriteSheet; }\n}\n```", "```cpp\nvoid ReadIn(std::stringstream& l_stream){\n    l_stream >> m_sheetName;\n}\n```", "```cpp\nvoid Create(TextureManager* l_textureMgr, \n  const std::string& l_name = \"\")\n{\n  if (m_spriteSheet){ return; }\n  m_spriteSheet = new SpriteSheet(l_textureMgr);\n  m_spriteSheet->LoadSheet(\"media/Spritesheets/\" +\n    (l_name != \"\" ? l_name : m_sheetName) + \".sheet\");\n}\n```", "```cpp\nSpriteSheet* GetSpriteSheet(){ return m_spriteSheet; }\nvoid UpdatePosition(const sf::Vector2f& l_vec){\n  m_spriteSheet->SetSpritePosition(l_vec);\n}\n\nconst sf::Vector2u& GetSize(){ \n  return m_spriteSheet->GetSpriteSize();\n}\nvoid Draw(sf::RenderWindow* l_wind){\n  if (!m_spriteSheet){ return; }\n  m_spriteSheet->Draw(l_wind);\n}\n```", "```cpp\nclass S_Renderer : public S_Base{\npublic:\n  S_Renderer(SystemManager* l_systemMgr);\n  ~S_Renderer();\n\n  void Update(float l_dT);\n  void HandleEvent(const EntityId& l_entity,\n    const EntityEvent& l_event);\n  void Notify(const Message& l_message);\n  void Render(Window* l_wind, unsigned int l_layer);\nprivate:\n  void SetSheetDirection(const EntityId& l_entity,\n    const Direction& l_dir);\n  void SortDrawables();\n};\n```", "```cpp\nS_Renderer::S_Renderer(SystemManager* l_systemMgr)\n  :S_Base(System::Renderer, l_systemMgr)\n{\n  Bitmask req;\n  req.TurnOnBit((unsigned int)Component::Position);\n  req.TurnOnBit((unsigned int)Component::SpriteSheet);\n  m_requiredComponents.push_back(req);\n  req.Clear();\n\n  m_systemManager->GetMessageHandler()->\n    Subscribe(EntityMessage::Direction_Changed,this);\n}\nS_Renderer::~S_Renderer(){}\n```", "```cpp\nvoid S_Renderer::Update(float l_dT){\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  for(auto &entity : m_entities)\n  {\n    C_Position* position = entities->\n      GetComponent<C_Position>(entity, Component::Position);\n    C_Drawable* drawable = nullptr;\n    if (entities->HasComponent(entity, Component::SpriteSheet)){\n      drawable = entities->\n        GetComponent<C_Drawable>(entity, Component::SpriteSheet);\n    } else { continue; }\n    drawable->UpdatePosition(position->GetPosition());\n  }\n}\n```", "```cpp\nvoid S_Renderer::HandleEvent(const EntityId& l_entity,\n  const EntityEvent& l_event)\n{\n  if (l_event == EntityEvent::Moving_Left ||\n    l_event == EntityEvent::Moving_Right ||\n    l_event == EntityEvent::Moving_Up ||\n    l_event == EntityEvent::Moving_Down ||\n    l_event == EntityEvent::Elevation_Change ||\n    l_event == EntityEvent::Spawned)\n  {\n    SortDrawables();\n  }\n}\n```", "```cpp\nvoid S_Renderer::Notify(const Message& l_message){\n  if(HasEntity(l_message.m_receiver)){\n    EntityMessage m = (EntityMessage)l_message.m_type;\n    switch(m){\n    case EntityMessage::Direction_Changed: \n      SetSheetDirection(l_message.m_receiver,\n        (Direction)l_message.m_int);\n      break;\n    }\n  }\n}\n```", "```cpp\nvoid S_Renderer::Render(Window* l_wind, unsigned int l_layer)\n{\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  for(auto &entity : m_entities){\n    C_Position* position = entities->\n      GetComponent<C_Position>(entity, Component::Position);\n    if(position->GetElevation() < l_layer){ continue; }\n    if(position->GetElevation() > l_layer){ break; }\n    C_Drawable* drawable = nullptr;\n    if (!entities->HasComponent(entity,\n      Component::SpriteSheet))\n    {\n      continue;\n    }\n    drawable = entities->\n      GetComponent<C_Drawable>(entity, Component::SpriteSheet);\n    sf::FloatRect drawableBounds;\n    drawableBounds.left = position->GetPosition().x –\n      (drawable->GetSize().x / 2);\n    drawableBounds.top = position->GetPosition().y –\n      drawable->GetSize().y;\n    drawableBounds.width = drawable->GetSize().x;\n    drawableBounds.height = drawable->GetSize().y;\n    if (!l_wind->GetViewSpace().intersects(\n      drawableBounds))\n    {\n      continue;\n    }\n    drawable->Draw(l_wind->GetRenderWindow());\n  }\n}\n```", "```cpp\nvoid S_Renderer::SetSheetDirection(const EntityId& l_entity,\n  const Direction& l_dir)\n{\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  if (!entities->HasComponent(l_entity,\n    Component::SpriteSheet))\n  {\n    return;\n  }\n  C_SpriteSheet* sheet = entities->\n    GetComponent<C_SpriteSheet>(l_entity,Component::SpriteSheet);\n  sheet->GetSpriteSheet()->SetDirection(l_dir);\n}\n```", "```cpp\nvoid S_Renderer::SortDrawables(){\n  EntityManager* e_mgr = m_systemManager->GetEntityManager();\n  std::sort(m_entities.begin(), m_entities.end(),\n    [e_mgr](unsigned int l_1, unsigned int l_2)\n  {\n    auto pos1 = e_mgr->\n      GetComponent<C_Position>(l_1, Component::Position);\n    auto pos2 = e_mgr->\n      GetComponent<C_Position>(l_2, Component::Position);\n    if (pos1->GetElevation() == pos2->GetElevation()){\n      return pos1->GetPosition().y < pos2->GetPosition().y;\n    }\n    return pos1->GetElevation() < pos2->GetElevation();\n  });\n}\n```", "```cpp\nstruct SharedContext{\n    SharedContext():\n        ...\n        m_systemManager(nullptr),\n        m_entityManager(nullptr),\n        ...{}\n    ...\n    SystemManager* m_systemManager;\n    EntityManager* m_entityManager;\n    ...\n};\n```", "```cpp\nclass Game{\n...\nprivate:\n    ...\n    SystemManager m_systemManager;\n    EntityManager m_entityManager;\n    ...\n};\n```", "```cpp\nGame::Game(): m_window(\"Chapter 8\", sf::Vector2u(800,600)), \n  m_entityManager(&m_systemManager, &m_textureManager),\n  m_stateManager(&m_context)\n{\n  ...\n  m_systemManager.SetEntityManager(&m_entityManager);\n  m_context.m_systemManager = &m_systemManager;\n  m_context.m_entityManager = &m_entityManager;\n  ...\n}\n```", "```cpp\nclass State_Game : public BaseState{\npublic:\n    ...\n    void PlayerMove(EventDetails* l_details);\n    ...\nprivate:\n    ...\n    Void UpdateCamera();\n    int m_player;\n};\n```", "```cpp\nvoid State_Game::OnCreate(){\n  ...\n  evMgr->AddCallback(StateType::Game, \"Player_MoveLeft\",\n    &State_Game::PlayerMove, this);\n  evMgr->AddCallback(StateType::Game, \"Player_MoveRight\",\n    &State_Game::PlayerMove, this);\n  evMgr->AddCallback(StateType::Game, \"Player_MoveUp\",\n    &State_Game::PlayerMove, this);\n  evMgr->AddCallback(StateType::Game, \"Player_MoveDown\",\n    &State_Game::PlayerMove, this);\n  ...\n  m_player = m_gameMap->GetPlayerId();\n}\n```", "```cpp\nvoid State_Game::Update(const sf::Time& l_time){\n  SharedContext* context = m_stateMgr->GetContext();\n  UpdateCamera();\n  m_gameMap->Update(l_time.asSeconds());\n  context->m_systemManager->Update(l_time.asSeconds());\n}\n```", "```cpp\nvoid State_Game::UpdateCamera(){\n  if (m_player == -1){ return; }\n  SharedContext* context = m_stateMgr->GetContext();\n  C_Position* pos = m_stateMgr->GetContext()->m_entityManager->\n    GetComponent<C_Position>(m_player, Component::Position);\n\n  m_view.setCenter(pos->GetPosition());\n  context->m_wind->GetRenderWindow()->setView(m_view);\n\n  sf::FloatRect viewSpace = context->m_wind->GetViewSpace();\n  if (viewSpace.left <= 0){\n    m_view.setCenter(viewSpace.width / 2, m_view.getCenter().y);\n    context->m_wind->GetRenderWindow()->setView(m_view);\n  } else if (viewSpace.left + viewSpace.width >\n    (m_gameMap->GetMapSize().x) * Sheet::Tile_Size)\n  {\n    m_view.setCenter(\n      ((m_gameMap->GetMapSize().x) * Sheet::Tile_Size) -\n      (viewSpace.width / 2), m_view.getCenter().y);\n    context->m_wind->GetRenderWindow()->setView(m_view);\n  }\n\n  if (viewSpace.top <= 0){\n    m_view.setCenter(m_view.getCenter().x, viewSpace.height / 2);\n    context->m_wind->GetRenderWindow()->setView(m_view);\n  } else if (viewSpace.top + viewSpace.height >\n    (m_gameMap->GetMapSize().y) * Sheet::Tile_Size)\n  {\n    m_view.setCenter(m_view.getCenter().x,\n      ((m_gameMap->GetMapSize().y) * Sheet::Tile_Size) -\n      (viewSpace.height / 2));\n    context->m_wind->GetRenderWindow()->setView(m_view);\n  }\n}\n```", "```cpp\nvoid State_Game::Draw(){\n  for(unsigned int i = 0; i < Sheet::Num_Layers; ++i){\n    m_gameMap->Draw(i);\n    m_stateMgr->GetContext()->m_systemManager->Draw(\n      m_stateMgr->GetContext()->m_wind, i);\n  }\n}\n```", "```cpp\nvoid State_Game::PlayerMove(EventDetails* l_details){\n  Message msg((MessageType)EntityMessage::Move);\n  if (l_details->m_name == \"Player_MoveLeft\"){\n    msg.m_int = (int)Direction::Left;\n  } else if (l_details->m_name == \"Player_MoveRight\"){\n    msg.m_int = (int)Direction::Right;\n  } else if (l_details->m_name == \"Player_MoveUp\"){\n    msg.m_int = (int)Direction::Up;\n  } else if (l_details->m_name == \"Player_MoveDown\"){\n    msg.m_int = (int)Direction::Down;\n  }\n  msg.m_receiver = m_player;\n  m_stateMgr->GetContext()->m_systemManager->\n    GetMessageHandler()->Dispatch(msg);\n}\n```", "```cpp\nenum class Direction{ Up = 0, Left, Down, Right };\n```", "```cpp\nSIZE 32 32\nDEFAULT_FRICTION 1.0 1.0\n|ENTITY|Name|x|y|elevation|\nENTITY Player 256.0 256.0 1\n...\n|TILE|ID|x|y|layer|solid|\nTILE 3 0 0 0 0\n...\n```", "```cpp\nenum Sheet{\n  Tile_Size = 32, Sheet_Width = 256,\n  Sheet_Height = 256, Num_Layers = 4\n};\n```", "```cpp\nstruct Tile{\n    ...\n    bool m_solid; // Is the tile a solid.\n};\n```", "```cpp\nclass Map{\npublic:\n    ...\n    Tile* GetTile(unsigned int l_x, unsigned int l_y, unsigned int l_layer);\n    ...\n    void Draw(unsigned int l_layer);\nprivate:\n    unsigned int ConvertCoords(unsigned int l_x, unsigned int l_y,unsigned int l_layer)const;\n    ...\n    int m_playerId;\n    ...\n};\n```", "```cpp\nTile* Map::GetTile(unsigned int l_x, unsigned int l_y,\n  unsigned int l_layer)\n{\n  if(l_x < 0 || l_y < 0 || l_x >= m_maxMapSize.x ||\n    l_y >= m_maxMapSize.y || l_layer < 0 ||\n    l_layer >= Sheet::Num_Layers)\n  {\n    return nullptr;\n  }\n  auto itr = m_tileMap.find(ConvertCoords(l_x,l_y,l_layer));\n  if (itr == m_tileMap.end()){ return nullptr; }\n  return itr->second;\n}\n```", "```cpp\nunsigned int Map::ConvertCoords(unsigned int l_x,\n  unsigned int l_y, unsigned int l_layer)const\n{\n  return ((l_layer*m_maxMapSize.y+l_y) * m_maxMapSize.x + l_x);\n}\n```", "```cpp\nvoid Map::Draw(unsigned int l_layer){\n  if (l_layer >= Sheet::Num_Layers){ return; }\n  sf::RenderWindow* l_wind = m_context->m_wind->GetRenderWindow();\n  sf::FloatRect viewSpace = m_context->m_wind->GetViewSpace();\n\n  sf::Vector2i tileBegin(\n    floor(viewSpace.left / Sheet::Tile_Size),\n    floor(viewSpace.top / Sheet::Tile_Size));\n  sf::Vector2i tileEnd(\n    ceil((viewSpace.left + viewSpace.width) / Sheet::Tile_Size),\n    ceil((viewSpace.top + viewSpace.height) / Sheet::Tile_Size));\n\n  unsigned int count = 0;\n  for(int x = tileBegin.x; x <= tileEnd.x; ++x){\n    for(int y = tileBegin.y; y <= tileEnd.y; ++y){\n      Tile* tile = GetTile(x,y,l_layer);\n      if (!tile){ continue; }\n      sf::Sprite& sprite = tile->m_properties->m_sprite;\n      sprite.setPosition(x * Sheet::Tile_Size,\n        y * Sheet::Tile_Size);\n      l_wind->draw(sprite);\n      ++count;\n    }\n  }\n}\n```", "```cpp\nif(type == \"TILE\"){\n  ...\n  sf::Vector2i tileCoords;\n  unsigned int tileLayer = 0;\n  unsigned int tileSolidity = 0;\n  keystream >> tileCoords.x >> tileCoords.y >>\n    tileLayer >> tileSolidity;\n  if (tileCoords.x > m_maxMapSize.x ||\n    tileCoords.y > m_maxMapSize.y ||\n    tileLayer >= Sheet::Num_Layers)\n  {\n    std::cout << \"! Tile is out of range: \" <<\n      tileCoords.x << \" \" << tileCoords.y << std::endl;\n    continue;\n  }\n  Tile* tile = new Tile();\n  // Bind properties of a tile from a set.\n  tile->m_properties = itr->second;\n  tile->m_solid = (bool)tileSolidity;\n  if(!m_tileMap.emplace(ConvertCoords(\n    tileCoords.x,tileCoords.y,tileLayer),tile).second)\n  {\n    ...\n  }\n  ...\n} else if ...\n```", "```cpp\n} else if(type == \"ENTITY\"){\n  // Set up entity here.\n  std::string name;\n  keystream >> name;\n  if (name == \"Player\" && m_playerId != -1){ continue; }\n  int entityId = m_context->m_entityManager->AddEntity(name);\n  if (entityId < 0){ continue; }\n  if(name == \"Player\"){ m_playerId = entityId; }\n  C_Base* position = m_context->m_entityManager->\n    GetComponent<C_Position>(entityId,Component::Position);\n  if(position){ keystream >> *position; }\n} else ...\n```"]