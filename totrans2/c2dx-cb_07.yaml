- en: Chapter 7. Working with Resource Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 与资源文件一起工作
- en: 'Games have a lot of resources such as images and audio files. Cocos2d-x has
    a management system of resources. The following topics will be covered in this
    chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏有很多资源，如图片和音频文件。Cocos2d-x 有一个资源管理系统。本章将涵盖以下主题：
- en: Selecting resource files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择资源文件
- en: Managing resource files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理资源文件
- en: Using SQLite
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQLite
- en: Using .xml files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 .xml 文件
- en: Using .plist files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 .plist 文件
- en: Using .json files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 .json 文件
- en: Selecting resource files
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择资源文件
- en: Your game has images of each resolution for multiresolution adaption. If you
    have resolved to find an image for each resolution, your application logic is
    very complicated. Cocos2d-x has a search path mechanism for solving this problem.
    In this recipe, we will explain this search path mechanism.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你的游戏有每个分辨率的图片以支持多分辨率适配。如果你决定为每个分辨率找到一个图片，你的应用程序逻辑将非常复杂。Cocos2d-x 有一个搜索路径机制来解决这个问题。在这个菜谱中，我们将解释这个搜索路径机制。
- en: Getting ready
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you want to share some resources between different resolutions, then you
    can put all the shared resources in the `Resources` folder, and put the resolution-specified
    resources in different folders as shown in the following image.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在不同的分辨率之间共享一些资源，那么你可以将所有共享资源放在 `Resources` 文件夹中，并将指定分辨率的资源放在不同的文件夹中，如下面的图片所示。
- en: '![Getting ready](img/B00561_07_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/B00561_07_01.jpg)'
- en: '`CloseNormal.png` and `CloseSelected.png` are shared resources between different
    resolutions. However, `HelloWorld.png` is a resolution-specified resource.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`CloseNormal.png` 和 `CloseSelected.png` 是不同分辨率之间的共享资源。然而，`HelloWorld.png` 是指定分辨率的资源。'
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You can set the priority to search resources for Cocos2d-x as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式设置 Cocos2d-x 搜索资源的优先级：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Cocos2d-x will find `HelloWorld.png` in `Resources/ipad`. Cocos2d-x will use
    `HelloWorld.png` in this path; that's why it can find this resource in `Resources/ipad`.
    However, Cocos2d-x cannot find `CloseNormal.png` in `Resources/ipad`. It will
    find the `Resources` folder that is the next order path. The system can find it
    in the `Resources` folder and use it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x 将在 `Resources/ipad` 中找到 `HelloWorld.png`。Cocos2d-x 将使用此路径中的 `HelloWorld.png`；这就是为什么它可以在
    `Resources/ipad` 中找到这个资源。然而，Cocos2d-x 不能在 `Resources/ipad` 中找到 `CloseNormal.png`。它将找到下一个顺序路径的
    `Resources` 文件夹。系统可以在 `Resources` 文件夹中找到它并使用它。
- en: You should add this code in the `AppDelegate::applicationDidFinishLaunching`
    method before creating the first scene. Then, the first scene can use this search
    path setting.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在创建第一个场景之前，在 `AppDelegate::applicationDidFinishLaunching` 方法中添加此代码。然后，第一个场景就可以使用这个搜索路径设置了。
- en: See also
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The search path mechanism in the next recipe called *Managing resource files*.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个菜谱中称为 *管理资源文件* 的搜索路径机制。
- en: Managing resource files
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理资源文件
- en: Cocos2d-x has an extension that manages resources. It is called `AssetsManagerExtension`.
    This extension is designed for a hot update of resources such as images and audio
    files. You can update a new version of resources on your games by using this extension
    without updating your applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x 有一个管理资源的扩展，它被称为 `AssetsManagerExtension`。这个扩展是为了资源如图片和音频文件的热更新而设计的。你可以通过这个扩展更新游戏中的资源新版本，而无需更新你的应用程序。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before using `AssetsManagerExtension`, you should learn about it. This extension
    has many useful features to help you make the hot update. Some of these features
    are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `AssetsManagerExtension` 之前，你应该了解它。这个扩展有许多有用的功能来帮助你进行热更新。以下是一些这些功能：
- en: Multithread downloading support
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多线程下载
- en: Two-level progression support—File-level and byte-level progression
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两级进度支持——文件级和字节级进度
- en: Compressed ZIP file support
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持压缩的 ZIP 文件
- en: Resuming download
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复下载
- en: Detailed progression information and error information
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细进度信息和错误信息
- en: Possibility to retry failed assets
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试失败资源的可能性
- en: You have to prepare a web server, and hence, your application will download
    resources.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须准备一个网络服务器，因此，你的应用程序将下载资源。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: You need to upload resources and manifest files. In this case, we will update
    `HelloWorld.png` and a `.zip` file called `test.zip`. This `.zip` file includes
    some new images. `AssetsManagerExtension` will download resources according to
    the manifest files. The manifest files are `version.manifest` and `project.manifest`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要上传资源和清单文件。在这种情况下，我们将更新 `HelloWorld.png` 和一个名为 `test.zip` 的 `.zip` 文件。这个 `.zip`
    文件包含一些新的图片。`AssetsManagerExtension` 将根据清单文件下载资源。清单文件是 `version.manifest` 和 `project.manifest`。
- en: 'The `version.manifest` file contains the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`version.manifest` 文件包含以下代码：'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `project.manifest` file contains the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.manifest` 文件包含以下代码：'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, you have to upload these manifest files and new resources.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须上传这些清单文件和新资源。
- en: 'Next, you have to prepare your application for a hot update. You have to create
    the `local.manifest` file in your project. The local manifest file should contain
    the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你必须为热更新准备你的应用程序。你必须在你的项目中创建 `local.manifest` 文件。本地清单文件应包含以下代码：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should make a class that manages `AssetsManagerExtension` in your project.
    Here, we create a class called `ResourceManager`. Firstly, you will create a header
    file of `ResourceManager`. It is called `ResourceManager.h`. This file contains
    the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在项目中创建一个管理 `AssetsManagerExtension` 的类。在这里，我们创建了一个名为 `ResourceManager` 的类。首先，你将创建
    `ResourceManager` 的头文件。它被称为 `ResourceManager.h`。此文件包含以下代码：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next step is to create a `ResourceManager.cpp` file. This file contains
    the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个 `ResourceManager.cpp` 文件。此文件包含以下代码：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, to start updating the resource, use the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要开始更新资源，请使用以下代码：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Firstly, we will explain the manifest file and the mechanism of `AssetsManagerExtension`.
    The manifest files are in the JSON format. Local manifest and version manifest
    have the following data:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将解释清单文件和 `AssetsManagerExtension` 的机制。清单文件是 JSON 格式。本地清单和版本清单包含以下数据：
- en: '| Keys | Description |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 键 | 描述 |'
- en: '| --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `packageUrl` | The URL where the assets manager will try to request and download
    all the assets. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `packageUrl` | 资源管理器将尝试请求和下载所有资产的 URL。 |'
- en: '| `remoteVersionUrl` | The remote version manifest file URL that permits one
    to check the remote version to determine whether a new version has been uploaded
    to the server. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `remoteVersionUrl` | 允许检查远程版本的远程版本清单文件 URL，以确定是否已将新版本上传到服务器。 |'
- en: '| `remoteManifestUrl` | The remote manifest file URL that contains all the
    asset information. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `remoteManifestUrl` | 包含所有资产信息的远程清单文件 URL。 |'
- en: '| `version` | The version of this manifest file. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `version` | 此清单文件的版本。 |'
- en: In addition, the remote manifest has the following data in the key called assets.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，远程清单中在名为 assets 的键中还有以下数据。
- en: '| Keys | Description |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 键 | 描述 |'
- en: '| --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `key` | Each key represents the relative path of the asset. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `key` | 每个键代表资产的相对路径。 |'
- en: '| `Md5` | The `md5` field represents the version information of the asset.
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `Md5` | `md5` 字段表示资产的版本信息。 |'
- en: '| `compressed` | When the compressed field is `true`, the downloaded file will
    be decompressed automatically; this key is optional. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `compressed` | 当压缩字段为 `true` 时，下载的文件将自动解压；此键是可选的。 |'
- en: '`AssetsManagerExtension` will execute the hot update in the following steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssetsManagerExtension` 将按照以下步骤执行热更新：'
- en: Read the local manifest in the application.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中读取本地清单。
- en: Download the version manifest according to the remote version URL in the local
    manifest.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据本地清单中的远程版本 URL 下载版本清单。
- en: Compare the version in the local manifest to the version in the version manifest.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本地清单中的版本与版本清单中的版本进行比较。
- en: If both versions do not match, `AssetsManagerExtension` downloads the project
    manifest according to the remote manifest URL in the local manifest.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个版本不匹配，`AssetsManagerExtension` 将根据本地清单中的远程清单 URL 下载项目清单。
- en: Compare the `md5` value in the remote manifest to the `md5` of the asset in
    the application.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将远程清单中的 `md5` 值与应用程序中资产的 `md5` 进行比较。
- en: If both `md5` values do not match, `AssetsManagerExtension` downloads this asset.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个 `md5` 值不匹配，`AssetsManagerExtension` 将下载此资产。
- en: Next time, `AssetsManagerExtension` will use the version manifest that was downloaded
    instead of the local manifest.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下次，`AssetsManagerExtension` 将使用下载的版本清单而不是本地清单。
- en: 'Next, we will explain the `ResourceManager` class. You can execute the hot
    update as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将解释 `ResourceManager` 类。你可以按照以下方式执行热更新：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should call the `ResourceManager::updateAssets` method by specifying the
    path of the local manifest. `ResourceManager::updateAssets` will create an instance
    of `AssetsManagerEx`, which is the class name of `AssetsManagerExtension`, by
    specifying the path of the local manifest and the path of the storage in the application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该通过指定本地清单的路径来调用 `ResourceManager::updateAssets` 方法。`ResourceManager::updateAssets`
    将通过指定本地清单的路径和应用程序中存储的路径来创建一个 `AssetsManagerEx` 的实例，这是 `AssetsManagerExtension`
    类的名称。
- en: It will create an instance of `EventListenerAssetsManagerEx` for listening to
    the progress of the hot update.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它将创建一个 `EventListenerAssetsManagerEx` 的实例以监听热更新的进度。
- en: If the compressed value is true, `AssetsManagerExtension` will unzip it after
    downloading it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果压缩值为真，`AssetsManagerExtension` 将在下载后解压它。
- en: 'You can update assets by calling the `AssetsManagerEx::update` method. During
    the update, you can get the following events:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用 `AssetsManagerEx::update` 方法来更新资产。在更新过程中，您可以获取以下事件：
- en: '| Event | Description |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ERROR_NO_LOCAL_MANIFEST` | Cannot find the local manifest. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `ERROR_NO_LOCAL_MANIFEST` | 无法找到本地清单。 |'
- en: '| `UPDATE_PROGRESSION` | Get the progression of the update. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `UPDATE_PROGRESSION` | 获取更新的进度。 |'
- en: '| `ERROR_DOWNLOAD_MANIFEST` | Fail to download the manifest file. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `ERROR_DOWNLOAD_MANIFEST` | 下载清单文件失败。 |'
- en: '| `ERROR_PARSE_MANIFEST` | Parse error for the manifest file. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `ERROR_PARSE_MANIFEST` | 解析清单文件时出错。 |'
- en: '| `ALREADY_UP_TO_DATE` | Already updating assets (The version in the local
    manifest and the version in the version manifest are equal.). |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `ALREADY_UP_TO_DATE` | 已在更新资产（本地清单中的版本和版本清单中的版本相等）。 |'
- en: '| `UPDATE_FINISHED` | Finished updating assets. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `UPDATE_FINISHED` | 资产更新完成。 |'
- en: '| `UPDATE_FAILED` | Error occurred during updating assets. In this case, the
    cause of error may be the connection. You should try to update again. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `UPDATE_FAILED` | 更新资产时发生错误。在这种情况下，错误的原因可能是连接。您应该尝试再次更新。 |'
- en: '| `ERROR_UPDATING` | Failed to update. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `ERROR_UPDATING` | 更新失败。 |'
- en: '| `ERROR_DECOMPRESS` | Error occurred during unzipping. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `ERROR_DECOMPRESS` | 解压时发生错误。 |'
- en: '`ResourceManager` dispatches the event called `EVENT_PROGRESS` if it catches
    the event called `UPDATE_PROGRESSION`. If you catch `EVENT_PROGRESS`, you should
    update the progress label.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `ResourceManager` 捕获到名为 `UPDATE_PROGRESSION` 的事件时，它会分发名为 `EVENT_PROGRESS`
    的事件。如果您捕获到 `EVENT_PROGRESS`，您应该更新进度标签。
- en: Further, it dispatches the event called `EVENT_FINISHED` if it catches the event
    called `UPDATE_FINISHED`. If you catch `EVENT_FINISHED`, you should refresh all
    textures. That's why we remove all texture caches and reload the scene.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果它捕获到名为 `UPDATE_FINISHED` 的事件，它还会分发名为 `EVENT_FINISHED` 的事件。如果您捕获到 `EVENT_FINISHED`，您应该刷新所有纹理。这就是为什么我们要移除所有纹理缓存并重新加载场景。
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using SQLite
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SQLite
- en: You can save and load game data easily by using the database in your game. In
    a smartphone application, the database called SQLite is usually used. SQLite is
    easy to use. However, you have to set a few things before using it. In this recipe,
    we will explain how to set up and use SQLite in Cocos2d-x.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用游戏中的数据库轻松地保存和加载游戏数据。在智能手机应用程序中，通常使用名为SQLite的数据库。SQLite易于使用。然而，在使用它之前，您必须设置一些事情。在本菜谱中，我们将解释如何在Cocos2d-x中设置和使用SQLite。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Cocos2d-x doesn't have an SQLite library. You have to add SQLite's source code
    to Cocos2d-x.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x 没有SQLite库。您必须将SQLite的源代码添加到Cocos2d-x中。
- en: 'You need to download the source code from the site [http://sqlite.org/download.html](http://sqlite.org/download.html).
    The latest version at the time of writing this book is version 3.8.10\. You can
    download this version''s `.zip` file and expand it. Then, you can add the resulting
    files to your project as shown in the following image:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从网站 [http://sqlite.org/download.html](http://sqlite.org/download.html) 下载源代码。本书撰写时的最新版本是版本3.8.10。您可以下载此版本的
    `.zip` 文件并将其展开。然后，您可以将生成的文件添加到您的项目中，如下面的图像所示：
- en: '![Getting ready](img/B00561_07_02.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/B00561_07_02.jpg)'
- en: In this recipe, we will create an original class called `SQLiteManager`. So,
    you have to add the `SQLiteManager.h` and `SQLiteManager.cpp` files to your project.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将创建一个名为 `SQLiteManager` 的原始类。因此，您必须将 `SQLiteManager.h` 和 `SQLiteManager.cpp`
    文件添加到您的项目中。
- en: 'Then, if you build for Android, you have to edit `proj.android/jni/Android.mk`
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您为Android构建，您必须按照以下方式编辑 `proj.android/jni/Android.mk`：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, you have to edit the `SQLiteManager.h` file as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须按照以下方式编辑 `SQLiteManager.h` 文件：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, you have to edit the `SQLiteManager.cpp` file. This code is a little long.
    So, we will explain it step by step.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你必须编辑`SQLiteManager.cpp`文件。这段代码有点长。所以，我们将一步一步地解释它。
- en: 'Add the following code for the singleton class:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为单例类添加以下代码：
- en: '[PRE11]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the method that opens and closes the database:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加打开和关闭数据库的方法：
- en: '[PRE12]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the method that inserts data to the database:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加向数据库插入数据的方法：
- en: '[PRE13]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the method that selects data from the database:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加从数据库选择数据的方法：
- en: '[PRE14]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, here''s how to use this class. To insert data, use the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这是如何使用这个类的方法。要插入数据，请使用以下代码：
- en: '[PRE15]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To select data, use the following code:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要选择数据，请使用以下代码：
- en: '[PRE16]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Firstly, in the constructor method of the `SQLiteManager` class, this class
    creates a table called data if it does not already exist. The data table is created
    in SQL as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`SQLiteManager`类的构造方法中，如果该类不存在，则创建一个名为data的表。数据表按以下SQL创建：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In order to use SQLite, you have to include `sqlite3.h` and use the sqlite3
    API. This API is in the C language. If you would like to learn it, you should
    check the website [http://sqlite.org/cintro.html](http://sqlite.org/cintro.html).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用SQLite，你必须包含`sqlite3.h`并使用sqlite3 API。这个API是用C语言编写的。如果你想学习它，你应该查看网站[http://sqlite.org/cintro.html](http://sqlite.org/cintro.html)。
- en: We created our database called `test.sqlite` in the sandbox area of the application.
    If you want to change the location or the name, you should edit the `open` method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序的沙盒区域创建了名为`test.sqlite`的数据库。如果你想更改位置或名称，你应该编辑`open`方法。
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can insert data by using the `insert` method to specify the key and the
    value.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`insert`方法指定键和值来插入数据。
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Further, you can select the value by using the `select` method to specify the
    key.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以通过使用`select`方法指定键来选择值。
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There's more...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we created the `insert` method and the `select` method. However,
    you can execute other SQL methods such as `delete` and `replace`. Further, you
    can make the database match your game. So, you will need to edit this class for
    your game.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们创建了`insert`方法和`select`方法。然而，你也可以执行其他SQL方法，如`delete`和`replace`。此外，你可以使数据库与你的游戏匹配。因此，你可能需要为此类编辑代码。
- en: Using .xml files
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.xml文件
- en: XML is often used as an API's return value. Cocos2d-x has the TinyXML2 library
    that can parse an XML file. In this recipe, we will explain how to parse XML files
    by using this library.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: XML通常用作API的返回值。Cocos2d-x拥有TinyXML2库，可以解析XML文件。在本教程中，我们将解释如何使用这个库来解析XML文件。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Firstly, you need to create an XML file and save it as `test.xml` in the `Resources/res`
    folder in your project. In this case, we will use the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个XML文件，并将其保存为`test.xml`，位于项目中的`Resources/res`文件夹。在这种情况下，我们将使用以下代码：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To use the TinyXML-2 library, you have to include it and use namespace as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用TinyXML-2库，你必须包含它并使用命名空间如下：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: You can parse an XML file by using the TinyXML2 library. In the following code,
    we parse `test.xml` and log each element in it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用TinyXML2库来解析XML文件。在以下代码中，我们解析`test.xml`并记录其中的每个元素。
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This result is the following log:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果是以下日志：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First, you will have to create an instance of `XMLDocument` and then, parse
    the `.xml` file by using the `XMLDocument::LoadFile` method. To get the root element,
    you will have to use the `XMLDocument::RootElement` method. Basically, you can
    get the element by using the `FirstChildElement` method. If it is a continuous
    element, you can get the next element by using the `NextSiblingElement` method.
    If there are no more elements, the return value of `NextSiblingElement` will be
    null.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须创建`XMLDocument`的一个实例，然后使用`XMLDocument::LoadFile`方法解析`.xml`文件。要获取根元素，你必须使用`XMLDocument::RootElement`方法。基本上，你可以使用`FirstChildElement`方法获取元素。如果它是连续的元素，你可以使用`NextSiblingElement`方法获取下一个元素。如果没有更多元素，`NextSiblingElement`的返回值将是null。
- en: Finally, you shouldn't forget to delete the instance of `XMLDocment`. That's
    why you created it using a new operation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你不应该忘记删除`XMLDocument`的实例。这就是为什么你使用new操作创建它的原因。
- en: Using .plist files
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.plist文件
- en: PLIST used in OS X and iOS is a property list. The file extension is `.plist`,
    but in fact, the PLIST format is an XML format. We often use `.plist` files to
    store game settings and so on. Cocos2d-x has a class through which you can easily
    use `.plist` files.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在OS X和iOS中使用的PLIST是一个属性列表。文件扩展名是`.plist`，但实际上，PLIST格式是一个XML格式。我们经常使用`.plist`文件来存储游戏设置等。Cocos2d-x有一个类，通过它可以轻松地使用`.plist`文件。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Firstly, you need to create a `.plist` file and save it as `test.plist` to
    the `Resources/res` folder in your project. In this case, it has two keys, namely
    `foo` and `bar`. The `foo` key has an integer value of `1`. The `bar` key has
    a string value of `This is string`. Refer to the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要创建一个`.plist`文件，并将其保存为`test.plist`到您项目中的`Resources/res`文件夹。在这种情况下，它有两个键，即`foo`和`bar`。`foo`键有一个整数值`1`。`bar`键有一个字符串值`This
    is string`。请参考以下代码：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: You can parse a `.plist` file by using the `FileUtils::getValueMapFromFile`
    method. In the following code, we parse `test.plist` and log a key value in it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`FileUtils::getValueMapFromFile`方法来解析`.plist`文件。在以下代码中，我们解析`test.plist`并记录其中的键值。
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can parse a `.plist` file by specifying the `.plist` file's path to the
    `FileUtils::getValueMapFromFile` method. After doing so, you get the data from
    the `.plist` file as a `ValueMap` value. The `ValueMap` class is a wrapper class-based
    `std::unordered_map`. PLIST's data containers are `Array` and `Dictionary`. After
    parsing the `.plist` file, `Array` is `std::vector<Value>` and `Dictionary` is
    `std::unordered_map<std::string, Value>`. Further, you can distinguish the type
    of value by using the `Value::getType` method. Then, you can get the value by
    using the `Value::asInt`, `asFloat`, `asDouble`, `asBool`, and `asString` methods.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将`.plist`文件的路径指定给`FileUtils::getValueMapFromFile`方法来解析`.plist`文件。这样做之后，您将得到`.plist`文件中的数据作为`ValueMap`值。`ValueMap`类是一个基于`std::unordered_map`的包装类。PLIST的数据容器是`Array`和`Dictionary`。解析`.plist`文件后，`Array`是`std::vector<Value>`，而`Dictionary`是`std::unordered_map<std::string,
    Value>`。此外，您可以使用`Value::getType`方法来区分值的类型。然后，您可以使用`Value::asInt`、`asFloat`、`asDouble`、`asBool`和`asString`方法来获取值。
- en: There's more...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'You can save the `.plist` file from `ValueMap`. By doing so, you can save your
    game data in the `.plist` file. To save the `.plist` file, use the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`ValueMap`保存`.plist`文件。这样做，您可以将游戏数据保存到`.plist`文件中。要保存`.plist`文件，请使用以下代码：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, you need to set the key value in `ValueMap`. In this case, the values
    are all of the integer type, but you can set mixed-type values as well. Finally,
    you need to save the file as a `.plist` file by using the `FileUtils::writeToFile`
    method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在`ValueMap`中设置键值。在这种情况下，值都是整数类型，但您也可以设置混合类型的值。最后，您需要使用`FileUtils::writeToFile`方法将文件保存为`.plist`文件。
- en: Using .json files
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.json文件
- en: We can use the JSON format like the XML format for saving/loading game-related
    data. JSON is a simpler format than XML. It takes less space to represent the
    same data than the XML file format. Further, today, it is used as the value of
    Web API. Cocos2d-x has a JSON parse library called **RapidJSON**. In this recipe,
    we will explain how to use RapidJSON.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将JSON格式像XML格式一样用于保存/加载游戏相关数据。JSON比XML格式简单。它比XML文件格式表示相同数据所需的空间更少。此外，今天，它被用作Web
    API的值。Cocos2d-x有一个名为**RapidJSON**的JSON解析库。在这个菜谱中，我们将解释如何使用RapidJSON。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'RapidJSON is usually included in Cocos2d-x. However, you need to include the
    header files as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: RapidJSON通常包含在Cocos2d-x中。然而，您需要按照以下方式包含头文件：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Firstly, we will parse a JSON string as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将按照以下方式解析一个JSON字符串：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can parse JSON by using `rapidjson::Document` as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`rapidjson::Document`来解析JSON，如下所示：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can parse JSON by using the `Document::Parse` method and specifying the
    JSON string. You may get a parse error when you use the `Document::HasParseError`
    method; you can get a description of this error by using the `Document::GetParseError`
    method for a string. Further, you can get an element by specifying the hash key
    and using the `Document::GetString` method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`Document::Parse`方法并指定JSON字符串来解析JSON。当您使用`Document::HasParseError`方法时可能会得到解析错误；您可以通过使用`Document::GetParseError`方法来获取这个错误的描述。此外，您可以通过指定哈希键并使用`Document::GetString`方法来获取一个元素。
- en: There's more...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'In a real application, you can get a JSON string from a file. We will now explain
    how to get this string from a file. First, you need to add a file called `test.json`
    to the `Resources/res` folder in your project and save it as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，你可以从一个文件中获取一个 JSON 字符串。现在我们将解释如何从文件中获取这个字符串。首先，你需要在项目的 `Resources/res`
    文件夹中添加一个名为 `test.json` 的文件，并按照以下方式保存：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, you can get a JSON string from a file as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以按照以下方式从一个文件中获取一个 JSON 字符串：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can get the string from the file by using the `FileUtils::getStringFromFile`
    method. Thereafter, you can parse in the same way. In addition, this JSON string
    may be an array. You can check whether the format is an array by using the `Document::IsArray`
    method. Then, you can use a for loop to go through the JSON object in the array.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `FileUtils::getStringFromFile` 方法从文件中获取字符串。之后，你可以以相同的方式解析。此外，这个 JSON
    字符串可能是一个数组。你可以使用 `Document::IsArray` 方法检查格式是否为数组。然后，你可以使用 for 循环遍历数组中的 JSON 对象。
