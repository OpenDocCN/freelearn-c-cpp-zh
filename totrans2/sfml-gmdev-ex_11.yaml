- en: Chapter 11. Don't Touch the Red Button! – Implementing the GUI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。别碰那个红按钮！ – 实现GUI
- en: We covered the fundamentals and created the building blocks necessary for graphical
    user interface assembly in the course of the last chapter. Although that might
    seem like lots of code, a lot more goes into making it tick. Proper management
    of interfaces, good support from the rest of the code base, and user-friendly
    semantics of the GUI system itself are all paramount. Let's finish our goal set
    in [Chapter 10](ch10.html "Chapter 10. Can I Click This? – GUI Fundamentals"),
    *Can I Click This? – GUI Fundamentals*, and finally provide our users with a means
    of interfacing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了基础知识并创建了图形用户界面组装所需的构建块。尽管这可能看起来代码很多，但要让其运行还需要更多的工作。正确管理接口、代码库的其他部分的良好支持以及GUI系统本身的用户友好语义都是至关重要的。让我们完成在[第10章](ch10.html
    "第10章。我能点击这个吗？ – GUI基础知识")中设定的目标，*我能点击这个吗？ – GUI基础知识*，并最终为用户提供一种接口方式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Management of interfaces and their events
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口及其事件的管理
- en: Expansion of the event manager class for additional GUI support
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展事件管理类以支持额外的GUI功能
- en: Creation of our first element type
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个元素类型
- en: Integration and use of our GUI system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们GUI系统的集成和使用
- en: With all the pieces in place, let's bring our interfaces to life!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有部件就位后，让我们让我们的接口活跃起来！
- en: The GUI manager
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI管理器
- en: 'The puppet master in the background, in charge of the entire show in this case,
    has to be the `GUI_Manager` class. It is responsible for storing all the interfaces
    in the application as well as maintaining their states. All mouse input processing
    originates from this class and is passed down the ownership tree. Let''s begin
    by getting some type definitions out of the way:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后负责整个表演的“木偶大师”，在这种情况下，必须是`GUI_Manager`类。它负责存储应用程序中的所有接口以及维护它们的状态。所有鼠标输入处理都源自这个类，并传递到所有权树中。让我们先解决一些类型定义问题：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will use the `std::unordered_map` data structure that indexes them by name
    to store the interface data. The interface data containers also need to be grouped
    by game states, which is what the next type definition is for. Similarly, GUI
    events need to be indexed by their relevant game state. The events themselves
    are stored in a `std::vector`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`std::unordered_map`数据结构，通过名称索引它们来存储接口数据。接口数据容器还需要按游戏状态分组，这正是下一个类型定义的目的。同样，GUI事件需要根据相关的游戏状态进行索引。事件本身存储在`std::vector`中。
- en: Additionally, since we will be creating elements in a factory-like fashion,
    much like we did before, a factory type definition is created. The main difference
    here is that the `lambda` functions we'll be storing need to take in a pointer
    to the owner interface in order to be constructed correctly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们将以类似之前的方式以工厂模式创建元素，因此创建了一个工厂类型定义。这里的主要区别在于我们将存储的`lambda`函数需要接收一个指向所有者接口的指针，以便正确构造。
- en: Lastly, we're going to be mapping element type strings to actual enumeration
    values for the same. Once again, the `std::unordered_map` type comes to the rescue.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将映射元素类型字符串到实际的枚举值。再次，`std::unordered_map`类型再次发挥作用。
- en: 'Now, here is the class definition itself:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里是类定义本身：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Right off the bat, we can tell that the factory method for elements is going
    to be used due to the presence of a `RegisterElement` method. It stores a `lambda`
    function with an owner interface pointer as its sole argument, which returns a
    `GUI_Element` type with a blank name, constructed from a given type denoted by
    the `l_id` argument. Its private method friend, `CreateElement`, will use the
    stored `lambda` functions and return pointers to newly created memory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们可以看出元素将使用工厂方法，因为存在`RegisterElement`方法。它存储一个以所有者接口指针作为唯一参数的`lambda`函数，该函数返回一个带有空白名称的`GUI_Element`类型，由`l_id`参数指定的给定类型构造而成。它的私有方法友元`CreateElement`将使用存储的`lambda`函数并返回指向新创建内存的指针。
- en: One last thing to note before diving into the implementation of this class is
    the existence of a `LoadStyle` method that takes in a `GUI_Element` type. The
    manager class is responsible for de-serializing style files and properly setting
    up elements based on them to avoid cluttering up the element and interface classes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实现这个类之前，还有一个需要注意的事情，那就是存在一个接受`GUI_Element`类型的`LoadStyle`方法。管理类负责反序列化样式文件并根据它们正确设置元素，以避免在元素和接口类中造成混乱。
- en: Implementing the GUI manager
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现GUI管理器
- en: 'With the class header out of the way, we can dive right into implementing our
    GUI manager. The constructor of the `GUI_Manager` class is defined like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完类头文件之后，我们可以直接进入实现我们的GUI管理器。`GUI_Manager`类的构造函数定义如下：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It requires a pointer to the event manager and shared context structures as
    arguments and sets them up through the initializer list, along with a default
    value for the current state. Inside the body, we can see that this class first
    registers three element types that we''re going to be working with. It also populates
    the element type map, which will be used for checks further down the line. Finally,
    it registers three callbacks: two for the left mouse button being pressed and
    released and one for text being entered. Note that these callbacks are registered
    to be called regardless of the state the application is in.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要一个指向事件管理器的指针和共享上下文结构作为参数，并通过初始化列表设置它们，同时为当前状态设置一个默认值。在函数体内部，我们可以看到这个类首先注册了我们将要使用的三个元素类型。它还填充了元素类型映射，这将用于后续的检查。最后，它注册了三个回调：两个用于左鼠标按钮的按下和释放，一个用于文本输入。请注意，这些回调被注册为无论应用程序处于何种状态都会被调用。
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The destructor removes all of the callbacks registered in the constructor and
    iterates over every single interface for proper de-allocation of dynamically allocated
    memory. The interface and event containers are then cleared.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数移除了在构造函数中注册的所有回调，并对每个界面进行迭代以正确释放动态分配的内存。然后清除界面和事件容器。
- en: 'Let''s take a look at how an interface is added to the GUI manager:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将一个界面添加到GUI管理器中：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Dynamic memory for an interface is allocated and an attempt to insert it is
    made when a valid application state and an unused interface name is provided.
    Any issues when inserting are caught by the return value of the `emplace` method,
    which gets stored in the `i` variable. If it fails, the memory is de-allocated
    and `false` is returned to signify failure. Otherwise, `true` is returned.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供有效的应用程序状态和未使用的界面名称时，为界面分配动态内存并尝试插入。在插入过程中遇到任何问题都会被`emplace`方法的返回值捕获，该值存储在`i`变量中。如果失败，将释放内存并返回`false`以表示失败。否则，返回`true`。
- en: 'Obtaining an interface is as simple as it gets:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个界面就像这样简单：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If a state provided as an argument is found, and an interface with the name
    provided is also located, it gets returned. Failure to find either a valid state
    or the correct interface is represented by a return value of `nullptr`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到作为参数提供的状态，并且还找到了提供的名称的界面，则返回它。找不到有效状态或正确界面的情况由返回值`nullptr`表示。
- en: 'Removing an interface is achieved by manipulating the container structure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过操作容器结构来移除界面：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `delete` keyword appears if both the state and the interface are
    found. Sometimes, it's very easy to forget the de-allocation of no longer used
    memory on the heap, which results in memory leaks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果找到状态和界面，`delete`关键字就会出现。有时，很容易忘记在堆上释放不再使用的内存，这会导致内存泄漏。
- en: 'Since the GUI manager needs to keep track of the current application state,
    the following method is necessary:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GUI管理器需要跟踪当前应用程序状态，因此需要以下方法：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In addition to changing the current state data member, it also invokes the `HandleRelease`
    method to prevent sticky interface and element states. If an element is clicked
    and the state suddenly changes, that same element will remain in the `CLICKED`
    state until it is hovered over unless `HandleRelease` is called.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改当前状态的数据成员外，它还调用了`HandleRelease`方法，以防止界面和元素状态粘滞。如果一个元素被点击并且状态突然改变，该元素将保持在`CLICKED`状态，直到它被悬停，除非调用`HandleRelease`。
- en: 'Now, let''s handle the mouse input to provide interaction with our interfaces:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理鼠标输入以提供与我们的界面交互：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method, just like its `HandleRelease` brother, takes in a single argument
    of the type `EventDetails`. For now, simply ignore that as it does not affect
    `GUI_Manager` at all and will be dealt later in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法，就像它的`HandleRelease`兄弟方法一样，只接受一个类型为`EventDetails`的参数。目前，只需忽略它，因为它对`GUI_Manager`没有任何影响，将在本章的后面处理。
- en: Firstly, it obtains the current mouse position relative to the window. Next,
    an iterator to the interface container is obtained and checked for validity. Every
    interface that belongs to the current state is then iterated over in reverse order,
    which gives newly added interfaces priority. If it is active and the mouse position
    falls within its boundaries, its `OnClick` method is invoked, with the mouse position
    passed in as the argument. The interface's `m_beingMoved` flag is then checked
    because the click might've been within the boundaries of its title bar. If so,
    the `BeginMoving` method is called to complete the drag operation. At this point,
    we simply return from the method in order to prevent a left click from affecting
    more than one interface at a time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它获取相对于窗口的当前鼠标位置。接下来，获取接口容器的迭代器并检查其有效性。然后，以相反的顺序遍历属于当前状态的每个接口，这给新添加的接口提供了优先权。如果它处于活动状态，并且鼠标位置在其边界内，则调用其`OnClick`方法，并将鼠标位置作为参数传递。然后检查接口的`m_beingMoved`标志，因为点击可能发生在其标题栏的边界内。如果是这样，则调用`BeginMoving`方法来完成拖动操作。在这个点上，我们简单地从方法中返回，以防止一次点击影响多个接口。
- en: 'Handling the left mouse button release follows the same convention:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 处理左鼠标按钮释放遵循相同的约定：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The only difference here is that every interface which is in a `Clicked` state
    has its `OnRelease` method called, as well as the `StopMoving` method if it is
    in a state of being dragged.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不同之处在于，每个处于`Clicked`状态的接口都会调用其`OnRelease`方法，如果它处于被拖动的状态，还会调用`StopMoving`方法。
- en: 'Lastly, let''s not forget about our text field elements as they need to be
    notified whenever some text is entered:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，别忘了我们的文本字段元素，因为它们需要在输入文本时得到通知：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a quite simple snippet of code. Whenever text is entered, we attempt
    to find an active and focused element. Once we find one, its `OnTextEntered` method
    is invoked with the text information passed in as the argument.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段相当简单的代码片段。每当输入文本时，我们尝试找到一个活动且聚焦的元素。一旦找到，就调用其`OnTextEntered`方法，并将文本信息作为参数传递。
- en: 'Adding GUI events is as simple as pushing them back onto a `std::vector` data
    structure:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 添加GUI事件就像将它们推回到`std::vector`数据结构中一样简单：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order to properly handle these events, we must have a way to obtain them:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确处理这些事件，我们必须有一种方法来获取它们：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is similar to the way SFML handles events, in that it takes in a reference
    to a `GUI_Event` data type and overwrites it with the last event in the event
    vector, right before popping it. It also returns a Boolean value to provide an
    easy way for it to be used in a `while` loop.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这与SFML处理事件的方式类似，因为它接收一个`GUI_Event`数据类型的引用，并在弹出之前用事件向量中的最后一个事件覆盖它。它还返回一个布尔值，以便在`while`循环中方便地使用。
- en: 'Next, let''s work on updating the interfaces:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来更新接口：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After the current mouse position is obtained, every interface that belongs to
    the current application state is iterated over. If the interface is currently
    active, it gets updated. The `Hover` and `Leave` events are only considered if
    the interface in question is not currently being dragged, as we did with the smaller
    GUI elements inside interfaces.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 获取当前鼠标位置后，遍历属于当前应用程序状态的所有接口。如果接口当前处于活动状态，则对其进行更新。只有当问题接口当前没有被拖动时，才会考虑`Hover`和`Leave`事件，就像我们在接口内部的小型GUI元素中所做的那样。
- en: 'Now it''s time to draw all of these interfaces onto the screen:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将这些接口绘制到屏幕上了：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once again, this method iterates over all interfaces that belong to the current
    application state. If they're active, each re-draw flag is checked and the appropriate
    re-draw methods are invoked. Finally, a pointer to the `sf::RenderWindow` is passed
    into the `Draw` method of an interface so it can draw itself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，此方法会遍历属于当前应用程序状态的所有接口。如果它们处于活动状态，则会检查每个重绘标志并调用相应的重绘方法。最后，将`sf::RenderWindow`的指针传递给接口的`Draw`方法，以便它能够绘制自身。
- en: 'It would be good to have a method for creating these types automatically because
    we''re working with factory-produced element types:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个方法可以自动创建这些类型，那就太好了，因为我们正在使用工厂生产的元素类型：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the provided element type is a `Window`, a new interface is created, to which
    a pointer of `GUI_Manager` is passed as its second argument. In the case of any
    other element type being passed in, the factory container is searched and the
    stored `lambda` function is invoked with the `l_owner` argument passed in to it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的元素类型是`Window`，则创建一个新的接口，并将`GUI_Manager`的指针传递为其第二个参数。在传递任何其他元素类型的情况下，搜索工厂容器，并调用存储的`lambda`函数，并将`l_owner`参数传递给它。
- en: 'Lastly, let''s discuss the de-serialization of interfaces. A method is needed
    to load files formatted in this way:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们讨论接口的反序列化。需要一个方法来加载这种格式的文件：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let''s work on loading our interfaces from a file. We''re not going to
    cover how the file itself is read as it''s pretty much identical to how we usually
    do it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从文件中加载我们的接口。我们不会介绍如何读取文件本身，因为它基本上与我们的常规做法相同：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s start with creating an interface:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个接口开始：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As suggested by the file format, it first needs to read in its name and the
    name of the style file. If adding an interface with the loaded name fails, an
    error is printed out and the file reading is stopped. Otherwise, a pointer to
    this freshly added window is obtained and its overloaded **>>** operator is used
    to read in additional information from the stream, which we covered back in the
    interface section of this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如文件格式所建议，首先需要读取其名称和样式文件名称。如果添加带有加载名称的接口失败，则打印错误信息并停止文件读取。否则，获取新添加的窗口的指针，并使用其重载的**>>**运算符从流中读取附加信息，这是我们在本章接口部分讨论过的。
- en: Next, an attempt is made to load the style file that was read in earlier by
    calling the `LoadStyle` method, which we will be covering shortly. If it fails,
    an error message is printed out. Lastly, its content size is adjusted based on
    its current style.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试通过调用`LoadStyle`方法加载之前读取的样式文件，我们将在稍后介绍该方法。如果失败，则打印错误信息。最后，根据其当前样式调整其内容大小。
- en: 'Handling element de-serialization, in its most basic form, is quite similar:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 处理元素反序列化，在其最基本的形式下，相当相似：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The element type, the name, position, and the style values are read in from
    the file. An element type is obtained after running the text that was read into
    the `type` variable through our helper method `StringToType`. An interface that
    the element needs to be added to is obtained by using the name passed in as an
    argument to the `LoadInterface` method. The `AddElement` method of the obtained
    interface is called in order to create the appropriate element type on the heap.
    If it''s successful, the element is obtained by name and its additional information
    is read in by utilizing its overloaded `>>` operator. The `LoadStyle` method is
    invoked once again in order to read the style of an element from a file. Let''s
    take a look at what this looks like:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 元素类型、名称、位置和样式值都是从文件中读取的。元素类型是在将读取到的文本运行到`type`变量中并通过我们的辅助方法`StringToType`后获得的。需要添加到元素中的接口是通过使用传递给`LoadInterface`方法的参数名称获得的。通过调用获取到的接口的`AddElement`方法，以在堆上创建适当的元素类型。如果成功，通过名称获取元素，并通过利用其重载的`>>`运算符读取其附加信息。再次调用`LoadStyle`方法，以从文件中读取元素的样式。让我们看看这看起来是什么样子：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this serving as an example, it''s time to try and read it in. Once again,
    we''re going to skip the code that reads the file as it is redundant. With that
    in mind, let''s take a look:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以此为例，现在是时候尝试读取它了。再次提醒，我们将跳过读取文件的代码，因为它与通常的做法重复。考虑到这一点，让我们看一下：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note the two `GUI_Style` structures that are set up here: they keep track of
    the main style that serves as a parent and the temporary style that''s currently
    being read in. Let''s keep moving further down this method, inside the actual
    `while` loop:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里设置的两种`GUI_Style`结构：它们跟踪作为父级的主要样式和当前正在读取的临时样式。让我们继续向下看这个方法，在实际的`while`循环中：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If a `State` keyword is encountered and `currentState` is not set up, the name
    of the state is read in. Otherwise, we print out an error message:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到`State`关键字且`currentState`未设置，则读取状态名称。否则，我们打印出错误信息：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When encountering a `/State` keyword, we can safely assume that the style currently
    being processed has ceased. The state is then determined based on the string that
    was read in denoting it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到`/State`关键字时，我们可以安全地假设当前正在处理的样式已经结束。然后，根据读取的表示该状态的字符串确定状态。
- en: If the state is `Neutral`, we need to set it to be the parent style, which means
    that every unset property of the other styles will also be inherited from this
    one. The `UpdateStyle` method is then invoked for each of the three supported
    states in order to overwrite the default values. If it is anything other than
    `Neutral`, the `UpdateStyle` method is only invoked once for that state. The `TemporaryStyle`
    variable is then overwritten with `ParentStyle` to simulate inheritance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态是`Neutral`，我们需要将其设置为父样式，这意味着其他样式的所有未设置属性也将从这一种继承过来。然后对三个支持的状态中的每一个调用`UpdateStyle`方法，以覆盖默认值。如果状态不是`Neutral`，则只为该状态调用一次`UpdateStyle`方法。然后，`TemporaryStyle`变量被`ParentStyle`覆盖，以模拟继承。
- en: 'Finally, let''s see how every different style feature is supported:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何支持每个不同的样式特性：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Every color value is first read in as four separate integers and then stored
    in a `sf::Color` structure which gets assigned to the appropriate data member
    of the style structure. Padding and text values are simply streamed in. One exception
    to this is the `TextOriginCenter` tag. It does not contain any additional information
    and its mere existence simply means that the origin of the text element should
    always be centered.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个颜色值首先被读取为四个单独的整数，然后存储在`sf::Color`结构中，该结构被分配给样式结构中的适当数据成员。填充和文本值只是简单地流进。有一个例外是`TextOriginCenter`标签。它不包含任何附加信息，它的存在仅仅意味着文本元素的起点应该始终居中。
- en: The label element
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签元素
- en: A label element is the simplest GUI type yet. It supports all of the default
    stylistic features but it doesn't do much else other than contain a certain string
    value that can be loaded in or set at runtime.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 标签元素是最简单的GUI类型。它支持所有默认的样式特性，但除了包含一个可以在运行时加载或设置的特定字符串值之外，没有做太多其他的事情。
- en: 'Let''s take a look at its constructor and destructor:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的构造函数和析构函数：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is nothing short of child's play in comparison to the code we've written
    before. Its name, type, and owner are set up in the initializer list and there's
    nothing else to it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前编写的代码相比，这简直是小菜一碟。它的名称、类型和所有者都在初始化列表中设置，除此之外没有其他内容。
- en: 'The de-serialization of this type of element is also fairly simple. Recall
    the following line from an interface file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型元素的反序列化过程也相当简单。回想一下接口文件中的以下行：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since the `GUI_Manager` class takes care of all of this information except
    the last part, the `ReadIn` method of this element might look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`GUI_Manager`类处理了所有这些信息（除了最后一部分），这个元素的`ReadIn`方法可能看起来像这样：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we have to implement the event methods of this element. In this case,
    it''s nothing more than simply adjusting the state of the label:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须实现这个元素的的事件方法。在这种情况下，这不过是简单地调整标签的状态：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The final bit of code is responsible for how this element is drawn:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分代码负责如何绘制这个元素：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After the background rectangle is drawn, the glyph is checked to see whether
    it needs to be drawn as well. Lastly, the text is rendered right on top of the
    last two visual attributes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制背景矩形之后，检查符号是否需要绘制。最后，文本直接渲染在最后两个视觉属性之上。
- en: The text field element
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本字段元素
- en: 'In order to implement a text field element successfully, we need to define
    how it responds to input correctly. Firstly, let''s set up a new element type
    by creating the text field element class and implementing the constructor, as
    shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功实现文本字段元素，我们需要定义它如何正确地响应输入。首先，让我们通过创建文本字段元素类和实现构造函数来设置一个新的元素类型，如下所示：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This element can also have a default text value when loaded, so let''s express
    that by providing a custom version of the `ReadIn` method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元素在加载时也可以有一个默认的文本值，所以让我们通过提供一个自定义的`ReadIn`方法来表达这一点：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you probably know, text fields do not change state if a mouse button is
    released. This allows them to be focused until a mouse click is registered elsewhere.
    We have already implemented that functionality in the `GUI_Interface` class as
    the `DefocusTextfields` method. All that''s left to do now is ignore release events:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，文本字段在鼠标按钮释放时不会改变状态。这允许它们保持聚焦状态，直到在其他地方注册鼠标点击。我们已经在`GUI_Interface`类中实现了该功能，作为`DefocusTextfields`方法。现在剩下的只是忽略释放事件：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Lastly, let''s take a look at drawing this element:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何绘制这个元素：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It is quite simple in nature. So far, we have only worried about drawing the
    background solid behind the text that this element holds. The glyph is also supported
    here but we're not going to be using it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它的本质相当简单。到目前为止，我们只关心绘制这个元素所包含文本背后的背景实体。符号也在这里得到支持，但我们不会使用它。
- en: The scrollbar element
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滑块元素
- en: 'All of that support for interface scrolling and control elements implies the
    existence of the scrollbar element. Its purpose is to move around the visible
    area of the content texture in order to reveal elements that are positioned further
    out than its size allows, which could be along any axis. With that knowledge,
    let''s take a stab at working out the basic class definition of the scrollbar
    element:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些对界面滚动和控制元素的支持意味着滑块元素的存在。其目的是在内容纹理的可见区域内移动，以揭示位置超出其尺寸允许的元素，这可以沿任何轴进行。有了这些知识，让我们尝试制定滑块元素的基本类定义：
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Firstly, we enumerate both possible types of sliders: horizontal and vertical.
    The actual `GUI_Scrollbar` class overwrites three of the original methods the
    parent class provides, in addition to implementing all of the purely virtual ones.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们列举两种可能的滑块类型：水平和垂直。实际的 `GUI_Scrollbar` 类覆盖了父类提供的三个原始方法，并实现了所有纯虚拟方法。
- en: Among its private data members, the scrollbar keeps track of its own type, which
    contains another drawable object to represent the slider and maintains information
    about the last known mouse coordinates, as well as the percentage value of scroll
    it's currently at.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在其私有数据成员中，滑块跟踪其自身类型，该类型包含另一个可绘制对象来表示滑块，并维护有关最后已知鼠标坐标以及当前滚动百分比值的信息。
- en: 'Let''s start with the easy part – the constructor:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的部分开始——构造函数：
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It's pretty straightforward so far. The element type is set to `Scrollbar` and
    the `m_isControl` flag is set to `true` to tell the owner interface which layer
    to draw it on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这相当直接。元素类型设置为 `Scrollbar`，并将 `m_isControl` 标志设置为 `true` 以告诉所有者界面在哪个层上绘制它。
- en: 'Next up, the `SetPosition` method needs to be overwritten to make sure that
    the scrollbar is positioned correctly:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要覆盖 `SetPosition` 方法以确保滑块定位正确：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Due to the nature of this particular element, one axis has to be always set
    to `0` in order to keep it positioned on the right edge.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个特定元素的特性，必须始终将一个轴设置为 `0` 以保持其在右侧边缘的位置。
- en: 'For now, the type of a scrollbar will be read in from the interface file. To
    make that happen, we may want to handle de-serialization like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，滑块类型将从界面文件中读取。为了实现这一点，我们可能需要像这样处理反序列化：
- en: '[PRE37]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s handle the events next, starting with `OnClick`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们处理事件，从 `OnClick` 开始：
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Since we only want scrolling to happen when the slider part is being dragged,
    the state of this element is only set to `Clicked` if the mouse coordinates are
    inside the slider. They then get stored in the `m_moveMouseLast` data member to
    prevent the slider from jumping.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只想在拖动滑块部分时进行滚动，因此只有当鼠标坐标在滑块内时，此元素的状态才设置为 `Clicked`。然后它们被存储在 `m_moveMouseLast`
    数据成员中，以防止滑块跳动。
- en: 'The remaining three events are not needed for anything other than adjusting
    the state:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的三个事件除了调整状态外不需要做任何事情：
- en: '[PRE39]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The style updating also has to be altered to maintain the desired functionality
    of the scrollbar:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 样式更新也必须更改以保持滑块的期望功能：
- en: '[PRE40]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The size of the scrollbar is set to match the size of the owner interface on
    the relevant axis after the parent `UpdateStyle` is called.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用父类 `UpdateStyle` 之后，滑块的大小设置为与所有者界面在相关轴上的大小相匹配。
- en: 'Next, we have to define a custom way of applying style attributes to scrollbar
    elements, due to their unique nature:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义一种自定义方式来应用样式属性到滑块元素，因为它们的独特性质：
- en: '[PRE41]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After the parent `ApplyStyle` is invoked and the slider color is set, the position
    of the element is overwritten to keep it at 0 on the axis of action and right
    near the edge on the perpendicular axis. The size of the background solid is determined
    by the size of the interface on the scroll axis. Its style attributes determine
    the other size value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用父类 `ApplyStyle` 并设置滑块颜色后，元素的定位被覆盖，以保持在动作轴上的位置为 0 并且在垂直轴的边缘附近。背景实体的尺寸由滚动轴上的界面尺寸决定。其样式属性决定了其他尺寸值。
- en: The position of the slider is modified on the non-operational axis to always
    match the position of the element itself. Calculating its size along the scrolling
    axis is as simple as dividing the size of the owner window by the result of dividing
    its content size by the same window size.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动条的位置在非操作轴上被修改，以确保始终与元素本身的位置相匹配。沿着滚动轴计算其大小就像将拥有窗口的大小除以其内容大小除以相同窗口大小的结果一样简单。
- en: 'With the style part of this element complete, let''s work on moving it and
    affecting its owner interface:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个元素的样式部分后，让我们来移动它并影响其所有者界面：
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: All of the code above only needs to be executed if the state of this element
    is `Clicked`. It's then obvious that the slider of the scrollbar is being dragged
    up and down. If the current mouse position is not the same as the last position
    from a previous iteration, the difference between them is calculated and the current
    position of the mouse is stored for later reference.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述所有代码只有在元素的当前状态为`Clicked`时才需要执行。很明显，滚动条的滑块正在上下拖动。如果当前鼠标位置与上一次迭代的最后位置不同，则计算它们之间的差异，并将当前鼠标位置存储以供以后参考。
- en: Firstly, the slider is moved by the difference of the mouse positions between
    the last two iterations. It is then checked to see if it is outside the boundaries
    of the interface, in which case, its position gets reset to the closest edge.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过两次迭代之间鼠标位置的差异来移动滑块。然后检查它是否超出界面的边界，如果是，则将其位置重置为最近的边缘。
- en: Lastly, the scroll percentage value is calculated by dividing the slider's position
    on the relevant axis by the difference of the window size and the slider size.
    The relevant update method for scrolling is then invoked and this element is marked
    to be re-drawn to reflect its changes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过将滑块在相关轴上的位置除以窗口大小和滑块大小的差值来计算滚动百分比值。然后调用相应的滚动更新方法，并将此元素标记为需要重新绘制以反映其更改。
- en: 'The last thing we need to do is define how the scrollbar element is drawn:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是定义滚动条元素是如何绘制的：
- en: '[PRE43]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For now, it only uses two rectangle shapes, however, this can easily be expanded
    to support textures as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它只使用两个矩形形状，但是很容易扩展以支持纹理。
- en: Integrating the GUI system
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成GUI系统
- en: 'In order to use the GUI system, it needs to first exist. Just like in previous
    chapters, we need to instantiate and update the GUI classes we built. Let''s start
    by adding the GUI manager and the font manager to the `SharedContext.h` file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用GUI系统，它首先需要存在。就像在之前的章节中一样，我们需要实例化和更新我们构建的GUI类。让我们首先将GUI管理器和字体管理器添加到`SharedContext.h`文件中：
- en: '[PRE44]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We need to keep a pointer to the GUI manager and the font manager in the `Game`
    class, as with all of the other classes that are shared through the `SharedContext`
    structure, starting with the header:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`Game`类中保留对GUI管理器和字体管理器的指针，就像所有通过`SharedContext`结构共享的其他类一样，从头文件开始：
- en: '[PRE45]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'These pointers are, of course meaningless, unless they actually point to valid
    objects in memory. Let''s take care of the allocation and de-allocation of resources
    in the `Game.cpp` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指针当然是没有意义的，除非它们实际上指向内存中的有效对象。让我们在`Game.cpp`文件中处理资源的分配和释放：
- en: '[PRE46]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we can look at updating all of the interfaces in the application and
    handling GUI events:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以查看更新应用程序中的所有界面和处理GUI事件：
- en: '[PRE47]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that the `GUI_Event` instance is forwarded to the `EventManager` class.
    We're going to be expanding it soon.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`GUI_Event`实例被转发到`EventManager`类。我们很快就会对其进行扩展。
- en: 'Finally, let''s handle drawing our interfaces:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们处理绘制我们的界面：
- en: '[PRE48]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In order for the GUI to be always drawn above the rest of the scene, the window
    view has to be set to the default before the interfaces are drawn. It then needs
    to be set back in order to maintain a consistent camera position, which might
    look something like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使GUI始终绘制在场景的其他部分之上，在绘制界面之前必须将窗口视图设置为默认值。然后需要将其设置回以保持一致的相机位置，这可能看起来像这样：
- en: '![Integrating the GUI system](img/B04284_11_01.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![集成GUI系统](img/B04284_11_01.jpg)'
- en: Expanding the event manager
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展事件管理器
- en: 'GUI events need to be handled for every possible state of the application in
    order to keep them from piling up, much like SFML events. In order to avoid writing
    all of that extra code, we''re going to use something that was built solely for
    the purpose of handling them: the event manager.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止堆积，需要为应用程序的每个可能状态处理 GUI 事件，就像 SFML 事件一样。为了避免编写所有额外的代码，我们将使用专门为处理它们而构建的东西：事件管理器。
- en: 'Let''s start by expanding the `EventType` enumeration to support GUI events:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从扩展 `EventType` 枚举以支持 GUI 事件开始：
- en: '[PRE49]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It's important to keep these custom event types at the very bottom of the structure
    because of the way the code we've written in the past works.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们过去编写的代码的方式，出于这个原因，重要的是将这些自定义事件类型放在结构的底部。
- en: Our previous raw implementation of the `EventManager` class relied on the fact
    that any given event can be represented simply by a numeric value. Most SFML events,
    such as key bindings, fit into that category but a lot of other event types, especially
    custom events, require additional information in order to be processed correctly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前对 `EventManager` 类的原始实现依赖于这样一个事实：任何给定的事件都可以简单地用一个数值来表示。大多数 SFML 事件，如按键绑定，都属于这一类，但许多其他事件类型，尤其是自定义事件，需要额外的信息才能正确处理。
- en: 'Instead of using numbers, we need to switch to a lightweight data structure
    like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用数字，我们需要切换到一个轻量级的数据结构，如下所示：
- en: '[PRE50]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The union ensures that no memory is wasted and that we can still use numeric
    representations of event types, as well as custom data-types, such as the `GUI_Event`
    structure. `GUI_Event` belongs to a union, which is why it couldn't use `std::string`
    typed data members.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 联合确保没有浪费内存，我们仍然可以使用事件类型的数值表示，以及自定义数据类型，如 `GUI_Event` 结构。`GUI_Event` 属于联合，这就是为什么它不能使用
    `std::string` 类型的数据成员。
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If the boost library is used, all of this code can be reduced to `boost::variant<int,
    GUI_Event>`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 boost 库，所有这些代码都可以简化为 `boost::variant<int, GUI_Event>`。
- en: 'One additional change is that we want to be able to pass the GUI event information
    to the callback methods that are registered. This information will also be held
    by our `EventDetails` structure:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个额外的变化是我们希望能够将 GUI 事件信息传递给已注册的回调方法。这些信息也将由我们的 `EventDetails` 结构持有：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let''s adjust the `Binding` structure:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调整 `Binding` 结构：
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We had to use `const char*` data types to hold element and interface names because
    of union restrictions. While that only applies to GUI-related events, this memory
    still needs to be de-allocated. When a binding is being destroyed, all of the
    event information is iterated over and checked to see if it is any of the four
    GUI event types, in which case the memory is safely de-allocated.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于联合的限制，我们不得不使用 `const char*` 数据类型来存储元素和接口名称。虽然这仅适用于与 GUI 相关的事件，但这些内存仍然需要释放。当一个绑定被销毁时，所有的事件信息都会被迭代并检查是否属于四种
    GUI 事件类型之一，如果是，则安全地释放内存。
- en: 'Next, we need a separate method that handles just the GUI events. Overloading
    the `HandleEvent` method with a different argument type seems like a good choice
    here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个单独的方法来处理仅 GUI 事件。在这里，使用不同的参数类型重载 `HandleEvent` 方法似乎是一个不错的选择：
- en: '[PRE53]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We need to make sure that no GUI events are processed in the original `HandleEvent`
    method:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保在原始的 `HandleEvent` 方法中不处理任何 GUI 事件：
- en: '[PRE54]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If the event is of one of the four GUI types, the iteration is skipped. Handling
    the GUI events themselves is quite simple and can be done in this manner:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件是四种 GUI 类型之一，则跳过迭代。处理 GUI 事件本身相当简单，可以按以下方式完成：
- en: '[PRE55]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: While iterating over the events inside bindings, their types are checked. Anything
    that is not a GUI event is skipped over. If the type of a processed event matches
    the type inside the binding, additional information is checked in the `EventInfo`
    structure, namely the interface and element names. If those match too, they are
    recorded as event details and the event count is incremented.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代绑定内的事件时，会检查它们的类型。任何不是 GUI 事件的都会被跳过。如果处理事件的类型与绑定内的类型匹配，则会在 `EventInfo` 结构中检查额外的信息，即接口和元素名称。如果这些也匹配，它们将被记录为事件细节，并且事件计数会增加。
- en: 'The last chunk of code that needs attention is the `LoadBindings` method. We
    need to adjust it to support interface and element name-loading from the `keys.cfg`
    file, which should look something like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 需要关注的最后一部分代码是 `LoadBindings` 方法。我们需要调整它以支持从 `keys.cfg` 文件中加载接口和元素名称，其格式可能如下所示：
- en: '[PRE56]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The first line represents a normal type of event, while the second line is
    a GUI event, which requires two identifiers to be loaded instead of just one.
    Let''s adjust it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代表一种普通类型的事件，而第二行是GUI事件，它需要加载两个标识符而不是一个。让我们调整它：
- en: '[PRE57]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: After the event type is loaded in as usual, it is checked to see if it matches
    any of the four GUI events. The window and element strings are then read in and
    copied to the newly allocated memory of `char*` via the `std::strcpy` method.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在像往常一样加载事件类型后，它会检查它是否与四个GUI事件中的任何一个匹配。然后读取窗口和元素字符串，并通过`std::strcpy`方法将它们复制到新分配的`char*`内存中。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that when memory for `char*` types is allocated to match a given
    string, it also needs an additional space for the null-terminating character at
    the end.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当为`char*`类型的内存分配以匹配给定字符串时，它还需要额外的空间来存储末尾的空终止字符。
- en: Re-implementing the main menu
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新实现主菜单
- en: 'In order to demonstrate how much easier it is building interactivity in this
    way, let''s re-construct the main menu, starting by creating its `.interface`
    file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示以这种方式构建交互性有多容易，让我们重新构建主菜单，首先创建其`.interface`文件：
- en: '[PRE58]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The interface is set to have zero padding on both axes, be immovable, and have
    no title bar. All three buttons in this interface, as well as its title, can be
    represented by labels with different styles. Speaking of which, let''s take a
    look at the style of our main menu interface:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该界面在两个轴向上都设置了零填充，不可移动，并且没有标题栏。此界面中的所有三个按钮以及其标题都可以用不同样式的标签表示。说到这里，让我们看看我们主菜单界面的样式：
- en: '[PRE59]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As you can see, it only defines the most basic attributes and does not aim
    to be visually responsive by itself. The button label style, however, is a little
    different:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它只定义了最基本的属性，并且本身并不旨在具有视觉响应性。然而，按钮标签样式略有不同：
- en: '[PRE60]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When its state changes, the label''s background color is adjusted as well,
    unlike the label that represents the title of the main menu:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态改变时，标签的背景颜色也会调整，这与代表主菜单标题的标签不同：
- en: '[PRE61]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'With all of the visual elements out of the way, let''s adjust the main menu
    state to load and maintain this interface:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有视觉元素都处理完毕后，让我们调整主菜单状态以加载并维护此界面：
- en: '[PRE62]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In addition to all of the required methods that a state has to implement, we
    only need two callbacks to handle GUI clicks. This is all set up in the `OnCreate`
    method of the main menu state:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了状态必须实现的所有必需方法之外，我们只需要两个回调函数来处理GUI点击。这一切都在主菜单状态中的`OnCreate`方法中设置：
- en: '[PRE63]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Firstly, the main menu interface is loaded from a file and placed on screen.
    The event manager is then used to set up callbacks for the **Play** and **Quit**
    button actions. This is already much cleaner than the previous approach.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，主菜单界面从文件加载并放置在屏幕上。然后使用事件管理器设置**播放**和**退出**按钮动作的回调。这已经比以前的方法干净得多。
- en: 'Once the state is destroyed, the interface and two callbacks must be removed,
    as shown here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦状态被销毁，必须移除界面和两个回调函数，如下所示：
- en: '[PRE64]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The text of the **Play** button must be changed if a `GAME` state exists:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在`GAME`状态，则必须更改**播放**按钮的文本：
- en: '[PRE65]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'That leaves us with our two callbacks, which look like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了我们两个回调函数，它们看起来像这样：
- en: '[PRE66]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This illustrates perfectly how easy it is to use our new GUI with an improved
    event manager for fast and responsive results. The main menu was created with
    roughly 20 lines of code, or fewer, and looks like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这完美地说明了使用我们新的GUI以及改进的事件管理器如何容易实现快速和响应的结果。主菜单是用大约20行代码或更少的代码创建的，看起来像这样：
- en: '![Re-implementing the main menu](img/B04284_11_02.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![重新实现主菜单](img/B04284_11_02.jpg)'
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At the beginning of [Chapter 10](ch10.html "Chapter 10. Can I Click This? –
    GUI Fundamentals"), *Can I Click This? – GUI Fundamentals*, our main goal was
    to achieve a simple yet powerful means of interfacing with our own application.
    Throughout this chapter, additional topics such as interface and event management,
    creation and integration of new element types, and expansion of existing code
    were covered in depth. The effectiveness of all the work that was put into the
    GUI cannot be measured in any other way but success. We are now left with a system
    that is capable of producing efficient, responsive, and fast results with the
    minimum amount of effort and code. Furthermore, you should now have the skills
    necessary to build even more element types that will enable this system to do
    amazing things.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 10 章的开始部分 [第 10 章](ch10.html "第 10 章。我能点击这个吗？ – GUI 基础")，“我能点击这个吗？ – GUI
    基础”，我们的主要目标是实现一种简单而强大的方式来与我们的应用程序进行交互。在本章中，我们深入探讨了诸如界面和事件管理、新元素类型的创建和集成以及现有代码的扩展等附加主题。投入
    GUI 的所有工作的有效性无法用其他方式衡量，只能用成功来衡量。我们现在拥有一个系统，它能够在最少的努力和代码下产生高效、响应快和快速的结果。此外，你现在应该具备构建更多元素类型的技能，这将使这个系统能够完成令人惊叹的事情。
- en: In the next chapter, we're going to be covering the management and usage of
    sound and music elements in SFML. See you there!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 SFML 中声音和音乐元素的管理和使用。那里见！
