<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Your Point of View</h1></div></div></div><p>Imagine that you are making a video. You've got your cell phone out, and you point it at the area that you want to shoot and press record. You're taking a video of the Grand Canyon, so you have to pan the camera around to get the whole scene in. Suddenly, a bird flies past the field of view, and you've captured the whole scene.</p><p>The preceding scenario is pretty much how games work as well. The game has a virtual camera that can be positioned and even moved around. Similarly to the video camera on your cell phone, the game camera can only see a part of the game world, so sometimes you have to move it around. Any game objects that move in front of the camera will be seen by the player.</p><p>This chapter will explain how things are rendered in the game. Rendering is the process of actually displaying images on the screen. In order to get your get your game onto the screen, you will need to have a solid understating of the following terms:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Coordinate systems</strong>: The <a id="id58" class="indexterm"/>coordinate system is the reference that allows you to position objects in the game</li><li class="listitem" style="list-style-type: disc"><strong>Primitives</strong>: Primitives are<a id="id59" class="indexterm"/> the fundamental building blocks of the images that you see on screen, and OpenGL was designed to work with them</li><li class="listitem" style="list-style-type: disc"><strong>Textures</strong>: Textures are<a id="id60" class="indexterm"/> image files that are used to give the objects in your game a realistic appearance</li></ul></div><p>By the time you have read this chapter, you will understand how to use images to build your game world and display it on the screen.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Plotting your revenge</h1></div></div></div><p>Okay, so you're not really plotting your revenge. But you are plotting everything in your game as if you <a id="id61" class="indexterm"/>were putting it all down on a piece of graph paper. Remember high-school geometry? You got out your graph paper, drew a couple of lines for the <em>X</em> and <em>Y</em> axis, and the plotted points on the graph. OpenGL works in pretty much the same way.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>The OpenGL coordinate system</h2></div></div></div><p>The OpenGL coordinate system is a standard <em>X</em> and <em>Y</em> axis system that you have most likely learned all your<a id="id62" class="indexterm"/> life. You can conceptualize (0, 0) as being the <a id="id63" class="indexterm"/>center of the screen.</p><p>Let's say that we want to display a moving car on the screen. We could start by plotting our car at position (5, 5) in the coordinate plane. If we then moved the car from (5, 5) to (6, 5), then (7, 5), and so forth, the car would move to the right (and eventually leave the screen), as illustrated in the following figure:</p><div><img src="img/8199OS_02_01.jpg" alt="The OpenGL coordinate system"/></div><p>We haven't been completely honest with you. Since OpenGL is a 3D rendering engine, there is actually one more axis called the Z-axis that we haven't discussed. As this part of the book focuses on 2D game programming, we will ignore the Z axis for now.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec12"/>Making your point</h3></div></div></div><p>As we learn each concept, we will actually write code to demonstrate each point. Speaking of points, we will write code to plot points using OpenGL.</p><p>We are going to set<a id="id64" class="indexterm"/> this project up as a separate project from the actual game. We will use this project to demonstrate how to code basic OpenGL tasks. To keep this thing as simple as possible, this project will be created as a console project in Visual Studio. A console project doesn't have many of the features of a full-blown Windows project and therefore, the setup code is much smaller.</p><p>Start Visual Studio and create a new project. For the project template, choose <strong>Win32 Console Application</strong> from the <strong>Visual C++</strong> group of templates. Name the project <strong>OpenGLFun</strong>, and click <strong>OK</strong>. Click <strong>Finish</strong> to complete the project wizard.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>You should notice that the code is much simpler than the code that was created in the previous chapter for a full-blown Windows application. We will return to using the more complicated code as we continue building the game.</p></div></div><div><img src="img/8199OS_02_02.jpg" alt="Making your point"/></div><p>Once you have<a id="id65" class="indexterm"/> the project created, type following the code into the code window:</p><div><pre class="programlisting">#include "stdafx.h"
#include &lt;windows.h&gt;
#include "glut.h"

void initGL() {
  glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
}

void drawPoints()
{
  glBegin(GL_POINTS);
  
  glColor3f(1.0f, 1.0f, 1.0f);
  glVertex2f(0.1f, -0.6f);
  glVertex2f(0.7f, -0.6f);
  glVertex2f(0.4f, -0.1f);
  
  glEnd();
}

void update()
{
  glClear(GL_COLOR_BUFFER_BIT);
  drawPoints();
  glFlush();
}

int _tmain(int argc, _TCHAR* argv[])
{
  glutCreateWindow("GL Fun");
  glutInitWindowSize(320, 320);
  glutInitWindowPosition(50, 50);
  glutDisplayFunc(update);
  initGL();
  glutMainLoop();
  return 0;
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec13"/>Understanding the code</h3></div></div></div><p>As we will be using the code to demonstrate the fundamentals of OpenGL, we will look at it in detail so that<a id="id66" class="indexterm"/> you understand what the code is doing.</p><div><div><div><div><h4 class="title"><a id="ch02lvl4sec01"/>Header files</h4></div></div></div><p>This code uses three header files:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">stdafx.h</code>: This header<a id="id67" class="indexterm"/> file loads the precompiled header <a id="id68" class="indexterm"/>that was created by Visual Studio when we created the project</li><li class="listitem" style="list-style-type: disc"><code class="literal">windows.h</code>: This header<a id="id69" class="indexterm"/> file allows the window that renders the OpenGL content to be created</li><li class="listitem" style="list-style-type: disc"><code class="literal">glut.h</code>: This header file allows us to use the OpenGL Utility Toolkit, which simplifies the setup and use <a id="id70" class="indexterm"/>of OpenGL</li></ul></div><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>You will need to download the GLUT files and place them in your project folder. Download<a id="id71" class="indexterm"/> the files from <a class="ulink" href="http://www.javaforge.com/doc/105278">http://www.javaforge.com/doc/105278</a>. Open the zipped file and copy <code class="literal">glut.h</code>, <code class="literal">glut32.dll</code>, and <code class="literal">glut32.lib</code> into the folder that contains your source code. You may have to add glut.h to your project (right-click on <code class="literal">Header files</code> | <code class="literal">Add</code> | <code class="literal">Existing item</code>).</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec02"/>Initializing OpenGL</h4></div></div></div><p>You will notice<a id="id72" class="indexterm"/> a function called <code class="literal">initGL</code>. This function currently contains a single line of code whose sole purpose is to set the background color of the screen at the <a id="id73" class="indexterm"/>start of each frame. This is often referred to as the <em>clear color</em> because it is the default that OpenGL clears the background to before it begins to render additional items:</p><div><pre class="programlisting">glClearColor(0.0f, 0.0f, 0.0f, 1.0f);</pre></div><p>The four numbers inside the parenthesis define the color, and the opacity of the color. The first three numbers represent the amount of red, green, and blue (RGB) that will be used to create the color. The fourth number represents the opacity (or seen another way, the transparency) of the color. This is also referred to as the alpha channel (RGBA). The values above create a black background that is 100 percent opaque.</p><p>All values in OpenGL have a range from 0 to 1. This means that there will be many decimal values, known in C++ as floats. Thus, the range in C++ lingo is from <code class="literal">0.0f</code> to <code class="literal">1.0f</code>.</p><p>C++ is different from many languages, which use integers or even hexadecimal numbers to express their ranges. For example, many other languages use a range of 0 to 255 for each color component. In these cases, integer 0 corresponds to <code class="literal">0.0f</code>, and integer 255 corresponds to <code class="literal">1.0f</code>.</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>To convert an integer of range 0 to 255 to OpenGL's system, use the formula <em>(1/255) * value</em>, where value is the integer value you are trying to convert. Thus, to convert the number 50, you would calculate <em>(1/255) * 50</em>, which results in 0.1096.</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec03"/>The main entry point</h4></div></div></div><p>Every program has to have a starting point, known as the entry point. In our program, this is the <code class="literal">_tmain</code> function. We put this at the very end because C++ expects the functions that are being used to have been defined before the function that calls them. There are various tricks around<a id="id74" class="indexterm"/> this, but we'll keep our examples simple and just always define <code class="literal">_tmain</code> as the last function in the code.</p><p>When we start the program, there are a few things that have to be done to set up the environment to render OpenGL. Here is the anatomy of the <code class="literal">_tmain</code> function:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">glutCreateWindow("GL Fun")</code>: This function creates the window that will render the OpenGL content. We<a id="id75" class="indexterm"/> include the name of the program as a parameter.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glutInitWindowSize(320, 320)</code>: This function initializes the size of the window. We have<a id="id76" class="indexterm"/> specified 320 pixels by 320 pixels. Feel free to try larger (or smaller) window sizes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glutInitWindowPosition(50, 50)</code>: This function sets the position of the window's upper-left<a id="id77" class="indexterm"/> corner in relation to the device's screen. In this case, the window will start drawing 50 pixels from the left and 50 pixels from the top of the screen. Feel free to try other positions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glutDisplayFunc(update)</code>: Remember the previous chapter where we talked about the game loop? The game loop is the part of the program that runs over and<a id="id78" class="indexterm"/> over again (that is, every <em>frame</em>). We need to tell GLUT the name of the function that we want to run every frame. In this case, we are telling GLUT to use a function named <code class="literal">update</code> (described in the next section).</li><li class="listitem" style="list-style-type: disc"><code class="literal">initGL()</code>: This simply<a id="id79" class="indexterm"/> calls the <code class="literal">initGL</code> function that we described earlier.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glutMainLoop()</code>: This function<a id="id80" class="indexterm"/> starts the main game loop, which in turn will call our <code class="literal">update</code> function every frame. This essentially starts our program, which will run in an infinite loop until we close the program.</li><li class="listitem" style="list-style-type: disc"><code class="literal">return 0</code>: This line<a id="id81" class="indexterm"/> is required by the <code class="literal">_tmain</code> function. It basically tells our system that the program has exited and everything is okay. This line of code won't run until we exit the program.</li></ul></div></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec04"/>The update function</h4></div></div></div><p>The update function is called every frame. Any work that we want to do will have to be coded in this function. The update function currently has three lines of code:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">glClear(GL_COLOR_BUFFER_BIT)</code>: The <code class="literal">glClear</code> function resets the <em>render buffer</em> to the color that was specified earlier by the <code class="literal">glClearColor</code> function. The render buffer is a separate location in the memory where OpenGL renders objects before<a id="id82" class="indexterm"/> they are displayed on the screen. Later, when all of the render operations are completed, the contents of the buffer are displayed on the screen in one fast transfer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">drawPoints()</code>: This is a function that we wrote to display three points on the screen. Later, we will replace this line of code to draw other objects. This function is described in the next section.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glFlush()</code>: This function flushes the OpenGL buffer, including the back buffer that currently holds our render. As a result, the rendering buffer is flushed, and all of the contents are rendered to the device screen.<div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>OpenGL uses two buffers to draw. One is the screen buffer, which is what the player currently sees on the computer display. The other is the back buffer, which is where we create the objects that we intend to render in the next frame. Once we are done creating the render in the back buffer, we quickly swap the contents of the back buffer onto the current screen. This occurs so quickly that the player cannot detect the swap.</p></div></div></li></ul></div></div><div><div><div><div><h4 class="title"><a id="ch02lvl4sec05"/>Drawing the points</h4></div></div></div><p>The <code class="literal">drawPoints</code> function does the actual work of determining what to draw, and where to draw it. Here is what each line<a id="id83" class="indexterm"/> of code does:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">glBegin(GL_POINTS)</code>: The call to <code class="literal">glBegin</code> tells OpenGL to prepare to render items to the screen. We also tell OpenGL what we want to render. In our example, we are <a id="id84" class="indexterm"/>directing OpenGL to interpret the data that we send it as individual points. Later, we will learn to render other objects, such as triangles using <code class="literal">GL_TRIANGLES</code>, or rectangles using <code class="literal">GL_QUADS</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">glColor3f(1.0f, 1.0f, 1.0f)</code>: As the name suggests, <code class="literal">glColor</code> sets the color of the item that is going to be rendered. Remember, OpenGL uses the RGB color system, so the color will be white (0, 0, 0 specified black).</li><li class="listitem" style="list-style-type: disc"><code class="literal">glVertex2f(0.1f, -0.6f)</code>: Each point in OpenGL is known as a <em>vertex</em>. This code tells OpenGL to render a single point at the coordinates (<code class="literal">0.1, -0.6</code>). In this case, zero means the center of the screen, and one means one unit from the center. The settings for the camera determine exactly how far one unit from the center actually is on the screen. There are three <code class="literal">glVertex</code> calls in our example code, one for each of the points that we want to render to the screen.<div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>The names of OpenGL functions give you a clue as to how to use the function. For example, <code class="literal">glVertex2f</code> means that this function takes 2 parameters and they will be of type<a id="id85" class="indexterm"/> <code class="literal">float</code>. In comparison, the <code class="literal">glVertex3f</code> function takes three parameters of type <code class="literal">float</code>.</p></div></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">glEnd()</code>: Just like all good things must come to an end, we have to tell OpenGL when we are<a id="id86" class="indexterm"/> done rendering. That is the purpose of the call to <code class="literal">glEnd</code>.<div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>You have probably noticed a lot of the use of the lower case letter f; this stands for <em>float</em>, meaning that a number that may contain a part after the decimal point (as opposed to an <em>integer</em>, which is always a whole number). So, a number, such as <code class="literal">0.0f</code>, is telling C++ to treat the number zero as a floating point number. OpenGL uses a similar naming convention for its functions. For example, the function <code class="literal">glVertex2f</code> indicates that the function requires two floating point numbers (in this case, the <em>x</em> and <em>y</em> coordinates of the point to render).</p></div></div></li></ul></div></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec14"/>Running the program</h3></div></div></div><p>Now that you <a id="id87" class="indexterm"/>have entered your code, it's time to see it in action. When you run the program (<strong>Debug</strong> | <strong>Start Debugging</strong>), here is what you will see:</p><div><img src="img/8199OS_02_03.jpg" alt="Running the program"/></div><p>You'll have to look at it closely, but if all went well, you should see three white points in the lower-right area of the screen. Congratulations! You have rendered your first OpenGL objects!</p><p>Hopefully, you have been able to follow the code. Think of <code class="literal">_tmain</code> as a manager that controls the program by setting everything up and then calling the <code class="literal">main</code> loop (just like we will do in our <a id="id88" class="indexterm"/>game). Then GLUT takes over and calls the <code class="literal">update</code> function every frame. The <code class="literal">update</code> function initializes the render buffer, draws objects to the render buffer, and then transfers the contents of the render buffer to the screen. In a game running at 60 frames per second, this entire operation will happen 60 times a second!</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec15"/>Stretching your point</h3></div></div></div><p>Let's see how<a id="id89" class="indexterm"/> easy it will be to modify GLFun to draw other objects. This time we will draw two lines. Add the following function to your code just under the <code class="literal">drawPoints</code> function:</p><div><pre class="programlisting">void drawLines()
{
  glBegin(GL_LINES);
  
  glColor3f(1.0f, 1.0f, 1.0f);
  glVertex2f(0.1f, -0.6f);
  glVertex2f(0.7f, -0.6f);
  
  glVertex2f(0.7f, -0.6f);
  glVertex2f(0.4f, -0.1f);
  
  glEnd();
}</pre></div><p>Next, go to the update function and replace <code class="literal">drawPoints</code> with a call to <code class="literal">drawLines</code>. The new <code class="literal">update</code> function <a id="id90" class="indexterm"/>will look like this:</p><div><pre class="programlisting">void update() 
{
  glClear(GL_COLOR_BUFFER_BIT);
  drawLines();
  glFlush();
}</pre></div><p>You will notice that there are four <code class="literal">glVertex</code> calls. Each pair of vertices sets the beginning and ending points of a line. As there are four points defined, the result is that two lines are drawn.</p><div><img src="img/8199OS_02_04.jpg" alt="Stretching your point"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Getting primitive</h2></div></div></div><p>Basic objects, such as points and lines, are called primitives. It would be pretty difficult to create everything <a id="id91" class="indexterm"/>out of points and lines, so OpenGL defines other primitive shapes that you can use to create more complicated objects.</p><p>In this section, we will dig a little under the hood and find out how OpenGL actually creates more realistic images on your screen. It may surprise you that a single, geometric figure is used to create everything from the simplest to the most complex graphics. So, roll up your sleeves and get ready to get a little greasy.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec16"/>A triangle by any other name</h3></div></div></div><p>Have you ever seen a <a id="id92" class="indexterm"/>geodesic dome? Although the dome appears to be spherical, it is actually built out of a combination of triangles. It turns out that triangles are very easy to put together in such a way that you can add a slight amount of curvature to the object. Each triangle can be attached at a slight angle to the others, allowing you to create a dome made out of flat triangles. Also, consider this: the smaller the triangle, the more convincing the end result!</p><div><img src="img/8199OS_02_05.jpg" alt="A triangle by any other name"/></div><p>The basic unit that<a id="id93" class="indexterm"/> is used to draw all modern graphics is the humble triangle. Graphic cards have been specifically engineered to be able to draw triangles—really small triangles—really fast. A typical graphics card can draw millions of triangles every second. Higher end cards reach billions of triangles per second.</p><div><img src="img/8199OS_02_06a.jpg" alt="A triangle by any other name"/></div><p>Remember when we drew points and lines earlier? Each point had one vertex, and each line had two vertices. Of course, each triangle has three vertices.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec17"/>A primitive example</h3></div></div></div><p>It's time to take a look at some code in action. Add the following code after the <code class="literal">drawLines</code> function<a id="id94" class="indexterm"/> in the GLFun project:</p><div><pre class="programlisting">void drawSolidTriangle()
{
  glBegin(GL_TRIANGLES);
  
  glColor3f(0.0f, 0.0f, 1.0f);
  glVertex2f(0.1f, -0.6f);
  glVertex2f(0.7f, -0.6f);
  glVertex2f(0.4f, -0.1f);
  
  glEnd();
}</pre></div><p>Then change the middle line of the <code class="literal">update</code> function to call <code class="literal">drawSolidTriangle</code>:</p><div><pre class="programlisting">void update()
{
  glClear(GL_COLOR_BUFFER_BIT);
  drawSolidTriangle();
  glFlush();
}</pre></div><p>Run the program, and you will see the following output:</p><div><img src="img/8199OS_02_06.jpg" alt="A primitive example"/></div><p>You may notice a similarity between the code for <code class="literal">drawSolidTriangle</code> and <code class="literal">drawPoints</code>. Look closely at the code, and you will see that the three <code class="literal">glVertex</code> functions define the same three points. However, in this case we told OpenGL to draw triangles, not points. You should also take a look at the code and make sure you understand why<a id="id95" class="indexterm"/> the triangle is rendered blue.</p><p>Let's take one more example. Add the following code below the <code class="literal">drawSolidTriangle</code> function:</p><div><pre class="programlisting">void drawGradientTriangle()
{
  glBegin(GL_TRIANGLES);
  
  glColor3f(1.0f, 0.0f, 0.0f);
  glVertex2f(0.3f, -0.4f);
  
  glColor3f(0.0f, 1.0f, 0.0f);
  glVertex2f(0.9f, -0.4f);
  
  glColor3f(0.0f, 0.0f, 1.0f);
  glVertex2f(0.6f, -0.9f);
  
  glEnd();
}</pre></div><p>Be sure to change<a id="id96" class="indexterm"/> the middle line in update to call <code class="literal">drawGradientTriangle</code>:</p><div><pre class="programlisting">void update()
{
  glClear(GL_COLOR_BUFFER_BIT);
  drawGradientTriangle();
  glFlush();
}</pre></div><p>Run the program, and this is what you will see:</p><div><img src="img/8199OS_02_07.jpg" alt="A primitive example"/></div><p>You will immediately notice that this triangle is filled with a gradient instead of a solid color. If you look <a id="id97" class="indexterm"/>closely at the code, you will see that a different color is being set for each vertex. OpenGL then takes care of interpolating the colors between each vertex.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec18"/>From triangles to models</h3></div></div></div><p>Triangles can be put together in an infinite number of ways to form almost any shape imaginable. It is<a id="id98" class="indexterm"/> important to understand that triangles are just geometry. Triangles are used to build the shape of your object. We call these shapes models.</p><p>Building a model using a single triangle at a time would be very time consuming, so 3D graphics programs, such<a id="id99" class="indexterm"/> as <strong>Maya</strong> and <a id="id100" class="indexterm"/>
<strong>Blender</strong>, allow you to create models out more complex shapes (which are themselves built out of triangles). These models can then be loaded into your game and rendered by OpenGL. OpenGL literally sends a the list of points to form these triangles directly to the video card, which then creates and image out of them on the screen. We will see this process in action when we begin to deal with 3D game design.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Introducing textures</h1></div></div></div><p>Images in games are called textures. Textures allow us to use real world images to paint our world. Think about what it would take to create a dirt road. You could either color the triangles in<a id="id101" class="indexterm"/> exactly the right way to make the overall scene look like dirt, or you could apply an actual image (that is, a texture) of dirt to the triangles. Which of these do you think would look more realistic?</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Using textures to fill the triangles</h2></div></div></div><p>Let's say that you <a id="id102" class="indexterm"/>are going to paint your bedroom. You can either use paint to color the walls, or you could buy some wallpaper and put that on your walls. Using images to add color to our triangles is pretty much like using wallpaper to color our bedroom walls. The image is applied to the triangle, giving it a more complex appearance than what could be created by color alone:</p><div><img src="img/8199OS_02_09a.jpg" alt="Using textures to fill the triangles"/></div><p>When we want to get really tricky, we use textures to fill the inside of our triangles instead of colors. A marble texture has been applied to the triangle in the preceding image. You could imagine using this technique to create a marble floor.</p><p>Remember the car we were working with before? It didn't look much like a triangle, did it? In fact, many real-world objects look more like rectangles than triangles:</p><div><img src="img/8199OS_02_10.jpg" alt="Using textures to fill the triangles"/></div><p>It turns out that that all the textures that we use in games are actually rectangles. Imagine that the car that we have been dealing with is actually embedded inside an invisible rectangle, depicted<a id="id103" class="indexterm"/> in the following image as light gray:</p><div><img src="img/8199OS_02_11.jpg" alt="Using textures to fill the triangles"/></div><p>Most graphic programs use a checkerboard background to indicate the areas of the image that are transparent.</p><div><img src="img/8199OS_02_12.jpg" alt="Using textures to fill the triangles"/></div><p>Using rectangles for all of our shapes solves one big problem that you might not have thought of earlier. If you recall, it was very important to position the car at exactly (5, 5). To do so, we decided to place the bottom-left corner of the car at point (5, 5).</p><div><img src="img/8199OS_02_13.jpg" alt="Using textures to fill the triangles"/></div><p>Looking at<a id="id104" class="indexterm"/> the car, it is actually a little difficult to figure out exactly where the bottom-left corner would be. Is it the lower left corner of the bumper, the tire, or somewhere else?</p><div><img src="img/8199OS_02_14.jpg" alt="Using textures to fill the triangles"/></div><p>By embedding the car inside of a rectangle, as we just discussed, the problem is immediately solved.</p><div><img src="img/8199OS_02_15.jpg" alt="Using textures to fill the triangles"/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>A matter of reference</h2></div></div></div><p>When working with a texture, it is very important to know what point is being used as a reference, usually known as the pivot point. In the following images, a black dot is used to represent the pivot point. The pivot point affects two critical issues. First, the pivot point determines <a id="id105" class="indexterm"/>exactly where the image will be placed on the screen. Second, the pivot point is the point on which the image will pivot when rotated.</p><p>Compare the two scenarios depicted in the following images:</p><div><img src="img/8199OS_02_18.jpg" alt="A matter of reference"/></div><p>The pivot point for the car in the preceding image has been set to the bottom-left corner of the image. The car has been rotated 90 degrees counter-clockwise.</p><div><img src="img/8199OS_02_19.jpg" alt="A matter of reference"/></div><p>The pivot point<a id="id106" class="indexterm"/> for the car in the preceding image has been set to the center of the image. The car has been rotated 90 degrees counter-clockwise. Notice how the pivot point affects not only how the car is rotated but also its final position in relation to its original position after the rotation is completed.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Hanging out in the quad</h2></div></div></div><p>So, are you confused yet? First, I tell you that the most basic shape used to create images is a triangle, and then I tell you that all textures are actually rectangles. Which one is it?</p><p>Just then, your <a id="id107" class="indexterm"/>high-school geometry teacher silently walks into the room, goes up to the chalkboard that just magically appeared on your wall, and draws something like the following diagram:</p><div><img src="img/8199OS_02_21.jpg" alt="Hanging out in the quad"/></div><p>Of course! You suddenly realize that two triangles can be fit together to form a rectangle. In fact, this arrangement is<a id="id108" class="indexterm"/> so useful that we have given it a name: <strong>quad</strong>.</p><p>When it comes to<a id="id109" class="indexterm"/> 2D graphics, the quad is the king.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec19"/>Coding the quad</h3></div></div></div><p>It's time to take a<a id="id110" class="indexterm"/> look at some code. Add the following code beneath the<a id="id111" class="indexterm"/> <code class="literal">drawGradientTriangle</code> function in <code class="literal">GLFun</code>:</p><div><pre class="programlisting">void drawQuad()
{
  glBegin(GL_QUADS);
  
  glColor3f(0.0f, 1.0f, 0.0f);
  glVertex2f(0.1f, -0.1f);
  glVertex2f(0.1f, -0.6f);
  glVertex2f(0.6f, -0.6f);
  glVertex2f(0.6f, -0.1f);
  
  glEnd();
}</pre></div><p>As usual, change the middle line in update to call <code class="literal">drawQuad</code>. Run the program, and you will get a pretty green square, er quad! It's important to note that the points are defined in order starting from the upper-left corner and then moving counter-clockwise in order.</p><div><img src="img/8199OS_02_22.jpg" alt="Coding the quad"/></div><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>The order that the points are defined in is known as <em>winding</em>. By default, a counter-clockwise<a id="id112" class="indexterm"/> winding tells OpenGL that the side facing out is the side that is considered the front. This helps determine, among other things, whether this face should be lit, and it <a id="id113" class="indexterm"/>becomes even more significant when we begin working in 3D. As it turns out, GLUT simplifies our life so that it doesn't matter if we use clockwise or counter-clockwise winding when using GLUT.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Rendering a texture</h2></div></div></div><p>Rendering<a id="id114" class="indexterm"/> a texture consist of two steps: loading the image and rendering the image using an OpenGL primitive. Our final achievement in this chapter will be to modify GLFun so that it will render a texture using a quad.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec20"/>Loading the texture</h3></div></div></div><p>Our first step is to create a function to load a texture. As it turns out, this isn't all that easy. So, I'm <a id="id115" class="indexterm"/>going to give you the code for a function that loads a 24-bit BMP file, and we'll treat it like a black box that you can use in your own code.</p><p>Add this code to the top of your existing <code class="literal">GLFun</code> code:</p><div><pre class="programlisting">  GLuint texture;
  #pragma warning(disable: 4996)
  bool loadTexture(const char* filename)
  {
    unsigned char header[54];
    unsigned char* data;
    int dataPos;
    int width;
    int height;
    int imageSize;
    
    FILE * file = fopen(filename, "rb");
    if (!file) return false;
    if (fread(header, 1, 54, file) != 54) return false;
    if (header[0] != 'B' || header[1] != 'M') return false;
    
    dataPos = *(int*)&amp;(header[0x0A]);
    imageSize = *(int*)&amp;(header[0x22]);
    width = *(int*)&amp;(header[0x12]);
    height = *(int*)&amp;(header[0x16]);
    
    if (imageSize == 0) imageSize = width*height * 3;
    if (dataPos == 0) dataPos = 54;
    
    data = new unsigned char[imageSize];
    fread(data, 1, imageSize, file);
    fclose(file);
    
    glGenTextures(1, &amp;texture);
    glBindTexture(GL_TEXTURE_2D, texture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    return true;
  }</pre></div><p>Add these lines of code to <code class="literal">initGL</code>:</p><div><pre class="programlisting">glEnable(GL_TEXTURE_2D);
glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);</pre></div><p>We are not going to dissect this piece of code line by line. In brief, it opens the image file, extracts the first 54 bytes of the file (the bmp header data), and stores the rest of the file as image data. A few OpenGL calls are made to assign this data to an OpenGL texture and that's it.</p><p>You need to have <a id="id116" class="indexterm"/>a call that loads the texture in, so add this line of code to <code class="literal">_tmain</code> just after the call to <code class="literal">initGL</code>:</p><div><pre class="programlisting">loadTexture("car.bmp"); </pre></div><p>Of course, replace <code class="literal">car.bmp</code> with the file that you want to load in. Ensure that you have placed the appropriate graphic files in the source code folder.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec21"/>Texture wrapping</h3></div></div></div><p>In order to display a<a id="id117" class="indexterm"/> texture on the screen, OpenGL maps the texture onto another primitive. This process is known as texture wrapping. As textures are rectangular, it makes sense to map the texture onto a quad.</p><p>The following image shows a texture the way that OpenGL sees it: a rectangle with four texture coordinates:</p><div><img src="img/8199OS_02_23.jpg" alt="Texture wrapping"/></div><p>The upper-left is texture coordinate <strong>0, 0</strong>. The lower-right is texture coordinate <strong>1, 1</strong>. You should be able to identify the texture coordinates of the other corners.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>It might make<a id="id118" class="indexterm"/> it easier to conceptualize OpenGL numbers if you convert them to percentage, where 0 is zero percent and 1 is 100 percent. For example, you can think of the lower-left corner as being zero percent of the width of the texture and one-hundred percent of the height of the texture.</p></div></div><p>In order to render a texture, we overlay it (or wrap it) onto a quad. So, let's say we have the following quad defined:</p><div><img src="img/8199OS_02_24.jpg" alt="Texture wrapping"/></div><p>We could map the texture<a id="id119" class="indexterm"/> coordinates to the quad coordinates:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Texture Coordinate</p>
</th><th style="text-align: left" valign="bottom">
<p>Maps to</p>
</th><th style="text-align: left" valign="bottom">
<p>Quad Coordinate</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>0, 0</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>0, 0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1, 0</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>1, 0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1, 0</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>1, 0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>0, 1</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>0, 1</p>
</td></tr></tbody></table></div><p>The following figure shows this graphically:</p><div><img src="img/8199OS_02_25.jpg" alt="Texture wrapping"/></div><p>In its simplest form, texture wrapping is the process of mapping the corners of a texture to the corners of a <a id="id120" class="indexterm"/>quad.</p><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>You will see texture wrapping also referred to as <em>uv</em> wrapping. I always tried to figure out what <em>uv</em> meant! Here's the real story: <em>x</em> and <em>y</em> were already used to refer to the quad coordinates, and we had to have something else to call the texture coordinates, so some bright person said, "Let's use u and v!"</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec22"/>Creating a textured quad</h3></div></div></div><p>Now, we will<a id="id121" class="indexterm"/> write the code to render a textured quad. Add the following function to the code:</p><div><pre class="programlisting">void drawTexture()
{
  glBindTexture(GL_TEXTURE_2D, texture);
  glBegin(GL_QUADS);
  glTexCoord2d(0.0, 0.0); glVertex2d(0.0, 0.0);
  glTexCoord2d(1.0, 0.0); glVertex2d(0.5, 0.0);
  glTexCoord2d(1.0, 1.0); glVertex2d(0.5, 0.5);
  glTexCoord2d(0.0, 1.0); glVertex2d(0.0, 0.5);
  glEnd();
}</pre></div><p>Here is what this code does:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">glBindTexture(GL_TEXTURE_2D, texture)</code>: Even if we have thousands of textures in a game, OpenGL can only work with one texture a time. The call to <code class="literal">glBindTexture</code> tells OpenGL which texture we are working with right now. Each time a texture is created, OpenGL assigns a number to that texture, called the texture handle.<p>When we loaded our bitmap, we used the <code class="literal">glGenTextures(1, &amp;texture)</code> command, which instructed OpenGL to generate one texture and save the handle into the variable called texture. We then pass this value into the <code class="literal">glBindTexture</code> function, along with a flag that tells OpenGL that we are working with a 2D texture.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">glTexCoord2d(0.0, 0.0); glVertex2d(0.0, 0.0)</code>: We put these two lines together because they work together. You should recognize the call to <code class="literal">glVertex2d</code>. This function tells OpenGL how to wrap the texture onto the quad (you should also recognize that we are drawing a quad because we set that up in the<a id="id122" class="indexterm"/> previous line of code).</li><li class="listitem" style="list-style-type: disc">Each call to <code class="literal">glTexCoord2d</code> defines a texture coordinate. The very next line of code maps the texture coordinate to a quad coordinate. The order is essential: first define a texture coordinate, then define the corresponding quad coordinate.</li></ul></div><p>By the way, don't forget to replace the middle line of code in update with the following line of code:</p><div><pre class="programlisting">drawTexture();</pre></div><p>Now, run the program!</p><div><img src="img/8199OS_02_26.jpg" alt="Creating a textured quad"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Putting the pieces together</h1></div></div></div><p>The following image is a <a id="id123" class="indexterm"/>composite that illustrates most of the concepts we have covered so far. See if you can you identify the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The transparent areas</li><li class="listitem" style="list-style-type: disc">The triangles</li><li class="listitem" style="list-style-type: disc">The vertices</li><li class="listitem" style="list-style-type: disc">The pivot point</li><li class="listitem" style="list-style-type: disc">The texture</li><li class="listitem" style="list-style-type: disc">The quad</li></ul></div><div><img src="img/8199OS_02_27.jpg" alt="Putting the pieces together"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Summary</h1></div></div></div><p>This chapter has covered the core concepts that are required to display images on your screen. We started by discussing the OpenGL coordinate system for a 2D game. The coordinate system allows you to place objects on the screen. This was followed by a discussion about the camera, OpenGL's way of viewing objects that appear on your screen.</p><p>Next, you learned how triangles and quads are used to create simple graphics, and how textures can be applied to these primitives to render 2D images to the screen.</p><p>You could finally see an image on your screen that has been rendered by OpenGL. As they say, a picture is worth a thousand lines of code!</p><p>In the next chapter, you will learn how to turn your still photography into moving pictures through the wonder of animation!</p></div></body></html>