- en: Chapter 6. Sensing the World – Feeling with Analog Inputs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章：感知世界——用模拟输入感觉
- en: The real world isn't digital. My digital-art-based vision shows me *The Matrix*
    behind things and huge digital waterfalls between things. In this chapter, however,
    I need to convey to you the relationship between digital and analog, and we need
    to understand it well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的世界并不是数字的。基于数字艺术的我的视野让我看到了事物背后的**矩阵**以及事物之间巨大的数字瀑布。然而，在这一章中，我需要向你传达数字和模拟之间的关系，并且我们需要很好地理解它。
- en: This chapter is a good one but a huge one. Don't be afraid. We'll also discuss
    new concepts a lot while writing and designing pure C++ code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这章很好，但很大。不要害怕。我们还将在设计纯C++代码的同时讨论很多新概念。
- en: We are going to describe together what analog inputs are. I'm also going to
    introduce you to a new and powerful friend worthy of respect, Max 6 framework.
    Indeed, it will help us a bit like Processing did—to communicate with the Arduino
    board. You'll realize how important this is for computers, especially when they
    have to sense the world. A computer with the Max 6 framework is very powerful,
    but a computer with the Max 6 framework and the Arduino plugin can feel much characteristics
    of the physical world, such as pressure, temperature, light, color, and many more.
    Arduino, as we have already seen, behaves a bit like a very powerful organ able
    to…*feel*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一起描述什么是模拟输入。我还会向你介绍一个值得尊重的新朋友，Max 6 框架。确实，它将帮助我们像Processing一样与Arduino板通信。你会意识到这对计算机来说有多重要，尤其是当它们需要感知世界时。拥有Max
    6框架的计算机非常强大，但拥有Max 6框架和Arduino插件的计算机可以感受到物理世界的许多特性，如压力、温度、光、颜色等等。正如我们之前看到的，Arduino表现得有点像一个能够…*感觉*的非常强大的器官。
- en: If you like this concept of feeling things, and especially that of making other
    things react to these feelings, you'll love this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这种感知事物的概念，尤其是让其他事物对这些感觉做出反应的概念，你将喜欢这一章。
- en: Sensing analog inputs and continuous values
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感知模拟输入和连续值
- en: There's no better way to define analog than by comparing it to digital. We just
    talked about digital inputs in the previous chapter, and you now know well about
    the only two values those kind of inputs can read. It is a bit exhausting to write
    it, and I apologize because this is indeed more a processor constraint than a
    pure input limitation. By the way, the result is that a digital input can only
    provide 0 or 1 to our executed binary firmware.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 没有比将其与数字比较更好的方法来定义模拟了。我们刚刚在上一章中讨论了数字输入，你现在很清楚这类输入可以读取的唯一两个值。写起来有点累人，我为此道歉，因为这确实更多的是处理器限制，而不是纯输入限制。顺便说一句，结果是数字输入只能向我们执行的二进制固件提供0或1。
- en: Analog works totally differently. Indeed, analog inputs can continuously provide
    variable values by measuring voltage from 0 V to 5 V. It means a value of 1.4
    V and another value of 4.9 V would be interpreted as totally different values.
    This is very different from a digital input that could interpret them as…1\. Indeed,
    as we already saw, a voltage value greater than 0 is usually understood as 1 by
    digital inputs. 0 is understood as 0, but 1.4 would be understood as 1; this we
    can understand as HIGH, the ON value, as opposed to the OFF, which comes from
    the 0 V measure.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的工作方式完全不同。确实，模拟输入可以通过测量从0V到5V的电压来连续提供可变值。这意味着1.4V和4.9V的值将被解释为完全不同的值。这与数字输入将它们解释为…1的情况非常不同。确实，正如我们之前看到的，电压值大于0通常被数字输入理解为1。0被理解为0，但1.4会被理解为1；我们可以将其理解为HIGH，即开启值，相对于来自0V测量的OFF。
- en: Here, in the continuous world of analog inputs, we can sense a flow between
    the different values, where digital inputs can provide only steps. This is one
    of the reasons why I'm always using the term "feeling". Yes, when you can measure
    a lot of values, this is near to sensing and feeling. This is a bit of humanization
    of the electronic hardware, and I totally assume that.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个连续的模拟输入世界中，我们可以感受到不同值之间的流动，而数字输入只能提供步骤。这就是我总是使用“感觉”这个术语的原因之一。是的，当你能测量很多值时，这几乎就是感觉和感知。这是对电子硬件的一点点人性化，我完全相信这一点。
- en: How many values can we distinguish?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们可以区分多少个值？
- en: The term "a lot" isn't precise. Even if we are in a new continuous field of
    measure, we are still in the digital world, the one of the computers. So how many
    values can be distinguished by Arduino's analog inputs? 1024.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: “很多”这个术语并不精确。即使我们处于一个新的连续测量领域，我们仍然处于数字世界，即计算机的世界。那么Arduino的模拟输入可以区分多少个值呢？1024。
- en: Why 1024? The reason is easy to understand if you understand how Arduino can
    feel continuous values.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是1024？如果你理解了Arduino如何感知连续值，这个原因很容易理解。
- en: Because Arduino's chip works in the digital domain for all calculations, we
    have to convert analog values from 0 V to 5 V to a digital one. The purpose of
    the **analog-to-digital converter** , housed within the chipset itself, is exactly
    this. This device is also referred to using the acronym ADC.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Arduino的芯片在数字域进行所有计算，我们必须将0V到5V的模拟值转换为数字。内置芯片组中的**模数转换器**的目的正是如此。这个设备也被称为ADC的缩写。
- en: Arduino's ADCs have a 10-bit resolution. This means that every analog value
    is encoded and mapped to a 10-bit, encoded integer value. The maximum number encodable
    using this encoding system is 1111111111 in the binary system, which means 1023
    in the decimal system. If I consider the first number to be 0, we have a total
    of 1024 values represented. A 1024-value resolution provides a very comfortable
    field of sensing as we are going to see in the next few pages.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino的ADC具有10位分辨率。这意味着每个模拟值都被编码并映射到一个10位的编码整数。使用这种编码系统可编码的最大数字是二进制的1111111111，即十进制的1023。如果我把第一个数字视为0，我们就有1024个值表示。1024值的分辨率提供了一个非常舒适的感知范围，正如我们将在下一页看到的那样。
- en: Let's see how we can use these precious inputs with Arduino.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用这些宝贵的输入与Arduino一起使用。
- en: Reading analog inputs
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取模拟输入
- en: Because we are now more familiar with circuits and code, we can work with a
    small project while still explaining concepts. I'm going to describe a simple
    example of circuits and code using a **potentiometer** only.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们现在对电路和代码更熟悉了，我们可以在解释概念的同时进行一个小项目。我将描述一个仅使用**电位器**的简单电路和代码示例。
- en: The real purpose of the potentiometer
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电位器的真正目的
- en: First, let's grab a potentiometer. A potentiometer is, if you remember correctly
    from the first chapter of this book, a variable resistor.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们拿一个电位器。如果你记得这本书的第一章，电位器是一个可变电阻。
- en: 'Considering Ohm''s law, which links voltage, current, and resistance value,
    we can understand that, for a constant current, we can make the voltage vary by
    changing the value of the resistance of the potentiometer. Indeed, because some
    of us haven''t dusted off our elementary electronics course textbook in many years,
    how about a refresher? Here''s Ohm''s law:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到欧姆定律，它将电压、电流和电阻值联系起来，我们可以理解，对于恒定电流，我们可以通过改变电位器的电阻值来改变电压。实际上，因为有些人多年没有翻阅我们的基础电子课程教科书，我们不妨复习一下？以下是欧姆定律：
- en: V = R * I
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: V = R * I
- en: Here, V is the voltage in Volts, R the resistance in Ohms, and I the current
    in Amperes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，V是电压（伏特），R是电阻（欧姆），I是电流（安培）。
- en: 'So now, to define the purpose of a potentiometer:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，为了定义电位器的目的：
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The potentiometer is your way to change continuously a variable in your running
    code from the physical world.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 电位器是你在运行代码中从物理世界连续改变变量的方法。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Always remember:**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**始终记住：**'
- en: Use 10-bit resolution, and you'll be the master of analog inputs!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用10位分辨率，你将成为模拟输入的大师！
- en: Changing the blinking delay of an LED with a potentiometer
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用电位器改变LED的闪烁延迟
- en: 'The following figure is the most basic circuit to illustrate the concept of
    analog inputs with the Arduino board:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是说明Arduino板上模拟输入概念的最基本电路：
- en: '![Changing the blinking delay of an LED with a potentiometer](img/7584_06_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![使用电位器改变LED的闪烁延迟](img/7584_06_01.jpg)'
- en: A potentiometer connected to the Arduino board
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个连接到Arduino板上的电位器
- en: 'Check the corresponding electrical diagram for connections:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 检查相应的电气图以了解连接：
- en: '![Changing the blinking delay of an LED with a potentiometer](img/7584_06_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![使用电位器改变LED的闪烁延迟](img/7584_06_02.jpg)'
- en: Analog input 0 is measuring the voltage
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟输入0正在测量电压
- en: Now let's see the code we have to use.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们必须使用的代码。
- en: Like the function `digitalRead()`, which can read the value of digital inputs
    on the Arduino, there is `analogRead()` for doing the same with analog inputs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`digitalRead()`函数可以读取Arduino上的数字输入值一样，还有`analogRead()`用于读取模拟输入。
- en: The intention here is to read the value as a pause value in our program for
    the purpose of controlling the blink rate of an LED. In code, we'll be using the
    `delay()` function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的是将值作为程序中的暂停值来读取，以控制LED的闪烁速率。在代码中，我们将使用`delay()`函数。
- en: 'Here''s an example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Upload the code. Then turn the pot a bit, and observe the output.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上传代码。然后转动电位器一点，观察输出。
- en: After the variable definition, I'm defining the `ledPin` pin as output in the
    `setup()` function in order to be able to drive current to this pin. Actually,
    I'm using pin 13 in order to simplify our tests. Don't forget pin 13 is the surface-mounted
    LED on the Arduino board.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 变量定义之后，我在`setup()`函数中将`ledPin`引脚定义为输出，以便能够驱动电流到这个引脚。实际上，我正在使用引脚13来简化我们的测试。别忘了引脚13是Arduino板上的表面贴装LED。
- en: Then, the magic happens in the `loop()` function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`loop()`函数中发生神奇的事情。
- en: I'm first reading the value at the `potPin` pin. As we discussed before, the
    value returned by this function is an integer between 0 and 1023\. I'm storing
    it in the `potValue` variable to keep the LED ON, but also to keep it OFF.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先读取`potPin`引脚的值。正如我们之前讨论的，这个函数返回的值是一个介于0和1023之间的整数。我将它存储在`potValue`变量中，以保持LED开启，但也以保持LED关闭。
- en: Then, I'm turning OFF and ON the LED with some delay between status changes.
    The smart thing here is to use `potValue` as the delay. Turned on one side completely,
    the potentiometer provides a value of 0\. Turned on the other side completely,
    it provides 1023, which is a reasonable and user-friendly delay value in milliseconds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我通过在状态变化之间设置一些延迟来打开和关闭LED。这里聪明的地方是使用`potValue`作为延迟。完全打开一边时，电位计提供一个值为0。完全打开另一边时，它提供一个1023，这是一个合理且用户友好的毫秒延迟值。
- en: The higher the value is, the longer the delay.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 值越高，延迟越长。
- en: In order to be sure you understood the physical part of this, I'd like to explain
    a bit more about voltage.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你理解了物理部分，我想再解释一下电压。
- en: The +5 V and ground pins of the Arduino supply the potentiometer the voltage.
    Its third leg provides a way to vary the voltage by varying the resistance. The
    Arduino's analog inputs are able to read this voltage. Please notice that analog
    pins on the Arduino are inputs only. This is also why, with analog pins, we don't
    have to worry about precision in the code like we have for digital pins.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino的+5V和地引脚为电位计提供电压。它的第三条腿提供了一种通过改变电阻来改变电压的方法。Arduino的模拟输入能够读取这个电压。请注意，Arduino上的模拟引脚仅是输入。这也是为什么，与数字引脚相比，我们不需要在代码中担心精度。
- en: So let's modify the code a bit in order to read a voltage value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们修改一下代码，以便读取电压值。
- en: How to turn the Arduino into a low voltage voltmeter?
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何将Arduino变成低电压电压表？
- en: Measuring voltage requires two different points on a circuit. Indeed, a voltage
    is an electrical potential. Here, we have (only) that analog pin involved in our
    circuit to measure voltage. What's that ?!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测量电压需要一个电路上的两个不同点。确实，电压是一种电势。在这里，我们只有那个参与我们电路测量电压的模拟引脚。那是什么？!
- en: Simple! We're using the +5 V supply from Vcc as a reference. We control the
    resistance provided by the potentiometer and supply the voltage from the Vcc pin
    to have something to demonstrate.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 简单！我们正在使用Vcc的+5V电源作为参考。我们控制电位计提供的电阻，并从Vcc引脚供电，以便有所展示。
- en: If we want to use it as a real potentiometer, we have to supply another part
    of a circuit with Vcc too, and then connect our A0 pin to another point of the
    circuit.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将其用作真正的电位计，我们必须给电路的另一个部分也提供Vcc，然后将我们的A0引脚连接到电路的另一个点。
- en: As we saw, the `analogRead()` function only provides integers from 0 to 1023\.
    How can we have real electrical measures displayed somewhere?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`analogRead()`函数只提供从0到1023的整数。我们如何将实际的电测量显示在某个地方？
- en: 'Here''s how it works:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的工作原理：
- en: 'The range 0 to 1023 is mapped to 0 to 5V. That comes built into the Arduino.
    We can then calculate the voltage as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 范围0到1023映射到0到5V。这是Arduino内置的。然后我们可以按照以下方式计算电压：
- en: V = 5 * (analogRead() value / 1023)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: V = 5 * (analogRead()值 / 1023)
- en: 'Let''s implement it and display it on our computer by using the serial monitor
    of the Arduino IDE:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现它，并通过使用Arduino IDE的串行监视器将其显示在我们的计算机上：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code is almost the same as the previous code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码几乎与之前的代码相同。
- en: 'I added a variable to store the calculated voltage. I also added the serial
    communication stuff, which you see all the time: `Serial.begin(9600)` to instantiate
    the serial communication and `Serial.println()` to write the current calculated
    voltage value to the serial communication port, followed by a carriage return.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个变量来存储计算出的电压。我还添加了串行通信的内容，你总是能看到：`Serial.begin(9600)`实例化串行通信，`Serial.println()`将当前计算出的电压值写入串行通信端口，后面跟着一个换行符。
- en: In order to see a result on your computer, you have to turn on the serial monitor,
    of course. Then, you can read the voltage values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在你的电脑上看到结果，你必须当然打开串行监视器。然后，你可以读取电压值。
- en: Calculating the precision
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算精度
- en: Please note that we are using an ADC here in order to convert an analog value
    to digital; then, we are making a small calculation on that digital value in order
    to have a voltage value. This is a very expensive method compared to a basic analog
    voltage controller.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里使用ADC是为了将模拟值转换为数字；然后，我们对这个数字值进行小计算，以获得电压值。与基本模拟电压控制器相比，这是一个非常昂贵的方法。
- en: It means our precision depends on the ADC itself, which has a resolution of
    10 bits. It means we can only have 1024 values between 0 V and 5 V. 5 divided
    by 1024 equals 0.00488, which is approximated.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的精度取决于ADC本身，它具有10位的分辨率。这意味着我们只能在0 V和5 V之间有1024个值。5除以1024等于0.00488，这是一个近似值。
- en: It basically means we won't be able to distinguish between values such as 2.01
    V and 2.01487 V, for instance. However, it should be precise enough for the purposes
    of our learning.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上意味着我们无法区分像2.01 V和2.01487 V这样的值。然而，对于我们的学习目的来说，这应该足够精确。
- en: Again, it was an example because I wanted to point out to you the precision/resolution
    concept. You have to know and consider it. It will prove very important and could
    deliver strange results in some cases. At least, you have been warned.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一个例子，因为我想向你指出精度/分辨率的概念。你必须了解并考虑它。它在某些情况下可能会证明非常重要，并可能产生奇怪的结果。至少，你已经得到了警告。
- en: Let's discover another neat way of interacting with the Arduino board.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索另一种与Arduino板交互的巧妙方式。
- en: Introducing Max 6, the graphical programming framework
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Max 6，图形编程框架
- en: Now, let me introduce you to the framework known as Max 6\. This is a whole
    universe in itself, but I wanted to write some pages about it in this book because
    you'll probably come across it in your future projects; maybe you'll be a Max
    6 developer one day, like me, or perhaps you'll have to interface your smart physical
    objects with Max 6-based systems.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我向你介绍一个名为Max 6的框架。这本身就是一个宇宙，但我想在本书中写一些关于它的内容，因为你在未来的项目中可能会遇到它；也许有一天你将成为像我一样的Max
    6开发者，或者你可能需要将你的智能物理对象与基于Max 6的系统进行接口。
- en: 'The following is one of the patches of my 3D universe project with Max 6:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我3D宇宙项目中的一个Max 6补丁：
- en: '![Introducing Max 6, the graphical programming framework](img/7584_06_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![介绍Max 6，图形编程框架](img/7584_06_03.jpg)'
- en: A brief history of Max/MSP
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Max/MSP简史
- en: Max is a visual programming language for multimedia purposes. It is actually
    developed and maintained by Cycling '74\. Why call it Max? It was named after
    Max Matthews ([http://en.wikipedia.org/wiki/Max_Mathews](http://en.wikipedia.org/wiki/Max_Mathews)),
    one of the great pioneers of computer music.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Max是一种用于多媒体目的的视觉编程语言。它实际上由Cycling '74开发和维护。为什么叫Max？它是以Max Matthews的名字命名的（[http://en.wikipedia.org/wiki/Max_Mathews](http://en.wikipedia.org/wiki/Max_Mathews)），他是计算机音乐的大先驱之一。
- en: The original version of Max was written by Miller Puckette; it was initially
    an editor named Patcher for Macintosh. He wrote it at **The European Institut
    de Recherche et Coordination Acoustique/Musique** (**IRCAM**), an avant-garde
    science institute based near the Centre Pompidou in Paris, France.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Max的原始版本是由Miller Puckette编写的；最初是一个名为Patcher的Macintosh编辑器。他在**欧洲声学/音乐研究协调院**（**IRCAM**）编写了它，这是一个位于法国巴黎蓬皮杜中心附近的前卫科学研究所。
- en: In 1989, the software was licensed by IRCAM to Opcode Systems, a private company,
    and ever since then, has been developed and extended by David Zicarelli. In the
    mid-'90s, Opcode Systems ceased all development for it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 1989年，该软件由IRCAM许可给了一家私营公司Opcode Systems，从那时起，它就由David Zicarelli开发和扩展。在20世纪90年代中期，Opcode
    Systems停止了所有对该软件的开发。
- en: Puckette released a totally free and open source version of Max named Pure Data
    (often seen as Pd). This version is actually used a lot and maintained by the
    community that uses it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Puckette发布了一个完全免费和开源的Max版本，名为Pure Data（通常简称为Pd）。这个版本实际上被广泛使用，并由使用它的社区维护。
- en: Around 1997, a whole module dedicated to sound processing and generation has
    been added, named **MSP** , for **Max Signal Processing** and, apparently, for
    the initials of Miller S. Puckette.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在1997年，一个专门用于声音处理和生成的模块被添加进来，命名为**MSP**，代表**Max Signal Processing**，显然也是为了纪念Miller
    S. Puckette。
- en: Since 1999, the framework commonly known as Max/MSP has been developed and distributed
    by Cycling '74, Mr. Zicarelli's company.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 自1999年以来，通常被称为Max/MSP的框架由Cycling '74公司开发和发行，这是Zicarelli先生的公司的产品。
- en: Because the framework architecture was very flexible, some extensions have progressively
    been added, such as Jitter (a huge and efficient visual synthesis), Processing,
    real-time matrix calculations modules, and 3D engine too. This happened around
    2003\. At that time, Jitter was released and could be acquired separately but
    required Max, of course.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于框架架构非常灵活，一些扩展逐渐被添加，例如Jitter（一个巨大且高效的视觉合成）、Processing、实时矩阵计算模块，以及3D引擎。这发生在2003年左右。当时，Jitter被发布并可以单独获取，但当然需要Max。
- en: In 2008, a major update was released under the name Max 5\. This version too
    did not include Jitter natively but as an add-on module.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年，发布了名为Max 5的重大更新。这个版本也没有原生包含Jitter，但作为一个附加模块。
- en: 'And the most giant upgrade, in my humble opinion, released in November 2011
    as Max 6, included Jitter natively and provided huge improvements such as:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我谦卑的意见中，最大的升级，也就是2011年11月发布的Max 6，它原生地包含了Jitter，并提供了巨大的改进，例如：
- en: A redesigned user interface
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新设计的用户界面
- en: A new audio engine compatible with 64-bit OSs
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容64位操作系统的新的音频引擎
- en: High-quality sound filter design features
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高质量声音滤波器设计功能
- en: A new data structure
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的数据结构
- en: New movement handling for 3D models
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的3D模型运动处理
- en: New 3D material handling
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的3D材料处理
- en: The Gen extension
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gen扩展
- en: Max 4 was already totally usable and efficient, but I have to give my opinion
    about Max 6 here. Whatever you have to build, interfaces, complex, or easy communication
    protocols including HID-based (**HID**=**human interface device**) USB devices
    such as Kinect, MIDI, OSC, serial, HTTP, and anything else, 3D-based sound engine
    or basic standalone applications for Windows or OS X platform, you can make it
    with Max 6, and it is a safe way to build.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Max 4已经完全可用且高效，但我在这里必须谈谈我对Max 6的看法。无论你需要构建什么，接口、复杂或简单的通信协议，包括基于HID（**HID**=**人机界面设备**）的USB设备，如Kinect、MIDI、OSC、串行、HTTP，以及其他任何东西，基于3D的声音引擎或Windows或OS
    X平台的基本独立应用程序，你都可以用Max 6来制作，而且这是一种安全的方式来构建。
- en: 'Here is my own short history with Max: I personally began to play with Max
    4\. I specially built some macro MIDI interfaces for my first hardware MIDI controllers
    in order to control my software tools in very specific ways. It has taught me
    much, and it opened my mind to new concepts. I use it all the time, for almost
    every part of my artistic creation.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我自己与Max的简短历史：我亲自开始尝试Max 4。我为我的第一个硬件MIDI控制器特别构建了一些宏MIDI接口，以便以非常具体的方式控制我的软件工具。它教会了我很多，并开阔了我的思路。我一直在使用它，几乎用于我艺术创作的每一个部分。
- en: Now, let's understand a little bit more about what Max is.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地了解一下Max是什么。
- en: Global concepts
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局概念
- en: Of course, I hesitated to begin the part about Max 6 in the preceding section.
    But I guess the little story was a good starting point to describing the framework
    itself.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我在上一节中犹豫是否开始介绍Max 6的部分。但我想这个小故事是描述框架本身的良好起点。
- en: What is a graphical programming framework?
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是图形编程框架？
- en: A **graphical programming framework** is a programming language that provides
    a way for users to create programs by manipulating elements graphically instead
    of by typing text.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形编程框架**是一种编程语言，它为用户提供了一种通过图形操作元素而不是通过键入文本来创建程序的方法。'
- en: Usually, graphical programming languages are also called **visual programming
    languages** , but I'll use "graphical" because, to many, "visual" is used for
    the product rendered by frameworks; I mean, the 3D scene for instance. Graphical
    is more related to **GUI** , that is, **graphical user interface**, which is,
    from the developer point of view, our editor interface (I mean, the IDE part).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，图形编程语言也被称为**可视化编程语言**，但我会使用“图形”，因为对许多人来说，“可视化”用于框架渲染的产品；我的意思是，例如3D场景。图形更相关于**GUI**，即**图形用户界面**，从开发者的角度来看，是我们的编辑器界面（我的意思是IDE部分）。
- en: Frameworks using this strong graphical paradigm include many ways of programming
    in which we can find data, data types, operator and functions, input and output,
    and a way of connecting hardware too.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种强大图形范式的框架包括许多编程方式，我们可以从中找到数据、数据类型、操作符和函数、输入和输出，以及连接硬件的方式。
- en: Instead of typing long source codes, you add objects and connect them together
    in order to build software architectures. Think Tinker Toys or Legos.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你不是键入长源代码，而是添加对象并将它们连接起来以构建软件架构。想想Tinker Toys或乐高积木。
- en: A global software architecture, which is a system of objects connected and related
    on our 2D screen, is called **Patch** in the Max world. By the way, other graphical
    programming frameworks use this term too.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Max的世界里，一个全球软件架构，即我们在2D屏幕上连接和相关的对象系统，被称为**Patch**。顺便提一下，其他图形化编程框架也使用这个术语。
- en: If this paradigm can be understood at first as a way of simplification, it is
    not the first purpose, I mean that not only is it easier, but it also provides
    a totally new approach for programmers and non-programmers alike. It also provides
    a new type of support task. Indeed, if we don't program in the same way we patch,
    we don't troubleshoot problems in the same way too.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一开始将这种范式理解为一种简化的方式，那么它并非首要目的，我的意思是，这不仅更容易，而且也为程序员和非程序员提供了全新的方法。它还提供了一种新的支持任务类型。实际上，如果我们编程的方式与修补不同，那么我们解决问题的方式也会不同。
- en: 'I can quote some other major graphical programming software in our fields:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以引用我们领域内的一些其他主要图形化编程软件：
- en: '**Quartz Composer**: This is a graphical rendering framework for OS X and is
    available at [https://developer.apple.com/technologies/mac/graphics-and-animation.html](https://developer.apple.com/technologies/mac/graphics-and-animation.html)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Quartz Composer**：这是一个针对OS X的图形渲染框架，可在[https://developer.apple.com/technologies/mac/graphics-and-animation.html](https://developer.apple.com/technologies/mac/graphics-and-animation.html)找到。'
- en: '**Reaktor**: This is a DSP and MIDI-processing framework by Native Instruments
    and is available at [http://www.native-instruments.com/#/en/products/producer/reaktor-5](http://www.native-instruments.com/#/en/products/producer/reaktor-5)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reaktor**：这是由Native Instruments开发的一个DSP和MIDI处理框架，可在[http://www.native-instruments.com/#/en/products/producer/reaktor-5](http://www.native-instruments.com/#/en/products/producer/reaktor-5)找到。'
- en: '**Usine**: This is a universal audio software for live and studio recording
    and is available at [http://www.sensomusic.com/usine](http://www.sensomusic.com/usine)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Usine**：这是一个适用于现场和录音棚录音的通用音频软件，可在[http://www.sensomusic.com/usine](http://www.sensomusic.com/usine)找到。'
- en: '**vvvv**: This is a real-time video synthesis tool for Windows and is available
    at [http://vvvv.org](http://vvvv.org)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vvvv**：这是一个Windows的实时视频合成工具，可在[http://vvvv.org](http://vvvv.org)找到。'
- en: '**SynthMa****ker**: This is a VST device design for Windows and is available
    at [http://synthmaker.co.uk](http://synthmaker.co.uk)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SynthMa****ker**：这是一个为Windows设计的VST设备，可在[http://synthmaker.co.uk](http://synthmaker.co.uk)找到。'
- en: I'd like to make a special mention of Usine. It is a very interesting and powerful
    framework that provides graphical programming to design patches usable inside
    Usine software itself or even as standalone binaries. But one of the particularly
    powerful features is the fact you can export your patch as a fully-functional
    and optimized VST plugin. **VST** (**Virtual Studio Technology**) is a powerful
    standard created by the Steinberg company. It provides a huge list of specifications
    and is implemented in almost all digital audio workstations. Usine provides a
    one-click-only export feature that packs your graphically programmed patch into
    a standard VST plugin for people who haven't even heard about Usine or patching
    styles. The unique multitouch feature of Usine makes it a very powerful framework
    too. Then, you can even code your own modules using their C++ **SDKs** (**software
    development kits**).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我想特别提一下Usine。这是一个非常有趣且强大的框架，它提供了图形化编程来设计可在Usine软件内部使用或作为独立二进制文件使用的补丁。但其中一个特别强大的功能是，你可以将你的补丁导出为功能齐全且经过优化的VST插件。**VST**（**虚拟工作室技术**）是由Steinberg公司创建的一个强大的标准。它提供了一长串规范，并在几乎所有数字音频工作站中得到实现。Usine提供了一个只需一键即可导出的功能，将你的图形化编程补丁打包成标准VST插件，这对于甚至没有听说过Usine或补丁风格的用户来说非常方便。Usine独特的多点触控功能也使其成为一个非常强大的框架。然后，你甚至可以使用他们的C++
    **SDK**（**软件开发工具包**）来编写自己的模块。
- en: '![What is a graphical programming framework?](img/7584_06_04.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![什么是图形化编程框架？](img/7584_06_04.jpg)'
- en: Usine big patch connecting the real world to many virtual objects
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Usine大补丁连接现实世界与许多虚拟对象
- en: Max, for the playground
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Max，用于游乐场
- en: Max is the playground and the core structure in which everything will be placed,
    debugged, and shown. This is the place where you put objects, connect them together,
    create a user interface (UI), and project some visual rendering too.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Max是游乐场和核心结构，所有内容都将放置在其中，进行调试和展示。这是放置对象、将它们连接起来、创建用户界面（UI）以及进行一些视觉渲染的地方。
- en: 'Here is a screenshot with a very basic patch designed to help you understand
    where things go:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个截图，展示了一个非常基本的补丁设计，旨在帮助你理解事物所在的位置：
- en: '![Max, for the playground](img/7584_06_05.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Max，用于游乐场](img/7584_06_05.jpg)'
- en: A small and easy calculation system patch with Max 6
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用Max 6的小型简单计算系统补丁
- en: As I described, with a graphical programming framework, we don't need to type
    code to make things happen. Here, I'm just triggering a calculation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我描述的那样，使用图形编程框架，我们不需要输入代码来让事情发生。这里，我只是触发了一个计算。
- en: The box with the number **17** inside is a numbox. It holds an integer and it
    is also a UI object, providing a neat way to change the value by dragging and
    dropping with a mouse. You then connect the output of one object to the input
    of another. Now when you change the value, it is sent through the wire to the
    object connected to the numboxes. Magic!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 内部带有数字**17**的盒子是一个numbox。它包含一个整数，它也是一个UI对象，提供了一种通过拖放鼠标来改变值的方式。然后你将一个对象的输出连接到另一个对象的输入。现在当你改变值时，它将通过电线发送到连接到numboxes的对象。魔法！
- en: 'You see two other objects. One with a:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了另外两个对象。一个带有：
- en: '**+** sign inside followed by the number **5**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**+**符号后面跟着数字**5**'
- en: '**-** sign inside followed by the number **3**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-**符号后面跟着数字**3**'
- en: Each one takes the number sent to them and makes the calculation of + 5 and
    - 3 respectively.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都接收发送给它们的数字，并分别进行+ 5和- 3的计算。
- en: You can see two other numboxes displaying basically the resulting numbers sent
    by the objects with the **+** and **–** signs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到另外两个numboxes，它们基本上显示了带有**+**和**–**符号的对象发送的结果数字。
- en: Are you still with me? I guess so. Max 6 provides a very well documented help
    system with all references to each object and is directly available in the playground.
    It is good to tell that to students when you teach them this framework, because
    it really helps the students teach themselves. Indeed, they can be almost autonomous
    in seeking answers to small questions and about stuff they have forgotten but
    don't dare to ask.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你还在吗？我猜是的。Max 6提供了一个非常完善的帮助系统，其中包含了每个对象的全部引用，并且可以直接在playground中直接访问。当你教授这个框架时，告诉学生这一点是很好的，因为它真的有助于学生自学。确实，他们几乎可以自主地寻找答案，无论是关于小问题还是他们已经忘记但不敢问的事情。
- en: Max part provides quite an advanced task scheduler, and some objects can even
    modify priority to, say, `defer` and `deferlow` for a neat granularity of priorities
    inside your patch, for instance, for the UI aspect and the calculation core aspect
    that each require very different scheduling.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Max部分提供了一个相当高级的任务调度器，一些对象甚至可以修改优先级，例如，将`defer`和`deferlow`用于在您的补丁中实现优先级的精细粒度，例如，对于UI方面和计算核心方面，每个方面都需要非常不同的调度。
- en: Max gives us a nifty debugging system too with a console-like window called
    the **Max window**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Max还提供了一个方便的调试系统，它有一个类似于控制台的窗口，称为**Max窗口**。
- en: '![Max, for the playground](img/7584_06_06.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Max，用于playground](img/7584_06_06.jpg)'
- en: The Max window showing debugging information about the expr object's error in
    the patch
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 显示expr对象错误调试信息的Max窗口
- en: 'Max drives many things. Indeed, it is Max that owns and leads the access to
    all modules, activated or not, provides autocompletion when you create new objects,
    and also gives access to many things that can extend the power of Max, such as:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Max驱动很多事情。实际上，是Max拥有并领导了对所有模块的访问，无论是激活的还是未激活的，当你创建新对象时提供自动完成，还提供了访问许多可以扩展Max功能的东西，例如：
- en: JavaScript API to Max itself and specific parts, such as Jitter, too
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript API用于Max本身以及特定部分，例如Jitter
- en: Java through the mxj object that instantiates directly inside Max 6 Java classes
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过mxj对象在Max 6中直接实例化Java类
- en: MSP core engine for everything related to signal rate stuff, including audio
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSP核心引擎用于与信号速率相关的一切，包括音频
- en: Jitter core engine for everything related to matrix processing and much more,
    such as visuals and video
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jitter核心引擎用于与矩阵处理相关的一切，以及更多，例如视觉和视频
- en: Gen engine for efficient and on-the-fly code compilation directly from the patch
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gen引擎用于从补丁中直接进行高效和即时的代码编译
- en: This is not an exhaustive list, but it gives you an insight of what Max provides.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个详尽的列表，但它让你了解了Max提供了什么。
- en: Let's check the other modules.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查其他模块。
- en: MSP, for sound
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MSP，用于声音
- en: Where Max objects communicate by sending messages triggered by user or by the
    scheduler itself, MSP is the core engine that calculates signals at any particular
    instant, as written in the documentation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Max对象通过用户或调度器本身触发的消息进行通信时，MSP是核心引擎，它在任何特定时刻计算信号，正如文档中所写。
- en: Even if we can patch (or connect) MSP objects in the same way as pure Max objects,
    the concept underneath is different. At each moment, a signal element is calculated,
    making an almost continuous data flow through what we call a signal network. The
    signal network is easy to identify in the patcher window; the wires are different.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们可以像纯Max对象一样连接MSP对象，但背后的概念是不同的。在每一个时刻，都会计算一个信号元素，通过我们所说的信号网络形成一个几乎连续的数据流。信号网络在补丁窗口中很容易识别；线缆是不同的。
- en: 'Here is an image of a very simple patch producing a cosine-based audio wave
    in your ears:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一张非常简单的补丁图，在你的耳朵里产生基于余弦的音频波：
- en: '![MSP, for sound](img/7584_06_07.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![MSP，用于声音](img/7584_06_07.jpg)'
- en: Indeed, even the patch cords have a different look, showing cool, striped yellow-and-black,
    bee-like colors, and the names of the MSP objects contain a tilde `~` as a suffix,
    symbolizing…a wave of course!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，甚至补丁线也有不同的外观，展现出酷炫的条纹状黄黑色，类似蜜蜂的颜色，MSP对象的名称后面包含一个波浪线 `~` 作为后缀，象征着……当然是一波！
- en: The signal rate is driven by the audio sampling rate and some dark parameters
    in the MSP core settings window. I won't describe that, but you have to know that
    Max usually provides, by default, parameters related to your soundcard, which
    include the sampling rate (44110 Hz, the standard sampling rate for audio CDs,
    means a fast processing rate of 44100 times per second for each audio channel).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 信号速率由音频采样率和MSP核心设置窗口中的某些暗参数驱动。我不会描述这些，但你需要知道，Max通常默认提供与你的声卡相关的参数，包括采样率（44110
    Hz，音频CD的标准采样率，意味着每个音频通道每秒以44100次的速度进行快速处理）。
- en: '![MSP, for sound](img/7584_06_08.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![MSP，用于声音](img/7584_06_08.jpg)'
- en: The Audio Status window is the place where you set up some important MSP parameters
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 音频状态窗口是设置一些重要MSP参数的地方
- en: Jitter, for visuals
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jitter，用于视觉效果
- en: Jitter is the core engine for everything related to visual processing and synthesis
    in Max 6.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Jitter是Max 6中与视觉处理和合成相关的所有事物的核心引擎。
- en: It provides a very efficient framework of matrix processing initially designed
    for fast pixel value calculations to display pictures, animated or not.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了一个非常高效的矩阵处理框架，最初是为快速像素值计算而设计的，用于显示图片，无论是有动画的还是没有的。
- en: We are talking about matrix calculation for everything related with Jitter processing
    matrices. And indeed, if you need to trigger very fast calculations of huge arrays
    in Max 6, you can use Jitter for that, even if you don't need to display any visuals.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在谈论与Jitter处理矩阵相关的一切的矩阵计算。实际上，如果你需要在Max 6中触发快速计算大量数组，即使你不需要显示任何视觉效果，你也可以使用Jitter来做这件事。
- en: Jitter provides much more than only matrix calculation. It gives full access
    to an OpenGL ([http://en.wikipedia.org/wiki/OpenGL](http://en.wikipedia.org/wiki/OpenGL))
    implementation that works at the speed of the light. It also provides a way for
    designing and handling particle systems, 3D worlds, OpenGL materials, and physics-based
    animation. Pixel processing is also one of the powerful features provided with
    many objects designed and optimized for pixel processing itself.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Jitter提供的不仅仅是矩阵计算。它提供了对OpenGL ([http://en.wikipedia.org/wiki/OpenGL](http://en.wikipedia.org/wiki/OpenGL))
    实现的完全访问，该实现以光速运行。它还提供了一种设计和处理粒子系统、3D世界、OpenGL材质和基于物理的动画的方法。像素处理也是它提供的许多专为像素处理本身设计和优化的对象所具有的强大功能之一。
- en: '![Jitter, for visuals](img/7584_06_09.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Jitter，用于视觉效果](img/7584_06_09.jpg)'
- en: A basic Jitter-core-based patch generating a good resolution 400x400 noise pixel
    map
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Jitter核心的基本补丁生成一个分辨率良好的400x400噪声像素图
- en: In order to summarize this massive load of information, Max schedules events
    or waits for the user to trigger something, MSP (for audio signal processing)—as
    soon as it is activated—calculates signal elements at each instant in its signal
    networks, and Jitter processes calculations when Jitter objects are triggered
    by **bangs**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这大量信息，Max安排事件或等待用户触发某些操作，一旦激活，MSP（用于音频信号处理）——在它的信号网络中的每一个瞬间计算信号元素，而Jitter在Jitter对象被**bangs**触发时处理计算。
- en: Indeed, Jitter objects need to be triggered in order to do their jobs, which
    can be very different, such as popping out a matrix that contains pixel color
    values, matrix processing for each cell of a matrix, and popping out the resulting
    matrix, for instance.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Jitter对象需要被触发才能执行它们的工作，这些工作可能非常不同，例如弹出包含像素颜色值的矩阵，对矩阵的每个单元格进行矩阵处理，然后弹出结果矩阵，例如。
- en: Bangs are special messages used to kinda say "*Hey, let's start your job!*"
    to objects. Objects in Max can behave differently, but almost every one can understand
    the bang message.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 触发信号是特殊消息，用来对对象说“*嘿，让我们开始你的工作！*”。Max 中的对象可以有不同的行为，但几乎每个对象都可以理解触发信号。
- en: In **Patch003** (pictured in the previous screenshot), the Max object `qmetro`
    provides a bang every 20 ms from a low priority scheduler queue to a Jitter object
    named `jit.noise`. This latter object calculates a matrix filled with a random
    value in each cell. Then, the result goes through a new green-and-black-striped
    patch cord to a UI object in which we can see a name, the `jit.pwindow`, a kind
    of display we can include in our patchers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Patch003**（如图中所示的前一个屏幕截图），Max 对象 `qmetro` 每隔 20 毫秒从低优先级调度队列向名为 `jit.noise`
    的 Jitter 对象发送一个触发信号。这个后者的对象计算出一个矩阵，每个单元格中填充随机值。然后，结果通过一条新的绿色和黑色条纹的补丁线到一个 UI 对象，我们可以看到一个名称，`jit.pwindow`，这是一种可以包含在我们的补丁中的显示方式。
- en: Jitter can be controlled via powerful Java and JavaScript APIs for some tasks
    that require typing big loops in code , which are easy to design using code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过强大的 Java 和 JavaScript API，可以控制抖动，这对于需要在代码中编写大循环的任务来说，使用代码设计起来很容易。
- en: Still here?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 还在这里吗？
- en: For the bravest among the brave, some other rows about Gen, the latest and most
    efficient module of Max 6.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最勇敢的勇士们，关于 Gen 的其他一些信息，这是 Max 6 中最新且最有效的模块。
- en: Gen, for a new approach to code generation
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gen，对于代码生成的新方法
- en: If you understood that there was a kind of compilation/execution behind our
    patches, I'd disappoint you by saying it doesn't really work like that. Even if
    everything works real time, there isn't a real compilation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解在我们的补丁背后存在一种编译/执行过程，那么我会让你失望地说，它实际上并不像那样工作。即使一切都可以实时工作，也没有真正的编译。
- en: By the way, there are many ways to design patch bits using code, with JavaScript
    for instance. Directly inside Max patcher, you can create a `.js` object and put
    your JavaScript code inside; it is indeed compiled on the fly (it is called **JS
    JIT** compiler, for JavaScript just-in-time compiler). It is really fast. Believe
    me, I tested it a lot and compared it to many other frameworks. So, as the documentation
    said, "we are not confined to writing Max externals in C" even if it is totally
    possible using the Max 6 SDK ([http://cycling74.com/products/sdk](http://cycling74.com/products/sdk)).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，有许多方法可以使用代码设计补丁位，例如使用 JavaScript。直接在 Max 补丁器内部，你可以创建一个 `.js` 对象，并将你的 JavaScript
    代码放入其中；它确实是即时编译的（它被称为 **JS JIT** 编译器，即 JavaScript 即时编译器）。它真的很快。相信我，我测试了很多，并与许多其他框架进行了比较。所以，正如文档所说，“我们不仅限于用
    C 语言编写 Max 外部插件”，即使使用 Max 6 SDK 完全可能（[http://cycling74.com/products/sdk](http://cycling74.com/products/sdk)）。
- en: Gen is a totally new concept.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Gen 是一个全新的概念。
- en: Gen provides a way of patching patch bits that are compiled on the fly, and
    this is a real compilation from your patch. It provides a new type of patcher
    with specific objects, quite similar to Max objects.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Gen 提供了一种在补丁上即时编译补丁位的方法，这是从你的补丁中进行的真正编译。它提供了一种具有特定对象的新的补丁类型，与 Max 对象非常相似。
- en: It works for MSP, with the `gen~` Max object, providing a neat way to design
    signal-rate related to audio patches architecture. You can design DSP and sound
    generators like that. The `gen~` patches are like a zoom in time; you have to
    consider them as sample processors. Each sample is processed by those patches
    inside the `gen~` patchers. There are smart objects to accumulate things over
    time, of course, in order to have signal processing windows of time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它适用于 MSP，使用 `gen~` Max 对象，提供了一种设计与音频补丁架构相关的信号速率的整洁方式。你可以设计这样的 DSP 和声音发生器。`gen~`
    补丁就像是对时间的放大；你必须把它们视为样本处理器。每个样本都在 `gen~` 补丁器内部由这些补丁处理。当然，有智能对象可以随时间累积事物，以便拥有信号处理的时间窗口。
- en: 'It works also for Jitter with three main Max objects:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它也适用于 Jitter，有三个主要的 Max 对象：
- en: '`jit.gen` is the fast matrix processor, processing each cell of a matrix at
    each turn'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jit.gen` 是快速矩阵处理器，在每个循环中处理矩阵的每个单元格。'
- en: '`jit.pix` is the CPU-based pixel processor, processing each pixel of a pixel
    map'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jit.pix` 是基于 CPU 的像素处理器，处理像素图中的每个像素。'
- en: '`jit.gl.pix` is the GPU-based version of `jit.pix`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jit.gl.pix` 是 `jit.pix` 的基于 GPU 的版本。'
- en: A GPU (graphics processor unit), and is basically a dedicated graphics processor
    on your video card. Usually, and this is a whole different universe, OpenGL pipeline
    provides an easy way to modify pixels from the software definitions to the screen
    just before they are displayed on the screen. It is called **shader process**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: GPU（图形处理器单元），基本上是你显卡上的一个专用图形处理器。通常，这是一个完全不同的领域，OpenGL 管道提供了从软件定义到屏幕显示之前修改像素的简单方法。这被称为**着色器过程**。
- en: You may already know that term in relation with the world of gaming. These are
    those shaders that are some of the last steps to improving graphics and visual
    renders in our games too.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经知道这个术语与游戏世界有关。这些是那些在我们的游戏中也是改善图形和视觉渲染的最后一步的着色器。
- en: Shaders are basically small programs that can be modified on the fly by passing
    arguments processed by the GPU itself. These small programs use specific languages
    and run vary fast on dedicated processors on our graphic cards.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器基本上是可以在 GPU 本身处理的参数传递中即时修改的小程序。这些小程序使用特定的语言，并在我们的显卡上的专用处理器上运行得非常快。
- en: Max 6 + Gen provides direct access to this part of the pipeline by patching
    only; if we don't want to write shaders based on **OpenGL GLSL** ([http://www.opengl.org/documentation/glsl](http://www.opengl.org/documentation/glsl)),
    **Microsoft DirectX HLSL** ([85).aspx">http://msdn.microsoft.com/en-us/library/bb509635(v=VS.).aspx">85).aspx](http://msdn.microsoft.com/en-us/library/bb509635(v=VS.).aspx)),
    or **Nvidia Cg** ([http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter01.html](http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter01.html)),
    Gen is your friend.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Max 6 + Gen 通过仅补丁即可直接访问管道的这一部分；如果我们不想基于 **OpenGL GLSL** ([http://www.opengl.org/documentation/glsl](http://www.opengl.org/documentation/glsl))、**Microsoft
    DirectX HLSL** ([http://msdn.microsoft.com/en-us/library/bb509635(v=VS.).aspx](http://msdn.microsoft.com/en-us/library/bb509635(v=VS.).aspx))
    或 **Nvidia Cg** ([http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter01.html](http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter01.html))
    编写着色器，Gen 就是你的朋友。
- en: All patches based on `jit.gl.pix` are specifically compiled and sent for GPU-based
    execution.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有基于 `jit.gl.pix` 的补丁都是专门编译并用于基于 GPU 的执行的。
- en: You can then design your own fragment shaders (or pixel shaders) by patching
    and you can even grab the source code in GLSL or WebGL language in order to use
    it in another framework, for instance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过补丁来设计自己的片段着色器（或像素着色器），甚至可以抓取 GLSL 或 WebGL 语言中的源代码，以便在其他框架中使用。
- en: Geometry shaders aren't available using Gen, but with other Jitter objects they
    already exists.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Gen 无法使用几何着色器，但与其他 Jitter 对象一起，它们已经存在。
- en: I guess I lost some of you. Relax I won't ask you questions about Gen in Arduino
    exams!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜我可能让一些人感到困惑了。放松，我不会在 Arduino 考试中问你关于 Gen 的问题！
- en: Summarizing everything in one table
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容总结在一个表格中
- en: Everything related to Max 6 is on the Cycling 74's website at [http://cycling74.com](http://cycling74.com).
    Also, almost 99 percent of the documentation is online too, at [http://cycling74.com/docs/max6/dynamic/c74_docs.html#docintro](http://cycling74.com/docs/max6/dynamic/c74_docs.html#docintro).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Max 6 相关的一切信息都可以在 Cycling 74 的网站上找到，网址是 [http://cycling74.com](http://cycling74.com)。此外，几乎
    99% 的文档也是在线的，可以在 [http://cycling74.com/docs/max6/dynamic/c74_docs.html#docintro](http://cycling74.com/docs/max6/dynamic/c74_docs.html#docintro)
    找到。
- en: 'The following table summarizes everything we did until now:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了到目前为止我们所做的一切：
- en: '| Parts | What? | Cable color | Distinctive sign |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 部分 | 是什么？ | 电缆颜色 | 特征标志 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Max | The playground | Gray by default and no stripes | Basic names |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| Max | 操场 | 默认为灰色，没有条纹 | 基本名称 |'
- en: '| MSP | Everything related to audio and signal rate | Yellow-and-black stripes
    | `~` suffixed to the namesignal-rate processing |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| MSP | 与音频和信号速率相关的一切 | 黄色和黑色条纹 | 命名后缀为 `~`，表示信号速率处理 |'
- en: '| Jitter | Everything related to visuals and matrices | Green-and-black stripes
    for matrix cablesBlue-and-black stripes for pixel map cables | `jit.` prefixed
    to the name |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| Jitter | 与视觉和矩阵相关的一切 | 矩阵电缆为绿色和黑色条纹 | 命名前缀为 `jit.` |'
- en: '| Gen | Specific patchers (DSP-related and matrix and texture processing) compiled
    on the fly | Like MSP for `gen~` and Jitter for `jit.gen`, `jit.pix`, and `jit.gl.pix`
    | Very very fast! |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| Gen | 在线编译的特定补丁（与 DSP 相关以及矩阵和纹理处理） | 类似于 MSP 的 `gen~` 和 Jitter 的 `jit.pix`、`jit.gl.pix`
    | 非常非常快！ |'
- en: Installing Max 6
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Max 6
- en: Max 6 is available as a 30-day trial. Installing Max 6 is quite easy as it comes
    with an installer for both platforms, Windows and OS X, downloadable at [http://cycling74.com/downloads](http://cycling74.com/downloads).
    Download and install it. Then, launch it. That's all. (The following examples
    will only work when you have installed Max.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Max 6作为一个30天的试用版可用。安装Max 6相当简单，因为它提供了Windows和OS X平台的安装程序，可在[http://cycling74.com/downloads](http://cycling74.com/downloads)下载。下载并安装它。然后，启动它。就这样。（以下示例只有在安装了Max之后才会工作。）
- en: You should see a blank playground
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个空白的游乐场
- en: '![Installing Max 6](img/7584_06_10.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![安装Max 6](img/7584_06_10.jpg)'
- en: Max 6 blank-page anxiety can occur right now, can't it?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Max 6的空白页面焦虑可能现在就会发生，不是吗？
- en: The very first patch
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个补丁
- en: Here is a basic patch you can find also in the `Chapter06/` folder under the
    name `Patcher004_Arduino.maxpat`. Usually, if you double-click on it, it is opened
    directly by Max 6.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个基本的补丁，你可以在`Chapter06/`文件夹下以`Patcher004_Arduino.maxpat`的名称找到它。通常，如果你双击它，它会被Max
    6直接打开。
- en: This patch is a very basic one, but not that basic actually!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个补丁是一个非常基本的补丁，但实际上并不那么简单！
- en: It is a basic noise-based sequencer modifying an oscillator's frequency regularly
    in real time. This produces a sequence of strange sounds, more or less pretty,
    the modifications of the frequency being controlled by chance. So, turn on your
    speakers and the patch will produce sounds.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的基于噪声的序列发生器，它实时地定期修改振荡器的频率。这会产生一系列奇怪的声音，或多或少有点漂亮，频率的改变是由随机控制的。所以，打开你的扬声器，补丁将会产生声音。
- en: '![The very first patch](img/7584_06_11.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![第一个补丁](img/7584_06_11.jpg)'
- en: The noise-based sequencer
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 基于噪声的序列发生器
- en: Basically, patches are stored in files. You can share patches with other friends
    quite easily. Of course, bigger projects would involve some dependency issues;
    if you added some libraries to your Max 6 framework, if you use them in a patch,
    or if you basically send your patch files to a friend who doesn't have those libraries
    installed, your friend will have some errors in the Max Window. I won't describe
    these kinds of issues here, but I wanted to warn you.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，补丁是存储在文件中的。你可以非常容易地与其他朋友分享补丁。当然，更大的项目可能会涉及一些依赖性问题；如果你向Max 6框架中添加了一些库，如果你在补丁中使用它们，或者如果你基本上将补丁文件发送给一个没有安装这些库的朋友，你的朋友在Max窗口中将会出现一些错误。我不会在这里描述这类问题，但我想要提醒你。
- en: Other neat ways to share patches in the Max 6 world are the copy/paste and copy
    compressed features. Indeed, if you select objects in your patcher (whatever the
    layer, including a subpatcher, inside a subpatcher, and so on) and go to **Edit**
    | **Copy**, text-based content is put in your clipboard. This can then be repasted
    into another patcher or inside a text file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Max 6的世界中，分享补丁的其他整洁方式是复制/粘贴和复制压缩功能。确实，如果你在补丁器中选择对象（无论层次，包括子补丁器，子补丁器内的子补丁器，等等），然后转到**编辑**
    | **复制**，基于文本的内容就会被放入你的剪贴板。然后你可以将其粘贴到另一个补丁器或文本文件中。
- en: The smartest way is the use of copy compress, which as the well-chosen name
    means, copies and compresses the JSON code to something much more compact and
    easy to copy into the text area on forums, for instance.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最聪明的办法是使用复制压缩功能，正如其名字所暗示的，它复制并压缩JSON代码，使其变得更加紧凑，更容易复制到论坛上的文本区域，例如。
- en: Wait, let me show you what it looks like.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，让我给你看看它是什么样子。
- en: I just selected all objects in my patch and went to **Edit** | **Copy Compressed**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是选择了补丁中的所有对象，然后转到**编辑** | **复制压缩**。
- en: '![The very first patch](img/7584_06_12.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![第一个补丁](img/7584_06_12.jpg)'
- en: The copy compressed feature
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 复制压缩功能
- en: And the following figure is the result of pasting directly into a text file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图是直接粘贴到文本文件中的结果。
- en: Those familiar with HTML would notice something funny; Cycling '74 developers
    include two HTML tags (`pre` and `code`) in order to directly provide code that
    is pastable inside a text field on (any) forums on the Web.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉HTML的人可能会注意到一些有趣的地方；Cycling '74的开发者在HTML标签（`pre`和`code`）中包含了两项，以便直接提供可以在（任何）网络论坛上的文本字段中粘贴的代码。
- en: '![The very first patch](img/7584_06_41.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![第一个补丁](img/7584_06_41.jpg)'
- en: Copy-compressed code
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 复制压缩代码
- en: So you can also copy that code into your clipboard and paste it into a new patch.
    You create a new empty patch by by going to **File** | **New** (or hitting *Ctrl*
    + *N* on Windows and *command* + *N* on OS X).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你也可以将那段代码复制到你的剪贴板，并将其粘贴到一个新的补丁中。你可以通过访问**文件** | **新建**（或者在Windows上按*Ctrl*
    + *N*，在OS X上按*command* + *N*）来创建一个新的空补丁。
- en: Playing sounds with the patch
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用补丁播放声音
- en: As you can see, I put some comments in the patcher. You can follow them in order
    to produce some electronic sounds from your computer.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我在补丁中添加了一些注释。你可以按照它们来产生一些来自你电脑的电子声音。
- en: Before you begin, be sure to lock the patch by clicking on the padlock icon
    in the lower-left corner. To hear the results of the patch, you'll also need to
    click on the speaker icon. To zoom out, go to the **View** menu and click on **Zoom
    Out**.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保通过点击左下角的锁形图标锁定补丁。要听到补丁的结果，你还需要点击扬声器图标。要缩小视图，请转到 **视图** 菜单并点击 **缩小**。
- en: First, note and check the toggle at the top. It will send the value `1` to the
    connected object metro.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意并检查顶部的 toggle。它将发送值 `1` 到连接的对象 metro。
- en: 'A metro is a pure Max object that sends a bang every *n* milliseconds. Here,
    I hardcoded an argument: `100`. As soon as the metro receives the message `1`
    from the toggle, it begins to be active and, following the Max timing scheduler,
    it will send its bangs every 100 ms to the next connected object.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Metro 是一个纯 Max 对象，每 *n* 毫秒发送一个 bang 信号。这里，我硬编码了一个参数：`100`。一旦 metro 收到来自 toggle
    的消息 `1`，它就开始活跃，并遵循 Max 定时调度器，每隔 100 毫秒向下一个连接的对象发送 bang 信号。
- en: When the `random` object receives a bang, it pops out a random integer from
    within a range. Here, I put `128`, which means `random` will send values from
    `0` to `127`. Directly after `random`, I put a `zmap` object that works like a
    scaler. I harcoded four arguments, minimum and maximum values for inputs and minimum
    and maximum values for output.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `random` 对象接收到一个 bang 信号时，它会从指定范围内弹出一个随机整数。这里，我设置了 `128`，这意味着 `random` 将发送
    `0` 到 `127` 的值。紧接着 `random`，我放置了一个 `zmap` 对象，它像一个缩放器。我硬编码了四个参数，即输入的最小值和最大值以及输出的最小值和最大值。
- en: Basically, here, `zmap` maps my values `0` to `127` sent by `random` to another
    values from `20` to `100`. It produces an implicit stretch and loss of resolution
    that I like.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在这里，`zmap` 将 `random` 发送的值 `0` 到 `127` 映射到 `20` 到 `100` 的另一个值。它产生了一种隐式的拉伸和分辨率损失，这是我喜欢的。
- en: Then, this resulting number is sent to the famous and important `mtof` object.
    This converts a MIDI note pitch standard to a frequency according to the MIDI
    standard. It is often used to go from the MIDI world into the real sound world.
    You can also read the frequency in the UI object `flonum` displaying the frequency
    as a float number in Hz (hertz, a measure of frequency).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个结果数值被发送到著名的且重要的 `mtof` 对象。它将 MIDI 音高标准转换为根据 MIDI 标准的频率。它通常用于从 MIDI 世界进入真实声音世界。你还可以在显示频率为浮点数（赫兹，频率的度量单位）的
    UI 对象 `flonum` 中读取频率。
- en: Then, at last, this frequency is sent to the `cycle~` object, producing a signal
    (check the yellow-and-black striped cord). Sending numbers to this object makes
    it to change the frequency of the signal produced. This one is multiplied by a
    signal multiply operator `*~`, producing another signal but with a lower amplitude
    to protect our precious ears.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个频率被发送到 `cycle~` 对象，产生一个信号（检查黄色和黑色条纹的线）。向这个对象发送数字会使其改变产生的信号的频率。这个信号乘以一个信号乘法运算符
    `*~`，产生另一个信号，但幅度更低，以保护我们宝贵的耳朵。
- en: The last destination of that signal is the big gray box on which you have to
    click once in order to hear or not hear the sounds produced by the upper signal
    network.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 该信号的最后一个目的地是你必须点击一次才能听到或听不到由上面的信号网络产生的声音的大灰色框。
- en: Now you're ready to check the toggle box. Activate the speaker icon by clicking
    on the gray box, and then you can dance. Actually, electronic sounds produced
    are a bit shuffly about the frequency (that is, the note) but it can be interesting.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以准备检查复选框了。通过点击灰色框激活扬声器图标，然后你可以开始跳舞。实际上，产生的电子声音在频率（即音符）上有些混乱，但可能会很有趣。
- en: Of course, controlling this cheap patch with the Arduino in order to not use
    the mouse/cursor would be very great.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用 Arduino 控制这个便宜的补丁，以便不使用鼠标/光标，将会非常棒。
- en: Let's do that with the same circuit that we designed previously.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用之前设计的相同电路来做这件事。
- en: Controlling software using hardware
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用硬件控制软件
- en: Coming from pure digital realms where everything can be wrapped into software
    and virtual worlds, we often need physical interfaces. This can sound like a paradox;
    we want everything in one place, but that place is so small and user-unfriendly
    for everything related to pure creation and feelings that we need more or less
    big external (physical) interfaces. I love this paradox.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 来自纯数字领域，其中一切都可以封装到软件和虚拟世界中，我们经常需要物理接口。这听起来可能像是一个悖论；我们希望一切都在一个地方，但那个地方对于与纯创造和情感相关的一切来说都太小，不够友好，因此我们需要更多或更少的大的外部（物理）接口。我喜欢这个悖论。
- en: But, why do we need such interfaces? Sometimes, the old mouse and QWERTY keyboard
    don't cut it. Our computers are fast, but these interfaces to control our programs
    are slow and clunky.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为什么我们需要这样的接口呢？有时，旧鼠标和 QWERTY 键盘就不够用了。我们的电脑很快，但这些控制我们程序的接口却很慢，很笨拙。
- en: We need interfaces between the real world and the virtual world. Whatever they
    are, we need them to focus on our final purpose, which is usually not the interface
    or even the software itself.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在现实世界和虚拟世界之间建立接口。无论它们是什么，我们都需要它们专注于我们的最终目的，这通常不是接口，甚至不是软件本身。
- en: Personally, I write books and teach art-related technology courses, but as a
    live performer, I need to focus on the final rendering. While performing, I want
    to black-box as much as possible the technology under the hood. I want to feel
    more than I want to calculate. I want a controller interface to help me operate
    at the speed and level of flexibility to make the types of changes I want.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 亲自来说，我写书并教授与艺术相关的技术课程，但作为一个现场表演者，我需要专注于最终的渲染。在表演时，我希望尽可能地黑盒化底下的技术。我想要感受，而不是计算。我需要一个控制器接口来帮助我在速度和灵活性上操作，以便进行我想要的类型的变化。
- en: As I already said in this book, I needed a huge MIDI controller, heavy, solid,
    and complex, in order to control only one software on my computer. So, I built
    Protodeck ([http://julienbayle.net/protodeck](http://julienbayle.net/protodeck))).
    This was my interface.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在这本书中已经说过的，我需要一个巨大的 MIDI 控制器，沉重、坚固且复杂，才能控制我电脑上的一个软件。因此，我建造了 Protodeck ([http://julienbayle.net/protodeck](http://julienbayle.net/protodeck))).
    这就是我的接口。
- en: So, how can we use Arduino to control software? I guess you have just a part
    of your answer because we already sent data to our computer by turning a potentiometer.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用 Arduino 来控制软件呢？我想你已经有了一部分答案，因为我们已经通过旋转电位器将数据发送到我们的电脑。
- en: Let's improve our Max 6 patch to make it receive our Arduino's data while we
    turn the potentiometer.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进我们的 Max 6 补丁，使其在旋转电位器时接收 Arduino 的数据。
- en: Improving the sequencer and connecting the Arduino
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进序列器和连接 Arduino
- en: We are going to create a very cheap and basic project that will involve our
    Arduino board as a small sound controller. Indeed, we'll directly use the firmware
    we just designed with the potentiometer, and then we'll modify our patch. This
    is a very useful base for you to continue to build things and even create bigger
    controller machines.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个非常便宜和基础的项目，该项目将涉及我们的 Arduino 板作为一个小型声音控制器。实际上，我们将直接使用我们刚刚设计的带有电位器的固件，然后我们将修改我们的补丁。这对于你继续构建事物甚至创建更大的控制器机器非常有用。
- en: Let's connect the Arduino to Max 6
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让我们连接 Arduino 到 Max 6
- en: Arduino can communicate using the serial protocol. We already did that. Our
    latest firmware already does that, sending the voltage value.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 可以使用串行协议进行通信。我们已经做到了。我们的最新固件已经做到了，发送电压值。
- en: 'Let''s modify it a bit and make it send only the analog value read, within
    the range `0` to `1023`. Here is the code, available in `Chapter06/maxController`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍作修改，使其只发送读取的模拟值，范围在 `0` 到 `1023` 之间。以下是代码，可在 `Chapter06/maxController` 中找到：
- en: '[PRE2]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I removed everything unnecessary and added a delay of 2 ms at the end of the
    loop (before the loop restarts) This is often used with analog input and especially
    ADC. It provides a break to let it stabilize a bit. I didn't do that in previous
    code involving analog read because there were already two `delay()` methods involved
    in the LED blinking.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我移除了所有不必要的部分，并在循环末尾（在循环重新开始之前）添加了 2 毫秒的延迟。这通常与模拟输入和特别是 ADC 一起使用。它提供了一个中断，让它稳定一会儿。我在之前的涉及模拟读取的代码中没有这样做，因为那里已经有两个
    `delay()` 方法涉及 LED 闪烁。
- en: This basic one sends the value read at the analog input pin where the potentiometer
    is connected. No more, but no less.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本版本发送连接到电位器的模拟输入引脚上读取的值。不多，也不少。
- en: Now, let's learn how to receive that somewhere other than the Serial Monitor
    of our precious IDE, especially in Max 6.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何在除了我们宝贵的 IDE 的串行监视器之外的某个地方接收这些数据。
- en: The serial object in Max 6
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Max 6 中的串行对象
- en: There is a Max object named `serial`. It provides a way to communicate using
    a serial port with any other type of device using serial communication.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Max 中有一个名为 `serial` 的对象。它提供了一种使用串行端口与其他任何使用串行通信的设备进行通信的方式。
- en: The next figure describes the new Max 6 patch including the part necessary to
    communicate with our small hardware controller.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图描述了新的 Max 6 补丁，包括与我们的小型硬件控制器通信所需的部件。
- en: Now, let's plug the Arduino in, if this has not been done already, and upload
    the `maxController` firmware.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果还没有这样做，请将 Arduino 插入，并上传 `maxController` 固件。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful to switch off serial monitoring for the IDE.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意关闭 IDE 的串行监控。
- en: Otherwise, there would be a conflict on your computer; only one serial communication
    can be instantiated on one port.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你的电脑上会有冲突；一个端口上只能实例化一个串行通信。
- en: Then here is another patch you can find, also in the `Chapter06/` folder, with
    the name `Patcher005_Arduino.maxpat`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这里还有一个你可以找到的补丁，也在 `Chapter06/` 文件夹中，名为 `Patcher005_Arduino.maxpat`。
- en: '![The serial object in Max 6](img/7584_06_13.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![Max 6 中的串行对象](img/7584_06_13.jpg)'
- en: The Max patch including the Arduino communication module
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 Arduino 通信模块的 Max 补丁
- en: Double-click on the file, and you'll see this patch.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 双击文件，你会看到这个补丁。
- en: Let's describe it a bit. I added everything in green and orange.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微描述一下。我添加了所有绿色和橙色的内容。
- en: Everything necessary to understand the Arduino messages and to convert them
    in terms understandable easily by our sequencer patch is in green. Some very useful
    helpers that are able to write to the Max window at every step of the data flow,
    from raw to converted data, are in orange.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Arduino 消息并将其转换为我们的序列器补丁易于理解的所有必要内容都在绿色部分。一些非常有用的辅助工具，能够在数据流中的每个步骤写入 Max
    窗口，从原始数据到转换后的数据，都在橙色部分。
- en: Let's describe both parts, beginning with the helpers.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述这两部分，从辅助部分开始。
- en: Tracing and Debugging easily in Max 6
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Max 6 中轻松追踪和调试
- en: Max 6 provides many ways to debug and trace things. I won't describe them all
    in this Arduino book, but some need a few words.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Max 6 提供了许多调试和追踪的方法。我不会在这本 Arduino 书中描述所有这些，但其中一些需要几句话说明。
- en: Check your patch, especially the orange-colored objects.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你的补丁，特别是橙色部分的对象。
- en: '`print` objects are the way to send messages directly to the Max window. Everything
    sent to them is written to the Max window as soon it has been received. The argument
    you can pass to these objects is very useful too; it helps to discern which `print`
    object sends what in cases where you use more than one `print` object. This is
    the case here and check: I name all my `print` objects considering the object
    from which comes the message:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 对象是直接向 Max 窗口发送消息的方式。一旦收到，发送给它们的任何内容都会立即写入 Max 窗口。你可以传递给这些对象的参数也非常有用；它有助于在您使用多个
    `print` 对象的情况下区分哪个 `print` 对象发送了什么。这里就是这种情况，检查一下：我根据消息来源的对象命名所有的 `print` 对象：'
- en: '`fromSerial`: This is for all messages coming from the `serial` object itself'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromSerial`：这是针对来自 `serial` 对象自身的所有消息'
- en: '`fromZl`: This is for all messages coming from the `zl` object'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromZl`：这是针对来自 `zl` 对象的所有消息'
- en: '`fromitoa`: This is for all messages coming from the `itoa` object'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromitoa`：这是针对来自 `itoa` 对象的所有消息'
- en: '`fromLastStep`: This is for all messages coming from the `fromsymbol` object'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromLastStep`：这是针对来自 `fromsymbol` 对象的所有消息'
- en: The `gate` objects are just small doors, gates that we can enable or disable
    by sending `1` or `0` to the leftmost input. The `toggle` objects are nice UI
    objects to do that by clicking. As soon as you check the toggle, the related `gate`
    object will let any message sent to the right input pass through them to the only
    one output.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`gate` 对象只是小门，我们可以通过发送 `1` 或 `0` 到最左侧的输入来启用或禁用它们。`toggle` 对象是很好的 UI 对象，可以通过点击来实现这一点。一旦你勾选了
    `toggle`，相关的 `gate` 对象将允许发送到右侧输入的消息通过它们传递到唯一的输出。'
- en: We are going to use this trace system in several minutes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在几分钟内使用这个追踪系统。
- en: Understanding Arduino messages in Max 6
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Max 6 中理解 Arduino 消息
- en: What is required to be understood is that the previous toggle is now connected
    to a new `qmetro` object too. This is the low priority `metro` equivalent. Indeed,
    this one will poll the `serial` object every 20 ms, and considering how our Arduino's
    firmware currently works by sending the analog value read at every turn in the
    loop, even if this polling lags a bit, it won't matter; the next turn, the update
    will occur.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的是，之前的切换现在也连接到了一个新的 `qmetro` 对象。这是低优先级的 `metro` 对应物。实际上，这个对象将每 20 毫秒轮询 `serial`
    对象，考虑到我们的 Arduino 固件当前通过在循环的每次迭代中发送读取的模拟值来工作，即使轮询有点延迟，也不会有问题；下一次迭代，更新将会发生。
- en: The `serial` object is the important one here.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`serial` 对象在这里非常重要。'
- en: 'I hardcoded some parameters related to serial communication with the Arduino:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我硬编码了一些与 Arduino 串行通信相关的参数：
- en: '`9600` sets the clock to 9600 bauds'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`9600` 设置时钟为 9600 波特'
- en: '`8` sets the word length at 8 bit'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`8` 设置字长为 8 位'
- en: '`1` means there is a stop bit'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 表示有一个停止位'
- en: '`0` means there is no parity (parity is sometimes useful in error checking)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 表示没有奇偶校验（奇偶校验有时在错误检查中很有用）'
- en: This object needs to be banged in order to provide the current content of the
    serial port buffer. This is the reason why I feed it by the `qmetro` object.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象需要被 bang 以提供串行端口缓冲区的当前内容。这就是为什么我用 `qmetro` 对象给它提供数据的原因。
- en: The `serial` object pops out a raw list of values. Those values need to be a
    bit parsed and organized before reading the analog value sent. This is what the
    `select`, `zl`, `itoa`, and `fromsymbol` objects stand for.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`serial` 对象会弹出一系列原始值。在读取发送的模拟值之前，这些值需要被稍微解析和组织。这就是 `select`、`zl`、`itoa` 和 `fromsymbol`
    对象的作用。'
- en: Note
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Directly read the help information for any object in Max 6 by pushing the *Alt*
    key on your keyboard and then clicking on the object.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按键盘上的 *Alt* 键然后点击对象，直接读取 Max 6 中任何对象的帮助信息。
- en: '![Understanding Arduino messages in Max 6](img/7584_06_14.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![理解 Max 6 中的 Arduino 消息](img/7584_06_14.jpg)'
- en: The serial object's help patch
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 串行对象的帮助补丁
- en: Every 20 ms, if the serial communication has been instantiated, the `serial`
    object will provide what will be sent by the Arduino, the current and most recently
    read analog value of the pin where the potentiometer is connected. This value
    going from 0 to 1023, I'm using a `scale` object as I did with the `zmap` object
    for the sequencer/sound part of the patch. This `scale` object recasts the scale
    of values from 0 to 1023 at input to an inverted range of 300 down to 20, letting
    the range to go opposite direction (be careful, current and future Max patchers,
    `zmap` doesn't behave like that). I did that in order to define the maximum range
    of the note-per-minute rate. The `expr` object calculates this. `qmetro` needs
    the interval between two bangs. I'm making this vary between 400 ms and 20 ms
    while turning my potentiometer. Then, I calculate the note-per-minute rate and
    display it in another `flonum` UI object.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 每 20 毫秒，如果串行通信已经实例化，`serial` 对象将提供 Arduino 将要发送的内容，即连接到电位器的引脚上当前和最近读取的模拟值。这个值从
    0 到 1023，我使用 `scale` 对象，就像我在补丁的序列/声音部分使用 `zmap` 对象一样。这个 `scale` 对象将输入的 0 到 1023
    的值范围重新映射为 300 到 20 的反转范围，使范围反向（请注意，当前和未来的 Max 补丁，`zmap` 不像这样）。我这样做是为了定义每分钟音符的最大范围。`expr`
    对象计算这个值。`qmetro` 需要两个 bang 之间的间隔。当我转动电位器时，我让这个间隔在 400 毫秒和 20 毫秒之间变化。然后，我计算每分钟音符速率，并在另一个
    `flonum` UI 对象中显示它。
- en: Then, I also added this strange `loadbang` object and the `print` one. `loadbang`
    is the specific object that sends a bang as soon as the patcher is opened by Max
    6\. It is often used to initialize some variable inside our patcher, a bit like
    we are doing with the declarations in the first rows of our Arduino sketches.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我还添加了这个奇怪的 `loadbang` 对象和 `print` 对象。`loadbang` 是一个特定的对象，当 Max 6 打开补丁时，它会立即发送一个
    bang。它通常用于初始化我们补丁内部的一些变量，有点像我们在 Arduino 脚本的第一行中进行的声明。
- en: '`print` is only text inside an object named `message`. Usually, each Max 6
    object can understand specific messages. You can create a new empty message by
    typing `m` anywhere in a patcher. Then, with the autocomplete feature, you can
    fill it with text by selecting it and clicking on it again.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 是在名为 `message` 的对象内的文本。通常，每个 Max 6 对象都可以理解特定的消息。你可以在补丁的任何地方键入 `m` 来创建一个新的空消息。然后，通过选择它并再次点击它，你可以使用自动完成功能填充文本。'
- en: Here, as soon as the patch is loaded and begins to run, the `serial` object
    receives the print message triggered by `loadbang`. The `serial` object is able
    to send the list of all serial port messages to the computer that runs the patch
    to the console (that is, the Max window). This happens when we send the print
    message to it. Check the Max window of the figure showing the `Patcher005_Arduino.maxpat`
    patch.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一旦补丁加载并开始运行，`serial`对象就会接收到由`loadbang`触发的打印消息。`serial`对象能够将所有串行端口消息列表发送到运行补丁的计算机的终端（即Max窗口）。这发生在我们向它发送打印消息时。检查显示`Patcher005_Arduino.maxpat`补丁的Max窗口。
- en: We can see a list of…things. `serial` pops out a list of serial port letter
    abbreviations with the corresponding serial ports often representing the hardware
    name. Here, as we already saw in the Arduino IDE, the one corresponding to the
    Arduino is `usbmodemfa131`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一系列事物。`serial`弹出一个串行端口字母缩写列表，对应的串行端口通常表示硬件名称。在这里，正如我们在Arduino IDE中已经看到的，对应于Arduino的是`usbmodemfa131`。
- en: The corresponding reference in Max is the letter `c` on my computer. This is
    only an internal reference.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Max中对应的引用是我电脑上的字母`c`。这仅是一个内部引用。
- en: '![Understanding Arduino messages in Max 6](img/7584_06_15.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![在Max 6中理解Arduino消息](img/7584_06_15.jpg)'
- en: 'Result of the print message sent to the serial object: the list of port letters
    / names of serial ports'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到串行对象的打印消息的结果：端口字母/串行端口的名称列表
- en: Let's change the hardcoded letter put as argument for the `serial` object in
    the patch.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改在补丁中作为`serial`对象参数的硬编码字母。
- en: Select the `serial` object. Then, re-click inside and swap `a` with the letter
    corresponding to the Arduino serial port on your computer. As soon as you hit
    *Enter*, the object is instantiated again with new parameters.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`serial`对象。然后，在内部重新单击并交换`a`与您计算机上Arduino串行端口的对应字母。一旦您按下*Enter*，对象就会以新的参数重新实例化。
- en: '![Understanding Arduino messages in Max 6](img/7584_06_16.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![在Max 6中理解Arduino消息](img/7584_06_16.jpg)'
- en: Changing the reference letter in the serial object to match the one corresponding
    to the serial port of the Arduino
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 将序列对象中的参考字母更改为与Arduino的串行端口对应的字母
- en: Now, everything is ready. Check the toggle, enable the gray box with the speaker,
    and turn your potentiometer. You are going to hear your strange noises from the
    sequencer, and you can now change the note rate (I mean the interval between each
    sound) because I abusively used the term note to fit better to the sequencer's
    usual definition.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切准备就绪。检查切换，启用带有扬声器的灰色框，并转动您的电位器。您将听到来自序列器的奇怪噪音，现在您可以更改音符速率（我的意思是每个声音之间的间隔），因为我滥用术语音符以更好地适应序列器的通常定义。
- en: What is really sent on the wire?
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 究竟在电线上发送了什么？
- en: 'You will have noticed that, as usual, I mentioned the series of objects: `select`,
    `zl`, `itoa`, and `fromsymbol`. The time has come to explain them.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，像往常一样，我提到了一系列对象：`select`、`zl`、`itoa`和`fromsymbol`。现在是时候解释它们了。
- en: When you use the `Serial.println()` function in your Arduino's firmware source
    code, the Arduino doesn't send only the value passed as argument to the function.
    Check the first orange toggle at the top of the series of toggle/gate systems.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Arduino固件源代码中使用`Serial.println()`函数时，Arduino不仅发送函数传递的参数值。检查一系列切换/门系统顶部的第一个橙色切换。
- en: '![What is really sent on the wire?](img/7584_06_17.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![电线上实际发送了什么？](img/7584_06_17.jpg)'
- en: The serial object pops out strange series of numbers
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 串行对象弹出一系列奇怪的数字
- en: 'You can see the name of the printing object in the first column named **Object**,
    and in the **Message** column, the message sent by the related object. And we
    can see the `serial` object popping out strange series of numbers in a repetitive
    way: **51**, **53**, **48**, **13**, **10**, and so on.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在名为**对象**的第一列中看到打印对象的名称，在**消息**列中，可以看到相关对象发送的消息。我们还可以看到`serial`对象以重复的方式弹出一系列奇怪的数字：**51**、**53**、**48**、**13**、**10**，等等。
- en: Note
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Arduino transmits its values as ASCII, exactly as if we were typing them on
    our computer.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino以ASCII码的形式发送其值，就像我们在计算机上键入它们一样。
- en: 'This is very important. Let''s check the *Appendix E, ASCII Table*, in order
    to find the corresponding characters:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要。让我们检查*附录E，ASCII表*，以找到相应的字符：
- en: 51 means the character 3
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 51表示字符3
- en: 53 means 5
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 53表示5
- en: 48 means 0
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 48表示0
- en: 13 means a carriage return
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13表示回车
- en: 10 means line feed, which itself means new line
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10表示换行，它本身意味着新的一行
- en: Of course, I cheated a bit by sorting the series as I did. I knew about the
    `10 13` couple of numbers. It is a usual marker meaning *a carriage return followed
    by a new line*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我在排序序列时有点作弊。我知道 `10 13` 这一对数字。这是一个常用的标记，意味着 *一个回车符后跟一个换行符*。
- en: 'So it seems that my Arduino sent a message a bit like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我的 Arduino 发送了一条类似这样的消息：
- en: '[PRE3]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `<CR>` and `<LF>` are carriage return and new line characters.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<CR>` 和 `<LF>` 分别代表回车符和换行符。
- en: If I had used the `Serial.print()` function instead of `Serial.println()`, I
    wouldn't have had the same result. Indeed, the `Serial.print()` version doesn't
    add the `<CR>` and `<NL>` characters at the end of a message. How could I have
    known whether `3`, `5`, or `0` would be the first character if I didn't have an
    end marker?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我使用了 `Serial.print()` 函数而不是 `Serial.println()`，我就不会得到相同的结果。实际上，`Serial.print()`
    版本不会在消息末尾添加 `<CR>` 和 `<NL>` 字符。如果没有结束标记，我怎么知道 `3`、`5` 或 `0` 将会是第一个字符呢？
- en: 'The design pattern to keep in mind is as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的设计模式如下：
- en: Build the message
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建消息
- en: Send the message after it is completely built (using the `Serial.println()`
    function.)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在消息完全构建后发送消息（使用 `Serial.println()` 函数）。
- en: 'If you want to send it while building it, here''s what you can use:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在构建过程中发送它，这里是你可以使用的方法：
- en: Send the first byte using `Serial.print()`
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Serial.print()` 发送第一个字节
- en: Send the second byte using `Serial.print()`
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Serial.print()` 发送第二个字节
- en: Continue to send until the end
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续发送直到结束
- en: Send the `<CR><LF>` at the end by using `Serial.println()` with no argument
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不带参数的 `Serial.println()` 在末尾发送 `<CR><LF>`
- en: Extracting only the payload?
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅提取有效载荷？
- en: In many fields related to communication, we talk about payload. This is the
    message, the purpose of the communication itself. Everything else is very important
    but can be understood as a carrier; without these signals and semaphores, the
    message couldn't travel. However, we are interested in the message itself.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多与通信相关的领域，我们谈论有效载荷。这是消息，通信本身的目的。其他所有东西都非常重要，但可以理解为载体；没有这些信号和信号量，消息无法传播。然而，我们感兴趣的是消息本身。
- en: We need to parse the message coming from the serial object.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解析来自串行对象的消息。
- en: We have to accumulate each ASCII code into the same message, and when we detect
    the `<CR><LF>` sequence, we have to pop out the message block and then restart
    the process.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将每个 ASCII 码累积到同一个消息中，当我们检测到 `<CR><LF>` 序列时，我们必须弹出消息块，然后重新开始这个过程。
- en: This is done with the `select` and `zl` objects.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过 `select` 和 `zl` 对象完成的。
- en: '`select` is able to detect messages equaling one of its arguments. When `select
    10 13` receives a 10, it will send a bang to the first output. If it is a 13,
    it will send a bang to the second output. Then, if anything else comes, it will
    just pass the message from the last output to the right.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` 能够检测与其参数相等的消息。当 `select 10 13` 接收到一个 10 时，它将向第一个输出发送一个 bang。如果是 13，它将向第二个输出发送一个
    bang。然后，如果收到其他任何消息，它将只从最后一个输出传递到右边。'
- en: '`zl` is such a powerful list processor with so many usage scenarios that it
    would make up a book by itself! Using argument operator, we can even use it to
    parse the data, cut lists into pieces, and much more. Here, with the group 4 argument,
    `zl` receives an initial message and stores it; when it receives a second message,
    it stores the message, and so on, until the fourth message. At the precise moment
    that this is received, it will send a bigger message composed of the four messages
    received and stored. Then, it clears its memory.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`zl` 是一个如此强大的列表处理器，具有如此多的使用场景，以至于它可以单独构成一本书！使用参数运算符，我们甚至可以用它来解析数据，将列表切割成片段，等等。在这里，使用组
    4 参数，`zl` 接收一个初始消息并将其存储；当它接收到第二个消息时，它存储该消息，依此类推，直到第四个消息。在接收到这个消息的精确时刻，它将发送一个由接收并存储的四个消息组成的大消息。然后，它清除其内存。'
- en: Here, if we check the corresponding toggle and watch the Max window, we can
    see **51 53 48** repeated several times and sent by the `zl` object.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们检查相应的切换并观察 Max 窗口，我们可以看到 **51 53 48** 被重复几次，并由 `zl` 对象发送。
- en: The `zl` object does a great job; it passes all ASCII characters except `<CR>`
    and `<LF>`, and as soon as it receives `<LF>`, `zl` sends a bang. We have just
    built a message processor that *resets* the `zl` buffer each time it receives
    `<LF>`, that is, when a new message is going to be sent.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`zl` 对象做得很好；它传递所有 ASCII 字符，除了 `<CR>` 和 `<LF>`，并且一旦它接收到 `<LF>`，`zl` 就发送一个 bang。我们刚刚构建了一个消息处理器，每次它接收到
    `<LF>` 时都会 *重置* `zl` 缓冲区，也就是说，当一条新消息即将发送时。'
- en: '![Extracting only the payload?](img/7584_06_18.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![仅提取有效载荷？](img/7584_06_18.jpg)'
- en: The zl list processor pops out a series of integers
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: zl列表处理器会弹出一系列整数
- en: ASCII conversions and symbols
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ASCII转换和符号
- en: We have now a series of three integers directly equaling the ASCII message sent
    by the Arduino, in my case, `51 53 48`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一系列三个整数，它们直接等于Arduino发送的ASCII消息，在我的情况下，是`51 53 48`。
- en: If you turn the potentiometer, you'll change this series, of course.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你旋转电位器，当然会改变这个系列。
- en: But look at this, where is the value between 0 and 1023 we so expected? We have
    to convert the ASCII integer message into a real character one. This can be done
    using the `itoa` object (which means integer to ASCII).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 但是看看这个，我们期望的0到1023之间的值在哪里？我们必须将ASCII整数消息转换为实际的字符。这可以通过使用`itoa`对象（表示整数到ASCII）来完成。
- en: Check the related toggle, and watch the Max window.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 检查相关的切换，并观察Max窗口。
- en: '![ASCII conversions and symbols](img/7584_06_19.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![ASCII转换和符号](img/7584_06_19.jpg)'
- en: Here is our important value
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的重要值
- en: This value is the important one; it is the message sent by the Arduino over
    the wire and is transmitted as a symbol. You cannot distinguish a symbol from
    another type of message, such as an integer or a float in the Max window.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值是重要的；它是Arduino通过电线发送的消息，并以符号的形式传输。你无法在Max窗口中区分符号和其他类型的消息，如整数或浮点数。
- en: I placed two empty messages in the patch. Those are really useful for debugging
    purposes too. I connect them to the `itoa` and `fromsymbol` objects to their right
    input. Each time you send a message to another message on its right input, the
    value of the destination message is changed by the content of the other one. We
    can then display what message is really sent by `itoa` and `fromsymbol`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我在补丁中放置了两个空消息。这些对于调试目的也非常有用。我将它们连接到右侧的`itoa`和`fromsymbol`对象。每次你向右侧输入的消息发送消息时，目标消息的值就会通过另一个消息的内容而改变。然后我们可以显示`itoa`和`fromsymbol`实际发送的消息。
- en: '![ASCII conversions and symbols](img/7584_06_20.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![ASCII转换和符号](img/7584_06_20.jpg)'
- en: '"350" doesn''t equal exactly 350'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '"350"并不完全等于350'
- en: '`fromsymbol` transforms each symbol into its component parts, which here make
    up an integer, `350`.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromsymbol`将每个符号转换为它的组成部分，在这里它组成一个整数，`350`。'
- en: This final value is the one we can use with every object able to understand
    and process numbers. This value is scaled by the scale object and sent, at last,
    to the metro object. Turning the potentiometer changes the value sent, and depending
    upon the value, the metro sends bangs faster or slower.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终值是我们可以用任何能够理解和处理数字的对象使用的。这个值通过比例对象进行缩放，最后发送到metro对象。旋转电位器会改变发送的值，根据这个值，metro会更快或更慢地发送bang。
- en: 'This long example taught you two main things:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个长例子教会了你两件主要的事情：
- en: You have to carefully know what is sent and received
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须仔细了解发送和接收的内容
- en: How an Arduino communicates
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino的通信方式
- en: Now, let's move on to some other examples relating to analog inputs.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续探讨一些与模拟输入相关的一些其他示例。
- en: Playing with sensors
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与传感器玩耍
- en: What I don't want to write in this book is a big catalog. Instead of that, I
    want to give you keys and the feel of all the concepts. Of course, we have to
    be precise and learn about particular techniques you didn't invent yourself, but
    I especially want you to learn best practices, to think about huge projects by
    yourself, and to be able to have a global vision.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想在这本书中写一个大的目录。相反，我想给你提供钥匙和所有概念的感觉。当然，我们必须精确，并了解你没有发明过的特定技术，但我特别想让你学习最佳实践，自己思考大型项目，并能够有一个全局的视角。
- en: I'll give you some examples here, but I won't cover every type of sensor for
    the previously mentioned reason.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里给你举一些例子，但不会涵盖之前提到的所有类型的传感器。
- en: Measuring distances
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量距离
- en: When I design installations for others or myself, I often have the idea of measuring
    distance between moving things and a fixed point. Imagine you want to create a
    system with a variable light intensity depending on the proximity of some visitors.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当我为他人或自己设计安装时，我经常有测量移动物体与固定点之间距离的想法。想象一下，你想要创建一个系统，其光线强度根据一些访客的接近程度而变化。
- en: I used to play with a Sharp GP2Y0A02YK infrared long range sensor.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经玩过一个Sharp GP2Y0A02YK红外长距离传感器。
- en: '![Measuring distances](img/7584_06_21.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![测量距离](img/7584_06_21.jpg)'
- en: The infrared Sharp GP2Y0A-family sensor
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 红外Sharp GP2Y0A系列传感器
- en: This cool analog sensor provides good results for distances from 20 to 150 cm.
    There are other types of sensors on the market, but I like this one for its stability.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个酷炫的模拟传感器对于20到150厘米的距离提供了良好的结果。市场上还有其他类型的传感器，但我喜欢这个，因为它很稳定。
- en: As with any distance sensors, the subject/target has to theoretically be perpendicular
    to the infrared beam's direction for maximum accuracy, but in the real world,
    it works fine even otherwise.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何距离传感器一样，目标/主题理论上必须垂直于红外光束的方向，以获得最大精度，但在现实世界中，即使不是这样也能正常工作。
- en: The datasheet is a first object to take care about.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表是首先要关注的对象。
- en: Reading a datasheet?
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读数据表？
- en: First, you have to find the datasheet. A search engine can help a lot. This
    sensor's datasheet is at [http://sharp-world.com/products/devvice/lineup/data/pdf/datasheet/gp2y0a02_e.pdf](http://sharp-world.com/products/devvice/lineup/data/pdf/datasheet/gp2y0a02_e.pdf).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须找到数据表。搜索引擎可以帮上大忙。这个传感器的数据表在[http://sharp-world.com/products/devvice/lineup/data/pdf/datasheet/gp2y0a02_e.pdf](http://sharp-world.com/products/devvice/lineup/data/pdf/datasheet/gp2y0a02_e.pdf)。
- en: You don't have to understand everything. I know some fellows would blame me
    here for not explaining the datasheet, but I want my students to be relaxed about
    that. You have to filter information.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必理解一切。我知道有些人会在这里责怪我没有解释数据表，但我想让我的学生对此放松。你必须过滤信息。
- en: Ready? Let's go!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？让我们开始吧！
- en: Generally, on the first page, you have all the features summarized.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在第一页上，你可以看到所有功能的总结。
- en: Here, we can see this sensor seems to be quite independent considering the color
    of the target. Ok, good. The distance output type is very important here. Indeed,
    it means it outputs the distance directly and needs no additional circuitry to
    utilize its analog data output.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这个传感器似乎在目标颜色方面相当独立。好的，很好。距离输出类型在这里非常重要。实际上，这意味着它直接输出距离，不需要额外的电路来利用其模拟数据输出。
- en: There are often some schematics of all dimensions of the outline of the sensor.
    This can be very useful if you want to be sure the sensor fits your box or installation
    before ordering it.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 常常有一些传感器所有尺寸的轮廓图。如果你想在订购之前确保传感器适合你的盒子或安装，这可能会非常有用。
- en: In the next figure, we can see a graph. This is a curve illustrating how the
    output voltage varies according to the distance of the target.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张图中，我们可以看到一个图表。这是一条曲线，说明了输出电压如何根据目标距离变化。
- en: '![Reading a datasheet?](img/7584_06_22.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![阅读数据表？](img/7584_06_22.jpg)'
- en: Mathematical relation between distance and analog output voltage from the sensor
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器距离与模拟输出电压之间的数学关系
- en: This information is precious. Indeed, as we discussed in the previous chapter,
    a sensor converts a physical parameter into something measurable by Arduino (or
    any other type of equipment). Here, a distance is converted into a voltage.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息非常宝贵。确实，正如我们在上一章讨论的那样，传感器将一个物理参数转换成Arduino（或任何其他类型的设备）可测量的东西。在这里，距离被转换成电压。
- en: Because we measure the voltage with the analog input of our Arduino board, we
    need to know how the conversion works. And I'm going to use a shortcut here because
    I made the calculation for you.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要用Arduino板上的模拟输入来测量电压，所以我们需要了解转换是如何工作的。在这里，我将使用一个捷径，因为我已经为你做了计算。
- en: Basically, I used another graph similar to the one we saw but mathematically
    generated. We need a formula to code our firmware.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我使用了另一个与我们看到的类似的图表，但它是通过数学生成的。我们需要一个公式来编写我们的固件。
- en: 'If the output voltage increases, the distance decreases following *a kind of*
    exponential function. I had been in touch with some Sharp engineers at some point
    and they confirmed my thoughts about the type of formula, providing me with this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出电压增加，距离会按照一种指数函数减少。我曾在某个时候与一些夏普工程师联系过，他们证实了我的关于公式的想法，并给了我这个：
- en: '![Reading a datasheet?](img/7584_06_42.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![阅读数据表？](img/7584_06_42.jpg)'
- en: Here, D is the distance in centimeters and V the voltage measured; and a = 0.008271,
    b = 939.65, c = -3.398, and d = 17.339
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，D是厘米距离，V是测量的电压；a = 0.008271，b = 939.65，c = -3.398，d = 17.339
- en: This formula will be included in Arduino's logic in order to make it directly
    provide the distance to anyone who would like to know it. We could also make this
    calculation on the other side of the communication chain, in a Max 6 patch for
    instance, or even in Processing. Either way, you want to make sure your distance
    parameter data scales well when comparing the output from the sensor to the input
    where that data will be used.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式将被包含在Arduino的逻辑中，以便它可以直接向任何想知道它的人提供距离。我们也可以在通信链的另一方进行这个计算，例如在Max 6补丁中，或者在Processing中。无论如何，你想要确保你的距离参数数据在比较传感器输出和将使用该数据输入时能够很好地缩放。
- en: Let's wire things
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让我们连接东西
- en: 'This next circuit will remind you very much of the previous one. Indeed, the
    range sensor replaces the potentiometer, but it is wired in exactly the same way:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个电路会让你想起之前的那个。实际上，范围传感器替换了电位器，但它是以完全相同的方式连接的：
- en: The Vcc and ground of the Arduino board connected respectively to +5 V and ground
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino板上的Vcc和地分别连接到+5 V和地
- en: The signal legs connected to the analog input 0
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到模拟输入0的信号引脚
- en: '![Let''s wire things](img/7584_06_23.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![让我们连接东西](img/7584_06_23.jpg)'
- en: The Sharp sensor connected to the Arduino board
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到Arduino板上的Sharp传感器
- en: 'The circuit diagram is as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 电路图如下：
- en: '![Let''s wire things](img/7584_06_24.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![让我们连接东西](img/7584_06_24.jpg)'
- en: The sensor range supplied by the Arduino itself and sending voltage to the Analog
    Input 0
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino本身提供的传感器范围和发送电压到模拟输入0
- en: Coding the firmware
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写固件
- en: 'The following code is the firmware I designed:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我设计的固件代码：
- en: '[PRE4]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Is it not gratifying to know you understood every line of this code? Just in
    case though, I will provide a brief explanation.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 知道你理解了每一行代码，是不是很令人欣慰？不过，以防万一，我将提供一个简短的说明。
- en: I need some variables to store the sensor value (that is, the values from `0`
    to `1023`) coming from the ADC. Then, I need to store the voltage calculated from
    the sensor value, and of course, the distance calculated from the voltage value.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要一些变量来存储从ADC来的传感器值（即从 `0` 到 `1023` 的值）。然后，我需要存储从传感器值计算出的电压，当然，还有从电压值计算出的距离。
- en: I only initiate serial communication in the `setup()` function. Then, I make
    every calculation in the `loop()` method.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我只在 `setup()` 函数中初始化串行通信。然后，我在 `loop()` 方法中进行所有计算。
- en: I started by reading the current ADC value measured and encoded from the sensor
    pin. I use this value to calculate the voltage using the formula we already used
    in a previous firmware. Then, I inject this voltage value into the formula for
    the Sharp sensor and I have the distance.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先读取从传感器引脚测量的当前ADC值和编码值。我使用这个值来计算电压，使用我们在之前的固件中已经使用过的公式。然后，我将这个电压值注入到Sharp传感器的公式中，我就得到了距离。
- en: At last, I send the distance calculated through serial communication with the
    `Serial.println()` function.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我通过串行通信使用 `Serial.println()` 函数发送计算出的距离。
- en: Reading the distance in Max 6
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Max 6中读取距离
- en: '`Patcher006_Arduino.maxpat` is the patch related to this distance measurement
    project. Here it is:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`Patcher006_Arduino.maxpat` 是与这个距离测量项目相关的补丁。这里就是它：'
- en: '![Reading the distance in Max 6](img/7584_06_25.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![在Max 6中读取距离](img/7584_06_25.jpg)'
- en: The distance reading patch
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 距离读取补丁
- en: As we learnt previously, this patcher contains the whole design pattern to read
    messages coming from the Arduino board.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，这个补丁包含了读取来自Arduino板的消息的整个设计模式。
- en: The only new thing here is the strange UI element at the bottom. It is called
    a **slider** . Usually, sliders are used to control things. Indeed, when you click
    and drag a slider object, it pops out values. It looks like sliders on mixing
    boards or lighting dimmers, which provide control over some parameters.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的新奇之处是底部的奇怪UI元素。它被称为**滑块**。通常，滑块用于控制事物。确实，当你点击并拖动滑块对象时，它会弹出值。它看起来像调音台或调光器的滑块，可以控制某些参数。
- en: Obviously, because I want to transmit a lot of data myself here, I'm using this
    slider object as a display device and not as a control device. Indeed, the slider
    object also owns an input port. If you send a number to a slider, the slider takes
    it and updates its internal current value; it also transmits the value received.
    I'm only using it here as a display.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，因为我想要在这里传输大量数据，所以我使用这个滑块对象作为显示设备，而不是控制设备。实际上，滑块对象也有一个输入端口。如果你向滑块发送一个数字，滑块会接受它并更新其内部当前值；它也会传输接收到的值。我这里只使用它作为显示。
- en: 'Each object in Max 6 has its own parameters. Of course a lot of parameters
    are common to all objects, but some aren''t. In order to check those parameters:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: Max 6中的每个对象都有其自己的参数。当然，很多参数对所有对象都是通用的，但也有一些不是。为了检查这些参数：
- en: Select the object
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择对象
- en: Check the inspector by choosing the **Inspector** tab or typing *Ctrl* + *I*
    on Windows or *command* + *I* on OS X![Reading the distance in Max 6](img/7584_06_26.jpg)
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过选择**检查器**选项卡或在Windows上按*Ctrl* + *I*或在OS X上按*command* + *I*来检查检查器![在Max 6中读取距离](img/7584_06_26.jpg)
- en: The inspector window showing the attributes and properties of the selected slider
    object
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显示所选滑块对象属性和属性的检查器窗口
- en: I won't describe all parameters, only the two at the bottom. In order to produce
    a relevant result, I had to scale the value coming from the `fromsymbol` object.
    I know the range of values transmitted by the Arduino (though this could require
    some personal verification), having calculated them from the Sharp datasheet.
    I considered this range as 20 to 150 cm. I mean a number between 20 and 150.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会描述所有参数，只描述底部的两个。为了产生相关结果，我必须将来自`fromsymbol`对象的值进行缩放。我知道Arduino传输的值范围（尽管这可能需要一些个人验证），我已经从Sharp数据表中计算了它们。我将这个范围视为20到150厘米。我的意思是20到150之间的一个数字。
- en: I took this range and compressed and translated it a bit, using the `scale`
    object, into a `0-to-100` range of float numbers. I chose the same range for my
    slider object. Doing that, the result displayed by the slider is coherent and
    represents the real value.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这个范围进行了压缩和转换，使用`scale`对象将其转换为浮点数的`0-to-100`范围。我为我的滑块对象选择了相同的范围。这样做，滑块显示的结果是一致的，并代表真实值。
- en: 'I didn''t write any increment marks on the slider but only made two comments:
    `near` and `far`. It is a bit poetic in this world of numbers.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有在滑块上写任何增量标记，只做了两个注释：“近”和“远”。在这个数字的世界里，这有点诗意。
- en: Let's check some other examples of sensors able to pop out continuous voltage
    variations.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其他一些能够弹出连续电压变化的传感器的例子。
- en: Measuring flexion
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量弯曲
- en: Flexi sensors are also very much in use. Where the distance sensor is able to
    convert a measured distance into voltage, the flexi sensor measures flexion and
    provides a voltage.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 柔性传感器也非常有用。在距离传感器能够将测量的距离转换为电压的地方，柔性传感器测量弯曲并提供电压。
- en: Basically, the device flexion is related to a variable resistance able to make
    a voltage vary according to the amount of flexion.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，设备的弯曲与一个能够根据弯曲量使电压变化的可变电阻相关。
- en: '![Measuring flexion](img/7584_06_27.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![测量弯曲](img/7584_06_27.jpg)'
- en: A standard flexi sensor with two connectors only
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两个连接器的标准柔性传感器
- en: A flexi sensor can be used for many purposes.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 柔性传感器可用于许多用途。
- en: I like to use it to inform computer through Arduino about door position in digital
    installations I design. People wanted initially to know only about whether doors
    are open or closed, but I proposed to use a flexi and got very good information
    about the angle of openness.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢用它通过Arduino通知计算机我设计的数字安装中的门位置。最初人们只想知道门是打开还是关闭，但我提出使用柔性传感器，并获得了关于开启角度的非常准确的信息。
- en: 'The following figure illustrates how the sensor works:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了传感器的工作原理：
- en: '![Measuring flexion](img/7584_06_28.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![测量弯曲](img/7584_06_28.jpg)'
- en: 'Now, I''m directly giving you the wiring schematic made again with Fritzing:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将直接给你看用Fritzing再次制作的接线图：
- en: '![Measuring flexion](img/7584_06_29.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![测量弯曲](img/7584_06_29.jpg)'
- en: Flexi sensor connected to Arduino board with the pull-down resistor
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 柔性传感器连接到Arduino板上的下拉电阻
- en: I put a pull-down resistor. If you didn't read [Chapter 5](ch05.html "Chapter 5. Sensing
    with Digital Inputs"), *Sensing with Digital Inputs*, about pull-up and pull-down
    resistors, I suggest you to do that now.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个下拉电阻。如果你还没有阅读关于上拉和下拉电阻的[第5章](ch05.html "第5章。使用数字输入进行感应")，*使用数字输入进行感应*，我建议你现在去阅读。
- en: Usually, I use resistors about 10K Ω and they work fine.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我使用大约10K Ω的电阻，它们工作得很好。
- en: 'The circuit diagram is shown in the following figure:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 电路图如下所示：
- en: '![Measuring flexion](img/7584_06_30.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![测量弯曲](img/7584_06_30.jpg)'
- en: The flexi sensor and its pull-down resistor wired to the Arduino
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 柔性传感器及其下拉电阻连接到Arduino
- en: Resistance calculations
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电阻计算
- en: For this project, I won't give you the code because it is very similar to the
    previous one, except for the calculation formulas. It is these resistance calculation
    formulas I'd like to discuss here.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我不会给你代码，因为它与上一个项目非常相似，只是计算公式不同。我想在这里讨论的是这些电阻计算公式。
- en: What do we do if we don't have the graph the Sharp Co. was kind enough to include
    with their infrared sensor? We have to resort to some calculations.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有Sharp公司慷慨提供的红外传感器图，我们该怎么办？我们必须求助于一些计算。
- en: Usually, the flexi sensor documentation provides resistance values for it when
    it is not bent and when it is bent at 90 degrees. Let's say some usual values
    of 10K Ω and 20K Ω, respectively.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，柔性传感器文档提供了当它未弯曲和当它弯曲到90度时的电阻值。让我们假设一些常见的值，如10K Ω和20K Ω，分别。
- en: What are the voltage values we can expect for these resistances values, including
    the pull-down one too?
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些电阻值，包括下拉电阻，我们可以期望的电压值是什么？
- en: 'Considering the electrical schematic, the voltage at the analog pin 0 is:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到电气原理图，模拟引脚0的电压是：
- en: '![Resistance calculations](img/7584_06_45.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![电阻计算](img/7584_06_45.jpg)'
- en: 'If we choose the same resistance for the pull-down as the one for the flexi
    when it is not flexed, we can expect the voltage to behave according to this formula:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择与未弯曲时的柔性电阻相同的下拉电阻，我们可以期望电压按照这个公式变化：
- en: '![Resistance calculations](img/7584_06_43.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![电阻计算](img/7584_06_43.jpg)'
- en: 'Obviously, by using the same formula when it isn''t bent, we can expect:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，通过在未弯曲时使用相同的公式，我们可以期望：
- en: '![Resistance calculations](img/7584_06_44.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![电阻计算](img/7584_06_44.jpg)'
- en: This means we found our range of voltage values.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们找到了我们的电压值范围。
- en: We can now convert that into digital 10-bit, encoded values, I mean the famous
    0-to-1023 range of Arduino's ADC.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这些数据转换为数字10位，编码值，我的意思是Arduino的ADC著名的0到1023的范围。
- en: 'A small, easy calculation provides us with the values:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小的简单计算为我们提供了以下值：
- en: '`511` when the voltage is 2.5 (when the flexi isn''t bent)'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当电压为2.5时（当柔性未弯曲时），电压为`511`
- en: '`347` when the voltage is 1.7 (when the flexi is bent at around a 90-degree
    angle)'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当电压为1.7时（当柔性弯曲在约90度角时），电压为`347`
- en: Because the voltage at Arduino's pin depends on the inverse of the resistance,
    we don't have a perfectly linear variation.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Arduino引脚上的电压取决于电阻的倒数，所以我们没有完美的线性变化。
- en: Experience tells me I can almost approximate this to a linear variation, and
    I used a scale function in Arduino firmware in order to map `[347,511]` to a simplerange
    of `[0,90]`. `map(value, fromLow, fromHigh, toLow, toHigh)` is the function to
    use here.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 经验告诉我，我可以几乎将其近似为线性变化，我在Arduino固件中使用了缩放函数，将`[347,511]`映射到更简单的范围`[0,90]`。`map(value,
    fromLow, fromHigh, toLow, toHigh)`是这里要使用的函数。
- en: Do you remember the `scale` object in Max 6? `map()` works basically the same
    way, but for the Arduino. The statement here would be `map(347,511,90,0)`. This
    would give a fairly approximated value for the physical angle of bend.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得Max 6中的`scale`对象吗？`map()`基本上以相同的方式工作，但针对Arduino。这里的语句将是`map(347,511,90,0)`。这将给出一个相当近似的物理弯曲角度值。
- en: The `map` function works in both directions and can map number segments going
    in the opposite direction. I guess you begin to see what steps to follow when
    you have to work with analog inputs on the Arduino.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`函数在两个方向上都可以工作，可以将相反方向的数字段进行映射。我想你开始看到当你需要在Arduino上处理模拟输入时应该遵循的步骤。'
- en: Now, we are going to meet some other sensors.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将遇到一些其他传感器。
- en: Sensing almost everything
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几乎可以感知一切
- en: Whatever the physical parameter you want to measure, there's a sensor for it.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你想测量哪个物理参数，都有相应的传感器。
- en: 'Here is a small list:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小列表：
- en: Light color and light intensity
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色和亮度
- en: Sound volume
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音音量
- en: Radioactivity intensity
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放射性强度
- en: Humidity
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 湿度
- en: Pressure
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压力
- en: Flexion
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弯曲
- en: Liquid level
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 液位
- en: Compass and direction related to magnetic north
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 罗盘和与磁北相关的方向
- en: Gas-specific detection
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气体特定检测
- en: Vibration intensity
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 振动强度
- en: Acceleration on three axes (x, y, z)
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三轴（x，y，z）加速度
- en: Temperature
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 温度
- en: Distance
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离
- en: Weight (different for a pure flexion sensor)
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重量（纯弯曲传感器不同）
- en: It isn't an exhaustive list, but it is quite complete.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个详尽的列表，但相当完整。
- en: Prices are really variable from a few dollars to $50 or $60\. I found one of
    the cheaper Geiger counters for around $100\. You can find a huge list of companies
    available on the Internet to buy sensors from in *Appendix G, List of Components'
    Distributors*.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 价格变化很大，从几美元到50或60美元。我找到了一个价格较低的盖革计数器，大约100美元。你可以在*附录G，组件分销商列表*中找到大量可以在互联网上购买传感器的公司。
- en: Now, let's move further. How can we handle multiple analog sensors? The first
    answer is by wiring everything to many analog inputs of the Arduino. Let's check
    if we can be smarter than that.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更进一步。我们如何处理多个模拟传感器？第一个答案是，将所有东西都连接到Arduino的多个模拟输入。让我们看看我们是否可以比这更聪明。
- en: Multiplexing with a CD4051 multiplexer/demultiplexer
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CD4051复用器/解复用器进行复用
- en: We are going to explore a technique called **multiplexing** . This is a major
    subchapter because we are going to learn how to make our real-life project more
    concrete, more real.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索一种称为**复用**的技术。这是一个重要的子章节，因为我们将要学习如何使我们的实际项目更加具体、更加真实。
- en: We often have many constraints in the real world. One can be the number of Arduinos
    available. This constraint can also come from having a computer that has only
    one USB port. Yes, this happens in real life, and I would be lying if I said you
    can have every connector you want, whenever you want, within the budget you want.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们经常有许多限制。其中一个可能是可用的Arduino数量。这种限制也可能来自于只有单个USB端口的计算机。是的，这种情况在现实生活中确实会发生，如果我说我可以在你想要的任何时候，在你想要的预算内拥有你想要的每一个连接器，那我就是在撒谎。
- en: Imagine that you have to plug more than eight sensors to you Arduino's analog
    input. How would you do it?
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你不得不将超过八个传感器连接到Arduino的模拟输入。你会怎么做？
- en: We will learn to multiplex signals.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何复用信号。
- en: Multiplexing concepts
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复用概念
- en: Multiplexing is quite common in the telecommunications world. Multiplexing defines
    techniques providing efficient ways to make multiple signals share a single medium.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 复用在电信世界中相当常见。复用定义了提供有效方式让多个信号共享单一介质的技巧。
- en: '![Multiplexing concepts](img/7584_06_31.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![复用概念](img/7584_06_31.jpg)'
- en: Basic multiplexing concept showing the shared medium
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 基本复用概念展示了共享介质
- en: This technique provides a very helpful concept in which you only need one shared
    medium to bring many channels of information as we can see in the previous figure.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术提供了一个非常有帮助的概念，其中你只需要一个共享介质来带来许多信息通道，正如我们在前面的图中可以看到的那样。
- en: Of course, it involves multiplexing (named mux in the figure) and demultiplexing
    (demux) processes.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这涉及到复用（在图中称为mux）和解复用（demux）过程。
- en: Let's dig into those processes a bit.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨一下这些过程。
- en: Multiple multiplexing/demultiplexing techniques
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多种复用/解复用技术
- en: When we have to multiplex/demultiplex signals, we basically have to find a way
    to separate them using physical quantities that we can control.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要复用/解复用信号时，我们基本上需要找到一种方法，通过我们可以控制的物理量来分离它们。
- en: 'I can list at least three types of multiplexing techniques:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我至少可以列出三种复用技术类型：
- en: space-division multiplexing
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空分复用
- en: frequency-division multiplexing
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频分复用
- en: time-division multiplexing
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时分复用
- en: Space-division multiplexing
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空分复用
- en: This is the easiest to grasp.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最容易理解的。
- en: '![Space-division multiplexing](img/7584_06_32.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![空分复用](img/7584_06_32.jpg)'
- en: Space-division multiplexing physically agglomerates all wires into the same
    place
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 空分复用将所有电线物理地聚集到同一个地方
- en: This concept is the basic phone network multiplexing in your flat, for instance.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个概念是您公寓中的基本电话网络复用。
- en: Your phone wires go out, as those from your neighbors, and all those wires are
    joined into one shielded, big multipair cable containing, for instance, all phone
    wires for the whole building in which you live. This huge multipair cable goes
    into the street, and it is easier to catch it as a single global cable than if
    you had to catch each cable coming from your neighbors plus yours.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 你的电话线，就像你邻居的电话线一样，所有这些线都被连接到一个屏蔽的大多对电缆中，例如，包含你居住的整个建筑中的所有电话线。这条巨大的多对电缆进入街道，将其作为一个全局电缆捕获比捕获来自你邻居的每根电缆加上你自己的电缆要容易。
- en: 'This concept is easily transposable to Wi-Fi communications. Indeed, some Wi-Fi
    routers today provide more than one Wi-Fi antenna. Each antenna would be able,
    for instance, to handle one Wi-Fi link. Every communication would be transmitted
    using the same medium: air transporting electromagnetic waves.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念很容易转化为Wi-Fi通信。确实，今天一些Wi-Fi路由器提供了不止一个Wi-Fi天线。例如，每个天线都能够处理一个Wi-Fi连接。每一次通信都会使用相同的介质：空气传输电磁波。
- en: Frequency-division multiplexing
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 频分复用
- en: This type of multiplexing is very common in everything related to DSL and cable
    TV connections.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复用技术在所有与DSL和有线电视连接相关的事物中都非常常见。
- en: Service providers can (and do) provide more than one service on the same cable
    using this technique.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 服务提供商可以使用这种技术通过同一根电缆提供多个服务。
- en: '![Frequency-division multiplexing](img/7584_06_33.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![频分复用](img/7584_06_33.jpg)'
- en: Frequency-division multiplexing plays with frequencies of transmission and bandwidths
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 频分复用与传输频率和带宽玩游戏
- en: Imagine the **1**, **2**, and **3** frequency bands on the figure would be three
    different services. 1 could be voice, 2 could be internet, and 3 TV. The reality
    isn't too far from this.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下图中的**1**、**2**和**3**频率波段是三种不同的服务。1可能是语音，2可能是互联网，3是电视。现实与这并不太远。
- en: Of course, what we multiplex at one end, we have to demultiplex at the other
    in order to address our signals correctly. I wouldn't try to convert a TV modulated
    signal into voice, but I'm guessing it wouldn't be a very fruitful experience.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们在一端复用的东西，我们必须在另一端解复用，以便正确地处理我们的信号。我不会尝试将电视调制的信号转换为语音，但我猜这不会是一次很有成效的经历。
- en: Time-division multiplexing
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时分复用
- en: This is the case we are going to dig into the deepest because this is the one
    we are going to use with the Arduino to multiplex many signals.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要深入挖掘的情况，因为这是我们将在Arduino上用于多路复用的信号。
- en: '![Time-division multiplexing](img/7584_06_34.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![时分复用](img/7584_06_34.jpg)'
- en: Time-division multiplexing illustrated with an example of one cycle of four
    steps
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个四步周期的例子说明时分复用
- en: Sequentially, only one channel between the multiplexer and the demultiplexer
    is fully used for the first signal, then the second, and so on, until the last
    one.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 依次，多路复用器和多路分解器之间只有一条通道被完全用于第一个信号，然后是第二个，以此类推，直到最后一个。
- en: This kind of system often involves a clock. This helps in setting the right
    cycle for each participant so they know at which step of communication we are.
    It is critical that we preserve the safety and integrity of communications.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这种系统通常涉及一个时钟。这有助于为每个参与者设置正确的周期，以便他们知道我们在通信的哪个步骤。保持通信的安全性和完整性至关重要。
- en: Serial communications work like that, and for many reasons—even if you think
    you know them a lot after previous chapters—we'll dig a bit deeper into them in
    the next chapter.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 串行通信就是这样工作的，并且由于许多原因——即使你在前面的章节中认为你已经了解了很多——我们将在下一章中更深入地探讨它们。
- en: Let's check how we can deal with eight sensors and only one analog input for
    our Arduino board.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查一下如何处理我们的Arduino板上的八个传感器和仅有一个模拟输入。
- en: The CD4051B analog multiplexer
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CD4051B模拟多路复用器
- en: The CD4051B analog multiplexer is a very cheap one and is very useful. It is
    basically an analog and digital multiplexer and demultiplexer. This doesn't mean
    you can use it as a multiplexer and a demultiplexer at the same time. You have
    to identify in what case you are and wire and design the code for this proper
    case. But it is always useful to have a couple of CD4051B devices.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: CD4051B模拟多路复用器非常便宜且非常有用。它基本上是一个模拟和数字多路复用器和多路分解器。这并不意味着你可以同时将其用作多路复用器和多路分解器。你必须确定你处于哪种情况，并为此情况布线和设计代码。但总是拥有几台CD4051B设备是有用的。
- en: Used as a multiplexer, you can connect, say eight potentiometers to the CD4051B
    and only one Arduino analog input, and you'll be able, by code, to read all 8
    values.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 用作多路复用器时，你可以将八个电位器连接到CD4051B，并只有一个Arduino模拟输入，然后通过代码读取所有8个值。
- en: Used as a demultiplexer, you could write to eight analog outputs by writing
    from only one Arduino pin. We'll talk about that a bit later in this book, when
    we approach the output pin and especially the **pulse-width modulation** (**PWM**)
    trick with LEDs.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 用作多路分解器时，你可以通过只从Arduino的一个引脚写入来写入八个模拟输出。我们将在本书稍后讨论这一点，当我们接近输出引脚，特别是与LED的**脉冲宽度调制**（**PWM**）技巧时。
- en: What is an integrated circuit?
  id: totrans-506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成电路是什么？
- en: An **integrated circuit** (**IC**) is an electronic circuit miniaturized and
    all included in a small box of plastic. This is the simplest definition.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成电路**（**IC**）是一个微型化并全部包含在一个小塑料盒中的电子电路。这是最简单的定义。'
- en: Basically, we cannot talk about integrated circuits without bringing to mind
    their small size. It is one of the more interesting features of IC.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们无法谈论集成电路而不想到它们的小尺寸。这是集成电路的一个更有趣的特点。
- en: The other one is what I am naming the **black box abstraction** . I also define
    it like the programming-like classes of the hardware world. Why? Because you don't
    have to know exactly how it works but only how you can use it. It means all the
    circuits inside don't really matter if the legs outside make sense for your own
    purpose.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是我称之为**黑盒抽象**的东西。我也像硬件世界的编程类一样定义它。为什么？因为你不必确切知道它是如何工作的，只需知道如何使用它。这意味着如果外部引脚对你自己的目的有意义，那么内部的电路实际上并不重要。
- en: 'Here are two among several type of IC packages:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是几种IC封装类型中的两种：
- en: '**Dual in-line package** (**DIP**, also named **DIL**)'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双列直插封装**（**DIP**，也称为**DIL**）'
- en: '**Small** **outline** (**SO**)'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小外形**（**SO**）'
- en: You can find a useful guide at [http://how-to.wikia.com/wiki/Guide_to_IC_packages](http://how-to.wikia.com/wiki/Guide_to_IC_packages).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://how-to.wikia.com/wiki/Guide_to_IC_packages](http://how-to.wikia.com/wiki/Guide_to_IC_packages)找到一份有用的指南。
- en: The more commonly used of the two ICs are definitely DIPs. They are also called
    through-holes. We can easily manipulate and plug them into a breadboard or **printed**
    **circuit board** (**PCB**).
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 两种IC中更常用的是DIP封装。它们也被称为通孔封装。我们可以轻松地操作并将它们插入到面包板或**印刷电路板**（**PCB**）上。
- en: SO requires more dexterity and finer tools.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: SO需要更多的灵巧和更精细的工具。
- en: Wiring the CD4051B IC?
  id: totrans-516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何布线CD4051B IC？
- en: The first question is about *what* it looks like? In this case, the answer is
    that it looks like a DIP package.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题关于它**看起来**像什么？在这种情况下，答案是它看起来像DIP封装。
- en: '![Wiring the CD4051B IC?](img/7584_06_35.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![如何布线CD4051B IC？](img/7584_06_35.jpg)'
- en: The CD4051B DIP case version
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: CD4051B DIP封装版本
- en: 'Here is the face of this nice little integrated circuit. The datasheet is easy
    to find on the Internet. Here is one by Texas Instruments:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个小巧的集成电路的正面。数据表在互联网上很容易找到。这里有一个来自德州仪器的：
- en: '[http://www.ti.com/lit/ds/symlink/cd4051b.pdf](http://www.ti.com/lit/ds/symlink/cd4051b.pdf)'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.ti.com/lit/ds/symlink/cd4051b.pdf](http://www.ti.com/lit/ds/symlink/cd4051b.pdf)'
- en: I redrew the global package in the next figure.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我在下一张图中重新绘制了全局封装。
- en: '![Wiring the CD4051B IC?](img/7584_06_36.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![如何布线CD4051B IC？](img/7584_06_36.jpg)'
- en: A schematic of the CD4051B with all pin descriptions
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 带有所有引脚描述的CD4051B原理图
- en: Identifying pin number 1
  id: totrans-525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 识别引脚编号1
- en: It is easy easy to find out which pin is pin number 1\. As standard, there is
    a small circle engraved in front of one of the corner pins. This is the pin number
    1.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易找出哪个是引脚编号1。按照标准，其中一个角落引脚前面刻有一个小圆圈。这就是引脚编号1。
- en: There is also a small hole shaped as a half circle. When you place the IC with
    this half circle at the top (as shown on the previous figure), you know which
    pin number 1 is; the first pin next to pin number 1 is pin number 2, and so on,
    until the last pin of the left column which, in our case, is pin number 8\. Then,
    continue with the pin opposite to the last one in the left column; this is pin
    number 9, and the next pin is pin number 10, and so on, until the top of the right
    column.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个半圆形的小孔。当你将IC放置在这个半圆形在顶部（如图中所示）时，你就知道哪个是引脚编号1；紧挨着引脚1的第一个引脚是引脚2，以此类推，直到左列的最后一个引脚，在我们的例子中是引脚8。然后，继续与左列最后一个引脚相对的引脚；这是引脚9，下一个引脚是引脚10，以此类推，直到右列的顶部。
- en: '![Identifying pin number 1](img/7584_06_37.jpg)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
  zh: '![识别引脚编号1](img/7584_06_37.jpg)'
- en: Numbering the pins of an IC
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: IC引脚编号
- en: Of course, it would be much too simple if the first input was pin 1\. The only
    real way you can know for sure is to check the specs.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果第一个输入是引脚1，那就太简单了。唯一真正能确定的方法是查看规格。
- en: Supplying the IC
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为IC供电
- en: The IC itself has to be supplied. This is to make it active but also, in some
    cases, to drive the current too.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: IC本身必须供电。这是为了使其激活，在某些情况下，还可以驱动电流。
- en: Vdd is the positive supply voltage pin. It has to be wired to the 5 V supply.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vdd是正电源电压引脚。它必须连接到5V电源。
- en: Vee is the negative supply voltage pin. Here, we'll wire it to Ground.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vee是负电源电压引脚。在这里，我们将它连接到地。
- en: Vss is the ground pin, connected to Ground too.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vss是地引脚，也连接到地。
- en: Analog I/O series and the common O/I
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟I/O系列和常见的O/I
- en: Check the order of the I and the O in this title.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 检查这个标题中I和O的顺序。
- en: If you choose to use the CD4051B as a multiplexer, you'll have multiple analog
    inputs and one common output.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择使用CD4051B作为多路复用器，你将有多路模拟输入和一个公共输出。
- en: On the other hand, if you choose to use it as a demultiplexer, you'll have one
    common input and multiple analog outputs.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你选择将其用作解复用器，你将有一个公共输入和多个模拟输出。
- en: How does the selection/commutation work? Let's check the selector's digital
    pins, A, B, and C.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 选择/切换是如何工作的？让我们检查选择器的数字引脚，A、B和C。
- en: Selecting the digital pin
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择数字引脚
- en: Now comes the most important part.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最重要的部分。
- en: There are three pins, named A (pin 11), B (pin10), and C (pin 9), that have
    to be driven by digital pins of the Arduino. What? Aren't we in the analog inputs
    part? We totally are, but we'll introduce a new method of control using these
    three selected pins.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个引脚，命名为A（引脚11）、B（引脚10）和C（引脚9），必须由Arduino的数字引脚驱动。什么？我们不是在模拟输入部分吗？我们完全是在，但我们将使用这三个选定的引脚介绍一种新的控制方法。
- en: The multiplexing engine under the hood isn't that hard to understand.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的多路复用引擎并不难理解。
- en: Basically, we send some signal to make the CD4051B commute the inputs to the
    common output. If we wanted to use it as a demultiplexer, the three selected pins
    would have to be controlled exactly in the same way.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们发送一些信号来使CD4051B将输入切换到公共输出。如果我们想将其用作解复用器，三个选定的引脚必须以完全相同的方式控制。
- en: In the datasheet, I found a table of truth. What is that? It is just a table
    where we can check which A, B, and C combinations commute the inputs to the common
    output.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据表中，我发现了一个真值表。那是什么？它只是一个表格，我们可以检查哪些A、B和C组合将输入切换到公共输出。
- en: 'The following table describes the combination:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 下表描述了组合：
- en: '![Selecting the digital pin](img/7584_06_38.jpg)'
  id: totrans-548
  prefs: []
  type: TYPE_IMG
  zh: '![选择数字引脚](img/7584_06_38.jpg)'
- en: The truth table for the CD4051B
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: CD4051B的真值表
- en: In other words, it means that, if we write 1 to the digital output on Arduino
    corresponding to A, 1 to that corresponding to B and 0 to that corresponding to
    C, the commuted input would be the third channel.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这意味着如果我们向Arduino上对应于A的数字输出写入1，对应于B的写入1，对应于C的写入0，则切换的输入将是第三个通道。
- en: Of course, there is something good in this. If you *read* the binary number
    corresponding to the inputs on C, B, and A (in that order), you'll have a nice
    surprise; it will be equivalent to the decimal number of the input pin commuted
    by the common output.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里有一些好处。如果你*读取*对应于C、B和A（按此顺序）的输入的二进制数，你会有一个惊喜；它将等同于公共输出切换的输入引脚的十进制数。
- en: 'Indeed, 0 0 0 in binary equals 0 in decimal. Refer the table for the binary
    values of decimal numbers:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，二进制的0 0 0等于十进制的0。参考表格以获取十进制数的二进制值：
- en: '| 0 0 0 | 0 |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| 0 0 0 | 0 |'
- en: '| 0 0 1 | 1 |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| 0 0 1 | 1 |'
- en: '| 0 1 0 | 2 |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| 0 1 0 | 2 |'
- en: '| 0 1 1 | 3 |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| 0 1 1 | 3 |'
- en: '| 1 0 0 | 4 |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| 1 0 0 | 4 |'
- en: '| 1 0 1 | 5 |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| 1 0 1 | 5 |'
- en: '| 1 1 0 | 6 |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| 1 1 0 | 6 |'
- en: '| 1 1 1 | 7 |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| 1 1 1 | 7 |'
- en: 'Here is how we could wire things:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们如何连接东西的方法：
- en: '![Selecting the digital pin](img/7584_06_39.jpg)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
  zh: '![选择数字引脚](img/7584_06_39.jpg)'
- en: The circuit including the CD4051B multiplexer with its common output wired to
    the analog pin 0
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 包括CD4051B多路复用器和其公共输出连接到模拟引脚0的电路
- en: 'And the following figure is the electrical diagram:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图是电气图：
- en: '![Selecting the digital pin](img/7584_06_40.jpg)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![选择数字引脚](img/7584_06_40.jpg)'
- en: The electrical diagram
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 电气图
- en: All devices we'd like to read with this system should be wired to I/O 0, 1,
    2, and so on, on the CD4051B.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用这个系统读取的所有设备都应该连接到CD4051B上的I/O 0、1、2等端口。
- en: 'Considering what we know about table of truth and how the device works, if
    we want to read sequentially all pins from 0 to 7, we will have to make a loop
    containing both types of statements:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们对真值表的了解以及设备的工作方式，如果我们想顺序读取从0到7的所有引脚，我们必须在循环中包含两种类型的语句：
- en: One for commuting the multiplexer
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于切换多路复用器
- en: One for reading the Arduino analog input 0
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于读取Arduino模拟输入0
- en: 'The source code would look like this (you can find it in the `Chapter6/analogMuxReader`
    folder):'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码看起来像这样（你可以在`Chapter6/analogMuxReader`文件夹中找到它）：
- en: '[PRE5]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After you've defined all the variables, we set up the serial port in `setup()`
    and also the three pins related to the selector pin of the CD4051B as outputs.
    Then, in each cycle, I first select the commuted input by either driving the current
    or not to pins A, B, and C of the CD4051B. I'm using a nested function in my statement
    in order to save some rows.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了所有变量之后，我们在`setup()`中设置串行端口，并将与CD4051B选择引脚相关的三个引脚作为输出。然后，在每个周期中，我首先通过驱动或不对CD4051B的A、B和C引脚供电来选择切换的输入。我在我的语句中使用嵌套函数来节省一些行。
- en: '`bitRead(number,n)` is a new function able to return the *nth* bit of a number.
    It is the perfect function for us in our case.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`bitRead(number,n)`是一个新函数，能够返回一个数的*第n*位。在我们的情况下，这是一个完美的函数。'
- en: We make a loop over the input commuted from 0 to 7, more precisely to `devicesNumber
    - 1`.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对从0到7的输入进行循环，更确切地说，到`devicesNumber - 1`。
- en: By writing those bits to pins A, B, and C of the CD4051B device, it selects
    the analog input at each turn and pops the value read at the serial port for further
    processing in Processing or Max 6 or whatever software you want to use.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些位写入CD4051B设备的引脚A、B和C，它每次选择模拟输入，并将串行端口读取的值弹出，以便在Processing或Max 6或您想使用的任何软件中进行进一步处理。
- en: Summary
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learnt at least how to approach a very powerful graphical
    framework environment named Max 6\. We'll use it in several further examples in
    this book as we continue to use Processing too.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们至少学会了如何接近一个名为Max 6的非常强大的图形框架环境。随着我们继续使用Processing，我们将在本书的几个后续示例中使用它。
- en: We learnt some reflexes for when we want to handle sensors providing continuous
    voltage variations to our Arduino analog inputs.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要处理为Arduino模拟输入提供连续电压变化的传感器时，我们学到了一些反射技巧。
- en: Then, we also discovered a very important technique, the multiplexing/demultiplexing.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还发现了一个非常重要的技术，即复用/解复用技术。
- en: We are going to talk about it in the next chapter about serial communication.
    We'll dig deeper into this type of communication now that we have used a lot of
    time already.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章关于串行通信的章节中讨论它。既然我们已经花费了很多时间，现在我们将更深入地探讨这种通信类型。
