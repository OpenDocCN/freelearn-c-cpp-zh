- en: Chapter 2. First Contact with C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my life as a programmer, I encountered a lot of compiler-based as well as
    scripting languages. One of the lowest common denominators has always been the
    C language.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, this is **embedded system programming**, which is another name
    for **hardware programming**; this first statement is also true.
  prefs: []
  type: TYPE_NORMAL
- en: Let's check what C programming really is and let's enter into a new world, that
    is, the realm of Arduino programming. We'll also use a very necessary feature
    called **serial monitoring**. This will help us a lot in our C learning, and you'll
    understand that this feature is also used in real-life projects.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first question is, **what is a program?**
  prefs: []
  type: TYPE_NORMAL
- en: A **program** is text that you write using a programming language that contains
    behaviors that you need a processor to acquire. It basically creates a way of
    handling inputs and producing outputs according to these behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Wikipedia ([http://en.wikipedia.org/wiki/Computer_programming](http://en.wikipedia.org/wiki/Computer_programming)):'
  prefs: []
  type: TYPE_NORMAL
- en: Programming is the process of designing, writing, testing, debugging and maintaining
    the source code of computer programs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Of course, this definition is very simple and it also applies to microcontrollers,
    as we already know that the latter are basically a type of computers.
  prefs: []
  type: TYPE_NORMAL
- en: '*Designing a program* is the fact you have to think about first, before you
    begin coding it. It generally involves writing, drawing, and making schematics
    of all the actions you want your processor to make for you. Sometimes, it also
    implies to write what we call **pseudocode**. I hope you remember that this is
    what we created in the previous chapter when we wanted to define precisely all
    the steps of our desired LED behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: I don't agree with a lot of people calling it *pseudocode* because it is actually
    more of a *real code*.
  prefs: []
  type: TYPE_NORMAL
- en: What we call *pseudocode* is something that helps a lot because it is human-readable,
    made of clear sentences, and is used to think and illustrate better our purpose,
    which is the key to success.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of my firmware *pseudocode*''s definition could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Measure the current thermic sensor value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the temperature is greater than 30° C and make a sound if it is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not, light the blue LED.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And make those previous steps permanent in a loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Writing a program* is typically what converts the pseudocode into real and
    well-formed code. It involves having knowledge of programming languages because
    it is the step when you really write the program. This is what we''ll learn in
    a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing* is the obvious step when you run the program after you made some
    modifications to the code. It is an exciting moment when you also are a bit afraid
    of bugs, those annoying things that make running your program absolutely different
    from what you expected at first.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Debugging* is a very important step when you are trying to find out why that
    program doesn''t work well as expected. You are tracking typo errors, logic discrepancies,
    and global program architecture problems. You''ll need to monitor things and often
    modify your program a bit in order to precisely trace how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Maintaining the source code* is the part of the program''s life that helps
    to avoid obsolescence.'
  prefs: []
  type: TYPE_NORMAL
- en: The program is working and you improve it progressively; you make it up-to-date
    considering hardware evolutions, and sometimes, you debug it because the user
    has this still undiscovered bug. This step increases the life duration of your
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Different programming paradigms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **paradigm** is a manner of describing something. It can either be a representation
    or a theoretical model of something.
  prefs: []
  type: TYPE_NORMAL
- en: Applied to programming, a programming paradigm is *a fundamental style of computer
    programming*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are four main programming paradigms:'
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imperative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some languages follow not one but multiple paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not the purpose of this book to have a debate around those, but I would
    add one, which can be a combination of these and which also describes a particular
    concept: **visual programming**. We''ll discover one of the most powerful frameworks
    in [Chapter 6](ch06.html "Chapter 6. Sensing the World – Feeling with Analog Inputs"),
    *Sensing the World — Feeling with Analog Inputs*, namely the **Max 6** framework
    (formerly named **Max/MSP**).'
  prefs: []
  type: TYPE_NORMAL
- en: Programming style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is no scientific or universal way to define what is the absolute best
    style of programming. However, I can quote six items that can help to understand
    what we''ll try to do together all along this book in order to make good programs.
    We''ll aim for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability**: This enables a code to handle its own generated errors while
    running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solidity**: This provides a frame to anticipate problems on the user side
    (wrong inputs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ergonomics**: This helps to intuitively be able to use it with ease'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: This is the designing of a program for a wide range of platforms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: This is the ease of modifying it even if you didn''t code
    it yourself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: This indicates that a program runs very smoothly without consuming
    a lot of resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, we'll come back to them in the examples of this book, and I'm sure
    you'll improve your style progressively.
  prefs: []
  type: TYPE_NORMAL
- en: C and C++?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dennis Ritchie** [http://en.wikipedia.org/wiki/Dennis_Ritchie](http://en.wikipedia.org/wiki/Dennis_Ritchie))
    at Bell Labs developed the C programming language from 1969 to 1973\. It is often
    defined as a general-purpose programming language and is indeed one of the most
    used languages of all times. It had been used initially to design the Unix operating
    system ([http://en.wikipedia.org/wiki/Unix](http://en.wikipedia.org/wiki/Unix))
    that had numerous requirements, especially high performance.'
  prefs: []
  type: TYPE_NORMAL
- en: It has influenced a lot of very well known and used languages such as C++, Objective-C,
    Java, JavaScript, Perl, PHP, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: C is to both **imperative** and **structured**. It is very appropriate for both
    8-bit and 64-bit processors, for systems having not only several bytes of memory
    but also terabytes too, and also for huge projects involving huge teams, to the
    smallest of projects with a single developer.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, we are going to learn a language that will open your mind to global and
    universal programming concepts!
  prefs: []
  type: TYPE_NORMAL
- en: C is used everywhere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Indeed, the C language provides a lot of advantages. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*It is small and easy to learn.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*It is processor-independent* because *compilers* exist for almost all processors
    in the world. This independence provides something very useful to programmers:
    they can focus on algorithms and the application levels of their job instead of
    thinking about the hardware level at each row of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*It is a very "low-level" high-level language*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is its main strength. Dennis M. Ritchie, in his book *The C Programming
    Language* written with Brian W. Kernighan commented on C as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C is a relatively "low level" language. This characterization is not pejorative;
    it simply means that C deals with the same sort of objects that most computers
    do. These may be combined and moved about with the arithmetic and logical operators
    implemented by real machines.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Today, this is the only language that allows interacting with the underlying
    hardware engine so easily and this is the reason why the Arduino toolchain is
    based on C.
  prefs: []
  type: TYPE_NORMAL
- en: Arduino is programmed with C and C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ can be considered as a superset of C. It means C++ brings new concepts and
    elements to C. Basically, C++ can be defined as C with object-oriented implementation
    ([http://en.wikipedia.org/wiki/Object-oriented_programming](http://en.wikipedia.org/wiki/Object-oriented_programming)),
    which is a higher-level feature. This is a very nice feature that brings and provides
    new ways of design.
  prefs: []
  type: TYPE_NORMAL
- en: We'll enter together into this concept a bit later in this book but basically,
    in object-oriented programs, you define structures called **classes** that are
    a kind of a model, and you create objects called **instances** of those classes,
    which have their own life at runtime and which respect and inherit the structure
    of the class from which they came.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) provides four properties that are
    very useful and interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance (classes can inherit attributes and behaviors from their parent
    classes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data encapsulation (each instance retains its data and functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object identity (each instance is an individual)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism (each behavior can depend on the context)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In OOP, we define classes first and then we use specific functions called **constructors**
    to create instances of those classes. Imagine that a class is a map of a type
    of house, and the instances are all the houses built according to the map.
  prefs: []
  type: TYPE_NORMAL
- en: Almost all Arduino libraries are made using C++ in order to be easily reusable,
    which is one of the most important qualities in programming.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino native library and other libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **programming library** is a collection of resources that are available for
    use by programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'They can include different types of things, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Help and documentation resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subroutines and reusable part of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I like to say that libraries provide a **behavior encapsulation**; you don't
    have to know how the behavior is made for using it but you just use it.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries can be very specific, or can have a global purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you intend to design firmware that connects the Arduino to
    the Internet in order to grab some information from a mail server, and react by
    making an LED matrix blink in one way or another according to the content of the
    mail server''s response, you have the following two solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Code the whole firmware from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if we like to code things, we are happier if we can focus on the global
    purpose of our designs, aren't we?
  prefs: []
  type: TYPE_NORMAL
- en: In that case, we'll try to find libraries already designed specifically for
    the behaviors we need. For instance, there is probably a library specifically
    designed for LED matrix control, and another one with a server-connection purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering the Arduino native library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The native library is designed for a very elementary and global purpose. It
    means it may not be enough, but it also means you'll use it every time in all
    your firmware design.
  prefs: []
  type: TYPE_NORMAL
- en: You can find it at [http://arduino.cc/en/Reference/HomePage](http://arduino.cc/en/Reference/HomePage).
    This page will be familiar to you by now!
  prefs: []
  type: TYPE_NORMAL
- en: 'It is divided in the following three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structure** (from global conditional control structures to more specific
    ones)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variables** (related to types and conversions between types)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions** (from I/O functions to math calculation ones and more)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following steps can be used to find help directly in IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **File** | **Examples**; you'll see the following screenshot:![Discovering
    the Arduino native library](img/7584_02_001.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the first part of the menu (in the preceding screenshot), you have lots of
    examples related to the native library only.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **02.Digital** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new window is displayed. Right-click on a colored keyword in the code as shown
    in the next screenshot:![Discovering the Arduino native library](img/7584_02_002.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finding information in reference for all reserved keywords directly in the Arduino
    IDE
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can see at the bottom of this contextual menu **Find in Reference***.* This
    is a really useful tool that you are going to understand right now; click on it!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your IDE directly called your default browser with an HTML page corresponding
    to the help page of the keyword on which you clicked. You can stay focused inside
    your IDE and go to help.
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering the Arduino native library](img/7584_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The useful local help files that are available
  prefs: []
  type: TYPE_NORMAL
- en: Other libraries included and not directly provided
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Arduino library has progressively included both necessary and useful other
    libraries. We have seen in the earlier chapter that the used libraries are now
    integrated into the *core* of the Arduino distribution, which is a bit abusive,
    but summarizes well the fact that they are available when you install only the
    Arduino IDE package.
  prefs: []
  type: TYPE_NORMAL
- en: Some very useful included libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**EEPROM** provides functions and classes to read/write in hardware storage
    components. It is very useful to store something beyond the power state of the
    Arduino, that is, even when the power is off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ethernet** helps to make layer 2 and layer 3 communications over an Ethernet
    network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Firmata** is used for serial communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SD** provides an easy way to read/write SD Cards; it is a more user-friendly
    alternative to the EEPROM solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Servo** helps to control servo motors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a couple more libraries in the core distribution. Sometimes, new ones
    are included.
  prefs: []
  type: TYPE_NORMAL
- en: Some external libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I suggest that you check other libraries quoted and referenced on the same page
    at the link [http://arduino.cc/en/Reference/Libraries](http://arduino.cc/en/Reference/Libraries).
  prefs: []
  type: TYPE_NORMAL
- en: 'I especially used a lot of the following libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TLC5940**: Used to control a 16-channel, 12-bit LED controller smoothly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MsTimer2**: Used to trigger an action that has to be very fast and even each
    1 ms (this library is also a nice hack of one of the hardware timers included
    in the chipset)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tone***:* Used to generate audible square waves'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use *Google* to find more libraries. You will find a lot of them, but
    not all are equally documented and maintained. We'll see in the last chapter of
    this book how to create our own library, and of course how to document it nicely
    for both other users and ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Checking all basic development steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are not here together to understand the entire details of code compilation.
    But I want to give you a global explanation that will help you to understand better
    how it works under the hood. It will also help you to understand how to debug
    your source code and why something wouldn't work in any random case.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by a flowchart showing the entire process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking all basic development steps](img/7584_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the source code to the binary executable code
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps are executed to take the code from the source to the executable
    production stage:'
  prefs: []
  type: TYPE_NORMAL
- en: The **C and C++ source code** is just the type of code you already wrote for
    the `Blink250ms` project in [Chapter 1](ch01.html "Chapter 1. Let's Plug Things"),
    *Let's Plug Things*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Headers** are usually included at the beginning of your code, and they refer
    to other files with the extension `.h` in which there are some definitions and
    class declarations. This kind of design, in which you have separate files for
    the source code (the program you are currently writing) and the headers (already
    made elements), provides a nice way to re-use your already written code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Preprocessor** is a routine that basically substitutes text elements in
    your code, considering the *headers* and *other constants'* definitions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Parser** prepares a file that will be translated, and that file will be
    assembled to produce multiple *object* files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An **object** file contains machine code that is not directly executable by
    any hardware processor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last important step is the **linkage** made by the **linker** program. The
    linker takes all objects produced by the previous compilation steps and combines
    them into a single executable file called **program**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the source code to the object file, all processes are summarized under
    the name `compilation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Usually, libraries provide object files, ready to be linked by the linker. Sometimes,
    especially in the open source world, libraries come with source code too. This
    makes any changes in the library easier. In that case, the library itself would
    have to be compiled to produce the required object files that would be used in
    your global code compilation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hence, we'll define *compilation* as the whole process from the source code
    to the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I should even use and introduce another term: **cross-compilation**. Indeed,
    we are compiling the source code on our computer, but the final targeted processor
    of our resulting program (firmware) is the Arduino''s processor.'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, we define cross-compilation as the process of compiling source code
    using a processor in order to make a program for another processor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move further and learn how we are going to test our initial pieces
    of C code precisely using the IDE console.
  prefs: []
  type: TYPE_NORMAL
- en: Using the serial monitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Arduino board itself can communicate easily using basic protocols for serial
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, **serial communication** is the process of sending data elements
    over a channel, often named a **bus**. Usually, data elements are bytes, but it
    all depends on the implementation of the serial communication.
  prefs: []
  type: TYPE_NORMAL
- en: In serial communication, data is sent *sequentially*, one after the previous
    one. This is the opposite of **parallel communication**, where data are sent over
    more than one channel, all at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Baud rate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because the two entities that want to communicate using serial communications
    have to be okay about the answer to the question "Hey, what is a word?", we have
    to use the same speed of transmission on both sides. Indeed, if I send `001010101010`,
    is it a whole word or are there many words? We have to define, for instance, that
    a word is four-digits long. Then, we can understand that the previous example
    contains three words: `0010`, `1010`, and `1010`. This involves a clock.'
  prefs: []
  type: TYPE_NORMAL
- en: That clock definition is made by initializing serial communication at a particular
    *speed* in **baud**, also called **baud rate**.
  prefs: []
  type: TYPE_NORMAL
- en: 1 baud means 1 symbol transmitted per second. A symbol can be more than one
    bit.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we don't have to create confusion between bps, bit per second, and
    baud!
  prefs: []
  type: TYPE_NORMAL
- en: Serial communication with Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each Arduino board has at least one serial port. It can be used by using digital
    pins 0 and 1, or directly using the USB connection when you want to use serial
    communication with your computer.
  prefs: []
  type: TYPE_NORMAL
- en: You can check [http://arduino.cc/en/Reference/serial](http://arduino.cc/en/Reference/serial).
  prefs: []
  type: TYPE_NORMAL
- en: On the Arduino board, you can read RX and TX on both digital pins 0 and 1 respectively.
    **TX** means transmit and **RX means** receive; indeed, the most basic serial
    communication requires two wires.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other kinds of serial communication buses we'll describe a bit
    later in [Chapter 10](ch10.html "Chapter 10. Some Advanced Techniques"), *Some
    Advanced Techniques*, in the *Using I2C and SPI for LCD, LED, and other funny
    games* section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use serial communication on your Arduino board, you cannot use the digital
    pins 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Serial communication with Arduino](img/7584_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Check TX and RX on digital pins 1 and 0
  prefs: []
  type: TYPE_NORMAL
- en: Arduino IDE provides a nice serial monitor that displays all symbols sent by
    the board to the computer via the USB interface. It provides a lot of baud rates
    from 300 baud to 115,200 baud. We are going to check how to use it in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Serial monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serial monitoring is the way of creating very basic and easy communication with
    our board! It means we can program it to speak to us, via the serial monitor.
  prefs: []
  type: TYPE_NORMAL
- en: If you have to debug something and the board's behavior differs from what you
    are expecting from it, and you want to "verify whether the problem stems from
    the firmware or not, you can create some routines that will write messages to
    you. These messages are called **traces**. Traces can be totally necessary for
    debugging source code.
  prefs: []
  type: TYPE_NORMAL
- en: Traces will be described in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Making the Arduino talk to us
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you have followed carefully the `Blink250ms` project, everything
    is wired correctly, you double-checked that, and the code seems okay too, but
    it doesn't work.
  prefs: []
  type: TYPE_NORMAL
- en: Our LED isn't blinking at all. How to be sure that the `loop()` structure of
    your code is correctly running? We'll modify the code a bit in order to trace
    its steps.
  prefs: []
  type: TYPE_NORMAL
- en: Adding serial communication to Blink250ms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, in the following code, we''ll add serial communication for the LED to
    blink every 250 ms:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your previous code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use **Save As** to create another project under the name `TalkingAndBlink250ms`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It is good practice to start from an already existing code, to save it under
    another name, and to modify it according to your needs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the current code by adding all rows beginning with `Serial`as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please notice that I highlight the comment code a bit each time in order to
    make things more readable. In the following steps, for instance, I won''t write
    the following comment:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // ---------- loop routine
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also find the whole code in the zip file in the folder `Chapter02/TalkingAndBlink250ms/`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the Serial Monitor button in the Arduino IDE:![Adding serial communication
    to Blink250ms](img/7584_02_006.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the little glass symbol in the top-right corner to activate the Serial
    Monitor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Choose the same baud rate you wrote in the code, which is in the menu at the
    bottom-right of the Serial Monitoring window, and observe what is happening.![Adding
    serial communication to Blink250ms](img/7584_02_007.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your Arduino board seems to be speaking to you!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will notice some messages appearing in the Serial Monitor window, synchronized
    with the blinking LED states.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can be sure that our code is fine because each message is sent and because
    all rows are processed sequentially; it means the `digitalWrite()` functions are
    also called correctly (nothing is blocked). This information can be a clue, for
    instance, to check our circuit once more to try to find the error there instead
    of in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Of course this is a trivial example, but I'm sure you understand the target
    and the power of tracing your code!
  prefs: []
  type: TYPE_NORMAL
- en: Serial functions in more detail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's check what we added in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Serial.begin()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Everything begins with the `Serial.begin()` function. This function in the `setup()`
    routine is executed only once, that is, when the Arduino is starting.
  prefs: []
  type: TYPE_NORMAL
- en: In the code, I set up the board to initiate a serial communication at 9,600
    baud.
  prefs: []
  type: TYPE_NORMAL
- en: Serial.print() and Serial.println()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Serial.print()` and `Serial.println()` behave almost identically: they write
    something to the serial output, but the `ln` version also adds a carriage return
    and a newline.'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of this function is `Serial.print(val)` or `Serial.print(val,format)`.
  prefs: []
  type: TYPE_NORMAL
- en: You can pass one or two arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, if `Serial.print(5)` prints the number `5` as an ASCII-encoded decimal
    symbol, `Serial.print(5,OCT)` prints the number `5` as an ASCII-encoded octal
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Digging a bit…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you checked the code carefully (and I''m sure you did), you noticed we put
    two groups of three rows: one group just after the digitalWrite(ledPin,HIGH) function
    that lights on the LED, and the other group after the row that lights it off.'
  prefs: []
  type: TYPE_NORMAL
- en: Got it?
  prefs: []
  type: TYPE_NORMAL
- en: We have asked the Arduino board to send a message according to the last order
    passed to the digital pin numbered 8, where the LED is still connected. And the
    board sends a message when we asked the pin to deliver current (when the LED is
    on), and another message when the pin doesn't deliver current (when the LED is
    off).
  prefs: []
  type: TYPE_NORMAL
- en: You just wrote your first trace routine.
  prefs: []
  type: TYPE_NORMAL
- en: Talking to the board from the computer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You probably noticed a text field and a **Send** button in the Serial Monitor
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Talking to the board from the computer](img/7584_02_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can send symbol to our Arduino board using Serial Communication
  prefs: []
  type: TYPE_NORMAL
- en: This means we can also use that tool to send data to the board from our computer.
    The firmware's board, however, has to implement some other functions in order
    to be able to understand what we'd like to send.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this book we'll see how to use the Serial Monitor window, the genius
    Processing framework, and the Max 6 framework to send messages easily to the Arduino
    board.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about programming using C language. We also learned
    how to use the serial monitoring feature of our Arduino IDE in order to know a
    bit more about what is happening in real time in our Arduino processor using traces.
  prefs: []
  type: TYPE_NORMAL
- en: I spoke about serial communication because it is very useful and is also used
    in many real-life projects in which you need a computer and an Arduino board to
    communicate among themselves. It can also be used between two Arduino boards or
    between Arduino boards and other circuits.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll enter C code by using the serial monitoring window
    in order to make things a bit less abstract.
  prefs: []
  type: TYPE_NORMAL
