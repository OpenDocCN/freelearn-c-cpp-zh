- en: Chapter 1. LLVM Design and Use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modular design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-compiling Clang/LLVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a C source code to LLVM assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting IR to LLVM bitcode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting LLVM bitcode to target machine assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting LLVM bitcode back to LLVM assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming LLVM IR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking LLVM bitcode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing LLVM bitcode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using C frontend Clang
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the GO frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using DragonEgg
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you get to know about **LLVM**, its design, and how we can make
    multiple uses out of the various tools it provides. You will also look into how
    you can transform a simple C code to the LLVM intermediate representation and
    how you can transform it into various forms. You will also learn how the code
    is organized within the LLVM source tree and how can you use it to write a compiler
    on your own later.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modular design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LLVM is designed as a set of libraries unlike other compilers such as **GNU
    Compiler Collection** (**GCC**). In this recipe, LLVM optimizer will be used to
    understand this design. As LLVM optimizer's design is library-based, it allows
    you to order the passes to be run in a specified order. Also, this design allows
    you to choose which optimization passes you can run—that is, there might be a
    few optimizations that might not be useful to the type of system you are designing,
    and only a few optimizations will be specific to the system. When looking at traditional
    compiler optimizers, they are built as a tightly interconnected mass of code,
    that is difficult to break down into small parts that you can understand and use
    easily. In LLVM, you need not know about how the whole system works to know about
    a specific optimizer. You can just pick one optimizer and use it without having
    to worry about other components attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go ahead and look into this recipe, we must also know a little about
    LLVM assembly language. The LLVM code is represented in three forms: in memory
    compiler **Intermediate Representation** (**IR**), on disk bitcode representation,
    and as human readable assembly. LLVM is a **Static Single Assignment** (**SSA**)-based
    representation that provides type safety, low level operations, flexibility, and
    the capability to represent all the high-level languages cleanly. This representation
    is used throughout all the phases of LLVM compilation strategy. The LLVM representation
    aims to be a universal IR by being at a low enough level that high-level ideas
    may be cleanly mapped to it. Also, LLVM assembly language is well formed. If you
    have any doubts about understanding the LLVM assembly mentioned in this recipe,
    refer to the link provided in the *See* *also* section at the end of this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must have installed the LLVM toolchain on our host machine. Specifically,
    we need the `opt` tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will run two different optimizations on the same code, one-by-one, and see
    how it modifies the code according to the optimization we choose.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let us write a code we can input for these optimizations. Here
    we will write it into a file named `testfile.ll:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the `opt` tool for one of the optimizations—that is, for combining
    the instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View the output to see how `instcombine` has worked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the opt command for dead argument elimination optimization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View the output, to see how `deadargelim` has worked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, we can see that, for the first command, the `instcombine`
    pass is run, which combines the instructions and hence optimizes `%B = add i32
    %A, 0; ret i32 %B` to `ret i32 %A` without affecting the code.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, when the `deadargelim pass` is run, we can see that there
    is no modification in the first function, but the part of code that was not modified
    last time gets modified with the function arguments that are not used getting
    eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: LLVM optimizer is the tool that provided the user with all the different passes
    in LLVM. These passes are all written in a similar style. For each of these passes,
    there is a compiled object file. Object files of different passes are archived
    into a library. The passes within the library are not strongly connected, and
    it is the LLVM **PassManager** that has the information about dependencies among
    the passes, which it resolves when a pass is executed. The following image shows
    how each pass can be linked to a specific object file within a specific library.
    In the following figure, the **PassA** references **LLVMPasses.a** for **PassA.o**,
    whereas the custom pass refers to a different library **MyPasses.a** for the **MyPass.o**
    object file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image00251.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the optimizer, the LLVM code generator also makes use of its modular
    design, splitting the code generation problem into individual passes: instruction
    selection, register allocation, scheduling, code layout optimization, and assembly
    emission. Also, there are many built-in passes that are run by default. It is
    up to the user to choose which passes to run.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the upcoming chapters, we will see how to write our own custom pass, where
    we can choose which of the optimization passes we want to run and in which order.
    Also, for a more detailed understanding, refer to [http://www.aosabook.org/en/llvm.html](http://www.aosabook.org/en/llvm.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand more about LLVM assembly language, refer to [http://llvm.org/docs/LangRef.html](http://llvm.org/docs/LangRef.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-compiling Clang/LLVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By cross-compiling we mean building a binary on one platform (for example, x86)
    that will be run on another platform (for example, ARM). The machine on which
    we build the binary is called the host, and the machine on which the generated
    binary will run is called the target. The compiler that builds code for the same
    platform on which it is running (the host and target platforms are the same) is
    called a **native assembler**, whereas the compiler that builds code for a target
    platform different from the host platform is called a **cross**-**compiler**.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, cross-compilation of LLVM for a platform different than the
    host platform will be shown, so that you can use the built binaries for the required
    target platform. Here, cross-compiling will be shown using an example where cross-compilation
    from host platform x86_64 for target platform ARM will be done. The binaries thus
    generated can be used on a platform with ARM architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following packages need to be installed on your system (host platform):'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmake`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ninja-build` (from backports in Ubuntu)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcc-4.x-arm-linux-gnueabihf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcc-4.x-multilib-arm-linux-gnueabihf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binutils-arm-linux-gnueabihf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libgcc1-armhf-cross`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libsfgcc1-armhf-cross`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libstdc++6-armhf-cross`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libstdc++6-4.x-dev-armhf-cross`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install llvm on your host platform`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compile for the ARM target from the host architecture, that is **X86_64**
    here, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `cmake` flags to the normal `cmake` build for LLVM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If using your platform compiler, run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If using Clang as the cross-compiler, run:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you have clang/Clang++ on the path, it should work fine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To build LLVM, simply type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the LLVM/Clang has built successfully, install it with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create a `sysroot` on the `install-dir` location if you have specified
    the `DCMAKE_INSTALL_PREFIX` options
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `cmake` package builds the toolchain for the required platform by making
    the use of option flags passed to `cmake`, and the `tblgen` tools are used to
    translate the target description files into C++ code. Thus, by using it, the information
    about targets is obtained, for example—what instructions are available on the
    target, the number of registers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If Clang is used as the cross-compiler, there is a problem in the LLVM ARM backend
    that produces absolute relocations on **position-independent code** (**PIC**),
    so as a workaround, disable PIC at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: The ARM libraries will not be available on the host system. So, either download
    a copy of them or build them on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a C source code to LLVM assembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we will convert a C code to intermediate representation in LLVM using the
    C frontend Clang.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clang must be installed in the PATH.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lets create a C code in the `multiply.c` file, which will look something like
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following command to generate LLVM IR from the C code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Have a look at the generated IR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also use the `cc1` for generating IR:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of C code getting converted to IR starts with the process of lexing,
    wherein the C code is broken into a token stream, with each token representing
    an Identifier, Literal, Operator, and so on. This stream of tokens is fed to the
    parser, which builds up an abstract syntax tree with the help of **Context free
    grammar** (**CFG**) for the language. Semantic analysis is done afterwards to
    check whether the code is semantically correct, and then we generate code to IR.
  prefs: []
  type: TYPE_NORMAL
- en: Here we use the Clang frontend to generate the IR file from C code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next chapter, we will see how the lexer and parser work and how code
    generation is done. To understand the basics of LLVM IR, you can refer to [http://llvm.org/docs/LangRef.html](http://llvm.org/docs/LangRef.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting IR to LLVM bitcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn to generate LLVM bit code from IR. The LLVM
    bit code file format (also known as bytecode) is actually two things: a bitstream
    container format and an encoding of LLVM IR into the container format.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `llvm-as` tool must be installed in the PATH.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First create an IR code that will be used as input to `llvm-as`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To convert LLVM IR in `test.ll` to bitcode format, you need to use the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output is generated in the `test.bc` file, which is in bit stream format;
    so, when we want to have a look at output in text format, we get it as shown in
    the following screenshot:![How to do it...](img/image00252.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since this is a bitcode file, the best way to view its content would be by
    using the `hexdump` tool. The following screenshot shows the output of `hexdump`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image00253.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `llvm-as` is the LLVM assembler. It converts the LLVM assembly file that
    is the LLVM IR into LLVM bitcode. In the preceding command, it takes the `test.ll`
    file as the input and outputs, and `test.bc` as the bitcode file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To encode LLVM IR into bitcode, the concept of blocks and records is used. Blocks
    represent regions of bitstream, for example—a function body, symbol table, and
    so on. Each block has an ID specific to its content (for example, function bodies
    in LLVM IR are represented by ID 12). Records consist of a record code and an
    integer value, and they describe the entities within the file such as instructions,
    global variable descriptors, type descriptions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcode files for LLVM IR might be wrapped in a simple wrapper structure. This
    structure contains a simple header that indicates the offset and size of the embedded
    BC file.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a detailed understanding of the LLVM the bitstream file format, refer
    to [http://llvm.org/docs/BitCodeFormat.html#abstract](http://llvm.org/docs/BitCodeFormat.html#abstract)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting LLVM bitcode to target machine assembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to convert the LLVM bitcode file to target
    specific assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The LLVM static compiler `llc` should be in installed from the LLVM toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bitcode file created in the previous recipe, `test.bc,` can be used as
    input to `llc` here. Using the following command, we can convert LLVM bitcode
    to assembly code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is generated in the `test.s` file, which is the assembly code. To
    have a look at that, use the following command lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also use Clang to dump assembly code from the bitcode file format.
    By passing the `–S` option to Clang, we get `test.s` in assembly format when the
    `test.bc` file is in bitstream file format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `test.s` file output is the same as that of the preceding example. We use
    the additional option `fomit-frame-pointer`, as Clang by default does not eliminate
    the frame pointer whereas `llc` eliminates it by default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `llc` command compiles LLVM input into assembly language for a specified
    architecture. If we do not mention any architecture as in the preceding command,
    the assembly will be generated for the host machine where the `llc` command is
    being used. To generate executable from this assembly file, you can use assembler
    and linker.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By specifying `-march=architecture flag` in the preceding command, you can specify
    the target architecture for which the assembly needs to be generated. Using the
    `-mcpu=cpu flag` setting, you can specify a CPU within the architecture to generate
    code. Also by specifying `-regalloc=basic/greedy/fast/pbqp,` you can specify the
    type of register allocation to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Converting LLVM bitcode back to LLVM assembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will convert LLVM bitcode back to LLVM IR. Well, this is
    actually possible using the LLVM disassembler tool called `llvm-dis.`
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To do this, you need the `llvm-dis` tool installed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see how the bitcode file is getting converted to IR, use the `test.bc` file
    generated in the recipe *Converting IR to LLVM Bitcode*. The `test.bc` file is
    provided as the input to the `llvm-dis` tool. Now proceed with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the following command shows how to convert a bitcode file to an the one
    we had created in the IR file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Have a look at the generated LLVM IR by the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output `test.ll` file is the same as the one we created in the recipe *Converting
    IR to LLVM Bitcode*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `llvm-dis` command is the LLVM disassembler. It takes an LLVM bitcode file
    and converts it into LLVM assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the input file is `test.bc`, which is transformed to `test.ll` by `llvm-dis`.
  prefs: []
  type: TYPE_NORMAL
- en: If the filename is omitted, `llvm-dis` reads its input from standard input.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming LLVM IR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can transform the IR from one form to another
    using the opt tool. We will see different optimizations being applied to IR code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have the opt tool installed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `opt` tool runs the transformation pass as in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take an actual example now. We create the LLVM IR equivalent to the
    C code used in the recipe *Converting a C source code to LLVM assembly*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Converting and outputting it, we get the unoptimized output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now use the opt tool to transform it to a form where memory is promoted to
    register:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `opt`, LLVM optimizer, and analyzer tools take the `input.ll` file as the
    input and run the pass `passname` on it. The output after running the pass is
    obtained in the `output.ll` file that contains the IR code after the transformation.
    There can be more than one pass passed to the opt tool.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the `–analyze` option is passed to opt, it performs various analyses of
    the input source and prints results usually on the standard output or standard
    error. Also, the output can be redirected to a file when it is meant to be fed
    to another program.
  prefs: []
  type: TYPE_NORMAL
- en: When the –analyze option is not passed to opt, it runs the transformation passes
    meant to optimize the input file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important transformations are listed as follows, which can be passed
    as a flag to the opt tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '`adce`: Aggressive Dead Code Elimination'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bb-vectorize`: Basic-Block Vectorization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constprop`: Simple constant propagation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dce`: Dead Code Elimination'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deadargelim`: Dead Argument Elimination'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`globaldce`: Dead Global Elimination'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`globalopt`: Global Variable Optimizer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gvn`: Global Value Numbering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inline`: Function Integration/Inlining'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`instcombine`: Combine redundant instructions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`licm`: Loop Invariant Code Motion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop`: unswitch: Unswitch loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loweratomic`: Lower atomic intrinsics to non-atomic form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lowerinvoke`: Lower invokes to calls, for unwindless code generators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lowerswitch`: Lower SwitchInsts to branches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mem2reg`: Promote Memory to Register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memcpyopt`: MemCpy Optimization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simplifycfg`: Simplify the CFG'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sink`: Code sinking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tailcallelim`: Tail Call Elimination'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run at least some of the preceding passes to get an understanding of how they
    work. To get to the appropriate source code on which these passes might be applicable,
    go to the `llvm/test/Transforms` directory. For each of the above mentioned passes,
    you can see the test codes. Apply the relevant pass and see how the test code
    is getting modified.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see the mapping of how C code is converted to IR, after converting the C
    code to IR, as discussed in an earlier recipe *Converting a C source code to LLVM
    assembly*, run the `mem2reg` pass. It will then help you understand how a C instruction
    is getting mapped into IR instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Linking LLVM bitcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will link previously generated `.bc` files to get one single
    bitcode file containing all the needed references.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To link the `.bc` files, you need the `llvm-link` tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To show the working of `llvm-link`, first write two codes in different files,
    where one makes a reference to the other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the following formats to convert this C code to bitstream file format,
    first convert to `.ll` files, then from `.ll` files to `.bc` files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We get `test1.bc` and `test2.bc` with `test2.bc` making a reference to `func`
    syntax in the `test1.bc` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Invoke the `llvm-link` command in the following way to link the two LLVM bitcode
    files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We provide multiple bitcode files to the `llvm-link` tool, which links them
    together to generate a single bitcode file. Here, `output.bc` is the generated
    output file. We will execute this bitcode file in the next recipe *Executing LLVM
    bitcode*.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `llvm-link` works using the basic functionality of a linker—that is, if
    a function or variable referenced in one file is defined in the other file, it
    is the job of linker to resolve all the references made in a file and defined
    in the other file. But note that this is not the traditional linker that links
    various object files to generate a binary. The `llvm-link` tool links bitcode
    files only.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding scenario, it is linking `test1.bc` and `test2.bc` files to
    generate the `output.bc` file, which has references resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After linking the bitcode files, we can generate the output as an IR file by
    giving `–S` option to the `llvm-link` tool.
  prefs: []
  type: TYPE_NORMAL
- en: Executing LLVM bitcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will execute the LLVM bitcode that was generated in previous
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute the LLVM bitcode, you need the `lli` tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw in the previous recipe how to create a single bitstream file after linking
    the two `.bc` files with one referencing the other to define `func`. By invoking
    the `lli` command in the following way, we can execute the `output.bc` file generated.
    It will display the output on the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`The output.bc` file is the input to `lli`, which will execute the bitcode
    file and display the output, if any, on the standard output. Here the output is
    generated as number is `10`, which is a result of the execution of the `output.bc`
    file formed by linking `test1.c` and `test2.c` in the previous recipe. The main
    function in the `test2.c` file calls the function `func` in the `test1.c` file
    with integer 5 as the argument to the function. The `func` function doubles the
    input argument and returns the result to main the function that outputs it on
    the standard output.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `lli` tool command executes the program present in LLVM bitcode format.
    It takes the input in LLVM bitcode format and executes it using a just-in-time
    compiler, if there is one available for the architecture, or an interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: If `lli` is making use of a just-in-time compiler, then it effectively takes
    all the code generator options as that of `llc`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adding JIT support for a language* recipe in [Chapter 3](part0041.xhtml#aid-173721
    "Chapter 3. Extending the Frontend and Adding JIT Support"), *Extending the Frontend
    and Adding JIT support*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the C frontend Clang
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will get to know how the Clang frontend can be used for
    different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need Clang tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clang can be used as the high-level compiler driver. Let us show it using an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `hello world` C code, `test.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use Clang as a compiler driver to generate the executable `a.out` file, which
    on execution gives the output as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here the `test.c` file containing C code is created. Using Clang we compile
    it and produce an executable that on execution gives the desired result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Clang can be used in preprocessor only mode by providing the `–E` flag. In
    the following example, create a C code having a #define directive defining the
    value of MAX and use this MAX as the size of the array you are going to create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the preprocessor using the following command, which gives the output on
    standard output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `test.c` file, which will be used in all the subsequent sections of this
    recipe, MAX is defined to be `100`, which on preprocessing is substituted to MAX
    in `a[MAX]`, which becomes `a[100]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can print the AST for the `test.c` file from the preceding example using
    the following command, which displays the output on standard output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `–cc1` option ensures that only the compiler front-end should be run,
    not the driver, and it prints the AST corresponding to the `test.c` file code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can generate the LLVM assembly for the `test.c` file in previous examples,
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `–S` and `–emit-llvm` flag ensure the LLVM assembly is generated for the
    `test.c` code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To get machine code use for the same `test.c` testcode, pass the `–S` flag
    to Clang. It generates the output on standard output because of the option `–o
    –`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the `–S` flag is used alone, machine code is generated by the code generation
    process of the compiler. Here, on running the command, machine code is output
    on the standard output as we use `–o –` options.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clang works as a preprocessor, compiler driver, frontend, and code generator
    in the preceding examples, thus giving the desired output as per the input flag
    given to it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This was a basic introduction to how Clang can be used. There are also many
    other flags that can be passed to Clang, which makes it perform different operation.
    To see the list, use Clang `–help`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the GO frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `llgo` compiler is the LLVM-based frontend for Go written in Go language
    only. Using this frontend, we can generate the LLVM assembly code from a program
    written in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to download the `llgo` binaries or build `llgo` from the source code
    and add the binaries in the `PATH` file location as configured.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Go source file, for example, that will be used for generating the
    LLVM assembly using `llgo`. Create `test.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, use `llgo` to get the LLVM assembly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `llgo` compiler is the frontend for the Go language; it takes the `test.go`
    program as its input and emits the LLVM IR.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For information about how to get and install `llgo,` refer to [https://github.com/go-llvm/llgo](https://github.com/go-llvm/llgo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using DragonEgg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dragonegg is a gcc plugin that allows gcc to make use of the LLVM optimizer
    and code generator instead of gcc's own optimizer and code generator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have gcc 4.5 or above, with the target machine being `x86-32/x86-64`
    and an ARM processor. Also, you need to download the dragonegg source code and
    build the `dragonegg.so` file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do It…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple `hello world` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile this program with your gcc; here we use gcc-4.5:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the `-fplugin=path/dragonegg.so` flag in the command line of gcc makes
    gcc use LLVM''s optimizer and LLVM codegen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To know about how to get the source code and installation procedure, refer to
    [http://dragonegg.llvm.org/](http://dragonegg.llvm.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
