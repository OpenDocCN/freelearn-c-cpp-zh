- en: Chapter 5. Functions and Macros
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。函数和宏
- en: Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Some things needs to be repeated. Code is not one of them. A function is a bundle
    of code that can get called any number of times, as often you wish.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有些事情需要重复。代码不是其中之一。函数是一组可以多次调用的代码，你可以按需多次调用。
- en: Analogies are good. Let's explore an analogy that deals with waiters, chefs,
    pizzas, and functions. In English, when we say a person has a function, we mean
    that the person performs some very specific (usually, very important) task. They
    can do this task again and again and whenever they are called upon to do so.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 类比是好的。让我们探讨一个涉及服务员、厨师、披萨和函数的类比。在英语中，当我们说一个人有一个函数时，我们的意思是这个人执行一些非常具体（通常，非常重要）的任务。他们可以一次又一次地做这项任务，并且每当他们被要求这样做时。
- en: The following comic strip shows the interaction between a waiter (caller) and
    a chef (callee). The waiter wants food for his table, so he calls upon the chef
    to prepare the food required by the waiting table.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的漫画展示了服务员（调用者）和厨师（被调用者）之间的交互。服务员想要为他的餐桌提供食物，所以他要求厨师准备等待餐桌所需的食物。
- en: The chef prepares the food and then returns the result to the waiter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 厨师准备食物，然后将结果返回给服务员。
- en: '![Functions](img/00052.jpeg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![函数](img/00052.jpeg)'
- en: Here, the chef performs his function of cooking food. The chef accepted the
    parameters about what type of food to cook (three pepperoni pan pizzas). The chef
    then went away, did some work, and returned with three pizzas. Note that the waiter
    does not know and does not care about how the chef goes about cooking the pizzas.
    The chef abstracts away the process of cooking pizzas for the waiter, so cooking
    a pizza is just a simple, single-line command for the waiter. The waiter just
    wants his request to be completed and the pizzas returned to him.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，厨师执行他的烹饪食物的功能。厨师接受了关于要烹饪什么类型食物的参数（三个辣味披萨）。然后厨师离开，做了一些工作，并带着三个披萨回来。请注意，服务员不知道也不关心厨师是如何烹饪披萨的。厨师为服务员抽象掉了烹饪披萨的过程，所以对服务员来说，烹饪披萨只是一个简单的一行命令。服务员只想完成他的请求，并得到披萨。
- en: When a function (chef) gets called with some arguments (types of pizzas to be
    prepared), the function performs some actions (preparing the pizzas) and optionally
    returns a result (the actual finished pizzas).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数（厨师）被调用并带有一些参数（要准备的披萨类型）时，该函数执行一些操作（准备披萨）并可选择返回一个结果（实际完成的披萨）。
- en: An example of a <cmath> library function – sqrt()
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 `<cmath>` 库函数的例子 – sqrt()
- en: Now, let's talk about a more practical example and relate it to the pizza example.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一个更实际的例子，并将其与披萨例子联系起来。
- en: 'There is a function in the `<cmath>` library called the `sqrt()` function.
    Let me quickly illustrate its use, as shown in the following code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`<cmath>` 库中有一个名为 `sqrt()` 的函数。让我快速展示它的用法，如下面的代码所示：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, `sqrt()` can find the mathematical square root of any number given to it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`sqrt()` 可以找到任何给定的数字的数学平方根。
- en: Do you know how to find the square root of a tough number such as 5? It's not
    simple. A clever soul sat down and wrote a function that can find the square roots
    of all types of numbers. Do you have to understand the math behind how the square
    root of 5 is found to use the `sqrt(5)` function call? Heck, no! So, just as the
    waiter didn't have to understand how to cook a pizza in order to get a pizza as
    the result, the caller of a C++ library function does not have to fully understand
    how that library function works internally to use it effectively.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道如何找到像5这样的困难数字的平方根吗？这并不简单。一个聪明的人坐下来编写了一个函数，可以找到所有类型的数字的平方根。你必须要理解5的平方根是如何找到的才能使用
    `sqrt(5)` 函数调用吗？当然不需要！所以，就像服务员不需要理解如何烹饪披萨就能得到披萨作为结果一样，调用C++库函数的人不需要完全理解该库函数内部的工作原理就能有效地使用它。
- en: 'The following are the advantages of using functions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数的优势如下：
- en: Functions abstract away a complex task into a simple, callable routine. This
    makes the code required to *cook a pizza*, for instance, just a single-line command
    for the caller (the caller is typically your program).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数将复杂任务抽象成一个简单可调用的例程。这使得调用者（通常是你的程序）所需的代码，例如“烹饪披萨”，只是一个单行命令。
- en: Functions avoid the repetition of code where it is not necessary. Say we have
    20 or so lines of code that can find the square root of a double value. We wrap
    these lines of code into a callable function; instead of repeatedly copying and
    pasting these 20 lines of code, we simply call the `sqrt` function (with the number
    to root) function whenever we need a root.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数避免了不必要的代码重复。假设我们有 20 或更多行代码可以找到双精度值的平方根。我们将这些代码行包装成一个可调用的函数；而不是反复复制粘贴这些 20
    行代码，我们只需在需要求根时调用 `sqrt` 函数（带有要开方的数字）。
- en: 'The following illustration shows the process of finding a square root:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图展示了寻找平方根的过程：
- en: '![An example of a <cmath> library function – sqrt()](img/00053.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![一个 <cmath> 库函数示例 – sqrt()](img/00053.jpeg)'
- en: Writing our own functions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们自己的函数
- en: 'Say, we want to write some code that prints out a strip of road, as shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一些代码来打印一段道路，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, say we want to print two strips of road, in a row, or three strips of road.
    Or, say we want to print any number of strips of road. We will have to repeat
    the four lines of code that produce the first strip of road once per strip of
    road we're trying to print.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要打印两条道路，一行一行地打印，或者打印三条道路。或者，假设我们想要打印任意数量的道路。我们将不得不为每条我们试图打印的道路重复一次产生第一条道路的四个代码行。
- en: 'What if we introduced our own C++ command that allowed us to print a strip
    of road on being called the command. Here''s how that will look:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们引入了自己的 C++ 命令，当调用该命令时可以打印一段道路。下面是它的样子：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is the definition of a function. A C++ function has the following anatomy:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是函数的定义。C++ 函数具有以下结构：
- en: '![Writing our own functions](img/00054.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![编写我们自己的函数](img/00054.jpeg)'
- en: 'Using a function is simple: we simply invoke the function we want to execute
    by name, followed by two round brackets(). For example, calling the `printRoad()`
    function will cause the `printRoad()` function to run. Let''s trace an example
    program to fully understand what this means.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数很简单：我们只需通过名称调用我们想要执行的功能，然后跟随着两个圆括号 ()。例如，调用 `printRoad()` 函数将导致 `printRoad()`
    函数运行。让我们跟踪一个示例程序来完全理解这意味着什么。
- en: A sample program trace
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例程序跟踪
- en: 'Here''s a complete example of how a function call works:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个函数调用的完整示例：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's trace the program's execution from beginning to end. Remember that for
    all C++ programs, execution begins on the first line of `main()`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从开始到结束跟踪程序的执行。记住，对于所有 C++ 程序，执行都是从 `main()` 的第一行开始的。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`main()` is also a function. It oversees the execution of the whole program.
    Once `main()` executes the `return` statement, your program ends.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 也是一个函数。它负责整个程序的执行。一旦 `main()` 执行了 `return` 语句，你的程序就结束了。'
- en: When the last line of the `main()` function is reached, the program ends.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当达到 `main()` 函数的最后一行时，程序结束。
- en: 'A line-by-line trace of the execution of the preceding program is shown as
    follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面程序执行逐行跟踪的展示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is how the output of this program will look:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个程序的输出将看起来像这样：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here''s an explanation of the preceding code, line by line:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面代码逐行的解释：
- en: The program's execution begins on the first line of `main()`, which outputs
    `program begin!.`
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序的执行从 `main()` 的第一行开始，输出 `program begin!`。
- en: The next line of code that is run is the call to `printRoad()`. What this does
    is it jumps the program counter to the first line of `printRoad()`. All the lines
    of `printRoad()` then execute in order (steps 3–6).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一条要执行的代码是调用 `printRoad()`。这样做会将程序计数器跳转到 `printRoad()` 的第一行。然后按照顺序执行 `printRoad()`
    的所有行（步骤 3–6）。
- en: Finally, after the function call to `printRoad()` is complete, control returns
    to the `main()` statement. We then see `Program end` printed.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `printRoad()` 函数调用完成后，控制权返回到 `main()` 语句。然后我们看到打印出 `Program end`。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't forget the brackets after the function call to `printRoad()`. A function
    call must always be followed by round brackets (), otherwise the function call
    will not work and you will get a compiler error.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在调用 `printRoad()` 函数后加上括号。函数调用必须始终跟随着圆括号 ()，否则函数调用将不会工作，并且你会得到编译器错误。
- en: 'The following code is used to print four strips of road:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于打印四条道路：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, you can also use the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用以下代码：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, instead of repeating the four lines of `cout` every time a box is printed,
    we simply call the `printRoad()` function to make it print. Also, if we want to
    change how a printed road looks, we have to simply modify the implementation of
    the `printRoad()` function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不必每次打印一个框时都重复四行`cout`，我们只需调用`printRoad()`函数来让它打印。此外，如果我们想改变打印的路的形状，我们只需简单地修改`printRoad()`函数的实现。
- en: Calling a function entails running the entire body of that function, line by
    line. After the function call is complete, the control of the program then resumes
    at the point of the function call.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个函数意味着逐行运行该函数的整个主体。函数调用完成后，程序的控制权随后恢复到函数调用的点。
- en: Exercise
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'As an exercise, find out what is wrong with the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，找出以下代码中存在的问题：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Solution
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The correct answer to this problem is that the call to `myFunction` (in the
    last line of `main()`) is not followed by round brackets. All function calls must
    be followed by round brackets. The last line of `main()` should read `myFunction();`,
    not just `myFunction`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的正确答案是，在`main()`的最后一行对`myFunction`的调用后面没有圆括号。所有函数调用都必须跟圆括号。`main()`的最后一行应该是`myFunction();`，而不是仅仅`myFunction`。
- en: Functions with arguments
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有参数的函数
- en: How can we extend the `printRoad()` function to print a road with a certain
    number of segments? The answer is simple. We can let the `printRoad()` function
    accept a parameter, called `numSegments`, to print a certain number of road segments.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何扩展`printRoad()`函数以打印具有特定路段数的路？答案是简单的。我们可以让`printRoad()`函数接受一个参数，称为`numSegments`，以打印一定数量的路段。
- en: 'The following code snippet shows how that will look:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了它的样子：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following screenshot shows the anatomy of a function that accepts an argument:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了接受一个参数的函数的解剖结构：
- en: '![Functions with arguments](img/00055.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![带有参数的函数](img/00055.jpeg)'
- en: 'Call this new version of `printRoad()`, asking it to print four segments, as
    follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个新的`printRoad()`版本，要求它打印四个路段，如下所示：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The 4 between the brackets of the `function call` in the preceding statement
    gets assigned to the `numSegments` variable of the `printRoad(int numSegments)`
    function. This is how the value 4 gets passed to `numSegments`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个语句的`function call`括号中的4被分配给`printRoad(int numSegments)`函数的`numSegments`变量。这就是值4如何传递给`numSegments`的：
- en: '![Functions with arguments](img/00056.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![带有参数的函数](img/00056.jpeg)'
- en: An illustration of how printRoad(4) will assign the value 4 to the numSegments
    variable
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何将值4赋给`numSegments`变量的`printRoad(4)`函数的示例
- en: So, `numSegments` gets assigned the value passed between the brackets in the
    call to `printRoad()`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`numSegments`被分配了在`printRoad()`调用中括号内传递的值。
- en: Functions that return values
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值的函数
- en: An example of a function that returns a value is the `sqrt()` function. The
    `sqrt()` function accepts a single parameter between its brackets (the number
    to root) and returns the actual root of the number.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值的函数的一个例子是`sqrt()`函数。`sqrt()`函数接受一个括号内的单个参数（要开方的数字）并返回该数字的实际根。
- en: 'Here''s an example usage of the `sqrt` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`sqrt`函数的一个示例用法：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `sqrt()` function does something analogous to what the chef did when preparing
    the pizzas.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqrt()`函数所做的与厨师在准备披萨时所做的类似。'
- en: As a caller of the function, you do not care about what goes on inside the body
    of the `sqrt()` function; that information is irrelevant since all you want is
    the result of the square root of the number that you are passing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数的调用者，你不需要关心`sqrt()`函数体内的内容；这个信息是不相关的，因为你想要的只是你传递的数字的平方根的结果。
- en: 'Let''s declare our own simple function that returns a value, as shown in the
    following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明自己的简单函数，该函数返回一个值，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following screenshot shows the anatomy of a function with parameters and
    a returned value:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了具有参数和返回值的函数的解剖结构：
- en: '![Functions that return values](img/00057.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![返回值的函数](img/00057.jpeg)'
- en: The `sum` function is very basic. All it does is take two `int` numbers `a`
    and `b`, sums them up together, and returns a result. You might say that we don't
    even need an entire function just to add two numbers. You're right, but bear with
    me for a moment. We will use this simple function to explain the concept of returned
    values.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum`函数非常基础。它所做的只是取两个`int`数字`a`和`b`，将它们相加，并返回一个结果。你可能会说，我们甚至不需要一个完整的函数来加两个数字。你说得对，但请稍等片刻。我们将使用这个简单的函数来解释返回值的概念。'
- en: 'You will use the `sum` function in this way (from `main()`):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你将这样使用 `sum` 函数（从 `main()` 中）：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For the `cout` command to complete, the `sum( 5,6 )` function call must be evaluated.
    At the point where the `sum( 5,6 )` function call occurs, the returned value from
    `sum( 5,6 )` is put right there.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `cout` 命令完成，必须评估 `sum( 5,6 )` 函数调用。在 `sum( 5,6 )` 函数调用发生的地方，`sum( 5,6 )`
    返回的值就被放在那里。
- en: 'In other words, this is the line of code that `cout` actually sees after evaluating
    the `sum( 5,6 )` function call:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这是 `cout` 在评估 `sum( 5,6 )` 函数调用后实际看到的代码行：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The returned value from `sum( 5,6 )` is effectively cut and pasted at the point
    of the function call.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `sum( 5,6 )` 返回的值实际上是在函数调用点剪切和粘贴的。
- en: A value must always be returned by a function that promises to do so (if the
    return type of the function is anything other than `void`).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 函数承诺返回值时，必须始终返回一个值（如果函数的返回类型不是 `void`）。
- en: Exercises
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Write an `isPositive` function that returns `true` when the double parameter
    passed to it is indeed positive.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 `isPositive` 函数，当传递给它的 `double` 类型的参数确实是正数时返回 `true`。
- en: 'Complete the following function definition:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成以下函数定义：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Write a `getGrade()` function that accepts an integer value (marks out of 100)
    and returns the grade (either A, B, C, D, or F).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 `getGrade()` 函数，该函数接受一个整数参数（满分100分）并返回成绩（A、B、C、D或F）。
- en: A mathematical function is of the form `f(x) = 3x + 4`. Write a C++ function
    that returns values for `f(x)`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个数学函数的形式为 `f(x) = 3x + 4`。请编写一个 C++ 函数，该函数返回 `f(x)` 的值。
- en: Solutions
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解答
- en: 'The `isPositive` function accepts a double parameter and returns a boolean
    value:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isPositive` 函数接受一个 `double` 类型的参数并返回一个布尔值：'
- en: '[PRE16]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the completed `absEqual` function:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下为完成的 `absEqual` 函数：
- en: '[PRE17]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `getGrade()` function is given in the following code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码给出了 `getGrade()` 函数：
- en: '[PRE18]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This program is a simple one that should entertain you. The origin of the `name`
    function in C++ actually came from the math world, as shown in the following code:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个程序是一个简单的程序，应该能让你感到愉快。C++ 中 `name` 函数的起源实际上来自数学世界，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Variables, revisited
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量，重新审视
- en: It's always nice to revisit a topic you've covered before, now that you understand
    C++ coding much more in depth.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对 C++ 编码有了更深入的理解，现在重新回顾你之前学过的主题总是很愉快。
- en: Global variables
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局变量
- en: Now that we've introduced the concept of functions, the concept of a global
    variable can be introduced.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了函数的概念，可以引入全局变量的概念。
- en: What is a global variable? A global variable is any variable that is made accessible
    to all the functions of the program. How can we make a variable that is accessible
    to all the functions of the program? We simply declare the global variable at
    the top of the code file, usually after or near the `#include` statements.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是全局变量？全局变量是指任何可以被程序中所有函数访问的变量。我们如何使一个变量可以被程序中所有函数访问？我们只需在代码文件顶部声明全局变量，通常在
    `#include` 语句之后或附近。
- en: 'Here''s an example program with some global variables:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个包含一些全局变量的示例程序：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the same `g_string` global variable is accessible to all the four functions
    in the program (`addA()`, `addB()`, `addC()`, and `main()`). Global variables
    live for the duration of the program.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，相同的 `g_string` 全局变量可以访问程序中的所有四个函数（`addA()`、`addB()`、`addC()` 和 `main()`）。全局变量在程序运行期间持续存在。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: People sometimes prefer to prefix global variables with `g_`, but prefixing
    the variable name with `g_` is not a requirement for a variable to be global.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 人们有时更喜欢在全局变量前加上 `g_` 前缀，但给变量名加上 `g_` 前缀并不是使变量成为全局变量的要求。
- en: Local variables
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量
- en: A local variable is a variable that is defined within a block of code. Local
    variables go out of the scope at the end of the block in which they are declared.
    Some examples will follow in the next section, *The* *scope of a variable*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量是在代码块内定义的变量。局部变量在其声明块的末尾超出作用域。下一节将提供一些示例，*变量的作用域*。
- en: The scope of a variable
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量的作用域
- en: 'The scope of a variable is the area of code where that variable can be used.
    The scope of any variable is basically the block in which it is defined. We can
    demonstrate a variable''s scope using an example, as shown in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域是指变量可以被使用的代码区域。任何变量的作用域基本上是其定义的块。我们可以通过以下示例来演示变量的作用域：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The main thing that defines a variable''s scope is a block. Let''s discuss
    the scope of a couple of the variables defined in the preceding code example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 定义变量作用域的主要因素是块。让我们讨论一下前面代码示例中定义的一些变量的作用域：
- en: '`g_int`: This is a global integer with a scope that ranges from the point it
    was declared until the end of the code file. That is to say, `g_int` can be used
    inside `func()` and `main()`, but it cannot be used in other code files. To have
    a single global variable that is used across multiple code files, you will need
    an external variable.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g_int`：这是一个全局整数，其作用域从声明点开始，直到代码文件的末尾。也就是说，`g_int`可以在`func()`和`main()`中使用，但不能在其他代码文件中使用。如果你需要一个在多个代码文件中使用的单个全局变量，你需要一个外部变量。'
- en: '`arg` (the argument of `func()`): This can be used from the first line of `func()`
    (after the opening curly brace {) to the last line of `func()` (until the closing
    curly brace }).'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arg`（`func()`的参数）：这可以从`func()`的第一行（在开括号`{`之后）使用到`func()`的最后一行（直到闭括号`}`）。'
- en: '`fx`: This can be used anywhere inside `func()` until the closing curly brace
    of `func()`}.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fx`：这可以在`func()`内部的任何地方使用，直到`func()`的闭合花括号`}`。'
- en: '`main()`(variables inside `main()`): This can be used as marked in the comments.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()`（`main()`内部的变量）：这可以按照注释中的标记使用。'
- en: 'Notice how variables declared inside the brackets of a function''s argument
    list can only be used inside the block below that function''s declaration. For
    example, the `arg` variable passed to `func()`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数参数列表中的变量只能在函数声明下面的块中使用。例如，传递给`func()`的`arg`变量：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `arg` variable will die after the closing curly brace (`}`) of the `func()`
    function. This is counterintuitive as the round brackets are technically outside
    the curly braces that define the `{` block `}`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`arg`变量将在`func()`函数的闭合花括号（`}`）之后消失。这看起来有些反直觉，因为圆括号在技术上是在定义`{}`块的闭合花括号之外。'
- en: 'The same goes for variables declared inside the round brackets of a `for` loop.
    Take as an example the following `for` loop:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在`for`循环圆括号内声明的变量也是同样的情况。以下是一个`for`循环的例子：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `int c` variable can be used inside the round brackets of the `for` loop
    declaration or inside the block below the `for` loop declaration. The `c` variable
    will die after the closing of the curly brace of the `for` loop it is declared
    in. If you want the `c` variable to live on after the brace brackets of the `for`
    loop, you need to declare the `c` variable before the `for` loop, as shown here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`int c`变量可以在`for`循环声明圆括号内或在其声明下面的块中使用。`c`变量将在其声明的`for`循环的闭合花括号之后消失。如果你想使`c`变量在`for`循环的括号之外继续存在，你需要在`for`循环之前声明`c`变量，如下所示：'
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Static local variables
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态局部变量
- en: 'The `static` local variables are exactly like global variables, only they have
    a local scope, as shown in the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 静态局部变量与全局变量非常相似，只是它们具有局部作用域，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the use of the `static` keyword inside `testFunc()`, the `runCount` variable
    remembers its value between calls of `testFunc()`. So, the output of the two separate
    preceding runs of `testFunc()` is:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`testFunc()`函数内部使用`static`关键字，`runCount`变量会在`testFunc()`函数调用之间记住其值。因此，`testFunc()`的前两次单独运行输出如下：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That''s because static variables are only created and initialized once (the
    first time when the function they are declared in runs), and after that, the static
    variable retains its old value. Say, we declare `runCount` as a regular, local,
    nonstatic variable:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为静态变量只创建和初始化一次（在它们声明的函数第一次运行时），之后静态变量会保留其旧值。比如说，我们将`runCount`声明为一个常规的、局部的、非静态变量：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, this is how the output will look:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输出将看起来是这样的：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we see `testFunc` saying `Ran this function 1 time` both the times. As
    a local variable, the value of `runCount` is not retained between function calls.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到`testFunc`两次都说了“运行了此函数1次”。作为一个局部变量，`runCount`的值在函数调用之间不会保留。
- en: You should not overuse static local variables. In general, you should only use
    a static local variable when it is absolutely necessary.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该过度使用静态局部变量。一般来说，只有在绝对必要时才应该使用静态局部变量。
- en: Const variables
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量变量
- en: 'A `const` variable is a variable whose value you promise the compiler not to
    change after the first initialization. We can declare one simply, for example,
    for the value of `pi`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`变量是一个你承诺编译器在第一次初始化后不会改变的值的变量。我们可以简单地声明一个，例如，用于`pi`的值：'
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since `pi` is a universal constant (one of the few things you can rely on to
    be the same), there should be no need to change `pi` after initialization. In
    fact, changes to `pi` should be forbidden by the compiler. Try, for example, to
    assign `pi` a new value:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `pi` 是一个通用常数（你唯一可以依赖的保持不变的东西之一），因此在初始化后不应需要更改 `pi`。实际上，编译器应该禁止对 `pi` 的更改。例如，尝试给
    `pi` 赋予新的值：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will get the following compiler error:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下编译器错误：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This error makes perfect sense, because besides the initial initialization,
    we should not be able to change the value of `pi`— a variable that is constant.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误完全合理，因为除了初始初始化之外，我们不应该能够更改 `pi` 的值——这是一个常量变量。
- en: Function prototypes
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数原型
- en: 'A function prototype is the signature of the function without the body. For
    example, let''s prototype the `isPositive`, `absEqual`, and `getGrade` functions
    from the following exercises:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 函数原型是函数的签名，不包括函数体。例如，让我们从以下练习中原型化 `isPositive`、`absEqual` 和 `getGrade` 函数：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice how the function prototypes are just the return type, function name,
    and argument list that the function requires. Function prototypes don't get a
    body. The body of the function is typically put in the `.cpp` file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数原型只是函数所需的返回类型、函数名和参数列表。函数原型不包含函数体。函数体通常放在 `.cpp` 文件中。
- en: .h and .cpp files
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .h 和 .cpp 文件
- en: It is typical to put your function prototypes in an `.h` file and the bodies
    of the functions in a `.cpp` file. The reason for this is you can include your
    `.h` file in a bunch of `.cpp` files and not get multiple definition errors.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将你的函数原型放在 `.h` 文件中，将函数体放在 `.cpp` 文件中。这样做的原因是你可以将你的 `.h` 文件包含在多个 `.cpp` 文件中，而不会出现多重定义错误。
- en: The following screenshot gives you a clear picture of `.h` and `.cpp` files:.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图为您清晰地展示了 `.h` 和 `.cpp` 文件：
- en: '![.h and .cpp files](img/00058.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![.h 和 .cpp 文件](img/00058.jpeg)'
- en: 'Here, we have three files in this Visual C++ project:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 Visual C++ 项目中，我们有三个文件：
- en: '![.h and .cpp files](img/00059.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![.h 和 .cpp 文件](img/00059.jpeg)'
- en: prototypes.h contains
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: prototypes.h 包含
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `prototypes.h` file contains function prototypes. We will explain what the
    `extern` keyword does in a few paragraphs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`prototypes.h` 文件包含函数原型。我们将在几段中解释 `extern` 关键字的作用。'
- en: funcs.cpp contains
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: funcs.cpp 包含
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: main.cpp contains
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: main.cpp 包含
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When you split up the code into `.h` and `.cpp` files, the `.h` file (the header
    file) is called the interface and the `.cpp` file (the one with the actual functions
    in it) is called the implementation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将代码拆分为 `.h` 和 `.cpp` 文件时，`.h` 文件（头文件）被称为接口，而 `.cpp` 文件（包含实际函数的文件）被称为实现。
- en: The puzzling part at first for some programmers is how does C++ know where the
    `isPositive` and `getGrade` function bodies are, if we only `#include` the prototypes?
    Shouldn't we `#include` the `funcs.cpp` file into `main.cpp` too?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些程序员来说，最初令人困惑的部分是，如果我们只包含原型，C++ 如何知道 `isPositive` 和 `getGrade` 函数体的位置？我们不应该也将
    `funcs.cpp` 文件包含到 `main.cpp` 中吗？
- en: The answer is *magic*. You only need to `#include` the `prototypes.h` header
    file in both `main.cpp` and `funcs.cpp`. As long as both `.cpp` files are included
    in your C++ **Integrated Development Environment** (**IDE**) project (that is,
    they appear in the **Solution Explorer** tree view at the left-hand side), the
    linkup of the prototypes to the function bodies is done automatically by the compiler.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是“魔法”。你只需要在 `main.cpp` 和 `funcs.cpp` 中包含 `prototypes.h` 头文件。只要两个 `.cpp` 文件都包含在你的
    C++ **集成开发环境**（**IDE**）项目中（即它们出现在左侧的 **解决方案资源管理器**树视图中），编译器会自动完成原型到函数体的链接。
- en: Extern variables
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部变量
- en: An `extern` declaration is similar to a function prototype, only it is used
    on a variable. You can put an `extern` global variable declaration in an `.h`
    file, and include this `.h` file in a whole bunch of other files. This way, you
    can have a single global variable that gets shared across multiple source files,
    without getting the multiply defined symbols found linker error. You'd put the
    actual variable declaration in a `.cpp` file so that the variable only gets declared
    once. There is an `extern` variable in the `prototypes.h` file in the previous
    example.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern` 声明与函数原型类似，但它用于变量。你可以在 `.h` 文件中放置一个 `extern` 全局变量声明，并将此 `.h` 文件包含在许多其他文件中。这样，你可以有一个在多个源文件之间共享的单个全局变量，而不会出现链接器错误中找到的多重定义符号。你将在
    `.cpp` 文件中放置实际的变量声明，这样变量就只声明一次。在上一个示例中，`prototypes.h` 文件中有一个 `extern` 变量。'
- en: Macros
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏
- en: C++ macros are from a class of C++ commands called preprocessor directives.
    A preprocessor directive is executed before compilation takes place.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 宏属于一类称为预处理器指令的 C++ 命令。预处理器指令是在编译之前执行的。
- en: 'Macros start with `#define`. For example, say we have the following macro:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 宏以 `#define` 开头。例如，假设我们有以下宏：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At the lowest level, macros are simply copy and paste operations that occur
    just before compile time. In the preceding macro statement, the `3.14159` literal
    will be copied and pasted everywhere the symbol `PI` occurs in the program.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低级别上，宏仅仅是编译前发生的复制粘贴操作。在先前的宏语句中，字面量 `3.14159` 将被复制并粘贴到程序中 `PI` 符号出现的所有地方。
- en: 'Take an example of the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下代码为例：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'What the C++ preprocessor will do is first go through the code and look for
    any usage of the `PI` symbol. It will find one such usage on this line:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 预处理器将首先遍历代码，寻找对 `PI` 符号的任何使用。它会在这一行找到这样一个用法：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding line will convert to the following just before compilation:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译之前，前面的行将转换为以下内容：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, all that happens with a `#define` statement is that all the occurrences
    of the symbol used (example, `PI`) are replaced by the literal number `3.14159`
    even before compilation occurs. The point of using macros in this way is to avoid
    hardcoding numbers into the code. Symbols are typically easier to read than big,
    long numbers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`#define` 语句所发生的一切就是，在编译发生之前，所有使用的符号（例如，`PI`）的出现都将被字面数字 `3.14159` 替换。使用宏的这种方式的目的是避免将数字硬编码到代码中。符号通常比大而长的数字更容易阅读。
- en: Advice – try to use const variables where possible
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建议——尽可能使用 const 变量
- en: 'You can use macros to define constant variables. You can also use `const` variable
    expressions instead. So, say we have the following line of code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用宏来定义常量变量。你也可以使用 `const` 变量表达式。所以，假设我们有以下一行代码：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will be encouraged to use the following instead:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将鼓励使用以下内容代替：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using a `const` variable will be encouraged because it stores your value inside
    an actual variable. The variable is typed, and typed data is a good thing.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `const` 变量将被鼓励，因为它将你的值存储在一个实际的变量中。变量是有类型的，有类型的数据是好事。
- en: Macros with arguments
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带参数的宏
- en: 'We can also write macros that accept arguments. Here''s an example of a macro
    with an argument:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以编写接受参数的宏。以下是一个带有参数的宏的示例：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'What this macro will do is every time `println("Some value")` is encountered
    in the code, the code on the right-hand side (`cout << "Some value" << endl`)
    will be copied and pasted on the console. Notice how the argument between the
    brackets is copied in the place of `X`. Say we had the following line of code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏将做的是，每当在代码中遇到 `println("Some value")` 时，右侧的代码（`cout << "Some value" << endl`）将被复制并粘贴到控制台上。注意括号中的参数是如何被复制到
    `X` 的位置的。假设我们有以下一行代码：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will be replaced by the following statement:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被替换为以下语句：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Macros with arguments are exactly like very short functions. Macros cannot contain
    any newline characters in them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 带参数的宏与非常短的功能完全一样。宏不能包含任何换行符。
- en: Advice – use inline functions instead of macros with arguments
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建议——使用内联函数而不是带参数的宏
- en: You have to know about how macros with arguments work because you will encounter
    them in C++ code a lot. Whenever possible, however, many C++ programmers prefer
    to use inline functions over macros with arguments.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须了解关于带参数的宏的工作方式，因为你在 C++ 代码中会遇到很多。然而，尽可能的情况下，许多 C++ 程序员更喜欢使用内联函数而不是带参数的宏。
- en: 'A normal function call execution involves a `jump` instruction to the function
    and then the execution of the function. An inlinefunction is one whose lines of
    code are copied to the point of the function call and no jump is issued. Using
    inline functions usually makes sense for very small, simple functions that don''t
    have a lot of lines of code. For example, we might inline a simple function `max`
    that finds the larger of two values:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正常的函数调用执行涉及一个跳转到函数的指令，然后执行函数。内联函数是指其代码行被复制到函数调用点，并且不会发出跳转指令的函数。通常，使用内联函数对于非常小、简单的函数来说是有意义的，这些函数没有很多代码行。例如，我们可能会内联一个简单的函数
    `max`，该函数找出两个值中的较大值：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Everywhere this `max` function is used, the code for the function body will
    be copied and pasted at the point of the function call. Not having to `jump` to
    the function saves execution time, making inline functions effectively similar
    to macros.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`max`函数被使用的任何地方，函数体的代码都会在函数调用的位置被复制和粘贴。不需要`跳转`到函数中可以节省执行时间，使得内联函数在效果上类似于宏。
- en: There is a catch to using inline functions. Inline functions must have their
    bodies completely contained in the `.h` header file. This is so that the compiler
    can make optimizations and actually inline the function wherever it is used. Functions
    are made inline typically for speed (since you don't have to jump to another body
    of the code to execute the function) but at the cost of code bloat.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联函数有一个陷阱。内联函数必须将其主体完全包含在`.h`头文件中。这样编译器才能进行优化，并在使用函数的任何地方实际内联该函数。通常将函数内联是为了速度（因为你不需要跳转到代码的另一个部分来执行函数），但代价是代码膨胀。
- en: 'The following are the reasons why inline functions are preferred over macros:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些为什么内联函数比宏更受欢迎的原因：
- en: 'Macros are error prone: the argument to the macro is not typed.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 宏容易出错：宏的参数没有类型。
- en: Macros have to be written in one line or you will see them using use escaped
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 宏必须写在一行中，否则你会看到它们使用转义字符
- en: '[PRE46]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If the macro is not carefully written, it will result in difficult-to-fix compiler
    errors. For example, if you do not bracket your argument properly, your code will
    just be wrong.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果宏没有仔细编写，会导致难以修复的编译器错误。例如，如果你没有正确地括号化你的参数，你的代码就会出错。
- en: Large macros are hard to debug.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大型宏很难调试。
- en: It should be said that macros do allow you to perform some preprocessor compiler
    magic. UE4 makes a lot of use of macros with arguments, as you will see later.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出的是，宏确实允许你执行一些预处理器编译器的魔法。UE4大量使用了带参数的宏，你稍后会看到。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Function calls allow you to reuse basic code. Code reuse is important for a
    number of reasons: mainly because programming is hard and duplicating effort should
    be avoided wherever possible. The efforts of the programmer that wrote the `sqrt()`
    function do not need to be repeated by other programmers who want to solve the
    same problem.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用允许你重用基本代码。代码重用对于许多原因来说都很重要：主要是因为编程很困难，应该尽可能避免重复工作。编写`sqrt()`函数的程序员所付出的努力不需要被其他想要解决相同问题的程序员重复。
