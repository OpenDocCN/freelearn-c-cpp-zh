<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Can I Click This? – GUI Fundamentals</h1></div></div></div><p>What do humans and machines really have in common, in the non-Turing sense of the word? It seems like the everyday life of an average human nowadays is almost synonymous with operating the large number of contraptions our species has created, yet most of us don't even speak the same language as the devices we use, which creates a need for some kind of translation. Now it's not as if we can't learn how to speak to machines directly, but it's simply too tedious and time-consuming as our brains work in a completely different way to a common processor. A gray area exists in which relatively intuitive actions performed by humans can also be understood and interpreted by machines without the need for ever getting involved with the underlying complexities - the means of interfacing.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implementation of core data types for all GUI elements</li><li class="listitem" style="list-style-type: disc">Utilizing SFML's render textures to achieve GUI layering</li><li class="listitem" style="list-style-type: disc">Laying down the fundamentals of smooth and responsive GUI interactions by using stylistic attributes</li></ul></div><p>There is quite a bit of ground to cover so let's get started!</p><div><div><div><div><h1 class="title"><a id="ch10lvl1sec84"/>Use of copyrighted resources</h1></div></div></div><p>Before <a id="id430" class="indexterm"/>we begin, it's only fair to credit the true creators of the<a id="id431" class="indexterm"/> fonts and images used in the next two chapters:</p><p>
<em>Fantasy UI Elements</em> by <em>Ravenmore</em> at <a class="ulink" href="http://dycha.net/">http://dycha.net/</a> under the CC-BY 3.0 license:</p><p>
<a class="ulink" href="http://opengameart.org/content/fantasy-ui-elements-by-ravenmore">http://opengameart.org/content/fantasy-ui-elements-by-ravenmore</a>
</p><p>
<em>Vegur font</em> by <em>Arro</em> under the CC0 license (public domain):</p><p>
<a class="ulink" href="http://www.fontspace.com/arro/vegur">http://www.fontspace.com/arro/vegur</a>
</p><p>More <a id="id432" class="indexterm"/>information about all of the licenses that apply to these<a id="id433" class="indexterm"/> resources can be found here:</p><p>
<a class="ulink" href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</a>
</p><p>
<a class="ulink" href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</a>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec85"/>What is a GUI?</h1></div></div></div><p>A GUI, short for <strong>Graphical User Interface</strong>, is a visual intermediary between the user and <a id="id434" class="indexterm"/>a piece of software which serves as a control mechanism for digital devices or computer programs. Using this type of interface is faster and easier than relying on text-based controls, such as typing commands.</p><p>Before any code is written, we need to outline the desired features of our GUI system, which is <a id="id435" class="indexterm"/>going to consist of three major components:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Element</strong>: Every GUI surface that is drawn onto the screen</li><li class="listitem" style="list-style-type: disc"><strong>Interface</strong>: A special kind of element that serves as a container for other elements and can be moved around as well as scrolled</li><li class="listitem" style="list-style-type: disc"><strong>Manager</strong>: The class that is in charge of keeping GUI interfaces in line and behaving</li></ul></div><p>All of the elements in this system need to be able to adapt to a different state when they are hovered over by a mouse or clicked on. Style-sets also need to be applied to different states, resulting in interfaces becoming responsive. Lastly, you must be able to load the interfaces from files at runtime and tie them to code based on an event or a set of events taking place within them.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec52"/>GUI style</h2></div></div></div><p>Unifying <a id="id436" class="indexterm"/>the way styles are applied and used on GUI surfaces is crucial if you need customization and flexibility. To put it simply, modifying and applying every single stylistic attribute of every possible type of element manually would be a nightmare and any kind of code re-use would be impossible. This calls for a custom data type that can be used all across the board: the <code class="literal">GUI_Style</code> structure.</p><p>First things first, any and all GUI elements should be able to support the three following states:</p><div><pre class="programlisting">enum class GUI_ElementState{ Neutral, Focused, Clicked };</pre></div><p>Although these states are not only meant for graphical purposes, each one of them is also defined as<a id="id437" class="indexterm"/> a set of visual properties in order to simulate interaction and fluidity, represented by a set of style attributes:</p><div><pre class="programlisting">struct GUI_Style{
    ...
    sf::Vector2f m_size; // Element size.
    // Background properties.
    sf::Color m_backgroundColor;
    sf::Color m_elementColor;
    std::string m_backgroundImage;
    sf::Color m_backgroundImageColor;
    // Text properties.
    sf::Color m_textColor;
    std::string m_textFont;
    sf::Vector2f m_textPadding;
    unsigned int m_textSize;
    bool m_textCenterOrigin;
    // Glyph properties.
    std::string m_glyph;
    sf::Vector2f m_glyphPadding;
};</pre></div><p>An element or interface can alter every single one of these properties and adjust itself to look completely different based on the state it's in. If they are not defined, the default values set in the constructor take precedence, as shown here:</p><div><pre class="programlisting">GUI_Style(): m_textSize(12), m_textCenterOrigin(false),
  m_backgroundImageColor(255,255,255,255)
{
  sf::Color none    = sf::Color(0, 0, 0, 0);
  m_backgroundColor = none;
  m_elementColor    = none;
  m_textColor       = none;
}</pre></div><p>All of this is useless if we don't have drawable objects to modify, so let's fix that:</p><div><pre class="programlisting">struct GUI_Visual{
    sf::RectangleShape m_backgroundSolid;
    sf::Sprite m_backgroundImage;
    sf::Sprite m_glyph;
    sf::Text m_text;
};</pre></div><p>This basic structure will be a part of every single element and interface allowing them to be represented by any combination of these four drawable elements.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec86"/>Expansion of utility functions</h1></div></div></div><p>In order to<a id="id438" class="indexterm"/> keep things simple and easy to read, it's always a good idea to create utility-type functions out of any code that is going to be used frequently. When dealing with interface de-serialization, many elements have to read in parameters that have spaces in them. Our solution to this problem is to put the string in double quotes and define an inline function to read the data. The perfect spot for that is in the <code class="literal">Utilities.h</code> file:</p><div><pre class="programlisting">inline void ReadQuotedString(std::stringstream&amp; l_stream, 
  std::string&amp; l_string)
{
  l_stream &gt;&gt; l_string;
  if (l_string.at(0) == '"'){
    while (l_string.at(l_string.length() - 1) != '"' ||
      !l_stream.eof())
    {
      std::string str;
      l_stream &gt;&gt; str;
      l_string.append(" " + str);
    }
  }
  l_string.erase(std::remove(l_string.begin(),
    l_string.end(), '"'), l_string.end());
}</pre></div><p>A word is loaded from the string stream object into the string provided as an argument. Its first character is checked to see if it is a double quote. If it is, a <code class="literal">while</code> loop keeps reading in words and appends them to the argument string until either its last character is a double quote or the end of the stream is reached.</p><p>Following that, all of the double quotes in the string are erased.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec87"/>Font management</h1></div></div></div><p>Before <a id="id439" class="indexterm"/>we start to build the structure of our graphical user interface, we need a way to manage and handle the loading and unloading of fonts automatically, just like we did with textures. The effort we put into the resource manager written back in <a class="link" href="ch06.html" title="Chapter 6. Set It in Motion! – Animating and Moving around Your World">Chapter 6</a>, <em>Set It in Motion! – Animating and Moving around Your World</em>, is about to pay off. In order to manage fonts, all we need to do is create a <code class="literal">FontManager.h</code> file and write the following code:</p><div><pre class="programlisting">class FontManager : public ResourceManager&lt;FontManager, sf::Font&gt;{
public:
  FontManager() : ResourceManager("fonts.cfg"){}

  sf::Font* Load(const std::string&amp; l_path){
    sf::Font* font = new sf::Font();
    if (!font-&gt;loadFromFile(
      Utils::GetWorkingDirectory() + l_path))
    {
      delete font;
      font = nullptr;
      std::cerr &lt;&lt; "! Failed to load font: "
        &lt;&lt; l_path &lt;&lt; std::endl;
    }
    return font;
  }
};</pre></div><p>This<a id="id440" class="indexterm"/> defines the font resource configuration file in the constructor, as well as the specific way of loading font files using the <code class="literal">Load</code> method. The resource manager class that we implemented earlier makes this process very simple, so let's keep going!</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec88"/>The core of all elements</h1></div></div></div><p>The <code class="literal">GUI_Element</code> class is the core of every single element and interface. It provides key functionality<a id="id441" class="indexterm"/> that higher level objects rely on, as well as enforcing the implementation of necessary methods, which leads to several distinctive element types.</p><p>A definition of the different element types is a good place to start:</p><div><pre class="programlisting">enum class GUI_ElementType{ Window, Label, Button, Scrollbar,
  Textfield };</pre></div><p>Each element has to hold different styles it can switch to, based on its state. The <code class="literal">unordered_map</code> data structure suits our purposes pretty well:</p><div><pre class="programlisting">using ElementStyles = std::unordered_map&lt;
  GUI_ElementState, GUI_Style&gt;;</pre></div><p>A forward declaration of the owner class is also necessary to prevent cross-inclusion:</p><div><pre class="programlisting">class GUI_Interface;</pre></div><p>Next, we can begin shaping the <code class="literal">GUI_Element</code> class:</p><div><pre class="programlisting">class GUI_Element{
  friend class GUI_Interface;
public:
  GUI_Element(const std::string&amp; l_name, 
    const GUI_ElementType&amp; l_type, GUI_Interface* l_owner);
  virtual ~GUI_Element();

  // Event methods.
  virtual void ReadIn(std::stringstream&amp; l_stream) = 0;
  virtual void OnClick(const sf::Vector2f&amp; l_mousePos) = 0;
  virtual void OnRelease() = 0;
  virtual void OnHover(const sf::Vector2f&amp; l_mousePos) = 0;
  virtual void OnLeave() = 0;
  virtual void Update(float l_dT) = 0;
  virtual void Draw(sf::RenderTarget* l_target) = 0;
  
  virtual void UpdateStyle(const GUI_ElementState&amp; l_state,
    const GUI_Style&amp; l_style);
  virtual void ApplyStyle();
  ... // Getters/setters
  friend std::stringstream&amp; operator &gt;&gt;(
    std::stringstream&amp; l_stream, GUI_Element&amp; b)
  {
    b.ReadIn(l_stream);
    return l_stream;
  }
protected:
  void ApplyTextStyle();
  void ApplyBgStyle();
  void ApplyGlyphStyle();

  void RequireTexture(const std::string&amp; l_name);
  void RequireFont(const std::string&amp; l_name);
  void ReleaseTexture(const std::string&amp; l_name);
  void ReleaseFont(const std::string&amp; l_name);
  void ReleaseResources();
  std::string m_name;
  sf::Vector2f m_position;
  ElementStyles m_style; // Style of drawables.
  GUI_Visual m_visual; // Drawable bits.
  GUI_ElementType m_type;
  GUI_ElementState m_state;
  GUI_Interface* m_owner;

  bool m_needsRedraw;
  bool m_active;
  bool m_isControl;
};</pre></div><p>The most essential part of any GUI element is how it responds to events. This is where the magic of pure-virtual methods comes in. Style application methods, however, are not purely virtual. An element doesn't handle its style any differently to a default element.</p><p>Every element also needs to have a name, a position, a set of styles for every possible state, a visual component that can be drawn, a type and state identifiers, and a pointer to an owner class. It also needs to keep track of whether it needs to be re-drawn, its active status, and a flag that denotes whether it is a control or not. These properties are represented by a set of private data members of the <code class="literal">GUI_Element</code> class.</p><p>With a<a id="id442" class="indexterm"/> rough idea of this structure hammered out, let's shape the finer details of the element class.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec53"/>Implementing the GUI element class</h2></div></div></div><p>The class <a id="id443" class="indexterm"/>we're about to begin implementing is a cornerstone of every single interface and element. It will define how our GUI system behaves. With that in mind, let's start by taking a look at the constructor, as we have quite a bit to initialize:</p><div><pre class="programlisting">GUI_Element::GUI_Element(const std::string&amp; l_name,
  const GUI_ElementType&amp; l_type, GUI_Interface* l_owner)
  : m_name(l_name), m_type(l_type), m_owner(l_owner),
  m_state(GUI_ElementState::Neutral), m_needsRedraw(false),
  m_active(true), m_isControl(false){}</pre></div><p>The element name, type, and a pointer to the owner class arguments are taken in and passed to the appropriate data members. Other additional flags are also initialized to the default values. There's nothing out of the ordinary so far. Let's take a look at how this class is destroyed:</p><div><pre class="programlisting">GUI_Element::~GUI_Element(){ ReleaseResources(); }</pre></div><p>Since there is no dynamic memory allocation going on anywhere in this class, releasing resources is also fairly simple. The method for that specific purpose is simply invoked here. It looks a little like this:</p><div><pre class="programlisting">void GUI_Element::ReleaseResources(){
  for (auto &amp;itr : m_style){
    ReleaseTexture(itr.second.m_backgroundImage);
    ReleaseTexture(itr.second.m_glyph);
    ReleaseFont(itr.second.m_textFont);
  }
}</pre></div><p>We only have to concern ourselves with those textures and fonts that are required by the element itself, so each style is iterated over and its resources are released by the respective methods, which all look similar to the one shown:</p><div><pre class="programlisting">void GUI_Element::ReleaseTexture(const std::string&amp; l_name){
  if (l_name == ""){ return; }
  m_owner-&gt;GetManager()-&gt;GetContext()-&gt;
    m_textureManager-&gt;ReleaseResource(l_name);
}</pre></div><p>If a font is<a id="id444" class="indexterm"/> released, the only difference is the manager that is being used.</p><p>Speaking of styles, we need to have a regulated way of modifying them. The <code class="literal">UpdateStyle</code> method takes care of that job:</p><div><pre class="programlisting">void GUI_Element::UpdateStyle(const GUI_ElementState&amp; l_state, 
  const GUI_Style&amp; l_style)
{
  // Resource management.
  if (l_style.m_backgroundImage !=
    m_style[l_state].m_backgroundImage)
  {
    ReleaseTexture(m_style[l_state].m_backgroundImage);
    RequireTexture(l_style.m_backgroundImage);
  }

  if (l_style.m_glyph != m_style[l_state].m_glyph){
    ReleaseTexture(m_style[l_state].m_glyph);
    RequireTexture(l_style.m_glyph);
  }

  if (l_style.m_textFont != m_style[l_state].m_textFont){
    ReleaseFont(m_style[l_state].m_textFont);
    RequireFont(l_style.m_textFont);
  }
  // Style application.
  m_style[l_state] = l_style;
  if (l_state == m_state){ SetRedraw(true); ApplyStyle(); }
}</pre></div><p>Two arguments are expected by this method: the state being modified and a style structure that will be used to replace the existing structure. While overwriting the relevant style is as simple as using the assignment operator, some resource management has to take place before that happens. We need to know if the style being replaced requires different resources to the other one. If it does, the older textures and fonts are released, while the new ones are reserved by using  two more helper methods which both look something like this:</p><div><pre class="programlisting">void GUI_Element::RequireTexture(const std::string&amp; l_name){
  if (l_name == ""){ return; }
  m_owner-&gt;GetManager()-&gt;GetContext()-&gt;
    m_textureManager-&gt;RequireResource(l_name);
}</pre></div><p>The font equivalent for this method uses a different manager but is otherwise identical.</p><p>Once the<a id="id445" class="indexterm"/> style is overwritten, we check if the state being modified is the same state as the element. If so, this particular element is marked to be re-drawn via the <code class="literal">SetRedraw</code> method, and its style is applied via the <code class="literal">ApplyStyle</code> method, which is what we'll take a look at next:</p><div><pre class="programlisting">void GUI_Element::ApplyStyle(){
  ApplyTextStyle();
  ApplyBgStyle();
  ApplyGlyphStyle();
  if (m_owner != this &amp;&amp; !IsControl()){
    m_owner-&gt;AdjustContentSize(this);
  }
}</pre></div><p>This chunk of code is responsible for connecting the style of an element to its visual representation. It first invokes a few helper methods which help us break down the code into smaller, more manageable chunks. The owner interface needs to be alerted afterwards because any modification of the element style may result in size changes. If the element is not an interface control and isn't its own owner, the <code class="literal">AdjustContentSize</code> method of the <code class="literal">GUI_Interface</code> class is called, with the <code class="literal">this</code> keyword passed in as an argument. We will get to implement it soon.</p><p>Let's take a look at the first helper method, which deals with text style:</p><div><pre class="programlisting">void GUI_Element::ApplyTextStyle(){
  FontManager* fonts = m_owner-&gt;GetManager()-&gt;
    GetContext()-&gt;m_fontManager;
  const GUI_Style&amp; CurrentStyle = m_style[m_state];
  if (CurrentStyle.m_textFont != ""){
    m_visual.m_text.setFont(
      *fonts-&gt;GetResource(CurrentStyle.m_textFont));
    m_visual.m_text.setColor(CurrentStyle.m_textColor);
    m_visual.m_text.setCharacterSize(CurrentStyle.m_textSize);
    if (CurrentStyle.m_textCenterOrigin){
      sf::FloatRect rect = m_visual.m_text.getLocalBounds();
      m_visual.m_text.setOrigin(rect.left + rect.width / 2.0f,
        rect.top + rect.height / 2.0f);
    } else {
      m_visual.m_text.setOrigin(0.f, 0.f);
    }
  }
  m_visual.m_text.setPosition(m_position +
    CurrentStyle.m_textPadding);
}</pre></div><p>A different<a id="id446" class="indexterm"/> font, color, and character size can be applied to the text for each distinct style that an element can have. The text's origin also needs to be re-calculated every time this happens because these attributes can be manipulated at any point. The position of the text is then updated with the padding value of the current style being factored in.</p><p>Background style application follows the same basic idea:</p><div><pre class="programlisting">void GUI_Element::ApplyBgStyle(){
  TextureManager* textures = m_owner-&gt;GetManager()-&gt;
    GetContext()-&gt;m_textureManager;
  const GUI_Style&amp; CurrentStyle = m_style[m_state];
  if (CurrentStyle.m_backgroundImage != ""){
    m_visual.m_backgroundImage.setTexture(
      *textures-&gt;GetResource(CurrentStyle.m_backgroundImage));
    m_visual.m_backgroundImage.setColor(
      CurrentStyle.m_backgroundImageColor);
  }
  m_visual.m_backgroundImage.setPosition(m_position);
  m_visual.m_backgroundSolid.setSize(
    sf::Vector2f(CurrentStyle.m_size));
  m_visual.m_backgroundSolid.setFillColor(
    CurrentStyle.m_backgroundColor);
  m_visual.m_backgroundSolid.setPosition(m_position);
}</pre></div><p>This shows how we add support for the background image and solid elements. Both of these elements are adjusted by applying the visual attributes of a current style and having their positions re-set.</p><p>Finally, the glyph of an element is altered in the same fashion:</p><div><pre class="programlisting">void GUI_Element::ApplyGlyphStyle(){
  const GUI_Style&amp; CurrentStyle = m_style[m_state];
  TextureManager* textures = m_owner-&gt;GetManager()-&gt;
    GetContext()-&gt;m_textureManager;
  if (CurrentStyle.m_glyph != ""){
    m_visual.m_glyph.setTexture(
      *textures-&gt;GetResource(CurrentStyle.m_glyph));
  }
  m_visual.m_glyph.setPosition(m_position +
    CurrentStyle.m_glyphPadding);
}</pre></div><p>Next, let's take a look at the changing element states:</p><div><pre class="programlisting">void GUI_Element::SetState(const GUI_ElementState&amp; l_state){
  if (m_state == l_state){ return; }
  m_state = l_state;
  SetRedraw(true);
}</pre></div><p>The element <a id="id447" class="indexterm"/>must be marked for re-drawing if its state is changed as different states may have style elements that are also different. That, however, is only done if the state provided as an argument does not match the current state, which is done to conserve resources.</p><p>Setting the element position also deserves some attention:</p><div><pre class="programlisting">void GUI_Element::SetPosition(const sf::Vector2f&amp; l_pos){
  m_position = l_pos;
  if (m_owner == nullptr || m_owner == this){ return; }
  const auto&amp; padding = m_owner-&gt;GetPadding();
  if (m_position.x &lt; padding.x){ m_position.x = padding.x; }
  if (m_position.y &lt; padding.y){ m_position.y = padding.y; }
}</pre></div><p>Since all elements are owned by a container structure, their positions must also honor the padding of those containers. Once the element position is set, the padding of the container interface is obtained. If the element position on either axis is less than that padding, the position is set to be at least as far away from the edge as the interface allows it to be.</p><p>Here's an important bit of code that can make or break interactions with any GUI surface:</p><div><pre class="programlisting">bool GUI_Element::IsInside(const sf::Vector2f&amp; l_point) const{
   sf::Vector2f position = GetGlobalPosition();
   return(l_point.x &gt;= position.x &amp;&amp;
      l_point.y &gt;= position.y &amp;&amp;
      l_point.x &lt;= position.x + m_style.at(m_state).m_size.x &amp;&amp;
      l_point.y &lt;= position.y + m_style.at(m_state).m_size.y);
}</pre></div><p>The <code class="literal">IsInside</code> method is used to determine whether a certain point in space is inside an element. Calculating intersections using its normal position yields incorrect results because of its relativity to its owner. Instead, it uses a <code class="literal">GetGlobalPosition</code> method to fetch the element's position in screen space, as opposed to local space, in the render texture of the owner interface. With a bit of basic bounding box collision magic, it then determines if a point provided as an argument is within the element, based on the size of its current style.</p><p>Obtaining global positions of elements can be done like so:</p><div><pre class="programlisting">sf::Vector2f GUI_Element::GetGlobalPosition() const{
  sf::Vector2f position = GetPosition();
  if (m_owner == nullptr || m_owner == this){ return position; }
  position += m_owner-&gt;GetGlobalPosition();
  if (IsControl()){ return position; }
  position.x -= m_owner-&gt;m_scrollHorizontal;
  position.y -= m_owner-&gt;m_scrollVertical;
  return position;
}</pre></div><p>Firstly, the<a id="id448" class="indexterm"/> element's local position is grabbed. The method then determines if this element has an owner and if does not own itself. If it does, the fetched position is simply the final result and is returned. Otherwise, the owner's global position is obtained through the use of this very method and added to the local position. Furthermore, if the element is not a control type, the horizontal and vertical scroll values are subtracted from its position in order to honor interface scrolling.</p><p>To cap things off, here are a few setters and getters that are not straightforward:</p><div><pre class="programlisting">Const sf::Vector2f&amp; GUI_Element::GetSize() const{ 
    return m_style.at(m_state).m_size;
}
void GUI_Element::SetActive(const bool&amp; l_active){ 
    if (l_active != m_active){
     m_active = l_active; 
        SetRedraw(true);
    }
}
std::string GUI_Element::GetText() const{ 
    return m_visual.m_text.getString();
}
void GUI_Element::SetText(const std::string&amp; l_text){ 
    m_visual.m_text.setString(l_text);
    SetRedraw(true);
}</pre></div><div><div><h3 class="title"><a id="note11"/>Note</h3><p>Note the methods <code class="literal">SetActive</code> and <code class="literal">SetText</code>. Whenever an element is modified, we must set its re-draw flag to <code class="literal">true</code>, otherwise it won't be updated until another event requires it.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec89"/>Defining GUI events</h1></div></div></div><p>Providing<a id="id449" class="indexterm"/> fluid interactivity with the interface and a painless way of associating changes with actions inside your application may be the most important criterion to separate good GUI systems from bad ones. As we are already learning SFML, we can use the SFML method and omit events.</p><p>Firstly, we have to define all the possible events that could take place in an interface. Create a <code class="literal">GUI_Event.h</code> file and construct an enumeration, as shown here:</p><div><pre class="programlisting">enum class GUI_EventType{ None, Click, Release, Hover, Leave };</pre></div><p>We must also define a custom structure in the same file that is used to hold event information:</p><div><pre class="programlisting">struct ClickCoordinates{
    float x, y;
};

struct GUI_Event{
    GUI_EventType m_type;
    const char* m_element;
    const char* m_interface;
    union{
        ClickCoordinates m_clickCoords;
    };
};</pre></div><p>The first thing to talk about here is the structure. It should be possible to merely use <code class="literal">sf::Vector2f</code> here. That would work fine under most circumstances but, a few lines below that, you see the importance of <code class="literal">ClickCoordinates</code>. Based on the type of event we're going to be working with, it's going to need to store different data in the <code class="literal">GUI_Event </code>structure. By using a <em>union</em> inside this structure, we're going to avoid allocating additional memory, but that comes at a price. Unions cannot have members that have member functions, virtual functions, or are derivatives of other classes. It is because of this restriction that we are forced to define our own <code class="literal">struct</code> that holds two <em>floats</em> and represents a point.</p><div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>The boost library could potentially be useful in a situation like this as it provides <code class="literal">boost::variant</code>, which is a type-safe union container that doesn't have these limitations. It also has little or no overhead.</p></div></div><p>The actual event structure holds an event type that is used to determine which member of the union is active, as well as names of the element and interface the event originated from. If you have a good eye for detail, you may have asked yourself by now why we're using <code class="literal">const char*</code> data types instead of <code class="literal">std::string</code>. Simplifying data types of data members is another sign that this structure will be incorporated into a union. Unfortunately, <code class="literal">std::string</code> falls into the same trap as <code class="literal">sf::Vector2f</code> and cannot be used in a <a id="id450" class="indexterm"/>union without extra work.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec90"/>The interface class</h1></div></div></div><p>An interface, in its <a id="id451" class="indexterm"/>simplest meaning, is a container of elements. It's a window that can be moved around and scrolled and has all of the same features and event hooks as a regular element. Efficiency is also a great concern, as dealing with lots of elements in a single window is a definite possibility. Those problems can be dealt with by carefully designing a way of drawing elements at the appropriate time.</p><p>The way we want our interfaces to draw content is by using three separate textures for different purposes, as shown below:</p><div><img src="img/B04284_10_01.jpg" alt="The interface class"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <strong>background</strong> layer is<a id="id452" class="indexterm"/> used for drawing backdrop elements</li><li class="listitem" style="list-style-type: disc">The <strong>content</strong> layer is <a id="id453" class="indexterm"/>where all of the elements of the interface are drawn</li><li class="listitem" style="list-style-type: disc">The <strong>controls</strong> layer<a id="id454" class="indexterm"/> hosts elements such as scrollbars that manipulate the content layer and don't need to be scrolled</li></ul></div><p>With the design details out of the way, element storage deserves some attention. As it happens, the <code class="literal">std::unordered_map</code> structure serves this purpose well:</p><div><pre class="programlisting">using Elements = std::unordered_map&lt;std::string,GUI_Element*&gt;;</pre></div><p>Next, a forward declaration of the owner class is needed to prevent cross-inclusion:</p><div><pre class="programlisting">class GUI_Manager;</pre></div><p>All of this brings us to the <code class="literal">GUI_Interface</code> class:</p><div><pre class="programlisting">class GUI_Interface : public GUI_Element{
  friend class GUI_Element;
  friend class GUI_Manager;
public:
  ...
private:
  void DefocusTextfields();
  Elements m_elements;
  sf::Vector2f m_elementPadding;

  GUI_Interface* m_parent;
  GUI_Manager* m_guiManager;

  sf::RenderTexture* m_backdropTexture;
  sf::Sprite m_backdrop;

  // Movement.
  sf::RectangleShape m_titleBar;
  sf::Vector2f m_moveMouseLast;
  bool m_showTitleBar;
  bool m_movable;
  bool m_beingMoved;
  bool m_focused;

  // Variable size.
  void AdjustContentSize(const GUI_Element* l_reference= nullptr);
  void SetContentSize(const sf::Vector2f&amp; l_vec);
  sf::RenderTexture* m_contentTexture;
  sf::Sprite m_content;
  sf::Vector2f m_contentSize;
  int m_scrollHorizontal;
  int m_scrollVertical;
  bool m_contentRedraw;

  // Control layer.
  sf::RenderTexture* m_controlTexture;
  sf::Sprite m_control;
  bool m_controlRedraw;
};</pre></div><div><div><h3 class="title"><a id="note12"/>Note</h3><p>Note the declarations of <code class="literal">friend</code> classes. Both the <code class="literal">GUI_Element</code> and <code class="literal">GUI_Manager</code> need to have access to private and protected members of this class.</p></div></div><p>For now, let's only focus on the private members and leave the public ones for the implementation section of this chapter.</p><p>In addition to having an element container, an interface also defines the amount of padding it has that elements most honor, a pointer to its parent class if it has one, as well as the <a id="id455" class="indexterm"/>manager class and a set of textures that represent its different layers. The rest of the data members, as well as the omitted methods, can't be fully understood unless we talk about implementation details, so let's get right to it!</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec54"/>Implementing the interface class</h2></div></div></div><p>A nice<a id="id456" class="indexterm"/> place to start, as always, is with the class constructor:</p><div><pre class="programlisting">GUI_Interface::GUI_Interface(const std::string&amp; l_name,
  GUI_Manager* l_guiManager)
  : GUI_Element(l_name, GUI_ElementType::Window, this),
  m_parent(nullptr), m_guiManager(l_guiManager), m_movable(false),
  m_beingMoved(false), m_showTitleBar(false), m_focused(false),
  m_scrollHorizontal(0),m_scrollVertical(0),m_contentRedraw(true),
  m_controlRedraw(true)
{
  m_backdropTexture = new sf::RenderTexture();
  m_contentTexture = new sf::RenderTexture();
  m_controlTexture = new sf::RenderTexture();
}</pre></div><p>Quite a lot of data members are initialized through the initializer list here. Firstly, the parent class <code class="literal">GUI_Element</code> needs to know the name, type, and owner of the interface. One of the <code class="literal">GUI_Interface</code> arguments is its name, which gets passed to the <code class="literal">GUI_Element</code> constructor. The type is, of course, set to <code class="literal">Window</code>, and the <code class="literal">this</code> keyword is passed in as the owner of the interface. Additionally, the parent of the interface is initialized to its default value <code class="literal">nullptr</code> and a pointer to the <code class="literal">GUI_Manager</code> class is stored inside the <code class="literal">m_guiManager</code> data member.</p><p>After the data member initialization, we enter the constructor's body, in which three <code class="literal">sf::RenderTexture</code> objects are allocated dynamically. These are the textures that are used to render the background, content, and control layers of an interface.</p><p>Next, let's take a look at freeing up all of these resources in the destructor:</p><div><pre class="programlisting">GUI_Interface::~GUI_Interface(){
  delete m_backdropTexture;
  delete m_contentTexture;
  delete m_controlTexture;
  for (auto &amp;itr : m_elements){
    delete itr.second;
  }
}</pre></div><p>The three texture instances, of course, have to be deleted, as well as every single element that still resides in the element container at the time of destruction. Afterwards, the element<a id="id457" class="indexterm"/> container is cleared.</p><p>Setting the position of an interface is slightly more complex, so let's take a look:</p><div><pre class="programlisting">void GUI_Interface::SetPosition(const sf::Vector2f&amp; l_pos){
    GUI_Element::SetPosition(l_pos);
    m_backdrop.setPosition(l_pos);
    m_content.setPosition(l_pos);
    m_control.setPosition(l_pos);
    m_titleBar.setPosition(m_position.x, m_position.y - m_titleBar.getSize().y);
    m_visual.m_text.setPosition(m_titleBar.getPosition() + m_style[m_state].m_textPadding);
}</pre></div><p>Firstly, the <code class="literal">SetPosition</code> method of the parent class is invoked in order to adjust the actual position. There is no need to fix what isn't broken. Next, the three sprites that represent the background, content, and control layers have their positions adjusted as well. Lastly, you set up the title bar. The solid background shape's position is set to be right above the interface, while the text of the visual component is used as a title and adjusted to take the same position as the title bar background, except with text padding included.</p><p>Empty windows aren't very useful or entertaining, so let's provide a way in which elements can be added to them:</p><div><pre class="programlisting">bool GUI_Interface::AddElement(const GUI_ElementType&amp; l_type, 
  const std::string&amp; l_name)
{
  if (m_elements.find(l_name) != m_elements.end()){return false;}
  GUI_Element* element = nullptr;
  element = m_guiManager-&gt;CreateElement(l_type, this);
  if (!element){ return false; }
  element-&gt;SetName(l_name);
  element-&gt;SetOwner(this);
  m_elements.emplace(l_name, element);
  m_contentRedraw = true;
  m_controlRedraw = true;
  return true;
}</pre></div><p>It is important to avoid name clashes so check the name provided as the second argument against the element container in order to prevent duplicates. If none are found, a <code class="literal">CreateElement</code> method of the <code class="literal">GUI_Manager</code> class is used to create an element of the relevant type on the heap and return its memory address. After verifying that it has indeed been created, the element's name and owner properties are set before it gets inserted into the element container. The interface then sets two flags to re-draw the content and control layers.</p><p>Any interface needs to have a way to provide access to its elements. That's where the <code class="literal">GetElement</code> method comes in:</p><div><pre class="programlisting">GUI_Element* GUI_Interface::GetElement(const std::string&amp; l_name)
const{
  auto itr = m_elements.find(l_name);
  return(itr != m_elements.end() ? itr-&gt;second : nullptr);
}</pre></div><p>It simply<a id="id458" class="indexterm"/> locates the element in the <code class="literal">std::unordered_map</code> using its find method and returns it. If the element isn't found, <code class="literal">nullptr</code> is returned instead. Easy.</p><p>Next, we need to have a way to remove elements from interfaces:</p><div><pre class="programlisting">bool GUI_Interface::RemoveElement(const std::string&amp; l_name){
  auto itr = m_elements.find(l_name);
  if (itr == m_elements.end()){ return false; }
  delete itr-&gt;second;
  m_elements.erase(itr);
  m_contentRedraw = true;
  m_controlRedraw = true;
  AdjustContentSize();
  return true;
}</pre></div><p>Following the same example as the <code class="literal">GetElement</code> method, the element is first located inside the container. The dynamic memory is then de-allocated by using the <code class="literal">delete</code> operator and the element itself is removed from the container. The interface is marked to re-draw its content and control layers and the <code class="literal">AdjustContentSize</code> method is invoked to re-size the content texture, if needed.</p><p>We need to override the original <code class="literal">IsInside</code> method because interfaces occupy additional space due to their title bars, as shown here:</p><div><pre class="programlisting">bool GUI_Interface::IsInside(const sf::Vector2f&amp; l_point) const{
    if (GUI_Element::IsInside(l_point)){ return true; }
    return m_titleBar.getGlobalBounds().contains(l_point);
}</pre></div><p>The parent class method is invoked first to determine if <code class="literal">l_point</code> is inside the space an interface is occupying. If not, the result of the title bar bounding box's <code class="literal">contains</code> method is returned to determine if <code class="literal">l_point</code> is inside that.</p><p>Next is shown the de-serialization portion of the code:</p><div><pre class="programlisting">void GUI_Interface::ReadIn(std::stringstream&amp; l_stream){
    std::string movableState;
    std::string titleShow;
    std::string title;
    l_stream &gt;&gt; m_elementPadding.x &gt;&gt; m_elementPadding.y &gt;&gt; movableState &gt;&gt; titleShow;
    Utils::ReadQuotedString(l_stream, title);
    m_visual.m_text.setString(title);
    if (movableState == "Movable"){ m_movable = true; }
    if (titleShow == "Title"){ m_showTitleBar = true; }
}</pre></div><p>All interfaces<a id="id459" class="indexterm"/> first read in the element padding  <em>x</em> and <em>y</em> values, as well as the state and title parameters. It then uses the <code class="literal">ReadQuotedText</code> utility function which we defined earlier to read in the actual title of the interface. Based on the strings read in, it then sets the <code class="literal">m_movable</code> and <code class="literal">m_showTitleBar</code> flags to reflect those values.</p><p>Now comes the fun part. Let's define what happens when an interface is clicked:</p><div><pre class="programlisting">void GUI_Interface::OnClick(const sf::Vector2f&amp; l_mousePos){
  DefocusTextfields();
  if (m_titleBar.getGlobalBounds().contains(l_mousePos) &amp;&amp;
    m_movable &amp;&amp; m_showTitleBar)
  {
    m_beingMoved = true;
  } else {
    GUI_Event event;
    event.m_type = GUI_EventType::Click;
    event.m_interface = m_name.c_str();
    event.m_element = "";
    event.m_clickCoords.x = l_mousePos.x;
    event.m_clickCoords.y = l_mousePos.y;
    m_guiManager-&gt;AddEvent(event);
    for (auto &amp;itr : m_elements){
      if (!itr.second-&gt;IsInside(l_mousePos)){ continue; }
      itr.second-&gt;OnClick(l_mousePos);
      event.m_element = itr.second-&gt;m_name.c_str();
      m_guiManager-&gt;AddEvent(event);
    }
    SetState(GUI_ElementState::Clicked);
  }
}</pre></div><p>Firstly, we invoke one of the private helper methods responsible for removing focus from all of the <code class="literal">Textfield</code> GUI elements. This will be covered in more depth later. Another problem is dragging, when a click is detected in an interface. If the mouse position is in the title bar area and the interface itself is movable, we set the <code class="literal">m_beingMoved</code> flag to <code class="literal">true</code> to indicate interface dragging.</p><p>In a case <a id="id460" class="indexterm"/>of it just being a regular click anywhere else within the interface boundaries, we first set up an event that is going to be dispatched, indicating that a click has happened. The type is set to <code class="literal">Click</code>, the interface name is copied as a <em>c string</em>, and the mouse coordinates are also set up. The <code class="literal">AddEvent</code> method of the <code class="literal">GUI_Manager</code> class is invoked with our newly created event as an argument. This first event indicates that a click happened within the interface itself and not in any particular element.</p><p>That is quickly followed by a loop that iterates over every single element in the interface. Their <code class="literal">IsInside</code> method is called to determine whether the click that took place was also within any of the elements. If so, the <code class="literal">OnClick</code> method of that particular element is invoked with the mouse position passed in as an argument. The same event that was set up before the loop is then slightly modified to contain the name of the element and is fired again, indicating that the click also affects it. The interface's state is then changed to <code class="literal">CLICKED</code>. The result of this is quite appealing to the eye:</p><div><img src="img/B04284_10_02.jpg" alt="Implementing the interface class"/></div><p>Next, let's take a look at the opposite side of clicking—the <code class="literal">OnRelease</code> method:</p><div><pre class="programlisting">void GUI_Interface::OnRelease(){
  GUI_Event event;
  event.m_type = GUI_EventType::Release;
  event.m_interface = m_name.c_str();
  event.m_element = "";
  m_guiManager-&gt;AddEvent(event);
  for (auto &amp;itr : m_elements){
    if (itr.second-&gt;GetState() != GUI_ElementState::Clicked)
    {
      continue;
    }
    itr.second-&gt;OnRelease();
    event.m_element = itr.second-&gt;m_name.c_str();
    m_guiManager-&gt;AddEvent(event);
  }
  SetState(GUI_ElementState::Neutral);
}</pre></div><p>Just like <a id="id461" class="indexterm"/>before, an event is set up and fired, indicating that a release happened within this specific interface. Every element is then iterated over and their states are checked. If the element is in a <code class="literal">Clicked</code> state, its <code class="literal">OnRelease</code> method is called and another event is fired, indicating the release of the left mouse button within that element. The state of the interface is then set to <code class="literal">Neutral</code>.</p><p>An interface also needs to deal with text being entered:</p><div><pre class="programlisting">void GUI_Interface::OnTextEntered(const char&amp; l_char){
  for (auto &amp;itr : m_elements){
    if (itr.second-&gt;GetType() != GUI_ElementType::Textfield){
      continue;
    }
    if (itr.second-&gt;GetState() != GUI_ElementState::Clicked){
      continue;
    }
    if (l_char == 8){
      // Backspace.
      const auto&amp; text = itr.second-&gt;GetText();
      itr.second-&gt;SetText(text.substr(0, text.length() -1));
      return;
    }
    if (l_char &lt; 32 || l_char &gt; 126){ return; }
    std::string text = itr.second-&gt;GetText();
    text.push_back(l_char);
    itr.second-&gt;SetText(text);
    return;
  }
}</pre></div><p>This method is going to be invoked whenever an SFML event <code class="literal">sf::Event::TextEntered</code> is received by our window. Each element is iterated over until we find one that is of the type <code class="literal">Textfield</code> and is currently in a <code class="literal">Clicked</code> state. The backspace key being pressed is handled by having the last character of our element's text attribute trimmed. Note that we're returning from the method in multiple places in order to avoid several <code class="literal">Textfield</code> elements receiving the same text that is being entered.</p><p>Lastly, we need to check the boundaries of the character value that has been received. Any characters below ID <code class="literal">32</code> or above <code class="literal">126</code> are reserved for other purposes and we're not interested in those. If a regular letter or number is typed in, we want to update our text attribute by adding that character to it.</p><div><div><h3 class="title"><a id="tip20"/>Tip</h3><p>The full <a id="id462" class="indexterm"/>table of ASCII characters can be found here: <a class="ulink" href="http://www.asciitable.com/">http://www.asciitable.com/</a>
</p></div></div><p>Since we're <a id="id463" class="indexterm"/>on the subject of handling text field elements, let's take a look at a method that we used before when handling a <code class="literal">Click</code> event:</p><div><pre class="programlisting">void GUI_Interface::DefocusTextfields(){
  GUI_Event event;
  event.m_type = GUI_EventType::Release;
  event.m_interface = m_name.c_str();
  event.m_element = "";
  for (auto &amp;itr : m_elements){
    if (itr.second-&gt;GetType() != GUI_ElementType::Textfield){
      continue;
    }
    itr.second-&gt;SetState(GUI_ElementState::Neutral);
    event.m_element = itr.second-&gt;m_name.c_str();
    m_guiManager-&gt;AddEvent(event);
  }
}</pre></div><p>When handling text fields, it's important to bear in mind that they lose focus every time a mouse is left-clicked. If that wasn't so, we would end up with text entered across multiple textboxes, and that is no good. Making a text field lose focus is as simple as constructing a <code class="literal">Release</code> event and sending it to every <code class="literal">Textfield</code> element that an interface possesses.</p><p>The next two methods are grouped together due to their similarities:</p><div><pre class="programlisting">void GUI_Interface::OnHover(const sf::Vector2f&amp; l_mousePos){
  GUI_Event event;
  event.m_type = GUI_EventType::Hover;
  event.m_interface = m_name.c_str();
  event.m_element = "";
  event.m_clickCoords.x = l_mousePos.x;
  event.m_clickCoords.y = l_mousePos.y;
  m_guiManager-&gt;AddEvent(event);

  SetState(GUI_ElementState::Focused);
}
void GUI_Interface::OnLeave(){
  GUI_Event event;
  event.m_type = GUI_EventType::Leave;
  event.m_interface = m_name.c_str();
  event.m_element = "";
  m_guiManager-&gt;AddEvent(event);

  SetState(GUI_ElementState::Neutral);
}</pre></div><p>An event is <a id="id464" class="indexterm"/>constructed including the mouse coordinates when the mouse hovers over an interface, as opposed to when the mouse leaves the interface area as in the <code class="literal">OnLeave</code> method. <code class="literal">OnHover</code> and <code class="literal">OnLeave</code> are only called once per event as they do not deal with elements. That job is left to the <code class="literal">Update</code> method:</p><div><pre class="programlisting">void GUI_Interface::Update(float l_dT){
   sf::Vector2f mousePos = sf::Vector2f(
      m_guiManager-&gt;GetContext()-&gt;m_eventManager-&gt;GetMousePos(
      m_guiManager-&gt;GetContext()-&gt;m_wind-&gt;GetRenderWindow()));

   if (m_beingMoved &amp;&amp; m_moveMouseLast != mousePos){
      sf::Vector2f difference = mousePos - m_moveMouseLast;
      m_moveMouseLast = mousePos;
      sf::Vector2f newPosition = m_position + difference;
      SetPosition(newPosition);
   }
   ...
}</pre></div><p>After the mouse position is obtained, the <code class="literal">m_beingMoved</code> flag is checked to determine whether or not an interface is currently being dragged. If it is, and the saved position of the mouse is different to where the mouse is currently located, that difference is calculated and the interface's location is adjusted based on it. With that out of the way, let's take a look at the omitted chunk of code:</p><div><pre class="programlisting">for (auto &amp;itr : m_elements){
  if (itr.second-&gt;NeedsRedraw()){
    if (itr.second-&gt;IsControl()){ m_controlRedraw = true; } 
    else { m_contentRedraw = true; }
  }
  if (!itr.second-&gt;IsActive()){ continue; }
  itr.second-&gt;Update(l_dT);
  if (m_beingMoved){ continue; }
  GUI_Event event;
  event.m_interface = m_name.c_str();
  event.m_element = itr.second-&gt;m_name.c_str();
  event.m_clickCoords.x = mousePos.x;
  event.m_clickCoords.y = mousePos.y;
  if (IsInside(mousePos) &amp;&amp; itr.second-&gt;IsInside(mousePos) 
    &amp;&amp; !m_titleBar.getGlobalBounds().contains(mousePos))
  {
    if (itr.second-&gt;GetState() != GUI_ElementState::Neutral){
      continue;
    }
    itr.second-&gt;OnHover(mousePos);
    event.m_type = GUI_EventType::Hover;
  } else if (itr.second-&gt;GetState() == GUI_ElementState::Focused){
    itr.second-&gt;OnLeave();
    event.m_type = GUI_EventType::Leave;
  }
  m_guiManager-&gt;AddEvent(event);
}</pre></div><p>We begin by <a id="id465" class="indexterm"/>checking if the current element needs to be re-drawn. The relevant flag for re-drawing the entire interface is set to <code class="literal">true</code> if one is encountered, while taking into account whether it's a control element or not.</p><p>When iterating over the list of all elements, their active status is checked. If an element is active, it gets updated. If the interface currently isn't being moved and the mouse is inside both the interface and the element, but not the title bar, the element's current state is checked. A <code class="literal">Hover</code> event needs to be dispatched and the <code class="literal">OnHover</code> method needs to be called if the element's current state is <code class="literal">Neutral</code>. However, if the mouse is not over the element, or the current interface's state is <code class="literal">Focused</code>, a <code class="literal">Leave</code> event is created and submitted, along with the <code class="literal">OnLeave</code> method being invoked.</p><p>Now, let's bring all of this hard work to the screen and render the interface:</p><div><pre class="programlisting">void GUI_Interface::Draw(sf::RenderTarget* l_target){
  l_target-&gt;draw(m_backdrop);
  l_target-&gt;draw(m_content);
  l_target-&gt;draw(m_control);

  if (!m_showTitleBar){ return; }
  l_target-&gt;draw(m_titleBar);
  l_target-&gt;draw(m_visual.m_text);
}</pre></div><p>This is quite simple, thanks to our design involving three different render textures. In order to draw an interface successfully, the sprites for the background, content, and control layers have to be drawn in that specific order. If the <code class="literal">m_showTitleBar</code> flag is set to <code class="literal">true</code>, the title background must also be drawn along with the text.</p><p>Whereas the <code class="literal">Update</code> method does most of the work, moving interfaces requires a bit more preparation. Let's begin by defining two helper methods for movement, starting with the one used to initiate the process:</p><div><pre class="programlisting">void GUI_Interface::BeginMoving(){
  if (!m_showTitleBar || !m_movable){ return; }
  m_beingMoved = true;
  SharedContext* context = m_guiManager-&gt;GetContext();
  m_moveMouseLast = sf::Vector2f(context-&gt;m_eventManager-&gt;
    GetMousePos(context-&gt;m_wind-&gt;GetRenderWindow()));
}</pre></div><p>If the <a id="id466" class="indexterm"/>conditions to move an interface are met, this method is invoked in order to save the mouse position at the point where dragging began.</p><p>We also have a simple line of code to stop interface movement:</p><div><pre class="programlisting">void GUI_Interface::StopMoving(){ m_beingMoved = false; }</pre></div><p>Since interfaces are quite different from normal GUI elements, they have to define their own way of obtaining their global position, as shown here:</p><div><pre class="programlisting">sf::Vector2f GUI_Interface::GetGlobalPosition() const{
    sf::Vector2f pos = m_position;
    GUI_Interface* i = m_parent;
    while (i){
        pos += i-&gt;GetPosition();
        i = i-&gt;m_parent;
    }
    return pos;
}</pre></div><p>When it obtains its actual position, it needs to follow through the chain of parent interfaces and sum all of their positions. A <code class="literal">while</code> loop serves as a nice way of doing this; the final position is returned when it concludes.</p><p>The style application of an interface also differs from the usual element types. Let's take a look:</p><div><pre class="programlisting">void GUI_Interface::ApplyStyle(){
    GUI_Element::ApplyStyle(); // Call base method.
    m_visual.m_backgroundSolid.setPosition(0.f,0.f);
    m_visual.m_backgroundImage.setPosition(0.f,0.f);
    m_titleBar.setSize(sf::Vector2f(m_style[m_state].m_size.x, 16.f));
    m_titleBar.setPosition(m_position.x,m_position.y - m_titleBar.getSize().y);
    m_titleBar.setFillColor(m_style[m_state].m_elementColor);
    m_visual.m_text.setPosition(m_titleBar.getPosition() + m_style[m_state].m_textPadding);
    m_visual.m_glyph.setPosition(m_titleBar.getPosition() + m_style[m_state].m_glyphPadding);
}</pre></div><p>The <code class="literal">ApplyStyle</code> method is invoked first because the parent class does a great job of setting up most of the visual components correctly. The background elements then need to be changed<a id="id467" class="indexterm"/> to have positions with absolute zero values because interfaces render these drawables to a texture and not to a screen. Regardless of the position of the interface, the positions of these elements will not change.</p><p>Next, the title bar background is set up to match the size of the interface on the <em>x</em> axis and should have a height of 16 pixels on the <em>y</em> axis. This hardcoded value can be tweaked at any time. Its position is then set to be right above the interface. The fill color of the title background is defined by the element color property of its style.</p><p>The last four lines set up the position of the title bar text and glyph. The position of the title bar background is summed together with the relevant padding to obtain the final position of these two attributes.</p><p>Rendering time! Let's draw all of these visuals onto their respective textures, starting with the background layer:</p><div><pre class="programlisting">void GUI_Interface::Redraw(){
  if (m_backdropTexture-&gt;getSize().x!=m_style[m_state].m_size.x ||
    m_backdropTexture-&gt;getSize().y != m_style[m_state].m_size.y)
  {
    m_backdropTexture-&gt;create(m_style[m_state].m_size.x,
      m_style[m_state].m_size.y);
  }
  m_backdropTexture-&gt;clear(sf::Color(0, 0, 0, 0));
  ApplyStyle();
  m_backdropTexture-&gt;draw(m_visual.m_backgroundSolid);

  if (m_style[m_state].m_backgroundImage != ""){
    m_backdropTexture-&gt;draw(m_visual.m_backgroundImage);
  }

  m_backdropTexture-&gt;display();
  m_backdrop.setTexture(m_backdropTexture-&gt;getTexture());
  m_backdrop.setTextureRect(sf::IntRect(0, 0,
    m_style[m_state].m_size.x, m_style[m_state].m_size.y));
  SetRedraw(false);
}</pre></div><p>Firstly, a check is made in order to be sure that the background texture is the same size as the current style dictates. If it isn't, the texture is recreated with the correct size.</p><p>The next line is extremely important for good looking results. At first glance, it simply clears the texture to the color black. If you look closely, however, you will notice that it has four arguments instead of three. The last argument is the <strong>alpha channel</strong>, or the transparency value for the color. The texture cleared to black appears as a large black square, and<a id="id468" class="indexterm"/> that's not what we want. Instead, we want it to be <a id="id469" class="indexterm"/>completely empty before drawing elements to it, which is what the alpha value of <em>0</em> will do.</p><p>Next, the <code class="literal">ApplyStyle</code> method is invoked in order to adjust the visual parts of the interface to match the current style. The background solid and the background image are then drawn onto the background texture. The texture's <code class="literal">display</code> method <em>must</em> be called in order to show all of the changes made to it, just like the render window.</p><p>Lastly, the background sprite is bound to the background texture and its visible area is cropped to the interface size in order to prevent overflow. The redraw flag is set to <code class="literal">false</code> to indicate that this process is complete.</p><p>A very similar process also needs to occur for the content layer:</p><div><pre class="programlisting">void GUI_Interface::RedrawContent(){
  if (m_contentTexture-&gt;getSize().x != m_contentSize.x ||
    m_contentTexture-&gt;getSize().y != m_contentSize.y)
  {
    m_contentTexture-&gt;create(m_contentSize.x, m_contentSize.y);
  }

  m_contentTexture-&gt;clear(sf::Color(0, 0, 0, 0));

  for (auto &amp;itr : m_elements){
    GUI_Element* element = itr.second;
    if (!element-&gt;IsActive() || element-&gt;IsControl()){ continue; }
    element-&gt;ApplyStyle();
    element-&gt;Draw(m_contentTexture);
    element-&gt;SetRedraw(false);
  }

  m_contentTexture-&gt;display();
  m_content.setTexture(m_contentTexture-&gt;getTexture());

  m_content.setTextureRect(sf::IntRect(
    m_scrollHorizontal, m_scrollVertical,
    m_style[m_state].m_size.x, m_style[m_state].m_size.y));
  m_contentRedraw = false;
}</pre></div><p>The content texture is checked for dimensions. The only difference here is that we're keeping a manual track of its size in the <code class="literal">m_contentSize</code> float vector, which will be covered later.</p><p>After the <a id="id470" class="indexterm"/>texture is cleared, we iterate over all of the elements inside the interface and check whether they are active or a control element. If all of these conditions are satisfied, the element's style is applied and it is rendered onto the content texture, which gets passed in as the argument of the <code class="literal">Draw</code> method. Its re-draw flag is then set to <code class="literal">false</code>.</p><p>After displaying the texture and binding it to a relevant sprite, it too gets cropped, except that, this time, we use the <code class="literal">m_scrollHorizontal</code> and <code class="literal">m_scrollVertical</code> data members as the first two arguments in order to account for scrolling. Consider the following illustration:</p><div><img src="img/B04284_10_03.jpg" alt="Implementing the interface class"/></div><p>Scrolling an interface means moving the cropped rectangle across the content texture. The <code class="literal">m_contentRedraw</code> flag then gets set to <code class="literal">false</code> to signify that the re-draw process has concluded. It leaves us with a result that looks like this:</p><div><img src="img/B04284_10_04.jpg" alt="Implementing the interface class"/></div><p>The final layer of the interface follows an almost identical path:</p><div><pre class="programlisting">void GUI_Interface::RedrawControls(){
  if (m_controlTexture-&gt;getSize().x!=m_style[m_state].m_size.x ||
    m_controlTexture-&gt;getSize().y != m_style[m_state].m_size.y)
  {
    m_controlTexture-&gt;create(m_style[m_state].m_size.x,
      m_style[m_state].m_size.y);
  }
  m_controlTexture-&gt;clear(sf::Color(0, 0, 0, 0));

  for (auto &amp;itr : m_elements){
    GUI_Element* element = itr.second;
    if (!element-&gt;IsActive() || !element-&gt;IsControl()){ continue; }
    element-&gt;ApplyStyle();
    element-&gt;Draw(m_controlTexture);
    element-&gt;SetRedraw(false);
  }

  m_controlTexture-&gt;display();
  m_control.setTexture(m_controlTexture-&gt;getTexture());
  m_control.setTextureRect(sf::IntRect(0, 0,
    m_style[m_state].m_size.x, m_style[m_state].m_size.y));
  m_controlRedraw = false;
}</pre></div><p>The main<a id="id471" class="indexterm"/> difference here is that the texture is aiming to match the size of the current style, just like the background layer. Only the control elements are drawn this time.</p><p>The subject of interface scrolling keeps popping up, so let's take a look at how it is done:</p><div><pre class="programlisting">void GUI_Interface::UpdateScrollHorizontal(
unsigned int l_percent)
{
  if (l_percent &gt; 100){ return; }
  m_scrollHorizontal = ((m_contentSize.x - GetSize().x) / 100) *
    l_percent;
  sf::IntRect rect = m_content.getTextureRect();
  m_content.setTextureRect(sf::IntRect(
    m_scrollHorizontal, m_scrollVertical,rect.width,rect.height));
}

void GUI_Interface::UpdateScrollVertical(unsigned int l_percent){
  if (l_percent &gt; 100){ return; }
  m_scrollVertical = ((m_contentSize.y - GetSize().y) / 100) *
    l_percent;
  sf::IntRect rect = m_content.getTextureRect();
  m_content.setTextureRect(sf::IntRect(
    m_scrollHorizontal, m_scrollVertical,rect.width,rect.height));
}</pre></div><p>Both the<a id="id472" class="indexterm"/> horizontal and vertical adjustment methods take in a percentage value that tells the interface how much it should be scrolled. The actual amount of pixels an interface should be offset by is calculated by first dividing the difference of its content size on the relevant axis and the size of the interface itself by a hundred, and multiplying the result by the percentage argument. The texture rectangle is then obtained to maintain the proper width and height of the content area, which is then re-set with the scroll values as the first two arguments. This effectively simulates the scroll sensation of an interface.</p><p>Adding, removing, or manipulating different elements inside an interface may alter its size. Here's a method to solve those problems:</p><div><pre class="programlisting">void GUI_Interface::AdjustContentSize(
  const GUI_Element* l_reference)
{
  if (l_reference){
    sf::Vector2f bottomRight = 
      l_reference-&gt;GetPosition() + l_reference-&gt;GetSize();
    if (bottomRight.x &gt; m_contentSize.x){
      m_contentSize.x = bottomRight.x;
      m_controlRedraw = true;
    }
    if (bottomRight.y &gt; m_contentSize.y){
      m_contentSize.y = bottomRight.y;
      m_controlRedraw = true;
    }
    return;
  }

  sf::Vector2f farthest = GetSize();

  for (auto &amp;itr : m_elements){
    GUI_Element* element = itr.second;
    if (!element-&gt;IsActive() || element-&gt;IsControl()){ continue; }
    sf::Vector2f bottomRight =
      element-&gt;GetPosition() + element-&gt;GetSize();
    if (bottomRight.x &gt; farthest.x){
      farthest.x = bottomRight.x;
      m_controlRedraw = true;
    }
    if (bottomRight.y &gt; farthest.y){
      farthest.y = bottomRight.y;
      m_controlRedraw = true;
    }
  }
  SetContentSize(farthest);
}</pre></div><p>Before examining it in depth, I can show you that, inside the class definition, this method looks like this:</p><div><pre class="programlisting">void AdjustContentSize(const GUI_Element* l_reference = nullptr);</pre></div><p>Its only <a id="id473" class="indexterm"/>argument has a default value of <code class="literal">nullptr</code>, which enables the method to detect size changes with or without a reference element.</p><p>If an element is provided as an argument, which usually happens when one is added to an interface, its bottom-right corner coordinates are calculated using its position and size. If these coordinates are somewhere outside of the content size boundaries, the content size is adjusted to be larger and the control redraw flag is set to <code class="literal">true</code> because the physical dimensions of the sliders will be changing. The method then returns in order to prevent the rest of the logic from being executed.</p><p>Without a reference element, a float vector is set up to keep track of the farthest point within the interface texture, the original value of which is the interface size. Every active non-control element is then iterated over and checked to see if it exceeds the furthest point in the texture, which simply gets overwritten on a relevant axis. If an element is found that pokes outside of these boundaries, its bottom-right corner position is stored and the control layer is marked for re-drawing. The content size itself is set to the farthest corner of the interface after all of the elements have been checked.</p><p>This final code snippet concludes the interface class.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec91"/>Summary</h1></div></div></div><p>Just as a book without binding is simply a stack of papers, the code we've written doesn't become what it needs to be unless it is properly incorporated and managed. The groundwork we've laid down in this chapter will aid us greatly in implementing a fully functional GUI system but it only represents all the pieces being laid out.</p><p>So far, we have covered the basic design of GUI elements and windows, as well as implementing quite a few useful features that different types of elements can use. While that is a lot of code, we're not quite done yet. In the next chapter, we will be bringing all of the pieces we worked on together, as well as creating actual GUI elements. See you there!</p></div></body></html>