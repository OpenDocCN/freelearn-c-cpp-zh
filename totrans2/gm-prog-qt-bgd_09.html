<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Qt Quick Basics</h1></div></div></div><div><blockquote class="blockquote"><p><em>In this chapter, you are going to be introduced to a technology called Qt Quick that allows us to implement resolution-independent user interfaces with lots of eye-candy, animations, and effects that can be combined with regular Qt code that implements the logic of the application. You will learn the basics of the QML declarative language that forms the foundation of Qt Quick. Using this language, you can define fancy graphics and animations, make use of particle engines, and structure your code using finite state machines. Pure QML code can be complemented with JavaScript or C++ logic in a manner similar to what you have learned in the previous chapter. By the end of this chapter, you should have enough knowledge to quickly implement fantastic 2D games with custom graphics, moving elements, and lots of visual special effects.</em></p></blockquote></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec131"/>Fluid user interfaces</h1></div></div></div><p>So far, we have been <a id="id654" class="indexterm"/>looking at graphical user interfaces as a set of panels embedded one into another. This is well-reflected in the world of desktop utility programs composed of windows and subwindows containing mostly static content scattered throughout a large desktop area where the user can use a mouse pointer to move windows around or adjust their size. However, this design doesn't correspond well with modern user interfaces that often try to minimize the area they occupy (because of either a small display size like with embedded and mobile devices or to avoid obscuring the main display panel like in games), at the same time providing rich content with a lot of moving or dynamically resizing items. Such user interfaces are often called "fluid" to signify that they are not formed as a number of separate different screens, but rather contain dynamic content and layout where one screen fluently transforms into another. Part of Qt 5 is the Qt Quick (Qt User Interface Creation Kit) module, which provides a runtime to create rich applications with fluid user interfaces. It builds upon a two-dimensional hardware accelerated canvas that contains a hierarchy of interconnected items.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec132"/>Declarative UI programming</h1></div></div></div><p>Although it is technically possible to use Qt Quick by writing C++ code, the module is accompanied by a dedicated programming language called <strong>QML</strong> (<strong>Qt Modeling Language</strong>). QML <a id="id655" class="indexterm"/>is an easy to read and understand declarative language that describes the world as a hierarchy of components that interact and relate to one another. It uses a JSON-like syntax and allows us to use imperative JavaScript expressions as well as dynamic property bindings. So, what is a declarative language, anyway?</p><p>Declarative <a id="id656" class="indexterm"/>programming is one of the programming paradigms that dictates that the program describes the logic of the computation without specifying how this result should be obtained. In contrast to imperative programming, where the logic is expressed as a list of explicit steps forming an algorithm that directly modifies the intermediate program state, a declarative approach focuses on what the ultimate result of the operation should be.</p><p>We use QML by creating one or more QML documents where we define hierarchies of objects. Each document is composed of two sections.</p><p>You can follow every example we explain in Qt Creator by creating a new Qt Quick UI project and placing the presented code in the QML file created for you. The details about using this project type will be described in a later section of this chapter.</p><div><div><h3 class="title"><a id="tip73"/>Tip</h3><p>If you can't see a <strong>Qt Quick UI</strong> project in the Creator's wizard, you have to enable a plugin called <code class="literal">QmlProjectManager</code> by choosing the <strong>About Plugins</strong> entry from the Creator's <strong>Help</strong> menu, then scrolling down to the <strong>QtQuick</strong> section, and making sure the <strong>QmlProjectManager</strong> entry is checked. If it is not, check it and restart Creator:</p><div><img src="img/8874OS_09_29.jpg" alt="Declarative UI programming"/></div></div></div><p>The first section contains a series of <code class="literal">import</code> statements that define the range of components that can be used in a particular document. In its simplest form, each statement consists of the <code class="literal">import</code> keyword followed by the module URI (name) and the module version to import. The following statement imports the <code class="literal">QtQuick</code> module in version 2.1:</p><div><pre class="programlisting">import QtQuick 2.1</pre></div><p>The second section contains a definition of a hierarchy of objects. Each object declaration consists of two parts. First, you have to specify the type of the object and then follow it with the detailed definition enclosed in braces. Since the detailed definition can be empty, the simplest object declaration is similar to the following:</p><div><pre class="programlisting">Item { }</pre></div><p>This declares an instance <a id="id657" class="indexterm"/>of the <code class="literal">Item</code> element, which is the most <a id="id658" class="indexterm"/>basic Qt Quick element and represents an abstract item of the user interface without any visual appearance.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec174"/>Element properties</h2></div></div></div><p>Each element <a id="id659" class="indexterm"/>type in QML defines a number of properties. Values for these properties can be set as part of the detailed definition of an object. The <code class="literal">Item</code> type brings a number of properties for specifying the geometry of an item:</p><div><pre class="programlisting">Item {
  x: 10
  y: 20
  width: 400
  height: 300
}</pre></div><p>
<code class="literal">Item</code> is a very interesting and useful element, but since it is totally transparent, we will now focus on its descendant type that draws a filled rectangle. This type is called <code class="literal">Rectangle</code>. It has a number of additional properties, among them, the <code class="literal">color</code> property for specifying the fill color of the rectangle. To define a red square, we could write the following code:</p><div><pre class="programlisting">Rectangle {
  color: "red"
  width: 400
  height: 400
}</pre></div><p>The problem with this code is that if we ever decide to change the size of the square, we will have to update values for the two properties separately. However, we can use the power of the declarative approach and specify one of the properties as a relation to the other properties:</p><div><pre class="programlisting">Rectangle {
  color: "red"
  width: 400
<strong>  height: width</strong>
}</pre></div><p>This is called <strong>property </strong><a id="id660" class="indexterm"/>
<strong>binding</strong>. It differs from a regular value assignment and binds the value of height to the value of width. Whenever width changes, height will reflect that change in its own value.</p><p>Note that the order of statements in the definition does not matter as you declare relations between properties. The following declaration is semantically identical to the previous one:</p><div><pre class="programlisting">Rectangle {
  height: width
  color: "red"
  width: 400
}</pre></div><p>You can bind a property <a id="id661" class="indexterm"/>not only to a value of another property, but also to any JavaScript statement that returns a value. For example, we can declare rectangle color to be dependent on the proportions between the <a id="id662" class="indexterm"/>width and the height of the element by using a ternary conditional expression operator:</p><div><pre class="programlisting">Rectangle {
  width: 600
  height: 400
<strong>  color: width &gt; height ? "red" : "blue"</strong>
}</pre></div><p>Whenever <code class="literal">width</code> or <code class="literal">height</code> of the object changes, the statement bound to the <code class="literal">color</code> property will be re-evaluated and if <code class="literal">width</code> of the rectangle is larger than its <code class="literal">height</code>, the rectangle will become <code class="literal">red</code>; otherwise, it will be <code class="literal">blue</code>.</p><p>Property binding statements can also contain function calls. We can extend the <code class="literal">color</code> declaration to use a different color if the rectangle is a square by using a custom function:</p><div><pre class="programlisting">Rectangle {
  width: 600
  height: 400
<strong>  color: colorFromSize()</strong>

<strong>  function colorFromSize() {</strong>
<strong>    if(width == height) return "green"</strong>
<strong>    if(width &gt; height) return "red"</strong>
<strong>    return "blue"</strong>
<strong>  }</strong>
}</pre></div><p>QML does its best to determine when the function value may change, but it is not omnipotent. For our last function, it can easily determine that the function result depends on the values of the <code class="literal">width</code> and <code class="literal">height</code> properties, so it will re-evaluate the binding if either of the two values change. However, in some cases, it can't know that a function might return a different value next time it is called, and in such situations, the statement will not be re-evaluated. Consider the following function:</p><div><pre class="programlisting">function colorByTime() {
  var d = new Date()
  var minutes = d.getMinutes()
  if(minutes &lt; 15) return "red"
  if(minutes &lt; 30) return "green"
  if(minutes &lt; 45) return "blue"
  return "purple"
}</pre></div><p>Binding the <code class="literal">color</code> <a id="id663" class="indexterm"/>property to the result of that function will not work properly. QML will only call this function once when the object is initialized, and it will never call it again. This is because it has no way of knowing that the value of this function depends on the current time. Later, we will see how to overcome this with a bit of imperative code and a timer.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec175"/>Group properties</h2></div></div></div><p>The <code class="literal">Rectangle</code> <a id="id664" class="indexterm"/>element allows us to define not only the fill color but also the outline size and color. This is done by using the <code class="literal">border.width</code> and <code class="literal">border.color</code> properties. You can see they have a common prefix followed by a dot. This means these properties are subproperties of a property group <code class="literal">border</code>. There are two ways to bind values to these properties. The first approach is to use the dot notation:</p><div><pre class="programlisting">Rectangle {
  color: "red"
  width: 400
  height: 300
<strong>  border.width: 4</strong>
<strong>  border.color: "black"</strong>
}</pre></div><p>An alternative approach, which is especially useful if you want to set a large number of subproperties in a single group, is to use brackets to enclose definitions in a group:</p><div><pre class="programlisting">Rectangle {
  color: "red"
  width: 400
  height: 300
<strong>  border {</strong>
<strong>    width: 4</strong>
<strong>    color: "black"</strong>
<strong>  }</strong>
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec176"/>Object hierarchies</h2></div></div></div><p>We said that <a id="id665" class="indexterm"/>QML is about defining object hierarchies. You do this in the simplest way possible–by putting one object declaration into another object's declaration. To create a button-like object containing a rounded <a id="id666" class="indexterm"/>frame with some text inside, we'll combine a <code class="literal">Rectangle</code> item with a <code class="literal">Text</code> item:</p><div><pre class="programlisting">Rectangle {
  border { width: 2; color: "black" }
  radius: 5
  color: "transparent"
  width: 50; height: 30

  Text {
    text: "Button Text"
  }
}</pre></div><div><div><h3 class="title"><a id="note14"/>Note</h3><p>You can use a semicolon instead of newlines to separate statements in QML in order to have a more compact object definition at the cost of decreased readability.</p></div></div><p>Running this code produces a result similar to the following diagram:</p><div><img src="img/8874OS_09_01.jpg" alt="Object hierarchies"/></div><p>As we can see, it <a id="id667" class="indexterm"/>does not look good–the frame is not big enough to hold the text and so it flows outside the frame. Moreover, the text is positioned incorrectly.</p><p>Unlike widgets where a child widget is clipped to its parent's geometry, Qt Quick items can be positioned outside their parents.</p><p>Since we didn't specify the <em>x</em> and <em>y</em> coordinates of the text, they are set to their default value, which is <code class="literal">0</code>. As a result, the text is pinned to the top-left corner of the frame and flows outside the right edge of the frame.</p><p>To correct this behavior, we can bind the width of the frame to the width of the text. To do this in the property binding for the rectangle width, we have to specify that we want to use the width of the text object. QML provides a pseudo-property called <code class="literal">id</code> to allow the programmer to name objects. Let's provide an ID for the <code class="literal">Text</code> element and bind the width of the outside object <a id="id668" class="indexterm"/>to the width of the text, and also do the same for the height. At the same time, let's reposition the text a little to provide <a id="id669" class="indexterm"/>padding for the four pixels between the frame and the text itself:</p><div><pre class="programlisting">Rectangle {
  border { width: 2; color: "black" }
  radius: 5
  color: "transparent"
<strong>  width: buttonText.width+8; height: buttonText.height+8</strong>

  Text {
<strong>    id: buttonText</strong>
    text: "Button Text"
<strong>    x:4; y: 4</strong>
  }
}</pre></div><p>As you can see in the following image, such code works, but it is still problematic:</p><div><img src="img/8874OS_09_02.jpg" alt="Object hierarchies"/></div><p>If you set empty text to the internal element, the rectangle width and height will drop to <code class="literal">8</code>, which does not look good. It will also look bad if the text is very long:</p><div><img src="img/8874OS_09_03.jpg" alt="Object hierarchies"/></div><p>Let's complicate matters even more and add an icon to the button by adding another child element to the rectangle. Qt Quick provides an <code class="literal">Image</code> type to display images, so let's use it to position our icon on the left side of the text:</p><div><pre class="programlisting">Rectangle {
<strong>  id: button</strong>
  border { width: 2; color: "black" }
  radius: 5
  color: "transparent"
<strong>  width: 4 + buttonIcon.width + 4 + buttonText.width + 4</strong>
<strong>  height: Math.max(buttonIcon.height, buttonText.height) + 8</strong>

<strong>  Image {</strong>
<strong>    id: buttonIcon</strong>
<strong>    source: "edit-undo.png"</strong>
<strong>    x: 4; y: button.height/2-height/2</strong>
<strong>  }</strong>
  Text { 
    id: buttonText
    text: "Button Text"
<strong>    x: 4+buttonIcon.width+4</strong>
<strong>    y: button.height/2-height/2</strong>
  }
}</pre></div><p>In this code, we used the <code class="literal">Math.max</code> function available in JavaScript to calculate the height of the button, and we modified definitions of the <em>y</em> properties of the internal objects to center them vertically in the button. The source property of <code class="literal">Image</code> contains the URL of a file <a id="id670" class="indexterm"/>containing the image to be shown <a id="id671" class="indexterm"/>in the item.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>The URL can point not only to a local file, but also to a remote HTTP resource. In such an event, if the remote machine is reachable, the file will be fetched from the remote server automatically.</p></div></div><p>The result of the code can be seen in the following image:</p><div><img src="img/8874OS_09_04.jpg" alt="Object hierarchies"/></div><p>Calculating the positions of each internal element as well as the size of the button frame is becoming complicated. Fortunately, we don't have to do it since Qt Quick provides a much better way of managing item geometry by attaching certain points of some objects to points of another object. These points are called anchor lines. The following anchor lines are available to each Qt Quick item:</p><div><img src="img/8874OS_09_05.jpg" alt="Object hierarchies"/></div><p>You can establish bindings between anchor lines to manage relative positioning of items. Each anchor line is represented by two properties–one that can be bound to something and another to bind from. Anchors to bind to are regular properties of the object. They can serve as binding arguments for properties defined in an anchors property group. Therefore, to bind the "left" anchor of the current object to the "right" anchor of the object <code class="literal">otherObject</code>, one would write:</p><div><pre class="programlisting">anchors.left: otherObject.right</pre></div><p>In addition to <a id="id672" class="indexterm"/>specifying an arbitrary number of <a id="id673" class="indexterm"/>anchor bindings, we can also set margins for each of the anchors (or for all of them at once) to offset the two bound anchor lines. Using anchors, we can simplify the previous button definition:</p><div><pre class="programlisting">Rectangle {
  border { width: 2; color: "black" }
  radius: 5
  color: "transparent"
  width: 4 + buttonIcon.width + 4 + buttonText.width + 4
  height: Math.max(buttonIcon.height, buttonText.height) + 8

  Image {
    id: buttonIcon
    source: "edit-undo.png"
<strong>    anchors {</strong>
<strong>      left: parent.left;</strong>
<strong>      leftMargin: 4;</strong>
<strong>      verticalCenter: parent.verticalCenter</strong>
<strong>    }</strong>
  }
  Text {
    id: butonText
    text: "Button Text"
<strong>    anchors {</strong>
<strong>      left: buttonIcon.right;</strong>
<strong>      leftMargin: 4;</strong>
<strong>      verticalCenter: parent.verticalCenter</strong>
<strong>    }</strong>
  }
}</pre></div><p>You can see the <a id="id674" class="indexterm"/>
<code class="literal">button</code> ID is not used anymore. Instead, we <a id="id675" class="indexterm"/>use parent, which is a property that always points to the item's parent.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec133"/>Time for action – creating a button component</h1></div></div></div><p>As an exercise, let's <a id="id676" class="indexterm"/>try to use what you've learned so far to create a more complete and better working button component. The <a id="id677" class="indexterm"/>button is to have a rounded shape with a nice background and should hold definable text and an icon. The button should look good for different texts and icons.</p><p>Start by creating a new project in Qt Creator. Choose <strong>Qt Quick UI</strong> as the project type. When asked for the component set, choose the lowest available version of Qt Quick:</p><div><img src="img/8874OS_09_06.jpg" alt="Time for action – creating a button component"/></div><p>At this point, you should end up with a project containing two files–one with a QML project extension, which is your project management file, and the other with the QML extension, which is your main user interface file. You can see that both files contain QML definitions. That is because Qt Creator manages Qt Quick projects using QML itself (you'll notice it imports the <code class="literal">QmlProject</code> module).</p><p>The QML <a id="id678" class="indexterm"/>document that was created for us contains a "Hello World" example code, which we can use as a starting point in our Qt Quick experiments. If you go to the <strong>Projects</strong> pane and look at the <strong>Run Configuration</strong> for the project, you will notice that it uses something called QML Scene to run your project. This configuration invokes an external application called <code class="literal">qmlscene</code> that is able to load and display an arbitrary QML document. If you run the example code, you should see a white window with some text centered in it. If you click anywhere in the window, the application will close.</p><p>Let's start by creating the button frame. Replace the <code class="literal">Text</code> item with a <code class="literal">Rectangle</code> item. You can see that the text is centered in the window by using a <code class="literal">centerIn</code> anchor binding that we didn't mention before. This is one of two special anchors that are provided for convenience to avoid having to write too much code. Using <code class="literal">centerIn</code> is equivalent to setting both <code class="literal">horizontalCenter</code> and <code class="literal">verticalCenter</code>. The other convenience binding is <code class="literal">fill</code>, which makes one item occupy the whole area of another item (similar to setting the left, right, top, and bottom anchors to their respective anchor lines in the destination item).</p><p>Let's give a basic <a id="id679" class="indexterm"/>look and feel to the button panel by setting <a id="id680" class="indexterm"/>some of its basic properties. This time, instead of setting a solid color for the button, we will declare the background to be a linear gradient. Replace the <code class="literal">Text</code> definition with the following code:</p><div><pre class="programlisting">Rectangle {
  id: button
  anchors.centerIn: parent
  border { width: 1; color: "black" }
  radius: 5
  width: 100; height: 30
  gradient: Gradient {
    GradientStop { position: 0; color: "#eeeeee" }
    GradientStop { position: 1; color: "#777777" }
  }
}</pre></div><p>After running the project, you should see a result similar to the following image:</p><div><img src="img/8874OS_09_07.jpg" alt="Time for action – creating a button component"/></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec177"/>
<em>What just happened?</em>
</h2></div></div></div><p>We bound a <code class="literal">Gradient</code> element to the gradient property and defined two <code class="literal">GradientStop</code> elements as its children, where we specified two colors to blend between. <code class="literal">Gradient</code> does not inherit from <code class="literal">Item</code> and thus is not a visual Qt Quick element. Instead, it is just an object that serves as a data holder for the gradient definition.</p><p>The <code class="literal">Item</code> type has a property called <code class="literal">children</code> that contains a list of visual children (<code class="literal">Item</code> instances) of an item and another property called <code class="literal">resources</code>, which contains a list of non-visual objects (such as <code class="literal">Gradient</code> or <code class="literal">GradientStop</code>) for an item. Normally, you don't need to use these properties when adding visual or non-visual objects to an item as the item will automatically <a id="id681" class="indexterm"/>assign child objects to appropriate <a id="id682" class="indexterm"/>properties. Note that in our code, the <code class="literal">Gradient</code> object is not a child object of the <code class="literal">Rectangle</code>; it is just assigned to its <code class="literal">gradient</code> property.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec134"/>Time for action – adding button content</h1></div></div></div><p>The next <a id="id683" class="indexterm"/>step is to add text and an icon to the button. We <a id="id684" class="indexterm"/>will do this by using another item type called <code class="literal">Row</code>, as shown:</p><div><pre class="programlisting">Rectangle {
  id: button
  // …
  gradient: Gradient {
    GradientStop { position: 0; color: "#eeeeee" }
    GradientStop { position: 1; color: "#777777" }
  }
  width: buttonContent.width+8
  height: buttonContent.height+8

  Row {
    id: buttonContent
    anchors.centerIn: parent
    spacing: 4

    Image {
        id: buttonIcon
        source: "edit-undo.png"
    }
    Text {
        id: buttonText
        text: "ButtonText"
    }
  }
}</pre></div><p>You'll get the following output:</p><div><img src="img/8874OS_09_08.jpg" alt="Time for action – adding button content"/></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec178"/>
<em>What just happened?</em>
</h2></div></div></div><p>
<code class="literal">Row</code> is one out of four positioner types (the others being <code class="literal">Column</code>, <code class="literal">Grid</code>, and <code class="literal">Flow</code>) that spreads its children in a <a id="id685" class="indexterm"/>horizontal row. It makes it possible to <a id="id686" class="indexterm"/>position a series of items without using anchors. <code class="literal">Row</code> has a spacing property that dictates how much space to leave between items.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec135"/>Time for action – sizing the button properly</h1></div></div></div><p>Our current <a id="id687" class="indexterm"/>panel definition still doesn't behave well when it comes to sizing the button. If the button content is very small (for example, the icon doesn't exist or the text is very short), the button will not look good. Typically, push buttons enforce a minimum size–if the content is smaller than a specified size, the button will be expanded to the minimum size allowed. Another problem is that the user might want to override the width or height of the item. In such cases, the content of the button should not overflow past the border of the button. Let's fix these two issues by replacing the <code class="literal">width</code> and <code class="literal">height</code> property bindings with the following code:</p><div><pre class="programlisting">clip: true
implicitWidth: Math.max(buttonContent.implicitWidth+8, 80)
implicitHeight: buttonContent.implicitHeight+8</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec179"/>
<em>What just happened?</em>
</h2></div></div></div><p>The <code class="literal">implicitWidth</code> and <code class="literal">implicitHeight</code> properties can contain the desired size the item wants to have. It's a direct equivalent of <code class="literal">sizeHint()</code> from the widget world. By using these two properties instead of <code class="literal">width</code> and <code class="literal">height</code> (which are bound to <code class="literal">implicitWidth</code> and <code class="literal">implicitHeight</code> by default), we allow the user of our component to override those implicit values. When this happens and the user does not set the width or height big enough to contain the icon and text of the button, we prevent the content from crossing the boundaries of the parent item by setting the <code class="literal">clip</code> property to <code class="literal">true</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec136"/>Time for action – making the button a reusable component</h1></div></div></div><p>So far, we <a id="id688" class="indexterm"/>have been working on a single button. Adding another button by copying the code, changing the identifiers of all components, and setting different bindings to properties are very tedious tasks. Instead, we can make our button item a real component, that is, a new QML type that can be instantiated on demand as many times as required.</p><p>First, position the text cursor right before the bracket opening of the definition of the button and press <em>Alt</em> + <em>Enter</em> on the keyboard to open the refactoring menu, like in the following screenshot:</p><div><img src="img/8874OS_09_09.jpg" alt="Time for action – making the button a reusable component"/></div><p>From the menu, choose <strong>Move Component into Separate File</strong>. In the popup, type in a name for the new <a id="id689" class="indexterm"/>type (for example, <code class="literal">Button</code>) and accept the dialog by clicking on the <strong>OK</strong> button:</p><div><img src="img/8874OS_09_10.jpg" alt="Time for action – making the button a reusable component"/></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec180"/>
<em>What just happened?</em>
</h2></div></div></div><p>You can see that we have a new file called <code class="literal">Button.qml</code> in the project, which contains everything the button item used to have. The main file was simplified to something similar the following:</p><div><pre class="programlisting">import QtQuick 2.0

Rectangle {
  width: 360
  height: 360
  Button {
    id: button
  }
}</pre></div><p>
<code class="literal">Button</code> has become a <a id="id690" class="indexterm"/>component–a definition of a new type of element that can be used the same way as element types imported into QML. Remember that QML component names as well as names of files representing them need to begin with a capital letter! If you name a file "button.qml" instead of "Button.qml", then you will not be able to use "Button" as a component name, and trying to use "button" instead will result in an error message. This works both ways–every QML file starting with a capital letter can be treated as a component definition. We will talk more about components later.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec137"/>Event handlers</h1></div></div></div><p>Qt Quick is <a id="id691" class="indexterm"/>meant to be used for creating user interfaces that are highly interactive. It offers a number of elements for taking input events from the user.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec181"/>Mouse input</h2></div></div></div><p>The simplest of <a id="id692" class="indexterm"/>all of them is <code class="literal">MouseArea</code>. It defines a transparent rectangle that <a id="id693" class="indexterm"/>exposes a number of properties and signals related to mouse input. Commonly used signals include clicked, pressed, and released. Let's do a couple of exercises to see how the element can be used.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec138"/>Time for action – making the button clickable</h1></div></div></div><p>Thus far, our <a id="id694" class="indexterm"/>component only looks like a button. The next task is to make it respond to mouse input. As you may have guessed, this is done by using the <code class="literal">MouseArea</code> item.</p><p>Add a <code class="literal">MouseArea</code> child item to the button and use anchors to make it fill the whole area of the button. Call the element <code class="literal">buttonMouseArea</code>. Put the following code in the body of the item:</p><div><pre class="programlisting">Rectangle {
  id: button
  // ... 
  Row { ... }
<strong>  MouseArea {</strong>
<strong>    id: buttonMouseArea</strong>

<strong>    anchors.fill:parent</strong>
<strong>    onClicked: button.clicked()</strong>
<strong>  }</strong>
}</pre></div><p>In addition to this, set the following declaration in the button object just after its ID is declared:</p><div><pre class="programlisting">Rectangle {
  id: button

<strong>  signal clicked()</strong>
  // ...
}</pre></div><p>To test the modification, add the following code at the end of the button object definition, just before the closing bracket:</p><div><pre class="programlisting">onClicked: console.log("Clicked!")</pre></div><p>Then, run the <a id="id695" class="indexterm"/>program and click on the button. You'll see your message printed to the Creator's console. Congratulations!</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec182"/>
<em>What just happened?</em>
</h2></div></div></div><p>With a signal <code class="literal">clicked()</code> statement, we declared that the button object emits a signal called clicked. With the <code class="literal">MouseArea</code> item, we defined a rectangular area (covering the whole button) that reacts to mouse events. Then, we defined <code class="literal">onClicked</code>, which is a signal handler. For every signal an object has, a script can be bound to a handler named like the signal and prefixed with "on"; hence, for the clicked signal, the handler is called <code class="literal">onClicked</code> and for <code class="literal">valueChanged</code> it is called <code class="literal">onValueChanged</code>. In this particular case, we have two handlers defined–one for the button where we write a simple statement to the console, and the other for the <code class="literal">MouseArea</code> element where we call the button's signal function effectively emitting that signal.</p><p>
<code class="literal">MouseArea</code> has even more features, so now let's try putting them to the right use to make our button more feature-rich.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec139"/>Time for action – visualizing button states</h1></div></div></div><p>Currently, there is <a id="id696" class="indexterm"/>no visual reaction to clicking on the button. In the real world, the button has some depth and when you push it and look at it from above, its contents seems to shift a little toward the right and downward. Let's mimic this behavior by making use of the pressed property <code class="literal">MouseArea</code> has, which denotes whether the mouse button is currently being pressed (note that the pressed property is different from the pressed signal that was mentioned earlier). The content of the button is represented by the <code class="literal">Row</code> element, so add the following statements inside its definition:</p><div><pre class="programlisting">Row {
  id: buttonContent
  // …
  anchors.verticalCenterOffset: buttonMouseArea.pressed ? 1 : 0
  anchors.horizontalCenterOffset: buttonMouseArea.pressed ? 1 : 0
  // …
}</pre></div><p>We can also make the text change color when the mouse cursor hovers over the button. For this, we have to do two things. First, let's enable receiving hover events on the <code class="literal">MouseArea</code> by settings its <code class="literal">hoverEnabled</code> property:</p><div><pre class="programlisting">hoverEnabled: true</pre></div><p>When this property is set, <code class="literal">MouseArea</code> will be setting its <code class="literal">containsMouse</code> property to <code class="literal">true</code> whenever it detects the mouse cursor over its own area. We can use this value to set the text color:</p><div><pre class="programlisting">Text {
  id: buttonText
  text: "ButtonText"
<strong>  color: buttonMouseArea.containsMouse ? "white" : "black"</strong>
}</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec183"/>
<em>What just happened?</em>
</h2></div></div></div><p>In the last exercise, we learned to use some properties and signals from <code class="literal">MouseArea</code> to make the button component more interactive. However, the element is much richer in features. In particular, if <a id="id697" class="indexterm"/>hover events are enabled, you can get the current mouse position in the item's local coordinate system through the <code class="literal">mouseX</code> and <code class="literal">mouseY</code> properties that return values. The cursor position can also be reported by handling the <code class="literal">positionChanged</code> signal. Speaking of signals, most <code class="literal">MouseArea</code> signals carry a <code class="literal">MouseEvent</code> object as their argument. This argument is called <code class="literal">mouse</code> and contains useful information about the current state of the mouse, including its position and buttons currently pressed:</p><div><pre class="programlisting">MouseArea {
  anchors.fill: parent
  hoverEnabled: true
  
  onClicked: {
    switch(mouse.button) {
      case Qt.LeftButton:   console.log("Left button clicked"); break;
      case Qt.MiddleButton: console.log("Middle button clicked"); break;
      case Qt.RightButton:  console.log("Right button clicked"); break;
    }
  }
  onPositionChanged: {
    console.log("Position: ["+mouse.x+"; "+mouse.y+"]")
  }
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec140"/>Time for action – notifying the environment about button states</h1></div></div></div><p>We have <a id="id698" class="indexterm"/>added some code to make the button look more natural by changing its visual aspects. Now, let's extend the button programming interface so that developers can use more features of the button.</p><p>The first thing we can do is make button colors definable by introducing some new properties for the button. Let's put the highlighted code at the beginning of the button component definition:</p><div><pre class="programlisting">Rectangle {
  id: button
<strong>  property color topColor: "#eeeeee"</strong>
<strong>  property color bottomColor: "#777777"</strong>
<strong>  property color textColor: "black"</strong>
<strong>  property color textPressedColor: "white"</strong>
  signal clicked()</pre></div><p>Then, we'll <a id="id699" class="indexterm"/>use the new definitions for the background gradient:</p><div><pre class="programlisting">gradient: Gradient {
  GradientStop { position: 0; color: <strong>button.topColor</strong> }
  GradientStop { position: 1; color: <strong>button.bottomColor</strong> }
}</pre></div><p>Now for the text color:</p><div><pre class="programlisting">Text {
  id: buttonText
  text: "ButtonText"
<strong>  color: buttonMouseArea.containsMouse ?</strong>
<strong>    button.textPressedColor : button.textColor</strong>
}</pre></div><p>Also, please notice that we used the <code class="literal">pressed</code> property of <code class="literal">MouseArea</code> to detect whether a mouse button is currently being pressed on the area. We can equip our button with a similar property. Add the following code to the <code class="literal">Button</code> component:</p><div><pre class="programlisting">property alias pressed: buttonMouseArea.pressed</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec184"/>
<em>What just happened?</em>
</h2></div></div></div><p>The first set of changes introduced four new properties defining four colors that we later used in statements defining gradient and text colors for the button. In QML, you can define new properties for objects with the <code class="literal">property</code> keyword. The keyword should be followed by the property type and property name. QML understands many property types, the most common being int, real, string, font, and color. Property definitions can contain an optional default value for the property preceded with a colon. The situation is different with the pressed property definition. You can see that for the property type, the definition contains the word alias. It is not a property type, but rather an indicator that the property is really an alias to another property–each time the pressed property of the button is accessed, the value of the <code class="literal">buttonMouseArea.pressed</code> property is returned, and every time the property is changed, it is the mouse area's property that really gets changed. With a regular property declaration, you can provide any valid expression as the default value because the expression is bound to the property. With a property alias, it is different–the value is mandatory and has to be pointing to an existing property of the same or an other object. You can treat property aliases in a similar way as references in C++.</p><p>Consider the following two definitions:</p><div><pre class="programlisting">property int foo: someobject.prop
property alias bar: someobject.prop</pre></div><p>At first glance, they are similar as they point to the same property and therefore, the values returned for the properties are the same. However, the properties are really very different, which becomes apparent if you try to modify their values:</p><div><pre class="programlisting">  foo = 7
  bar = 7</pre></div><p>The first property actually has an expression bound to it, so assigning <code class="literal">7</code> to <code class="literal">foo</code> simply releases the binding and assigns the value <code class="literal">7</code> to the <code class="literal">foo</code> property, leaving <code class="literal">someobject.prop</code> with its original value. The second statement, however, acts like a C++ reference; therefore, assigning a new value applies the modification to the someobject.prop property the alias is really pointing to.</p><p>Speaking of properties, there <a id="id700" class="indexterm"/>is an easy way to react when a property value is modified. For each existing property, there is a handler available that is executed whenever the property value is modified. The handler name is <code class="literal">on</code> followed by the property name, then followed by the word <code class="literal">Changed</code>, all in camel case–thus, for a foo property, it becomes <code class="literal">onFooChanged</code> and for <code class="literal">topColor</code>, it becomes <code class="literal">onTopColorChanged</code>. To log the current press state of the button to the console, all we need to do is implement the property change handler for this property:</p><div><pre class="programlisting">Button {
  // …

  onPressedChanged: {
  console.log("The button is currently "
  +(pressed ? "" : "not ")+"pressed")
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec185"/>Touch input</h2></div></div></div><p>As mentioned <a id="id701" class="indexterm"/>earlier, <code class="literal">MouseArea</code> is the simplest of input event elements. Nowadays, more and more devices have touch capabilities and Qt Quick can handle <a id="id702" class="indexterm"/>them, as well. Currently, we have three ways of handling touch input.</p><p>First of all, we can keep using <code class="literal">MouseArea</code> as simple touch events are also reported as mouse events; therefore, tapping and sliding a finger on the screen is supported out-of-the-box. The following exercise works on touch-capable devices, as well, when using mouse as input.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec141"/>Time for action – dragging an item around</h1></div></div></div><p>Create a <a id="id703" class="indexterm"/>new <code class="literal">Qt Quick UI</code> project. Modify the default code by discarding the existing child items and adding a circle instead:</p><div><pre class="programlisting">Rectangle {
  id: circle
  width: 60; height: width
  radius: width/2
  color: "red"
}</pre></div><p>Next, use the <code class="literal">drag</code> property of <code class="literal">MouseArea</code> to enable moving the circle by touch (or mouse):</p><div><pre class="programlisting">MouseArea {
  anchors.fill: parent
  drag.target: circle
}</pre></div><p>Then, you can start the application and begin moving the circle around.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec186"/>
<em>What just happened?</em>
</h2></div></div></div><p>A circle was created by defining a rectangle with its height equal to width, making it a square and rounding the borders to half the side length. The <code class="literal">drag</code> property can be used to tell <code class="literal">MouseArea</code> to manage a given item's position using input events flowing into the area element. We denote the item to be dragged by using the target subproperty. You can use other subproperties to control the axis the item is allowed to move along or constrain the move to a given area. An important thing to remember is that the item being dragged cannot be anchored for the axis on which the drag is requested; otherwise, the item will respect the anchor and not the drag. We didn't anchor our circle item at all since we want it to be draggable along both axes.</p><p>The second approach to handling touch input in Qt Quick applications is to use <code class="literal">PinchArea</code>, which is an item similar to <code class="literal">MouseArea</code>, but rather than dragging an item around, it allows you to rotate or scale it using two fingers (with a so called "pinch" gesture), as shown. Be aware that <code class="literal">PinchArea</code> reacts only to touch input, so to test the example you will need a real touch capable device.</p><div><img src="img/8874OS_09_11.jpg" alt="What just happened?"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec142"/>Time for action – rotating and scaling a picture by pinching</h1></div></div></div><p>Start a <a id="id704" class="indexterm"/>new <code class="literal">Qt Quick UI</code> project. In the QML file, delete everything but the external item. Then, add an image to the UI and make it <a id="id705" class="indexterm"/>centered in its parent:</p><div><pre class="programlisting">Image {
  id: image
  anchors.centerIn: parent
  source: "wilanow.jpg"
}</pre></div><p>Now, we will add a <code class="literal">PinchArea</code> element. This kind of item can be used in two ways–either by manually implementing signal handlers <code class="literal">onPinchStarted</code>, <code class="literal">onPinchUpdated</code>, and <code class="literal">onPinchFinished</code> to have total control over the functionality of the gesture or by using a simplified interface similar to the drag property of <code class="literal">MouseArea</code>. Since the simplified interface does exactly what we want, there is no need to handle pinch events manually. Let's add the following declaration to the file:</p><div><pre class="programlisting">PinchArea {
  anchors.fill: parent
  pinch {
    target: image
    minimumScale: 0.2; maximumScale: 2.0
    minimumRotation: -90; maximumRotation: 90
  }
}</pre></div><p>You'll get an output similar to the following screenshot:</p><div><img src="img/8874OS_09_12.jpg" alt="Time for action – rotating and scaling a picture by pinching"/></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec187"/>
<em>What just happened?</em>
</h2></div></div></div><p>Our simple application loads an image and centers it in the view. Then, there is a <code class="literal">PinchArea</code> item filling the view area that is told to operate on the image object. We define the range of <a id="id706" class="indexterm"/>the scaling and rotating of the <a id="id707" class="indexterm"/>item. The rest is left to the <code class="literal">PinchArea</code> item itself. If you start interacting with the application, you will see the item rotate and scale. What really happens behind the scenes is that <code class="literal">PinchArea</code> modifies the values of the two properties each Qt Quick item has–<code class="literal">rotation</code> and <code class="literal">scale</code>.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>
<code class="literal">PinchArea</code> can also control the dragging of the item with <code class="literal">pinch.dragAxis</code>, just like <code class="literal">MouseArea</code> does with drag, but for simplicity, we didn't use this part of the API. Feel free to experiment with it in your own code.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec188"/>Have a go hero – rotating and scaling with a mouse</h2></div></div></div><p>Of course, you don't have to use <code class="literal">PinchArea</code> to rotate or scale an item. Properties controlling <a id="id708" class="indexterm"/>those aspects are regular properties that you can read <a id="id709" class="indexterm"/>and write at any time. Try replacing <code class="literal">PinchArea</code> with <code class="literal">MouseArea</code> to obtain a result similar to what we just did by modifying the scale and rotation properties as a result of receiving mouse events–when the user drags the mouse while pressing the left button, the image is scaled and when the user does the same while pressing the right button, the image is rotated. You can control which buttons trigger mouse events by manipulating the <code class="literal">acceptedButtons</code> property (setting it to <code class="literal">Qt.LeftButton|Qt.RightButton</code> will cause both buttons to trigger events). The button that triggers the event is reported in the event object (which is called <code class="literal">mouse</code>) through its <code class="literal">button</code> property, and the list of all buttons currently pressed is available in the <code class="literal">button</code> property:</p><div><pre class="programlisting">MouseArea {
  acceptedButtons: Qt.LeftButton|Qt.RightButton
  onPositionChanged: console.log(mouse.button)
}</pre></div><p>If you manage to do the task, try replacing <code class="literal">MouseArea</code> with <code class="literal">PinchArea</code> again, but then instead of using the <code class="literal">pinch</code> property, handle events manually to obtain the same effect (the event object is called <code class="literal">pinch</code> and has a number of properties you can play with).</p><p>A third approach to <a id="id710" class="indexterm"/>handling touch input is by using the <code class="literal">MultiPointTouchArea</code> item. It provides a low-level interface to gestures by reporting each touch <a id="id711" class="indexterm"/>point separately. It can be used to create custom high-level gesture handlers similar to <code class="literal">PinchArea</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec189"/>Keyboard input</h2></div></div></div><p>So far, we've been <a id="id712" class="indexterm"/>dealing with pointer input, but user input is not just that–we can also handle keyboard input. This is quite simple and basically boils down to two easy steps.</p><p>First, you have to enable receiving keyboard events by stating that a particular item has keyboard focus:</p><div><pre class="programlisting">focus: true</pre></div><p>Then, you can start <a id="id713" class="indexterm"/>handling events by writing handlers in a similar fashion as for mouse events. However, <code class="literal">Item</code> doesn't provide its own handler for manipulating keys that is a counterpart for <code class="literal">keyPressEvent</code> and <code class="literal">keyReleaseEvent</code> of <code class="literal">QWidget</code>. Instead, adequate handlers are provided by the <code class="literal">Keys</code> attached property.</p><p>Attached properties are provided by elements that are not used as stand-alone elements but instead provide properties to other objects by getting attached to them. This is a way of adding support for new properties without modifying the API of the original element (it doesn't add new properties through an <strong>is-a</strong> relation, but rather through a <strong>has-a</strong> one). Each object that references an attached property gets its own copy of the attaching object that then handles the extra properties. We will come back to attached properties later in this chapter. For now, you just need to remember that in certain situations, an element can obtain additional properties that are not part of its API.</p><p>Let's go back to implementing event handlers for keyboard input. As we said earlier, each Item has a <code class="literal">Keys</code> attached property that allows us to install our own keyboard handlers. The basic two signals <code class="literal">Keys</code> adds to <code class="literal">Item</code> are pressed and released; therefore, we can implement the <code class="literal">onPressed</code> and <code class="literal">onReleased</code> handlers that have a <code class="literal">KeyEvent</code> argument providing similar information as <code class="literal">QKeyEvent</code> in the widget world. As an example, we can see an item that detects when a spacebar was pressed:</p><div><pre class="programlisting">Rectangle {
  focus: true
  Keys.onPressed:  { if(event.key == Qt.Key_Space) color = "red"  }
  Keys.onReleased: { if(event.key == Qt.Key_Space) color = "blue" }
}</pre></div><p>It might become problematic if you want to handle many different keys in the same item as the <code class="literal">onPressed</code> handler would likely contain a giant switch section with branches for every possible key. Fortunately, <code class="literal">Keys</code> offers more properties. Most of the commonly used keys (but not letters) have <a id="id714" class="indexterm"/>their own handlers that are called when the particular <a id="id715" class="indexterm"/>key is pressed. Thus, we can easily implement an item that takes a different color depending on which key was pressed last:</p><div><pre class="programlisting">Rectangle {
  focus: true
  Keys.onSpacePressed:      color = "purple"
  Keys.onReturnPressed:     color = "navy"
  Keys.onVolumeUpPressed:   color = "blue"
  Keys.onRightPressed:      color = "green"
  Keys.onEscapePressed:     color = "yellow"
  Keys.onTabPressed:        color = "orange"
  Keys.onDigit0Pressed:     color = "red"
}</pre></div><p>Please note that there is still a single released signal even if a key has its own pressed signal.</p><p>Now, consider another example:</p><div><pre class="programlisting">import QtQuick 2.1
Item {
  property int number: 0
  width: 200; height: width
  focus: true
  Keys.onSpacePressed: number++

  Text { text: number; anchors.centerIn: parent }
}</pre></div><p>We would expect that when we press and hold the spacebar, we will see the text change from <code class="literal">0</code> to <code class="literal">1</code> and stay on that value until we release the key. If you run the example, you will see that instead, the number keeps incrementing as long as you hold down the key. This is because by default, the keys auto-repeat–when you hold the key, the operating system keeps sending a sequence of press-release events for the key (you can verify that by adding the <code class="literal">console.log()</code> statements to the <code class="literal">Keys.onPressed</code> and <code class="literal">Keys.onReleased</code> handlers). To counter this effect, you can either disable key repeats in your system (which will, of course, not work if someone installs your program on his or her own computer) or you can differentiate between auto-repeat and regular events. In Qt Quick, you can do this easily as each key event carries the appropriate information. Simply replace the handler from the last example with the following one:</p><div><pre class="programlisting">Keys.onSpacePressed: if(!event.isAutoRepeat) number++</pre></div><p>The event variable we use here is the name of the parameter of the <code class="literal">spacePressed</code> signal. As we cannot declare our own names for the parameters like we can do in C++, for each signal handler you will have to look up the name of the argument in the documentation, as shown:</p><div><img src="img/8874OS_09_13.jpg" alt="Keyboard input"/></div><p>In standard C++ applications, we usually use the <em>Tab</em> key to navigate through focusable items. With games (and fluid user interfaces in general), it is more common to use arrow keys for item navigation. Of course, we can handle this situation by using the <code class="literal">Keys</code> attached property and adding <code class="literal">Keys.onRightPressed</code>, <code class="literal">Keys.onTabPressed</code>, and other signal handlers to each of our items where we want to modify the focus property of the desired item, but it would quickly clutter our code. Qt Quick comes to our help once again by providing a <code class="literal">KeyNavigation</code> attached property, which is meant to handle this specific situation and allows <a id="id716" class="indexterm"/>us to greatly simplify the needed code. Now, we can <a id="id717" class="indexterm"/>just specify which item should get into focus when a specific key is triggered:</p><div><pre class="programlisting">Row {
  spacing: 5
  
  Rectangle {
    id: first
    width: 50; height: width
    color: focus ? "blue" : "lightgray"
    focus: true

    KeyNavigation.right: second
  }
  Rectangle {
    id: second
    width: 50; height: width
    color: focus ? "blue" : "lightgray"

    KeyNavigation.right: third
    KeyNavigation.left: first
  }
  Rectangle {
    id: third
    width: 50; height: width
    color: focus ? "blue" : "lightgray"

    KeyNavigation.left: second
  }
}</pre></div><p>Notice that we made the first item get into focus in the beginning by explicitly setting the focus property.</p><p>Both the <code class="literal">Keys</code> and <code class="literal">KeyNavigation</code> attached properties have a way to define the order in which each of the mechanisms <a id="id718" class="indexterm"/>receive the events. This is handled by the priority property, which can be set to either <code class="literal">BeforeItem</code> or <code class="literal">AfterItem</code>. By default, <code class="literal">Keys</code> <a id="id719" class="indexterm"/>will get the event first (<code class="literal">BeforeItem</code>), then the internal event handling can take place and finally, <code class="literal">KeyNavigation</code> will have a chance of handling the event (<code class="literal">AfterItem</code>). Note that if the key is handled by one of the mechanisms, the event is accepted and the remaining mechanisms will not be able to handle that event.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec190"/>Have a go hero – practicing key-event propagation</h2></div></div></div><p>As an <a id="id720" class="indexterm"/>exercise, you can expand our last example by building a larger array of items (you can use the <code class="literal">Grid</code> element to position them) and defining a navigation system that makes use of the <code class="literal">KeyNavigation</code> attached property. Have some of the items handle events themselves using the <code class="literal">Keys</code> attached property. See what happens when the same key is handled by both mechanisms. Try influencing the behavior using the priority property.</p><p>Apart from the attached properties we described, Qt Quick provides built-in elements for handling keyboard input. The two most basic types are <code class="literal">TextInput</code> and <code class="literal">TextEdit</code>, which are QML equivalents of <code class="literal">QLineEdit</code> and <code class="literal">QTextEdit</code>. The former are used for single-line text input, while the latter serve as its multi-line counterpart. They both offer cursor handling, undo-redo functionality, and text selections. You can validate text typed into <code class="literal">TextInput</code> by assigning a validator to the <code class="literal">validator</code> property. For example, to obtain an item where the user can input a dot-separated IP address, we could use the following declaration:</p><div><pre class="programlisting">TextInput {
  id: ipAddress
  width: 100
  validator: RegExpValidator {
    regExp: /\d+\.\d+\.\d+\.\d+/ 
    /* four numbers separated by dots*/
  }
  focus: true
}</pre></div><p>The regular expression only verifies the format of the address. The user can still insert bogus numbers. You should either do a proper check before using the address or provide a more complex regular expression that will constrain the range of numbers the user can enter.</p><p>One thing to remember is that neither <code class="literal">TextInput</code> nor <code class="literal">TextEdit</code> has any visual appearance (apart <a id="id721" class="indexterm"/>from the text and cursor they contain), so if you want to give the user some visual hint as to where the item is positioned, the easiest solution is to wrap it in a styled rectangle:</p><div><pre class="programlisting">Rectangle {
  id: textInputFrame
  width: 200
  height: 40
  border { color: "black"; width: 2 }
  radius: 10
  antialiasing: true
  color: "darkGray"
}
TextInput {
  id: textInput
  anchors.fill: textInputFrame
  anchors.margins: 5
  font.pixelSize: height-2
  verticalAlignment: TextInput.AlignVCenter
  clip: true
}</pre></div><p>Notice the highlighted code–the <code class="literal">clip</code> property of <code class="literal">textInput</code>–is enabled such that by default, if the text entered in the box doesn't fit in the item, it will overflow it and remain visible outside the actual item. By enabling clipping, we explicitly say that anything that doesn't fit the item should not be drawn.</p><div><img src="img/8874OS_09_14.jpg" alt="Have a go hero – practicing key-event propagation"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec143"/>Using components in Qt Quick</h1></div></div></div><p>By now, you <a id="id722" class="indexterm"/>should be familiar with the very basics of QML and Qt Quick. Now, we can start combining what you know and fill the gaps with more information to build a functional Qt Quick application. Our target is going to be to display an analog clock.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec144"/>Time for action – a simple analog clock application</h1></div></div></div><p>Create a new <code class="literal">Qt Quick UI</code> project. To create a clock, we will implement a component representing the clock <a id="id723" class="indexterm"/>needle and we will use instances of that component in the actual clock element. In addition to this, we will make the clock a reusable component; therefore, we will create it in a separate file and instantiate it from within <code class="literal">main.qml</code>:</p><div><pre class="programlisting">import QtQuick 2.0

Clock {
  id: clock
  width:  400
  height: 400
}</pre></div><p>Then, add the new QML file to the project and call it <code class="literal">Clock.qml</code>. Let's start by declaring a circular clock plate:</p><div><pre class="programlisting">import QtQuick 2.0

Item {
  id: clock

  property color color: "lightgray"

  Rectangle {
    id: plate

    anchors.centerIn: parent
    width: Math.min(clock.width, clock.height)
    height: width
    radius: width/2
    color: clock.color
    border.color: Qt.darker(color)
    border.width: 2
  }
}</pre></div><p>If you run the program now, you'll see a plain gray circle hardly resembling a clock plate:</p><div><img src="img/8874OS_09_15.jpg" alt="Time for action – a simple analog clock application"/></div><p>The next step is to <a id="id724" class="indexterm"/>add marks dividing the plate into 12 sections. We can do this by putting the following declaration inside the <code class="literal">plate</code> object:</p><div><pre class="programlisting">Repeater {
  model: 12
  
  Item {
    id: hourContainer

    property int hour: index
    height: plate.height/2
    transformOrigin: Item.Bottom
    rotation: index * 30
    x: plate.width/2
    y: 0

    Rectangle {
      width: 2
      height: (hour % 3 == 0) ? plate.height*0.1 
                              : plate.height*0.05
      color: plate.border.color
      antialiasing: true
      anchors.horizontalCenter: parent.horizontalCenter
      anchors.top: parent.top
      anchors.topMargin: 4
    }
  }
}</pre></div><p>Running the program <a id="id725" class="indexterm"/>should now give the following result, looking much more like a clock plate:</p><div><img src="img/8874OS_09_16.jpg" alt="Time for action – a simple analog clock application"/></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec191"/>
<em>What just happened?</em>
</h2></div></div></div><p>The code we just created introduces a couple of new features. Let's go through them one by one.</p><p>First of all, we used a new element called <code class="literal">Repeater</code>. It does exactly what its name says–it repeats items declared within it using a given model. For each entry in the model, it creates an instance of a component assigned to a property called <code class="literal">delegate</code> (the property name means that it contains an entity to which the caller delegates some responsibility, such as describing a component to be used as a stencil by the caller). <code class="literal">Item</code> declared in <code class="literal">Repeater</code> describes the delegate even though we cannot see it explicitly assigned to a property. This is because <code class="literal">delegate</code> is a default property of the <code class="literal">Repeater</code> type, which means anything unassigned to any property explicitly gets implicitly assigned to the default property of the type.</p><p>The <code class="literal">Item</code> type also has a default property called <code class="literal">data</code>. It holds a list of elements that gets automatically split into two "sublists"–the list of the item's children (which creates the hierarchy of <code class="literal">Item</code> instances in Qt Quick) and another list called resources, which contains all "child" elements that do not inherit from <code class="literal">Item</code>. You have direct access to all three lists which means calling <code class="literal">children[2]</code> will return the third <code class="literal">Item</code> element declared in the item, and <code class="literal">data[5]</code> will return the sixth element declared in the <code class="literal">Item</code> regardless of whether the given element is a visual item (that inherits <code class="literal">Item</code>) or not.</p><p>The model can be a number of things but in our case, it is simply a number denoting how many times the delegate should be repeated. The component to be repeated is a transparent item containing a rectangle. The item has a property declared called <code class="literal">hour</code> that has something called <code class="literal">index</code> bound to it. The latter is a property assigned by <code class="literal">Repeater</code> to each instance of the delegate component. The value it contains is the index of the instance in the <code class="literal">Repeater</code> object–since we have a model containing twelve elements, <code class="literal">index</code> will hold values within a range of <code class="literal">0</code> to <code class="literal">11</code>. The item can make use of the <code class="literal">index</code> property to customize instances created by <code class="literal">Repeater</code>. In this particular case, we use <code class="literal">index</code> to provide values for a <code class="literal">rotation</code> property and by multiplying the index by <code class="literal">30</code>, we get values starting from <code class="literal">0</code> for the first instance and ending at <code class="literal">330</code> for the last one.</p><p>The <code class="literal">rotation</code> property brings us to the second most important subject–item transformations. Each item can be transformed in a number of ways, including rotating the item and scaling it in <a id="id726" class="indexterm"/>two-dimensional space as we already mentioned earlier. Another property called <code class="literal">transformOrigin</code> denotes the origin point around which scale and rotation are applied. By default, it points to <code class="literal">Item.Center</code>, which makes the item scale and rotate around its center, but we can change it to eight other values such as <code class="literal">Item.TopLeft</code> for the top-left corner or <code class="literal">Item.Right</code> for the middle of the right edge of the item. In the code we crafted, we rotate each item clockwise around its bottom edge. Each item is positioned horizontally in the middle of the plate using the <code class="literal">plate.width/2</code> expression and vertically at the top of the plate with the default width of <code class="literal">0</code> and the height of half the plate's height; thus, each item is a thin vertical line spanning from within the top to the center of the plate. Then, each item is rotated around the center of the plate (each item's bottom edge) by 30 degrees more than a previous item effectively laying items evenly on the plate.</p><p>Finally, each item has a gray <code class="literal">Rectangle</code> attached to the top edge (offset by <code class="literal">4</code>) and horizontally centered in the transparent parent. Transformations applied to an item influence the item's children similarly to what we have seen in Graphics View; thus, the effective rotation of the rectangle follows that of its parent. The height of the rectangle depends on the value of <code class="literal">hour</code>, which maps to the index of the item in <code class="literal">Repeater</code>. Here, you cannot use <code class="literal">index</code> directly as it is only visible within the top-most item of the delegate. That's why we create a real property called <code class="literal">hour</code> that can be referenced from within the whole delegate item hierarchy.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>If you want more control over item transformations, then we are happy to inform you that apart from rotation and scale properties, each item can be assigned an array of elements such as <code class="literal">Rotation</code>, <code class="literal">Scale</code>, and <code class="literal">Translate</code> to a property called <code class="literal">transform</code>, which are applied in order, one at a time. These types have properties for fine-grained control over the transformation. For instance, using <code class="literal">Rotation</code> you can implement rotation over any of the three axes and around a custom origin point (instead of being limited to nine predefined origin points as when using the <code class="literal">rotation</code> property of <code class="literal">Item</code>).</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec145"/>Time for action – adding needles to the clock</h1></div></div></div><p>The next step is to <a id="id727" class="indexterm"/>add the hour, minute, and second needles to the clock. Let's start by creating a new component called <code class="literal">Needle</code> in a file called <code class="literal">Needle.qml</code> (remember that component names and files representing them need to start with a capital letter):</p><div><pre class="programlisting">import QtQuick 2.0

Rectangle {
  id: root

  property int value: 0
  property int granularity: 60
  property alias length: root.height
  width: 2
  height: parent.height/2
  radius: width/2
  antialiasing: true
  anchors.bottom: parent.verticalCenter
  anchors.horizontalCenter: parent.horizontalCenter
  transformOrigin: Item.Bottom
  rotation: 360/granularity * (value % granularity)
}</pre></div><p>
<code class="literal">Needle</code> is basically a rectangle anchored to the center of its parent by its bottom edge, which is also the item's pivot. It also has <code class="literal">value</code> and <code class="literal">granularity</code> properties driving the rotation of the item, where <code class="literal">value</code> is the current value the needle shows and <code class="literal">granularity</code> is the number of different values it can display. Also, anti-aliasing for the needle is enabled as we want the tip of the needle nicely rounded. Having such a definition, we can use the component to declare the three needles inside the clock plate object:</p><div><pre class="programlisting">Needle {
  length: plate.height*0.3
  color: "blue"
  value: clock.hours; granularity: 12
}
Needle {
  length: plate.height*0.4
  color: "darkgreen"
  value: clock.minutes; granularity: 60
}
Needle {
  width: 1
  length: plate.height*0.45
  color: "red"
  value: clock.seconds; granularity: 60
}</pre></div><p>The three needles make use the of <code class="literal">hours</code>, <code class="literal">minutes</code>, and <code class="literal">seconds</code> properties of clock, so these need to be declared, as well:</p><div><pre class="programlisting">property int hours: 0
property int minutes: 0
property int seconds: 0</pre></div><p>By assigning different values to the properties of <code class="literal">Clock</code> in <code class="literal">main.qml</code>, you can make the clock show a different time:</p><div><pre class="programlisting">import QtQuick 2.0

Clock {
  id: clock
  width:  400
  hours: 7
  minutes: 42
  seconds: 17
}</pre></div><p>You'll get an <a id="id728" class="indexterm"/>output as shown:</p><div><img src="img/8874OS_09_18.jpg" alt="Time for action – adding needles to the clock"/></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec192"/>
<em>What just happened?</em>
</h2></div></div></div><p>Most <code class="literal">Needle</code> functionality is declared in the component itself, including geometry and transformations. Then, whenever we want to use the component, we declare an instance of <code class="literal">Needle</code> and optionally customize the <code class="literal">length</code> and <code class="literal">color</code> properties, as well as set its <code class="literal">value</code> and <code class="literal">granularity</code> to obtain the exact functionality we need.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec146"/>Time for action – making the clock functional</h1></div></div></div><p>The final <a id="id729" class="indexterm"/>step in creating a clock is to make it actually show the current time. In JavaScript, we can query the current time using the <code class="literal">Date</code> object:</p><div><pre class="programlisting">var currentDate = new Date()
var hours   = currentDate.getHours()
var minutes = currentDate.getMinutes()
var seconds = currentDate.getSeconds()</pre></div><p>Therefore, the first thing that comes to mind is to use the preceding code to show the current time on the clock:</p><div><pre class="programlisting">Item {
  id: clock
  property int hours:   currentDate.getHours()
  property int minutes: currentDate.getMinutes()
  property int seconds: currentDate.getSeconds()
  property var currentDate: new Date()
  // ...
}</pre></div><p>This will indeed show the current time once you start the application, but the clock will not be updating itself as the time passes. This is because <code class="literal">new Date()</code> returns an object representing one particular moment in time (the date and time at the moment when the object was instantiated). What we need instead is to have the <code class="literal">currentDate</code> property updated with a new object created as the current time changes. To obtain this effect, we can use a <code class="literal">Timer</code> element that is an equivalent of <code class="literal">QTimer</code> in C++ and lets us periodically execute some code. Let's modify the code to use a timer:</p><div><pre class="programlisting">Item {
  id: clock
  property int hours: currentDate.getHours()
  property int minutes: currentDate.getMinutes()
  property int seconds: currentDate.getSeconds()
  readonly property var currentDate: new Date()
  property alias running: timer.running
  Timer {
    id: timer
    repeat: true
    interval: 500
    running: true
    onTriggered: clock.currentDate = new Date()
  }
}</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec193"/>
<em>What just happened?</em>
</h2></div></div></div><p>Based on the interval property, we can determine that the timer emits a <code class="literal">triggered</code> signal every 500 ms, causing <code class="literal">currentDate</code> to be updated with a new <code class="literal">Date</code> object representing the current time. The <a id="id730" class="indexterm"/>clock is also given a <code class="literal">running</code> property (pointing to its equivalent in the timer) that can control whether updates should be enabled. The timer is set to <code class="literal">repeat</code>; otherwise, it would trigger just once.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec194"/>Dynamic objects</h2></div></div></div><p>To briefly sum up what <a id="id731" class="indexterm"/>you have learned so far, we can say that you know how to create hierarchies of objects by declaring their instances and you also know <a id="id732" class="indexterm"/>how to program new types in separate files, making definitions available as components to be instantiated in other QML files. You can even use the <code class="literal">Repeater</code> element to declare a series of objects based on a common stencil.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec195"/>Using components in detail</h2></div></div></div><p>We promised to <a id="id733" class="indexterm"/>give you more information about components and now is the time to do so. You already know the basics of creating components in separate files. Every QML file beginning with a capital letter is treated as a component definition. This definition can be used directly by other QML files residing in the same directory as the component definition. If you need to access a component definition from a file residing elsewhere, you will have to first import the module containing the component in the file where you want to use it. The definition of a module is very simple–it is just a relative path to the directory containing QML files. The path is constructed using dots as the separator. This means that if you have a file named <code class="literal">Baz.qml</code> in a directory called <code class="literal">Base/Foo/Bar</code> and you want to use the <code class="literal">Baz</code> component from within the <code class="literal">Base/Foo/Ham.qml</code> file, you will have to put the following import statement in <code class="literal">Ham.qml</code>:</p><div><pre class="programlisting">import "Bar"</pre></div><p>If you want to use the same component from within the <code class="literal">Base/Spam.qml</code> file, you will have to replace the import statement with:</p><div><pre class="programlisting">import "Foo.Bar"</pre></div><p>Importing a module makes all its components available for use. You can then declare objects of types imported <a id="id734" class="indexterm"/>from a certain module.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec196"/>Creating objects on request</h2></div></div></div><p>The problem with <a id="id735" class="indexterm"/>pre-declaring objects directly in a QML file is that you need to know up front how many objects you are going to need. More often than not, you will want to dynamically add and remove objects to your scene, for example, in an alien invasion game where as the player progresses, new alien saucers will be <a id="id736" class="indexterm"/>entering the game screen and other saucers will be getting shot down and destroyed. Also, the player's ship will be "producing" new bullets streaking in front of the ship, eventually running out of fuel or otherwise disappearing from the game scene. By putting a good amount of effort into the problem, you would be able to use <code class="literal">Repeater</code> to obtain this effect, but there is a better tool at hand.</p><p>QML offers us another element type called <code class="literal">Component</code>, which is another way to teach the engine about a new element type by declaring its contents in QML. There are basically two approaches to doing this.</p><p>The first approach is to declare a <code class="literal">Component</code> element instance in the QML file and inline the definition of the new type directly inside the element:</p><div><pre class="programlisting">Component {
  id: circleComponent
  Item {
    property int diameter: 20
    property alias color: rect.color
    property alias border: rect.border

    implicitWidth: diameter
    implicitHeight: diameter

    Rectangle {
      id: rect  
      width: radius; height: radius; radius: diameter/2
      anchors.centerIn: parent
    }
  }
}</pre></div><p>Such code declares a component called <code class="literal">circleComponent</code> that defines a circle and exposes its <code class="literal">diameter</code>, <code class="literal">color</code>, and <code class="literal">border</code> properties.</p><p>The other approach is to load the component definition from an existing QML file. QML exposes a special global object called <code class="literal">Qt</code>, which provides a set of interesting methods. One of the methods allows the caller to create a component passing the URL of an existing QML document:</p><div><pre class="programlisting">var circleComponent = Qt.createComponent("circle.qml")</pre></div><p>An interesting note is that <code class="literal">createComponent</code> can not only accept a local file path but also a remote URL, and if it understands the network scheme (for example, <code class="literal">http</code>), it will download the document automatically. In this case, you have to remember that it takes time to do that, so the component may not be ready immediately after calling <code class="literal">createComponent</code>. Since the current loading status is kept in the <code class="literal">status</code> property, you can connect to the <a id="id737" class="indexterm"/>
<code class="literal">statusChanged</code> signal to be notified when this happens. A typical code path looks similar to the following:</p><div><pre class="programlisting">var circleComponent = Qt.createComponent("http://example.com/circle.qml")
if(circleComponent.status === Component.Ready) {
  // use the component
} else {
  circleComponent.statusChanged.connect(function() {
    if(circleComponent.status === Component.Ready) {
       // use the component
    }
  })
}</pre></div><p>If the component <a id="id738" class="indexterm"/>definition is incorrect or the document cannot be retrieved, the status of the object will change to <code class="literal">Error</code>. In that case, you can make use of the <code class="literal">errorString()</code> method to see what the actual problem is:</p><div><pre class="programlisting">if(circleComponent.status === Component.Error) {
  console.warn(circleComponent.errorString())
}</pre></div><p>Once you are sure the component is ready, you can finally start creating objects from it. For this, the component exposes a method called <code class="literal">createObject</code>. In its simplest form, it accepts an object that is to become the parent of the newly born instance (similar to widget constructors accepting a pointer to a parent widget) and returns the new object itself so that you can assign it to some variable:</p><div><pre class="programlisting">var circle = circleComponent.createObject(someItem)</pre></div><p>Then, you can start setting the object's properties:</p><div><pre class="programlisting">circle.diameter = 20
circle.color = 'red'</pre></div><p>A more complex invocation lets us do both these operations (create the object and set its properties) in a single call by passing a second parameter to <code class="literal">createObject</code>:</p><div><pre class="programlisting">var circle = circleComponent.createObject(someItem, {diameter: 20, color: 'red'})</pre></div><p>The second parameter is an object (created here using JSON syntax) whose properties are to be applied to the object being created. The advantage of the latter syntax is that all property values are applied to the object as one atomic operation (just like usual when the item is declared in a QML document) instead of a series of separate operations, each of which sets the value for a single property, possibly causing an avalanche of change handler invocations in the object.</p><p>After creation, the <a id="id739" class="indexterm"/>object becomes a first-class citizen of the scene, acting in the same way as items declared directly in the QML document. The only difference is that a dynamically created object can also be dynamically <a id="id740" class="indexterm"/>destructed by calling its <code class="literal">destroy()</code> method, which is an equivalent of calling <code class="literal">delete</code> on C++ objects. When speaking of destroying dynamic items, we have to point out that when you assign a result of <code class="literal">createObject</code> to a variable (like <code class="literal">circle</code>, in our example) and that variable goes out of scope, the item will not be released and garbage collected as its parent still holds a reference to it, preventing it from being recycled.</p><p>We didn't mention this explicitly before, but we have already used inline component definitions earlier in this chapter when we introduced the <code class="literal">Repeater</code> element. The repeated item defined within the repeater is in fact not a real item, but a component definition that is instantiated as many times as needed by the repeater.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec197"/>Delaying item creation</h2></div></div></div><p>Another <a id="id741" class="indexterm"/>recurring scenario is that you do know how many elements you are going to need, but the problem is that you cannot determine up front what type of elements they are going to be. At some point during the lifetime of your application, you will learn that information and will be able to instantiate an object. Until you gain the knowledge about the given component, you will need some kind of item placeholder where you will later put the real item. You can, of course, write some code to use the <code class="literal">createObject()</code> functionality of the component, but this is cumbersome. Fortunately, Qt Quick offers a nicer solution in the form of a <code class="literal">Loader</code> item. This item type is exactly what we described it to be–a temporary placeholder for a real item that will be loaded on demand from an existing component. You can put <code class="literal">Loader</code> in place of another item and when you need to create this item, one way is to set the URL of a component to the <code class="literal">source</code> property:</p><div><pre class="programlisting">Loader {
  id: ldr
}
ldr.source = "MightySword.qml"You could also directly attach a real component to <strong>sourceComponent</strong> of a <strong>Loader</strong>:
Component {
  id: swordComponent
  // ...
}
Loader {
  id: ldr
  sourceComponent: shouldBeLoaded ? swordComponent : undefined
}</pre></div><p>Immediately afterwards, the magic begins and an instance of the component appears in the loader. If the <code class="literal">Loader</code> object has its size set explicitly (for example, by anchoring or setting the width <a id="id742" class="indexterm"/>and height), then the item will be resized to the size of the loader. If an explicit size is not set, then <code class="literal">Loader</code> will instead be resized to the size of the loaded element once the component is instantiated:</p><div><pre class="programlisting">Loader {
  anchors {
    left: parent.left; leftMargin: 0.2*parent.width
    right: parent.right;
    verticalCenter: parent.verticalCenter
  }
  height: 250
  
  source: "Armor.qml"
}</pre></div><p>In the preceding situation, the loader has its size set explicitly so when its item is created, it will respect the anchors and sizes declared here.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec198"/>Accessing your item's component functionality</h2></div></div></div><p>Each <a id="id743" class="indexterm"/>item in Qt Quick is an instantiation of some kind of component. Each object has a <code class="literal">Component</code> attached property that offers two signals informing about important moments of the object's life cycle. The first signal–<code class="literal">completed()</code>—is triggered after the object has been instantiated. If you provide a handler for the signal, you can perform some late initialization of the object after it has been fully instantiated. There are many use cases for this signal, starting with logging a message to the console:</p><div><pre class="programlisting">Rectangle {
  Component.onCompleted: console.log("Rectangle created")
}</pre></div><p>A more advanced use of this signal is to optimize performance by delaying expensive operations until the component is fully constructed:</p><div><pre class="programlisting">Item {
  id: root

  QtObject {
    id: priv
    property bool complete: false

    function layoutItems() {
      if(!complete) return
      // ...
    }
  }
  onChildrenChanged: priv.layoutItems()
  Component.onCompleted: { priv.complete = true; priv.layoutItems(); }
}</pre></div><p>When items <a id="id744" class="indexterm"/>are created, they are added to their parent's <code class="literal">children</code> property. Thus, as items get created and destroyed, the value of that property is modified, triggering the <code class="literal">childrenChanged</code> signal. As this happens, we would like to reposition the item's children according to some algorithm. For that, we have an internal <code class="literal">QtObject</code> instance (representing a <code class="literal">QObject</code>) called <code class="literal">priv</code> where we can declare functions and properties that will not be visible outside the component definition. In there, we have a <code class="literal">layoutItems()</code> function that is called whenever the list of children is updated. This is fine if items are created or destroyed dynamically (for example, using the <code class="literal">Component.createObject()</code> function). However, as the root object is being constructed, it may have a number of child items declared directly in the document. There is no point in repositioning them over and over again as declarations are instantiated. Only when the list of objects is complete does it make sense to position the items. Therefore, we declare a Boolean property in the private object denoting whether the root item is fully constructed. Until it is, every time <code class="literal">layoutItems()</code> is called, it will exit immediately without doing any computations. When <code class="literal">Component.onCompleted</code> is called, we raise the flag and call <code class="literal">layoutItems()</code>, which computes the geometry of all child items declared statically in the document.</p><p>The other signal in the attached <code class="literal">Component</code> property is <code class="literal">destruction</code>. It is triggered right after the destruction process for the object starts when the component is still fully constructed. By handling that signal, you can perform actions such as saving the state of the object in persistent storage or otherwise cleaning the object up.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec199"/>Imperative painting</h2></div></div></div><p>Declaring <a id="id745" class="indexterm"/>graphical items is nice and easy but as programmers, we're more used to writing imperative code, and some things are easier expressed as an algorithm rather than as a description of the final result to be achieved. It is easy to use QML to encode a definition of a primitive shape such as a rectangle in a compact way–all we need is to mark the origin point of the rectangle, its width, height, and optionally, a color. Writing down a declarative definition of a complex shape consisting of many control points positioned in given absolute coordinates, possibly with an outline in some parts of it, maybe accompanied by an image or two, is still possible in language such as QML; however, this will result in a much more verbose and much less readable definition. This is a case where using an imperative approach might prove more effective. HTML (being a declarative language) already exposes a proven imperative interface for drawing different primitives called a <code class="literal">Canvas</code> that has been used in numerous Web applications. Fortunately, Qt Quick provides us with its own implementation of a <code class="literal">Canvas</code> interface similar to the one from the Web by letting us instantiate <code class="literal">Canvas</code> items. Such items can be used to draw straight and curved lines, simple and complex shapes, and graphs and graphic images. It can also add text, colors, shadows, gradients, and patterns. It can even perform low-level pixel operations. Finally, the output may be saved as an image file or serialized to a URL usable as source for an <code class="literal">Image</code> item. There are many tutorials and <a id="id746" class="indexterm"/>papers available out there on using an HTML canvas and they can usually be easily applied to a Qt Quick canvas, as well (the reference manual even includes a list of aspects you need to pay attention to when porting HTML canvas applications to a Qt Quick canvas), so here we will just give you the very basics of imperative drawing in Qt Quick.</p><p>Consider a game where the player's health is measured by the condition of his heart–the slower the beat, the more healthy the player is. We will use this kind of visualization as our exercise in practicing painting using the <code class="literal">Canvas</code> element.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec147"/>Time for action – preparing Canvas for heartbeat visualization</h1></div></div></div><p>Let's start <a id="id747" class="indexterm"/>with simple things by creating a Quick UI project based on the latest version of Qt Quick. Rename the <a id="id748" class="indexterm"/>QML file Creator made for us to <code class="literal">HeartBeat.qml</code>. Open the <code class="literal">qmlproject</code> file that was created with the project and change the <code class="literal">mainFile</code> property of the <code class="literal">Project</code> object to <code class="literal">HeartBeat.qml</code>. Then, you can close the <code class="literal">qmlproject</code> document and return to <code class="literal">HeartBeat.qml</code>. There, you can replace the original content with the following:</p><div><pre class="programlisting">import QtQuick 2.2

Canvas {
  id: canvas

  implicitWidth: 600
  implicitHeight: 300

  onPaint: {
    var ctx = canvas.getContext("2d")
    ctx.clearRect(0, 0, canvas.width, canvas.height)
  }
}</pre></div><p>When you run the project, you will see... a blank window.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec200"/>
<em>What just happened?</em>
</h2></div></div></div><p>In the preceding code, we created a basic boilerplate code for using a canvas. First, we renamed the existing file to what we want our component to be called, and then we informed Creator that this document is to be executed when we run the project using <code class="literal">qmlscene</code>.</p><p>Then, we created a <code class="literal">Canvas</code> instance with an implicit width and height set. There, we created a handler for the <code class="literal">paint</code> signal that is emitted whenever the canvas needs to be redrawn. The <a id="id749" class="indexterm"/>code placed there retrieves a context for the canvas, which can be thought of as an equivalent to the <code class="literal">QPainter</code> instance we used when drawing on Qt widgets. We inform the canvas that we <a id="id750" class="indexterm"/>want its 2D context, which gives us a way to draw in two dimensions. A 2D context is the only context currently present for the <code class="literal">Canvas</code> element, but you still have to identify it explicitly–similar to in HTML. Having the context ready, we tell it to clear the whole area of the canvas. This is different to the widget world in which when the <code class="literal">paintEvent</code> handler was called, the widget was already cleared for us and everything had to be redrawn from scratch. With <code class="literal">Canvas</code>, it is different; the previous content is kept by default so that you can draw over it if you want. Since we want to start with a clean sheet, we call <code class="literal">clearRect()</code> on the context.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec148"/>Time for action – drawing a heartbeat</h1></div></div></div><p>We will <a id="id751" class="indexterm"/>extend our component now and implement its main functionality–drawing a heartbeat-like diagram.</p><p>Add the following property declarations to <code class="literal">canvas</code>:</p><div><pre class="programlisting">property int lineWidth: 2
property var points: []
property real arg: -Math.PI</pre></div><p>Below, add a declaration for a timer that will drive the whole component:</p><div><pre class="programlisting">Timer {
  interval: 10
  repeat: true
  running: true
  onTriggered: {
    arg += Math.PI/180
    while(arg &gt;= Math.PI) arg -= 2*Math.PI
  }
}</pre></div><p>Then, define the handler for when the value of <code class="literal">arg</code> is modified:</p><div><pre class="programlisting">onArgChanged: {
  points.push(func(arg))
  points = points.slice(-canvas.width)
  canvas.requestPaint()
}</pre></div><p>Then, implement <code class="literal">func</code>:</p><div><pre class="programlisting">function func(argument) {
  var a=(2*Math.PI/10); var b=4*Math.PI/5
  return Math.sin(20*argument) * (
      Math.exp(-Math.pow(argument/a, 2)) +
      Math.exp(-Math.pow((argument-b)/a,2)) +
      Math.exp(-Math.pow((argument+b)/a,2))
  )
}</pre></div><p>Finally, modify <a id="id752" class="indexterm"/>
<code class="literal">onPaint</code>:</p><div><pre class="programlisting">onPaint: {
  var ctx = canvas.getContext("2d")
  ctx.reset()
  ctx.clearRect(0, 0, canvas.width, canvas.height)
  var pointsToDraw = points.slice(-canvas.width)
  ctx.translate(0, canvas.height/2)
  ctx.beginPath()
  ctx.moveTo(0, -pointsToDraw[0]*canvas.height/2)
  for(var i=1; i&lt;pointsToDraw.length; i++)
    ctx.lineTo(i, -pointsToDraw[i]*canvas.height/2)
  ctx.lineWidth = canvas.lineWidth
  ctx.stroke()
}</pre></div><p>Then, you can run the code and see a heart beat-like diagram appear on the canvas:</p><div><img src="img/8874OS_09_19.jpg" alt="Time for action – drawing a heartbeat"/></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec201"/>
<em>What just happened?</em>
</h2></div></div></div><p>We added two kinds of properties to the element. By introducing <code class="literal">lineWidth</code>, we can manipulate the width of the line that visualizes the heartbeat. The <code class="literal">points</code> and <code class="literal">arg</code> variables are two helper variables that store an array of points already calculated and the function argument that was last evaluated. The function we are going to use is a periodic function that extends from <code class="literal">-Π</code> to <code class="literal">+Π</code>; thus, we initialize <code class="literal">arg</code> to <code class="literal">-Math.PI</code> and we store an empty array in points.</p><p>Then, we added a timer that ticks in regular intervals, incrementing <code class="literal">arg</code> by 1° until it reaches <code class="literal">+Π</code>, in which case it is reset to the initial value.</p><p>Changes to <code class="literal">arg</code> <a id="id753" class="indexterm"/>are intercepted in the handler we implemented next. In there, we push a new item to the array of points. The value is calculated by the function <code class="literal">func</code>, which is quite complicated, but it is sufficient to say that it returns a value from within a range of <code class="literal">-1</code> to <code class="literal">+1</code>. The array of points is then compacted using <code class="literal">Array.slice()</code> so that at most, the last canvas.width items remain in the array. This is so we can plot one point for each pixel of the width of the canvas and we don't have to store any more data than required. At the end of the function, we invoke <code class="literal">requestPaint()</code>, which is an equivalent of <code class="literal">QWidget::update()</code> and schedules a call to paint.</p><p>That, in turn, calls our <code class="literal">onPaint</code>. There, after retrieving the context, we reset the canvas to its initial state and then calculate an array of points that is to be drawn again by using <code class="literal">slice()</code>. Then, we prepare the canvas by translating and scaling it in the vertical axis so that the origin is moved to half of the height of the canvas (that's the reason for calling <code class="literal">reset()</code> at the beginning of the procedure–to revert this transformation). After that, <code class="literal">beginPath()</code> is called to inform the context that we are starting to build a new path. Then, the path is built segment by segment by appending lines. Each value is multiplied by <code class="literal">canvas.height/2</code> so that values from the point array are scaled to the size of the item. The value is negated as the vertical axis of the canvas grows to the bottom and we want positive values to be above the origin line. After that, we set the width of the pen and draw the path by calling <code class="literal">stroke()</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec149"/>Time for action – making the diagram more colorful</h1></div></div></div><p>The diagram <a id="id754" class="indexterm"/>serves its purpose, but it looks a bit dull. Add some shine to it by defining three new color properties in the canvas object–<code class="literal">color</code>, <code class="literal">topColor</code>, <code class="literal">bottomColor</code>–and setting their default values to <code class="literal">black</code>, <code class="literal">red</code>, and <code class="literal">blue</code>, respectively.</p><p>Since <code class="literal">points</code> and <code class="literal">arg</code> should not really be public properties that anyone can change behind our backs, we'll correct it now. Declare a child element of the canvas of <code class="literal">QtObject</code> and set its ID to <code class="literal">priv</code>. Move declarations of <code class="literal">points</code> and <code class="literal">arg</code> inside that object. Move the <code class="literal">onArgChanged</code> handler there, as well:</p><div><pre class="programlisting">QtObject {
  id: priv
  property var points: []
  property real arg: -Math.PI

  onArgChanged: {
    points.push(func(arg))
    points = points.slice(-canvas.width)
    canvas.requestPaint()
  }
}</pre></div><p>Then, search through the whole code and prefix all occurrences of arg and points outside the newly declared object with <code class="literal">priv</code>, so that each of their invocations lead to the <code class="literal">priv</code> object.</p><p>Then, let's make <a id="id755" class="indexterm"/>use of the three colors we defined by extending <code class="literal">onPaint</code>:</p><div><pre class="programlisting">onPaint: {
    ...
<strong>    // fill:</strong>
<strong>    ctx.beginPath()</strong>
<strong>    ctx.moveTo(0, 0)</strong>
<strong>    var i</strong>
<strong>    for(i=0; i&lt;pointsToDraw.length; i++)</strong>
<strong>        ctx.lineTo(i, -pointsToDraw[i]*canvas.height/2)</strong>
<strong>    ctx.lineTo(i, 0)</strong>
<strong>    var gradient = ctx.createLinearGradient(0, -canvas.height/2, 0, canvas.height/2)</strong>
<strong>    gradient.addColorStop(0.1, canvas.topColor)</strong>
<strong>    gradient.addColorStop(0.5, Qt.rgba(1, 1, 1, 0))</strong>
    gradient.addColorStop(0.9, canvas.bottomColor)
    ctx.fillStyle = gradient
    ctx.fill()

    // stroke:
    ctx.beginPath()
    ctx.moveTo(0, -pointsToDraw[0]*canvas.height/2)
    for(var i=1; i&lt;pointsToDraw.length; i++)
        ctx.lineTo(i, -pointsToDraw[i]*canvas.height/2)
    ctx.lineWidth = canvas.lineWidth
    ctx.strokeStyle = canvas.color
    ctx.stroke()
}</pre></div><p>Upon running the <a id="id756" class="indexterm"/>preceding code snippet, you get the following output:</p><div><img src="img/8874OS_09_20.jpg" alt="Time for action – making the diagram more colorful"/></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec202"/>
<em>What just happened?</em>
</h2></div></div></div><p>By moving the two properties inside the <code class="literal">priv</code> object, we have effectively hidden them from the external world as child objects of an object (such as <code class="literal">priv</code> being a child of <code class="literal">canvas</code>) are not accessible from outside the QML document that defines the object. This ensures that neither <code class="literal">points</code> nor <code class="literal">arg</code> can be modified from outside the <code class="literal">HeartBeat.qml</code> document.</p><p>The modifications to <code class="literal">onPaint</code> that we implemented are creating another path and using that path to fill an area using a gradient. The path is very similar to the original one, but it contains two additional points that are the first and last point drawn projected onto the horizontal axis. This makes sure the gradient fills the area properly. Please note that the canvas uses imperative code for drawing; therefore, the order of drawing the fill and the stroke matters–the fill has to be drawn first so that it doesn't obscure the stroke.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec150"/>Qt Quick and C++</h1></div></div></div><p>Thus far, we have <a id="id757" class="indexterm"/>been using standard Qt Quick items or creating new ones by compositing existing element types in QML. But there is a lot more you can do if you interface QML and C++ using the technologies Qt has to offer. Essentially, QML runtime does not differ much in its design from Qt Script, which you read about in the previous chapter of this book. In the following paragraphs, you will learn how to gain access to objects living in one of the environments from within the other one, as well as how to extend QML with new modules and elements.</p><p>Until now, all the example projects we did in this chapter were written with just QML and because of that, the project type we were choosing was Qt Quick UI, which let us quickly see the Qt Quick scene we modeled by interpreting it with the <code class="literal">qmlscene</code> tool. Now, we will want to add C++ to the equation and since C++ is a compiled language, we will need to do some proper compilation to get things working. Therefore, we will be using the <strong>Qt Quick Application</strong> template.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec203"/>Creating QML objects from C++</h2></div></div></div><p>When you start <a id="id758" class="indexterm"/>a new project of such a type in Qt Creator, after you answer the question about the component set you would like to use (choose any of the Qt Quick 2.<em>x</em> options for a regular Qt Quick application), you will receive some boilerplate code–a <code class="literal">main.cpp</code> file containing the C++ part and <code class="literal">main.qml</code>, which contains the scene definition. Let's have a look at the latter first:</p><div><pre class="programlisting">import QtQuick 2.3
import QtQuick.Window 2.2

Window {
  visible: true
  width: 360
  height: 360
  
  MouseArea {
    anchors.fill: parent
    onClicked: {
      Qt.quit();
    }
  }

  Text {
    text: qsTr("Hello World")
    anchors.centerIn: parent
  }
}</pre></div><p>The code is a little bit different than before; just look at the highlighted parts. Instead of an <code class="literal">Item</code> root object, we now have a Window together with an <code class="literal">import</code> statement for a <code class="literal">QtQuick.Window</code> <a id="id759" class="indexterm"/>module. To understand why this is the case, we will have to understand the C++ code which invokes this QML document:</p><div><pre class="programlisting">#include &lt;QGuiApplication&gt;
#include &lt;QQmlApplicationEngine&gt;

int main(int argc, char *argv[])
{
  QGuiApplication app(argc, argv);

  QQmlApplicationEngine engine;
  engine.load(QUrl(QStringLiteral("qrc:/main.qml")));

  return app.exec();
}</pre></div><p>The source code is pretty simple. First, we instantiate an application object, just like for any other type of application. As we are not using Qt widgets, <code class="literal">QGuiApplication</code> is used instead of <code class="literal">QApplication</code>. The last line of the main function is also obvious–the application's event loop is started. Between those two lines, we can see an instance of <code class="literal">QQmlApplicationEngine</code> being created and fed with the URL of our QML document.</p><p>QML is driven by an engine implemented in <code class="literal">QQmlEngine</code> that is somewhat similar to <code class="literal">QScriptEngine</code>. <code class="literal">QQmlApplicationEngine</code> is a subclass of <code class="literal">QQmlEngine</code>, which provides a simple way of loading an application from a single QML file. This class does not create a root window to display our Qt Quick scene (QML applications don't have to necessarily be Qt Quick applications; they don't have to deal with the user interface at all), so it is the responsibility of the application to create a window if it wants to show a Qt Quick scene in it.</p><p>An alternative fit for loading Qt Quick-based user interfaces would be to use <code class="literal">QQuickView</code> or its less convenient superclass–<code class="literal">QQuickWindow</code>, which inherit <code class="literal">QWindow</code> and are able to render Qt Quick scenes.</p><p>You could then replace the <code class="literal">main.cpp</code> contents with the following code:</p><div><pre class="programlisting">#include &lt;QGuiApplication&gt;
#include &lt;QQuickView&gt;

int main(int argc, char *argv[])
{
  QGuiApplication app(argc, argv);

  QQuickView view;
  view.setSource(QUrl::fromLocalFile(QStringLiteral("main.qml")));
  view.show();

  return app.exec();
}</pre></div><p>Since <code class="literal">QQuickView</code> inherits <code class="literal">QWindow</code>, we can see that a window will be created to encompass the Qt Quick scene defined in <code class="literal">main.qml</code>. In such an event, you could replace the Window declaration with an <code class="literal">Item</code> similar to what we have seen in the earlier examples.</p><div><div><h3 class="title"><a id="tip74"/>Tip</h3><p>If you want to combine a Qt Quick scene with a Qt widgets-based user interface, you can use <code class="literal">QQuickWidget</code> present in the <code class="literal">QtQuickWidgets</code> module (add <code class="literal">QT += quickwidgets</code> to the project file to activate the module), which is similar to <code class="literal">QQuickView</code> and has a similar API, but instead of rendering the scene to a separate window, it renders it to a widget you can then put alongside other widgets.</p></div></div><p>The last way of creating <a id="id760" class="indexterm"/>QML objects is to use <code class="literal">QQmlComponent</code>. Contrary to the previous approaches, which had a <code class="literal">QQmlEngine</code> instance embedded in the object creating the QML object, we have to use a separate engine with the component method.</p><p>
<code class="literal">QQmlComponent</code> is a wrapper around a QML component definition similar to the <code class="literal">Component</code> element on the QML side. It can create instances of that component with the <code class="literal">create()</code> method using a given <code class="literal">QQmlEngine</code> instance:</p><div><pre class="programlisting">QQmlEngine *engine = new QQmlEngine;
QQmlComponent component(engine, QUrl::fromLocalFile(QStringLiteral("main.qml")));
QObject *object = component.create();</pre></div><p>The object created is <code class="literal">QObject</code>, since that is the base class for all objects in QML. If the object represents a Qt Quick user interface, you can cast it to <code class="literal">QQuickItem</code> and use its methods to access Item's functionality:</p><div><pre class="programlisting">QQuickItem *item = qobject_cast&lt;QQuickItem*&gt;(object);
Q_CHECK_PTR(item); // assert to check if qobject_cast returned a valid pointer
item-&gt;setOpacity(0.5);</pre></div><p>
<code class="literal">QQmlComponent</code> is the most "classic" way of instantiating QML objects. You can even use it to create additional objects in existing views:</p><div><pre class="programlisting">QQuickView *view;
// …
QQmlComponent component(view-&gt;engine(), QUrl::fromLocalFile("foobar.qml"));
component.create();</pre></div><p>A variation on using <code class="literal">QQmlComponent</code> is to create an object in the QML engine asynchronously using the <code class="literal">QQmlIncubator</code> object. When creating complex objects, it takes time for them to instantiate and at times, it is desired to not block the control flow for too long by waiting for the operation to complete. In such cases, an incubator object can be used to schedule instantiation and continue the flow of the program. We can query the state of the incubator and when the object is constructed, we will be able to access it. The following code demonstrates how to use the incubator to instantiate an object and process pending events while waiting for the operation to complete:</p><div><pre class="programlisting">QQmlComponent component(engine, QUrl::fromLocalFile("ComplexObject.qml"));
QQmlIncubator incubator;
component.create(incubator);
while(!incubator.isError() &amp;&amp; !incubator.isReady())
  QCoreApplication::processEvents();
QObject *object = incubator.isReady() ? incubator.object() : 0;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec204"/>Pulling QML objects to C++</h2></div></div></div><p>In our terminology, pulling QML objects to C++ means that by using C++ code, we would like to gain <a id="id761" class="indexterm"/>access to objects living in the QML engine (for example, those declared in some QML file). Before we do that, it is important that we stress that in general, it is bad practice to try and pull objects from the QML engine. There are a few reasons for that, but we would like to stress just two of them.</p><p>First, if we assume the most common case, which is that the QML part of our application deals with a user interface in Qt Quick for the logic written in C++, then accessing QtQuick objects from C++ breaks the separation between logic and the presentation layer, which is one of the major principles in GUI programming. The second reason is that QML documents (and Qt Quick ones in particular) are often made by different people (designers) than those who implement the application logic (programmers). The user interface is prone to dynamic changes, relayouting up to a complete revamp. Heavy modifications of QML documents, such as adding or removing items from the design, would then have to be followed by adjusting the application logic to cope with those changes. This in turn needs recompilation of the whole application, which is cumbersome. In addition, if we allow a single application to have multiple user interfaces (skins), it might happen that because they are so different, it is impossible to decide upon a single set of common entities with hardcoded names that could be fetched from C++ and manipulated. Even if you managed to do that, such an application could crash easily if the rules were not strictly followed by designers.</p><p>That said, we have to admit that there are cases when it does make sense to pull objects from QML to C++, and that is why we decided to familiarize you with the way to do it. One of the situations where such an approach is desired is when QML serves us as a way to quickly define a hierarchy of objects with properties of different objects linked through more or less complex expressions, allowing them to answer to changes taking place in the hierarchy.</p><p>For example, if you <a id="id762" class="indexterm"/>create a <code class="literal">Qt Quick UI</code> project, among the files generated, you will find a <code class="literal">qmlproject</code> file containing the project definition expressed in QML itself, such as this one:</p><div><pre class="programlisting">import QmlProject 1.1

Project {
  mainFile: "main.qml"

  importPaths: [ "plugins" ]

  QmlFiles {
    files: [ "Clock.qml", "Needle.qml" ]
  }
  JavaScriptFiles {
    directory: "."
  }
  ImageFiles {
    directory: "."
  	}
}</pre></div><p>It contains project contents specified as a set of file selectors and additional properties such as the main project file or a list of directories of where to look for QML modules. It is very easy to specify such a project description in QML and after doing so and by getting a handle on the <code class="literal">Project</code> instance from C++, one can read the required information directly from the object and its properties as needed.</p><p>
<code class="literal">Project</code> is considered a root object of this document. There are five ways to get access to a root object, based on how the document was actually loaded into the engine:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">QQmlApplicationEngine::rootObjects()</code> if using <code class="literal">QQmlApplicationEngine</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">QQuickView::rootObject()</code> if using <code class="literal">QQuickView</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">QQuickWidget::rootObject()</code> if using <code class="literal">QQuickWidget</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">QQmlComponent::create()</code> if using <code class="literal">QQmlComponent</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">QQmlIncubator::object()</code> if using <code class="literal">QQmlComponent</code> with <code class="literal">QQmlIncubator</code></li></ul></div><p>As we noted earlier, after retrieving an object, you can downcast it to a proper type using <code class="literal">qobject_cast</code>. Alternatively, you can start using the object through the generic <code class="literal">QObject</code> interface–accessing properties with <code class="literal">property()</code> and <code class="literal">setProperty()</code>, running functions through <code class="literal">QMetaObject::invokeMethod()</code>, and connecting to signals as usual.</p><p>The use case provided is a valid and fair situation when you want to pull a view root object or a manually created object from the QML world into C++. Now, we are going to show you how to do the same for an object from an arbitrary depth of the object tree.</p><p>QML documents define object trees. We can ask Qt to traverse a <code class="literal">QObject</code> tree and return a single object or a list of <a id="id763" class="indexterm"/>objects in the tree matching specified criteria. The same approach can be implemented for QML object trees. There are two criteria that can be used when searching. First, we can search for objects inheriting from a given class. Then, we can search for objects matching a given value of the <code class="literal">objectName</code> property defined in <code class="literal">QObject</code>. To search the tree for objects, one uses a <code class="literal">findChild</code> template method.</p><p>Consider a Qt Quick document defining a number of items:</p><div><pre class="programlisting">import QtQuick 2.0

Item {
  width: 400; height: 400
  Rectangle {
    id: rect
    objectName: "redRectangle"
    color: "red"
    anchors.centerIn: parent
    width: height; height: parent.height*2/3
  }
  Rectangle {
    id: circle
    objectName: "blueCircle"
    color: "blue"
    anchors.centerIn: parent
    radius: width/2; width: height; height: parent.height*1/3
  }
}</pre></div><p>After gaining access to the root object using one of the methods described earlier, we can query the object tree for any of the colored shape items using the <code class="literal">objectName</code> values:</p><div><pre class="programlisting">QObject *root = view-&gt;rootObject();
QObject *rect = root-&gt;findChild&lt;QObject*&gt;("redRectangle");
QObject *circle = root-&gt;findChild&lt;QObject*&gt;("blueCircle");
if(circle &amp;&amp; rect)
    circle-&gt;setProperty("width", rect-&gt;property("width").toInt());</pre></div><p>The <code class="literal">findChild()</code> method requires us to pass a class pointer as the template argument. Without knowing what class actually implements a given type, it is safest to simply pass <code class="literal">QObject*</code> as, once again, we know all QML objects inherit this. It is more important what gets passed as the function argument value–it is the name of the object we want returned. Notice it is not <code class="literal">id</code> of the object, but the value of the <code class="literal">objectName</code> property. When the results get assigned to the variables, we verify whether items have been successfully found and if that is the case, the generic <code class="literal">QObject</code> API is used to set the width of the circle to that of the rectangle.</p><p>Let us stress this again: if you <a id="id764" class="indexterm"/>have to use this approach, limit it to the minimum. And always verify whether the returned item exists (is a non-null pointer); the QML document might change between subsequent compilations of the program, and items and their names existing in one version of the document might cease to exist in the next version.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec205"/>Pushing C++ objects to QML</h2></div></div></div><p>A much better approach is <a id="id765" class="indexterm"/>to cross the boundary in the other direction–by exporting objects from C++ to QML. This allows C++ developers to decide what API is available for the script. The choice of which API to use is left to QML developers. Separation between the application logic and the user interface is maintained.</p><p>In the previous chapter, you learned to use Qt Script. We told you how to expose existing <code class="literal">QObject</code> instances to scripting through the use of the script engine's global object. We also discussed execution contexts, which provide layers of object visibility while calling functions. As already mentioned, QML has many similarities to that framework and in QML, a very similar approach is used to expose objects to the engine.</p><p>QML engines also use contexts to provide data scopes for the language. You can set properties on a context to make certain names resolve to given objects:</p><div><pre class="programlisting">QQmlContext *context = new QQmlContext(engine);
QObject *object = new MyObject(...);
context-&gt;setContextProperty("foo", object);</pre></div><p>From this moment, <code class="literal">object</code> is visible within <code class="literal">context</code> under the name <code class="literal">foo</code>.</p><p>Contexts can form hierarchies. On the top of the hierarchy resides a root context of the engine. Context properties are resolved from the bottom up, meaning that redefining a name in a child context shadows the name defined in the parent context. Let's see an example:</p><div><pre class="programlisting">QQmlContext *parentContext = new QQmlContext(engine);
QQmlContext *childContext1 = new QQmlContext(parentContext);
QQmlContext *childContext2 = new QQmlContext(parentContext);
QQmlContext *childContext3 = new QQmlContext(parentContext);
QObject *objectA = new A, *objectB = new B, *object C = new C;
parentContext-&gt;setContextProperty("foo", objectA);
childContext1-&gt;setContextProperty("foo", objectB);
childContext2-&gt;setContextProperty("foo", objectC);</pre></div><p>We created instances of classes <code class="literal">A</code>, <code class="literal">B</code>, and <code class="literal">C</code> and assigned them to a <code class="literal">foo</code> property of different contexts forming a hierarchy of five contexts. Why five? When passing a <code class="literal">QQmlEngine</code> to a constructor of <code class="literal">QQmlContext</code>, the context created becomes a child of the engine's root context. Therefore, we have four contexts we created ourselves and an additional context <a id="id766" class="indexterm"/>that always exists in the engine:</p><div><img src="img/8874OS_09_21.jpg" alt="Pushing C++ objects to QML"/></div><p>Now, if we call foo from within <code class="literal">childContext1</code>, we will access object <code class="literal">B</code>, and when we call <code class="literal">foo</code> from <code class="literal">childContext2</code>, we will access <code class="literal">C</code>. If we call it from <code class="literal">childContext3</code>, then, since <code class="literal">foo</code> is not defined there, the call will propagate to <code class="literal">parentContext</code> and hence <code class="literal">A</code> will be accessed. In <code class="literal">rootContext</code>, the context foo will not be available at all.</p><p>In most cases, we will not be creating contexts ourselves and thus, the most common situation is when we will have control over just the root context since it always exists and is easily accessible. Therefore, this context will usually be used to register C++ objects. As the root engine context is an ancestor of all other contexts, an object registered there will be visible from any QML document.</p><p>So what can we do with an exported object using QML? The object itself is accessible using the identifier given to it with the <code class="literal">setContextProperty()</code>. The identifier can be treated as the ID pseudo-property declared on objects in QML documents. Features that can be accessed from QML depend on the kind of object exported.</p><p>You can export two kinds of object. First, you can export a <code class="literal">QVariant</code> value that is then converted to an equivalent QML entity. The following table lists the most commonly used basic types:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Qt type</p>
</th><th style="text-align: left" valign="bottom">
<p>QML basic type</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bool</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">bool</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">unsigned int, int</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">int</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">double</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">double</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">float, qreal</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">real</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QString</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">string</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QUrl</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">url</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QColor</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">color</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QFont</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">font</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QDate</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">date</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QPoint, QPointF</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">point</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QSize, QSizeF</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">size</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">QRect, QRectF</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">rect</code>
</p>
</td></tr></tbody></table></div><p>It allows us to export a wide range of objects:</p><div><pre class="programlisting">int temperature = 17;
double humidity = 0.648;
QDate today = QDate::currentDate();
engine-&gt;rootContext()-&gt;setContextProperty("temperature", temperature);
engine-&gt;rootContext()-&gt;setContextProperty("humidity", humidity);
engine-&gt;rootContext()-&gt;setContextProperty("today", Qt.formatDate(today, ""));</pre></div><p>And use them easily <a id="id767" class="indexterm"/>in QtQuick:</p><div><pre class="programlisting">import QtQuick 2.0

Rectangle {
  id: root
  width: 400; height: width; radius: width/10
  color: "navy"
  border { width: 2; color: Qt.darker(root.color) }

  Grid {
    id: grid
    anchors.centerIn: parent
    columns: 2; spacing: 5
    Text { color: "white"; font.pixelSize: 20; text: "Temperature:" }
    Text { color: "white"; font.pixelSize: 20; text: temperature+"°C"}
    Text { color: "white"; font.pixelSize: 20; text: "Humidity:" }
    Text { color: "white"; font.pixelSize: 20; text: humidity*100+"%"}
  }
  Text {
    anchors {
      horizontalCenter: grid.horizontalCenter;
      bottom: grid.top; bottomMargin: 5
    }
    font.pixelSize: 24; color: "white"
    text: "Weather for "+Qt.formatDate(today)
  }
}</pre></div><p>This will give us the following output:</p><div><img src="img/8874OS_09_22.jpg" alt="Pushing C++ objects to QML"/></div><p>In addition to the basic types, the QML engine provides automatic type conversions between special <code class="literal">QVariant</code> cases and JavaScript types–<code class="literal">QVariantList</code> is converted to JavaScript array and <code class="literal">QVariantMap</code> to a JavaScript object. This allows for an even more versatile approach. We can group all the weather information within a single JavaScript object by taking advantage of the <code class="literal">QVariantMap</code> conversion:</p><div><pre class="programlisting">QVariantMap weather;
weather["temperature"] = 17;
weather["humidity"] = 0.648;
weather["today"] = QDate::currentDate();
engine-&gt;rootContext()-&gt;setContextProperty("weather", weather);</pre></div><p>As a result, we get better <a id="id768" class="indexterm"/>encapsulation on the QML side:</p><div><pre class="programlisting">Grid {
  // ...
  Text { color: "white"; font.pixelSize: 20; text: "Temperature:" }
  Text { color: "white"; font.pixelSize: 20; text: weather.temperature+"°C" }
  Text { color: "white"; font.pixelSize: 20; text: "Humidity:" }
  Text { color: "white"; font.pixelSize: 20; text: weather.humidity*100+"%"}
}
Text {
  // ...
  text: "Weather for "+Qt.formatDate(weather.today)
}</pre></div><p>That's all fine and dandy in a world where weather conditions never change. In real life, however, one needs a way to handle situations where the data changes. We could, of course, re-export the map every time any of the values changed, but that would be very tedious.</p><p>Fortunately, the second kind of object that can be exported to QML comes to our rescue. Apart from <code class="literal">QVariant</code>, the engine can accept <code class="literal">QObject</code> instances as context property values. When exporting such an instance to QML, all the object's properties are exposed and all its slots become <a id="id769" class="indexterm"/>callable functions in the declarative environment. Handlers are made available for all the object's signals.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec151"/>Time for action – self-updating car dashboard</h1></div></div></div><p>In the next exercise, we <a id="id770" class="indexterm"/>will implement a car dashboard that can be used in a racing game and will show a number of parameters such as current speed and motor revolutions per minute. The final result will look similar to the following image:</p><div><img src="img/8874OS_09_23.jpg" alt="Time for action – self-updating car dashboard"/></div><p>We will start with the C++ part. Set up a new Qt Quick Application. Choose the most recent Qt Quick version for the Qt Quick component set. This will generate a main function for you that instantiates <code class="literal">QGuiApplication</code> and <code class="literal">QQmlApplicationEngine</code> and sets them up to load a QML document.</p><p>Use the <strong>File</strong> menu to create <strong>New file or Project</strong> and create a new C++ class. Call it <code class="literal">CarInfo</code> and choose <code class="literal">QWidget</code> as its base class. Why not <code class="literal">QObject</code>, you may ask? This is because our class will also be a widget, which will be used for modifying values of different parameters so that we may observe how they influence what the Qt Quick scene displays. In the class header, declare the following properties:</p><div><pre class="programlisting">  Q_PROPERTY(int rpm READ rpm NOTIFY rpmChanged)
  Q_PROPERTY(int gear READ gear NOTIFY gearChanged)
  Q_PROPERTY(int speed READ speed NOTIFY speedChanged)
  Q_PROPERTY(QDate today READ today NOTIFY todayChanged)
  Q_PROPERTY(double distance READ distance NOTIFY distanceChanged)</pre></div><p>The properties are <a id="id771" class="indexterm"/>read-only and the <code class="literal">NOTIFY</code> clause defines signals emitted when respective property values change. Go ahead and implement the appropriate functions for each property. Apart from the getter, also implement a setter as a public slot. Here is an example for a property controlling the speed of the car:</p><div><pre class="programlisting">int CarInfo::speed() const { return m_speed; }
void CarInfo::setSpeed(int newSpeed) {
  if(m_speed == newSpeed) return;
  m_speed = newSpeed;
  emit speedChanged(m_speed);
}</pre></div><p>You should be able to follow the example for the remaining properties on your own.</p><p>Since we want to use the widget to tweak property values, design the user interface for it using a Qt Designer Form. It can something look like this:</p><div><img src="img/8874OS_09_24.jpg" alt="Time for action – self-updating car dashboard"/></div><p>Make appropriate signal-slot connections in the widget so that modifying any of the widgets for a given parameter or using the setter slot directly updates all the widgets for that parameter.</p><div><div><h3 class="title"><a id="tip75"/>Tip</h3><p>Instead of adding member variables to the <code class="literal">CarInfo</code> class for properties such as <code class="literal">speed</code>, <code class="literal">rpm</code>, <code class="literal">distance</code>, or <code class="literal">gear</code> you can operate directly on the widgets placed on the <code class="literal">ui</code> form so that, for example, a getter for the <code class="literal">distance</code> property will look like:</p><div><pre class="programlisting">qreal CarInfo::distance() const { return ui-&gt;distanceBox-&gt;value(); }</pre></div><p>The setter would then be modified to:</p><div><pre class="programlisting">void CarInfo::setDistance(qreal newDistance) 
{ ui-&gt;distanceBox-&gt;setValue(newDistance); }</pre></div><p>You will then need to add <code class="literal">connect()</code> statements to the constructor to be sure that signals are propagated from the ui form:</p><div><pre class="programlisting">connect(ui-&gt;distanceBox, SIGNAL(valueChanged(double)), this, SIGNAL(distanceChanged(double)));</pre></div></div></div><p>Next, you can test your work by running the widget. To do this, you have to alter the main function to look as follows:</p><div><pre class="programlisting">int main(int argc, char **argv) {
  QApplication app(argc, argv);
  CarInfo cinfo;
  cinfo.show();
  return app.exec();
};</pre></div><p>Since we are using widgets, we have to replace <code class="literal">QGuiApplication</code> with <code class="literal">QApplication</code> and enable the widgets module <a id="id772" class="indexterm"/>by placing <code class="literal">QT += widgets</code> in the project file (remember to run <code class="literal">qmake</code> from the project's context menu afterwards). Make sure everything works as expected (that is, that moving sliders and changing spinbox values reflect the changes to widget properties) before moving on to the next step.</p><p>We are now going to add <code class="literal">QtQuick</code> to the equation, so let's start by updating our main function to display our scene. Introduce the highlighted changes to the code:</p><div><pre class="programlisting">int main(int argc, char **argv) {
  QApplication app(argc, argv);
  CarInfo cinfo;
  QQuickView view;
<strong>  view.engine()-&gt;rootContext()-&gt;setContextProperty("carData", &amp;cinfo);</strong>
<strong>  view.setSource("qrc:/main.qml");</strong>
  view.show();
  cinfo.show();
  return app.exec();
};</pre></div><p>The modifications create a view for our scene, export the <code class="literal">CarInfo</code> instance to the global context of the QML engine, and load and display the scene from a file located in a resource.</p><p>It is important to first export all the objects and only then load the scene. This is because we want all the names to be already resolvable when the scene is being initialized so that they can be used right away. If we reversed the order of calls, we would get a number of warnings on the console about the identities being undefined.</p><p>Finally, we can focus on the QML part. Look at the picture of the result we want to be shown at the beginning of the exercise. For the black background, we used a bitmap image created in a graphical editor (you can find the file in the materials for this book), but you can obtain a similar effect by composing three black rounded rectangles directly in <code class="literal">QtQuick</code>–the two outer parts are perfect circles and the inner module is a horizontally stretched ellipse.</p><p>If you decide to use our <a id="id773" class="indexterm"/>background file (or make your own prettier image), you can put the following code into <code class="literal">main.qml</code>:</p><div><pre class="programlisting">import QtQuick 2.3

Image {
  source: "dashboard.png"
  Item {
    id: leftContainer
    anchors.centerIn: parent
    anchors.horizontalCenterOffset: -550
    width: 400; height: width
  }
  Item {
    id: middleContainer
    anchors.centerIn: parent
    width: 700; height: width
  }
  Item {
    id: rightContainer
    anchors.centerIn: parent
    anchors.horizontalCenterOffset: 525
    width: 400; height: width
  }
}</pre></div><p>What we do here is make the image our root item and create three items to serve as containers for different elements of the dashboard. The containers are all centered in the parent and we use a <code class="literal">horizontalCenterOffset</code> property to move the two outer items sideways. The values of the offset, as well as the widths, are calculated by trial and error to look good (note that all three containers are perfect squares). If instead of using our file, you settle for creating the three parts yourself using Qt Quick items, the containers will simply be anchored to the centers of the three black items.</p><p>The dials look complicated, but in reality, they are very easy to implement and you have already learned everything you need to design them.</p><p>Let's start with the needle. Create <a id="id774" class="indexterm"/>a new QML document and call it <code class="literal">Needle.qml</code>. Open the file and place the following content:</p><div><pre class="programlisting">import QtQuick 2.0

Item {
  id: root
  property int length: parent.width*0.4
  property color color: "white"
  property color middleColor: "red"
  property int size: 2

  Rectangle {    // needle
    width: root.size
    height: length+20
    color: root.color
    anchors.horizontalCenter: parent.horizontalCenter
    anchors.bottom: parent.bottom
    anchors.bottomMargin: -20
    antialiasing: true
  }
  Rectangle {    // fixing
    anchors.centerIn: parent
    width: 8+root.size; height: width; radius: width/2
    color: root.color
    Rectangle {  // middle dot
      anchors { fill: parent; margins: parent.width*0.25 }
      color: root.middleColor
    }
  }
}</pre></div><p>The document defines an item with four attributes–the length of the needle (defaults to 80% of the dial's radius), the color of the needle, <code class="literal">middleColor</code>, which stands for the color of the needle's fixing, and the size, which defines how wide the needle is. The code is self-explanatory. The item itself does not have any dimensions and onlys acts as an anchor for visual elements–the needle itself is a thin rectangle oriented vertically with a fixing 20 units from the end. The fixing is a circle of the same color as the needle with a smaller circle in the middle that uses a different fill color. The smaller radius of the inner circle is obtained by filling the outer circle with a 25% margin from each side.</p><p>As for the dials, we will put their code inline in the main file since we just have two of them and they differ a bit, so the overhead of creating a separate component with a well-designed set of properties would outweigh the benefits of having nicely encapsulated objects.</p><p>If you think about what needs to be done to have the dial displayed and working, it seems the hardest thing is to layout the numbers nicely on the circle, so let's start with that. Here is an implementation of a <a id="id775" class="indexterm"/>function for calculating the position along a circle circumference, based on the radius of the circle and angle (in degrees) where an item should be positioned:</p><div><pre class="programlisting">function calculatePosition(angle, radius) {
  if( radius === undefined) radius = width/2*0.8
  var a = angle * Math.PI/180 // convert degrees to radians
  var px = width/2 + radius * Math.cos(a)
  var py = width/2 + radius * Math.sin(a)
  return Qt.point(px, py)
}</pre></div><p>The function converts degrees to radians and returns the desired point. The function expects a width property to be available that helps to calculate the center of the circle and in case a radius was not given, serves as a means to calculate a feasible value for it.</p><p>With such a function available, we can use the already familiar <code class="literal">Repeater</code> element to position items where we want them. Let's put the function in <code class="literal">middleContainer</code> and declare the dial for car speed:</p><div><pre class="programlisting">Item {
  id: middleContainer
  // ...
  function calculatePosition(angle, radius) { /* ... */ }
  Repeater {
    model: 24/2
    Item {
      property point pt:
      middleContainer.calculatePosition(120+index*12*2)
      x: pt.x; y: pt.y
      Label {
        anchors.centerIn: parent
        text: index*20
      }
    }
  }
  Needle {
    anchors.centerIn: parent
    length: parent.width*0.35
    size: 4
    rotation: 210+(carData.speed*12/10)
    color: "yellow"
  }
}</pre></div><p>You might have noticed we used an element called <code class="literal">Label</code>. We created it to avoid having to set the same property values for all the texts we use in the user interface:</p><div><pre class="programlisting">import QtQuick 2.0

Text {
  color: "white"
  font.pixelSize: 24
}</pre></div><p>The dial consists of a repeater that will create 12 elements. Each element is an item positioned using the earlier <a id="id776" class="indexterm"/>described function. The item has a label anchored to it that displays the given speed. We use <code class="literal">120+index*12*2</code> as the angle expression as we want "0" to be positioned at 120 degrees and each following item positioned 24 degrees further.</p><p>The needle is given rotation based on the value read from the <code class="literal">carData</code> object. Since the angular distance between consecutive 20 kph labels is 24 degrees, the distance for one kph is 1.2 and thus we multiply <code class="literal">carData.speed</code> by that factor. Item rotation is calculated with 0 degrees "pointing right"; therefore, we add 90 to the initial 120 degree offset of the first label to obtain starting coordinates matching those of the label system.</p><p>As you can see in the image, the speed dial contains small lines every 2 kph, with those divisible by 10 kph longer than others. We can use another <code class="literal">Repeater</code> to declare such ticks:</p><div><pre class="programlisting">Repeater {
  model: 120-4

  Item {
    property point pt: middleContainer.calculatePosition(
      120+index*1.2*2, middleContainer.width*0.35
    )
    x: pt.x; y: pt.y
    Rectangle {
      width: 2
      height: index % 5 ? 5 : 10
        color: "white"
        rotation: 210+index*1.2*2
        anchors.centerIn: parent
        antialiasing: true
    }
  }
}</pre></div><p>Finally, we can put a label for the dial:</p><div><pre class="programlisting">Text {
    anchors.centerIn: parent
    anchors.verticalCenterOffset: 40
    text: "SPEED\n[kph]"
    horizontalAlignment: Text.AlignHCenter
    color: "#aaa"
    font.pixelSize: 16
}</pre></div><p>Make sure the label is declared before the dial needle, or give the needle a higher <em>z</em> value so that the label doesn't overpaint the needle.</p><p>Next, repeat the process on your <a id="id777" class="indexterm"/>own for the left container by creating an RPM dial reading values from <code class="literal">carData.rpm</code>. The dial also displays the current gear of the car's engine. Place the following code inside the <code class="literal">leftContainer</code> object definition:</p><div><pre class="programlisting">Item {
  id: gearContainer
  anchors.centerIn: parent
  anchors.horizontalCenterOffset: 10
  anchors.verticalCenterOffset: -10

  Text {
    id: gear
    property int value: carData.gear
    property var gears: [
<strong>      "R", "N",</strong>
      <strong>"1&lt;sup&gt;st&lt;/sup&gt;", "2&lt;sup&gt;nd&lt;/sup&gt;", "3&lt;sup&gt;rd&lt;/sup&gt;",</strong>
<strong>      "4&lt;sup&gt;th&lt;/sup&gt;", "5&lt;sup&gt;th&lt;/sup&gt;"</strong>
    ]
    text: gears[value+1]
    anchors.left: parent.left
    anchors.bottom: parent.bottom
    color: "yellow"
    font.pixelSize: 32
    textFormat: Text.RichText
  }
}</pre></div><p>The only part needing explanation is highlighted. It defines an array of gear labels starting with reverse, going through neutral, and then through five forward gears. The array is then indexed with the current gear and the text for that value is applied to the label. Notice that the value is incremented by 1, which means the 0th index of the array will be used when <code class="literal">carData.gear</code> is set to <code class="literal">1</code>.</p><p>We will not show how to implement the right container. You can do that easily yourself now with the use of the <code class="literal">Grid</code> positioner to lay out the labels and their values. To display the series of controls on the bottom of the right container (with texts <code class="literal">ABS</code>, <code class="literal">ESP</code>, <code class="literal">BRK</code>, and <code class="literal">CHECK</code>), you can use <code class="literal">Row</code> of <code class="literal">Label</code> instances.</p><p>Now, start the program and begin moving the sliders on the widget. See how the Qt Quick scene follows <a id="id778" class="indexterm"/>the changes.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec206"/>
<em>What just happened?</em>
</h2></div></div></div><p>We have created a very simple <code class="literal">QObject</code> instance and exposed it as our "data model" to QML. The object has a number of properties that can receive different values. Changing a value results in emitting a signal, which in turn notifies the QML engine and causes bindings containing those properties to be reevaluated? As a result, our user interface gets updated.</p><p>The data interface between the QML and C++ worlds that we created is very simple and has a small number of properties. But as the amount of data we want to expose grows, the object can become cluttered. Of course, we can counter that effect by dividing it into multiple smaller objects each having separate responsibilities and then exporting all those objects to QML, but that is not always desirable. In our case, we can see that rpm and gear are properties of the engine sub-system so we could move them to a separate object; however, in reality, their values are tightly coupled with the speed of the car and to calculate the speed, we will need to know the values of those two parameters. But the speed also depends on other factors such as the slope of the road, so putting the speed into the engine sub-system object just doesn't seem right. Fortunately, there is a nice solution for that problem.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec152"/>Time for action – grouping engine properties</h1></div></div></div><p>QML has a concept <a id="id779" class="indexterm"/>called grouped properties. These are properties of an object that contain a group of "sub-properties." You already know a number of them–the border property of the <code class="literal">Rectangle</code> element or the anchors property of the <code class="literal">Item</code> element, for example. Let's see how to define such properties for our exposed object.</p><p>Create a new <code class="literal">QObject</code>-derived class and call it <code class="literal">CarInfoEngine</code>. Move the property definitions of rpm and gear to that new <code class="literal">class.Add</code> the following property declaration to <code class="literal">CarInfo</code>:</p><div><pre class="programlisting">Q_PROPERTY(Object* engine READ engine NOTIFY engineChanged)</pre></div><p>Implement the getter and the private field:</p><div><pre class="programlisting">    QObject* engine() const { return m_engine; }
private:
    CarInfoEngine *m_engine;</pre></div><p>We are not going to use the signal right now; however, we had to declare it otherwise QML would complain we were binding expressions that depend on properties that are non-notifiable:</p><div><pre class="programlisting">signals:
    void engineChanged();</pre></div><p>Initialize <code class="literal">m_engine</code> in the constructor of <code class="literal">CarInfo</code>:</p><div><pre class="programlisting">m_engine = new CarInfoEngine(this);</pre></div><p>Next, update the code of <code class="literal">CarInfo</code> to modify properties of <code class="literal">m_engine</code> whenever respective sliders on the widget are moved. Provide a link the other way, as well–if the property value is changed, update the user interface accordingly.</p><p>Update the QML <a id="id780" class="indexterm"/>document and replace <code class="literal">carData.gear</code> with <code class="literal">carData.engine.gear</code>. Do the same for <code class="literal">carData.rpm</code> and <code class="literal">carData.engine.rpm</code>. You should end up with something along the lines of:</p><div><pre class="programlisting">Item {
  id: leftContainer
  // ...

  Item {
    id: gearContainer
    Text {
      id: gear
      property int value: carData.engine.gear
      // ...
    }
  }
  Needle {
    anchors.centerIn: parent
    length: parent.width*0.35
    rotation: 210+(carInfo.engine.rpm*35)
  }
}</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec207"/>
<em>What just happened?</em>
</h2></div></div></div><p>Essentially, what we did is expose a property in <code class="literal">CarInfo</code> that is itself an object that exposes a set of properties. This object of the type <code class="literal">CarInfoEngine</code> is bound to the <code class="literal">CarInfo</code> instance it refers to.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec153"/>Extending QML</h1></div></div></div><p>Thus far, what we <a id="id781" class="indexterm"/>did was exposing to QML single objects created and initialized in C++. But we can do much more–the framework allows us to define new QML types. These can either be generic <code class="literal">QObject</code> derived QML elements or items specialized for Qt Quick. In this section, you will learn to do both.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec208"/>Registering classes as QML elements</h2></div></div></div><p>We will <a id="id782" class="indexterm"/>start with something simple–exposing the <code class="literal">CarInfo</code> type to QML so that instead of instantiating it in C++ and then exposing it in QML, we can directly declare the element in QML and still allow the changes made to the widget to be reflected in the scene.</p><p>To make a certain class (derived from <code class="literal">QObject</code>) instantiable in QML, all that is required is to register that class with the declarative engine using the <code class="literal">qmlRegisterType</code> template function. This function takes the class as its template parameter along a number of function arguments: the module <code class="literal">uri</code>, the major and minor version numbers, and the name of the QML type we are registering. The following call would register the class <code class="literal">FooClass</code> as the QML type <code class="literal">Foo</code>, available after importing <code class="literal">foo.bar.baz</code> in Version 1.0:</p><div><pre class="programlisting">qmlRegisterType&lt;FooClass&gt;("foo.bar.baz", 1, 0, "Foo");</pre></div><p>You can place this invocation anywhere in your C++ code; just make sure this is before you try to load a QML document that might contain declarations of <code class="literal">Foo</code> objects. A typical place to put the function call is in the program's main function:</p><div><pre class="programlisting">#include &lt;QGuiApplication&gt;
#include &lt;QQuickView&gt;
#include &lt;QtQml&gt;

int main(int argc, char **argv) {
  QGuiApplication app(argc, argv);
  QQuickView view;
  qmlRegisterType&lt;FooClass&gt;("foo.bar.baz", 1, 0, "Foo");
  view.setSource(QUrl("main.qml"));
  view.show();
  return app.exec();
}</pre></div><p>Afterwards, you can start declaring objects of the type <code class="literal">Foo</code> in your documents. Just remember you have to import the respective module first:</p><div><pre class="programlisting">import QtQuick 2.0
import foo.bar.baz 1.0

Item {
<strong>  Foo {</strong>
<strong>    id: foo</strong>
  }
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec154"/>Time for action – making CarInfo instantiable from QML</h1></div></div></div><p>First, we will <a id="id783" class="indexterm"/>update the QML document to create an instance of <code class="literal">CarInfo</code> present in the CarInfo 1.0 module:</p><div><pre class="programlisting">import QtQuick 2.0
import CarInfo 1.0

Image {
  source: "dashboard.png"
  
<strong>  CarInfo {</strong>
<strong>    id: carData</strong>
<strong>    visible: true // make the widget visible</strong>
  }
  // ...
}</pre></div><p>As for registering <code class="literal">CarInfo</code>, it might be tempting to simply call <code class="literal">qmlRegisterType</code> on <code class="literal">CarInfo</code> and congratulate ourselves for a job well done:</p><div><pre class="programlisting">int main(int argc, char **argv) {
  QGuiApplication app(argc, argv);
  QQuickView view;
  qmlRegisterType&lt;CarInfo&gt;("CarInfo", 1, 0, "CarInfo");
  view.setSource(QUrl("qrc://main.qml"));
  view.show();
  return app.exec();
}</pre></div><p>In general this would work (yes, it is as simple as that). However, at the time of writing, trying to instantiate any widget in a QML document as the child of some <code class="literal">QtQuick</code> item will lead to a crash (maybe at the time you are reading this text the issue will have already been resolved). To avoid this, we need to make sure that what we instantiate is not a widget. For that, we will use a proxy object that will forward our calls to the actual widget. Therefore, create a new class called <code class="literal">CarInfoProxy</code> derived from <code class="literal">QObject</code> and make it have the same properties as <code class="literal">CarInfo</code>, for example:</p><div><pre class="programlisting">class CarInfoProxy : public QObject {
  Q_OBJECT
  Q_PROPERTY(QObject *engine READ engine NOTIFY engineChanged)
  Q_PROPERTY(int speed READ speed WRITE setSpeed NOTIFY speedChanged)
  // ...</pre></div><p>Declare one more property that will let us show and hide the widget on demand:</p><div><pre class="programlisting">  Q_PROPERTY(bool visible READ visible WRITE setVisible NOTIFY visibleChanged)</pre></div><p>Then, we can place the widget as a member variable of the proxy so that it is created and destroyed alongside its proxy:</p><div><pre class="programlisting">private:
  CarInfo m_car;</pre></div><p>Next, implement <a id="id784" class="indexterm"/>the missing interface. For simplicity, we are showing you code for some of the properties. The others are similar so you can fill in the gaps on your own:</p><div><pre class="programlisting">public:
  CarInfoProxy(QObject *parent = 0) : QObject(parent) {
    connect(&amp;m_car, SIGNAL(engineChanged()), this, SIGNAL(engineChanged()));
    connect(&amp;m_car, SIGNAL(speedChanged(int)), this, SIGNAL(speedChanged(int)));
  }
  QObject *engine() const { return m_car.engine(); }
  bool visible() const { return m_car.isVisible(); }
  void setVisible(bool v) {
    if(v == visible()) return;
    m_car.setVisible(v);
    emit visibleChanged(v);
  }
  int speed() const { return m_car.speed(); }
  void setSpeed(int v) { m_car.setSpeed(v); }
signals:
  void engineChanged();
  void visibleChanged(bool);
  void speedChanged(int);
};</pre></div><p>You can see that we reuse the <code class="literal">CarInfoEngine</code> instance from the widget instead of duplicating it in the proxy class. Finally, we can register <code class="literal">CarInfoProxy</code> as <code class="literal">CarInfo</code>:</p><div><pre class="programlisting">  qmlRegisterType&lt;CarInfoProxy&gt;("CarInfo", 1, 0, "CarInfo");</pre></div><p>If you run the code now, you will see it works–<code class="literal">CarInfo</code> has become a regular QML element. Because of this, its properties can be set and modified directly in the document, right? If you try setting the speed or the distance, it will work just fine. However, as soon as you try setting any of the properties grouped in the engine property, QML runtime will start complaining with a message similar to the following one:</p><div><pre class="programlisting">
<strong>Cannot assign to non-existent property "gear"</strong>
<strong>             engine.gear: 3</strong>
<strong>                    ^</strong>
</pre></div><p>This is because the runtime does not understand the engine property–we declared it as <code class="literal">QObject</code> and yet we are using a property this class doesn't have. To avoid this issue, we have to teach the runtime about <code class="literal">CarInfoEngine</code>.</p><p>First, let's update the property declaration macro to use <code class="literal">CarInfoEngine</code> instead of <code class="literal">QObject</code>:</p><div><pre class="programlisting">Q_PROPERTY(<strong>CarInfoEngine</strong>* engine READ engine NOTIFY engineChanged)</pre></div><p>And the <a id="id785" class="indexterm"/>getter function itself, as well:</p><div><pre class="programlisting">
<strong>CarInfoEngine</strong>* engine() const { return m_engine; }</pre></div><p>Then, we should teach the runtime about the type:</p><div><pre class="programlisting">QString msg = QStringLiteral("Objects of type CarInfoEngine cannot be created");
qmlRegisterUncreatableType&lt;CarInfoEngine&gt;("CarInfo", 1, 0, "CarInfoEngine", msg);</pre></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec209"/>
<em>What just happened?</em>
</h2></div></div></div><p>In this exercise, we let the QML runtime know about two new elements. One of them is <code class="literal">CarInfo</code>, which is a proxy to our widget class. We told the engine this is a full-featured class that is instantiable from QML. The other class, <code class="literal">CarInfoEngine</code>, also became known to QML; however, the difference is that every attempt to declare an object of this type in QML fails with a given warning message. There are other functions available for registering types in QML but they are rarely used, so we will not be describing them here. If you are curious about them, type in qmlRegister in the Index tab of Creator's <strong>Help</strong> pane.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec210"/>Custom Qt Quick items</h2></div></div></div><p>It is nice to be <a id="id786" class="indexterm"/>able to create new QML element types that can be used to provide dynamic data engines or some other type of non-visual objects; however, this chapter is about Qt Quick so it is time now to learn how to provide new types of items to Qt Quick.</p><p>The first question you should ask yourself is whether you really need a new type of item. Maybe you can achieve the same goal with already existing elements? Very often you can use vector or bitmap images to use custom shapes in your applications, or you can use Canvas to quickly draw the graphics you need directly in QML.</p><p>If you decide that you do require custom items, you will be doing that by implementing subclasses of <code class="literal">QQuickItem</code>, which is the base class for all items in Qt Quick. After creating the new type, you <a id="id787" class="indexterm"/>will always have to register it with QML using <code class="literal">qmlRegisterType</code>.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec49"/>OpenGL items</h3></div></div></div><p>To provide very fast <a id="id788" class="indexterm"/>rendering of its scene, Qt Quick uses a mechanism called scene-graph. The graph consists of a number of nodes of well-known types, each describing a primitive shape to be drawn. The framework makes use of knowledge of each of the primitives allowed and their parameters to find the most performance-wise optimal order in which items can be rendered. Rendering itself is done using OpenGL, and all the shapes are defined in terms of OpenGL calls.</p><p>Providing new items for Qt Quick boils down to delivering a set of nodes that define the shape using terminology the graph understands. This is done by subclassing <code class="literal">QQuickItem</code> and implementing the pure virtual <code class="literal">updatePaintNode()</code> method, which is supposed to return a node that will tell the scene-graph how to render the item. The node will most likely be a describing a geometry (shape) with a material (color, texture) applied.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec155"/>Time for action – creating a regular polygon item</h1></div></div></div><p>Let's learn <a id="id789" class="indexterm"/>about the scene-graph by delivering an item class for rendering convex regular polygons. We will draw the polygon using the OpenGL drawing mode called "triangle fan." It draws a set of triangles that all have a common vertex. Subsequent triangles are defined by the shared vertex, the vertex from the previous triangle, and the next vertex specified. Have a look at the diagram to see how to draw a hexagon as a triangle fan using 8 vertices as control points:</p><div><img src="img/8874OS_09_25.jpg" alt="Time for action – creating a regular polygon item"/></div><p>The same method applies for any regular polygon. The first vertex defined is always the shared vertex occupying the center of the shape. The remaining points are positioned on the circumference of a bounding circle of the shape at equal angular distances. The angle is easily calculated by dividing the full angle by the number of sides. For a hexagon, this yields 60 degrees.</p><p>Let's get down to business and the subclass <code class="literal">QQuickItem</code>. We will give it a very simple interface:</p><div><pre class="programlisting">class RegularPolygon : public QQuickItem {
  Q_OBJECT
  Q_PROPERTY(int sides READ sides WRITE setSides NOTIFY sidesChanged)
  Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged)
public:
  RegularPolygon(QQuickItem *parent = 0);

  int sides() const { return m_sideCount; }
  void setSides (int s);

  QColor color() const { return m_color; }
  void setColor(const QColor &amp;c);

  QSGNode *updatePaintNode(QSGNode *, UpdatePaintNodeData *);

signals:
  void sidesChanged(int);
  void colorChanged(QColor);
private:
  int m_sideCount;
  QColor m_color;
};</pre></div><p>Our polygon is <a id="id790" class="indexterm"/>defined by the number of sides and fill color. We also get everything we inherited from <code class="literal">QQuickItem</code>, including the width and height of the item. Besides the obvious getters and setters for the properties, we define just one method–<code class="literal">updatePaintNode()</code>, which is responsible for building the scene-graph.</p><p>Before we deal with updating graph nodes, let's deal with the easy parts first. Implement the constructor as follows:</p><div><pre class="programlisting">RegularPolygon::RegularPolygon(QQuickItem *parent) : QQuickItem(parent) {
  setFlag(ItemHasContents, true);
  m_sideCount = 6;
}</pre></div><p>We make our polygon a hexagon by default. We also set a flag, <code class="literal">ItemHasContents</code>, which tells the scene-graph that the item is not fully transparent and should ask us how the item should be painted by calling <code class="literal">updatePaintNode()</code>. This is an early optimization to avoid having to prepare the whole infrastructure if the item would not be painting anything anyway.</p><p>The setters are also quite easy to grasp:</p><div><pre class="programlisting">void RegularPolygon::setSides(int s) {
  s = qMax(3, s);
  if(s == sides()) return;
  m_sideCount = v;
  emit sidesChanged(v);
  update();
}

void RegularPolygon::setColor(const QColor &amp;c) {
  if(color() == c) return;
  m_color = c;
  emit colorChanged(c);
  update();
}</pre></div><p>A polygon has to have at least three sides; thus, we enforce this as a minimum, sanitizing the input value with <code class="literal">qMax</code>. After we change any of the properties that might influence the look of the item, we call <code class="literal">update()</code> to let Qt Quick know that the item needs to be rerendered. Let's tackle <code class="literal">updatePaintNode()</code> now. We'll disassemble it into smaller pieces so that it is easier for you to understand how the function works:</p><div><pre class="programlisting">QSGNode *RegularPolygon::updatePaintNode(QSGNode *oldNode, 
                         QQuickItem::UpdatePaintNodeData *) {</pre></div><p>When the function is <a id="id791" class="indexterm"/>called, it might receive a node it returned during a previous call. Be aware the graph is free to delete all the nodes when it feels like it, so you should never rely on the node being there even if you returned a valid node during the previous run of the function:</p><div><pre class="programlisting">  QSGGeometryNode *node = 0;
  QSGGeometry *geometry = 0;
  QSGFlatColorMaterial *material = 0;</pre></div><p>The node we are going to return is a geometry node that contains information about the geometry and the material of the shape being drawn. We will be filling those variables as we go through the method:</p><div><pre class="programlisting">  if (!oldNode) {
    node = new QSGGeometryNode;
    geometry = new QSGGeometry(QSGGeometry::defaultAttributes_Point2D(), m_sideCount+2);
    geometry-&gt;setDrawingMode(GL_TRIANGLE_FAN);
    node-&gt;setGeometry(geometry);
    node-&gt;setFlag(QSGNode::OwnsGeometry);</pre></div><p>As we already mentioned, the function is called with the previously returned node as the argument but we should be prepared for the node not being there and we should create it. Thus, if that is the case, we create a new <code class="literal">QSGGeometryNode</code> and a new <code class="literal">QSGGeometry</code> for it. The geometry constructor takes a so-called attribute set as its parameter, which defines a layout for data in the geometry. Most common layouts have been predefined:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Attribute set</p>
</th><th style="text-align: left" valign="bottom">
<p>Usage</p>
</th><th style="text-align: left" valign="bottom">
<p>First attribute</p>
</th><th style="text-align: left" valign="bottom">
<p>Second attribute</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Point2D</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Solid colored shape</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">float x, y</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">-</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ColoredPoint2D</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Per-vertex color</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">float x, y</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">uchar red, green, blue, alpha</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TexturedPoint2D</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Per-vertex texture coordinate</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">float x, y</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">float tx, float ty</code>
</p>
</td></tr></tbody></table></div><p>We will be defining the geometry in terms of 2D points without any additional information attached to each point; therefore, we pass <code class="literal">QSGGeometry::defaultAttributes_Point2D()</code> to construct the layout we need. As you can see in the preceding table for that layout, each attribute consists of two floating point values denoting the <em>x</em> and <em>y</em> coordinates of a point.</p><p>The second argument of the <code class="literal">QSGGeometry</code> constructor informs us about the number of vertices we will be <a id="id792" class="indexterm"/>using. The constructor will allocate as much memory as is needed to store the required number of vertices using the given attribute layout. After the geometry container is ready, we pass its ownership to the geometry node so that when the geometry node is destroyed, the memory for the geometry is freed as well. At this moment, we also mark that we are going to be rendering in the <code class="literal">GL_TRIANGLE_FAN</code> mode:</p><div><pre class="programlisting">        material = new QSGFlatColorMaterial;
        material-&gt;setColor(m_color);
        node-&gt;setMaterial(material);
        node-&gt;setFlag(QSGNode::OwnsMaterial);</pre></div><p>The process is repeated for the material. We use <code class="literal">QSGFlatColorMaterial</code> as the whole shape is going to have one color that is set from <code class="literal">m_color</code>. Qt provides a number of predefined material types. For example, if we wanted to give each vertex a separate color, we would have used <code class="literal">QSGVertexColorMaterial</code> together with the <code class="literal">ColoredPoint2D</code> attribute layout:</p><div><pre class="programlisting">    } else {
      node = static_cast&lt;QSGGeometryNode *&gt;(oldNode);
      geometry = node-&gt;geometry();
      geometry-&gt;allocate(m_sideCount+2);</pre></div><p>This piece of code deals with a situation in which <code class="literal">oldNode</code> did contain a valid pointer to a node that was already initialized. In this case, we only need to make sure the geometry can hold as many vertices as we need in case the number of sides changed since the last time the function was executed:</p><div><pre class="programlisting">material = static_cast&lt;QSGFlatColorMaterial*&gt;(node-&gt;material());
if(material-&gt;color() != m_color) {
  material-&gt;setColor(m_color);
  node-&gt;markDirty(QSGNode::DirtyMaterial);
}
}</pre></div><p>This is repeated for the material. If the color differs, we reset it and tell the geometry node that the material <a id="id793" class="indexterm"/>needs to be updated by marking the <code class="literal">DirtyMaterial</code> flag:</p><div><pre class="programlisting">  QRectF bounds = boundingRect();
  QSGGeometry::Point2D *vertices = geometry-&gt;vertexDataAsPoint2D();

  // first vertex is the shared one (middle)
  QPointF center = bounds.center();

  vertices[0].set(center.x(), center.y());

  // vertices are distributed along circumference of a circle

  const qreal angleStep = 360.0/m_sideCount;
  const qreal radius = qMin(width(), height())/2;

  for (int i = 0; i &lt; m_sideCount; ++i) {
    qreal rads = angleStep*i*M_PI/180;
    qreal x = center.x()+radius*std::cos(rads);
    qreal y = center.y()+radius*std::sin(rads);
    vertices[1+i].set(x, y);
  }
  vertices[1+m_sideCount] = vertices[1];</pre></div><p>Finally, we can set vertex data. First, we ask the geometry object to prepare a mapping for us from the allocated memory to a <code class="literal">QSGGeometry::Point2D</code> structure, which can be used to conveniently set data for each vertex. Then, actual calculations are performed using the equation for calculating points on a circle. The radius of the circle is taken as the smaller part of the width and height of the item so that the shape is centered in the item. As you can see on the diagram at the beginning of the exercise, the last point in the array has the same coordinates as the second point in the array to close the fan into a regular polygon:</p><div><pre class="programlisting">  node-&gt;markDirty(QSGNode::DirtyGeometry);
  return node;
}</pre></div><p>At the very end, we mark the geometry as changed and return the node to the caller.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec211"/>
<em>What just happened?</em>
</h2></div></div></div><p>Rendering in Qt Quick can happen in a thread different than the main thread. By implementing <code class="literal">updatePaintNode()</code>, we performed synchronization between the GUI thread and the rendering thread. The function executing the main thread is blocked. Due to this reason, it is crucial that it executes as quickly as possible and doesn't do any unnecessary calculations as this directly influences performance. This is also the only place in your code where you can safely call functions from your item (such as reading properties) as well as interact with the scene-graph (creating and updating the nodes). Try not emitting any signals nor creating any objects from within this method as they will have affinity to the rendering thread rather than the GUI thread.</p><p>Having said that, you <a id="id794" class="indexterm"/>can now register your class with QML and test it with the following QML document:</p><div><pre class="programlisting">RegularPolygon {
  id: poly
  vertices: 5
  color: "blue"
}</pre></div><p>This should give you a nice blue pentagon. If the shape looks aliased, you can enforce anti-aliasing on the window:</p><div><pre class="programlisting">int main(int argc, char **argv) {
  QGuiApplication app(argc, argv);
  QQuickView view;
  QSurfaceFormat format = view.format();
<strong>  format.setSamples(16); // enable multisampling</strong>
  view.setFormat(format);
  qmlRegisterType&lt;RegularPolygon&gt;("RegularPolygon", 1, 0, 
                              "RegularPolygon");
  view.setSource(QUrl("qrc://main.qml"));
  view.setResizeMode(QQuickView::SizeRootObjectToView);
  view.show();
  return app.exec();
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec212"/>Have a go hero – creating a supporting border for RegularPolygon</h2></div></div></div><p>What is <a id="id795" class="indexterm"/>returned by <code class="literal">updatePaintNode()</code> might not just be a single <code class="literal">QSGGeometryNode</code> but also a larger tree of <code class="literal">QSGNode</code> items. Each node can have any number of child nodes. By returning a node that has two geometry nodes as children, you can draw two separate shapes in the item:</p><div><img src="img/8874OS_09_26.jpg" alt="Have a go hero – creating a supporting border for RegularPolygon"/></div><p>As a challenge, extend <code class="literal">RegularPolygon</code> to draw not only the internal filled part of the polygon <a id="id796" class="indexterm"/>but also an edge that can be of a different color. You can draw the edge using the <code class="literal">GL_QUAD_STRIP</code> drawing mode. Coordinates of the points are easy to calculate–the points closer to the middle of the shape are the same points that form the shape itself. The remaining points also lie on a circumference of a circle that is slightly larger (by the width of the border). Therefore, you can use the same equations to calculate them. The <code class="literal">GL_QUAD_STRIP</code> mode renders quadrilaterals with every two vertices specified after the first four, composing a connected quadrilateral. The following diagram should give you a clear idea of what we are after:</p><div><img src="img/8874OS_09_27.jpg" alt="Have a go hero – creating a supporting border for RegularPolygon"/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl3sec50"/>Painted items</h2></div></div></div><p>Implementing <a id="id797" class="indexterm"/>items in OpenGL is quite difficult–you need to come up with an algorithm of using OpenGL primitives to draw the shape you want, and then you also need to be skilled enough with OpenGL to build a proper scene graph node tree for your item. But there is another way–you can create items by painting them with <code class="literal">QPainter</code>. This comes at a cost of performance as behind the scenes, the painter draws on an indirect surface (a frame buffer object or an image) that is then converted to OpenGL texture and rendered on a quad by the scene-graph. Even considering that performance hit, it is often much simpler to draw the item using a rich and convenient drawing API than to spend hours doing the equivalent in OpenGL or by using Canvas.</p><p>To use that approach, we will not be subclassing <code class="literal">QQuickItem</code> directly but rather <code class="literal">QQuickPaintedItem</code>, which gives us the infrastructure needed to use the painter for drawing items.</p><p>Basically, all we have <a id="id798" class="indexterm"/>to do, then, is implement the pure virtual <code class="literal">paint()</code> method that renders the item using the received painter. Let's see this put into practice and combine it with the skills we gained earlier.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec156"/>Time for action – creating an item for drawing outlined text</h1></div></div></div><p>The goal of <a id="id799" class="indexterm"/>the current exercise is to be able to make the following QML code work:</p><div><pre class="programlisting">import QtQuick 2.3
import OutlineTextItem 1.0

Rectangle {
  width: 800; height: 400
  OutlineTextItem {
    anchors.centerIn: parent
    text: "This is outlined text"
    fontFamily: "Arial"
    fontPixelSize: 64
    color: "#33ff0000"
    antialiasing: true
    border {
      color: "blue"
      width: 2
      style: Qt.DotLine
    }
  }
}</pre></div><p>And produce the following result:</p><div><img src="img/8874OS_09_28.jpg" alt="Time for action – creating an item for drawing outlined text"/></div><p>Start with an empty Qt project with the <code class="literal">core</code>, <code class="literal">gui</code>, and <code class="literal">quick</code> modules activated. Create a new class and call it <code class="literal">OutlineTextItemBorder</code>. Delete the implementation file as we are going to put all <a id="id800" class="indexterm"/>code into the header file. Place the following code into the class definition:</p><div><pre class="programlisting">class OutlineTextItemBorder : public QObject {
  Q_OBJECT
  Q_PROPERTY(int width MEMBER m_width NOTIFY widthChanged)
  Q_PROPERTY(QColor color MEMBER m_color NOTIFY colorChanged)
  Q_PROPERTY(int style MEMBER m_style NOTIFY styleChanged)
public:
  OutlineTextItemBorder(QObject *parent) : QObject(parent),
    m_width(0), m_color(Qt::transparent), m_style(Qt::SolidLine) {}

  int width() const { return m_width; }
  QColor color() const { return m_color; }
  Qt::PenStyle style() const { return (Qt::PenStyle)m_style; }
  QPen pen() const {
   QPen p;
   p.setColor(m_color);
   p.setWidth(m_width);
   p.setStyle((Qt::PenStyle)m_style);
   return p;
  }
signals:
  void widthChanged(int);
  void colorChanged(QColor);
  void styleChanged(int);
private:
  int m_width;
  QColor m_color;
  int m_style;
};</pre></div><p>You can see that <code class="literal">Q_PROPERTY</code> macros don't have the <code class="literal">READ</code> and <code class="literal">WRITE</code> keywords we've been using thus far. This is because we are taking a shortcut right now and we let <code class="literal">moc</code> produce code that will operate on the property by directly accessing the given class member. Normally, we would recommend against such an approach as without getters, the only way to access the properties is through the generic <code class="literal">property()</code> and <code class="literal">setProperty()</code> calls. However, in this case, we are not going to be exposing this class to the public in C++ so we won't need the setters, and we implement the getters ourselves, anyway. The nice thing about the <code class="literal">MEMBER</code> keyword is that if we also provide the <code class="literal">NOTIFY</code> signal, the generated code will emit that signal when the value of the property changes, which will make property bindings in QML work as expected. The rest of the class is pretty simple–we are, in fact, providing a class for defining a pen that is going to be used for stroking text, so implementing a method that returns the actual pen seems like a good idea.</p><p>The class will <a id="id801" class="indexterm"/>provide a grouped property for our main item class. Create a class called <code class="literal">OutlineTextItem</code> and derive it from <code class="literal">QQuickPaintedItem</code>, as follows:</p><div><pre class="programlisting">class OutlineTextItem : public QQuickPaintedItem {
  Q_OBJECT
  Q_PROPERTY(OutlineTextItemBorder* border READ border NOTIFY borderChanged)
  Q_PROPERTY(QString text MEMBER m_text NOTIFY textChanged)
  Q_PROPERTY(QColor color MEMBER m_color NOTIFY colorChanged)
  Q_PROPERTY(QString fontFamily MEMBER m_ffamily NOTIFY fontFamilyChanged)
  Q_PROPERTY(int fontPixelSize MEMBER m_fsize NOTIFY fontPixelSizeChanged)
public:
  OutlineTextItem(QQuickItem *parent = 0);
  void paint(QPainter *painter);
  OutlineTextItemBorder* border() const { return m_border; }
  QPainterPath shape(const QPainterPath &amp;path) const;
private slots:
  void updateItem();
signals:
  void textChanged(QString);
  void colorChanged(QColor);
  void borderChanged();
  void fontFamilyChanged(QString);
  void fontPixelSizeChanged(int);
private:
  OutlineTextItemBorder* m_border;
  QPainterPath m_path;
  QRectF m_br;
  QString m_text;
  QColor m_color;
  QString m_ffamily;
  int m_fsize;
};</pre></div><p>The interface defines properties for the text to be drawn, in addition to its color, font, and the grouped property for the outline data. Again, we use <code class="literal">MEMBER</code> to avoid having to manually implement getters and setters. Unfortunately, this makes our constructor code more complicated as we still need a way to run some code when any of the properties are modified. Implement the constructor using the following code:</p><div><pre class="programlisting">OutlineTextItem::OutlineTextItem(QQuickItem *parent) : QQuickPaintedItem(parent) {
    m_border = new OutlineTextItemBorder(this);
    connect(this, SIGNAL(textChanged(QString)), SLOT(updateItem()));
connect(this, SIGNAL(colorChanged(QColor)), SLOT(updateItem()));
connect(this, SIGNAL(fontFamilyChanged(QString)), SLOT(updateItem()));
connect(this, SIGNAL(fontPixelSizeChanged(int)), SLOT(updateItem()));
connect(m_border, SIGNAL(widthChanged(int)), SLOT(updateItem()));
connect(m_border, SIGNAL(colorChanged(QColor)), SLOT(updateItem()));
connect(m_border, SIGNAL(styleChanged(int)), SLOT(updateItem()));
updateItem();
}</pre></div><p>We basically connect all the property change signals from both the object and its grouped property object <a id="id802" class="indexterm"/>to the same slot that is going to update the data for the item if any of its components are modified. We also call the same slot directly to prepare the initial state of the item. The slot can be implemented like this:</p><div><pre class="programlisting">void OutlineTextItem::updateItem() {
  QFont font(m_ffamily, m_fsize);
  m_path = QPainterPath();
  m_path.addText(0, 0 , font, m_text);
  m_br = shape(m_path).controlPointRect();
  setImplicitWidth(m_br.width());
  setImplicitHeight(m_br.height());
  update();
}</pre></div><p>At the beginning, the function resets a painter path object that serves as a backend for drawing outlined text and initializes it with the text drawn using the font set. Then, the slot calculates the bounding rect for the path using a function <code class="literal">shape()</code> that we will shortly see. Finally, it sets the calculated size as the size hint for the item and asks the item to repaint itself with the <code class="literal">update()</code> call:</p><div><pre class="programlisting">QPainterPath OutlineTextItem::shape(const QPainterPath &amp;path) const
{
  QPainterPathStroker ps;
  if(m_border-&gt;width() &gt; 0 &amp;&amp; m_border-&gt;style() != Qt::NoPen) {
    ps.setWidth(m_border-&gt;width());
  } else {
    ps.setWidth(0.0000001); // workaround a bug in Qt
  }
  QPainterPath p = ps.createStroke(path);
  p.addPath(path);
  return p;
}</pre></div><p>The <code class="literal">shape()</code> function returns a new painter path that includes both the original path and its outline created with the <code class="literal">QPainterPathStroker</code> object. This is so that the width of the stroke is correctly taken into account when calculating the bounding rectangle. We use <code class="literal">controlPointRect()</code> to calculate the bounding rectangle as it is much faster than <code class="literal">boundingRect()</code> and returns an area greater or equal to the one <code class="literal">boundingRect()</code> would, which is okay for us.</p><p>What remains is to <a id="id803" class="indexterm"/>implement the <code class="literal">paint()</code> routine itself:</p><div><pre class="programlisting">void OutlineTextItem::paint(QPainter *painter) {
  if(m_text.isEmpty()) return;
  painter-&gt;setPen(m_border-&gt;pen());
  painter-&gt;setBrush(m_color);
  painter-&gt;setRenderHint(QPainter::Antialiasing, true);
  painter-&gt;translate(-m_br.topLeft());
  painter-&gt;drawPath(m_path);
}</pre></div><p>The code is really simple–we bail out early if there is nothing to draw. Otherwise, we set up the painter using the pen and color obtained from the item's properties. We enable anti-aliasing and calibrate the painter coordinates with that of the bounding rectangle of the item. Finally, we draw the path on the painter.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec213"/>
<em>What just happened?</em>
</h2></div></div></div><p>During this exercise, we made use of the powerful API of Qt's graphical engine to complement an existing set of Qt Quick items with a simple functionality. This is otherwise very hard to achieve using predefined Qt Quick elements and even harder to implement using OpenGL. We agreed to take a small performance hit in exchange for having to write just about a hundred lines of code to have a fully working solution. Remember to register the class with QML if you want to use it in your code:</p><div><pre class="programlisting">qmlRegisterUncreatableType&lt;OutlineTextItemBorder&gt;(
  "OutlineTextItem", 1, 0, "OutlineTextItemBorder", 
  "Can't create items of OutlineTetItemBorder type"
);
qmlRegisterType&lt;OutlineTextItem&gt;(
  "OutlineTextItem", 1, 0, "OutlineTextItem"
);</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec157"/>Summary</h1></div></div></div><p>In this chapter, you have been familiarized with a declarative language called QML. The language is used to drive Qt Quick–a framework for highly dynamic and interactive content. You learned the basics of Qt Quick–how to create documents with a number of element types and how to create your own in QML or in C++. You also learned how to bind expressions to properties to automatically re-evaluate them. But so far, despite us talking about "fluid" and "dynamic" interfaces, you haven't seen much of that. Do not worry; in the next chapter, we will focus on animations in Qt Quick, as well as fancy graphics and applying what you learned in this chapter for creating nice looking and interesting games. So, read on!</p></div></body></html>