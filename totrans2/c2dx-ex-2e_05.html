<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;On the Line &#x2013; Rocket Through"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. On the Line – Rocket Through</h1></div></div></div><p class="calibre6">
<span class="strong"><em class="calibre8">In our third game, Rocket Through, we'll use particle effects to spice things up a bit, and we'll use DrawNode to make our own OpenGL drawings on screen. And be advised, this game uses quite a bit of vector math, but luckily for us, Cocos2d-x comes bundled with a sweet pack of helper methods to deal with that as well.</em></span>
</p><p class="calibre6">You will learn:</p><div class="book"><ul class="itemizedlist"><li class="listitem">How to load and set up a particle system</li><li class="listitem">How to draw primitives (lines, circles, and more) with <code class="email">DrawNode</code></li><li class="listitem">How to use vector math helper methods included in Cocos2d-x</li></ul></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;On the Line &#x2013; Rocket Through">
<div class="book" title="The game – Rocket Through"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec66" class="calibre1"/>The game – Rocket Through</h1></div></div></div><p class="calibre6">In this <a id="id178" class="calibre1"/>sci-fi version of the classic Snake game engine, you control a rocket ship that must move around seven planets, collecting tiny supernovas. But here's the catch: you can only steer the rocket by rotating it around pivot points put in place through <code class="email">touch</code> events. So the vector of movement we set for the rocket ship is at times linear and at times circular.</p></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;On the Line &#x2013; Rocket Through">
<div class="book" title="The game – Rocket Through">
<div class="book" title="The game settings"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec62" class="calibre1"/>The game settings</h2></div></div></div><p class="calibre6">This is <a id="id179" class="calibre1"/>a universal game designed for the regular iPad and then scaled up and down to match the screen resolution of other devices. It is set to play in portrait mode and it does not support multitouches.</p></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;On the Line &#x2013; Rocket Through">
<div class="book" title="The game – Rocket Through">
<div class="book" title="Play first, work later"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec63" class="calibre1"/>Play first, work later</h2></div></div></div><p class="calibre6">Download<a id="id180" class="calibre1"/> the <code class="email">4198_05_START_PROJECT.zip</code> and <code class="email">4198_05_FINAL_PROJECT.zip</code> files from this book's <span class="strong"><strong class="calibre7">Support</strong></span> page.</p><p class="calibre6">You will, once again, use the <span class="strong"><strong class="calibre7">Start Project</strong></span> option to work on; this way, you won't need to type logic or syntax already covered in previous chapters. The <span class="strong"><strong class="calibre7">Start Project</strong></span> option contains all the <a id="id181" class="calibre1"/>resource files and all the class declarations as well as placeholders for all the methods inside the classes' implementation files. We'll go over these in a moment.</p><p class="calibre6">You should run the final project version to acquaint yourself with the game. By pressing and dragging your finger on the rocket ship, you draw a line. Release the touch and you create a pivot point. The ship will rotate around this pivot point until you press on the ship again to release it. Your aim is to collect the bright supernovas and avoid the planets.</p><div class="mediaobject"><img src="../images/00016.jpeg" alt="Play first, work later" class="calibre9"/></div><p class="calibre10"> </p></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;On the Line &#x2013; Rocket Through">
<div class="book" title="The game – Rocket Through">
<div class="book" title="The start project"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec64" class="calibre1"/>The start project</h2></div></div></div><p class="calibre6">If you<a id="id182" class="calibre1"/> run the <span class="strong"><strong class="calibre7">Start Project</strong></span> option, you should see the basic game screen already in place. There is no need to repeat the steps we've taken in our previous tutorial to create a batch node and place all the screen sprites. We once again have a <code class="email">_gameBatchNode</code> object and a <code class="email">createGameScreen</code> method.</p><p class="calibre6">But by all means, read through the code inside the <code class="email">createGameScreen</code> method. What is of key importance here is that each planet we create is stored inside the <code class="email">_planets</code> vector. And we also create our <code class="email">_rocket</code> object (the <code class="email">Rocket</code> class) and our <code class="email">_lineContainer</code> object (the <code class="email">LineContainer</code> class) here. More on these soon.</p><p class="calibre6">In the <span class="strong"><strong class="calibre7">Start Project</strong></span> option, we also have our old friend <code class="email">GameSprite</code>, which extends <code class="email">Sprite</code> here with an extra method to get the <code class="email">radius()</code> method of our sprites. The <code class="email">Rocket</code> object and <a id="id183" class="calibre1"/>all the planets are <code class="email">GameSprite</code> objects.</p></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;On the Line &#x2013; Rocket Through">
<div class="book" title="The game – Rocket Through">
<div class="book" title="Screen settings"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch05lvl2sec65" class="calibre1"/>Screen settings</h2></div></div></div><p class="calibre6">So if you <a id="id184" class="calibre1"/>have the <span class="strong"><strong class="calibre7">Start Project</strong></span> option opened in Xcode, let's review the screen settings for this game in <code class="email">AppDelegate.cpp</code>. Inside the <code class="email">applicationDidFinishLaunching</code> method, you should see this:</p><div class="informalexample"><pre class="programlisting">auto designSize = Size(1536, 2048);

glview-&gt;setDesignResolutionSize(designSize.width, designSize.height, ResolutionPolicy::EXACT_FIT);

std::vector&lt;std::string&gt; searchPaths;
if (screenSize.width &gt; 768) {
  searchPaths.push_back("ipadhd");
  director-&gt;setContentScaleFactor(1536/designSize.width);
} else if (screenSize.width &gt; 320) {
  searchPaths.push_back("ipad");
  director-&gt;setContentScaleFactor(768/designSize.width);
} else {
  searchPaths.push_back("iphone");
  director-&gt;setContentScaleFactor(380/designSize.width);
}
auto fileUtils = FileUtils::getInstance();
fileUtils-&gt;setSearchPaths(searchPaths);</pre></div><p class="calibre6">So we basically start the same way we did in the previous game. The majority of sprites in this game are circle-shaped and you may notice some distortion in different screens; you should test the same configuration but using different <code class="email">ResolutionPolicies</code>, such as <code class="email">SHOW_ALL</code>.</p></div></div></div>
<div class="book" title="So what are particles?"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec67" class="calibre1"/>So what are particles?</h1></div></div></div><p class="calibre6">Particles or<a id="id185" class="calibre1"/> particle systems are a way to add special effects to your applications. In general terms this is achieved by the use of a large number of tiny textured sprites (particles), which are animated and run through a series of transformations. You can use these systems to create smoke, explosions, sparks, lightening, rain, snow, and other such effects.</p><p class="calibre6">As I mentioned in <a class="calibre1" title="Chapter 1. Installing Cocos2d-x" href="part0016_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre8">Installing Cocos2d-x</em></span>, you should seriously consider getting yourself a program to help you design your particle systems. In this game, the particles were created in ParticleDesigner.</p><p class="calibre6">It's time to add them to our game!</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Time for action &#x2013; creating particle systems"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec68" class="calibre1"/>Time for action – creating particle systems</h1></div></div></div><p class="calibre6">For <a id="id186" class="calibre1"/>particles, all we need is the XML file describing the particle system's properties.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">So let's go to <code class="email">GameLayer.cpp</code>.</li><li class="listitem" value="2">The game initializes by calling <code class="email">createGameScreen</code>, which is already in place, then <code class="email">createParticles</code> and <code class="email">createStarGrid</code>, which is also implemented. So let's go over the <code class="email">createParticles</code> method now.</li><li class="listitem" value="3">Go to that method in <code class="email">GameLayer.cpp</code> and add the following code:<div class="informalexample"><pre class="programlisting">_jet = ParticleSystemQuad::create("jet.plist");
_jet-&gt;setSourcePosition(Vec2(-_rocket-&gt;getRadius() * 0.8f,0));
_jet-&gt;setAngle(180);
_jet-&gt;stopSystem();
this-&gt;addChild(_jet, kBackground);

_boom = ParticleSystemQuad::create("boom.plist");
_boom-&gt;stopSystem();
this-&gt;addChild(_boom, kForeground);

_comet = ParticleSystemQuad::create("comet.plist");
_comet-&gt;stopSystem();
_comet-&gt;setPosition(Vec2(0, _screenSize.height * 0.6f));
_comet-&gt;setVisible(false);
this-&gt;addChild(_comet, kForeground);

_pickup = ParticleSystemQuad::create("plink.plist");
_pickup-&gt;stopSystem();
this-&gt;addChild(_pickup, kMiddleground);

_warp = ParticleSystemQuad::create("warp.plist");
_warp-&gt;setPosition(_rocket-&gt;getPosition());
this-&gt;addChild(_warp, kBackground);

_star = ParticleSystemQuad::create("star.plist");
_star-&gt;stopSystem();
_star-&gt;setVisible(false);
this-&gt;addChild(_star, kBackground, kSpriteStar);</pre></div></li></ol><div class="calibre12"/></div></div>

<div class="book" title="Time for action &#x2013; creating particle systems">
<div class="book" title="What just happened?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec66" class="calibre1"/>
<span class="strong"><em class="calibre8">What just happened?</em></span>
</h2></div></div></div><p class="calibre6">We created our first particles. ParticleDesigner exports the particle system data as a <code class="email">.plist</code> file, which we used to create our <code class="email">ParticleSystemQuad</code> objects. You should open one of these files in Xcode to review the number of settings used in a particle system. From Cocos2d-x you can modify any of these settings through setters inside <code class="email">ParticleSystem</code>.</p><p class="calibre6">The particles<a id="id187" class="calibre1"/> we'll use in this game are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">_jet</code>: This is <a id="id188" class="calibre1"/>attached to the <code class="email">_rocket</code> object and it will trail behind the <code class="email">_rocket</code> object. We set the system's angle and source position parameters to match the <code class="email">_rocket</code> sprite.</li><li class="listitem"><code class="email">_boom</code>: This is the particle system used when <code class="email">_rocket</code> explodes.</li><li class="listitem"><code class="email">_comet</code>: This is a particle system that moves across the screen at set intervals and can collide with <code class="email">_rocket</code>.</li><li class="listitem"><code class="email">_pickup</code>: This is used when a star is collected.</li><li class="listitem"><code class="email">_warp</code>: This marks the initial position of the rocket.</li><li class="listitem"><code class="email">_star</code>: This is the particle system used for the star that the rocket must collect.</li></ul></div><p class="calibre6">The following screenshot shows these various particles:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="What just happened?" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">All particle systems are added as children to <code class="email">GameLayer</code>; they cannot be added to our <code class="email">SpriteBatchNode</code> class. And you must call <code class="email">stopSystem()</code> on each system as they're created otherwise they will start playing as soon as they are added to a node.</p><p class="calibre6">In order to run the system, you make a call to <code class="email">resetSystem()</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note12" class="calibre1"/>Note</h3><p class="calibre6">Cocos2d-x comes bundled with some common particle systems you can modify for your own needs. If you go to the <code class="email">test</code> folder at: <code class="email">tests/cpp-tests/Classes/ParticleTest</code>, you will see examples of these systems being used. The<a id="id189" class="calibre1"/> actual particle data files are found at: <code class="email">tests/cpp-tests/Resources/Particles</code>.</p></div></div></div>
<div class="book" title="Creating the grid"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec69" class="calibre1"/>Creating the grid</h1></div></div></div><p class="calibre6">Let's take <a id="id190" class="calibre1"/>some time now to review the grid logic in the game. This grid is created inside the <code class="email">createStarGrid</code> method in <code class="email">GameLayer.cpp</code>. What the method does is determine all possible spots on the screen where we can place the <code class="email">_star</code> particle system.</p><p class="calibre6">We use a C++ vector list called <code class="email">_grid</code> to store the available spots:</p><div class="informalexample"><pre class="programlisting">std::vector&lt;Point&gt; _grid;</pre></div><p class="calibre6">The <code class="email">createStarGrid</code> method divides the screen into multiple cells of 32 x 32 pixels, ignoring the areas too close to the screen borders (<code class="email">gridFrame</code>). Then we check the distance between each cell and the planet sprites stored inside the vector <code class="email">_planets</code>. If the cell is far enough from the planets, we store it inside the <code class="email">_grid</code> vector as <code class="email">Point</code>.</p><p class="calibre6">In the following figure, you can get an idea of the result we're after. We want all the white cells not overlapping any of the planets.</p><div class="mediaobject"><img src="../images/00018.jpeg" alt="Creating the grid" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">We output a message to the console with <code class="email">Log</code> stating how many cells we end up with:</p><div class="informalexample"><pre class="programlisting">CCLOG("POSSIBLE STARS: %i", _grid.size());</pre></div><p class="calibre6">This <code class="email">vector</code> list will be shuffled at each new game, so we end up with a random sequence of possible positions for our star:</p><div class="informalexample"><pre class="programlisting">std::random_shuffle(_grid.begin(), _grid.end());</pre></div><p class="calibre6">This way we never place a star on top of a planet or so close to it that the rocket could not reach it <a id="id191" class="calibre1"/>without colliding with the planet.</p></div>
<div class="book" title="Drawing primitives in Cocos2d-x"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec70" class="calibre1"/>Drawing primitives in Cocos2d-x</h1></div></div></div><p class="calibre6">One of the<a id="id192" class="calibre1"/> main elements in the game is the <code class="email">LineContainer.cpp</code> class. It is a <code class="email">DrawNode</code> derived class that allows us to draw lines and circles<a id="id193" class="calibre1"/> on the screen.</p><p class="calibre6">
<code class="email">DrawNode</code> comes bundled with a list of drawing methods you can use to draw lines, points, circles, polygons, and so on.</p><p class="calibre6">The methods we'll use are <code class="email">drawLine</code> and <code class="email">drawDot</code>.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Time for action &#x2013; let's do some drawing!"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec71" class="calibre1"/>Time for action – let's do some drawing!</h1></div></div></div><p class="calibre6">Time to implement the drawing inside <code class="email">LineContainer.cpp</code>. You will notice that this class <a id="id194" class="calibre1"/>already has most of its methods implemented, so you can save a little typing. I'll go over what these methods represent once we add the game's main update method. But basically <code class="email">LineContainer</code> will be used to display the lines the player draws on screen to manipulate <code class="email">_rocket</code> sprite, as well as display an energy bar that acts as a sort of timer in our game:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">What we need to change here is the <code class="email">update</code> method. So this is what you need to type inside that method:<div class="informalexample"><pre class="programlisting">_energy -= dt * _energyDecrement;
if (_energy &lt; 0) _energy = 0;
clear();

switch (_lineType) {
  case LINE_NONE:
   break;
  case LINE_TEMP:
   drawLine(_tip, _pivot, Color4F(1.0, 1.0, 1.0, 1.0));
   drawDot(_pivot, 5, Color4F(Color3B::WHITE));
   break;
            
  case LINE_DASHED:
   drawDot(_pivot, 5, Color4F(Color3B::WHITE));
   int segments = _lineLength / (_dash + _dashSpace);
   float t = 0.0f;
   float x_;
   float y_;
            
   for (int i = 0; i &lt; segments + 1; i++) {
      x_ = _pivot.x + t * (_tip.x - _pivot.x);
      y_ = _pivot.y + t * (_tip.y - _pivot.y);
      drawDot(Vec2(x_, y_), 5, Color4F(Color3B::WHITE));
      t += (float) 1 / segments;
   }
   break;
}</pre></div></li><li class="listitem" value="2">We end <a id="id195" class="calibre1"/>our drawing calls by drawing the energy bar in the same <code class="email">LineContainer</code> node:<div class="informalexample"><pre class="programlisting">drawLine(Vec2(_energyLineX, _screenSize.height * 0.1f),  Vec2(_energyLineX, _screenSize.height * 0.9f), Color4F(0.0, 0.0, 0.0, 1.0)); 
drawLine(Vec2(_energyLineX, _screenSize.height * 0.1f),  Vec2(_energyLineX, _screenSize.height * 0.1f + _energy *  _energyHeight ), Color4F(1.0, 0.5, 0.0, 1.0));</pre></div></li></ol><div class="calibre12"/></div></div>

<div class="book" title="Time for action &#x2013; let's do some drawing!">
<div class="book" title="What just happened?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec67" class="calibre1"/>
<span class="strong"><em class="calibre8">What just happened?</em></span>
</h2></div></div></div><p class="calibre6">You just learned how to draw inside <code class="email">DrawNode</code>. One important line in that code is the <code class="email">clear()</code> call. It clears all the drawings in that node before we update them with their new state.</p><p class="calibre6">In <code class="email">LineContainer</code>, we use a <code class="email">switch</code> statement to determine how to draw the player's line. If the <code class="email">_lineType</code> property is set to <code class="email">LINE_NONE</code>, we don't draw anything (this will, in effect, clear the screen of any drawings done by the player).</p><p class="calibre6">If <code class="email">_lineType</code> is <code class="email">LINE_TEMP</code>, this means the player is currently dragging a finger away from the <code class="email">_rocket</code> object, and we want to show a white line from the <code class="email">_rocket</code> current position to the player's current touch position. These points are called <code class="email">tip</code> and <code class="email">pivot</code>, respectively.</p><p class="calibre6">We also draw a dot right on the <code class="email">pivot</code> point.</p><div class="informalexample"><pre class="programlisting">drawLine(_tip, _pivot, Color4F(1.0, 1.0, 1.0, 1.0));
drawDot(_pivot, 5, Color4F(Color3B::WHITE));</pre></div><p class="calibre6">If <code class="email">_lineType</code> is <code class="email">LINE_DASHED</code>, it means the player has removed his or her finger from the screen and set a new pivot point for the <code class="email">_rocket</code> to rotate around. We draw a white dotted line, using what is known as the Bezier linear formula to draw a series of tiny circles from the <code class="email">_rocket</code> current position and the <code class="email">pivot</code> point:</p><div class="informalexample"><pre class="programlisting">for (int i = 0; i &lt; segments + 1; i++) {

    x_ = _pivot.x + t * (_tip.x - _pivot.x);
    y_ = _pivot.y + t * (_tip.y - _pivot.y);

    drawDot(Vec2(x_, y_), 5, Color4F(Color3B::WHITE));
    t += (float) 1 / segments;
}</pre></div><p class="calibre6">And finally, for the energy bar, we draw a black line underneath an orange one. The orange one resizes as the value for <code class="email">_energy</code> in <code class="email">LineContainer</code> is reduced. The black one stays the<a id="id196" class="calibre1"/> same and it's here to show contrast. You layer your drawings through the order of your <code class="email">draw</code> calls; so the first things drawn appear underneath the latter ones.</p></div></div>
<div class="book" title="The rocket sprite"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec72" class="calibre1"/>The rocket sprite</h1></div></div></div><p class="calibre6">Time to<a id="id197" class="calibre1"/> tackle the second object in the game: the rocket.</p><p class="calibre6">Once again, I already put in place the part of the logic that's old news to you. But please review the code already inside <code class="email">Rocket.cpp</code>. We have a method to reset the rocket every time a new game starts (<code class="email">reset</code>), and a method to show the selected state of the rocket (<code class="email">select(bool flag)</code>) by changing its displayed texture:</p><div class="informalexample"><pre class="programlisting">if (flag) {
    this-&gt;setDisplayFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("rocket_on.png"));
} else {
    this-&gt;setDisplayFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName("rocket.png"));
}</pre></div><p class="calibre6">This will either show the rocket with a glow around it, or not.</p><p class="calibre6">And finally a method to check collision with the sides of the screen (<code class="email">collidedWithSides</code>). If there is a collision, we adjust the rocket so it moves away from the screen side it collided with, and we release it from any pivot point.</p><p class="calibre6">What we really need to worry about here is the rocket's <code class="email">update</code> method. And that's what we'll add next.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Time for action &#x2013; updating our rocket sprite"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec73" class="calibre1"/>Time for action – updating our rocket sprite</h1></div></div></div><p class="calibre6">The game's main<a id="id198" class="calibre1"/> loop will call the rocket's <code class="email">update</code> method in every iteration.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Inside the empty <code class="email">update</code> method in <code class="email">Rocket.cpp</code>, add the following lines:<div class="informalexample"><pre class="programlisting">Point position = this-&gt;getPosition();
if (_rotationOrientation == ROTATE_NONE) {
  position.x += _vector.x * dt;
  position.y += _vector.y * dt;
} else {
  float angle = _angularSpeed * dt;
  Point rotatedPoint = position.rotateByAngle(_pivot, angle);
  position.x = rotatedPoint.x;
  position.y = rotatedPoint.y;
  float rotatedAngle;
  
  Point diff = position;
  diff.subtract(_pivot);
  Point clockwise = diff.getRPerp();
  
  if (_rotationOrientation == ROTATE_COUNTER) {
    rotatedAngle = atan2 (-1 * clockwise.y, -1 * clockwise.x);
  } else {
    rotatedAngle = atan2 (clockwise.y, clockwise.x);
  }
         
  _vector.x = _speed * cos (rotatedAngle);
  _vector.y = _speed * sin (rotatedAngle);
  this-&gt;setRotationFromVector();
  
  if (this-&gt;getRotation() &gt; 0) {
    this-&gt;setRotation( fmodf(this-&gt;getRotation(), 360.0f) );
  } else {
    this-&gt;setRotation( fmodf(this-&gt;getRotation(), -360.0f) );
  }
}</pre></div></li><li class="listitem" value="2">Here<a id="id199" class="calibre1"/> we are saying, if the rocket is not rotating <code class="email">(_rotationOrientation == ROTATE_NONE</code>), just move it according to its current <code class="email">_vector</code>. If it is rotating, then use the Cocos2d-x helper <code class="email">rotateByAngle</code> method to find its next position around its pivot point:<div class="mediaobject"><img src="../images/00019.jpeg" alt="Time for action – updating our rocket sprite" class="calibre9"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">The method will rotate any point around a pivot by a certain angle. So we rotate the rocket's updated position around its pivot (determined by the player) using a property of <code class="email">Rocket</code> class called _<code class="email">angularSpeed</code>; we'll see in a moment how it gets calculated.</li><li class="listitem" value="4">Based on whether the rocket is rotating clockwise or counterclockwise, we adjust its rotation so the rocket will be at a 90 degree angle with the line drawn between the rocket and its pivot point. Then we change the rocket's movement vector based on this rotated angle, and we wrap the value of that angle between 0 and 360.</li><li class="listitem" value="5">Finish<a id="id200" class="calibre1"/> up the <code class="email">update</code> method with these lines:<div class="informalexample"><pre class="programlisting">if (_targetRotation &gt; this-&gt;getRotation() + 180) {
  _targetRotation -= 360;
}
if (_targetRotation &lt; this-&gt;getRotation() - 180) {
  _targetRotation += 360;
}

this-&gt;setPosition(position);
_dr = _targetRotation - this-&gt;getRotation() ;
_ar = _dr * _rotationSpring;
_vr += _ar ;
_vr *= _rotationDamping;
float rotationNow = this-&gt;getRotation();
rotationNow += _vr;
this-&gt;setRotation(rotationNow);</pre></div></li><li class="listitem" value="6">With these lines we determine the new target rotation of our sprite and we run an animation to rotate the rocket to its target rotation (with a bit of a spring to it).</li></ol><div class="calibre12"/></div></div>

<div class="book" title="Time for action &#x2013; updating our rocket sprite">
<div class="book" title="What just happened?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec68" class="calibre1"/>
<span class="strong"><em class="calibre8">What just happened?</em></span>
</h2></div></div></div><p class="calibre6">We just wrote the logic that will move the rocket around the screen, whether the rocket is rotating or not.</p><p class="calibre6">So when the player picks a pivot point for the <code class="email">_rocket</code> sprite, this pivot point is passed to both <code class="email">Rocket</code> and <code class="email">LineContainer</code>. The former will use it to rotate its vector around it and the latter will use it to draw a dotted line between <code class="email">_rocket</code> and the <code class="email">pivot</code> point.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre6">We can't use <code class="email">Action</code> to rotate the sprite because the target rotation is updated too many times in our logic, and <code class="email">Action</code> needs time to initialize and run.</p></div><p class="calibre6">So it's time to code the touch events to make all that logic fall into place.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Time for action &#x2013; handling touches"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec74" class="calibre1"/>Time for action – handling touches</h1></div></div></div><p class="calibre6">We need <a id="id201" class="calibre1"/>to implement <code class="email">onTouchBegan</code>, <code class="email">onTouchMoved</code>, and <code class="email">onTouchEnded</code>.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Now in <code class="email">GameLayer.cpp</code>, inside <code class="email">onTouchBegan</code>, add the following lines:<div class="informalexample"><pre class="programlisting">if (!_running) return true;
Point tap = touch-&gt;getLocation();
float dx = _rocket-&gt;getPositionX() - tap.x;
float dy = _rocket-&gt;getPositionY() - tap.y;
if (dx * dx + dy * dy &lt;= pow(_rocket-&gt;getRadius(), 2) ) {
 _lineContainer-&gt;setLineType ( LINE_NONE );
 _rocket-&gt;setRotationOrientation ( ROTATE_NONE );
 _drawing = true;
}

return true;</pre></div><p class="calibre13">When a touch begins, we only need to determine whether it's touching the ship. If it is, we set our <code class="email">_drawing</code> property to <code class="email">true</code>. This will indicate we have a valid point (one that began by touching the <code class="email">_rocket</code> sprite).</p></li><li class="listitem" value="2">We <a id="id202" class="calibre1"/>clear any lines we may be currently drawing in <code class="email">_lineContainer</code> by calling <code class="email">setLineType( LINE_NONE )</code>, and we make sure <code class="email">_rocket</code> will not rotate until we have a pivot point by releasing <code class="email">_rocket (setRotationOrientation ( ROTATE_NONE ))</code>, so it will continue to move on its current linear trajectory <code class="email">(_vector</code>).</li><li class="listitem" value="3">From here, we begin drawing a new line with the next <code class="email">onTouchMoved</code> method. Inside that method, we add the following lines:<div class="informalexample"><pre class="programlisting">if (!_running) return;
  if (_drawing) {
     Point tap = touch-&gt;getLocation();
     float dx = _rocket-&gt;getPositionX() - tap.x;
     float dy = _rocket-&gt;getPositionY() - tap.y;
     if (dx * dx + dy * dy &gt; pow (_minLineLength, 2)) {
       _rocket-&gt;select(true);
       _lineContainer-&gt;setPivot ( tap );
       _lineContainer-&gt;setLineType ( LINE_TEMP );
     } else {
       _rocket-&gt;select(false);
       _lineContainer-&gt;setLineType ( LINE_NONE );
    }
 }</pre></div></li><li class="listitem" value="4">We'll handle touch moved only if we are using <code class="email">_drawing</code>, which means the player has pressed on the ship and is now dragging his or her finger across the screen.<p class="calibre13">Once the distance between the finger and <code class="email">_rocket</code> is greater than the _<code class="email">minLineLength</code> distance we stipulate in game <code class="email">init</code>, then we give a visual cue to the player by adding a glow around <code class="email">_rocket (_rocket-&gt;select(true))</code>, and we draw the new line in <code class="email">_lineContainer</code> by passing it the touch's current position and setting the line type to <code class="email">LINE_TEMP</code>. If the minimum length is not reached, we don't show a line and nor do we show the player selected.</p></li><li class="listitem" value="5">Next comes <code class="email">onTouchEnded</code>. There is logic in place already inside our <code class="email">onTouchEnded</code> method which deals with game states. You should uncomment <a id="id203" class="calibre1"/>the calls to <code class="email">resetGame</code> and add a new <code class="email">else if</code> statement inside the method:<div class="informalexample"><pre class="programlisting">} else if (_state == kGamePaused) {
  _pauseBtn-&gt;setDisplayFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName ("btn_pause_off.png"));
  _paused-&gt;setVisible(false);
  _state = kGamePlay;
  _running = true;
  return;
} </pre></div></li><li class="listitem" value="6">If the game is paused, we change the texture in the <code class="email">_pauseBtn</code> sprite through <code class="email">Sprite-&gt;setDisplayFrame</code>, and we start running the game again.</li><li class="listitem" value="7">Now we begin handling the touch. First, we determine whether it's landing on the <code class="email">Pause</code> button:<div class="informalexample"><pre class="programlisting">if (!_running) return;
if(touch != nullptr) {
  Point tap = touch-&gt;getLocation();
  if (_pauseBtn-&gt;getBoundingBox().containsPoint(tap)) {
    _paused-&gt;setVisible(true);
    _state = kGamePaused;
    _pauseBtn-&gt;setDisplayFrame(SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName ("btn_pause_on.png"));
    _running = false;
    return;
  }
}</pre></div></li><li class="listitem" value="8">If so, we change the game state to <code class="email">kGamePaused</code>, change the texture on the <code class="email">_pauseBtn</code> sprite (by retrieving another sprite frame from <code class="email">SpriteFrameCache</code>), stop running the game (pausing it), and return from the function.</li><li class="listitem" value="9">We can finally do something about the rocket ship. So, continuing inside the same <code class="email">if(touch != nullptr) {</code> conditional seen previously, add these lines:<div class="informalexample"><pre class="programlisting">    _drawing = false;
   _rocket-&gt;select(false);
   if (_lineContainer-&gt;getLineType() == LINE_TEMP) {
      _lineContainer-&gt;setPivot (tap);
      _lineContainer-&gt;setLineLength ( _rocket-&gt;getPosition().distance( tap ) );
      _rocket-&gt;setPivot (tap);</pre></div></li><li class="listitem" value="10">We start by deselecting the <code class="email">_rocket</code> sprite, and then we check whether we are currently showing a temporary line in <code class="email">_lineContainer</code>. If we are, this means we can go ahead and create our new pivot point with the player's released <a id="id204" class="calibre1"/>touch. We pass this information to <code class="email">_lineContainer</code> with our <code class="email">setPivot</code> method, along with the line length. The <code class="email">_rocket</code> sprite also receives the pivot point information.<p class="calibre13">Then, things get hairy! The <code class="email">_rocket</code> sprite is moving at a pixel-based speed. Once <code class="email">_rocket</code> starts rotating, it will move at an angular-based speed through <code class="email">Point.rotateByAngle</code>. So the following lines are added to translate the <code class="email">_rocket</code> current pixel-based speed into angular speed:</p><div class="informalexample"><pre class="programlisting">float circle_length = _lineContainer-&gt;getLineLength() * 2 * M_PI;
int iterations = floor(circle_length / _rocket-&gt;getSpeed());
_rocket-&gt;setAngularSpeed ( 2 * M_PI / iterations);</pre></div></li><li class="listitem" value="11">It grabs the length of the circumference about to be described by <code class="email">_rocket (line length * 2 * PI)</code> and divides it by the rocket's speed, getting in return the number of iterations needed for the rocket to complete that length. Then the 360 degrees of the circle is divided by the same number of iterations (but we do it in radians) to arrive at the fraction of the circle that the rocket must rotate at each iteration: its angular speed.</li><li class="listitem" value="12">What follows next is even more math, using the amazingly helpful methods from Cocos2d-x related to vector math (<code class="email">Point.getRPerp</code>, <code class="email">Point.dot</code>, <code class="email">Point.subtract</code>, to name a few) some of which we've seen already in the <code class="email">Rocket</code> class:<div class="informalexample"><pre class="programlisting">Vec2 diff = _rocket-&gt;getPosition();
diff.subtract(_rocket-&gt;getPivot());
Point clockwise = diff.getRPerp();
float dot =clockwise.dot(_rocket-&gt;getVector());
if (dot &gt; 0) {
   _rocket-&gt;setAngularSpeed ( _rocket-&gt;getAngularSpeed() * -1 );
   _rocket-&gt;setRotationOrientation ( ROTATE_CLOCKWISE );
   _rocket-&gt;setTargetRotation  ( CC_RADIANS_TO_DEGREES( atan2(clockwise.y, clockwise.x) ) );
} else {
   _rocket-&gt;setRotationOrientation ( ROTATE_COUNTER );
   _rocket-&gt;setTargetRotation ( CC_RADIANS_TO_DEGREES  (atan2(-1 * clockwise.y, -1 * clockwise.x) ) );
}
_lineContainer-&gt;setLineType ( LINE_DASHED );</pre></div></li><li class="listitem" value="13">What they do here is determine which direction the rocket should rotate to: clockwise or counterclockwise, based on its current vector of movement.</li><li class="listitem" value="14">The line<a id="id205" class="calibre1"/> the player just drew between <code class="email">_rocket</code> and pivot point, which we get by subtracting (<code class="email">Point.subtract</code>) those two points, has two perpendicular vectors: one to the right (clockwise) that you get through <code class="email">Point.getRPerp</code> and one to the left (counterclockwise) that you get through <code class="email">Point.getPerp</code>. We use the angle of one of these vectors as the <code class="email">_rocket</code> target rotation so the rocket will rotate to be at 90 degrees with the line drawn in <code class="email">LineContainer</code>. And we find the correct perpendicular through the dot product of the <code class="email">_rocket</code> current vector and one of the perpendiculars (<code class="email">Point.dot</code>).</li></ol><div class="calibre12"/></div></div>

<div class="book" title="Time for action &#x2013; handling touches">
<div class="book" title="What just happened?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec69" class="calibre1"/>
<span class="strong"><em class="calibre8">What just happened?</em></span>
</h2></div></div></div><p class="calibre6">I know. A lot of math and all at once! Thankfully, Cocos2d-x made it all much easier to handle.</p><p class="calibre6">We just added the logic that allows the player to draw lines and set new pivot points for the <code class="email">_rocket</code> sprite.</p><p class="calibre6">The player will steer the <code class="email">_rocket</code> sprite through the planets by giving the rocket a pivot point to rotate around. And by releasing the <code class="email">_rocket</code> from pivot points, the player will make it move in a straight line again. All that logic gets managed here in the game's touch events.</p><p class="calibre6">And don't worry about the math. Though understanding how to deal with vectors is a very useful tool in any game developer's toolbox, and you should definitely research the topic, there are countless games you can still build with little or no math; so cheer up!</p></div></div>
<div class="book" title="The game loop"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec75" class="calibre1"/>The game loop</h1></div></div></div><p class="calibre6">It's time to<a id="id206" class="calibre1"/> create our good old ticker! The main loop will be in charge of collision detection, updating the points inside <code class="email">_lineContainer</code>, adjusting our <code class="email">_jet</code> particle system to our <code class="email">_rocket</code> sprite, and a few other things.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Time for action &#x2013; adding the main loop"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec76" class="calibre1"/>Time for action – adding the main loop</h1></div></div></div><p class="calibre6">Let's implement <a id="id207" class="calibre1"/>our main <code class="email">update</code> method.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In <code class="email">GameLayer.cpp</code>, inside the <code class="email">update</code> method, add the following lines:<div class="informalexample"><pre class="programlisting">if (!_running || _state != kGamePlay) return;
if (_lineContainer-&gt;getLineType() != LINE_NONE) {
  _lineContainer-&gt;setTip (_rocket-&gt;getPosition() );
}

if (_rocket-&gt;collidedWithSides()) {
  _lineContainer-&gt;setLineType ( LINE_NONE );
}
_rocket-&gt;update(dt);

//update jet particle so it follows rocket
if (!_jet-&gt;isActive()) _jet-&gt;resetSystem();
_jet-&gt;setRotation(_rocket-&gt;getRotation());
_jet-&gt;setPosition(_rocket-&gt;getPosition());</pre></div><p class="calibre13">We <a id="id208" class="calibre1"/>check to see if we are not currently on pause. Then, if there is a line for our ship that we need to show in <code class="email">_lineContainer</code>, we update the line's <code class="email">tip</code> point with the <code class="email">_rocket</code> current position.</p><p class="calibre13">We run collision checks between <code class="email">_rocket</code> and the screen sides, update the <code class="email">_rocket</code> sprite, and position and rotate our <code class="email">_jet</code> particle system to align it with the <code class="email">_rocket</code> sprite.</p></li><li class="listitem" value="2">Next we update <code class="email">_comet</code> (its countdown, initial position, movement, and collision with <code class="email">_rocket</code> if <code class="email">_comet</code> is visible):<div class="informalexample"><pre class="programlisting">_cometTimer += dt;
float newY;

if (_cometTimer &gt; _cometInterval) {
    _cometTimer = 0;
    if (_comet-&gt;isVisible() == false) {
        _comet-&gt;setPositionX(0);
        newY = (float)rand()/((float)RAND_MAX/_screenSize.height * 0.6f) + _screenSize.height * 0.2f;
        if (newY &gt; _screenSize.height * 0.9f) 
           newY = _screenSize.height * 0.9f;
           _comet-&gt;setPositionY(newY);
           _comet-&gt;setVisible(true);
           _comet-&gt;resetSystem();
    }
}
    
if (_comet-&gt;isVisible()) {
    //collision with comet
    if (pow(_comet-&gt;getPositionX() - _rocket-&gt;getPositionX(), 2) + pow(_comet-&gt;getPositionY() - _rocket-&gt;getPositionY(), 2) &lt;= pow (_rocket-&gt;getRadius() , 2)) {
        if (_rocket-&gt;isVisible()) killPlayer();
    }
    _comet-&gt;setPositionX(_comet-&gt;getPositionX() + 50 * dt);
    
    if (_comet-&gt;getPositionX() &gt; _screenSize.width * 1.5f) {
        _comet-&gt;stopSystem();
        _comet-&gt;setVisible(false);
    }
}</pre></div></li><li class="listitem" value="3">Next <a id="id209" class="calibre1"/>we update <code class="email">_lineContainer</code>, and slowly reduce the opacity of the <code class="email">_rocket</code> sprite based on the <code class="email">_energy</code> level in <code class="email">_lineContainer</code>:<div class="informalexample"><pre class="programlisting">_lineContainer-&gt;update(dt);
_rocket-&gt;setOpacity(_lineContainer-&gt;getEnergy() * 255);</pre></div><p class="calibre13">This will add a visual cue for the player that time is running out as the <code class="email">_rocket</code> sprite will slowly turn invisible.</p></li><li class="listitem" value="4">Run collision with planets:<div class="informalexample"><pre class="programlisting">for (auto planet : _planets) {
    if (pow(planet-&gt;getPositionX() - _rocket-&gt;getPositionX(),  2)
    + pow(planet-&gt;getPositionY() - _rocket-&gt;getPositionY(), 2)  &lt;=   pow (_rocket-&gt;getRadius() * 0.8f + planet-&gt;getRadius()  * 0.65f, 2)) {

        if (_rocket-&gt;isVisible()) killPlayer();
        break;
    }
}</pre></div></li><li class="listitem" value="5">And collision with the star:<div class="informalexample"><pre class="programlisting">if (pow(_star-&gt;getPositionX() - _rocket-&gt;getPositionX(), 2)
    + pow(_star-&gt;getPositionY() - _rocket-&gt;getPositionY(), 2)  &lt;=
    pow (_rocket-&gt;getRadius() * 1.2f, 2)) {

    _pickup-&gt;setPosition(_star-&gt;getPosition());
    _pickup-&gt;resetSystem();
    if (_lineContainer-&gt;getEnergy() + 0.25f &lt; 1) {
        _lineContainer-&gt;setEnergy(_lineContainer-&gt;getEnergy() +  0.25f);
    } else {
        _lineContainer-&gt;setEnergy(1.0);
    }
    _rocket-&gt;setSpeed(_rocket-&gt;getSpeed() + 2);
    if (_rocket-&gt;getSpeed() &gt; 70) _rocket-&gt;setSpeed(70);
        _lineContainer-&gt;setEnergyDecrement(0.0002f);
        SimpleAudioEngine::getInstance()-&gt;playEffect("pickup.wav");
        resetStar();

        int points = 100 - _timeBetweenPickups;
        if (points &lt; 0) points = 0;

        _score += points;
        _scoreDisplay-&gt;setString(String::createWithFormat("%i", _score)-&gt;getCString());
        _timeBetweenPickups = 0;
}</pre></div><p class="calibre13">When we collect <code class="email">_star</code>, we activate the <code class="email">_pickup</code> particle system on the spot where <code class="email">_star</code> was, we fill up the player's energy level, we make the game slightly harder, and we immediately reset <code class="email">_star</code> to its next position to be collected again.</p><p class="calibre13">The score is based on the time it took the player to collect <code class="email">_star</code>.</p></li><li class="listitem" value="6">And we<a id="id210" class="calibre1"/> keep track of this time on the last lines of <code class="email">update</code> where we also check the energy level:<div class="informalexample"><pre class="programlisting">_timeBetweenPickups += dt;
if (_lineContainer-&gt;getEnergy() == 0) {
    if (_rocket-&gt;isVisible()) killPlayer();
}</pre></div></li></ol><div class="calibre12"/></div></div>

<div class="book" title="Time for action &#x2013; adding the main loop">
<div class="book" title="What just happened?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec70" class="calibre1"/>
<span class="strong"><em class="calibre8">What just happened?</em></span>
</h2></div></div></div><p class="calibre6">We added the main loop to our game and finally have all the pieces talking to each other. But you probably noticed quite a few calls to methods we have not implemented yet, such as <code class="email">killPlayer</code> and <code class="email">resetStar</code>. We'll finish our game logic with these methods.</p></div></div>
<div class="book" title="Kill and reset"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec77" class="calibre1"/>Kill and reset</h1></div></div></div><p class="calibre6">It's <a id="id211" class="calibre1"/>that time again! Time to kill our player and reset the game! We also need to move the <code class="email">_star</code> sprite to a new position whenever it's picked up by the player.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Time for action &#x2013; adding our resets and kills"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec78" class="calibre1"/>Time for action – adding our resets and kills</h1></div></div></div><p class="calibre6">We need <a id="id212" class="calibre1"/>to add logic to restart our game and to move our pickup star to a new position. But first, let's kill the player!</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Inside the <code class="email">killPlayer</code> method, add the following lines:<div class="informalexample"><pre class="programlisting">void GameLayer::killPlayer() {

    SimpleAudioEngine::getInstance()-&gt;stopBackgroundMusic();
    SimpleAudioEngine::getInstance()-&gt;stopAllEffects();
    SimpleAudioEngine::getInstance()-&gt;playEffect("shipBoom.wav");
    
    _boom-&gt;setPosition(_rocket-&gt;getPosition());
    _boom-&gt;resetSystem();
    _rocket-&gt;setVisible(false);
    _jet-&gt;stopSystem();
    _lineContainer-&gt;setLineType ( LINE_NONE );
    
    _running = false;
    _state = kGameOver;
    _gameOver-&gt;setVisible(true);
    _pauseBtn-&gt;setVisible(false);
}</pre></div></li><li class="listitem" value="2">Inside <code class="email">resetStar</code>, add<a id="id213" class="calibre1"/> the following lines:<div class="informalexample"><pre class="programlisting">void GameLayer::resetStar() {
    Point position = _grid[_gridIndex];
    _gridIndex++;
    if (_gridIndex == _grid.size()) _gridIndex = 0;
    //reset star particles
    _star-&gt;setPosition(position);
    _star-&gt;setVisible(true);
    _star-&gt;resetSystem();
}</pre></div></li><li class="listitem" value="3">And<a id="id214" class="calibre1"/> finally, our <code class="email">resetGame</code> method:<div class="informalexample"><pre class="programlisting">void GameLayer::resetGame () {

    _rocket-&gt;setPosition(Vec2(_screenSize.width * 0.5f,  _screenSize.height * 0.1f));
    _rocket-&gt;setOpacity(255);
    _rocket-&gt;setVisible(true);
    _rocket-&gt;reset();
    
    _cometInterval = 4;
    _cometTimer = 0;
    _timeBetweenPickups = 0.0;
    
    _score = 0;
    _scoreDisplay-&gt;setString(String::createWithFormat("%i", _score)-&gt;getCString());

    _lineContainer-&gt;reset();
    
    //shuffle grid cells

    std::random_shuffle(_grid.begin(), _grid.end());
    _gridIndex = 0;
    
    resetStar();
    
    _warp-&gt;stopSystem();
    
    _running = true;
    
    SimpleAudioEngine::getInstance()-&gt;playBackgroundMusic("background.mp3", true);
    SimpleAudioEngine::getInstance()-&gt;stopAllEffects();
    SimpleAudioEngine::getInstance()-&gt;playEffect("rocket.wav", true);
    
}</pre></div></li></ol><div class="calibre12"/></div></div>

<div class="book" title="Time for action &#x2013; adding our resets and kills">
<div class="book" title="What just happened?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec71" class="calibre1"/>
<span class="strong"><em class="calibre8">What just happened?</em></span>
</h2></div></div></div><p class="calibre6">That's it. We're <a id="id215" class="calibre1"/>done. It took more math than most people are comfortable <a id="id216" class="calibre1"/>with. But what can I tell you, I just love messing around with vectors!</p><p class="calibre6">Now, let's move on to Android!</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Time for action &#x2013; running the game in Android"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec79" class="calibre1"/>Time for action – running the game in Android</h1></div></div></div><p class="calibre6">Follow<a id="id217" class="calibre1"/> these steps to deploy the game to Android:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open the manifest file and set the <code class="email">app</code> orientation to <code class="email">portrait</code>.</li><li class="listitem" value="2">Next, open the <code class="email">Android.mk</code> file in a text editor.</li><li class="listitem" value="3">Edit the lines in <code class="email">LOCAL_SRC_FILES</code> to read:<div class="informalexample"><pre class="programlisting">LOCAL_SRC_FILES := hellocpp/main.cpp \
                   ../../Classes/AppDelegate.cpp \
                   ../../Classes/GameSprite.cpp \
                   ../../Classes/LineContainer.cpp \
                   ../../Classes/Rocket.cpp \
                   ../../Classes/GameLayer.cpp  </pre></div></li><li class="listitem" value="4">Import the game into Eclipse and build it.</li><li class="listitem" value="5">Save and run your application. This time, you can try out different size screens if you have the devices.</li></ol><div class="calibre12"/></div></div>

<div class="book" title="Time for action &#x2013; running the game in Android">
<div class="book" title="What just happened?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec72" class="calibre1"/>
<span class="strong"><em class="calibre8">What just happened?</em></span>
</h2></div></div></div><p class="calibre6">You now have Rocket Through running in Android.</p></div></div>

<div class="book" title="Time for action &#x2013; running the game in Android">
<div class="book" title="Have a go hero"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec73" class="calibre1"/>Have a go hero</h2></div></div></div><p class="calibre6">Add logic to the <code class="email">resetStar</code> method so that the new position picked is not too close to the <code class="email">_rocket</code> sprite. So, make the function a recurrent one until a proper position is picked.</p><p class="calibre6">And <a id="id218" class="calibre1"/>take the <code class="email">warp</code> particle system, which right now does not do a whole lot, and use it as a random teleport field so that the rocket may get sucked in by a randomly placed warp and moved farther away from the target star.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec80" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">Congratulations! You now have enough information about Cocos2d-x to produce awesome 2D games. First sprites, then actions, and now particles.</p><p class="calibre6">Particles make everything look shiny! They are easy to implement and are a very good way to add an extra bit of animation to your game. But it's very easy to overdo it, so be careful. You don't want to give your players epileptic fits. Also, running too many particles at once could stop your game in its tracks.</p><p class="calibre6">In the next chapter, we'll see how to use Cocos2d-x to quickly test and develop game ideas.</p></div></body></html>