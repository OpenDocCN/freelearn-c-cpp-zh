<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Multithreading</h1></div></div></div><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating an execution thread</li><li class="listitem" style="list-style-type: disc">Syncing access to a common resource</li><li class="listitem" style="list-style-type: disc">Fast access to a common resource using atomics</li><li class="listitem" style="list-style-type: disc">Creating a work_queue class</li><li class="listitem" style="list-style-type: disc">Multiple-readers-single-writer lock</li><li class="listitem" style="list-style-type: disc">Creating variables that are unique per thread</li><li class="listitem" style="list-style-type: disc">Interrupting a thread</li><li class="listitem" style="list-style-type: disc">Manipulating a group of threads</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Introduction</h1></div></div></div><p>In this chapter we'll take care of threads and all of the stuff connected with them. Basic knowledge of multithreading is encouraged.</p><p><strong>Multithreading</strong> <a id="id277" class="indexterm"/>means that multiple execution threads exist within a single process. Threads may share process resources and have their own resources. Those execution threads may run independently on different CPUs, leading to faster and more responsive programs.</p><p>The <code class="literal">Boost.Thread</code> library provides uniformity across operating system interfaces for working with threads. It is not a header-only library, so all of the examples from this chapter will need to link against the <code class="literal">libboost_thread</code> and <code class="literal">libboost_system</code> libraries.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Creating an execution thread</h1></div></div></div><p>On modern multi-core compilers, to <a id="id278" class="indexterm"/>achieve maximal performance (or just to provide a good <a id="id279" class="indexterm"/>user experience), programs usually must use multiple execution threads. Here is a motivating example in which we need to create and fill a big file in a thread that draws the user interface:</p><div><pre class="programlisting">#include &lt;algorithm&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;

void set_not_first_run();
bool is_first_run();

// Function, that executes for a long time
void fill_file_with_data(char fill_char, std::size_t size, const char* filename){
  std::ofstream ofs(filename);
  std::fill_n(std::ostreambuf_iterator&lt;char&gt;(ofs), size, fill_char);
  set_not_first_run();
}

// ...
// Somewhere in thread that draws a user interface
if (is_first_run()) {
  // This will be executing for a long time during which
  // users interface will freeze..
  fill_file_with_data(0, 8 * 1024 * 1024, "save_file.txt");
}</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec184"/>Getting ready</h2></div></div></div><p>This recipe will <a id="id280" class="indexterm"/>require <a id="id281" class="indexterm"/>knowledge of the <code class="literal">boost::bind</code> library.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec185"/>How to do it...</h2></div></div></div><p>Starting an execution thread was never so easy:</p><div><pre class="programlisting">#include &lt;boost/thread.hpp&gt;

// ...
// Somewhere in thread that draws a user interface
if (is_first_run()) {
  boost::thread(boost::bind(
      &amp;fill_file_with_data,
      0,
      8 * 1024 * 1024,
      "save_file.txt"
  )).detach();
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec186"/>How it works...</h2></div></div></div><p>The <code class="literal">boost::thread</code> variable <a id="id282" class="indexterm"/>accepts a functional object that can be called without parameters (we provided one using <code class="literal">boost::bind</code>) and creates a separate execution thread. That functional object will be <a id="id283" class="indexterm"/>copied into a constructed execution thread and will <a id="id284" class="indexterm"/>be run there.</p><div><img src="img/4880OS_05_01.jpg" alt="How it works..."/></div><div><div><h3 class="title"><a id="note13"/>Note</h3><p>In all of the recipes with the <code class="literal">Boost.Thread</code> library, we'll be using Version 4 (defined <code class="literal">BOOST_THREAD_VERSION to 4</code>) of threads by default and pointing out some important differences between <code class="literal">Boost.Thread</code> versions.</p></div></div><p>After that, we call the <code class="literal">detach()</code> <a id="id285" class="indexterm"/>function, which will do the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The execution thread will be detached from the <code class="literal">boost::thread</code> variable but will continue its execution</li><li class="listitem" style="list-style-type: disc">The <code class="literal">boost::thread</code> variable <a id="id286" class="indexterm"/>will hold a <code class="literal">Not-A-Thread</code> state</li></ul></div><p>Note that without a call to <code class="literal">detach()</code>, the destructor of <code class="literal">boost::thread</code> will notice that it still holds a thread and will call <code class="literal">std::terminate</code>, which will terminate our program.</p><p>Default constructed threads will also have a <a id="id287" class="indexterm"/>
<code class="literal">Not-A-Thread</code> state, and they won't create a separate execution thread.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec187"/>There's more...</h2></div></div></div><p>What if we want to make sure that a file was created and written before doing some other job? In that case we need to join a <a id="id288" class="indexterm"/>thread <a id="id289" class="indexterm"/>using the following:</p><div><pre class="programlisting">// ...
// Somewhere in thread that draws a user interface
if (is_first_run()) {
  boost::thread t(boost::bind(
      &amp;fill_file_with_data,
      0,
      8 * 1024 * 1024,
      "save_file.txt"
  ));
  // Do some work
  // ...
  // Waiting for thread to finish
  t.join();
}</pre></div><p>After the thread is joined, the <code class="literal">boost::thread</code> variable will hold a <code class="literal">Not-A-Thread</code> state and its destructor won't call <code class="literal">std::terminate</code>.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>Remember that the thread must be joined or detached before its destructor is called. Otherwise, your program will terminate!</p><p>Beware that <code class="literal">std::terminate()</code> is called when any exception that is not of type <code class="literal">boost::thread_interrupted</code> leaves the boundary of the functional object and is passed to the <code class="literal">boost::thread</code> constructor.</p></div></div><p>The <code class="literal">boost::thread</code> class was <a id="id290" class="indexterm"/>accepted as a part of the C++11 standard and you can find it in <a id="id291" class="indexterm"/>the <code class="literal">&lt;thread&gt;</code> header in the <code class="literal">std::</code> namespace. By default, with <code class="literal">BOOST_THREAD_VERSION=2</code>, the destructor of <code class="literal">boost::thread</code> will call <code class="literal">detach()</code>, <a id="id292" class="indexterm"/>which won't lead to <code class="literal">std::terminate</code>. But doing so will break compatibility with <code class="literal">std::thread</code>, and some day, when your project is moving to the C++ standard library threads or when <code class="literal">BOOST_THREAD_VERSION=2</code> is no longer supported this will give you a lot of surprises. Version 4 of <code class="literal">Boost.Thread</code> is more explicit and strong, which is usually preferable in C++ language.</p><p>There is a very helpful wrapper that works as a RAII wrapper around the thread and allows you to emulate the <code class="literal">BOOST_THREAD_VERSION=2</code> behavior; it is called <code class="literal">boost::scoped_thread&lt;T&gt;</code>, where <code class="literal">T</code> can be one of the following classes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">boost::interrupt_and_join_if_joinable</code>: To <a id="id293" class="indexterm"/>interrupt and join thread at destruction</li><li class="listitem" style="list-style-type: disc"><code class="literal">boost::join_if_joinable</code>: To <a id="id294" class="indexterm"/>join a thread at destruction</li><li class="listitem" style="list-style-type: disc"><code class="literal">boost::detach</code>: To detach a <a id="id295" class="indexterm"/>thread at destruction</li></ul></div><p>Here is a small <a id="id296" class="indexterm"/>example:</p><div><pre class="programlisting">#include &lt;boost/thread/scoped_thread.hpp&gt;
void some_func();
void example_with_raii() {
  boost::scoped_thread&lt;boost::join_if_joinable&gt; t(
    (boost::thread(&amp;some_func))
  );
  // 't' will be joined at scope exit
}</pre></div><div><div><h3 class="title"><a id="note15"/>Note</h3><p>We added additional parentheses around <code class="literal">(boost::thread(&amp;some_func))</code> so that the compiler won't interpret it as a function declaration instead of a variable construction.</p></div></div><p>There is no big difference between the <a id="id297" class="indexterm"/>Boost and C++11 STL versions of the <code class="literal">thread</code> class; however, <code class="literal">boost::thread</code> is available on the C++03 compilers, so its usage is more versatile.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec188"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All of the recipes in this chapter will be using <code class="literal">Boost.Thread</code>; you may continue reading to get more information about them</li><li class="listitem" style="list-style-type: disc">The official documentation has a full list of the <code class="literal">boost::thread</code> methods and remarks about their availability in the <a id="id298" class="indexterm"/>C++11 STL implementation; it can be found at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html">http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html</a></li><li class="listitem" style="list-style-type: disc">The <em>Interrupting a thread</em> recipe will give you an idea of what the <code class="literal">boost::interrupt_and_join_if</code><code class="literal">_joinable</code> class does</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Syncing access to a common resource</h1></div></div></div><p>Now that we know how to start <a id="id299" class="indexterm"/>execution threads, we want to have access to <a id="id300" class="indexterm"/>some common resources from different threads:</p><div><pre class="programlisting">#include &lt;cassert&gt;
#include &lt;cstddef&gt;

// In previous recipe we included
// &lt;boost/thread.hpp&gt;, which includes all
// the classes of Boost.Thread
#include &lt;boost/thread/thread.hpp&gt;

int shared_i = 0;

void do_inc() {
  for (std::size_t i = 0; i &lt; 30000; ++i) {
    // do some work
    // ...

    const int i_snapshot = ++ shared_i;

    // do some work with i_snapshot
    // ...
  }
}

void do_dec() {
  for (std::size_t i = 0; i &lt; 30000; ++i) {
    // do some work
    // ...

    const int i_snapshot = -- shared_i;

    // do some work with i_snapshot
    // ...
  }
}

void run() {
  boost::thread t1(&amp;do_inc);
  boost::thread t2(&amp;do_dec);

  t1.join();
  t2.join();

  // assert(shared_i == 0); // Oops!
  std::cout &lt;&lt; "shared_i == " &lt;&lt; shared_i;
}</pre></div><p>This <code class="literal">'Oops!'</code> is not written there accidentally. For some people it will be a surprise, but there is a big chance that <code class="literal">shared_i</code> won't be <a id="id301" class="indexterm"/>equal to 0:</p><div><pre class="programlisting">shared_i == 19567</pre></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Modern compilers and processors have a huge number of different, tricky optimizations that can break the preceding code. We won't discuss them here, but there is a useful link in the <em>See also</em> section to a document that briefly describes them.</p></div></div><p>And it will get even worse in <a id="id302" class="indexterm"/>cases when a common resource has some non-trivial classes; segmentation faults and memory leaks may (and will) occur.</p><p>We need to change the code so that only one thread modifies the <code class="literal">shared_i</code> variable at a single moment of time and so that all of the processor and compiler optimizations that inflict multithreaded code are bypassed.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec189"/>Getting ready</h2></div></div></div><p>Basic knowledge of threads is recommended for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec190"/>How to do it...</h2></div></div></div><p>Let's see how we can fix the previous example and make <code class="literal">shared_i</code> equal at the end of the run:</p><div><ol class="orderedlist arabic"><li class="listitem">First of all we'll need to create a mutex:<div><pre class="programlisting">#include &lt;boost/thread/mutex.hpp&gt;
#include &lt;boost/thread/locks.hpp&gt;

int shared_i = 0;
boost::mutex i_mutex;</pre></div></li><li class="listitem">Put all the operations that modify or get data from the <code class="literal">shared_i</code> variable between the following:<div><pre class="programlisting">{ // Critical section begin
  boost::lock_guard&lt;boost::mutex&gt; lock(i_mutex);</pre></div><p>And the following:</p><div><pre class="programlisting">} // Critical section end</pre></div></li></ol></div><p>This is what it will look like:</p><div><pre class="programlisting">void do_inc() {
  for (std::size_t i = 0; i &lt; 30000; ++i) {

    // do some work
    // …

    int i_snapshot;
    { // Critical section begin
      boost::lock_guard&lt;boost::mutex&gt; lock(i_mutex);
      i_snapshot = ++ shared_i;
    } // Critical section end

    // do some work with i_snapshot
    // ...
  }
}

void do_dec() {
  for (std::size_t i = 0; i &lt; 30000; ++i) {
    // do some work
    // ...

    int i_snapshot;
    { // Critical section begin
      boost::lock_guard&lt;boost::mutex&gt; lock(i_mutex);
      i_snapshot = -- shared_i;
    } // Critical section end

    // do some work with i_snapshot
    // ...
  }
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec191"/>How it works...</h2></div></div></div><p>The <code class="literal">boost::mutex</code> class <a id="id303" class="indexterm"/>takes care of all of the synchronization stuff. When a thread tries to lock it via the <code class="literal">boost::lock_guard&lt;boost::mutex&gt;</code> variable and there is no other thread holding a lock, it will successfully acquire unique access to the section of code until the lock is unlocked or destroyed. If <a id="id304" class="indexterm"/>some other thread already holds a lock, the thread that tried to acquire the lock will wait until another thread unlocks the lock. All the locking/unlocking operations imply specific instructions so that the changes made in a <strong>critical section</strong> <a id="id305" class="indexterm"/>will be visible to all threads. Also, you no longer need to <em>make sure that modified values of resources are visible to all cores and are not just modified in the processor's register</em> and <em>force the processor and compiler to not reorder the instructions</em>.</p><p>The <code class="literal">boost::lock_guard</code> class is a <a id="id306" class="indexterm"/>very simple RAII class that stores a reference to the mutex and calls <code class="literal">lock()</code> in the single-parameter constructor and <code class="literal">unlock()</code> in the destructor. Note the curly bracket usage in the preceding example; the <code class="literal">lock</code> variable is constructed inside them so that, on reaching the <code class="literal">critical section</code> closing bracket, the destructor for the <code class="literal">lock</code> variable will be <a id="id307" class="indexterm"/>called and the mutex will be unlocked. Even if some exception occurs in the critical section, the mutex will be correctly unlocked.</p><div><img src="img/4880OS_05_02.jpg" alt="How it works..."/></div><div><div><h3 class="title"><a id="note17"/>Note</h3><p>If you have some resources that are used from different threads, usually all the code that uses them must be treated as a critical section and secured by a mutex.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec192"/>There's more...</h2></div></div></div><p>Locking a mutex is potentially a very slow operation, which may stop your code for a long time, until some other thread releases a lock. Try to make critical sections as small as possible and try to have less of them in your code.</p><p>Let's take a look at how some operating systems (OS) handle locking on a multicore CPU. When <code class="literal">thread #1</code>, running on CPU1, tries to lock a mutex that is already locked by another thread, <code class="literal">thread #1</code> is stopped by the OS till the lock is released. The stopped thread does not <em>eat</em> processor resources, so the <a id="id308" class="indexterm"/>OS will still execute other threads on CPU1. Now we have some threads running on CPU1; some other thread releases the lock, and now the OS has to resume execution of a <code class="literal">thread #1</code>. So it will resume its execution on a currently free CPU, for example, CPU2. This will result in CPU cache misses, and code will be running slightly slower after the mutex is released. This is another reason to reduce the number of critical sections. However, things are not so bad because a good OS will try to resume the thread on the same CPU that it was using before.</p><p>Do not attempt to lock a <code class="literal">boost::mutex</code> variable twice in the same thread; it will lead to a <strong>deadlock</strong>. If locking a mutex multiple <a id="id309" class="indexterm"/>times from a single thread is required, use <code class="literal">boost::recursive_mutex</code> instead of the <code class="literal">&lt;boost/thread/recursive_mutex.hpp&gt;</code> header. Locking it multiple times won't lead to a deadlock. The <code class="literal">boost::recursive_mutex</code> will release the lock only after <code class="literal">unlock()</code> is called once for each <code class="literal">lock()</code> call. Avoid using <code class="literal">boost::recursive_mutex</code>; it is slower than <code class="literal">boost::mutex</code> and usually indicates bad code flow design.</p><p>The <code class="literal">boost::mutex</code>, <code class="literal">boost::recursive_mutex</code>, and <code class="literal">boost::lock_guard</code> classes were accepted to the C++11 standard, and you may find them in the <code class="literal">&lt;mutex&gt;</code> header in the <code class="literal">std::</code> namespace. No big difference between Boost and STL versions exists; a Boost version may have some extensions (which are <a id="id310" class="indexterm"/>marked in the official documentation as <em>EXTENSION</em>) and provide better portability because they can be used even on C++03 compilers.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec193"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The next recipe will give you some ideas on how to make this example much faster (and shorter).</li><li class="listitem" style="list-style-type: disc">Read the first recipe from this chapter to get more information about the <code class="literal">boost::thread</code> class. The official documentation for <a id="id311" class="indexterm"/><code class="literal">Boost.Thread</code> may help you too; it can be found at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html">http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html</a>.</li><li class="listitem" style="list-style-type: disc">For more information about why the first example will fail and how multiprocessors work with common resources, see <em>Memory Barriers: a Hardware View for Software Hackers</em> at <a class="ulink" href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf">http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Fast access to common resource using atomics</h1></div></div></div><p>In the previous recipe, we saw how to <a id="id312" class="indexterm"/>safely access a common <a id="id313" class="indexterm"/>resource from different threads. But in <a id="id314" class="indexterm"/>that recipe, we were doing two system calls (in locking and unlocking the mutex) just to get the value from an integer:</p><div><pre class="programlisting">{ // Critical section begin
  boost::lock_guard&lt;boost::mutex&gt; lock(i_mutex);
  i_snapshot = ++ shared_i;
} // Critical section end</pre></div><p>This looks lame! And slow! Can we make the code from the previous recipe better?</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec194"/>Getting ready</h2></div></div></div><p>Reading the first recipe is all you need to start with this. Or just some basic knowledge of multithreading.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec195"/>How to do it...</h2></div></div></div><p>Let's see how to improve our previous example:</p><div><ol class="orderedlist arabic"><li class="listitem">We will need different headers:<div><pre class="programlisting">#include &lt;cassert&gt;
#include &lt;cstddef&gt;

#include &lt;boost/thread/thread.hpp&gt;
#include &lt;boost/atomic.hpp&gt;</pre></div></li><li class="listitem">Changing the type of <code class="literal">shared_i</code> <a id="id315" class="indexterm"/>is required (as it is no longer needed in the mutex):<div><pre class="programlisting">boost::atomic&lt;int&gt; shared_i(0);</pre></div></li><li class="listitem">Remove all the <code class="literal">boost::lock_guard</code> variables:<div><pre class="programlisting">void do_inc() {
  for (std::size_t i = 0; i &lt; 30000; ++i) {
    // do some work
    // ...
    const int i_snapshot = ++ shared_i;
    // do some work with i_snapshot
    // ...
  }
}

void do_dec() {
  for (std::size_t i = 0; i &lt; 30000; ++i) {
    // do some work
    // ...
    const int i_snapshot = -- shared_i;
    // do some work with i_snapshot
    // ...
  }
}</pre></div><p>And that's it! Now it works.</p><div><pre class="programlisting">int main() {
  boost::thread t1(&amp;do_inc);
  boost::thread t2(&amp;do_dec);
  t1.join();
  t2.join();
  assert(shared_i == 0);
  std::cout &lt;&lt; "shared_i == " &lt;&lt; shared_i &lt;&lt; std::endl;
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec196"/>How it works...</h2></div></div></div><p>Processors provide specific atomic operations that cannot be interfered with by other processors or processor cores. These operations appear to occur instantaneously for a system. <code class="literal">Boost.Atomic</code> provides classes that wrap around system-specific atomic operations and provide a uniform and <a id="id316" class="indexterm"/>portable interface to work with them.</p><p>In other words, it is safe to use the <code class="literal">boost::atomic&lt;&gt;</code> variables from different threads simultaneously. Each operation on the <a id="id317" class="indexterm"/>atomic variable will be seen by the system as a single transaction. Series of operations on the atomic variables will be <a id="id318" class="indexterm"/>treated by the system as a series of transactions:</p><div><pre class="programlisting">-- shared_i; // Transaction #1
// Some other thread may work here with shared_i and change its value
++shared_i; // Transaction #2</pre></div><div><img src="img/4880OS_05_03.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec197"/>There's more...</h2></div></div></div><p>The <code class="literal">Boost.Atomic</code> library can work only with POD types; otherwise, its behavior is undefined. Some platforms/processors do not provide atomic operations for some types, so <code class="literal">Boost.Atomic</code> will emulate atomic behavior using <code class="literal">boost::mutex</code>. The atomic type won't use <code class="literal">boost::mutex</code> if the type-specific macro is set to <code class="literal">2</code>:</p><div><pre class="programlisting">#include &lt;boost/static_assert.hpp&gt;
BOOST_STATIC_ASSERT(BOOST_ATOMIC_INT_LOCK_FREE == 2);</pre></div><p>The <code class="literal">boost::atomic&lt;T&gt;::is_lock_free</code> member function depends on runtime, so it is not good for compile-time checks but may provide a more readable syntax when the runtime check is enough:</p><div><pre class="programlisting">assert(shared_i.is_lock_free());</pre></div><p>Atomics work much faster than mutexes. If <a id="id319" class="indexterm"/>we compare the execution time of a recipe that uses mutexes (0:00.08 seconds) and the execution time of the preceding <a id="id320" class="indexterm"/>example in this recipe (0:00.02 seconds), we'll see the difference (tested on 3,00,000 iterations).</p><p>The C++11 compilers should have all the atomic classes, typedefs, and macros in the <code class="literal">&lt;atomic&gt;</code> header in the <code class="literal">std::</code> namespace. Compiler-specific implementations of <code class="literal">std::atomic</code> may work faster than the Boost's version, if the compiler correctly supports the C++11 memory model and atomic operations are not a compiler barrier for it any more.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec198"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The official documentation may give you many more examples and some theoretical information on the topic; it can be found at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/atomic.html">http://www.boost.org/doc/libs/1_53_0/doc/html/atomic.html</a></li><li class="listitem" style="list-style-type: disc">For more information about how atomics work, see <em>Memory Barriers: a Hardware View for Software Hackers</em> at <a class="ulink" href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf">http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Creating a work_queue class</h1></div></div></div><p>Let's call the functional object that takes <a id="id321" class="indexterm"/>no arguments (a task, in short).</p><div><pre class="programlisting">typedef boost::function&lt;void()&gt; task_t;</pre></div><p>And now, imagine a situation where we have threads that post tasks and threads that execute posted tasks. We need to design a class that can be safely used by both types of thread. This class must have methods for getting a task (or blocking and waiting for a task until it is posted by another thread), checking and getting a task if we have one (returning an empty task if no tasks remain), and a method to post tasks.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec199"/>Getting ready</h2></div></div></div><p>Make sure that you feel comfortable with <code class="literal">boost::thread</code> or <code class="literal">std::thread</code> and know some basics of mutexes.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec200"/>How to do it...</h2></div></div></div><p>The classes that we are going to implement will be close in functionality to <code class="literal">std::queue&lt;task_t&gt;</code> and will also have thread synchronization. Let's start:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll need the following headers and members:<div><pre class="programlisting">#include &lt;deque&gt;
#include &lt;boost/function.hpp&gt;
#include &lt;boost/thread/mutex.hpp&gt;
#include &lt;boost/thread/locks.hpp&gt;
#include &lt;boost/thread/condition_variable.hpp&gt;

class work_queue {
public:
  typedef boost::function&lt;void()&gt; task_type;

private:
  std::deque&lt;task_type&gt;   tasks_;
  boost::mutex            tasks_mutex_;
  boost::condition_variable cond_;</pre></div></li><li class="listitem">A function for putting a task in the queue will look like this:<div><pre class="programlisting">public:
  void push_task(const task_type&amp; task) {
    boost::unique_lock&lt;boost::mutex&gt; lock(tasks_mutex_);
    tasks_.push_back(task);
    lock.unlock();
    cond_.notify_one();
  }</pre></div></li><li class="listitem">A non-blocking function for getting a pushed task or an empty task (if no tasks remain):<div><pre class="programlisting">  task_type try_pop_task() {
    task_type ret;
    boost::lock_guard&lt;boost::mutex&gt; lock(tasks_mutex_);
    if (!tasks_.empty()) {
      ret = tasks_.front();
      tasks_.pop_front();
    }
    return ret;
  }</pre></div></li><li class="listitem">Blocking function for getting a <a id="id322" class="indexterm"/>pushed task or for blocking while the task is pushed by another thread:<div><pre class="programlisting">  task_type pop_task() {
    boost::unique_lock&lt;boost::mutex&gt; lock(tasks_mutex_);
    while (tasks_.empty()) {
      cond_.wait(lock);
    }
    task_type ret = tasks_.front();
    tasks_.pop_front();
    return ret;
  }
};</pre></div><p>And this is how a <code class="literal">work_queue</code> class may be used:</p><div><pre class="programlisting">#include &lt;boost/thread/thread.hpp&gt;

work_queue g_queue;

void do_nothing(){}

const std::size_t tests_tasks_count = 3000;

void pusher() {
  for (std::size_t i = 0; i &lt; tests_tasks_count; ++i) {
    // Adding task to do nothing
    g_queue.push_task(&amp;do_nothing);
  }
}

void popper_sync() {
  for (std::size_t i = 0; i &lt; tests_tasks_count; ++i) {
    g_queue.pop_task() // Getting task
    (); // Executing task
  }
}

int main() {
  boost::thread pop_sync1(&amp;popper_sync);
  boost::thread pop_sync2(&amp;popper_sync);
  boost::thread pop_sync3(&amp;popper_sync);

  boost::thread push1(&amp;pusher);
  boost::thread push2(&amp;pusher);
  boost::thread push3(&amp;pusher);

  // Waiting for all the tasks to pop
  pop_sync1.join();
  pop_sync2.join();
  pop_sync3.join();

  push1.join();
  push2.join();
  push3.join();

  // Asserting that no tasks remained,
  // and falling though without blocking
  assert(!g_queue.try_pop_task());

  g_queue.push_task(&amp;do_nothing);
  // Asserting that there is a task,
  // and falling though without blocking
  assert(g_queue.try_pop_task());
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec201"/>How it works...</h2></div></div></div><p>In this example, we will see a new <a id="id323" class="indexterm"/>RAII class <code class="literal">boost::unique_lock</code>. It is just a <code class="literal">boost::lock_guard</code> class with additional functionality; for example, it has methods for explicit unlocking and locking mutexes.</p><p>Going back to our <code class="literal">work_queue</code> class, let's start with the <a id="id324" class="indexterm"/>
<code class="literal">pop_task()</code> function. In the beginning, we are acquiring a lock and checking for available tasks. If there is a task, we return it; otherwise, <code class="literal">cond_.wait(lock)</code> is called. This method will unlock the lock and pause the execution thread until till some other thread notifies the current thread.</p><p>Now, let's take a look at the <code class="literal">push_task</code> method. In it we also acquire a lock, push a task to <code class="literal">tasks_.queue</code>, unlock the lock, and call <code class="literal">cond_notify_one()</code>, which will wake up the thread (if any) waiting in <code class="literal">cond_wait(lock)</code>. So, after that, if some thread was waiting on a conditional variable in a <code class="literal">pop_task()</code> method, the thread will continue its execution, call <code class="literal">lock.lock()</code> deep inside <code class="literal">cond_wait(lock)</code>, and check <code class="literal">tasks_empty()</code> in the while loop. Because we just <a id="id325" class="indexterm"/>added a task in <code class="literal">tasks_</code>, we'll get out from the <code class="literal">while</code> loop, unlock the mutex (the <code class="literal">lock</code> variable will go out of scope), and return a task.</p><div><img src="img/4880OS_05_04.jpg" alt="How it works..."/></div><div><div><h3 class="title"><a id="note18"/>Note</h3><p>It is highly recommended that you check conditions in a loop, not just in an <code class="literal">if</code> statement. The <code class="literal">if</code> statement will lead to an error if <code class="literal">thread #1</code> pops a task after it is pushed by <code class="literal">thread #2</code> but <code class="literal">thread #3</code> is notified by <code class="literal">thread #2</code> before it (<code class="literal">thread #3</code>) starts waiting.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec202"/>There's more...</h2></div></div></div><p>Note that we explicitly unlocked the mutex before calling <code class="literal">notify_one()</code>. Without unlocking, our example would still work.</p><p>But, in that case, the thread that has woken up may be blocked once more during an attempt to call <code class="literal">lock.lock()</code> deep inside <code class="literal">cond_wait(lock)</code>, which leads to more context switches and worse performance.</p><p>With <code class="literal">tests_tasks_count</code> set to <code class="literal">3000000</code> and without explicit unlocking, this example runs for 7 seconds:</p><div><pre class="programlisting">
<strong>$time -f E ./work_queue</strong>

<strong>0:07.38</strong>
</pre></div><p>With explicit unlocking, this example <a id="id326" class="indexterm"/>runs for 5 seconds:</p><div><pre class="programlisting">
<strong>$ time -f E ./work_queue </strong>

<strong>0:05.39</strong>
</pre></div><p>You may also notify all the threads waiting on a specific conditional variable using <code class="literal">cond_notify_all()</code>.</p><p>The C++11 standard has <code class="literal">std::condition_variable</code> declared in the <code class="literal">&lt;condition_variable&gt;</code> header and <code class="literal">std::unique_lock</code> declared in the <code class="literal">&lt;mutex&gt;</code> header. Use the Boost version if you need portable behavior, use C++03 compiler, or just use some of the Boost's extensions.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec203"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first three recipes in this chapter provide a lot of useful information about <code class="literal">Boost.Thread</code></li><li class="listitem" style="list-style-type: disc">The official documentation may give you many more examples and some theoretical information on the topic; it can be found at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html">http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Multiple-readers-single-writer lock</h1></div></div></div><p>Imagine that we are developing some online services. We have a map of registered users with some properties for each user. <a id="id327" class="indexterm"/>This set is accessed by many threads, but it is very rarely modified. All operations with the following set are done in a thread-safe manner:</p><div><pre class="programlisting">#include &lt;map&gt;
#include &lt;boost/thread/mutex.hpp&gt;
#include &lt;boost/thread/locks.hpp&gt;

struct user_info {
  std::string address;
  unsigned short age;
  
  // Other parameters
  // ...
};

class users_online {
  typedef boost::mutex                      mutex_t;
  mutable mutex_t                           users_mutex_;
  std::map&lt;std::string, user_info&gt;          users_;

public:
  bool is_online(const std::string&amp; username) const {
    boost::lock_guard&lt;mutex_t&gt; lock(mutex_);
    return users_.find(username) != users_.end();
  }

  unsigned short get_age(const std::string&amp; username) const {
    boost::lock_guard&lt;mutex_t&gt; lock(mutex_);
    return users_.at(username).age;
  }

  void set_online(const std::string&amp; username, const user_info&amp; data) {
    boost::lock_guard&lt;mutex_t&gt; lock(mutex_);
    users_.insert(std::make_pair(username, data));
  }

  // Other methods
  // ...
};</pre></div><p>But any operation will acquire a unique lock on the <code class="literal">mutex_</code> variable, so even getting resources will result in waiting on a locked <a id="id328" class="indexterm"/>mutex; therefore, this class will become a bottleneck very soon.</p><p>Can we fix it?</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec204"/>How to do it...</h2></div></div></div><p>Replace <code class="literal">boost::unique_locks</code> with <code class="literal">boost::shared_lock</code> for methods that do not modify data:</p><div><pre class="programlisting">#include &lt;boost/thread/shared_mutex.hpp&gt;

class users_online {
  typedef boost::shared_mutex         mutex_t;
  mutable mutex_t                     users_mutex_;
  std::map&lt;std::string, user_info&gt;    users_;

public:
  bool is_online(const std::string&amp; username) const {
    boost::shared_lock&lt;mutex_t&gt; lock(users_mutex_);
    return users_.find(username) != users_.end();
  }

  unsigned short get_age(const std::string&amp; username) const {
    boost::shared_lock&lt;mutex_t&gt; lock(users_mutex_);
    return users_.at(username).age;
  }

  void set_online(const std::string&amp; username, const user_info&amp; data) {
    boost::lock_guard&lt;mutex_t&gt; lock(users_mutex_);
    users_.insert(std::make_pair(username, data));
  }

  // Other methods
  // ...
};</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec205"/>How it works...</h2></div></div></div><p>We can allow getting the data from multiple threads simultaneously if those threads do not modify it. We need to uniquely own the mutex only if we are going to modify the data in it; in all other situations simultaneous access to it is allowed. And that is what <code class="literal">boost::shared_mutex</code> was designed for. It allows shared locking (read locking), which allows multiple simultaneous access to resources.</p><p>When we do try to unique lock a resource that is <a id="id329" class="indexterm"/>shared locked, operations will be blocked until there are no read locks remaining and only after that resource is unique locked, forcing new shared locks to wait until the unique lock is released.</p><p>Some readers may be seeing the mutable keyword for the first time. This keyword can be applied to non-static and non-constant class members. The mutable data member can be modified in the constant member functions.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec206"/>There's more...</h2></div></div></div><p>When you do need only unique locks, do not use <code class="literal">boost::shared_mutex</code> because it is slightly slower than a usual <code class="literal">boost::mutex</code> class. However, in other cases, it may give a big performance gain. For example, with four reading threads, shared mutex will work almost four times faster than <code class="literal">boost::mutex</code>.</p><p>Unfortunately, shared mutexes are not the part of the C++11 standard.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec207"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There is also a <code class="literal">boost::upgrade_mutex</code> <a id="id330" class="indexterm"/>class, which may be useful for cases when a shared lock needs promotion to unique lock. See the <code class="literal">Boost.Thread</code> documentation at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html">http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html</a> for more information.</li><li class="listitem" style="list-style-type: disc">For more information about the mutable keyword see <a class="ulink" href="http://herbsutter.com/2013/01/01/video-you-dont-know-const-and-mutable/">http://herbsutter.com/2013/01/01/video-you-dont-know-const-and-mutable/</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Creating variables that are unique per thread</h1></div></div></div><p>Let's take a glance at the recipe <em>Creating a</em> <em>work_queue class</em>. Each task there can be executed in one of many <a id="id331" class="indexterm"/>threads and we do not know which one. Imagine that we want to send the results of an executed task using some connection.</p><div><pre class="programlisting">#include &lt;boost/noncopyable.hpp&gt;

class connection: boost::noncopyable {
public:
  // Opening a connection is a slow operation
  void open();

  void send_result(int result);

  // Other methods
  // ...
};</pre></div><p>We have the following solutions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Open a new connection when we need to send the data (which is slow)</li><li class="listitem" style="list-style-type: disc">Have a single connection for all the threads and wrap them in mutex (which is also slow)</li><li class="listitem" style="list-style-type: disc">Have a pool of connections, get a connection from it in a thread-safe manner and use it (a lot of coding is required, but this solution is fast)</li><li class="listitem" style="list-style-type: disc">Have a single connection per thread (fast and simple to implement)</li></ul></div><p>So, how can we implement the last solution?</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec208"/>Getting ready</h2></div></div></div><p>Basic knowledge of threads is required.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec209"/>How to do it...</h2></div></div></div><p>It is time to make a thread <a id="id332" class="indexterm"/>local variable:</p><div><pre class="programlisting">// In header file
#include &lt;boost/thread/tss.hpp&gt;

connection&amp; get_connection();

// In source file
boost::thread_specific_ptr&lt;connection&gt; connection_ptr;

connection&amp; get_connection() {
  connection* p = connection_ptr.get();
  if (!p) {
    connection_ptr.reset(new connection);
    p = connection_ptr.get();
    p-&gt;open();
  }
  return *p;
}</pre></div><p>Using a thread-specific resource was never so easy:</p><div><pre class="programlisting">void task() {
  int result;
  // Some computations go there
  // ...

  // Sending result
  get_connection().send_result(result);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec210"/>How it works...</h2></div></div></div><p>The <code class="literal">boost::thread_specific_ptr</code> variable holds a separate pointer for each thread. Initially, this pointer is equal to <code class="literal">NULL</code>; that is why we check for <code class="literal">!p</code> and open a connection if it is <code class="literal">NULL</code>.</p><p>So, when we enter <code class="literal">get_connection()</code> from the thread that has already initiated the pointer, <code class="literal">!p</code> will return the value <code class="literal">false</code> and we'll return the already opened connection. <code class="literal">delete</code> for the pointer will be called when the thread is <a id="id333" class="indexterm"/>exiting, so we do not need to worry about memory leaks.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec211"/>There's more...</h2></div></div></div><p>You may provide your own cleanup function that will be called instead of <code class="literal">delete</code> at thread exit. A cleanup function must have the <code class="literal">void (*cleanup_function)(T*)</code> signature and will be passed during the <code class="literal">boost::thread_specific_ptr</code> construction.</p><p>C++11 has a special keyword, <code class="literal">thread_local</code>, to declare variables with thread local storage duration. C++11 has no <code class="literal">thread_specific_ptr</code> class, but you may use <code class="literal">thread_local boost::scoped_ptr&lt;T&gt;</code> or <code class="literal">thread_local std::unique_ptr&lt;T&gt;</code> to achieve the same behavior on compilers that support <code class="literal">thread_local</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec212"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Boost.Thread</code> documentation <a id="id334" class="indexterm"/>gives a lot of good examples on different cases; it can be found at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html">http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html</a></li><li class="listitem" style="list-style-type: disc">Reading this topic at <a class="ulink" href="http://stackoverflow.com/questions/13106049/c11-gcc-4-8-thread-local-performance-penalty.html">http://stackoverflow.com/questions/13106049/c11-gcc-4-8-thread-local-performance-penalty.html</a> and about the <code class="literal">GCC__thread</code> keyword at <a class="ulink" href="http://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/Thread-Local.html">http://gcc.gnu.org/onlinedocs/gcc-3.3.1/gcc/Thread-Local.html</a> may give you some ideas about how <code class="literal">thread_local</code> is implemented in compilers and how fast it is</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Interrupting a thread</h1></div></div></div><p>Sometimes, we need to kill a thread that <a id="id335" class="indexterm"/>ate too many resources or that is just executing for too long. For example, some parser works in a thread (and actively uses <code class="literal">Boost.Thread</code>), but we already have the required amount of data from it, so parsing can be stopped. All we have is:</p><div><pre class="programlisting">boost::thread parser_thread(&amp;do_parse);
  // Some code goes here
  // ...
  if (stop_parsing) {
    // no more parsing required
    // TODO: stop parser
  }</pre></div><p>How can we do it?</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec213"/>Getting ready</h2></div></div></div><p>Almost nothing is required for this recipe. You only need to have at least basic knowledge of threads.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec214"/>How to do it...</h2></div></div></div><p>We can stop a thread by interrupting it:</p><div><pre class="programlisting">if (stop_parsing) {
  // no more parsing required
  parser_thread.interrupt();
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec215"/>How it works...</h2></div></div></div><p><code class="literal">Boost.Thread</code> provides some predefined <a id="id336" class="indexterm"/>interruption points in which the thread is checked for being interrupted via the <code class="literal">interrupt()</code> call. If the thread was interrupted, the exception <code class="literal">boost::thread_interrupted</code> is thrown.</p><p><code class="literal">boost::thread_interrupted</code> is not derived from <code class="literal">std::exception</code>!</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec216"/>There's more...</h2></div></div></div><p>As we know from the first recipe, if a function passed into a thread won't catch an exception and the exception will leave function bounds, the application will terminate. <code class="literal">boost::thread_interrupted</code> is the only exception to that rule; it may leave function bounds and does not <a id="id337" class="indexterm"/>
<code class="literal">std::terminate()</code> application; instead, it stops the execution thread.</p><p>We may also add interruption points at any point. All we need is to call <code class="literal">boost::this_thread::interruption_point()</code>:</p><div><pre class="programlisting">void do_parse() {
  while (not_end_of_parsing) {
    boost::this_thread::interruption_point();
    // Some parsing goes here
  }
}</pre></div><p>If interruptions are not required for a project, defining <code class="literal">BOOST_THREAD_DONT_PROVIDE_INTERRUPTIONS</code> gives a small performance boost and totally disables thread interruptions.</p><p>C++11 has no thread interruptions but you can partially emulate them using atomic operations:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create an atomic Boolean variable</li><li class="listitem" style="list-style-type: disc">Check the atomic variable in the thread and throw some exception if it has changed</li><li class="listitem" style="list-style-type: disc">Do not forget to catch that exception in the function passed to the thread (otherwise your application will terminate)</li></ul></div><p>However, this won't help you if the code is waiting somewhere in a conditional variable or in a sleep method.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec217"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The official documentation for <a id="id338" class="indexterm"/><code class="literal">Boost.Thread</code> provides a list of predefined interruption points at <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/thread/thread_management.html#thread.thread_management.tutorial.interruption.html">http://www.boost.org/doc/libs/1_53_0/doc/html/thread/thread_management.html#thread.thread_management.tutorial.interruption.html</a></li><li class="listitem" style="list-style-type: disc">As an exercise, see the other recipes from this chapter and think of where additional interruption points would improve the code</li><li class="listitem" style="list-style-type: disc">Reading other parts of the <code class="literal">Boost.Thread</code> documentation may be useful; go to <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html">http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Manipulating a group of threads</h1></div></div></div><p>Those readers who were trying to <a id="id339" class="indexterm"/>repeat all the examples by themselves or those who were experimenting with threads must already be bored with writing the following code to launch threads:</p><div><pre class="programlisting">boost::thread t1(&amp;some_function);
boost::thread t2(&amp;some_function);
boost::thread t3(&amp;some_function);
// ...
t1.join();
t2.join();
t3.join();</pre></div><p>Maybe there is a better way to do this?</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec218"/>Getting ready</h2></div></div></div><p>Basic knowledge of threads will be more than enough for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec219"/>How to do it...</h2></div></div></div><p>We may manipulate a group of threads <a id="id340" class="indexterm"/>using the <code class="literal">boost::thread_group</code> class.</p><div><ol class="orderedlist arabic"><li class="listitem">Construct a <code class="literal">boost::thread_group</code> variable:<div><pre class="programlisting">boost::thread_group threads;</pre></div></li><li class="listitem">Create threads into the preceding variable:<div><pre class="programlisting">// Launching 10 threads
for (unsigned i = 0; i &lt; 10; ++i) {
  threads.create_thread(&amp;some_function);
}</pre></div></li><li class="listitem">Now you may call functions for all the threads inside <code class="literal">boost::thread_group</code>:<div><pre class="programlisting">// Joining all threads
threads.join_all();

// We can also interrupt all of them
// by calling threads.interrupt_all();</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec220"/>How it works...</h2></div></div></div><p>The <code class="literal">boost::thread_group</code> variable <a id="id341" class="indexterm"/>just holds all the threads constructed or moved to it and may send some calls to all the threads.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec221"/>There's more...</h2></div></div></div><p>C++11 has no <code class="literal">thread_group</code> class; it's Boost specific.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec222"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The official documentation of <a id="id342" class="indexterm"/><code class="literal">Boost.Thread</code> may surprise you with a lot of other useful classes that were not described in this chapter; go to <a class="ulink" href="http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html">http://www.boost.org/doc/libs/1_53_0/doc/html/thread.html</a></li></ul></div></div></div></body></html>