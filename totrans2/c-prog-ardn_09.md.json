["```cpp\nint piezoPin = 9; \nint value = 0;  // stores the current feed value\nint incdec = 1; // stores the direction of the variation\n\nvoid setup() {\n}\n\nvoid loop() {\n\n  // test current value and change the direction if required\n  if (value == 0 || value == 255) incdec *= -1;\n\n  analogWrite(piezoPin, value + incdec);\n  delay(30);\n}\n```", "```cpp\n#include <Servo.h> \n\nServo myServo;  // instantiate the Servo object\nint angle = 0;  // store the current angle\n\nvoid setup() \n{ \n  // pin 9 to Servo object myServo\n  myServo.attach(9);  \n} \n\nvoid loop() \n{ \n  for(angle = 0; angle < 180; angle += 1)   \n  {                                  \n    myServo.write(angle);               \n    delay(20);                       \n  } \n  for(angle = 180; angle >= 1; angle -=1)     \n  {                                \n    myServo.write(angle);              \n    delay(20);                       \n  } \n}\n```", "```cpp\n#include <Servo.h> \n\nServo servo01;\nServo servo02;\nServo servo03;\n\nint angle;\n\nvoid setup() \n{ \n  servo01.attach(9);\n  servo02.attach(10);\n  servo03.attach(11);\n} \n\nvoid loop() \n{ \n  for(angle = 0; angle < 180; angle += 1)   \n  {                                  \n    servo01.write(angle);\n    servo02.write(135-angle/2);\n    servo03.write(180-angle);\n\n    delay(15);                       \n  }\n}\n```", "```cpp\n#include <Stepper.h>\n#define STEPS 200\n\n// create an instance of stepper class\nStepper stepper(STEPS, 8, 9, 10, 11);\n\nint counter = 0; // store steps number since last change of direction\nint multiplier = 1; // a basic multiplier\n\nvoid setup() \n{ \n  stepper.setSpeed(30); // set the speed at 30 RPM\n} \n\nvoid loop()\n{\n\n  // move randomly from at least 1 step\n  stepper.step(multiplier);\n\n  // counting how many steps already moved\n  // then if we reach a whole turn, reset counter and go backward\n  if (counter < STEPS)  counter++ ;\n  else { \n    counter = 0; \n    multiplier *= -1;\n  }\n}\n```", "```cpp\nvoid setup() {\n  // initiate the pseudo-random number generator\n  randomSeed(analogRead(0));\n}\n\nvoid loop() {\n  // generate random pitch & duration\n  int pitch = random(30,5000);\n  int duration = 1000 / (random(1000) + 1);\n\n  // play a tone to the digital pin PWM number 8\n  tone(8, pitch, duration);\n\n  // make a pause\n  delay(duration * 1.30);\n\n  // stop the tone playing\n  noTone(8);\n}\n```", "```cpp\n#include <MozziGuts.h>\n#include <Oscil.h> // oscillator template\n#include <tables/sin2048_int8.h> // sine table for oscillator\n\n// use: Oscil <table_size, update_rate> oscilName (wavetable)\nOscil <SIN2048_NUM_CELLS, AUDIO_RATE> aSin(SIN2048_DATA);\n\n// use #define for CONTROL_RATE, not a constant\n#define CONTROL_RATE 64 // powers of 2 please\n\nvoid setup(){\n  startMozzi(CONTROL_RATE); // set a control rate of 64 (powers of 2 please)\n  aSin.setFreq(440u); // set the frequency with an unsigned int or a float\n}\n\nvoid updateControl(){\n  // put changing controls in here\n}\n\nint updateAudio(){\n  return aSin.next(); // return an int signal centered around 0\n}\n\nvoid loop(){\n  audioHook(); // required here\n}\n```", "```cpp\n#include <MozziGuts.h>\n#include <Oscil.h>\n#include <tables/cos8192_int8.h> // table for Oscils to play\n#include <utils.h> // for mtof\n\n#define CONTROL_RATE 64 // powers of 2 please\n\nOscil<COS8192_NUM_CELLS, AUDIO_RATE> aCos(COS8192_DATA);\nOscil<COS8192_NUM_CELLS, AUDIO_RATE> aVibrato(COS8192_DATA);\n\nconst long intensityMax = 500;\n\nint potPin = A0;\nint potValue = 0;\nvoid setup(){\n  startMozzi(CONTROL_RATE);\n  aCos.setFreq(mtof(random(21,80)));\n  aVibrato.setFreq((float) map(potValue, 0, 1024, 0, intensityMax));\n}\n\nvoid loop(){\n  audioHook();\n}\n\nvoid updateControl(){\n  potValue = analogRead(potPin);\n}\n\nint updateAudio(){\n  long vibrato = map(potValue, 0, 1024, 0, intensityMax) * aVibrato.next();\n  return (int)aCos.phMod(vibrato);\n}\n```", "```cpp\n#include <MIDI.h>\n#include <MozziGuts.h>\n#include <Oscil.h> // oscillator template\n#include <Line.h> // for envelope\n#include <utils.h> // for mtof\n#include <tables/sin2048_int8.h> // sine table for oscillator\n\n// use #define for CONTROL_RATE, not a constant\n#define CONTROL_RATE 128 // powers of 2 please\n\n// declare an oscillator using a sine tone wavetable\n// use: Oscil <table_size, update_rate> oscilName (wavetable)\nOscil <SIN2048_NUM_CELLS, AUDIO_RATE> aSin(SIN2048_DATA);\n\n// for envelope\nLine <unsigned int> aGain;\nunsigned int release_control_steps = CONTROL_RATE; // 1 second of control\nunsigned int release_audio_steps = 16384; // 1 second of audio\nint fade_counter;\n\nfloat vol= 1\\. ; // store the master output volume\n\nunsigned int freq; // to convey control info from MIDI handler to updateControl()\n\nvoid HandleControlChange(byte channel, byte CCnumber, byte value) { \n  switch(CCnumber){\n    case 100:\n      vol = map(value,0, 127, 0., 1.);\n    break;\n  }\n}\n\nvoid HandleNoteOn(byte channel, byte pitch, byte velocity) { \n  // scale velocity for high resolution linear fade on Note-off later\n  freq = mtof(pitch);\n  aGain.set(velocity<<8); // might need a fade-in to avoid clicks\n\n}\n\nvoid HandleNoteOff(byte channel, byte pitch, byte velocity) { \n\n  // scale velocity for high resolution linear fade on Note-off later\n  aGain.set(0,release_audio_steps);\n  fade_counter = release_control_steps;\n}\n\nvoid setup() {\n\n  // Initiate MIDI communications, listen to all channels\n  MIDI.begin(MIDI_CHANNEL_OMNI);    \n\n  // Connect the HandleControlChange function to the library, so it is called upon reception of a NoteOn.\n  MIDI.setHandleControlChange(HandleControlChange); // Put only the name of the function\n\n    // Connect the HandleNoteOn function to the library, so it is called upon reception of a NoteOn.\n  MIDI.setHandleNoteOn(HandleNoteOn);  // Put only the name of the function\n\n   // Connect the HandleNoteOn function to the library, so it is called upon reception of a NoteOn.\n  MIDI.setHandleNoteOff(HandleNoteOff);  // Put only the name of the function\n\n  aSin.setFreq(440u); // default frequency\n  startMozzi(CONTROL_RATE); \n}\n\nvoid updateControl(){\n  // Ideally, call MIDI.read the fastest you can for real-time performance.\n  // In practice, there is a balance required between real-time \n  // audio generation and a responsive midi control rate.\n  MIDI.read();\n\n  if (fade_counter-- <=0) aGain.set(0,0,2); // a line along 0\n}\n\nint updateAudio(){\n  // aGain is scaled down to usable range\n  return (int) ((aGain.next()>>8) * aSin.next() * vol )>>8; // >>8 shifts the multiplied result back to usable output range\n}\n\nvoid loop() {\n    audioHook(); // required here\n}\n```"]