- en: Chapter 4. Have Thy Gear Ready - Building Game Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making games is a fine art. It is entirely possible, of course, to make art
    with the most basic of tools, but most commonly, developers need a strong toolkit
    supporting them in order to efficiently and professionally create quick, painless
    edits to their game. Building the said toolkit is arguably on a par with the difficulty
    of building the actual game, but the work spent on proper tools offsets the difficulty
    and frustrations that come with direct file edits.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to be covering these topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Building a graphical means of file management
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File loading in a separate thread
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing a state and means of controls for map editing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's lots of ground to cover, so let's get started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Use of copyrighted resources
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, let us give proper thanks to the artists and their assets that made
    this possible:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '*Folder Orange* by *sixsixfive* under the **CC0** license (public domain): [https://openclipart.org/detail/212337/folder-orange](https://openclipart.org/detail/212337/folder-orange)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Generic Document* by *isendrak* under the **CC0** license (public domain): [https://openclipart.org/detail/212798/generic-document](https://openclipart.org/detail/212798/generic-document)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tango Media Floppy* by *warszawianka* under the **CC0** license (public domain): [https://openclipart.org/detail/34579/tango-media-floppy](https://openclipart.org/detail/34579/tango-media-floppy)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Close* by *danilo* under the **CC0** license (public domain): [https://openclipart.org/detail/215431/close](https://openclipart.org/detail/215431/close)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hand Prints* by *kattekrab* under the **CC0** license (public domain): [https://openclipart.org/detail/16340/hand-prints](https://openclipart.org/detail/16340/hand-prints)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Paint Brush with Dark Red Dye* by *Astro* under the **CC0** license (public
    domain): [https://openclipart.org/detail/245360/Paint-Brush-with-Dye-11](https://openclipart.org/detail/245360/Paint-Brush-with-Dye-11)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Primary Eraser* by *dannya* under the **CC0** license (public domain): [https://openclipart.org/detail/199463/primary-eraser](https://openclipart.org/detail/199463/primary-eraser)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mono Tool Rect Selection* by *dannya* under the **CC0** license (public domain): [https://openclipart.org/detail/198758/mono-tool-rect-selection](https://openclipart.org/detail/198758/mono-tool-rect-selection)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Color Bucket Red* by *frankes* under the **CC0** license (public domain): [https://openclipart.org/detail/167327/color-bucket-red](https://openclipart.org/detail/167327/color-bucket-red)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File management
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The success and usability of the map editor tool is going to rely heavily on
    one specific interfacing element here, which is file access and management. In
    order to provide efficient means of file access, loading and saving, we are going
    to work on developing the means of visually guiding our user through the file
    system. The entire system consists of a few moving parts. For now, let us solely
    focus on the interface aspect of this idea.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: File manager interface
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can successfully work with any kind of map data, it is important
    to have a comfortable means of loading and saving. This can be offloaded to a
    file manager interface, which is going to be responsible for displaying directory
    information. Let us take a look at what ours is going to look like:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![File manager interface](img/image_04_001.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'With this goal in mind, let us begin planning a class for it, starting with
    the header:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Evidently, this class is a slightly more complex manifestation of a wrapper
    for a `GUI_Interface` instance. It is responsible for keeping track of the current
    directory we are in, as well as invoking a callback function/method when a file
    is selected to be loaded or saved. The callback function only takes a string argument,
    which carries the full path to the file that was selected to be loaded or saved,
    and can be registered like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Nothing too complicated yet. Let us move on to actually implementing the class!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the file manager
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the class definition out of the way, it is time to take a look at the
    actual code that makes the file manager tick. Let''s start by implementing the
    constructor of this class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we load the interface and store its pointer in the designated data member.
    We also want to store the current state of the application, and obtain the style
    names of the elements, called `FolderEntry` and `FileEntry`, which are then removed.
    This makes the interface file a sort of template that gets filled in with all
    the right information later.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Once the appropriate content size and offset are set, the interface is positioned
    in the centre of the screen. We then subscribe to relevant GUI interface events
    and set our file manager directory as the current directory the application is
    in.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'The callbacks and interfaces created in this class obviously need to be removed
    once they are no longer in use. This is where the destructor comes in:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, it is important for the file manager class to have a way to easily change
    its current directory:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A couple of interesting things happened. Right after the argument is stored;
    all of the backward slashes in the directory string are replaced with forward
    slashes, in order to maintain compatibility with multiple other operating systems
    that do not play well with the former. The interface is then instructed to destroy
    all elements it has that begin with the `""Entry_""` string. This is done in order
    to clear out all file and directory entries that may already exist. Finally, `ListFiles()`
    method is invoked, which populates the file manager with all of the files and
    folders inside the new directory. Let'' us take a look at how that can be done:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, the `Directory` element is obtained in order to change its text. It represents
    the full path of the current working directory. The complete file list inside
    that directory is then obtained, including other folders. After it gets sorted
    alphabetically and by type, the parent directory element is obtained to calculate
    the starting coordinates of the first element on the list, which is, in turn,
    iterated over. Non-physical directories, such as `"."` or `".."`, are dismissed.
    A new element is then added to the interface, with an appropriate name that varies
    depending on whether we are working with a file or a folder. That same element
    is then updated to have the entry name, be in the right position and have a correct
    style attached to it. Finally, the *y* coordinate is incremented for the next
    element on the list.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'With the directory structure being visually represented, let us take a look
    at what needs to happen when one of its entries is actually clicked:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first check here lets us know whether the item clicked on was a directory
    or a file. In case of a folder click, we want to be able to traverse the filesystem
    by taking its name and adding it onto our existing directory path. The vertical
    scroll of the interface is then set back to zero, in order to move the content
    back up to the top if any scrolling has been done.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: A file click is a simpler matter. All we need to do in that case is obtain the
    text-field element that holds the filename, and change its contents to the name
    of the file that was just clicked on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this works perfectly for forward-traversal, but what if we want to go
    backwards? The parent directory element helps us out here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, it simply comes down to basic string manipulation. The very last instance
    of the forward slash character is first attempted to be located inside the directory
    string. If one is found, the string is simply *clipped* at that point, in order
    to drop everything that comes after it. The shortened path is then set as the
    current directory, where the rest of the magic that we've already covered happens.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of the puzzle in making this work is handling the button press
    action:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First, we need to make sure the action callback is actually set. If it is,
    it gets invoked with the path to the currently selected file as its argument.
    The only other action button we have to worry about after this point is the close
    button:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It simply invokes the `Hide()` method, which is covered here, along with its
    counterpart:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When an interface is hidden, it's simply set to inactive. Showing it requires
    setting it back to being active, except we also want to position it in the absolute
    centre of the screen in this instance. In addition to that, it is a good idea
    to refresh its content, as the file structure may have changed while it was hidden.
    Lastly, the interface is focused, in order to bring it to the front of the drawing
    queue.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'The final bits of helpful code for this class consist of these methods:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: They help our other classes interface with this one more easily, by allowing
    them to determine if the file manager is in `Save` or `Load` mode, and to switch
    between the two.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Loading files in a separate thread
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have covered the threaded worker base class previously in [Chapter 1](ch01.html
    "Chapter 1. Under the Hood - Setting up the Backend"), *Under the Hood - Setting
    up the Backend*. This is exactly where it will come in handy. In order to make
    the application seem more user-friendly, we want to render a nice loading bar
    that shows progress while the files are being loaded. Let us start by first defining
    a data type, used to store file paths that need to be loaded:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `size_t` here represents the number of lines that are in the file, which
    makes it easy for us to determine the current loading progress. With that out
    of the way, let us work on the header file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Any `FileLoader` class in our code base needs to implement the `ProcessLine`
    method, which simply defines what needs to happen as each individual line of the
    file is being parsed. If necessary, it can also take advantage of `SaveToFile`,
    which, as the name states, defines the process of writing the class data out,
    and `ResetForNextFile`. The latter method is invoked after every file that has
    finished loading, in order to give derivative classes a chance to clean up their
    internal state.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: As far as data members go, we have a list of loader paths that are to be loaded,
    the number of total lines of all files that are supposed to be parsed, and the
    number of the current line being read.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the file loader
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us start simply, and cover the one-liner methods first:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The constructor simply initializes a few of the class data members to their
    default values. The `AddFile()` method inserts the argument to the file container
    with the line count *zero*. The next two methods are simple getters, while the
    last two are not even implemented, as they are optional.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us work on the method that will actually be running in a thread and
    parse the file information:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, a private method for counting all file lines is invoked. This is necessary,
    as we want to be able to calculate our progress, and knowing how much work there
    is in total is needed for that. If after this method is called, the total number
    of lines is zero, we simply return as there is nothing to process.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: We then enter a loop that runs once for each file on the list. The class is
    reset for new file iteration, and a line from the input stream is created. The
    number of lines remaining to be processed is created, and another loop is entered
    that will execute once for each line in the file. Our `sf::Mutex` object is then
    locked in order to safely manipulate the two line data members that are used for
    progress tracking.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: If the first character of our line is a pipe, `|`, it means we ran into a commented
    line and should just skip the current iteration. Otherwise, an `std::stringstream`
    of the current line is created and passed into the pure virtual `ProcessLine()`
    method, which is encapsulated in an `if` statement to catch a possible failure,
    in which case the remainder of lines inside the current file are simply added
    to the current line counter and the loop is broken out of.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Once the processing of all files is complete, the `Done()` method is invoked
    in order to terminate the thread and let the outside code know we've finished.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Another equally as important process is counting the lines of all file entries
    inside this class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This one is fairly straightforward. After the two counters are zeroed out, we
    begin iterating over each path inside the file list. If the name of it is empty,
    the element is removed. Otherwise, we attempt to open the files. If that fails,
    the path is also erased. Otherwise, the file stream is requested to not skip whitespaces,
    and we enter a `sf::Mutex` lock, where the number of lines in the file stream
    is calculated using `std::count`, and added to the total line counter. The path
    iterator is then moved forward, and the file is closed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The loading state
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last piece of the threaded file loading puzzle is the loading state. In
    order to avoid other logic going on and simply focus on the graphical progress
    representation, it''s a good idea to just switch to a dedicated state that will
    handle all loading logic inside it. Let us begin by defining a data type for holding
    pointers to `FileLoader*` instances:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The actual loading state header will end up looking something like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we have one event callback method, a couple of helper methods,
    the container for loader pointers, an instance of `sf::Text` and `sf::RectangleShape`
    to represent the loading bar, a number to represent the progress percentage, and
    the number of lines inside all files we originally started with.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the loading state
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of this data needs to be initialized before it being used, so let us take
    a look at the `OnCreate()` method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because we are going to be using text, we need to have a font to work with.
    After one is acquired and all of the stylistic text settings are handled, we set
    up the rectangle to be exactly in the centre of the screen and register an event
    callback for proceeding out of the loading state, if the manual continue flag
    is set to `true`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Destroying this state also means the event callback and the font need to be
    released:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, let us take a look at the updated logic:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, a check is made to determine if we are ready to exit the state, given
    all of the work that has been done. If the manual continue flag is set to `false`,
    we simply invoke the Proceed callback directly by passing `nullptr` as the `EventDetails`
    pointer, since it is not used there anyway. The update method is then returned
    from.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: If we still have some work to do, the first element on the loader list is checked
    to see if it's done. If it is, the loader is removed, and if it was the last one,
    the size of the rectangle is set to match the full size of the window on the x
    axis, which shows full completion. The text in the middle is also updated to let
    the user know they need to press the spacebar key to continue. Finally, the update
    method is returned from once again, to prevent further logic from executing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: If none of those conditions were met, the first element on the loader list is
    checked to see if it has started its work. If it has not yet started, its `Begin`
    method is invoked. This is quickly followed by the percentage calculation, which
    is then used to update the text in the middle of the screen and adjust the size
    of the progress bar rectangle to match said percentage.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing in this state simply comes down to two calls:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: All we need to do here is render the rectangle and the text instances.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us take a look at the helper method that updates our text instance:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After the text string is updated, its position is updated to be directly in
    the middle of the screen. Since updating its contents may change the bounding
    box, and thus how it is centered, a helper function inside our `Utils` namespace
    is used to center it properly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us calculate the actual progress of the loading procedure:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After an absolute value of `100.f` is created, the current progress is calculated
    by first determining the progress of how many files have been already loaded out
    of the number we began with, followed by the progress of the current file being
    calculated and used to determine absolute progress, which is then returned.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all of the work is done, the `Proceed()` method is invoked to return to
    the previous state:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Obviously it needs to check if the list of file loaders is actually empty first.
    If it is, the state manager is instructed to switch to the state that comes just
    before this one, which means it is the one that initiated the loading procedure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, what would a class be without some helper methods? Let us take a look
    at them now:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Creating the map editor state
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we''re finally ready to actually tackle the state, in which all of the
    map editing is going to take place. Let us take a gander at its header file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This `State_MapEditor` class is going to be the frontier that deals with the
    most general editor events. Note the highlighted data member here. We have not
    yet covered this class, but it is responsible for handling the finer aspects of
    control for this application. It will be covered in the next chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the `MapControls` class, we also have the file manager, a string
    for the path to a file that is currently being worked on, and a *boolean* flag
    that keeps track of whether the game map should be redrawn or not.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the state
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, let us begin by tackling the construction of all the important data
    inside this state:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After all of the event callbacks are set up, the file manager class is provided
    with its own callback for either loading or saving a file, as well as the starting
    directory it needs to be in. In this case, appropriately enough, it is the maps
    folder. The manager is then hidden, and another interface is loaded and positioned
    on screen. `MapEditorTop` is the control strip on the very top of the screen that
    has buttons for creating a new map, loading, saving, and exiting the application:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the state](img/image_04_002.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'Once the state is finished and is about to be destroyed, it needs to remove
    all call-backs that it set up. This can be done in the `OnDestroy()` method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In addition to callbacks, the map is also purged just before its size is set
    back to absolute zero. Since we are on the subject of callbacks, let us just cover
    most of them in a single go:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When the **New** map button is clicked, we want to invoke a special method of
    the `MapControls` class that will handle it. If the **Load** button is clicked,
    we simply switch the mode of the file manager to load, and show it on screen.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the **Save** button can have two behaviors. First, if we are dealing
    with a fresh, new map that has not been saved yet, it is the same as clicking
    the **Save As...** button, which switches the file manager to save mode and shows
    it on screen. However, if we have loaded a map or have previously saved a new
    one, the state remembers where it was saved, as well as its name. Prompting the
    user to enter a filename again would be pointless here, so the map is simply written
    to the exact same location, with the exact same name.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the **Exit** button is clicked, we simply switch back to the main
    menu state and remove this one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'With the UI code out of the way, let us take a look at what needs to happen
    when a map is being loaded:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since we want a nice loading bar to appear as a map is being read in, we are
    going to be using the loading state. After it is obtained, both the particle system
    and the map are purged. The map, which inherits from the `FileLoader` class, is
    then reset. The file path that was provided as an argument is then added to it
    to be loaded, and the loading state itself is set up to automatically dismiss
    itself once the loading is done. At the same time, we make sure that the map is
    going to be re-drawn as the map editor state resumes, and that it remembers the
    path of the map if it is to be saved later. Finally, we can switch to the loading
    state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us work on the code that is responsible for saving the map:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is much simpler than the previous method. The path is simply passed to
    the `SaveToFile` method of the game map class, and stored for later use.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual callback of the file manager that mediates between the load and
    save methods can be implemented like :'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Depending on the mode the file manager is in, the appropriate method is called
    with the path being passed in as the argument. The actual interface is then hidden.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we want to re-draw the map after it was loaded, the perfect place for
    that logic is inside the `Activate()` method, as it gets called right when a state
    is switched to:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the `m_mapRedraw` flag is not on, there is no need to do anything at this
    point. Otherwise, we want to redraw the map and provide the `mapControls` class
    with the tile-sheet texture name, so that it can perform its own logic, such as,
    for example, tile selection.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us take a look at what needs to be updated while the application
    is in this state:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Alongside the `mapControls` class, the game map, ECS system manager, and the
    particle system also need to be updated, because we are going to be using all
    of these classes while building maps. Predictably enough, these are the same objects
    that also need to be drawn:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note the `from` and `to` variables. The `mapControl` class is going to provide
    us with a way to switch between layers/elevations, so we need to obtain that information
    before anything is rendered, in order to make sure only the appropriate layers
    are drawn on screen. `DrawSelectedLayers` simply returns a *boolean* value that
    determines whether or not all layers should be drawn, or just the selected ones.
    Once the loop has iterated over the appropriate elevations, we make sure to draw
    the remaining particles that are above the maximum elevation, provided, of course,
    everything needs to be rendered. This is topped off by the map controls being
    drawn over everything else.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'For other outside communications with this class, we provide two basic setter
    methods:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These are going to be used inside the control classes to communicate events,
    such as a new map being created, or it needing to be re-drawn.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Building the control mechanism
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While building maps, the user tends to run into situations where they need
    more than just a tile being placed where the mouse clicks. It would definitely
    be useful to have tools that would enable them to freely pan around, select chunks
    of the map for deletion or copying, erase them and so on. Our control class is
    going to serve this exact purpose. It will provide a set of tools that can be
    used for multiple different situations:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建地图时，用户往往会遇到需要不仅仅是在鼠标点击的位置放置瓦片的情况。拥有能够让他们自由平移、选择地图的一部分进行删除或复制、擦除等的工具肯定会很有用。我们的控制类将正好起到这个作用。它将提供一套可用于多种不同情况下的工具：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding control mode enumeration represents a couple of the most common
    tools that come in a variety of different pieces of software. We''re going to
    implement some of them here, and leave the rest up to you! In the end, we should
    have a control interface that looks a little like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的控制模式枚举代表了一些在多种不同软件中常见的工具。我们将在这里实现其中一些，其余的留给你们！最终，我们应该有一个看起来像这样的控制界面：
- en: '![Building the control mechanism](img/image_04_003.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![构建控制机制](img/image_04_003.jpg)'
- en: 'Let us get to actually writing out the header for the control class. For clarity,
    we are going to be discussing its methods and data members separately, starting
    with the member functions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写控制类的头文件。为了清晰起见，我们将分别讨论其方法和数据成员，从成员函数开始：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In addition to all of the helper methods for setting and getting the class
    parameters, we have a whole bunch of event callbacks, as well as individual update
    methods for every kind of map tool we''re going to be working with. Next, let
    us take a look at the data members we are going to be working with:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置和获取类参数的所有辅助方法之外，我们还有一大堆事件回调，以及针对我们将要使用的每种地图工具的单独更新方法。接下来，让我们看看我们将要工作的数据成员：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Alongside the `ControlMode` that this class is currently in, we are also going
    to be storing a couple of flags. The `m_action` flag will be used with tools,
    as well as `m_secondaryAction`. The former simply denotes whether the left mouse
    button is pressed or not, while the latter is used with an action that can only
    happen once the mouse position has changed. This will prove useful when we are
    trying to optimize certain things to not happen, unless they absolutely have to.
    The last two flags signify whether we are currently right-click panning, and whether
    only the selected layers should be drawn on screen.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个类当前所在的`ControlMode`之外，我们还将存储几个标志。`m_action`标志将与工具一起使用，以及`m_secondaryAction`。前者简单地表示左鼠标按钮是否被按下，而后者用于只有在鼠标位置改变后才能发生的行为。这将在我们尝试优化某些事情以避免它们发生时非常有用。最后两个标志表示我们是否正在使用右键进行平移，以及是否只应在屏幕上绘制选定的图层。
- en: Below that, there are a couple of 2D vectors, used to store mouse information,
    such as its current position, where a left-click first happened, the difference
    between the current and last frame in the mouse position, its current position
    in tile coordinates, and its starting position in tile coordinates. Additionally,
    we also have a floating point value for the current zoom factor.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面，有一些用于存储鼠标信息的二维向量，例如其当前位置、左键第一次点击的位置、鼠标位置当前帧与上一帧之间的差异、其在瓦片坐标中的当前位置以及其在瓦片坐标中的起始位置。此外，我们还有一个用于当前缩放因子的浮点值。
- en: For the brush that will be used to paint with, we simply use a `TileMap` structure,
    just like the game map class does. Since the brush is going to have to be drawn
    on screen, we need to store a texture for it, as well as another drawable object
    that will be used to show it. Finally, a `sf::RectangleShape` type is going to
    more than suffice for showing the boundaries of the map on screen.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将要用来绘画的刷子，我们简单地使用一个`TileMap`结构，就像游戏地图类所做的那样。由于刷子将要被绘制在屏幕上，我们需要为其存储一个纹理，以及另一个将被用来显示它的可绘制对象。最后，一个`sf::RectangleShape`类型将足以显示地图在屏幕上的边界。
- en: 'Additional code separation, especially when code is becoming quite lengthy,
    is always a good idea. For this purpose, other non-general-control logic is going
    to be spread out into two additional interface classes: a tile selector, and the
    selection options. A tile selector is a simple window that shows the entire tile-sheet
    and allows the user to select tiles they want to paint with, while selection options
    is a separate interface that provides us with a myriad of settings that can be
    tweaked when specific things on screen are selected. Both of these classes are
    going to be covered in the next chapter.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have another interface, named `m_mapSettings`, the logic of which
    is going to be handled within the `MapControls` class. When creating new maps,
    we need a neat little window that is going to allow us to configure the size of
    the map, its default friction value, and the name of the tile-sheet it is going
    to be using. This is exactly the purpose the map settings interface is going to
    serve.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Implementing controls
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are quite a few data members to initialize, so let us take a look at
    how the constructor manages it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, there is quite a lot going on here. Let us zip through it section
    by section. Right after the arguments of the constructor are processed, we set
    up the data members of this class to hold their initial values. Shortly after
    that, the custom interface classes get set up, with all the necessary arguments
    being passed to their constructors. For now, we are not going to be worrying about
    them, as they will be covered in the next chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at the actual constructor body next:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Right after all event callbacks get set up, we begin working on the interfaces.
    The actual tools interface is loaded and positioned on screen, as well as the
    new map settings window, which we are going to keep track of by storing its pointer
    as one of our data members. It gets positioned in the centre of the screen and
    set as inactive for the time being.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The next segment simply deals with the stylistic aspects of the brush drawable,
    as well as the map boundaries rectangle. These values can obviously be customized
    to look completely different.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need to make sure to populate the drop-down element for sheet selection
    inside the new map settings interface. After the element is obtained and cleared
    of all other entries, the list of all filenames that are of type `.tilesheet`
    inside the appropriate location is obtained and iterated over, stripping away
    the file format from each one and adding it to the drop-down list, which is then
    re-drawn to reflect all changes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that all interfaces and callbacks that were created here need to
    be removed, which is all that happens in the destructor. For that specific reason,
    we are not going to be covering that here, as it is redundant.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at what needs to happen when this class is being updated:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: First, we handle any possible changes in size of the map class. The map boundary
    rectangle is updated here to reflect them. Next, we must make sure the mouse is
    updated properly. All of that logic is contained within the `UpdateMouse` method,
    which is invoked here. Finally, depending on the current `ControlMode`, we need
    to invoke the appropriate update method for the specific tool that is selected.
    The pan tool is special in a way, because it will be updated when it is selected
    as a tool, and when the right mouse button is being pressed as well.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing all of these objects may be simpler than you think:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this specific instance, all we need to render is the rectangle of the `mapBoundaries`,
    the brush, if the `ControlMode` is set to `Brush`, and the `SelectionOptions`
    class, which has its own `Draw` method. More on that will be covered in the next
    chapter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us implement everything necessary to keep track of all the relevant
    mouse information:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After the current mouse position is obtained, it is used to compute the coordinate
    difference between the current frame and the previous one.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the mouse difference is expressed in **global coordinates**, we must remember
    to multiply them by the *zoom factor*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The mouse position is then stored for the next frame, so this process can take
    place all over again. The current `sf::View` is then obtained for calculating
    the current **global** position of the camera. From this, we can calculate the
    global mouse position (adjusted for zoom, of course), and the mouse tile position,
    which is simply the tile that's being pointed at.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The current mouse tile position is then checked against the calculated result
    for being different. If it is, and the left mouse button is currently being pressed
    (as shown by the `m_action` data member), the secondary action flag is turned
    on. The mouse tile position is then stored for the next frame.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method in the mouse variety deals with left and right clicks, and
    can be implemented like so:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Because something else may have already processed a mouse event, we need to
    check for the event details that get submitted as an argument. We do not want
    to accidentally paint some tiles on the map if we are simply interacting with
    an interface, for example. Next, the key code of the event is checked to see whether
    it is the left mouse button. If it is not, all we need to worry about is setting
    the right-click pan flag to `true` and returning.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: If we indeed have a left-click, on the other hand, the current mouse position
    is stored as both the starting and the current positions. A very similar process
    to updating the mouse takes place here, leading to the calculation of the global
    mouse coordinates. They are then passed into the `MouseClick()` method of the
    selection options class, which returns a *boolean* flag, signifying whether any
    entities or particle emitters have been selected. We will be dealing with that
    in the next chapter. If that is not the case, however, both the action and secondary
    action flags are set to `true` in order to use the currently selected tool.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way that for every action there is an equal and opposite reaction,
    for each click we need to have a release:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: All we need to worry about here is resetting all of the action flags that are
    used while the mouse is active. This includes the right-click panning, and both
    action flags. The selection options interface also needs to be notified of a release.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'A neat little feature that is going to help out a lot is being able to zoom
    in and out. It is handled here as an event:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If this event has not already been processed by something else, we proceed to
    calculate the amount of zoom that needs to happen. A `float factor` value is defined
    here, and is multiplied by the change in the mouse wheel position. In order for
    it to be treated as a scale factor, it is subtracted from `1.f`, and then used
    to zoom in the view. Finally, in order to keep track of the current zoom value,
    we must multiply it by the said scale factor.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The next event we need to worry about is one of the tools being selected:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is quite simple, as we basically map the names of elements to their `ControlMode`
    counter-parts. The appropriate mode is then selected on the bottom.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of tools, each one of them has their own individual update method.
    Let us begin by taking a look at how the pan tool is updated:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We obviously do not want the screen to move if the mouse is not being clicked,
    or if the mouse position delta between frames is absolute zero. Given that both
    those conditions are satisfied, however, all we need to do is move the centre
    of the view to a different location. This location is calculated by adding its
    current position with the mouse position difference, which has to have its sign
    flipped. We do this, because as the mouse is clicked and moved left, for example,
    the view needs to shift right in order to feel natural. The same is true for the
    *x* axis.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a brush tool, the logic goes like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'First, the global position of the tile the mouse is over currently is calculated,
    which the brush drawable is set to match. Doing it like this creates a feel of
    the brush being locked to a grid. Another method is then invoked for placing the
    tiles:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first and most obvious check here is to make sure that both the primary
    and secondary actions are on. We do not want to be placing tiles if the mouse
    is not being clicked, or if it already has been clicked, but is still at the same
    location. Otherwise, we are good to go on painting, which begins by the brush
    tile map being placed on the game maps tile map at the current mouse tile position,
    starting at the lowest layer currently selected by the selection options. Even
    though we may be able to shift through elevations at ease, we still need to tell
    this method about the lowest current elevation selected, because the brush tile
    map itself still begins at elevation *0*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: After the map has been updated, the tile coordinate range to be redrawn is calculated
    and passed to the `MapControls` class to be rendered on screen. We do not want
    to re-draw the whole map, as that would take more time and introduce latency.
    Lastly, the secondary action flag is set to `false` in order to indicate that
    a placement has been made at these coordinates already.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'The next tool we need to update is the selection box:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, all of that logic is handled by the `SelectionOptions` class.
    For now, we simply need to worry about invoking this method
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'The same `SelectionOptions` interface may be responsible for manipulating our
    brush, which means we need to have a method for redrawing it to reflect changes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: First, the real pixel brush size is calculated from the size of its tile map.
    If it does not match the current dimensions of the texture that represents it,
    the texture needs to be re-created. Once that is taken care of, the texture is
    cleared to all transparent pixels, and we begin iterating over each tile and layer
    inside said brush. Given it is a valid tile that has proper ties to an information
    structure that holds its sprite for rendering, the latter is set to the correct
    position on the texture and drawn to it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, the texture's display method is invoked to show all the changes,
    and the drawable object of the brush is bound to the texture again. The drawables
    size and texture rectangle is also reset, because the dimensions of the texture
    could have changed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'In this type of an application, it''s important to have a quick and easy way
    of deleting something that''s currently selected. For this, we''re going to be
    processing the event that''s bound to the *Delete* key on your keyboard:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is a very simple callback. It simply checks if the current `ControlMode`
    is selected, and passes its details to another callback that belongs to the `selectionOptions`
    class. It will be dealing with all removals.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new tool is being selected, we must reset all data members we work with
    to their initial values in order to avoid weird bugs. This is where the `ResetTools()`
    method comes in:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It simply resets certain mouse data to a default uninitialized state. The `m_selectionOptions
    Reset()` method is also invoked, so that it can deal with its own resetting. Lastly,
    the `tileSelector` interface is hidden here as well.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful little method is for resetting the zoom of the current view
    to a normal level:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: By dividing `1.f` by the current zoom factor, we obtain a scale value, which,
    when scaled by, the view returns to its normal state.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us see what needs to happen in order for this class to change its
    `ControlMode`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: After the tools are reset, the mode passed in as the argument is stored. If
    the mode being applied is a brush, it needs to be re-drawn. Lastly, the `selectionOptions`
    class is notified of the mode change, so that it can perform its own logic.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, one of the last key pieces of code is the creation of a new map:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: First, we obtain the size values from the text-fields of the map settings interface.
    In addition to that, we also grab the friction value, as well as the current selection
    of the tile-sheet drop–down menu. If the latter is empty, we simply return, as
    no tile-sheet has been selected.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: If we do proceed, the particle system and the map both need to be purged. The
    `MapEditor` state is then notified to reset its save path, which forces the user
    to re-enter a filename when saving.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The map's size is then set up, alongside the default friction value. The selected
    tile-sheet file is added for further loading in a separate thread, and its name
    is registered inside the game map's internal `TileSet` data member.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the loading state is obtained, the tile-set is added to it, and the
    manual continue flag is set to `false`, in order to make the loading screen simply
    go back to the current state after it is done. The new map settings interface
    is then hidden, and we can finally switch to the loading state.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'In case a mistake happens, the user must have a way to close the new `m_mapSettings`
    interface:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This callback gets invoked when the **close** button of the interface is pressed.
    All it does is simply hiding it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have a bunch of setters and getters that do not add up to much
    on their own, but are useful in the long run:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You may have noticed that we have not yet covered the bucket and eraser tools.
    This is what is usually referred to as homework, which should serve as good practice:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Keep in mind that as we have not yet implemented everything that makes the map
    editor tick, this should probably wait until the next chapter is wrapped up.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced and implemented the concept of graphical
    file management, as well as laid the foundations for one of the most important
    tools a small RPG-style game uses. There is still a lot left to do before we can
    start reaping the benefits of having proper tools. In the next chapter, we will
    be covering the finishing touches of the map editor, as well as implementing a
    different tool for managing entities. See you there!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
