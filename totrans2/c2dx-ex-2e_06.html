<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Quick and Easy Sprite – Victorian Rush Hour</h1></div></div></div><p class="calibre6">
<em class="calibre8">In our fourth example of a game built with Cocos2d-x, I'll show you a simple technique for rapid prototyping. Often in game development, you want to test the core ideas of your game as soon as possible, because a game may sound fun in your head but in reality it just doesn't work. Rapid prototyping techniques allow you to test your game as early as possible in the development process as well as build up on the good ideas.</em>
</p><p class="calibre6">Here's what you'll learn:</p><div><ul class="itemizedlist"><li class="listitem">How to quickly create placeholder sprites</li><li class="listitem">How to code collisions for a platform game</li><li class="listitem">How to create varied terrain for a side-scroller</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec81" class="calibre1"/>The game – Victorian Rush Hour</h1></div></div></div><p class="calibre6">In <a id="id219" class="calibre1"/>this game (Victorian Rush Hour), you control a cyclist in Victorian London trying to avoid rush-hour traffic on his way home. For reasons no one can explain, he's riding his bike on top of the buildings. As the player, it is your job to ensure he makes it.</p><p class="calibre6">The controls are very simple: you tap the screen to make the cyclist jump and while he's in the air, if you tap the screen again, the cyclist will open his trusty umbrella, either slowing his descent or adding a boost to his jump.</p><p class="calibre6">This game is of a type commonly known as a dash game or endless runner, a genre that has become increasingly popular online and on various app stores. Usually in these types of games you, the developer, have two choices: either make the terrain the main obstacle and challenge in the game, or make what's added to the terrain the main challenge (enemies, pick-ups, obstacles, and so on). With this game, I decided on the first option.</p><p class="calibre6">So our challenge<a id="id220" class="calibre1"/> is to create a game where the terrain is the enemy but not an unbeatable one.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec82" class="calibre1"/>The game settings</h1></div></div></div><p class="calibre6">The <a id="id221" class="calibre1"/>game is a universal application, designed for the iPad retina display but with support for other display sizes. It is played in the landscape mode and it does not support multitouch.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec83" class="calibre1"/>Rapid prototyping with Cocos2d-x</h1></div></div></div><p class="calibre6">The idea behind this is to create sprites as placeholders for your game elements as quickly as possible, so you can test your game ideas and refine them. Every game in this book was initially developed in the way I'm about to show you, with simple rectangles in place of textured sprites.</p><p class="calibre6">The<a id="id222" class="calibre1"/> technique shown here allows you to create rectangles of any size and of any color to be used in your game logic:</p><div><img src="img/00020.jpeg" alt="Rapid prototyping with Cocos2d-x" class="calibre9"/></div><p class="calibre10"> </p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec84" class="calibre1"/>Time for action – creating placeholder sprites</h1></div></div></div><p class="calibre6">So let<a id="id223" class="calibre1"/> me show you how to do that:</p><div><ol class="orderedlist"><li class="listitem" value="1">Go ahead and download the <code class="email">4198_06_START_PROJECT.zip</code> file if you haven't done so already.</li><li class="listitem" value="2">When you open the project in Xcode, you will see all the classes we'll need for the game, and we'll go over them in a second. But for now, just go to <code class="email">GameLayer.cpp</code>.</li><li class="listitem" value="3">Scroll down to the<a id="id224" class="calibre1"/> last <code class="email">createGameScreen</code> method and add the following lines:<div><pre class="programlisting">auto quickSprite = Sprite::create("blank.png");
quickSprite-&gt;setTextureRect(Rect(0, 0, 100, 100));
quickSprite-&gt;setColor(Color3B(255,255,255));

quickSprite-&gt;setPosition(Vec2(_screenSize.width * 0.5, _screenSize.height * 0.5));
this-&gt;addChild(quickSprite);</pre></div><p class="calibre13">And that's it. The sprite is created with a texture called <code class="email">blank.png</code>. This is a 1 x 1 pixel white square you will find in the <code class="email">Resources</code> folder. Then we set the size of the sprite's texture rectangle to 100 x 100 pixels (<code class="email">setTextureRect</code>), and fill it with a white color (<code class="email">setColor</code>). By resizing the texture rectangle, we in effect resize the sprite. If you run the game now, you should see a white square smack in the middle of the screen.</p></li><li class="listitem" value="4">Now delete the previous lines and replace them with these:<div><pre class="programlisting">_gameBatchNode = SpriteBatchNode::create("blank.png", 200);
this-&gt;addChild(_gameBatchNode, kMiddleground);</pre></div><p class="calibre13">This creates <code class="email">_gameBatchNode</code> that uses as its source texture the same <code class="email">blank.png</code> file. Now we are ready to place as many rectangles inside <code class="email">_gameBatchNode</code> as we'd like, and set a different color for each one of them if we want. We can, in other words, build an entire test game with one tiny image. Which is what we'll proceed to do now.</p></li><li class="listitem" value="5">So, to finish up here, add these last lines:<div><pre class="programlisting">_terrain = Terrain::create();
_gameBatchNode-&gt;addChild(_terrain, kMiddleground);
    
_player = Player::create();
_gameBatchNode-&gt;addChild(_player, kBackground);</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec74" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We just created a placeholder sprite we can use to test gameplay ideas quickly and painlessly. And we created our game's two main objects: the <code class="email">Player</code> and <code class="email">Terrain</code> object. These are empty shells at the moment, but we'll start working on them next. But first let's go over the different game elements.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec85" class="calibre1"/>The Player object</h1></div></div></div><p class="calibre6">This<a id="id225" class="calibre1"/> represents our cyclist. It will jump, float, and collide with the <code class="email">_terrain</code> object. Its <code class="email">x</code> speed is passed to the <code class="email">_terrain</code> object causing the <code class="email">Terrain</code> object to move, side scrolling to the left of the screen.</p><p class="calibre6">The <code class="email">Player</code> object derives, once again, from a <code class="email">GameSprite</code> class. This one has getters and setters for next position, vector of movement, and the sprite's width and height.</p><p class="calibre6">The <code class="email">Player</code> interface has inline helper methods to retrieve information about its rectangle boundaries related to its current position (left, right, top, bottom), and its next position (<code class="email">next_left</code>, <code class="email">next_right</code>, <code class="email">next_top</code>, <code class="email">next_bottom</code>). These will be used in collision detection with the <code class="email">_terrain</code> object.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec86" class="calibre1"/>The Block object</h1></div></div></div><p class="calibre6">These<a id="id226" class="calibre1"/> objects form the individual pieces of the <code class="email">_terrain</code> object. They can take the shape of a building, or an empty gap between buildings. We'll have four different types of buildings, which later will represent four different types of textures when we finally bring in our sprite sheets. These blocks can have different widths and heights.</p><p class="calibre6">
<code class="email">Block</code> also derives from <code class="email">GameSprite</code> and it also has inline helper methods to retrieve information about its boundaries, but only in relation to its current position, since <code class="email">Block</code> doesn't technically move.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec87" class="calibre1"/>The terrain object</h1></div></div></div><p class="calibre6">This <a id="id227" class="calibre1"/>object contains the individual <code class="email">Block</code> objects that form the landscape. It contains just enough <code class="email">Block</code> objects to fill the screen, and as the <code class="email">_terrain</code> object scrolls to the left, the <code class="email">Block</code> objects that leave the screen are moved to the far right side of the <code class="email">_terrain</code> and reused as new blocks, ensuring continuous scrolling.</p><p class="calibre6">The <code class="email">_terrain</code> object is also responsible for collision checks with the <code class="email">_player</code> object, since it has quick access to all information we'll need for collision detection; namely the list of blocks currently on the screen, their size, type, and position. Our main loop then will call on the <code class="email">Terrain</code> object to test for collision with the <code class="email">player</code> object.</p><p class="calibre6">Let's work on these main objects, starting with the <code class="email">Player</code> object.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec88" class="calibre1"/>Time for action – coding the player</h1></div></div></div><p class="calibre6">Open <a id="id228" class="calibre1"/>up the <code class="email">Player.cpp</code> class.</p><div><ol class="orderedlist"><li class="listitem" value="1">The <code class="email">_player</code> object is created through a static method that uses our <code class="email">blank.png</code> file to texture the sprite. That method also makes a call to <code class="email">initPlayer</code>, and this is what you should type for that method:<div><pre class="programlisting">void Player::initPlayer () {
    this-&gt;setAnchorPoint(Vec2(0.5f, 1.0f));
    this-&gt;setPosition(Vec2(_screenSize.width * 0.2f, _nextPosition.y));
    
    _height = 228;
    _width = 180;
    this-&gt;setTextureRect(Rect(0, 0, _width, _height));
    this-&gt;setColor(Color3B(255,255,255));
}</pre></div><p class="calibre13">The <code class="email">_player</code> object will have its registration point at the top of the sprite. The reason<a id="id229" class="calibre1"/> behind this top center anchor point has much more to do with the way the <code class="email">_player</code> object will be animated when floating, than with any collision logic requirements.</p></li><li class="listitem" value="2">Next comes <code class="email">setFloating</code>:<div><pre class="programlisting">void Player::setFloating (bool value) {
    
    if (_floating == value) return;
    
    if (value &amp;&amp; _hasFloated) return;
    
    _floating = value;
    
    if (value) {
        _hasFloated = true;
        _vector.y += PLAYER_JUMP * 0.5f;
    }
}</pre></div><p class="calibre13">The <code class="email">_hasFloated</code> property will ensure the player can only open the umbrella once while in the air. And when we set <code class="email">_floating</code> to <code class="email">true</code>, we give the <code class="email">_player.y</code> vector a boost.</p></li><li class="listitem" value="3">We begin the update method of <code class="email">_player</code> with:<div><pre class="programlisting">void Player::update (float dt) {
    if (_speed + P_ACCELERATION &lt;= _maxSpeed) {
        _speed += P_ACCELERATION;
    } else {
        _speed = _maxSpeed;
    }
    
    _vector.x = _speed;</pre></div><p class="calibre13">The game will increase <code class="email">_maxSpeed</code> of the <code class="email">_player</code> object as time goes on, making the game more difficult. These first lines make the change from the <code class="email">_players</code> current <code class="email">_speed</code> up to <code class="email">_maxSpeed</code> a bit smoother and not an immediate change.</p><div><h3 class="title2"><a id="note14" class="calibre1"/>Note</h3><p class="calibre6">Victorian Rush Hour has no levels, so it's important to figure out a way to make<a id="id230" class="calibre1"/> it incrementally harder to play, and yet not impossible. Finding that sweet spot in your logic may take some time and it's one more reason to test game ideas as soon as possible. Here we make the game harder by increasing the player's speed and the size of the gaps between buildings. These are updated inside a countdown in the main loop.</p></div></li><li class="listitem" value="4">Next, we update the <code class="email">_player</code> object based on its <code class="email">_state</code> of movement:<div><pre class="programlisting">switch (_state) {
    
    case kPlayerMoving:
        _vector.y -= FORCE_GRAVITY;
        if (_hasFloated) _hasFloated = false;
        break;

   case kPlayerFalling:
      if (_floating ) {
         _vector.y -= FLOATNG_GRAVITY;
         _vector.x *= FLOATING_FRICTION;

      } else {
         _vector.y -= FORCE_GRAVITY;
         _vector.x *= AIR_FRICTION;
         _floatingTimer = 0;
      }
      break;

   case kPlayerDying:
      _vector.y -= FORCE_GRAVITY;
      _vector.x = -_speed;
      this-&gt;setPositionX(this-&gt;getPositionX() + _vector.x);
      break;

}</pre></div><p class="calibre13">We have different values for gravity and friction depending on move state.</p><p class="calibre13">We also have a time limit for how long the <code class="email">_player</code> object can be floating, and we reset that timer when the <code class="email">_player</code> object is not floating. If the <code class="email">_player</code> object is dying (collided with a wall), we move the <code class="email">_player</code> object backward and downward until it leaves the screen.</p></li><li class="listitem" value="5">We finish with:<div><pre class="programlisting">    if (_jumping) {
        _state = kPlayerFalling;
        _vector.y += PLAYER_JUMP * 0.25f;
        if (_vector.y &gt; PLAYER_JUMP ) _jumping = false;
    }
    
    if (_vector.y &lt; -TERMINAL_VELOCITY) 
        _vector.y = -TERMINAL_VELOCITY;
    
    _nextPosition.y = this-&gt;getPositionY() + _vector.y;
    
    if (_floating) {
        _floatingTimer += dt;
        if (_floatingTimer &gt; _floatingTimerMax) {
            _floatingTimer = 0;
            this-&gt;setFloating(false);
        }
    }
}</pre></div><p class="calibre13">When the<a id="id231" class="calibre1"/> player presses the screen for a jump, we shouldn't make the sprite jump immediately. Changes in state should always happen smoothly. So we have a <code class="email">boolean</code> property in <code class="email">_player</code> called <code class="email">_jumping</code>. It is set to <code class="email">true</code> when the player presses the screen and we slowly add the jump force to <code class="email">_vector.y</code>. So the longer the player presses the screen, the higher the jump will be and a quick tap will result in a shorter jump. This is a nice feature to add to any platform game.</p><p class="calibre13">We next limit the <code class="email">y</code> speed with a terminal velocity, update the next position of the <code class="email">_player</code> object, and update the floating timer if <code class="email">_player</code> is floating.</p></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec75" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">The <code class="email">_player</code> object is updated through a series of states. Touching the screen will make changes to this <code class="email">_state</code> property, as will the results of collision checking with <code class="email">_terrain</code>.</p><p class="calibre6">Now let's work on the <code class="email">Block</code> class.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec89" class="calibre1"/>Time for action – coding the Block object</h1></div></div></div><p class="calibre6">Once <a id="id232" class="calibre1"/>again a static method, <code class="email">create</code>, will use <code class="email">blank.png</code> to create our <code class="email">Block</code> sprite. Only this time, we don't actually change the texture rectangle for <code class="email">Block</code> inside <code class="email">create</code>:</p><div><ol class="orderedlist"><li class="listitem" value="1">The <code class="email">Block</code> object is properly textured inside the <code class="email">setupBlock</code> method:<div><pre class="programlisting">void Block::setupBlock (int width, int height, int type) {
    
    _type = type;
    
    _width = width * _tileWidth;
    _height = height * _tileHeight;
    
    this-&gt;setAnchorPoint(Vec2(0,0));
    this-&gt;setTextureRect(Rect(0, 0, _width, _height));</pre></div><p class="calibre13">A <code class="email">Block</code> object's appearance will be based on its type, width, and height.</p><p class="calibre13">The <code class="email">Block</code> sprite's registration point is set to top left. And we finally change the <code class="email">Block</code> object's texture rectangle size here.</p></li><li class="listitem" value="2">Then <a id="id233" class="calibre1"/>we set the <code class="email">Block</code> object's color based on type:<div><pre class="programlisting">    switch (type) {
        
        case kBlockGap:
            this-&gt;setVisible(false);
            return;
            
        case kBlock1:
            
            this-&gt;setColor(Color3B(200,200,200));
            break;
        case kBlock2:
            
            this-&gt;setColor(Color3B(150,150,150));
            break;
        case kBlock3:
            
            this-&gt;setColor(Color3B(100,100,100));
            break;
        case kBlock4:
            
            this-&gt;setColor(Color3B(50,50,50));
        break;
    }
    
    this-&gt;setVisible(true);
   
}</pre></div><p class="calibre13">
<code class="email">kBlockGap</code> means there is no building, just a gap the <code class="email">_player</code> object must jump. We make the block invisible in that case and return from the function. So again, gaps are actually types of blocks in our logic.</p></li></ol><div></div><p class="calibre6">In<a id="id234" class="calibre1"/> this test version, the different types of buildings are represented with different colors. Later we'll use different textures.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec76" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">The <code class="email">Block</code> object is very simple. We just need its values for <code class="email">_width</code> and <code class="email">_height</code> whether it's a gap or not, so we can properly run collision detection with these objects.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec77" class="calibre1"/>Planning the Terrain class</h2></div></div></div><p class="calibre6">Before we <a id="id235" class="calibre1"/>jump to coding the <code class="email">Terrain</code> class, we need to discuss a few things regarding randomness.</p><p class="calibre6">It is a very common mistake among game developers to confuse randomness with variableness, and very important to know when you need what.</p><p class="calibre6">A random number can be anything. 1234 is a random series of numbers. And the next time you want a random series of numbers and you once again get 1234 this will be just as random as the previous one. But not varied.</p><p class="calibre6">If you decide to build a random terrain, you will probably be disappointed in the result as it won't necessarily be varied. Also, remember that we need to make the terrain the key challenge of the game; but this means it can be neither too easy nor too difficult. True randomness would not allow us enough control here, or worse, we would end up with a long list of conditionals to make sure we have the correct combination of blocks, and that would result in at least one recurrent function inside our main loop, which is not a good idea.</p><p class="calibre6">We need instead to control the results and their variableness by applying our own patterns to them.</p><p class="calibre6">So we'll apply this logic of patterns to our <code class="email">_terrain</code> object, forming a kind of pool of proper random choices. We'll use four arrays to store possible results in our decision making, and we'll shuffle three of these arrays during the game to add the "randomness" feel to our terrain.</p><p class="calibre6">These arrays are:</p><div><pre class="programlisting">int patterns[] = {1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,3,3,3};</pre></div><p class="calibre6">This holds the information of how many buildings (<code class="email">Blocks</code>) we have in a row, between gaps.</p><p class="calibre6">You can easily change the <code class="email">patterns</code> value just by adding new values or by increasing or reducing the number of times one value appears. So here we're making a terrain with far more groupings of two buildings between gaps, than groups of three or one.</p><p class="calibre6">Next, consider the following lines:</p><div><pre class="programlisting">int widths[] = {2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,4,4};
int heights[] =  {0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,2,3,3,3,3,3,3,4};</pre></div><p class="calibre6">The <a id="id236" class="calibre1"/>preceding lines specify the widths and heights of each new building. These will be multiplied with the tile size determined for our game to get the final width and height values as you saw in <code class="email">Block:setupBlock</code>.</p><p class="calibre6">We'll use a <code class="email">0</code> value for height to mean there is no change in height from the previous building. A similar logic could be easily applied to widths.</p><p class="calibre6">And finally:</p><div><pre class="programlisting">int types[] =  {1,2,3,4,1,3,2,4,3,2,1,4,2,3,1,4,2,3,1,2,3,2,3,4,1,2,4,3,1,3,1,4,2,4,2,1,2,3};</pre></div><p class="calibre6">These are building types and this array will not be shuffled unlike the three previous ones, so this is the <code class="email">patterns</code> array of <code class="email">types</code> we'll use throughout the game and it will loop continuously. You can make it as long as you wish.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec78" class="calibre1"/>Building the terrain object</h2></div></div></div><p class="calibre6">So every<a id="id237" class="calibre1"/> time we need to create a new block, we'll set it up based on the information contained in these arrays.</p><p class="calibre6">This gives us far more control over the terrain, so that we don't create impossible combinations of obstacles for the player: a common mistake in randomly-built terrain for dash games.</p><p class="calibre6">But at the same time, we can easily expand this logic to fit every possible need. For instance, we could apply level logic to our game by creating multiple versions of these arrays, so as the game gets harder, we begin sampling data from arrays that contain particularly hard combinations of values.</p><p class="calibre6">And we can still use a conditional loop to refine results even further and I'll give you at least one example of this.</p><p class="calibre6">The values you saw in the <code class="email">patterns</code> arrays will be stored inside the lists called <code class="email">_blockPattern</code>, <code class="email">_blockWidths</code>, <code class="email">_blockHeights</code>, and <code class="email">_blockTypes</code>.</p><p class="calibre6">The <code class="email">Terrain</code> class then takes care of building the game's terrain in three stages. First we initialize the <code class="email">_terrain</code> object, creating among other things a pool for <code class="email">Block</code> objects. Then we add the first blocks to the <code class="email">_terrain</code> object until a minimum width is reached to ensure the whole screen is populated with <code class="email">Blocks</code>. And finally we distribute the various block objects.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec90" class="calibre1"/>Time for action – initializing our Terrain class</h1></div></div></div><p class="calibre6">We'll <a id="id238" class="calibre1"/>go over these steps next:</p><div><ol class="orderedlist"><li class="listitem" value="1">The first important method to implement is <code class="email">initTerrain</code>:<div><pre class="programlisting">void Terrain::initTerrain () {
    
    _increaseGapInterval = 5000;
    _increaseGapTimer = 0;
    _gapSize = 2;
    
    //init object pools
    for (int i = 0; i &lt; 20; i++) {
          auto block = Block::create();
          this-&gt;addChild(block);
          _blockPool.pushBack(block);
    }

   _minTerrainWidth = _screenSize.width * 1.5f;
   
    random_shuffle(_blockPattern.begin(), _blockPattern.end());
    random_shuffle(_blockWidths.begin(), _blockWidths.end());
    random_shuffle(_blockHeights.begin(), _blockHeights.end());
   
   this-&gt;addBlocks(0);
}</pre></div><p class="calibre13">We have a timer to increase the width of gaps (we begin with gaps two tiles long).</p><p class="calibre13">We create a pool for blocks so we don't instantiate any during the game. And <code class="email">20</code> blocks is more than enough for what we need.</p><p class="calibre13">The blocks we are currently using in the terrain will be stored inside a <code class="email">_blocks</code> vector.</p><p class="calibre13">We determine that the minimum width the <code class="email">_terrain</code> object must have is <code class="email">1.5</code> times the screen width. We'll keep adding blocks until the <code class="email">_terrain</code> object reaches this minimum width. We end by shuffling the <code class="email">patterns</code> arrays and adding the blocks.</p></li><li class="listitem" value="2">The <code class="email">addBlocks</code> method should look like this:<div><pre class="programlisting">void Terrain::addBlocks(int currentWidth) {

    while (currentWidth &lt; _minTerrainWidth)
   {   
      auto block = _blockPool.at(_blockPoolIndex);
      _blockPoolIndex++;
      if (_blockPoolIndex == _blockPool.size()) {
        _blockPoolIndex = 0;
      }
      this-&gt;initBlock(block);
      currentWidth +=  block-&gt;getWidth();
      _blocks.pushBack(block);
   }
   this-&gt;distributeBlocks();
}</pre></div><p class="calibre13">The logic inside the <code class="email">while</code> loop will continue to add blocks until <code class="email">currentWidth</code> of the <code class="email">_terrain</code> object reaches <code class="email">_minTerrainWidth</code>. Every new block we retrieve from the pool in order to reach <code class="email">_minTerrainWidth</code> gets added to the <code class="email">_blocks</code> vector.</p></li><li class="listitem" value="3">Blocks <a id="id239" class="calibre1"/>are distributed based on their widths:<div><pre class="programlisting">void Terrain::distributeBlocks() {
    int count = (int) _blocks.size();
    int i;
   
   for (i = 0; i &lt; count; i++) {
      auto block =  _blocks.at(i);
      if (i != 0) {
        auto prev_block = _blocks.at(i - 1);
        block-&gt;setPositionX( prev_block-&gt;getPositionX() + prev_block-&gt;getWidth());
      }
      else
      {
        block-&gt;setPositionX ( 0 ); 
      }
   }
}</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec79" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">
<code class="email">Terrain</code> is a container of <code class="email">Blocks</code>, and we just added the logic that will add a new <code class="email">block</code> object to this container. Inside <code class="email">addBlocks</code>, we call an <code class="email">initBlock</code> method, which will use the information from our <code class="email">patterns</code> arrays to initialize each block used in the terrain. It is this method we'll implement next.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec91" class="calibre1"/>Time for action – initializing our Blocks object</h1></div></div></div><p class="calibre6">Finally, we<a id="id240" class="calibre1"/> will discuss the method that initializes the blocks based on our <code class="email">patterns</code> array:</p><div><ol class="orderedlist"><li class="listitem" value="1">So inside the <code class="email">Terrain</code> class, we start the <code class="email">initBlock</code> method as follows:<div><pre class="programlisting">void Terrain::initBlock(Block * block) {

    int blockWidth;
    int blockHeight;
    
    int type = _blockTypes[_currentTypeIndex];
    _currentTypeIndex++;

    if (_currentTypeIndex == _blockTypes.size()) {
        _currentTypeIndex = 0;
    }</pre></div><p class="calibre13">Begin by <a id="id241" class="calibre1"/>determining the type of building we are initializing. See how we loop through the <code class="email">_blockTypes</code> array using the index stored in <code class="email">_currentTypeIndex</code>. We'll use a similar logic for the other <code class="email">patterns</code> arrays.</p></li><li class="listitem" value="2">Then, let's start building our blocks:<div><pre class="programlisting">if (_startTerrain) {
   //...
} else {
    _lastBlockHeight = 2;
    _lastBlockWidth = rand() % 2 + 2;
    block-&gt;setupBlock (_lastBlockWidth, _lastBlockHeight, type);
}</pre></div><p class="calibre13">The player must tap the screen to begin the game (<code class="email">_startTerrain</code>). Until then, we show buildings with the same height (two tiles) and random width:</p><div><img src="img/00021.jpeg" alt="Time for action – initializing our Blocks object" class="calibre9"/></div><p class="calibre14"> </p><p class="calibre13">We will store <code class="email">_lastBlockHeight</code> and <code class="email">_lastBlockWidth</code> because the more information we have about the terrain the better we can apply our own conditions to it, as you will see in a moment.</p></li><li class="listitem" value="3">Consider that we are set to <code class="email">_startTerrain</code>:<div><pre class="programlisting">if (_startTerrain) {
    if (_showGap) {
        int gap = rand() % _gapSize;
        if (gap &lt; 2) gap = 2;

        block-&gt;setupBlock (gap, 0, kBlockGap);
        _showGap = false;
    } else {
        //...</pre></div><p class="calibre13">In the following screenshot, you can see the different widths used for our blocks:</p><div><img src="img/00022.jpeg" alt="Time for action – initializing our Blocks object" class="calibre9"/></div><p class="calibre14"> </p><p class="calibre13">The<a id="id242" class="calibre1"/> information inside <code class="email">_blockPattern</code> determines how many buildings we show in a row, and once a series is completed, we show a gap by setting the <code class="email">boolean</code> value of <code class="email">_showGap</code> to <code class="email">true</code>. A gap's width is based on the current value of <code class="email">_gapSize</code>, which may increase as the game gets harder and it can't be less than two times the tile width.</p></li><li class="listitem" value="4">If we are not creating a gap this time, we determine the width and height of the new block based on the current indexed values of <code class="email">_blockWidths</code> and <code class="email">_blockHeights</code>:<div><pre class="programlisting">} else {
    
    blockWidth = _blockWidths[_currentWidthIndex];

    _currentWidthIndex++;
    if (_currentWidthIndex == _blockWidths.size()) {
        random_shuffle(_blockWidths.begin(),  _blockWidths.end());
        _currentWidthIndex = 0;
    }

    if (_blockHeights[_currentHeightIndex] != 0) {

        //change height of next block
        blockHeight = _blockHeights[_currentHeightIndex];
        //if difference too high, decrease it
        if (blockHeight - _lastBlockHeight &gt; 2 &amp;&amp; _gapSize ==  2)  
        {
            blockHeight = 1;
        }

    } else {
        blockHeight = _lastBlockHeight;
    }
    _currentHeightIndex++;
    if (_currentHeightIndex == _blockHeights.size()) {
        _currentHeightIndex = 0;
        random_shuffle(_blockHeights.begin(),  _blockHeights.end());
    }
            
    block-&gt;setupBlock (blockWidth, blockHeight, type);
    _lastBlockWidth = blockWidth;
    _lastBlockHeight = blockHeight;</pre></div><p class="calibre13">Notice how we reshuffle the arrays once we are done iterating through them (<code class="email">random_shuffle</code>).</p><p class="calibre13">We <a id="id243" class="calibre1"/>use <code class="email">_lastBlockHeight</code> to apply an extra condition to our terrain. We don't want the next block to be too tall in relation to the previous building, at least not in the beginning of the game, which we can determine by checking the value for <code class="email">_gapSize</code>, which is only increased when the game gets harder.</p><p class="calibre13">And if the value from <code class="email">_blockHeights</code> is <code class="email">0</code>, we don't change the height of the new building and use instead the same value from <code class="email">_lastBlockHeight</code>.</p></li><li class="listitem" value="5">We finish by updating the count in the current series of buildings to determine whether we should show a gap next, or not:<div><pre class="programlisting">//select next block series pattern
_currentPatternCnt++;

if (_currentPatternCnt &gt; _blockPattern[_currentPatternIndex]) {
    _showGap = true;
    //start new pattern
    _currentPatternIndex++;
    if (_currentPatternIndex == _blockPattern.size()) {
        random_shuffle(_blockPattern.begin(),  _blockPattern.end());
        _currentPatternIndex = 0;
    }
    _currentPatternCnt = 1;
    }
}</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec80" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We<a id="id244" class="calibre1"/> finally got to use our <code class="email">patterns</code> arrays and build the blocks inside the terrain. The possibilities are endless here in how much control we can have in building our blocks. But the key idea here is to make sure the game does not become ridiculously hard, and I advise you to play some more with the values to achieve even better results (don't take my choices for granted).</p><p class="calibre6">Before we tackle collision, let's add the logic to move and reset the terrain.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec92" class="calibre1"/>Time for action – moving and resetting</h1></div></div></div><p class="calibre6">We move <a id="id245" class="calibre1"/>the terrain inside the <code class="email">move</code> method.</p><div><ol class="orderedlist"><li class="listitem" value="1">The <code class="email">move</code> method <a id="id246" class="calibre1"/>receives as a parameter the amount of movement in the <code class="email">x</code> axis:<div><pre class="programlisting">void Terrain::move (float xMove) {
    if (xMove &lt; 0) return;

    if (_startTerrain) {
        
        if (xMove &gt; 0 &amp;&amp; _gapSize &lt; 5)              _increaseGapTimer += xMove;
        
        if (_increaseGapTimer &gt; _increaseGapInterval) {
            _increaseGapTimer = 0;
            _gapSize += 1;
        }
    }
    
    this-&gt;setPositionX(this-&gt;getPositionX() - xMove);
    
   auto  block = _blocks.at(0);  
   if (_position.x + block-&gt;getWidth() &lt; 0) {
      auto firstBlock = _blocks.at(0);
      _blocks.erase(0);
      _blocks.pushBack(firstBlock);
      _position.x +=  block-&gt;getWidth();
      
      float width_cnt = this-&gt;getWidth() - block-&gt;getWidth() - ( _blocks.at(0))-&gt;getWidth();
      this-&gt;initBlock(block);
      this-&gt;addBlocks(width_cnt);
    }
}</pre></div><p class="calibre13">The<a id="id247" class="calibre1"/> value for <code class="email">xMove</code> comes from the <code class="email">_player</code> speed.</p><p class="calibre13">We start by <a id="id248" class="calibre1"/>updating the timer that will make the gaps wider. Then we move the terrain to the left. If after moving the terrain, a block leaves the screen, we move the block back to the end of the <code class="email">_blocks</code> vector and reinitialize it as a new block through <code class="email">initBlock</code>.</p><p class="calibre13">We make a call to <code class="email">addBlocks</code> just in case the reinitialized block made the total width of the terrain less than the minimum width required.</p></li><li class="listitem" value="2">Next, our <code class="email">reset</code> method:<div><pre class="programlisting">void Terrain::reset() {
    
    this-&gt;setPosition(Vec2(0,0));
    _startTerrain = false;
    
    int currentWidth = 0;
    for (auto block : _blocks) {
       this-&gt;initBlock(block);
       currentWidth +=  block-&gt;getWidth();
    }
    
   while (currentWidth &lt; _minTerrainWidth) {
        auto block = _blockPool.at(_blockPoolIndex);
        _blockPoolIndex++;
        if (_blockPoolIndex == _blockPool.size()) {
            _blockPoolIndex = 0;
        }
        _blocks.pushBack(block);
        this-&gt;initBlock(block);
        currentWidth +=  block-&gt;getWidth();
   }
    
   this-&gt;distributeBlocks();
    _increaseGapTimer = 0;
    _gapSize = 2;
}</pre></div><p class="calibre13">The <code class="email">reset</code> method is called whenever we restart the game. We move <code class="email">_terrain</code> back to its starting point, and we reinitialize all the current <code class="email">Block</code> objects currently inside the <code class="email">_terrain</code> object. This is done because we are back to <code class="email">_startTerrain = false</code>, which means all blocks should have the same<a id="id249" class="calibre1"/> height and a random width.</p><p class="calibre13">If at the<a id="id250" class="calibre1"/> end of the reset we need more blocks to reach <code class="email">_minTerrainWidth</code>, we add them accordingly.</p></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec81" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We can now move the <code class="email">_terrain</code> object and all the blocks it contains, and we can restart the process all over again if we need to.</p><p class="calibre6">Once again, using the container behavior of nodes simplified our job tremendously. When you scroll the terrain, you scroll all the <code class="email">Block</code> objects it contains.</p><p class="calibre6">So we are finally ready to run collision logic.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec93" class="calibre1"/>Platform collision logic</h1></div></div></div><p class="calibre6">We have in<a id="id251" class="calibre1"/> place all the information we need to check for collision through the inline methods found in <code class="email">Player</code> and <code class="email">Block</code>.</p><p class="calibre6">In this game, we'll need to check collision between the <code class="email">_player</code> object's bottom side and the <code class="email">block</code> object's top side, and between the <code class="email">_player</code> object's right side and the <code class="email">Block</code> class' left side. And we'll do that by checking the <code class="email">_player</code> object's current position and its next position. We are looking for these conditions:</p><div><img src="img/00023.jpeg" alt="Platform collision logic" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre6">The diagram represents the conditions for bottom side collision, but the same idea applies to right side collision.</p><p class="calibre6">In the current position, the <code class="email">_player</code> object must be above the top of the block or touching it. In the next position, the <code class="email">_player</code> object must be either touching the top of the block or already<a id="id252" class="calibre1"/> overlapping it (or has moved past it altogether). This would mean a collision has occurred.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec94" class="calibre1"/>Time for action – adding collision detection</h1></div></div></div><p class="calibre6">Let's see <a id="id253" class="calibre1"/>how that translates to code:</p><div><ol class="orderedlist"><li class="listitem" value="1">Still in <code class="email">Terrain.cpp</code>:<div><pre class="programlisting">void Terrain::checkCollision (Player * player) {

   if (player-&gt;getState() == kPlayerDying) return;
   bool inAir = true;
   for (auto block : _blocks) {
      if (block-&gt;getType() == kBlockGap) continue;
      
      //if within x, check y (bottom collision)
      if (player-&gt;right() &gt;= this-&gt;getPositionX() + block-&gt;left() &amp;&amp; player-&gt;left() &lt;= this-&gt;getPositionX() + block-&gt;right()) {
            
        if (player-&gt;bottom() &gt;= block-&gt;top() &amp;&amp; player-&gt;next_bottom() &lt;= block-&gt;top() &amp;&amp; player-&gt;top() &gt; block-&gt;top()) {
           player-&gt;setNextPosition(Vec2(player-&gt;getNextPosition().x, block-&gt;top() + player-&gt;getHeight()));
           player-&gt;setVector ( Vec2(player-&gt;getVector().x, 0) );
           player-&gt;setRotation(0.0);
           inAir = false;
           break;
         }       
      }
   }</pre></div><p class="calibre13">First we state that the <code class="email">_player</code> object is currently falling with <code class="email">inAir = true;</code> we'll let the collision check determine if this will remain true or not.</p><p class="calibre13">We don't check the collision if <code class="email">_player</code> is dying and we skip collision checks with any gap blocks.</p><p class="calibre13">We check collision on the <code class="email">y</code> axis, which here means the bottom of the <code class="email">_player</code> and top of the block. We first need to determine if the <code class="email">_player</code> object is within range of the block we want to check against collision. This means the center of the <code class="email">_player</code> object must be between the left and right side of the block; otherwise, the block is too far from the <code class="email">_player</code> object and may be ignored.</p><p class="calibre13">Then we run a basic check to see if there is a collision between the <code class="email">_player</code> object's current position and next position, using the conditions I explained earlier. If so, we fix the <code class="email">_player</code> object's position and change its <code class="email">y</code> vector speed to <code class="email">0</code> and we determine that <code class="email">inAir = false</code> after all, the <code class="email">_player</code> object has landed.</p></li><li class="listitem" value="2">Next <a id="id254" class="calibre1"/>we check collision on the <code class="email">x</code> axis, meaning the right side of the <code class="email">_player</code> object with the left side of the blocks:<div><pre class="programlisting">for (auto block : _blocks) {
  if (block-&gt;getType() == kBlockGap) continue;
  //now if within y, check x (side collision)
  if ((player-&gt;bottom() &lt; block-&gt;top() &amp;&amp; player-&gt;top() &gt;  block-&gt;bottom()) || (player-&gt;next_bottom() &lt; block-&gt;top() &amp;&amp;  player-&gt;next_top() &gt; block-&gt;bottom())) {
   if (player-&gt;right() &gt;= this-&gt;getPositionX() + block-&gt;getPositionX()  &amp;&amp; player-&gt;left() &lt; this-&gt;getPositionX() + block-&gt;getPositionX()) {
      player-&gt;setPositionX( this-&gt;getPositionX() +  block-&gt;getPositionX() - player-&gt;getWidth() * 0.5f );
      player-&gt;setNextPosition(Vec2(this-&gt;getPositionX() +  block-&gt;getPositionX() - player-&gt;getWidth() * 0.5f,  player-&gt;getNextPosition().y));
      player-&gt;setVector ( Vec2(player-&gt;getVector().x * -0.5f,  player-&gt;getVector().y) );
      if (player-&gt;bottom() + player-&gt;getHeight() * 0.2f &lt;  block-&gt;top()) {
         player-&gt;setState(kPlayerDying);
         return;
      }
      break;
     }
  }
}</pre></div><p class="calibre13">Similar steps are used to determine if we have a viable block or not.</p><p class="calibre13">If we do have a side collision, the <code class="email">_player</code> state is changed to <code class="email">kPlayerDying</code>, we reverse its <code class="email">x</code> speed so the <code class="email">_player</code> state will move to the left and off the screen, and we return from this method.</p></li><li class="listitem" value="3">We end by updating the <code class="email">_player</code> object's state based on our collision results:<div><pre class="programlisting">    if (inAir) {
        player-&gt;setState(kPlayerFalling);
    } else {
        player-&gt;setState(kPlayerMoving);
        player-&gt;setFloating (false);
    }
}</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec82" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We just added the collision logic to our platform game. As we did in our first game, Air Hockey, we test the player's current position for collision as well as its next position to<a id="id255" class="calibre1"/> determine if a collision occurred between the current iteration and the next one. The test simply looks for overlaps between the player's and block's boundaries.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec95" class="calibre1"/>Adding the controls</h1></div></div></div><p class="calibre6">It is <a id="id256" class="calibre1"/>fairly common in a dash game such as this to have very simple controls. Often the player must only press the screen for jumping. But we spiced things up a bit, adding a floating state.</p><p class="calibre6">And remember we want smooth transitions between states, so pay attention to how jumping is implemented: not by immediately applying a force to the player's vector but by simply changing a <code class="email">boolean</code> property and letting the <code class="email">_player</code> object's update method handle the change smoothly.</p><p class="calibre6">We'll handle the touch events next.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec96" class="calibre1"/>Time for action – handling touches</h1></div></div></div><p class="calibre6">Let's go <a id="id257" class="calibre1"/>back to <code class="email">GameLayer.cpp</code> and add our game's final touches (pun intended).</p><div><ol class="orderedlist"><li class="listitem" value="1">First we work on our <code class="email">onTouchBegan</code> method:<div><pre class="programlisting">bool GameLayer::onTouchBegan(Touch* touch, Event* event) {
    
    if (!_running) {
        
        if (_player-&gt;getState() == kPlayerDying) {
            _terrain-&gt;reset();
            _player-&gt;reset();
            resetGame();
        }
        return true;
    }</pre></div><p class="calibre13">If we are not running the game and the <code class="email">_player</code> object died, we reset the game on touch.</p></li><li class="listitem" value="2">Next, if the terrain has not started, insert the following:<div><pre class="programlisting">    if (!_terrain-&gt;getStartTerrain()) {
        _terrain-&gt;setStartTerrain ( true );
        return true;
    }</pre></div><p class="calibre13">Remember<a id="id258" class="calibre1"/> that at first the buildings are all the same height and there are no gaps. Once the player presses the screen, we begin changing that through <code class="email">setStartTerrain</code>.</p></li><li class="listitem" value="3">We finish with:<div><pre class="programlisting">    if (touch) {
      if (_player-&gt;getState() == kPlayerFalling) {
            _player-&gt;setFloating ( _player-&gt;getFloating() ? false : true );
        
       } else {
            
          if (_player-&gt;getState() !=  kPlayerDying) _player-&gt;setJumping(true);
       }
       return true;
    }
    return false;
}</pre></div><p class="calibre13">Now we are in play, and if the <code class="email">_player</code> object is falling, we either open or close the umbrella, whichever the case may be, through a call to <code class="email">setFloating</code>.</p><p class="calibre13">And if the <code class="email">_player</code> object is not falling, nor dying, we make it jump with <code class="email">setJumping(true)</code>.</p></li><li class="listitem" value="4">With touches ended, we just need to stop any jumps:<div><pre class="programlisting">void GameLayer::onTouchEnded(Touch* touch, Event* event) {
    _player-&gt;setJumping(false);
}</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec83" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We added the logic for the game's controls. The <code class="email">_player</code> object will change to floating if currently falling or to jumping if currently riding on top of a building.</p><p class="calibre6">It's time to add our main game loop.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec97" class="calibre1"/>Time for action – coding the main loop</h1></div></div></div><p class="calibre6">Finally, it's<a id="id259" class="calibre1"/> time for the last part in our logic.</p><div><ol class="orderedlist"><li class="listitem" value="1">Inside <code class="email">GameLayer.cpp</code>:<div><pre class="programlisting">void GameLayer::update(float dt) {

    if (!_running) return;


    if (_player-&gt;getPositionY() &lt; -_player-&gt;getHeight() ||
        _player-&gt;getPositionX() &lt; -_player-&gt;getWidth() * 0.5f)  {

            _running = false;

    }</pre></div><p class="calibre13">If the <code class="email">_player</code> object is off screen, we stop the game.</p></li><li class="listitem" value="2">Now<a id="id260" class="calibre1"/> update all the elements, positions and check for collision:<div><pre class="programlisting">_player-&gt;update(dt);

    _terrain-&gt;move(_player-&gt;getVector().x);

    if (_player-&gt;getState() != kPlayerDying) 
        _terrain-&gt;checkCollision(_player);

    _player-&gt;place();</pre></div></li><li class="listitem" value="3">Move <code class="email">_gameBatchNode</code> in relation to the <code class="email">_player</code> object:<div><pre class="programlisting">if (_player-&gt;getNextPosition().y &gt; _screenSize.height * 0.6f) {
        _gameBatchNode-&gt;setPositionY( (_screenSize.height *  0.6f - _player-&gt;getNextPosition().y) * 0.8f);

    } else {
        _gameBatchNode-&gt;setPositionY  ( 0 );
    }</pre></div></li><li class="listitem" value="4">Make the game more difficult as time goes on by increasing the <code class="email">_player</code> object's maximum speed:<div><pre class="programlisting">if (_terrain-&gt;getStartTerrain() &amp;&amp; _player-&gt;getVector().x &gt; 0) {

        _speedIncreaseTimer += dt;
        if (_speedIncreaseTimer &gt; _speedIncreaseInterval) {
            _speedIncreaseTimer = 0;
            _player-&gt;setMaxSpeed (_player-&gt;getMaxSpeed() + 4);
        }
    }
    
}</pre></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec84" class="calibre1"/>
<em class="calibre8">What just happened?</em>
</h2></div></div></div><p class="calibre6">We have our test game in place. From here, we can test our terrain patterns, our speeds, and our general gameplay to find spots where things could be improved.</p><p class="calibre6">We <a id="id261" class="calibre1"/>should check in particular whether the game gets too hard too fast or whether we have combinations of buildings that are just impossible to get past.</p><p class="calibre6">I find, for instance, that starting with larger groups of buildings, say four or five, and then slowly reducing them to two and one between gaps can make the game even more fun to play, so the patterns could be changed to reflect that idea.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec98" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">Every game has a simple idea for its gameplay at its core. But often, this idea needs a whole lot of testing and improvement before we can determine whether it's fun or not, which is why rapid prototyping is vital.</p><p class="calibre6">We can use Cocos2d-x to quickly test core gameplay ideas and run them in the simulator or on a device in a matter of minutes.</p><p class="calibre6">Also, the techniques shown here can be used to build interface elements (such as the energy bar from our previous game) as well as an entire game! If you don't believe me, check out the game <em class="calibre8">Square Ball</em> in an App Store near you.</p><p class="calibre6">Now, with all the logic for gameplay in its proper place, we can proceed to making this game look good! We'll do that in the next chapter.</p></div></body></html>