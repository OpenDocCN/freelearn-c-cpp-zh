<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Intel Edison and IoT (Home Automation)</h1>
            </header>

            <article>
                
<p>In <a href="bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml" target="_blank">Chapter 2</a>, <span><em>Weather Station (IoT)</em>,</span> we dealt with transferring data from Edison to the cloud platform. Here, in this chapter, we'll be doing just the opposite. We'll be controlling devices using the Internet. When we talk about IoT, the first thing that usually comes to mind is home automation. Home automation is basically controlling and monitoring home electrical appliances using an interface, which may be a mobile application, a web interface, a wall touch unit, or more simply, your own voice. So, here in this chapter, we'll be dealing with the various concepts of home automation using the MQTT protocol; then, we'll be controlling an electrical load with an Android application and a <span><strong>Windows Presentation Foundation</strong> (</span><strong>WPF</strong>) application using the MQTT protocol. Some of the topics that we will discuss are:</p>
<ul>
<li>The various concepts of controlling devices using the Internet MQTT protocol</li>
</ul>
<ul>
<li>Using Edison to push data and get data using the MQTT protocol</li>
</ul>
<ul>
<li><span class="MsoCommentReference">L</span>ED control using the MQTT protocol</li>
</ul>
<ul>
<li>Home automation use cases using the MQTT protocol</li>
</ul>
<ul>
<li>The controller <span>application </span>in Android (MyMqtt) and in WPF (to be developed)</li>
</ul>
<p>This chapter will use a companion <span>application</span> named MyMqtt, which can be downloaded from the Play Store. Credit goes to the developer (Instant Solutions) for developing the <span>application </span>and uploading it to the Play Store for free. MyMqtt can be found here: <a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">h</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">t</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">t</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">p</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">s</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">://p</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">l</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">a</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">y</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">.</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">g</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">o</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">o</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">g</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">l</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">e</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">.</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">c</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">o</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">m</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">/s</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">t</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">o</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">r</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">e</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">/a</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">p</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">p</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">s</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">/d</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">e</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">t</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">a</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">i</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">l</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">s</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">?i</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">d</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">=a</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">t</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">.</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">t</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">r</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">i</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">p</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">w</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">i</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">r</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">e</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">.</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">m</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">q</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">t</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">t</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">.</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">c</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">l</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">i</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">e</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">n</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">t</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">&amp;h</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">l</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">=e</a><a href="https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&amp;hl=en">n</a></p>
<p>We are going to develop our own controller for PC as a WPF <span>application </span>that will implement the protocol and control your Edison.</p>
<div class="packt_infobox">To develop the WPF application, we are going to use Microsoft Visual Studio. You can download it at <a href="https://msdn.microsoft.com/">h</a><a href="https://msdn.microsoft.com/">t</a><a href="https://msdn.microsoft.com/">t</a><a href="https://msdn.microsoft.com/">p</a><a href="https://msdn.microsoft.com/">s</a><a href="https://msdn.microsoft.com/">://m</a><a href="https://msdn.microsoft.com/">s</a><a href="https://msdn.microsoft.com/">d</a><a href="https://msdn.microsoft.com/">n</a><a href="https://msdn.microsoft.com/">.</a><a href="https://msdn.microsoft.com/">m</a><a href="https://msdn.microsoft.com/">i</a><a href="https://msdn.microsoft.com/">c</a><a href="https://msdn.microsoft.com/">r</a><a href="https://msdn.microsoft.com/">o</a><a href="https://msdn.microsoft.com/">s</a><a href="https://msdn.microsoft.com/">o</a><a href="https://msdn.microsoft.com/">f</a><a href="https://msdn.microsoft.com/">t</a><a href="https://msdn.microsoft.com/">.</a><a href="https://msdn.microsoft.com/">c</a><a href="https://msdn.microsoft.com/">o</a><a href="https://msdn.microsoft.com/">m</a>.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Controlling devices using the Internet - concepts</h1>
            </header>

            <article>
                
<p>When it comes to control devices using the Internet, some key factors come to play. Firstly, is the technique to be used. There are lot of techniques in this field. A quick workaround is the use of REST services, such as HTTP <kbd>GET</kbd> requests, where we get data from an existing database.</p>
<p>Some of the workarounds are discussed here.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">REST services</h1>
            </header>

            <article>
                
<p>One of the most commonly-used techniques for obtaining the desired data is by an HTTP <kbd>GET</kbd> call. Most of the IoT platforms that exist in the market have REST APIs exposed. There, we can send values from the device to the platform using an HTTP <kbd>POST</kbd> request, and at the same time get data by an HTTP <kbd>GET</kbd> request. Infact, in <a href="bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml" target="_blank">Chapter 2</a>, <span><em>Weather Station (IoT)</em>, </span>where we used <kbd>dweet.io</kbd> to send data from a device, we used an SDK. Internally, the SDK also performs a similar HTTP <kbd>POST</kbd> call to send in data.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Instructions or alerts (present on most IoT platforms)</h1>
            </header>

            <article>
                
<p>In certain IoT platforms, we have certain ready-made solutions where we just need to call a certain web service and the connection is established. Internally, it may use REST APIs, but for the benefit of the user, they have come up with their own SDK where we implement.</p>
<p>Internally, a platform may follow either a REST call, MQTT, or Web Sockets. However, we just use an SDK where we don't implement it directly, and by using the platform's SDK, we are able to establish a connection. It is entirely platform-specific. Here, we are discussing one of the workarounds,where we use the MQTT protocol to control our devices directly without the use of any IoT platforms.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Architecture</h1>
            </header>

            <article>
                
<p>In a typical system, the IoT platform acts as a bridge between the user and the protocols to the controller, as shown in the following figure:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="331" src="assets/image001.jpg" width="587"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Architecture of the IoT system for controlling devices</div>
<p>The preceding image depicts a typical workflow or architecture of controlling devices using the Internet. It is to be noted that the user may directly control the controller without the use of an IoT platform, as we do here. However, normally a user will use the IoT platform, which also provides more enhanced security. The user may use any web interface, mobile application, or a wall control unit to control the device using any standard protocol. Here in the image, only REST, MQTT, and Web Sockets are included. However, there are more protocols that can be used, such as the AMQP protocol, the MODBUS protocol, and so on. The choice of the protocol depends mainly on how sensitive the system is and how stable the system needs to be.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">MQTT protocol overview</h1>
            </header>

            <article>
                
<p>The MQTT protocol is based on the publish-subscribe architecture. It's a very lightweight protocol, where message exchange happens asynchronously. The main usage of the MQTT protocol is in places of low bandwidth and low processing power. A small code footprint is required for establishing an MQTT connection. Every communication in the MQTT protocol happens through a medium called a broker. The broker is either subscribed or published. If you want the data to flow from Edison to a server, then you publish the data via the broker. A dashboard or an <span>application </span>subscribes to the broker with the channel credentials and provides the data. Similarly, when we control the device from any application, Edison will act as a subscriber and our <span>application </span>will act as a publisher. That's how the entire system works out. The following screenshot explains the concept:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="285" src="assets/image002.jpg" width="506"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Overflow where Edison acts as a publisher</div>
<p>In the preceding <span>screenshot</span>, we see Edison acting as a publisher. This is one type of use case, where we need to send data from Edison, as with a similar example shown in <a href="bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml" target="_blank">Chapter 2</a>, <em>Weather Station (IoT)</em>. The <span>application </span>will get the data and act as a publisher. The following <span>screenshot</span> depicts the use case that will be used in this chapter: the use of Edison as a subscriber:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="312" src="assets/image003.jpg" width="554"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Overflow where Edison acts as a subscriber</div>
<p>In the preceding case, we have some controls on the application. These controls send signals to Edison via the MQTT broker. Now, in this case, the <span>application </span>will act as a publisher and Edison acts as a subscriber.</p>
<p>It is to be noted that in a single system, you can make the endpoint (device or application) act both as a publisher as well as a subscriber. This occurs when we want to get some data from the IoT device, such as the Intel Edison, and also control the device in emergency cases. The same may also occur when we need to control the home's electrical appliances, as well as monitor them remotely. Although most systems are deployed based on a closed loop feedback control, there is always room to monitor them remotely, and at the same time have control based on feedback received from the sensors.</p>
<p>To implement the MQTT protocol, we are not going to set our own server but use an existing one. <a href="https://iot.eclipse.org/">https://iot.eclipse.org/</a> has provided a sandbox server which will be used for the upcoming projects. We're just going to set up our broker and then publish and subscribe to the broker. For the Intel Edison side, we are going for Node.js and its related libraries. For the application end, we are going to use an already available <span>application </span>named MyMqtt for Android. If anyone wants to develop his or her own application, then you need to import the <kbd>paho</kbd> library to set up MQTT. We are also developing a PC application, where we will again use MQTT to communicate.</p>
<p>For details on the eclipse IoT project on MQTT and other standards, please refer to the following link:</p>
<p><a href="https://iot.eclipse.org/standards/">https://iot.eclipse.org/standards/</a></p>
<p>In the following section, we'll set up and configure Edison for our project and also set up the development environment for the WPF application.</p>
<p>The paho project can be accessed through this link:</p>
<p><a href="https://eclipse.org/paho/">https://eclipse.org/paho/</a></p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using Intel Edison to push data by using the MQTT protocol</h1>
            </header>

            <article>
                
<p>As previously mentioned, this short section will show users how to push data from Edison to an Android device using the MQTT protocol. The following screenshot depicts the workflow:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="331" src="assets/image004.jpg" width="588"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Workflow of pushing data from the Edison to the Android application</div>
<p>From the preceding illustration, it is clear that we first obtain readings from the temperature sensor and then use the MQTT broker to push the readings to the Android application.</p>
<p>Firstly, we are going to connect the temperature sensor to Edison. Make a reference of the circuit from <a href="bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml" target="_blank">Chapter 2</a>, <em>Weather Station (IoT)</em>. After it is connected, fire up your editor to write the following Node.js code:</p>
<pre>
var mraa = require('mraa'); var mqtt = require('mqtt'); var B=4275;<br/><br/>var R0=100000;<br/><br/>var client = mqtt.connect('mqtt://iot.eclipse.org');<br/>function sendData()<br/><br/>{<br/><br/>  var tempPin=new mraa.Aio(0);<br/><br/>//Processing of temperature var a=tempPin.read();<br/><br/>  var R=1023/a-1; R=100000*R;<br/><br/>  var temperature=1/(Math.log(R/100000)/B+1/298.15)-273.15; temperature<br/>  = +temperature.toFixed(2);<br/><br/>//Converting type int to type string<br/><br/>  var sendTemp= temperature.toString();<br/><br/>//Publish the processed data client.publish('avirup/temperature',sendTemp); console.log("Sending data of temperature %d", temperature); setTimeout(sendData,1000);<br/><br/>}<br/><br/>sendData();
</pre>
<p>The code written here is similar to what we used in the <a href="bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml" target="_blank">Chapter 2</a>, <em>Weather Station (IoT)</em>. Here, the difference is that we are not sending it to <kbd>dweet.io</kbd> but to the MQTT broker. We're publishing the data obtained to a particular channel in the MQTT broker.</p>
<p>However, to execute this code, you must have the MQTT dependency installed via <kbd>npm</kbd>. Type in the following command in the PuTTY console:</p>
<pre>
<strong>npm install mqtt</strong>
</pre>
<p>This will install the MQTT dependency.</p>
<p>In the preceding code, we initially imported the required libraries or dependency. For this case, we need the <kbd>mraa</kbd> and the <kbd>mqtt</kbd> libraries:</p>
<pre>
<strong>var mraa = require('mraa'); <br/>var mqtt = require('mqtt');</strong>
</pre>
<p>Then, we need to initialize the analog pin to read the temperature. After that, we convert the raw readings to the standard value.</p>
<p>We declare the client variable, which will handle the MQTT publish operation:</p>
<pre>
<strong>var client = mqtt.connect('mqtt://iot.eclipse.org');</strong>
</pre>
<p>Here, <a href="https://iot.eclipse.org/">https://iot.eclipse.org/</a> is the free broker that we are using.</p>
<p>Next, in the <kbd>sendData</kbd> function, the initial temperature processing is computed before the data is published to the channel:</p>
<pre>
<strong>client.publish('avirup/temperature',sendTemp);</strong>
</pre>
<p>The name of the channel is <kbd>avirup/temperature</kbd>. Please note the type of <kbd>sendTemp</kbd>. The initial processed value is obtained in the variable temperature. Here in <kbd>client.publish</kbd>, the second parameter has to be a string. Thus, we store the temperature value as a string type in <kbd>sendTemp</kbd>. Finally, we print the temperature into the console.</p>
<p>We have also provided a delay of 1 second. Now run this Node.js file using the <kbd>node</kbd> command.</p>
<p>The screenshot is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="304" src="assets/6639_03_01.png" width="478"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output console log</div>
<p>As seen in the preceding screenshot, the log is displayed. Now we need to see this data in the Android MyMqtt application.</p>
<div class="packt_infobox">While carrying out this mini-project, as well as the later one to be discussed under MQTT, please change the channel name. One of my projects may be live and it could create an issue. One can go for the <kbd>NAME_OF_THE_USER/VARIABLE_NAME</kbd> convention.</div>
<p>Open up the MyMqtt <span>application </span>in Android and browse to <span class="packt_screen">Settings</span>. There, in the field of <span class="packt_screen">Broker URL</span>, insert <kbd>iot.eclipse.org</kbd>. You will have used this on your Node.js snippet as well:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="156" src="assets/6639_03_02.jpg" width="208"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Screenshot of MyMqtt—1</div>
<p>Next, go to the <span class="packt_screen">Subscribe</span> option and enter your channel name based on your Node.js code. In our case, it was <kbd>avirup/temperature</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="135" src="assets/6639_03_03.jpg" width="290"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Screenshot of MyMqtt—2</div>
<p>Click on <span class="packt_screen">Add</span> to add the channel and then finally go to the dashboard to visualize your data:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="465" src="assets/6639_03_04.jpg" width="298"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Screenshot of MyMqtt—3</div>
<p>If your code on the device is running in parallel to this, then you should get live data feed in this dashboard.</p>
<p>So, now you can visualize the data that you are sending from Edison.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Getting data to Edison by using MQTT</h1>
            </header>

            <article>
                
<p>We have been talking about home automation controlling electrical loads, but everything has a starting point. The most basic kick-starter is controlling Edison over the Internet—that's what it's all about.</p>
<p>When you have a device that is controllable over the Internet, we recommend controlling the electrical loads. In this other mini-project, we are going to control a simple LED that is already attached to pin <kbd>13</kbd> of Intel Edison. There is no need for any external hardware for this, as we are using an in-built functionality. Now, open your editor and type in the following code:</p>
<pre>
var mraa = require('mraa'); var mqtt = require('mqtt');<br/><br/>varledPin=new mraa.Gpio(13); ledPin.dir(mraa.DIR_OUT);<br/><br/>var client = mqtt.connect('mqtt://iot.eclipse.org'); client.subscribe('avirup/control/#') client.handleMessage=function(packet,callback)<br/><br/>{<br/><br/>  var payload = packet.payload.toString() console.log(payload);<br/>  if(payload=='ON')<br/><br/>  ledPin.write(1); if(payload=='OFF') ledPin.write(0);<br/>  callback();<br/><br/>}
</pre>
<p>The preceding code will subscribe to the channel in the broker and wait for incoming signals.</p>
<p>Initially, we've declared the GPIO pin <kbd>13</kbd> as the output mode because the onboard LED is connected to this pin:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="384" src="assets/image009.jpg" width="678"/></div>
<div class="CDPAlignCenter CDPAlign">Onboard LED location</div>
<p>The location of the onboard LED is shown in the preceding image.</p>
<p>On having a close look at the code, we see that it initially imports the library and then sets the GPIO pin configuration. Then, we use a variable client to initiate the MQTT connection to the broker.</p>
<p>After that, we move on to subscribe our device to the channel, which in this case is named as <kbd>avirup/control/#</kbd>.</p>
<p>We have an event handler, <kbd>handleMessage()</kbd>. This event handler will deal with incoming messages. The incoming message will be stored in the packet variable. We've also implemented a callback method, <kbd>callback()</kbd>, which needs to be called from <kbd>handleMessage()</kbd>.</p>
<p>This enables us to receive multiple messages. Also note that, unlike other Node.js snippets, we haven't implemented any loop. The functionality is actually handled by the <kbd>callback()</kbd> method.</p>
<p>Finally, inside the function we obtain the payload, which is the message. It is then converted to a string and then condition checking is performed. We also print the value received to the console.</p>
<p>Now push this code to your Edison using FileZilla and run the code.</p>
<p>Once you run the code, you won't see anything in the console. The reason behind that is there is no message. Now, go to the Android <span>application, </span>MyMqtt, and browse to the <span class="packt_screen">Publish</span> section of the application.</p>
<p>We need to insert the channel name here. In this case, it is <kbd>avirup/control</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="127" src="assets/6639_03_05.png" width="204"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Publish MyMqtt</div>
<p>In the <span class="packt_screen">Topic</span> section, enter the channel name, and in the <span class="packt_screen">Message</span> section enter the message to be sent to Edison.</p>
<p>Now, in parallel, run your Node.js code.</p>
<p>Once your code is up and running, we will send a message. Type <kbd>ON</kbd> in the <span class="packt_screen">Message</span> field and click <span class="packt_screen">Publish</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="152" src="assets/6639_03_06.png" width="213"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Send control signals</div>
<p>Once you have published from the application, it should be reflected on the PuTTY console:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="185" src="assets/6639_03_07.png" width="556"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Message send and receive—MQTT</div>
<p>Now you should see that the LED is turned on.</p>
<p>Similarly, send a message, <kbd>OFF</kbd>, to turn off the onboard LED:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="147" src="assets/6639_03_08.png" width="509"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Message send and receive. The LED should turn off</div>
<p>It's also worth noting that this will work even if Edison and the device aren't connected to the same network.</p>
<p>Now you can control your Intel Edison with your Android application. Virtually speaking, you can now control your home. In the following section, we'll deep dive into the home automation scenario and also develop a WPF <span>application </span>to control.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Home automation using Intel Edison, MQTT, Android, and WPF</h1>
            </header>

            <article>
                
<p>Until now we have learned about the MQTT protocol and how to subscribe and publish data, both using the <span>application </span>and Edison. Now we will be dealing with a real use case where we'll control an electrical load using Intel Edison, which again will be controlled by the Internet. Here is a quick introduction about what we will be dealing with:</p>
<ul>
<li>Hardware components and circuits</li>
<li>Developing a WPF <span>application </span>to control Intel Edison</li>
<li>Using MQTT to stitch everything together</li>
</ul>
<p>Since we've already seen how to control Edison using an Android application, this section won't concentrate on that; instead, it will mainly deal with the WPF application. This is just to give you a brief idea about how a PC can control IoT devices, not only in home automation, but also in various other use cases, both in simple proof of concept scenarios to industry standard solutions.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Hardware components and circuit</h1>
            </header>

            <article>
                
<p>When we are dealing with electrical load, we simply cannot directly connect it to Edison or any other boards, as it will end up frying. For dealing with these loads, an interfacing circuit is used called a relay. A relay in its crude form is a series of electromechanical switches. They operate on a DC voltage and control AC sources. Components that will be used are listed as follows:<br/></p>
<ul>
<li>Intel Edison</li>
<li>5V relay module</li>
<li>Electric bulb wires</li>
</ul>
<p>Before going into the circuitry, we'll discuss relays first:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="169" src="assets/6639_03_09.jpg" width="280"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Relay schematics. Picture credits: <a href="http://www.phidgets.com/docs/3051_User_Guide">h</a><a href="http://www.phidgets.com/docs/3051_User_Guide">t</a><a href="http://www.phidgets.com/docs/3051_User_Guide">t</a><a href="http://www.phidgets.com/docs/3051_User_Guide">p</a><a href="http://www.phidgets.com/docs/3051_User_Guide">://w</a><a href="http://www.phidgets.com/docs/3051_User_Guide">w</a><a href="http://www.phidgets.com/docs/3051_User_Guide">w</a><a href="http://www.phidgets.com/docs/3051_User_Guide">.</a><a href="http://www.phidgets.com/docs/3051_User_Guide">p</a><a href="http://www.phidgets.com/docs/3051_User_Guide">h</a><a href="http://www.phidgets.com/docs/3051_User_Guide">i</a><a href="http://www.phidgets.com/docs/3051_User_Guide">d</a><a href="http://www.phidgets.com/docs/3051_User_Guide">g</a><a href="http://www.phidgets.com/docs/3051_User_Guide">e</a><a href="http://www.phidgets.com/docs/3051_User_Guide">t</a><a href="http://www.phidgets.com/docs/3051_User_Guide">s</a><a href="http://www.phidgets.com/docs/3051_User_Guide">.</a><a href="http://www.phidgets.com/docs/3051_User_Guide">c</a><a href="http://www.phidgets.com/docs/3051_User_Guide">o</a><a href="http://www.phidgets.com/docs/3051_User_Guide">m</a><a href="http://www.phidgets.com/docs/3051_User_Guide">/d</a><a href="http://www.phidgets.com/docs/3051_User_Guide">o</a><a href="http://www.phidgets.com/docs/3051_User_Guide">c</a><a href="http://www.phidgets.com/docs/3051_User_Guide">s</a><a href="http://www.phidgets.com/docs/3051_User_Guide">/3051_</a><a href="http://www.phidgets.com/docs/3051_User_Guide">U</a><a href="http://www.phidgets.com/docs/3051_User_Guide">s</a><a href="http://www.phidgets.com/docs/3051_User_Guide">e</a><a href="http://www.phidgets.com/docs/3051_User_Guide">r</a><a href="http://www.phidgets.com/docs/3051_User_Guide">_</a><a href="http://www.phidgets.com/docs/3051_User_Guide">G</a><a href="http://www.phidgets.com/docs/3051_User_Guide">u</a><a href="http://www.phidgets.com/docs/3051_User_Guide">i</a><a href="http://www.phidgets.com/docs/3051_User_Guide">d</a><a href="http://www.phidgets.com/docs/3051_User_Guide">e</a></div>
<p>The red rectangular area represents the electromagnet. We excite the electromagnet with a DC voltage, and that triggers the mechanical switch. Having a closer look at the preceding image, we can see three ports where the AC load is connected: common, normally closed, and normally open. In default conditions, that is when the electromagnet is not excited, and the common and normally closed ports are connected. What we are interested in for now is the normally open port.</p>
<p>The image of the relay used is shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="173" src="assets/image015.jpg" width="365"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Relay unit. Picture credits: Seed Studio</div>
<p>The electrical load will have a live and neutral wire. Connect either one according to the following circuit:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="343" src="assets/image016.jpg" width="609"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Basic relay connection</div>
<p>With reference to the preceding figure, <strong>Vcc</strong> and <strong>Gnd</strong> are connected to the controller. The AC source connects one end of the electrical load directly, while the other is via the relay. A part of it connects the common port, while the other may be in <strong>normally closed</strong> (<strong>NC</strong>) or <strong>normally open</strong> (<strong>NO</strong>). When you have the other end of the electrical load connected to the NC port, then by default without excitation of the electromagnet, the circuit is complete. Since we don't want the bulb to be operating when the electromagnet isn't excited, connect it to the <strong>NO</strong> port, rather than <strong>NC</strong>. Thus, when the electromagnet is operating by applying voltage on <strong>Vcc</strong> and <strong>Gnd</strong> as ground, the mechanical switch flips to the <strong>NO</strong> position, thus connecting it with the common port.</p>
<p>The whole idea behind the operation of a relay is the use of electromechanical switches to complete a circuit. However, it is worth noting that not all relays operate on the same principle; some relays use solid state devices to operate.</p>
<p><strong>Solid State Relays</strong> (<strong>SSRs</strong>) don't have any movable parts unlike that of electromechanical relays. SSRs uses photo-couplers to isolate the input and the output. They change electrical signals to optical signals, which propagates through space and thus isolates the entire circuit. The coupler on the receiving end is connected to any switching device, such as a MOSFET, to perform the switching action.</p>
<p>There are some advantages of using SSRs over electromechanical relays. They are as follows:</p>
<ul>
<li>They provide high speed, high frequency switching operations</li>
<li>There is failure of contact points</li>
<li>They generate minimal noise</li>
<li>They don't generate operation noise</li>
</ul>
<p>Although we will use electromechanical relays for now, if the use case deals with high frequency switching, then it's better to go with SSRs. It is also to be noted that when exposed to long usage, SSRs are known to heat up.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Final circuit</h1>
            </header>

            <article>
                
<p>The entire connection is shown in the following figure:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="395" src="assets/image017.jpg" width="702"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Circuit diagram for home automation project</div>
<p>The circuit adds Intel Edison because the relay circuit will be controlled by the controller. The relay here just acts as an interfacing unit to the AC load.</p>
<div class="packt_infobox">While the relay is being operated, please do not touch the underside of it or you may get an AC electric shock, which can be dangerous.</div>
<p>To test whether the circuit is working or not, try out a simple program using the Arduino IDE:</p>
<pre>
#define RELAY_PIN 13 void setup()<br/>{<br/>  pinMode(RELAY_PIN,OUTPUT); //Set relay pin to output<br/>}<br/>void loop<br/>{<br/>  digitalWrite(RELAY_PIN, HIGH); //Set relay to on position<br/>}
</pre>
<p>The code should switch the position of the switch from the NC position to the NO position, thus completing the circuit, leading your bulb to glow. Don't forget to switch on the AC power supply.</p>
<p>Once you have the final circuit ready, we'll move forward with the development of the WPF application, which will control Edison.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Android application for controlling Intel Edison using MQTT</h1>
            </header>

            <article>
                
<p>In the previous section, we saw how an Android <span>application </span>can be used to subscribe and publish to a channel using a broker. Here, in this section, we'll develop our own Android <span>application </span>for controlling the device using MQTT. The section won't concentrate on the set up of the Android, but will concentrate on the development side of it. We're going to use the Android Studio IDE for the development of the application. Make sure it's configured with all the latest SDKs.</p>
<p>Open your <span class="packt_screen">Android Studio</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="387" src="assets/6639_03_10.jpg" width="647"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Android Studio—1</div>
<p>Now, select <span class="packt_screen">Start a new Android Studio project</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="611" src="assets/6639_03_11.png" width="903"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Android Studio—set up <span>application </span>name</div>
<p>Enter a name for your application; here, we've entered <kbd>MQTT</kbd>. Click on <span class="packt_screen">Next</span> to continue:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="587" src="assets/6639_03_12.png" width="863"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Android Studio: set API level</div>
<p>Now select the <span class="packt_screen">Minimum SDK</span> version. Select <span class="packt_screen">API 23: Android 6.0 (Marshmallow)</span>. Now let's select the type of activity:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="513" src="assets/6639_03_13.png" width="751"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Set activity</div>
<p>Select <span class="packt_screen">Empty Activity</span> and click on <span class="packt_screen">Next</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="533" src="assets/6639_03_14.png" width="783"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Set start-up activity name</div>
<p>Give a name to your activity and click on <span class="packt_screen">Finish</span>. It may take a few minutes to set up your project. After it's done, you may see a screen like this:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="470" src="assets/6639_03_15.jpg" width="913"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Design page. activity_name.xml</div>
<p>If you have a closer look over the project folder, you will notice that we have folders such as <kbd>java</kbd>, <kbd>res</kbd>, <kbd>values</kbd>, and so on. Let's have a closer look at what these folders actually contain:</p>
<ul>
<li><kbd>java</kbd>: This contains all the <kbd>.java</kbd> source files for your project. The main activity, named as <kbd>MainActivity.java</kbd>, is also contained in this project.</li>
<li><kbd>res/drawable</kbd>: This is a directory for drawable components for this project. It won't be used for the moment.</li>
<li><kbd>res/layout</kbd>: This contains all the files responsible for the applications UI.</li>
<li><kbd>res/values</kbd>: This is a kind of directory for various other <kbd>xml</kbd> files that contain definitions of resources, such as string and color.</li>
<li><kbd>AndroidManifest.xaml</kbd>: This is a manifest file that defines the <span>application </span>as well as the permissions required by the application.</li>
<li><kbd>build.gradle</kbd>: This is an auto-generated file that contains information such as <kbd>compileSdkVersion</kbd>, <kbd>buildToolsVersion</kbd>, <kbd>applicationID</kbd>, and so on.</li>
</ul>
<p>In this application, we will be using a third-party resource or library known as the eclipse <kbd>paho</kbd> library for MQTT. These dependencies need to be added to <kbd>build.gradle</kbd>.</p>
<p>There should be two <kbd>build.gradle</kbd> files. We need to add the dependencies in the <kbd>build.gradle(Module:app)</kbd> file:</p>
<pre>
repositories <br/>{ <br/>  maven <br/>    {<br/>      url "https://repo.eclipse.org/content/repositories/paho-<br/>      snapshots/"<br/>    }<br/>}<br/>dependencies <br/>{<br/>  compile('org.eclipse.paho:org.eclipse.paho.android.service:1.0.3-<br/>  SNAPSHOT')<br/>    {<br/>      exclude module: 'support-v4'<br/>    }<br/>}
</pre>
<p>A dependency block should already exist, so you need not write the entire thing again. In that case, just write <kbd>compile('org.eclipse.paho:org.eclipse.paho.android.service:1.0.3-SNAPSHOT') { exclude module: 'support-v4'</kbd> in the already present dependency block. Immediately after you paste the code, Android Studio will ask you to sync gradle. It is necessary that you sync gradle before proceeding:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="501" src="assets/6639_03_16.jpg" width="940"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Add dependencies</div>
<p>Now we need to add permissions and services to our project. Browse to <kbd>AndroidManifest.xml</kbd> and add the following permission and services:</p>
<pre>
&lt;service android:name="org.eclipse.paho.android.service.MqttService" &gt;<br/>&lt;/service&gt;<br/>&lt;uses- permission android:name="android.permission.INTERNET" /&gt;
</pre>
<p>After this is done, we will move forward with the UI. The UI needs to be designed under the layout, in the <kbd>activity_main.xml</kbd> file.</p>
<p>We'll have the following UI components:</p>
<ul>
<li><kbd>EditText</kbd>: This is for the broker</li>
<li><kbd>URL EditText</kbd>: This is for the <kbd>EditText</kbd> port for the channel</li>
</ul>
<p>Button to connect:</p>
<ul>
<li>On button to send the on signal</li>
<li>Off button to send the off signal</li>
</ul>
<p>Drag and drop the previously mentioned components in the designer window. Alternatively, you can directly write it in the text view.</p>
<p>For your reference, the XML code of the final design is shown as follows. Write your code inside the relative layout tab:</p>
<pre>
<strong>&lt;EditText <br/>  android:layout_width="wrap_content"<br/>  android:layout_height="wrap_content" <br/>  android:text="android/edison" <br/>  android:id="@+id/channelID" <br/>  android:hint="Enter channel ID" <br/>  android:layout_centerVertical="true"<br/>  android:layout_alignParentStart="true"<br/>  android:layout_alignEnd="@+id/portNum" /&gt; <br/><br/>&lt;Button <br/>  android:layout_width="wrap_content"<br/>  android:layout_height="wrap_content" <br/>  android:text="On" <br/>  android:id="@+id/on"<br/>  android:layout_below="@+id/connectMQTT"<br/>  android:layout_alignParentStart="true" <br/>  android:layout_marginTop="45dp" /&gt;<br/></strong><br/><strong>&lt;Button <br/>  android:layout_width="wrap_content"<br/>  android:layout_height="wrap_content" <br/>  android:text="Off" <br/>  android:id="@+id/off"<br/>  android:layout_alignTop="@+id/on" <br/>  android:layout_alignParentEnd="true" /&gt; <br/><br/>&lt;EditText <br/>  android:layout_width="wrap_content"<br/>  android:layout_height="wrap_content" <br/>  android:id="@+id/brokerAdd" <br/>  android:layout_alignParentTop="true"<br/>  android:layout_alignParentStart="true" <br/>  android:layout_marginTop="40dp" <br/>  android:hint="Broker Address" <br/>  android:layout_alignParentEnd="true" <br/>  android:text="iot.eclipse.org" /&gt; <br/><br/>&lt;EditText <br/>  android:layout_width="wrap_content"<br/>  android:layout_height="wrap_content" <br/>  android:id="@+id/portNum" <br/>  android:layout_below="@+id/brokerAdd"<br/>  android:layout_alignParentStart="true" <br/>  android:layout_marginTop="40dp" <br/>  android:hint="Port Default: 1883"<br/>  android:layout_alignEnd="@+id/brokerAdd" <br/>  android:text="1883" /&gt; <br/><br/>&lt;Button <br/>  android:layout_width="wrap_content"<br/>  android:layout_height="wrap_content" <br/>  android:text="@string/connect" <br/>  android:id="@+id/connectMQQT" <br/>  android:layout_below="@+id/channelID"<br/>  android:layout_alignParentStart="true"<br/>  android:layout_alignEnd="@+id/channelID" /&gt;</strong>
</pre>
<p>Now click on the <span class="packt_screen">Design</span> view; you will see that a UI has been created, which should be somewhat similar to that of the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="313" src="assets/6639_03_17.png" width="204"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Application </span>design</div>
<p>Now have a closer look at the preceding code to try to find out the properties that were used. Basic properties such as <kbd>height</kbd>, <kbd>width</kbd>, and <kbd>position</kbd> are set, which is understandable from the code. The main properties are <kbd>text</kbd>, <kbd>id </kbd>and <kbd>hint</kbd> of the <kbd>EditText</kbd>. Each component in the Android UI should have a unique ID. Beside that, we set a hint such that the user knows exactly what to enter in the text areas. For ease, we have defined the text such that while deploying, we don't need to do that again. In the final application, remove the text properties. There is another option to get your values from <kbd>strings.xml</kbd>, which can be found under values for the texts or the hints:</p>
<pre>
<strong>android:text="@string/connect"</strong>
</pre>
<p>Now that we have the UI ready, we need to implement our code that will use these UI components to interact with the device using the MQTT protocol. We also have the dependencies in place. The main Java code is written in <kbd>MainActivity.java</kbd>.</p>
<p>Before proceeding further with the <kbd>MainActivity.java</kbd> activity, let's create a class that will handle the MQTT connection. This will make the code a lot easier to understand and more efficient. Have a look at the following screenshot to see the location of the <kbd>MainActivity.java</kbd> file:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="132" src="assets/6639_03_18.png" width="262"/></div>
<p>Right click on the highlighted folder and click on <span class="packt_screen">new</span> | <span class="packt_screen">java</span> class. This class will handle all the required data exchanges happening between the <span>application </span>and the MQTT broker:</p>
<pre>
package com.example.avirup.mqtt;<br/>import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;<br/>import org.eclipse.paho.client.mqttv3.MqttCallback;<br/>import org.eclipse.paho.client.mqttv3.MqttClient;<br/>import org.eclipse.paho.client.mqttv3.MqttException;<br/>import org.eclipse.paho.client.mqttv3.MqttMessage;<br/>import org.eclipse.paho.client.mqttv3.MqttPersistenceException;<br/>import org.eclipse.paho.client.mqttv3.MqttSecurityException;<br/>import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;<br/>import java.io.UnsupportedEncodingException;<br/>/** * Created by Avirup on 16-02-2017. */<br/>public class MqttClassimplements MqttCallback <br/>{ <br/>  String serverURI, port, clientID; <br/>  MqttClientclient; <br/>  MqttCallback callback;<br/>//ConstructorMqttClass(String uri, String port, String clientID) <br/>    {<br/>      this.serverURI=uri;<br/>      this.port=port;<br/>      this.clientID=clientID; <br/>    }<br/>  public void MqttConnect() <br/>    {<br/>      try <br/>        { <br/>          MemoryPersistencepersistance = new MemoryPersistence();<br/>          StringBuilderServerURI = new StringBuilder();<br/>          ServerURI.append("tcp://"); <br/>          ServerURI.append(serverURI);<br/>          ServerURI.append(":"); <br/>          ServerURI.append(port); <br/>          String finalServerUri = ServerURI.toString();<br/>          client = new MqttClient(finalServerUri, clientID,<br/>          persistance);<br/>          client.setCallback(callback);<br/>          client.connect(); <br/>        }<br/>      catch (MqttSecurityException e) <br/>        { <br/>          e.printStackTrace(); <br/>        } <br/>      catch (MqttException e) <br/>        { <br/>          e.printStackTrace(); <br/>        }<br/>      }<br/>    public void MqttPublish(String message) <br/>      { <br/>        String commId=clientID;<br/>        try<br/>          {<br/>            byte[]<br/>            payload=message.getBytes("UTF-8"); <br/>            MqttMessagefinalMsg= new MqttMessage(payload);<br/>            client.publish(clientID,finalMsg); <br/>          }<br/>        catch (UnsupportedEncodingException e) <br/>          { <br/>            e.printStackTrace(); <br/>          } <br/>        catch (MqttPersistenceExceptione) <br/>          { <br/>            e.printStackTrace(); <br/>          } <br/>        catch (MqttException e) <br/>          { <br/>            e.printStackTrace(); <br/>          } <br/>        } <br/>      @Override<br/>      public void connectionLost(Throwable cause) <br/>        {<br/>     }<br/>       @Override<br/>       public void messageArrived(String topic, MqttMessage<br/>       message) throws Exception <br/>         {<br/>       }<br/>      @Override<br/>      public void deliveryComplete(IMqttDeliveryToken token) <br/>        {<br/>      } <br/>    }
</pre>
<p>The code that is pasted earlier may seem complicated at first glance, but it's actually very simple once you understand it. It is assumed that the reader has a basic understanding of object-oriented programming concepts.</p>
<p>The statements that import the packages are all done automatically. After creating the class, implement the <kbd>MqttCallback</kbd> interface. This will add the abstract methods that are required to be overridden.</p>
<p>Initially, we write a parameterized constructor for this class. We also create a global reference variable for the <kbd>MqttClient</kbd> and the <kbd>MqttCallback</kbd> classes. Three global variables are also created for <kbd>serverURI</kbd>, <kbd>port</kbd>, and <kbd>clientID</kbd>:</p>
<pre>
String serverURI, port, clientID; <br/>MqttClientclient; <br/>MqttCallback callback; <br/>MqttClass(String uri, String port, String clientID)<br/>{<br/>  this.serverURI=uri;<br/>  this.port=port;<br/>  this.clientID=clientID; <br/>}
</pre>
<p>The parameters are the broker <kbd>URI</kbd>, <kbd>port</kbd> number, and the <kbd>clientID</kbd>.</p>
<p>Next, we have created three global variables that are set to the parameters. In the <kbd>MqttConnect</kbd> method, we initially form a string as we take input as just the server URI. Here, we append it with <kbd>tcp://</kbd> and the port number and also create an object for the <kbd>MemoryPersistence</kbd> class:</p>
<pre>
MemoryPersistencepersistance = new MemoryPersistence(); StringBuilderServerURI = new StringBuilder(); ServerURI.append("tcp://"); <br/>ServerURI.append(serverURI); <br/>ServerURI.append(":"); <br/>ServerURI.append(port); <br/>String finalServerUri = ServerURI.toString();
</pre>
<p>Next, we create the objects for the global reference variables using the <kbd>new</kbd> keyword:</p>
<pre>
client = new MqttClient(finalServerUri, clientID, persistance);
</pre>
<p>Please note the parameters as well.</p>
<p>The preceding code is surrounded by a try catch block to handle exceptions. The catch block is shown as follows:</p>
<pre>
catch(MqttSecurityException e) <br/>{ <br/>  e.printStackTrace(); <br/>} <br/>catch (MqttException e) <br/>{<br/>  e.printStackTrace(); <br/>}
</pre>
<p>The connection part is achieved. The next phase is to create the <kbd>publish</kbd> method that will publish the data to the broker.</p>
<p>The parameter is just the <kbd>message</kbd> of type string:</p>
<pre>
public void MqttPublish(String message) <br/>{ <br/>  String commId=clientID;<br/>  try<br/>    {<br/>      byte[] payload=message.getBytes("UTF-8"); <br/>      MqttMessagefinalMsg= new MqttMessage(payload);<br/>      client.publish(clientID,finalMsg); <br/>    }<br/>  catch (UnsupportedEncodingException e) <br/>    { <br/>      e.printStackTrace(); <br/>    } <br/>  catch (MqttPersistenceException<br/>    { <br/>      e.printStackTrace(); <br/>    } <br/>  catch (MqttException e) <br/>    { <br/>      e.printStackTrace(); <br/>    } <br/>}
</pre>
<p><kbd>client.publish</kbd> is used to publish data. The parameter is a string which is the <kbd>clientID</kbd> or <kbd>channelID</kbd> and an object of type <kbd>MqttMessage</kbd>. <kbd>MqttMessage</kbd> contains our message. However, it doesn't accept strings. It uses a byte array. In the try block, we first convert the string to a byte array and then publish the final message by using the <kbd>MqttMessage</kbd> class to the specific channel.</p>
<p>For this specific application, the overridden methods aren't required, so we leave it as is.</p>
<p>Now head back to the <kbd>MainActivity.java</kbd> class. We will use the <kbd>MqttClass</kbd> that we just created to do the publish action. The main task here is to get data from the UI and use it to connect to the broker using the class that we just wrote.</p>
<p>The <kbd>MainActivity.java</kbd> will contain the following code by default:</p>
<pre>
packagecom.example.avirup.mqtt;<br/>import android.support.v7.app.AppCompatActivity;<br/>import android.os.Bundle;<br/>public class MainActivityextends AppCompatActivity <br/>{ <br/>  @Overrideprotected void onCreate(Bundle savedInstanceState)<br/>  {<br/>    super.onCreate(savedInstanceState);<br/>    setContentView(R.layout.activity_main); <br/>  } <br/>}
</pre>
<p>Whenever the application is opened, the <kbd>onCreate</kbd> method is triggered. On having a closer look at the activity life cycle, the concept will be clear.</p>
<p>The life cycle callbacks are:</p>
<ol>
<li><kbd>onCreate()</kbd></li>
<li><kbd>onStart()</kbd></li>
<li><kbd>onResume()</kbd></li>
<li><kbd>onPause()</kbd></li>
<li><kbd>onStop()</kbd></li>
<li><kbd>onDestroy()</kbd></li>
</ol>
<p>More details on the life cycle can be obtained from:</p>
<p><a href="https://developer.android.com/guide/components/activities/activity-lifecycle.html">https://developer.android.com/guide/components/activities/activity-lifecycle.html</a></p>
<p>Now we need to assign some reference variables to the UI components. We'll do that on a global level.</p>
<p>Before the start of <kbd>onCreate</kbd> method, that is before the keyword override, add the following lines:</p>
<pre>
<strong>EditTextserverURI,port,channelID; <br/>Button connect,on,off;</strong>
</pre>
<p>Now, in the <kbd>onCreate</kbd> method, we need to assign the reference variables we just declared and explicitly typecast them to the class type:</p>
<pre>
serverURI=(EditText)findViewById(R.id.brokerAdd);<br/>port=(EditText)findViewById(R.id.port Num);<br/>connect=(Button)findViewById(R.id.connectMQTT);<br/>channelID=(EditText)findViewById(R.id.channelID);<br/>on=(Button)findViewById(R.id.on);<br/>off=( Button)findViewById(R.id.off);
</pre>
<p>In the preceding lines, we have explicitly type-casted them to <kbd>EditText</kbd> and <kbd>Button</kbd>, and bound them to the UI components.</p>
<p>Now we will create a new event handler for the connect button:</p>
<pre>
connect.setOnClickListener(new View.OnClickListener() <br/>{ <br/>  @Overridepublic void onClick(View v) <br/>    {<br/>    } <br/>});
</pre>
<p>The preceding block is activated when we press the connect button. The block contains a method whose parameter is view. The code that needs to be executed when the button is pressed needs to be written inside the <kbd>onCLick(View v)</kbd> method.</p>
<p>Before that, create a global reference variable for the class that you created before:</p>
<pre>
<strong>MqttClassmqttClass;</strong>
</pre>
<p>Next, inside the method, get the text from the edit boxes. Declare the global variables for those of the type string beforehand:</p>
<pre>
<strong>String serverUri, portNo,channelid;</strong>
</pre>
<p>Now, write the following code inside the <kbd>onClick</kbd> method:</p>
<pre>
serverUri=serverURI.getText().toString();<br/>portNo=port.getText().toString();<br/>channelid=channelID.getText().toString();
</pre>
<p>Once we get the data, we will create an object for the <kbd>MqttClass</kbd> class and pass the strings as parameters, and we will also invoke the <kbd>MqttConnect</kbd> method:</p>
<pre>
mqttClass=new MqttClass(serverUri,portNo,channelid); mqttClass.MqttConnect(); 
</pre>
<p>Now we'll create similar cases for the <kbd>ON</kbd> and <kbd>OFF</kbd> methods:</p>
<pre>
on.setOnClickListener(new View.OnClickListener() <br/>{ <br/>  @Overridepublic void onClick(View v) <br/>    {<br/>      mqttClass.MqttPublish("ON"); <br/>    } <br/>});<br/>off.setOnClickListener(new View.OnClickListener() <br/>{<br/>  @Overridepublic void onClick(View v) <br/>    {<br/>      mqttClass.MqttPublish("OFF"); <br/>    } <br/>});
</pre>
<p>We have used the <kbd>MqttPublish</kbd> method of <kbd>MqttClass</kbd>. The parameter is just a string and is based on the <kbd>onClick</kbd> method that when it is activated, it publishes the data.</p>
<p>Now the application is ready and can be deployed on your device. You must turn on the developer mode on your Android device and to deploy it, connect your device to a PC and press the <span class="packt_screen">Run</span> button. You should now have the <span>application </span>running on your device. To test your application, you can directly use Edison or just use the MyMqtt application.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Windows Presentation Foundation application for controlling using MQTT</h1>
            </header>

            <article>
                
<p>WPF is a powerful UI framework for building Windows desktop client applications. It supports a broad spectrum of application features including models, controls, graphics layout, data binding, documents, and security. The programming is based on C# for the core logic and XAML for the UI.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Sample "Hello World" application in WPF</h1>
            </header>

            <article>
                
<p>Before moving on to the development of an application for controlling Intel Edison, let's have a brief look at how we can integrate certain basic features such as a button click event, handling displaying data, and so on. Open up your Visual Studio and select <span class="packt_screen">New Project</span>.</p>
<p>In PCs with low RAM, the installation of Visual Studio may take a while, as will opening Visual for the first time:</p>
<div class="packt_infobox">The reason we are working with WPF is that it will be used in multiple topics, such as those in this chapter and in the upcoming chapters on robotics. In robotics, we'll be developing software to control robots. It is also assumed that the reader has an understanding of Visual Studio. For detailed information about how to work with Visual Studio and WPF, refer to the following link: <br/>
<a href="https://msdn.microsoft.com/en-us/library/aa970268(v%3Dvs.110).aspx">https://msdn.microsoft.com/en-us/library/aa970268(v%3Dvs.110).aspx</a><br/>
<a href="https://msdn.microsoft.com/en-us/library/aa970268(v%3Dvs.110).aspx"/></div>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/6639_03_19.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Create new project in WPF</div>
<p>Click on <span class="packt_screen">New Project</span>, then under the <span class="packt_screen">Visual C#</span> section, click on <span class="packt_screen">WPF Application</span>. Enter a name such as <kbd>Mqtt Controller</kbd> in the field of <span class="packt_screen">Name</span> and click on <span class="packt_screen">OK</span>.</p>
<p>Once you click <span class="packt_screen">OK</span>, the project will be created:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/6639_03_20.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">WPF project created</div>
<p>Once the project is created, you should get a display similar to this. If some display components are missing from your window, then go to <span class="packt_screen">View</span> and select those. Now have a close look on the Solution Explorer, which is visible on the right-hand side of the image.</p>
<p>There, have a look at the project structure:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="235" src="assets/6639_03_21.png" width="270"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Solution Explorer</div>
<p>An application has two main components. The first is the UI, which will be designed in <kbd>MainWindow.xaml</kbd>, and the second is the logic, which will be implemented in <kbd>MainWindow.xaml.cs</kbd>.</p>
<p>The UI is designed using XAML, while the logic is implemented in C#.</p>
<p>To start with, we'll just have one button control: a field where the user will enter some text and an area where the entered text will be displayed. After we have a fair idea about handling events, we can move forward to the implementation of MQTT.</p>
<p>Initially, we'll design the UI for the double click on <kbd>MainPage.xaml.cs</kbd>. It's in this file that we'll add the UI's XAML components. The code is written in XAML and much of the work can be accomplished by the use of drag and drop feature. From the toolbox situated on the right-hand side of the application, look up the following items:</p>
<ul>
<li><kbd>Button</kbd></li>
<li><kbd>TextBlock</kbd></li>
<li><kbd>TextBox</kbd></li>
</ul>
<p>There are two ways of adding the components. The first is to manually add the code in the XAML view of the page, while the second is to drag and drop from the components' toolbox. A few things to note are as follows.</p>
<p>The Designer window can be edited according to your wishes. A quick workaround for this is to select the component you want to edit, which can be done in the <span class="packt_screen">Properties</span> window.</p>
<p>Properties can also be edited using XAML:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/6639_03_22.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Visual Studio layout</div>
<p>In the preceding screenshot, we've changed the background color and added the components. Note the properties window where the background color is highlighted.</p>
<p>The <kbd>TextBox</kbd> is the area where the user will enter the text and the <kbd>TextBlock</kbd> is the area where it will be displayed. Once you have the components placed on the design view and have edited their properties, mainly the names of the components, we'll add the event handlers. For a shortcut of the design shown in the preceding screenshot, write the following XAML code within the <kbd>grid</kbd> tag:</p>
<pre>
&lt;Button x:Name="click_me" Content="Click me" HorizontalAlignment="Left" Margin="151,137,0,0" VerticalAlignment="Top" Width="193"/&gt;<br/>&lt;TextBlock x:Name="textBlock" Text="TextBlock" HorizontalAlignment="Left"<br/>Margin="151,189,0,0" TextWrapping="Wrap" VerticalAlignment="Top" Width="193" Foreground="White"/&gt;<br/>&lt;TextBox x:Name="textBox" HorizontalAlignment="Left" Height="23" Margin="151,101,0,0" TextWrapping="Wrap" Text="TextBox" VerticalAlignment="Top" Width="193"/&gt;
</pre>
<p>Now in the <span class="packt_screen">Designer</span> window, double click on the button to create an event handler for a click event. The events that are available can be viewed in the <span class="packt_screen">Properties</span> window, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="368" src="assets/6639_03_23.png" width="237"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Event properties of button</div>
<p>Once you have double clicked, you will automatically be redirected to <kbd>MainWindow.xaml.cs</kbd> along with a method self-generated for the event.</p>
<p>You will get a method something similar to the following code:</p>
<pre>
privatevoidclick_me_Click(object sender, RoutedEventArgs e)<br/>{<br/>}
</pre>
<p>Here, we are going to implement the logic. Initially, we will read the data as written in the <kbd>TextBox</kbd>. If it's empty, we'll display a message saying that it cannot be empty. Then, we'll just pass the message to the <kbd>TextBlock</kbd>. The following code does the same thing:</p>
<pre>
privatevoidclick_me_Click(object sender, RoutedEventArgs e)<br/>{<br/>  string res = textBox.Text; if(string.IsNullOrEmpty(res))<br/>    {<br/>      MessageBox.Show("No text entered. Please enter again");<br/>    }<br/>  else<br/>    {<br/>      textBlock.Text = res;<br/>    }<br/>}
</pre>
<p>The preceding code initially reads the data and then checks if it's null or empty and then outputs the data into the <kbd>TextBlock</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/6639_03_24.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Application run—1</div>
<p>Press <em>F5</em> to run your application and then the preceding screens should appear. Next, delete the text in the <span class="packt_screen">TextBox</span> and click on the <span class="packt_screen">Click me</span> button:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="238" src="assets/6639_03_25.png" width="354"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Empty text</div>
<p>Now, enter any text in the <span class="packt_screen">TextBox</span> and press the <span class="packt_screen">Click me</span> button. Your entered text should be displayed following in the <span class="packt_screen">TextBlock</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="245" src="assets/6639_03_26.png" width="360"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">WPF HelloWorld</div>
<p>Now that we know how to make a simple WPF application, we are going to edit the application itself to implement the MQTT protocol. To implement the MQTT protocol, we have to use a library, which will be added using the nugget package manager.</p>
<p>Now browse to <span class="packt_screen">References</span> and click on <span class="packt_screen">Manage Nugget Packages</span> and add the <kbd>M2Mqtt</kbd> external library:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/6639_03_27.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">NuGet package manager</div>
<p>Once we have the packages, we can use them in our project. For this project, we'll be using the following UI components in <kbd>MainWindow.xaml</kbd>:</p>
<ul>
<li>A <span class="packt_screen">TextBox</span> for entering the channel ID</li>
<li>A <span class="packt_screen">TextBlock</span> to display the latest control command</li>
<li>A button to set the status as <span>on</span></li>
<li>A button to set the status as <span class="packt_screen">off</span></li>
<li>A button to <span class="packt_screen">Connect</span></li>
</ul>
<p>Feel free to design the UI on your own:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/6639_03_28.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">UI for controller application</div>
<p>In the preceding screenshot, you will see that the design is updated and a button has also been added. The code for the preceding design is pasted as follows. The <span class="packt_screen">TextBox</span> is the area where we'll enter the channel ID, and then we will use the buttons to turn an LED <span class="packt_screen">on</span> and <span class="packt_screen">off</span>, and the <span class="packt_screen">Connect</span> button to connect to the service. Now, as done previously, we will create event handlers for click events for the two buttons mentioned previously. To add click events, simply double click on each button:</p>
<pre>
&lt;Button x:Name="on" Content="on" HorizontalAlignment="Left" Margin="151,180,0,0" VerticalAlignment="Top" Width="88" Click="on_Click"/&gt;<br/>  &lt;TextBlock x:Name="statusBox" Text="status"<br/>  HorizontalAlignment="Left" Margin="229,205,0,0" TextWrapping="Wrap"<br/>  VerticalAlignment="Top" Width="115" Foreground="White"/&gt;<br/>  &lt;TextBox x:Name="channelID" HorizontalAlignment="Left" Height="23"<br/>  Margin="151,101,0,0" TextWrapping="Wrap" Text=""<br/>  VerticalAlignment="Top" Width="193"/&gt;<br/>  &lt;Button x:Name="off" Content="off" HorizontalAlignment="Left"<br/>  Margin="256,180,0,0" VerticalAlignment="Top" Width="88"<br/>  Click="off_Click"/&gt;<br/>  &lt;Button x:Name="connect" Content="Connect" HorizontalAlignment="Left"<br/>  VerticalAlignment="Top" Width="193" Margin="151,139,0,0"<br/>  Click="connect_Click"/&gt; 
</pre>
<p>The preceding code is mentioned in the grid tag.</p>
<p>Now, once you have the design, move on to <kbd>MainWindow.xaml.cs</kbd> and write the main code. You will notice that a constructor and two event handler methods already exist.</p>
<p>Add the following namespace to use the library using:</p>
<pre>
<strong>uPLibrary.Networking.M2Mqtt;</strong>
</pre>
<p>Now create an instance of the <kbd>MqttClient</kbd> class and declare a global string variable:</p>
<pre>
<strong>MqttClient client = new MqttClient("iot.eclipse.org"); <br/></strong><strong>String channelID;</strong>
</pre>
<p>Next, in the event handler for the <span class="packt_screen">Connect</span> button, connect it to the broker using the channel ID.</p>
<p>The entire code for the <span class="packt_screen">Connect</span> button's event handler is mentioned as follows:</p>
<pre>
channelID_text = channelID.Text;<br/>if (string.IsNullOrEmpty(channelID_text))<br/>{<br/>  MessageBox.Show("Channel ID cannot be null");<br/>}<br/>else<br/>{<br/>  try<br/>  {<br/>    client.Connect(channelID_text); connect.Content = "Connected";<br/>  }<br/>catch (Exception ex)<br/>{<br/>  MessageBox.Show("Some issues occured: " + ex.ToString());<br/>}<br/>}
</pre>
<p>In the preceding snippet, we read the data from the <kbd>textbox</kbd> that contains the channel ID. If it's null, we ask the user to enter it again. Then, finally, we connect it to the channel ID. Note that it is inside the <kbd>try catch</kbd> block.</p>
<p>There are two more event handlers. We need to publish some value to the channel they are connected to.</p>
<p>In the <kbd>on</kbd> button's event handler, insert the following code:</p>
<pre>
private void on_Click(object sender, RoutedEventArgs e)<br/>{<br/>  byte[] array = Encoding.ASCII.GetBytes("on");<br/>  client.Publish(channelID_text, array);<br/>}
</pre>
<p>As seen in the preceding code, the parameter for the <kbd>Publish</kbd> method is the topic, which is the <kbd>channelID</kbd> and a <kbd>byte[] array</kbd> which contains the message.</p>
<p>Similarly, for the <kbd>off</kbd> method, we have:</p>
<pre>
private void off_Click(object sender, RoutedEventArgs e)<br/>{<br/>  byte[] array = Encoding.ASCII.GetBytes("off");<br/>  client.Publish(channelID_text, array);<br/>}
</pre>
<p>That's it. That's the entire code for your MQTT controller for home automation. The entire code is pasted as follows for your reference:</p>
<pre>
using System; <br/>usingSystem.Collections.Generic; <br/>usingSystem.Linq;<br/>usingSystem.Text; <br/>usingSystem.Threading.Tasks; <br/>usingSystem.Windows; <br/>usingSystem.Windows.Controls; <br/>usingSystem.Windows.Data; <br/>usingSystem.Windows.Documents; <br/>usingSystem.Windows.Input; <br/>usingSystem.Windows.Media; <br/>usingSystem.Windows.Media.Imaging; <br/>usingSystem.Windows.Navigation; <br/>usingSystem.Windows.Shapes;<br/>using uPLibrary.Networking.M2Mqtt; <br/>namespaceMqtt_Controller<br/>{<br/>/// &lt;summary&gt;<br/>/// Interaction logic for MainWindow.xaml<br/>/// &lt;/summary&gt;<br/>  public partial class MainWindow : Window<br/>    {<br/>      MqttClient client = new MqttClient("iot.eclipse.org"); <br/>      String channelID_text;<br/>      publicMainWindow()<br/>        {<br/>          InitializeComponent();<br/>        }<br/>      private void on_Click(object sender, RoutedEventArgs e)<br/>        {<br/>          byte[] array = Encoding.ASCII.GetBytes("ON");<br/>          client.Publish(channelID_text, array); <br/>          statusBox.Text = "on";<br/>        }<br/>      private void off_Click(object sender, RoutedEventArgs e)<br/>        {<br/>          byte[] array = Encoding.ASCII.GetBytes("OFF");<br/>          client.Publish(channelID_text, array); <br/>          statusBox.Text = "off";<br/>        }<br/>      private void connect_Click(object sender, RoutedEventArgs e)<br/>        {<br/>          channelID_text = channelID.Text;<br/>          if (string.IsNullOrEmpty(channelID_text))<br/>            {<br/>              MessageBox.Show("Channel ID cannot be null");<br/>            }<br/>          else<br/>            {<br/>              try<br/>                {<br/>                  client.Connect(channelID_text); <br/>                  connect.Content = "Connected";<br/>                }<br/>              catch (Exception ex)<br/>                {<br/>                  MessageBox.Show("Some issues occured: " +<br/>                  ex.ToString());<br/>                }<br/>            }<br/>        }<br/>    }<br/>}
</pre>
<p>Press the <em>F5</em> or the <span class="packt_screen">Start</span> button to execute this code:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/6639_03_29.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Application running</div>
<p>Next, in the <span class="packt_screen">TextBox</span>, enter the <kbd>channelID</kbd>. Here, we'll be entering it as <kbd>avirup/control</kbd> and then we will press the <span class="packt_screen">Connect</span> button:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/6639_03_30.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Application running—2</div>
<p>Now open your PuTTY console and log in to Intel Edison. Verify that the device is connected to the Internet using the <kbd>ifconfig</kbd> command. Next, just run the Node.js script. Next, press the <kbd>ON</kbd> button:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/6639_03_31.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">MQTT controlled by WPF application</div>
<p>Similarly, on pressing the <kbd>OFF</kbd> button, you will see a screen similar to the following:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/6639_03_32.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">MQTT controlled by WPF</div>
<p>Keep pressing <kbd>ON</kbd> and <kbd>OFF</kbd> and you will see the effect on Intel Edison. Now that we remember that we have connected the relay and the electric bulb, the effect should be visible by now. If the main switch of the AC power supply is turned off, then you won't see the bulb getting turned on, but you will hear a <kbd>tick</kbd> sound. That suggest that the relay is now in the <kbd>ON</kbd> position. The image of the hardware setup is shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="269" src="assets/image039.jpg" width="476"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Hardware setup for home automation</div>
<p>Thus, you have a home automation setup ready and you can control it by the PC <span>application </span>or the Android application.</p>
<div class="packt_infobox">If you are in office network, then sometimes port <kbd>1883</kbd> is blocked. In those cases, it is recommended to use your own personal network.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Open-ended task for the reader</h1>
            </header>

            <article>
                
<p>Now, you may have got a brief idea about how things must work in home automation. We have covered multiple areas in this niche. The task that is left for the reader is not only to integrate a single control command, but multiple control commands. This will allow you to control multiple devices. Add more functionality in the Android and the WPF <span>application </span>and go with more string control commands. Connect more relay units to the device for interfacing.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we've learned about the idea of home automation in its crude form. We also learned about how we can control an electrical load using relays. Not only that, but also we learned how to develop a WPF application and implement the MQTT protocol. On the device end, we used a Node.js code to connect our device to the Internet and subscribe to certain channels using the broker and ultimately receive signals to control itself. In the Android side of the system, we have used an already available MyMqtt <span>application </span>and used it to both to get and publish data. However, we also covered the development of the Android <span>application </span>in detail and showcased the use of it in implementing the MQTT protocol to control devices.</p>
<p>In <a href="3fa86b30-3d51-4628-a827-db7b3e31f3e7.xhtml" target="_blank">Chapter 4</a>, <span><em>Intel Edison and Security System</em>,</span> we are going to learn how to deal with image processing and speech processing applications using Intel Edison. <a href="3fa86b30-3d51-4628-a827-db7b3e31f3e7.xhtml" target="_blank">Chapter 4</a>, <span><em>Intel Edison and Security System</em>,</span> will mainly deal with Python and the usage of some open source libraries.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>