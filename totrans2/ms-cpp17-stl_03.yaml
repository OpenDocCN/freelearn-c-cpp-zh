- en: The Iterator-Pair Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器对算法
- en: Now that you've been introduced to iterator types--both standard-provided and
    user-defined--it's time to look at some of the things you can *do* with iterators.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了迭代器类型——既包括标准提供的也包括用户定义的——现在是时候看看你可以用迭代器做什么了。
- en: 'In this chapter you''ll learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你将学习：
- en: The notion of a "half-open range," which nails down the exact manner in which
    two iterators can be said to define a *range*
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “半开范围”的概念，这确定了两个迭代器如何定义一个*范围*
- en: How to classify each standard algorithm as "read-only," "write-only", "transformative",
    or "permutative"; and as "one-range", "two-range", or "one-and-a-half range"
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将每个标准算法分类为“只读”、“只写”、“转换”或“排列”；以及作为“单范围”、“双范围”或“一又一半范围”
- en: That some standard algorithms, such as `merge` and `make_heap`, are merely the
    necessary building blocks out of which we make higher-level entities such as `stable_sort`
    and `priority_queue`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些标准算法，如`merge`和`make_heap`，仅仅是构建更高层次实体（如`stable_sort`和`priority_queue`）所必需的构建块。
- en: How to sort a range based on a comparator other than `operator<`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何根据除`operator<`之外的比较器对范围进行排序
- en: How to manipulate sorted arrays using the *erase-remove idiom*
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用*erase-remove习语*操作排序数组
- en: A note about headers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于头文件的说明
- en: Most function templates discussed in this chapter are defined in the standard
    header `<algorithm>`. The special iterator types, on the other hand, are generally
    defined in `<iterator>`. If you're wondering where to find a specific entity,
    I strongly recommend that you consult an online reference such as [cppreference.com](https://cppreference.com)
    for the authoritative answer; don't just guess!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的大多数函数模板都定义在标准头文件`<algorithm>`中。另一方面，特殊的迭代器类型通常定义在`<iterator>`中。如果你想知道如何找到特定的实体，我强烈建议你咨询在线参考资料，如[cppreference.com](https://cppreference.com)，以获得权威答案；不要只是猜测！
- en: Read-only range algorithms
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只读范围算法
- en: In the preceding chapters, we built up an algorithm that we called `distance`
    and another called `count_if`. Both of these algorithms appear in the standard
    library.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们构建了一个我们称之为`distance`的算法，另一个称为`count_if`。这两个算法都出现在标准库中。
- en: '`std::count_if(a,b,p)` returns the number of elements between `a` and `b` that
    satisfy the predicate function `p`--that is, the number of elements `e` for which
    `p(e)` is `true`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::count_if(a,b,p)`返回满足谓词函数`p`的元素数量，即在`a`和`b`之间，使得`p(e)`为`true`的元素数量`e`。'
- en: Notice that, whenever we say "between `a` and `b`", we're talking about the
    range that includes `*a` but does not include `*b`--what mathematicians call a
    "half-open range" and represented by the asymmetrical notation `[a,b)`. Why should
    we not include `*b`? Well, for one thing, if `b` is the `end()` of some vector,
    then it doesn't point to an element of that vector at all! So in general, dereferencing
    the *end point* of a range is a dangerous thing to do. For another thing, using
    half-open ranges conveniently allows us to represent *empty* ranges; for example,
    the range "from `x` to `x`" is an empty range consisting of zero data elements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每当说到“在`a`和`b`之间”，我们都是在谈论包括`*a`但不包括`*b`的范围——数学家称之为“半开范围”，并用不对称的符号`[a,b)`表示。为什么我们不能包括`*b`呢？首先，如果`b`是某个向量的`end()`，那么它根本不指向该向量的任何元素！所以一般来说，解引用范围的*终点*是一件危险的事情。其次，使用半开范围方便地允许我们表示*空*范围；例如，“从`x`到`x`”的范围是一个包含零数据元素的空范围。
- en: 'Half-open ranges are quite natural in C++ just as they are in C. For decades,
    we''ve been writing for-loops that range from a lower bound (inclusive) to an
    upper bound (exclusive); this idiom is so common that deviation from the idiom
    often indicates a bug:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，半开范围与在C中一样自然。几十年来，我们一直在编写从下界（包含）到上界（不包含）的范围的for循环；这个习语如此常见，以至于偏离这个习语通常表明存在错误：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`std::distance(a,b)` returns the number of elements between `a` and `b`--that
    is, the number of times you''d have to apply `++` to `a` in order to reach `b`.
    You could think of this function as being equivalent in its effects to `std::count_if(a,b,[](auto&&){return
    true;})`.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::distance(a,b)`返回`a`和`b`之间的元素数量——也就是说，你需要将`++`应用于`a`多少次才能到达`b`。你可以将这个函数视为在效果上等同于`std::count_if(a,b,[](auto&&){return
    true;})`。'
- en: As we saw in [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d),
    *Iterators and Ranges*, if the iterators in question are random-access iterators,
    this number can be quickly computed as `(b - a)`, and so the standard `std::distance`
    will do so. Notice that `(b - a)` might be a negative number, if you gave the
    arguments in the "wrong" order!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 2 章](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d)，*迭代器和范围*
    中所看到的，如果相关的迭代器是随机访问迭代器，这个数字可以快速计算为 `(b - a)`，因此标准 `std::distance` 会这样做。请注意，`(b
    - a)` 可能是一个负数，如果你以“错误”的顺序给出了参数！
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the iterators are random-access iterators, `std::distance` does nothing
    more than subtract them; so passing in "wrongly ordered" arguments is explicitly
    supported and blessed by the C++ standard. However, if the iterators in question
    are merely bidirectional iterators (such as `std::list<int>::iterator`--see [Chapter
    4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d), *The Container Zoo*),
    "wrongly ordered" iterators are *not* supported. You might expect that `std::distance(b,a)
    == -std::distance(a,b)` should be true of all iterator types; but consider, how
    would the `std::distance` algorithm itself have any idea whether the iterators
    you gave it were "wrongly ordered" or not? The only thing it *can* do (in the
    absence of an `operator-`) is to keep incrementing `a`--perhaps past the end of
    the container and off into space--in the vain hope that it''ll eventually reach
    `b`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当迭代器是随机访问迭代器时，`std::distance` 实际上只是进行减法操作；因此，传递“错误顺序”的参数是明确支持并由 C++ 标准认可的。然而，如果相关的迭代器仅仅是双向迭代器（例如
    `std::list<int>::iterator`——见 [第 4 章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)，*容器动物园*），则不支持“错误顺序”的迭代器。你可能期望对于所有迭代器类型，`std::distance(b,a)
    == -std::distance(a,b)` 应该成立；但考虑一下，`std::distance` 算法本身如何知道你给出的迭代器是否“错误顺序”呢？它唯一能做的事情（在没有
    `operator-` 的情况下）是不断递增 `a`——可能超过容器的末尾，进入空间——在徒劳的希望中，它最终会到达 `b`：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Consult the diagrams of `std::list` and `std::forward_list` in [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*, to understand this code sample's odd behavior.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考 [第 4 章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d) 中 `std::list`
    和 `std::forward_list` 的图示，*容器动物园*，以理解这个代码示例的奇怪行为。
- en: '`std::count(a,b,v)` returns the number of elements between `a` and `b` that
    are equal to `v`--that is, the number of elements `e` for which `e == v` is true.
    You can think of this function as being equivalent in its effects to `std::count_if(a,b,[&v](auto&&
    e){return e == v;})`, and in fact both versions should give the same assembly
    code. If C++ had had lambda-expressions in 1998, they probably wouldn''t have
    put the `std::count` algorithm in the standard library.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::count(a,b,v)` 返回 `a` 和 `b` 之间等于 `v` 的元素数量——也就是说，对于 `e == v` 为真的元素 `e`
    的数量。你可以将这个函数视为在效果上等同于 `std::count_if(a,b,[&v](auto&& e){return e == v;})`，实际上两种版本应该给出相同的汇编代码。如果
    C++ 在 1998 年就有 lambda 表达式，他们可能就不会将 `std::count` 算法放入标准库中。'
- en: 'Notice that `std::count(a,b,v)` necessarily loops over *all* of the elements
    in the range between `a` and `b`. It can''t take advantage of special information
    you might have about the arrangement of the data in the range. For example, suppose
    I want to count the instances of `42` in a `std::set<int>`? I could write the
    code in either of the following ways:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `std::count(a,b,v)` 必然会遍历 `a` 和 `b` 之间的 **所有** 元素。它无法利用你可能对范围内数据排列的任何特殊信息。例如，假设我想计算
    `std::set<int>` 中 `42` 的实例？我可以以下两种方式之一编写代码：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The raw algorithm `std::count` is outperformed by the second approach, which
    simply asks the `set` itself for the answer. This turns a O(*n*) traversal of
    the whole set into a O(log *n*) tree lookup. Similarly, `std::unordered_set` provides
    a `count` method that is roughly O(1).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 原始算法 `std::count` 在性能上不如第二种方法，后者只是简单地向 `set` 本身请求答案。这把整个集合的 O(*n*) 遍历转换成了 O(log
    *n*) 的树查找。同样，`std::unordered_set` 提供了一个大致为 O(1) 的 `count` 方法。
- en: For more about these containers, see [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*; the takeaway point here right now is that, Q sometimes there
    is important structure in your data that can be exploited by choosing the proper
    tool for the job. Even though I'm pointing to cases where the standard algorithms
    seem to "magically" do the right thing (as with `std::distance` delegating to
    `(b - a)`), you should not imagine that this "magic" stretches farther than it
    does. The standard algorithms know only as much as they're told, which is to say,
    only about the properties of the *iterator types* you pass them. They'll never
    change their behavior based on the relationships of the *underlying data elements*
    to each other. Arranging your code to exploit relationships in the underlying
    data (for example, "this data is sorted," "this range spans the entire container")
    is part of your job as the programmer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些容器，更多内容请参阅第 4 章 [《容器动物园》](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)；目前这里的关键点是，有时你的数据中存在重要的结构，可以通过选择合适的工具来利用。尽管我在指出标准算法似乎“神奇地”做了正确的事情（例如
    `std::distance` 委派给 `(b - a)`），但你不应想象这种“魔法”比它所做的那样更远。标准算法只知道它们被告知的内容，也就是说，只关于你传递给它们的
    *迭代器类型* 的属性。它们永远不会根据 *底层数据元素* 之间的关系改变其行为。安排你的代码以利用底层数据中的关系（例如，“这些数据是有序的”，“这个范围跨越整个容器”）是作为程序员的你工作的一部分。
- en: Here are some more algorithms similar to `std::count` and `std::count_if`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些类似于 `std::count` 和 `std::count_if` 的算法。
- en: '`std::find(a,b,v)` and `std::find_if(a,b,p)` work just like `std::count(a,b,v)`
    and `std::count_if(a,b,p)` respectively, except that, rather than looping over
    the entire range and returning the *count* of matching elements, the `find` variants
    loop only until they''ve found the first match, and then return an iterator to
    the data element that matched. There is also a variant `find_if_not` that is just
    like `find_if` but with the sense of the predicate negated; this variant also
    probably wouldn''t have needed to exist if we''d gotten lambdas earlier in the
    history of C++:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::find(a,b,v)` 和 `std::find_if(a,b,p)` 的功能与 `std::count(a,b,v)` 和 `std::count_if(a,b,p)`
    分别相似，区别在于，`find` 变体不是遍历整个范围并返回匹配元素的 *计数*，而是只循环到找到第一个匹配项，然后返回指向匹配数据元素的迭代器。还有一个变体
    `find_if_not`，它与 `find_if` 类似，但谓词的感测被否定；如果我们在 C++ 的早期历史中得到了 lambdas，这个变体可能就不需要存在了：'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that because `find` returns *immediately* upon finding the first match,
    it's faster on average than the `count` algorithm (which scans the whole range
    no matter what). This kind of "return immediately" behavior is often referred
    to as "short-circuiting".
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为 `find` 在找到第一个匹配项时立即返回，所以它平均来说比 `count` 算法（无论什么情况都会扫描整个范围）要快。这种“立即返回”的行为通常被称为“短路”。
- en: '`std::all_of(a,b,p)`, `std::any_of(a,b,p)`, and `std::none_of(a,b,p)` return
    either `true` or `false`, depending on how often the provided predicate function
    `p` is true of the elements in the range. They can all be built on top of the
    `find` algorithms, thus picking up the short-circuiting behavior for free:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::all_of(a,b,p)`、`std::any_of(a,b,p)` 和 `std::none_of(a,b,p)` 根据提供的谓词函数
    `p` 在范围中的元素中为真的频率返回 `true` 或 `false`。它们都可以建立在 `find` 算法之上，从而免费获得短路行为：'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There is one more `find`-related algorithm I should mention: `find_first_of`.
    It implements the operation of "looking in a sequence for the first occurrence
    of any of a fixed set of target elements"--that is, just like `strcspn` in the
    C standard library, but for any type, not just `char`. Abstractly speaking, `find_first_of`
    takes two conceptual parameters: the range to search in, and the set of target
    elements. This being the STL, they''re both passed in as ranges, which is to say,
    pairs of iterators. So a call to this algorithm looks like `find_first_of(haystack,
    haystack, needle, needle)`: two pairs of iterators side by side. This can get
    confusing--beware of algorithms taking multiple similar parameters!'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该提一下一个与 `find` 相关的算法：`find_first_of`。它实现了在序列中查找固定集合中目标元素首次出现的操作——也就是说，就像
    C 标准库中的 `strcspn`，但适用于任何类型，而不仅仅是 `char`。抽象地说，`find_first_of` 接受两个概念参数：要搜索的范围和目标元素集合。由于这是
    STL，它们都作为范围传递，也就是说，迭代器对。因此，对这个算法的调用看起来像 `find_first_of(haystack, haystack, needle,
    needle)`：并排的两个迭代器对。这可能会让人困惑——当算法接受多个类似参数时要小心！
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that the "haystack" iterators are expected to be of any old `InputIterator`
    type, but the "needle" iterators are required to be at least `ForwardIterator`.
    Recall from [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d),
    *Iterators and Ranges*, that the big thing about `ForwardIterator` types is that
    they can be meaningfully *copied*, letting the same range be traversed multiple
    times. This is exactly what `find_first_of` needs! It traverses the "needle" range
    once per character in the "haystack"; so the "needle" must be re-traversable--and
    incidentally, must be finite in size! Contrariwise, there''s nothing particularly
    requiring that the "haystack" be finite; it might be pulling its elements from
    a potentially unbounded input stream:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，“稻草堆”迭代器预期是任何旧的`InputIterator`类型，但“针”迭代器必须至少是`ForwardIterator`。回想一下[第2章](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d)，“迭代器和范围”，`ForwardIterator`类型的一个重要特点是它们可以被有意义地**复制**，使得相同的范围可以被多次遍历。这正是`find_first_of`所需要的！它对“稻草堆”范围中的每个字符进行一次遍历；因此，“针”必须是可重遍历的——顺便说一下，还必须是有限大小的！相反，没有特别要求“稻草堆”必须是有限的；它可能从可能无界的输入流中提取其元素：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Speaking of multiple similar parameters, let''s finish our look at simple read-only
    algorithms with these two: `std::equal` and `std::mismatch`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到多个相似参数，让我们通过这两个来结束对简单只读算法的探讨：`std::equal`和`std::mismatch`。
- en: '`std::equal(a,b,c,d)` takes two iterator-pairs: the range `[a,b)` and the range
    `[c,d)`. It returns `true` if the two ranges are element-for-element equal, and
    `false` otherwise.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::equal(a,b,c,d)`接受两个迭代器对：范围`[a,b)`和范围`[c,d)`。如果两个范围元素逐个相等，则返回`true`，否则返回`false`。'
- en: '`std::mismatch(a,b,c,d)` is sort of like `find`: it''ll tell you exactly which
    pair of elements was the one that torpedoed the match:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::mismatch(a,b,c,d)`有点像`find`：它会告诉你确切哪一对元素破坏了匹配：'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice the use of `std::equal_to<>{}` as a predicate object; we won't cover
    the built-in predicates in depth in this book, so just take it for granted that
    `std::equal_to<>{}` is an object whose behavior is similar to `[](auto a, auto
    b){ return a == b; }` but with more *perfect forwarding* involved.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到使用了`std::equal_to<>{}`作为谓词对象；在这本书中，我们不会深入探讨内置谓词，所以请假设`std::equal_to<>{}`是一个行为类似于`[](auto
    a, auto b){ return a == b; }`的对象，但涉及更多的**完美转发**。
- en: Finally, watch out again! Many of the two-range algorithms in the C++17 standard
    library also have variant forms colloquially known as one-and-a-half-range algorithms.
    For example, in addition to `std::mismatch(a,b,c,d)` you'll find `std::mismatch(a,b,c)`--the
    second range's "end" point is simply assumed to be at `c + std::distance(a, b)`.
    If `c` actually points into a container where `c + std::distance(a, b)` would
    be "off the end," then, tough luck!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，再次注意！C++17标准库中的许多双范围算法也有被称为半范围算法的变体形式。例如，除了`std::mismatch(a,b,c,d)`之外，你还会发现`std::mismatch(a,b,c)`——第二个范围的“结束”点简单地假设为`c
    + std::distance(a, b)`。如果`c`实际上指向一个容器，其中`c + std::distance(a, b)`将是“超出范围”，那么，运气不佳！
- en: Because "tough luck" is never a really *great* answer to a technical question,
    the C++17 standard added safe two-range variants for many of the one-and-a-half-range
    algorithms that had existed in C++14.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因为“运气不佳”永远不是对技术问题的真正**伟大**回答，C++17标准为许多在C++14中存在的半范围算法添加了安全的双范围变体。
- en: Shunting data with std::copy
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::copy移动数据
- en: We've just seen our first few two-range algorithms. The `<algorithm>` header
    is full of two-range algorithms and their siblings, the one-and-a-half-range algorithms.
    What's the simplest possible such algorithm?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了几个双范围算法。`<algorithm>`头文件充满了双范围算法及其兄弟半范围算法。这种算法可能有多简单？
- en: 'A reasonable answer would be: "Copy each data element from the first range
    into the second range." Indeed, the STL provides that algorithm, under the name
    `std::copy`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合理的回答可能是：“将每个数据元素从第一个范围复制到第二个范围。”实际上，STL提供了这个算法，名为`std::copy`：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that this is a one-and-a-half-range algorithm. The standard library actually
    does not provide a two-range version of `std::copy`; the assumption is that if
    you are actually trying to write into a buffer, then you must have checked its
    size already, so checking "are we at the end of the buffer yet" inside the loop
    would be both redundant and inefficient.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是一个半范围算法。标准库实际上没有提供`std::copy`的双范围版本；假设如果你实际上正在尝试写入缓冲区，那么你一定已经检查了它的大小，所以在循环中检查“我们是否到达了缓冲区的末尾”将是既冗余又低效的。
- en: 'Now I can practically hear you exclaiming: "Horrors! This is the same crude
    logic that brought us `strcpy`, `sprintf`, and `gets`! This is an invitation to
    buffer overflows!" Well, *if* you were to exclaim thusly, you''d be right about
    the bad behavior of `gets`--in fact, the `gets` function has been officially removed
    from the C++17 standard library. And you''d be right about `sprintf`--anyone who
    needs that functionality is better of using the range-checked version `snprintf`,
    which is analogous to a "two-range algorithm" in this context. But about `strcpy`
    I''d disagree. With `gets` it is *impossible* to know the correct size for the
    output buffer; with `sprintf` it is *difficult*; but with `strcpy` it is *trivial*:
    you just measure the `strlen` of the input buffer and that''s your answer. Likewise
    with `std::copy`, the relationship between "input elements consumed" and "output
    elements produced" is exactly one-to-one, so sizing the output buffer doesn''t
    present a technical challenge.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以几乎听到你在惊叹：“天哪！这正是导致我们有了 `strcpy`、`sprintf` 和 `gets` 的那种粗糙逻辑！这是对缓冲区溢出的邀请！”好吧，*如果你这样惊叹，那么你对
    `gets` 的不良行为判断是正确的——实际上，`gets` 函数已经被正式从 C++17 标准库中移除。你对 `sprintf` 的看法也是正确的——任何需要该功能的人最好使用经过范围检查的版本
    `snprintf`，在这个上下文中，它类似于一个“双范围算法”。但关于 `strcpy`，我不同意。对于 `gets`，确定输出缓冲区的正确大小是*不可能的*；对于
    `sprintf`，是*困难的*；但对于 `strcpy`，是*微不足道的*：你只需测量输入缓冲区的 `strlen`，这就是你的答案。同样，对于 `std::copy`，"输入元素消耗"
    和 "输出元素产生" 之间的关系是一对一，因此输出缓冲区的大小并不构成技术挑战。
- en: 'Notice that the parameter we called `destination` is an *output iterator*.
    This means that we can use `std::copy`, not merely to shunt data around in memory,
    but even to feed data to an arbitrary "sink" function. For example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们称之为 `destination` 的参数是一个*输出迭代器*。这意味着我们可以使用 `std::copy`，不仅可以在内存中移动数据，甚至可以将数据提供给任意的“接收”函数。例如：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You may find it instructive to compare this version of our `putc_iterator` to
    the version from [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d),
    *Iterators and Ranges*; this version is using `boost::iterator_facade` as introduced
    at the end of [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d),
    *Iterators and Ranges* and also using a common trick to return `*this` instead
    of a new proxy object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现将这个版本的 `putc_iterator` 与 [第 2 章](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d)
    中提到的版本进行比较是有益的；这个版本使用了在 [第 2 章](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d)
    的末尾介绍的 `boost::iterator_facade`，并且还使用了一个常见的技巧来返回 `*this` 而不是一个新的代理对象。
- en: 'Now we can use the flexibility of `destination` to solve our concerns about
    buffer overflow! Suppose that, instead of writing into a fixed-size array, we
    were to write into a resizable `std::vector` (see [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*). Then "writing an element" corresponds to "pushing an element
    back" on the vector. So we could write an output iterator very similar to `putc_iterator`,
    that would `push_back` instead of `putc`, and then we''d have an overflow-proof
    way of filling up a vector. Indeed, the standard library provides just such an
    output iterator, in the `<iterator>` header:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以利用 `destination` 的灵活性来解决我们对缓冲区溢出的担忧！假设我们不是写入一个固定大小的数组，而是写入一个可调整大小的 `std::vector`（参见
    [第 4 章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d) 的“容器动物园”）。那么，“写入一个元素”对应于“在向量上推入一个元素”。因此，我们可以编写一个非常类似于
    `putc_iterator` 的输出迭代器，它将使用 `push_back` 而不是 `putc`，然后我们就有了一种防止溢出的填充向量的方法。实际上，标准库在
    `<iterator>` 头文件中就提供了这样的输出迭代器：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The function call `std::back_inserter(dest)` simply returns a `back_insert_iterator`
    object. In C++17, we could rely on template type deduction for constructors and
    write the body of that function as simply `return std::back_insert_iterator(dest)`;
    or dispense with the function entirely and just write `std::back_insert_iterator(dest)`
    directly in our code--where C++14 code would have to "make do" with `std::back_inserter(dest)`.
    However, why would we want all that extra typing? The name `back_inserter` was
    deliberately chosen to be easy to remember, since it's the one that we were expected
    to use most often. Although C++17 allows us to write `std::pair` in place of `std::make_pair`,
    and `std::tuple` in place of `std::make_tuple`, it would be silly to write the
    cumbersome `std::back_insert_iterator` in place of `std::back_inserter`. You should
    prefer `std::back_inserter(dest)` even in C++17.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用 `std::back_inserter(dest)` 简单地返回一个 `back_insert_iterator` 对象。在 C++17 中，我们可以依赖模板类型推导来构造函数，并将该函数体的内容简单地写为
    `return std::back_insert_iterator(dest)`；或者完全省略该函数，直接在我们的代码中写 `std::back_insert_iterator(dest)`--在
    C++14 代码中则必须使用 `std::back_inserter(dest)` 来“应付”。然而，为什么我们要输入那么多额外的代码？名称 `back_inserter`
    被故意选择为易于记忆，因为它是我们预期最常使用的。尽管 C++17 允许我们用 `std::pair` 替代 `std::make_pair`，用 `std::tuple`
    替代 `std::make_tuple`，但在 C++17 中用繁琐的 `std::back_insert_iterator` 替代 `std::back_inserter`
    是愚蠢的。即使在 C++17 中，你也应该首选 `std::back_inserter(dest)`。
- en: Variations on a theme - std::move and std::move_iterator
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题变奏 - std::move 和 std::move_iterator
- en: 'As you might guess from the name, or you might have noticed in the preceding
    implementation, the `std::copy` algorithm works by copying elements from the input
    range to the output. As of C++11, you might wonder: What if instead of *copying*
    the elements, we used move semantics to *move* them from the input to the output?'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，或者你可能已经在前面的实现中注意到，`std::copy` 算法通过从输入范围复制元素到输出工作。截至 C++11，你可能会想：如果我们不是
    *复制* 元素，而是使用移动语义将它们从输入 *移动* 到输出会怎样？
- en: 'The STL provides two different approaches to this problem. The first one is
    the most straightforward: there is a `std::move` algorithm (defined in the `<algorithm>`
    header) with the following definition:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: STL 为此问题提供了两种不同的方法。第一种方法是最直接的：有一个 `std::move` 算法（定义在 `<algorithm>` 头文件中），其定义如下：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's exactly the same as the `std::copy` algorithm except for the addition of
    a single `std::move` on the input element (be careful--this inner `std::move`,
    with *one* argument, defined in the `<utility>` header, is a completely different
    beast from the outer, three-argument `std::move` defined in `<algorithm>`! The
    fact that they share a name is unfortunate. Ironically, one of the few other STL
    functions to suffer a similar situation is `std::remove`; see the *Deleting from
    a sorted array* section, and also [Chapter 12](part0188.html#5J99O0-2fdac365b8984feebddfbb9250eaf20d),
    *Filesystem*).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 `std::copy` 算法完全相同，只是在输入元素上添加了一个 `std::move` 操作（小心--这个内部 `std::move`，带有一个
    *参数*，定义在 `<utility>` 头文件中，与定义在 `<algorithm>` 中的外部三个参数的 `std::move` 完全不同！它们共享一个名称是不幸的。讽刺的是，其他少数
    STL 函数也遭受了类似的情况，比如 `std::remove`；参见 *从排序数组中删除* 部分，以及 [第 12 章](part0188.html#5J99O0-2fdac365b8984feebddfbb9250eaf20d)，*文件系统*)。
- en: The other approach is a variation of what we saw previously with `back_inserter`.
    Rather than switching out the core *algorithm*, we can continue using `std::copy`
    but parameterize it differently. Suppose we passed in a new type of iterator,
    which (like `back_inserter`) wrapped around our original object and changed its
    behavior? In particular, we need an input iterator whose `operator*` returns an
    rvalue. We can do that!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是我们之前看到的 `back_inserter` 的变体。而不是更换核心 *算法*，我们可以继续使用 `std::copy` 但以不同的方式参数化。假设我们传递了一个新的迭代器类型，它（就像
    `back_inserter` 一样）围绕我们的原始对象并改变其行为？特别是，我们需要一个输入迭代器，其 `operator*` 返回一个右值。我们可以做到这一点！
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Sorry for the density of that code; trust me that you can safely skip over the
    details. For those who like this kind of thing, you might notice that we're providing
    a templated constructor from `move_iterator<U>` that happens to double as our
    copy constructor (when `U` is the same type as `It`); and that we're providing
    a lot of member functions (such as `operator[]` and `operator--`) whose bodies
    will error out for a lot of possible types of `It` (for example, when `It` is
    a forward iterator--see [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d),
    *Iterators and Ranges*), but this is fine because their bodies won't get instantiated
    unless the user actually tries to call those functions at compile time (if the
    user actually *does* try to `--` a `move_iterator<list_of_ints::iterator>`, then
    of course that'll yield a compile-time error).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这段代码的密集性，我表示歉意；请相信你可以安全地跳过细节。对于那些喜欢这类东西的人来说，你可能注意到我们提供了一个从 `move_iterator<U>`
    到模板构造函数，它恰好也充当了我们的复制构造函数（当 `U` 与 `It` 类型相同时）；我们还提供了许多成员函数（例如 `operator[]` 和 `operator--`），它们的主体对于许多可能的
    `It` 类型（例如，当 `It` 是一个前向迭代器时--见[第2章](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d)，*迭代器和范围*）将产生错误，但这是可以的，因为它们的主体只有在用户实际在编译时尝试调用这些函数时才会实例化（如果用户实际上尝试对
    `move_iterator<list_of_ints::iterator>` 进行 `--` 操作，那么当然会产生编译时错误）。
- en: Just as with `back_inserter`, notice that the STL provides a helper function
    `make_move_iterator` for the benefit of pre-C++17 compilers that don't have constructor
    template type deduction. In this case, as with `make_pair` and `make_tuple`, the
    "helper" name is uglier than the actual class name, and so I tentatively recommend
    using the C++17 feature in your code; why type an extra five characters and instantiate
    an extra function template if you don't have to?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `back_inserter` 一样，请注意，STL 为那些没有构造函数模板类型推导的预 C++17 编译器提供了一个辅助函数 `make_move_iterator`。在这种情况下，就像
    `make_pair` 和 `make_tuple` 一样，"辅助" 名称比实际类名更丑陋，所以我建议你在代码中使用 C++17 的特性；如果你不需要，为什么要多打五个字符并实例化一个额外的函数模板呢？
- en: 'Now we have two different ways of moving data from one container or range to
    another: the `std::move` algorithm and the `std::move_iterator` adaptor class.
    Here are examples of both idioms:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两种不同的方式将数据从一个容器或范围移动到另一个：`std::move` 算法和 `std::move_iterator` 适配器类。以下是这两种习惯用法的示例：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first approach, using `std::move`, is obviously much cleaner if moving data
    is all you're doing. So why did the standard library bother to provide this "messier"
    approach with `move_iterator`? To answer that question, we'll have to explore
    yet another algorithm that is fundamentally related to `std::copy`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法，使用 `std::move`，如果你只是移动数据，显然要干净得多。那么，为什么标准库要提供这种“更混乱”的方法 `move_iterator`
    呢？为了回答这个问题，我们不得不探索另一个与 `std::copy` 基本相关的算法。
- en: Complicated copying with std::transform
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::transform 进行复杂复制
- en: 'You might have noticed, way back when we presented the implementation of `std::copy`,
    that the `value_type` of the two iterator type parameters were not constrained
    to be the same. This is a feature, not a bug! It means that we can write code
    that relies on implicit conversions and it will just Do The Right Thing:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了，当我们之前展示了 `std::copy` 的实现时，两个迭代器类型参数的 `value_type` 并没有限制必须相同。这是一个特性，而不是错误！这意味着我们可以编写依赖于隐式转换的代码，并且它将正确地执行：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Looks trivial, right? Look closely! Deep within our instantiation of `std::copy`
    is a call to the implicit constructor that converts `const char *` (the type of
    `*input.begin()`) to `std::string` (the type of `*output.begin()`). So for the
    umpteenth time, we're seeing an example of generic code that does surprisingly
    complicated operations simply by virtue of being given certain iterator types.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，对吧？仔细看看！在我们对 `std::copy` 的实例化中，有一个调用隐式构造函数，它将 `const char *`（`*input.begin()`
    的类型）转换为 `std::string`（`*output.begin()` 的类型）。所以，我们又一次看到了一个示例，即通用代码通过简单地提供某些迭代器类型，就能执行令人惊讶的复杂操作。
- en: But sometimes you want to apply a complicated transformation function during
    the copying operation--something more complicated than implicit conversions can
    handle. The standard library has got you covered!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时你希望在复制操作期间应用一个复杂的转换函数--比隐式转换更复杂的函数。标准库已经为你准备好了！
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Sometimes you even need to do a transformation using a function that takes
    *two* arguments. Again the library has you covered:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要使用一个接受 *两个* 参数的函数来进行转换。库已经为你准备好了：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This version of `std::transform` might be humorously described as a one-and-two-halves-range
    algorithm!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的 `std::transform` 可以幽默地描述为一种一又二分之一的范围算法！
- en: (What about functions of three arguments? Four arguments? Unfortunately there's
    no fully variadic version of `std::transform`; variadic templates weren't introduced
    to C++ until C++11\. You might try implementing a variadic version and see what
    kinds of problems you run into--they're surmountable but certainly not trivial.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: （关于三个参数的函数？四个参数的函数？不幸的是，`std::transform` 没有完全可变参数版本；可变模板直到 C++11 才被引入到 C++ 中。你可以尝试实现一个可变参数版本，看看会遇到什么问题——它们是可克服的，但绝对不是微不足道的。）
- en: 'The existence of `std::transform` gives us yet a third way to move data elements
    from one place to another:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::transform` 的存在为我们提供了将数据元素从一个地方移动到另一个地方的第三种方法：'
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I certainly don't recommend this approach, though! The biggest and reddest of
    its red flags is that it contains explicit specialization of the `std::move` template.
    Whenever you see an explicit specialization--those angle brackets after the template's
    name--that's an almost sure sign of very subtle and fragile code. Advanced readers
    might enjoy figuring out how the compiler deduces which of the two `std::move`s
    I meant; remember, there's one in `<utility>` and one in `<algorithm>`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我当然不推荐这种方法！它的最大和最明显的红旗是它包含了 `std::move` 模板的显式特化。每当你在模板名称后看到显式特化——那些模板名称后的尖括号——这几乎可以肯定是非常微妙和脆弱的代码。高级读者可能会喜欢弄清楚编译器如何推断出我指的是两个
    `std::move` 中的哪一个；记住，一个在 `<utility>` 中，一个在 `<algorithm>` 中。
- en: Write-only range algorithms
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只写范围算法
- en: 'We began this chapter looking at algorithms such as `std::find` that march
    through a range reading its elements in order without modification. You might
    be surprised to learn that the inverse operation also makes sense: there is a
    family of standard algorithms that march through a range *modifying* each element
    without reading it!'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时查看了一些算法，例如 `std::find`，这些算法遍历一个范围，按顺序读取其元素而不进行修改。你可能会惊讶地发现逆操作也是有意义的：存在一组标准算法，它们遍历一个范围
    *修改* 每个元素而不读取它！
- en: '`std::fill(a,b,v)` does what its name implies: fill each element of the given
    range `[a,b)` with a copy of the provided value `v`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::fill(a,b,v)` 做的正如其名所暗示的那样：将给定范围 `[a,b)` 的每个元素填充为提供的值 `v` 的副本。'
- en: '`std::iota(a,b,v)` is slightly more interesting: it fills the elements of the
    given range with copies of `++v`. That is, `std::iota(a,b,42)` will set `a[0]`
    equal to 42, `a[1]` equal to 43, `a[2]` equal to 44, and so on all the way up
    to `b`. This algorithm''s funny name comes from the APL programming language,
    where a function named `ι` (that''s the Greek letter *iota*) performed this operation.
    Another funny thing about this algorithm is that, for whatever reason, its definition
    is found in the standard `<numeric>` header instead of in `<algorithm>`. It''s
    just an oddball that way.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::iota(a,b,v)` 稍微更有趣：它将给定范围的元素填充为 `++v` 的副本。也就是说，`std::iota(a,b,42)` 将将
    `a[0]` 设置为 42，`a[1]` 设置为 43，`a[2]` 设置为 44，以此类推，直到 `b`。这个算法有趣的名字来源于 APL 编程语言，其中名为
    `ι`（希腊字母 *iota*）的函数执行了这个操作。这个算法的另一个有趣之处在于，出于某种原因，它的定义可以在标准 `<numeric>` 头文件中找到，而不是在
    `<algorithm>` 中。它就是这样一种怪异的算法。'
- en: '`std::generate(a,b,g)` is even more interesting: it fills the elements of the
    given range with the successive results of `g()`, whatever it is:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::generate(a,b,g)` 更有趣：它将给定范围的元素填充为 `g()` 的连续结果，无论它是什么：'
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here''s an example of using each of these standard algorithms to fill a vector
    of strings with different contents. Test your understanding: do you understand
    why each call produces the output that it does? The example I picked for `std::iota`
    is particularly interesting (yet unlikely to be helpful in real-world code):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用这些标准算法填充具有不同内容的字符串向量的示例。测试你的理解：你是否理解为什么每个调用会产生这样的输出？我选择的 `std::iota` 的例子特别有趣（但在现实世界的代码中不太可能有用）：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Algorithms that affect object lifetime
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 影响对象生命周期的算法
- en: 'The `<memory>` header provides an obscure family of algorithms with names such
    as `std::uninitialized_copy`, `std::uninitialized_default_construct`, and `std::destroy`
    (for the full list, consult an online reference such as [cppreference.com](http://cppreference.com)).
    Consider the following algorithm that uses explicit destructor calls to destroy
    the elements of a range:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`<memory>` 头文件提供了一组名为 `std::uninitialized_copy`、`std::uninitialized_default_construct`
    和 `std::destroy`（完整列表，请参考在线参考资料，如 [cppreference.com](http://cppreference.com)）的晦涩算法。考虑以下使用显式析构函数调用销毁范围元素的算法：'
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that `std::addressof(x)` is a convenient little helper function that
    returns the address of its parameter; it's exactly the same thing as `&x` except
    in the rare case that `x` is of some class type that sadistically overloads its
    own `operator&`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`std::addressof(x)`是一个方便的小辅助函数，它返回其参数的地址；它与`&x`完全相同，只是在`x`是某些类类型并且残酷地重载了自己的`operator&`的罕见情况下除外。
- en: 'And consider this algorithm that uses explicit placement-new syntax to "copy-construct
    into" the elements of a range (notice how it neatly cleans up after itself if
    an exception is thrown during the copying). This algorithm clearly shouldn''t
    be used on any range whose elements already exist; so the following example looks
    very contrived:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个使用显式placement-new语法“复制构造”到范围元素中的算法（注意，如果在复制过程中抛出异常，它会干净利落地清理）。这个算法显然不应该用于任何已经存在元素的任何范围；所以以下例子看起来非常牵强：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We'll see more about how these algorithms are *meant* to be used in [Chapter
    4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d), *The Container Zoo*,
    when we talk about `std::vector`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第4章中了解更多关于这些算法应该如何使用的信息，*容器动物园*，当我们讨论`std::vector`时。
- en: 'Our first permutative algorithm: std::sort'
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个排列算法：std::sort
- en: So far all the algorithms we've covered simply walk through their given ranges
    in order, linearly, from one element to the next. Our next family of algorithms
    doesn't behave that way. Instead, it takes the values of the elements in the given
    range and shuffles them around so that the same values still appear, but in a
    different order. The mathematical name for this operation is a *permutation*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的所有算法都是简单地按顺序遍历它们给定的范围，线性地从第一个元素到下一个元素。我们下一系列的算法不会这样表现。相反，它将给定范围中元素的值打乱，使得相同的值仍然出现，但顺序不同。这种操作的数学名称是排列。
- en: 'The simplest permutative algorithm to describe is `std::sort(a,b)`. It does
    what the name implies: sort the given range so that the smallest elements appear
    at the front and the biggest elements at the back. To figure out which elements
    are "smallest," `std::sort(a,b)` uses `operator<`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的排列算法要描述的是`std::sort(a,b)`。它做的是名字暗示的事情：对给定的范围进行排序，使得最小的元素出现在前面，最大的元素出现在后面。为了确定哪些元素是“最小的”，`std::sort(a,b)`使用`operator<`。
- en: 'If you want a different order, you could try to overload `operator<` to return
    `true` under different conditions--but probably what you should do is use the
    three-argument version of the algorithm, `std::sort(a,b,cmp)`. The third argument
    should be a *comparator*; that is, a function, functor, or lambda that returns
    `true` whenever its first argument is "smaller" than its second argument. For
    example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想有不同的顺序，你可以尝试重载`operator<`以在不同的条件下返回`true`--但可能你应该使用算法的三参数版本，`std::sort(a,b,cmp)`。第三个参数应该是一个比较器；也就是说，一个函数、仿函数或lambda，当其第一个参数“小于”第二个参数时返回`true`。例如：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice that I carefully chose my lambda in this example so that it would sort
    the array in a deterministic way. If I''d chosen the function `(a % 6 < b % 6)`
    instead, then there would have been two possible outputs: either `{1, 1, 3, 9,
    4, 5}` or `{1, 1, 9, 3, 4, 5}`. The standard `sort` algorithm doesn''t guarantee
    anything about the relative position of elements that happen to be *equal* under
    the given comparison function!'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我在这个例子中仔细选择了我的lambda，以便以确定的方式对数组进行排序。如果我用函数`(a % 6 < b % 6)`代替，那么可能会有两种可能的输出：要么是`{1,
    1, 3, 9, 4, 5}`，要么是`{1, 1, 9, 3, 4, 5}`。标准的`sort`算法对于在给定比较函数下恰好相等的元素的相对位置没有任何保证！
- en: To fix this problem (if it *is* a problem), you should replace your use of `std::sort`
    with `std::stable_sort`. The latter might be a little slower, but it will guarantee
    that in the case of equal elements the original order is preserved--that is, in
    this case we'll get `{1, 1, 3, 9, 4, 5}` because in the original (unsorted) vector,
    element `3` came in front of element `9`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题（如果它确实是一个问题），你应该将你的`std::sort`使用替换为`std::stable_sort`。后者可能稍微慢一点，但它将保证在相等元素的情况下保留原始顺序--也就是说，在这种情况下，我们将得到`{1,
    1, 3, 9, 4, 5}`，因为在原始（未排序）向量中，元素`3`在元素`9`之前。
- en: There's an even worse thing that can happen with `sort` and `stable_sort`--what
    if I had chosen the comparison function `(a % 6 < b)`? Then I would have had certain
    pairs of elements `x, y` where `x < y` and simultaneously `y < x`! (One such pair
    of elements in the original vector is `5` and `9`.) In this case, there's nothing
    that can save us; we've passed in a "comparison function" that simply *isn't*
    a comparison function! This is a violation of the preconditions of `std::sort`,
    just as if we'd passed it a null pointer. When sorting an array, make sure you're
    sorting it based on a comparison function that makes sense!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sort` 和 `stable_sort` 还可能发生更糟糕的事情——如果我选择了比较函数 `(a % 6 < b)` 会怎样？那么我就会有一些元素对
    `x, y`，其中 `x < y` 同时 `y < x`！（原始向量中的一个这样的元素对是 `5` 和 `9`。）在这种情况下，没有什么可以拯救我们；我们传递了一个“比较函数”，而这个函数根本就不是比较函数！这与传递空指针给
    `std::sort` 的先决条件相违背。在排序数组时，确保你是基于一个有意义的比较函数进行排序！
- en: Swapping, reversing, and partitioning
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换、反转和划分
- en: The STL contains a surprisingly large number of permutative algorithms besides
    `std::sort`. Many of these algorithms can be seen as "building blocks" that implement
    just a small part of the overall sorting algorithm.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: STL 除了 `std::sort` 之外还包含大量排列算法。许多这些算法可以被视为“构建块”，它们仅实现了整体排序算法的一小部分。
- en: '`std::swap(a,b)` is the most basic building block; it just takes its two arguments
    and "swaps" them--which is to say, it exchanges their values. This is implemented
    in terms of the given type''s move constructor and move assignment operator. `swap`
    is actually a little special among the standard algorithms because it is *such*
    a primitive operation, and because there is *almost always* a faster way to swap
    two arbitrary objects than by performing the equivalent of `temp = a; a = b; b
    = temp;`. The usual idiom for standard library types (such as `std::vector`) is
    for the type itself to implement a `swap` member function (as in `a.swap(b)`),
    and then to add a function overload of `swap` in the same namespace as the type--that
    is, if we''re implementing `my::obj`, we''d add the overload in namespace `my`--such
    that `swap(a,b)` for that particular type, will call `a.swap(b)` instead of doing
    the three move operations. Here''s an example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::swap(a,b)` 是最基本的构建块；它只是接受它的两个参数并将它们“交换”——也就是说，它交换它们的值。这是通过给定类型的移动构造函数和移动赋值运算符实现的。`swap`
    在标准算法中实际上有点特殊，因为它是一个如此原始的操作，而且几乎总是有比执行 `temp = a; a = b; b = temp;` 等效操作更快的方式来交换两个任意对象。对于标准库类型（如
    `std::vector`）的常用惯例是类型本身实现一个 `swap` 成员函数（如 `a.swap(b)`），然后在类型的同一命名空间中添加 `swap`
    函数的重载——也就是说，如果我们正在实现 `my::obj`，我们会在命名空间 `my` 中添加重载，这样对于该特定类型的 `swap(a,b)`，将调用
    `a.swap(b)` 而不是执行三个移动操作。以下是一个例子：'
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we have `swap` and bidirectional iterators, we can build `std::reverse(a,b)`,
    a permutative algorithm that simply reverses the order of a range of elements
    by swapping the first item with the last item, the second item with the penultimate
    item, and so on. One common application of `std::reverse` is to reverse the order
    of larger chunks of a string--for example, to reverse the order of the words in
    a sentence:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `swap` 和双向迭代器，我们可以构建 `std::reverse(a,b)`，这是一个排列算法，它通过交换第一个元素与最后一个元素、第二个元素与倒数第二个元素，依此类推，简单地反转元素范围的顺序。`std::reverse`
    的一个常见应用是反转字符串中较大的块顺序——例如，反转句子中单词的顺序：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A small tweak to the implementation of `std::reverse` gives us another building
    block of `sort`, namely `std::partition`. Whereas `std::reverse` walks through
    the range from both ends swapping each pair of elements unconditionally, `std::partition`
    swaps them only if they are "out of order" with respect to a certain predicate
    function. In the following example, we''re partitioning all *even* elements to
    the front of our range and all *odd* elements to the back. If we were using `std::partition`
    to build a Quicksort sorting routine, we''d be partitioning elements *less than
    the pivot element* to the front of the range and elements *greater than the pivot
    element* to the back:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `std::reverse` 的实现进行一点小的调整，我们得到了排序的另一个构建块，即 `std::partition`。与 `std::reverse`
    从两端遍历范围无条件地交换每一对元素不同，`std::partition` 只有在元素相对于某个谓词函数“顺序错误”时才交换它们。在以下示例中，我们将所有
    *偶数* 元素划分到范围的起始位置，所有 *奇数* 元素划分到范围的末尾。如果我们使用 `std::partition` 来构建 Quicksort 排序程序，我们将把小于枢轴元素的元素划分到范围的起始位置，把大于枢轴元素的元素划分到范围的末尾：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You might notice something interesting about the preceding code: The code for
    `reverse` and the code for `partition` are almost identical! The only difference
    is that `partition` contains an awkward do-while loop where `reverse` has just
    a simple increment or decrement.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到前面代码的一个有趣之处：`reverse`和`partition`的代码几乎完全相同！唯一的区别是`partition`包含一个令人不快的do-while循环，而`reverse`只有简单的递增或递减。
- en: You might also have noticed that the first do-while loop in `partition` is equivalent
    to a standard algorithm we've already seen; namely, `std::find_if_not`. And the
    second do-while loop is sort of equivalent to `std::find_if`... except that it
    needs to run *backwards*, not forwards! Unfortunately for us, there is no such
    algorithm as `std::rfind_if`. But--as you might have suspected by now--the standard
    library isn't going to leave us in the lurch.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到`partition`中的第一个do-while循环与我们之前看到的标准算法等价；即`std::find_if_not`。第二个do-while循环类似于`std::find_if`...
    但它需要向后运行，而不是向前！不幸的是，我们没有`std::rfind_if`这样的算法。但是——正如你可能已经猜到的——标准库不会让我们陷入困境。
- en: 'We need something that behaves just like an iterator for the purposes of `std::find_if`,
    but iterates "backwards." The standard library provides this exact thing in the
    form of the `std::reverse_iterator` adaptor. We won''t show the code for it; revisit
    [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d), *Iterators
    and Ranges*, if you need a refresher on how it might be implemented. Suffice it
    to say, a `std::reverse_iterator<FwdIt>` object wraps and behaves just like a
    `FwdIt` object, except that when you increment the wrapper, it decrements the
    wrapped object, and vice versa. So we can write `partition` in terms of `reverse_iterator`
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个在`std::find_if`的目的上表现得像迭代器，但迭代“反向”的东西。标准库以`std::reverse_iterator<FwdIt>`适配器的形式提供了这个确切的东西。我们不会展示它的代码；如果你需要复习如何实现它，请回顾[第2章](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d)，*迭代器和范围*。简而言之，`std::reverse_iterator<FwdIt>`对象就像一个`FwdIt`对象一样包装和表现，除了当你递增包装器时，它会递减被包装的对象，反之亦然。因此，我们可以用`reverse_iterator`来写`partition`，如下所示：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Of course, sometimes it''s useful to partition a range without changing the
    relative order of the elements in either partition. For those times, there''s
    `std::stable_partition(a,b,p)` (but see the section *Merges and mergesort* for
    a caveat about `stable_partition`: It may allocate memory using `operator new`).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时在保持每个分区中元素相对顺序不变的情况下对范围进行分区是有用的。在这些情况下，可以使用`std::stable_partition(a,b,p)`（但请参阅关于`stable_partition`的警告部分：它可能会使用`operator
    new`分配内存）。
- en: 'There are a few non-permutative algorithms that also deal with partitions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些非排列算法也处理分区：
- en: '`std::is_partitioned(a,b,p)` returns `true` if the given range is already partitioned
    by the predicate `p` (so that all the elements satisfying `p` come at the front
    and all the ones not satisfying `p` come at the back).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::is_partitioned(a,b,p)`如果给定的范围已经通过谓词`p`分区（即满足`p`的所有元素都在前面，而不满足`p`的所有元素都在后面），则返回`true`。'
- en: '`std::partition_point(a,b,p)` uses binary search to find the first element
    in an already partitioned range that doesn''t satisfy `p`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::partition_point(a,b,p)`使用二分查找来找到已经分区范围内不满足`p`的第一个元素。'
- en: '`std::partition_copy(a,b,ot,of,p)` copies each of the elements in the range
    `[a,b)` to one or the other of the output iterators: `*ot++ = e` for elements
    where `p(e)` is `true`, and `*of++ = e` for elements where `p(e)` is `false`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::partition_copy(a,b,ot,of,p)`将范围`[a,b)`中的每个元素复制到输出迭代器之一：对于满足`p(e)`的元素，`*ot++
    = e`；对于不满足`p(e)`的元素，`*of++ = e`。'
- en: Incidentally, if you only want one output sequence or the other, then you can
    use `std::copy_if(a,b,ot,p)` or `std::remove_copy_if(a,b,of,p)` respectively.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果你只想得到一个输出序列或另一个，那么你可以分别使用`std::copy_if(a,b,ot,p)`或`std::remove_copy_if(a,b,of,p)`。
- en: Rotation and permutation
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转和排列
- en: 'Remember our code from *Swapping, reversing, and partitioning* to reverse the
    order of words in a sentence? When the "sentence" contains only two words, there
    is another way to look at the reversal: you could consider it a *cyclic rotation*
    of the elements in the underlying range. `std::rotate(a,mid,b)` rotates the elements
    of the range `[a,b)` so that the element formerly addressed by `mid` is now at
    `a` (and returns an iterator pointing to the element whose value was formerly
    at `a`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们来自 *交换、反转和分区* 的代码，用来反转句子中单词的顺序吗？当“句子”只包含两个单词时，还有另一种看待反转的方法：你可以将其视为底层范围中元素的
    *循环旋转*。`std::rotate(a,mid,b)` 将范围 `[a,b)` 的元素旋转，使得原本由 `mid` 指向的元素现在位于 `a`（并返回一个指向原本位于
    `a` 的元素的迭代器）：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Another miscellaneous but sometimes useful permutative algorithm is `std::next_permutation(a,b)`.
    Calling this function in a loop runs through all the possible permutations of
    *n* elements, which might be useful if you''re trying to brute-force a solution
    to a (small) instance of the Traveling Salesman Problem:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个杂项但有时有用的排列算法是 `std::next_permutation(a,b)`。在循环中调用此函数将遍历所有 *n* 个元素的排列，这可能在你尝试暴力解决旅行商问题（小规模实例）时很有用：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice that `next_permutation` uses the idea of a "less-than relationship"
    to determine that one permutation is lexicographically "less than" another; for
    example, `{20, 10, 30}` is "less than" `{20, 30, 10}` because 10 is less than
    30\. Therefore, `next_permutation` also has a comparator-based version: `std::next_permutation(a,b,cmp)`.
    There are also `std::prev_permutation(a,b)` and `std::prev_permutation(a,b,cmp)`,
    which count lexicographically "downward" instead of "upward."'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`next_permutation` 使用“小于”关系来确定一个排列在字典序上“小于”另一个排列；例如，`{20, 10, 30}` 在字典序上“小于”
    `{20, 30, 10}`，因为 10 小于 30。因此，`next_permutation` 也有一个基于比较器的版本：`std::next_permutation(a,b,cmp)`。还有
    `std::prev_permutation(a,b)` 和 `std::prev_permutation(a,b,cmp)`，它们在字典序上“向下”计数而不是“向上”。
- en: By the way, to compare two sequences lexicographically in this way, you could
    use `std::mismatch` from section *Read-only range algorithms*, or you could just
    use the standard-provided `std::lexicographical_compare(a,b,c,d)`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，要按这种方式在字典序上比较两个序列，你可以使用来自 *只读范围算法* 部分的 `std::mismatch`，或者你可以直接使用标准提供的
    `std::lexicographical_compare(a,b,c,d)`。
- en: Heaps and heapsort
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆和堆排序
- en: '`std::make_heap(a,b)` (or its comparator-based version, `std::make_heap(a,b,cmp)`)
    takes a range of unsorted elements and rearranges them into an order that satisfies
    the *max-heap property*: in an array with the max-heap property, each element
    of the range at index *i* will be at least as great as either of the elements
    at indices 2*i*+1 and 2*i*+2\. This implies that the greatest element of all will
    be at index 0.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::make_heap(a,b)`（或其基于比较器的版本，`std::make_heap(a,b,cmp)`）接受一个未排序的元素范围，并将它们重新排列成一个满足最大堆属性的顺序：具有最大堆属性的数组中，索引
    *i* 的每个元素将至少与索引 2*i*+1 和 2*i*+2 的元素之一相等。这意味着所有元素中的最大值将位于索引 0。这表明，最大元素将位于索引 0。'
- en: '`std::push_heap(a,b)` (or its comparator-based version) assumes that the range
    `[a,b-1)` is already a max-heap. It takes the element currently at `b[-1]` and
    "bubbles it up," by swapping with its parent in the heap, until the max-heap property
    is restored for the whole range `[a,b)`. Notice that `make_heap` can be implemented
    as a simple loop repeatedly calling `std::push_heap(a,++b)`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::push_heap(a,b)`（或其基于比较器的版本）假设范围 `[a,b-1)` 已经是一个最大堆。它将当前位于 `b[-1]` 的元素“冒泡”起来，通过与堆中的父元素交换，直到整个范围
    `[a,b)` 的最大堆属性得到恢复。请注意，`make_heap` 可以通过简单地循环调用 `std::push_heap(a,++b)` 来实现。'
- en: '`std::pop_heap(a,b)` (or its comparator-based version) assumes that the range
    `[a,b)` is already a max-heap. It swaps `a[0]` with `b[-1]`, so that the greatest
    element is now at the *back* of the range instead of at the front; and then it
    swaps `a[0]` with one of its children in the heap, and so on, "bubbling it down"
    until the max-heap property is restored. After a call to `pop_heap(a,b)`, the
    greatest element will be at `b[-1]` and the range `[a, b-1)` will have the max-heap
    property.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::pop_heap(a,b)`（或其基于比较器的版本）假设范围 `[a,b)` 已经是一个最大堆。它将 `a[0]` 与 `b[-1]` 交换，使得最大元素现在位于范围的
    *尾部* 而不是 *前端*；然后它与堆中的一个子元素交换，依此类推，“冒泡”下来直到最大堆属性得到恢复。在调用 `pop_heap(a,b)` 之后，最大元素将位于
    `b[-1]`，范围 `[a, b-1)` 将具有最大堆属性。'
- en: '`std::sort_heap(a,b)` (or its comparator-based version) takes a range with
    the max-heap property and permutes it into sorted order by repeatedly calling
    `std::pop_heap(a, b--)`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::sort_heap(a,b)`（或其基于比较器的版本）接受一个具有最大堆属性的范围，并通过重复调用`std::pop_heap(a, b--)`将其排列成排序顺序。'
- en: 'Using these building blocks, we can implement the classic "heapsort" algorithm.
    The standard library''s `std::sort` function might reasonably be implemented like
    this (but in practice it is typically implemented as a hybrid algorithm, such
    as "introsort"):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些构建块，我们可以实现经典的“堆排序”算法。标准库中的`std::sort`函数可能合理地实现如下（但在实践中通常实现为混合算法，例如“introsort”）：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We'll see another application of `push_heap` and `pop_heap` in [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*, when we talk about `std::priority_queue`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d)“容器动物园”中看到`push_heap`和`pop_heap`的另一个应用，当我们讨论`std::priority_queue`时。
- en: Merges and mergesort
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并和归并排序
- en: As long as we're on the topic of sorting algorithms, let's write `sort` a different
    way!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们谈论到了排序算法，让我们以不同的方式编写`sort`！
- en: '`std::inplace_merge(a,mid,b)` takes a single range `[a,b)` which has already
    been sorted with the equivalent of `std::sort(a,mid)` and `std::sort(mid,b)`,
    and merges the two subranges together into a single sorted range. We can use this
    building block to implement the classic mergesort algorithm:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::inplace_merge(a,mid,b)`接受一个已经通过`std::sort(a,mid)`和`std::sort(mid,b)`排序的范围`[a,b)`，并将两个子范围合并成一个排序的范围。我们可以使用这个构建块来实现经典的归并排序算法：'
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, beware! The name `inplace_merge` seems to imply that the merging is
    happening "in-place" without the need for any additional buffer space; but this
    is not what happens in fact. In actuality, the `inplace_merge` function allocates
    a buffer for its own use, typically by calling `operator new`. If you are programming
    in an environment where heap allocation is problematic, then you should *avoid*
    `inplace_merge` *like the plague*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意！名称`inplace_merge`似乎暗示合并是在“原地”发生的，无需任何额外的缓冲空间；但实际上并非如此。实际上，`inplace_merge`函数会为其自身分配一个缓冲区，通常是通过调用`operator
    new`。如果你在一个堆分配有问题的环境中编程，那么你应该*避免*使用`inplace_merge`。
- en: The other standard algorithms that may allocate temporary buffers on the heap
    are `std::stable_sort` and `std::stable_partition`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会在堆上分配临时缓冲区的其他标准算法是`std::stable_sort`和`std::stable_partition`。
- en: '`std::merge(a,b,c,d,o)` is the non-allocating merge algorithm; it takes two
    iterator-pairs representing the ranges `[a,b)` and `[c,d)` and merges them into
    the output range defined by `o`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::merge(a,b,c,d,o)`是非分配合并算法；它接受两个迭代器对，代表范围`[a,b)`和`[c,d)`，并将它们合并到由`o`定义的输出范围中。'
- en: Searching and inserting in a sorted array with std::lower_bound
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`std::lower_bound`在有序数组中进行搜索和插入
- en: 'Once a range of data has been sorted, it becomes possible to search within
    that data using binary search, as opposed to the slower linear search. The standard
    algorithm that implements binary search is called `std::lower_bound(a,b,v)`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据范围被排序，就可以使用二分搜索在该数据内进行搜索，而不是使用较慢的线性搜索。实现二分搜索的标准算法称为`std::lower_bound(a,b,v)`：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function returns an iterator to the first element in the range that is
    *not less than* the given value `v`. If there is an instance of the value `v`
    already in the range, then the returned iterator will point at it (in fact, it
    will point at the *first* such value in the range). If there's no instance already
    in the range, then the returned iterator will point at the place where `v` should
    go.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个指向范围中第一个不小于给定值`v`的元素的迭代器。如果范围中已经存在该值的实例，则返回的迭代器将指向它（实际上，它将指向范围中的第一个这样的值）。如果没有该值的实例，则返回的迭代器将指向`v`应该放置的位置。
- en: 'We can use the return value of `lower_bound` as the input to `vector::insert`
    in order to insert `v` into the proper place in a sorted vector while preserving
    its sorted order:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`lower_bound`的返回值作为`vector::insert`的输入，以便在保持其排序顺序的同时将`v`插入到排序向量的正确位置：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The similar function `std::upper_bound(a,b,v)` returns an iterator to the first
    element in the range that is *greater than* the given value `v`. If `v` is not
    in the given range, then `std::lower_bound` and `std::upper_bound` will have the
    same return value. But if `v` is present in the range, then `lower_bound` will
    return an iterator pointing to the first instance of `v` in the range and `upper_bound`
    will return an iterator pointing "one past" the last instance of `v` in the range.
    In other words, using the two functions together will give you a half-open range
    `[lower, upper)` containing nothing but instances of the value `v`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的函数 `std::upper_bound(a,b,v)` 返回一个指向范围中第一个大于给定值 `v` 的元素的迭代器。如果 `v` 不在给定的范围内，那么
    `std::lower_bound` 和 `std::upper_bound` 将返回相同的值。但如果 `v` 存在于范围内，那么 `lower_bound`
    将返回一个指向范围中 `v` 的第一个实例的迭代器，而 `upper_bound` 将返回一个指向范围中 `v` 的最后一个实例之后一个位置的迭代器。换句话说，使用这两个函数一起将给出一个包含仅
    `v` 值实例的半开范围 `[lower, upper)`：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This handles searching and inserting values in a sorted array. But what about
    deletion?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了在有序数组中搜索和插入值的问题。但删除怎么办？
- en: Deleting from a sorted array with std::remove_if
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::remove_if 从有序数组中删除
- en: 'In all our discussion of standard generic algorithms up to this point, we haven''t
    covered the question of how to remove items from a range. This is because the
    concept of "a range" is fundamentally read-only: we might change the *values*
    of the elements of a given range, but we can never use a standard algorithm to
    shorten or lengthen *the range itself*. When, in the *Shunting data with std::copy*
    section, we used `std::copy` to "insert into" a vector named `dest`, it wasn''t
    the `std::copy` algorithm that was doing the inserting; it was the `std::back_insert_iterator`
    object itself that held a reference to the underlying container and was able to
    insert into the container. `std::copy` didn''t take `dest.begin()` and `dest.end()`
    as parameters; instead it took the special object `std::back_inserter(dest)`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到目前为止关于标准泛型算法的所有讨论中，我们还没有涵盖如何从范围中删除元素的问题。这是因为“范围”的概念本质上是只读的：我们可能改变给定范围中元素的
    *值*，但我们永远不能使用标准算法来缩短或延长 *范围本身*。在 *使用 std::copy 推送数据* 这一部分中，当我们使用 `std::copy` 向名为
    `dest` 的向量“插入”时，并不是 `std::copy` 算法在进行插入；而是 `std::back_insert_iterator` 对象本身持有对底层容器的引用，并且能够将元素插入到容器中。`std::copy`
    并没有将 `dest.begin()` 和 `dest.end()` 作为参数；相反，它使用了特殊的对象 `std::back_inserter(dest)`。
- en: So how do we erase items from a range? Well, we can't. All we can do is erase
    items from a *container*; and the algorithms of the STL do not deal in containers.
    So what we ought to be looking for is a way to rearrange the values of a range
    so that the "removed" items will wind up somewhere predictable, so that we can
    quickly erase them all from the underlying container (using some means other than
    an STL algorithm).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何从范围中删除项目呢？嗯，我们不能。我们所能做的就是从 *容器* 中删除项目；而 STL 的算法并不处理容器。因此，我们应该寻找一种重新排列范围值的方法，使得“删除”的项目最终会出现在可预测的位置，这样我们就可以快速地从底层容器中删除它们（使用除
    STL 算法之外的其他方法）。
- en: 'We''ve seen one possible approach already:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一种可能的方法：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'But this is much more wasteful than it needs to be (notice that `stable_partition`
    is one of those few STL algorithms that allocates a temporary buffer on the heap!).
    The algorithm we want is actually much simpler:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但这比实际需要的要浪费得多（注意，`stable_partition` 是那些在堆上分配临时缓冲区的不多算法之一！）。我们想要的算法实际上要简单得多：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`std::remove(a,b,v)` removes all values equal to `v` from a range `[a,b)`.
    Notice that the range does *not* have to be sorted--but `remove` will preserve
    whatever order was there before, by "shifting down" the non-removed elements to
    fill in the gaps in the range. If `remove` removes *k* elements from the range,
    then when the `remove` function returns, there will be *k* elements at the end
    of the range whose values are in the moved-from state, and return value of `remove`
    will be an iterator pointing to the first such moved-from element.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::remove(a,b,v)` 从范围 `[a,b)` 中删除所有等于 `v` 的值。请注意，范围不必是有序的--但 `remove` 将通过“向下移动”非删除元素来填补范围中的空隙，从而保留原有的顺序。如果
    `remove` 从范围中删除了 *k* 个元素，那么当 `remove` 函数返回时，范围末尾将有 *k* 个元素的值处于已移动状态，`remove` 的返回值将是一个指向第一个这种已移动元素的迭代器。'
- en: '`std::remove_if(a,b,p)` removes all elements satisfying the given predicate;
    that is, it removes all elements `e` such that `p(e)` is true. Just like `remove`,
    `remove_if` shifts elements down to fill in the range and returns an iterator
    to the first "moved-from" element.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::remove_if(a,b,p)` 会移除所有满足给定谓词的元素；也就是说，它会移除所有使得 `p(e)` 为真的元素 `e`。就像 `remove`
    一样，`remove_if` 会将元素向下移动以填充范围，并返回一个指向第一个“已移动”元素的迭代器。'
- en: The common idiom for removing items from a sequence container is what's known
    as the *erase-remove idiom*, because it involves passing that return value straight
    into the container's own `.erase()` member function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从序列容器中删除项的常用惯用方法是所谓的 *erase-remove 惯用方法*，因为它涉及到将返回值直接传递到容器自己的 `.erase()` 成员函数。
- en: 'Another standard library algorithm that works with the erase-remove idiom is
    `std::unique(a,b)`, which takes a range and, for each set of consecutive equivalent
    items, removes all but the first of them. Like `std::remove`, the input range
    doesn''t need to be sorted; the algorithm will preserve whatever ordering was
    there to begin with:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与 erase-remove 惯用方法一起工作的标准库算法是 `std::unique(a,b)`，它接受一个范围，并对每一组连续的等效项，移除除了第一个之外的所有项。像
    `std::remove` 一样，输入范围不需要排序；算法将保留最初存在的任何排序：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, notice that we can often do better than `std::remove` in general,
    either by using the `erase` member function of whatever our underlying container
    is (for example, we''ll see in the next chapter how `std::list::erase` can be
    much faster than the erase-remove idiom on a `std::list`)--and even if we''re
    removing from a vector whose order happens *not* to be significant, we''ll still
    usually be better off with something like the following generic algorithm `unstable_remove`,
    which has been proposed for future standardization but (at the time of writing)
    not yet adopted into the STL:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，我们通常可以比 `std::remove` 做得更好，要么通过使用我们底层容器的 `erase` 成员函数（例如，我们将在下一章中看到 `std::list::erase`
    可以比在 `std::list` 上的 erase-remove 惯用方法快得多）--即使我们从不需要排序顺序的向量中删除，我们通常也会更倾向于以下这样的泛型算法
    `unstable_remove`，该算法已被提议用于未来的标准化，但在撰写本文时尚未被纳入 STL：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the next chapter, we'll look at *containers*--the STL's answer to the question,
    "Where are all these elements being stored, anyway?"
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 *容器*--STL 对“所有这些元素到底存储在哪里？”这一问题的回答。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The Standard Template Library has a generic algorithm for (almost) every desire.
    If you're doing something algorithmic, check the STL first!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 标准模板库为几乎每个需求都提供了一个泛型算法。如果你在进行算法操作，首先检查 STL！
- en: STL algorithms deal in the half-open ranges defined by pairs of iterators. Be
    careful when dealing with any of the one-and-a-half-range algorithms.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: STL 算法处理由一对迭代器定义的半开区间。在处理任何一元半区间算法时都要小心。
- en: STL algorithms that deal with comparison and sorting will use `operator<` by
    default, but you can always pass a two-argument "comparator" instead. If you want
    to perform a non-trivial operation on a whole range of data, remember that the
    STL might support it directly (`std::move`, `std::transform`) or indirectly via
    a special iterator type (`std::back_inserter`, `std::istream_iterator`).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 处理比较和排序的 STL 算法默认使用 `operator<`，但你始终可以传递一个两个参数的“比较器”。如果你想在整个数据范围上执行非平凡操作，请记住
    STL 可能直接支持它（`std::move`，`std::transform`）或通过特殊迭代器类型间接支持（`std::back_inserter`，`std::istream_iterator`）。
- en: You should know what a "permutation" is, and how the standard permutative algorithms
    (`swap`, `reverse`, `rotate`, `partition`, `sort`) are implemented in terms of
    one another. Just three STL algorithms (`stable_sort`, `stable_partition`, `inplace_merge`)
    may quietly allocate memory from the heap; if you can't afford heap allocation,
    avoid these three algorithms like the plague.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道“排列”是什么，以及标准排列算法（`swap`，`reverse`，`rotate`，`partition`，`sort`）是如何相互实现的。只有三个
    STL 算法（`stable_sort`，`stable_partition`，`inplace_merge`）可能会默默地从堆中分配内存；如果你负担不起堆分配，请像躲避瘟疫一样避开这三个算法。
- en: Use the erase-remove idiom to maintain the sort order of a sequence container
    even as you delete items from it. Use something like `my::unstable_remove` if
    you don't care about the sort order. Use `.erase()` for containers that support
    it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 erase-remove 惯用方法来维护序列容器的排序顺序，即使你在删除项时也是如此。如果你不关心排序顺序，可以使用类似 `my::unstable_remove`
    的方法。对于支持 `.erase()` 的容器，请使用 `.erase()`。
