- en: The Iterator-Pair Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've been introduced to iterator types--both standard-provided and
    user-defined--it's time to look at some of the things you can *do* with iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you''ll learn:'
  prefs: []
  type: TYPE_NORMAL
- en: The notion of a "half-open range," which nails down the exact manner in which
    two iterators can be said to define a *range*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to classify each standard algorithm as "read-only," "write-only", "transformative",
    or "permutative"; and as "one-range", "two-range", or "one-and-a-half range"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That some standard algorithms, such as `merge` and `make_heap`, are merely the
    necessary building blocks out of which we make higher-level entities such as `stable_sort`
    and `priority_queue`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to sort a range based on a comparator other than `operator<`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manipulate sorted arrays using the *erase-remove idiom*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A note about headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most function templates discussed in this chapter are defined in the standard
    header `<algorithm>`. The special iterator types, on the other hand, are generally
    defined in `<iterator>`. If you're wondering where to find a specific entity,
    I strongly recommend that you consult an online reference such as [cppreference.com](https://cppreference.com)
    for the authoritative answer; don't just guess!
  prefs: []
  type: TYPE_NORMAL
- en: Read-only range algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapters, we built up an algorithm that we called `distance`
    and another called `count_if`. Both of these algorithms appear in the standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::count_if(a,b,p)` returns the number of elements between `a` and `b` that
    satisfy the predicate function `p`--that is, the number of elements `e` for which
    `p(e)` is `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, whenever we say "between `a` and `b`", we're talking about the
    range that includes `*a` but does not include `*b`--what mathematicians call a
    "half-open range" and represented by the asymmetrical notation `[a,b)`. Why should
    we not include `*b`? Well, for one thing, if `b` is the `end()` of some vector,
    then it doesn't point to an element of that vector at all! So in general, dereferencing
    the *end point* of a range is a dangerous thing to do. For another thing, using
    half-open ranges conveniently allows us to represent *empty* ranges; for example,
    the range "from `x` to `x`" is an empty range consisting of zero data elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Half-open ranges are quite natural in C++ just as they are in C. For decades,
    we''ve been writing for-loops that range from a lower bound (inclusive) to an
    upper bound (exclusive); this idiom is so common that deviation from the idiom
    often indicates a bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`std::distance(a,b)` returns the number of elements between `a` and `b`--that
    is, the number of times you''d have to apply `++` to `a` in order to reach `b`.
    You could think of this function as being equivalent in its effects to `std::count_if(a,b,[](auto&&){return
    true;})`.'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d),
    *Iterators and Ranges*, if the iterators in question are random-access iterators,
    this number can be quickly computed as `(b - a)`, and so the standard `std::distance`
    will do so. Notice that `(b - a)` might be a negative number, if you gave the
    arguments in the "wrong" order!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When the iterators are random-access iterators, `std::distance` does nothing
    more than subtract them; so passing in "wrongly ordered" arguments is explicitly
    supported and blessed by the C++ standard. However, if the iterators in question
    are merely bidirectional iterators (such as `std::list<int>::iterator`--see [Chapter
    4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d), *The Container Zoo*),
    "wrongly ordered" iterators are *not* supported. You might expect that `std::distance(b,a)
    == -std::distance(a,b)` should be true of all iterator types; but consider, how
    would the `std::distance` algorithm itself have any idea whether the iterators
    you gave it were "wrongly ordered" or not? The only thing it *can* do (in the
    absence of an `operator-`) is to keep incrementing `a`--perhaps past the end of
    the container and off into space--in the vain hope that it''ll eventually reach
    `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Consult the diagrams of `std::list` and `std::forward_list` in [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*, to understand this code sample's odd behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::count(a,b,v)` returns the number of elements between `a` and `b` that
    are equal to `v`--that is, the number of elements `e` for which `e == v` is true.
    You can think of this function as being equivalent in its effects to `std::count_if(a,b,[&v](auto&&
    e){return e == v;})`, and in fact both versions should give the same assembly
    code. If C++ had had lambda-expressions in 1998, they probably wouldn''t have
    put the `std::count` algorithm in the standard library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that `std::count(a,b,v)` necessarily loops over *all* of the elements
    in the range between `a` and `b`. It can''t take advantage of special information
    you might have about the arrangement of the data in the range. For example, suppose
    I want to count the instances of `42` in a `std::set<int>`? I could write the
    code in either of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The raw algorithm `std::count` is outperformed by the second approach, which
    simply asks the `set` itself for the answer. This turns a O(*n*) traversal of
    the whole set into a O(log *n*) tree lookup. Similarly, `std::unordered_set` provides
    a `count` method that is roughly O(1).
  prefs: []
  type: TYPE_NORMAL
- en: For more about these containers, see [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*; the takeaway point here right now is that, Q sometimes there
    is important structure in your data that can be exploited by choosing the proper
    tool for the job. Even though I'm pointing to cases where the standard algorithms
    seem to "magically" do the right thing (as with `std::distance` delegating to
    `(b - a)`), you should not imagine that this "magic" stretches farther than it
    does. The standard algorithms know only as much as they're told, which is to say,
    only about the properties of the *iterator types* you pass them. They'll never
    change their behavior based on the relationships of the *underlying data elements*
    to each other. Arranging your code to exploit relationships in the underlying
    data (for example, "this data is sorted," "this range spans the entire container")
    is part of your job as the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some more algorithms similar to `std::count` and `std::count_if`.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::find(a,b,v)` and `std::find_if(a,b,p)` work just like `std::count(a,b,v)`
    and `std::count_if(a,b,p)` respectively, except that, rather than looping over
    the entire range and returning the *count* of matching elements, the `find` variants
    loop only until they''ve found the first match, and then return an iterator to
    the data element that matched. There is also a variant `find_if_not` that is just
    like `find_if` but with the sense of the predicate negated; this variant also
    probably wouldn''t have needed to exist if we''d gotten lambdas earlier in the
    history of C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that because `find` returns *immediately* upon finding the first match,
    it's faster on average than the `count` algorithm (which scans the whole range
    no matter what). This kind of "return immediately" behavior is often referred
    to as "short-circuiting".
  prefs: []
  type: TYPE_NORMAL
- en: '`std::all_of(a,b,p)`, `std::any_of(a,b,p)`, and `std::none_of(a,b,p)` return
    either `true` or `false`, depending on how often the provided predicate function
    `p` is true of the elements in the range. They can all be built on top of the
    `find` algorithms, thus picking up the short-circuiting behavior for free:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more `find`-related algorithm I should mention: `find_first_of`.
    It implements the operation of "looking in a sequence for the first occurrence
    of any of a fixed set of target elements"--that is, just like `strcspn` in the
    C standard library, but for any type, not just `char`. Abstractly speaking, `find_first_of`
    takes two conceptual parameters: the range to search in, and the set of target
    elements. This being the STL, they''re both passed in as ranges, which is to say,
    pairs of iterators. So a call to this algorithm looks like `find_first_of(haystack,
    haystack, needle, needle)`: two pairs of iterators side by side. This can get
    confusing--beware of algorithms taking multiple similar parameters!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the "haystack" iterators are expected to be of any old `InputIterator`
    type, but the "needle" iterators are required to be at least `ForwardIterator`.
    Recall from [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d),
    *Iterators and Ranges*, that the big thing about `ForwardIterator` types is that
    they can be meaningfully *copied*, letting the same range be traversed multiple
    times. This is exactly what `find_first_of` needs! It traverses the "needle" range
    once per character in the "haystack"; so the "needle" must be re-traversable--and
    incidentally, must be finite in size! Contrariwise, there''s nothing particularly
    requiring that the "haystack" be finite; it might be pulling its elements from
    a potentially unbounded input stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Speaking of multiple similar parameters, let''s finish our look at simple read-only
    algorithms with these two: `std::equal` and `std::mismatch`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::equal(a,b,c,d)` takes two iterator-pairs: the range `[a,b)` and the range
    `[c,d)`. It returns `true` if the two ranges are element-for-element equal, and
    `false` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::mismatch(a,b,c,d)` is sort of like `find`: it''ll tell you exactly which
    pair of elements was the one that torpedoed the match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of `std::equal_to<>{}` as a predicate object; we won't cover
    the built-in predicates in depth in this book, so just take it for granted that
    `std::equal_to<>{}` is an object whose behavior is similar to `[](auto a, auto
    b){ return a == b; }` but with more *perfect forwarding* involved.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, watch out again! Many of the two-range algorithms in the C++17 standard
    library also have variant forms colloquially known as one-and-a-half-range algorithms.
    For example, in addition to `std::mismatch(a,b,c,d)` you'll find `std::mismatch(a,b,c)`--the
    second range's "end" point is simply assumed to be at `c + std::distance(a, b)`.
    If `c` actually points into a container where `c + std::distance(a, b)` would
    be "off the end," then, tough luck!
  prefs: []
  type: TYPE_NORMAL
- en: Because "tough luck" is never a really *great* answer to a technical question,
    the C++17 standard added safe two-range variants for many of the one-and-a-half-range
    algorithms that had existed in C++14.
  prefs: []
  type: TYPE_NORMAL
- en: Shunting data with std::copy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've just seen our first few two-range algorithms. The `<algorithm>` header
    is full of two-range algorithms and their siblings, the one-and-a-half-range algorithms.
    What's the simplest possible such algorithm?
  prefs: []
  type: TYPE_NORMAL
- en: 'A reasonable answer would be: "Copy each data element from the first range
    into the second range." Indeed, the STL provides that algorithm, under the name
    `std::copy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this is a one-and-a-half-range algorithm. The standard library actually
    does not provide a two-range version of `std::copy`; the assumption is that if
    you are actually trying to write into a buffer, then you must have checked its
    size already, so checking "are we at the end of the buffer yet" inside the loop
    would be both redundant and inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I can practically hear you exclaiming: "Horrors! This is the same crude
    logic that brought us `strcpy`, `sprintf`, and `gets`! This is an invitation to
    buffer overflows!" Well, *if* you were to exclaim thusly, you''d be right about
    the bad behavior of `gets`--in fact, the `gets` function has been officially removed
    from the C++17 standard library. And you''d be right about `sprintf`--anyone who
    needs that functionality is better of using the range-checked version `snprintf`,
    which is analogous to a "two-range algorithm" in this context. But about `strcpy`
    I''d disagree. With `gets` it is *impossible* to know the correct size for the
    output buffer; with `sprintf` it is *difficult*; but with `strcpy` it is *trivial*:
    you just measure the `strlen` of the input buffer and that''s your answer. Likewise
    with `std::copy`, the relationship between "input elements consumed" and "output
    elements produced" is exactly one-to-one, so sizing the output buffer doesn''t
    present a technical challenge.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the parameter we called `destination` is an *output iterator*.
    This means that we can use `std::copy`, not merely to shunt data around in memory,
    but even to feed data to an arbitrary "sink" function. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You may find it instructive to compare this version of our `putc_iterator` to
    the version from [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d),
    *Iterators and Ranges*; this version is using `boost::iterator_facade` as introduced
    at the end of [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d),
    *Iterators and Ranges* and also using a common trick to return `*this` instead
    of a new proxy object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use the flexibility of `destination` to solve our concerns about
    buffer overflow! Suppose that, instead of writing into a fixed-size array, we
    were to write into a resizable `std::vector` (see [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*). Then "writing an element" corresponds to "pushing an element
    back" on the vector. So we could write an output iterator very similar to `putc_iterator`,
    that would `push_back` instead of `putc`, and then we''d have an overflow-proof
    way of filling up a vector. Indeed, the standard library provides just such an
    output iterator, in the `<iterator>` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The function call `std::back_inserter(dest)` simply returns a `back_insert_iterator`
    object. In C++17, we could rely on template type deduction for constructors and
    write the body of that function as simply `return std::back_insert_iterator(dest)`;
    or dispense with the function entirely and just write `std::back_insert_iterator(dest)`
    directly in our code--where C++14 code would have to "make do" with `std::back_inserter(dest)`.
    However, why would we want all that extra typing? The name `back_inserter` was
    deliberately chosen to be easy to remember, since it's the one that we were expected
    to use most often. Although C++17 allows us to write `std::pair` in place of `std::make_pair`,
    and `std::tuple` in place of `std::make_tuple`, it would be silly to write the
    cumbersome `std::back_insert_iterator` in place of `std::back_inserter`. You should
    prefer `std::back_inserter(dest)` even in C++17.
  prefs: []
  type: TYPE_NORMAL
- en: Variations on a theme - std::move and std::move_iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you might guess from the name, or you might have noticed in the preceding
    implementation, the `std::copy` algorithm works by copying elements from the input
    range to the output. As of C++11, you might wonder: What if instead of *copying*
    the elements, we used move semantics to *move* them from the input to the output?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL provides two different approaches to this problem. The first one is
    the most straightforward: there is a `std::move` algorithm (defined in the `<algorithm>`
    header) with the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It's exactly the same as the `std::copy` algorithm except for the addition of
    a single `std::move` on the input element (be careful--this inner `std::move`,
    with *one* argument, defined in the `<utility>` header, is a completely different
    beast from the outer, three-argument `std::move` defined in `<algorithm>`! The
    fact that they share a name is unfortunate. Ironically, one of the few other STL
    functions to suffer a similar situation is `std::remove`; see the *Deleting from
    a sorted array* section, and also [Chapter 12](part0188.html#5J99O0-2fdac365b8984feebddfbb9250eaf20d),
    *Filesystem*).
  prefs: []
  type: TYPE_NORMAL
- en: The other approach is a variation of what we saw previously with `back_inserter`.
    Rather than switching out the core *algorithm*, we can continue using `std::copy`
    but parameterize it differently. Suppose we passed in a new type of iterator,
    which (like `back_inserter`) wrapped around our original object and changed its
    behavior? In particular, we need an input iterator whose `operator*` returns an
    rvalue. We can do that!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Sorry for the density of that code; trust me that you can safely skip over the
    details. For those who like this kind of thing, you might notice that we're providing
    a templated constructor from `move_iterator<U>` that happens to double as our
    copy constructor (when `U` is the same type as `It`); and that we're providing
    a lot of member functions (such as `operator[]` and `operator--`) whose bodies
    will error out for a lot of possible types of `It` (for example, when `It` is
    a forward iterator--see [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d),
    *Iterators and Ranges*), but this is fine because their bodies won't get instantiated
    unless the user actually tries to call those functions at compile time (if the
    user actually *does* try to `--` a `move_iterator<list_of_ints::iterator>`, then
    of course that'll yield a compile-time error).
  prefs: []
  type: TYPE_NORMAL
- en: Just as with `back_inserter`, notice that the STL provides a helper function
    `make_move_iterator` for the benefit of pre-C++17 compilers that don't have constructor
    template type deduction. In this case, as with `make_pair` and `make_tuple`, the
    "helper" name is uglier than the actual class name, and so I tentatively recommend
    using the C++17 feature in your code; why type an extra five characters and instantiate
    an extra function template if you don't have to?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have two different ways of moving data from one container or range to
    another: the `std::move` algorithm and the `std::move_iterator` adaptor class.
    Here are examples of both idioms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first approach, using `std::move`, is obviously much cleaner if moving data
    is all you're doing. So why did the standard library bother to provide this "messier"
    approach with `move_iterator`? To answer that question, we'll have to explore
    yet another algorithm that is fundamentally related to `std::copy`.
  prefs: []
  type: TYPE_NORMAL
- en: Complicated copying with std::transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have noticed, way back when we presented the implementation of `std::copy`,
    that the `value_type` of the two iterator type parameters were not constrained
    to be the same. This is a feature, not a bug! It means that we can write code
    that relies on implicit conversions and it will just Do The Right Thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Looks trivial, right? Look closely! Deep within our instantiation of `std::copy`
    is a call to the implicit constructor that converts `const char *` (the type of
    `*input.begin()`) to `std::string` (the type of `*output.begin()`). So for the
    umpteenth time, we're seeing an example of generic code that does surprisingly
    complicated operations simply by virtue of being given certain iterator types.
  prefs: []
  type: TYPE_NORMAL
- en: But sometimes you want to apply a complicated transformation function during
    the copying operation--something more complicated than implicit conversions can
    handle. The standard library has got you covered!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes you even need to do a transformation using a function that takes
    *two* arguments. Again the library has you covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This version of `std::transform` might be humorously described as a one-and-two-halves-range
    algorithm!
  prefs: []
  type: TYPE_NORMAL
- en: (What about functions of three arguments? Four arguments? Unfortunately there's
    no fully variadic version of `std::transform`; variadic templates weren't introduced
    to C++ until C++11\. You might try implementing a variadic version and see what
    kinds of problems you run into--they're surmountable but certainly not trivial.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The existence of `std::transform` gives us yet a third way to move data elements
    from one place to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I certainly don't recommend this approach, though! The biggest and reddest of
    its red flags is that it contains explicit specialization of the `std::move` template.
    Whenever you see an explicit specialization--those angle brackets after the template's
    name--that's an almost sure sign of very subtle and fragile code. Advanced readers
    might enjoy figuring out how the compiler deduces which of the two `std::move`s
    I meant; remember, there's one in `<utility>` and one in `<algorithm>`.
  prefs: []
  type: TYPE_NORMAL
- en: Write-only range algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We began this chapter looking at algorithms such as `std::find` that march
    through a range reading its elements in order without modification. You might
    be surprised to learn that the inverse operation also makes sense: there is a
    family of standard algorithms that march through a range *modifying* each element
    without reading it!'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::fill(a,b,v)` does what its name implies: fill each element of the given
    range `[a,b)` with a copy of the provided value `v`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::iota(a,b,v)` is slightly more interesting: it fills the elements of the
    given range with copies of `++v`. That is, `std::iota(a,b,42)` will set `a[0]`
    equal to 42, `a[1]` equal to 43, `a[2]` equal to 44, and so on all the way up
    to `b`. This algorithm''s funny name comes from the APL programming language,
    where a function named `Î¹` (that''s the Greek letter *iota*) performed this operation.
    Another funny thing about this algorithm is that, for whatever reason, its definition
    is found in the standard `<numeric>` header instead of in `<algorithm>`. It''s
    just an oddball that way.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::generate(a,b,g)` is even more interesting: it fills the elements of the
    given range with the successive results of `g()`, whatever it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of using each of these standard algorithms to fill a vector
    of strings with different contents. Test your understanding: do you understand
    why each call produces the output that it does? The example I picked for `std::iota`
    is particularly interesting (yet unlikely to be helpful in real-world code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Algorithms that affect object lifetime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `<memory>` header provides an obscure family of algorithms with names such
    as `std::uninitialized_copy`, `std::uninitialized_default_construct`, and `std::destroy`
    (for the full list, consult an online reference such as [cppreference.com](http://cppreference.com)).
    Consider the following algorithm that uses explicit destructor calls to destroy
    the elements of a range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `std::addressof(x)` is a convenient little helper function that
    returns the address of its parameter; it's exactly the same thing as `&x` except
    in the rare case that `x` is of some class type that sadistically overloads its
    own `operator&`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And consider this algorithm that uses explicit placement-new syntax to "copy-construct
    into" the elements of a range (notice how it neatly cleans up after itself if
    an exception is thrown during the copying). This algorithm clearly shouldn''t
    be used on any range whose elements already exist; so the following example looks
    very contrived:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We'll see more about how these algorithms are *meant* to be used in [Chapter
    4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d), *The Container Zoo*,
    when we talk about `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first permutative algorithm: std::sort'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far all the algorithms we've covered simply walk through their given ranges
    in order, linearly, from one element to the next. Our next family of algorithms
    doesn't behave that way. Instead, it takes the values of the elements in the given
    range and shuffles them around so that the same values still appear, but in a
    different order. The mathematical name for this operation is a *permutation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest permutative algorithm to describe is `std::sort(a,b)`. It does
    what the name implies: sort the given range so that the smallest elements appear
    at the front and the biggest elements at the back. To figure out which elements
    are "smallest," `std::sort(a,b)` uses `operator<`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want a different order, you could try to overload `operator<` to return
    `true` under different conditions--but probably what you should do is use the
    three-argument version of the algorithm, `std::sort(a,b,cmp)`. The third argument
    should be a *comparator*; that is, a function, functor, or lambda that returns
    `true` whenever its first argument is "smaller" than its second argument. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that I carefully chose my lambda in this example so that it would sort
    the array in a deterministic way. If I''d chosen the function `(a % 6 < b % 6)`
    instead, then there would have been two possible outputs: either `{1, 1, 3, 9,
    4, 5}` or `{1, 1, 9, 3, 4, 5}`. The standard `sort` algorithm doesn''t guarantee
    anything about the relative position of elements that happen to be *equal* under
    the given comparison function!'
  prefs: []
  type: TYPE_NORMAL
- en: To fix this problem (if it *is* a problem), you should replace your use of `std::sort`
    with `std::stable_sort`. The latter might be a little slower, but it will guarantee
    that in the case of equal elements the original order is preserved--that is, in
    this case we'll get `{1, 1, 3, 9, 4, 5}` because in the original (unsorted) vector,
    element `3` came in front of element `9`.
  prefs: []
  type: TYPE_NORMAL
- en: There's an even worse thing that can happen with `sort` and `stable_sort`--what
    if I had chosen the comparison function `(a % 6 < b)`? Then I would have had certain
    pairs of elements `x, y` where `x < y` and simultaneously `y < x`! (One such pair
    of elements in the original vector is `5` and `9`.) In this case, there's nothing
    that can save us; we've passed in a "comparison function" that simply *isn't*
    a comparison function! This is a violation of the preconditions of `std::sort`,
    just as if we'd passed it a null pointer. When sorting an array, make sure you're
    sorting it based on a comparison function that makes sense!
  prefs: []
  type: TYPE_NORMAL
- en: Swapping, reversing, and partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STL contains a surprisingly large number of permutative algorithms besides
    `std::sort`. Many of these algorithms can be seen as "building blocks" that implement
    just a small part of the overall sorting algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::swap(a,b)` is the most basic building block; it just takes its two arguments
    and "swaps" them--which is to say, it exchanges their values. This is implemented
    in terms of the given type''s move constructor and move assignment operator. `swap`
    is actually a little special among the standard algorithms because it is *such*
    a primitive operation, and because there is *almost always* a faster way to swap
    two arbitrary objects than by performing the equivalent of `temp = a; a = b; b
    = temp;`. The usual idiom for standard library types (such as `std::vector`) is
    for the type itself to implement a `swap` member function (as in `a.swap(b)`),
    and then to add a function overload of `swap` in the same namespace as the type--that
    is, if we''re implementing `my::obj`, we''d add the overload in namespace `my`--such
    that `swap(a,b)` for that particular type, will call `a.swap(b)` instead of doing
    the three move operations. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have `swap` and bidirectional iterators, we can build `std::reverse(a,b)`,
    a permutative algorithm that simply reverses the order of a range of elements
    by swapping the first item with the last item, the second item with the penultimate
    item, and so on. One common application of `std::reverse` is to reverse the order
    of larger chunks of a string--for example, to reverse the order of the words in
    a sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A small tweak to the implementation of `std::reverse` gives us another building
    block of `sort`, namely `std::partition`. Whereas `std::reverse` walks through
    the range from both ends swapping each pair of elements unconditionally, `std::partition`
    swaps them only if they are "out of order" with respect to a certain predicate
    function. In the following example, we''re partitioning all *even* elements to
    the front of our range and all *odd* elements to the back. If we were using `std::partition`
    to build a Quicksort sorting routine, we''d be partitioning elements *less than
    the pivot element* to the front of the range and elements *greater than the pivot
    element* to the back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You might notice something interesting about the preceding code: The code for
    `reverse` and the code for `partition` are almost identical! The only difference
    is that `partition` contains an awkward do-while loop where `reverse` has just
    a simple increment or decrement.'
  prefs: []
  type: TYPE_NORMAL
- en: You might also have noticed that the first do-while loop in `partition` is equivalent
    to a standard algorithm we've already seen; namely, `std::find_if_not`. And the
    second do-while loop is sort of equivalent to `std::find_if`... except that it
    needs to run *backwards*, not forwards! Unfortunately for us, there is no such
    algorithm as `std::rfind_if`. But--as you might have suspected by now--the standard
    library isn't going to leave us in the lurch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need something that behaves just like an iterator for the purposes of `std::find_if`,
    but iterates "backwards." The standard library provides this exact thing in the
    form of the `std::reverse_iterator` adaptor. We won''t show the code for it; revisit
    [Chapter 2](part0026.html#OPEK0-2fdac365b8984feebddfbb9250eaf20d), *Iterators
    and Ranges*, if you need a refresher on how it might be implemented. Suffice it
    to say, a `std::reverse_iterator<FwdIt>` object wraps and behaves just like a
    `FwdIt` object, except that when you increment the wrapper, it decrements the
    wrapped object, and vice versa. So we can write `partition` in terms of `reverse_iterator`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, sometimes it''s useful to partition a range without changing the
    relative order of the elements in either partition. For those times, there''s
    `std::stable_partition(a,b,p)` (but see the section *Merges and mergesort* for
    a caveat about `stable_partition`: It may allocate memory using `operator new`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few non-permutative algorithms that also deal with partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::is_partitioned(a,b,p)` returns `true` if the given range is already partitioned
    by the predicate `p` (so that all the elements satisfying `p` come at the front
    and all the ones not satisfying `p` come at the back).'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::partition_point(a,b,p)` uses binary search to find the first element
    in an already partitioned range that doesn''t satisfy `p`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::partition_copy(a,b,ot,of,p)` copies each of the elements in the range
    `[a,b)` to one or the other of the output iterators: `*ot++ = e` for elements
    where `p(e)` is `true`, and `*of++ = e` for elements where `p(e)` is `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, if you only want one output sequence or the other, then you can
    use `std::copy_if(a,b,ot,p)` or `std::remove_copy_if(a,b,of,p)` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation and permutation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember our code from *Swapping, reversing, and partitioning* to reverse the
    order of words in a sentence? When the "sentence" contains only two words, there
    is another way to look at the reversal: you could consider it a *cyclic rotation*
    of the elements in the underlying range. `std::rotate(a,mid,b)` rotates the elements
    of the range `[a,b)` so that the element formerly addressed by `mid` is now at
    `a` (and returns an iterator pointing to the element whose value was formerly
    at `a`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Another miscellaneous but sometimes useful permutative algorithm is `std::next_permutation(a,b)`.
    Calling this function in a loop runs through all the possible permutations of
    *n* elements, which might be useful if you''re trying to brute-force a solution
    to a (small) instance of the Traveling Salesman Problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `next_permutation` uses the idea of a "less-than relationship"
    to determine that one permutation is lexicographically "less than" another; for
    example, `{20, 10, 30}` is "less than" `{20, 30, 10}` because 10 is less than
    30\. Therefore, `next_permutation` also has a comparator-based version: `std::next_permutation(a,b,cmp)`.
    There are also `std::prev_permutation(a,b)` and `std::prev_permutation(a,b,cmp)`,
    which count lexicographically "downward" instead of "upward."'
  prefs: []
  type: TYPE_NORMAL
- en: By the way, to compare two sequences lexicographically in this way, you could
    use `std::mismatch` from section *Read-only range algorithms*, or you could just
    use the standard-provided `std::lexicographical_compare(a,b,c,d)`.
  prefs: []
  type: TYPE_NORMAL
- en: Heaps and heapsort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::make_heap(a,b)` (or its comparator-based version, `std::make_heap(a,b,cmp)`)
    takes a range of unsorted elements and rearranges them into an order that satisfies
    the *max-heap property*: in an array with the max-heap property, each element
    of the range at index *i* will be at least as great as either of the elements
    at indices 2*i*+1 and 2*i*+2\. This implies that the greatest element of all will
    be at index 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::push_heap(a,b)` (or its comparator-based version) assumes that the range
    `[a,b-1)` is already a max-heap. It takes the element currently at `b[-1]` and
    "bubbles it up," by swapping with its parent in the heap, until the max-heap property
    is restored for the whole range `[a,b)`. Notice that `make_heap` can be implemented
    as a simple loop repeatedly calling `std::push_heap(a,++b)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::pop_heap(a,b)` (or its comparator-based version) assumes that the range
    `[a,b)` is already a max-heap. It swaps `a[0]` with `b[-1]`, so that the greatest
    element is now at the *back* of the range instead of at the front; and then it
    swaps `a[0]` with one of its children in the heap, and so on, "bubbling it down"
    until the max-heap property is restored. After a call to `pop_heap(a,b)`, the
    greatest element will be at `b[-1]` and the range `[a, b-1)` will have the max-heap
    property.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::sort_heap(a,b)` (or its comparator-based version) takes a range with
    the max-heap property and permutes it into sorted order by repeatedly calling
    `std::pop_heap(a, b--)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these building blocks, we can implement the classic "heapsort" algorithm.
    The standard library''s `std::sort` function might reasonably be implemented like
    this (but in practice it is typically implemented as a hybrid algorithm, such
    as "introsort"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We'll see another application of `push_heap` and `pop_heap` in [Chapter 4](part0052.html#1HIT80-2fdac365b8984feebddfbb9250eaf20d),
    *The Container Zoo*, when we talk about `std::priority_queue`.
  prefs: []
  type: TYPE_NORMAL
- en: Merges and mergesort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As long as we're on the topic of sorting algorithms, let's write `sort` a different
    way!
  prefs: []
  type: TYPE_NORMAL
- en: '`std::inplace_merge(a,mid,b)` takes a single range `[a,b)` which has already
    been sorted with the equivalent of `std::sort(a,mid)` and `std::sort(mid,b)`,
    and merges the two subranges together into a single sorted range. We can use this
    building block to implement the classic mergesort algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: However, beware! The name `inplace_merge` seems to imply that the merging is
    happening "in-place" without the need for any additional buffer space; but this
    is not what happens in fact. In actuality, the `inplace_merge` function allocates
    a buffer for its own use, typically by calling `operator new`. If you are programming
    in an environment where heap allocation is problematic, then you should *avoid*
    `inplace_merge` *like the plague*.
  prefs: []
  type: TYPE_NORMAL
- en: The other standard algorithms that may allocate temporary buffers on the heap
    are `std::stable_sort` and `std::stable_partition`.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::merge(a,b,c,d,o)` is the non-allocating merge algorithm; it takes two
    iterator-pairs representing the ranges `[a,b)` and `[c,d)` and merges them into
    the output range defined by `o`.'
  prefs: []
  type: TYPE_NORMAL
- en: Searching and inserting in a sorted array with std::lower_bound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once a range of data has been sorted, it becomes possible to search within
    that data using binary search, as opposed to the slower linear search. The standard
    algorithm that implements binary search is called `std::lower_bound(a,b,v)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function returns an iterator to the first element in the range that is
    *not less than* the given value `v`. If there is an instance of the value `v`
    already in the range, then the returned iterator will point at it (in fact, it
    will point at the *first* such value in the range). If there's no instance already
    in the range, then the returned iterator will point at the place where `v` should
    go.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the return value of `lower_bound` as the input to `vector::insert`
    in order to insert `v` into the proper place in a sorted vector while preserving
    its sorted order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The similar function `std::upper_bound(a,b,v)` returns an iterator to the first
    element in the range that is *greater than* the given value `v`. If `v` is not
    in the given range, then `std::lower_bound` and `std::upper_bound` will have the
    same return value. But if `v` is present in the range, then `lower_bound` will
    return an iterator pointing to the first instance of `v` in the range and `upper_bound`
    will return an iterator pointing "one past" the last instance of `v` in the range.
    In other words, using the two functions together will give you a half-open range
    `[lower, upper)` containing nothing but instances of the value `v`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This handles searching and inserting values in a sorted array. But what about
    deletion?
  prefs: []
  type: TYPE_NORMAL
- en: Deleting from a sorted array with std::remove_if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In all our discussion of standard generic algorithms up to this point, we haven''t
    covered the question of how to remove items from a range. This is because the
    concept of "a range" is fundamentally read-only: we might change the *values*
    of the elements of a given range, but we can never use a standard algorithm to
    shorten or lengthen *the range itself*. When, in the *Shunting data with std::copy*
    section, we used `std::copy` to "insert into" a vector named `dest`, it wasn''t
    the `std::copy` algorithm that was doing the inserting; it was the `std::back_insert_iterator`
    object itself that held a reference to the underlying container and was able to
    insert into the container. `std::copy` didn''t take `dest.begin()` and `dest.end()`
    as parameters; instead it took the special object `std::back_inserter(dest)`.'
  prefs: []
  type: TYPE_NORMAL
- en: So how do we erase items from a range? Well, we can't. All we can do is erase
    items from a *container*; and the algorithms of the STL do not deal in containers.
    So what we ought to be looking for is a way to rearrange the values of a range
    so that the "removed" items will wind up somewhere predictable, so that we can
    quickly erase them all from the underlying container (using some means other than
    an STL algorithm).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen one possible approach already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'But this is much more wasteful than it needs to be (notice that `stable_partition`
    is one of those few STL algorithms that allocates a temporary buffer on the heap!).
    The algorithm we want is actually much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`std::remove(a,b,v)` removes all values equal to `v` from a range `[a,b)`.
    Notice that the range does *not* have to be sorted--but `remove` will preserve
    whatever order was there before, by "shifting down" the non-removed elements to
    fill in the gaps in the range. If `remove` removes *k* elements from the range,
    then when the `remove` function returns, there will be *k* elements at the end
    of the range whose values are in the moved-from state, and return value of `remove`
    will be an iterator pointing to the first such moved-from element.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::remove_if(a,b,p)` removes all elements satisfying the given predicate;
    that is, it removes all elements `e` such that `p(e)` is true. Just like `remove`,
    `remove_if` shifts elements down to fill in the range and returns an iterator
    to the first "moved-from" element.'
  prefs: []
  type: TYPE_NORMAL
- en: The common idiom for removing items from a sequence container is what's known
    as the *erase-remove idiom*, because it involves passing that return value straight
    into the container's own `.erase()` member function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another standard library algorithm that works with the erase-remove idiom is
    `std::unique(a,b)`, which takes a range and, for each set of consecutive equivalent
    items, removes all but the first of them. Like `std::remove`, the input range
    doesn''t need to be sorted; the algorithm will preserve whatever ordering was
    there to begin with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, notice that we can often do better than `std::remove` in general,
    either by using the `erase` member function of whatever our underlying container
    is (for example, we''ll see in the next chapter how `std::list::erase` can be
    much faster than the erase-remove idiom on a `std::list`)--and even if we''re
    removing from a vector whose order happens *not* to be significant, we''ll still
    usually be better off with something like the following generic algorithm `unstable_remove`,
    which has been proposed for future standardization but (at the time of writing)
    not yet adopted into the STL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the next chapter, we'll look at *containers*--the STL's answer to the question,
    "Where are all these elements being stored, anyway?"
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Standard Template Library has a generic algorithm for (almost) every desire.
    If you're doing something algorithmic, check the STL first!
  prefs: []
  type: TYPE_NORMAL
- en: STL algorithms deal in the half-open ranges defined by pairs of iterators. Be
    careful when dealing with any of the one-and-a-half-range algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: STL algorithms that deal with comparison and sorting will use `operator<` by
    default, but you can always pass a two-argument "comparator" instead. If you want
    to perform a non-trivial operation on a whole range of data, remember that the
    STL might support it directly (`std::move`, `std::transform`) or indirectly via
    a special iterator type (`std::back_inserter`, `std::istream_iterator`).
  prefs: []
  type: TYPE_NORMAL
- en: You should know what a "permutation" is, and how the standard permutative algorithms
    (`swap`, `reverse`, `rotate`, `partition`, `sort`) are implemented in terms of
    one another. Just three STL algorithms (`stable_sort`, `stable_partition`, `inplace_merge`)
    may quietly allocate memory from the heap; if you can't afford heap allocation,
    avoid these three algorithms like the plague.
  prefs: []
  type: TYPE_NORMAL
- en: Use the erase-remove idiom to maintain the sort order of a sequence container
    even as you delete items from it. Use something like `my::unstable_remove` if
    you don't care about the sort order. Use `.erase()` for containers that support
    it.
  prefs: []
  type: TYPE_NORMAL
