- en: Chapter 6. Blueprints
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 蓝图
- en: 'In this chapter, we will learn what Blueprints are and how they can be used
    to prototype your game. We will learn about:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习蓝图是什么以及如何使用它们来原型化您的游戏。我们将学习以下内容：
- en: Getting familiar with Blueprint editor
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉蓝图编辑器
- en: Various Blueprint graph types (for example, function graphs, event graphs, and
    so on)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种蓝图图类型（例如，函数图、事件图等）
- en: Blueprint nodes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图节点
- en: And, finally, we will create a simple Blueprint that can be placed in world
    or dynamically spawned while running the game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个简单的蓝图，可以在游戏运行时放置在世界上或动态生成。
- en: Blueprint Visual Scripting in Unreal Engine 4 is an extremely powerful and flexible
    node-based interface to create gameplay elements and provides artists and designers
    with the ability to program their game and to quickly iterate gameplay within
    the editor without writing a single line of code! Using Blueprints you can create
    and tweak gameplay, characters, inputs, environments, and virtually anything in
    your game.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 4中的蓝图视觉脚本是一个极其强大且灵活的基于节点的界面，用于创建游戏元素，并为艺术家和设计师提供编程游戏和快速在编辑器中迭代游戏玩法的能力，而无需编写任何代码！使用蓝图，您可以创建和调整游戏玩法、角色、输入、环境和游戏中几乎任何事物。
- en: Blueprints work by using graphs that contain various nodes connected to each
    other, which defines what the Blueprint does. For example, it can be gameplay
    events, spawning new Actors, or anything really.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图通过使用包含相互连接的节点的图来工作，这些节点定义了蓝图的功能。例如，它可以是对游戏事件的调用、生成新的演员，或者任何其他事情。
- en: Different Blueprint types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的蓝图类型
- en: 'Let''s take a quick look at various Blueprint types that are available in Unreal
    Engine 4:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看在Unreal Engine 4中可用的各种蓝图类型：
- en: '**Level Blueprint**: Level Blueprint is a special Blueprint that acts as a
    level-wide global event graph, which the user can neither remove nor create. Each
    level will have its own level Blueprint that the user can use to create events
    that pertain to the whole level. The user can use this graph to call events on
    a specific actor present in the level or play a Matinee sequence. Users who are
    familiar with Unreal Engine 3 (or UDK) should be familiar with this concept as
    this is similar to how Kismet worked in those Engines.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**级别蓝图**：级别蓝图是一种特殊的蓝图，充当整个级别的全局事件图，用户无法删除或创建。每个级别都将有自己的级别蓝图，用户可以使用它来创建与整个级别相关的事件。用户可以使用此图来调用级别中特定演员的事件或播放Matinee序列。熟悉Unreal
    Engine 3（或UDK）的用户应该熟悉这个概念，因为这类似于那些引擎中Kismet的工作方式。'
- en: '**Class Blueprint**: Commonly referred to as just Blueprint, is an asset that
    you create inside **Content Browser**. Once the asset is created, you define its
    behavior visually instead of typing any code. This Blueprint is saved as an asset
    in **Content Browser** so you can drag and drop this into your world as an instance
    or spawn dynamically in another Blueprint graph.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类蓝图**：通常简称为蓝图，是在**内容浏览器**内创建的资产。一旦创建资产，就通过视觉定义其行为而不是编写任何代码。此蓝图作为资产保存在**内容浏览器**中，因此您可以将其拖放到您的世界中作为实例，或在另一个蓝图图中动态生成。'
- en: '**Animation Blueprint**: These are specialized graphs that control the animation
    of a skeletal mesh by blending animations, controlling the bones directly, and
    outputting a final pose in each frame. Animation Blueprints will always have two
    graphs, namely **EventGraph** and **AnimGraph**.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画蓝图**：这些是专门用于通过混合动画、直接控制骨骼和输出每帧的最终姿势来控制骨骼网格动画的图。动画蓝图始终有两个图，即**事件图**和**AnimGraph**。'
- en: '**EventGraph**: This uses a collection of animation-related events to initiate
    a sequence of nodes, which updates the values used to drive animations within
    **Animgraph**.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件图**：这使用一系列与动画相关的事件来启动一系列节点，这些节点更新在**Animgraph**中驱动动画使用的值。'
- en: '**AnimGraph**: This is used to evaluate the final pose for your **Skeletal
    Mesh**. In this graph, you can perform animation blends or control bone transforms
    using **SkeletalControls**.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AnimGraph**：用于评估您的**骨骼网格**的最终姿势。在此图中，您可以使用**骨骼控制**执行动画混合或控制骨骼变换。'
- en: '**Macro Library**: These are containers that can hold various macros or graphs
    that you can use multiple times in any other Blueprint class. Macro libraries
    cannot contain variables or inherit from other Blueprints or be placed in the
    level. They are just a collection of graphs that you use commonly and can be a
    time-saver. If you are referencing a macro in your Blueprint then changes to that
    macro will not be applied to your Blueprint until you recompile your Blueprint.
    Compiling a Blueprint means converting all the properties and graphs into a class
    that Unreal can use.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宏库**：这些是可以包含各种宏或图，您可以在任何其他蓝图类中多次使用的容器。宏库不能包含变量或从其他蓝图继承，也不能放置在级别中。它们只是您常用的一些图的集合，可以节省时间。如果您在蓝图中引用宏，则对该宏的更改不会应用到您的蓝图，直到您重新编译蓝图。编译蓝图意味着将所有属性和图转换为Unreal可以使用的类。'
- en: '**Blueprint Interface**: These are graphs that contain one or more functions
    without implementation. Other classes that add this interface must include the
    functions in a unique manner. This has the same concept of interface in programming
    where you can access various objects with a common interface and share or send
    data to one another. Interface graphs have some limitations in that you cannot
    create variables, edit graphs, or add any components.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝图接口**：这些是包含一个或多个未实现函数的图。添加此接口的其他类必须以独特的方式包含这些函数。这与编程中的接口概念相同，您可以使用公共接口访问各种对象并向彼此共享或发送数据。接口图有一些限制，您不能创建变量、编辑图或添加任何组件。'
- en: Getting familiar with the Blueprint user interface
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉蓝图用户界面
- en: 'The Blueprint **User Interface** (**UI**) contains various tabs by default.
    In the following screenshot you can see the unified layout of the Blueprint UI:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图**用户界面**（**UI**）默认包含多个选项卡。在下面的屏幕截图中，您可以看到蓝图UI的统一布局：
- en: '![Getting familiar with the Blueprint user interface](img/B03950_06_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![熟悉蓝图用户界面](img/B03950_06_01.jpg)'
- en: 'Let''s take a look at these tabs:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些选项卡：
- en: '**Components**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**'
- en: '**My Blueprint**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我的蓝图**'
- en: '**Toolbar**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具栏**'
- en: '**Graph editor**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形编辑器**'
- en: '**Details panel**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**详细信息面板**'
- en: Components tab
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件选项卡
- en: Most Blueprint classes can have different types of components. These can be
    light components, mesh components, UI components, and so on. In this section,
    we will see what they are and how we can use them in our Blueprint classes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数蓝图类都可以有不同的组件类型。这些可以是灯光组件、网格组件、UI组件等等。在本节中，我们将了解它们是什么以及我们如何在蓝图类中使用它们。
- en: What are components?
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件是什么？
- en: Components are the bits and pieces that make up the whole Actor. Components
    cannot exist on their own but when added to an Actor, the Actor will then have
    access to all the functionalities provided by the component. For example, think
    about a car. The wheels, body, lights, and so on can be considered as components
    and the car itself as the Actor. Then in the graph, you can access the component
    and do the logic for your car Actor. Components are always instanced and each
    Actor instance will have its own unique instance of components. If this were not
    the case, then, if we place multiple car Actors in world and if one starts moving,
    all the others will also move.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是构成整个Actor的各个部分。组件不能独立存在，但添加到Actor后，Actor将能够访问组件提供的所有功能。例如，考虑一辆车。车轮、车身、灯光等可以视为组件，而汽车本身作为Actor。然后在图中，您可以访问组件并为您的汽车Actor执行逻辑。组件始终是实例化的，每个Actor实例都将有其自己的唯一组件实例。如果不是这样，那么，如果我们将多个汽车Actor放置在世界中，如果一个开始移动，所有其他的也将移动。
- en: Adding a component
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加组件
- en: To add a component to your Actor, click the **Add Component** button on the
    **Components** tab. After clicking the button it will show a list of various **Components**
    that you can add.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要将组件添加到您的Actor中，请点击**组件**选项卡上的**添加组件**按钮。点击按钮后，它将显示您可以添加的各种**组件**列表。
- en: '![Adding a component](img/B03950_06_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![添加组件](img/B03950_06_02.jpg)'
- en: After adding a component, you will be prompted to give it a name. Components
    can also be directly added simply by dragging-and-dropping from **Content Browser**
    to the **Components** window.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 添加组件后，您将被提示为其命名。您也可以通过从**内容浏览器**拖放到**组件**窗口直接添加组件。
- en: To rename a component, you can select it in the **Components** tab and press
    *F2*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要重命名组件，您可以在**组件**选项卡中选择它并按*F2*。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The drag-and-drop method only applies to **StaticMeshes**, **SkeletalMeshes**,
    **SoundCues**, and **ParticleSystems**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放方法仅适用于**静态网格**、**骨骼网格**、**声音提示**和**粒子系统**。
- en: With the component selected, you can delete it by pressing the *Delete* key.
    You can also right-click on the component and select **Delete** to remove it as
    well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 选择组件后，你可以通过按*Delete*键来删除它。你也可以在组件上右键点击并选择**删除**来移除它。
- en: Transforming the component
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变换组件
- en: Once the component is added and selected, you can use the transform tools (*W*,
    *E*, and *R*) to change the location, rotation, and scale of the component either
    by entering values in the **Details** panel or in the **Viewport** tab. When using
    moving, rotating, or scaling, you can press *Shift* to enable snapping, provided
    you have enabled grid snapping in the **Viewport** toolbar.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦组件被添加并选择，你可以使用变换工具（*W*、*E*和*R*）通过在**详情**面板或**视口**标签中输入值来改变组件的位置、旋转和缩放。当使用移动、旋转或缩放时，如果你在**视口**工具栏中启用了网格吸附，你可以按*Shift*来启用吸附。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the Component has any child components attached to it then moving, rotating
    or scaling that component will propagate the transformation to all child components
    too.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件有任何子组件附加到它上面，那么移动、旋转或缩放该组件将传播变换到所有子组件。
- en: Adding events for components
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为组件添加事件
- en: 'Adding events based on a component is very easy and can be done by different
    methods. Events created in this manner are specific to that component and need
    not be tested as to which component is involved:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据组件添加事件非常简单，可以通过不同的方法完成。以这种方式创建的事件是特定于该组件的，无需测试涉及哪个组件：
- en: '**Adding events from the details panel**: When you select the component you
    will see all the events available for that component in the **Details** panel
    as buttons. When you click on any of them, the editor will create the event node
    specific for that component in the event graph.![Adding events for components](img/B03950_06_03.jpg)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从详情面板添加事件**：当你选择组件时，你将在**详情**面板中看到该组件所有可用的事件作为按钮。当你点击任何一个时，编辑器将在事件图中为该组件创建特定的事件节点。![为组件添加事件](img/B03950_06_03.jpg)'
- en: '**Adding events by right-clicking**: When you right-click on a component, you
    will see **Add Event** in the context menu. From there you can select any event
    you want and editor will create the event node specific to that component in the
    event graph.![Adding events for components](img/B03950_06_04.jpg)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过右键点击添加事件**：当你在组件上右键点击时，你将在上下文菜单中看到**添加事件**。从那里你可以选择任何你想要的事件，编辑器将在事件图中为该组件创建特定的事件节点。![为组件添加事件](img/B03950_06_04.jpg)'
- en: '**Adding events in the graph**: Once you select your component in the **My
    Blueprints** tab, you can right-click on the graph and get all the **Events**
    for that component.![Adding events for components](img/B03950_06_05.jpg)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在图中添加事件**：一旦你在**我的蓝图**标签页中选择了你的组件，你可以在图上右键点击并获取该组件的所有**事件**。![为组件添加事件](img/B03950_06_05.jpg)'
- en: My Blueprints tab
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我的蓝图标签页
- en: The **My Blueprints** tab displays a list of **Graphs**, **Functions**, **Macros**,
    **Variables**, and so on that are contained within your Blueprint. This tab is
    dependent on the type of Blueprint. For example, a class Blueprint will have **EventGraph**,
    **ConstructionScript Graph**, **Variables**, **Functions**, **Macros**, and so
    on. An interface will only show the list of functions within it. A **Macro Library**
    will show only the macros created within it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**我的蓝图**标签页显示了一个列表，其中包括了蓝图内包含的**图形**、**函数**、**宏**、**变量**等等。此标签页依赖于蓝图类型。例如，类蓝图将包含**事件图**、**构建脚本图**、**变量**、**函数**、**宏**等等。接口将仅显示其中的函数列表。**宏库**将仅显示其中创建的宏。'
- en: Creation buttons
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建按钮
- en: You can create new variables, functions, macros, event graphs, and event dispatchers
    inside the **My Blueprints** tab by clicking the shortcut button (**+**).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击快捷按钮（**+**）在**我的蓝图**标签页内创建新的变量、函数、宏、事件图和事件分发器。
- en: '![Creation buttons](img/B03950_06_06.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![创建按钮](img/B03950_06_06.jpg)'
- en: You can also add them by clicking the **+Add New** drop-down button.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过点击**+添加新**下拉按钮来添加它们。
- en: Searching in my Blueprint
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我的蓝图中进行搜索
- en: The **My Blueprint** tab also provides a search area to search for your variables,
    functions, macros, event graphs, and event dispatchers. You can search based on
    name, comment, or any other data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**我的蓝图**标签页还提供了一个搜索区域，用于搜索你的变量、函数、宏、事件图和事件分发器。你可以根据名称、注释或其他数据进行搜索。'
- en: Categorizing in My Blueprint
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我的蓝图中进行分类
- en: 'It is always a good practice to organize your variables, functions, macros,
    event dispatchers, and so on into various categories. In the **My Blueprints**
    tab, you can have as many categories with sub-categories. Check the following
    screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总是组织你的变量、函数、宏、事件调度器等等到各种类别中是一个好习惯。在**我的蓝图**标签页中，你可以拥有尽可能多的类别和子类别。查看以下截图：
- en: '![Categorizing in My Blueprint](img/B03950_06_07.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![在“我的蓝图”中分类](img/B03950_06_07.jpg)'
- en: 'Here you can see how I have organized everything into various categories and
    sub-categories. To set a category for your variables, functions, macros, and event
    dispatchers, simply select them and in the **Details** panel you can type your
    new category name or select from an existing category. If you need sub-categories
    then you need to separate your sub-category name with a vertical bar key (**|**).
    For example, if you want **Health** as a sub-category in **Attributes**, you can
    set it like this: **Attributes** | **Health**.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我如何将所有内容组织成各种类别和子类别。要为你的变量、函数、宏和事件调度器设置类别，只需选择它们，然后在**详细信息**面板中输入你的新类别名称或从现有类别中选择。如果你需要子类别，则需要使用垂直线键（**|**）来分隔子类别名称。例如，如果你想将**健康**作为**属性**的子类别，你可以设置如下：**属性**
    | **健康**。
- en: Toolbar
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具栏
- en: The toolbar provides access to common commands required while editing Blueprints.
    Toolbar buttons will be different depending on which mode (editing mode, play
    in editor mode, and so on) is active and which Blueprint type you are currently
    editing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏提供了在编辑蓝图时所需的常用命令的访问权限。工具栏按钮将根据当前激活的模式（编辑模式、在编辑器中播放模式等）以及你当前正在编辑的蓝图类型而有所不同。
- en: Graph editor
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形编辑器
- en: Graph editor is the main area of your Blueprint. This is where you add new nodes
    and connect them to create the network that defines the scripted behavior. More
    information on how to create new nodes and various nodes will be explained later
    on in this book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图形编辑器是蓝图的主要区域。这是你添加新节点并将它们连接起来以创建定义脚本行为的网络的区域。关于如何创建新节点以及各种节点的更多信息将在本书的后续部分进行解释。
- en: Details panel
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细信息面板
- en: The **Details** panel provides access to properties of the selected **Components**
    or **Variables**. It contains a search field so you can search for a specific
    property.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细信息**面板提供了访问所选**组件**或**变量**属性的方法。它包含一个搜索字段，你可以用它来搜索特定的属性。'
- en: Blueprint graph types
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图图类型
- en: 'As we mentioned before, Blueprints are assets that are saved in **Content Browser**
    that are used to create new types of Actors or script gameplay logic, events,
    and so on, giving both designers and programmers the ability to quickly iterate
    gameplay without writing a single line of code. In order for a Blueprint to have
    scripted behavior, we need to define how it behaves using various nodes in graph
    editor. Let''s take a quick look at various graphs:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，蓝图是保存在**内容浏览器**中的资产，用于创建新的演员类型或脚本游戏逻辑、事件等，这为设计师和程序员提供了快速迭代游戏玩法而不需要写一行代码的能力。为了让蓝图具有脚本行为，我们需要在图形编辑器中使用各种节点来定义其行为。让我们快速看一下各种图：
- en: '**Construction Script Graph**: Construction graph is executed the moment the
    Blueprint is initialized and whenever a change happens to any variables within
    the Blueprint. This means that whenever you place an instance of the Blueprint
    in the level and change its transformation or any variable, the construction graph
    is executed. This graph is executed once every time it is constructed and again
    when any of the properties or Blueprint is updated. This can be used to construct
    procedural elements or to set up values before the game begins.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造脚本图**：构造图在蓝图初始化时执行，并且每当蓝图中的任何变量发生变化时都会执行。这意味着每次你在级别中放置蓝图实例并更改其变换或任何变量时，构造图都会执行。此图在每次构建时执行一次，并且在任何属性或蓝图更新时再次执行。这可以用于构建程序元素或设置游戏开始前的值。'
- en: '**Event Graph**: This is where all the gameplay logic is contained, including
    interactivity and dynamic responses. Using various event nodes as entry points
    to functions, flow controls, and variables, you can script the behavior of the
    Blueprint. Event graphs are only executed when you start the game.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件图**：这是包含所有游戏逻辑的地方，包括交互性和动态响应。使用各种事件节点作为函数、流程控制和变量的入口点，你可以为蓝图脚本化行为。事件图仅在开始游戏时执行。'
- en: '**Function Graph**: By default, this graph contains one single entry point
    with the name of the function. This node can never be deleted but you can move
    it around freely. Nodes in this graph are only executed when you call this function
    in the construction or event graph or from another Blueprint that is referencing
    the Blueprint that this function belongs to.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数图**: 默认情况下，此图包含一个名为函数的单个入口点。此节点不能被删除，但你可以自由移动它。此图中的节点仅在你在构造图或事件图中调用此函数或从引用此函数所属蓝图的另一个蓝图调用此函数时执行。'
- en: '**Macro Graph**: This is like a collapsed graph that contains your nodes. Unlike
    function graphs, macros can have multiple inputs or outputs.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宏图**: 这就像是一个包含你的节点的折叠图。与函数图不同，宏可以有多个输入或输出。'
- en: '**Interface Graph**: Interface graphs are disabled and you cannot move, create
    graphs, variables, or components.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口图**: 接口图被禁用，你不能移动、创建图、变量或组件。'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Only class Blueprints have **Construction Script** and it stops executing when
    gameplay begins and is considered completed before gameplay.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 只有类蓝图才有**构造脚本**，它在游戏开始时停止执行，并被视为在游戏开始前完成。
- en: Function graph
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数图
- en: Function graphs are node graphs created inside a Blueprint and can be executed
    from another graph (such as **Event Graph** or **Construction Script**) or from
    another Blueprint. By default, function graphs contain a single execution pin
    that is activated when the function is called, causing the connected nodes to
    execute.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 函数图是在蓝图内部创建的节点图，可以从另一个图（如**事件图**或**构造脚本**）或从另一个蓝图执行。默认情况下，函数图包含一个单一的执行引脚，当函数被调用时激活，导致连接的节点执行。
- en: Creating functions
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建函数
- en: Function graphs are created through **My Blueprints** tab and you can create
    as many functions as you want.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 函数图是通过**我的蓝图**选项卡创建的，你可以创建任意数量的函数。
- en: Inside **My Blueprints** tab you can hover your mouse over the functions header
    and click on **+Function** to add a new function
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在**我的蓝图**选项卡中，你可以将鼠标悬停在函数标题上，然后点击**+函数**来添加一个新函数。
- en: '![Creating functions](img/B03950_06_08.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![创建函数](img/B03950_06_08.jpg)'
- en: Clicking that button (the yellow highlighted button) will create a new function
    and prompts you to enter a new name for it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 点击那个按钮（黄色高亮的按钮）将创建一个新的函数，并提示你输入一个新名称。
- en: Graph settings
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图形设置
- en: When you create a new function and select it, you will get some properties of
    that function, which you can change in the **Details** panel. Let's take a quick
    look at them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个新函数并选择它时，你将获得该函数的一些属性，你可以在**详细信息**面板中更改它们。让我们快速看一下它们。
- en: '![Graph settings](img/B03950_06_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图形设置](img/B03950_06_09.jpg)'
- en: '**Description**: Appears as a tooltip when you hover your mouse over this function
    in another graph.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**: 当你在另一个图中的此函数上悬停鼠标时，会显示为工具提示。'
- en: '**Category**: Keeps this function in its given category (for organizational
    purpose only).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**: 保持此函数在其指定的类别中（仅用于组织目的）。'
- en: '**Access Specifier**: Sometimes when you create functions, you don''t want
    to access some of them in another Blueprint. Access specifiers let you specify
    what other objects can access this function.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问指定符**: 有时当你创建函数时，你不想在另一个蓝图中访问它们。访问指定符让你指定哪些其他对象可以访问此函数。'
- en: '**Public**: This means any object can access this function from anywhere. This
    is the default setting.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**: 这意味着任何对象都可以从任何地方访问此功能。这是默认设置。'
- en: '**Protected**: This means current Blueprint and any Blueprints derived from
    the current Blueprint can access this function.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护**: 这意味着当前蓝图及其从当前蓝图派生的任何蓝图都可以访问此功能。'
- en: '**Private**: This setting means only the current Blueprint can access this
    function.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**: 此设置意味着只有当前蓝图可以访问此功能。'
- en: '**Pure**: When enabled, this function is marked as a **Pure Function** and
    when disabled it is an **Impure Function**.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯函数**: 当启用时，此功能被标记为**纯函数**，当禁用时，则为**不纯函数**。'
- en: '**Pure Function** will not modify state or members of a class in any way and
    is considered a **Constant Function** that only outputs a data value and does
    not have an execution pin. These are connected to other **Data Pins** and are
    automatically executed when the data on them is required.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯函数**不会以任何方式修改类的状态或成员，被视为**常量函数**，它只输出数据值，没有执行引脚。这些与**数据引脚**相连，并在需要它们上的数据时自动执行。'
- en: '**Impure Function** is free to modify any value in a class and contains an
    execution pin.'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不纯函数**可以自由修改类中的任何值，并包含一个执行引脚。'
- en: 'The following is a screenshot showing the difference between **Pure Function**
    and **Impure Function**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了**纯函数**和**不纯函数**之间的区别：
- en: '![Graph settings](img/B03950_06_10.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图形设置](img/B03950_06_10.jpg)'
- en: Editing functions
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑函数
- en: To define the functionality of the function you need to edit it. You can have
    as many inputs or outputs as you want, and can then create a node network between
    those inputs and outputs to define the functionality. To add input or output,
    you first need to select the function either in the **My Blueprint** tab or select
    the main pink node when you open the **Function Graph**. Then, in the **Details**
    panel, you will see a button labelled **New** that creates new inputs or outputs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义函数的功能，您需要编辑它。您可以拥有任意数量的输入或输出，然后在这些输入和输出之间创建节点网络来定义功能。要添加输入或输出，您首先需要在**我的蓝图**选项卡中选择函数，或者在打开**函数图**时选择主要粉红色节点。然后，在**详细信息**面板中，您将看到一个标有**新建**的按钮，该按钮创建新的输入或输出。
- en: '![Editing functions](img/B03950_06_11.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![编辑函数](img/B03950_06_11.jpg)'
- en: In this screenshot you can see how I added new inputs and outputs to **Function
    Example**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，您可以看到我如何向**函数示例**添加新的输入和输出。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**ReturnNode** is optional and will only appear if you have at least one output
    data pin. If you remove all output pins then **ReturnNode** is automatically removed
    and you can still use your function.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**ReturnNode**是可选的，并且只有在您至少有一个输出数据引脚时才会出现。如果您移除所有输出引脚，则**ReturnNode**将自动删除，您仍然可以使用您的函数。'
- en: For example, in the following screenshot I created a Blueprint function that
    appends a prefix to my character name so I can use this one single function to
    change the prefix anytime I want.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的屏幕截图中，我创建了一个蓝图函数，为我的角色名称添加了一个前缀，这样我就可以使用这个单一函数随时更改前缀。
- en: '![Editing functions](img/B03950_06_12.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![编辑函数](img/B03950_06_12.jpg)'
- en: Now, back in **Event Graph**, I call this function on the **Begin Play** event
    so I can set the character name when the game starts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到**事件图**，我在**开始播放**事件上调用这个函数，这样我就可以在游戏开始时设置角色名称。
- en: '![Editing functions](img/B03950_06_13.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![编辑函数](img/B03950_06_13.jpg)'
- en: Macro graph
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏图
- en: Macro graphs are essentially collapsed graphs of nodes, which contain an entry
    point and exit point designated by tunnel nodes but cannot contain variables.
    Macro graphs can have any number of execution or data pins.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 宏图实际上是节点的折叠图，其中包含由隧道节点指定的入口点和出口点，但不能包含变量。宏图可以有任何数量的执行或数据引脚。
- en: Macros can be created inside a **Class Blueprint** or **Level Blueprint** like
    functions or you can organize your **Macros** in a **Blueprint Macro Library**,
    which can be created in **Content Browser**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 宏可以在**类蓝图**或**关卡蓝图**内创建，就像函数一样，或者您可以在**蓝图宏库**中组织您的**宏**，该宏库可以在**内容浏览器**中创建。
- en: '**Blueprint Macro Library** can contain all your **Macros** in one place so
    you can use them in any other Blueprint. These can be real time-savers as they
    can contain most commonly used nodes and can transfer data. But changes to a macro
    graph are only reflected when the Blueprint containing that macro is recompiled.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**蓝图宏库**可以包含您所有的**宏**在一个地方，这样您就可以在任何其他蓝图中使用它们。这些可以节省大量时间，因为它们可以包含大多数常用节点并可以传输数据。但是，对宏图的更改只有在包含该宏的蓝图重新编译时才会反映出来。'
- en: To create a macro library you need to right-click in **Content Browser** and
    select **Blueprint Macro Library** from the Blueprints sub-category.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个宏库，您需要在**内容浏览器**中右键点击，并从蓝图子类别中选择**蓝图宏库**。
- en: '![Macro graph](img/B03950_06_14.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![宏图](img/B03950_06_14.jpg)'
- en: Once you select that option you have to select a parent class for your Macro.
    Most of the time we select Actor as the parent class. After the selection, you
    will be prompted to type a name for your Macro library and save it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择该选项，您必须为您的宏选择一个父类。大多数情况下，我们选择**演员**作为父类。选择后，您将被提示为您的宏库输入一个名称并保存它。
- en: If you just created your Macro library, the editor will create a blank Macro
    named **NewMacro_0** and will be highlighted for you to rename.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刚刚创建了您的宏库，编辑器将创建一个名为**NewMacro_0**的新宏，并将其突出显示以便您重命名。
- en: As you did with functions, you can type a description and define a **Category**
    for your Macro. You also get an option to define a color for your Macro using
    **Instance Color**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 就像处理函数一样，您可以输入一个描述并为您的宏定义一个**类别**。您还可以使用**实例颜色**为您的宏定义一个颜色。
- en: 'In the following screenshot you can see I created a Macro with multiple outputs
    and defined a **Description**, **Category**, and an **Instance Color** for the
    Macro:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到我创建了一个具有多个输出的宏，并为宏定义了**描述**、**类别**和**实例颜色**：
- en: '![Macro graph](img/B03950_06_15.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![宏图](img/B03950_06_15.jpg)'
- en: In any other Blueprint I can now get this Macro and use it. If you hover you
    mouse over the Macro, you can see the description you set as a **Tooltip**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他蓝图中，我现在都可以获取这个宏并使用它。如果您将鼠标悬停在宏上，您可以看到您设置的作为**工具提示**的描述。
- en: '![Macro graph](img/B03950_06_16.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![宏图](img/B03950_06_16.jpg)'
- en: Interface graph
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口图
- en: Interface graphs are a collection of functions without any implementation, which
    can be added to other Blueprints. Any Blueprint class implementing an interface
    will definitely contain all the functions from the interface. It is then up to
    the user to give functionality to the functions in that interface. Interface editor
    is similar to other Blueprints but you cannot add new variables, edit the graph,
    or add any components.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接口图是函数的集合，没有任何实现，可以添加到其他蓝图中。任何实现接口的蓝图类都将肯定包含接口中的所有函数。然后，用户需要为该接口中的函数提供功能。接口编辑器类似于其他蓝图，但您不能添加新变量、编辑图表或添加任何组件。
- en: Interfaces are used to communicate between various Blueprints that share specific
    functionality. For example, if the player is having a **Flame Thrower** gun and
    in the game you have **Ice** and **Cloth**, both can take damage but one should
    melt and the other should burn. You can create a **Blueprint Interface** that
    contains a **TakeWeaponFire** function and have **Ice** and **Cloth** implement
    this interface. Then, in **Ice Blueprint**, you can implement the **TakeWeaponFire**
    function and make the ice melt and, in **Cloth Blueprint**, you can implement
    that same function and make the cloth burn. Now when you are firing your **Flame
    Thrower** you can simply call the **TakeWeaponFire** function and it calls them
    in those Blueprints.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接口用于在具有特定功能的不同蓝图之间进行通信。例如，如果玩家有一个**火焰喷射器**枪，在游戏中您有**冰**和**布料**，两者都可以受到伤害，但一个应该融化，另一个应该燃烧。您可以创建一个包含**TakeWeaponFire**函数的**蓝图接口**，让**冰**和**布料**实现此接口。然后，在**冰蓝图**中，您可以实现**TakeWeaponFire**函数并使冰融化，在**布料蓝图**中，您可以实现相同的函数并使布料燃烧。现在，当您使用**火焰喷射器**射击时，您只需调用**TakeWeaponFire**函数，它就会调用那些蓝图中的函数。
- en: To create a new interface, you need to right-click on the **Content Browser**
    and select **Blueprint Interface** from the Blueprints sub-category and then name
    it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的接口，您需要在**内容浏览器**上右键单击，并从**蓝图**子类别中选择**蓝图接口**，然后命名它。
- en: 'In the following example I named it **BP_TestInterface**:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我将其命名为**BP_TestInterface**：
- en: '![Interface graph](img/B03950_06_17.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![接口图](img/B03950_06_17.jpg)'
- en: If you just created your interface the editor will create a blank function named
    **NewFunction_0**, which will be highlighted for you to rename. If you implement
    this interface on any Blueprint then it will have this function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刚刚创建了您的接口，编辑器将创建一个名为**NewFunction_0**的空白函数，该函数将突出显示以便您重命名。如果您在任何蓝图中实现此接口，则它将具有此函数。
- en: In this example, I created a function called **MyInterfaceFunction**. We will
    use this to simply print out the Actor name that implements this interface.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我创建了一个名为**MyInterfaceFunction**的功能。我们将使用它简单地打印出实现此接口的Actor名称。
- en: '![Interface graph](img/B03950_06_18.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![接口图](img/B03950_06_18.jpg)'
- en: To create functionality for this function, we first need to implement this interface
    in a Blueprint. So open your Blueprint where you want this to be implemented and
    select **Class Settings** in the **Toolbar**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要为此函数创建功能，我们首先需要在蓝图中实现此接口。因此，打开您想要实现此功能的蓝图，并在**工具栏**中选择**类设置**。
- en: '![Interface graph](img/B03950_06_19.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![接口图](img/B03950_06_19.jpg)'
- en: Now the **Details** panel will show the settings for this Blueprint and, under
    the **Interfaces** section, you can add your interface.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**详细信息**面板将显示此蓝图的相关设置，在**接口**部分，您可以添加您的接口。
- en: '![Interface graph](img/B03950_06_20.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![接口图](img/B03950_06_20.jpg)'
- en: Once you add that interface, the **My Blueprints** tab will update to show you
    the interface functions. Now all you have to do is double-click on the function
    to open the graph and add functionality.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了该接口，**我的蓝图**标签页将更新以显示接口功能。现在您只需双击该功能即可打开图表并添加功能。
- en: '![Interface graph](img/B03950_06_21.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![接口图](img/B03950_06_21.jpg)'
- en: The reason why **MyInterfaceFunction** appears in the **My Blueprints** tab
    is because that function contains an output value. If you have an interface function
    without an output then it won't appear in the **My Blueprints** tab. Instead it
    appears under **Events** when right-clicking in your Blueprint. For example, in
    that same interface I created another function without output data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**我的接口函数**出现在**我的蓝图**标签页中的原因是该函数包含一个输出值。如果您有一个没有输出的接口函数，则它不会出现在**我的蓝图**标签页中。相反，当在蓝图上右键单击时，它将出现在**事件**下。例如，在同一个接口中，我创建了一个没有输出数据的另一个函数。'
- en: '![Interface graph](img/B03950_06_22.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![接口图](img/B03950_06_22.jpg)'
- en: This **AnotherInterfaceFunction** will not appear in the **My Blueprints** tab
    because it has no output. So, to implement this function in your Blueprint, you
    have to add this as an event.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**另一个接口函数**不会出现在**我的蓝图**标签页中，因为它没有输出。因此，要在您的蓝图实现此函数，您必须将其添加为事件。'
- en: '![Interface graph](img/B03950_06_23.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![接口图](img/B03950_06_23.jpg)'
- en: Blueprint node references
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图节点引用
- en: The behavior of a Blueprint object is defined using various nodes. Nodes can
    be **Events**, **Function Calls**, **Flow Control**, **Variables**, and so on
    that are used in the graph. Even though each type of node has a unique function,
    the way they are created and used is common.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用各种节点定义蓝图对象的行为。节点可以是**事件**、**函数调用**、**流程控制**、**变量**等，这些都是在图中使用的。尽管每种类型的节点都有其独特的功能，但它们的创建和使用方式是通用的。
- en: Nodes are added to the graph by right-clicking inside the graph panel and selecting
    the node from the **Context Menu**. If a component inside Blueprint is selected,
    events and functions supported by that component are also listed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在图面内右键单击并从**上下文菜单**中选择节点，可以将节点添加到图中。如果选择了蓝图内的组件，则该组件支持的事件和函数也会列出。
- en: '![Blueprint node references](img/B03950_06_24.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图节点引用](img/B03950_06_24.jpg)'
- en: After a node is added you can select it and move it around using the left mouse
    button. You can use *Ctrl* to add or remove from the current selection of nodes.
    Clicking and dragging inside the graph creates a **Marquee Selection** that adds
    to the current selection.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 添加节点后，您可以使用左鼠标按钮选择并移动它。您可以使用*Ctrl*键向当前节点选择中添加或删除节点。在图中单击并拖动会创建一个**矩形选择**，它将添加到当前选择中。
- en: 'Nodes can have multiple inputs and outputs and are of two types: **Execution
    Pins** and **Data Pins**.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 节点可以有多个输入和输出，分为两种类型：**执行引脚**和**数据引脚**。
- en: Execution pins start the flow of execution and when the execution is completed
    it activates an output execution pin to continue the flow. Execution pins are
    drawn as outlines when not wired and solid white when connected.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 执行引脚启动执行流程，当执行完成后，它会激活一个输出执行引脚以继续流程。未连接时，执行引脚以轮廓形式绘制，连接时以纯白色绘制。
- en: '![Blueprint node references](img/B03950_06_25.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图节点引用](img/B03950_06_25.jpg)'
- en: Data pins are nodes that transfer (such as taking and outputting) data from
    one node to the other. These nodes are type specific. That means they can be connected
    to variables of the same type. Some data pins are automatically converted if you
    connect them to another data pin that is not of the same type. For example, if
    you connect a `float` variable to `string`, the Blueprint editor will automatically
    insert a `float` to a `string` conversion node. Like execution pins, they are
    drawn as an outline when not connected, and a solid color when connected.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 数据引脚是节点，用于从一个节点传输（如取用和输出）数据到另一个节点。这些节点是类型特定的。这意味着它们可以连接到相同类型的变量。如果将它们连接到不同类型的另一个数据引脚，某些数据引脚会自动转换。例如，如果您将`float`变量连接到`string`，蓝图编辑器将自动插入一个`float`到`string`转换节点。像执行引脚一样，未连接时以轮廓形式绘制，连接时以纯色绘制。
- en: '![Blueprint node references](img/B03950_06_26.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图节点引用](img/B03950_06_26.jpg)'
- en: Node colors
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点颜色
- en: Nodes in Blueprint have different colors that show what kind of node it is.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图中的节点有不同的颜色，表示它是什么类型的节点。
- en: A red-colored node means it's an event node and this is where execution starts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 红色节点表示它是一个事件节点，这是执行开始的地方。
- en: '![Node colors](img/B03950_06_27.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![节点颜色](img/B03950_06_27.jpg)'
- en: A blue-colored node means it can either be a function or an event being called.
    These nodes can have multiple inputs or outputs. The icon on top of the function
    will be changed based on whether it's a function or event.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色节点表示它可以是函数或被调用的事件。这些节点可以有多个输入或输出。函数顶部的图标将根据它是函数还是事件而改变。
- en: '![Node colors](img/B03950_06_28.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![节点颜色](img/B03950_06_28.jpg)'
- en: A purple-colored node can neither be created nor destroyed. You can see this
    node in **Construction Script** and **Functions**.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 紫色的节点既不能创建也不能销毁。你可以在**构造脚本**和**函数**中看到此节点。
- en: '![Node colors](img/B03950_06_29.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![节点颜色](img/B03950_06_29.jpg)'
- en: A grey node can be a **Macro**, **Flow Control**, or **Collapsed** node.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 灰色的节点可以是**宏**、**流程控制**或**折叠**节点。
- en: '![Node colors](img/B03950_06_30.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![节点颜色](img/B03950_06_30.jpg)'
- en: A green-colored node usually means a Pure function used to get a value.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色的节点通常表示一个纯函数，用于获取值。
- en: '![Node colors](img/B03950_06_31.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![节点颜色](img/B03950_06_31.jpg)'
- en: A cyan-colored node means it's a cast node. This node converts the given object
    to another.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色的节点表示它是一个铸造节点。此节点将给定的对象转换为另一个对象。
- en: '![Node colors](img/B03950_06_32.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![节点颜色](img/B03950_06_32.jpg)'
- en: Variables
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: Variables are properties that hold a value or an object reference. They can
    be accessed inside the Blueprint editor or from another Blueprint. They can be
    created to include data types (`float`, `integer`, `Boolean`, and so on) or reference
    types or classes. Each variable can also be an array. All types are color coded
    for easy identification.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是持有值或对象引用的属性。它们可以在蓝图编辑器内部或从另一个蓝图访问。它们可以创建以包含数据类型（`float`、`integer`、`Boolean`等）或引用类型或类。每个变量也可以是一个数组。所有类型都有颜色编码，以便于识别。
- en: Math expression
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学表达式
- en: Math expression nodes are essentially collapsed nodes that you can double-click
    to open the sub graph to see the functionality. Whenever you rename the node,
    the new expression is parsed and a new graph is generated. To rename the node,
    simply select it and press *F2*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 数学表达式节点本质上是可以双击打开子图以查看功能的折叠节点。每次你重命名节点时，都会解析新的表达式并生成一个新的图。要重命名节点，只需选择它并按*F2*。
- en: To create a **Math Expression** node, right-click on the graph editor and select
    **Add Math Expression** node. You will then be prompted to type your **Math Expression**.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个**数学表达式**节点，在图编辑器上右键单击并选择**添加数学表达式**节点。然后你将被提示输入你的**数学表达式**。
- en: 'For example, let''s type this expression: *(vector(x, y, z)) + ((a + 1) * (b
    + 1))* and press *Enter*.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们输入这个表达式：*(vector(x, y, z)) + ((a + 1) * (b + 1))* 并按*Enter*。
- en: '![Math expression](img/B03950_06_33.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![数学表达式](img/B03950_06_33.jpg)'
- en: You will now see that the **Math Expression** node has automatically parsed
    your expression and generated proper variables and a graph from your expression.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在会看到**数学表达式**节点已经自动解析了你的表达式，并从你的表达式中生成了适当的变量和图。
- en: '![Math expression](img/B03950_06_34.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![数学表达式](img/B03950_06_34.jpg)'
- en: 'The following operators are supported and can be combined with logical and
    comparison operators to create complex expressions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下运算符受支持，可以与逻辑和比较运算符结合使用以创建复杂表达式：
- en: '**Multiplicative**: *, /, % (modulo)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乘法**: *, /, % (取模)'
- en: '**Additive**: +, -'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加法**: +, -'
- en: '**Relational**: <, >, <=, >='
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系**: <, >, <=, >='
- en: '**Equality**: == (equal), != (not equal)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相等性**: == (等于), != (不等于)'
- en: '**Logical**: || (or), && (and), ^ (power)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑**: || (或), && (与), ^ (幂)'
- en: Creating our first Blueprint class
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个蓝图类
- en: Now that we have an idea of what Blueprint is and what it does, let's create
    a simple Blueprint actor that spins on its own and destroys itself after a few
    seconds with a particle effect and sound. After creating our Blueprint, we will
    drag and drop this into the world and we will also use the **Level Blueprint**
    to dynamically spawn this Blueprint while running the game.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了蓝图是什么以及它做什么，让我们创建一个简单的蓝图演员，它会在自己的基础上旋转，并在几秒钟后通过粒子效果和声音自我销毁。创建我们的蓝图后，我们将将其拖放到世界中，并在运行游戏时使用**关卡蓝图**动态生成此蓝图。
- en: Creating a new Blueprint
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的蓝图
- en: To create this Blueprint, first right-click inside **Content Browser** and select
    **Blueprint Class**. Once you click that you will be prompted to select a parent
    class for the Blueprint. You need to specify a parent class for your Blueprint
    as it will inherit all properties from that parent class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此蓝图，首先在**内容浏览器**内右键单击并选择**蓝图类**。点击后，你将被提示选择蓝图的一个父类。你需要为你的蓝图指定一个父类，因为它将继承该父类的所有属性。
- en: 'Even though you can choose all existing classes (even other Blueprint classes),
    let''s take a look at the most common parent classes:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以选择所有现有的类（甚至其他蓝图类），但让我们看看最常见的父类：
- en: '**Actor**: An Actor-based Blueprint can be placed or spawned in the level'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**演员**: 基于演员的蓝图可以放置或生成在关卡中'
- en: '**Pawn**: **Pawn** is what you can call an agent which you can possess and
    receives inputs from the controller'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NPC**：**NPC**是你可以称为的代理，你可以控制它并从控制器接收输入'
- en: '**Character**: This is an extended version of **Pawn** with the ability to
    walk, run, jump, crouch, and more'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色**：这是**NPC**的扩展版本，具有行走、奔跑、跳跃、蹲下等功能'
- en: '**Player Controller**: This is used to control the **Character** or **Pawn**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家控制器**：用于控制**角色**或**NPC**'
- en: '**Game Mode**: This defines the game being played'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏模式**：这定义了正在玩的游戏'
- en: '**Actor Component**: This is a reusable component that can be added to any
    actor'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**演员组件**：这是一个可重用的组件，可以添加到任何演员上'
- en: '**Scene Component**: This is a component with scene transform and can be attached
    to other scene components'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景组件**：这是一个具有场景变换的组件，可以附加到其他场景组件上'
- en: In this example, we will use the **Actor** class as our parent because we want
    to place it in the level and spawn at runtime. So choose **Actor** class and Unreal
    will create and place your new Blueprint in **Content Browser**. Double-click
    on your newly created Blueprint and this will open the Blueprint editor. By default,
    it should open the **Viewport** tab but if it doesn't then simply select the **Viewport**
    tab. This is where you can see and manipulate all of your components.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用**演员**类作为我们的父类，因为我们想将其放置在级别中并在运行时生成。因此，选择**演员**类，Unreal 将创建并放置你的新蓝图在**内容浏览器**中。双击你新创建的蓝图，这将打开蓝图编辑器。默认情况下，它应该打开**视口**选项卡，但如果它没有，那么只需简单地选择**视口**选项卡。这就是你可以看到并操作所有组件的地方。
- en: Now we need a component that will spin when this Blueprint is spawned. On the
    **Components** tab, click **Add Component** and select **Static Mesh** component.
    After you add the component, rename it to **Mesh Component** (you can choose whatever
    name you want but, for this example, let's choose that name) and note how the
    **Details** panel has been populated with **Static Mesh** properties.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个组件，当这个蓝图生成时它会旋转。在**组件**选项卡中，点击**添加组件**并选择**静态网格**组件。添加组件后，将其重命名为**网格组件**（你可以选择任何你想要的名称，但在这个例子中，让我们选择这个名称）并注意**详细信息**面板已经填充了**静态网格**属性。
- en: In the **Details** panel, you can find the section that corresponds to your
    component type where you can assign the asset to use.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，你可以找到对应于你的组件类型的部分，在那里你可以分配要使用的资产。
- en: But, in this example, instead of directly assigning a mesh in the **Components**
    tab, we create a **Static Mesh** variable and use that to assign the mesh in the
    graph. This way, we can change the mesh without opening the Blueprint editor.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在这个例子中，我们不是直接在**组件**选项卡中分配网格，而是创建一个**静态网格**变量，并使用它来在图中分配网格。这样，我们可以更改网格而不必打开蓝图编辑器。
- en: In the **My Blueprints** tab, create a new variable and set the type to **Static
    Mesh** (make sure to select **reference**).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在**我的蓝图**选项卡中，创建一个新变量并将类型设置为**静态网格**（确保选择**引用**）。
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In versions before Unreal Engine 4.9, you can search for **Static Mesh** and
    simply select the reference. There was no additional options to select before
    4.9.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unreal Engine 4.9 之前的版本中，你可以搜索**静态网格**并简单地选择引用。在 4.9 之前没有其他选项可以选择。
- en: 'After that, rename that variable to **My Mesh**. Since this variable is used
    to assign the asset to use with our **Static Mesh** component, let''s expose this
    variable so that we can change it in the **Details** panel after placing it in
    world. To expose this variable, select it and enable **Editable** in the **Details**
    panel inside the Blueprint editor. After making it editable, compile the Blueprint
    (shortcut key: *F7*) and you will be able to assign a default mesh for the **My
    Mesh** variable. For this example, let''s add a simple cube **Static Mesh**.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将那个变量重命名为**我的网格**。由于这个变量用于将资产分配给我们的**静态网格**组件，让我们将其公开，以便在将其放置在世界上之后在**详细信息**面板中更改它。要公开这个变量，请选择它并在蓝图编辑器内部的**详细信息**面板中启用**可编辑**。在使其可编辑后，编译蓝图（快捷键：*F7*），你将能够为**我的网格**变量分配一个默认网格。对于这个例子，让我们添加一个简单的立方体**静态网格**。
- en: 'Now that our variable is set, we can assign it to our **Static Mesh** component.
    Since we know that **Construction Graph** is executed every time this Blueprint
    is initialized and whenever a variable or property is changed, that is where we
    are going to assign the mesh for our **Static Mesh** component. So, open the **Construction
    Graph** and:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了变量，我们可以将其分配给我们的**静态网格**组件。由于我们知道**构造图**在每次初始化此蓝图以及每次更改变量或属性时都会执行，因此我们将在这里为我们的**静态网格**组件分配网格。因此，打开**构造图**并：
- en: Right-click on the graph editor and search for the **Get Mesh** component.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图表编辑器上右键单击并搜索**获取网格**组件。
- en: Select **Get Mesh** component from the context menu.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从上下文菜单中选择**获取网格**组件。
- en: Click and drag from the output pin and release it. You will now see a new context
    menu and, in that resulting menu, search for **Set Static Mesh** and select it.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从输出引脚点击并拖动，然后释放。你现在将看到一个新上下文菜单，并在该菜单中搜索**设置静态网格**并选择它。
- en: Right-click again on graph editor and search for **Get My Mesh**.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次在图表编辑器上右键单击并搜索**获取我的网格**。
- en: Select **Get My Mesh** and connect the output pin to the input (**New Mesh**)
    of the **Set Static Mesh** Blueprint node.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择**获取我的网格**并将输出引脚连接到**设置静态网格**蓝图节点的输入（**新网格**）。
- en: 'And, finally, connect the execution pin of **Construction Script** to **Set
    Static Mesh Blueprint** node and press **Compile** (shortcut key: *F7*).'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，将**构造脚本**的执行引脚连接到**设置静态网格蓝图**节点，并按**编译**（快捷键：*F7*）。
- en: If you check the **Viewport** tab after compiling, you will see your new mesh
    there. From this point, feel free to drag this Blueprint to the world and in the
    **Details** panel you can change **My Mesh** to any other **Static Mesh**.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编译后检查**视口**选项卡，你将看到你的新网格在那里。从这一点开始，你可以随意将这个蓝图拖到世界中，在**细节**面板中，你可以将**我的网格**更改为任何其他**静态网格**。
- en: Tip
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Press *Ctrl*+*E* to open the associated editor of the object you have selected
    in world.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Ctrl*+*E*打开您在世界中选择的对象的关联编辑器。
- en: Spinning static mesh
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转静态网格
- en: In Blueprint editor, there are a couple of ways to rotate a mesh and in this
    section we will look into the simplest way, which is using a **Rotate Movement**
    component.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图编辑器中，有几种旋转网格的方法，在本节中我们将探讨最简单的方法，即使用**旋转运动**组件。
- en: 'Open the Blueprint if you have closed it and add a new component called **Rotating
    Movement**. This component will make this Actor continuously rotate at a given
    rotation rate optionally around a specified point. This component has three main
    parameters that can be changed in the Blueprint graph. They are:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已关闭蓝图，请将其打开并添加一个名为**旋转运动**的新组件。此组件将使该演员在给定的旋转速率下持续旋转，可选地围绕指定点旋转。此组件有三个主要参数可以在蓝图图中更改。它们是：
- en: '**Rotation Rate**: The speed at which this will update the **Roll**/**Pitch**/**Yaw**
    axis.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转速率**：此更新**翻滚**/**俯仰**/**偏航**轴的速度。'
- en: '**Pivot Translation**: The pivot point at which we rotate. If set to zero then
    we rotate around the object''s origin.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**枢轴平移**：我们旋转的枢轴点。如果设置为零，则围绕对象的起点旋转。'
- en: '**Rotation in Local Space**: Whether rotation is applied in local space or
    world space.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部空间中的旋转**：旋转是应用于局部空间还是世界空间。'
- en: 'You can create two new variables (**Rotator** and **Vector** variables) and
    make them editable so you can change it in the **Details** panel in world. The
    final graph should look like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建两个新的变量（**旋转器**和**向量**变量）并将它们设置为可编辑的，这样您就可以在世界的**细节**面板中更改它们。最终的图表应如下所示：
- en: '![Spinning static mesh](img/B03950_06_35.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![旋转静态网格](img/B03950_06_35.jpg)'
- en: Destroying our Blueprint Actor after some seconds
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在几秒钟后销毁我们的蓝图演员
- en: 'Once we place or spawn this Actor in world we will destroy this actor with
    a particle effect and sound. To do that:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将此演员放置或生成到世界中，我们将使用粒子效果和声音销毁此演员。为此：
- en: Create a new variable (`float`) and name it **DestroyAfter**. Let's give it
    a default value of five seconds.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的变量（`float`）并将其命名为**销毁后**。让我们给它一个默认值五秒。
- en: Go to **Event Graph** and add a new event called **Event BeginPlay**. This node
    is immediately executed when the game starts or when the actor is spawned in the
    game.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前往**事件图**并添加一个名为**事件开始播放**的新事件。当游戏开始或演员在游戏中生成时，此节点立即执行。
- en: Right-click on the graph editor and search for **Delay** and add it. Connect
    **Event BeginPlay** to the **Delay** node. This node is used to call an action
    after a number of specified seconds.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图表编辑器上右键单击并搜索**延迟**并添加它。将**事件开始播放**连接到**延迟**节点。此节点用于在指定秒数后调用动作。
- en: The **Delay** node takes a `float` value, which is used for the duration. After
    the duration runs out, execution is continued to the next action. We will connect
    our **DestroyAfter** variable to the duration of **Delay**.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**节点接受一个`float`值，用于持续时间。持续时间结束后，执行继续到下一个动作。我们将我们的**销毁后**变量连接到**延迟**的持续时间。'
- en: Right-click on the graph and search for **Spawn Emitter At Location**. This
    node will spawn the given particle effect at the specified location and rotation.
    Connect **Delay** to this node and set a particle effect by assigning it in the
    **Emitter Template**. To set the location, right-click on the graph and search
    for **GetActorLocation** and connect it to **Location pin**.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键单击图并搜索**在位置生成发射器**。此节点将在指定的位置和旋转处生成给定的粒子效果。将**Delay**连接到该节点，并在**发射器模板**中设置一个粒子效果。要设置位置，右键单击图并搜索**GetActorLocation**并将其连接到**位置引脚**。
- en: Right-click on the graph and search for **Spawn Sound At Location**. This node
    will spawn and play a sound at the given location. Connect **Spawn Emitter** node
    to this one.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键单击图并搜索**在位置生成声音**。此节点将在给定位置生成并播放声音。将**Spawn Emitter**节点连接到该节点。
- en: And, finally, to destroy this actor, right-click on the graph editor and search
    for **DestroyActor** and connect it to **Spawn Sound** node.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，为了销毁此演员，右键单击图编辑器并搜索**DestroyActor**并将其连接到**Spawn Sound**节点。
- en: 'The final graph should look like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的图应该看起来像这样：
- en: '![Destroying our Blueprint Actor after some seconds](img/B03950_06_36.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![几秒后销毁我们的蓝图演员](img/B03950_06_36.jpg)'
- en: Now, when you place this actor in world and start the game you will see it spin
    and, after five seconds (or the value you used in **Destroy After**), this actor
    will be destroyed after spawning the particle effect and sound.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你将这个演员放置在世界上并开始游戏时，你会看到它旋转，并在五秒钟（或你在**销毁后**使用的值）后，在生成粒子效果和声音后，这个演员将被销毁。
- en: Spawning our Blueprint class in Level Blueprint
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在级别蓝图中生成了我们的蓝图类
- en: We will now see how we can spawn this Blueprint Actor in world while the game
    is running, instead of directly placing when editing.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到如何在游戏运行时在世界上生成这个蓝图演员，而不是在编辑时直接放置。
- en: Before we continue we will make a change to the **DestroyAfter** variable in
    our spinning Blueprint Actor. Open our spinning actor's Blueprint editor and,
    in **Variables**, select the **DestroyAfter** variable and, in the **Details**
    panel, enable the **Expose On Spawn** setting.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们将修改旋转蓝图演员中的**DestroyAfter**变量。打开旋转演员的蓝图编辑器，在**变量**中，选择**DestroyAfter**变量，并在**详细信息**面板中启用**在生成时暴露**设置。
- en: '![Spawning our Blueprint class in Level Blueprint](img/B03950_06_37.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![在级别蓝图中生成了我们的蓝图类](img/B03950_06_37.jpg)'
- en: This setting means this variable will be exposed in the **Spawn Actor** node.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置意味着此变量将在**Spawn Actor**节点中暴露。
- en: 'Open your level and, on the toolbar, click the Blueprints button and select
    **Open Level** Blueprint. In **Level Blueprint** perform the following steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的级别，在工具栏上，点击蓝图按钮并选择**打开级别**蓝图。在**级别蓝图**中执行以下步骤：
- en: Right-click on the graph and search for **Event BeginPlay** and add it.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键单击图并搜索**Event BeginPlay**并添加它。
- en: Right-click on the graph and search for **Spawn Actor** from **Class** and add
    it. This node will spawn the given actor class at the specified location, rotation
    and scale.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键单击图并从**类**搜索**Spawn Actor**并添加它。此节点将在指定的位置、旋转和缩放处生成给定的演员类。
- en: In the class pin set the class to our **Rotating Blueprint** Actor. Note how
    the **Destroy After** variable is now exposed to **Spawn** node. You can now adjust
    that value from that **Spawn** node.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类引脚设置中将类设置为我们的**旋转蓝图**演员。注意现在**销毁后**变量已经暴露给了**Spawn**节点。你现在可以从那个**Spawn**节点调整那个值。
- en: Drag from the **Spawn Transform** node and release the left mouse button. From
    the resulting context menu, select **Make Transform**. The transform node contains
    3D transformation including translation, rotation, and scale. For this example,
    let's set the **Location** to **0,0,300** so that is this Actor will be spawned
    300 units above the ground.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**Spawn Transform**节点拖动并释放左鼠标按钮。从结果上下文菜单中选择**制作变换**。变换节点包含3D变换，包括平移、旋转和缩放。对于此示例，让我们将**位置**设置为**0,0,300**，这样这个演员将在地面上方生成300个单位。
- en: 'The resulting graph should look like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图应该看起来像这样：
- en: '![Spawning our Blueprint class in Level Blueprint](img/B03950_06_38.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![在级别蓝图中生成了我们的蓝图类](img/B03950_06_38.jpg)'
- en: If you play (*Alt*+*P*) or simulate (*Alt*+*S*) you will see this rotating Actor
    spawn **300** units above the ground and spinning.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你播放（*Alt*+*P*）或模拟（*Alt*+*S*），你会看到这个旋转的演员在地面上方生成**300**个单位并旋转。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have learned what components are and how we can use them
    to define a Blueprint Actor. We also learned about Blueprint nodes and how you
    can create them. From what you have learned in this chapter, you can take it even
    further by:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了组件是什么以及我们如何使用它们来定义蓝图演员。我们还了解了蓝图节点以及如何创建它们。从本章所学的内容中，你可以通过以下方式更进一步：
- en: Spawning this actor when overlapping a trigger volume placed in the level
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在关卡中重叠放置的触发体积中生成此演员时
- en: Playing a particle and sound effect when spawning this Blueprint
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生成此蓝图时播放粒子效果和声音效果
- en: Applying damage to a player if the player is in a certain radius
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家位于某个半径内，对玩家造成伤害
- en: In the next chapter, we will use Matinee to create a cut scene.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用Matinee创建一个剪辑场景。
