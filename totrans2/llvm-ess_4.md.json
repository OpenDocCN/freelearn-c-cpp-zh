["```cpp\n$ opt -Ox -S input.ll\n\n```", "```cpp\ndefine internal i32 @test(i32* %X, i32* %Y)\n{  \n    %A = load i32, i32* %X\n    %B = load i32, i32* %Y\n    %C = add i32 %A, %B\n    ret i32 %C\n}\ndefine internal i32 @caller(i32* %B)\n{\n    %A = alloca i32\n    store i32 1, i32* %A\n    %C = call i32 @test(i32* %A, i32* %B)\n    ret i32 %C\n}\ndefine i32 @callercaller()\n{\n    %B = alloca i32\n    store i32 2, i32* %B\n    %X = call i32 @caller(i32* %B)\n    ret i32 %X\n}\n```", "```cpp\n$ opt -O1 -S test.ll > 1.ll\n$ opt -O2 -S test.ll > 2.ll\n\n```", "```cpp\nLEVEL = ../../..\n\nLIBRARYNAME = FnNamePrint\n\nLOADABLE_MODULE = 1\n\ninclude $(LEVEL)/Makefile.common\n```", "```cpp\n#include \"llvm/Pass.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nusing namespace llvm;\n\nnamespace {\n  struct FnNamePrint: public FunctionPass {\n    static char ID;\n    FnNamePrint () : FunctionPass(ID) {}\n    bool runOnFunction(Function &F) override {\n      errs() << \"Function \" << F.getName() << '\\n';\n      return false;\n    }\n  };\n}\n\nchar FnNamePrint::ID = 0;static RegisterPass< FnNamePrint > X(\"funcnameprint\",\"Function Name Print\", false, false);\n```", "```cpp\n#include \"llvm/Pass.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nusing namespace llvm;\n```", "```cpp\nstruct FnNamePrint: public FunctionPass {\n  static char ID;\n  FnNamePrint () : FunctionPass(ID) {}\n  bool runOnFunction(Function &F) override {\n    errs() << \"Function \" << F.getName() << '\\n';\n    return false;\n    }\n  };\n}\n```", "```cpp\nchar FnNamePrint::ID = 0;\n```", "```cpp\nstatic RegisterPass< FnNamePrint > X(\"funcnameprint\",\"Function Name Print\", false, false);\n```", "```cpp\n$ opt -load path-to-llvm/build/lib/FnNamePrint.so -funcnameprint test.ll\n\n```", "```cpp\nFunction test\nFunction caller\nFunction callercaller\n\n```", "```cpp\n$ opt -O2 -S test.ll -debug-pass=Structure\n$ opt -load /build-folder/lib/LLVMFnNamePrint.so test.ll -funcnameprint -debug-pass=Structure\n\nPass Arguments:  -targetlibinfo -tti -funcnameprint -verify\nTarget Library Information\nTarget Transform Information\n ModulePass Manager\n FunctionPass Manager\n Function Name Print\n Module Verifier\nFunction test\nFunction caller\nFunction callercaller\n\n```", "```cpp\nvirtual void getAnalysisUsage(AnalysisUsage &Info) const;\n```", "```cpp\nvoid getAnalysisUsage(AnalysisUsage &AU) const override {\nAU.addRequired<AliasAnalysis>();\n…\n…\n}\n```", "```cpp\nvoid DependenceAnalysis::getAnalysisUsage(AnalysisUsage &AU) const {\n  …\n  AU.addRequiredTransitive<AliasAnalysis>();\n  AU.addRequiredTransitive<ScalarEvolution>();\n  AU.addRequiredTransitive<LoopInfo>();\n}\n```", "```cpp\nvoid getAnalysisUsage(AnalysisUsage &AU) const override {\n      ……\n      AU.addPreserved<AliasAnalysis>();\n      …..\n    }\n```", "```cpp\nsub i32 2, 1 -> 1\n```", "```cpp\nor i32 %x, 0 -> %x\n```", "```cpp\nand i32 %x %x -> %x\n\n```", "```cpp\n    static Value *SimplifyBinOp(unsigned Opcode, Value *LHS, \n    Value *RHS, const Query &Q, unsigned MaxRecurse)\n    ```", "```cpp\nswitch (Opcode) {\n```", "```cpp\n    X + undef -> undef\n    X + 0 -> X\n    X + (Y - X) -> Y or (Y - X) + X -> Y\n    ```", "```cpp\nif (match(Op1, m_Sub(m_Value(Y), m_Specific(Op0))) ||\n      match(Op0, m_Sub(m_Value(Y), m_Specific(Op1))))\n    return Y;\n```", "```cpp\n    X - undef -> undef\n    X - X -> 0\n    X - 0 -> X\n    X - (X - Y) -> Y\n    ```", "```cpp\n    A & ~A  =  ~A & A  =  0\n    ```", "```cpp\nif (match(Op0, m_Not(m_Specific(Op1))) ||\n      match(Op1, m_Not(m_Specific(Op0))))\n    return Constant::getNullValue(Op0->getType());\n```", "```cpp\n%Y = add i32 %X, 1\n%Z = add i32 %Y, 1\ninto:\n%Z = add i32 %X, 2\n```", "```cpp\ndefine i32 @testfunc(i32 %x, i32 %y, i32 %z) {\n%xor1 = xor i32 %y, %z\n%or = or i32 %x, %xor1\n%xor2 = xor i32 %x, %z\n%xor3 = xor i32 %xor2, %y\n%res = xor i32 %or, %xor3\nret i32 %res\n}\n```", "```cpp\nIf (match(Op01, m_Or(m_Xor(m_Value(B), m_Value(C)), m_Value(A)))\n&& match(Op1I, m_Xor( m_Xor(m_Specific(A), m_Specific(C)), m_Specific(B)))) {\n  return BinaryOperator::CreateAnd(A, Builder->CreateXor(B,C));\n}\n```", "```cpp\n$ opt –instcombine –S test.ll\ndefine i32 @testfunc(i32 %x, i32 %y, i32 %z) {\n%1 = xor i32 %y, %z\n%res = and i32 %1, %x\nret i32 %res\n}\n\n```"]