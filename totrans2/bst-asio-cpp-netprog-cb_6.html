<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Other Topics</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using composite buffers for scatter/gather operations</li><li class="listitem" style="list-style-type: disc">Using timers</li><li class="listitem" style="list-style-type: disc">Getting and setting socket options</li><li class="listitem" style="list-style-type: disc">Performing a stream-based I/O</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Introduction</h1></div></div></div><p>This final chapter includes four recipes that stand somewhat apart from those in previous chapters that demonstrate the core Boost.Asio concepts, covering the majority of typical use cases. However, it does not mean that recipes demonstrated in this chapter are less important. On the contrary, they are very important and even critical to specific cases. However, they will be required less often in typical distributed applications.</p><p>Though most applications will not require scatter/gather I/O operations and composite buffers, for some, which keep different parts of messages in separate buffers, such facilities may turn out to be very usable and convenient.</p><p>The Boost.Asio timer is a powerful instrument that allows measuring time intervals. Often, this is used to set deadlines for the operations that may last unpredictably long and to interrupt those operations if they do not complete after running for a certain period of time. For many distributed applications, such an instrument is critical, taking into account the fact that Boost.Asio does not provide a way to specify a timeout for potentially long-running operations. In addition to this, timers provided by Boost.Asio can be used to solve other tasks that are not related to network communication.</p><p>Tools that allow getting and setting socket options are quite important as well. When developing a simple network application, the developer may be fully satisfied with the socket equipped with default values of the options that are automatically set during instantiation of the socket object. However, in more sophisticated cases, it may be absolutely necessary to reconfigure the socket by customizing the values of its options.</p><p>Boost.Asio classes that wrap the socket and provide a stream-like interface to it allow us to create simple and elegant distributed applications. And simplicity is known to be one of the key characteristics of a good software.</p><p>Now, let's move on to a detailed consideration of the mentioned topics.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Using composite buffers for scatter/gather operations</h1></div></div></div><p>The <em>Using fixed-length I/O buffers</em> recipe in <a class="link" href="ch02.html" title="Chapter 2. I/O Operations">Chapter 2</a>, <em>I/O Operations</em>, introduces simple I/O buffers, but only slightly touches upon scatter/gather operations and composite buffers. In this recipe, we are going to consider this topic in more detail.</p><p>A <a id="id331" class="indexterm"/>composite buffer is <a id="id332" class="indexterm"/>basically a complex buffer that consists of two or more simple buffers (contiguous blocks of memory) distributed over the process' address space. Such buffers become especially handy in two situations.</p><p>The first situation is when the application needs a buffer either to store the message before sending it to the remote application or to receive the message sent by the remote application. The problem is that the size of the message is so big that allocating a single contiguous buffer that is sufficient to store it may fail due to the process' address space fragmentation. In this case, allocating multiple smaller buffers, whose sizes when summed would be enough to store the data, and combining them in a single composite buffer is a good solution to the problem.</p><p>Another situation is actually the first one inverted. Due to specificity of the design of the application, the message to be sent to the remote application is broken into several parts and stored in different buffers, or if the message to be received from the remote application needs to be broken into several parts, each of which should be stored in a separate buffer for further processing. In both the cases, combining several buffers into one composite buffer and then using scatter send or gather receive operations would be a good approach to the problem.</p><p>In this recipe, we will see how to create composite buffers and use them in scatter/gather I/O operations.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec109"/>Getting ready…</h2></div></div></div><p>To understand the content presented in this recipe, it is desirable to be familiar with the content of the <em>Using fixed-length I/O buffers</em> recipe in <a class="link" href="ch02.html" title="Chapter 2. I/O Operations">Chapter 2</a>, <em>I/O Operations</em>, that provides a general overview of Boost.Asio's fixed length I/O buffers. Therefore, it is recommended to get acquainted with the <em>Using fixed-length I/O buffers</em> recipe before proceeding with this one.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec110"/>How to do it…</h2></div></div></div><p>Let's consider <a id="id333" class="indexterm"/>two algorithms and corresponding code samples that describe how to create and prepare a composite buffer that is to be used with Boost.Asio I/O operations. The first algorithm deals with the composite buffer intended for use in gather output operations and the second one for scatter input operations.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec53"/>Preparing a composite buffer for gather output operations</h3></div></div></div><p>The following <a id="id334" class="indexterm"/>is the algorithm and corresponding code sample that describe how to prepare the composite buffer that is to be used with the socket's method that performs output operations such as <code class="literal">asio::ip::tcp::socket::send()</code> or a free function such as <code class="literal">asio::write()</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Allocate as many memory buffers as needed to perform the task at hand. Note that this step does not involve any functionality or data types from Boost.Asio.</li><li class="listitem">Fill the buffers with data to be output.</li><li class="listitem">Create an instance of a class that satisfies the <code class="literal">ConstBufferSequence</code> or <code class="literal">MultipleBufferSequence</code> concept's requirements, representing a composite buffer.</li><li class="listitem">Add simple buffers to the composite buffer. Each simple buffer should be represented as an instance of the <code class="literal">asio::const_buffer</code> or <code class="literal">asio::mutable_buffer</code> classes.</li><li class="listitem">The composite buffer is ready to be used with Boost.Asio output functions.</li></ol></div><p>Let's say we want to send a string <code class="literal">Hello my friend!</code> to the remote application, but our message was broken into three parts and each part was stored in a separate buffer. What we can do is represent our three buffers as a composite buffer, and then, use it in the output operation. This is how we will do it in the following code:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;

using namespace boost;

int main()
{
  // Steps 1 and 2. Create and fill simple buffers.
  const char* part1 = "Hello ";
  const char* part2 = "my ";
  const char* part3 = "friend!";

  // Step 3. Create an object representing a composite buffer.
  std::vector&lt;asio::const_buffer&gt; composite_buffer;

  // Step 4. Add simple buffers to the composite buffer.
  composite_buffer.push_back(asio::const_buffer(part1, 6));
  composite_buffer.push_back(asio::const_buffer(part2, 3));
  composite_buffer.push_back(asio::const_buffer(part3, 7));

  // Step 5. Now composite_buffer can be used with Boost.Asio
  // output operations as if it was a simple buffer represented
  // by contiguous block of memory.

  return 0;
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec54"/>Preparing a composite buffer for an input operation</h3></div></div></div><p>The <a id="id335" class="indexterm"/>following is the algorithm and corresponding code sample that describe how to prepare the composite buffer that is to be used with the <code class="literal">socket's</code> method that performs an input operation such as <code class="literal">asio::ip::tcp::socket::receive()</code> or a free function such as <code class="literal">asio::read()</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Allocate as many memory buffers as required to perform the task at hand. The sum of the sizes of the buffers must be equal to or greater than the size of the expected message to be received in these buffers. Note that this step does not involve any functionalities or data types from Boost.Asio.</li><li class="listitem">Create an instance of a class that satisfies the <code class="literal">MutableBufferSequence</code> concept's requirements that represents a composite buffer.</li><li class="listitem">Add simple buffers to the composite buffer. Each simple buffer should be represented as an instance of the <code class="literal">asio::mutable_buffer</code> class.</li><li class="listitem">The composite buffer is ready to be used with Boost.Asio input operations.</li></ol></div><p>Let's imagine a hypothetical situation, where we want to receive 16 bytes long messages from the server. However, we do not have a buffer that can fit the entire message. Instead, we have three buffers: 6, 3, and 7 bytes long. To create a buffer in which we can receive 16 bytes of data, we can join our three small buffers into a composite one. This is how we <a id="id336" class="indexterm"/>do it in the following code:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;

using namespace boost;

int main()
{
  // Step 1. Allocate simple buffers.
  char part1[6];
  char part2[3];
  char part3[7];

  // Step 2. Create an object representing a composite buffer.
  std::vector&lt;asio::mutable_buffer&gt; composite_buffer;

  // Step 3. Add simple buffers to the composite buffer object.
  composite_buffer.push_back(asio::mutable_buffer(part1,
  sizeof(part1)));
  composite_buffer.push_back(asio::mutable_buffer(part2,
  sizeof(part2)));
  composite_buffer.push_back(asio::mutable_buffer(part3,
  sizeof(part3)));

  // Now composite_buffer can be used with Boost.Asio 
  // input operation as if it was a simple buffer 
  // represented by contiguous block of memory.

  return 0;
}</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec111"/>How it works…</h2></div></div></div><p>Let's see how the first sample works. It starts with allocating three read-only buffers that are filled with parts of the message string <code class="literal">Hello my friend!</code>.</p><p>In the next step, an instance of the <code class="literal">std::vector&lt;asio::const_buffer&gt;</code> class is created, which is the embodiment of the composite buffer. The instance is given the corresponding name, <code class="literal">composite_buffer</code>. Because the  <code class="literal">std::vector&lt;asio::const_buffer&gt;</code> class satisfies the requirements of <code class="literal">ConstBufferSequence</code>, its objects can be used as composite buffers and can be passed to Boost.Asio gather output functions and methods as arguments that represent the data source.</p><p>In step 4, each of our three buffers is represented as an instance of the <code class="literal">asio::const_buffer</code> class and added to the composite buffer. Because all Boost.Asio output functions and methods that work with fixed-sized buffers are designed to work with composite buffers as well, our <code class="literal">composite_buffer</code> object can be used with them like a simple buffer.</p><p>The second <a id="id337" class="indexterm"/>sample works quite similar to the first one. The only difference is that because the composite buffer created in this sample is intended to be used as a data destination (rather than a data source as it is in the first sample), the three simple buffers added to it are created as writable ones and are represented as instances of the <code class="literal">asio::mutable_buffer</code> class when added to the composite buffer.</p><p>Another thing to note about the second sample is that because the composite buffer created in this sample is composed of mutable buffers, it can be used in both gather output and scatter input operations. In this particular sample, the initial buffers (<code class="literal">part1</code>, <code class="literal">part2</code>, and <code class="literal">part3</code>) are not filled with any data and they contain garbage; and therefore, using them in output operations is senseless unless they are filled with meaningful data.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec112"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using fixed-length I/O buffers</em> recipe in <a class="link" href="ch02.html" title="Chapter 2. I/O Operations">Chapter 2</a>, <em>I/O Operations</em>, provides more information on fixed size simple buffers</li><li class="listitem" style="list-style-type: disc">The <em>Using extensible stream-oriented I/O buffers</em> recipe in Chapter 2, <em>I/O Operations</em>, demonstrates how to use classes provided by Boost.Asio, representing different types of buffers—extensible buffers</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Using timers</h1></div></div></div><p>Timing is <a id="id338" class="indexterm"/>a <a id="id339" class="indexterm"/>very important aspect of software systems in general and distributed applications in particular. Therefore a hardware timer—a device used to measure time intervals—is essential component of any computer and all modern operating systems provide interface allowing applications to use it.</p><p>There are two typical use cases related to the timer. The first one assumes that the application wants to know the current time and asks the operating system to find it out. The second use case is when the application asks the operating system to notify it (usually, by means of invoking a callback) when a certain amount of time elapses.</p><p>The second use case is particularly important when it comes to developing distributed applications with Boost.Asio because a timer is the only way to implement the timeout mechanism for asynchronous operations.</p><p>The Boost.Asio library includes several classes that implement timers, which we will consider in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec113"/>How to do it…</h2></div></div></div><p>The Boost.Asio library <a id="id340" class="indexterm"/>provides two template classes that implement timers. One of them is <code class="literal">asio::basic_deadline_timer&lt;&gt;</code>, which was the only one available before Boost.Asio 1.49 version was released. In version 1.49, the second timer <code class="literal">asio::basic_waitable_timer&lt;&gt;</code> class template was introduced.</p><p>The <code class="literal">asio::basic_deadline_timer&lt;&gt;</code> class template was designed to be compatible with the Boost.Chrono library and internally relies on the functionality it provides. This template class is somewhat outdated and provides a limited functionality. Therefore, we will not consider it in this recipe.</p><p>On the contrary, a newer <code class="literal">asio::basic_waitable_timer&lt;&gt;</code> class template, which is compatible with the C++11 <code class="literal">chrono</code> library is more flexible and provides more functionalities. Boost.Asio includes three <code class="literal">typedefs</code> for classes that are generically derived from the <code class="literal">asio::basic_waitable_timer&lt;&gt;</code> template class:</p><div><pre class="programlisting">typedef basic_waitable_timer&lt; std::chrono::system_clock &gt;
   system_timer;
typedef basic_waitable_timer&lt; std::chrono::steady_clock &gt; 
   steady_timer;
typedef basic_waitable_timer&lt; std::chrono::high_resolution_clock &gt;
   high_resolution_timer;</pre></div><p>The <code class="literal">asio::system_timer</code> class is based on the <code class="literal">std::chrono::system_clock</code> class, which represents a system-wide real-time clock. This clock (and so is the timer) is influenced by external changes of the current system time. Therefore, the <code class="literal">asio::system_timer</code> class is a good choice when we need to set up a timer that will notify us when a certain absolute time point is reached (for instance, 13h:15m:45s), taking into account the system clock shifts made after the timer was set up. However, this timer is not good at measuring time intervals (for instance, 35 seconds from now) because the system clock shifts may result in the timer expiring sooner or later than the actual interval elapses.</p><p>The <code class="literal">asio::steady_timer</code> class is based on the <code class="literal">std::chrono::steady_clock</code> class, which represents a steady clock that is not influenced by the system clock changes. It means that <code class="literal">asio::steady_timer</code> is a good choice to measure intervals.</p><p>The last timer <code class="literal">asio::high_resolution_timer</code> class is based on the <code class="literal">std::chrono::high_resolution_clock</code> class, which represents a high-resolution system clock. It can be used in cases when high precision in time measurement is required.</p><p>In distributed <a id="id341" class="indexterm"/>applications implemented with the Boost.Asio library, timers are usually used to implement timeout periods for asynchronous operations. Just after the asynchronous operation starts (for example, <code class="literal">asio::async_read()</code>), the application will start a timer set up to expire after a certain period of time, <em>a timeout period</em>. When the timer expires, the application checks whether the asynchronous operation has completed and if it has not, the operation is considered timed out and is canceled.</p><p>Because a steady timer is not influenced by the system clock shifts, it is the best fit to implement the timeout mechanism.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>Note that on some platforms, steady clocks are not available and the corresponding class that represents a <code class="literal">std::chrono::steady_clock</code> exhibits behavior that is identical to that of <code class="literal">std::chrono::stystem_clock</code>, which means that just like the latter, it is influenced by the changes of the system clock. It is advised to refer to the documentation of the platform and corresponding C++ standard library implementation to find out whether the steady clock is actually <em>steady</em>.</p></div></div><p>Let's consider a somewhat unrealistic but representative sample application that demonstrates how to create, start, and cancel Boost.Asio timers. In our sample, we will create and start two steady timers one by one. When the first timer expires, we will cancel the second one, before it has a chance to expire.</p><p>We begin our sample application with including the necessary Boost.Asio headers and the <code class="literal">using</code> directive:</p><div><pre class="programlisting">#include &lt;boost/asio/steady_timer.hpp&gt;
#include &lt;iostream&gt;

using namespace boost;</pre></div><p>Next, we define the only component in our application: the <code class="literal">main()</code> entry point function:</p><div><pre class="programlisting">int main()
{</pre></div><p>Like almost any nontrivial Boost.Asio application, we need an instance of the <code class="literal">asio::io_service</code> class:</p><div><pre class="programlisting">  asio::io_service ios;</pre></div><p>Then, we create and start the first <code class="literal">t1</code> timer, which is set up to expire in 2 seconds:</p><div><pre class="programlisting">  asio::steady_timer t1(ios);
  t1.expires_from_now(std::chrono::seconds(2));</pre></div><p>Then, we create and start the second <code class="literal">t2</code> timer, which is set up to expire in 5 seconds. It should definitely expire later than the first timer:</p><div><pre class="programlisting">  asio::steady_timer t2(ios);
  t2.expires_from_now(std::chrono::seconds(5));</pre></div><p>Now, we <a id="id342" class="indexterm"/>define and set a callback function that is to be called when the first timer expires:</p><div><pre class="programlisting">   t1.async_wait([&amp;t2](boost::system::error_code ec) {
      if (ec == 0) {
         std::cout &lt;&lt; "Timer #2 has expired!" &lt;&lt; std::endl;
      }
      else if (ec == asio::error::operation_aborted) {
         std::cout &lt;&lt; "Timer #2 has been cancelled!" 
                     &lt;&lt; std::endl;
      }
      else {
         std::cout &lt;&lt; "Error occured! Error code = "
            &lt;&lt; ec.value()
            &lt;&lt; ". Message: " &lt;&lt; ec.message() 
                      &lt;&lt; std::endl;
      }

      t2.cancel();
   });</pre></div><p>Then, we define and set another callback function that is to be called when the second timer expires:</p><div><pre class="programlisting">   t2.async_wait([](boost::system::error_code ec) {
      if (ec == 0) {
         std::cout &lt;&lt; "Timer #2 has expired!" &lt;&lt; std::endl;
      }
      else if (ec == asio::error::operation_aborted) {
         std::cout &lt;&lt; "Timer #2 has been cancelled!" 
&lt;&lt; std::endl;
      }
      else {
         std::cout &lt;&lt; "Error occured! Error code = "
            &lt;&lt; ec.value()
            &lt;&lt; ". Message: " &lt;&lt; ec.message() 
&lt;&lt; std::endl;
      }
   });</pre></div><p>In the last step, we call the <code class="literal">run()</code> method on the instance of the <code class="literal">asio::io_service</code> class:</p><div><pre class="programlisting">  ios.run();

  return 0;
}</pre></div><p>Now, our sample application is ready.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec114"/>How it works…</h2></div></div></div><p>Now, let's track<a id="id343" class="indexterm"/> the application's execution path to better understand how it works.</p><p>The <code class="literal">main()</code> function begins with creating an instance of the <code class="literal">asio::io_service</code> class. We need it because just like sockets, acceptors, resolvers, and other components defined by the Boost.Asio library, which use operating system services, timers require an instance of the <code class="literal">asio::io_service</code> class as well.</p><p>In the next step, the first timer named <code class="literal">t1</code> is instantiated and then the <code class="literal">expires_from_now()</code> method is called on it. This method switches the timer to a non-expired state and starts it. It accepts an argument that represents the duration of the time interval, after which the timer should expire. In our sample, we pass an argument that represents the duration of 2 seconds, which means that in 2 seconds, from the moment when the timer starts, it will expire and all those who are waiting for this timer's expiration event will be notified.</p><p>Next, the second timer named <code class="literal">t2</code> is created, which is then started and set up to expire in 5 seconds.</p><p>When both the timers are started, we asynchronously wait for the timers' expiration events. In other words, we register callbacks on each of the two timers, which will be invoked when the corresponding timers expire. To do this, we call the timer's <code class="literal">async_wait()</code> method and pass the pointer to the callback function as an argument. The <code class="literal">async_wait()</code> method expects its argument to be a pointer to the function that has the following signature:</p><div><pre class="programlisting">void callback(
  const boost::system::error_code&amp; ec);</pre></div><p>The callback function accepts a single <code class="literal">ec</code> argument, which designates the wait completion status. In our sample application, we use lambda functions as expiration callbacks for both the timers.</p><p>When both timer expiration callbacks are set, the <code class="literal">run()</code> method is called on the <code class="literal">ios</code> object. The method blocks until both the timers expire. The thread, in the context of which the method <code class="literal">run()</code> is invoked, will be used to invoke the expiration callbacks.</p><p>When the first timer expires, the corresponding callback function is invoked. It checks the wait completion status and outputs corresponding messages to the standard output stream. And then it cancels the second timer by calling the <code class="literal">cancel()</code> method on the <code class="literal">t2</code> object.</p><p>The canceling<a id="id344" class="indexterm"/> of the second timer leads to the expiration callback being called with the status code, notifying that the timer was canceled before expiration. The expiration callback of the second timer checks the expiration status and outputs corresponding messages to the standard output stream and returns.</p><p>When both callbacks are completed, the <code class="literal">run()</code> method returns and the execution of the <code class="literal">main()</code> function runs to the end. This is when the execution of the application is completed.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Getting and setting socket options</h1></div></div></div><p>The <a id="id345" class="indexterm"/>socket's properties and its behavior can be configured by changing the values of its various options. When the socket object is instantiated, its options have default values. In <a id="id346" class="indexterm"/>many cases, the socket configured by default is a perfect fit, whereas in others, it may be needed to fine tune the socket by changing values of its options so that it meets the requirements of the application.</p><p>In this recipe, we will see how to get and set socket options with Boost.Asio.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec115"/>Getting ready…</h2></div></div></div><p>This recipe assumes familiarity with the content provided in <a class="link" href="ch01.html" title="Chapter 1. The Basics">Chapter 1</a>, <em>The Basics</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec116"/>How to do it…</h2></div></div></div><p>Each socket option, whose value can be set or obtained by means of a functionality provided by Boost.Asio, is represented by a separate class. The complete list of classes that represent setting or getting socket options, which are supported by Boost.Asio, can be found on this Boost.Asio documentation page at <a class="ulink" href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/socket_base.html">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/socket_base.html</a>.</p><p>Note that <a id="id347" class="indexterm"/>there are fewer classes that represent socket options listed on this page than the options that can be set or obtained from a native socket (an object of the underlying operating system). This <a id="id348" class="indexterm"/>is because Boost.Asio supports only a limited amount of socket options. To set or obtain values of other socket options, developers may need to extend the Boost.Asio library by adding classes that represent the required options. However, the topic on the extension of the Boost.Asio library is beyond the scope of this book. We will focus on how to work with socket options that are supported by the library out of the box.</p><p>Let's consider a hypothetical situation where we want to make the size of the socket's receive buffer two times bigger than whatever its size is now. To do this, we first need to get the current size of the buffer, then multiply it by two, and finally, set the value obtained after multiplication as the new receive buffer size.</p><p>The following sample demonstrates how to do this in the following code:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;

using namespace boost;

int main()
{
  try {
    asio::io_service ios;

    // Create and open a TCP socket.
    asio::ip::tcp::socket sock(ios, asio::ip::tcp::v4());

    // Create an object representing receive buffer
      // size option.
    asio::socket_base::receive_buffer_size cur_buf_size;

    // Get the currently set value of the option. 
    sock.get_option(cur_buf_size);

    std::cout &lt;&lt; "Current receive buffer size is "
      &lt;&lt; cur_buf_size.value() &lt;&lt; " bytes."
      &lt;&lt; std::endl;

    // Create an object representing receive buffer
      // size option with new value.
    asio::socket_base::receive_buffer_size
      new_buf_size(cur_buf_size.value() * 2);

    // Set new value of the option.
    sock.set_option(new_buf_size);

    std::cout &lt;&lt; "New receive buffer size is "
      &lt;&lt; new_buf_size.value() &lt;&lt; " bytes."
      &lt;&lt; std::endl;
  }
  catch (system::system_error &amp;e) {
    std::cout &lt;&lt; "Error occured! Error code = " &lt;&lt; e.code()
      &lt;&lt; ". Message: " &lt;&lt; e.what();

    return e.code().value();
  }

  return 0;
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec117"/>How it works…</h2></div></div></div><p>Our <a id="id349" class="indexterm"/>sample consists <a id="id350" class="indexterm"/>of a single component: the <code class="literal">main()</code> entry point function. This function begins with creating an instance of the <code class="literal">asio::io_service</code> class. This instance is then used to create an object that represents a TCP socket.</p><p>Note the usage of the socket class constructor, which creates and <em>opens</em> the socket. Before we can get or set options on a particular socket object, the corresponding socket must be opened. This is because before the Boost.Asio socket object is opened, the underlying native <em>socket</em> object of the corresponding operating system is not yet allocated, and there is nothing to set the options on or get them from.</p><p>Next, an instance of the <code class="literal">asio::socket_base::receive_buffer_size</code> class is instantiated. This class represents an option that controls the size of the socket's receive buffer. To obtain the current value of the option, the <code class="literal">get_option()</code> method is called on the socket object and the reference to the option object is passed to it as an argument.</p><p>The <code class="literal">get_option()</code> method deduces the option that is requested by the type of the argument passed to it. Then, it stores the corresponding option's value in the option object and returns. The value of the option can be obtained from the object that represents the corresponding option by invoking the object's <code class="literal">value()</code> method, which returns the value of the option.</p><p>After the current value of receive buffer size option is obtained and output to the standard output stream, in order to set the new value of this option, the <code class="literal">main()</code> function proceeds with creating one more instance of the <code class="literal">asio::socket_base::receive_buffer_size</code> class named <code class="literal">new_buf_size</code>. This instance represents the same option as the first instance, <code class="literal">cur_buf_size</code>, but this one contains the new value. The new option value is passed to the option object as an argument of its constructor.</p><p>After the <a id="id351" class="indexterm"/>option<a id="id352" class="indexterm"/> object that contains the new receive buffer size option value is constructed, the reference to it is passed as an argument to the socket's <code class="literal">set_option()</code> method. Like <code class="literal">get_option()</code>, this method deduces the option to be set by the type of the argument passed to it, and then, sets the corresponding option value, making the new value equal to the one stored in the option object.</p><p>In the last step, the new option's value is output to the standard output stream.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Performing a stream-based I/O</h1></div></div></div><p>The concepts <a id="id353" class="indexterm"/>of a stream and stream-based I/O are powerful in their expressiveness and elegance when used properly. Sometimes, most of the application's source code consists of stream-based I/O operations. The source code readability and maintainability of such an application would be increased if network communication modules were implemented by means of stream-based operations as well.</p><p>Fortunately, Boost.Asio provides tools that allow us to implement inter-process communication in a stream-based fashion. In this recipe, we will see how to use them.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec118"/>How to do it…</h2></div></div></div><p>The Boost.Asio library contains the <code class="literal">asio::ip::tcp::iostream</code> wrapper class that provides an I/O stream-like interface to the TCP socket objects, which allows us to express inter-process communication operations in terms of stream-based operations.</p><p>Let's consider a TCP client application, which takes advantage of a stream-based I/O provided by Boost.Asio. When using this approach, the TCP client application becomes as simple as the following code:</p><div><pre class="programlisting">#include &lt;boost/asio.hpp&gt;
#include &lt;iostream&gt;

using namespace boost;

int main() 
{
  asio::ip::tcp::iostream stream("localhost", "3333");
  if (!stream) {
    std::cout &lt;&lt; "Error occurred! Error code = " 
      &lt;&lt; stream.error().value()
      &lt;&lt; ". Message = " &lt;&lt; stream.error().message()
      &lt;&lt; std::endl;

    return -1;
  }
  
  stream &lt;&lt; "Request.";
  stream.flush();

  std::cout &lt;&lt; "Response: " &lt;&lt; stream.rdbuf();

  return 0;
} </pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec119"/>How it works…</h2></div></div></div><p>The sample<a id="id354" class="indexterm"/> TCP client is quite simple and consists of a single component: the <code class="literal">main()</code> entry point function. The <code class="literal">main()</code> function begins with creating an instance of the <code class="literal">asio::ip::tcp::iostream</code> class, which wraps a TCP socket and provides an I/O stream-like interface to it.</p><p>The <code class="literal">stream</code> object is constructed with a constructor that accepts a server DNS name and a protocol port number and automatically tries to resolve the DNS name and then tries to connect to that server. Note that the port number is represented as a string rather than an integer. This is because both arguments passed to this constructor are directly used to create the resolver query, which requires the port number to be represented as a string (it should be expressed as a service name such as <code class="literal">http</code>, <code class="literal">ftp</code>, and so on or a port number that is represented as a string such as "<code class="literal">80</code>", "<code class="literal">8081</code>", "<code class="literal">3333</code>", and so on).</p><p>Alternatively, we can construct the <code class="literal">stream</code> object using the default constructor, which does not perform the DNS name resolution and connection. Then, when the object is constructed, we can call the <code class="literal">connect()</code> method on it by specifying the DNS name and protocol port number in order to perform the resolution and connect the socket.</p><p>Next, the state of the stream object is tested to find out whether the connection has succeeded. And if the stream object is in a bad or erroneous state, the appropriate message is output to the standard output stream and the application exits. The <code class="literal">error()</code> method of the <code class="literal">asio::ip::tcp::iostream</code> class returns an instance of the <code class="literal">boost::system::error_code</code> class, which provides the information about the last error that occurred in the stream.</p><p>However, if the stream has been successfully connected to the server, the output operation is performed on it, which sends the string <code class="literal">Request</code>, to the server. After this, the <code class="literal">flush()</code> method is called on the stream object to make sure that all the buffered data is pushed to the server.</p><p>In the last step, the <a id="id355" class="indexterm"/>input operation is performed on the stream to read all the data that was received from the server as a response. The received message is output to the standard output stream. After this, the <code class="literal">main()</code> function returns and the application exits.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec120"/>There's more…</h2></div></div></div><p>Not only can we implement the client-side I/O in a stream-oriented fashion using the <code class="literal">asio::ip::tcp::iostream</code> class, we can also perform I/O operations on the server side as well. In addition to this, this class allows us to specify timeouts for operations, which makes a stream-based I/O more advantageous than a normal synchronous I/O. Let's take a look at how this is done.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec55"/>Implementing a server-side I/O</h3></div></div></div><p>The <a id="id356" class="indexterm"/>following code snippet demonstrates how to implement a simple server that performs a stream-based I/O using the <code class="literal">asio::ip::tcp::iostream</code> class:</p><div><pre class="programlisting">  // ... 
  asio::io_service io_service;

  asio::ip::tcp::acceptor acceptor(io_service,
    asio::ip::tcp::endpoint(asio::ip::tcp::v4(), 3333));
   
  asio::ip::tcp::iostream stream;

acceptor.accept(*stream.rdbuf());
std::cout &lt;&lt; "Request: " &lt;&lt; stream.rdbuf();
stream &lt;&lt; "Response.";
// ...</pre></div><p>This code snippet demonstrates a piece of source code of a simple server application. It creates instances of acceptors and the <code class="literal">asio::ip::tcp::iostream</code> classes. And then, the interesting thing happens.</p><p>The <code class="literal">accept()</code> method is invoked on the <code class="literal">acceptor</code> object. As an argument, this method is passed an object, a pointer to which is returned by the <code class="literal">rdbuf()</code> method called on the <code class="literal">stream</code> object. The <code class="literal">rdbuf()</code> method of the <code class="literal">stream</code> object returns a pointer to the stream buffer object. This <a id="id357" class="indexterm"/>stream buffer object is an instance of a class, which is inherited from the <code class="literal">asio::ip::tcp::socket</code> class, which means that the stream buffer used by objects of the <code class="literal">asio::ip::tcp ::iostream</code> class plays two roles: one of a stream buffer and another of a socket. Therefore, this <code class="literal">twofold</code> stream buffer/socket object can be used as a normal active socket to connect and communicate with the client application.</p><p>When the connection request is accepted and the connection is established, further communication with the client is done in a stream-fashioned style just like it is done in the client application, as demonstrated earlier in this recipe.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec56"/>Setting timeout intervals</h3></div></div></div><p>Because I/O operations are <a id="id358" class="indexterm"/>provided by the <code class="literal">asio::ip::tcp::stream</code> class block the thread of execution, and they potentially may run for a substantial amount of time, the class provides a way to set a timeout period that, when it runs out, leads to the interruption of the operation that currently blocks the thread, if any.</p><p>The timeout interval can be set by the <code class="literal">expires_from_now()</code> method of the <code class="literal">asio::ip::tcp::stream</code> class. This method accepts the duration of the timeout interval as an input parameter and starts the internal timer. If at the moment, when the timer expires, an I/O operation is still in progress, that operation is considered timed out and is, therefore, forcefully interrupted.</p></div></div></div></body></html>