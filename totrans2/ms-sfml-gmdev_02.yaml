- en: Chapter 2.  Its Game Time! - Designing the Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered the essential parts of our pre-established
    code base that is going to be used while creating a game. The time has come to
    take what we have learned and build upon it, by focusing on project-specific code
    that will be unique to the game we are making.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing key entity components and systems for minimal gameplay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a couple of states for navigating the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arranging all of our code into a cohesive, working project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a whole game to design, so let us get to it!
  prefs: []
  type: TYPE_NORMAL
- en: Use of copyrighted resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, and for the entire length of this book, we are going to be
    using these resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mage City Arcanos* by *Hyptosis* under the **CC0** license (public domain): [http://opengameart.org/content/mage-city-arcanos](http://opengameart.org/content/mage-city-arcanos)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[LPC] Leaf Recolor* by *William. Thompsonj* under the **CC-BY-SA 3.0** and
    **GPL 3.0** licenses: [http://opengameart.org/content/lpc-leaf-recolor](http://opengameart.org/content/lpc-leaf-recolor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[LPC] Medieval fantasy character sprites* by *Wulax* under **CC-BY-SA 3.0**
    and **GPL 3.0** licenses: [http://opengameart.org/content/lpc-medieval-fantasy-character-sprites](http://opengameart.org/content/lpc-medieval-fantasy-character-sprites)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fantasy UI Elements* by *Ravenmore* at [http://dycha.net/](http://dycha.net/)
    under the **CC-BY 3.0** license: [http://opengameart.org/content/fantasy-ui-elements-by-ravenmore](http://opengameart.org/content/fantasy-ui-elements-by-ravenmore)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vegur font* by *Arro* under the **CC0** license (public domain): [http://www.fontspace.com/arro/vegur](http://www.fontspace.com/arro/vegur)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fantozzi''s Footsteps (Grass/Sand & Stone)* by *Fantozzi* under the **CC0**
    license (public domain): [http://opengameart.org/content/fantozzis-footsteps-grasssand-stone](http://opengameart.org/content/fantozzis-footsteps-grasssand-stone)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Electrix* (NES Version) by *Snabisch* under the **CC-BY 3.0** license: [http://opengameart.org/content/electrix-nes-version](http://opengameart.org/content/electrix-nes-version)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Town Theme RPG* by *cynicmusic* under the **CC-BY 3.0** license: [http://opengameart.org/content/town-theme-rpg](http://opengameart.org/content/town-theme-rpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Information about all of the licenses that apply to these resources can be
    found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://creativecommons.org/publicdomain/zero/1.0/](http://creativecommons.org/publicdomain/zero/1.0/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://creativecommons.org/licenses/by/3.0/](http://creativecommons.org/licenses/by/3.0/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://creativecommons.org/licenses/by-sa/3.0/](http://creativecommons.org/licenses/by-sa/3.0/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.gnu.org/licenses/gpl-3.0.html](http://www.gnu.org/licenses/gpl-3.0.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity placement and rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us start with the basics. Most (if not all) entities in any game we build
    are going to be positioned within the world. Let us ignore the corner cases of
    special types of entities for now. In order to represent the entity position,
    we are going to be creating a position component like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Only two things are worthy of noting here. First, the component type has to
    be set up through the `C_Base` constructor. That can be changed in the future
    if we are going to be re-designing this system, but for now this is the way to
    do it. We must also implement the `ReadIn` method, in order to be able to de-serialize
    component data properly. This means that every time an entity file is being loaded
    and the position data is encountered, it is going to read in the *x* coordinate,
    the *y* coordinate, and the elevation in this exact order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component itself only holds the data that is relevant to its cause. Two
    different data members for entity position are being stored here: the current
    position `m_position`, and the position of the entity one game tick ago, `m_positionOld`.
    That can be useful, should any system need to rely on position changes between
    updates.'
  prefs: []
  type: TYPE_NORMAL
- en: The drawable side of things
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The visual side of things is not that different to represent within the ECS
    paradigm. Because we may be dealing with more than one type of renderable objects,
    it helps out to have an interface that they all have to honor and implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the type and implementation of drawable components, they may rely
    on different ways of representing their position, size, and the particular method
    of being drawn. All three of these aspects need to be defined when a new drawable
    type is created, much like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A sprite-sheet component utilizes one of the classes we have covered back in
    [Chapter 1](ch01.html "Chapter 1. Under the Hood - Setting up the Backend") ,
    *Under the Hood - Setting up the Backend*. De-serialization for this component
    is quite simple. All it requires is the name of the sheet file, which contains
    all size, padding, space, and animation information. Because this class relies
    on the texture manager for loading its assets, a special `Create()` method is
    used in order to set up this relationship post-loading.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the data aspect all taken care of and out of the way, we can now focus
    on actually drawing entities on screen. This is where the very first type of system
    comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The renderer system operates on two different types of component for now: position
    and sprite sheet. Given a wider variety of drawable component types, it would,
    of course, need to include them as well. This is precisely why a bitmask data
    member with the name `m_drawableTypes` is kept around. It keeps track of all possible
    drawable component types, and will be used later to fetch actual component data.
    All of those types should be registered here.'
  prefs: []
  type: TYPE_NORMAL
- en: This system also needs to be notified when an entity changes its direction,
    in order to enforce those changes on a given sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the components a system uses usually need to be updated like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's pretty straightforward. Any and all drawable components need to have their
    positions updated in order for the simulation to be accurate. We use a private
    method to obtain a pointer to whatever drawable type the current entity has, check
    if it's not `nullptr`, and then update its position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Event handling is also utilized in this system in order to achieve a *depth*
    effect by sorting entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All we have to do here is invoke another private method that's going to sort
    all entities this system has along the *y* axis. This only needs to happen if
    an entity is moving, changing elevations, or has just spawned.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as entity messages go, we''re only interested in one single type, as
    should be evident from the constructor of `S_Renderer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Another private method comes to the rescue. It will be covered shortly, but
    the basic gist of it is that sprite sheets need to be informed of any direction
    changes, in order to reflect them visually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the whole point of this system is rendering our entities on screen, let''s
    do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once again, it's fairly simple. The actual rendering is layer-based, so an argument
    is taken in for the specific layer we're currently drawing. The position component
    is obtained first in order to check if the entity's elevation matches the current
    layer being rendered. Because the game entities are always kept sorted, we know
    it's okay to break out of the loop if any given entity's elevation goes beyond
    the layer we're working with.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the drawable component of the entity is obtained, as well as checked
    for being outside the screen area, in order to minimize unnecessary drawing.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we have left now are the private helper methods, starting with `SetSheetDirection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing we haven't seen before. The entity is checked for having a sprite-sheet
    component, which then gets obtained and informed of direction changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This system heavily relies on entities being sorted, based on their *y* coordinate
    and elevation. For that, we use this bit of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Because entity identifiers are stored inside an STL container, `std::sort` comes
    to the rescue. The actual sorting gives priority to elevation; however, if two
    entities share that in common, they're sorted according to the *y* coordinate,
    going from smallest to largest.
  prefs: []
  type: TYPE_NORMAL
- en: 'To wrap this up, here''s a method that''s going to save us some typing, should
    additional drawable component types be added in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All it does is simply iterate through all component types, looking for one that
    matches drawable types registered in the constructor of this system. Once one
    is found, the entity is checked for having that component. If it does, a pointer
    to it gets returned.
  prefs: []
  type: TYPE_NORMAL
- en: Entity kinematics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code we have written so far would only produce a static, unmoving scene.
    Since that isn''t very exciting, let''s work on adding potential for entity movement.
    Since it calls for more data being stored, we need another component type to work
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our movement is going to be modeled by the relationships between velocity, speed,
    and acceleration. For purposes of controlling entities, a maximum velocity value
    is going to be imposed as well, in order to prevent endless acceleration. We also
    store direction with this component in order to reduce certain complexities and
    inter-component relationships; however, it could be its own separate component.
  prefs: []
  type: TYPE_NORMAL
- en: Movement system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To kick this into gear, let us first take a look at what the movement system
    needs in order to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The entity's kinematic state is going to directly control its position, so we
    need both position and movable components here. An entity message type of `Is_Moving`
    is also subscribed to. The way it is named should be a clue that this message
    is going to be used as a request for information, and its sender will be expecting
    an answer. Since this system is responsible for everything related to motion,
    it will be handling requests like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us update the component data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After both components are obtained, they are passed into a private method that
    handles a movement step. We will be covering this later, but it's important to
    note that it takes the position component pointer in as a `const` value, which
    implies that it will be read only. This is why the position of the entity is modified
    separately one line down, by invoking its `MoveBy()` method. It simply advances
    the position by a vector, provided as the sole argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a more complex system task, we obviously have more events to deal with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We will want to stop our entity on a given axis, if it is actually colliding
    with a solid. The collision event emission will be discussed when we are covering
    the collision system, so all we have to remember now is that if an entity is colliding
    on a specific axis, it needs to have its velocity reduced to `0` on that axis.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are also in charge of the entity's direction, movement events are handled
    and used to update it. Direction priority is given to horizontal movement, while
    up and down directions are only set if the velocity on the *x* axis is zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the constructor of this system, we have subscribed to a message that
    requests movement information. Let us take a look at how that can be handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If the entity information was requested about isn't even part of this system,
    the message gets ignored. Otherwise, the movable component is obtained and its
    velocity gets checked for not being an absolute zero. If it is, an entity event
    `Became_Idle` is sent out. This will be useful later, when we're dealing with
    entity animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, all the hard lifting exists inside our helper methods. Let''s start
    with a simple one, used to obtain tile friction for a specific coordinate in space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A `null` pointer to a tile is established first. A `while` loop is then used
    to attempt to obtain an actual tile, starting with the original elevation and
    moving down until it reaches *0*. We finally return either the friction of the
    tile that was found, or the default friction of the map if it wasn''t. It comes
    into play when we''re trying to process the movement step of an entity here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After the friction coefficient is obtained from the current tile an entity is
    standing on, speed loss due to friction is calculated, velocity due to acceleration
    is added, acceleration itself is zeroed out, and friction is applied. In order
    to account for diagonal movement, a velocity magnitude is calculated and checked
    for exceeding the maximum allowed value. If it does, the entity's velocity is
    re-calculated based on the ratios between its current velocity and the total magnitude,
    and adjusted to fit within the provided boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stopping an entity simply comes down to zeroing its velocity out on a provided
    axis, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Updating the entity''s direction is equally as simple, but it can''t go unnoticed
    by other systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After the direction is updated, a new message is constructed and dispatched,
    letting the relevant systems know about the direction changes of an entity. This
    will also prove to be incredibly useful when handling entity animations.
  prefs: []
  type: TYPE_NORMAL
- en: Handling collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make the game we''re making feel like more than just entities moving
    across a static background with no consequences, collisions have to be checked
    for and handled. Within the ECS paradigm, this can be achieved by implementing
    a collidable component. For more flexibility, let''s define multiple points that
    the collision box can be attached to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The **TOP_LEFT** origin simply places the collision rectangle''s top-left corner
    to the position provided. **ABS_CENTRE** moves that rectangle''s centre to the
    position, and the **MIDDLE_BOTTOM** origin places it halfway through the *x* axis
    and all the way down the *y* axis. Consider the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling collisions](img/image_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With this information, let us work on implementing the collidable component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, let us look at the data we are keeping. `sf::FloatRect` represents the
    basic **AABB** bounding box around the entity that will be used as our collider.
    We also want to be able to offset it by some value, which is going to be loaded
    from the entity file. Obviously, the origin point is stored as well, along with
    two flags that indicate whether a collision is happening on each axis.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetPosition()` method incorporates the use of an origin point and adjusts
    the rectangle to be positioned properly, since the native `sf::FloatRect` doesn't
    support origins by itself.
  prefs: []
  type: TYPE_NORMAL
- en: Collision system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to work with and handle collisions, we only need two components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note the `m_gameMap` data member. We're going to need to provide the collision
    system with a pointer to the game map at some point, in order to be able to handle
    map collisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s handle updating our component data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First, the entity's position is checked to see whether it's outside the map's
    boundaries. After it potentially has been adjusted, the `collidable` component
    is updated with the new position information, and its collision flags are reset.
    Both components are then passed into a private method that handles map collisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all of the entities are checked against the map, we must check them for
    collisions against each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So far, we don't really need to handle entity-on-entity collisions in any way,
    but this is an entry point for later features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The out-of-bounds check is fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It simply checks the position for being either in negative coordinates, or outside
    the map's boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing actual map collisions is further broken down into more readable
    bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After a `Collisions` data type is set up, it, along with the position and collidable
    components, is passed to two private methods, which actually perform collision
    checks, and later handle them. The `Collisions` data type is just a container
    for collision information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us focus on actually filling this structure out with useful collision information
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This method uses the entity collision box and the map tile size to establish
    a range of tiles that are intersecting with it. We then use that range to obtain
    tiles one by one, check if they exist and are solid, construct their bounding
    boxes, measure the areas of intersection, and add all of that information to the
    collision container. So far, so good!
  prefs: []
  type: TYPE_NORMAL
- en: 'The grand finale of this system is, of course, handling all of the collision
    information that got collected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The collision container is first checked for being empty. If it isn't, we sort
    the collision information to flow in a descending order, and use the size of the
    intersecting area for the comparison. This ensures that the collision(s) with
    the largest area of intersection come first, and thus gets handled first.
  prefs: []
  type: TYPE_NORMAL
- en: During the processing of this information, we must first check if the entity's
    bounding box is still colliding with the tile. In case of multiple collisions,
    the first collision that got processed may have moved an entity in such a way
    that it no longer collides with anything at all.
  prefs: []
  type: TYPE_NORMAL
- en: The `xDiff` and `yDiff` variables are used to hold the penetration information
    of each axis, and the `resolve` variable will be used to store exact distance
    by which the entity is going to be pushed to resolve the collision. The first
    two variables are then compared, in order to decide which axis to resolve the
    collision on. Our `resolve` variable is used to calculate the exact distance of
    the push based on whether it's a left-to-right or right-to-left collision.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the position is adjusted by the resolve distance on the relevant axis,
    the collidable component's position is updated to match the changes, a colliding
    event is sent out, and the collidable component's `CollideOnX` or `CollideOnY`
    method is invoked to update the collision flags. These events then get handled
    by other systems, such as `S_Movement`, which we have already covered.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we have already laid down the code foundation, it''s now possible to
    focus on controlling the entities on the screen. Whether they''re being controlled
    as player avatars by means of a keyboard, or through some sort of **artificial
    intelligence** (**AI**), they still need to have this basic component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can tell, we have absolutely no data that gets stored here so far. For
    now, it can simply be considered just a specific signature that lets the ECS know
    it can be controlled.
  prefs: []
  type: TYPE_NORMAL
- en: Control system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order for entities to be controlled, they must have three basic component
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Actual control happens through the event system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The movement itself is just a modification of the movable component, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `C_Movable` component type takes care of actually modifying its data. All
    we need to do is pass in a valid direction.
  prefs: []
  type: TYPE_NORMAL
- en: Entity states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having entities that are able to move around now implies they can either be
    standing still or moving. This quickly brings about the issue of entity states.
    Luckily, we have an elegant way of dealing with that, by introducing another component
    type and a system. Let''s start by enumerating all possible entity states, and
    using the enumeration to establish a component type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: That's all we have to keep track of inside the component class. Time to move
    on to the system!
  prefs: []
  type: TYPE_NORMAL
- en: State system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because state is not directly tethered to any other data, we can only require
    one component type to be present in order to work with states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This system also needs to subscribe to two different message types: `Move`
    and `Switch_State`. The action of movement is obviously state-dependent, since,
    for example, an entity shouldn''t be able to move if it is dead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating entities with a state is fairly basic, since we''re about to utilize
    the movement system indirectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'All we care about so far is if the state of the current entity is `Walking`,
    but the entity has gone idle. For that, we can send out the `Is_Moving` message,
    which the `S_Movement` is going to respond to with an event, given that the entity
    has stopped. That event is then handled here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: A private method for changing an entity's state is invoked, setting it to `Idle`.
    Kids' stuff!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us handle the message types this system is subscribed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Since actual entity movement depends on its state, this is the system that decides
    whether there is movement or not. The entity's state is first checked, to make
    sure it can't move if it's dying. An `EntityEvent` structure is then constructed
    and set to match the direction of the `Move` message. After the event is dispatched,
    the entity's state is changed to `Walking`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other systems within the ECS may care about the state of an entity changing.
    For that, we need to handle these changes accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note the last argument of this method. It indicates whether the state change
    should be forced or not. This is done to ensure that certain state changes can
    be defined as non-critical, and should be ignored if an entity is dying.
  prefs: []
  type: TYPE_NORMAL
- en: If the state ends up getting changed, the component data is updated, and a new
    `State_Changed` message is dispatched to inform other systems.
  prefs: []
  type: TYPE_NORMAL
- en: Sheet animation system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the objects sensitive to state changes is the sprite sheet animation
    system. Knowing an entity''s state is of paramount importance, if we desire to
    apply animations that describe its current action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all we need are two component types and a subscription to a
    message type of `State_Changed`. So far, so good!
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating the sprite sheets can get a little involved, so let us delve right
    into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: After the sprite sheet and state components are obtained, the sheet gets updated.
    The name of its current animation is then obtained. Keep in mind that certain
    entity states are dependent on the current animation, and as soon as that animation
    is over, we want to switch back to an idle state. For example, the attack animation
    is first checked for no longer playing. If that's the case, a message is sent
    to the state system, letting it know that this entity's state needs to be switched
    to idle. Additionally, the animation's action range is checked, which is used
    to determine whether, for example, the current frames of the attack animation
    are of the character swinging the sword just right, where we can inflict damage.
  prefs: []
  type: TYPE_NORMAL
- en: The exact same principle applies to the death animation, except the message
    that gets sent out once that is finished is different.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, every single animation has to be checked for frame progression, in
    which case a message gets sent out, notifying systems interested in that type
    that the animation frame has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, sprite sheets need to know if the entity''s state has
    changed. This is where we handle that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This essentially just maps the name of a specific animation to a state. The
    private method used to set that up is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It takes in the entity identifier, the name of the animation, a flag for whether
    the animation should be played automatically, and another flag for whether it
    should loop. The sprite sheet that sits inside the component is then requested
    to play the animation provided.
  prefs: []
  type: TYPE_NORMAL
- en: Entity sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like states, an entity can emit multiple different types of sound. Each
    different type must also have certain parameters associated with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`struct SoundParameters` simply stores the name of the sound, as well as an
    array of integers for the maximum number of sound frames. A sound frame is the
    glue between sounds and sprite sheets, as it defines during which animation frames
    the sound is emitted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having defined the previous data structure allows us to successfully create
    a sound emitter component type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The only data we are storing here is an array of `SoundParameter` objects for
    each type of `EntitySound` enum, and a `SoundID` data member, which is going to
    be used in the sound system, in order to make sure only one entity sound is playing
    at the same time. The large method for de-serialization simply deals with correctly
    loading in the sound frames.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another, much more basic component type we need before we can proceed is a
    sound listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This, much like `C_Controller`, is basically just a flag that lets the sound
    system know that the entity that has it should be treated as the listener. We
    need to be careful with this, since there should only ever be one sound listener
    present at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Sound system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The system in charge of managing entity sounds uses the component signature
    bitmask in a way that allows multiple different compositions to be recognized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We want entities with a position component, as well as an emitter and/or listener
    component. The message of type `Direction_Changed` is also subscribed to, as well
    as `Frame_Change`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating these components looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The entity is checked for being a sound listener. If it is, the SFML's sound
    listener position is set to the position of the entity, with elevation included.
    We utilize a private helper method here, to construct a 3D vector, which will
    be covered shortly.
  prefs: []
  type: TYPE_NORMAL
- en: If the entity has a sound emitter component, and its sound identifier isn't
    equal to `-1`, which would indicate that no sounds are playing, the sound's position
    is attempted to be updated, provided the entity isn't a sound listener. If either
    the position update fails, or the sound is no longer playing, its identifier is
    set back to `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is message handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We should only care about the direction change message if our entity is a sound
    listener, in which case the global sound listener direction is simply updated
    to reflect the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a frame is changed, we make sure the entity is a sound emitter first. If
    it is, its current state is matched to a sound type that would play. The private
    `EmitSound` method is then invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: After all the component and entity checks have passed, the sound emitter is
    checked for not emitting another sound already in case we want to use the existing
    ID. The sound frame is then checked, and the position for the sound is calculated
    based on whether the entity is a listener or not. Finally, based on whether we're
    using the sound ID or not, the sound manager's `Play` method is invoked, and its
    return sound ID is possibly stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude the sound topic within ECS, as well as the entire ECS portion of
    this chapter, let''s look at how we construct a 3D sound position based on the
    entity''s *x* and *y* positions, as well as its elevation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `z` member of `sf::Vector3f` is used to store the *height*, which is simply
    the elevation multiplied by the tile size.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the menu state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With most of the backend already covered, we''re ready to move towards the
    front, and start working on more interactive aspects of the project, such as interfaces.
    Let''s start by creating a main menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: All of these classes have already been covered in [Chapter 1](http://Chapter
    1) , *Under the Hood - Setting up the Backend*, but let us have a quick rundown
    of what this does once more. After we obtain the shared context, a main menu interface
    is loaded and positioned on screen. The `m_eventManager` is then used to bind
    the main menu button clicks to methods of this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'These resources/bindings obviously have to be removed when the state is destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon activation of the main menu state, we are going to want to check if a
    game state has already been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the first button in the menu accurately reflects the existence/lack
    of a game state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here are the callbacks of the main menu buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In case of the play button being clicked, we switch to a game state, whether
    or not it exists yet. The quit button, on the other hand, would reach the window
    class and close it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the game state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it''s getting more interesting. The game state is where all of the fun
    happens, so we need to make sure it''s set up properly. Let us start, as per usual,
    with the creation of the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: First, all of the relevant events we're interested in are bound to methods of
    this class. This includes the escape key, which simply switches back to the menu
    state, and four player movement keys. The view of this state is then set up to
    be zoomed in slightly more, just to be able to see the character better.
  prefs: []
  type: TYPE_NORMAL
- en: The last couple of lines obtain the loading state, and add the game map and
    the tile set to it as loaders right after the map and tile set files to be loaded
    are added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, these callbacks are going to need to be unbound upon the destruction
    of the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that both the game map and the tile set are both purged here as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating the game state only comes down to updating its own camera, alongside
    the game map and the ECS system manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The camera (or the view) of the state is updated like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This can look like a lot, but the basic gist of it is first obtaining the position
    of our player, and then using those coordinates to either centre the view on,
    or position it in such a way that the very edge of the map is at the edge of the
    view. The idea is not moving the state view beyond the borders of the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing is also fairly straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: A loop is started for each layer/elevation the game map supports. The map data
    of that layer is drawn first, and is followed by the system manager drawing entities
    on that layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at the callback method for our player movement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Whenever this is invoked, a new `Move` message is constructed. The direction
    it carries is set, based on the actual event name. After the receiving entity
    (the player) is stored, the message is dispatched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have one callback and the state''s activation method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If the *Esc* key is pressed, we simply switch to the main menu state. If the
    state is then switched back to `Game`, the `Activate` method of it is invoked.
    We use that functionality to re-obtain the player ID, in case it changed.
  prefs: []
  type: TYPE_NORMAL
- en: The main game class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All we have left to do now is to put everything together. We''re going to be
    using a `Game` class for that, so let''s take a look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This class holds all of the classes that we covered, so let us begin setting
    them up in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The initializer list is used to set up whatever dependencies our classes have
    that need to be satisfied inside their constructors. The rest of the constructor
    body is used to invoke three private *setup* methods, as well as to require the
    main font that is to be used throughout the game, and switch to the `Intro` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to need a couple of basic setters and getters from this class
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'With that out of the way, let us actually update all of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: After the relevant managers are updated, the GUI events are polled and passed
    to the event manager to be handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us take a look at what needs to happen during the `Render` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This is fairly basic as well. Since we're going to always want to draw states,
    the state manager's `Draw` call is placed here. On top of that (quite literally),
    we're going to always draw the GUIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A nice little feature to have is a late update that can be used to process
    anything that can''t go into regular updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The state manager's removal requests are processed here, in addition to the
    game clock being restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the three private methods invoked in the constructor that helps us set
    up all the classes can be implemented like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: After the random number generator is seeded, we need to make sure to bind every
    single class to the shared context, in order to be able to access them anywhere
    a service locator pattern is relied upon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another set up function we invoked deals with setting up the entity component
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Here, all of the component types and systems are added and set up for use. The
    collision and movement systems need to have access to the game map, while the
    sound system relies on the audio and sound managers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last bit of setup is related to states and their dependents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The event, GUI, and sound managers all rely on being kept up to date on all
    state changes, so they must be registered as dependents. Also, our three main
    state types that we will be using are registered as well, so that they can be
    created using the factory method inside the state manager.
  prefs: []
  type: TYPE_NORMAL
- en: The final bit of code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lastly, the main entry point of our application is defined inside the main
    function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: After an instance of `Game` is set up, we begin a `while` loop that keeps running
    until the `Window` instance is closed. Inside the loop, we update the game, render
    it, and call the late update method as well, for all of those post-rendering tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that, it's a good time to wrap up. If you have followed through to the
    end, congratulations! You have just built a basic, fully functioning game out
    of nothing but a couple of states, some components, and systems. This chapter,
    much like the one before, is quite condensed, so feel free to look through the
    code and feel comfortable with its structure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to be focusing solely on implementing and using
    particle systems in order to really add some life to the bare-bones game we have
    made. See you there!
  prefs: []
  type: TYPE_NORMAL
