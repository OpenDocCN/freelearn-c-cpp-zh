- en: Chapter 4. Preparing Optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Various levels of optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own LLVM pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your own pass with the opt tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using another pass in a new pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering a pass with pass manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an analysis pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an alias analysis pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using other analysis passes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the source code transformation completes, the output is in the LLVM IR
    form. This IR serves as a common platform for converting into assembly code, depending
    on the backend. However, before converting into an assembly code, the IR can be
    optimized to produce more effective code. The IR is in the SSA form, where every
    new assignment to a variable is a new variable itself—a classic case of an SSA
    representation.
  prefs: []
  type: TYPE_NORMAL
- en: In the LLVM infrastructure, a pass serves the purpose of optimizing LLVM IR.
    A pass runs over the LLVM IR, processes the IR, analyzes it, identifies the optimization
    opportunities, and modifies the IR to produce optimized code. The command-line
    interface **opt** is used to run optimization passes on LLVM IR.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, various optimization techniques will be discussed.
    Also, how to write and register a new optimization pass will be explored.
  prefs: []
  type: TYPE_NORMAL
- en: Various levels of optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various levels of optimization, starting at 0 and going up to 3 (there
    is also `s` for space optimization). The code gets more and more optimized as
    the optimization level increases. Let's try to explore the various optimization
    levels.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Various optimization levels can be understood by running the opt command-line
    interface on LLVM IR. For this, an example C program can first be converted to
    IR using the **Clang** frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open an `example.c` file and write the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now convert this into LLVM IR using the `clang` command, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A new file, `example.ll`, will be generated, containing LLVM IR. This file will
    be used to demonstrate the various optimization levels available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The opt command-line tool can be run on the IR-generated `example.ll` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `–O0` syntax specifies the least optimization level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, you can run other optimization levels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The opt command-line interface takes the `example.ll` file as the input and
    runs the series of passes specified in each optimization level. It can repeat
    some passes in the same optimization level. To see which passes are being used
    in each optimization level, you have to add the `--debug-pass=Structure` command-line
    option with the previous opt commands.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To know more on various other options that can be used with the opt tool, refer
    to [http://llvm.org/docs/CommandGuide/opt.html](http://llvm.org/docs/CommandGuide/opt.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own LLVM pass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All LLVM passes are subclasses of the `pass` class, and they implement functionality
    by overriding the virtual methods inherited from `pass`. LLVM applies a chain
    of analyses and transformations on the target program. A pass is an instance of
    the Pass LLVM class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how to write a pass. Let''s name the pass `function block counter`;
    once done, it will simply display the name of the function and count the basic
    blocks in that function when run. First, a `Makefile` needs to be written for
    the pass. Follow the given steps to write a `Makefile`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a `Makefile` in the `llvm lib/Transform` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specify the path to the LLVM root folder and the library name, and make this
    pass a loadable module by specifying it in `Makefile`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `Makefile` specifies that all the `.cpp` files in the current directory
    are to be compiled and linked together in a shared object.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `.cpp` file called `FuncBlockCount.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this file, include some header files from LLVM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include the `llvm` namespace to enable access to LLVM functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then start with an anonymous namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next declare the pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then declare the pass identifier, which will be used by LLVM to identify the
    pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This step is one of the most important steps in writing a pass—writing a `run`
    function. Since this pass inherits `FunctionPass` and runs on a function, a `runOnFunction`
    is defined to be run on a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function prints the name of the function that is being processed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to initialize the pass ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the pass needs to be registered, with a command-line argument and
    a name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Putting everything together, the entire code looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simple `gmake` command compiles the file, so a new file `FuncBlockCount.so`
    is generated at the LLVM root directory. This shared object file can be dynamically
    loaded to the opt tool to run it on a piece of LLVM IR code. How to load and run
    it will be demonstrated in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To know more on how a pass can be built from scratch, visit [http://llvm.org/docs/WritingAnLLVMPass.html](http://llvm.org/docs/WritingAnLLVMPass.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your own pass with the opt tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pass written in the previous recipe, *Writing your own LLVM pass*, is ready
    to be run on the LLVM IR. This pass needs to be loaded dynamically for the opt
    tool to recognize and execute it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the C test code in the `sample.c` file, which we will convert into an
    `.ll` file in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the C test code into LLVM IR using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate a `sample.ll` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the new pass with the opt tool, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will look something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As seen in the preceding code, the shared object loads dynamically into the
    opt command-line tool and runs the pass. It goes over the function and displays
    its name. It does not modify the IR. Further enhancement in the new pass is demonstrated
    in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To know more about the various types of the Pass class, visit [http://llvm.org/docs/WritingAnLLVMPass.html#pass-classes-and-requirements](http://llvm.org/docs/WritingAnLLVMPass.html#pass-classes-and-requirements)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using another pass in a new pass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pass may require another pass to get some analysis data, heuristics, or any
    such information to decide on a further course of action. The pass may just require
    some analysis such as memory dependencies, or it may require the altered IR as
    well. The new pass that you just saw simply prints the name of the function. Let's
    see how to enhance it to count the basic blocks in a loop, which also demonstrates
    how to use other pass results.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code used in the previous recipe remains the same. Some modifications are
    required, however, to enhance it—as demonstrated in next section—so that it counts
    the number of basic blocks in the IR.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `getAnalysis` function is used to specify which other pass will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the new pass will be counting the number of basic blocks, it requires
    loop information. This is specified using the `getAnalysis` loop function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will call the `LoopInfo` pass to get information on the loop. Iterating
    through this object gives the basic block information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will go over the loop to count the basic blocks inside it. However, it
    counts only the basic blocks in the outermost loop. To get information on the
    innermost loop, recursive calling of the `getSubLoops` function will help. Putting
    the logic in a separate function and calling it recursively makes more sense:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The newly modified pass now needs to run on a sample program. Follow the given
    steps to modify and run the sample program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `sample.c` file and replace its content with the following program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert it into a `.ll` file using Clang:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the new pass on the previous sample program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will look something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The LLVM''s pass manager provides a debug pass option that gives us the chance
    to see which passes interact with our analyses and optimizations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Registering a pass with pass manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, a new pass was a dynamic object that was run independently. The opt
    tool consists of a pipeline of such passes that are registered with the pass manager,
    and a part of LLVM. Let's see how to register our pass with the Pass Manager.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `PassManager` class takes a list of passes, ensures that their prerequisites
    are set up correctly, and then schedules the passes to run efficiently. The Pass
    Manager does two main tasks to try to reduce the execution time of a series of
    passes:'
  prefs: []
  type: TYPE_NORMAL
- en: Shares the analysis results to avoid recomputing analysis results as much as
    possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipelines the execution of passes to the program to get better cache and memory
    usage behavior out of a series of passes by pipelining the passes together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the given steps to register a pass with Pass Manager:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a `DEBUG_TYPE` macro, specifying the debugging name in the `FuncBlockCount.cpp`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `FuncBlockCount` struct, specify the `getAnalysisUsage` syntax as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now initialize the macros for initialization of the new pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `createFuncBlockCount` Pass function in the `LinkAllPasses.h` file,
    located at `include/llvm/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the declaration to the `Scalar.h` file, located at `include/llvm/Transforms`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also modify the constructor of the pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Scalar.cpp file`, located at `lib/Transforms/Scalar/`, add the initialization
    pass entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this initialization declaration to the `InitializePasses.h` file, which
    is located at `include/llvm/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the `FuncBlockCount.cpp` filename to the `CMakeLists.txt` file,
    located at `lib/Transforms/Scalar/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compile the LLVM with the `cmake` command as specified in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. LLVM Design and Use"), *LLVM Design and Use*. The Pass Manager will
    include this pass in the pass pipeline of the opt command-line tool. Also, this
    pass can be run in isolation from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To know more about adding a pass in Pass Manager in simple steps, study the
    LoopInstSimplify pass at [http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/Transforms/Scalar/LoopInstSimplify.cpp](http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/Transforms/Scalar/LoopInstSimplify.cpp)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an analysis pass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The analysis pass provides higher-level information about IR without actually
    changing the IR. The results that the analysis pass provides can be used by another
    analysis pass to compute its result. Also, once an analysis pass calculates the
    result, its result can be used several times by different passes until the IR
    on which this pass was run is changed. In this recipe, we will write an analysis
    pass that counts and outputs the number of opcodes used in a function.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we write the test code on which we will be running our pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Transform this into a `.bc` file, which we will use as the input to the analysis
    pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now create the file containing the pass source code in `llvm_root_dir/lib/Transforms/opcodeCounter`.
    Here, `opcodeCounter` is the directory we have created, and it is where our pass's
    source code will reside.
  prefs: []
  type: TYPE_NORMAL
- en: Make the necessary `Makefile` changes so that this pass can be compiled.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s start writing the source code for our analysis pass:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the necessary header files and use the `llvm` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the structure defining the pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the structure, create the necessary data structures to count the number
    of opcodes and to denote the pass ID of the pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the preceding structure, write the code for the actual implementation
    of the pass, overloading the `runOnFunction` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the code for registering the pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile the pass using the `make` or `cmake` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the pass on the test code using the opt tool to get the information on
    the number of opcodes present in the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This analysis pass works on a function level, running once for each function
    in the program. Hence, we have inherited the `FunctionPass` function when declaring
    the `CountOpcodes : public FunctionPass` struct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `opcodeCounter` function keeps a count of every opcode that has been used
    in the function. In the following for loops, we collect the opcodes from all the
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The first `for` loop iterates over all the basic blocks present in the function,
    and the second for loop iterates over all the instructions present in the basic
    block.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the first `for` loop is the actual code that collects the opcodes
    and their numbers. The code below the `for` loops is meant for printing the results.
    As we have used a map to store the result, we iterate over it to print the pair
    of the opcode name and its number in the function.
  prefs: []
  type: TYPE_NORMAL
- en: We return `false` because we are not modifying anything in the test code. The
    last two lines of the code are meant for registering this pass with the given
    name so that the opt tool can use this pass.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, on execution of the test code, we get the output as different opcodes
    used in the function and their numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an alias analysis pass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alias analysis is a technique by which we get to know whether two pointers point
    to the same location—that is, whether the same location can be accessed in more
    ways than one. By getting the results of this analysis, you can decide about further
    optimizations, such as common subexpression elimination. There are different ways
    and algorithms to perform alias analysis. In this recipe, we will not deal with
    these algorithms, but we will see how LLVM provides the infrastructure to write
    your own alias analysis pass. In this recipe, we will write an alias analysis
    pass to see how to get started with writing such a pass. We will not make use
    of any specific algorithm, but will return the `MustAlias` response in every case
    of the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write the test code that will be the input for alias analysis. Here, we will
    take the `testcode.c` file used in the previous recipe as the test code.
  prefs: []
  type: TYPE_NORMAL
- en: Make the necessary `Makefile` changes, make changes to register the pass by
    adding entries for the pass in `llvm/lib/Analysis/Analysis.cpp llvm/include/llvm/InitializePasses.h`,
    `llvm/include/llvm/LinkAllPasses.h`, `llvm/include/llvm/Analysis/Passes.h` and
    create a file in `llvm_source_dir/lib/Analysis/ named EverythingMustAlias.cpp`
    that will contain the source code for our pass.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the necessary header files and use the `llvm` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a structure for our pass by inheriting the `ImmutablePass` and `AliasAnalysis`
    classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the data structures and constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `getAdjustedAnalysisPointer` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `initializePass` function to initialize the pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `alias` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register the pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile the pass using the `cmake` or `make` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the test code using the `.so` file that is formed after compiling the
    pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AliasAnalysis` class gives the interface that the various alias analysis
    implementations should support. It exports the `AliasResult` and `ModRefResult`
    enums, representing the results of the `alias` and `modref` query respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `alias` method is used to check whether two memory objects are pointing
    to the same location or not. It takes two memory objects as the input and returns
    `MustAlias`, `PartialAlias`, `MayAlias`, or `NoAlias` as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The `getModRefInfo` method returns the information on whether the execution
    of an instruction can read or modify a memory location. The pass in the preceding
    example works by returning the value `MustAlias` for every set of two pointers,
    as we have implemented it that way. Here, we have inherited the `ImmutablePasses`
    class, which suits our pass, as it is a very basic pass. We have inherited the
    `AliasAnalysis` pass, which provides the interface for our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The `getAdjustedAnalysisPointer` function is used when a pass implements an
    analysis interface through multiple inheritance. If needed, it should override
    this to adjust the pointer as required for the specified pass information.
  prefs: []
  type: TYPE_NORMAL
- en: The `initializePass` function is used to initialize the pass that contains the
    `InitializeAliasAnalysis` method, which should contain the actual implementation
    of the alias analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The `getAnalysisUsage` method is used to declare any dependency on other passes
    by explicitly calling the `AliasAnalysis::getAnalysisUsage` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `alias` method is used to determine whether two memory objects alias each
    other or not. It takes two memory objects as the input and returns the `MustAlias`,
    `PartialAlias`, `MayAlias`, or `NoAlias` responses as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The code following the `alias` method is meant for registering the pass. Finally,
    when we use this pass over the test code, we get 10 `MustAlias` responses (`100.0%`)
    as the result, as implemented in our pass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a more detailed insight into LLVM alias analysis, refer to [http://llvm.org/docs/AliasAnalysis.html](http://llvm.org/docs/AliasAnalysis.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using other analysis passes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will take a brief look into the other analysis passes that
    are provided by LLVM and can be used to get analysis information about a basic
    block, function, module, and so on. We will look into passes that have already
    been implemented in LLVM, and how we can use them for our purpose. We will not
    go through all the passes but take a look at only some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write the test code in the `testcode1.c` file, which will be used for analysis
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert the C code to bitcode format, using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the steps given to use other analysis passes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the alias analysis evaluator pass by passing `–aa-eval` as a command-line
    option to the opt tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the dominator tree information using the `–print-dom-info` command-line
    option along with opt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Count the number of queries made by one pass to another using the `–count-aa`
    command-line option along with opt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the alias sets in a program using the `-print-alias-sets` command-line
    option with opt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first case, where we use the `-aa-eval` option, the opt tool runs the
    alias analysis evaluator pass, which outputs the analysis on the screen. It iterates
    through all pairs of pointers in the function and queries whether the two are
    aliases of each other or not.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `-print-dom-info` option, the pass for printing the dominator tree
    is run, through which information about the dominator tree can be obtained.
  prefs: []
  type: TYPE_NORMAL
- en: In the third case, we execute the `opt -count-aa -basicaa –licm` command. The
    `count-aa` command option counts the number of queries made by the `licm` pass
    to the `basicaa` pass. This information is obtained by the count alias analysis
    pass using the opt tool.
  prefs: []
  type: TYPE_NORMAL
- en: To print all the alias sets within a program, we use the `- print-alias-sets`
    command-line option. In this case, it prints the alias sets obtained after analyzing
    with the `basicaa` pass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [http://llvm.org/docs/Passes.html#anal](http://llvm.org/docs/Passes.html#anal)
    to know about more passes not mentioned here.
  prefs: []
  type: TYPE_NORMAL
