<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Building a Real-time Tower Defense Game from Scratch – Part 1</h1></div></div></div><p>Now that you have all the basic tools, it's time for us to build something new. What about a mix of a<a id="id377" class="indexterm"/> <strong>Real Time Strategy</strong> (<strong>RTS</strong>) and a tower defense? And what about making it a multiplayer game? You like these ideas? Great! This is exactly what we will start building.</p><p>As this project is much <a id="id378" class="indexterm"/>more consequent than all the others, it will be split in two parts. The first one will focus on the game mechanism and logic, and the second on the multiplayer layer. So, in this chapter we will do the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create animations</li><li class="listitem" style="list-style-type: disc">Build and use a generic map system with tile model and dynamic loading</li><li class="listitem" style="list-style-type: disc">Build an entity system</li><li class="listitem" style="list-style-type: disc">Make the game's logic</li></ul></div><p>This project will reuse a lot of the components made previously, such as <code class="literal">ActionTarget</code>, <code class="literal">ResourceManager</code>, our GUI, and the game loop. To allow you to reuse these components easily for future projects, they have been gathered into a single framework (<code class="literal">SFML-utils</code>) that has been separated from the code in this book. This framework is available on the<a id="id379" class="indexterm"/> GitHub website at <a class="ulink" href="https://github.com/Krozark/SFML-utils">https://github.com/Krozark/SFML-utils</a>, due to which these components have been moved from the book namespace to <code class="literal">SFML-utils</code>. Moreover, the map and entity systems that will be explained in this chapter are also part of this framework.</p><p>The final result of this chapter will look as follows:</p><div><img src="img/8477OS_07_01.jpg" alt="Building a Real-time Tower Defense Game from Scratch – Part 1"/></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec37"/>The goal of the game</h1></div></div></div><p>First of all, let's explain our goal. As we said previously, we will build a new game that will be a mix of a real-time <a id="id380" class="indexterm"/>strategy game and tower defense.</p><p>The idea is that each team starts with some money/gold and a main building named GQ. When a team loses all its GQ, it loses the game. The money can be spent to build other buildings with different abilities, or to upgrade them. For example, some of the buildings will spawn warriors who will attack the enemies; other buildings will only defend the surrounding area. There is also a restriction concerning the area where new buildings can be made. In fact, you can only place a new building around your team's existing buildings. This keeps you from placing a big tower in the center of the enemy camp at the start of the game. It's also important to notice that once a building is built, you don't control its behavior just as you don't control the different warriors spawn by it.</p><p>Also, each time an enemy is destroyed, some gold is added to your gold stock, allowing you to build more towers, thus increasing your power to defeat your enemies.</p><p>Now that the game has been introduced, let's list our needs:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Resources and event management</strong>: These two features have been created previously, so we will just reuse them.</li><li class="listitem" style="list-style-type: disc"><strong>GUI</strong>: This feature has also been developed already in <a class="link" href="ch05.html" title="Chapter 5. Playing with User Interfaces">Chapter 5</a>, <em>Playing with User Interfaces</em>. We will reuse it as is.</li><li class="listitem" style="list-style-type: disc"><strong>Animation</strong>: In SFML, there is no class to manage animated sprites in SFML, but for our game, we will need this functionality. So we will build it and add it to our framework.</li><li class="listitem" style="list-style-type: disc"><strong>Tile map</strong>: This functionality is very important and has to be as flexible as possible to allow us to reuse it in many other projects.</li><li class="listitem" style="list-style-type: disc"><strong>Entity manager</strong>: If you remember, this was introduced in <a class="link" href="ch03.html" title="Chapter 3. Making an Entire 2D Game">Chapter 3</a>, <em>Making an Entire 2D Game</em>. Now it's time for us to really see it. This system will avoid a complex inheritance tree.</li></ul></div><p>As you can see, this project is a bit more challenging than the previous one due its complexity, but it will also be much more interesting.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec38"/>Building animations</h1></div></div></div><p>In all our previous games, all the different <a id="id381" class="indexterm"/>entities displayed on the screen were static; at least they were not animated. For a more attractive game, the simplest thing to do is add some animations and different<a id="id382" class="indexterm"/> entities on the player. For us, this will be applied on the different buildings and warriors.</p><p>As we use a sprite-based game and not real-time animation based on bone movement, we need some textures with the animations that are already prepared. So, our textures will look as shown in the following figure:</p><div><img src="img/8477OS_07_02.jpg" alt="Building animations"/></div><div><div><h3 class="title"><a id="note14"/>Note</h3><p>Note that the green grid is not a part of the image and is only shown here for information; the background is transparent in reality.</p></div></div><p>This type of texture is called a sprite sheet. In this example, the image can be split in two lines of four columns. Each line represents a direction of movement, namely left and right. Each cell of these lines represents a step of the future animation.</p><p>The aim of the <a id="id383" class="indexterm"/>work for this part is to be able to display a sprite using this sheet as an animation frame.</p><p>We will follow the design of the SFML by building two classes. The first one will store the animations and the second one will be used to display works such as <code class="literal">sf::Texture</code> and <code class="literal">sf::Sprite</code>. These two classes are named as <code class="literal">Animation</code> and <code class="literal">AnimatedSprite</code>.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec70"/>The Animation class</h2></div></div></div><p>The <code class="literal">Animation</code> class only stores<a id="id384" class="indexterm"/> all the required data, for example, the textures and the different frames.</p><p>As this class is a kind <a id="id385" class="indexterm"/>of resource, we will use it through our <code class="literal">ResourceManager</code> class.</p><p>Here is the header of the class:</p><div><pre class="programlisting">class Animation
{
  public:
  Animation(sf::Texture* texture=nullptr);
  ~Animation();

  void setTexture(sf::Texture* texture);
  sf::Texture* getTexture()const;

  Animation&amp; addFrame(const sf::IntRect&amp; rect);
  Animation&amp; addFramesLine(int number_x,int number_y,int line);
  Animation&amp; addFramesColumn(int number_x,int number_y,int column);
  size_t size()const;
  const sf::IntRect&amp; getRect(size_t index)const;

  private:
  friend class AnimatedSprite;
  std::vector&lt;sf::IntRect&gt; _frames;
  sf::Texture* _texture;
};</pre></div><p>As you can see, this class is<a id="id386" class="indexterm"/> nothing but a container for a texture and some rectangles. To simplify the usage of this class, some helper functions have been created, namely <code class="literal">addFramesLines()</code> and <code class="literal">addFramesColumn()</code>. Each of these functions add a complete line or column to the<a id="id387" class="indexterm"/> internal <code class="literal">_frames</code> list. The implementation of this class is also very simple and is as follows:</p><div><pre class="programlisting">Animation::Animation(sf::Texture* texture) : _texture(texture){}

Animation::~Animation(){}

void Animation::setTexture(sf::Texture* texture){ _texture = 
  texture;}

sf::Texture* Animation::getTexture() const {return _texture;}

size_t Animation::size() const {return _frames.size();}

const sf::IntRect&amp; Animation::getRect(size_t index) const {return 
  _frames[index];}

Animation&amp; Animation::addFrame(const sf::IntRect&amp; rect)
{
  _frames.emplace_back(rect);
  return *this;
}

Animation&amp; Animation::addFramesLine(int number_x,int number_y,int 
  line)
{
  const sf::Vector2u size = _texture-&gt;getSize();
  const float delta_x = size.x / float(number_x);
  const float delta_y = size.y / float(number_y);

  for(int i = 0;i&lt;number_x;++i)
      addFrame(sf::IntRect(i*delta_x,line*delta_y,delta_x,delta_y));
  return *this;
}
Animation&amp; Animation::addFramesColumn(int number_x,int 
  number_y,int column)
{
  const sf::Vector2u size = _texture-&gt;getSize();
  const float delta_x = size.x / float(number_x);
  const float delta_y = size.y / float(number_y);
  for(int i = 0;i&lt;number_y;++i)
      addFrame(sf::IntRect(column*delta_x,i*delta_y,delta_x,delta_y));
  return *this;
}</pre></div><p>The three <code class="literal">addFrameXXX()</code> functions allow us to add frames to our animation. The last two ones are some shortcuts to add an entire line or column. The rest of the methods allow us to access to the internal <a id="id388" class="indexterm"/>data.</p><p>Nothing more is<a id="id389" class="indexterm"/> required by our frame container. It's now time to build the <code class="literal">AnimatedSprite</code> class.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec71"/>The AnimatedSprite class</h2></div></div></div><p>The <code class="literal">AnimatedSprite</code> class is<a id="id390" class="indexterm"/> in charge of the animation displayed on the screen. Due to this, it will keep a reference to an <code class="literal">Animation</code> class and will change the sub-rectangle of the texture periodically, just like <code class="literal">sf::Sprite</code>. We will also copy the <code class="literal">sf::Music</code>/<code class="literal">sf::Sound</code> API concerning the play/pause/stop ability. An <code class="literal">AnimatedSprite</code> instance should also be able to display on the screen and be transformable, due to which the class will inherit from <code class="literal">sf::Drawable</code> and <code class="literal">sf::Transformable</code>. We<a id="id391" class="indexterm"/> will also add a callback that will be triggered when the animation is complete. It could be interesting for the future.</p><p>The header looks as follows:</p><div><pre class="programlisting">class AnimatedSprite : public sf::Drawable, public sf::Transformable
{
  public:
  AnimatedSprite(const AnimatedSprite&amp;) = default;
  AnimatedSprite&amp; operator=(const AnimatedSprite&amp;) = default;
  AnimatedSprite(AnimatedSprite&amp;&amp;) = default;
  AnimatedSprite&amp; operator=(AnimatedSprite&amp;&amp;) = default;

  using FuncType = std::function&lt;void()&gt;;
  static FuncType defaultFunc;
  FuncType onFinished;
  enum Status {Stopped,Paused,Playing};

  AnimatedSprite(Animation* animation = nullptr,Status status= Playing,const sf::Time&amp; deltaTime = sf::seconds(0.15),bool loop = true,int repeat=0);

  void setAnimation(Animation* animation);
  Animation* getAnimation()const;

  void setFrameTime(sf::Time deltaTime);
  sf::Time getFrameTime()const;

  void setLoop(bool loop);
  bool getLoop()const;
  void setRepeat(int nb);
  int getRepeat()const;

  void play();
  void pause();
  void stop();
  Status getStatus()const;

  void setFrame(size_t index);
  void setColor(const sf::Color&amp; color);
  void update(const sf::Time&amp; deltaTime);

  private:
  Animation* _animation;
  sf::Time _delta;
  sf::Time _elapsed;
  bool _loop;
  int _repeat;
  Status _status;
  size_t _currentFrame;
  sf::Vertex _vertices[4];

  void setFrame(size_t index,bool resetTime);
  virtual void draw(sf::RenderTarget&amp; target,sf::RenderStates states) const override;
};</pre></div><p>As you can see, this class is bigger than the previous one. Its main functionality is to store an array of four vertices that will represent a frame taken from the associated animation. We also need some <a id="id392" class="indexterm"/>other information, such as the time between two frames, if the animation is a loop. This is why we need so<a id="id393" class="indexterm"/> many little functions. Now, let's see how all these are implemented:</p><div><pre class="programlisting">AnimatedSprite::AnimatedSprite(Animation* animation,Status status,const sf::Time&amp; deltaTime,bool loop,int repeat) : onFinished(defaultFunc),_delta(deltaTime),_loop(loop), _repeat(repeat),_status(status)
{
  setAnimation(animation); 
}</pre></div><p>The constructor only initializes all the different attributes to their correct values:</p><div><pre class="programlisting">void AnimatedSprite::setAnimation(Animation* animation)
{
  if(_animation != animation){
    _animation = animation;
    _elapsed = sf::Time::Zero;
    _currentFrame = 0;
    setFrame(0,true);
  }
}</pre></div><p>This function changes the current texture for a new one only if they are different, and resets the frame to the<a id="id394" class="indexterm"/> first one of the new animation. Note that at least one frame has to be stored in the new<a id="id395" class="indexterm"/> animation received as a parameter.</p><div><pre class="programlisting">Animation* AnimatedSprite::getAnimation()const {return _animation;}

void AnimatedSprite::setFrameTime(sf::Time deltaTime){_delta = deltaTime;}

sf::Time AnimatedSprite::getFrameTime()const {return _delta;}

void AnimatedSprite::setLoop(bool loop){_loop = loop;}

bool AnimatedSprite::getLoop()const {  return _loop;}

void AnimatedSprite::setRepeate(int nb) {_repeat = nb;}

int AnimatedSprite::getRepeate()const{  return _repeat;}

void AnimatedSprite::play() {_status = Playing;}

void AnimatedSprite::pause() {_status = Paused;}

void AnimatedSprite::stop()
{
  _status = Stopped;
  _currentFrame = 0;
  setFrame(0,true);
}

AnimatedSprite::Status AnimatedSprite::getStatus()const {return _status;}</pre></div><p>All these functions are simple getters and setters. They allow us to manage basic elements of the <code class="literal">AnimatedSprite</code> class, as depicted in the previous code snippet.</p><div><pre class="programlisting">void AnimatedSprite::setFrame(size_t index)
{
  assert(_animation);
  _currentFrame = index % _animation-&gt;size();
  setFrame(_currentFrame,true);
}</pre></div><p>This function changes the current frame to a new one taken from the internal <code class="literal">Animation</code> class.</p><div><pre class="programlisting">void AnimatedSprite::setColor(const sf::Color&amp; color)
{
  _vertices[0].color = color;
  _vertices[1].color = color;
  _vertices[2].color = color;
  _vertices[3].color = color;
}</pre></div><p>This function changes the<a id="id396" class="indexterm"/> color mask of the displayed image. To do this, we set the color of each internal vertex to<a id="id397" class="indexterm"/> the new color received as a parameter:</p><div><pre class="programlisting">void AnimatedSprite::update(const sf::Time&amp; deltaTime)
{
  if(_status == Playing and _animation)
  {
    _elapsed += deltaTime;

    if(_elapsed &gt; _delta)
    {//need to change frame
      _elapsed -= _delta;
      if(_currentFrame + 1 &lt; _animation-&gt;size())
          ++_currentFrame;
      else
      {//end of frame list
        _currentFrame = 0;

        if(not _loop)
        {//can we make another loop an the frames?
          --_repeat;
          if(_repeat&lt;=0)
          { //no, so we stop
                _status = Stopped;
                onFinished();
          }
        }
      }
    }
    //update the frame
    setFrame(_currentFrame,false);
  }
}</pre></div><p>This function is the main one. Its job is to change from the current frame to the next one when the time limit is reached. Once we reach the last frame of the animation, you can do the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reset the animation from the first one, depending of the <code class="literal">_loop</code> value</li><li class="listitem" style="list-style-type: disc">Reset the animation from the first one if the <code class="literal">_repeat</code> value authorizes us to do it</li><li class="listitem" style="list-style-type: disc">In all other cases, we trigger the event "on finish" by calling the internal callback</li></ul></div><p>Now, take a look at<a id="id398" class="indexterm"/> the function that updates<a id="id399" class="indexterm"/> the frame's skin:</p><div><pre class="programlisting">void AnimatedSprite::setFrame(size_t index,bool resetTime)
{
  if(_animation)
  {
    sf::IntRect rect = _animation-&gt;getRect(index);
    //update vertice position
    _vertices[0].position = sf::Vector2f(0.f, 0.f);
    _vertices[1].position = sf::Vector2f(0.f, static_cast&lt;float&gt;(rect.height));
    _vertices[2].position = sf::Vector2f(static_cast&lt;float&gt;(rect.width), static_cast&lt;float&gt;(rect.height));
    _vertices[3].position = sf::Vector2f(static_cast&lt;float&gt;(rect.width), 0.f);

    //compute the texture coords
    float left = static_cast&lt;float&gt;(rect.left);
    float right = left + static_cast&lt;float&gt;(rect.width);
    float top = static_cast&lt;float&gt;(rect.top);
    float bottom = top + static_cast&lt;float&gt;(rect.height);

    //set the texture coords
    _vertices[0].texCoords = sf::Vector2f(left, top);
    _vertices[1].texCoords = sf::Vector2f(left, bottom);
    _vertices[2].texCoords = sf::Vector2f(right, bottom);
    _vertices[3].texCoords = sf::Vector2f(right, top);
  }
  if(resetTime)
  _elapsed = sf::Time::Zero;
}</pre></div><p>This function is also an important one. Its aims is to update the attributes of the different vertices to those taken from the internal <code class="literal">Animation</code> class, namely the position and texture coordinates:</p><div><pre class="programlisting">void AnimatedSprite::draw(sf::RenderTarget&amp; target,sf::RenderStates states) const
{
  if (_animation and _animation-&gt;_texture)è
  {
    states.transform *= getTransform();
    states.texture = _animation-&gt;_texture;
    target.draw(_vertices, 4, sf::Quads, states);
  }
}</pre></div><p>The final function <a id="id400" class="indexterm"/>of this class manages the display. Because we inherit from <code class="literal">sf::Transformable</code>, we need to take into account the possible transformation. Then, we set the texture we used and finally draw the internal <a id="id401" class="indexterm"/>vertices array.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec72"/>A usage example</h2></div></div></div><p>Now that we have the requisite<a id="id402" class="indexterm"/> classes to display an animation, let's build a little usage example. </p><p>Now, here's the implementation:</p><div><pre class="programlisting">int main(int argc,char* argv[])
{
  //Creation of the window
  sf::RenderWindow window(sf::VideoMode(600,800),"Example 
    animation");

  //load of the texture image
  ResourceManager&lt;sf::Texture,int&gt; textures;
  textures.load(0,"media/img/eye.png");

  //Creation of the different animations
  Animation walkLeft(&amp;textures.get(0));
  walkLeft.addFramesLine(4,2,0);
  Animation walkRight(&amp;textures.get(0));
  walkRight.addFramesLine(4,2,1);

  //Creation of the animates sprite
  AnimatedSprite sprite(&amp;walkLeft,AnimatedSprite::Playing,sf::seconds(0.1));
  //game loop
  sf::Clock clock;
  while (window.isOpen())
  {
    sf::Time delta = clock.restart();
    sf::Event event;
    while (window.pollEvent(event))
    {
      if (event.type == sf::Event::Closed) //close event
      window.close();
    }
    float speed = 50; // the movement speed of the entity
    if(sf::Keyboard::isKeyPressed(sf::Keyboard::Left)) //move left
    {
      sprite.setAnimation(&amp;walkLeft);
      sprite.play();
      sprite.move(-speed*delta.asSeconds(),0);
    }
    else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Right)) 
      //move right     {
      sprite.setAnimation(&amp;walkRight);
      sprite.play();
      sprite.move(speed*delta.asSeconds(),0);
    }
    window.clear();
    sprite.update(delta); //update the animate sprite for possible 
      frame change
    window.draw(sprite); //display the animation
    window.display();
  }
  return 0;
}</pre></div><p>For a better <a id="id403" class="indexterm"/>understanding of this code snippet, I've written some comments in the code.</p><p>This short program displays an animation on the screen. You can also change its position by moving it using the arrows on your keyboard. The animation will also change depending on the direction <a id="id404" class="indexterm"/>of movement.</p><p>Now that the first point of this chapter has been explained, let's continue to the second one, building a map.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec39"/>Building a generic Tile Map</h1></div></div></div><p>For our project, we need <a id="id405" class="indexterm"/>something that will manage the map. In fact, the map is nothing but a big grid. The cells can be of any shape (square, hexagonal, and so on). The only restriction is that all the cells <a id="id406" class="indexterm"/>of a single map should have the same geometry.</p><p>Moreover, each cell can contain several objects, possibly of different types. For example, a cell can contain some background texture for the ground, a tree, and a bird. Because SFML doesn't use a <code class="literal">z</code> buffer with sprites (also called a depth buffer), we need to simulate it by hand. This is called the Painter's Algorithm. Its principle is very simple; draw everything but by depth order, starting with the most distant. It's how a tradition art painter would paint.</p><p>All this information brings us to the following structure:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">Map</code> class must be of a specific geometry and must contain any number of layers sorted by their <code class="literal">z</code> buffer.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">Layer</code> contains only a specific type. It also has a <code class="literal">z</code> buffer and stores a list of content sorted by their positions.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">CONTENT</code> and <code class="literal">GEOMETRY</code> classes are template parameters but they need to have a specific API.</li></ul></div><p>Here is the flowchart representing the class hierarchy of the previously explained structure:</p><div><img src="img/8477OS_07_04.jpg" alt="Building a generic Tile Map"/></div><p>Following is the explanation of the flowchart:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">CONTENT</code> template class can be any class that inherits from <code class="literal">sf::Drawable</code> and <code class="literal">sf::Transformable</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">GEOMETRY</code> class is a new one that we will learn about shortly. It only defines the geometric shape and some helper functions to manipulate coordinates.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">VLayer</code> class defines a common class for all the different types of layers.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Layer</code> class is just a container of a specific type with a depth variable that defines its draw order for the painter algorithm.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">VMap</code> class defines a common API for the entire Map. It also contains a list of <code class="literal">VLayer</code> that is displayed using the painter algorithm.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Map</code> class inherits from <code class="literal">VMap</code> and is of a specific geometry.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec73"/>The Geometry class as an isometric hexagon</h2></div></div></div><p>For our project, I made the<a id="id407" class="indexterm"/> choice of an isometric view with the tile as a hexagon. An isometric view is really simple to obtain but needs to be understood well. Following are the steps we need to follow:</p><div><ol class="orderedlist arabic"><li class="listitem">First, view your tile from the top view:<div><img src="img/8477OS_07_05.jpg" alt="The Geometry class as an isometric hexagon"/></div></li><li class="listitem">Then, rotate it 45 degrees clockwise:<div><img src="img/8477OS_07_06.jpg" alt="The Geometry class as an isometric hexagon"/></div></li><li class="listitem">Finally, divide its height by 2:<div><img src="img/8477OS_07_07.jpg" alt="The Geometry class as an isometric hexagon"/></div></li><li class="listitem">You now have a nice isometric view. Now, let's take a look at the hexagon:<div><img src="img/8477OS_07_08.jpg" alt="The Geometry class as an isometric hexagon"/></div></li></ol></div><p>As you know, we need to calculate the coordinates of each of the edges using trigonometry, especially the<a id="id408" class="indexterm"/> Pythagoras theorem. This is without taking into account the rotation and the height resize. We need to follow two steps to find the right coordinates:</p><div><ol class="orderedlist arabic"><li class="listitem">Calculate the coordinates from the rotated shape (adding 45 degrees).</li><li class="listitem">Divide the total height value by two. By doing this, you will finally be able to build <code class="literal">sf::Shape</code>:<div><pre class="programlisting">shape.setPointCount(6);
shape.setPoint(0,sf::Vector2f(0,(sin_15+sin_75)/2));
shape.setPoint(1,sf::Vector2f(sin_15,sin_15/2));
shape.setPoint(2,sf::Vector2f(sin_15+sin_75,0));
shape.setPoint(3,sf::Vector2f(sin_15+sin_75+sin_45,sin_45/2));
shape.setPoint(4,sf::Vector2f(sin_75+sin_45,(sin_75+sin_45)/2));
shape.setPoint(5,sf::Vector2f(sin_45,(sin_15+sin_75+sin_45)/2));
shape.setOrigin(height/2,height/4);</pre></div></li><li class="listitem">The major part of the <code class="literal">GEOMETRY</code> class has been made. What remains is only a conversion from world to pixel coordinates, and the reverse. If you are interested in doing this, take a look at the class implementation in the <code class="literal">SFML-utils/src/SFML-utils/map/HexaIso.cpp</code> file.</li></ol></div><p>Now that the main geometry has been defined, let's construct a <code class="literal">Tile&lt;GEOMETRY&gt;</code> class on it. This class will simply encapsulate <code class="literal">sf::Shape</code> , which is initialized by the geometry, and with the different requirements to be able to be use a <code class="literal">COMPONENT</code> parameter for the map. As this class is<a id="id409" class="indexterm"/> not very important, I will not explain it through this book, but you can take a look at its implementation in the <code class="literal">SFML-utils/include/SFML-utils/map/Tile.tpl</code> file.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec74"/>VLayer and Layer classes</h2></div></div></div><p>The aim of a layer is to manage any number of components at the same depth. To do this, each layer contains its <a id="id410" class="indexterm"/>depth and a container of components. It also has the ability to resort the container to respect the painter algorithm. The <code class="literal">VLayer</code> class<a id="id411" class="indexterm"/> is an interface that only defines the API of the layer, allowing the<a id="id412" class="indexterm"/> map to store any<a id="id413" class="indexterm"/> kind of layer, thanks to polymorphism.</p><p>Here is the header of the <code class="literal">Layer</code> class:</p><div><pre class="programlisting">template&lt;typename CONTENT&gt;
class Layer : public VLayer
{
  public:
  Layer(const Layer&amp;) = delete;
  Layer&amp; operator=(const Layer&amp;) = delete;
  Layer(const std::string&amp; type,int z=0,bool isStatic=false);
  virtual ~Layer(){};

  CONTENT* add(const CONTENT&amp; content,bool resort=true);
  std::list&lt;CONTENT*&gt; getByCoords(const sf::Vector2i&amp; coords,const VMap&amp; map);
  bool remove(const CONTENT* content_ptr,bool resort=true);
  virtual void sort() override;

  private:
  virtual void draw(sf::RenderTarget&amp; target, sf::RenderStates states,const sf::FloatRect&amp; viewport) override;
  std::list&lt;CONTENT&gt; _content;
};</pre></div><p>As mentioned previously, this class will not only store a container of its <code class="literal">template</code> class argument, but also its depth (<code class="literal">z</code>) and an is static Boolean member contained in the <code class="literal">Vlayer</code> class to optimize the display. The idea under this argument is that if the content within the layer doesn't move at all, it doesn't need to repaint the scene each time. The result is stored in an internal <code class="literal">sf::RenderTexture</code> parameter and will be refreshed only when the scene moves. For example, the ground never moves nor is it animated. So we can display it on a big texture and display<a id="id414" class="indexterm"/> this texture on the screen. This texture will be refreshed when the view is moved/resized.</p><p>To take this idea further, we <a id="id415" class="indexterm"/>only need to display content that appears on the screen. We don't need do draw something out of the screen. That's why we have the <code class="literal">viewport</code> attribute of the <code class="literal">draw()</code> method.</p><p>All other functions<a id="id416" class="indexterm"/> manage the <a id="id417" class="indexterm"/> content of the layer. Now, take a look at its implementation:</p><div><pre class="programlisting">template&lt;typename CONTENT&gt;
Layer&lt;CONTENT&gt;::Layer(const std::string&amp; type,int z,bool isStatic) 
  : Vlayer(type,z,isStatic) {}

template&lt;typename CONTENT&gt;
CONTENT* Layer&lt;CONTENT&gt;::add(const CONTENT&amp; content,bool resort)
{
  _content.emplace_back(content);
  CONTENT* res = &amp;_content.back();
  if(resort)
      sort();
  return res;
}</pre></div><p>This function adds new content to the layer, sort it if requested, and finally, return a reference to the new object:</p><div><pre class="programlisting">template&lt;typename CONTENT&gt;
std::list&lt;CONTENT*&gt; Layer&lt;CONTENT&gt;::getByCoords(const sf::Vector2i&amp; coords,const VMap&amp; map)
{
  std::list&lt;CONTENT*&gt; res;
  const auto end = _content.end();
  for(auto it = _content.begin();it != end;++it)
  {
    auto pos = it-&gt;getPosition();
    sf::Vector2i c = map.mapPixelToCoords(pos.x,pos.y);
    if(c == coords)
        res.emplace_back(&amp;(*it));
  }
  return res;
}</pre></div><p>This function returns all the different objects to the same place. This is useful to pick up objects, for example, to pick objects under the cursor:</p><div><pre class="programlisting">template&lt;typename CONTENT&gt;
bool Layer&lt;CONTENT&gt;::remove(const CONTENT* content_ptr,bool resort)
{
  auto it = std::find_if(_content.begin(),_content.end(),[content_ptr](const CONTENT&amp; content)-&gt;bool
  {
    return &amp;content == content_ptr;
  });
  if(it != _content.end()) {
    _content.erase(it);
    if(resort)
    sort();
    return true;
  }
  return false;
}</pre></div><p>This is the reverse<a id="id418" class="indexterm"/> function of <code class="literal">add()</code>. Using its<a id="id419" class="indexterm"/> address, it removes a component from the container:</p><div><pre class="programlisting">template&lt;typename CONTENT&gt;
void Layer&lt;CONTENT&gt;::sort()
{
  _content.sort([](const CONTENT&amp; a,const CONTENT&amp; b)-&gt;bool{
    auto pos_a = a.getPosition();
    auto pos_b = b.getPosition();
    return (pos_a.y &lt; pos_b.y) or (pos_a.y == pos_b.y and pos_a.x &lt; pos_b.x);
    });
  }
}</pre></div><p>This function sorts<a id="id420" class="indexterm"/> all the content with respect to the<a id="id421" class="indexterm"/>  painter algorithm order:</p><div><pre class="programlisting">template&lt;typename CONTENT&gt;
void Layer&lt;CONTENT&gt;::draw(sf::RenderTarget&amp; target, sf::RenderStates states,const sf::FloatRect&amp; viewport)
{
  if(_isStatic)
  {//a static layer
    if(_lastViewport != viewport)
    { //the view has change
      sf::Vector2u size(viewport.width+0.5,viewport.height+0.5);
      if(_renderTexture.getSize() != size)
      {//the zoom has change
        _renderTexture.create(size.x,size.y);
        _sprite.setTexture(_renderTexture.getTexture(),true);
      }
      _renderTexture.setView(sf::View(viewport));
      _renderTexture.clear();

      auto end = _content.end();
      for(auto it = _content.begin();it != end;++it)
      {//loop on content
      CONTENT&amp; content = *it;
      auto pos = content.getPosition();
      if(viewport.contains(pos.x,pos.y))
      {//content is visible on screen, so draw it
        _renderTexture.draw(content);
      }
    }
    _renderTexture.display();
    _lastViewport = viewport;
    _sprite.setPosition(viewport.left,viewport.top);
  }
  target.draw(_sprite,states);
}
else
{ //dynamic layer
  auto end = _content.end();
  for(auto it = _content.begin();it != end;++it)
  {//loop on content
    const CONTENT&amp; content = *it;
    auto pos = content.getPosition();
    if(viewport.contains(pos.x,pos.y))
    {//content is visible on screen, so draw it
      target.draw(content,states);
    }
  }
}</pre></div><p>This<a id="id422" class="indexterm"/>  function is<a id="id423" class="indexterm"/> much more<a id="id424" class="indexterm"/> complicated than what we expect because of some optimizations. Let's explain it step by <a id="id425" class="indexterm"/>step:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we separate two cases. In the case of a static map we do as follows:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check if the view port has changed</li><li class="listitem" style="list-style-type: disc">Resize the internal texture if needed</li><li class="listitem" style="list-style-type: disc">Reset the textures</li></ul></div></li><li class="listitem" style="list-style-type: disc">Draw each <a id="id426" class="indexterm"/> object with a position inside the view port into the <code class="literal">textureDisplay</code> the texture for the <code class="literal">RenderTarget</code> argument.</li><li class="listitem" style="list-style-type: disc">Draw each object with a<a id="id427" class="indexterm"/> position inside the view port into the <code class="literal">RenderTarget</code> argument if the layer contains dynamic objects (not static).</li></ul></div><p>As you can see, the <code class="literal">draw()</code> function uses a naive algorithm in the case of dynamic content and optimizes the<a id="id428" class="indexterm"/> statics. To give you an idea of the benefits, with a layer of 10000 objects, the FPS was approximately 20. With position optimization, it reaches 400, and with static optimization, 2,000. So, I think the complexity of this function is justified by the enormous<a id="id429" class="indexterm"/> performance benefits.</p><p>Now that the <code class="literal">layer</code> class has been exposed to you, let's continue with the <code class="literal">map</code> class.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec75"/>VMap and Map classes</h2></div></div></div><p>A map is a container of <code class="literal">VLayer</code>. It will implement the usual <code class="literal">add()</code>/<code class="literal">remove()</code> functions. This class can also be constructed from a file (described in the <em>Dynamic board loading</em> section) and handle unit conversion (coordinate to pixel and vice versa).</p><p>Internally, a <code class="literal">VMap</code> class store<a id="id430" class="indexterm"/> has the following layers:</p><div><pre class="programlisting">std::vector&lt;VLayer*&gt; _layers;</pre></div><p>There are only two<a id="id431" class="indexterm"/> interesting<a id="id432" class="indexterm"/> functions in this class. The others are simply shortcuts, so I will not explain the entire class. Let us see the concerned functions:</p><div><pre class="programlisting">void VMap::sortLayers()
{
  std::sort(_layers.begin(),_layers.end(),[](const VLayer* a, const VLayer* b)-&gt;bool{
    return a-&gt;z() &lt; b-&gt;z();
  });
  const size_t size = _layers.size();
  for(size_t i=0;i&lt;size;++i)
    _layers[i]-&gt;sort();
}</pre></div><p>This function sorts the different layers by their <code class="literal">z</code> buffer with respect to the Painter's Algorithm. In fact, this function is simple but very important. We need to call it each time a layer is added to the map.</p><div><pre class="programlisting">void VMap::draw(sf::RenderTarget&amp; target, sf::RenderStates states,const sf::FloatRect&amp; viewport) const
{
  sf::FloatRect delta_viewport(viewport.left - _tile_size,
  viewport.top - _tile_size,
  viewport.width + _tile_size*2,
  viewport.height + _tile_size*2);
  const size_t size = _layers.size();
  for(size_t i=0;i&lt;size;++i)
    _layers[i]-&gt;draw(target,states,delta_viewport);
}</pre></div><p>The function draws<a id="id433" class="indexterm"/> each layer by calling its draw method; but first, we adjust the screen view port by adding a little<a id="id434" class="indexterm"/> delta on each of its borders. This is done to display all the tiles that appear on the screen, even partially (when its position is out on the screen).</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec76"/>Dynamic board loading</h2></div></div></div><p>Now that the map structure is done, we need a way to load it. For this, I've chosen the <code class="literal">JSON</code> format. There are two<a id="id435" class="indexterm"/> reasons for this choice:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It can be read by humans</li><li class="listitem" style="list-style-type: disc">The format is not verbose, so the final file is quite small even for big map</li></ul></div><p>We will need some information to construct a map. This includes the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The map's geometry</li><li class="listitem" style="list-style-type: disc">The size of each tile (cell)</li><li class="listitem" style="list-style-type: disc">Define the layers as per the following:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">z</code> buffer</li><li class="listitem" style="list-style-type: disc">If it is static or dynamic</li><li class="listitem" style="list-style-type: disc">The content type</li></ul></div></li></ul></div><p>Depending on the content type of the layer, some other information to build this content could be specified. Most often, this extra information could be as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Texture</li><li class="listitem" style="list-style-type: disc">Coordinates</li><li class="listitem" style="list-style-type: disc">Size</li></ul></div><p>So, the <code class="literal">JSON</code> file will look as follows:</p><div><pre class="programlisting">{
  "geometry" : {
    "name" :"HexaIso", "size" : 50.0
  },
  "layers" : [{
    "content" : "tile", "z" : 1, "static" : true,
    "data" : [{"img" :"media/img/ground.png", "x" : 0, "y" : 0, "width" : 100, "height" : 100}]
  },{
    "content" : "sprite", "z" : 3,
    "data" : [
    {"x" : 44, "y" : 49, "img" : "media/img/tree/bush4.png"},
    {"x" : 7, "y" : 91, "img" : "media/img/tree/tree3.png"},
    {"x" : 65, "y" : 58, "img" : "media/img/tree/tree1.png"}
    ]
  }]
}</pre></div><p>As you can see, the different datasets are present to create a map with the isometric hexagon geometry with two layers. The first layer contains the grid with the ground texture and the second one contains some sprite for decoration.</p><p>To use this file, we<a id="id436" class="indexterm"/> need a <code class="literal">JSON</code> parser. You can use any existing one, build yours, or take the one built with this project. Next, we need a way to create an entire map from a file or update its content from a file. In the second case, the geometry will be ignored because we can't change the value of a template at runtime.</p><p>So, we will add a static method to the <code class="literal">VMap</code> class to create a new <code class="literal">Map</code>, and add another method to update its content. The signature will be as follows:</p><div><pre class="programlisting">static VMap* createMapFromFile(const std::string&amp; filename);
virtual void loadFromJson(const utils::json::Object&amp; root) = 0;</pre></div><p>The <code class="literal">loadFromJson()</code> function has to be virtual and implemented in the <code class="literal">Map</code> class because of the <code class="literal">GEOMETRY</code> parameter required by the <code class="literal">Tile</code> class. The <code class="literal">createMapFromFile()</code> function will be used internationally. Let's see its implementation:</p><div><pre class="programlisting">VMap* VMap::createMapFromFile(const std::string&amp; filename)
{
  VMap* res = nullptr;
  utils::json::Value* value = utils::json::Driver::parse_file(filename);
  if(value)
  {
    utils::json::Object&amp; root = *value;
    utils::json::Object&amp; geometry = root["geometry"];
    std::string geometry_name = geometry["name"].as_string();
    float size = geometry["size"].as_float();
    if(geometry_name == "HexaIso")
    {
      res = new Map&lt;geometry::HexaIso&gt;(size);
      res-&gt;loadFromJson(root);
    }
    delete value;
  }
  return res;
}</pre></div><p>The goal of this function is pretty simple; construct the appropriate map depending on the geometry parameter<a id="id437" class="indexterm"/> and forward it the rest of the job.</p><div><pre class="programlisting">void Map&lt;GEOMETRY&gt;::loadFromJson(const utils::json::Object&amp; root)
{
    const utils::json::Array&amp; layers = root["layers"];
    for(const utils::json::Value&amp; value : layers) //loop through the 
rs
    {
        const utils::json::Object&amp; layer = value;
        std::string content = layer["content"].as_string(); //get the content type
                                                                                                      
        int z = 0; //default value
        try{
            z = layer["z"].as_int(); //load value
        } catch(...){}
                                                                                                      
        bool isStatic = false; //default value
        try {
            isStatic = layer["static"].as_bool(); //load value
        }catch(...){}
        
        if(content == "tile") //is a layer or tile?
        {
            auto current_layer = new Layer&lt;Tile&lt;GEOMETRY&gt;&gt;(content,z,isStatic); //create the layer
            const utils::json::Array&amp; textures = layer["data"];
            for(const utils::json::Object&amp; texture : textures) //loop through the textures
            {
                int tex_x = texture["x"]; //get the tile position
                int tex_y = texture["y"];
                int height = std::max&lt;int&gt;(0,texture["height"].as_int()); //get the square size
                int width = std::max&lt;int&gt;(0,texture["width"].as_int());
                std::string img = texture["img"]; //get texture path
                                                                                                      
                sf::Texture&amp; tex = _textures.getOrLoad(img,img); //load the texture
                tex.setRepeated(true);
                                                                                                      
                for(int y=tex_y;y&lt; tex_y + height;++y)//create the tiles
                {
                    for(int x=tex_x;x&lt;tex_x + width;++x)
                    {
                        Tile&lt;GEOMETRY&gt; tile(x,y,_tileSize);
                        tile.setTexture(&amp;tex);
                        tile.setTextureRect(GEOMETRY::getTextureRect(x,y,_tileSize));
                                                                                                      
                        current_layer-&gt;add(std::move(tile),false);//add the new tile to the layer
                    }
                }
            }
            add(current_layer,false);//if it's a layer of images
        }
        else if(content == "sprite")
        {
            auto current_layer = new Layer&lt;sf::Sprite&gt;(content,z,isStatic);//create the layer
            const utils::json::Array&amp; data = layer["data"].as_array();//loop on data
                                                                                                      
            for(const utils::json::Value&amp; value : data)
            {
                const utils::json::Object&amp; obj = value;
                int x = obj["x"];//get the position
                int y = obj["y"];
                float ox = 0.5;//default center value (bottom center)
                float oy = 1;
                                                                                                      
                try{//get value
                    ox = obj["ox"].as_float();
                }catch(...){}
                                                                                                      
                try{
                    oy = obj["oy"].as_float();
                }catch(...){}
                                                                                                      
                std::string img = obj["img"];//get texture path
                                                                                                      
                sf::Sprite spr(_textures.getOrLoad(img,img));//load texture
                spr.setPosition(GEOMETRY::mapCoordsToPixel(x,y,_tileSize));
                                                                                                      
                sf::FloatRect rec = spr.getLocalBounds();
                spr.setOrigin(rec.width*ox,rec.height*oy);
                                                                                                      
                current_layer-&gt;add(std::move(spr),false);//add the sprite
                                                                                                      
            }
            add(current_layer,false); //add the new layer to the map
        }
    }
    sortLayers(); //finally sort the layers (recuively)
}</pre></div><p>For a better understanding, the previous function was explained with raw comments. It's aimed at building layers and filling them with the data picked from the <code class="literal">JSON</code> file.</p><p>Now that we are able to<a id="id438" class="indexterm"/> build a map and fill it from a file, the last thing we need to do is display it on the screen. This will be done with the <code class="literal">MapViewer</code> class.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec77"/>The MapViewer class</h2></div></div></div><p>This class encapsulates a <code class="literal">Map</code> class and manages some events such as mouse movement, moving the view, zoom, and so on. This is a really simple class with nothing new. This is why I will not go into details about<a id="id439" class="indexterm"/> anything but the <code class="literal">draw()</code> method (because of the view port). If you are interested in the full<a id="id440" class="indexterm"/> implementation, take a look at the <code class="literal">SFML-utils/src/SFML-utils/map/MapViewer.cpp</code> file.</p><p>So here is the draw method:</p><div><pre class="programlisting">void MapViewer::draw(sf::RenderTarget&amp; target, sf::RenderStates states) const
{
  sf::View view = target.getView();
  target.setView(_view);
  _map.draw(target,states,sf::FloatRect(target.mapPixelToCoords(sf::Vector2i(0,0),_view),_view.getSize());
  target.setView(view);
}</pre></div><p>As usual, we receive <code class="literal">sf::RenderTarget</code> and <code class="literal">sf::RenderStates</code> as parameters. However, here we don't want to interact with the current view of the target, so we make a backup of it and attach our local view to the rendered target. Then, we call the draw method of the internal map, forwarding the target, and states but adding the view port. This parameter is very important because it's used by our layers for optimization. So, we need to build a view port with the size of the rendered target, and thanks to SFML, it's very simple. We convert the top-left coordinate to the world coordinate, relative to our view. The result is in the top-left coordinate of the displayed area. Now, we only need the size. Here again, SFML provides use all the need: <code class="literal">sf::View::getSize()</code>. With this information, we are now able to build the correct view port and pass it to the map <code class="literal">draw()</code> function.</p><p>Once the rendering is complete, we restore the initial view back to the rendered target.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec78"/>A usage example</h2></div></div></div><p>We now have all the requirements to load and display a map to the screen. The following code snippet shows you<a id="id441" class="indexterm"/> the minimal steps:</p><div><pre class="programlisting">int main(int argc,char* argv[])
{
  sf::RenderWindow window(sf::VideoMode(1600,900),"Example Tile");
  sfutils::VMap* map = sfutils::VMap::createMapFromFile("./map.json");
  sfutils::MapViewer viewer(window,*map);
  sf::Clock clock;
  while (window.isOpen())
  {
    sf::Event event;
    while (window.pollEvent(event))
    {
      if (event.type == sf::Event::Closed)   // Close window : exit
      window.close();
    }
    window.clear();
    viewer.processEvents();
    viewer.update(clock.restart().asSeconds());
    viewer.draw();
    window.display();
  }
  return 0;
}</pre></div><p>The different steps of this function are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Creating a window</li><li class="listitem">Creating a map from a file</li><li class="listitem">Process the events and quit if requests</li><li class="listitem">Update the viewer</li><li class="listitem">Display the viewer on the screen</li></ol></div><p>The result will be as follows:</p><div><img src="img/8477OS_07_09.jpg" alt="A usage example"/></div><p>Now that the map is done, we <a id="id442" class="indexterm"/>need to fill it with some entities.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Building an entity system</h1></div></div></div><p>First of all, what is an entity system?</p><p>An <strong>entity system</strong> is a design pattern that focuses on <a id="id443" class="indexterm"/>data. Instead of creating a complex hierarchical tree of all possible entities, the idea is to build a system that allows us to add components to an entity at runtime. These<a id="id444" class="indexterm"/> components could be anything such as health points, artificial intelligence, skin, weapon, and everything but data.</p><p>However, if none of the entities and components hold functionalities, where are they stored? The answer is in the systems. Each system manages at least one component, and all the logic is inside these systems. Moreover, it is not possible to build an entity directly. You have to create or update it using an entity manager. It will be in charge of a set of entities, managing their components, creation, and destruction.</p><p>The structure is represented by the following chart:</p><div><img src="img/8477OS_07_10.jpg" alt="Building an entity system"/></div><p>There are many ways to implement such a structure. My choice was to use template and <a id="id445" class="indexterm"/>polymorphism.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec79"/>Use of the entity system</h2></div></div></div><p>Without going much<a id="id446" class="indexterm"/> into the internal structure, we create a new component with this system as a structure, with no method except a constructor/destructor, and inherit from <code class="literal">Component</code> as follows:</p><div><pre class="programlisting">struct CompHp : Component&lt;CompHp&gt;
{
  explicit Hp(int hp) : _hp(hp){};
  int _hp;
};</pre></div><p>The inheritance is important to have a common base class between all the components. The same idea is used to create <code class="literal">System</code>:</p><div><pre class="programlisting">struct SysHp : sfutils::System&lt;SysHp&gt;
{
  virtual void update(sfutils::EntityManager&amp; manager,const sf::Time&amp; dt) override;
};</pre></div><p>The reason for the inheritance is to have a common parent and API (the <code class="literal">update</code> function). Finally, to create an entity, you will have to do the following:</p><div><pre class="programlisting">EntityManager entities;
std::uint32_t id = entities.create();
entities.addComponent&lt;CompHp&gt;(id,42); //the first argument is always the entity id</pre></div><p>If we continue this example, when an entity has no <code class="literal">hp</code>, we have to remove it from the board. This part of the logic is implemented inside the <code class="literal">SysHp::update()</code> function:</p><div><pre class="programlisting">void SysHp::update(sfutils::EntityManager&amp; manager,const sf::Time&amp; dt)
{
  CompHp::Handle hp; //Handler is a kind of smart pointer which ensure access to valid data
  auto view = manager.getByComponents(hp); //this object is a filter on all our entities by there components
  auto end = view.end();
  for(auto current = view.begin(); current != end;++current)
  {
    if(hp-&gt;_hp &lt;= 0)
    manager.remove(current-&gt;id());
  }
}</pre></div><p>This <code class="literal">SysHp::update()</code> function is<a id="id447" class="indexterm"/> used to create a specific functionality. Its aim is to remove all the entities with <code class="literal">hp</code> under or equal to zero. To do this, we initialize <code class="literal">ComponentHandler&lt;CompHp&gt;</code> using the <code class="literal">CompHp::Handle</code> shortcut (defined in the <code class="literal">Component</code> class). Then we create our query on the world. In our case, we need to get all the entities with <code class="literal">CompHp</code> attached to them. The multiple criteria query is also possible for more complex systems.</p><p>Once we have our view, we iterate on it. Each iteration gives us access to <code class="literal">Entity</code> and updates the handler values to the entity components. So, creating access to the <code class="literal">hp</code> handler is equivalent to the following:</p><div><pre class="programlisting">manager.getComponent&lt;CompHp&gt;(current-&gt;id())</pre></div><p>Then, we check the <code class="literal">_hp</code> value and remove the entity if needed.</p><p>It's important to note that the entity will actually be removed only when the <code class="literal">EntityManager::update()</code> function is called to keep data consistent inside the system loops.</p><p>Now that the <code class="literal">SysHp</code> parameter has been completed, we need to register it to <code class="literal">SystemManager</code> that is linked to <code class="literal">EntityManager</code>:</p><div><pre class="programlisting">EntityManager entities;
SystemManager systems(entities);
systems.add&lt;SysHp&gt;();</pre></div><p>We have now built an entity manager, a component, a system, and an entity. Putting them all together will result in the following code:</p><div><pre class="programlisting">int main()
{
  EntityManager entities;
  SystemManager systems(entities);
  systems.add&lt;SysHp&gt;();

  for(int i =0; i&lt;10; ++i)
  {//create entities
    std::uint32_t id = entities.create();
    entities.addComponent&lt;CompHp&gt;(id,i*10);
  }
  sf::Clock clock;
  while(/* some criterion*/)
  {//game loop
    systems.updateAll(clock.restart());
    entities.update();
  }
  return 0;
}</pre></div><p>This little code will create an entity and system manager. Then, we create 10 entities and add them to the <code class="literal">CompHp</code> component. Finally, we enter the game loop.</p><p>As mentioned previously, don't detail the implementation of the entity system; focus on its usage. If you are interested in the implementation, which is a bit complex, take a look at the files in the <code class="literal">SFML-utils/include/SFML-utils/es</code> directory. This is header only library.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec80"/>Advantages of the entity system approach</h2></div></div></div><p>With a component system, each <a id="id448" class="indexterm"/>entity is represented as a single unique integer (its ID). These components are nothing but data. So, this is really simple to create a serialization function that saves the entire world. Database saving is made very simple with this approach but it's not the only point.</p><p>To create a flying car with a classic hierarchical tree, you have to inherit it from two different classes, namely car and flying vehicle. Each of these classes could inherit from the other. In fact, when the number of entities become large, the hierarchical tree is too much. For the same example, create an entity with the entity system, attach it to some wheels and wings. That's it! I agree that creating an entity system can be difficult, but its usage simplifies a lot the game's complexity.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec41"/>Building the game logic</h1></div></div></div><p>We now have all the requirements to start our game: resource management, events management, GUI, animations, map, and the entity system. It's time for us to group them into a single project.</p><p>First, we need to<a id="id449" class="indexterm"/> create our entities. Thanks to the entity system previously described, we only need to build some <a id="id450" class="indexterm"/>components and their systems. We can build many of them, but the main components for the project are as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Components</p>
</th><th style="text-align: left" valign="bottom">
<p>Entities</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Skin</p>
</td><td style="text-align: left" valign="top">
<p>Animation</p>
</td></tr><tr><td rowspan="2" style="text-align: left" valign="top">
<p>Health points</p>
</td><td style="text-align: left" valign="top">
<p>Current health</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Maximum health</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Team</p>
</td><td style="text-align: left" valign="top">
<p>Identifier for the team</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Build area</p>
</td><td style="text-align: left" valign="top">
<p>The authorized range around the entity</p>
</td></tr><tr><td rowspan="2" style="text-align: left" valign="top">
<p>Movement</p>
</td><td style="text-align: left" valign="top">
<p>Speed</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Destination</p>
</td></tr><tr><td rowspan="3" style="text-align: left" valign="top">
<p>Artificial intelligence for warriors</p>
</td><td style="text-align: left" valign="top">
<p>Delta time</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Damage</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Length of hit</p>
</td></tr></tbody></table></div><p>The interesting ones are artificial intelligence (to damage) and movement. The others are pretty naive. Of course, you can create your own component in addition/replacement of those proposed.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec81"/>Building our components</h2></div></div></div><p>We know <a id="id451" class="indexterm"/>all the data needed by our components, so let's build the two interesting components, namely the <code class="literal">walker AI</code> and the <code class="literal">warrior AI</code>:</p><div><pre class="programlisting">struct CompAIWalker : Component&lt;CompAIWalker&gt;
{
  explicit CompAIWalker(float speed);
  const float _speed;
  sf::Vector2i _pathToTake;
};</pre></div><p>This component handles the speed and destination. The destination can be updated by anything (for example, when an enemy is detected at proximity):</p><div><pre class="programlisting">struct CompAIWarrior : Component&lt;CompAIWarrior&gt;
{
  explicit CompAIWarrior(int hitPoint,const sf::Time&amp; timeDelta,int range);
  const int _hitPoint;
  const sf::Time _delta;
  sf::Time _elapsed;
  const int _range;
};</pre></div><p>This component stores the aggressiveness of an entity, with its damaged, attack speed and area of aggressively.</p><p>As we will use this<a id="id452" class="indexterm"/> component in the system section, I will also explain the <code class="literal">CompSkin</code> component. This component stores an <code class="literal">AnimatedSkin</code> and different possible <code class="literal">Animation</code> that could be applied to it:</p><div><pre class="programlisting">struct CompSkin : sfutils::Component&lt;CompSkin,Entity&gt;
{
  enum AnimationId : int{ Stand,Spawn, MoveLeft, MoveRight, HitLeft, HitRight};
  sfutils::AnimatedSprite _sprite;
  std::unordered_map&lt;int,sfutils::Animation*&gt; _animations;
};</pre></div><p>Now that the components have been built, take a look at the systems.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec82"/>Creating the different systems</h2></div></div></div><p>We need <a id="id453" class="indexterm"/>as many systems as the number of components. The skin system simply calls the update function on the animation. We have already built the related system for the health. For the team component, we don't need any system because this component is used only by artificial intelligence. The two systems left are more complex.</p><p>Let's start with the movement:</p><div><pre class="programlisting">struct SysAIWalker : sfutils::System&lt;SysAIWalker,Entity&gt;
{
  explicit SysAIWalker(Level&amp; level);
  virtual void update(sfutils::EntityManager&lt;Entity&gt;&amp; manager,const sf::Time&amp; dt) override;
  Level&amp; _level;
};</pre></div><p>Notice that the <code class="literal">Level</code> class has not yet been introduced. This class regroups an <code class="literal">EntityManager</code> and a <code class="literal">SystemManager</code> classes and gives us access to some functions concerning the map geometry, without having to know it. I will explain it later. In our case, we will need some information about the distance between the actual position of the component and its<a id="id454" class="indexterm"/> destination. This is why we need to keep a reference to the level.</p><p>Here's the implementation of the walker system:</p><div><pre class="programlisting">SysAIWalker::SysAIWalker(Level&amp; level) :_level(level) {}
void SysAIWalker::update(EntityManager&amp; manager,const sf::Time&amp; 
  dt)
{
  CompAIWalker::Handle AI;
  CompSkin::Handle skin;
  auto view = manager.getByComponents(AI,skin);
  auto end = view.end();
  const float seconds = dt.asSeconds();

  for(auto begin = view.begin();begin != end;++begin)
  {
    sf::Vector2f PosCurrent = skin-&gt;_sprite.getPosition();
    sf::Vector2i CoordCurrent = 
      _level.mapPixelToCoords(PosCurrent);
    sf::Vector2i CoordDest = AI-&gt;_pathToTake;
    if(CoordDest != CoordCurrent) //need to move
    {
      sf::Vector2f PosDest = _level.mapCoordsToPixel(CoordDest);
      //calculation of the direction to take
      sf::Vector2f directon = PosDest - PosCurrent;
      //calculation of the distance
      const float distance = 
        std::sqrt((directon.x*directon.x)+(directon.y*directon.y));
      const float frameDistance = AI-&gt;_speed * seconds;
      if(distance &gt; frameDistance)
          skin-&gt;_sprite.setPosition(PosCurrent + 
        directon*(frameDistance/distance));
      else
      {
        skin-&gt;_sprite.setPosition(PosDest);
        AI-&gt;_pathToTake = CoordCurrent;
      }

      if(directon.x &gt;0) //update skin direction
          skin-&gt;_sprite.setAnimation(skin-
        &gt;_animations.at(CompSkin::MoveRight));
      else
          skin-&gt;_sprite.setAnimation(skin-
        &gt;_animations.at(CompSkin::MoveLeft));
    }
  }
}</pre></div><p>This system doesn't just move the entity but also makes different things. The position is stored inside the <code class="literal">CompSkin</code> component, so we need to iterate on the entities by getting the <code class="literal">CompAIWalker</code> and <code class="literal">CompSkin</code> components attached to them. Then, we calculate the position of the entity in the world coordinate and check if a move is needed. If we need to move, we calculate the vector corresponding to the total displacement (direction). This vector gives us the direction that the entity needs to follow. Then, we calculate the distance between the end point and the current position. Depending on the speed, we change the current <a id="id455" class="indexterm"/>position to the new one.</p><p>Once the movement is complete, we also change the current animation to the one matching the movement direction taken by the entity.</p><p>Now, let's take an interest in the <code class="literal">Warrior AI</code>:</p><div><pre class="programlisting">SysAIWarrior::SysAIWarrior(Level&amp; level) : _level(level){}
void SysAIWarrior::update(sfutils::EntityManager&lt;Entity&gt;&amp; manager,const sf::Time&amp; dt)
{
  CompAIWarrior::Handle AI;
  CompTeam::Handle team;
  CompSkin::Handle skin;
  auto view = manager.getByComponents(AI,team,skin);
  auto end = view.end();
  for(auto begin = view.begin();begin != end;++begin)
  {
    AI-&gt;_elapsed += dt;
    std::vector&lt;Team*&gt; teamEnemies = team-&gt;_team-&gt;getEnemies();

    //if no enemies
    if(teamEnemies.size() &lt;=0)
        continue;
    std::uint32_t id = std::uint32_t(-1);

    /* ….set id to the nearest enemy ... */

    if(not manager.isValid(id))
        continue;

    //update path
    Entity&amp; enemy = manager.get(id);
    const sf::Vector2f pos = enemy.component&lt;CompSkin&gt;()-&gt;_sprite.getPosition();
    const sf::Vector2i coord = _level.mapPixelToCoords(pos);
    const int distance = _level.getDistance(myPosition,coord);
    if(distance &lt;= range) //next me
    {
      //shoot it
      if(AI-&gt;_elapsed &gt;= AI-&gt;_delta)
      {
        AI-&gt;_elapsed = sf::Time::Zero;
        CompHp::Handle hp = enemy.component&lt;CompHp&gt;();
        hp-&gt;_hp -= AI-&gt;_hitPoint;
        Entity&amp; me = **begin;
        if(enemy.onHitted != nullptr)
        enemy.onHitted(enemy,coord,me,myPosition,_level);
        if(me.onHit != nullptr)
        me.onHit(me,myPosition,enemy,coord,_level);
        //win some gold
        if(hp-&gt;_hp &lt;=0){
            team-&gt;_team-&gt;addGold(hp-&gt;_maxHp/50);
        }
      }

      //no need to move more
      if(begin-&gt;has&lt;CompAIWalker&gt;())
      begin-&gt;component&lt;CompAIWalker&gt;()-&gt;_pathToTake = myPosition;
    }
    else
    {//too far
        sf::Vector2i path = _level.getPath1(myPosition,coord);
        //move closer
        if(begin-&gt;has&lt;CompAIWalker&gt;())
            begin-&gt;component&lt;CompAIWalker&gt;()-&gt;_pathToTake = path;
  }
}</pre></div><p>This system requires three components, namely <code class="literal">CompSkin</code> (for position), <code class="literal">CompTeam</code> (for detect enemy), and <code class="literal">CompAIWarrior</code>. The first thing to do is update the delta time. Then, we check if we have some enemies to defeat. Next, we search for an enemy who is closer (I won't detail this part because you can put your own algorithm). If an enemy is found, we check the distance between us and the enemy. If we can shoot the enemy, we do so and reset the delta<a id="id456" class="indexterm"/> time to avoid hitting each frame. We also trigger some events (for example, to create sound) and add gold to the team if we just kill the enemy. We also set the destination of the <code class="literal">CompAIWarrior</code> to the current position (to stay fighting) if we can, or move closer to the next enemy.</p><p>We now have all the components and systems to manage them. So, we will continue with the game architecture.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec83"/>The level class</h2></div></div></div><p>As usual, we split the game into several parts. The <code class="literal">level</code> class represents a map. This class stores all the entities, systems, viewers, maps, sounds, and so on. As previously explained, it also implements an abstraction layer <a id="id457" class="indexterm"/>above the map geometry.</p><p>In fact, a level is a very simple object; it is just the glue between others. It registers all the systems, constructs<a id="id458" class="indexterm"/> the map, initializes a <code class="literal">MapViewer</code>, events, and regroups all the different update calls into one method. This class also offers users the ability to create new entities, by creating them through the internal <code class="literal">EntityManager</code>, and adding them to a map layer. The map is always synchronized with the <code class="literal">EntityManager</code> while doing this.</p><p>If you are interested in this implementation, take a look at the <code class="literal">SFML-book/07_2D_iso_game/src/SFML-Book/Level.cpp</code> file.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec84"/>The game class</h2></div></div></div><p>Now, the <code class="literal">game</code> class! You should be familiar with this class by now. Its global behavior hasn't changed and still<a id="id459" class="indexterm"/> contains the same functionalities (<code class="literal">update()</code>, <code class="literal">processEvents()</code>, and <code class="literal">render()</code>).</p><p>The big change here is that the<a id="id460" class="indexterm"/> game class will initialize a <code class="literal">Level</code> and <code class="literal">Team</code>. One of these will be the one controlled by the player, and the GUI depends on it. This is the reason that the GUI for this project was attached to a team instead of the entire game. I won't say that it's the best way, but it's the simplest and allows us to jump from one team to another.</p><p>If you are interested in this implementation, take a look at the <code class="literal">SFML-book/07_2D_iso_game/src/SFML-Book/Game.cpp</code> file.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec85"/>The Team GUI class</h2></div></div></div><p>This class handles different<a id="id461" class="indexterm"/> information and is the interface between the game and the player. It should allow the player to build some entities and interact with them.</p><p>The following screen shows you the<a id="id462" class="indexterm"/> <strong>Build</strong> menu. This menu shows the player the different entities that can be created and the current gold amount:</p><div><img src="img/8477OS_07_11.jpg" alt="The Team GUI class"/></div><p>Of course, we can complete this menu a lot, but this is the minimum information required by our game. Using<a id="id463" class="indexterm"/> our previously made GUI will facilitate this task a lot.</p><p>Once an entity is<a id="id464" class="indexterm"/> selected, we just have to place it into the game keeping in mind the following criteria:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The amount of gold</li><li class="listitem" style="list-style-type: disc">The build area</li></ul></div><p>After this, everything will run easily. Don't hesitate to make some helper functions that create different entities by adding some components with specific values.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec42"/>Summary</h1></div></div></div><p>In this chapter, we covered different things, such as creating animations. This class allowed us to display animated characters on screen. Then, we built a <code class="literal">Map</code> class that was filled with some entities. We also learned how to use an entity system by creating some components and systems to build our game logic. Finally, we put all the accumulated knowledge together to build a complete game with some artificial intelligence, a user interface, sounds, and animations.</p><p>With all this knowledge, you are now able to build any kind of game based on a tile system without too much effort.</p><p>In the next chapter, we will turn this game in a multiplayer one by using networking.</p></div></body></html>