<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Using 2D Graphics</h1></div></div></div><p>In this chapter, we will learn how to work and draw with 2D graphics and built-in Cinder tools.</p><p>The recipes in this chapter will cover<a id="id415" class="indexterm"/> the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Drawing 2D geometric primitives</li><li class="listitem" style="list-style-type: disc">Drawing arbitrary shapes with the mouse</li><li class="listitem" style="list-style-type: disc">Implementing a scribbler algorithm</li><li class="listitem" style="list-style-type: disc">Implementing 2D metaballs</li><li class="listitem" style="list-style-type: disc">Animating text around curves</li><li class="listitem" style="list-style-type: disc">Adding a blur effect</li><li class="listitem" style="list-style-type: disc">Implementing a force-directed graph</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Drawing 2D geometric primitives</h1></div></div></div><p>In this recipe, we <a id="id416" class="indexterm"/>will learn how to draw the following <a id="id417" class="indexterm"/>2D geometric shapes, as filled and stroked shapes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Circle</li><li class="listitem" style="list-style-type: disc">Ellipse</li><li class="listitem" style="list-style-type: disc">Line</li><li class="listitem" style="list-style-type: disc">Rectangle</li></ul></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec184"/>Getting ready</h2></div></div></div><p>Include the necessary header to draw in OpenGL using Cinder commands.</p><p>Add the following line of code at the top of your source file:</p><div><pre class="programlisting">#include "cinder/gl/gl.h"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec185"/>How to do it…</h2></div></div></div><p>We will create several geometric primitives using Cinder's methods for drawing in 2D. Perform the following<a id="id418" class="indexterm"/> steps to do so:</p><div><ol class="orderedlist arabic"><li class="listitem">Let's begin by declaring member variables to keep information about the shapes we will be drawing.<p>Create two <code class="literal">ci::Vec2f</code> objects to store the beginning and end of a line, a <code class="literal">ci::Rectf</code> object to draw a rectangle, a <code class="literal">ci::Vec2f</code> object to define the center of the circle, and a <code class="literal">float</code> object to define its radius. Finally, we will create <code class="literal">aci::Vec2f</code> to define the ellipse's radius and two <code class="literal">float</code> objects to define its width and height.</p><p>Let's also declare two <code class="literal">ci::Color</code> objects to define the stroke and fill colors.</p><div><pre class="programlisting">Vec2f mLineBegin,mLineEnd;
Rect fmRect;
Vec2f mCircleCenter;
float mCircleRadius;
Vec2f mEllipseCenter;
float mElipseWidth, mEllipseHeight;
Color mFillColor, mStrokeColor;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method, let's initialize the preceding members:<div><pre class="programlisting">mLineBegin = Vec2f( 10, 10 );
mLineEnd = Vec2f( 400, 400 );

mCircleCenter = Vec2f( 500, 200 );
mCircleRadius = 100.0f;

mEllipseCenter = Vec2f( 200, 300 );
mEllipseWidth = 200.0f;
ellipseHeight = 100.0f;

mRect = Rectf( Vec2f( 40, 20 ), Vec2f( 300, 100 ) );

mFillColor = Color( 1.0f, 1.0f, 1.0f );
mStrokeColor = Color( 1.0f, 0.0f, 0.0f );</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, let's start by drawing filled shapes.<p>Let's clear the background and set <code class="literal">mFillColor</code> to be the drawing color.</p><div><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) );
gl::color( mFillColor );</pre></div></li><li class="listitem">Draw the<a id="id419" class="indexterm"/> filled shapes by calling the <code class="literal">ci::gl::drawSolidRect</code>, <code class="literal">ci::gl::drawSolidCircle</code>, and <code class="literal">ci::gl::drawSolidEllipse</code> methods.<p>Add the following code snippet inside the <code class="literal">draw</code> method:</p><div><pre class="programlisting">gl::drawSolidRect( mRect );
gl::drawSolidCircle( mCircleCenter, mCircleRadius );
gl::drawSolidEllipse( mEllipseCenter, mEllipseWidth, ellipseHeight );</pre></div></li><li class="listitem">To draw our shapes as stroked graphics, let's first set <code class="literal">mStrokeColor</code> as the drawing color.<div><pre class="programlisting">gl::color( mStrokeColor );</pre></div></li><li class="listitem">Let's draw our shapes again, this time using only strokes by calling the <code class="literal">ci::gl::drawLine</code>, <code class="literal">ci::gl::drawStrokeRect</code>, <code class="literal">ci::gl::drawStrokeCircle</code>, and <code class="literal">ci::gl::drawStrokedEllipse</code> methods.<p>Add the following code snippet inside the <code class="literal">draw</code> method:</p><div><pre class="programlisting">gl::drawLine( mLineBegin, mLineEnd );
gl::drawStrokedRect( mRect );
gl::drawStrokedCircle( mCircleCenter, mCircleRadius );
gl::drawStrokedEllipse( mEllipseCenter, mEllipseWidth, ellipseHeight );</pre></div><p>This results in the following:</p><div><img src="img/8703OS_07_01.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec186"/>How it works…</h2></div></div></div><p>Cinder's drawing<a id="id420" class="indexterm"/> methods use OpenGL calls internally to provide fast and easy drawing routines.</p><p>The <code class="literal">ci::gl::color</code> method<a id="id421" class="indexterm"/> sets the drawing color so that all shapes will be drawn with that color until another is set by calling <code class="literal">ci::gl::color</code> again.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec187"/>There's more…</h2></div></div></div><p>You can also set the stroke width by calling the <code class="literal">glLineWidth</code> method and passing a <code class="literal">float</code> value as a parameter.</p><p>For example, to set the stroke to be 5 pixels wide you should write the following:</p><div><pre class="programlisting">glLineWidth( 5.0f );</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Drawing arbitrary shapes with the mouse</h1></div></div></div><p>In this recipe, we will learn<a id="id422" class="indexterm"/> how to draw arbitrary shapes <a id="id423" class="indexterm"/>using the mouse.</p><p>We will begin a new <a id="id424" class="indexterm"/>contour every time the user presses the mouse button, and draw when the user drags the mouse.</p><p>The shape will be drawn using fill and stroke.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec188"/>Getting ready</h2></div></div></div><p>Include the necessary files to draw and create a <code class="literal">ci::Shape2d</code> object.</p><p>Add the following code snippet at the top of your source file:</p><div><pre class="programlisting">#include "cinder/gl/gl.h"
#include "cinder/shape2d.h"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec189"/>How to do it…</h2></div></div></div><p>We will create a <code class="literal">ci::Shape2d</code> object and create vertices using mouse coordinates. Perform the following steps to do so:</p><div><ol class="orderedlist arabic"><li class="listitem">Declare a <code class="literal">ci::Shape2d</code> object to define our shape and two <code class="literal">ci::Color</code> objects to define the fill and stroke colors.<div><pre class="programlisting">Shape2d mShape;
Color fillColor, strokeColor;</pre></div></li><li class="listitem">Initialize the colors in the <code class="literal">setup</code> method.<p>We'll be using black for stroke and yellow for fill.</p><div><pre class="programlisting">mFillColor = Color( 1.0f, 1.0f, 0.0f );
mStrokeColor = Color( 0.0f, 0.0f, 0.0f );</pre></div></li><li class="listitem">Since the drawing will be made with the mouse, it is necessary to use the <code class="literal">mouseDown</code> and <code class="literal">mouseDrag</code> events.<p>Declare the necessary callback methods.</p><div><pre class="programlisting">void mouseDown( MouseEvent event );
void mouseDrag( MouseEvent event );</pre></div></li><li class="listitem">In the implementation of <code class="literal">mouseDown</code> we will create a new contour by calling the <code class="literal">moveTo</code> method.<p>The following code snippet shows what the method should look like:</p><div><pre class="programlisting">void MyApp::mouseDown( MouseEvent event ){
  mShape.moveTo( event.getpos() );
}</pre></div></li><li class="listitem">In the <a id="id425" class="indexterm"/><code class="literal">mouseDrag</code> method<a id="id426" class="indexterm"/> we will add a line to our shape<a id="id427" class="indexterm"/> by calling the <code class="literal">lineTo</code> method.<p>Its implementation should look like the following code snippet:</p><div><pre class="programlisting">void MyApp::mouseDrag( MouseEvent event ){
  mShape.lineTo( event.getPos() );  
}</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, we will first need to clear the background, then set <code class="literal">mFillColor</code> as the drawing color, and draw <code class="literal">mShape</code>.<div><pre class="programlisting">gl::clear( Color::white() );
gl::color( mFillColor );
gl::drawSolid( mShape );</pre></div></li><li class="listitem">All there is left to do is to set <code class="literal">mStrokeColor</code> as the drawing color and draw <code class="literal">mShape</code> as a stroked shape.<div><pre class="programlisting">gl::color( mStrokeColor );
gl::draw( mShape );</pre></div></li><li class="listitem">Build and run the application. Press the mouse button to begin drawing a new contour, and drag to draw.<div><img src="img/8703OS_07_02.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec190"/>How it works…</h2></div></div></div><p><code class="literal">ci:Shape2d</code> is a class<a id="id428" class="indexterm"/> that defines an arbitrary shape in two<a id="id429" class="indexterm"/> dimensions allowing multiple contours.</p><p>The <code class="literal">ci::Shape2d::moveTo</code> method<a id="id430" class="indexterm"/> creates a new contour starting at the coordinate passed as a parameter. Then, the <code class="literal">ci::Shape2d::lineTo</code> method creates a straight line from the last position to the coordinate which is passed as a parameter.</p><p>The shape is internally tessellated into triangles when drawing a solid graphic.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec191"/>There's more…</h2></div></div></div><p>It is also possible to add curves when constructing a shape using <code class="literal">ci::Shape2d</code>.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Explanation</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">quadTo (constVec2f&amp; p1, constVec2f&amp; p2)</code></p>
</td><td style="text-align: left" valign="top">
<p>Adds a quadratic curve from the last position to <code class="literal">p2</code>, using <code class="literal">p1</code> as a control point<a id="id431" class="indexterm"/></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">curveTo (constVec2f&amp; p1, constVec2f&amp; p2, constVec2f&amp; p3)</code></p>
</td><td style="text-align: left" valign="top">
<p>Adds a curve from the last position to <code class="literal">p3</code>, using <code class="literal">p1</code> and <code class="literal">p2</code> as control points</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">arcTo (constVec2f&amp; p, constVec2f&amp; t, float radius)</code>
<a id="id432" class="indexterm"/></p>
</td><td style="text-align: left" valign="top">
<p>Adds an arc from the last position to <code class="literal">p1</code> using <code class="literal">t</code> as the tangent point and radius as the arc's radius</p>
</td></tr></tbody></table></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Implementing a scribbler algorithm</h1></div></div></div><p>In this recipe, <a id="id433" class="indexterm"/>we are going to implement a scribbler algorithm, which is very simple to implement using Cinder but gives an interesting effect while drawing. <a id="id434" class="indexterm"/>You can read more about the concept of connecting neighbor points at <a class="ulink" href="http://www.zefrank.com/scribbler/about.html">http://www.zefrank.com/scribbler/about.html</a>. You can find an example of scribbler at <a class="ulink" href="http://www.zefrank.com/scribbler/">http://www.zefrank.com/scribbler/</a> or <a class="ulink" href="http://mrdoob.com/projects/harmony/">http://mrdoob.com/projects/harmony/</a>.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec192"/>How to do it…</h2></div></div></div><p>We will implement an application illustrating scribbler. Perform the following steps to do so:</p><div><ol class="orderedlist arabic"><li class="listitem">Include the necessary headers:<div><pre class="programlisting">#include&lt;vector&gt;</pre></div></li><li class="listitem">Add properties to your main application class:<div><pre class="programlisting">vector &lt;Vec2f&gt; mPath;
float mMaxDist;
ColorA mColor;
bool mDrawPath;</pre></div></li><li class="listitem">Implement the <code class="literal">setup</code> method, as follows:<div><pre class="programlisting">void MainApp::setup()
{
  mDrawPath = false;
  mMaxDist = 50.f;
  mColor = ColorA(0.3f,0.3f,0.3f, 0.05f);
  setWindowSize(800, 600);

  gl::enableAlphaBlending();
  gl::clear( Color::white() );
}</pre></div></li><li class="listitem">Since the drawing <a id="id435" class="indexterm"/>will be made with the mouse, it is necessary to use the <code class="literal">mouseDown</code> and <code class="literal">mouseUp</code> events. Implement these methods, as follows:<div><pre class="programlisting">void MainApp::mouseDown( MouseEvent event )
{
  mDrawPath = true;
}

void MainApp::mouseUp( MouseEvent event )
{
  mDrawPath = false;
}</pre></div></li><li class="listitem">Finally, the implementation of drawing methods looks like the following code snippet:<div><pre class="programlisting">void MainApp::draw(){
  if( mDrawPath ) {
  drawPoint( getMousePos() );
    }
}

void MainApp::drawPoint(Vec2f point) {
  mPath.push_back( point );

  gl::color(mColor);
  vector&lt;Vec2f&gt;::iterator it;
  for(it = mPath.begin(); it != mPath.end(); ++it) {
  if( (*it).distance(point) &lt;mMaxDist ) {
  gl::drawLine(point, (*it));
        }
    }
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec193"/>How it works…</h2></div></div></div><p>While the left mouse button is down, we are adding a new point to our container and drawing lines connecting it with other points near it. The distance between the newly-added point and the points in its neighborhood <a id="id436" class="indexterm"/>we are looking for to draw a connection line has to be less than the value of the <code class="literal">mMaxDist</code> property. Please notice that we are clearing the drawing area only once, at the program startup at the end of the <code class="literal">setup</code> method, so we don't have to redraw all the connections to each frame, which would be very slow.</p><div><img src="img/8703OS_07_03.jpg" alt="How it works…"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Implementing 2D metaballs</h1></div></div></div><p>In this recipe, we <a id="id437" class="indexterm"/>will learn how we can implement organic looking objects called metaballs.<a id="id438" class="indexterm"/></p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec194"/>Getting ready</h2></div></div></div><p>In this recipe, we are going to use the code base from the <em>Applying repulsion and attraction forces</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Building Particle Systems">Chapter 5</a>, <em>Building Particle Systems</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec195"/>How to do it…</h2></div></div></div><p>We will implement<a id="id439" class="indexterm"/> the metaballs' rendering using a shader program. Perform the following steps to do so:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a file inside the <code class="literal">assets</code> folder with a name, <code class="literal">passThru_vert.glsl</code>, and put the following code snippet inside it:<div><pre class="programlisting">void main()
{
  gl_Position = ftransform();
  gl_TexCoord[0] = gl_MultiTexCoord0;
  gl_FrontColor = gl_Color; 
}</pre></div></li><li class="listitem">Create a file inside the <code class="literal">assets</code> folder with a name, <code class="literal">mb_frag.glsl</code>, and put the following code snippet inside it:<div><pre class="programlisting">#version 120

uniform vec2 size;
uniform int num;
uniform vec2 positions[100];
uniform float radius[100];

void main(void)
{

  // Get coordinates
  vec 2 texCoord = gl_TexCoord[0].st;
  
  vec4 color = vec4(1.0,1.0,1.0, 0.0);
  float a = 0.0;
  
  int i;  
  for(i = 0; i&lt;num; i++) {
    color.a += (radius[i] / sqrt( ((texCoord.x*size.x)-
    positions[i].x)*((texCoord.x*size.x)-positions[i].x) + 
    ((texCoord.y*size.y)-
    positions[i].y)*((texCoord.y*size.y)-positions[i].y) ) 
    ); 
    }

  // Set color
  gl_FragColor = color;
}</pre></div></li><li class="listitem">Add the necessary <a id="id440" class="indexterm"/>header files.<div><pre class="programlisting">#include "cinder/Utilities.h"
#include "cinder/gl/GlslProg.h"</pre></div></li><li class="listitem">Add a property to your application's main class, which is the <code class="literal">GlslProg</code> object for our GLSL shader program.<div><pre class="programlisting">gl::GlslProg  mMetaballsShader;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method, change the values of <code class="literal">repulsionFactor</code> and <code class="literal">numParticle</code>.<div><pre class="programlisting">repulsionFactor = -40.f;
int numParticle = 10;</pre></div></li><li class="listitem">At the end of the <code class="literal">setup</code> method, load our GLSL shader program, as follows:<div><pre class="programlisting">mMetaballsShader = gl::GlslProg( loadAsset("passThru_vert.glsl"), loadAsset("mb_frag.glsl") );</pre></div></li><li class="listitem">The last major change is in the <code class="literal">draw</code> method, which looks like the following code snippet:<div><pre class="programlisting">void MainApp::draw()
{
  gl::enableAlphaBlending();
  gl::clear( Color::black() );

  int particleNum = mParticleSystem.particles.size();

  mMetaballsShader.bind();
  mMetaballsShader.uniform( "size", Vec2f(getWindowSize()) );
  mMetaballsShader.uniform( "num", particleNum );

  for (int i = 0; i&lt;particleNum; i++) {
  mMetaballsShader.uniform( "positions[" + toString(i) + 
  "]", mParticleSystem.particles[i]-&gt;position );
  mMetaballsShader.uniform( "radius[" + toString(i) + 
    "]", mParticleSystem.particles[i]-&gt;radius );
  }

  gl::color(Color::white());
  gl::drawSolidRect( getWindowBounds() );
  mMetaballsShader.unbind();
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec196"/>How it works…</h2></div></div></div><p>The most important part <a id="id441" class="indexterm"/>of this recipe is the fragment shader program mentioned in step 2. The shader generates texture with rendered metaballs based on the positions and radius passed to the shader from our particle system. In step 7, you can find out how to pass information to the shader program. We are using <code class="literal">setMatricesWindow</code> and <code class="literal">setViewport</code> to set OpenGL for drawing.</p><div><img src="img/8703OS_07_04.jpg" alt="How it works…"/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec197"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>A Wikipedia article on metaballs</strong><a id="id442" class="indexterm"/>: <a class="ulink" href="http://en.wikipedia.org/wiki/Metaballs">http://en.wikipedia.org/wiki/Metaballs</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Animating text around curves</h1></div></div></div><p>In this recipe, we will <a id="id443" class="indexterm"/>learn how we can animate text around a user-defined curve.</p><p>We will create the <a id="id444" class="indexterm"/>
<code class="literal">Letter</code> and <code class="literal">Word</code> classes to manage the animation, a <code class="literal">ci::Path2d</code> object to define the curve, and a <code class="literal">ci::Timer</code> object to define the duration of the animation.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec198"/>Getting ready</h2></div></div></div><p>Create and add the following files to your project:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Word.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Word.cpp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Letter.h</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Letter.cpp</code></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec199"/>How to do it…</h2></div></div></div><p>We will create a word and animate its letters along a <code class="literal">ci::Path2d</code> object. Perform the following steps to do so:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">Letter.h</code> file, include the necessary to use the <code class="literal">text</code>, <code class="literal">ci::Vec2f</code>, and <code class="literal">ci::gl::Texture</code> files.<p>Also add the <code class="literal">#pragma once</code> macro</p><div><pre class="programlisting">#pragma once

#include "cinder/vector.h"
#include "cinder/text.h"
#include "cinder/gl/Texture.h"</pre></div></li><li class="listitem">Declare the <code class="literal">Letter</code> class with the following members and methods:<div><pre class="programlisting">class Letter{
public:
    Letter( ci::Font font, conststd::string&amp; letter );

    void draw();
    void setPos( const ci::Vec2f&amp; newPos );

    ci::Vec2f pos;
    float rotation;
    ci::gl::Texture texture;
    float width;
};</pre></div></li><li class="listitem">Move to the <code class="literal">Letter.cpp</code> file to<a id="id445" class="indexterm"/> implement the class.<p>In the constructor, create a <code class="literal">ci::TextBox</code> object, set its parameters, and render it to texture. Also, set the width as the texture's width plus a padding value of 10:</p><div><pre class="programlisting">Letter::Letter( ci::Font font, conststd::string&amp; letter ){
    ci::TextBoxtextBox;  
    textBox = ci::TextBox().font( font ).size( ci::Vec2i( ci::TextBox::GROW, ci::TextBox::GROW ) ).text( letter ).premultiplied();
    texture = textBox.render();
    width = texture.getWidth() + 10.0f;
}</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, we will draw the texture and use OpenGL transformations to translate the texture to its position, and rotate according to the rotation:<div><pre class="programlisting">void Letter::draw(){
    glPushMatrix();
    glTranslatef( pos.x, pos.y, 0.0f );
    glRotatef( ci::toDegrees( rotation ), 0.0f, 0.0f, 1.0f );
    glTranslatef( 0.0f, -texture.getHeight(), 0.0f );
    ci::gl::draw( texture );
    glPopMatrix();
}</pre></div></li><li class="listitem">In the <code class="literal">setPos</code> method<a id="id446" class="indexterm"/> implementation, we will update the position and calculate its rotation so that the letter is perpendicular to its movement. We do this by calculating the arc tangent of its velocity:<div><pre class="programlisting">void Letter::setPos( const ci::Vec2f&amp;newPos ){
    ci::Vec2f vel = newPos - pos;
    rotation = atan2( vel.y, vel.x );
    pos = newPos;
}</pre></div></li><li class="listitem">The <code class="literal">Letter</code> class is ready! <a id="id447" class="indexterm"/>Now move to the <code class="literal">Word.h</code> file, add the <code class="literal">#pragma once</code> macro, and include the <code class="literal">Letter.h</code> file:<div><pre class="programlisting">#pragma once
#include "Letter.h"</pre></div></li><li class="listitem">Declare the <code class="literal">Word</code> class with the following members and methods:<div><pre class="programlisting">class Word{
public:
    Word( ci::Font font, conststd::string&amp; text );

    ~Word();

    void update( const ci::Path2d&amp; curve, float curveLength, float  progress );
    void draw();

      std::vector&lt; Letter* &gt; letters;
      float length;
};</pre></div></li><li class="listitem">Move to the <code class="literal">Word.cpp</code> file and include the <code class="literal">Word.h</code> file:<div><pre class="programlisting">#include "Word.h"</pre></div></li><li class="listitem">In the constructor, we will iterate over each character of <code class="literal">text</code> and add a new <code class="literal">Letter</code> object.We will also calculate the total length of the text by calculating the sum of widths of all the letters:<div><pre class="programlisting">Word::Word( ci::Font font, conststd::string&amp; text ){
  length = 0.0f;
  for( int i=0; i&lt;text.size(); i++ ){
  std::string letterText( 1, text[i] );
          Letter *letter = new Letter( font, letterText );
  letters.push_back( letter );
  length += letter-&gt;width;
    }
}</pre></div><p>In the destructor, we will delete all the <code class="literal">Letter</code> objects to clean up memory used by the class:</p><div><pre class="programlisting">Word::~Word(){
  for( std::vector&lt;Letter*&gt;::iterator it = letters.begin(); it != letters.end(); ++it ){
  delete *it;
    }
}</pre></div></li><li class="listitem">In the <code class="literal">update</code> method, <a id="id448" class="indexterm"/>we will pass a reference to the <code class="literal">ci::Path2d</code> object, the total length of the path, and the progress of the animation as a normalized value from 0.0 to 1.0.<p>We will calculate the position of each individual letter along the curve taking into account the length of <code class="literal">Word</code> and the current progress:</p><div><pre class="programlisting">void Word::update( const ci::Path2d&amp; curve, float curveLength,   float progress ){
  float maxProgress = 1.0f - ( length / curveLength );
  float currentProgress = progress * maxProgress;
  float progressOffset = 0.0f;
  for( int i=0; i&lt;letters.size(); i++ ){
        ci::Vec2f pos = curve.getPosition
        ( currentProgress + progressOffset );
        letters[i]-&gt;setPos( pos );
        progressOffset += ( letters[i]-&gt;width / curveLength );
    }
}</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, we will iterate over all letters and call the <code class="literal">draw</code> method of each letter:<div><pre class="programlisting">void Word::draw(){
  for( std::vector&lt; Letter* &gt;::iterator it = letters.begin(); it != letters.end(); ++it ){
        (*it)-&gt;draw();
    }
}</pre></div></li><li class="listitem">With the <code class="literal">Word</code> and <code class="literal">Letter</code> classes ready, it's time to move to our application's class source file. Start by including the necessary source files and adding the helpful <code class="literal">using</code> statements:<div><pre class="programlisting">#include "cinder/Timer.h"
#include "Word.h"

using namespace ci;
using namespace ci::app;
using namespace std;</pre></div></li><li class="listitem">Declare the following members:<div><pre class="programlisting">Word * mWord;
Path2d mCurve;
float mPathLength;
Timer mTimer;
double mSeconds;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method, we <a id="id449" class="indexterm"/>will start by creating <code class="literal">std::string</code> and <code class="literal">ci::Font</code> and use them to initialize <code class="literal">mWord</code>. We will also initialize <code class="literal">mSeconds</code> with the seconds we want our animation to last for:<div><pre class="programlisting">string text = "Some Text";
Font font = Font( "Arial", 46 );
mWord = new Word( font, text );
mSeconds = 5.0;</pre></div></li><li class="listitem">We now need to create the curve by creating the keypoints and connecting them by calling <code class="literal">curveTo</code>:<div><pre class="programlisting">Vec2f curveBegin( 0.0f, getWindowCenter().y );
Vec2f curveCenter = getWindowCenter();
Vec2f curveEnd( getWindowWidth(), getWindowCenter().y );

mCurve.moveTo( curveBegin );
mCurve.curveTo( Vec2f( curveBegin.x, curveBegin.y + 200.0f ), Vec2f( curveCenter.x, curveCenter.y + 200.0f ), curveCenter );
mCurve.curveTo( Vec2f( curveCenter.x, curveCenter.y - 200.0f ), Vec2f( curveEnd.x, curveEnd.y - 200.0f ), curveEnd );</pre></div></li><li class="listitem">Let's calculate the length of the path by summing the distance between each point and the one next to it. Add the following code snippet inside the <code class="literal">setup</code> method:<div><pre class="programlisting">mPathLength = 0.0f;
for( int i=0; i&lt;mCurve.getNumPoints()-1; i++ ){
  mPathLength += mCurve.getPoint( i ).distance( mCurve.getPoint( i+1 ) );
    }</pre></div></li><li class="listitem">We need to check if <code class="literal">mTimer</code> is running and calculate the progress by calculating the ratio between the elapsed seconds and <code class="literal">mSeconds</code>. Add the following code snippet inside the <code class="literal">update</code> method:<div><pre class="programlisting">if( mTimer.isStopped() == false ){
  float progress;
  if( mTimer.getSeconds() &gt;mSeconds ){
    mTimer.stop();
    progress = 1.0f;
        } else {
  progress = (float)( mTimer.getSeconds() / mSeconds );
        }
mWord-&gt;update( mCurve, mPathLength, progress );
    }</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method, <a id="id450" class="indexterm"/>we will need to clear the background, enable alpha blending, draw <code class="literal">mWord</code>, and draw the path:<div><pre class="programlisting">gl::clear( Color( 0, 0, 0 ) ); 
gl::enableAlphaBlending();
mWord-&gt;draw(); 
gl::draw( mCurve );</pre></div></li><li class="listitem">Finally, we need to start the timer whenever the user presses any key.<p>Declare the <code class="literal">keyUp</code> event handler:</p><div><pre class="programlisting">void keyUp( KeyEvent event );</pre></div></li><li class="listitem">And the following is the implementation of the the <code class="literal">keyUp</code> event handler:<div><pre class="programlisting">void CurveTextApp::keyUp( KeyEvent event ){
mTimer.start();
}</pre></div></li><li class="listitem">Build and run the application. Press any key to begin the animation.<div><img src="img/8703OS_07_05.jpg" alt="How to do it…"/></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Adding a blur effect</h1></div></div></div><p>In this recipe<a id="id451" class="indexterm"/>, we<a id="id452" class="indexterm"/> will learn how we can apply a blur effect while drawing a texture.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec200"/>Getting ready</h2></div></div></div><p>In this recipe, we are going to use a Gaussian blur shader provided by Geeks3D at <a class="ulink" href="http://www.geeks3d.com/20100909/shader-library-gaussian-blur-post-processing-filter-in-glsl/">http://www.geeks3d.com/20100909/shader-library-gaussian-blur-post-processing-filter-in-glsl/</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec201"/>How to do it…</h2></div></div></div><p>We will implement<a id="id453" class="indexterm"/> a sample Cinder application to illustrate the mechanism. Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a file inside the <code class="literal">assets</code> folder with the name <code class="literal">passThru_vert.glsl</code> and put the following code snippet inside it:<div><pre class="programlisting">void main()
{
  gl_Position = ftransform();
  gl_TexCoord[0] = gl_MultiTexCoord0;
  gl_FrontColor = gl_Color; 
}</pre></div></li><li class="listitem">Create a file inside the <code class="literal">assets</code> folder with the name <code class="literal">gaussian_v_frag.glsland</code> and put the following code snippet inside it:<div><pre class="programlisting">#version 120

uniform sampler2D sceneTex; // 0

uniform float rt_w; // render target width
uniform float rt_h; // render target height
uniform float vx_offset;

float offset[3] = float[]( 0.0, 1.3846153846, 3.2307692308 );
float weight[3] = float[]( 0.2270270270, 0.3162162162, 0.0702702703 );

void main() 
{ 
  vec3 tc = vec3(1.0, 0.0, 0.0);
  if (gl_TexCoord[0].x&lt;(vx_offset-0.01)){
vec2 uv = gl_TexCoord[0].xy;
tc = texture2D(sceneTex, uv).rgb * weight[0];
for (int i=1; i&lt;3; i++) {
tc += texture2D(sceneTex, uv + vec2(0.0, offset[i])/rt_h).rgb * weight[i];
  tc += texture2D(sceneTex, uv - vec2(0.0, offset[i])/rt_h).rgb * weight[i];
    }
  }
else if (gl_TexCoord[0].x&gt;=(vx_offset+0.01)){
  tc = texture2D(sceneTex, gl_TexCoord[0].xy).rgb;
  }
gl_FragColor = vec4(tc, 1.0);
}</pre></div><p>Create a file inside the <a id="id454" class="indexterm"/>
<code class="literal">assets</code> folder with the name <code class="literal">gaussian_h_frag.glsl</code> and put the following code snippet inside it:</p><div><pre class="programlisting">#version 120

uniform sampler2D sceneTex; // 0

uniform float rt_w; // render target width
uniform float rt_h; // render target height
uniform float vx_offset;

float offset[3] = float[]( 0.0, 1.3846153846, 3.2307692308 );
float weight[3] = float[]( 0.2270270270, 0.3162162162, 0.0702702703 );

void main() 
{ 
vec3 tc = vec3(1.0, 0.0, 0.0);
if (gl_TexCoord[0].x&lt;(vx_offset-0.01)){
vec2 uv = gl_TexCoord[0].xy;
tc = texture2D(sceneTex, uv).rgb * weight[0];
for (int i=1; i&lt;3; i++) 
    {
    tc += texture2D(sceneTex, uv + vec2(offset[i])/rt_w, 0.0).rgb * weight[i];
    tc += texture2D(sceneTex, uv - vec2(offset[i])/rt_w, 0.0).rgb * weight[i];
    }
  }
else if (gl_TexCoord[0].x&gt;=(vx_offset+0.01))
  {
  tc = texture2D(sceneTex, gl_TexCoord[0].xy).rgb;
  }
gl_FragColor = vec4(tc, 1.0);
}</pre></div></li><li class="listitem">Add the necessary headers:<div><pre class="programlisting">#include "cinder/Utilities.h"
#include "cinder/gl/GlslProg.h"
#include "cinder/gl/Texture.h"
#include "cinder/ImageIo.h"
#include "cinder/gl/Fbo.h"</pre></div></li><li class="listitem">Add the properties to your application's main class:<div><pre class="programlisting">gl::GlslProg  mGaussianVShader, mGaussianHShader;
gl::Texture mImage, mImageBlur;
gl::Fbo    mFboBlur1, mFboBlur2;
float           offset, level;
params::InterfaceGl mParams;</pre></div></li><li class="listitem">Implement the <a id="id455" class="indexterm"/><code class="literal">setup</code> method, as follows:<div><pre class="programlisting">void MainApp::setup(){
  setWindowSize(512, 512);

  level = 0.5f;
  offset = 0.6f;

  mGaussianVShader = gl::GlslProg( loadAsset("passThru_vert.glsl"), loadAsset("gaussian_v_frag.glsl") );
  mGaussianHShader = gl::GlslProg( loadAsset("passThru_vert.glsl"), loadAsset("gaussian_h_frag.glsl") );
  mImage = gl::Texture(loadImage(loadAsset("image.png")));

  mFboBlur1 = gl::Fbo
  (mImage.getWidth(), mImage.getHeight());
  mFboBlur2 = gl::Fbo
  (mImage.getWidth(), mImage.getHeight());

// Setup the parameters
  mParams = params::InterfaceGl
  ( "Parameters", Vec2i( 200, 100 ) );
  mParams.addParam
  ( "level", &amp;level, "min=0 max=1 step=0.01" );
  mParams.addParam
  ( "offset", &amp;offset, "min=0 max=1 step=0.01");
}</pre></div></li><li class="listitem">At the beginning of the <code class="literal">draw</code> method calculate the blur intensity:<div><pre class="programlisting">float rt_w = mImage.getWidth()*3.f-mImage.getWidth()*2.f*level;
float rt_h = mImage.getHeight()*3.f-mImage.getHeight()*2.f*level;</pre></div></li><li class="listitem">In the <code class="literal">draw</code> function<a id="id456" class="indexterm"/> render an image to <code class="literal">mFboBlur1</code> with a first step shader applied:<div><pre class="programlisting">mFboBlur1.bindFramebuffer();
gl::setViewport( mFboBlur1.getBounds() );
mImage.bind(0);
mGaussianVShader.bind();
mGaussianVShader.uniform("sceneTex", 0);
mGaussianVShader.uniform("rt_w", rt_w);
mGaussianVShader.uniform("rt_h", rt_h);
mGaussianVShader.uniform("vx_offset", offset);
gl::drawSolidRect(mFboBlur1.getBounds());
mGaussianVShader.unbind();
mFboBlur1.unbindFramebuffer();</pre></div></li><li class="listitem">In the <code class="literal">draw</code> function render a texture from <code class="literal">mFboBlur1</code> with a second step shader applied:<div><pre class="programlisting">mFboBlur2.bindFramebuffer();
mFboBlur1.bindTexture(0);
mGaussianHShader.bind();
mGaussianHShader.uniform("sceneTex", 0);
mGaussianHShader.uniform("rt_w", rt_w);
mGaussianHShader.uniform("rt_h", rt_h);
mGaussianHShader.uniform("vx_offset", offset);
gl::drawSolidRect(mFboBlur2.getBounds());
mGaussianHShader.unbind();
mFboBlur2.unbindFramebuffer();</pre></div></li><li class="listitem">Set <code class="literal">mImageBlur</code> to the result texture from <code class="literal">mFboBlur2</code>:<div><pre class="programlisting">mImageBlur = mFboBlur2.getTexture();</pre></div></li><li class="listitem">At the end of the <code class="literal">draw</code> method draw a texture with the result and GUI:<div><pre class="programlisting">gl::clear( Color::black() );
gl::setMatricesWindow(getWindowSize());
gl::setViewport(getWindowBounds());
gl::draw(mImageBlur);
params::InterfaceGl::draw();</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec202"/>How it works…</h2></div></div></div><p>Since a Gaussian blur shader <a id="id457" class="indexterm"/>needs to be applied twice—for the vertical and horizontal processing—we have to use <strong>frame buffer object</strong> (<strong>FBO</strong>
<a id="id458" class="indexterm"/>), a mechanism of drawing to the texture in the memory of graphic card. In step 8, we are drawing the original image from the <code class="literal">mImage</code> object and applying shader program stored in the <code class="literal">gaussian_v_frag.glsl</code> file loaded into <code class="literal">mGaussianVShaderobject</code>. At this point, everything is drawn into <code class="literal">mFboBlur1</code>. The next step is to use a texture from <code class="literal">mFboBlur2</code> and apply a shader to the second <a id="id459" class="indexterm"/>pass which you can find in step 9. The final processed texture is stored in <code class="literal">mImageBlur</code> in step 10. In step 7 we are calculating blur intensity.</p><div><img src="img/8703OS_07_06.jpg" alt="How it works…"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Implementing a force-directed graph</h1></div></div></div><p>A force-directed graph is a<a id="id460" class="indexterm"/> way of drawing an aesthetic graph using simple physics such as repealing and springs. We are going to make <a id="id461" class="indexterm"/>our graph interactive so that users can drag nodes around and see how graph reorganizes itself.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec203"/>Getting ready</h2></div></div></div><p>In this recipe we are going to use the code base from the <em>Creating a particle system in 2D</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Building Particle Systems">Chapter 5</a>, <em>Building Particle Systems</em>. To get some details of how to draw nodes and connections between them, please refer to the <em>Connecting particles</em> recipe in <a class="link" href="ch06.html" title="Chapter 6. Rendering and Texturing Particle Systems">Chapter 6</a>, <em>Rendering and Texturing Particle Systems</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec204"/>How to do it…</h2></div></div></div><p>We will create an interactive<a id="id462" class="indexterm"/> force-directed graph. Perform the following steps to do so:</p><div><ol class="orderedlist arabic"><li class="listitem">Add properties to your main application class.<div><pre class="programlisting">vector&lt; pair&lt;Particle*, Particle*&gt; &gt; mLinks;
float mLinkLength;
Particle*   mHandle;
bool mIsHandle;</pre></div></li><li class="listitem">In the <code class="literal">setup</code> method set default values and create a graph.<div><pre class="programlisting">void MainApp::setup(){
  mLinkLength = 40.f;
  mIsHandle   = false;

  float drag = 0.95f;

  Particle *particle = newParticle(getWindowCenter(), 10.f, 10.f, drag );
  mParticleSystem.addParticle( particle );

  Vec2f r = Vec2f::one()*mLinkLength;
  for (int i = 1; i&lt;= 3; i++) {
    r.rotate( M_PI * (i/3.f) );
    Particle *particle1 = newParticle( particle-&gt;position+r, 7.f,7.f, drag );
    mParticleSystem.addParticle( particle1 );
    mLinks.push_back(make_pair(mParticleSystem.particles[0], particle1));

    Vec2f r2 = (particle1-&gt;position-particle-&gt;position);
    r2.normalize();
    r2 *= mLinkLength;
    for (int ii = 1; ii &lt;= 3; ii++) {
      r2.rotate( M_PI * (ii/3.f) );
      Particle *particle2 = newParticle( particle1-&gt;position+r2, 5.f, 5.f, drag );
      mParticleSystem.addParticle( particle2 );
      mLinks.push_back(make_pair(particle1, particle2));

      Vec2f r3 = (particle2-&gt;position-particle1-&gt;position);
      r3.normalize();
      r3 *= mLinkLength;
      for (int iii = 1; iii &lt;= 3; iii++) {
r3.rotate( M_PI * (iii/3.f) );
Particle *particle3 = newParticle( particle2-&gt;position+r3, 3.f, 3.f, drag );
mParticleSystem.addParticle( particle3 );
mLinks.push_back(make_pair(particle2, particle3));
            }
        }
    }
}</pre></div></li><li class="listitem">Implement interaction with the mouse.<div><pre class="programlisting">void MainApp::mouseDown(MouseEvent event){
  mIsHandle = false;

  float maxDist = 20.f;
  float minDist = maxDist;
  for( std::vector&lt;Particle*&gt;::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ){
  float dist = (*it)-&gt;position.distance( event.getPos() );
  if(dist&lt;maxDist&amp;&amp;dist&lt;minDist) {
  mHandle = (*it);
  mIsHandle = true;
  minDist = dist;
        }
    }
}

void MainApp::mouseUp(MouseEvent event){
mIsHandle = false;
}</pre></div></li><li class="listitem">Inside the <code class="literal">update</code> method, <a id="id463" class="indexterm"/>calculate all forces affecting particles.<div><pre class="programlisting">void MainApp::update() {
  for( std::vector&lt;Particle*&gt;::iterator it1 = mParticleSystem.particles.begin(); it1 != mParticleSystem.particles.end(); ++it1 )
    {
    for( std::vector&lt;Particle*&gt;::iterator it2 = mParticleSystem.particles.begin(); it2 != mParticleSystem.particles.end(); ++it2 ){
      Vec2f conVec = (*it2)-&gt;position - (*it1)-&gt;position;
      if(conVec.length() &lt;0.1f)continue;

        float distance = conVec.length();
        conVec.normalize();
        float force = (mLinkLength*2.0f - distance)* -0.1f;
        force = math&lt;float&gt;::min(0.f, force);

            (*it1)-&gt;forces +=  conVec * force*0.5f;
            (*it2)-&gt;forces += -conVec * force*0.5f;
        }
    }

for( vector&lt;pair&lt;Particle*, Particle*&gt; &gt; ::iterator it = mLinks.begin(); it != mLinks.end(); ++it ){
  Vec2f conVec = it-&gt;second-&gt;position - it-&gt;first-&gt;position;
  float distance = conVec.length();
  float diff = (distance-mLinkLength)/distance;
  it-&gt;first-&gt;forces += conVec * 0.5f*diff;
  it-&gt;second-&gt;forces -= conVec * 0.5f*diff;
      }

  if(mIsHandle) {
    mHandle-&gt;position = getMousePos();
    mHandle-&gt;forces = Vec2f::zero();
    }

  mParticleSystem.update();
}</pre></div></li><li class="listitem">In the <code class="literal">draw</code> method implement <a id="id464" class="indexterm"/>drawing particles and links between them.<div><pre class="programlisting">void MainApp::draw()
{
  gl::enableAlphaBlending();
  gl::clear( Color::white() );
  gl::setViewport(getWindowBounds());
  gl::setMatricesWindow( getWindowWidth(), getWindowHeight() );

  gl::color( ColorA(0.f,0.f,0.f, 0.8f) );
  for( vector&lt;pair&lt;Particle*, Particle*&gt; &gt; ::iterator it = mLinks.begin(); it != mLinks.end(); ++it )
    {
    Vec2f conVec = it-&gt;second-&gt;position - it-&gt;first-&gt;position;
    conVec.normalize();
    gl::drawLine(it-&gt;first-&gt;position + conVec * ( it-&gt;first-&gt;radius+2.f ),
    it-&gt;second-&gt;position - conVec * ( it-&gt;second-&gt;radius+2.f ) );
    }

  gl::color( ci::ColorA(0.f,0.f,0.f, 0.8f) );
  mParticleSystem.draw();
} </pre></div></li><li class="listitem">Inside the <code class="literal">Particle.cpp</code> source file, drawing of each particle should be implemented, as follows:<div><pre class="programlisting">void Particle::draw(){
  ci::gl::drawSolidCircle( position, radius);
  ci::gl::drawStrokedCircle( position, radius+2.f);
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec205"/>How it works…</h2></div></div></div><p>In step 2, in the<a id="id465" class="indexterm"/> <code class="literal">setup</code> method, <a id="id466" class="indexterm"/>we are creating our particles for each level of the graph and adding links between them. In the <code class="literal">update</code> method in step 4, we are calculating forces affecting all particles, which is repelling each particle from each other, and forces coming from the springs connecting the nodes. While repelling spreading particles, springs try to keep them at a fixed distance defined in <code class="literal">mLinkLength</code>.</p><div><img src="img/8703OS_07_07.jpg" alt="How it works…"/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec206"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a id="id467" class="indexterm"/><strong>The Wikipedia article on Force-directed graph drawing</strong>: <a class="ulink" href="http://en.wikipedia.org/wiki/Force-based_algorithms_(graph_drawing)">http://en.wikipedia.org/wiki/Force-based_algorithms_(graph_drawing)</a></li></ul></div></div></div></body></html>